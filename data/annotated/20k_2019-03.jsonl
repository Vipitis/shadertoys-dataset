{"id": "3d23Rc", "name": "penrose flower", "author": "spleenooname", "description": "(1st shader on shadertoy. advance thanks for any advice!!)\n\na code rumination after Escher's exhibition.", "tags": ["triangle", "flower", "escher", "red", "penrose", "black", "cineshader"], "likes": 9, "viewed": 8932, "published": "Public API", "date": "1551653590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define luma( rgba ) ( dot( rgba, vec4(0.2126, 0.7152, 0.0722, 1.0) ) )\n\n#define R iResolution\n#define t iTime\n\nvoid mainImage( out vec4 O, in vec2 XY ) {\n    \n    // get normalized texture coordinates\n    vec2 p = (XY * 2. - R.xy ) /R.y;\n    \n    float a = -.5 + max( abs(p.x) + p.y, -p.y);\n    //float a = 0.15 + min( 1.0 * abs(p.x) + p.y * 0.75, -p.y); //like this variation:\n   \n    p = vec2( a, atan(p.x, p.y) );\n    \n    float c = 25. * log(t) * sin(t * .25 ) / t;\n    \n    vec4 s = .25 * cos( vec4(c, 1., 2., 0.) + t - p.y );\n    \n    vec4 e = s.yzxy;\n       \n    vec4 f = min(p.x - s, e - p.x); \n    \n    vec4 col = dot( clamp( f * 100., 0., 1.), 20. * (s - e) ) * (e -.1) ;\n    \n    // output color with luma subtract\n    O = vec4(1.0, 0.0, 0.0, 1.0) - luma(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d23Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 155, 202, 775]], "test": "valid"}
{"id": "3d2SRD", "name": "Rainbow Crocs", "author": "bignobody", "description": "Second Gyroid raymarch experiment. Closed up the gyroid a little more, tinted the colours and punched some holes.", "tags": ["raymarch", "gyroid"], "likes": 8, "viewed": 223, "published": "Public", "date": "1553101687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define EPSILON 0.02\n#define MAX_DIST 500.0\n\nfloat gyroidSDF(vec3 p , float s)\n{\n//\tfloat g = cos(p.x) * sin(p.y) + cos(p.y) * sin(p.z) + cos(p.z) * sin(p.x);\n    float g = dot(cos(p),sin(p.yzx));\t// shorthand suggested by Shane\n    return length(normalize(p) * g * s);\n\n}\n\nfloat sphereSDF(vec3 p, float r)\n{\n \treturn length(p)-r;   \n}\n\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sphereSDF(q, 0.11);\n}\n\nfloat sceneSDF(vec3 p)\n{\n\n    return opSub(opRep(p,vec3(0.33,0.33,0.33)), gyroidSDF(p, 0.314159 ));\n}\n\n\nfloat distToSurface( vec3 eye, vec3 dir, float startDist, float endDist )\n{\n\tfloat depth = startDist;\n\tfor (int i = 0; i < MAX_STEPS; i++) \n    {\n    \tfloat dist = sceneSDF(eye + depth * dir);\n    \tif (dist < EPSILON) \n        {\n        // We're inside the scene surface!\n        return depth;\n    \t}\n    \t// Move along the view ray\n    \tdepth += dist;\n\n    \tif (depth >= MAX_DIST) \n        {\n        \t// Gone too far; give up\n        \treturn endDist;\n    \t}\n    }\n    return endDist;\n}\n\nvec3 estimateNormal(vec3 p) \n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 0.45;\n    float ext = iTime * 0.6;\n    vec3 lookAt = vec3(cos(ext)*4.0,0.0,ext);\n    vec3 camOrigin = vec3(0.0,1.0,-10.0 + ext);\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n\n    float d = distToSurface(camOrigin,rayDirection, 0.0,MAX_DIST);\n\tvec3 g = estimateNormal(camOrigin + rayDirection * d);\n    d = d/length(g);\n  \tvec3 p = camOrigin + rayDirection * d;\n  \n   \t\n    if (d > MAX_DIST-EPSILON)\n    {\n     \t// no hit\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        return;\n    }\n\tvec3 bc = vec3(-0.1+g.y,-0.9+g.y,1.0-g.x);\n    vec3 col = vec3(clamp(d,0.0,0.99))*(bc+g);\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2SRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 101, 179, 293], [295, 295, 329, 329, 356], [359, 359, 396, 396, 418], [420, 420, 455, 455, 477], [479, 479, 516, 516, 537], [540, 540, 576, 576, 638], [640, 640, 664, 664, 741], [744, 744, 819, 819, 1230], [1232, 1232, 1262, 1262, 1572], [1575, 1575, 1632, 1673, 2730]], "test": "valid"}
{"id": "3d2SRh", "name": "almost polygon distance", "author": "abje", "description": "distance to a polygon. almost works.", "tags": ["distance", "polygon"], "likes": 5, "viewed": 409, "published": "Public API", "date": "1552934402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.0)\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n#define sides 10\n\nfloat plane(vec2 p, vec2 n, float l) {\n    return dot(p,n)-l;\n}\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n#define plot(p, s, t) len = min(len,abs(length(p)*aa-s)-t)\n\n#define size2(i) (0.2+hash(i))\n\nfloat size(int i) {\n    return mix(size2(float(i)+float(int(iTime*0.3+0.0))*PI),\n               size2(float(i)+float(int(iTime*0.3+1.0))*PI),\n               fract(iTime*0.3));\n}\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = 2.0;\n    vec2 uv = scale*(fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 muv = scale*(iMouse.xy*2.0-iResolution.xy)/iResolution.y;\n    float aa = iResolution.y/scale*0.4;\n\n    float len = -10000.0;\n    float len3 = 10000.0;\n\n    vec2 n = vec2(0,1);\n\n    for (int i = 0; i < sides; i++) {\n        n *= rot(PI/float(sides)*2.0);\n\n        float l = plane(uv,n,size(i));\n\n        len3 = min(len3,abs(l));\n        len = max(l,len);\n    }\n    len = abs(len3)*aa+clamp(1.0-abs(len)*aa,0.0,1.0);\n\n    if (iMouse.z > 0.0) {\n        float len1 = -1000.0;\n        float len2 = -1000.0;\n        n = vec2(0,1);\n        vec2 dir1;\n        vec2 dir2;\n        float s1;\n        float s2;\n\n        plot(muv-uv, 4.0/aa, 4.0);\n\n        for (int i = 0; i < sides; i++) {\n            n *= rot(PI/float(sides)*2.0);\n\n            float s = size(i);\n            float l = plane(muv,n,s);\n\n            if (l > 0.0)\n                plot((muv-l*n)-uv, 3.0, 0.0);\n\n            if (l > len2) {\n                if (l > len1) {\n                    len2 = len1;\n                    dir2 = dir1;\n                    s2 = s1;\n\n                    len1 = l;\n                    dir1 = n;\n                    s1 = s;\n                } else {\n                    len2 = l;\n                    dir2 = n;\n                    s2 = s;\n                }\n            }\n        }\n\n        if (len2 > 0.0) {\n            vec2 dir3 = vec2(dir1.y,-dir1.x);\n            vec2 dir4 = vec2(dir2.y,-dir2.x);\n\n            vec2 p = muv-len1*dir1;\n\n            float l = max(plane(p,dir2,s2),0.0);\n\n            plot(p-l*dir3/dot(dir3,dir2)-uv, 9.0, 1.0);\n            plot(p-uv, 7.0, 0.0);\n            plot(muv-len2*dir2-uv, 5.0, 0.0);\n        } else {\n            plot(muv-len1*dir1-uv, 9.0, 1.0);\n        }\n    }\n\n    float len1 = -1000.0;\n    float len2 = -1000.0;\n    n = vec2(0,1);\n    vec2 dir1;\n    vec2 dir2;\n    float s1;\n    float s2;\n\n    for (int i = 0; i < sides; i++) {\n        n *= rot(PI/float(sides)*2.0);\n\n        float s = size(i);\n        float l = plane(uv,n,s);\n\n        if (l > len2) {\n            if (l > len1) {\n                len2 = len1;\n                dir2 = dir1;\n                s2 = s1;\n\n                len1 = l;\n                dir1 = n;\n                s1 = s;\n            } else {\n                len2 = l;\n                dir2 = n;\n                s2 = s;\n            }\n        }\n    }\n\n    float len4;\n\n    if (len2 > 0.0) {\n        vec2 dir3 = vec2(dir1.y,-dir1.x);\n        vec2 dir4 = vec2(dir2.y,-dir2.x);\n\n        vec2 p = uv-len1*dir1;\n\n        float l = max(plane(p,dir2,s2),0.0);\n\n        p += dir3*l/dot(dir3,dir2);\n\n        len4 = length(p-uv);\n    } else {\n        len4 = len1;\n    }\n\n\n    vec3 col = vec3(1.0) - sign(len4)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-2.0*abs(len4));\n    col *= 0.8 + 0.2*cos(120.0*abs(len4));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(len4+0.02)) );\n\n    col *= min(len,1.0);\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2SRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 128, 128, 153], [155, 155, 178, 178, 217], [311, 311, 330, 330, 488], [494, 494, 551, 601, 3605]], "test": "valid"}
{"id": "3d2Szm", "name": "Recursive Lotus", "author": "dracusa", "description": "Shadertoy version of a shader I made to demonstrate the log-spherical mapping for this article: \n\nhttps://www.osar.fr/notes/logspherical/\n\nThe log-spherical mapping allows the creation of self-similar SDFs, without loops.", "tags": ["raymarching", "sdf", "flower", "recursive", "zoomer", "loopless", "selfsimilar", "logspherical"], "likes": 43, "viewed": 998, "published": "Public API", "date": "1553271908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nSelf-similar flower based on the log-spherical mapping.\nAccompanying blog post: https://www.osar.fr/notes/logspherical/\n*/\n\n#define AA 2\n#define M_PI 3.1415926535897932384626433832795\n\nfloat density;\nfloat height;\nfloat fov;\nfloat camera_y;\nfloat gTime;\nfloat vcut;\nfloat lpscale;\n\nfloat camera_ty = -0.17;\nfloat interpos = -0.5;\nfloat shorten = 1.;\nfloat line_width = 0.017;\nfloat rot_XY = 0.;\nfloat rot_YZ = 0.785;\nfloat radius = 0.05;\nfloat rho_offset = 0.;\n\n// Modified from http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( vec3 p, vec2 c )\n{\n\t// c must be normalized\n\tfloat q = length(p.xz);\n\treturn dot(c,vec2(q,p.y));\n}\n\n// Axis rotation taken from tdhooper. R(p.xz, a) rotates \"x towards z\".\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`: point in log-spherical space without offset or tiling\n- out `tp`: point in tiled log-spherical space\n- out `rp`: point in rotated tiled log-spherical space\n- out `mul`: total amount of scaling applied at this point\n*/\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul)\n{\n\t// Apply the forward log-spherical map\n\tfloat r = length(p);\n\tp = vec3(log(r), acos(p.y / length(p)), atan(p.z, p.x));\n\n\t// Get a scaling factor to compensate for pinching at the poles\n\t// (there's probably a better way of doing this)\n\tfloat xshrink = 1.0/(abs(p.y-M_PI)) + 1.0/(abs(p.y)) - 1.0/M_PI;\n\tp.y += height;\n\tp.z += p.x * 0.3;\n\tmul = r/lpscale/xshrink;\n\tp *= lpscale;\n\tsp = p;\n\n\t// Apply rho-translation, which yields zooming\n\tp.x -= rho_offset + gTime;\n\t\n\t// Turn tiled coordinates into single-tile coordinates\n\tp = fract(p*0.5) * 2.0 - 1.0;\n\tp.x *= xshrink;\n\ttp = p;\n\tpR(p.xy, rot_XY);\n\tpR(p.yz, rot_YZ);\n\trp = p;\n}\n\nfloat sdf(in vec3 p)\n{\n\tvec3 sp, tp, rp;\n\tfloat mul;\n\ttile(p, sp, tp, rp, mul);\n\t\n\t// surface\n\tfloat spheres = abs(rp.x) - 0.012;\n\tfloat leaves = max(spheres, max(-rp.y, rp.z));\n\tleaves = max(leaves, vcut-sp.y);\n\tspheres = max(spheres, vcut-sp.y+1.07);\n\tfloat ret = min(leaves, spheres);\n\n\t// intercals\n\tvec3 pi = rp;\n\tpi.x += interpos;\n\tfloat interS = abs(pi.x) - 0.02;\n\tfloat interL = max(interS, max(-rp.y, rp.z));\n\tinterL = max(interL, vcut-sp.y+2.);\n\tinterS = max(interS, vcut-sp.y+3.);\n\tret = min(ret, min(interL, interS));\n\n\t// outline\n\tfloat ol = abs(rp.y) - radius*0.8;\n\tol = min(ol, abs(rp.z) - radius*0.8);\n\t// cut out\n\tret = max(ret, -ol);\n\n\treturn ret * mul / shorten;\n}\n\nvec3 colr(in vec3 p)\n{\n\tvec3 sp, tp, rp, ret;\n\tfloat mul;\n\ttile(p, sp, tp, rp, mul);\n\n\t// 2d outline\n\tfloat ol = abs(rp.y) - radius;\n\tol = min(ol, abs(rp.z) - radius);\n\n\t// intercals\n\tvec3 pi = rp;\n\tpi.x += interpos;\n\tfloat inter = abs(pi.x) - 0.02;\n\tinter = max(inter, vcut-sp.y+2.);\n\n\tfloat dark = smoothstep(density*0.25, density*0.5, density - sp.y);\n\tdark *= dark;\n\t\n\tif (ol < line_width)\n\t\tret = vec3 (0.6, 0.6, 0.8)*dark;\n\telse if (inter < 0.02)\n\t\tret = vec3 (0.1, 0.35, 0.05)*dark;\n\telse\n\t\tret = vec3 (0.1, 0.15, 0.25)*dark;\n\treturn ret;\n}\n\n// Adapted from http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(in vec3 pos)\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773;\n\tconst float eps = 0.0005;\n\treturn normalize(\n\t\te.xyy*sdf(pos + e.xyy*eps) + \n\t\te.yyx*sdf(pos + e.yyx*eps) + \n\t\te.yxy*sdf(pos + e.yxy*eps) + \n\t\te.xxx*sdf(pos + e.xxx*eps)\n\t);\n}\n\n// From http://www.iquilezles.org/www/articles/functions/functions.htm\nfloat gain(float x, float k) \n{\n\tfloat a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n\treturn (x<0.5)?a:1.0-a;\n}\n\nvec3 gain(vec3 v, float k)\n{\n\treturn vec3(gain(v.x, k), gain(v.y, k), gain(v.z, k));\n}\n\nfloat osc(float v1, float v2)\n{\n\treturn (sin(iTime*0.25)*0.5+0.5)*(v2-v1)+v1;\n}\n\n// Based on http://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 iUV = fragCoord/iResolution.xy;\n\n\tgTime = iTime + osc(0., 4.);\n\tdensity = 26.;\n\theight = osc(0., 0.41);\n\tfov = osc(1.5, 1.07);\n\tcamera_y = osc(0.4, 1.07);\n\n\t\n\tvcut = floor(density*0.25)*2.+0.9;\n\tlpscale = floor(density)/M_PI;\n    \n\n\t // camera movement\t\n\tfloat an = 0.002*gTime + 7.0;\n\tvec3 ro = vec3(1.0*cos(an), camera_y, 1.0*sin(an));\n\tvec3 ta = vec3( 0.0, camera_ty, 0.0 );\n\t// camera matrix\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\n\tvec3 bg = vec3(0.06, 0.08, 0.11)*0.3;\n\tbg *= 1.-smoothstep(0.1, 2., length(iUV*2.-1.));\n\tvec3 tot = bg;\n\t\n\t#if AA>1\n\tfor(int m=0; m<AA; m++)\n\tfor(int n=0; n<AA; n++)\n\t{\n\t\t// pixel coordinates\n\t\tvec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n\t\tvec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\t#else    \n\t\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\t#endif\n\n\t\t// create view ray\n\t\tvec3 rd = normalize(p.x*uu + p.y*vv + fov*ww);\n\n\t\t// raymarch\n\t\tconst float tmax = 3.5;\n\t\tfloat t = 0.0;\n\t\tvec3 pos;\n\t\tint iout;\n\t\tfor( int i=0; i<64; i++ )\n\t\t{\n\t\t\tpos = ro + t*rd;\n\t\t\tfloat h = sdf(pos);\n\t\t\tif( h<0.0001 || t>tmax ) break;\n\t\t\tt += h;\n\t\t\tiout = i;\n\t\t}\n\t\tfloat fSteps = float(iout) / 64.;\n\t\n\t\t// shading/lighting\t\n\t\tvec3 col = vec3(0.0);\n\t\tif( t<tmax )\n\t\t{\n\t\t\tvec3 nor = calcNormal(pos);\n\t\t\tfloat dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n\t\t\tfloat amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n\t\t\tcol = colr(pos)*amb + colr(pos)*dif;\n\t\t}\n\n\t\t// glow\n\t\tfloat gloamt = smoothstep(0.04, 0.5, length(pos));\n\t\tfloat gain_pre = 1. - gloamt*0.6;\n\t\tfloat gain_k = 1.5 + gloamt*2.5;\n\t\tcol += gain(fSteps*vec3(0.7, 0.8, 0.9)*gain_pre, gain_k);\n\n\t\t// fog\n\t\tcol = mix(col, bg, smoothstep(0.2+camera_y, 1.6+camera_y, t));\n\n\t\t// gamma        \n\t\tcol = sqrt( col );\n\t\ttot += col;\n\t#if AA>1\n\t}\n\ttot /= float(AA*AA);\n\t#endif\n\n\tfragColor = vec4(tot, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2Szm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 553, 585, 610, 665], [667, 739, 771, 771, 813], [815, 1107, 1183, 1223, 1811], [1813, 1813, 1835, 1835, 2496], [2498, 2498, 2520, 2520, 3045], [3047, 3124, 3154, 3154, 3364], [3366, 3437, 3468, 3468, 3541], [3543, 3543, 3571, 3571, 3629], [3631, 3631, 3662, 3662, 3710], [3712, 3791, 3848, 3898, 5795]], "test": "valid"}
{"id": "3d2XWm", "name": "Sparkles and lines", "author": "gena", "description": "Some points and lines, from the tutorial: https://www.youtube.com/watch?v=3CycKKJiwis", "tags": ["lines", "audio", "points"], "likes": 18, "viewed": 942, "published": "Public API", "date": "1554054076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Credits: https://www.youtube.com/watch?v=KGJUl8Teipk\n// Original code: https://www.shadertoy.com/view/lscczl\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    \n    return length(pa - ba*t);\n}\n\nfloat N21(vec2 p) {\n\tp = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    \n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p) {\n\tfloat n = N21(p);\n    \n    return vec2(n, N21(p + n));\n}\n\nfloat speed = .4;\n\nvec2 GetPos(vec2 id, vec2 offs) {\n    vec2 n = N22(id + offs);\n    \n    return offs + sin(n * speed * iTime) * .4;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b) {\n\tfloat d = DistLine( p, a, b);\n    float m = S(.03, .01, d);\n    float d2 = length(a-b);\n    m *= S(1., .0, d2) * .5 + S(.05, .03, abs(d2 - .75));\n    \n    return m;\n}\n\nfloat Layer(vec2 uv) {\n    float m = .0;\n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);\n\n    vec2 p[9];\n    int i = 0;\n    for(float y=-1.; y<=1.; y++) {\n        for(float x=-1.; x<=1.; x++, i++) {\n            p[i] = GetPos(id, vec2(x, y));\n        }\n    }\n\n    for(int i=0; i<9; i++) {\n        m += Line(gv, p[4], p[i]);\n\n        vec2 j = (p[i] - gv) * 20.;\n        float sparkle = 1./dot(j, j);\n        m += sparkle * ( sin(speed * iTime + fract(p[i].x) * 10.) * .4 + .4);\n    }\n    m += Line(gv, p[1], p[3]);\n    m += Line(gv, p[1], p[5]);\n    m += Line(gv, p[5], p[7]);\n    m += Line(gv, p[7], p[3]);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec2 mouse = (iMouse.xy / iResolution.xy) - .5;\n    \n    float gradient = uv.y - 0.15;\n    \n    float m = 0.0;\n    float t = iTime * speed * .1;\n\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c); \n    uv *= rot;\n    mouse *= rot;\n\n    \n    for(float i=0.; i<= 1.; i+= 1./4.) {\n        float z = fract(i + t);\n        float size = mix(10., .5, z);\n        float fade = S(0., .5, z) * S(1.2, .8, z);\n        m += Layer(uv * size + i * 20. - mouse) * fade;\n    }\n    \n    float fft = texelFetch(iChannel0, ivec2(0.7, 0), 0).x;\n    \n    vec3 base = sin((t * t + 100.) * vec3(.345, .456, .657)) * .4 + .6;\n\n    vec3 col = base * m;\n\n    gradient *= fft;\n    \n    col -= gradient * base;\n       \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "ltSGW3", "previewfilepath": "https://soundcloud.com/g-k-e-islam/yann-tiersen-amelie-soundtrack-piano-version", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/g-k-e-islam/yann-tiersen-amelie-soundtrack-piano-version", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2XWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 153, 193, 193, 328], [330, 330, 349, 349, 451], [453, 453, 471, 471, 529], [550, 550, 583, 583, 666], [668, 668, 704, 704, 872], [874, 874, 896, 896, 1507], [1509, 1509, 1566, 1566, 2384]], "test": "error"}
{"id": "3d2XzR", "name": "Enso or Arrival", "author": "willstall", "description": "A play on Enso, let’s be a little uninhibited and free for just a moment", "tags": ["sdf", "circle", "loop", "enso"], "likes": 16, "viewed": 608, "published": "Public API", "date": "1552696408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\n#define SECONDS 6.0\n#define COUNT 32\n\nvec2 random2(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(29.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat random(vec2 st)\n{\n    return fract(sin(dot(st.yx,vec2(14.7891,43.123)))*312991.41235);\n}\n\nfloat random (in float x)\n{\n    return fract(sin(x)*43758.5453123);\n}\n\n// iq\nfloat v_noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate(float angle)\n{\n    return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );\n}\n\nvec2 ratio(vec2 st)\n{\n    return  vec2(\n            max(st.x/st.y,1.0),\n            max(st.y/st.x,1.0)\n            );\n}\n\nvec2 center(vec2 st)\n{\n    float aspect = iResolution.x/iResolution.y;\n    st.x = st.x * aspect - aspect * 0.5 + 0.5;\n    return st;\n}\n\nvec3 time()\n{\n    float period = mod(iTime,SECONDS);\n    vec3 t = vec3(fract(iTime/SECONDS),period, 1.0-fract(period));\n    return t;       // return fract(length),period,period phase\n}\n\nfloat scene(vec2 st, vec3 t)\n{\n    st = st * 2.0 - 1.0;\n\n    float seed = 29192.173;\n    float center = length(st-0.5) - 0.5;\n\n    float n_scale = 0.12;\n\n    float n_1 = v_noise(st + sin(PI*t.x)) * n_scale;\n    float n_2 = v_noise(st+seed - sin(PI*t.x)) * n_scale;\n\n    float d = 1.0;\n    for(int i = 1; i <= COUNT; i++)\n    {\n        float spread = 1.0 / float(i);\n        float speed = ceil(3.0*spread);\n        float r = random(float(i)*5.0 + seed);\n        float r_scalar = r * 2.0 - 1.0;\n\n        vec2 pos = st - vec2(0.0);\n            pos += vec2(0.01) * rotate(TWO_PI * r_scalar + TWO_PI * t.x * speed * sign(r_scalar));\n            pos *= rotate(TWO_PI * r_scalar + TWO_PI * t.x * speed * sign(r_scalar) + v_noise(pos + float(i) + iTime) );\n            pos += mix(n_1,n_2,0.5+0.5*sin(TWO_PI*t.x*speed));\n\n        float s = .45 + .126 * r;\n\n        float a = atan(pos.y,pos.x)/PI;\n            a = abs(a);\n            a = smoothstep(0.0,1.0,a);\n\n        float c = length(pos);\n            c = abs(c-s);\n            c -= 0.0004 + .0125 * a;\n\n        d = min(d,c);\n    }\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // timing\n    vec3 t = time();\n\n    // space\n    vec2 st = fragCoord/iResolution.xy;\n    st = center( st );\n\n    st = st * 2.0 - 1.0;\n    st = st * (1.0 + .03 * sin(TWO_PI*t.x));\n    st = st * 0.5 + 0.5;\n\n    // scene\n    float s = scene(st, t);\n\n    // aa\n    float pixelSmoothing = 2.0;\n    float aa = ratio(iResolution.xy).x/iResolution.x*pixelSmoothing;\n    \n    // color\n    vec3 color = vec3(0.08);\n        color = mix(color,vec3(1.0),1.0-smoothstep(-aa,aa,s));\n        color = 1.0 - color;\n\n    // vignette\n    float size = length(st-.5)-1.33;\n    float vignette = (size) * 0.75 + random(st) *.08;        \n    color = mix(color,vec3(0.0, 0.0, 0.0),vignette+.5);\n\t\n    float d = v_noise(st*7.0+iTime*0.25);\n    \n    fragColor = vec4(color,mix(.25,.25+.75*d,1.0-smoothstep(-aa,aa,s)));\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Enso or Arrival\",\n\t\"description\": \"A play on Enso, let’s be a little uninhibited and free for just a moment\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2XzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 144, 144, 282], [284, 284, 307, 307, 378], [380, 380, 407, 407, 449], [451, 457, 481, 481, 885], [887, 887, 913, 913, 980], [982, 982, 1003, 1003, 1101], [1103, 1103, 1125, 1125, 1237], [1239, 1239, 1252, 1252, 1424], [1426, 1426, 1456, 1456, 2517], [2519, 2519, 2576, 2590, 3373]], "test": "valid"}
{"id": "3dBSDD", "name": "Grow object", "author": "edo_m18", "description": "Grow object test.", "tags": ["raymarching", "grow"], "likes": 0, "viewed": 88, "published": "Public", "date": "1553754720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 2\n\nconst vec3 light = normalize(vec3(0.77));\nconst vec3 amblight = vec3(0.05);\n\nstruct Surface\n{\n    float dist;\n    vec3 color;\n    bool isGrow;\n};\n    \nSurface near(Surface a, Surface b)\n{\n    if (a.dist < b.dist)\n    {\n        return a;\n    }\n    else\n    {\n        return b;\n    }\n}\n\nfloat dist_sphere(in vec3 p, in vec3 offset)\n{\n    return length(p - offset) - 1.0;\n}\n\nfloat dist_box(in vec3 p, in vec3 offset, in vec3 b)\n{\n    vec3 d = abs(p - offset) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat dist_plane(in vec3 p)\n{\n    const vec4 n = vec4(0, 1.0, 0, 1.0);\n    return dot(n.xyz, p) + n.w;\n}\n\nconst Surface NO_HIT = Surface(1e+30, vec3(0.0), false);\n\nSurface emitSurface = NO_HIT;\n\nSurface dist_func(in vec3 p)\n{\n    // Grow object\n    // float d1 = dist_sphere(p, vec3(0, 3.5, 0));\n    float d1 = dist_box(p, vec3(0, 2.5, 0), vec3(0.5));\n    Surface grow = Surface(d1, vec3(1.0, 0.0, 0.0), true);\n    \n    emitSurface = near(grow, emitSurface);\n        \n    float d2 = dist_plane(p);\n    Surface plane = Surface(d2, vec3(0.2), false);\n    \n    vec3 q = p;\n    q.xz = mod(q.xz, vec2(8.0, 4.0)) - vec2(4.0, 2.0);\n    float d3 = dist_sphere(q, vec3(0.0));\n    Surface sphere1 = Surface(d3, vec3(0.8), false);\n    \n    return near(near(grow, plane), sphere1);\n}\n\nvec3 getNormal(in vec3 p)\n{\n    const vec2 d = vec2(0.01, 0.0);\n    return normalize(vec3(dist_func(p + d.xyy).dist - dist_func(p - d.xyy).dist,\n                          dist_func(p + d.yxy).dist - dist_func(p - d.yxy).dist,\n                          dist_func(p + d.yyx).dist - dist_func(p - d.yyx).dist));\n}\n\nmat3 camera(in vec3 ro, in vec3 ta)\n{\n    const vec3 up = vec3(0, 1.0, 0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 render(vec3 ray, vec3 p)\n{\n    Surface surf;\n    \n    for (int i = 0; i < 100; i++)\n    {\n        surf = dist_func(p);\n        \n        if (surf.dist < 0.001)\n        {\n            break;\n        }\n        \n        p += ray * surf.dist;\n\t}\n    \n    vec3 col = vec3(0.0);\n    \n    if (surf.dist < 0.001)\n    {\n        col = surf.color;\n        \n        if (!surf.isGrow)\n        {\n            vec3 n = getNormal(p);\n            float diff = dot(n, light);\n            col *= diff;\n        }\n    }\n    else\n    {\n        col = mix(vec3(0.03, 0.06, 0.05), vec3(0.05, 0.1, 0.2), ray.y);\n    }\n    \n    float k = 1.5;\n    vec3 emit = pow(emitSurface.dist + 2.0, -k) * emitSurface.color;\n    col += emit + amblight;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float camDist = 8.0;\n    float sp = iTime * 0.5;\n    float x = sin(sp) * camDist;\n    float y = sin(sp) + 3.0;\n    float z = cos(sp) * camDist;\n    \n    vec3 ro = vec3(x, y, z);\n    vec3 ta = vec3(0, 1.0, 0);\n    \n    mat3 c = camera(ro, ta);\n\n    vec3 tot = vec3(0.0);\n    \n    for (int m = 0; m < AA; m++)\n    {\n        for (int n = 0; n < AA; n++)\n        {\n            vec2 o = vec2(float(m), float(n)) / float(AA);\n            vec2 uv = ((fragCoord + o) * 2.0 - iResolution.xy) / iResolution.y;\n    \t\tvec3 ray = c * normalize(vec3(uv, 1.25));\n    \t\tvec3 p = ro;\n        \n            vec3 col = render(ray, p);\n            tot += col;\n        }\n    }\n    \n    tot /= float(AA * AA);\n    \n    // gamma\n    tot = pow(tot, vec3(0.4545));\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 1.0 - uv.yx;\n    float vig = uv.x * uv.y * 30.0;\n    vig = pow(vig, 0.1);\n    \n    fragColor = vec4(tot * vig, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 201, 201, 297], [299, 299, 345, 345, 384], [386, 386, 440, 440, 544], [546, 546, 575, 575, 650], [741, 741, 771, 841, 1317], [1319, 1319, 1346, 1346, 1629], [1631, 1631, 1668, 1668, 1850], [1852, 1852, 1883, 1883, 2589], [2591, 2591, 2648, 2648, 3570]], "test": "error"}
{"id": "3dBSDR", "name": "test: fbm", "author": "takumifukasawa", "description": "ref.\nhttps://thebookofshaders.com/13/?lan=jp\nhttp://www.iquilezles.org/www/articles/warp/warp.htm\n", "tags": ["fbm"], "likes": 5, "viewed": 140, "published": "Public", "date": "1553329935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// ref.\n// https://thebookofshaders.com/13/?lan=jp\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n\n#define OCTAVES 6\n\n// Get random value\nfloat random(in vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(in vec2 st) {\n  float value = 0.;\n  float amp = .5;\n  float freq = 0.;\n\n  for(int i = 0; i < OCTAVES; i++) {\n    value += amp * noise(st);\n    st *= 2.1;\n    amp *= .4;\n  }\n  return value;\n}\n\nfloat pattern(in vec2 p) {\n  float f = 0.;\n  vec2 q = vec2(\n    fbm(p + iTime * .2 + vec2(0.)),\n    fbm(p + iTime * .30 + vec2(2.4, 4.8))\n  );\n  vec2 r = vec2(\n    fbm(q + iTime * .3 + 4. * q + vec2(3., 9.)),\n    fbm(q + iTime * .2 + 8. * q + vec2(2.4, 8.4))\n  );\n  f = fbm(p + r * 2. + iTime * .09);\n  return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // fix aspect uv\n  vec2 uv = (fragCoord.xy - .5 * iResolution.xy);\n  uv = 2. * uv.xy / iResolution.y;\n\n  vec3 color = vec3(0.);\n  color += pattern(uv);\n\n  fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 148, 174, 174, 250], [252, 252, 278, 278, 658], [660, 660, 683, 683, 860], [862, 862, 888, 888, 1176], [1178, 1178, 1235, 1254, 1423]], "test": "valid"}
{"id": "3dfSD2", "name": "Merry Ray Marching!", "author": "ooptyp", "description": "And Happy Soft Shadows! \n\nPress buttons to watch bonus effects.\n\nMy Task1 in mashgraph course.\nArtur B., 316", "tags": ["raymarching", "fractal", "shadows"], "likes": 1, "viewed": 337, "published": "Public API", "date": "1552249590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 300;\nconst int SHADOW_STEPS = 128;\nconst float MAX_MARCH_DIST = 120.0;\nconst float EPS = 0.0001;\nconst float SHININESS = 10.0;\n\nconst float KEY_F  = 70.5/256.0;\nconst float KEY_T  = 84.5/256.0;\n\n//---------------------------------------------------------------------------------\n/*\n\nEffects:\n\nPress F to watch fractal \"star\"\nPress T to change shadow type (sharp / soft)\n\n*/\n//---------------------------------------------------------------------------------\n\nstruct Figure \n{\n    float dist;\n    vec3 color;\n};\n\nstruct Light\n{\n    vec3 pos;\n    vec3 power;\n};\n\n\nFigure Unite(Figure f1, Figure f2)\n{\n    if (f1.dist < f2.dist) return f1;\n        else return f2;\n}\n\nFigure Carve(Figure f1, Figure f2)\n{\n    if (f1.dist > -f2.dist) return f1;\n    else {\n        f2.dist *= -1.;\n        return f2;\n    }\n}\n\nFigure Plane(vec3 p)\n{\n    Figure f;\n    vec4 n = vec4(0.0, 1.0, 0.0, 1.5);\n    f.dist = dot(p,n.xyz) + n.w;\n    f.color = vec3(0.4, 0.6, 1.0);\n    return f;\n}\n\nFigure Sphere1(vec3 p)\n{\n    Figure f;\n    p += vec3(-25.0, 0.0, -11.0);\n    f.dist = length(p) - 4.0;\n    f.color = vec3(0.4, 0.8, 1.0);\n    return f;\n}\n\nFigure Sphere2(vec3 p)\n{\n    Figure f;\n    p += vec3(-25.0, -5.75, -11.0);\n    f.dist = length(p) - 3.0;\n    f.color = vec3(0.4, 0.8, 1.0);\n    return f;\n}\n\nFigure Sphere3(vec3 p)\n{\n    Figure f;\n    p += vec3(-25.0, -9.5, -11.0);\n    f.dist = length(p) - 2.0;\n    f.color = vec3(0.4, 0.8, 1.0);\n    return f;\n}\n\nFigure Eyes(vec3 p)\n{\n    Figure f;\n    vec3 c1 = vec3(23.0, 10, 12.5);\n    vec3 c2 = vec3(25.0, 10, 13.0);\n    float d1 = length(p - c1) - 0.5;\n    float d2 = length(p - c2) - 0.5;\n    f.dist = min(d1, d2);\n    f.color = vec3(0.0);\n    return f;\n}\n\nFigure Box1(vec3 p)\n{\n    Figure f;\n    p += vec3(15.0, -5.0, -16.0);\n    vec3 d = abs(p) - vec3(4.0, 3.0, 2.0);\n    f.dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    f.color = vec3(1.0, 0.0, 1.0);\n    return f;\n}\n\nFigure Box2(vec3 p)\n{\n    Figure f;\n    p += vec3(15.0, -5.0, -16.0);\n    vec3 d = abs(p) - vec3(4.5, 3.5, 0.5);\n    f.dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    f.color = vec3(1.0, 1.0, 0.0);\n    return f;\n}\n\nFigure Box3(vec3 p)\n{\n    Figure f;\n    p += vec3(15.0, -5.0, -16.0);\n    vec3 d = abs(p) - vec3(0.5, 3.5, 2.5);\n    f.dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    f.color = vec3(1.0, 1.0, 0.0);\n    return f;\n}\n\nFigure Stick(vec3 p)\n{\n    Figure f;\n    vec3 a = vec3(15.0, -3.0, 0.0);\n    vec3 b = vec3(15.0, 13.0, 0.0);\n    float r = 1.5;\n    \n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    f.dist = length( pa - ba*h ) - r;\n    if (mod(p.y, 2.) < 1.0) f.color = vec3(1.0, 0.0, 0.0);\n        else f.color = vec3(1.0, 0.8, 0.8);\n    return f;\n}\n\nFigure halfTorus(vec3 p)\n{\n    Figure f;\n    p -= vec3(12.0, 13.0, 0.0);\n    if (p.y < -1.0) {\n        f.dist = MAX_MARCH_DIST;\n        return f;\n    }\n    vec2 t = vec2(3.0, 1.5);\n    vec2 q = vec2(length(p.xy)-t.x, p.z);\n    f.dist = length(q)-t.y;\n    if (mod(p.y, 2.) < 1.0) f.color = vec3(1.0, 0.0, 0.0);\n        else f.color = vec3(1.0, 0.8, 0.8);\n    return f;\n}\n\n// FRACTAL STAR\n// (The Mandelbulb fractal)\nFigure Star(vec3 p) {\n\tFigure f;\n    p -= vec3(-8.0, 14.0, 0.0);\n\n    vec3 point = p;\n    float dz = 1.0;   \n    for (int j=0; j<4; j++) {      \n        float r = length(point);\n        float o = acos(point.z/r);\n        float i = atan(point.y/point.x);\n        \n        dz = 8.0 * pow(r, 7.0) * dz + 1.0;\n        r = pow(r, 8.0);\n        o *= 8.0;\n        i *= 8.0;\n\n        point = vec3( r*sin(o)*cos(i), r*sin(o)*sin(i), r*cos(o)) + p;\n        if (dot(point,point) > 4.0) break;\n    }\n    float z = length(point);\n    f.dist = 0.5 *z*log(z)/dz;\n    f.color = vec3(1.0, 1.0, 0.0);\n\treturn f;\n}\n\n// COMPLEX FIGURES\nFigure Tree( vec3 p)\n{\n    Figure f;\n    p -= vec3(-8.0, 0.0, 0.0);\n    vec2 d1 = abs(vec2(length(p.xz),p.y)) - vec2(8.0, 4.0);\n    p -= vec3(0.0, 6.0, 0.0);\n    vec2 d2 = abs(vec2(length(p.xz),p.y)) - vec2(6.0, 3.0);\n    p -= vec3(0.0, 4.0, 0.0);\n    vec2 d3 = abs(vec2(length(p.xz),p.y)) - vec2(3.5, 2.5);\n\n    float dd1 = min(max(d1.x,d1.y),0.0) + length(max(d1,0.0));\n    float dd2 = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n    float dd3 = min(max(d3.x,d3.y),0.0) + length(max(d3,0.0));\n    f.dist = min(min(dd1, dd2), dd3);\n    f.color = vec3(0.0, 1.0, 0.2);\n    return f;\n}\n\nFigure Snowman(vec3 p)\n{\n    return\n        Unite(\n            Sphere1(p), Unite(\n                Sphere2(p), Unite(\n                    Sphere3(p), Eyes(p)\n                )\n            )\n        );\n}\n\nFigure Bench(vec3 p)\n{\n    Figure f, g;\n    p -= vec3(-30.0, 0.0, 10.0);\n    vec3 d = abs(p) - vec3(4.0, 6.0, 5.0);\n    f.dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    f.color = vec3(1.0, 0.5, 0.0);\n    p -= vec3(2.0, 4.0, 0.0);\n    g.dist = length(p) - 5.0;\n    return Carve(f, g);\n}\n\nFigure ChristmasTree(vec3 p)\n{\n    return Unite(Tree(p), Star(p));\n}\n\nFigure Gift(vec3 p)\n{\n    return Unite(Box1(p), Unite(Box2(p), Box3(p)));\n}\n\nFigure Candy(vec3 p)\n{\n    return Unite(Stick(p), halfTorus(p));\n}\n\n\nFigure Map(vec3 p)\n{\n    return\n        Unite(\n            Plane(p), Unite(\n                Snowman(p), Unite(\n                    ChristmasTree(p), Unite(\n                        Gift(p), Unite(\n                            Candy(p), Bench(p)\n                        )\n                    )\n                )\n            )\n        );          \n}\n// Map is built!\n\n// Ray Marching begins here\nFigure RayMarching(vec3 eye, vec3 dir)\n{\n    float depth = 0.0;\n    float end = MAX_MARCH_DIST;\n    Figure f;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        f = Map(eye + depth * dir);\n        if (f.dist < EPS) {\n            f.dist = depth;\n            return f;\n        }\n        depth += f.dist;\n        if (depth >= end) {\n            f.dist = end;\n            return f;\n        }\n    }\n    f.dist = end;\n    return f;\n}\n\nvec3 NormEstimate(vec3 p) {\n    vec3 dp;\n    dp.x = Map(p + vec3(EPS, 0.0, 0.0)).dist - Map(p - vec3(EPS, 0.0, 0.0)).dist;\n    dp.y = Map(p + vec3(0.0, EPS, 0.0)).dist - Map(p - vec3(0.0, EPS, 0.0)).dist;\n    dp.z = Map(p + vec3(0.0, 0.0, EPS)).dist - Map(p - vec3(0.0, 0.0, EPS)).dist;\n    return normalize(dp);\n}       \n\nvec3 LightEffect(vec3 p, vec3 eye, Light light, vec3 k_a, vec3 k_d, vec3 k_s) \n{\n    vec3 N = NormEstimate(p);\n    vec3 L = normalize(light.pos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float len = length(light.pos - p);\n    \n    if (dot(L, N) < 0.0) {\n        return vec3(0.0);\n    } \n    if (dot(R, V) < 0.0) {\n        return 400.* light.power * (k_d * dot(L, N)) /len/len  + k_a/len;\n    }\n    return  400.* light.power * \n            (k_d * dot(L, N) + k_s * pow(dot(V, R), SHININESS)) /len/len + k_a/len;\n}\n\nfloat shadowSharp(vec3 p, vec3 rd, float dist)\n{\n    float t = 0.1;\n    for (int i = 0; i < SHADOW_STEPS; ++i)\n    {\n        float h = Map(p + rd * t ).dist;\n        if (h < EPS)\n            return 0.0;\n        t += h;\n        if (t > dist)\n            break;\n    }\n    return 1.0;\n}\n\nfloat shadowSoft(vec3 p, vec3 rd, float dist, float k)\n{\n    float t = 0.1;\n    float res = 1.0;\n    for ( int i = 0; i < SHADOW_STEPS; ++i )\n    {\n        float h = Map(p + rd * t ).dist;\n        if (h < EPS)\n            return 0.0;\n        res = min( res, k * h / t );\n        t += h;\n        if (t > dist)\n            break;\n    }\n    return res;\n}\n\nvec3 shade(vec3 p, Light light, float shadepower, bool isSoftShadow)\n{\n    vec3 N = NormEstimate(p);\n    vec3 L = normalize(light.pos - p);\n    \n    float len = length(light.pos - p);\n    \n    float res = 0.1;\n    float type = shadowSoft(p, L, len, 8.0);\n\n    if (isSoftShadow == false) {\n        type = shadowSharp(p, L, len);\n    } \n    \n    if (type > 0.0) {\n        float behind = 1.0 * max( 0.0, dot(L, N));\n        float near = 1.0 - pow(min(1.0, len/shadepower), 2.0 );\n        res += behind * near * type;\n    }\n    return vec3(res);\n}\n\n\nvec3 Illumination(vec3 p, vec3 eye, vec3 k_a, vec3 k_d, vec3 k_s, bool isSoftShadow) \n{\n    vec3 color = vec3(0.0);\n    \n    Light light1, light2;\n    light1.pos = vec3(50.0, 70.0 + 20.0*cos(iTime), 10.0);\n    light1.power = vec3(12);\n    light2.pos = vec3(50.0 *sin(0.22*iTime), 15.0, 5.0 + 15.0 * cos(0.22*iTime));\n    light2.power = vec3(0.7);\n\n    color += vec3(0.5) * shade(p, light1, 100.0, isSoftShadow);\n    color += vec3(0.5) * shade(p, light2, 30.0, isSoftShadow);\n    color += LightEffect(p, eye, light1, k_a, k_d, k_s);\n    color += LightEffect(p, eye, light2, k_a, k_d, k_s);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 coord = fragCoord / iResolution.x - 0.5;\n\n    vec3 eye = vec3(0.0 + 10.*cos(0.3*t), 35.0, 75.0);\n    vec3 dir = normalize(vec3(coord.x, coord.y - 0.3, -1.0));\n    \n    if (texture(iChannel0, vec2(KEY_F, 0.75)).x > 0.) {\n        vec3 C = vec3(-8, 14.0, 0.0);\n        eye = vec3(-8.0, 15.0, -5.0);\n        dir = normalize(vec3(coord.x, coord.y - 0.07, 1.0));\n        t *= 0.2;\n        mat2 rmat = mat2(cos(t),sin(t),-sin(t),cos(t));\n        eye.xz = (eye.xz - C.xz) *rmat + C.xz;\n        dir.xz *= rmat;\n    }\n    \n    Figure f = RayMarching(eye, dir);\n    \n    if (f.dist > MAX_MARCH_DIST - EPS) {\n        fragColor = vec4(vec3(0.5, 0.7, 1.0), 1.0);\n        fragColor.r = fragCoord.y / iResolution.y;\n        return;\n    }\n    \n    vec3 p = eye + f.dist * dir;\n    \n    vec3 K_a = f.color;\n    vec3 K_d = f.color;\n    vec3 K_s;\n    if (f.color.r < 0.5) K_s = vec3(0.0);\n        else K_s = vec3(1.0);\n\n    bool isSoftShadow = true;\n    if (texture(iChannel0, vec2(KEY_T, 0.75)).x > 0.) {\n        isSoftShadow = false;\n    }\n\n    vec3 color = Illumination(p, eye, K_a, K_d, K_s, isSoftShadow);\n    fragColor = vec4(color, 1.0);\n}\n       ", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 593, 629, 629, 693], [695, 695, 731, 731, 832], [834, 834, 856, 856, 993], [995, 995, 1019, 1019, 1148], [1150, 1150, 1174, 1174, 1305], [1307, 1307, 1331, 1331, 1461], [1463, 1463, 1484, 1484, 1711], [1713, 1713, 1734, 1734, 1942], [1944, 1944, 1965, 1965, 2173], [2175, 2175, 2196, 2196, 2404], [2406, 2406, 2428, 2428, 2784], [2786, 2786, 2812, 2812, 3155], [3157, 3201, 3222, 3222, 3796], [3798, 3817, 3839, 3839, 4403], [4405, 4405, 4429, 4429, 4606], [4608, 4608, 4630, 4630, 4910], [4912, 4912, 4942, 4942, 4980], [4982, 4982, 5003, 5003, 5057], [5059, 5059, 5081, 5081, 5125], [5128, 5128, 5148, 5148, 5473], [5492, 5520, 5560, 5560, 5955], [5957, 5957, 5984, 5984, 6271], [6280, 6280, 6360, 6360, 6833], [6835, 6835, 6883, 6883, 7118], [7120, 7120, 7176, 7176, 7471], [7473, 7473, 7543, 7543, 8016], [8019, 8019, 8106, 8106, 8631], [8634, 8634, 8691, 8691, 9848]], "test": "error"}
{"id": "3dfSDj", "name": "2 Points Interference", "author": "gest", "description": "Two points interference test", "tags": ["experiment"], "likes": 3, "viewed": 115, "published": "Public", "date": "1552141024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord )\n{\n    vec2 u_canvas = iResolution.xy;\n    float u_time = iTime;\n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv - 0.5;\n    uv.x *= aspect;\n    uv *= 0.2;\n\n    float bright = 0.7;\n    float z = 0.01;\n\n    vec3 p = vec3(uv, z);\n\n    vec3 p1 = vec3(  0.1,  0., 0. );\n    vec3 p2 = vec3( -0.1,  0., 0. );\n\n    float time1 = mod(u_time, 10.);\n    //-0.2...+0.2 за 10 секунд\n    p1.x = 0.20 - time1 * 0.40/10.;\t\n    p2.x = -0.20 + time1 * 0.40/10.;\t\n\n    float time2 = mod(u_time, 60.);\n    if (time2<10.) {\n        p1.y = 0.;\n        p1.z = 0.01;\n        p2.y = 0.;\n        p2.z = 0.01;\n    } else if (time2<20.) {\n        p1.y = 0.01;\n        p1.z = 0.01;\n        p2.y = -0.01;\n        p2.z = 0.01;\n    } else if (time2<30.) {\n        p1.y = 0.03;\n        p1.z = 0.01;\n        p2.y = -0.03;\n        p2.z = 0.01;\n    } else if (time2<40.) {\n        p1.y = 0.03;\n        p1.z = 0.05;\n        p2.y = -0.03;\n        p2.z = 0.05;\n    } else if (time2<50.) {\n        p1.y = 0.01;\n        p1.z = 0.05;\n        p2.y = -0.01;\n        p2.z = 0.05;\n    } else if (time2<60.) {\n        p1.y = 0.;\n        p1.z = 0.05;\n        p2.y = 0.;\n        p2.z = 0.05;\n    }\n\n\n    float r1 = length(p - p1) * u_canvas.x;\n    float r2 = length(p - p2) * u_canvas.x;\n\n    vec3 a = vec3(1.0, 1.5, 2.0);\n    vec3 re = cos(r1 * a) / r1 + cos(r2 * a)/r2;\n    vec3 im = sin(r1 * a) / r1 + sin(r2 * a)/r2;\n    vec3 color = bright * (re*re + im*im) * u_canvas.x;\n\n    GL_FragColor = vec4(color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 1593]], "test": "valid"}
{"id": "3dfSRj", "name": "TargetCasem", "author": "asdhyq", "description": "Target", "tags": ["target"], "likes": 0, "viewed": 45, "published": "Public", "date": "1551755983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rgb(float r, float g, float b) \n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nvec3 circle(vec2 uv, vec2 pos, float rad) \n{\n    \n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n    \n\treturn vec3(1.0 - t);\n}\n\nfloat variation(vec2 v1, vec2 v2, float strength, float speed) \n{\n\treturn sin(\n        dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n    ) / 100.0;\n}\n\nvec3 paintCircle (vec2 uv, vec2 center, float rad, float width) \n{\n    \n    vec2 diff = center-uv;\n    float len = length(diff);\n\n    len += variation(diff, vec2(0.0, 1.0), 5.0, 2.0);\n    len -= variation(diff, vec2(1.0, 0.0), 5.0, 2.0);\n    \n    float circle = smoothstep(rad-width, rad, len) - smoothstep(rad, rad+width, len);\n    return vec3(circle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n\t\n    \n    vec2 center = iResolution.xy * 0.5;\n\tfloat radius = .3 * iResolution.y;\n\n    \n\tvec3 actualCircle = paintCircle(uv, center, radius, 0.1);\n    vec3 anotherCircle =circle(uv, center, .1 * iResolution.y);\n    vec3 anotherCircle2 =paintCircle(uv, center, .2 * iResolution.y,0.1);\n    vec3 anotherCircle3 =paintCircle(uv, center, .4 * iResolution.y,0.1);\n    vec3 anotherCircle4 =paintCircle(uv, center, .5 * iResolution.y,0.1);\n    \n    vec2 v = rotate2d(iTime) * uv;\n    \n    actualCircle *= vec3(v.x, v.y, 0.7-v.y*v.x);\n\tactualCircle += paintCircle(uv, center, radius, 0.01);\n    \n    \n    anotherCircle *= vec3(v.x, v.y, 0.7-v.y*v.x);\n\tanotherCircle += paintCircle(uv, center, .1 * iResolution.y, 0.01);\n    \n    anotherCircle2 *= vec3(v.x, v.y, 0.7-v.y*v.x);\n\tanotherCircle2 += paintCircle(uv, center, .2 * iResolution.y, 0.01);\n    \n    anotherCircle3 *= vec3(v.x, v.y, 0.7-v.y*v.x);\n\tanotherCircle3 += paintCircle(uv, center, .4 * iResolution.y, 0.01);\n    \n    anotherCircle4 *= vec3(v.x, v.y, 0.7-v.y*v.x);\n\tanotherCircle4 += paintCircle(uv, center, .5 * iResolution.y, 0.01);\n    \n    actualCircle += anotherCircle;\n    actualCircle += anotherCircle2;\n    actualCircle += anotherCircle3;\n    actualCircle += anotherCircle4;\n    \n   \n\tfragColor = vec4(actualCircle,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 87], [89, 89, 116, 116, 198], [200, 200, 244, 244, 345], [347, 347, 412, 412, 511], [513, 513, 579, 579, 868], [870, 870, 927, 927, 2238]], "test": "valid"}
{"id": "3dfSRs", "name": "sine iroiro wave", "author": "noriben", "description": "iroiro wave", "tags": ["wave"], "likes": 1, "viewed": 319, "published": "Public API", "date": "1551874641", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float amp = 0.7 * random(uv / 111112.0); //振幅\n    float amp2 = 0.2; \n    float freq = 17.0; //周波数\n    float freq2 = 43.0;\n    float thickness = 0.02 / 2.0; //線の太さ\n    float smoothing = 4.0 / iResolution.x; //画面解像度に応じたアンチエイリアス\n    \n    //wave1\n    float post = uv.x * freq + iTime * 4.0;\n    float wave = amp * sin(post);\n    //wave2\n    float post2 = uv.x * freq2 + iTime;\n    float wave2 = amp2 * sin(floor(post2)) * 1.0;\n    \n    \n    //サインカーブをtimeでmix\n    float y = mix(wave, wave2, (sin(iTime) + 1.0) / 2.0);\n    \n    vec3 linecolor = 0.5 + vec3(1.0 * (sin(iTime) + 1.0) / 2.0, 1.0 * (cos(iTime) + 1.0) / 2.0, 1.9);\n    vec3 coltop = vec3(smoothstep(0.0, smoothing, uv.y - y - 0.5 + thickness)) * linecolor;\n    vec3 colbottom = vec3(1. - smoothstep(0.0, smoothing, uv.y - y - 0.5 - thickness));\n\n\tvec3 col = coltop * colbottom;\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfSRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 95], [97, 97, 154, 154, 1143]], "test": "valid"}
{"id": "3dfSzj", "name": "Midterms_Co_Design5", "author": "johannco98", "description": "asd", "tags": ["asd"], "likes": 2, "viewed": 41, "published": "Public", "date": "1551703789", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) \n{\n\tfloat d = length((pos) - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n    \n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n    \n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n    \n\n    // Background layer\n\tvec4 bg = vec4(vec3(1.0, 1.0, 1.0), 1.0);\n\t\n\t// Circle\n\tvec3 orange = vec3(1.0, 0.5, 0.3);\n\tvec4 circle = circle(uv, center , radius, orange);\n\t\n     uv = fragCoord.xy / iResolution.xy;\n    \n    \n    //x bars\n    float valx = uv.x;\n    valx = fract(sin(abs(uv.x * 3.0)));\n    vec3 mCol2 = vec3(sin(valx * iTime * 4.0) * 0.5,\n                     sin(valx * iTime * 8.0) * 0.8, \n                     (sin(valx * iTime) * 6.0) + 0.0);\n    \n    //y bars\n    float valy = uv.y;\n    valy = fract(sin(abs(uv.y * 3.0)));\n    vec3 mCol3 = vec3(abs(sin(valy * iTime * 4.0)) * 0.5,\n                     abs(sin(valy * iTime * 8.0)) * 0.1, \n                     (abs(sin(valy * iTime) * 6.0)) + 0.0);\n\t// Blend the two\n\tfragColor = mix(bg, circle, circle.a) + vec4(mCol2 + mCol3, 1.0);\n\n}\n\n//https://www.youtube.com/watch?v=GgGBR4z8C9o\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfSzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 161], [163, 163, 220, 220, 1135]], "test": "valid"}
{"id": "3dfXDX", "name": "Tuto009 Color Mixer", "author": "arthurstammet", "description": "Color Mixer\nmy step by step tutorial 9\nby Arthur Stammet, 03.2019", "tags": ["tutorial", "color", "animation", "rotation"], "likes": 1, "viewed": 262, "published": "Public API", "date": "1552300012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Color Mixer\n// my step by step tutorial 9\n// by Arthur Stammet, 03.2019\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y; // set center to the middle of the screen\n\n    // change values here --------------------------------------------------------------\n\n    // Disk Color-Cycling RGB-Values\n    float SpeedDR = iTime * 0.7;\n    float SpeedDG = iTime * 0.8;\n    float SpeedDB = iTime * 0.9;\n\n    // Background Color-Cycling RGB-Values\n    float SpeedBR = iTime * 0.11;\n    float SpeedBG = iTime * 0.12;\n    float SpeedBB = iTime * 0.13;\n\n    float Speed1 = iTime * 0.51;\n    float Speed2 = iTime * 0.55;\n    float Sharpness = 10.; // Higher values for sharper edges\n    \n    // ---------------------------------------------------------------------------------\n    \n\t// Animate color cycling for the background\n    float BR = 0.5 + sin(SpeedBR*0.5); \t// 0.0 <> 1.0\n\tfloat BG = 0.5 + sin(SpeedBG*0.5);\t// 0.0 <> 1.0\n\tfloat BB = 0.5 + sin(SpeedBB*0.5); \t// 0.0 <> 1.0\n\n\t// Animate color cycling for the disk\n    float DR = 0.5 - sin(SpeedDR*0.5); \t// 0.0 <> 1.0\n\tfloat DG = 0.5 - sin(SpeedDG*0.5);\t// 0.0 <> 1.0\n\tfloat DB = 0.5 - sin(SpeedDB*0.5); \t// 0.0 <> 1.0\n\n    float radius = 0.45; // radius of the disk ( 0.5 = height of the screen ) \n    float blur = 0.02; // low values for sharper edges\n\n    float Rot1 = Sharpness * sin(Speed1);\n    float Rot2 = Sharpness * sin(Speed2);\n    \n    vec3 disk = vec3( DR, DG, DB ); // colorized disk (animated)\t\n    vec3 back = vec3( BR, BG, BB ); // colorized background (animated)\t\n    vec2 CenterDisk = p - vec2( 0.0, 0.0 );\t// center of the disk\n    \n    disk *= smoothstep( radius, radius-blur, length(CenterDisk)); // moving disk (animated)\n\tback *= p.x + Rot1 * p.y;\n    back += p.y + Rot2 * p.x;\n    \n    fragColor = vec4(back + disk, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfXDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 76, 133, 133, 1859]], "test": "valid"}
{"id": "3djSDm", "name": "CSG cull small frustrum", "author": "ollj", "description": "this is a smaller, semi-crunched version of parent: \nhttps://www.shadertoy.com/view/4llfR4", "tags": ["shadow", "csg", "frustrumculling"], "likes": 2, "viewed": 360, "published": "Public API", "date": "1554051304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sat(a) clamp(a,0.,1.)\n\n\n//this is a smaller, semi-crunched version of \n//parent: https://www.shadertoy.com/view/4llfR4\n//parent uses a 2d library, that often is overly convoluted structure (https://www.shadertoy.com/view/lslXW8)\n//because it implements logox-turtle plotter command-structure\n//, but i think this is silly in the context of distance fields with parallel processing\n//and more often than not just way too obfuscating\n//this dismantles that a unnecessary/unused structure a bit, and uses left-endian punctuation/context\n//this has the side effect of defining many global variables, bad style for efficient/compatible opengl code.\n\n// Frustum CSG Tree Intersection 2\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// set to 1 to show CSG operator debug setup\n#define DEBUG_CSG_OP CSG_ANDN\n#define TEST_SETUP 0\n\n#define PERSPECTIVE\n\nvec2 ray_origin0;\nvec2 ray_origin1;\nvec2 ray_dir0;\nvec2 ray_dir1;\n\nconst int op_set=0;\nconst int op_or=1;\nconst int op_and=2;\nconst int op_and_not=3;\nconst int empty=-1;\nconst int solid=-2;\nconst float infinity=9999.;\nconst vec2 empty_interval=vec2(infinity,-infinity);\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n// represents the current drawing context\n// you usually don't need to change anything here\n\nvec4 Sposition;\nvec2 Sshape;\nvec2 Sclip;\nvec2 Sscale;\nfloat Sline_width=11.;\nbool Spremultiply;\nvec2 Sblur;\nvec4 Ssource;\nvec2 Sstart_pt;\nvec2 Slast_pt;\nint Ssource_blend;\nbool Shas_clip;\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\n\nfloat AA;\nfloat AAINV;\nvec3 _color=vec3(1);\nconst int Replace=0;// default: replace the new source with the old one\nconst int Alpha=1;// alpha-blend the new source on top of the old one\nconst int Multiply=2;// multiply the new source with the old one\n\n\n// these brushes are usually imported using a SSBO\n// here we provide a small local array\n#if TEST_SETUP\n #define NUM_BRUSHES 3\n #define NUM_CSG_OPS 3\n#else\n #define NUM_BRUSHES 7\n #define NUM_CSG_OPS 7\n#endif\n\nstruct CSG_OP{int brush;int product;};\nCSG_OP csg_ops[NUM_CSG_OPS];\nbool keep[NUM_CSG_OPS];\nbool clip[NUM_CSG_OPS];\nvec3 brushes[NUM_BRUSHES];\nvec4 brush_intervals[NUM_BRUSHES];// vec2: front interval, vec2: back interval\n\nvec2 iCircle(in vec2 o, in vec2 d, in vec3 s\n){d=normalize(d)\n ;o-=s.xy\n ;float k=dot(o,d)\n ;float D=k*k-dot(o,o)+s.z*s.z\n ;float q=sqrt(D)\n ;if(D<0.)return vec2(infinity, -infinity)\n ;return (vec2(-q,q)-k)*d.x;}\n\nfloat dCircle(vec2 p, vec3 i){return length(p-i.xy)-i.z;}\n\n\nvec2 length2(vec4 a){return vec2(length(a.xy),length(a.zw));}\nvec2 dot2(vec4 a,vec2 b){return vec2(dot(a.xy,b),dot(a.zw,b));}\nfloat mus(){return min(Sscale.x,Sscale.y);}\nvoid add_field(vec2 d){Sshape=min(Sshape,d/Sscale);}\nvoid move_to(vec2 p){Sstart_pt=p;Slast_pt=p;}\nvec3 hue(float hue){return sat(abs(mod(hue*6.+vec3(0,4,2),6.)-3.)-1.);}\nvec3 hsl(float h,float s,float l){return l+s*(hue(h)-.5)*(1.-abs(2.*l-1.));}\nvec4 hsl(float h, float s,float l,float a){return vec4(hsl(h,s,l),a);}\nvoid circle(vec2 p, float r\n){vec4 c=Sposition-p.xyxy\n ;add_field(vec2(length(c.xy),length(c.zw))-r);}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r\n){s*=.5\n ;r=min(r, min(s.x, s.y))\n ;o+=s\n ;s-=r\n ;vec4 d=abs(o.xyxy-Sposition)-s.xyxy\n ;vec4 dmin=min(d,0.)\n ;vec2 df=max(dmin.xz, dmin.yw)+length2(max(d,0.))\n ;add_field(df-r);}\nvoid rounded_rectangle(float ox,float oy,float sx,float sy,float r\n){rounded_rectangle(vec2(ox,oy),vec2(sx,sy),r);}\nvoid rounded_rectangle(float x,float y,float sx,float sy\n){rounded_rectangle(vec2(x,y),vec2(sx,sy),0.);}\n\nfloat det(vec2 a, vec2 b){return a.x*b.y-b.x*a.y;}\nmat3 mat2x3_invert(mat3 s\n){float d=det(s[0].xy,s[1].xy)\n ;d=(d!=0.)?(1./d):d\n ;return mat3(s[1].y*d,-s[0].y*d,0,-s[1].x*d,s[0].x*d,0\n ,det(s[1].xy,s[2].xy)*d,det(s[2].xy,s[0].xy)*d,1.);}\nvoid transform(mat3 mtx\n){mtx=mat2x3_invert(mtx)\n ;Sposition.xy=(mtx*vec3(Sposition.xy,1.)).xy\n ;Sposition.zw=(mtx*vec3(Sposition.zw,1.)).xy\n ;Sscale *= vec2(length(mtx[0].xy), length(mtx[1].xy));}\nvoid scale(float s){transform(mat3(s,0,0,0,s,0,0,0,1));}\n\nvec2 stroke_shape(){return abs(Sshape)-Sline_width/Sscale;}\n\nbool is_solid(vec4 range){return range[1]<=range[2];}\nbool has_surface(vec4 range){return range[0] != infinity;}\nbool in_range(float x, vec2 r){return x>=r[0]&&x<r[1];}\n\nvoid write_color(vec4 rgba, float w\n){float src_a=w*rgba.a\n ;float dst_a=Spremultiply?w:src_a\n ;_color=_color*(1.0-src_a)+rgba.rgb*dst_a;}\n\nfloat calc_aa_blur(float w\n){vec2 blur=Sblur\n ;w-=blur.x\n ;return sat(-w*AA*min(1.,Sscale.x/Sscale.y))*sat(-w/blur.x+blur.y);}\n\nvoid line_to(vec2 p\n){vec4 pa=Sposition-Slast_pt.xyxy\n ;vec2 ba=p-Slast_pt\n ;vec2 h=sat(dot2(pa, ba)/dot(ba,ba))\n ;vec2 s=sign(pa.xz*ba.y-pa.yw*ba.x)\n ;vec2 d=length2(pa-ba.xyxy*h.xxyy)\n ;add_field(d)\n ;Sclip=max(Sclip,d*s/Sscale)\n ;Shas_clip=true;\n ;Slast_pt=p;}\n\nvoid shadow(\n){float z=infinity\n ;float z_local=infinity\n ;int last_product=0\n ;int last_start_offset=0\n #ifdef PERSPECTIVE\n  ;vec2 ro=vec2(0)\n  ;vec2 rd=vec2(Sposition.xy)\n #else\n  ;vec2 ro=vec2(0,Sposition.y)\n  ;vec2 rd=vec2(1,0)\n #endif\n ;for(int i=0;i<NUM_CSG_OPS;++i\n ){CSG_OP op=csg_ops[i]\n  ;if (op.product != last_product\n  ){last_product=op.product\n   ;z=min(z, z_local)\n   ;z_local=infinity\n   ;last_start_offset=i;}\n  ;if(!keep[i])continue\n  ;int brush=abs(op.brush)\n  ;vec2 d=iCircle(ro,rd,brushes[brush])\n  ;if(d[0]!=infinity\n  ){float q=(op.brush<0)?d[1]:d[0]\n   ;for(int k=last_start_offset;k<NUM_CSG_OPS;++k\n   ){CSG_OP rhs_op=csg_ops[k]\n    ;if(rhs_op.product!=op.product)break\n    ;if((!keep[k]&&!clip[k])||(k==i))continue\n    ;int rhs_brush=abs(rhs_op.brush)\n    ;vec2 rhs_d=iCircle(ro, rd, brushes[rhs_brush])\n    ;if(rhs_op.brush<0\n    ){if (q>=rhs_d[0]&&q<=rhs_d[1])q=infinity;\n     }else {if(q<=rhs_d[0]||q>=rhs_d[1])q=infinity;}}\n    ;z_local=min(z_local,q);}}    \n ;z=min(z,z_local)\n ;add_field(vec2(z-Sposition.x))\n ;Ssource=hsl(0.,1.,.5,.3)\n ;write_color(Ssource, calc_aa_blur(Sshape.x))\n ;if (Shas_clip)write_color(Ssource, calc_aa_blur(Sclip.x))\n ;Sshape=vec2(DEFAULT_SHAPE_V)\n ;Sclip=vec2(DEFAULT_CLIP_V)\n ;Shas_clip=false;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){aspect=vec2(iResolution.x/iResolution.y,1)\n ;ScreenH=min(iResolution.x,iResolution.y)\n ;AA=ScreenH*.4\n ;AAINV=1./AA\n ;uv=fragCoord.xy/iResolution.xy\n ;vec2 m=iMouse.xy/iResolution.xy\n ;position=(uv*2.-1.)*aspect\n ;query_position=(m*2.-1.)*aspect\n ;Sposition=vec4(position, query_position)\n ;Sshape=vec2(DEFAULT_SHAPE_V)\n ;Sclip=vec2(DEFAULT_CLIP_V)\n ;Sscale=vec2(1)\n ;Spremultiply=false\n ;Sblur=vec2(0,1)\n ;Ssource=vec4(0,0,0,1)\n ;Sstart_pt=vec2(0)\n ;Slast_pt=vec2(0)\n ;Ssource_blend=Replace\n ;Shas_clip=false\n ;float rdot=AAINV\n ;scale(3.)\n ;transform(mat3(1,0,0,0,1,0,-.5,0,1))\n ;float frustum_offset=0.\n ;float frustum_half_width=0.04 //0.025\n ;if(iMouse.z>.5\n ){frustum_offset=Sposition.w\n  ;frustum_half_width=.001*pow(100.0,Sposition.z);}\n  #ifdef PERSPECTIVE\n   ;ray_origin0=ray_origin1=vec2(0)\n   ;ray_dir0=vec2(1,-frustum_half_width+frustum_offset)\n   ;ray_dir1=vec2(1, frustum_half_width+frustum_offset)\n  #else\n   ;ray_origin0=vec2(0,-frustum_half_width+frustum_offset)\n   ;ray_origin1=vec2(0, frustum_half_width+frustum_offset)\n   ;ray_dir0=vec2(1,0)\n   ;ray_dir1=vec2(1,0)\n  #endif\n   ;float t=iTime\n   ;brushes[0]=vec3(.3,0,.1)\n   ;brushes[1]=vec3(mix(.25,.35,sin(t*.7)*.5+.5),.26,.29)\n   ;brushes[6]=vec3(.3,mix(.0,.1,sin(t*.6)*.5+.5),.12)\n   ;vec2 c=vec2(.8,.03)\n   ;float r0=.08,r1=.09\n   ;float a0=t,a1=a0+radians(90.)\n   ;brushes[2]=vec3(c.x+cos(a0)*r0,c.y+sin(a0)*r0,.1)\n   ;brushes[3]=vec3(c.x-cos(a0)*r0,c.y-sin(a0)*r0,.1)\n   ;brushes[4]=vec3(c.x+cos(a1)*r1,c.y+sin(a1)*r1,.1)\n   ;brushes[5]=vec3(c.x-cos(a1)*r1,c.y-sin(a1)*r1,.1)\n   ;int product=1,idx=0\n   #define CSG_FACTOR(X) csg_ops[idx++]=CSG_OP(X, product)\n   ;product++\n   ;CSG_FACTOR(2)\n   ;CSG_FACTOR(3)\n   ;CSG_FACTOR(4)\n   ;CSG_FACTOR(5)\n   ;product++\n   ;CSG_FACTOR(0)\n   ;CSG_FACTOR(-1)\n   ;CSG_FACTOR(-6)\n   ;for(int i=0;i<NUM_BRUSHES;++i\n   ){vec4 c=vec4(iCircle(ray_origin0,ray_dir0,brushes[i])\n               ,iCircle(ray_origin1,ray_dir1,brushes[i])) \n   ;c=vec4(min(c.x,c.z),max(c.y,c.w),max(c.x,c.z),min(c.y,c.w))\n   ;if (c.x>c.y)c.xy=vec2(infinity,-infinity)\n   ;if (c.z>c.w)c.zw=vec2(infinity,-infinity)\n   ;vec2 p0=brushes[i].xy-vec2(brushes[i].z,0.)\n   ;vec2 p1=brushes[i].xy+vec2(brushes[i].z,0.)\n   ;vec3 pl0=vec3(normalize(vec2( ray_dir0.y,-ray_dir0.x)),0.)\n   ;vec3 pl1=vec3(normalize(vec2(-ray_dir1.y, ray_dir1.x)),0.)\n   ;pl0.z=-dot(pl0.xy,ray_origin0)\n   ;pl1.z=-dot(pl1.xy,ray_origin1)\n   ;if((dot(vec3(p0,1.),pl0)<0.)&&(dot(vec3(p0,1.),pl1)<0.))c.x=min(c.x,p0.x)\n   ;if((dot(vec3(p1,1.),pl0)<0.)&&(dot(vec3(p1,1.),pl1)<0.))c.y=max(c.y,p1.x)\n   ;brush_intervals[i]=vec4(c.x, min(c.z, c.y),max(c.w,c.x),c.y);}\n   ;Sline_width=mus()*AAINV\n   ;vec2 p=Sposition.xy\n   ;{float z=infinity\n    ;float d=infinity\n    ;int last_product=0\n    ;for (int i=0;i<NUM_CSG_OPS;++i\n    ){CSG_OP op=csg_ops[i]\n     ;if (op.product != last_product\n     ){last_product=op.product\n      ;z=min(z,d)\n      ;d=-infinity;}         \n     ;int brush=op.brush;\n     ;float c=dCircle(p, brushes[abs(brush)])\n     ;d=max(d,(brush<0)?-c:c);}    \n    ;z=min(z,d)\n    ;add_field(vec2(z));}\n   ;Ssource=vec4(hsl(.6,.7,.95),1)\n   ;write_color(Ssource, calc_aa_blur(Sshape.x))\n   ;if(Shas_clip)write_color(Ssource,calc_aa_blur(Sclip.x))\n   ;Ssource=vec4(hsl(.6,.2,.5),1)\n   ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n   ;Sclip=vec2(DEFAULT_CLIP_V)\n   ;Shas_clip=false\n   ;// paint brushes\n   ;Ssource=hsl(.6,.2,.5,.3)\n   ;for (int i=0;i<NUM_BRUSHES;++i\n   ){vec3 brush=brushes[i]\n    ;circle(brush.xy, brush.z)\n    ;write_color(Ssource,calc_aa_blur(stroke_shape().x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;Ssource=vec4(0,0,0,.2)\n   ;move_to(vec2(0,ray_origin0.y))\n   ;line_to(vec2(0,ray_origin1.y))\n   ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n   ;Sclip=vec2(DEFAULT_CLIP_V)\n   ;Shas_clip=false;\n   ;for (int i=0;i<2;++i\n   ){vec2 ro=(i==0)?ray_origin0:ray_origin1\n    ;vec2 rd=(i==0)?ray_dir0:ray_dir1\n    ;// paint ray    \n    ;Ssource=vec4(0,0,0,.2)\n    ;move_to(ro)\n    ;line_to(ro+rd)\n    ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false\n    ;Ssource=vec4(0,0,0,1)\n    ;circle(ro,rdot)\n    ;write_color(Ssource,calc_aa_blur(Sshape.x))\n    ;if(Shas_clip)write_color(Ssource,calc_aa_blur(Sclip.x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false\n    ;vec2 u=normalize(rd)\n    ;vec2 v=normalize(vec2(-rd.y,rd.x))\n    ;move_to(ro+rd+v*rdot)\n    ;line_to(ro+rd+v*-rdot)\n    ;line_to(ro+rd+u*rdot*3.)\n    ;line_to(Sstart_pt)\n    ;write_color(Ssource, calc_aa_blur(Sshape.x))\n    ;if(Shas_clip)write_color(Ssource, calc_aa_blur(Sclip.x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;if(true //(iMouse.z > 0.5){\n   ){\n    ;float y=ray_origin0.y\n    ;float h=.01\n    ;float ht=ray_origin1.y-ray_origin0.y\n    ;int num_products=0\n    ;for(int i=0;i<NUM_CSG_OPS;++i\n    ){CSG_OP op=csg_ops[i]\n     ;num_products=max(op.product-1, num_products);}\n    ;float maxz=infinity\n    ;int maxz_op=-1\n    ;for (int i=0;i<NUM_CSG_OPS;++i\n    ){CSG_OP op=csg_ops[i]\n     ;float hue=float(op.product)/float(num_products)\n     ;int brush=abs(op.brush)\n     ;y=ray_origin0.y+ht+h*float(NUM_CSG_OPS-i-1)\n     ;vec4 range=brush_intervals[brush]\n     ;bool is_surf=false\n     ;bool is_clip=false\n     ;bool is_occluder=false\n     ;vec4 r=(op.brush<0)?range.zwxy:range\n     ;if(has_surface(range)\n     ){is_occluder=(op.brush<0)||is_solid(range)\n      ;vec4 cliprange=range\n      ;for(int k=0;k<NUM_CSG_OPS;++k\n      ){CSG_OP rhs=csg_ops[k]\n       ;if((i==k)||(op.product!=rhs.product)) continue\n       ;vec4 rhs_range=brush_intervals[abs(rhs.brush)]\n       ;vec4 rhs_r=(rhs.brush<0)?rhs_range.zwxy:rhs_range\n       ;if (rhs.brush<0\n       ){if(has_surface(rhs_range)&&(r[1]>= rhs_range[0])&&(r[1]<=rhs_range[3]))is_occluder=false;\n        }else if(!has_surface(rhs_range)||!is_solid(rhs_range)\n                  ||r[1]<=rhs_range[1]||r[1]>=rhs_range[2])is_occluder=false\n      ;if (rhs.brush<0\n      ){if(has_surface(rhs_range)&&is_solid(rhs_range)\n       ){if(in_range(cliprange[0],rhs_range.yz))cliprange[0]=max(cliprange[0],rhs_range[2])\n        ;if(in_range(cliprange[1],rhs_range.yz))cliprange[1]=min(cliprange[1],rhs_range[1])\n        ;if(in_range(cliprange[2],rhs_range.yz))cliprange[2]=max(cliprange[2],rhs_range[2])\n        ;if(in_range(cliprange[3],rhs_range.yz))cliprange[3]=min(cliprange[3],rhs_range[1])\n     ;}}else{\n      ;cliprange[0]=max(cliprange[0],rhs_range[0])\n      ;cliprange[1]=min(cliprange[1],rhs_range[3])\n      ;cliprange[2]=max(cliprange[2],rhs_range[0])\n      ;cliprange[3]=min(cliprange[3],rhs_range[3])\n    ;}}\n    ;if(cliprange[0]<=cliprange[1]){is_clip=true;if(op.brush >= 0){is_surf=true;}}\n    ;if(cliprange[2]<=cliprange[3]){is_clip=true;if (op.brush<0){is_surf=true;}}               \n   ;}\n   ;float z=(is_surf&&is_occluder)?((op.brush<0)?range[3]:range[1]):infinity\n   ;if(z<maxz){maxz=z;maxz_op=i;}\n   ;rounded_rectangle(range[0], y, range[3]-range[0], h)\n   ;Ssource=hsl(hue,1.,.5,.1)\n   ;write_color(Ssource, calc_aa_blur(Sshape.x))\n   ;if(Shas_clip)write_color(Ssource, calc_aa_blur(Sclip.x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n   ;Sclip=vec2(DEFAULT_CLIP_V)\n   ;Shas_clip=false\n   ;rounded_rectangle(range[0],y,range[1]-range[0],h)\n   ;rounded_rectangle(range[2],y,range[3]-range[2],h)\n   ;Ssource=hsl(hue,1.,.5,.3)\n   ;write_color(Ssource, calc_aa_blur(Sshape.x))\n   ;if(Shas_clip)write_color(Ssource, calc_aa_blur(Sclip.x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n   ;Sclip=vec2(DEFAULT_CLIP_V)\n   ;Shas_clip=false\n   ;Ssource=vec4(0,0,0,1)\n   ;Sline_width=mus()*AAINV*2.\n   ;clip[i]=is_surf||is_clip\n   ;keep[i]=is_surf\n   ;if(is_surf&&(op.brush>=0)\n   ){move_to(vec2(range[0],y))\n    ;line_to(vec2(range[0],y+h))\n    ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;if(is_surf&&(op.brush<0) \n   ){move_to(vec2(range[3],y))\n    ;line_to(vec2(range[3],y+h))\n    ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;Ssource=vec4(0,0,0,.5)\n   ;Sline_width=mus()*AAINV*1.3\n   ;if (is_clip&&(op.brush<0)\n   ){move_to(vec2(range[0],y))\n    ;line_to(vec2(range[0],y+h))\n    ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;if(is_clip&&(op.brush >= 0)\n   ){move_to(vec2(range[3],y))\n    ;line_to(vec2(range[3],y+h))\n    ;write_color(Ssource,calc_aa_blur(stroke_shape().x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;Sline_width=mus()*AAINV\n   ;rounded_rectangle(r[0],y,r[1]-r[0],h)\n   ;Ssource=vec4(hsl(hue,1., .3),1)\n   ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n   ;Sclip=vec2(DEFAULT_CLIP_V)\n   ;Shas_clip=false;}\n  ;Ssource=vec4(0,0,0,.5)\n  ;Sline_width=mus()*AAINV\n  ;move_to(vec2(maxz,-1))\n  ;line_to(vec2(maxz,1))\n  ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n  ;Sshape=vec2(DEFAULT_SHAPE_V)\n  ;Sclip=vec2(DEFAULT_CLIP_V)\n  ;Shas_clip=false\n  ;shadow()\n ;}\n ;fragColor=vec4(_color,1.);}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djSDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2213, 2259, 2306, 2306, 2471], [2473, 2473, 2503, 2503, 2530], [2533, 2533, 2554, 2554, 2594], [2595, 2595, 2620, 2620, 2658], [2659, 2659, 2671, 2671, 2702], [2703, 2703, 2726, 2726, 2755], [2756, 2756, 2777, 2777, 2801], [2802, 2802, 2822, 2822, 2873], [2874, 2874, 2908, 2908, 2950], [2951, 2951, 2994, 2994, 3021], [3022, 3022, 3052, 3052, 3124], [3126, 3126, 3175, 3175, 3351], [3352, 3352, 3421, 3421, 3467], [3468, 3468, 3527, 3527, 3572], [3574, 3574, 3600, 3600, 3624], [3625, 3625, 3653, 3653, 3812], [3813, 3813, 3839, 3839, 4010], [4011, 4011, 4031, 4031, 4067], [4069, 4069, 4089, 4089, 4128], [4130, 4130, 4156, 4156, 4183], [4184, 4184, 4213, 4213, 4242], [4243, 4243, 4274, 4274, 4298], [4300, 4300, 4338, 4338, 4438], [4440, 4440, 4469, 4469, 4566], [4568, 4568, 4590, 4590, 4831]], "test": "valid"}
{"id": "3djSRD", "name": "Netflix logo", "author": "saidwho12", "description": "Netflix is amazing.", "tags": ["2d", "sdf", "logo", "animation", "2019", "netflix"], "likes": 9, "viewed": 198, "published": "Public", "date": "1553111260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float udBox(in vec2 p, in vec2 b) {\n\treturn length(max(abs(p)-b,0.));\n}\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    O -= O;\n    //O -= O++;\n    vec2 R = iResolution.xy, p = (u+u-R)/R.y;\n\n    float t = (.5+.5*-cos(iTime*1.7))*3.;\n    \n    vec2 s = vec2(.125,.75);\n    float d0 = max(abs(abs(p.x)-s.x*2.)-s.x, p.y-(clamp(t-2.*float(p.x>=0.),-.05,1.)*2.-1.)*s.y);\n    //O.r += .7*smoothstep(3./R.y,0., );\n    //O.r += .7*smoothstep(3./R.y,0.,max(udBox(p+vec2(.3,0),s), p.y-(t*2.-1.)*s.y) );\n    //O.r += .7*smoothstep(3./R.y,0.,max(udBox(vec2(p.x-.3,-p.y),s), -(-p.y)-(t*2.-1.)*s.y) );\n\t\n\tfloat x2 = 2.*s.x;\n\tfloat x1 = -2.*s.x;\n    float y2 = -s.y;\n    float y1 = s.y;\n    float a = atan(y2-y1,x2-x1)+3.14;\n    \n    float w = s.x*sin(a);\n    \n    vec2 p0 = rot(a)*p;\n    float d1 = max(abs(p0.y)-w, -(p.y + s.y*((t-1.)*2.-1.)) );\n    //float d1 = max(abs(p0.y)-w, -(p0.x + s.y*((t-1.)*2.-1.)) );\n    \n    //float d2 = min(d0, d1);\n    \n    d0 = max(d0, abs(p.y)-s.y);\n    d1 = max(d1, abs(p.y)-s.y);\n    \n    float r = 2.8;\n    float dx = s.x*3.;\n    float d2 = length(p+vec2(0,s.y+sqrt(r*r - dx*dx)))-r;\n    \n    d0 = max(d0, -d2 );\n    d1 = max(d1, -d2 );\n    \n    float d = min(d0,d1);\n    \n    //O *= .25*vec4(d);\n    O = mix(O, vec4(.6 -.5*exp(-22.*max(d1,0.)) * (1.-pow(abs(p0.x),1.25)),0,0,0), smoothstep(3./R.y, 0., d0));\n    //O *= 1. - .8 * ;\n    O = mix(O, vec4(1,0,0,0), smoothstep(3./R.y, 0., d1));\n    \n    O.rgb = sqrt(O.rgb);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 71], [124, 124, 165, 165, 1495]], "test": "valid"}
{"id": "3djSWD", "name": "Souren Shapes", "author": "souren", "description": "shapes", "tags": ["shapes"], "likes": 1, "viewed": 67, "published": "Public", "date": "1553816386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup\n    vec4 solidWhite = vec4(1.0,1.0,1.0,1.0);\n    vec4 solidRed = vec4(1.0,0.0,0.0,1.0);\n    vec4 solidBlue = vec4(0.0,0.0,1.0,1.0);\n    \n    vec4 color = solidWhite;\n    \n   \tvec2 xy = fragCoord.xy;\n    \n    float width = iResolution.x;\n    float height = iResolution.y;\n    \n\tfloat size = sin(mod(width/10. + iTime*5., 100.))*50.;\n    \n    // Square\n\t/*\n    if (\n   \t\txy.x < width/2. + size && \n        xy.x > width/2. - size &&\n        xy.y < height/2. + size &&\n        xy.y > height/2. - size\n    ) {\n        color=solidRed;\n    }\n\t*/\n\n    // Circle\n    if (\n    \tpow((xy.x - width/2.), 2.) + pow((xy.y - height/2.), 2.) < pow(size, 2.)\n    ) {\n\t\tcolor=solidRed;\n    }\n    \n\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 70, 779]], "test": "valid"}
{"id": "3djSWR", "name": "Wire Mesh Fence", "author": "MacSlow", "description": "This is a by-product of trying to understand shane's and flockeroo's simplex-weave patterns.\n\nThe zoom (line 44) does not follow the bass as desired. I have yet to find proper documentation on how to read correctly from the sound-textures.", "tags": ["2d", "grid", "sound", "parallax", "simplex"], "likes": 10, "viewed": 590, "published": "Public API", "date": "1553436017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Wire Mesh Fence - A by-product of trying to understand shane's and flockaroo's\n// simplex-weave patterns\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (in float degree)\n{\n    float rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (vec2 (c, s), vec2 (-s, c));\n}\n\nfloat line (in vec2 a, in vec2 b)\n{\n    vec2 ba = b - a;\n    float h = clamp (dot (-a, ba)/dot (ba, ba), .0, 1.);\n    return length (-a - ba*h);\n}\n\nfloat grid (in vec2 p0)\n{\n    // offset, scale and rotate space\n\tvec2 p = p0 + 2.*vec2 (cos(iTime),sin(iTime));\n    float bassZoom = texelFetch (iChannel0, ivec2(0), 0).r;\n    p *= 2. + bassZoom*(.5 + .5*cos (iTime));\n\tp *= r2d (37.*iTime);\n\n    // get triangle-center/vertices/edge-midpoints\n    vec2 s = floor(p + (p.x + p.y)*.36602540378);\n    p -= s - (s.x + s.y)*.211324865;\n    vec2 v0 = p;\n\tfloat i = v0.x < v0.y ? 1. : 0.;\n    vec2 ioffs = vec2(1. - i, i);\n    vec2 v1 = v0 - ioffs + .2113248654;\n    vec2 v2 = v0 - .577350269;\n    vec2 center = (v0 + v1 + v2)/3.;\n\tvec2 e0 = .5*(v0 + v1);\n\tvec2 e1 = .5*(v1 + v2);\n\tvec2 e2 = .5*(v2 + v0);\n\n    // twist and compute lines\n\tfloat t = 4.*iTime;\n    center *= r2d (45.*sin(t)); \n\tvec2 offset = .035*vec2 (cos(t), sin(t));\n    float l0 = line (center + offset, e0);\n    float l1 = line (center + offset, e1);\n    float l2 = line (center + offset, e2);\n\n    // 'draw' lines\n    float m0 = smoothstep (.02, .01, l0);\n    float m1 = smoothstep (.02, .01, l1);\n    float m2 = smoothstep (.02, .01, l2);\n\treturn m0 + m1 + m2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize, aspect-correct and 'bulge' UVs\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .5*length(fragCoord.xy/iResolution.xy*2. - 1.);\n\n    // offset UVs for green and blue channel for fake chromatic aberration\n    float offsetScale = .0175;\n    vec2 offsetGreen = vec2(offsetScale*length(fragCoord.xy/iResolution.xy*2. - 1.));\n    vec2 offsetBlue = vec2(-offsetScale*length(fragCoord.xy/iResolution.xy*2. - 1.));\n\n    // draw four layers of grid for a parallax-like effect\n    vec3 col = vec3 (1., .95, .9);\n\tfloat layerLarge = 3.*grid(uv);\n\tfloat layerMedium = .75*grid(2.*uv*r2d(3.));\n\tfloat layerSmall = .25*grid(3.*uv*r2d(6.));\n\tfloat layerTiny = .125*grid(4.*uv*r2d(9.));\n\n    vec2 uvGreen = uv + offsetGreen;\n    float layerLargeGreen = 3.*grid(uvGreen);\n\tfloat layerMediumGreen = .75*grid(2.*uvGreen*r2d(3.));\n\tfloat layerSmallGreen = .25*grid(3.*uvGreen*r2d(6.));\n\tfloat layerTinyGreen = .125*grid(4.*uvGreen*r2d(9.));\n\n    vec2 uvBlue = uv + offsetBlue;\n    float layerLargeBlue = 3.*grid(uvBlue);\n\tfloat layerMediumBlue = .75*grid(2.*uvBlue*r2d(3.));\n\tfloat layerSmallBlue = .25*grid(3.*uvBlue*r2d(6.));\n\tfloat layerTinyBlue = .125*grid(4.*uvBlue*r2d(9.));\n\n    col.r += 4.*(layerLarge + layerMedium + layerSmall + layerTiny);\n    col.g += 4.*(layerLargeGreen + layerMediumGreen + layerSmallGreen + layerTinyGreen);\n    col.b += 4.*(layerLargeBlue + layerMediumBlue + layerSmallBlue + layerTinyBlue);\n\n    // tone-map, vignette, raster-effect, gamma-correct\n    col = col / (1. + col);\n    col *= 1. - .6*length (fragCoord.xy/iResolution.xy*2. - 1.);\n    col *= mix (1., .75, .5 + .5*cos(900.*uvRaw.y));\n    col = pow (col, vec3 (1./2.2));\n\n    fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [{"id": "lts3DN", "previewfilepath": "https://soundcloud.com/iamdjtrp/m-22-white-lies-trp-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/iamdjtrp/m-22-white-lies-trp-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djSWR.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 988, 1016, 1016, 1147], [1149, 1149, 1184, 1184, 1295], [1297, 1297, 1322, 1360, 2373], [2375, 2375, 2432, 2481, 4217]], "test": "error"}
{"id": "3djSzh", "name": "Polygon repeat", "author": "flyingrub", "description": "Play with the parameters defined at the begining", "tags": ["2d"], "likes": 3, "viewed": 132, "published": "Public", "date": "1552923936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TAU 6.28318530718\n#define pixel_width 50.*repeat*3./max(iResolution.y,iResolution.x)\n\n#define repeat 0.05\n#define speed 0.1\n#define sides 3.\n#define width 1.\n#define rotation_speed 0.1\n\nfloat stroke(float d, float size) {\n\treturn smoothstep(pixel_width,0.0,abs(d-size)-width/2.);\n}\n\nvec2 rotate(vec2 _uv, float _angle){\n    _uv =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _uv;\n    return _uv;\n}\n\nfloat polygonSDF(vec2 _uv) {\n\t// Angle and radius from the current pixel\n\tfloat a = atan(_uv.x,_uv.y)+PI;\n\tfloat r = TAU/float(floor(sides));\n\n\treturn cos(floor(.5+a/r)*r-a)*length(_uv);\n}\n\n// From https://www.shadertoy.com/view/tsBGDD\nfloat smoothmodulo(float a) {\n\treturn abs( mod(a, 2.) - 1.);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    vec2 U = ( 2.*u - R ) / R.y;\n    U = rotate(U,iTime*rotation_speed);\n    U *= repeat*50.;\n    float c = stroke(smoothmodulo(polygonSDF(U)+iTime*10.*speed),1.);\n    O = vec4(vec3(c),1.);                                       \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 254, 254, 314], [316, 316, 352, 352, 460], [462, 462, 490, 534, 650], [652, 698, 727, 727, 760], [762, 762, 800, 800, 1060]], "test": "valid"}
{"id": "3djXDw", "name": "ZicNoiceMoves", "author": "Jonas44444444", "description": "My first noise test.", "tags": ["noise", "abstract", "art"], "likes": 2, "viewed": 64, "published": "Public", "date": "1554040749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WEIGHT (3.0 / iResolution.x)\nconst vec3 RED = vec3(1.0,0.0,0.0);\nconst vec3 GREEN = vec3(0.0,1.0,0.0);\nconst vec3 BLUE = vec3(0.0,0.8,1.0);\nconst vec3 WHITE = vec3(1.0,1.0,0.97);\nconst vec3 YELLOW = vec3(1.0,1.0,0.0);\nconst vec3 COLOR = vec3(1.0,1.0,1.0);\n\nconst float NOICESCALE = 1.0;\nconst float PI = 3.1415926535897932384626433832795;\nconst float MAXSIZE = 0.5;\nconst float RINGOFSET = 0.1;\nconst float WIDTH = 0.0003;\nconst float SPEED = 0.5;\nconst int NROFRINGS = 4;\nconst float NROFPOINTS = 20.0;\n\n    // noice\n\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return .5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\nvec3 mix3(vec3 a, vec3 b, vec3 c, float t) {\n    if(t>0.5) return mix(b,c,t*2.0-1.0);\n    else return mix(a,b,t*2.0);\n}\nvec3 fragment(vec3 p) {\n    float t = sin(p.x*0.8+iTime*0.5)*0.5+0.5;\n    float fog = min(pow(p.z,3.0)*400.0,1.0);\n    return mix3(RED,GREEN,BLUE,t) * fog;\n}    \nvec2 getAnglePoint(float angle,float size)\n{\n    float x = sin(angle)*size;\n    float y = cos(angle)*size;\n    vec2 noiceVal = vec2(x*NOICESCALE/iResolution.x,y*NOICESCALE/iResolution.y);\n    float noise = snoise(vec3(noiceVal,iTime*SPEED));\n    return vec2(iResolution.x*0.5,iResolution.y*0.5)+vec2(x,y)+vec2(x,y)*noise;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float iColor = 0.0;\n\n\n    // draw circle\n    float stapsize = PI*2.0/NROFPOINTS;\n    \n    float size;\n    float ringOff;\n    float width = WIDTH *iResolution.x*iResolution.y;\n    if(iResolution.y<iResolution.x)\n    {\n        size  = MAXSIZE*iResolution.y*0.5;\n        ringOff = RINGOFSET*iResolution.y*0.5;\n    }else\n    {\n        size  = MAXSIZE*iResolution.x*0.5;\n        ringOff = RINGOFSET*iResolution.x*0.5;\n    }\n    for(int i = 0; i < NROFRINGS; i++) {\n        vec2 prefpoint = getAnglePoint(0.0,size) ;\n\t\tvec2 startPoint = prefpoint;\n        \n        for(float i = 0.0; i < PI*2.0-stapsize/2.0; i+=stapsize) {\n        \tvec2 point = getAnglePoint(i+stapsize,size);\n        \tiColor+=line(fragCoord,prefpoint,point,width);\n       \t \tprefpoint=point;\n        }\n        \n        size-=ringOff;\n    }\n   \n\tvec3 col = COLOR*iColor;\n\tfragColor = vec4(fragment(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[517, 2159, 2206, 2206, 2408], [2409, 2409, 2453, 2453, 2528], [2529, 2529, 2552, 2552, 2686], [2691, 2691, 2735, 2735, 3014], [3015, 3015, 3072, 3122, 4044]], "test": "error"}
{"id": "3djXWD", "name": "okcool2", "author": "lennyjpg", "description": "lksdjöskdfhj\n", "tags": ["akdsjhalksdjfh"], "likes": 7, "viewed": 359, "published": "Public API", "date": "1553824543", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    vec2 u = uv - 0.24;\n    \n    float e = iTime*0.5,\n          a = atan(u.x,u.y),\n          k = mod(a+e +3.14,6.28)-3.14, g;  \n    \n    u = uv - vec2(.7,.32);\n    a = atan(u.x,u.y);\n    g = mod(a-e +3.14,6.28)-3.14;\n    \n    fragColor = vec4((k-g)*.2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 352]], "test": "valid"}
{"id": "3dlSRX", "name": "shadow study 2", "author": "mindtree", "description": "more shadow marching experiments", "tags": ["raymarchshadow"], "likes": 2, "viewed": 74, "published": "Public", "date": "1551840198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching Primitives\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/Ff0jJyyiVyw\n\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n// Light RGBs\n#define LIGHT_COL vec3(1.0, 1.0, 1.0)\n#define LIGHT_SPREAD 64.\n\n#define BOX_SIZE 0.25\n\nconst float PI = 3.1457;\n\nfloat bpm() { return 128.5; }\nfloat beats_per_bar() { return 4.; }\nfloat bar() { return iTime * bpm() / 60.0 / beats_per_bar(); }\nfloat bar_phase() { return mod(bar(), 1.0); }\nfloat bar4_phase() { return mod(bar(), 4.0) / 4.0; }\nfloat bar8_phase() { return mod(bar(), 8.0) / 8.0; }\nfloat bar16_phase() { return mod(bar(), 16.0) / 16.0; }\nfloat beat() { return iTime * bpm() / 60.0; }\nfloat beat_phase() { return mod(beat(), 1.0); }\nfloat minim_phase() { return mod(beat()*0.5, 1.0); }\nfloat quaver_phase() { return mod(beat()*2.0, 1.0); }\nfloat semiquaver_phase() { return mod(beat()*4.0, 1.0); }\n\nfloat light_rot_phase() { return beat_phase(); }\nfloat light_spread_phase() { return bar16_phase(); }\nfloat box_size() { return sin(bar_phase()*2.*PI)*BOX_SIZE; }\n\nfloat light_spread() {\n    return LIGHT_SPREAD - pow(sin(light_spread_phase()*PI*2.0)*0.5+0.5, 0.5) * LIGHT_SPREAD;\n    //return LIGHT_SPREAD;\n}\n\nvec3 light_position() {\n    vec3 pos = vec3(0, 5, 6);\n    float spread = light_spread();\n    float phase = light_rot_phase() * PI * 2.0;\n    pos.xz += vec2(sin(phase), cos(phase))*spread;\n    pos.y += sin(bar4_phase()*PI*2.0)*2.0;\n\treturn pos;\n}\n\n\nfloat dBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist = length(p-s.xyz)-s.w;//*sin(bar_phase()*PI*2.0);\n    float planeDist = p.y;\n    \n    vec3 p_for_box = p;\n    //p_for_box.z = mod(p_for_box.z, 10.0);\n    p_for_box.x = mod(p_for_box.x, 8.0);\n    p_for_box.y = mod(p_for_box.y, 2.0);\n    vec3 boxp = vec3(4.0, 1.0, 10.0);\n    vec3 boxdim = vec3(1., 1., 1.)*BOX_SIZE;\n    float boxDist = dBox(p_for_box-boxp, boxdim);\n    \n    float d = min(sphereDist, planeDist);\n    d = min(d, boxDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat shadow_march(vec3 ro, vec3 rd, float min_light, float light_dist, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    float maxt = min(MAX_DIST, light_dist);\n    for (float t=min_light; t < maxt;) {\n        vec3 p = ro + rd*t;\n        float h = GetDist(p);\n        if (h<SURF_DIST) {\n            return 0.0;\n        }\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat invert_phase() {\n    return beat_phase();\n}\n\nfloat invert_lightness(float l) {\n    return mix(l, 1.0-l, cos(invert_phase()*PI*2.));\n}\n\n\nfloat GetLight(vec3 p) {\n    vec3 light_pos = light_position();\n\n    vec3 l = normalize(light_pos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(light_pos-p)) dif *= .1;\n    float min_light = 0.2;\n    float light_dist = 1.0;\n    float k = 0.5;\n    float s = shadow_march(p+n*SURF_DIST*2., l, min_light, light_dist, k);\n    //s = 1.;\n    \n    return dif*s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));//*bar16_phase()));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    float fade_dist = 1.0 - pow(d / MAX_DIST, 2.);\n    //dif = invert_lightness(dif);\n    col = LIGHT_COL * dif * fade_dist;\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlSRX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[349, 476, 489, 489, 505], [506, 506, 529, 529, 542], [543, 543, 556, 556, 605], [606, 606, 625, 625, 651], [652, 652, 672, 672, 704], [705, 705, 725, 725, 757], [758, 758, 779, 779, 813], [814, 814, 828, 828, 859], [860, 860, 880, 880, 907], [908, 908, 929, 929, 960], [961, 961, 983, 983, 1014], [1015, 1015, 1041, 1041, 1072], [1074, 1074, 1099, 1099, 1122], [1123, 1123, 1151, 1151, 1175], [1176, 1176, 1194, 1194, 1236], [1238, 1238, 1260, 1260, 1382], [1384, 1384, 1407, 1407, 1629], [1632, 1632, 1660, 1660, 1697], [1700, 1700, 1723, 1723, 2230], [2232, 2232, 2266, 2266, 2472], [2474, 2474, 2498, 2498, 2687], [2689, 2689, 2771, 2771, 3182], [3184, 3184, 3206, 3206, 3233], [3235, 3235, 3268, 3268, 3323], [3326, 3326, 3350, 3350, 3775], [3777, 3777, 3834, 3834, 4284]], "test": "valid"}
{"id": "3dlSzf", "name": "clouds :)", "author": "Zoz", "description": "Experimentation with tracing rays through 3d-noise.", "tags": ["clouds"], "likes": 0, "viewed": 102, "published": "Public", "date": "1551809974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX*rotY*rotZ;\n}\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n    \n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return max(0., 2.2 * n_xyz);\n}\n\nfloat fbm(vec3 p) {\n    p *= .5;\n    \n \tfloat t = 1.;\n    float s = 1.;\n    float a = 0.;\n    for (int i = 0; i < 4; i++) {\n     \ta += t * cnoise(p * s);\n        t *= 0.7;\n        s *= 1.9;\n    }\n    \n    return a;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat opUnion(float d1, float d2) {\n \treturn min(d1, d2);   \n}\n\nfloat opIntersect(float d1, float d2) {\n \treturn max(d1, d2);   \n}\n\nfloat opComp(float d1, float d2) {\n    return max(d1, -d2);\n}\n\n\nfloat FOG_AMOUNT = 0.2;\nfloat map(vec3 p) {\n    \n    p.z -= 15.;\n    p.x -= 5.;\n    p += vec3(.5, .5, 0.);\n    p.y = mod(p.y, 1.) - .5;\n    \n \tfloat d1 = sdRoundBox(p, vec3(.5), 0.01);\n    float d2 = sdRoundBox(p, vec3(.4, .4, 1.), 0.03);\n    float d3 = sdRoundBox(p, vec3(.4, 1., .4), 0.03);\n    float d4 = sdRoundBox(p, vec3(1., .4, .4), 0.03);\n     \n    \n    float d = opComp(d1, d2);\n    d = opComp(d, d3);\n    d = opComp(d, d4);\n    \n   \tp.y = mod(p.y, .1) -.05;\n    d = min(d, length(p) - .2);\n    \n    return d;\n}\n\nvoid applyFog( inout vec3  rgb, in float dist )\n{\n    float fogAmount = 1.0 - exp( -dist*FOG_AMOUNT );\n    vec3  fogColor  = vec3(.05, .05, .1);\n    fogColor = vec3(0);\n    rgb = mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    \n    //Compute rotation matrix from mouse coordinates\n    vec3 angles = vec3((iMouse.xy/iResolution.xy)*PI,0);\n    angles.xy *= vec2(2.0,1.0);\n    angles.y = clamp(angles.y,0.0,PI/2.0);\n    mat3 rotate = Rotate(angles.xyz);\n    //rotate = Rotate(vec3(iTime));\n    \n    //Calculate ray direction\n    vec3 o = vec3(0., 0., -3.);\n    vec3 r = normalize(vec3(uv, 2.));\n    \n    //mouse rotation\n   \to = rotate * o;\n    r = rotate * r;\n    //o.z += iTime;\n    o.y += .9;\n    \n\n    //raymarch object\n    float d2 = 0.;\n    for (int i = 0; i < 50; i++) {        \n        vec3 p = o + r * d2;\n        d2 += map(p);\n        //d += p.y + .5;\n    }\n\n    vec3 col = vec3(.7, .3, .9);\n    applyFog(col, d2);\n     \n    //trace clouds\n    float d = 0.;\n    float step_size = .8;\n    vec3 c = vec3(0.);\n    float a = 0.;\n    for (int i = 0; i < 35; i++) {\n        if (float(i) > d2) break;\n     \tvec3 p = o + r * (float(i) * step_size);\n  \n        float n = fbm(p*.8 + iTime * .1);\n        n += .1;\n        vec3 c_t = n * vec3(.9, .8, 1.);\n        float t =  1.2 * n * mix(0., 1., smoothstep(.0, 1., -p.y +\n                                         3.*cnoise(vec3(iTime*.1 + p.xz*.3, 0.))));\n        c += (1. - a) * t * c_t * step_size;   \t\n        a += t * (1. - a);\n        if (a >= 1.) break;\n        \n    }\n   \n\t//c = 0.3 * exp(c);\n    col = mix(vec3(0.45, 0.6, .9) , col, 1. - c);//vec3(.1, .1, 1.) * c;\n\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 46, 46, 331], [333, 333, 354, 354, 403], [405, 405, 426, 426, 475], [477, 477, 499, 499, 536], [538, 538, 566, 566, 618], [620, 620, 639, 639, 679], [681, 705, 727, 727, 3037], [3039, 3039, 3058, 3058, 3255], [3257, 3257, 3302, 3302, 3403], [3405, 3405, 3440, 3440, 3467], [3469, 3469, 3508, 3508, 3535], [3537, 3537, 3571, 3571, 3598], [3625, 3625, 3644, 3644, 4121], [4123, 4123, 4172, 4172, 4336], [4338, 4338, 4395, 4445, 6019]], "test": "valid"}
{"id": "3dlXR2", "name": "Semi - 3D Rainbow", "author": "asdhyq", "description": "THIS IS JUST SAD", "tags": ["sad"], "likes": 0, "viewed": 48, "published": "Public", "date": "1551755979", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 violet = vec3(238./255.,130./255.,238./255.);\n//./255.\nvec3 blue = vec3(0.,0.,1.);\nvec3 green = vec3(124./255.,252./255.,0.);\nvec3 yellow = vec3(1.,1.,0.);\nvec3 orange = vec3(255./255.,165./255.,0.);\nvec3 red = vec3(1.,0.,0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \tuv.x -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv*= sin(iTime); \n    uv.x *= sin(iTime);\n    float r = 0.1;\n    float d = length(uv);\n    \n    float c5 = smoothstep(d,d+0.02,0.6) ;\n    float c4 = smoothstep(d,d+0.02,0.5) ;\n    float c3 = smoothstep(d,d+0.02,0.4) ;\n    float c2 = smoothstep(d,d+0.02,0.3) ;\n    float c1 = smoothstep(d,d+0.02,0.2) ;\n    float c = smoothstep(d,d+0.02,r) ;\n\t\n    vec3 col = red * c5;\n    \n    col -= red * c4;\n    col += orange * c4;\n    \n    col -= red * c3;\n    col -= orange * c3;\n    col += yellow * c3;\n    \n    col -= red * c2;\n    col -= orange * c2;\n    col -= yellow * c2;\n    col += green * c2;\n    \n    \n    col -= red * c1;\n    col -= orange * c1;\n    col -= yellow * c1;\n    col -= green * c1;\n    col += blue * c1;\n    \n    col -= red * c;\n    col -= orange * c;\n    col -= yellow * c;\n    col -= green * c;\n    col -= blue * c;\n    \n    col += vec3(0.) * c;\n    \n    \n\tfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlXR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 233, 290, 290, 1297]], "test": "valid"}
{"id": "3dlXRj", "name": "2d Mirror Shape", "author": "Minstreams", "description": "trying to make some interactive fractal animation.\nClick to change color.", "tags": ["2d", "fractal"], "likes": 4, "viewed": 342, "published": "Public API", "date": "1551689924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535\n#define root2 1.41421\n#define root22 root2/2.0\n\n#define M_SIDE_NUM 6.0\n#define M_RADIUS 0.1\n#define MAX_BOUNCE_NUM 2\n#define ROTATE_SPEED 6.0\n#define CAM_SPEED 0.2\n#define DISTORT_POINTER 1.12\n#define COLOR_RANGE 0.1\n#define SATURATION 0.4\n\n//#define MODE0\n\nconst float angleUnit = 2.0*PI/M_SIDE_NUM;\n\nvec2 cam(vec2 uv)\n{\n    float d = length(uv);\n    float a = atan(uv.y,uv.x) + CAM_SPEED * iTime;\n    return vec2(d*cos(a),d*sin(a));\n}\n\nvec2 rotate(vec2 uv)\n{\n    float d = length(uv);\n    float a = atan(uv.y,uv.x);\n    a/=angleUnit;\n#ifdef MODE0\n    a = fract(a);\n#else\n    a = fract(a+0.5)-0.5;\n#endif\n    a*=angleUnit;\n    return vec2(d*cos(a),d*sin(a));\n}\nvec2 bounce(vec2 uv)\n{\n    float f = 0.0;\n    for(int i = 0;i<MAX_BOUNCE_NUM;i++){\n        float a = atan(uv.y,uv.x);\n        float d = length(uv);\n        a/=angleUnit;\n        f += floor(a+0.5);\n        a = fract(a+0.5)-0.5;\n        a*=angleUnit;\n        float x = d*cos(a);\n        float y = d*sin(a);\n        if(x<M_RADIUS)\n        {\n            a +=f*angleUnit;\n            return vec2(d*cos(a),d*sin(a));\n        }\n        x = 2.0*M_RADIUS-x;\n        uv = vec2(x,y);\n    }\n    return uv;\n}\nvec2 distort(vec2 uv){\n    float factor = pow(2.2,DISTORT_POINTER);\n    float d = length(uv);\n    d = pow(d,DISTORT_POINTER)/d * factor;\n    return uv*d;\n}\n\nvec3 mask(vec2 uv){\n    float d = length(uv);\n    return 1.2*vec3(1.0-d*d);\n}\nvec3 render(vec2 uv)\n{\n    if(uv.x>M_RADIUS)uv*=M_RADIUS/length(uv);\n    float ts = iTime*ROTATE_SPEED;\n    vec3 cosOffset = 0.2*cos(ts)+2.75+vec3(0,1,2) + 0.3*angleUnit;\n    vec3 style = vec3(0.9,0.70,0.76);\n    float edge = uv.x<M_RADIUS?max(pow(1.0-uv.x/M_RADIUS,0.1),0.0):1.0;\n    float flow = max(0.5+0.5*cos(uv.y/M_RADIUS*PI+ts ),0.0);\n    float edgeFactor = 0.5-0.5*cos(ts);\n    float flowFactor = 0.0+0.1*cos(ts/3.0-0.5*PI);\n    float shadow = edgeFactor*edge+flowFactor*flow+1.0-edgeFactor-flowFactor;\n    vec3 col =cos(cosOffset+(uv.xyx*COLOR_RANGE/M_RADIUS+COLOR_RANGE)*20.0 + iMouse.xyx/iResolution.y*PI*2.0);\n    col = 1.0-SATURATION*0.5+SATURATION*0.5*col;\n    return style*shadow*col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    vec3 col = mask(uv);\n    uv.y *= invar;\n    \n    uv = cam(uv);\n    uv = distort(uv);\n    uv = bounce(uv);\n    uv = rotate(uv);\n    \n    col *= render(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 326, 345, 345, 460], [462, 462, 484, 484, 685], [686, 686, 708, 708, 1181], [1182, 1182, 1204, 1204, 1337], [1339, 1339, 1358, 1358, 1416], [1417, 1417, 1439, 1439, 2118], [2119, 2119, 2176, 2196, 2513]], "test": "valid"}
{"id": "3dlXWf", "name": "Tuto012 Sine & Cosine Waves", "author": "arthurstammet", "description": "Complex Sine & Cosine Waves\nmy step by step tutorial 12\nby Arthur Stammet, 03.2019\ninspired by The Art of Code : https://www.youtube.com/watch?v=jKuXA0trQPE", "tags": ["wave", "tutorial", "sine"], "likes": 1, "viewed": 287, "published": "Public API", "date": "1552379679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* ************************************************************************************* \n\nSine & Cosine Waves\n\nBasic tutorial 12\nby Arthur Stammet, 03.2019\n\ninspired by The Art of Code : https://www.youtube.com/watch?v=jKuXA0trQPE\n\n************************************************************************************* */\n\nfloat Bar (float t, float b1, float b2, float blur) {\n    float s1 = smoothstep(b1 - (blur/2.), b1 + (blur/2.), t); \t// first ramp\n    float s2 = smoothstep(b2 + (blur/2.), b2 - (blur/2.), t); \t// second ramp\n    return s1 * s2; \t\t\t\t\t\t\t\t\t\t\t// build ramp\n}\n\nfloat Rectangle (vec2 uv, float L, float R, float B, float T, float blur ) {\n    float b1 = Bar(uv.x, L, R, blur); \t// build Left-Right Limits\n    float b2 = Bar(uv.y, B, T, blur); \t// build Bottom-Top Limits\n    return b1 * b2;\n}\n\nfloat sineWave (float x, float s, float f, float a) {\n    float w = sin(s+x*f)*a;\n    return w;\n}\n\nfloat cosineWave (float x, float s, float f, float a) {\n    float w = cos(s+x*f)*a;\n    return w;\n}\n\nfloat Waves4 (float x, float p, float f, float a) {\n    float w = sin(p+x*f)*a;\n    return w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set the center to the middle of the screen and make the pixels quadratic\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y; \n\n    // change values here --------------------------------------------------------------\n\n\tfloat freq = 14. + sin(iTime * 0.1) * 10.;\n    float amp = sin(iTime * 0.15) * 0.4;    \n    float phase = iTime;    \n    float blur = 0.03;    \n    \n    // dimensions of the base rectangle (before y-distortion)\n    float width = 1.5;\n    float height = 0.04;\n    \n    // ---------------------------------------------------------------------------------\n    \n\tfloat x = p.x;\n    float modS = sineWave( x, phase, freq, amp);\n    float modC = cosineWave( x, phase, freq, amp);\n    float yS = p.y - modS;\n    float yC = p.y - modC;\n    \n    vec3 back = vec3 ( 0., 0., 0. ); // colorized screen (animated)\n    vec3 sinWave = vec3 ( 0., 1., 0. ); // green\n    vec3 cosWave = vec3 ( 0., 0., 1. ); // blue\n\tsinWave *= Rectangle( vec2(x,yS), -width/2., width/2., -height/2., height/2., blur);\n\tcosWave *= Rectangle( vec2(x,yC), -width/2., width/2., -height/2., height/2., blur);\n    \n    fragColor = vec4(back + sinWave + cosWave, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlXWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 323, 376, 376, 578], [580, 580, 656, 656, 810], [812, 812, 865, 865, 909], [911, 911, 966, 966, 1010], [1012, 1012, 1063, 1063, 1107], [1110, 1110, 1167, 1247, 2328]], "test": "valid"}
{"id": "3dlXzj", "name": "CPPN s010", "author": "eps", "description": "CPPN to GLSL \nhttps://github.com/wxs/cppn-to-glsl\nsoftmax0_pre_activation_matmul:10", "tags": ["cppn"], "likes": 15, "viewed": 306, "published": "Public", "date": "1551698017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define N_HIDDEN 16\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(0.034445092, 0.0009861573, -0.04045886, 0.0003548697) + mat4(vec4(0.7932643890380859, -0.042238444089889526, -1.064584493637085, 0.7274017930030823), vec4(0.7954014539718628, 0.9088431000709534, 0.7487874627113342, 1.1422759294509888), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\nbufA[1] = vec4(0.014371727, 0.030635575, -0.037635952, 0.0007509119) + mat4(vec4(-0.17421628534793854, -0.08308246731758118, -0.9619466662406921, 0.4242114722728729), vec4(-0.9150875210762024, 0.8941507935523987, 0.48954132199287415, 0.10768552124500275), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\nbufA[2] = vec4(-0.023517082, -0.0158431, -0.021325601, -0.031348288) + mat4(vec4(0.22869540750980377, 0.3937651813030243, 0.5430814027786255, -0.6344336867332458), vec4(-0.875287652015686, 0.897762656211853, -0.3610375225543976, -0.605395495891571), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\nbufA[3] = vec4(0.004557687, 0.0073745856, 0.024763215, -0.01625731) + mat4(vec4(0.19620312750339508, 1.6809027194976807, 0.7423408627510071, -0.4519013464450836), vec4(0.13655275106430054, 0.9473739266395569, -0.046656712889671326, -0.19842000305652618), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(0.012940874, 0.019554624, -0.0048637125, -0.01319419) + mat4(vec4(-0.16928886, 0.25527576, 0.042183816, 0.388011), vec4(0.089048244, -0.39293832, -0.29206705, -0.2589509), vec4(0.05971402, -0.14081655, 0.1791858, 0.2731195), vec4(-0.14968343, -0.20620269, 0.078112856, 0.0519194)) * bufB[0] + mat4(vec4(-0.07693301, 0.1559813, 0.16473627, 0.08620981), vec4(0.03253185, -0.055484116, -0.08563124, 0.02873129), vec4(0.09212342, -0.07487029, -0.19469303, 0.04826589), vec4(0.2536777, 0.3343314, 0.39759645, -0.17704172)) * bufB[1] + mat4(vec4(0.005963893, -0.013430862, 0.18657684, 0.1598644), vec4(-0.23850808, -0.19608088, 0.018362705, 0.48741126), vec4(-0.038642887, 0.2818781, -0.027117195, -0.087961264), vec4(-0.09550527, -0.18702878, -0.46768475, -0.022020377)) * bufB[2] + mat4(vec4(0.108506866, 0.04410068, -0.0018663332, 0.2553719), vec4(-0.18234996, 0.29269183, 0.0039636143, 0.034467764), vec4(0.055824324, 0.06407464, 0.27242616, 0.36462352), vec4(-0.1787637, -0.11115205, -0.22366618, -0.2856334)) * bufB[3] + mat4(vec4(0.24028936, 0.17328255, 0.29617876, -0.21333247), vec4(0.1633031, 0.1279023, -0.22944646, 0.20119599), vec4(-0.19378611, -0.20968746, 0.010062818, -0.12560545), vec4(0.17260155, 0.037778243, 0.0018859059, -0.063637555)) * bufB[4] + mat4(vec4(-0.20912102, 0.18448348, 0.3281095, -0.24297911), vec4(0.076617196, 0.024012685, -0.16596758, -0.46772182), vec4(-0.008803283, 0.31589288, 0.06345462, -0.04095669), vec4(-0.075985335, -0.18000028, -0.03282419, -0.27902687)) * bufB[5] + mat4(vec4(0.15515897, 0.17452613, 0.06624183, -0.15472975), vec4(0.05802707, -0.22347692, 0.0004253061, -0.013665133), vec4(0.056936506, -0.43004993, 0.17541595, 0.118844986), vec4(0.046530906, 0.22631821, -0.28602037, -0.0750872)) * bufB[6] + mat4(vec4(-0.28373677, 0.018489458, -0.11744985, -0.081450544), vec4(0.28039303, -0.036934722, -0.16141188, 0.05291212), vec4(0.32030484, -0.25785217, -0.15948631, 0.057585582), vec4(0.107837684, 0.25416392, -0.34851366, -0.00985768)) * bufB[7];\nbufA[1] = vec4(0.010671025, 0.019952986, 9.348645e-06, -0.0051642335) + mat4(vec4(0.19027416, 0.54558337, -0.02848936, -0.049902823), vec4(0.18851742, 0.2898375, 0.20690423, 0.11802101), vec4(-0.14422992, -0.19343932, 0.049446303, -0.2774561), vec4(0.17379944, -0.12283511, -0.16956133, 0.1493693)) * bufB[0] + mat4(vec4(-0.20496115, 0.23044178, 0.16529736, -0.06702477), vec4(-0.22896768, -0.12287241, -0.09302216, 0.026678301), vec4(0.2168441, 0.05879832, 0.19121844, 0.2204174), vec4(0.09786244, 0.08169206, 0.058085673, -0.05726325)) * bufB[1] + mat4(vec4(0.20552213, 0.040520996, -0.2766886, -0.41736174), vec4(-0.045542035, -0.014129155, -0.03719035, -0.34884015), vec4(-0.049796943, 0.19279313, 0.12703966, -0.00061712763), vec4(0.0025198802, -0.28439346, -0.09019973, 0.10256998)) * bufB[2] + mat4(vec4(0.047888156, 0.19489515, -0.03998944, -0.22028072), vec4(-0.29600954, -0.23554912, -0.17652866, 0.24270163), vec4(0.06838974, 0.029182317, 0.1102306, -0.13397282), vec4(-0.090592846, -0.2150131, 0.21954377, 0.07484672)) * bufB[3] + mat4(vec4(0.028540337, -0.09622528, 0.20293264, 0.24483092), vec4(0.260125, 0.066327415, -0.38406226, -0.078866296), vec4(-0.02670291, 0.17839198, -0.07247582, -0.20022088), vec4(0.0048434283, 0.07413309, 0.012943989, 0.06853544)) * bufB[4] + mat4(vec4(-0.31313035, 0.28254595, 0.06616798, -0.00036702177), vec4(-0.01976677, 0.20856465, -0.09763425, 0.3817577), vec4(-0.056516558, 0.20406568, -0.1145009, -0.14779115), vec4(-0.11143926, -0.004050482, -0.24071082, -0.2346712)) * bufB[5] + mat4(vec4(0.20365185, 0.07052061, -0.048494622, 0.48771346), vec4(0.035094246, -0.123589985, -0.1420468, -0.3180177), vec4(-0.13672687, 0.2056109, -0.18752922, 0.09839657), vec4(-0.3138061, 0.030987058, 0.09790976, -0.2591422)) * bufB[6] + mat4(vec4(-0.052007593, -0.006052384, 0.1570154, -0.040342744), vec4(0.055804625, -0.049223024, 0.068106495, 0.09628068), vec4(-0.09402272, -0.07786089, -0.14185403, -0.33215514), vec4(0.11713483, 0.022679256, -0.03249315, -0.19056831)) * bufB[7];\nbufA[2] = vec4(0.0111631, -0.025902024, -0.03362862, -0.007882316) + mat4(vec4(0.22253245, 0.19246455, -0.01826338, 0.19171758), vec4(0.35774884, 0.16436134, -0.13834979, 0.23643821), vec4(-0.23170166, 0.32055032, 0.020928292, 0.13713749), vec4(0.19325693, 0.24581166, 0.25287145, 0.098338716)) * bufB[0] + mat4(vec4(0.1436925, -0.119160704, -0.1259023, 0.109611295), vec4(0.17512122, -0.08383069, 0.33141512, 0.13180909), vec4(-0.06014209, 0.1320344, 0.030065529, -0.35425875), vec4(-0.06445887, 0.08914452, 0.026781961, -0.11350412)) * bufB[1] + mat4(vec4(-0.18007363, -0.28823417, -0.12148496, 0.039477758), vec4(0.00832195, 0.19057374, -0.19932356, 0.2437709), vec4(0.06004036, -0.34164098, 0.08122399, -0.07669018), vec4(0.11002948, 0.08658771, -0.04401098, -0.16802226)) * bufB[2] + mat4(vec4(0.18268673, -0.045181938, 0.24059834, 0.09117171), vec4(-0.0615679, -0.569394, 0.23045005, 0.030920496), vec4(0.45884758, -0.006095044, -0.035138864, -0.15763576), vec4(-0.14780535, -0.0343018, 0.06256177, -0.019838389)) * bufB[3] + mat4(vec4(0.14578226, 0.27410573, 0.080519535, 0.059650168), vec4(0.24564713, 0.15455127, -0.33199173, 0.028185), vec4(0.043831494, -0.006299787, -0.34728563, 0.097108364), vec4(0.111806735, -0.2741348, -0.08381092, 0.20817815)) * bufB[4] + mat4(vec4(0.20847273, 0.15780926, 0.23893528, 0.08776166), vec4(-0.28757098, -0.059391174, 0.09948238, 0.052496664), vec4(0.19289072, -0.28415623, -0.13613555, 0.18650882), vec4(-0.024465242, -0.04104148, 0.33103627, 0.045383275)) * bufB[5] + mat4(vec4(-0.023826161, 0.3237349, -0.098428026, 0.105149046), vec4(0.10561746, 0.2949831, -0.27166405, -0.073210895), vec4(0.02663811, 0.45632854, 0.0600633, 0.28726324), vec4(-0.14767714, 0.4816957, 0.04051172, 0.0004901312)) * bufB[6] + mat4(vec4(0.032388385, 0.09258542, 0.043311134, 0.13914394), vec4(-0.02606041, -0.17778514, -0.3984911, 0.38597628), vec4(0.0039942567, 0.31604454, 0.27022976, -0.29495925), vec4(0.07433933, 0.21181826, -0.008404411, 0.33350068)) * bufB[7];\nbufA[3] = vec4(0.008541586, 0.011142996, -0.00640501, -0.004825538) + mat4(vec4(-0.14830548, 0.0768004, 0.12325945, 0.01970177), vec4(0.11266266, -0.018127289, -0.14749922, 0.26789537), vec4(0.060191255, 0.04726103, 0.018540308, 0.065221444), vec4(-0.064744644, 0.29291162, 0.06971619, 0.025813375)) * bufB[0] + mat4(vec4(0.01453301, 0.55092406, -0.09040778, -0.025242466), vec4(-0.033946797, -0.120185174, 0.18891905, -0.18477824), vec4(0.36352763, 0.1412699, -0.066567615, 0.017376468), vec4(-0.04060935, 0.0094176615, 0.06664457, 0.2245078)) * bufB[1] + mat4(vec4(-0.036666144, 0.3792712, -0.018660627, 0.03958137), vec4(-0.08617852, -0.13014367, -0.044892527, 0.05609883), vec4(-0.2880179, -0.119195156, -0.0136686, -0.029347857), vec4(-0.15526104, -0.12210492, -0.22333124, 0.37559074)) * bufB[2] + mat4(vec4(-0.11933548, 0.08936229, 0.2625185, -0.1920971), vec4(-0.034151252, -0.23809373, 0.13104114, -0.0045763813), vec4(0.1380749, -0.0066646035, 0.07219439, 0.098863214), vec4(-0.07008151, -0.2655982, -0.09142641, 0.37225103)) * bufB[3] + mat4(vec4(0.11701548, -0.124520645, 0.34097326, 0.3294527), vec4(0.1441985, -0.46489337, 0.018054342, -0.06307481), vec4(-0.108129606, -0.20366253, 0.017936148, -0.11953266), vec4(0.24819495, -0.068069115, 0.021755598, 0.09413457)) * bufB[4] + mat4(vec4(0.15176623, -0.16074632, 0.13721415, 0.07374412), vec4(-0.12489759, 0.064899705, -0.2582605, 0.18120909), vec4(-0.49870747, 0.04082048, 0.09666919, -0.0043411986), vec4(-0.15578575, 0.009425364, 0.019013954, -0.17836297)) * bufB[5] + mat4(vec4(0.116886735, -0.048438184, -0.24820122, -0.2358551), vec4(-0.11614458, 0.019628406, -0.13926311, 0.118395746), vec4(-0.054168556, 0.18811761, 0.27433014, 0.057908952), vec4(0.2408797, 0.118998714, 0.0964964, -0.0051250355)) * bufB[6] + mat4(vec4(-0.1316033, 0.21822277, -0.04482547, -0.33268088), vec4(-0.36732775, -0.050563715, 0.14589839, 0.22447339), vec4(-0.20842715, -0.35466915, 0.02271436, -0.23894753), vec4(-0.21394423, 0.178919, -0.113818526, -0.10635945)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(-0.0055563333, -0.0065136007, 0.008689762, 0.024896242) + mat4(vec4(-0.08910284, 0.085453406, -0.240656, 0.17894368), vec4(0.14253363, 0.046660654, -0.11087878, 0.011795361), vec4(-0.2042495, 0.012760143, 0.06746683, 0.02527104), vec4(0.16378604, 0.04998438, 0.03076252, -0.18414903)) * bufB[0] + mat4(vec4(-0.13532345, 0.0619175, -0.23944189, 0.07927062), vec4(-0.123179816, 0.11534059, -0.19242963, 0.008047333), vec4(-0.1406293, -0.15476222, -0.09196613, -0.00764533), vec4(0.014636766, 0.21421891, -0.14533135, 0.28356335)) * bufB[1] + mat4(vec4(-0.20910642, 0.06386524, -0.17585826, -0.006797893), vec4(-0.07440061, 0.32749242, 0.12584107, -0.048750516), vec4(-0.123874575, 0.02939188, 0.23553605, -0.4177714), vec4(0.19853523, -0.1194625, -0.03758633, -0.041762345)) * bufB[2] + mat4(vec4(0.08632263, -0.037517633, -0.26874033, 0.20095037), vec4(0.22104613, -0.09928623, -0.18525916, 0.15599409), vec4(-0.35026047, -0.14546448, -0.043942433, 0.20263995), vec4(0.21396066, -0.15647517, -0.16342534, 0.33126596)) * bufB[3] + mat4(vec4(0.2636451, 0.34285092, 0.11971939, -0.24435718), vec4(0.1662853, 0.17202638, 0.038330726, -0.055998612), vec4(0.28317168, -0.011708372, -0.07975848, 0.12098231), vec4(-0.2373417, -0.3830126, -0.23018496, -0.28376687)) * bufB[4] + mat4(vec4(0.017826624, 0.045792837, 0.20379682, 0.20124216), vec4(0.0475854, -0.22184175, 0.35988775, -0.12435258), vec4(0.103630744, -0.2956843, 0.26812127, 0.382763), vec4(0.14838699, 0.09832934, -0.07491828, -0.22712055)) * bufB[5] + mat4(vec4(-0.024187792, -0.28867683, -0.04546469, -0.066036604), vec4(-0.2831218, -0.3184173, -0.0124948835, -0.030719647), vec4(0.40066677, -0.07529597, 0.03698233, 0.3371167), vec4(0.023803309, 0.18674354, -0.08500973, -0.12800598)) * bufB[6] + mat4(vec4(-0.11177396, 0.00014938926, -0.0058073453, 0.26921827), vec4(0.19505385, 0.28011954, 0.040746074, 0.3602877), vec4(0.058692876, -0.14562088, -0.25301766, 0.1639285), vec4(0.036894836, -0.062159296, -0.043760657, -0.043474723)) * bufB[7];\nbufA[1] = vec4(-0.011015982, -0.010445767, -0.029972352, -0.0121563515) + mat4(vec4(0.10042291, 0.22375424, 0.051446434, -0.06997136), vec4(-0.12351346, 0.24618268, -0.03467014, -0.2439024), vec4(-0.351294, -0.39671355, -0.050164524, -0.15983994), vec4(-0.3147123, -0.12176476, 0.0160083, -0.036888175)) * bufB[0] + mat4(vec4(0.07817486, -0.05098632, 0.08800775, -0.06404154), vec4(0.032172788, 0.18926227, -0.029385395, -0.04771346), vec4(-0.17908116, -0.45195013, 0.030596932, 0.22927773), vec4(-0.047421742, 0.085011855, 0.019943941, -0.2704254)) * bufB[1] + mat4(vec4(-0.30652684, -0.27719602, -0.0928428, -0.3246975), vec4(-0.13864027, 0.19462094, -0.09807203, 0.14817105), vec4(-0.22886913, 0.1906838, -0.1323732, 0.16493459), vec4(0.17328948, 0.003434009, -0.39579937, -0.4036991)) * bufB[2] + mat4(vec4(-0.16310702, 0.12973142, 0.13201909, 0.3363273), vec4(0.034408305, 0.0962453, -0.107411705, -0.081167884), vec4(-0.10061462, 0.071235485, -0.165285, -0.026182232), vec4(0.10634797, -0.2644892, 0.04822015, 0.13447532)) * bufB[3] + mat4(vec4(0.2127945, 0.40389755, 0.36783355, 0.20785134), vec4(0.33009395, -0.15416464, -0.113582015, -0.084454305), vec4(0.22028045, 0.24268055, 0.105370164, -0.0819374), vec4(-0.106720075, -0.15846112, -0.1549463, 0.057197284)) * bufB[4] + mat4(vec4(-0.08443916, -0.10148769, -0.059501242, 0.054487932), vec4(0.25086045, -0.048040878, 0.0893977, 0.022819165), vec4(0.013706171, 0.03858821, 0.09541394, 0.055959135), vec4(-0.1417172, -0.05740298, 0.2626161, 0.18726717)) * bufB[5] + mat4(vec4(0.08541579, 0.2561145, -0.018661384, 0.04779082), vec4(-0.21682274, -0.015063971, 0.07483827, 0.022013979), vec4(0.23354784, 0.23680212, 0.14697058, 0.010255494), vec4(0.24185982, 0.23175217, 0.19828527, -0.023815695)) * bufB[6] + mat4(vec4(-0.09940417, -0.25569645, 0.2597382, 0.40249345), vec4(0.070534915, -0.006114012, -0.050096177, 0.10906189), vec4(0.12387469, 0.17715251, -0.38701525, -0.1357285), vec4(-0.051709633, 0.20782511, -0.2726951, -0.039933622)) * bufB[7];\nbufA[2] = vec4(-0.0015401612, -0.015320524, 0.00472196, -0.025346933) + mat4(vec4(0.02190822, -0.0029768047, -0.03826658, 0.062332943), vec4(-0.09910948, -0.030056087, -0.33200732, -0.06749059), vec4(0.067430384, 0.019558571, -0.12863183, 0.25025737), vec4(0.06386353, 0.15495257, 0.10867021, 0.21657634)) * bufB[0] + mat4(vec4(-0.20263961, -0.26141247, -0.3739553, 0.18333855), vec4(0.25360164, 0.21686445, 0.003152999, 0.10551642), vec4(0.23491837, -0.23141718, -0.192929, 0.01759906), vec4(0.011049245, 0.11909842, -0.19450594, -0.14627399)) * bufB[1] + mat4(vec4(-0.058338623, 0.23082659, -0.079996586, 0.58845735), vec4(-0.06778737, -0.106519796, 0.1388543, -0.30500472), vec4(0.04772482, 0.31403485, -0.061524272, 0.122703254), vec4(-0.32570153, -0.13370503, -0.19823888, -0.012663108)) * bufB[2] + mat4(vec4(0.0072416677, 0.07424206, -0.026242869, -0.06005669), vec4(0.2068763, 0.039736953, 0.08248686, -0.1977753), vec4(-0.13777587, -0.07864098, 0.21296328, -0.19045638), vec4(0.21907073, 0.10264701, -0.10243157, 0.08222131)) * bufB[3] + mat4(vec4(-0.038171, 0.036884047, -0.0635951, 0.14116718), vec4(0.25648388, 0.20125939, 0.17339401, 0.08822426), vec4(-0.0025065013, -0.18390761, -0.0792426, -0.35962227), vec4(-0.24630092, 0.16479674, 0.14119364, -0.15507779)) * bufB[4] + mat4(vec4(0.17024015, 0.34281555, 0.017582253, 0.15092751), vec4(0.19545414, -0.31009883, 0.0026735002, -0.0871843), vec4(0.09988617, 0.06280219, 0.19940887, 0.124938525), vec4(-0.02114256, 0.14061294, -0.10255109, 0.01809132)) * bufB[5] + mat4(vec4(0.121582955, 0.08338137, 0.15990104, 0.16849193), vec4(-0.19928224, -0.21873784, -0.17008945, 0.07787208), vec4(-0.23794541, 0.20620358, 0.21138825, -0.1546589), vec4(0.07548678, -0.2694975, -0.1201366, -0.015544529)) * bufB[6] + mat4(vec4(0.011730867, 0.15963534, -0.34621173, 0.21452361), vec4(-0.37427503, 0.075120784, 0.18916312, 0.020373914), vec4(0.05591021, 0.09337508, 0.3189148, 0.16161993), vec4(-0.42422804, 0.11167672, 0.13757636, 0.29377618)) * bufB[7];\nbufA[3] = vec4(0.028569905, -0.008045049, 0.02854157, -0.009895686) + mat4(vec4(-0.005049615, -0.113367185, -0.18008566, -0.15351151), vec4(0.008478948, -0.089090966, -0.039787825, -0.10132098), vec4(-0.1643582, 0.26306275, 0.113194995, -0.20999135), vec4(-0.118199304, 0.08254007, -0.09394405, -0.1333149)) * bufB[0] + mat4(vec4(-0.27421987, 0.053188458, 0.4007435, 0.21396756), vec4(0.0065526506, 0.016607359, 0.29068598, 0.21276937), vec4(0.010193225, 0.27512068, -0.024153842, 0.008676995), vec4(-0.07902568, 0.25176665, 0.12809919, -0.04282849)) * bufB[1] + mat4(vec4(-0.07997033, -0.016547553, 0.0678045, 0.088833556), vec4(-0.119971104, -0.16114224, 0.32559198, 0.0002326597), vec4(-0.33007413, -0.16739012, 0.0031455853, -0.021331051), vec4(-0.033422753, -0.2283718, -0.046321396, 0.17605986)) * bufB[2] + mat4(vec4(-0.19531518, 0.123403035, -0.19074571, 0.3081423), vec4(0.05901668, -0.3231315, 0.0651207, -0.14957434), vec4(-0.119946264, 0.14226793, 0.052549392, 0.043329533), vec4(-0.10007786, 0.053491853, 0.21884148, -0.27568552)) * bufB[3] + mat4(vec4(-0.09660644, -0.12735245, 0.24655221, 0.24322931), vec4(0.4917051, -0.046378236, -0.17119572, -0.21785131), vec4(-0.06287016, 0.100413606, -0.14169584, -0.13594188), vec4(0.24773027, -0.07228163, -0.3547469, -0.43610248)) * bufB[4] + mat4(vec4(0.11057487, -0.10760347, -0.45700628, -0.14233048), vec4(0.13032341, -0.0468333, -0.06429036, 0.06559656), vec4(0.0740297, 0.30381364, -0.08616089, -0.16457921), vec4(-0.027918488, -0.087633856, 0.08629995, 0.21917802)) * bufB[5] + mat4(vec4(-0.33579126, -0.06275233, -0.19933085, -0.3700205), vec4(-0.03890044, -0.0056117764, 0.09112663, -0.18849148), vec4(0.14046769, -0.0005573763, -0.044484563, 0.04248587), vec4(-0.036263593, -0.20131072, 0.13990204, -0.13943419)) * bufB[6] + mat4(vec4(-0.16410062, -0.027418597, -0.27988824, 0.042068038), vec4(-0.5102247, -0.032315403, -0.12982537, -0.03785678), vec4(-0.29596874, 0.16918124, -0.04273053, 0.09464839), vec4(0.14466253, 0.030333046, 0.03633561, 0.12507248)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(0.0073163775, -0.07645688, 0.007362486, -0.012676678) + mat4(vec4(0.13049862, -0.110925876, -0.05808108, 0.23557316), vec4(0.40501964, 0.15274361, -0.12517953, -0.26075977), vec4(0.061813474, -0.22900604, -0.07904278, 0.07228751), vec4(0.020770948, 0.08574876, -0.15411866, -0.095215455)) * bufB[0] + mat4(vec4(-0.057871412, 0.116626374, -0.10955469, -0.21479939), vec4(0.24005386, -0.19023564, 0.14637972, -0.121758185), vec4(-0.07722401, -0.04368218, 0.018365672, -0.20554413), vec4(-0.0715162, 0.012659858, -0.2174152, 0.16725881)) * bufB[1] + mat4(vec4(0.23952565, -0.24864118, -0.05623803, 0.16532654), vec4(-0.2506533, -0.008097878, 0.09117569, 0.10928194), vec4(0.12731774, 0.04668302, -0.0073332083, 0.19146971), vec4(-0.3718011, -0.0093277125, -0.0954693, -0.3736161)) * bufB[2] + mat4(vec4(-0.11952767, 0.012109225, -0.085779935, -0.14503098), vec4(0.01519976, -0.19770376, 0.0018333942, -0.048608076), vec4(-0.13058169, -0.07911754, 0.07460923, -0.045440186), vec4(0.07652215, 0.083539516, -0.02113198, -0.11239003)) * bufB[3] + mat4(vec4(-0.121542074, 0.11607961, 0.039707176, 0.06348462), vec4(-0.072566316, -0.20511483, -0.17860126, 0.053357933), vec4(-0.18017972, 0.2777991, -0.21556516, 0.09931727), vec4(-0.1581032, 0.005753218, -0.47543797, -0.12344835)) * bufB[4] + mat4(vec4(-0.15608633, 0.16637734, -0.33353192, 0.06754868), vec4(-0.35204524, 0.2039238, 0.033334013, -0.249869), vec4(-0.17087701, -0.021925703, 0.06129371, 0.0557133), vec4(-0.002288789, -0.10546422, 0.36825034, 0.18726233)) * bufB[5] + mat4(vec4(-0.14500329, -0.07921285, 0.09618896, -0.22064893), vec4(-0.009923426, 0.019221641, 0.1355505, 0.061669827), vec4(0.08797993, 0.28072715, -0.11466743, 0.0737733), vec4(-0.2696347, 0.2211898, 0.12940943, 0.21119131)) * bufB[6] + mat4(vec4(0.25287893, 0.070839204, -0.28502, -0.23152433), vec4(-0.052357916, -0.016626382, 0.053267244, 0.10993845), vec4(-0.12585929, 0.14573807, 0.12186811, -0.19097315), vec4(-0.082578875, 0.18514653, 0.1400924, -0.04418841)) * bufB[7] + in0;\nbufA[1] = vec4(-0.014264606, 0.010746552, 0.0037369223, 0.089422286) + mat4(vec4(0.14060766, 0.09861541, 0.039212726, 0.083029285), vec4(-0.062293608, 0.011661043, 0.15177812, 0.28090987), vec4(0.18726137, 0.14448997, 0.18033165, -0.10695398), vec4(0.27197474, -0.12276778, 0.1749919, 0.06884517)) * bufB[0] + mat4(vec4(0.08711438, -0.07724819, -0.17496336, 0.32750002), vec4(-0.06350586, 0.10665134, -0.15735227, -0.04447548), vec4(0.23407741, 0.08225087, 0.12106818, -0.07707309), vec4(-0.21428414, 0.23094273, 0.18673182, -0.12655689)) * bufB[1] + mat4(vec4(0.04699203, 0.11334075, 0.3587137, -0.00046505296), vec4(0.18194711, -0.07943383, -0.027722387, 0.16095823), vec4(-0.26064432, 0.25734735, 0.12361991, -0.26016808), vec4(-0.024865836, -0.2325359, -0.12600847, 0.16894804)) * bufB[2] + mat4(vec4(-0.011659903, -0.07431901, 0.1109762, 0.24167433), vec4(0.12093801, 0.0068630003, 0.26269698, -0.25652263), vec4(0.37501875, -0.05728369, 0.17073892, 0.33333498), vec4(-0.041515112, 0.11704485, -0.027006546, 0.25852555)) * bufB[3] + mat4(vec4(0.44467372, 0.048740856, 0.028421113, 0.12451301), vec4(0.2988557, -0.1276277, 0.121800415, -0.15417221), vec4(0.039372377, -0.11337649, -0.0685535, 0.12246496), vec4(-0.09025741, -0.0023219911, -0.26798478, 0.21594891)) * bufB[4] + mat4(vec4(-0.044101685, 0.36634853, 0.13497213, -0.30867696), vec4(0.062687926, 0.34595907, 0.032078493, 0.07690598), vec4(-0.09315473, -0.2312451, 0.0030552754, -0.096139744), vec4(0.14537482, -0.13343121, 0.1888091, -0.31004182)) * bufB[5] + mat4(vec4(-0.34017235, -0.080315046, 0.07420934, -0.18492137), vec4(-0.14009364, -0.2868207, 0.12898538, -0.24407548), vec4(-0.23314843, 0.17549142, 0.103701726, 0.06291206), vec4(-0.103160605, 0.029619178, -0.04787297, 0.37112498)) * bufB[6] + mat4(vec4(-0.091151685, 0.18351887, 0.06433823, 0.20292538), vec4(0.21201995, -0.18084134, 0.16591133, -0.10502336), vec4(-0.096882194, -0.22197501, -0.19075896, -0.099618785), vec4(-0.24715215, -0.21796715, 0.15141399, -0.08143616)) * bufB[7] + in1;\nbufA[2] = vec4(-1.22989e-05, 0.054801423, -0.05944044, -0.0055104364) + mat4(vec4(-0.06704425, 0.08217671, 0.05709516, 0.15557209), vec4(-0.09585643, 0.060542714, 0.23946777, -0.19553953), vec4(-0.07285208, 0.07939203, 0.15774202, -0.015466755), vec4(0.030717881, -0.13743982, -0.011985577, -0.18053558)) * bufB[0] + mat4(vec4(-0.19653024, 0.030233692, -0.07408209, -0.3207614), vec4(0.055311654, -0.37857485, -0.23408908, 0.077038474), vec4(-0.36051401, 0.23523222, -0.103607155, 0.006726114), vec4(-0.27072024, 0.11835811, -0.0621448, 0.16215207)) * bufB[1] + mat4(vec4(0.035888255, -0.10078953, -0.07484679, 0.008719366), vec4(-0.26634917, 0.4195927, -0.0032727232, 0.018159717), vec4(0.12591875, -0.0013907426, 0.029420007, -0.007880448), vec4(0.021352487, 0.25166515, 0.025426881, 0.06927715)) * bufB[2] + mat4(vec4(0.032812186, 0.52462685, 0.026338082, 0.0012771217), vec4(0.029108599, 0.0133271245, -0.08179965, 0.11940468), vec4(0.13624871, 0.08126023, -0.16511932, 0.021828886), vec4(0.06606572, 0.4242805, 0.111589335, 0.3396406)) * bufB[3] + mat4(vec4(0.13205121, 0.09161683, 0.23568483, -0.0016780517), vec4(-0.043917727, -0.09936575, 0.08777463, -0.025620677), vec4(-0.007713823, 0.038398832, 0.20424615, 0.10146972), vec4(0.07268835, -0.15182224, 0.026103849, -0.2004265)) * bufB[4] + mat4(vec4(-0.18474583, -0.15631905, 0.18109582, 0.29084063), vec4(0.11511933, -0.123975866, -0.09890955, 0.03106792), vec4(0.03335805, -0.032613985, 0.23473975, 0.009099809), vec4(-0.004824701, -0.27770883, -0.12248568, 0.16116743)) * bufB[5] + mat4(vec4(0.21792233, 0.17341292, 0.15962768, 0.16027443), vec4(-0.18163061, -0.3507899, 0.1506538, -0.20252007), vec4(-0.12924889, 0.111565344, -0.32934108, 0.0014856646), vec4(0.3784403, -0.18766592, 0.023684805, -0.0047173565)) * bufB[6] + mat4(vec4(0.1320679, -0.064730205, -0.09778816, -0.006637483), vec4(0.037622172, 0.256753, 0.036995105, -0.123098254), vec4(0.17646788, -0.02071362, 0.21647543, -0.13224062), vec4(0.13677192, 0.072270885, 0.29691663, -0.025397727)) * bufB[7] + in2;\nbufA[3] = vec4(0.0063585015, 0.0075504323, -0.01359879, -0.033984628) + mat4(vec4(-0.35246736, -0.1450342, -0.07190384, -0.2043459), vec4(0.42176166, -0.27540183, 0.08832669, 0.1811551), vec4(-0.3128362, -0.10262157, 0.13176498, -0.5021654), vec4(0.27690265, -0.124402, 0.05477288, -0.19859982)) * bufB[0] + mat4(vec4(0.051756382, 0.0053079543, -0.20915177, -0.074100584), vec4(-0.085729, 0.0072429413, 0.28795427, 0.23874119), vec4(0.20172268, -0.041642427, -0.047768313, -0.011616732), vec4(0.06780757, 0.12533401, 0.13414937, -0.009075834)) * bufB[1] + mat4(vec4(-0.040056918, -0.077738576, 0.057690132, -0.018077334), vec4(0.2172599, -0.16109364, 0.11636553, 0.109067634), vec4(-0.33372635, 0.0025580605, 0.03074818, -0.118962355), vec4(-0.15991807, 0.017847398, -0.18621427, 0.12645763)) * bufB[2] + mat4(vec4(-0.03074599, 0.17032863, 0.21546984, -0.084924445), vec4(-0.036873955, -0.04596651, 0.058682594, -0.3401839), vec4(0.15091395, -0.07604269, 0.011026078, 0.15372461), vec4(0.3312571, -0.096195646, 0.1568339, -0.17214167)) * bufB[3] + mat4(vec4(-0.13204789, -0.054496508, 0.05690066, -0.07284035), vec4(0.0848793, -0.097907804, 0.1665025, -0.15127492), vec4(0.16998635, -0.14468941, 0.26079726, -0.065959886), vec4(0.24233736, -0.011353366, 0.04950023, 0.26134425)) * bufB[4] + mat4(vec4(-0.06693001, 0.14216201, 0.06632612, 0.18031403), vec4(-0.106914304, -0.20506537, 0.23020263, 0.005509952), vec4(-0.26050094, -0.38066468, -0.105704635, 0.058248382), vec4(-0.28285852, 0.17736769, 0.2588452, 0.22412701)) * bufB[5] + mat4(vec4(0.30655393, -0.055255298, -0.23810048, 0.1879181), vec4(0.1836889, -0.15487002, -0.27748144, -0.38992366), vec4(0.0058332067, -0.027330251, -0.008228904, -0.06854442), vec4(-0.24394567, -0.041474544, -0.085062176, -0.1038456)) * bufB[6] + mat4(vec4(-0.36645448, -0.064776175, 0.15919447, 0.330717), vec4(0.03599768, 0.11401257, -0.04158003, 0.22692983), vec4(0.20711778, -0.06361471, 0.19966002, -0.11442184), vec4(-0.068053536, 0.07514562, -0.11359335, -0.263204)) * bufB[7] + in3;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(-0.012222041, 0.050071403, 0.082462154, 0.03508317) + mat4(vec4(0.3044708, -0.34474078, -0.10228804, -0.07364205), vec4(-0.12173964, -0.0034437242, -0.27961472, -0.31994966), vec4(0.10792464, -0.124542676, 0.006697851, 0.03447215), vec4(0.21946353, 0.4291924, 0.061268523, -0.40328914)) * bufB[0] + mat4(vec4(0.11945283, -0.026908675, 0.19305974, 0.031765237), vec4(-0.0018026177, -0.00887713, -0.081768535, -0.2711592), vec4(-0.024111679, 0.287452, -0.016121628, -0.3444682), vec4(0.11282309, -0.3949072, 0.08935448, -0.08929583)) * bufB[1] + mat4(vec4(0.007931371, -0.24008869, 0.016847402, -0.05393696), vec4(-0.17869182, 0.048310522, -0.14808823, 0.289491), vec4(0.19605088, 0.027079597, -0.041340105, 0.1423789), vec4(0.07458765, 0.13241373, 0.1364499, 0.11003701)) * bufB[2] + mat4(vec4(0.19253309, -0.024062661, 0.14399421, -0.15311947), vec4(0.31342253, -0.36200613, 0.19989476, 0.077606134), vec4(0.08978617, 0.30998924, 0.015426675, -0.005295923), vec4(0.09737605, -0.20338511, -0.03707124, -0.009461393)) * bufB[3] + mat4(vec4(-0.059242025, -0.047972508, 0.48570493, -0.05557222), vec4(0.12095288, 0.12056121, 0.03836112, 0.010830827), vec4(0.2529053, -0.09622156, 0.11777106, -0.11751446), vec4(0.062767595, -0.06074267, 0.024982216, -0.2550725)) * bufB[4] + mat4(vec4(-0.024032496, -0.10601449, -0.5038406, 0.16386077), vec4(-0.051146403, -0.046062108, 0.07131725, -0.054407578), vec4(-0.23593456, 0.13028014, -0.08007556, 0.09201508), vec4(0.14554246, 0.0034916075, -0.045205176, -0.39375994)) * bufB[5] + mat4(vec4(-0.0968241, 0.04841139, -0.21009165, 0.08634423), vec4(0.39071605, -0.2585773, -0.18786088, -0.0332428), vec4(0.050290626, 0.0066799438, -0.22674856, 0.19381137), vec4(-0.14738564, 0.08577128, -0.008564024, 0.017259242)) * bufB[6] + mat4(vec4(0.0037753703, -0.02064476, -0.061397363, 0.1540708), vec4(-0.26777756, 0.26169768, 0.053758316, -0.10428129), vec4(0.05867394, 0.37477508, -0.20825435, -0.09164378), vec4(-0.08801739, -0.042479873, -0.00034550187, -0.0476347)) * bufB[7];\nbufA[1] = vec4(-0.048562624, 7.838296e-05, -0.007954048, 0.105195805) + mat4(vec4(0.008120941, -0.21381477, -0.2427726, -0.15163293), vec4(0.12144646, 0.10097112, 0.06694742, 0.22962481), vec4(-0.1540317, 0.10650427, -0.07621951, 0.00090348104), vec4(0.20687598, -0.09728808, 0.24556936, -0.04190966)) * bufB[0] + mat4(vec4(-0.053522892, -0.15467662, -0.14884822, 0.06407026), vec4(-0.17134506, 0.16417532, -0.22965102, -0.045954276), vec4(0.061906546, -0.2182434, -0.09754333, -0.010692725), vec4(-0.17598096, 0.22367054, -0.2341057, 0.12059363)) * bufB[1] + mat4(vec4(0.20602849, 0.44573784, -0.27630416, -0.15905635), vec4(-0.17883871, 0.02476629, 0.062363427, 0.027217474), vec4(0.20154013, 0.029537758, -0.08008231, 0.11944439), vec4(-0.020861788, 0.524989, -0.08242571, 0.07160075)) * bufB[2] + mat4(vec4(0.23167071, 0.20486686, -0.16892858, 0.0039780727), vec4(-0.044632155, 0.18998541, 0.19328244, 0.009283336), vec4(0.10378139, 0.23312744, -0.13397025, 0.4648601), vec4(0.1100739, -0.065440394, 0.10553896, -0.2909372)) * bufB[3] + mat4(vec4(0.013048318, -0.10834443, 0.05992679, -0.06019016), vec4(0.30822027, -0.008664709, 0.38179755, -0.0015248572), vec4(-0.09734101, -0.108983524, -0.12028945, 0.02007695), vec4(0.06717544, 0.20799161, -0.0065591685, 0.031215997)) * bufB[4] + mat4(vec4(-0.19734699, -0.025847008, 0.14581311, -0.37331945), vec4(0.1816546, -0.020074952, -0.16618478, 0.36204925), vec4(0.17598395, -0.11019941, 0.15596019, 0.12585805), vec4(0.07012915, -0.014559652, 0.08790195, -0.4516082)) * bufB[5] + mat4(vec4(0.024573505, 0.15300445, 0.27809247, -0.16700472), vec4(-0.38108763, -0.14375708, -0.17386536, 0.07003596), vec4(0.036493942, 0.07471801, 0.20488979, 0.115507536), vec4(0.5567951, -0.01213911, 0.23969395, -0.30162677)) * bufB[6] + mat4(vec4(0.041672584, 0.024749072, -0.37321323, -0.19396158), vec4(-0.057892736, -0.046362955, -0.11861138, 0.12698004), vec4(0.3301811, -0.05609779, -0.088261984, -0.25617182), vec4(-0.026216084, 0.16795178, 0.10771176, -0.24012484)) * bufB[7];\nbufA[2] = vec4(0.052618302, -0.011630083, -0.09021054, 0.041498512) + mat4(vec4(-0.17784677, -0.056285053, -0.16858533, -0.32146376), vec4(0.1505728, -0.10516146, -0.10460459, -0.17878938), vec4(0.21478766, 0.083683886, -0.31405592, -0.2989377), vec4(0.06556207, -0.0934684, 0.31325352, -0.2737581)) * bufB[0] + mat4(vec4(-0.062455602, -0.052433606, 0.13721272, 0.21124537), vec4(-0.3497449, 0.1512367, -0.020683393, -0.021968398), vec4(-0.2808347, 0.51676744, -0.18151125, 0.12380521), vec4(0.06882115, 0.16171946, 0.12702975, -0.088985324)) * bufB[1] + mat4(vec4(0.30580848, 0.21865797, 0.027845953, -0.1839897), vec4(-0.14694422, -0.121029876, 0.033216484, 0.20756555), vec4(-0.019629713, 0.2466533, 0.0606364, -0.13133194), vec4(0.108889066, -0.057106372, -0.0020879474, -0.09506249)) * bufB[2] + mat4(vec4(0.050530188, -0.28769043, -0.03714421, 0.09713722), vec4(0.19774167, 0.06551614, 0.1662927, -0.01874926), vec4(-0.04683738, -0.21291558, 0.1133693, 0.052467227), vec4(-0.30260292, -0.31008968, -0.13131137, 0.13289063)) * bufB[3] + mat4(vec4(-0.043152113, -0.196279, 0.18803978, -0.082463324), vec4(0.20412445, 0.15661247, 0.2573508, -0.20792826), vec4(-0.12960263, 0.12053214, 0.058575056, -0.30928084), vec4(0.21079902, -0.19906048, 0.17177936, -0.05223171)) * bufB[4] + mat4(vec4(0.2516683, -0.005836672, -0.04247912, -0.14035541), vec4(-0.107437804, -0.1276372, -0.020521086, 0.19100234), vec4(-0.13493429, -0.24185376, 0.10990235, -0.15417841), vec4(-0.033591375, 0.11212631, 0.068589814, -0.15151553)) * bufB[5] + mat4(vec4(0.08269612, -0.14838085, 0.037613716, -0.17543662), vec4(-0.09730141, 0.08483148, 0.46854305, 0.17796798), vec4(-0.027244892, 0.0025252304, 0.0857874, -0.13499656), vec4(-0.20572245, 0.11450643, 0.23764399, -0.19067025)) * bufB[6] + mat4(vec4(0.1709603, -0.16934408, 0.15420339, -0.28066495), vec4(-0.08365627, 0.08633121, 0.04318496, 0.15790525), vec4(0.28592956, 0.09978791, 0.12460094, 0.124165505), vec4(-0.007834432, -0.18224448, -0.1514358, 0.05709703)) * bufB[7];\nbufA[3] = vec4(0.022118675, 0.04951177, 0.0610159, -0.01108094) + mat4(vec4(0.1242938, -0.04968525, 0.28612798, 0.29304653), vec4(0.09585524, -0.05360571, 0.35375467, 0.06489166), vec4(-0.32975644, -0.26065165, -0.4684275, -0.18281145), vec4(0.10153638, -0.13457441, -0.008173633, -0.01019329)) * bufB[0] + mat4(vec4(0.017664196, 0.21303304, 0.10452896, -0.22790056), vec4(-0.109340094, -0.055618364, -0.23364468, -0.17440964), vec4(-0.38373893, 0.4371907, 0.074443, 0.08545207), vec4(-0.04344317, 0.03570718, 0.26808396, -0.1739864)) * bufB[1] + mat4(vec4(0.073178865, 0.081324115, -0.12346181, 0.20927802), vec4(-0.3931758, 0.033278774, 0.056031365, -0.111927606), vec4(0.14526181, -0.13459723, 0.3675334, -0.06668286), vec4(-0.23754452, -0.27935404, 0.1624586, 0.26335418)) * bufB[2] + mat4(vec4(0.09823628, -0.2768835, 0.022614257, 0.0051791943), vec4(0.3679193, -0.15992439, 0.15381992, -0.15235752), vec4(-0.124938406, -0.26796028, 0.010490505, -0.24312022), vec4(-0.14117768, 0.1687807, -0.27600458, 0.42252702)) * bufB[3] + mat4(vec4(0.32758918, -0.0821431, -0.010784635, -0.1729258), vec4(-0.21099691, 0.104551, 0.1626273, 0.0031968707), vec4(0.16385195, -0.20709877, 0.045965157, -0.20184231), vec4(0.08764211, 0.2809317, 0.02432067, -0.06473672)) * bufB[4] + mat4(vec4(0.14813782, -0.013441306, 0.22830342, 0.12846461), vec4(-0.13418561, 0.05859601, -0.20056619, -0.030766182), vec4(-0.03365252, 0.25354436, 0.036910966, -0.06315298), vec4(-0.024362335, -0.025130436, -0.2534861, -0.1448526)) * bufB[5] + mat4(vec4(-0.297206, 0.20734745, -0.1457954, 0.14207776), vec4(-0.10447353, 0.086746365, -0.15799153, 0.026097389), vec4(-0.061346542, 0.18286149, -0.0146702165, 0.119883135), vec4(0.13537481, -0.19207929, -0.2312615, 0.06370229)) * bufB[6] + mat4(vec4(0.0359026, -0.07974062, 0.2989429, -0.10526644), vec4(-0.014406053, 0.00768573, -0.41958562, 0.253642), vec4(0.038619753, -0.40675974, -0.017866269, 0.014241815), vec4(0.14264973, -0.0749942, -0.04774723, -0.21615647)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(0.00077766133, -0.07212722, -0.06489811, 0.09027675) + mat4(vec4(-0.13661994, 0.13645485, 0.10866642, -0.11474554), vec4(-0.18318245, 0.15193047, 0.09182226, 0.0042132987), vec4(-0.09058352, 0.18582873, -0.15890948, 0.056934007), vec4(0.036308493, 0.028377367, 0.15870804, -0.087603614)) * bufB[0] + mat4(vec4(0.13258955, -0.007835036, -0.028875235, -0.12851925), vec4(-0.11333816, 0.0619062, -0.07122359, -0.13658817), vec4(-0.1248886, 0.17206892, -0.17570071, 0.0039606597), vec4(0.05447921, 0.027592493, 0.06100271, -0.01948927)) * bufB[1] + mat4(vec4(-0.091720246, -0.04452092, -0.02763496, -0.17575283), vec4(-0.12502915, -0.2350582, -0.017342454, 0.17244399), vec4(0.16793363, -0.057209786, -0.26915756, 0.045873456), vec4(-0.040884532, 0.12092187, -0.3695535, 0.16575564)) * bufB[2] + mat4(vec4(0.13058974, 0.055007968, 0.039820295, 0.22182657), vec4(-0.012689059, -0.044829242, -0.13268001, -0.18687557), vec4(0.20748541, 0.15687631, 0.006822857, 0.1259188), vec4(0.008713451, -0.18209594, 0.05954673, -0.022991197)) * bufB[3] + mat4(vec4(-0.012858109, -0.2720342, -0.23058873, -0.3777622), vec4(-0.08538478, 0.1722992, 0.20668395, 0.01103997), vec4(0.0009831528, 0.13689631, 0.17486632, 0.0905468), vec4(-0.24978513, -0.1354412, -0.003137923, -0.22514309)) * bufB[4] + mat4(vec4(0.20518994, 0.18698746, 0.06047428, -0.071997344), vec4(-0.031181226, 0.18053654, 0.1979231, -0.2986247), vec4(0.28888154, -0.21000333, -0.035753664, -0.16992159), vec4(0.15094064, -0.06511179, 0.040075645, 0.08425856)) * bufB[5] + mat4(vec4(-0.08115819, -0.2840588, -0.17998919, 0.2109924), vec4(-0.08150192, -0.1486883, 0.21809776, -0.050520837), vec4(-0.2683263, 0.03092325, -0.0979894, -0.0002760248), vec4(-0.073042616, -0.0050337757, 0.012304963, 0.18918473)) * bufB[6] + mat4(vec4(-0.27603167, -0.08321606, 0.3558625, 0.1035834), vec4(-0.102931954, 0.14982945, -0.19255838, 0.06201201), vec4(-0.14876953, 0.18506032, -0.06954363, -0.014680257), vec4(0.32200426, -0.086168736, 0.38520125, -0.38964662)) * bufB[7];\nbufA[1] = vec4(-0.023078771, 0.1650869, -0.016669447, 0.050665796) + mat4(vec4(-0.04407584, -0.12868495, 0.18279292, 0.08167231), vec4(-0.2927384, 0.09456003, -0.48051, 0.38129056), vec4(0.03621881, -0.0039429083, -0.12795457, 0.18784325), vec4(0.215774, 0.048416812, 0.32620078, -0.02313032)) * bufB[0] + mat4(vec4(-0.017081922, 0.34054995, -0.059982415, -0.15234378), vec4(0.38247916, -0.115569726, -0.19706042, -0.15874179), vec4(-0.12633689, 0.08306044, 0.046569165, 0.07899542), vec4(-0.074150726, 0.35008952, 0.20760149, 0.34221464)) * bufB[1] + mat4(vec4(0.15756547, 0.17364685, 0.07931918, -0.23524123), vec4(0.03893915, -0.20266004, 0.16343743, 0.016745197), vec4(-0.06636396, 0.24899481, 0.25757742, 0.2988733), vec4(0.095769, 0.035640676, -0.17457633, -0.19064374)) * bufB[2] + mat4(vec4(-0.29615423, 0.14376056, -0.011572347, 0.04440417), vec4(0.17333934, -0.041140202, -0.16363923, 0.015751928), vec4(-0.13191052, -0.08068055, -0.25776348, 0.012036087), vec4(0.06047974, 0.14555158, -0.045298405, -0.27540374)) * bufB[3] + mat4(vec4(0.13840437, -0.16326527, -0.049109124, -0.08951356), vec4(-0.15584862, -0.07338847, 0.18718554, -0.0680502), vec4(0.023439493, -0.3261522, -0.112917386, 0.13320796), vec4(0.15985085, -0.072206855, 0.119166516, 0.11747975)) * bufB[4] + mat4(vec4(-0.26812008, -0.21322553, -0.20093246, -0.22341569), vec4(0.17555666, 0.013081518, 0.12552054, -0.13552241), vec4(0.066273734, 0.046756294, -0.48762152, -0.1052705), vec4(-0.0067698774, -0.04477727, 0.15975457, 0.06629442)) * bufB[5] + mat4(vec4(0.103270926, 0.0515023, -0.10115071, 0.0123086255), vec4(0.052139107, -0.048417117, 0.23657343, -0.08091422), vec4(0.24570197, -0.3491251, -0.15866344, -0.21740417), vec4(-0.034822445, -0.17014176, 0.33033642, -0.1000386)) * bufB[6] + mat4(vec4(0.019016294, -0.008974942, -0.124867044, -0.26949203), vec4(0.22220802, -0.103155024, 0.5930454, 0.17401962), vec4(0.027702224, 0.10357983, 0.012810686, 0.10030881), vec4(0.11999227, 0.10835636, 0.05362149, 0.4151515)) * bufB[7];\nbufA[2] = vec4(0.039658345, 0.11944382, -0.06418731, 0.094682544) + mat4(vec4(0.16559926, -0.123246424, -0.08223969, -0.030360607), vec4(-0.12245032, -0.21189356, -0.06598612, -0.068606466), vec4(0.055699974, 0.11229861, 0.036110546, -0.029934136), vec4(0.0047321394, 0.28742343, -0.13863078, -0.06485385)) * bufB[0] + mat4(vec4(-0.012392214, 0.12394227, -0.102800116, -0.02847524), vec4(0.06266485, 0.1825103, -0.1239188, 0.40103063), vec4(0.1803921, 0.3198092, 0.32749113, -0.04879432), vec4(0.06840037, 0.15656893, -0.26305217, -0.3500602)) * bufB[1] + mat4(vec4(0.12441015, -0.00884724, -0.30141133, -0.08571291), vec4(-0.046866074, 0.035330236, 0.13803922, -0.03307077), vec4(-0.077960856, -0.20001666, 0.1750268, 0.2460824), vec4(0.51012677, 0.26073232, 0.14913636, 0.14676584)) * bufB[2] + mat4(vec4(0.045749705, 0.47181323, -0.026112832, 0.22150636), vec4(0.11375808, 0.026931493, 0.34509686, -0.36544096), vec4(-0.08467486, -0.16617733, 0.155361, 0.15833807), vec4(-0.4487173, -0.22951616, 0.08783111, -0.17876555)) * bufB[3] + mat4(vec4(0.03226077, -0.15383382, -0.01312762, -0.07607062), vec4(-0.099896386, -0.18643522, 0.34854588, 0.105936), vec4(0.13058023, -0.10993678, 0.03145673, -0.046257287), vec4(0.1445933, -0.06170926, -0.27829444, -0.18478423)) * bufB[4] + mat4(vec4(-0.13826978, -0.06346313, -0.16222543, 0.038244545), vec4(0.18620847, -0.22495055, 0.4047983, -0.09836409), vec4(-0.20457238, -0.17190947, 0.08575415, -0.21082003), vec4(-0.054962624, 0.13378723, -0.16366594, -0.18547468)) * bufB[5] + mat4(vec4(0.048389312, -0.24056959, -0.035621755, -0.03341275), vec4(0.1142597, -0.11296289, 0.41560417, -0.1443471), vec4(0.08643642, 0.12462412, -0.12023816, 0.039113205), vec4(-0.12583293, -0.18361132, -0.12537117, -0.0718124)) * bufB[6] + mat4(vec4(-0.192368, 0.06851227, 0.11796392, -0.2971651), vec4(-0.25808477, -0.13747364, -0.15347219, -0.11939779), vec4(-0.29654014, 0.19070968, -0.09345351, -0.0559938), vec4(-0.24240607, -0.2051667, -0.13086875, 0.15119939)) * bufB[7];\nbufA[3] = vec4(0.041591402, -0.08374927, -0.05042762, -0.10915974) + mat4(vec4(-0.16584656, -0.088643126, -0.11622254, -0.07695288), vec4(-0.11147117, -0.06383857, -0.0068063727, 0.17353241), vec4(0.08041635, -0.17706442, -0.11644454, 0.037799735), vec4(0.034255467, -0.3828827, 0.032976557, -0.19003639)) * bufB[0] + mat4(vec4(0.41695723, 0.07422077, -0.05290848, -0.074534014), vec4(-0.12517124, -0.21072927, -0.04753536, 0.12663327), vec4(0.3216882, -0.2370003, -0.27806008, -0.41307908), vec4(0.0648439, -0.27853844, 0.30116108, -0.19853626)) * bufB[1] + mat4(vec4(-0.08014949, -0.24327047, 0.15309875, 0.14632083), vec4(-0.35057938, 0.46875829, 0.2570429, -0.11741325), vec4(0.0733565, 0.2274681, -0.30487555, -0.09460019), vec4(-0.13011345, 0.30434832, 0.04712299, 0.33328778)) * bufB[2] + mat4(vec4(-0.039133217, -0.058161043, 0.24171335, 0.080562785), vec4(0.014329098, 0.018095111, 0.13891867, 0.20765772), vec4(0.068299614, 0.0046460535, 0.06605943, -0.21562724), vec4(0.18793581, 0.22688845, -0.03395195, 0.13711217)) * bufB[3] + mat4(vec4(0.0449346, 0.17406183, -0.15977071, 0.28120247), vec4(0.05112229, -0.10897016, -0.05391078, 0.107976064), vec4(-0.21471182, 0.09131312, 0.23555022, -0.011308032), vec4(-0.29616752, 0.43088076, 0.0843119, -0.172273)) * bufB[4] + mat4(vec4(0.121807925, 0.18895823, 0.10248805, 0.046800278), vec4(-0.4076168, -0.08767412, -0.18700105, 0.05814769), vec4(-0.20512606, -0.08522172, -0.11059765, 0.22791825), vec4(0.008024307, 0.14582738, 0.055968143, -0.26277345)) * bufB[5] + mat4(vec4(-0.2500237, -0.02059901, -0.2234352, -0.26176196), vec4(-0.26286814, 0.18305233, 0.08468416, 0.050498717), vec4(0.094111785, 0.28792834, 0.14795475, -0.08166166), vec4(-0.19421025, -0.30097827, -0.08928084, 0.2698229)) * bufB[6] + mat4(vec4(0.40992406, -0.02325453, -0.27993253, 0.25367), vec4(0.049035672, 0.043280534, 0.18010728, -0.045298457), vec4(-0.34021255, -0.088619, -0.38384655, -0.08689441), vec4(-0.19722691, 0.110885784, 0.34453708, 0.32480103)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(-0.12102909, -0.016122594, 0.10323197, -0.110773794) + mat4(vec4(0.41640836, 0.039350428, 0.18700492, -0.05413405), vec4(0.04976615, 0.017336871, -0.18104526, 0.37706473), vec4(0.2329924, 0.34970015, -0.19024268, -0.0740575), vec4(-0.12732506, 0.24847282, -0.1072184, -0.103114225)) * bufB[0] + mat4(vec4(0.06765392, -0.13617857, 0.062148854, -0.14484528), vec4(0.23378909, -0.01415085, -0.36568838, 0.21839692), vec4(0.12881733, 0.13511254, -0.16040275, 0.2620914), vec4(0.28284153, 0.11254756, 0.1560185, -0.12188948)) * bufB[1] + mat4(vec4(-0.28006685, -0.14588325, -0.15699795, 0.42093825), vec4(0.22168365, 0.11033019, 0.17772463, 0.0043788864), vec4(0.17921232, 0.11027818, 0.039385118, 0.1430549), vec4(0.32494545, 0.043030266, 0.015418545, 0.18264402)) * bufB[2] + mat4(vec4(-0.012158245, 0.012357067, -0.13095275, 0.4403873), vec4(0.32445055, -0.18498787, -0.37721762, -0.08318151), vec4(0.39847562, -0.22113618, 0.31872073, 0.36264077), vec4(-0.30587208, 0.29945946, -0.099105895, 0.17460816)) * bufB[3] + mat4(vec4(0.19440283, 0.45583978, -0.1275092, -0.31416264), vec4(0.18213949, -0.3230792, -0.157974, 0.24468532), vec4(0.22005792, -0.049653854, -0.033627722, -0.050401326), vec4(0.16081093, 0.03180168, -0.3860827, 0.015930211)) * bufB[4] + mat4(vec4(0.06359219, 0.28423467, -0.08021276, 0.16813856), vec4(0.06001509, -0.1471529, 0.21433543, 0.47986236), vec4(-0.012504498, -0.19116044, 0.1289327, -0.2213821), vec4(-0.20147207, 0.08093832, -0.44318843, 0.18794803)) * bufB[5] + mat4(vec4(0.012769684, -0.23378555, 0.118135236, 0.13251743), vec4(-0.20932624, 0.07812454, 0.12320843, 0.35667914), vec4(0.13546382, -0.15722749, -0.15069921, 0.13813128), vec4(0.5685978, -0.0027548699, -0.14398989, 0.21339327)) * bufB[6] + mat4(vec4(0.072800554, -0.17713054, -0.074259065, 0.053658623), vec4(0.31478575, -0.061836857, -0.024835229, -0.1513822), vec4(0.0029267073, -0.36850023, 0.024936868, 0.072644345), vec4(-0.07489492, -0.09122101, -0.048592713, 0.14060608)) * bufB[7];\nbufA[1] = vec4(-0.15262105, -0.012050901, -0.036621157, -0.14858584) + mat4(vec4(0.18000339, 0.28527948, -0.13697945, 0.14668365), vec4(0.18806913, -0.03923596, -0.1289851, 0.1499786), vec4(0.029906888, 0.078831285, 0.090210974, 0.21459483), vec4(-0.1205107, 0.28308448, -0.38712806, -0.27921924)) * bufB[0] + mat4(vec4(0.20716548, -0.11871907, -0.16372825, 0.0076498403), vec4(-0.12082013, -0.008673803, 0.10551351, -0.26414242), vec4(0.028423334, -0.13369273, -0.12172238, 0.061626274), vec4(0.021601476, 0.15433443, 0.025399039, -0.1442782)) * bufB[1] + mat4(vec4(-0.24755415, -0.07327956, -0.15067312, -0.07395546), vec4(0.10546837, 0.19949041, -0.20084776, -0.24131332), vec4(0.09356289, -0.18176807, -0.029474951, -0.010155278), vec4(-0.13212594, 0.1525274, 0.3763609, 0.22083217)) * bufB[2] + mat4(vec4(-0.24173152, 0.13542767, 0.10548842, 0.25881174), vec4(-0.004265287, -0.080854796, 0.258808, -0.19017632), vec4(-0.051163804, -0.1416749, 0.08608348, 0.4450145), vec4(-0.11851074, 0.13142107, 0.029430658, -0.02150497)) * bufB[3] + mat4(vec4(-0.19363555, 0.097969696, 0.061666276, -0.1497583), vec4(-0.056806825, -0.030464731, 0.0045421356, 0.005920547), vec4(-0.17469868, -0.01217016, -0.1991112, -0.03232414), vec4(-0.0665956, -0.022611244, -0.12414626, 0.56572264)) * bufB[4] + mat4(vec4(0.097605266, 0.0055651157, -0.24238774, 0.13865001), vec4(0.32157403, -0.09930948, 0.06888107, -0.10228383), vec4(0.4659449, 0.074537754, 0.10782458, -0.023579026), vec4(0.07326331, -0.13752718, -0.029588517, -0.35501006)) * bufB[5] + mat4(vec4(0.11541461, 0.2693556, -0.062120363, 0.15475756), vec4(0.13390087, 0.22717294, -0.16557802, 0.2269839), vec4(-0.46521226, -0.07917734, 0.13763602, -0.094547145), vec4(-0.60368943, 0.13421836, 0.005048356, 0.036853064)) * bufB[6] + mat4(vec4(0.27717587, -0.1445783, -0.18929963, 0.16749083), vec4(-0.22690272, 0.1672585, 0.041684657, -0.030203993), vec4(0.061616477, -0.02201608, -0.19990952, -0.150401), vec4(0.24492295, 0.0115483, 0.17855147, 0.2627397)) * bufB[7];\nbufA[2] = vec4(0.11390191, -0.13900287, -0.06436503, 0.027492467) + mat4(vec4(0.426577, -0.091764934, -0.18316835, 0.02974633), vec4(-0.063149005, -0.031639896, 0.123249836, -0.29837537), vec4(0.09325365, 0.3919278, 0.0139637925, 0.038441546), vec4(0.34413806, -0.07587314, -0.1077396, 0.15849045)) * bufB[0] + mat4(vec4(-0.054135066, -0.2020978, 0.015714835, -0.042615943), vec4(0.24595362, -0.0017607461, 0.29614598, 0.32883072), vec4(0.13470618, -0.08186838, 0.1867288, 0.0025405358), vec4(0.3155194, 0.26653153, -0.12088711, 0.1746783)) * bufB[1] + mat4(vec4(0.1748442, 0.0056188027, 0.2968589, 0.2850368), vec4(0.12400115, 0.2836584, 0.17974992, -0.06199026), vec4(0.37441963, -0.034711964, 0.10388319, -0.12039981), vec4(-0.008782144, 0.28120834, -0.026046002, 0.20420176)) * bufB[2] + mat4(vec4(-0.05880847, -0.019349277, -0.04915768, -0.17702529), vec4(0.058025956, 0.07714214, 0.18557853, -0.22238392), vec4(-0.12660234, 0.37381202, 0.21030763, -0.04549896), vec4(-0.07868452, -0.13339761, -0.21563193, 0.0068289666)) * bufB[3] + mat4(vec4(0.22581753, 0.04217922, 0.6153023, 0.18275169), vec4(-0.014978845, 0.22403713, 0.014742933, 0.15251322), vec4(-0.10265758, 0.3674817, 0.2033043, -0.11459239), vec4(0.17174684, -0.05690335, 0.03664777, 0.04039323)) * bufB[4] + mat4(vec4(-0.011240884, -0.0055511524, 0.21513319, -0.19139118), vec4(0.20912646, 0.21655901, 0.2905087, -0.0041921968), vec4(0.037474472, 0.2087235, 0.16244687, -0.04436419), vec4(0.17367499, -0.15193823, 0.07577679, 0.3893622)) * bufB[5] + mat4(vec4(-0.103753045, 0.080282226, -0.17733027, -0.2908693), vec4(0.46594682, -0.25225934, -0.17232284, -0.11924913), vec4(0.29321352, -0.10912502, 0.12158102, 0.10768967), vec4(0.06754146, 0.36498725, 0.07573895, -0.07843429)) * bufB[6] + mat4(vec4(0.5489624, 0.20960504, 0.08385851, 0.067091346), vec4(0.1631908, 0.10385348, -0.048522856, 0.3180985), vec4(0.030686382, -0.23090023, 0.02968873, 0.060397718), vec4(-0.2056049, 0.22652772, -0.1974378, 0.1403103)) * bufB[7];\nbufA[3] = vec4(0.13476744, -0.00039371758, -0.048532996, -0.061685506) + mat4(vec4(-0.20124434, -0.08576414, 0.29355547, 0.030624524), vec4(-0.3846241, 0.055661056, 0.150128, 0.223575), vec4(-0.010195291, -0.05185922, -0.19720864, -0.19476067), vec4(-0.107144855, -0.047359332, 0.09285351, 0.043901)) * bufB[0] + mat4(vec4(0.37869558, 0.2852762, -0.26615655, 0.45376474), vec4(0.26696137, 0.10467058, -0.23583299, 0.30836976), vec4(0.0611018, -0.07083023, -0.26725447, 0.25256306), vec4(0.049856573, -0.13372618, 0.33961627, 0.19061367)) * bufB[1] + mat4(vec4(0.20568636, 0.2081961, 0.080540314, 0.06689062), vec4(-0.084828965, 0.11327692, -0.045271486, 0.07722204), vec4(0.028692052, 0.13818172, 0.1485183, -0.15111862), vec4(0.1661405, 0.44703218, -0.033347227, 0.23349358)) * bufB[2] + mat4(vec4(-0.020400133, -0.10880695, -0.07559393, 0.03177918), vec4(-0.31949607, -0.16735159, 0.21631183, -0.026252158), vec4(-0.17314668, -0.17861666, -0.10214306, 0.21085714), vec4(0.1457168, -0.14668635, -0.2542595, 0.11574225)) * bufB[3] + mat4(vec4(0.011106661, 0.0006899886, 0.11666094, 0.13349108), vec4(0.14625435, -0.10485348, 0.044859182, -0.10484463), vec4(0.25613427, -0.027821261, 0.097437546, 0.1578916), vec4(-0.24633473, 0.03158871, -0.13629206, 0.10147597)) * bufB[4] + mat4(vec4(-0.013911991, 0.31671688, -0.08191318, -0.0058686975), vec4(0.057930905, 0.19925597, -0.19556345, 0.19295931), vec4(0.41764504, 0.14759775, -0.012362564, -0.12301087), vec4(-0.13596302, -0.08434017, 0.32092354, 0.044657554)) * bufB[5] + mat4(vec4(-0.19754052, -0.1895516, -0.037710767, -0.08266576), vec4(-0.056635816, 0.06511742, -0.059888694, -0.1735105), vec4(-0.023764139, -0.038504127, -0.13182159, 0.1200544), vec4(0.024422469, 0.114904635, 0.13754433, 0.24312021)) * bufB[6] + mat4(vec4(-0.123369776, 0.11079726, 0.033294763, -0.1439413), vec4(-0.0992891, 0.20856757, 0.1421518, 0.086299576), vec4(-0.2675767, 0.06378091, 0.16659923, 0.0330098), vec4(-0.09960462, 0.065028064, -0.10006452, 0.20125383)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(-0.1546674, -0.047357053, -0.24869572, 0.23545812) + mat4(vec4(0.043223176, -0.34423137, -0.074028976, -0.28858972), vec4(0.3833759, 0.3141856, 0.030807514, -0.14301568), vec4(0.28419352, 0.06315165, -0.13091284, -0.62005293), vec4(-0.12897056, 0.13163702, 0.08460042, -0.027792586)) * bufB[0] + mat4(vec4(-0.2482417, 0.5639253, -0.23609236, -0.38611466), vec4(-0.3220625, 0.37499878, -0.11420659, -0.3119361), vec4(0.41283447, -0.1372769, -0.00079505204, -0.17939508), vec4(0.23528174, 0.32789204, -0.32604107, -0.15295342)) * bufB[1] + mat4(vec4(-0.30189693, -0.658262, 0.041852247, 0.016979383), vec4(-0.012353744, 0.05422333, 0.027522486, -0.08012157), vec4(0.10475429, -0.10381238, 0.24975817, -0.1840068), vec4(0.18039115, -0.07273953, 0.048251335, 0.1370264)) * bufB[2] + mat4(vec4(0.14786243, -0.11889776, -0.33523378, 0.39779758), vec4(-0.06437752, -0.026077313, -0.021834577, 0.514497), vec4(-0.2778853, 0.23995501, 0.18299636, -0.22428925), vec4(0.20197847, 0.028983483, -0.32693383, -0.025914112)) * bufB[3] + mat4(vec4(0.1110842, 0.22375213, 0.6400073, 0.18330921), vec4(0.040610794, 0.045864806, -0.31211004, -0.23933722), vec4(0.18525602, -0.07586704, 0.088350415, -0.09033781), vec4(0.21176612, -0.110903755, -0.27817592, -0.055996023)) * bufB[4] + mat4(vec4(0.03684623, -0.15871374, 0.15314543, 0.25382733), vec4(0.03660053, 0.11088603, 0.5609041, -0.3755773), vec4(-0.21885878, -0.004573518, 0.40010706, 0.29843125), vec4(0.12852605, -0.17739554, 0.18547851, 0.27507317)) * bufB[5] + mat4(vec4(0.31077087, -0.6237595, -0.12904476, -0.43391025), vec4(-0.015237135, -0.44620872, 0.10135746, -0.060798723), vec4(0.04191629, 0.18726903, -0.20307085, -0.22471236), vec4(0.37456152, 0.4032113, 0.046735983, 0.022299036)) * bufB[6] + mat4(vec4(-0.31542796, 0.18452431, 0.20965545, -0.121055566), vec4(-0.09492318, 0.05557397, -0.012246389, -0.02094885), vec4(0.15695399, 0.31058857, -0.29951394, 0.080018535), vec4(-0.22657791, 0.27426878, -0.12763596, -0.30764252)) * bufB[7];\nbufA[1] = vec4(0.1614623, 0.1485664, 0.098726414, -0.32370007) + mat4(vec4(0.15607812, 0.18843372, -0.06832116, 0.10160644), vec4(-0.1728218, -0.10087694, 0.21551943, -0.054959502), vec4(0.12200369, 0.3744463, 0.262717, -0.036540568), vec4(0.08015148, 0.04528275, 0.081531726, -0.09568636)) * bufB[0] + mat4(vec4(-0.65472627, -0.13787583, -0.10905198, 0.22161388), vec4(0.078015305, 0.677227, -0.098651946, -0.20985411), vec4(-0.41035625, -0.31609732, 0.057454, -0.017104981), vec4(0.01898015, -0.3377328, -0.2417524, -0.059646368)) * bufB[1] + mat4(vec4(0.030641893, -0.14699341, 0.23398542, -0.17578244), vec4(-0.14087686, 0.20373735, 0.05797395, 0.13317907), vec4(0.06947766, -0.12441894, 0.23997909, -0.135677), vec4(-0.3174679, -0.15054001, 0.06195069, 0.102000035)) * bufB[2] + mat4(vec4(0.14244613, -0.10029393, -0.042847514, 0.2718776), vec4(0.062507115, 0.27570885, 0.18335125, -0.34752667), vec4(0.3189132, -0.4308922, 0.316662, 0.04472781), vec4(0.051069733, 0.1795432, -0.20817515, -0.20259093)) * bufB[3] + mat4(vec4(-0.3488388, 0.09077599, -0.13421796, -0.031126238), vec4(-0.31769833, -0.1923456, -0.050109033, -0.24630189), vec4(-0.48763302, -0.11551345, -0.10425788, -0.21751134), vec4(-0.23553213, 0.078460306, -0.027633786, 0.47414917)) * bufB[4] + mat4(vec4(-0.327651, -0.043778665, 0.1450041, 0.30333465), vec4(-0.44937125, -0.41500866, 0.19098732, 0.025995491), vec4(0.5589495, 0.15589, 0.08221026, 0.2995485), vec4(-0.08751339, -0.05892962, 0.30611473, 0.068103634)) * bufB[5] + mat4(vec4(-0.30909002, -0.1472308, -0.13744472, 0.041200683), vec4(-0.08063733, 0.24043903, -0.10336401, 0.19522732), vec4(-0.037249364, -0.37162957, 0.15988027, 0.4074305), vec4(0.11464716, 0.07982921, -0.27495497, -0.04928619)) * bufB[6] + mat4(vec4(0.18043026, -0.01852891, -0.24064364, 0.16610244), vec4(0.060718823, -0.11844342, 0.118544765, -0.15056527), vec4(-0.067508094, 0.53333175, -0.42461628, 0.036975622), vec4(-0.21491681, -0.40845573, -0.24280202, -0.04875933)) * bufB[7];\nbufA[2] = vec4(0.2821629, -0.116653875, -0.2237135, 0.17050084) + mat4(vec4(-0.2171852, 0.030841354, 0.14393651, -0.12437883), vec4(-0.045788325, 0.14790049, 0.15224913, 0.15987918), vec4(-0.03826943, 0.022643737, -0.026578907, 0.09033994), vec4(0.29776844, -0.31312728, -0.17701276, 0.1291862)) * bufB[0] + mat4(vec4(-0.05021774, 0.15142615, -0.1585352, 0.26116204), vec4(-0.016557408, -0.10896546, -0.22150688, 0.47103095), vec4(0.40722755, 0.12164674, 0.09636541, -0.316995), vec4(-0.18549368, -0.04519026, -0.15055425, -0.042257093)) * bufB[1] + mat4(vec4(0.31653118, -0.10577222, 0.35530773, 0.16379035), vec4(-0.11312587, 0.053702794, 0.1953756, 0.0063466853), vec4(0.09021787, 0.2613173, -0.11153499, -0.008294247), vec4(-0.09417445, -0.24262278, 0.354716, -0.06846267)) * bufB[2] + mat4(vec4(0.025759287, -0.24624334, -0.13195454, -0.074833214), vec4(0.12623656, -0.30575874, 0.06607781, 0.109387346), vec4(0.16848527, 0.13621837, 0.010140857, 0.123737425), vec4(-0.15404223, -0.13898845, 0.07677273, 0.18420966)) * bufB[3] + mat4(vec4(0.14735031, 0.075700186, 0.3009387, 0.28382716), vec4(0.011139254, 0.051235095, 0.15811336, -0.10166622), vec4(-0.28030598, 0.10317609, -0.4051075, -0.09925912), vec4(0.0679835, 0.6452742, -0.061332587, 0.097428896)) * bufB[4] + mat4(vec4(-0.09141723, -0.08731479, 0.40816095, 0.138196), vec4(-0.16157356, -0.2997215, -0.3217251, -0.08477081), vec4(0.06480983, 0.43191996, 0.014640346, -0.020788854), vec4(-0.06938523, 0.32295325, 0.19433896, -0.25190613)) * bufB[5] + mat4(vec4(-0.10049773, -0.018602623, -0.013336444, 0.30744925), vec4(-0.04775159, 0.27520832, 0.01910998, -0.06981494), vec4(-0.107865684, -0.049754094, -0.4714622, -0.27995282), vec4(-0.0073856628, 0.15897529, 0.2714864, 0.005684573)) * bufB[6] + mat4(vec4(-0.19578148, -0.34288424, -0.18546084, 0.10541466), vec4(-0.790229, -0.2431636, 0.15914582, 0.11632053), vec4(-0.079255775, -0.19664364, -0.1815076, -0.21388529), vec4(-0.08417807, 0.15219499, -0.18554133, -0.2600727)) * bufB[7];\nbufA[3] = vec4(-0.07376879, 0.24441701, 0.10147969, 0.2288161) + mat4(vec4(0.040812273, 0.14731827, 0.11160597, -0.049839824), vec4(-0.13346402, 0.36639342, 0.09131413, -0.31646502), vec4(-0.098391704, 0.40094957, -0.17579396, -0.08956314), vec4(-0.080831766, 0.12910572, 0.029074825, 0.07819637)) * bufB[0] + mat4(vec4(0.06441188, 0.29662707, 0.03232318, -0.1806469), vec4(0.08009121, -0.18330781, -0.34439996, 0.12709932), vec4(-0.21103242, -0.05820989, -0.091874346, -0.077447005), vec4(0.29865372, 0.022712266, -0.3035939, -0.09880327)) * bufB[1] + mat4(vec4(0.47972643, 0.13139781, -0.025930654, -0.16665249), vec4(-0.6233104, -0.10554046, -0.32755023, 0.15173751), vec4(0.16044787, -0.013293261, -0.11745266, 0.032802504), vec4(-0.09853335, -0.050664917, -0.03990833, 0.11195004)) * bufB[2] + mat4(vec4(0.21880789, -0.110319704, -0.14205214, 0.2189752), vec4(0.031767875, 0.22221074, -0.04548432, 0.3386141), vec4(-0.2837718, 0.1393651, -0.34999385, 0.18094957), vec4(-0.29285252, -0.21198693, -0.12846191, 0.1281284)) * bufB[3] + mat4(vec4(0.26872906, -0.13469994, -0.28335702, -0.24142437), vec4(0.051034797, -0.21260644, 0.31205234, -0.22232509), vec4(-0.2007208, -0.06830922, 0.025291333, -0.33940122), vec4(0.009835629, -0.19375338, 0.15573841, 0.34286186)) * bufB[4] + mat4(vec4(-0.10811612, 0.037841767, -0.12867676, -0.13429248), vec4(-0.33097792, -0.4263447, -0.3394005, -0.3911729), vec4(-0.039206363, 0.3174636, -0.10910434, -0.19696832), vec4(-0.5420425, -0.37587768, -0.097357176, 0.037627146)) * bufB[5] + mat4(vec4(0.07846698, 0.13201916, 0.01455032, 0.420541), vec4(0.35855272, -0.0771908, 0.1542037, 0.15286162), vec4(0.13386011, -0.09296666, 0.027810374, 0.12760064), vec4(0.123336315, -0.07104541, 0.098206446, -0.22425699)) * bufB[6] + mat4(vec4(-0.043371387, -0.11002996, 0.17775741, 0.12246641), vec4(-0.16071829, 0.15206623, 0.0896113, -0.22375967), vec4(-0.37858343, 0.07816306, -0.22952631, -0.39313525), vec4(0.0089433165, -0.21031605, 0.16301629, -0.20467852)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(-0.14184888, 0.054144524, -0.11176425, -0.08341283) + mat4(vec4(0.15373044, 0.16608448, -0.18503676, -0.12721707), vec4(-0.13052675, 0.16265391, -0.03225276, 0.7660827), vec4(0.28837222, -0.17343321, -0.07929595, -0.22271582), vec4(-0.12855455, -0.15722838, 0.28226015, 0.016655969)) * bufB[0] + mat4(vec4(0.048168737, 0.1897622, -0.5802853, -0.35772702), vec4(0.6117234, 0.07706976, 0.124759436, -0.6746694), vec4(0.049665943, -0.2414503, 0.25319067, 0.777842), vec4(0.1178729, 0.3667983, 0.31523886, 0.7662581)) * bufB[1] + mat4(vec4(0.30847406, 0.16405033, -0.11920793, 0.06500282), vec4(0.46235865, -0.25696552, 0.61080354, -0.389004), vec4(-0.069633566, -0.47435883, -0.17400888, -0.044040736), vec4(-0.2957162, -0.2778206, 0.024522496, -0.2085966)) * bufB[2] + mat4(vec4(-0.42448774, 0.10121019, 0.059221726, -0.35786405), vec4(0.5351228, 0.2696054, -0.15060616, 0.17394899), vec4(-0.15441844, -0.18675224, -0.25757697, 0.27435687), vec4(-0.23629557, 0.48442283, 0.24141556, -0.5442629)) * bufB[3] + mat4(vec4(-0.12057224, 0.09303773, -0.096672684, 0.33259898), vec4(0.45838597, 0.1129788, 0.038864806, 0.33686608), vec4(0.42730507, 0.09997564, 0.7330871, -0.10131665), vec4(0.274622, 0.6151688, -0.19338751, -0.050566137)) * bufB[4] + mat4(vec4(0.113983646, 0.5461982, -0.18307383, -0.20264229), vec4(-0.41190746, -0.38918006, -0.21847305, -0.19391194), vec4(0.40112096, -0.58152854, 0.20244399, -0.082424186), vec4(0.26193616, -0.3460721, 0.42394108, 0.4657768)) * bufB[5] + mat4(vec4(-0.7116941, -0.16086572, 0.489674, 0.5209412), vec4(-0.2169426, 0.37744817, -0.26482832, 0.16645226), vec4(-0.03190806, -0.035981964, 0.44655615, -0.15091409), vec4(0.7589859, -0.4267328, 0.85746926, 0.1471768)) * bufB[6] + mat4(vec4(-0.19012547, -0.4135721, -0.043686893, 0.03455414), vec4(0.7053345, -0.69943804, 0.27972353, 0.68454), vec4(-0.06814304, 0.011750624, -0.34551507, -0.74526733), vec4(0.09553713, -0.43721396, 0.52374804, 0.27001458)) * bufB[7];\nbufA[1] = vec4(-0.44464725, 0.3575691, -0.032028332, -0.57736224) + mat4(vec4(-0.14345399, 0.3005646, 0.07151296, 0.14322503), vec4(0.25123292, -0.15830019, -0.05166168, 0.29083446), vec4(0.033494707, 0.026860386, 0.37093312, -0.15698758), vec4(0.04690596, 0.21500966, -0.07594789, -0.2952912)) * bufB[0] + mat4(vec4(-0.26893684, 0.013783975, -0.32352632, 0.09855453), vec4(-0.15971835, -0.2877834, -0.28171104, 0.13500147), vec4(0.3353804, -0.12729174, 0.163003, -0.33481902), vec4(0.048098266, 0.039793596, 0.2528516, -0.11063237)) * bufB[1] + mat4(vec4(-0.051491436, -0.279938, 0.41624242, -0.08714611), vec4(0.07810806, -0.23492347, -0.08770018, -0.12706551), vec4(-0.054247588, -0.09754038, 0.2418193, -0.09883552), vec4(0.17521383, -0.17994724, -0.2617391, -0.0850875)) * bufB[2] + mat4(vec4(-0.07512658, 0.0009568116, 0.094185695, 0.3178662), vec4(-0.11513296, -1.048537, -0.25023222, -0.16779709), vec4(-0.0073948996, 0.015092768, 0.10301108, -0.036457382), vec4(-0.1507476, -0.458405, 0.25393, -0.15319747)) * bufB[3] + mat4(vec4(-0.09174449, -0.23504733, 0.07225356, 0.7277715), vec4(-0.05098396, 0.32700628, 0.48232347, 0.13243347), vec4(-0.096743345, -0.21615846, -0.04707476, 0.04069937), vec4(-0.037112564, 0.30480498, 0.12552048, 0.061568733)) * bufB[4] + mat4(vec4(-0.23735498, -0.8777401, -0.6603726, -0.28709415), vec4(0.10222884, 0.08873494, 0.19603373, -0.41007587), vec4(-0.08098091, -1.0482634, -0.43654084, -0.013818852), vec4(0.027248763, -0.40921628, 0.3209043, 0.27360168)) * bufB[5] + mat4(vec4(-0.2597714, -0.47826275, 0.3691355, -0.17117473), vec4(-0.025592078, 0.13754718, -0.006254369, 0.18729903), vec4(0.07271743, 0.03899634, -0.1421065, -0.38434833), vec4(0.20295265, -0.01802309, 0.23910326, -0.17665018)) * bufB[6] + mat4(vec4(0.1438945, 0.52747536, -0.20964879, 0.17411323), vec4(0.07238048, -0.3544479, 0.4331109, 0.22122431), vec4(0.16574946, -0.37615642, 0.7764886, 0.22084807), vec4(0.40053132, 0.010338801, 0.83102477, 0.48566446)) * bufB[7];\nbufA[2] = vec4(0.01413025, -0.19814663, 0.069957666, -0.1588629) + mat4(vec4(0.18957008, 0.25140664, -0.25394118, 0.014872159), vec4(0.6912544, 0.0963686, -0.010283446, -0.33612928), vec4(-0.2312804, 0.08503222, 0.12757604, -0.0826961), vec4(-0.3960668, 0.09806034, -0.075252086, -0.10800047)) * bufB[0] + mat4(vec4(-0.11601322, -0.028494507, -0.010577731, -0.013212591), vec4(0.34389117, -0.058042154, 0.10956037, -0.28214002), vec4(0.18169802, 0.21576935, 0.26326773, -0.35482705), vec4(-0.59903973, 0.0107278675, 0.47354627, -0.109604605)) * bufB[1] + mat4(vec4(0.1709774, 0.14648339, 0.33232847, -0.24052246), vec4(0.12028126, 0.013051418, -0.020902235, 0.28683394), vec4(0.40692928, 0.18009524, -0.13043465, -0.02726534), vec4(0.36419228, -0.5065135, -0.29540628, -0.48957643)) * bufB[2] + mat4(vec4(-0.45675826, 0.15107417, -0.06825906, 0.09455472), vec4(0.4161082, -0.115257956, 0.15043281, 0.098253034), vec4(-0.042867452, 0.13718611, -0.23363647, -0.07228524), vec4(-0.17952964, -0.2507885, 0.30587974, 0.33789697)) * bufB[3] + mat4(vec4(-0.3046178, 0.2789865, 0.1497364, -0.072509184), vec4(-0.0072978814, 0.15832637, 0.22524266, -0.21263903), vec4(-0.35135105, -0.033463076, -0.10978693, 0.12920803), vec4(0.27624393, 0.08886374, 0.19778614, -0.061365407)) * bufB[4] + mat4(vec4(0.39979908, -0.33313414, 0.06025276, 0.12060081), vec4(-0.6834129, 0.587499, -0.23992357, -0.23248453), vec4(-0.19666447, 0.08293782, 0.1810286, -0.38289645), vec4(-0.72716653, 0.2211936, -0.03097142, -0.30328977)) * bufB[5] + mat4(vec4(-0.1708278, 0.3883469, -0.30018714, 0.11288531), vec4(0.3005291, -0.40614852, 0.03970975, 0.26847327), vec4(-0.23546903, 0.28752443, -0.23847374, 0.23236305), vec4(-0.16861035, 0.03594445, -0.061357435, 0.12125858)) * bufB[6] + mat4(vec4(-0.2822599, 0.22959277, -0.22317912, -0.21935283), vec4(0.24552618, -0.0625965, -0.03209757, 0.28044426), vec4(-0.52094126, 0.037595343, -0.07854814, 0.03236826), vec4(-0.0813481, -0.0072247046, 0.369988, 0.2163594)) * bufB[7];\nbufA[3] = vec4(-0.042774986, -0.55886066, -0.24642777, 0.18390726) + mat4(vec4(0.12787353, 0.078406475, 0.36317003, -0.1901944), vec4(0.13530329, 0.43892646, 0.044396315, 0.107408576), vec4(0.18387848, 0.19444744, 0.3957715, 0.31443268), vec4(0.5557142, -0.3179548, -0.28169566, 0.32299194)) * bufB[0] + mat4(vec4(0.090413235, -0.021062158, -0.34114406, -0.079396024), vec4(-0.19680719, 0.07648362, 0.1309153, -0.12497353), vec4(0.15177356, 0.14551869, 0.2611331, -0.008197726), vec4(0.070660084, -0.10508243, 0.020438079, 0.27034378)) * bufB[1] + mat4(vec4(-0.22863163, -0.12125039, -0.62515765, 0.1544146), vec4(0.34250176, 0.020434463, 0.27883717, 0.07181392), vec4(-0.36212286, 0.10548709, -0.016758576, -0.10920499), vec4(0.08366738, -0.718098, -0.20267305, 0.29864448)) * bufB[2] + mat4(vec4(-0.23874542, -0.29878384, 0.24388969, -0.17836668), vec4(0.23697035, 0.2082646, -0.116499506, 0.018628804), vec4(0.07245763, -0.04353994, -0.17120025, 0.28064126), vec4(0.05979372, -0.33778122, -0.4236907, 0.15861212)) * bufB[3] + mat4(vec4(-0.042890117, 0.56603676, -0.48623383, -0.14782578), vec4(-0.21008463, 0.44245967, 0.17384398, 0.07887723), vec4(0.0008928083, 0.068434305, 0.017530924, -0.32419482), vec4(-0.14250717, -0.017003225, 0.28323793, 0.22137298)) * bufB[4] + mat4(vec4(-0.19122896, -0.15047725, -0.03183736, 0.12312524), vec4(0.2243802, 0.3372562, 0.1949522, 0.057082295), vec4(-0.3055676, 0.042924795, -0.07419531, -0.39706996), vec4(-0.051237732, 0.038241725, -0.20733091, -0.039740577)) * bufB[5] + mat4(vec4(0.006627539, -0.021563603, -0.19681233, 0.1412315), vec4(-0.08875595, -0.01920298, 0.038687445, -0.08740073), vec4(0.30978313, 0.48629388, 0.3045601, -0.2738469), vec4(0.3823615, -0.07725112, -0.22567815, 0.23194513)) * bufB[6] + mat4(vec4(-0.13423869, -0.40980747, 0.43631607, 0.059128046), vec4(0.03180296, 0.37131846, 0.049863834, 0.098175496), vec4(0.2723287, 0.35754803, 0.6265448, -0.082978554), vec4(0.3331092, 0.4215118, 0.43091142, 0.393469)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 9 \nbufA[0] = vec4(0.2510268986225128, -0.10530571639537811, -0.21771205961704254, 0.0) + mat4(vec4(-0.04659845307469368, -0.03265337273478508, -0.023958519101142883, 0.0), vec4(-0.101434126496315, -0.09912846237421036, -0.11691778898239136, 0.0), vec4(0.0417294017970562, 0.06948017328977585, 0.05095406994223595, 0.0), vec4(0.06735315918922424, 0.01747855357825756, 0.023382235318422318, 0.0)) * bufB[0] + mat4(vec4(0.18643218278884888, 0.023792430758476257, -0.13909724354743958, 0.0), vec4(-0.006630886811763048, 0.017334815114736557, 0.012095863930881023, 0.0), vec4(0.029247760772705078, 0.001904970151372254, 0.003050580620765686, 0.0), vec4(-0.05051644518971443, -0.06651621311903, 0.00205358793027699, 0.0)) * bufB[1] + mat4(vec4(-0.10424099117517471, -0.14157579839229584, -0.0868704617023468, 0.0), vec4(0.10289725661277771, 0.059175554662942886, 0.10832810401916504, 0.0), vec4(0.14498861134052277, 0.0368017740547657, -0.006212505977600813, 0.0), vec4(0.031299617141485214, 0.043552152812480927, 0.0073524294421076775, 0.0)) * bufB[2] + mat4(vec4(0.05784415453672409, 0.00017283560009673238, 0.08075538277626038, 0.0), vec4(-0.05674897879362106, -0.04748173803091049, -0.11243990063667297, 0.0), vec4(0.09232810139656067, 0.0014680539024993777, -0.012788004241883755, 0.0), vec4(0.13345453143119812, 0.15293744206428528, 0.10277199745178223, 0.0)) * bufB[3] + mat4(vec4(-0.04535670951008797, -0.08856093138456345, -0.11278852075338364, 0.0), vec4(-0.1384236067533493, -0.09956283867359161, -0.07402560114860535, 0.0), vec4(0.12265322357416153, 0.12331648916006088, 0.08775624632835388, 0.0), vec4(0.122463658452034, 0.11096907407045364, 0.11136636883020401, 0.0)) * bufB[4] + mat4(vec4(-0.033073991537094116, -0.14953893423080444, -0.14307495951652527, 0.0), vec4(-0.16452163457870483, -0.16484352946281433, -0.14537054300308228, 0.0), vec4(0.10567266494035721, 0.12167291343212128, 0.11112666875123978, 0.0), vec4(0.11589740961790085, 0.0898909643292427, 0.08152113854885101, 0.0)) * bufB[5] + mat4(vec4(0.0853000208735466, 0.09608637541532516, 0.10024293512105942, 0.0), vec4(0.12005528807640076, 0.148329958319664, 0.14857587218284607, 0.0), vec4(0.06940969824790955, 0.03268490731716156, 0.03192070126533508, 0.0), vec4(-0.15807226300239563, -0.1769511103630066, -0.14539983868598938, 0.0)) * bufB[6] + mat4(vec4(-0.1369607299566269, -0.06103292107582092, 0.0111517533659935, 0.0), vec4(-0.1312755048274994, -0.1846066117286682, -0.17038322985172272, 0.0), vec4(-0.05222734808921814, -0.04680958390235901, -0.06643503904342651, 0.0), vec4(0.057400066405534744, 0.12882933020591736, 0.14456315338611603, 0.0)) * bufB[7];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.32*sin(iTime), 0.32*sin(0.5*iTime), 0.23*sin(2.*iTime), 0.23*sin(1.5*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 142, 142, 71353], [71355, 71355, 71412, 71462, 71906]], "test": "valid"}
{"id": "3dlXzs", "name": "ProcPlanets", "author": "thebeardphantom", "description": "Terrain", "tags": ["terrain"], "likes": 1, "viewed": 80, "published": "Public", "date": "1552418378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 1\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .4;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat remap(float value, float low1, float high1, float low2, float high2)\n{\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = vec2(\n        remap(uv.x, 0.0, 1.0, -1.0, 1.0),\n        remap(uv.y, 0.0, 1.0, -1.0, 1.0));\n    pos.x *= iResolution.x/iResolution.y;\n    \n    vec2 dir = normalize(pos);\n    float dist = length(pos);\n    float lowFreq = fbm(dir * 2.0) * 0.3;\n    float highFreq = (fbm(dir * 12.0) - 0.1) * dist;\n    float finalNoise = mix(lowFreq, lowFreq + highFreq, 0.12);\n    if(dist <= 0.2)\n    {\n        dist -= fbm(dir * 2.5 + iTime) * 0.055;\n    }\n    float albedoDist = dist - highFreq * 0.08;\n    float pixel = step(dist + finalNoise, 1.0);\n    vec3 color;\n    if(albedoDist > 0.965)\n    {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    else if(albedoDist > 0.92)\n    {\n        color = vec3(0.5, 0.5, 0.5);\n    }\n    else if(albedoDist > 0.7)\n    {\n        color = vec3(0.0, 0.4, 0.0);\n    }\n    else if(albedoDist > 0.28)\n    {\n        color = vec3(0.3, 0.2, 0.0);\n    }\n    else if(albedoDist > 0.15)\n    {\n        color = vec3(0.1, 0.05, 0.0);\n    }\n    else\n    {\n        color = mix(\n            vec3(0.6, 0.0, 0.0),\n        \tvec3(1.0, 1.0, 0.0),\n        \t(fbm(fragCoord * 0.06 + iTime * -0.5) + fbm(fragCoord * 0.06 + iTime)) / 2.0);\n    }\n    fragColor = vec4(color, 1.0) * pixel;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 134], [136, 214, 240, 240, 620], [640, 640, 664, 686, 940], [942, 942, 1018, 1018, 1088], [1090, 1090, 1145, 1195, 2431]], "test": "valid"}
{"id": "3dSSDR", "name": "logpolar mapping", "author": "FabriceNeyret2", "description": "cf [url]https://en.wikipedia.org/wiki/Log-polar_coordinates[/url]", "tags": ["2d", "spiral", "short", "logpolar"], "likes": 8, "viewed": 424, "published": "Public API", "date": "1553329917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define D smoothstep(3.,0., (1.-max(s.x,s.y)) / length(fwidth(p)) )\n// vec3(p,cos,sin): trick to get rid of angle derivative discontinuity \n#define D smoothstep(3.,0., (1.-max(s.x,s.y)) / length(fwidth(vec3(p.x,cos(p.y),sin(p.y)))) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O-=O;\n    vec2 R = iResolution.xy, \n         U = u+u-R,\n         p = vec2(log(length(U)/R.y)-.3*iTime, atan(U.y,U.x) ),\n        \n    s = .5+.5*cos( 30. * p );  // log-polar grid\n    O.r += D ;\n    \n    s = .5+.5*cos( 30. * p * mat2(1,-1,1,1) );\n    O.g += D;                  // diagonals of log-polar grid\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 237, 275, 275, 589]], "test": "valid"}
{"id": "3dsSWs", "name": "Rounding the Square", "author": "iq", "description": "Mapping the unit square into the unit disk, shown as a mesh here. I found [url=https://arxiv.org/ftp/arxiv/papers/1509/1509.06344.pdf]this paper[/url] and simplified their maths into v = maxcomp(abs(v))*normalize(v). Colors show amount of displacement.", "tags": ["2d", "circle", "map", "square"], "likes": 72, "viewed": 3257, "published": "Public API", "date": "1552556268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Converting the unit square into the unit circle, from\n// https://arxiv.org/ftp/arxiv/papers/1509/1509.06344.pdf \n// but I realized it could be much simplified.\n//\n// v = maxcomp(abs(v))*normalize(v)\n//\n// Also I developped an improvement over it to make it more\n// uniform.\n\n\n#define IMPROVED 1           // make 0 for faster approach\n\n//-----------------------------------------------\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat maxcomp( in vec2 v ) { return max(v.x,v.y); }\n\n// Take a point in the unit square [-1,1]^2 and map it\n// into a point in the unit disk\nvec2 square2circle( in vec2 v )\n{\n    #if IMPROVED==0\n    return maxcomp(abs(v))*normalize(v);\n    #else\n    return maxcomp(abs(v))*normalize(v*(2.0+abs(v)));\n    #endif\n}\n\nvec2 circle2square( vec2 v )\n{\n    #if IMPROVED==0\n    return v*length(v)/maxcomp(abs(v));\n    #else\n    return vec2(0.0);\n    #endif\n}\n\n\n//-----------------------------------------------\n\nfloat sdLineSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn dot2(pa-ba*h);\n}\n\nfloat sdPointSq( in vec2 p, in vec2 a )\n{\n    return dot2(p-a);\n}\n\n//-----------------------------------------------\n\nvec2 vertex( int i, int j, int num, float anim)\n{\n    // unit square\n    vec2 s = -1.0+2.0*vec2(i,j)/float(num);\n    \n    // unit circle\n    vec2 c = square2circle(s);\n        \n    // blend\n    return mix(c,s,anim);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // plane coords\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float w = 2.0/iResolution.y;\n    \n    // scale\n\tp *= 1.15;\n\tw *= 1.15;\n \n    // anim\n    float anim = smoothstep(-0.6,0.6,cos(iTime*2.0+0.0));\n    float show = smoothstep(-0.1,0.1,sin(iTime*1.0+3.4));\n    \n    // mesh: body\n    vec2 di = vec2(10.0);\n    const int num = 11;         // Make \"num\" odd. If even is desired, the \n\tfor( int j=0; j<num; j++ )  // normalize() in square2circle() should be\n\tfor( int i=0; i<num; i++ )  // protected against divisions by zero.\n    {\n        vec2 a = vertex(i+0,j+0,num,anim);\n        vec2 b = vertex(i+1,j+0,num,anim);\n        vec2 c = vertex(i+0,j+1,num,anim);\n        di = min( di, vec2(min(sdLineSq(p,a,b), \n                               sdLineSq(p,a,c)),\n                               sdPointSq(p,a)));\n    }\n    // mesh: top and right edges\n\tfor( int j=0; j<num; j++ )\n    {\n        vec2 a = vertex(num,j+0,num,anim);\n        vec2 b = vertex(num,j+1,num,anim);\n        vec2 c = vertex(j+0,num,num,anim);\n        vec2 d = vertex(j+1,num,num,anim);\n        di = min( di, vec2(min(sdLineSq(p,a,b), \n                               sdLineSq(p,c,d)),\n                           min(sdPointSq(p,a),\n                               sdPointSq(p,c))));\n    }\n    // mesh: top-right corner\n    di.y = min( di.y, sdPointSq(p,vertex(num,num,num,anim)));\n    di = sqrt(di);\n\n    \n    // background\n    vec3 col = vec3(1.0);\n    \n    // colorize displacement\n    vec2 q = square2circle(p);\n    vec2 p1 = mix(q,p,    anim);\n    vec2 p2 = mix(q,p,1.0-anim);\n    col = mix( col, 0.6 + 0.5*cos(length(p-p1)*15.0 + 2.5+vec3(0,2,4) ),\n               show*smoothstep(0.999,0.99,length(p2)) );\n    // draw mesh    \n    col *= 0.9+0.1*smoothstep(0.0,0.05,di.x);\n    col *= smoothstep(0.0,0.008,di.x);\n    col *= smoothstep(0.03,0.03+w,di.y );\n    \n    // vignette\n    col *= 1.0 - 0.15*length(p);\n\n    // output\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsSWs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[465, 516, 541, 541, 560], [561, 561, 589, 589, 612], [614, 702, 735, 735, 873], [875, 875, 905, 905, 1010], [1013, 1064, 1115, 1115, 1215], [1217, 1217, 1258, 1258, 1282], [1284, 1335, 1384, 1403, 1552], [1554, 1554, 1611, 1631, 3562]], "test": "valid"}
{"id": "3dSXD1", "name": "[twitch] Paper City", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and SHADOW_STEPS if too slow\nYou can find the original shader here: http://lezanu.fr/LiveCode/PaperCity.glsl\nInspired by https://www.shadertoy.com/view/tsjGRG", "tags": ["3d", "volumetric", "live", "twitch"], "likes": 73, "viewed": 1753, "published": "Public", "date": "1553553482", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and SHADOW_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/PaperCity.glsl\nInspired by https://www.shadertoy.com/view/tsjGRG\n*/\n\n#define MARCH_STEPS 60\n#define SHADOW_STEPS 10\n\n#define time iTime\nfloat PI=acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat box(vec3 p, vec3 s) {\n  vec3 ap=abs(p)-s;\n  //return length(max(vec3(0),ap)) + min(0, max(ap.x,max(ap.y,ap.z)));\n  return max(ap.x,max(ap.y,ap.z));\n}\n\nfloat tri(vec3 p, vec3 s) {\n  p.y=-p.y;\n  p.xz=abs(p.xz);\n  return max(max(-p.y-s.y, dot(p.xy,vec2(0.7))-s.x), p.z-s.z);\n}\n\nfloat cone(vec3 p, float a, float b) {\n  return max(length(p.xz)-p.y*a, p.y-b);\n}\n\nvec3 rep(vec3 p, vec3 s) {\n  return (fract(p/s+0.5)-0.5)*s;\n}\n\nvec2 rep(vec2 p, vec2 s) {\n  return (fract(p/s+0.5)-0.5)*s;\n}\n\nfloat rep(float p, float s) {\n  return (fract(p/s+0.5)-0.5)*s;\n}\n\nfloat house(vec3 p, float s) {\n  float t=tri(p+vec3(0,3,0)*s, vec3(1,1,3.5)*s);\n  t = min(t, box(p, vec3(2,2,3)*s));\n  return t;\n}\n\nfloat minitower(vec3 p) {\n  p.y+=5.0;\n  vec3 p2 = p;\n  if(abs(p2.x)<abs(p2.z)) p2.xz=p2.zx;\n  float t = min(house(p+vec3(0,3,0),0.5), house(p2, 1.0));\n  t = min(t, house(p-vec3(0,5,0),1.5));\n  return t;\n}\n\nfloat tower(vec3 p) {\n  p.y+=15.0;\n  vec3 p2 = p;\n  if(abs(p2.x)<abs(p2.z)) p2.xz=p2.zx;\n  float t = min(house(p+vec3(0,3,0),0.5), house(p2, 1.0));\n  t = min(t, house(p-vec3(0,5,0),1.5));\n  p2.x -= sign(p2.x)*5.0;\n  p2.x = abs(p2.x);\n  p2.z = abs(p2.z);\n  t = min(t, house(p2.zyx-vec3(2,8,2),0.3));  \n  t = min(t, house(p2-vec3(0,12,0),1.5));\n  return t;\n}\n\nfloat wall(vec3 p) {\n  \n  p.x -= cos(p.z*0.1)*2.0;\n  p.x -= sin(p.z*0.03)*3.0;\n  \n  vec3 rp=p;\n  rp.z = rep(rp.z, 5.0);\n  float w = box(rp+vec3(0,1,0), vec3(2,1,50));\n  rp.x = abs(rp.x)-2.0;\n  float m = box(rp-vec3(0,2,0), vec3(0.25,5,1.6));\n  return min(w, m);\n  \n}\n\nfloat field(vec3 p) {\n  vec3 p2 = p;\n  if(abs(p2.x)<abs(p2.z)) p2.xz=p2.zx;\n  \n  float tmp = box(p2, vec3(5,5,5));\n  float f = max(abs(tmp-4.0), -p.y-2.0);\n  f=min(f, box(p, vec3(7,0.5,7)));\n  \n  vec3 p3 = p;\n  p3.xz=rep(p3.xz, vec2(2.5));\n  \n  float a = box(p3, vec3(0.2,2,0.2));\n  a = min(a, cone(p3+vec3(0,4,0), 0.3,3.0));\n  f=min(f, max(a,tmp-3.8));\n  \n  return f;\n}\n\nfloat village(vec3 p) {\n  vec3 p2=p;\n  p2.xz = abs(p2.xz);\n  float w = wall(p);\n  p2.xz -= 23.0;\n  float t=tower(p2);\n  vec3 p3 = p;\n  p3.z = p3.z-4.5*sign(p.x);\n  p3.x = abs(p3.x)-25.0;\n  float f=field(p3);\n  \n  float res = t;\n  res = min(res, w);\n  res = min(res, f);\n  \n /*\n  p2.xz*=rot(0.3);\n  res = min(res, house(p2+vec3(13,0,0), 1));\n  p2.xz*=rot(0.6);\n  res = min(res, house(p2+vec3(18,1,-2.5), 1.5));\n  */\n  p.z = p.z+10.0*sign(p.x);\n  p.x = -abs(p.x);\n  res = min(res, minitower(p+vec3(29,1,0)));\n  \n  return res;\n}\n\nfloat map(vec3 p) {\n  \n  float t1=sin(length(p.xz)*0.009);\n  float s=12.0;\n  for(int i=0; i<6; ++i) {\n    p.xz=abs(p.xz)-s;\n    p.xz *= rot(0.55+t1+float(i)*0.34);\n    s /= 0.85;\n  }\n  p.x+=3.0;\n  \n  return min(village(p), -p.y);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist, 0.0, 1.0);\n}\n\nfloat noise(vec2 p) {\n  vec2 ip=floor(p);\n  p=smoothstep(0.0,1.0,fract(p));\n  vec2 st=vec2(67,137);\n  vec2 v=dot(ip,st)+vec2(0,st.y);\n  vec2 val=mix(fract(sin(v)*9875.565), fract(sin(v+st.x)*9875.565), p.x);\n  return mix(val.x,val.y,p.y);\n}\n\nfloat fractal(vec2 p) {\n  float d=0.5;\n  float v=0.0;\n  for(int i=0; i<5; ++i) {\n    v+=noise(p/d)*d;\n    d *= 0.5;\n  }\n  return v;\n}\n\nvec3 sky(vec3 r, vec3 l) {\n  float v=pow(max(dot(r,l),0.0),3.0);\n  \n  vec2 sphereuv = vec2(abs(atan(r.z,r.x))+time*0.03,atan(r.y,length(r.xz)));\n  \n  float skyn = fractal(sphereuv*vec2(5,10));\n  float skyn2 = fractal(sphereuv*vec2(5,10)*0.3-vec2(time*0.06,0));\n  skyn2=smoothstep(0.3,0.7,skyn2);\n  \n  vec3 blue = mix(vec3(0.5,0.5,0.8), vec3(0.0), skyn2*skyn);\n  \n  return mix(blue*0.2, vec3(1,0.7,0.4)*(skyn2*0.8+0.2), v);\n}\n\nvec3 sky2(vec3 r, vec3 l) {\n  float v=pow(max(dot(r,l),0.0),3.0);\n  \n  vec3 blue = vec3(0.5,0.5,0.8);\n  \n  return mix(blue*0.2, vec3(1,0.7,0.4), v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float t2=time+10.0;\n  vec3 s=vec3(0,0,-100);\n  s.yz *= rot(sin(t2*0.3)*0.2+0.5);\n  s.xz *= rot(t2*0.2);\n  vec3 t=vec3(0,30,60);\n  t.yz *= rot(sin(t2)*0.3-0.2);\n  t.xz *= rot(t2*0.32);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  //vec3 r=normalize(vec3(-uv, 0.7));\n  vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n  \n  \n  \n  vec3 p=s;\n  float dd=0.0;\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d=map(p);\n    if(abs(d)<0.001) break;\n    if(dd>500.0) {dd=500.0; break;}\n    p+=d*r*0.8;\n    dd+=d;\n  }\n  \n  float fog = 1.0-clamp(dd/500.0,0.0,1.0);\n  \n  vec3 col=vec3(0);\n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  float ao = (getao(p, n, 12.0) * 0.5 + 0.5) * (getao(p, n, 2.0) * 0.3 + 0.7) * (getao(p, n, 0.5) * 0.8 + 0.2);\n  \n  vec3 l=normalize(vec3(-1,-2,-2.5));\n  float f = pow(1.0-abs(dot(n,r)), 3.0);\n  \n  float shad = 1.0;\n  vec3 sp = p + n * 0.5 - r * 0.2;\n  for(int i=0; i<SHADOW_STEPS; ++i) {\n    float d=map(sp);\n    if(d<0.2) { shad = 0.0; break; }\n    sp+=d*l*3.0;\n  }\n  \n  col += max(0.0,dot(n,l)) * fog * vec3(1,0.7,0.4) * 1.5 * mix(0.0, ao*0.5+0.5, shad);\n  col += (-n.y*0.5+0.5) * ao * fog * vec3(0.5,0.5,0.8) * 0.5;\n  col += sky2(reflect(r,n), l)*f*10.0*fog * (0.5+0.5*shad);\n    \n  col += sky(r, l) * pow(dd*0.01,1.4);\n  \n  //col = vec3(shad);\n  \n  col = 1.0-exp(-col*2.5);\n  col = pow(col, vec3(2.3));\n  col = pow(col, vec3(0.4545));\n  \n  //col = vec3(skyn);\n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 384, 403, 403, 472], [474, 474, 501, 501, 629], [631, 631, 658, 658, 753], [755, 755, 793, 793, 836], [838, 838, 864, 864, 899], [901, 901, 927, 927, 962], [964, 964, 993, 993, 1028], [1030, 1030, 1060, 1060, 1160], [1162, 1162, 1187, 1187, 1366], [1368, 1368, 1389, 1389, 1724], [1726, 1726, 1746, 1746, 1992], [1994, 1994, 2015, 2015, 2364], [2366, 2366, 2389, 2389, 2891], [2893, 2893, 2912, 2912, 3124], [3126, 3126, 3167, 3167, 3215], [3217, 3217, 3238, 3238, 3457], [3459, 3459, 3482, 3482, 3592], [3594, 3594, 3620, 3620, 4018], [4020, 4020, 4047, 4047, 4170], [4173, 4173, 4230, 4230, 5907]], "test": "valid"}
{"id": "3dsXD7", "name": "CherryBlossom i guess", "author": "asdhyq", "description": "Sad", "tags": ["flower"], "likes": 0, "viewed": 44, "published": "Public", "date": "1551755966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(225./255., 95./255., 60./255.);\nvec3 pink = vec3(255./255.,192./255.,203./255.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float x = sin(iTime * 1.5 ) ;\n    \n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos = vec2(.5 * ratio, .5) ;\n    float dist = distance ( shapePos ,uv) ;\n    \n    vec2 shapePos2 = vec2(.5 * ratio, .5);\n    float dist2 = distance ( shapePos2,uv) ;\n    \n    uv -= shapePos;\n    \n    //get angle\n    float angle = atan(uv.y, uv.x)  +  x;\n    \n    float radius = cos(5. * angle  + iTime + x) * .3;\n  \tfloat radius2 = cos(5. *  atan(uv.y , uv.x) + iTime  + x) * .3;\n    float radius3 = cos(5. *  atan(uv.y , uv.x) + x) * .3;\n    \n    radius *= sin(iTime * .5);\n   radius2 *= sin(iTime * .5);\n    radius3 *= sin(iTime * .5);\n    \n    //vec3 color = mix (vec3(0.));\n    float value =   1.  - step(radius,dist);\n    float value2 = 1.  - step(radius2,dist2);\n    float value3 = 1.  - step(radius3,dist2);\n    \n    vec3 color = mix(pink,red ,value + value2 + value3);\n \n    \n  //  fragColor = vec4(value + value2 + value3 );\n    fragColor = vec4(color  ,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsXD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 155, 155, 1203]], "test": "valid"}
{"id": "3dSXDz", "name": "hypnocircles", "author": "abje", "description": "zooming infinitely into cylinders with logarithmic radius.", "tags": ["circles", "logarithmic"], "likes": 5, "viewed": 307, "published": "Public API", "date": "1553364130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define pi acos(-1.0)\n#define FAR 200.0\n#define STEPS 20\n\nfloat map(float c) {\n    \n    return (sin(c+5.0)-1.0)*4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0,0,-20.1);\n    vec3 rd = normalize(vec3(uv,1));\n\n    if (length(iMouse.xy) > 40.0) {\n        rd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n        rd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        ro.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n        ro.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    } else {\n        rd.yz *= rot(-0.5);\n        ro.yz *= rot(-0.5);\n        \n    }\n\n    float r = 1.0;\n\n    float e = 1.0/dot(rd.xz,rd.xz);\n\n    float a = dot(-ro.xz,rd.xz)*e;\n    vec2 p = ro.xz+rd.xz*a;\n    float b = dot(p,p);\n\n    float offset = iTime;\n    float freq = (0.03*iTime+1.0);\n    float limit = 0.2;\n    float cell = floor(log(max(length(ro.xz),limit))*freq-offset)+offset;\n    float dir = -1.0;\n    \n    float h = map(cell);\n    ro.y = max(ro.y,h+0.1);\n\n    vec3 n = vec3(0);\n    float d = 0.0;\n    for (int i = 0; i < STEPS; i++) {\n        \n        float h = map(cell);\n        \n        if ( ro.y+rd.y*d < h) {\n            n = vec3(-normalize(ro.xz+rd.xz*d)*dir,0).xzy;\n            break;\n        }\n        \n        float pln = 10000.0;\n        if (rd.y < 0.0) pln = -(ro.y-h)/rd.y;\n        \n        float cell2 = max(exp((cell+dir*0.5+0.5)/freq),0.0);\n        \n        float l = 0.0;\n        \n        if (max(b,limit*limit) <= cell2*cell2 || dir == 1.0) {\n            float c = sqrt((cell2*cell2-b)*e);\n            if (c+a > 0.0) {\n                d = a+c*dir;\n                \n                cell += dir;\n            } else {\n                dir = 1.0;\n            }\n        } else {\n            dir = 1.0;\n        }\n        \n        \n        if (pln < d) {\n            d = pln;\n            n = vec3(0,1,0);\n            cell -= dir;\n            break;\n        }\n        \n        if ( d > FAR ) break;\n        \n\n    }\n\n    /*if (b <= r*r) {\n        float c = sqrt((r*r-b)*e);\n        float len = a-c;\n        if (len > 0.0 && len < l) {\n            n = vec3((ro.xz+rd.xz*len)/r,0).xzy;\n            l = len;\n        }\n    }*/\n\n    vec3 col;\n    vec3 background = 0.2 + 0.1*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    if (d < FAR) {\n        vec3 p = ro+rd*d;\n        \n        cell -= offset;\n\n        col = sin(cell*vec3(5.3,0.3,6.7)+vec3(1.4,3.2,0.3))*0.5+0.5;\n        \n        float diff = max(0.1,dot(n,normalize(vec3(1))));\n        \n        col *= diff;\n        \n        col = mix(col,background,d/FAR);\n        //col = fract(p);\n    } else {\n        col = background;\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 143, 143, 183], [185, 185, 242, 292, 2825]], "test": "valid"}
{"id": "3dsXWf", "name": "Truncated Octahedral Voxels", "author": "dr2", "description": "Hollowed out sparsely-filled truncated octahedral grid ", "tags": ["octahedron"], "likes": 18, "viewed": 497, "published": "Public API", "date": "1552380800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Truncated Octahedral Voxels\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1\n\nvec3 vuOrg, ltPos, cMid;\nfloat dstFar, tCur, rVoid, fcId;\nconst float pi = 3.14159;\n\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv3 (vec3 p);\n\nvec3 FcVec (float k)\n{\n  vec3 u, e;\n  e = vec3 (1., 0., -1.);\n  if (k <= 3.) u = (k == 1.) ? e.xyy : ((k == 2.) ? e.yxy : e.yyx);\n  else if (k <= 5.) u = 0.5 * ((k == 4.) ? e.xxx : e.zxx);\n  else u = 0.5 * ((k == 6.) ? e.xzx : e.xxz);\n  return u;\n}\n\nbool CellOcc (vec3 p)\n{\n  return (length (p - vuOrg) > rVoid && Hashfv3 (17.3 * p) < 0.2);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cm, fv;\n  float dHit, dm, d, s;\n  cMid = sign (ro) * floor (abs (ro) + 0.5);\n  cm = mod (cMid, 2.);\n  if (dot (cm, vec3 (1.)) > 0.) cMid += step (abs (cm.yzx - cm.zxy), vec3 (0.5)) *\n     sign (ro - cMid);\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    p = cMid - (ro + dHit * rd);\n    fcId = 0.;\n    dm = dstFar;\n    for (float k = 1.; k < 8.; k ++) {\n      fv = FcVec (k);\n      s = dot (fv, rd);\n      if (s != 0.) {\n        d = dot (p + sign (s) * fv, fv)  / s;\n        if (d < dm) {\n          dm = d;\n          fcId = sign (s) * k;\n        }\n      }\n    }\n    cMid = floor (cMid + 2. * sign (fcId) * FcVec (abs (fcId)) + 0.5);\n    dHit += dm;\n    if (CellOcc (cMid) || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat ObjHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec3 p, cm, fv;\n  float dHit, dm, d, s;\n  cMid = sign (ro) * floor (abs (ro) + 0.5);\n  cm = mod (cMid, 2.);\n  if (dot (cm, vec3 (1.)) > 0.) cMid += step (abs (cm.yzx - cm.zxy), vec3 (0.5)) *\n     sign (ro - cMid);\n  dHit = 0.;\n  for (int j = 0; j < 20; j ++) {\n    p = cMid - (ro + dHit * rd);\n    fcId = 0.;\n    dm = dstFar;\n    for (float k = 1.; k < 8.; k ++) {\n      fv = FcVec (k);\n      s = dot (fv, rd);\n      if (s != 0.) {\n        d = dot (p + sign (s) * fv, fv)  / s;\n        if (d < dm) {\n          dm = d;\n          fcId = sign (s) * k;\n        }\n      }\n    }\n    cMid = floor (cMid + 2. * sign (fcId) * FcVec (abs (fcId)) + 0.5);\n    dHit += dm;\n    if (CellOcc (cMid) || dHit > rng) break;\n  }\n  return 0.3 + 0.7 * smoothstep (0.5 * rng, rng, dHit);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltDir;\n  float dstObj, sh, ltDist, lDotV, atten;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = - normalize (sign (fcId) * FcVec (abs (fcId)));\n    if (length (ro - cMid) > 0.9) col = HsvToRgb (vec3 (Hashfv3 (21.3 * cMid), 0.6, 1.));\n    else col = vec3 (1., 0.8, 0.8) * (0.6 + 0.4 * cos (4. * pi * (0.4 +\n       0.6 * Hashfv3 (17.3 * cMid)) * tCur)) * pow (0.7 - 0.3 * dot (rd, vn), 4.);\n    ltDir = ltPos - ro;\n    ltDist = max (length (ltDir), 0.1);\n    ltDir /= ltDist;\n    sh = ObjHitSh (ro + 0.01 * vn, ltDir, 15.);\n    atten = 1. / (1. + 0.05 * (ltDist - rVoid + 1.) * (1. + 0.2 * (ltDist - rVoid + 1.)));\n    lDotV = max (dot (ltDir, vn), 0.);\n    col = col * (0.2 + 0.8 * atten * sh * lDotV * lDotV) +\n       0.2 * atten * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 16.);\n    col += vec3 (0.5) * max (- dot (rd, vn), 0.) * (1. - smoothstep (0., 0.002,\n       abs ((dstObj - rVoid + 2.) / dstFar - 0.5 * mod (0.1 * tCur, 1.))));\n  } else {\n    col = vec3 (0.5, 0.5, 0.6) * (0.2 + 0.8 * rd.z * rd.z);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, ori, ca, sa, col;\n  vec2 canvas, uv;\n  float sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (mPtr.z > 0.) ori = vec3 (pi * mPtr.y, 2. * pi * mPtr.x, 0.22 * pi);\n  else ori = vec3 (0.017, 0.007, 0.019) * pi * tCur;\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.);\n  rVoid = 16.;\n  vuOrg = vec3 (0., 0., 8.);\n  ro = vuOrg + vuMat * vec3 (1.1);\n  ltPos = vuOrg + vuMat * vec3 (Rot2D (vec2 (5., 0.), 0.5 * tCur), 0.);\n  dstFar = 50.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 2.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsXWf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 314, 336, 336, 562], [564, 564, 587, 587, 656], [658, 658, 691, 691, 1423], [1425, 1425, 1471, 1471, 2240], [2242, 2242, 2277, 2277, 3386], [3388, 3388, 3444, 3444, 4654], [4656, 4656, 4680, 4680, 4797], [4799, 4799, 4829, 4829, 4942], [4976, 4976, 5000, 5000, 5065]], "test": "valid"}
{"id": "3dsXzj", "name": "midterms 9", "author": "jojo169", "description": "9", "tags": ["9"], "likes": 1, "viewed": 36, "published": "Public", "date": "1551700283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(1.,0.,0.);\nvec3 blue = vec3(0.,0.,1.);\nvec3 green = vec3(0,1.,0.);\nvec3 yellow = vec3(1.,1.,0.);\nvec3 black = vec3(0.,0.,0.);\nvec3 gray = vec3(.5,.5,.3);\n\nfloat quad(vec2 uv,float h, float w,float posX, float posY)\n{\n    float quad = step(posX-h ,uv.x)-step(posX+h,uv.x);\n\tquad = quad + step(posY-w,uv.y)-step(0.,uv.y)-step(posY+w,uv.y);\n    return quad;\n}\nfloat circle(vec2 uv,float distanceAa, float distanceAb,float size)\n{\n    \n    float val = distance(uv, vec2(distanceAa, distanceAb));\n    \n\tval = step(val, size);\n    \n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 value = mix(cos(iTime*-.9)+blue,yellow,circle(uv,sin(iTime)+.005,cos(iTime)+.003,.05));\n    value = mix(value,green,circle(uv,.15,.15,.5));\n    value = mix(value,red,circle(uv,.1,.3,.01));\n    value = mix(value,red,circle(uv,.6,.3,.01));\n    value = mix(value,red,circle(uv,.3,.25,.01));\n    value = mix(value,red,circle(uv,.45,.34,.01));\n    value = mix(value,gray,quad(uv,.5,.1,.5,.05));\n    \n\n    // Output to screen\n  \n    \n    fragColor = vec4(value,uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 232, 232, 372], [373, 373, 442, 442, 559], [561, 561, 618, 678, 1186]], "test": "valid"}
{"id": "3dXSDB", "name": "twisted thingy", "author": "wj", "description": "derived from Torus_Thingy_8  (https://www.shadertoy.com/view/lt2fDz) just by mucking a bit with the formula (and adding some music). used to create the \"twisted thingy\" audio visualization effect on my page http://www.wothke.ch/playmod/", "tags": ["3d", "torus", "knot", "audiovisualization"], "likes": 14, "viewed": 1470, "published": "Public", "date": "1551978565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*\n* Created by wj just by playing with the formula of the original version\n* \n* here: https://www.shadertoy.com/view/lt2fDz created by bal-khan\n*\n* (and by adding some music..=\n*/\n\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t400.\n#define E\t\t\t0.00001\n#define FAR\t\t\t50.\n#define PI\t\t\t3.14\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    pos.z = 4.5+1.5*sin(t*10.);    // add camera movement\n    \n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    col.xyz = ret_col*(1.-inter.x*.0125);\n    col += h * .4;\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    \n    // overall object placement\n    p.z += 25.;\n    rotate(p.xz, 1.57-.5*iTime );\n    rotate(p.yz, 1.57-.5*iTime );\n    \n    var = atan(p.x,p.y);\n    vec2 q = vec2( ( length(p.xy) )-9.,p.z);\n    float ttwists=0.75;\n    rotate(q, var*ttwists+iTime*0.4);\t\n    \n    vec2 oq = q ;\n    \n    q = abs(q)-vec2(3.,3.)-sin(q)*7.; // add some twists\n\n    float twist= 3.3;\t// twists the \"blue\" strands\n    float s= iTime*1.;   // add \"movement speed\" to the \"blue\" strands \n    if (oq.x < q.x && oq.y > q.y){\n    \trotate(q, ( (var*twist)+s)*3.14+s);\n    }else{\n        rotate(q, ( 0.28-(var*twist)+s)*3.14+s);\n    }\n    \n    float\toldvar = var;\n    ret_col = 1.-vec3(.350, .2, .3);\n    \n    q=q*0.2;\n\n    mind = length(q)+.5+1.05*(length(fract(q*.5*(3.+3.*sin(oldvar*1. - iTime*1.)) )-.5)-1.215);\n    // only the coloring:   \n    h -= vec3(-3.20,.20,1.0)*vec3(1.)*.0025/(.051+(mind-sin(oldvar*1. - iTime*2. + 3.14)*.125 )*(mind-sin(oldvar*1. - iTime*2. + 3.14)*.125 ) );\n    h -= vec3(1.20,-.50,-.50)*vec3(1.)*.025/(.501+(mind-sin(oldvar*1. - iTime*2.)*.5 )*(mind-sin(oldvar*1. - iTime*2.)*.5 ) );\n    h += vec3(.25, .4, .5)*.0025/(.021+mind*mind);\n\n    // add some music feedback\n    float f= texture(iChannel0, vec2(8. * 0.18, 0.0)).x * 0.3 + 0.05;\n    h+= f*.1 - 0.005;\n    \n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n            // log trick by aiekick\n\t        if (log(dist.y*dist.y/dist.x/1e5) > .0 || dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [{"id": "XsXGR8", "previewfilepath": "/media/previz/buffer01.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer01.png", "ctype": "buffer"}, {"id": "XdfGR8", "previewfilepath": "/media/previz/buffer03.png", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer03.png", "ctype": "buffer"}, {"id": "llXGDN", "previewfilepath": "https://soundcloud.com/dexterbritain/what-about-us-pink", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dexterbritain/what-about-us-pink", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXSDB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[632, 854, 882, 882, 1207], [1209, 1256, 1299, 1299, 1675], [1677, 1677, 1698, 1698, 3030], [3032, 3032, 3064, 3064, 3549], [3551, 3565, 3605, 3605, 3680], [3682, 3682, 3704, 3704, 3910]], "test": "error"}
{"id": "3dXSWf", "name": "Portfolio Shader 2", "author": "LCVillafania23", "description": "Clouds achieved through a combinations of random, noise, and a light blue background for the sky.", "tags": ["clouds"], "likes": 1, "viewed": 116, "published": "Public", "date": "1552302413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash(vec2 x){\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    x = x * k + k.yx;\n    return -1.0 + 2.0 * fract(16.0 * k * fract(x.x * x.y * (x.x + x.y)));\n}\n\nfloat gnoise( in vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\t\n\tvec2 u = f * f *(3.0 - 2.0 * f);\n\n    return mix(mix(dot(hash(i + vec2(0.0,0.0)), f - vec2(0.0,0.0)), \n                     dot( hash(i + vec2(1.0,0.0)), f - vec2(1.0,0.0)), u.x),\n                mix( dot( hash(i + vec2(0.0,1.0)), f - vec2(0.0,1.0)), \n                     dot( hash(i + vec2(1.0,1.0)), f - vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat random(in vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + \n            (c - a) * u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 8\nfloat fbm (in vec2 uv) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(uv);\n        uv *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 blue = vec3(0.3, 0.5, 1.0);\n\n    float offset = gnoise(uv + iTime / 6.0);\n\n    vec3 clouds = vec3(fbm((uv) * 5.0)) * 0.3;\n    vec3 finalColor = mix(blue, white, smoothstep(0.0 - offset, 0.4 - offset, clouds) - smoothstep(0.5 - offset, 0.7 - offset, clouds));\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 163], [165, 165, 190, 190, 576], [578, 578, 604, 604, 679], [681, 681, 706, 706, 1052], [1072, 1072, 1096, 1096, 1325], [1327, 1327, 1382, 1382, 1825]], "test": "valid"}
{"id": "3dXXWX", "name": "metaball merge color", "author": "kuma720", "description": "metaball", "tags": ["metaball"], "likes": 2, "viewed": 88, "published": "Public", "date": "1552286213", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdf(vec3 p,out vec3 col) {\n    \n    float len = 9999.;\n    vec3 lightDir = normalize(vec3(-0.4,1.,-1.));\n\n    //ball-center\n    float t1 = iTime * .9;\n    float t2 = iTime * 1.5;\n    vec3 center[4] = vec3[](\n        vec3( 0. , -0.25 , 0. ),\n    \tvec3( sin(t1) * .4 , -0.2 , cos(t1) * .12 ),\n    \tvec3( 0.12 , -0.2 + cos(t2) * .4 , sin(t2) * .2 ),\n    \tvec3( -0.12 , -0.2 + cos(t1) * .4 , sin(t1) * .2 )\n    );\n        \n    \n    //ball-color\n    vec3 ballcol[4] = vec3[](\n        vec3(0.,1.,0.),\n    \tvec3(0.,0.,1.),\n    \tvec3(1.,0.,0.),\n    \tvec3(1.,1.,1.)\n    );\n    \n    //meta-ball\n    float k = .3;\n    for ( int I=0 ; I<4 ; ++I ) {\n        \n        vec3 C = center[I];\n        float res = length( p - C ) - .07;\n        float h = clamp( 0.5 + 0.5*(res-len)/k, 0.0, 1.0 );\n        float k2 = - k*h*(1.0-h);\n        float len2 = mix( res, len, h ) + k2;\n        if ( len2 < len ) {\n            len = len2;\n            \n            vec3 normal = normalize( p - C );\n            float lp = dot(normal,lightDir) + .1;\n            vec3 tmpcol = ballcol[I] * lp;\n            col = mix( tmpcol , col , h ) + k2; \n        }\n        \n    }\n    \n    return len;\n}\n\n\n#define LOOP 10\nvec4 render( vec2 uv ) {\n    \n    //camera\n    vec3 eye = vec3( uv , -10. );\n    vec3 target = vec3(0.,0.,99999.);\n    vec3 dir = normalize( target - eye );\n    \n    //ray-march\n    vec3 col = vec3(0.,0.,0.);\n    vec3 p = eye;\n\tfor(int I=0;I<LOOP;++I) {\n        float l = sdf( p, col );\n\t    if( l < 0.01 ) {\n            return vec4(col,1.);\n  \t\t}\n        p += dir * l;\n    }\n\t\n    //sky-color\n    return vec4( 0.3,0.6,0.85, 1. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord /iResolution.x - vec2(0.5, 0.5);\n   fragColor = render( uv );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 1163], [1182, 1182, 1206, 1224, 1614], [1617, 1617, 1674, 1674, 1761]], "test": "valid"}
{"id": "3s2SRh", "name": "bilibili", "author": "mxr233", "description": "a sign of bilibili.", "tags": ["tv"], "likes": 5, "viewed": 170, "published": "Public", "date": "1552915155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdfDifference( const float a, const float b)\n{\n    return max(a, -b);\n}\nfloat sdfIntersection( const float a, const float b )\n{\n    return max(a, b);\n}\nfloat sdfUnion( const float a, const float b )\n{\n    return min(a, b);\n}\nfloat rectangle(vec2 uv, vec2 pos, float width, float height, float r) {\n\tvec2 size=vec2(width,height);\n    float tt=length(max(abs(uv-pos),size)-size)-r;\n    return 1.0-max(0.,abs(tt)-min(iResolution.x, iResolution.y)/50.);\n}\nfloat sdfLine(vec2 p0, vec2 p1, float width, vec2 coord)\n{\n    vec2 dir0 = p1 - p0;\n\tvec2 dir1 = coord - p0;\n\tfloat h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n\treturn (length(dir1 - dir0 * h) - width * 0.5);\n}\nfloat sdfEllipse(vec2 center, float a, float b, vec2 coord) { \n    float a2 = a * a; \n    float b2 = b * b; \n    return (b2 * (coord.x - center.x) * (coord.x - center.x) + a2 * (coord.y - center.y) * (coord.y - center.y) - a2 * b2)/(a2 * b2); \n}\nvec2 rotate(vec2 uv, float angle){\n    vec2 ruv;\n    ruv.x =   cos(angle)*uv.x + -sin(angle)*uv.y;\n    ruv.y =   sin(angle)*uv.x + cos(angle)*uv.y;\n    return ruv;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy*4.-1.5*iResolution.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat width = 0.25 * iResolution.x;\n\tfloat height = 0.25 * iResolution.x;\n    float minSize = min(iResolution.x, iResolution.y);\n\tfloat raduis=minSize/25.;\n    float linewidth=minSize/30.;\n    float halfwidth=minSize;\n\tuv.xy-=sin(iTime*50.)*2.;    \n\n\tvec4 background = vec4(1,1,1, 1.0);\n    vec4 linecolor = vec4(0,0,0,1.0);\n\tfloat t=rectangle(uv,center,0.7*width,0.5*height,raduis);\n\t// Rectangle\n\t\n    vec4 col=mix(background,linecolor,t);\n    vec2 rotateUV=uv-center;\n    t=rectangle(rotate(rotateUV,-0.02)+center,center,0.52*width,0.33*height,raduis);\n    col=mix(col,linecolor,t);\n    //sky line\n    float skyt=sdfLine(vec2(0.5,0.76)*iResolution.xy,vec2(0.61,0.97)*iResolution.xy,linewidth,uv);\n    col=mix(col,linecolor,1.0-skyt);\n    skyt=sdfLine(vec2(0.47,0.76)*iResolution.xy,vec2(0.35,0.9)*iResolution.xy,linewidth,uv);\n    col=mix(col,linecolor,1.0-skyt);\n    skyt=sdfLine(vec2(0.44,0.6)*iResolution.xy,vec2(0.4,0.5)*iResolution.xy,linewidth,uv);\n    col=mix(col,linecolor,1.0-skyt);\n    skyt=sdfLine(vec2(0.53,0.6)*iResolution.xy,vec2(0.6,0.5)*iResolution.xy,linewidth,uv);\n    col=mix(col,linecolor,1.0-skyt);\n    //half circle\n    float cirt1=sdfEllipse(vec2(0.41,0.2)*iResolution.xy,halfwidth/20.,halfwidth/20.,uv);\n    //float cirt2=sdfEllipse(vec2(0.45,0.44)*iResolution.xy,15.,18.,uv);\n    //float cirt=sdfDifference(cirt1,cirt2);\n   // cirt=sdfIntersection(cirt,uv.y-0.44*iResolution.y);\n    col=mix(col,linecolor,1.-cirt1);\n    cirt1=sdfEllipse(vec2(0.6,0.2)*iResolution.xy,halfwidth/21.,halfwidth/21.,uv);\n    col=mix(col,linecolor,1.-cirt1);\n    \n    cirt1=sdfEllipse(vec2(0.46,0.41)*iResolution.xy,halfwidth/15.,halfwidth/15.,uv);\n    float cirt2=sdfEllipse(vec2(0.46,0.41)*iResolution.xy,halfwidth/22.,halfwidth/22.,uv);\n    float cirt=sdfDifference(cirt1,cirt2);\n    float halfcirt1=sdfIntersection(cirt,uv.y-0.41*iResolution.y);\n    \n    cirt1=sdfEllipse(vec2(0.52,0.41)*iResolution.xy,halfwidth/15.,halfwidth/15.,uv);\n    cirt2=sdfEllipse(vec2(0.52,0.41)*iResolution.xy,halfwidth/22.,halfwidth/22.,uv);\n    cirt=sdfDifference(cirt1,cirt2);\n    float halfcirt2=sdfIntersection(cirt,uv.y-0.41*iResolution.y);\n    cirt=sdfUnion(halfcirt1,halfcirt2);\n    col=mix(col,linecolor,1.-cirt);\n\tfragColor =col;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2SRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 77], [78, 78, 133, 133, 157], [158, 158, 206, 206, 230], [231, 231, 303, 303, 457], [458, 458, 516, 516, 678], [679, 679, 740, 740, 924], [925, 925, 959, 959, 1090], [1091, 1091, 1148, 1148, 3464]], "test": "valid"}
{"id": "3s2SzW", "name": "Simple Page Peel Effect", "author": "droozle", "description": "Quick'n'dirty page peeling effect. Not meant to impress, so be gentle.", "tags": ["2d", "page", "turn", "peel"], "likes": 13, "viewed": 330, "published": "Public", "date": "1553092663", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 aspect = vec2( iResolution.x / iResolution.y, 1.0 );\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Define the fold.\n    vec2 origin = vec2( 0.6 + 0.4 * sin( iTime * 0.2 ), 0.5 + 0.5 * cos( iTime * 0.13 ) ) * aspect;\n    vec2 normal = normalize( vec2( 1.0, 2.0 * sin( iTime * 0.3 ) ) * aspect );\n\n    // Sample texture.\n    vec3 col = texture( iChannel0, uv ).rgb; // Front color.\n    \n    // Check on which side the pixel lies.\n    vec2 pt = uv * aspect - origin;\n    float side = dot( pt, normal );\n    if( side > 0.0 ) {\n        col *= 0.25; // Background color (peeled off).        \n            \n        float shadow = smoothstep( 0.0, 0.05, side );\n        col = mix( col * 0.6, col, shadow );\n    }\n    else {\n        // Find the mirror pixel.\n        pt = ( uv * aspect - 2.0 * side * normal ) / aspect;\n        \n        // Check if we're still inside the image bounds.\n        if( pt.x >= 0.0 && pt.x < 1.0 && pt.y >= 0.0 && pt.y < 1.0 ) {\n            vec4 back = texture( iChannel0, pt ); // Back color.\n            back.rgb = back.rgb * 0.25 + 0.75;\n            \n            float shadow = smoothstep( 0.0, 0.2, -side );\n            back.rgb = mix( back.rgb * 0.2, back.rgb, shadow );\n            \n            // Support for transparency.\n            col = mix( col, back.rgb, back.a );\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2SzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1496]], "test": "error"}
{"id": "3s2XWh", "name": "I LIKE SHINY THINGS, NO APOLOGY", "author": "kevs3d", "description": "There really isn't such a thing as too much SHINY.\n\nTwo reflection bounces used to create even MOAR SHINY.\n\nUses code by other authors - as credited in method comments.\nThis and others on my shader page: http://www.kevs3d.co.uk/dev/shaders", "tags": ["procedural", "noise", "raymarch", "shiny", "reflect"], "likes": 13, "viewed": 300, "published": "Public", "date": "1553617905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Distance field ray-marching demo - by Kevin Roast\n   Uses code by other authors - as credited in method comments.\n   http://www.kevs3d.co.uk/dev/shaders\n*/\n\n\n#define AO_SAMPLES 4\n#define RAY_DEPTH 512\n#define MAX_DEPTH 512.0\n#define DISTANCE_MIN 0.002\n#define PI 3.14159265\n\n#define ANTIALIAS_SAMPLES 1\n#define REFLECT 1\n\n#define FLOOR_YPOS 0.0\n\nconst bool rotateWorld = true;\nconst vec2 delta = vec2(DISTANCE_MIN, 0.0);\n\n\n#define HASHSCALE1 .1031\nfloat Hash(float p)\n{\n   vec3 p3  = fract(vec3(p) * HASHSCALE1);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract((p3.x + p3.y) * p3.z);\n}\n\n// unsmoothed psuedo random number noise - fine for this purpose (a single random per domain cell)\nfloat vnoise(in vec2 x)\n{\n   vec2 p = floor(x);\n   float n = p.x + p.y*57.0;\n   float res = Hash(n);\n   return res;\n}\n\nvec3 RotateY(vec3 p, float a)\n{\n   float c,s;\n   vec3 q=p;\n   c = cos(a);\n   s = sin(a);\n   p.x = c * q.x + s * q.z;\n   p.z = -s * q.x + c * q.z;\n   return p;\n}\n\nfloat fOpUnion(float a, float b, float r) {\n   vec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat Plane(vec3 p, vec3 n)\n{\n   return dot(p, n);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat length8(vec2 p)\n{\n   p = p*p; p = p*p; p = p*p;\n   return pow(p.x + p.y, 1.0/8.0);\n}\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nconst float DOMAIN = 5.0;\nfloat Map(vec3 p)\n{\n   vec3 q = vec3(mod(p.x, DOMAIN) - 0.5 * DOMAIN, p.y, mod(p.z, DOMAIN) - 0.5 * DOMAIN);\n\n   float f = vnoise( vec2( floor(p.x/DOMAIN)*DOMAIN, floor(p.z/DOMAIN)*DOMAIN ) );\n   float d;\n   if (f > 0.75) {\n      d = udRoundBox(vec3(q.x-(0.25*f), q.y-max(f, 0.1)+sin(iTime*f)*0.75+0.25, q.z+(f-0.75)), vec3(1.0-(f*0.5), max(f, 0.1), f), 0.025);\n   }\n   else if (f > 0.5) {\n      d = length(q-vec3(-0.15+f*0.25,0.75+sin(iTime+100.0*f), 0.0)) - (0.4+f);\n   }\n   else if (f > 0.25) {\n      d = sdTorus(vec3(q.x, q.y-sin(iTime*f*2.0)-0.75, q.z), vec2(f+0.33,f+0.05));\n   }\n   else {\n      d = sdTorus88(RotateY(vec3(q.x, q.y-sin(iTime*f*3.0)-1.0, q.z), cos(iTime*f*2.0)), vec2(f+0.4,f+0.05));\n   }\n   return d;\n}\n\nfloat Dist(vec3 pos)\n{\n   if (rotateWorld) pos = RotateY(pos, sin(iTime*0.15)*PI);\n   \n   return fOpUnion(\n      Plane(pos-vec3(0.,FLOOR_YPOS,0.), vec3(0.,1.,0.)),\n      Map(pos),\n      0.5\n   );\n}\n\nconst vec3 lightColour = vec3(2.5, 1.8, 1.9);\nconst float specular = 1.5;\nconst float specularHardness = 20.0;\nconst float diffuse = 0.05;\nconst float ambientFactor = 0.3;\n\n// Based on original by IQ\nfloat CalcAO(vec3 p, vec3 n)\n{\n   float r = 0.0;\n   float w = 1.0;\n   for (int i=1; i<=AO_SAMPLES; i++)\n   {\n      float d0 = float(i) * ambientFactor;   // NOTE: factor controls the 'spread' of the AO test and therefore overlap into domain cells\n      r += w * (d0 - abs(Dist(p + n * d0)));\n      normalize(n + vec3(0.0,0.5,0.0));\n      w *= 0.5;\n   }\n   return 1.0 - r;\n}\n\n// see http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat SoftShadow(vec3 ro, vec3 rd)\n{\n   float k = 20.0;            // softness\n   float res = 1.0;\n   float t = 0.01;            // min-t\n   for (int i=0; i<48; i++)\n   {\n      float h = Dist(ro + rd * t);\n      res = min(res, k*h/t);\n      t += h;\n      if (res < DISTANCE_MIN || t > 64.0) break; // max-t\n   }\n   return clamp(res, 0.0, 1.0);\n}\n\nvec3 GetNormal(vec3 pos, float s)\n{\n   if (pos.y < FLOOR_YPOS + DISTANCE_MIN)\n   {\n      return vec3(0.0,1.0,0.0);\n   }\n   else\n   {\n      vec3 n;\n      n.x = s - Dist(pos - delta.xyy);\n      n.y = s - Dist(pos - delta.yxy);\n      n.z = s - Dist(pos - delta.yyx);\n      return normalize(n);\n   }\n}\n\nconst vec3 lightDir = vec3(0.1313, 0.1209, 0.0518);\n\nvec3 Sky(vec3 rd)\n{\n   vec3 sky = mix( vec3(.7,.7,.8), vec3(0), exp2(-(1.0/max(rd.y,.01))*vec3(.4,.6,1.0)) );\n   float sunAmount = max(dot(rd, lightDir), 0.0);\n   sky += vec3(1.0,0.6,0.3) * sunAmount * sunAmount * .5 + vec3(1.0,0.6,0.3) * min(pow(sunAmount, 800.0), .3);\n   return sky;\n}\n\n// Fog routine - original by IQ\nvec3 Fog(vec3 rgb, vec3 rd, float distance)   // camera to point distance\n{\n   const float start = 20.0;  // start offset\n   const float b = 0.2;       // fog amount\n   float fogAmount = clamp(1.0 - exp((-distance+start)*b*b), 0.0, 1.0);\n   vec3 fogColor = Sky(rd);\n   return mix(rgb, fogColor, fogAmount);\n}\n\nvec4 Shading(vec3 pos, vec3 rd, vec3 norm, float d)\n{\n   vec3 light;\n   float ref;\n   \n   if (d != 0.0)\n   {\n      float fresnel = pow(1.0 - dot(normalize(-rd), norm), 5.0);\n\n      light = lightColour * max(0.0, dot(norm, lightDir));\n      vec3 heading = normalize(-rd + lightDir);\n      float spec = pow(max(0.0, dot(heading, norm)), specularHardness);\n      light = (diffuse * light * (1.0-fresnel)) + (spec * specular);\n\n      // object reflection\n      fresnel = mix(0.5, 1.0, fresnel);\n      ref = fresnel;\n\n      light *= SoftShadow(pos, lightDir);\n\n      float occ = CalcAO(pos, norm);\n      light *= occ;\n\n      // sky light with AO\n      float sky = clamp(0.5 + 0.5 * norm.y, 0.0, 1.0);\n      light += sky * vec3(0.24, 0.20, 0.24) * 0.5 * occ * occ;\n      \n      // indirect light bounce with AO\n      float ind = clamp(dot(norm, normalize(lightDir * vec3(-1.0,0.0,-1.0))), 0.0, 1.0);\n      light += ind * lightColour * 0.25 * occ * occ;\n   }\n   else\n   {\n      // Sky hit - distance test went to max\n      light = Sky(rd);\n   }\n   \n   return vec4(light, ref);\n}\n\n// Original method by David Hoskins\n#define GAMMA 0.8\n#define CONTRAST 1.1\n#define SATURATION 1.2\n#define BRIGHTNESS 1.2\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\trgb = pow(rgb, vec3(GAMMA));\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\treturn rgb;\n}\n\n// Camera function by TekF\n// Compute ray from camera parameters\nvec3 GetRay(vec3 dir, vec2 pos)\n{\n   pos = pos - 0.5;\n   pos.x *= iResolution.x/iResolution.y;\n   \n   dir = normalize(dir);\n   vec3 right = normalize(cross(vec3(0.,1.,0.),dir));\n   vec3 up = normalize(cross(dir,right));\n   \n   return dir + right*pos.x + up*pos.y;\n}\n\n// Ray March\nfloat March(vec3 ro, vec3 rd, inout vec3 p)\n{\n   float t = 0.0;\n   float d = 0.0;\n   for (int i=0; i<RAY_DEPTH; i++)\n   {\n      p = ro + rd * t;\n      float d = Dist(p);\n      if (abs(d) < DISTANCE_MIN)\n      {\n         return d;\n      }\n      t += d * 0.75;\n      if (t >= MAX_DEPTH) break;\n   }\n   return 0.0;\n}\n\n// Boing\nfloat MarchReflect(vec3 ro, vec3 rd, inout vec3 p)\n{\n   float t = 0.0;\n   float d = 0.0;\n   for (int i=0; i<RAY_DEPTH/2; i++)\n   {\n      p = ro + rd * t;\n      float d = Dist(p);\n      if (abs(d) < DISTANCE_MIN)\n      {\n         return d;\n      }\n      t += d * 0.75;\n      if (t >= MAX_DEPTH) break;\n   }\n   return 0.0;\n}\n\nconst vec3 cameraPos = vec3(0.0, 5.0, -12.0);\nconst vec3 cameraLookAt = vec3(16.0, -5.0, -1.2);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 cpos = vec3(cameraPos);\n   vec3 lookAt = cameraLookAt;\n   if (rotateWorld) {\n      //cpos.y = sin(iTime)*0.5 + 5.0;\n      cpos.y = sin(iTime*0.5)*4.0 + 8.0;\n      cpos.x = cos(iTime*.25)*8.0 + 4.0;\n      lookAt.y = -sin(iTime*0.75)*4.0 - 2.0;\n   }\n   \n   vec4 res = vec4(0.0);\n   vec2 p;\n   float d_ang = 2.*PI / float(ANTIALIAS_SAMPLES);\n   float ang = d_ang * 0.333;\n   float r = 0.333;\n   for (int i = 0; i < ANTIALIAS_SAMPLES; i++)\n   {\n      p = vec2((gl_FragCoord.x + cos(ang)*r) / iResolution.x, (gl_FragCoord.y + sin(ang)*r) / iResolution.y);\n      vec3 ro = cpos;\n      vec3 rd = normalize(GetRay(lookAt-cpos, p));\n      vec3 hit;\n\n      float d = March(ro, rd, hit);\n      float fogDistance = length(ro - hit);\n      vec3 fogRd = rd;\n      vec3 norm = GetNormal(hit,d);\n      vec4 shade = Shading(hit, rd, norm, d);\n#if REFLECT\n      shade.rgb *= 1.0 - shade.a;\n      if (shade.a != 0.0)     // reflection sample needed\n      {\n         // ray reflection - shift out again so not immediately hit same point\n         rd = reflect(rd, norm);\n         ro = hit + rd;\n         d = MarchReflect(ro, rd, hit);\n\n         norm = GetNormal(hit, d);\n         vec4 shade1 = Shading(hit, rd, norm, d);\n         if (shade1.a != 0.0)\n         {\n            // add in colour from another reflection march step\n            shade.rgb += shade1.rgb * shade.a * 0.5;\n\n            // ray reflection - shift out again so not immediately hit same point\n            rd = reflect(rd, norm);\n            ro = hit + rd;\n            d = MarchReflect(ro, rd, hit);\n\n            // add in colour from another reflection march step\n            norm = GetNormal(hit, d);\n            vec4 shade2 = Shading(hit, rd, norm, d);\n            shade.rgb += shade2.rgb * shade.a * 0.5;\n         }\n         else shade.rgb += shade1.rgb * shade.a;\n      }\n#endif\n      res.rgb += Fog(shade.rgb, fogRd, fogDistance);\n      ang += d_ang;\n   }\n   res.rgb /= float(ANTIALIAS_SAMPLES);\n   \n   fragColor = vec4(PostEffects(res.rgb, p), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2XWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 451, 472, 472, 590], [592, 691, 716, 716, 808], [810, 810, 841, 841, 970], [972, 972, 1015, 1015, 1102], [1104, 1104, 1133, 1133, 1156], [1158, 1158, 1189, 1189, 1276], [1278, 1278, 1323, 1323, 1363], [1365, 1365, 1398, 1398, 1463], [1465, 1465, 1488, 1488, 1555], [1556, 1556, 1591, 1591, 1658], [1686, 1686, 1705, 1705, 2411], [2413, 2413, 2435, 2435, 2610], [2785, 2812, 2842, 2842, 3185], [3187, 3257, 3293, 3293, 3602], [3604, 3604, 3639, 3639, 3901], [3956, 3956, 3975, 3975, 4243], [4245, 4277, 4352, 4352, 4585], [4587, 4587, 4640, 4640, 5658], [5660, 5781, 5818, 5818, 6047], [6049, 6114, 6147, 6147, 6379], [6381, 6394, 6439, 6439, 6707], [6709, 6718, 6770, 6770, 7040], [7139, 7139, 7196, 7196, 9210]], "test": "valid"}
{"id": "3s2XWR", "name": "Octoshape", "author": "abelu", "description": "A mystic creature from the depths. Made as an exercise to learn shapes and 2d transforms.", "tags": ["shapes", "tentacles", "octopus"], "likes": 6, "viewed": 468, "published": "Public API", "date": "1553439358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI              3.14159265359\n#define TWO_PI          6.28318530718\n#define HALF_PI         1.57079632679\n#define JOINTS_COUNT    12.0\n#define JOINTS_GLOW     0.16\n#define EYES_GLOW       0.014\n#define TENTACLES_COUNT 8.0\n#define PUPIL_OFFSET    0.01\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x, 0.0, 0.0, _scale.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle), cos(_angle));\n}\n\nfloat triangle(\n    in vec2 ps,\n    in float size\n) {\n   \tfloat N = 3.0;\n    float a = atan(ps.x,ps.y)+PI;\n    float r = TWO_PI/floor(N);\n    float d = cos(floor(.5+a/r)*r-a)*length(ps);\n    return 1.-smoothstep(size,size+JOINTS_GLOW,d);\n}\n\nfloat circle(\n    in vec2 ps,\n    in float radius,\n    in float glow\n) {\n    return 1.-smoothstep(radius,radius+glow,length(ps));\n}\n\nfloat joint(\n    in vec2 ps,\n    in vec2 tr,\n    in float s,\n    in float a\n) {\n    return triangle((ps+tr)*scale(vec2(s))*rotate2d(a),.1);\n}\n\nfloat tentacle(\n    in vec2 ps,\n    in float timeScale,\n    in float c\n) {\n    float tr = 0.;\n    float t = sin(iTime);\n    float a = 0.;\n    float d = mod(iTime*timeScale*PI,PI*2.);\n    vec2 p = vec2(0.);\n    for (float i = .0; i < JOINTS_COUNT; i++) {\n        tr += .1+t*.005;\n        p = vec2(-tr*.7,sin(d+PI*-tr)*.2*tr);\n        a = HALF_PI+(cos(d)*.5)*HALF_PI*tr;\n        c += joint(ps*scale(vec2(1.+i*.1)),p,3.+tr*2.,a)*(1.-tr*.5);\n    }\n    return c;\n}\n\nfloat ttentacle(\n    in vec2 position, \n    in float timeScale, \n    in float scaleRatio, \n    in float angle,\n    in float color\n) {\n    return tentacle(\n        position*scale(vec2(scaleRatio))*rotate2d(angle),\n        timeScale,\n        color\n    );\n}\n\nfloat eye(\n    in vec2 st, \n    in float timeOffset,\n    in float timeScale,\n    in float size, \n    in float c\n) {\n    float t = timeOffset+iTime*timeScale;\n    float o = floor(abs(sin(t*.4))/(1./3.));\n    vec2 pst = vec2(\n        st.x+size*.1+(step(1.,o)-step(2.,o)*2.)*PUPIL_OFFSET,\n        st.y-size*.2+step(1.,o)*PUPIL_OFFSET\n    );\n    return circle(st,size,EYES_GLOW) - \n        circle(st,size*.5,0.03)*.2 -\n        circle(pst,size*.05+.0005*sin(t),.01)*.7;\n}\n\nfloat tentacles(in vec2 st, in float c) {\n    float color = c;\n    for (float i = .0; i < TENTACLES_COUNT; i++) {\n        c += ttentacle(\n            st,\n            1.+i*.01,\n            1.+mod(i,4.)*.01,\n            PI*2./TENTACLES_COUNT*i + mod(i,3.)*.16,\n            color\n        );\n    }\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = gl_FragCoord.xy / iResolution.xy;\n  \tst.y *= iResolution.y / iResolution.x;\n    \n    st -= vec2(.5,.3);\n\n    float s = sin(iTime*2.)*2.;\n    float body = circle(vec2(st.x,st.y+s*.01),.1,.02);\n    float eyes = \n        eye(vec2(st.x+.05,st.y-.05+s*.005),1.,1.2,.020,.01) +\n        eye(vec2(st.x-.06,st.y-.01+s*.005),2.,1.4,.032,.01) +\n        eye(vec2(st.x+.03,st.y+.06+s*.005),3.,1.0,.024,.01) + \n        eye(vec2(st.x+.01,st.y-.01+s*.005),4.,1.6,.016,.01) +\n        eye(vec2(st.x-.04,st.y+.06+s*.005),5.,1.8,.022,.01) +\n        eye(vec2(st.x-.02,st.y-.06+s*.005),5.,1.8,.014,.01) +\n        eye(vec2(st.x+.07,st.y+.01+s*.005),6.,1.2,.020,.01);\n\n    // Output to screen\n    fragColor = vec4(\n        vec3(.0,.0,.1)+\n        (\n            vec3(.65+.15*s,.6+.3*s,.3)*body +\n            vec3(.7+.1*s,.65+.25*s,.3)*tentacles(st*rotate2d(s*.1),0.)*.75\n        )*(1.-eyes),\n        1.\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2XWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 260, 284, 284, 333], [335, 335, 363, 363, 450], [452, 452, 505, 505, 691], [693, 693, 765, 765, 824], [826, 826, 905, 905, 967], [969, 969, 1043, 1043, 1428], [1430, 1430, 1563, 1563, 1684], [1686, 1686, 1801, 1801, 2152], [2154, 2154, 2195, 2195, 2463], [2465, 2465, 2521, 2521, 3422]], "test": "valid"}
{"id": "3sBXDm", "name": "Swirll", "author": "bjwebb", "description": "A spiral.", "tags": ["spiral"], "likes": 3, "viewed": 251, "published": "Public API", "date": "1553958982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float r_2 = (uv.x - 0.5)*(uv.x - 0.5) + (uv.y - 0.5) * (uv.y - 0.5);\n    float radius = sqrt(r_2);\n    float angle = atan((uv.y - 0.5)/(uv.x - 0.5)); \n \n    float intensity = sin(-iTime*10. + radius*50. + angle*2.);\n\n    // Output to screen\n    fragColor = vec4(\n        intensity*vec3(0.0,1.0,1.0) + -intensity*vec3(1.0,0.0,0.0),\n        1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 500]], "test": "valid"}
{"id": "3sBXWw", "name": " Concentric Gradients\tLights", "author": "Carandiru", "description": "orig: https://www.shadertoy.com/view/llscW4\n\nhad an idea working with isometric lighting, see how light blending could look", "tags": ["light", "gradient", "isometric", "concentric"], "likes": 2, "viewed": 126, "published": "Public", "date": "1553910179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tOriginal by Simon Gladman | September 2017\n\n\tmodified for light blending test theory\n\n*/\n\nconst float stepWidth = 13.0; \n\nstruct HeightColorPair {\n    vec3 color;\n    vec3 pos;\n};\n   \nvec2 toIsoUV(in vec2 uv)\n{ \n    return( (vec2(uv.x + uv.y, uv.y - uv.x) * vec2(1.0f,1.0f)) );\n}\nvec2 toIso(in vec2 pos)\n{ \n    return( vec2(pos.x + pos.y, pos.y - pos.x) * vec2(1.0f,0.5f));\n}\n\nHeightColorPair sawtoothGradient(vec2 uv, vec2 offset, vec3 color) {\n   \n    \n    float len = length(toIsoUV(uv) - toIso(offset)); \n    float value = len * stepWidth;\n    value = smoothstep(stepWidth*-0.5, stepWidth*0.5, abs(mod(value*2.0f, 1.0f / stepWidth))); \n    value = value * 0.5 + 0.5;\n    value *= 1.0 - pow(len, 0.37);\n    \n    float height = 1.0 - floor(len * 2.0f * stepWidth) / stepWidth;\n    \n    return HeightColorPair(value * color, (vec3(uv.x + offset.x, height, uv.y + offset.y) * 0.5f + 0.5f)); \n}\n\nHeightColorPair topHeightColorStep(HeightColorPair a, HeightColorPair b) {\n    HeightColorPair result = a;\n    HeightColorPair major, minor;\n    if (b.pos.y > a.pos.y) {\n     \tresult.pos.y = b.pos.y;\n    \tmajor = b; minor = a;\n    }\n    else {\n        result.pos.y = a.pos.y;\n    \tmajor = a; minor = b;\n    }\n    result.color = b.color * (b.pos.y + (major.pos.y-minor.pos.y)) + a.color * (a.pos.y + (1.0f - (major.pos.y-minor.pos.y)));\n    \n    return result;\n}\n\nHeightColorPair topHeightColor(HeightColorPair a, HeightColorPair b) {\n            \n    HeightColorPair as, bs;\n    HeightColorPair gradient[2];\n    HeightColorPair step;\n    \n    const float inv_stepwidth = 1.0f;// / stepWidth;\n        \n   step = a;\n    \n    step.pos = a.pos + vec3(0.0,inv_stepwidth,0.0);\n    gradient[0] = topHeightColorStep(step, b);\n    \n    step.pos = a.pos + vec3(0.0,-inv_stepwidth,0.0);\n    gradient[1] = topHeightColorStep(step, b);\n    \n    as.color = gradient[1].color - gradient[0].color;\n    as.pos = gradient[1].pos - gradient[0].pos;\n    \n   step = b;\n    \n    step.pos = b.pos + vec3(0.0,inv_stepwidth,0.0);\n    gradient[0] = topHeightColorStep(a, step);\n    \n    step.pos = b.pos + vec3(0.0,-inv_stepwidth,0.0);\n    gradient[1] = topHeightColorStep(a, step);\n    \n    bs.color = gradient[0].color - gradient[1].color;\n    bs.pos = gradient[0].pos - gradient[1].pos;\n    \n    HeightColorPair result;\n    \n    result = topHeightColorStep(a, b);\n    vec3 gradient_a = mix(result.color, as.color, distance(result.pos, as.pos) / stepWidth);\n    vec3 gradient_b = mix(result.color, bs.color, distance(result.pos, bs.pos) / stepWidth);\n    vec3 gab0 = gradient_a * (abs(result.pos.y - as.pos.y) * 0.5f\n              + gradient_b * (abs(result.pos.y - bs.pos.y) * 0.5f));\n    \n    vec3 gab1 = gradient_a * (abs(result.pos.y - as.pos.y) * 0.5f\n              + gradient_b * (abs(result.pos.y - bs.pos.y) * 0.5f));\n    \n    result.color = mix(result.color, mix(mix(gradient_a,gab0,0.5f), mix(gradient_b,gab1,0.5f), 0.5f), 0.5f);\n    result.pos = mix(mix(result.pos, as.pos, 0.5f), mix(result.pos, bs.pos, 0.5f), 0.5f);\n\n    //result = as;\n    //result = bs;\n    \n    //result.color = mix(bs.color, as.color, 0.5f);\n    //result.pos = mix(bs.pos, as.pos, 0.5f);\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n    \n    float aRadius = (sin(iTime * 0.5) * 0.25) + 0.25; \n\tHeightColorPair a = sawtoothGradient(uv, \n                                         (vec2(cos(iTime) * aRadius, \n                                                    sin(iTime) * aRadius)),\n                                         vec3(1.0, 1.0, 0.0));\n    \n    float bRadius = (sin(iTime * 0.75) * 0.1) + 0.4; \n    HeightColorPair b = sawtoothGradient(uv, \n                                         (vec2(sin(iTime * 0.3) * bRadius, \n                                                    cos(iTime * 0.3) * bRadius)),\n                                         vec3(0.0, 1.0, 1.0));\n    \n    float cRadius = (cos(iTime * 0.25) * 0.3) + 0.1; \n    HeightColorPair c = sawtoothGradient(uv, \n                                         (vec2(cos(iTime * 0.7) * cRadius, \n                                                    sin(iTime * 0.7) * cRadius)),\n                                         vec3(1.0, 0.0, 1.0));\n    \n    vec3 color = topHeightColor(topHeightColor(a, b), c).color;  \n    \n    fragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 188, 214, 214, 283], [284, 284, 309, 309, 379], [381, 381, 449, 449, 897], [899, 899, 973, 973, 1360], [1362, 1362, 1432, 1432, 3172], [3174, 3174, 3231, 3231, 4362]], "test": "valid"}
{"id": "3sfSWj", "name": "Задание 1. Трассировка лучей", "author": "anna_antipina_321", "description": "Задание 1. Трассировка лучей", "tags": ["1"], "likes": 1, "viewed": 71, "published": "Public", "date": "1552149523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEP 100\n\nstruct Material {\n    vec4 ambient;\n\tvec4 diffuse;\n\tvec4 specular;\n\tfloat shininess;\n};\n    \nstruct Light{\n    vec3 pos;\n    vec4 color;\n    float ambientIntensity;\n    float diffuseIntensity;\n    float specularIntensity;\n    float range;\n};     \n    \nstruct Object{\n    int index;\n    float sd;\n    Material material;\n    vec4 color;\n    vec3 posOffset;\n};\n    \nMaterial planeMat = Material (vec4(0.2125,0.1275,0.054,1),\n                               vec4(0.714,0.4284,0.18144,1),\n                               vec4(0.0,0.0,0.0,1),\n                               5.6);   \nMaterial planeMat1 = Material (vec4(0.2125,0.1275,0.054,1),\n                               vec4(0.2,0.1,0.1,1),\n                               vec4(0.1,0.05,0.08,1),\n                               8.6);   \nMaterial bronze = Material(vec4(0.2125,0.1275,0.054,1),\n                               vec4(0.714,0.4284,0.18144,1),\n                               vec4(0.393548,0.271906,0.166721,1),\n                               12.6);\nMaterial brass = Material(vec4(0.329412,0.223529,0.027451,1),\n                              vec4(0.780392,0.568627,0.113725,1),\n                              vec4(0.492157,0.241176,0.407843,1),\n                              15.8974);\nObject objects[6];\n    \nLight lights[2];\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nObject Minimum(Object obj1, Object obj2){\n    if (obj1.sd < obj2.sd)\n        return obj1;\n    else\n        return obj2;\n}\n\nObject GetMinObj(vec3 p) \n{\n    vec3 currP = p;\n    currP.xz *= Rot(iTime);\n    objects[0].sd = sdPlane(p-objects[0].posOffset, vec4(0.,1.,0.,0.));\n    objects[1].sd = sdSphere(currP-objects[1].posOffset, .7);\n    objects[2].sd = sdBox(currP - objects[2].posOffset, vec3(0.5, 0.5, 0.5));\n    objects[3].sd = sdCapsule(currP - objects[3].posOffset, vec3(0,0.2,4), vec3(1,0.2,4), .3);\n    objects[4].sd = sdTorus(currP - objects[4].posOffset, vec2(0.4, 0.2));\n\tcurrP.yz *= Rot(1.6);\n    objects[5].sd = sdTriPrism(currP - objects[5].posOffset, vec2(0.3, 0.6));\n    Object result = Minimum(objects[0], objects[1]);\n    result = Minimum(result,objects[2]);\n    result = Minimum(result,objects[3]);\n    result = Minimum(result,objects[4]);\n    result = Minimum(result,objects[5]);\n    return result;\n}\n\nstruct RayMarchResult{\n\tObject obj;\n    float dist;\n    vec3 normal;\n};\n\nvec3 Normal (vec3 p)\n{\n    Object obj = GetMinObj(p);\n    float dist = obj.sd;\n    vec2 e = vec2(.01,0);\n    Object obj1,obj2,obj3;\n    obj1 = GetMinObj(p - e.xyy);\n    obj2 = GetMinObj(p - e.yxy);\n    obj3 = GetMinObj(p - e.yyx);\n    vec3 normal = dist - vec3(obj1.sd, obj2.sd, obj3.sd);\n    return normalize(normal);                    \n}    \n    \nRayMarchResult RayMarch (vec3 rayOrigin, vec3 rayDirection) \n{\n    float distFromOrigin = .0;\n    RayMarchResult result;\n    for (int i = 0; i < MAX_STEP; i++)\n    {\n        vec3 p = rayOrigin + distFromOrigin*rayDirection;\n        result.normal = Normal(p);\n        Object obj = GetMinObj(p);\n        result.obj = obj;\n        float currDist = obj.sd;\n        distFromOrigin += currDist;   \n        result.dist = distFromOrigin;\n        if ((currDist < 0.001) || (distFromOrigin > 500.))\n            break;\n    }\n    return result;\n}\n\nfloat shadow(vec3 p, vec3 rayToLight, float mint, float maxt){\n\tfloat t = mint;\n    for (int i = 0; i < 128; ++i) {\n        Object obj = GetMinObj(p + rayToLight * t);\n        float dist = obj.sd;\n        if (dist < 0.001)\n            return 0.0;\n        t += dist;\n\t\t\n\t\tif (t > maxt)\n\t\t\tbreak;\n    }\n    return 1.0;\n}\n\nfloat shadowSoft(vec3 p, vec3 rayToLight, float mint, float maxt, float k){\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for (int i = 0; i < 128; ++i) {\n        Object obj = GetMinObj(p + rayToLight * t);\n        float dist = obj.sd;\n        if (dist < 0.001)\n            return 0.0;\n\t\tres = min(res, k*dist/t);\n        t += dist;\n\t\t\n\t\tif (t > maxt)\n\t\t\tbreak;\n    }\n    return res;\n}\n\nvec4 Shade(vec3 p, vec3 normal) {\n   \tfloat comb = 0.1;\n    vec4 res = vec4(vec3(comb), 1.0);\n    for (int i = 0; i<2; i++) {\n\t\tvec3 rayToLight = lights[i].pos - p;\n\t\tfloat dist = length(rayToLight);\n\t\trayToLight = normalize(rayToLight);\n\t\tfloat shade;\n\t\tif (i == 0) \n            shade = shadow(p, rayToLight, 0.01, dist);\n\t\telse\n            shade = shadowSoft(p, rayToLight, 0.0625, dist, 8.0);\n\t\n\t\tif (shade > 0.0){\n\t\t\tfloat diffuse = 2.0 * max(0.0, dot(normal, rayToLight));\n\t\t\tfloat attenuation = 1.0 - pow(min(1.0, dist/lights[i].range), 2.0);\n\t\t\tres += diffuse * attenuation * shade * lights[i].color;\n        }\n    }\n\treturn res;\n}\n\nvec4 LightRay (vec3 p)\n{\n    Object obj = GetMinObj(p);\n    vec4 result = vec4(0.0,0.0,0.0,0.0);\n    for (int i = 0; i<2; i++) {\n  \n    \tvec4 ambient = lights[i].ambientIntensity * lights[i].color;\n        \n        vec3 lightRay = normalize(p-lights[i].pos);\n    \tvec3 normal = Normal(p);\n        float diffuseFactor = clamp(dot(normal,-lightRay), 0.0, 1.0);\n        vec4 diffuse = diffuseFactor * lights[i].color;\n        \n        vec3 lightReflect = normalize(reflect(lightRay, normal));\n        float specularFactor = pow(max(0.0, dot(p, lightReflect)),obj.material.shininess);\n        vec4 specular = lights[i].specularIntensity * lights[i].color * obj.material.specular * specularFactor;\n        float distance = length(p - lights[i].pos);\n  \t\tfloat pointFactor = 1.0 / pow(distance, 2.);\n        result += pointFactor * obj.color * (ambient + diffuse + specular);\n    }\n   \n    return result;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Object plane;\n    plane.index = 0;\n    plane.color = vec4(0.0,0.1,0.3,1.0);\n    plane.material = planeMat;\n    plane.posOffset = vec3(0., 0.0, .0);\n    objects[0] = plane;\n    \n    Object sphere;\n    sphere.index = 1;\n    sphere.color = vec4(0.2,0.5,0.7,1.0);\n    sphere.material = brass;\n    sphere.posOffset = vec3(1., 1.7, -.1);\n    objects[1] = sphere;\n    \n    Object box;\n    box.index = 2;\n    box.color = vec4(0.3,0.3,0.,1.);\n    box.material = bronze;\n    box.posOffset = vec3(2, .0, .0);\n    objects[2] = box;\n    \n    Object capsule;\n    capsule.index = 3;\n    capsule.color = vec4(0.7,0.0,0.1,1.);\n    capsule.material = planeMat1;\n    capsule.posOffset = vec3(0.0, 0.1, -3.0);\n    objects[3] = capsule;\n    \n    Object torus;\n    torus.index = 4;\n    torus.color = vec4(0.2,0.2,0.6,1.);\n    torus.material = bronze;\n    torus.posOffset = vec3(0.3, .2, -1.);\n    objects[4] = torus;\n    \n    Object triPrism;\n    triPrism.index = 5;\n    triPrism.color = vec4(0.0,0.6,0.6,1.);\n    triPrism.material = brass;\n    triPrism.posOffset = vec3(1.0, 0.0, 0.4);\n    objects[5] = triPrism;\n    \n    lights[0] = Light(vec3(1.0, 3.2,2.0), vec4(0.6,0.0,0.0, 1.0), 35.8, 35.8,0.6, 5.0);\n    lights[1] = Light(vec3(-3.0,1.7,3.0), vec4(0.0,0.8,1.0, 1.0), 16.2,16.2,0.1, 6.0);\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 rayOrigin = vec3(1., 2.0, -5.0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y-.2, 1.0));\n    \n    RayMarchResult result = RayMarch(rayOrigin, rayDirection);\n    vec3 fragmentPos = rayOrigin + result.dist*rayDirection;\n    vec4 shade = Shade(fragmentPos, result.normal);\n    vec4 pointLight = LightRay(fragmentPos) + shade;\n\n    fragColor = vec4(pointLight);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1301, 1301, 1334, 1334, 1365], [1367, 1367, 1402, 1402, 1426], [1428, 1428, 1480, 1480, 1607], [1609, 1609, 1642, 1642, 1707], [1709, 1709, 1740, 1740, 1890], [1892, 1892, 1928, 1928, 2015], [2017, 2017, 2036, 2036, 2112], [2115, 2115, 2156, 2156, 2236], [2238, 2238, 2265, 2265, 3034], [3109, 3109, 3131, 3131, 3449], [3459, 3459, 3521, 3521, 3993], [3995, 3995, 4057, 4057, 4313], [4315, 4315, 4390, 4390, 4692], [4694, 4694, 4727, 4727, 5332], [5334, 5334, 5358, 5358, 6234], [6240, 6240, 6297, 6297, 8016]], "test": "valid"}
{"id": "3sfXDS", "name": "Mashgraf_2019_1", "author": "Polina", "description": "Sport", "tags": ["raymarching"], "likes": 2, "viewed": 75, "published": "Public", "date": "1552175463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 30.\n#define SURF_DIST .01\n\nvec4 Sphere = vec4(1.0, 2., 9, 2);\nvec3 Torus_s = vec3(2.5, 2.5, 8.0);\nvec2 Torus_r = vec2(1.2, 0.35);\nvec3 Torus_s_1 = vec3(3, 1.5, 8.0);\nvec2 Torus_r_1 = vec2(1.0, 0.4);\n\nvec4 Sphere_1 = vec4(-2.0, 0.7, 4.0, 0.82);\nvec4 Box_d = vec4(-2.0, 0.7, 4.0, 0.65);\nfloat Box_k = .0;\nvec3 Cylinder_s_1 = vec3(-2.0, 0.7, 4.0);\nvec2 Cylinder_h_1 = vec2(0.3, 0.8);\nvec3 Cylinder_s_2 = vec3(-2.0, 0.7, 4.0);\nvec2 Cylinder_h_2 = vec2(0.3, 0.8);\nvec3 Cylinder_s_3 = vec3(-2.0, 0.7, 4.0);\nvec2 Cylinder_h_3 = vec2(0.3, 0.8);\n\nvec3 Capsule_a = vec3(-2, 2, 4);\nvec3 Capsule_b = vec3(0.0,0.2,4);\nfloat Capsule_r = 0.2; \nvec3 Cylinder_s = vec3(1.4,0.4,3.0);\nvec2 Cylinder_h = vec2(0.2, 0.4);\nvec3 Ellipsoid_s = vec3(1.0,0.4,3.0);\nvec3 Ellipsoid_r = vec3(0.2, 0.4, 0.4);\nvec3 Ellipsoid_s_1 = vec3(1.8,0.4,3.0);\nvec3 Ellipsoid_r_1 = vec3(0.2, 0.4, 0.4);\n\n\nfloat sdSphere(vec3 p, vec4 s)\n{\n\treturn length(p-s.xyz)-s.w;\n}\n\nfloat sdTorus(vec3 p, vec3 c, vec2 r)\n{\n\tp -=c;\n    vec2 q = vec2(length(p.xy)-r.x,p.z);\n\treturn length(q)-r.y;\n}\n\nfloat udBox(vec3 p, vec4 d, float k)\n{\n    return length(max(abs(p-d.xyz)-d.w,0.0))- k;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h )- 0.2;\n}\n\nfloat sdCylinder1(vec3 p, vec3 s, vec2 h)\n{\n    p -= s;\n    vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder2(vec3 p, vec3 s, vec2 h)\n{\n    p -= s;\n    vec2 d = abs(vec2(length(p.yx),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder3(vec3 p, vec3 s, vec2 h)\n{\n    p -= s;\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid(vec3 p, vec3 s, vec3 r)\n{\n    p -= s;\n    return (length(p/r) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat opBlend(vec3 p, float d1, float d2, float k)\n{\n    float res = exp(-k*d1) + exp(-k*d2);\n    return -log(res)/k;\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat opS(float d1, float d2)\n{\n    return max(d1,-d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat GetDist(vec3 p)\n{\n    float pd = p.y + 0.02;\n\n    float d = min(min(min(min(\n        opBlend(p, sdEllipsoid(p, Ellipsoid_s, Ellipsoid_r),\n        \topBlend(p, sdEllipsoid(p, Ellipsoid_s_1, Ellipsoid_r_1),\n        \t\tsdCylinder1(p, Cylinder_s , Cylinder_h), 40.), 40.),\n        sdCapsule(p, Capsule_a, Capsule_b, Capsule_r)),\n\t\topS(opI(udBox(p,  Box_d,  Box_k), sdSphere(p, Sphere_1)),\n\t\t\topU(sdCylinder1(p, Cylinder_s_1, Cylinder_h_1),\n\t\t\t\topU(sdCylinder2(p, Cylinder_s_2, Cylinder_h_2),\n\t\t\t\t\tsdCylinder3(p, Cylinder_s_3, Cylinder_h_3))\t\n\t\t))),\n\t\topBlend(p, sdSphere(p, Sphere), sdTorus(p, Torus_s, Torus_r), 30.)),\n        pd);\n    \n//    vec4 Sp = vec4(0, 2. + abs(0.3*sin(iTime+5.0)),9,2);\n// \tfloat k = min(sdSphere(p, Sp), pd);\n    return d;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 a = vec2(.01, 0);\n    float d = GetDist(p);\n    vec3 n = d - vec3(GetDist(p-a.xyy),GetDist(p-a.yxy),GetDist(p-a.yyx));\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n\tfor(int i=0; i<MAX_STEPS; i++)\n    {\n\t\tvec3 p = ro + dO * rd;\n\t\tfloat dS = GetDist(p);\n\t\tdO += dS;\n\t\tif(dS<SURF_DIST || dO>MAX_DIST) break;\n\t}\n\treturn dO;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n    float a = 0.0;\n    float b = 1.0;\n    for( int i=0; i < 5; i++ )\n    {\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 c =  n * h + p;\n        float d = GetDist(c);\n        a += -(d - h) * b;\n        b *= 0.95;\n    }\n    return clamp(1.0-3.0*a, 0.0, 1.0) * 0.40 * clamp(0.5+0.5*n.y, 0.0, 1.0);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lp = vec3(2, 6, 2);\n    lp.xz += vec2(sin(iTime), cos(iTime)) * 2.;    \n    vec3 l = normalize(lp - p);\n    vec3 n = GetNormal(p);\n    vec3 np = p;\n    \n    float d = 0.05;\n    float rl = 1.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        if (d > length(lp - p)) break;\n        np = p + l * d;\n    \tfloat k = GetDist(np);\n        if (k < SURF_DIST * 0.1)\n        {\n            rl = 0.0;\n            break;\n        }\n        d += k;\n        rl = min(rl, 20. * k / d);\n    }\n    \n\tfloat dif = clamp(dot(n, l) / (length(lp - p) * length(lp - p)), 0., 1.);\n\tdif *= 20. * rl;\n    \n  //  float s = RayMarch(p + n * SURF_DIST * 2., l);\n  //  if (s < length(lp - p)) dif *= rl;\n    \n    float ao = calcAO(p, n);\n\n    return dif + ao;\n}\n\nvec3 Color(vec3 p)\n{\n    if(sdCapsule(p, Capsule_a, Capsule_b, Capsule_r) <= 0.02)\n    {\n        return vec3(1,1,0.6);\n    }\n    if(opBlend(p, sdSphere(p, Sphere), sdTorus(p, Torus_s, Torus_r), 30.) <= 0.02)\n    {\n        return vec3(0.1,0.2,0.3);\n    }\n    if(opBlend(p, sdEllipsoid(p, Ellipsoid_s, Ellipsoid_r),\n        \topBlend(p, sdEllipsoid(p, Ellipsoid_s_1, Ellipsoid_r_1),\n        \t\tsdCylinder1(p, Cylinder_s , Cylinder_h), 40.), 40.) <= 0.02)\n    {\n        return vec3(0.4,0.5,0.6);\n    }\n    if(udBox(p,  Box_d,  Box_k) <= 0.02)\n    {\n        return vec3(1,0.7,0);\n\t}\n    if(p.y <= 0.2)\n    {\n        if(sin(p.x * 20.) <= 0.) return vec3(0, 1, 0.5); \n        if(sin(p.z * 20.) <= 0.) return vec3(0, 1, 0);\n        return vec3(1, 1, 0);\n    }\n    return vec3(1,1,1);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord -.5*iResolution.xy)/iResolution.y;    \n    vec3 col = vec3(0, 1.0, 3.0 * xy.y);\n\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize (vec3(xy.x, xy.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    if (d <= MAX_DIST)  \n    {\n        vec3 p = ro + rd * d;\n\t\tfloat dif = GetLight(p);\n\t\tcol = Color(p) * dif;\n    }\n    \n    fragColor = vec4 (col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfXDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[901, 901, 933, 933, 964], [966, 966, 1005, 1005, 1079], [1081, 1081, 1119, 1119, 1170], [1172, 1172, 1222, 1222, 1337], [1339, 1339, 1382, 1382, 1497], [1499, 1499, 1542, 1542, 1657], [1659, 1659, 1702, 1702, 1817], [1819, 1819, 1862, 1862, 1932], [1934, 1934, 1986, 1986, 2053], [2055, 2055, 2086, 2086, 2111], [2113, 2113, 2144, 2144, 2170], [2172, 2172, 2205, 2205, 2230], [2232, 2232, 2255, 2255, 2984], [2986, 2986, 3010, 3010, 3162], [3164, 3164, 3198, 3198, 3375], [3377, 3377, 3407, 3407, 3720], [3722, 3722, 3746, 3746, 4490], [4492, 4492, 4512, 4512, 5268], [5275, 5275, 5332, 5332, 5713]], "test": "valid"}
{"id": "3sfXRj", "name": "Issues - Don Toliver", "author": "IsaacAndersen", "description": "Testing out soundcloud input. Random vectors for each fft freq. I took the background noise (FBM) from The Shader Book!\n\nFair warning: My CPU has been running really hot while testing this. Not sure if it's the for-loops or the frequent texture access.", "tags": ["musicsynth"], "likes": 3, "viewed": 453, "published": "Public", "date": "1553987981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float line(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 a = p-p0; // the vector that we want to project on b\n    vec2 b = p1-p0; // this line is our goal.\n    \n    vec2 proj = clamp((dot(a,b)/dot(b,b)),0.0,1.0)*b; // vector projection of a onto b\n    vec2 rejc = a-proj; // vector rejection or distance in other words\n    \n    return smoothstep(0.0,1.2,1.0-dot(rejc, rejc)*1e4);\n} // stolen: https://www.shadertoy.com/view/4d3fWr\n\nvec2 random12(float i) {\n    return normalize(vec2(sin(329.34+131.8*sin(722.1*i+8.23)),\n                sin(494.34+2871.1*sin(431.1*i+415.39))));\n}\n        \nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = ( U - 0.5*R) / R.y;\n    float t = iTime/2.;\n    \n    float angle1 = (3.1415)* (t/4.0);\n        \n    float s1 = sin(angle1);\n    float c1 = cos(angle1);\n\n    uv *= mat2(c1, -s1, s1, c1);\n    \n    \n  \tvec2 bgUV = uv * 10.;\n    \n\tvec3 col = vec3(124,41,212)/255.0;\n   \n    \n    \n    float m = texture( iChannel0, vec2(1.,0.25) ).x;;\n    \n    float col_1 = -fbm(bgUV + vec2(t,0.)+fbm(bgUV + t));     \n    \n\tcol += col_1;\n    \n    vec3 col2 = vec3(0);\n\n    float numChannels = 16.; // all 512 seems overkill\n    float maxFreq = 0.;\n    for(float i = 0.; i < 1.; i += 1./numChannels) {\n        float fft  = texture( iChannel0, vec2(i,0.25) ).x;\n        \n        for(float j = 0.; j < 64./numChannels;j+= 1.) {\n            vec2 segment = random12(i+j)*fft;\n            col2 += line(uv, vec2(0),segment*fbm(segment+t))*fft;\n        }\n        \n    }\n    \n    col2 *= 0.4 + 0.6*sin(18.*smoothstep(-1.,1.,m)*(1.0-length(uv)));\n    \n    col += col2;\n\t\n\t// output final color\n\tO = vec4(col,1.0);\n}", "image_inputs": [{"id": "Mtf3D4", "previewfilepath": "https://soundcloud.com/dontoliver/issues", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dontoliver/issues", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 372], [373, 423, 447, 447, 570], [580, 580, 608, 608, 716], [718, 796, 823, 823, 1205], [1230, 1230, 1256, 1256, 1594], [1596, 1596, 1637, 1637, 2665]], "test": "error"}
{"id": "3sjSDw", "name": "Jellyshell", "author": "OliverSchaff", "description": "Another go on transparency and self-glow. Based on Shane's https://www.shadertoy.com/view/ll2SRy\nChange angle with mouse.", "tags": ["3d", "raymarching", "transparency"], "likes": 20, "viewed": 811, "published": "Public", "date": "1554057123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on a shader by Shane\n// https://www.shadertoy.com/view/ll2SRy\n// almost all the code comes from his shader. It's a very good resource!\n\n#define PI 3.14159265359\n\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    //return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.0,0.5),vec3(1.0,1.0,1.0),vec3(0.2,0.33,0.67) );\n\n}\n\n// iq's distance functions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat sdUnion_s( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 carToPol(vec3 p) {\n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n\n// 2D rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat map( vec3 pos ){\n    \n    vec3 p2 = vec3(1.7*sin(-0.5*iTime),0.9*cos(-0.5*iTime),0.3*cos(-0.5*iTime));\n    float d2 = sdSphere( pos-p2, 0.2);\n    vec3 p3 = vec3(1.9*sin(-0.5*iTime+2.5),0.3*cos(-0.5*iTime-0.5),0.9*cos(-0.9*0.5*iTime));\n    float d3 = sdSphere( pos-p3, 0.2);\n    vec3 p4 = vec3(1.9*sin(-0.5*iTime+1.5),-0.3*cos(-0.6*iTime-4.5),0.3*cos(-0.4*iTime));\n    float d4 = sdSphere( pos-p4, 0.2);\n    float d00 = sdUnion_s(d2,d3,0.2);\n    \n    float d0 = sdUnion_s(d00,d4,0.2);\n\n    vec3 pol = carToPol(pos);\n    \n    float d1 = sdSphere( pos, 1.0 );\n    float wave = 0.25*sin(5.*(pol.y))*sin(2.0*pol.z);\n    d1 = opOnion(d1+wave, 0.001);\n    \n    return sdUnion_s(d1,d0,0.3);\n    \n}\n\nvec3 selfColor(vec3 pos) {\n    vec3 pol = carToPol(pos);\n    return spectrum(1.0*pol.z/PI/2.0+0.5*pol.y/PI);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec3 ro = vec3( 5.0*cos(0.2*iTime+20.5), 0.0, 5.0*sin(0.2*iTime+20.5));\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    float aa = 1.0/min(iResolution.y,iResolution.x);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0);  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy, 3.0) ); // 3.0 is the lens length\n    \n    // rotate camera with mouse\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\trd = rot * rd;\n\tro = rot * ro;\n    vec3 col = vec3(1), sp;\n    \n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n\tfloat t=0., layers=0., d, aD;\n    \n    // Surface distance threshold. Smaller numbers give a sharper object. Antialiased with aa\n    float thD = .3*sqrt(aa); \n    \n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n\tfor(int i=0; i<80; i++)\t{\n        \n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if(layers>20. || col.x<0. || t>8.) break;\n        \n        // Current ray postion\n        sp = ro + rd*t;\n\t\t\n        d = map(sp); // Distance to nearest point in the cube field.\n        \n        // If we get within a certain distance of the surface, accumulate some surface values.\n        // Values further away have less influence on the total.\n        //\n        // aD - Accumulated distance. I interpolated aD on a whim (see below), because it seemed \n        // to look nicer.\n        //\n        // 1/.(1. + t*t*.25) - Basic distance attenuation. Feel free to substitute your own.\n        \n         // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d))/thD;\n        \n        // If we're within the surface threshold, accumulate some color.\n        // Two \"if\" statements in a shader loop makes me nervous. I don't suspect there'll be any\n        // problems, but if there are, let us know.\n        if(aD>0.) { \n            // Smoothly interpolate the accumulated surface distance value, then apply some\n            // basic falloff (fog, if you prefer) using the camera to surface distance, \"t.\"\n            // selfColor is the color of the object at the point sp\n            vec3 sc = selfColor(sp);\n            col -= sc*(aD*aD*(3. - 2.*aD)/(1. + t*t*2.25)*4.5); \n            layers++;\n        }\n\n\t\t\n        // Kind of weird the way this works. I think not allowing the ray to hone in properly is\n        // the very thing that gives an even spread of values. The figures are based on a bit of \n        // knowledge versus trial and error. If you have a faster computer, feel free to tweak\n        // them a bit.\n        t += max(abs(d)*.5, thD*0.8); \n\t}\n    \n    // I'm virtually positive \"col\" doesn't drop below zero, but just to be safe...\n    col = max(col, 0.);\n    \n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjSDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 242, 310, 310, 353], [355, 355, 379, 379, 576], [578, 605, 640, 640, 664], [666, 666, 717, 717, 750], [752, 752, 798, 798, 891], [893, 893, 916, 916, 1031], [1033, 1061, 1092, 1092, 1248], [1250, 1250, 1272, 1272, 1945], [1947, 1947, 1973, 1973, 2057], [2059, 2059, 2123, 2123, 2301], [2303, 2303, 2357, 2357, 5374]], "test": "valid"}
{"id": "3sjSzm", "name": "Super Simple Rgb Crown", "author": "Oggy", "description": "Rgb Crown but even shorter ⍨\nMay be interesting to put trigonometric functions into operator arrays (+,-,*,/)\nThanks to FabriceNeyret2!", "tags": ["rgb", "trigonometry", "operators"], "likes": 1, "viewed": 309, "published": "Public API", "date": "1553271766", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14\n\nvoid mainImage(out vec4 O, vec2 u) \n{\n    vec2 R = iResolution.xy,\n         U = -( 2.*u - R ) / R.y;\n\n    O = 1.- sqrt( U.y + cos(tan(U.x) + vec4(0, pi, pi * 9.42,0 ) + iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 54, 54, 196]], "test": "valid"}
{"id": "3sjXDh", "name": "Drop Impact on a Solid Surface", "author": "MoltenQwartz", "description": "Simulation of water droplets hitting a solid surface.\nWe can have a pretty good close form solution for the profile of a drop impacting and spreading on a solid surface", "tags": ["simulation", "water", "droplet", "impact"], "likes": 2, "viewed": 167, "published": "Public", "date": "1553626211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://people.maths.bris.ac.uk/~majge/retractionPOF.pdf\n// http://www.off-ladhyx.polytechnique.fr/people/josserand/papier/annrev.pdf\n// https://www.researchgate.net/publication/258661354_Spreading_dynamics_of_drop_impacts\n\nconst int NDroplets = 30;\nconst vec2 dropletUVPos[NDroplets] = vec2[](\nvec2(0.436031,0.501581), vec2(0.423547,0.111569), vec2(0.453239,0.26699), \nvec2(0.815673,0.924419), vec2(0.0226986,0.313017), vec2(0.174258,0.453433),\nvec2(0.408085,0.233295), vec2(0.91921,0.474745), vec2(0.0135368,0.911714),\nvec2(0.778153,0.390637), vec2(0.257558,0.0772851), vec2(0.569454,0.832701),\nvec2(0.262737,0.211211), vec2(0.30801,0.471577), vec2(0.781463,0.392764), \nvec2(0.278776,0.908572), vec2(0.51161,0.479434), vec2(0.523552,0.221627),\nvec2(0.988079,0.741381), vec2(0.178634,0.155069), vec2(0.586289,0.823556),\nvec2(0.660606,0.889636), vec2(0.519263,0.563728), vec2(0.474654,0.487724),\nvec2(0.974624,0.0858092), vec2(0.605884,0.444089), vec2(0.790726,0.0957065),\nvec2(0.867111,0.367446), vec2(0.792375,0.319052), vec2(0.392994,0.0308541));\n    \n    \nconst float deltaTime[NDroplets] = float[](\n16.2616, 14.1047, 12.7014, 17.219, 16.4117, 16.5616, 18.3943, \n19.1071, 17.9323, 19.1383, 12.7135, 16.6305, 13.1771, 16.4899,\n15.4864, 12.3044, 15.9527, 18.3372, 12.268, 18.2772, 14.1241,\n16.9782, 12.1193, 17.3486, 13.0258, 16.317, 12.8056, 16.94, 13.0454,\n17.7878);\n\nconst float dropletSizesDelta[NDroplets] = float[](\n0.522874, 0.768016, 0.424533, 0.40368, 0.981766, 0.9371, 0.86986,\n0.0205862, 0.0598045, 0.960639, 0.458194, 0.205621, 0.769871,\n0.626017, 0.604965, 0.529476, 0.852081, 0.0480453, 0.112271,\n0.192868, 0.325125, 0.571701, 0.551602, 0.916609, 0.958534,\n0.0347382, 0.653168, 0.823736, 0.584742, 0.679072);\n\n//#define displayNormalMap\n#define normalStrength 20.0\n#define simulationSpeed 5.0\n#define dropletSizes  20.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float globalH = 0.0;\n    const int NDroplets = 10;\n\n    for(int i = 0; i < NDroplets; i++)\n    {\n        vec2 uv_droplets = dropletUVPos[i];\n        float r = length(uv_droplets-uv);\n        r *= 20.0 / dropletSizesDelta[i];\n\n        \n        float t = mod(simulationSpeed * iTime, deltaTime[i]);\n        \n        \n        float h = 1.0/(t*t) * 1.0/pow(1.0 + 0.625*(r/t)*(r/t),6.0);\n        globalH += h;//min(globalH+h,1.0);\n    }\n\tglobalH = min(globalH,1.0);\n    \n    float dHdx = normalStrength*dFdx(globalH);\n    float dHdy = normalStrength*dFdy(globalH);\n\tvec3 N = vec3(dHdx,dHdy,1.0);\n    N = normalize(N);\n\n    // Output to screen\n    fragColor = vec4(globalH);\n    #ifdef displayNormalMap\n        fragColor = vec4(0.5*N+0.5,0.0);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1729, 1841, 1898, 1948, 2744]], "test": "valid"}
{"id": "3sjXDm", "name": "Raytracing Quadratic Bezier 3D", "author": "bloxard", "description": "Analytical solution for ray tracing 3D quadratic bezier curves.\nIntersection between a ray and a 3D quadratic bezier is calculated once, rather than calculating the distance between a point and a 3D quadratic bezier multiple times while stepping forward.", "tags": ["3d", "raytracing", "bezier", "intersection", "analytical", "quadratic"], "likes": 12, "viewed": 499, "published": "Public", "date": "1554057905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Per Bloksgaard/2019\n// Analytical solution for ray tracing 3D quadratic bezier curves.\n// Intersection between a ray and a 3D quadratic bezier is calculated once, rather than calculating\n// the distance between a point and a 3D quadratic bezier multiple times while stepping forward.\n\n#define PI 3.14159265358979\n#define HALFPI 1.57079632679\n\nconst float thickness = 35e-3;\n\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2(float a, float b, float c)\n{\n\tfloat p = b-a*a/3., p3 = p*p*p;\n\tfloat q = a*(2.*a*a-9.*b)/27.+ c;\n\tfloat d = q*q+4.*p3/27.;\n\tfloat offset = -a / 3.;\n\tif(d>0.)\n\t{ \n\t\tfloat z = sqrt(d);\n\t\tvec2 x = (vec2(z,-z)-q)*0.5;\n\t\tvec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n\t\treturn vec2(offset + uv.x + uv.y);\n\t}\n\tfloat v = acos(-sqrt(-27./p3)*q/2.)/3.;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\treturn vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// How to resolve the equation below can be seen on this image.\n// http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\nvec3 intersectQuadraticBezier(vec3 p0, vec3 p1, vec3 p2) \n{\n\tvec2 A2 = p1.xy - p0.xy;\n\tvec2 B2 = p2.xy - p1.xy - A2;\n\tvec3 r = vec3(-3.*dot(A2,B2), dot(-p0.xy,B2)-2.*dot(A2,A2), dot(-p0.xy,A2)) / -dot(B2,B2);\n\tvec2 t = clamp(solveCubic2(r.x, r.y, r.z), 0., 1.);\n\tvec3 A3 = p1 - p0;\n\tvec3 B3 = p2 - p1 - A3;\n\tvec3 D3 = A3 * 2.;\n\tvec3 pos1 = (D3+B3*t.x)*t.x+p0;\n\tvec3 pos2 = (D3+B3*t.y)*t.y+p0;\n\tpos1.xy /= thickness;\n\tpos2.xy /= thickness;\n\tfloat pos1Len = length(pos1.xy);\n\tif (pos1Len>1.)\n\t{\n\t\tpos1 = vec3(1e8);\n\t}\n\tfloat pos2Len = length(pos2.xy);\n\tif (pos2Len>1.)\n\t{\n\t\tpos2 = vec3(1e8);\n\t}\n\tpos1.z -= cos(pos1Len*HALFPI)*thickness;\n\tpos2.z -= cos(pos2Len*HALFPI)*thickness;\n\treturn (length(pos1) < length(pos2)) ? vec3(pos1Len,pos1.z,t.x) : vec3(pos2Len,pos2.z,t.y);\n}\n\n// Convert HSL colorspace to RGB. http://en.wikipedia.org/wiki/HSL_and_HSV\nvec3 HSLtoRGB(in float h, in float s, in float l)\n{\n\tvec3 rgb = clamp(abs(mod(h+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n\treturn l+s*(rgb-0.5)*(1.-abs(2.*l-1.));\n}\n\nmat3 inverseView(vec2 a)\n{\n    vec2 c = cos(a);\n    vec2 s = sin(a);\n    return mat3(c.y,0.,-s.y,s.x*s.y,c.x,s.x*c.y,c.x*s.y,-s.x,c.x*c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 s = (-iResolution.xy+2.*gl_FragCoord.xy)/iResolution.y;\n\tvec3 vCamPos = vec3(0.0,1.1,-1.2-sin(iTime*0.35)*0.5);\n\tvec3 vCamTarget = vec3(0.,0.5,0.);\n\tvec3 vCamForward = normalize(vCamTarget-vCamPos);\n\n\tvec3 vCamRight = normalize(cross(vCamForward,vec3(0.,1.,0.)));\n\tvec3 vCamUp = normalize(cross(vCamRight,vCamForward));\n\tvec3 vRayDir = normalize(s.x*vCamRight+s.y*vCamUp+vCamForward*1.5);\n\tmat3 m = inverseView(vec2(asin(-vRayDir.y),atan(vRayDir.x, vRayDir.z)));\n\n\tvec3 bRes = vec3(1e4,1e4,0.);\n\tfloat bI = 0.;\n\tfor (float i=1.; i<19.; i+=1.)\n\t{\n\t\tfloat t = (iTime+i*0.15+11.)*0.5;\n\t\tvec3 p0 = vec3(sin(0.15-t*0.74)*2.0,cos(t*-1.17)*2.0,0.61+sin(0.3+t*1.71)*0.5);\n\t\tvec3 p1 = vec3(cos(t*-0.85)*2.13,sin(-t*0.432)*2.134,0.61+cos(0.2+-t*0.64)*0.5);\n\t\tvec3 p2 = vec3(sin(0.45-t*1.72)*2.,cos(t*1.331)*1.972,0.61+sin(0.9-t*0.53)*0.5);\n\t\tp1 += vec3(1e-1)*(1.-abs(sign(p1*2.-p0-p2)));\n\t\tvec3 lRes = intersectQuadraticBezier((p0-vCamPos)*m, (p1-vCamPos)*m, (p2-vCamPos)*m);\n\t\tif (lRes.y > 0.0 && bRes.y > lRes.y)\n\t\t{\n\t\t\tbRes = lRes;\n\t\t\tbI = i;\n\t\t}\t    \n\t}\n\tfloat alpha = 1.-clamp(bRes.x*0.9,0.,1.);\n\tvec3 color = HSLtoRGB(bRes.z*2.+bI/19.*6.,1.,alpha);\n\tfloat t = max(-2./vRayDir.y,0.);\n\tif (t < bRes.y && vRayDir.y < 0.)\n\t{\n\t\tvec3 pos = vCamPos + vRayDir*t;\n\t\tvec2 grid = 5.7-pow(vec2(1.4),abs(vec2(0.5)-fract(pos.xz*4.))*10.2);\n\t\tvec3 c = vec3(clamp(min(grid.x,grid.y),0.,1.));\n\t\tcolor = mix(c*clamp(1.-t*0.15,0.,1.),color*0.5,alpha);\n\t}\n\tfragColor = vec4(color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 489, 534, 534, 946], [948, 1082, 1141, 1141, 1853], [1855, 1930, 1981, 1981, 2086], [2088, 2088, 2114, 2114, 2229], [2231, 2231, 2286, 2286, 3758]], "test": "valid"}
{"id": "3sjXRz", "name": "Purple Spin", "author": "BradyInstead", "description": "Created for a contract for Club Transcendia - https://clubtranscendia.com/\nThe exposed variables are meant to be altered within the Unity editor (after I ported this to Cg), but you can play around and see what they do.", "tags": ["noise", "displacement", "psychedelic"], "likes": 1, "viewed": 202, "published": "Public", "date": "1552718177", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Exposed Variables\nfloat SPEED = -.5;\nfloat ROTATION_SPEED = .5;\nfloat RIPPLE_SPEED = 20.;\nfloat RIPPLE_FREQUENCY = 40.;\nfloat RIPPLE_AMOUNT = .4;\nfloat NOISE_SCALE = 25.;\nfloat HUE = 2.0;\nfloat HUE_ROTATION = -.4;\nfloat LIQUIFY_AMOUNT = 3.0;\nfloat LIQUIFY_SIZE = 1.0;\nfloat BRIGHTNESS = 3.5;\n\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec2 rotateUV(vec2 uv, float rotation, vec2 mid)\n{\n    return vec2(\n      cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,\n      cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y\n    );\n}\n\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Variables\n    float t = iTime * SPEED;\n    float unModTime = t * .5;\n    float time = unModTime + sin(t);\n    \n    // Coords\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Center Coords\n    uv.x -= iResolution.x/iResolution.y * .5;\n    uv.y -= .50;\n    float ripple = sin(unModTime*RIPPLE_SPEED + RIPPLE_FREQUENCY*distance(uv, vec2(0.))) * RIPPLE_AMOUNT;\n    uv *= NOISE_SCALE + ripple;\n    \n    // UV Transformations\n    uv = abs(uv);\n    uv = rotateUV(uv, unModTime*ROTATION_SPEED, vec2(0));\n    uv = abs(uv +5.);\n    \n    // Liquify\n    vec2 luv = uv * LIQUIFY_SIZE;\n    uv += cnoise(vec3(luv.x, luv.y, unModTime*10.)) * LIQUIFY_AMOUNT;\n\n    // Color\n    float col = cnoise(vec3(uv.x, uv.y, unModTime));\n    col*= BRIGHTNESS;\n    col = min(col,1.0) - .5;\n    \n    // Contrast Color\n    float colorNoise = cnoise(vec3(uv.x, uv.y, unModTime));\n    colorNoise = min(col, 1.0);\n    \n    vec3 color_OUT = hueShift(vec3(1.,.5,0.0), colorNoise * HUE_ROTATION + ripple*.5) + col;\n    color_OUT = hueShift(color_OUT, HUE);\n\n    // Output to screen\n    fragColor = vec4(color_OUT,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 351, 372, 372, 409], [410, 410, 437, 437, 485], [486, 486, 505, 505, 541], [543, 543, 564, 564, 2836], [2838, 2838, 2888, 2888, 3071], [3074, 3074, 3119, 3119, 3894], [3897, 3897, 3954, 3971, 5115]], "test": "valid"}
{"id": "3sjXWz", "name": "Smurf Gum in Vanilla Cream", "author": "sy2002", "description": "My first raymarching experiment based on \"Raymarching for Dummies\" from \"The Art of Code\" (https://youtu.be/PGtv-dBi2wE)", "tags": ["raymarching", "beginner", "experiment"], "likes": 1, "viewed": 333, "published": "Public API", "date": "1553472168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Smurf Gum in Vanilla Cream - First Raymarching Experiment\n   inspired by \"Raymarching for Dummies\" tutorial from \"The Art of Code\" (https://youtu.be/PGtv-dBi2wE)\n   done by sy2002 on 24th of March 2019\n*/\n\n#define MAX_STEPS\t\t200\n#define\tMAX_DIST\t\t100.0\n#define SURFACE_DIST\t0.01\n\n#define IS_FLOOR\t\t1.0\n#define IS_OBJECT\t\t2.0\n\n//in Raymarching, the distance function equals the scene description\n//the first scalar represents the object type, the second the actual distance\nvec2 GetDist(vec3 p)\n{    \n    //distance to sphere = distance to center of sphere minus radius\n    //y-pos and radius vary over time in some sin/cos pattern\n\tvec4 sphere = vec4(0, 1.0, 6, 1.0);\n    sphere.y += 1.0 * cos(iTime/2.0);\n    sphere.w += abs(sin(iTime / 3.0));\n    float dS = length(p - sphere.xyz) - sphere.w;\n    \n    //displace the body of the sphere according to the x-position and the time\n    dS += 0.2 * sin(sin(iTime/3.0)*7.0*p.x) * cos(iTime);\n    \n    //distance to ground plane is just height of camera due to our simple scene\n    float dP = p.y + 0.01 * sin(p.x * 5.0 + iTime);\n    \n\t//the object that is closest, wins\n    vec2 retval = vec2(0);\n    if (dP < dS)\n        retval.x = IS_FLOOR;\n    else\n        retval.x = IS_OBJECT;\n    \n    //mix the two distances with an intensity that depends on how close they are\n    float k = 0.5;\n    float h = clamp(0.5 + 0.5*(dP-dS)/k, 0.0, 1.0);\n    retval.y = mix(dP, dS, h) - k*h*(1.0-h);\n    \n    return retval;\n}\n\n//return the distance to the first object that the ray hits\n//the first scalar represents the object type, the second the actual distance\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.0; //distance from origin\n    vec2 retval = vec2(0);\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dO*rd;\t//march the ray\n        retval = GetDist(p);\n        float dS = retval.y;\t//minimum distance from surface relative to p\n        dO += dS;\t\t\t\t//it is safe to march at least the distance dS without intersecting\n        \n        //approached surface close enough OR reached \"infinity\"\n\t\tif (dS < SURFACE_DIST || dO > MAX_DIST)\n            break;\n    }\n    \n    retval.y = dO;\t\t\t\t//retval.x is the detected object type\n    return retval;\n}\n\n//this is still magic to me, note to self: learn more\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).y;\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3 (\n        GetDist(p - e.xyy).y,\n        GetDist(p - e.yxy).y,\n        GetDist(p - e.yyx).y\n    );\n    return normalize(n);\n}\n\n//simple diffuse light model: maximum intensity, when the light ray is perpendicular\n//to the surface and zero intensity, when it is parallel: this is the dot product\n//between the normalized normal vector of the surface and the light\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(-0.9, 0.9, 1.9);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    vec3 l = normalize(lightPos - p);\t//light vector\n    vec3 n = GetNormal(p);\t\t\t\t//perpendicular to surface\n    \n    //the dot product delivers a value between -1..1, we need 0..1, so clamp it\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n        \n    return dif;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //normalized and aspect ratio corrected pixel coordinates from -1 to 1\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //ro = ray origin = camera\n    //rd = ray direction\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n \n    //distance to the nearest object\n    vec2 retval = RayMarch(ro, rd);\n    float object = retval.x;\n    float d = retval.y;\n    \n    if (d < MAX_DIST) //Vanilla Cream + Smurf Gum\n    {\n        //light that point using diffuse lighting\n        vec3 p = ro + rd*d;\n        float dif = GetLight(p);\n        if (object == IS_FLOOR)\n            col = vec3(0.92, 0.92, 0.65) * vec3(dif) * 1.1 + 0.1;\n        else\n        \tcol = vec3(0.0, 0.7, 1.0) * vec3(dif) * 1.2 + vec3(0.05, 0.05, 0.2);\n    }\n    else //sky\n    {\n        const vec3 left  = vec3(0.698, 0.996, 0.980);\n        const vec3 right = vec3(0.055, 0.824, 0.969);\n        col = mix(left, right, (fragCoord.x / iResolution.x) * (fragCoord.y / (0.4*iResolution.y))) - 0.05; \n    }\n    \n    //output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 476, 498, 633, 1457], [1459, 1597, 1630, 1630, 2211], [2213, 2267, 2291, 2291, 2499], [2501, 2736, 2760, 2760, 3125], [3128, 3128, 3183, 3258, 4284]], "test": "valid"}
{"id": "3slXDB", "name": "Boreal Starry Night", "author": "BrutPitt", "description": "A Boreal Starry Night.\n\nMy 2012 WebGL experiment ported to ShaderToy\nStandalone version also on github: [url]https://github.com/BrutPitt[/url]", "tags": ["fractal", "noise", "line", "starfield"], "likes": 29, "viewed": 931, "published": "Public", "date": "1552061533", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Show shootiong star \n#define COMET\n\n//varing light intensity for stars\n//#define FRACTAL_SKY\n//#define PULSED_STARS //for FRACTAL_SKY only\n\n//for use in shadertoy environment or similia\n#define SHADERTOY\n\n#ifdef SHADERTOY\nvec2 mouseR = vec2(0.);\nvec2 mouseL = vec2(0.);\n#else\nuniform float time;\nuniform vec2 mouseR;\nuniform vec2 mouseL;\nuniform vec2 resolution;\nuniform sampler2D skyTex;\nuniform sampler2D landTex;\n#endif\n\nconst vec3 starColor = vec3(.43,.57,.97);\n\nfloat contrast(float valImg, float contrast) { return clamp(contrast*(valImg-.5)+.5, 0., 1.); }\nvec3  contrast(vec3 valImg, float contrast)  { return clamp(contrast*(valImg-.5)+.5, 0., 1.); }\n\nfloat gammaCorrection(float imgVal, float gVal)  { return pow(imgVal, 1./gVal); }\nvec3  gammaCorrection(vec3 imgVal, float gVal)   { return pow(imgVal, vec3(1./gVal)); }\n\n//Get color luminance intensity\nfloat cIntensity(vec3 col) { return dot(col, vec3(.299, .587, .114)); }\n\n\nfloat hash( float n ) { return fract(sin(n)*758.5453); }\nhighp float rand(vec2 p) { return fract(sin(dot(p ,vec2(1552.9898,78.233))) * 43758.5453); }\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t    mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f  = 0.50000*noise( p ); p *= 2.02;\n          f += 0.25000*noise( p ); p *= 2.03;\n          f += 0.12500*noise( p ); p *= 2.01;\n          f += 0.06250*noise( p ); p *= 2.04;\n          f += 0.03125*noise( p );\n    return f*1.032258;\n}\n\n\nfloat fbm2( vec3 p )\n{\n    float f  = 0.50000*noise( p ); p *= 2.021;\n          f += 0.25000*noise( p ); p *= 2.027;\n          f += 0.12500*noise( p ); p *= 2.01;\n          f += 0.06250*noise( p ); p *= 2.03;\n          f += 0.03125*noise( p ); p *= 4.01;\n          f += 0.015625*noise( p );p *= 8.04;\n          f += 0.00753125*noise( p );\n    return f*1.05;\n}\n\nfloat borealCloud(vec3 p)\n{\n\tp+=fbm(vec3(p.x,p.y,0.0)*0.5)*2.25;\n\tfloat a = smoothstep(.0, .9, fbm(p*2.)*2.2-1.1);\n    \n\treturn a<0.0 ? 0.0 : a;\n}\n\nvec3 smoothCloud(vec3 c, vec2 pos)\n{\n\tc*=0.75-length(pos-0.5)*0.75;\n\tfloat w=length(c);\n\tc=mix(c*vec3(1.0,1.2,1.6),vec3(w)*vec3(1.,1.2,1.),w*1.25-.25);\n\treturn clamp(c,0.,1.);\n}\n\nfloat fractalField(in vec3 p,float s,  int idx) {\n   float strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n   float accum = s/4.;\n   float prev = 0.;\n   float tw = 0.;\n   for (int i = 0; i < 24; ++i) {\n      float mag = dot(p, p);\n      p = abs(p) / mag + vec3(-.5, -.4, -1.5);\n      float w = exp(-float(i) / 4.8);\n      accum += w * exp(-strength * pow(abs(mag - prev), 2.7));\n      tw += w;\n      prev = mag;\n   }\n   return max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n   vec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n   vec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n   vec3 c = mix(a, b, 0.5);\n   return c;\n}\n\n#ifdef PULSED_STARS\nfloat starField(vec2 p)\n{\n   vec3 rnd = nrand3(p * iResolution.x);\n   float intensity = pow((1.+sin((iTime+27.)*rnd.x))*.5, 7.) ;\n   return max(rnd.x * pow(rnd.y,7.) * intensity, 0.);\n\n}\n#else\nfloat starField(vec2 p)\n{\n   vec3 rnd = nrand3(p * iResolution.x);\n   return pow(abs(rnd.x + rnd.y + rnd.z)/2.93,9.7);\n}\n#endif\n\n#define iterations 16\n#define formuparam 0.53 //77\n\n#define volsteps 4\n#define stepsize 0.00733\n\n#define zoom   1.2700\n#define tile   .850\n#define speed  0.000\n\n#define brightness 0.0007\n#define darkmatter .1700\n#define distfading 1.75\n#define saturation .250\n\n\nvec3 starr(vec2 UV)\n{\n    float ratio = iResolution.y/iResolution.x;\n\t//get coords and direction\n\tvec2 uv=UV*.3723+vec2(0.,-.085); //-mouseL;\n\tuv.y*= ratio;\n\tvec3 dir=vec3(uv*zoom/ratio,1.);\n\n\tdir.xz*=mat2(.803, .565, .565, .803);\n\tdir.xy*=mat2(.9935,.0998,.0998,.9935);\n\n    vec3 from=vec3(-0.4299,-0.7817,-0.3568);\n\n\t//volumetric rendering\n\tfloat s=0.0902,fade=.7;\n\tfloat v=0.;\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*-9.9;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\n\t\tfor (int i=0; i<iterations; i++) {\n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\ta*=a*a; // add contrast\n\t\tv+=fade;\n\t\tv+=s*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv = contrast(v *.009, .95)-.05;\n\tvec3 col = vec3(.43,.57,.97) * 1.7 * v;\n\n\tcol = gammaCorrection(col, .7);\n\n\treturn col + vec3(.67,.83,.97) * vec3(starField(UV)) * .9;\n}\n\n//besselham line function\n//creates an oriented distance field from o to b and then applies a curve with smoothstep to sharpen it into a line\n//p = point field, o = origin, b = bound, sw = StartingWidth, ew = EndingWidth, \nfloat shoothingStarLine(vec2 p, vec2 o, vec2 b, float sw, float ew){\n\tfloat d = distance(o, b);\n\tvec2  n = normalize(b - o);\n\tvec2 l = vec2( max(abs(dot(p - o, n.yx * vec2(-1.0, 1.0))), 0.0),\n\t               max(abs(dot(p - o, n) - d * 0.5) - d * 0.5, 0.0));\n\treturn smoothstep( mix(sw, ew, 1.-distance(b,p)/d) , 0., l.x+l.y);\n}\n\nvec3 comet(vec2 p)\n{\nconst float modu = 4.;        // Period: 4 | 8 | 16 \nconst float endPointY = -.1; // Hide point / Punto di sparizione Y\nvec2 cmtVel = mod(iTime/modu+modu*.5, 2.) > 1. ? vec2(2., 1.4)*.5 : vec2(-2., 1.4)*.5;  // Speed component X,Y\nvec2 cmtLen = vec2(.25)*cmtVel; //cmt lenght\n    \n    vec2 cmtPt = 1. - mod(iTime*cmtVel, modu);\n    cmtPt.x +=1.;\n\n    vec2 cmtStartPt, cmtEndPt;\n\n    if(cmtPt.y < endPointY) {\n        cmtEndPt   = cmtPt + cmtLen;\n        if(cmtEndPt.y > endPointY) cmtStartPt = vec2(cmtPt.x + cmtLen.x*((endPointY - cmtPt.y)/cmtLen.y), endPointY);\n        else                       return vec3(.0);\n    }\n    else {\n        cmtStartPt = cmtPt;\n        cmtEndPt = cmtStartPt+cmtLen; \n    }\n\n    float bright = clamp(smoothstep(-.2,.65,distance(cmtStartPt, cmtEndPt)),0.,1.);\n\n    vec2 dlt = vec2(.003) * cmtVel;\n\n    float q = clamp( (p.y+.2)*2., 0., 1.);\n\n    return  ( bright  * .75 *  (smoothstep(0.993, 0.999, 1. - length(p - cmtStartPt)) + shoothingStarLine(p, cmtStartPt, cmtStartPt+vec2(.06)*cmtVel,  0.009, 0.003)) +   //bulbo cmta\n             vec3(1., .7, .2) * .33 * shoothingStarLine(p, cmtStartPt,         cmtEndPt,        0.003, .0003) +          // scia ...\n             vec3(1., .5, .1) * .33 * shoothingStarLine(p, cmtStartPt+dlt,     cmtEndPt+dlt*2., 0.002 ,.0002) +         // ...\n             vec3(1., .3, .0) * .33 * shoothingStarLine(p, cmtStartPt+dlt+dlt, cmtEndPt+dlt*4., 0.001, .0001)            //\n            ) * (bright) * \n        q ; //attenuation on Y}\n}\n\n#define SMOOTH_V(V,R)  { float p = position.y-.2; if(p < (V)) { float a = p/(V); R *= a *a ;  } }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n#ifdef SHADERTOY\n    mouseL = iMouse.xy / iResolution.xy;\n#endif\n    vec2 mouseLeft = vec2(0.0);\n    vec2 mouse = mouseL;\n\n\tvec2 position = ( fragCoord / iResolution.xy );\n    vec2 uv = 2. * position - 1.;\n\t\n    position.y+=0.2;\n\n\tvec2 coord= vec2((position.x-0.5)/position.y,1./(position.y+.2));\n\n\tfloat tm = iTime * .75 * .5;\n\tcoord+=tm*0.0275 + vec2(1. - mouse.x, mouse.y);\n\tvec2 coord1=coord - tm*0.0275 + vec2(1. - mouse.x, mouse.y);\n\n\t\n    vec2 ratio = iResolution.xy / max(iResolution.x, iResolution.y);;\n    vec2 uvs = uv * ratio;\n\n// Boreal effects\n////////////////////////////////////\n    // CloudColor * cloud * intensity\n    vec3 boreal = vec3 (vec3(.1,1.,.5 )  * borealCloud(vec3(coord*vec2(1.2,1.), tm*0.22)) * .9  +\n                        //vec3(.0,.7,.7 )  * borealCloud(vec3(coord1*vec2(.6,.6)  , tm*0.23)) * .5 +\n                        vec3(.1,.9,.7) * borealCloud(vec3(coord*vec2(1.,.7)  , tm*0.27)) *  .9 +\n                        vec3(.75,.3,.99) * borealCloud(vec3(coord1*vec2(.8,.6)  , tm*0.29)) *  .5 +\n                        vec3(.0,.99,.99)  * borealCloud(vec3(coord1*vec2(.9,.5)  , tm*0.20)) *  .57);\n                        \n\n    SMOOTH_V(.5,boreal);\n    SMOOTH_V(.35,boreal);\n    SMOOTH_V(.27,boreal);\n\n    boreal = smoothCloud(boreal, position);\n    boreal = gammaCorrection(boreal,1.3);\n\n#ifdef EXTERNAL_TEXT\n\tvec2 vCoord = vec2(v_texCoord.x, 1.-v_texCoord.y);\n#endif\n\n// Sky background (fractal)\n////////////////////////////////////\n#ifdef FRACTAL_SKY\n    // point position sky fractal    \n    vec3 skyPt = vec3(uvs / 6., 0) + vec3(-1.315, .39, 0.);  //pt + pos\n    \n    skyPt.xy += vec2(- mouseLeft.x*.5*ratio.x, - mouseLeft.y * .5*ratio.y);\n\n    //fractal\n    vec3 freq = vec3(0.3, 0.67, 0.87);\n    float ff = fractalField(skyPt,freq.z, 27);\n\n    vec3 sky =  vec3 (.75, 1., 1.4) * .05 * pow(2.4,ff*ff*ff)  * freq ;\n#else\n    vec3 sky =  vec3 (0.);\n#endif\n\n// Moon\n////////////////////////////////////\n    vec2 moonPos = vec2(0.77,-.57) * ratio;\n    float len = 1. - length((uvs - moonPos) ) ;\n    // moon\n    vec3 moon = vec3(.99, .7, .3) * clamp(smoothstep(0.95, 0.957, len) - \n                                          smoothstep(0.93, 0.957, 1. - length(uvs - (moonPos + vec2(0.006, 0.006)) ) - .0045)\n                                          , 0., 1.) \n\n                                          * 2.;\n    vec3 haloMoon  = vec3(.0,  .2,  .7)  * 0.2     * smoothstep(0.4, 0.9057, len);\n         haloMoon += vec3(.5,  .5,  .85) * 0.0725  * smoothstep(0.7, 0.995,  len);\n\n// Shooting star\n////////////////////////////////////\n#ifdef COMET\n    vec3 cometA = comet(uvs);\n#endif\n\n// Terrain\n////////////////////////////////////\n         float ground = smoothstep(0.07,0.0722,fbm2(vec3((position.x-mouse.x)*5.1, position.y,.0))*(position.y-0.158)*.9+0.01);\n\n// Horizon Light\n////////////////////////////////////\n         float pos = 1. - position.y;\n         vec3 sunrise = vec3(.6,.3,.99) * (pos >  .45  ? (pos - .45)  * .65  : 0.) +  \n                        vec3(.0,.7,.99) * (pos >= .585 ? (pos - .585  ) * .6  : 0.) +\n                        vec3(.5,.99,.99)* (pos >= .67  ? (pos - .67) * .99 : 0.) ; \n\n// StarField\n////////////////////////////////////\n#ifdef FRACTAL_SKY\n         vec3 starColor = vec3(starField(uv));\n#else\n\n         vec3 starColor = starr(uv);\n         SMOOTH_V(.37,starColor);\n#endif\n\n// Intensity attenuation\n////////////////////////////////////\n         float ib = clamp(1.0-cIntensity(boreal)*3.,0.,1.);\n         ib*=ib;\n         float im = 1.0-cIntensity(moon);\n         float ih = 1.0-cIntensity(haloMoon)*8.;\n         float is = 1.0-cIntensity(sunrise)*6.;\n\n\n         sky += ((moon + haloMoon)*ib*ib) * is * is +\n                sunrise +\n#ifdef COMET\n                cometA +\n#endif\n                starColor  * ib *ib /*vec3(.3,.63,.97)*/  * im * im * ih * ih * is * is;\n\n\t\t fragColor =  vec4(boreal + sky, 1.) * ground;\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 469, 515, 515, 564], [565, 565, 611, 611, 660], [662, 662, 712, 712, 743], [744, 744, 794, 794, 831], [833, 865, 893, 893, 936], [939, 939, 962, 962, 995], [1091, 1091, 1117, 1117, 1432], [1434, 1434, 1455, 1455, 1699], [1702, 1702, 1724, 1724, 2061], [2063, 2063, 2090, 2090, 2209], [2211, 2211, 2247, 2247, 2388], [2390, 2390, 2439, 2439, 2865], [2867, 2867, 2891, 2891, 3082], [3688, 3688, 3709, 3709, 4699], [4701, 4924, 4992, 4992, 5252], [5254, 5254, 5274, 5274, 6776], [6877, 6877, 6934, 6934, 10826]], "test": "valid"}
{"id": "3slXDj", "name": "Tuto004 Animated Shadow", "author": "arthurstammet", "description": "Animated Shadow\nmy step by step tutorial 4\nby Arthur Stammet, 03.2019", "tags": ["tutorial", "shadow", "animation"], "likes": 1, "viewed": 222, "published": "Public API", "date": "1552249291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Animated Shadow\n// my step by step tutorial 4\n// by Arthur Stammet, 03.2019\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set center to the middle of the screen\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y; \n\n    // change values here --------------------------------------------------------------\n\n    // Background Color-Cycling RGB-Values\n    float SpeedR = iTime * 0.7;\n    float SpeedG = iTime * 0.8;\n    float SpeedB = iTime * 0.9;\n\n    // Parameters for the Lissajous Curve ( Ellipse if SpeedX = SpeedY )\n    float SpeedX = iTime * 0.62;\n    float SpeedY = iTime * 0.75;\n    \n    // ---------------------------------------------------------------------------------\n    \n\tfloat red = 0.5 + sin(SpeedR*0.5); \t\t// 0.0 <> 1.0\n\tfloat green = 0.5 + sin(SpeedG*0.5);\t// 0.0 <> 1.0\n\tfloat blue = 0.5 + sin(SpeedB*0.5); \t// 0.0 <> 1.0\n\n    // creating a Lissajous Curve\n    float CenterX = sin(SpeedX)*0.4;\n\tfloat CenterY = cos(SpeedX)*0.2;\n    \n    vec3 col = vec3( red, green, blue ); // colorized screen (animated)\t\n\tcol *= length(p - vec2(CenterX,CenterY)); // moving shadow (animated)\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 80, 137, 183, 1161]], "test": "valid"}
{"id": "3slXRj", "name": "Simple Circle Render", "author": "GrayVoid", "description": "Simple circle renderer", "tags": ["simple", "circle", "cutout"], "likes": 1, "viewed": 78, "published": "Public", "date": "1551690318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 diff = uv*2.0 - 1.0;\n    vec2 diffScale = vec2(iResolution.x/iResolution.y, iResolution.y/iResolution.x);\n    diffScale = max(diffScale, vec2(1.0));\n    diff *= diffScale;\n    float lsq = dot(diff, diff);\n    \n    fragColor = vec4(col,1.0) * step(lsq, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 510]], "test": "valid"}
{"id": "3slXRS", "name": "Shader3 - candle", "author": "EmperorLem", "description": "A simple candle light", "tags": ["color"], "likes": 2, "viewed": 78, "published": "Public", "date": "1551546483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 black = vec3(0.0,0.0,0.0);\nvec3 maroon = vec3(0.7,0.0,0.0);\nvec3 blue = vec3(0.0,0.0,0.8);\nvec3 gold = vec3(0.9,0.9,0.0);\nvec3 white = vec3(1.0,1.0,1.0);\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nvec3 circle(vec2 uv, vec2 pos)\n{       \n\tvec3 green = vec3(0.0 , 1.0, 0.2);\n    vec3 blue = vec3(0.2, 0.2, 1.0);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float d = length(uv - pos);    \n    \n    float offset = noise(uv*4.+vec2(.0, -iTime*4.))*.1;\n    \n    float r = 0.09;\n    float rate = clamp(sin(20.0 * r * iTime)*r , 0.25, 0.30);\n    float circle = smoothstep(rate, r, d+offset);\n    vec3 mixed = mix(black, gold, circle);\n    \n    return mixed;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float height = step(0.0,uv.y) - step(0.35,uv.y);\n    float width = step(0.4,uv.x) -step(0.6,uv.x);\n                                          \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 image = mix(black, maroon, height * width);\n    \n    height = step(0.35,uv.y) - step(0.45,uv.y);\n    width = step(0.5,uv.x) -step(0.51,uv.x);\n        \n    image = mix(image, white, height * width);\n    \n    vec3 mCircle = circle(uv, vec2(0.89,0.52));\n    \n    image = mix(mCircle, image, image);\n    \n\n    // Output to screen\n    fragColor = vec4(image,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slXRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 181, 356, 422], [424, 439, 464, 464, 975], [977, 977, 1009, 1009, 1437], [1439, 1439, 1496, 1546, 2198]], "test": "valid"}
{"id": "3slXW7", "name": "a few animated circles", "author": "nebbul", "description": "a few simple animated circles", "tags": ["simple", "circle", "animated"], "likes": 3, "viewed": 139, "published": "Public", "date": "1552900271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DIV 10.0\n#define MINRADIUS 0.1\n#define MAXRADIUS 0.9\n#define PULSEFREQ 4.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // define the UVs, make them square by using the same iRes dimension\n\tvec2 uv = fragCoord.xy/iResolution.xx;\n    // define UV squares\n    vec2 uvShift = floor( uv * DIV ) / DIV * PULSEFREQ;\n    // make UV gradients inside the squares\n\tuv = fract( uv * DIV ) * 2.0 - 1.0;\n\n    // circle radius pulse offset by the UV squares\n    float sinTime = sin(iTime * 2.0 - uvShift.x - uvShift.y);\n    // remap sinTime output to min/max radius\n    float radius = (sinTime + 1.0) / 2.0 * (MAXRADIUS - MINRADIUS) + MINRADIUS;\n    \n    float circle = length(uv) - radius; \n    \n    // anti aliasing\n    float pix = DIV * 2.0 / iResolution.x;\n    float t = smoothstep(-.75, .75, circle / pix);\n\n    // Background color RGBA\n\tvec4 bg_color = vec4(0.0, 0.0, 0.0, 1.0);\n    // foreground color RGBA (circle)\n\tvec4 fg_color = vec4(1.0, 1.0, 1.0, 1.0);\n    \n\t// Blend the BG and FG colors\n\tfragColor = vec4(mix(fg_color, bg_color, t));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slXW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 141, 215, 1063]], "test": "valid"}
{"id": "3slXWB", "name": "Cell Population", "author": "arthurstammet", "description": "Cell Population - Inspired by https://www.youtube.com/watch?v=l-07BXzNdPw\nPlease wait for allowing death to strike and to give life a new chance.\nSoundtrack on Soundcloud : https://soundcloud.com/arthur-stammet/d-sert", "tags": ["animation", "vornoi", "cells"], "likes": 1, "viewed": 280, "published": "Public API", "date": "1552054718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cell Population\n// my step by step tutorial\n// Inspired by https://www.youtube.com/watch?v=l-07BXzNdPw\n\n// create random numbers for x and y\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y; // -1 <> 1\n    float fft = 2.*texture(iChannel0,vec2(0.01,0.)).x;\n    \n    // Change values here ------------------------------------------------------\n    \n    float window = 0.8;\n    float t = 200.+((iTime*.5)+fft);\n\tfloat lifeTime = t*.2;\n    const float density = 100.;\n    const float mortality = 95.; // mortality < density\n    float brightness = 10.; // high values for more brightness\n    float contrast = .9; // low values for higher contrast\n    \n    // -------------------------------------------------------------------------\n    \n    float minDist = 50.;\n\tfloat xFactor = (iResolution.x/(iResolution.y*.9))*window;\n    float m = 0.;\n    float cellIndex = 0.;\n    float Greyscale = 1.;\n    const float maxCells = density + mortality; \n    float cells = density+(sin(lifeTime)*mortality);\n    \n    for(float i=2.; i<maxCells; i++) {\n        vec2 n = N22(vec2(i));\n        vec2 p = sin(n*t);\n\t\tp.x *= xFactor;\n\t\tp.y *= window;\n        \n        float d = length(uv-p);\n\n        if(i>cells) {break;}\n        \n        if(d<minDist) {\n\t    \tminDist = d;\n            cellIndex = i;\n            Greyscale = brightness+(cellIndex/(density*contrast));\n\t\t}\n    }\n\n    vec3 col = vec3(minDist*Greyscale);\t\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4llGW4", "previewfilepath": "https://soundcloud.com/arthur-stammet/d-sert", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/arthur-stammet/d-sert", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slXWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 144, 162, 162, 288], [290, 290, 347, 347, 1651]], "test": "error"}
{"id": "3slXzj", "name": "midterms 8", "author": "jojo169", "description": "8", "tags": ["8"], "likes": 2, "viewed": 39, "published": "Public", "date": "1551698492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(1.,0.,0.);\nvec3 blue = vec3(0.,0.,1.);\nvec3 green = vec3(0,1.,0.);\nvec3 yellow = vec3(1.,1.,0.);\nvec3 black = vec3(0.,0.,0.);\nvec3 gray = vec3(.5,.5,.3);\n\nfloat virus(vec2 uv,float posX,float posY,float midSize,float outerSize)\n{\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos= vec2(posX*ratio,posY);\n    float dist = distance(shapePos,uv)*2.;\n    \n    uv -=shapePos;\n    float angle= atan(uv.y,uv.x);\n    float radius = cos(2.*angle);\n    radius = abs(cos(angle*12.+iTime)*sin(angle*3.+iTime))*outerSize+midSize;\n    \n    float value = 1.-step(radius,dist);\n\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float value = virus(uv,.5,.5,.5,.2);\n\tvec3 val = mix(col,col*2.,value);\n    \n    \n    // Output to screen\n    fragColor = vec4(val,uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 245, 245, 642], [644, 644, 701, 701, 941]], "test": "valid"}
{"id": "3sSGzD", "name": "CIE L*u*v* sRGB Gamut (spinning)", "author": "Tynach", "description": "Spinning sRGB gamut in the L*u*v* colorspace.\n\nClick+drag to freely rotate. Click the furthest left pixels to animate it again.\n\nBased on my similar shader that uses the L*a*b* colorspace.", "tags": ["color", "rgb", "spinning", "srgb", "luv", "cie", "cieluv"], "likes": 2, "viewed": 81, "published": "Public", "date": "1552639128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/******************************************************************************\n * Scroll to just above the functions to change the parameters used to draw   *\n * the diagram                                                                *\n ******************************************************************************/\n\nprecision highp float;\nprecision highp int;\n\n#define PI 3.1415926535897932384626433832795\n#define EULER 2.7182818284590452353602874713527\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Parameters for a colorspace\nstruct rgb_space {\n\t// Chromaticity coordinates (xyz) for Red, Green, and Blue primaries\n\tmat3 primaries;\n\n\t// Chromaticity coordinates (xyz) for white point\n\tvec3 white;\n\n\t// Linearization and gamma correction parameters\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define Primaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\tr1, r2, 1.0 - r1 - r2,\\\n\t\tg1, g2, 1.0 - g1 - g2,\\\n\t\tb1, b2, 1.0 - b1 - b2)\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define white(x, y)\\\n\tvec3(x, y, (1.0 - x - y))\n\n#define Bright(w)\\\n\t((w)/w.y)\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define diag(v)\\\n\tmat3(\\\n\t\t(v).x, 0.0, 0.0,\\\n\t\t0.0, (v).y, 0.0,\\\n\t\t0.0, 0.0, (v).z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space)\\\n\tspace.primaries*diag((inverse(space.primaries)*Bright(space.white)))\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define conversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\nconst mat3 CIECAM02 = mat3(\n\t0.7328, -0.7036, 0.003,\n\t0.4296, 1.6975, 0.0136,\n\t-0.1624, 0.0061, 0.9834\n);\n\nconst mat3 HUNT = mat3(\n\t0.38971, -0.22981, 0,\n\t0.68898, 1.1834, 0,\n\t-0.07868, 0.04641, 1\n);\n\nconst mat3 CIECAM97_1 = mat3(\n\t0.8951, -0.7502, 0.0389,\n\t0.2664, 1.7135, -0.0685,\n\t-0.1614, 0.0367, 1.0296\n);\n\nconst mat3 CIECAM97_2 = mat3(\n\t0.8562, -0.836, 0.0357,\n\t0.3372, 1.8327, -0.0469,\n\t-0.1934, 0.0033, 1.0112\n);\n\n// Converts from L*a*b* to nonlinear XYZ; calling\n// toLinear() afterward completes the conversion\nconst mat3 frLab = mat3(\n\t1, 0, 0,\n\t1, 1, 1,\n\t0, 0, 1\n)*mat3(\n\t1.16/500.0, 0, 0,\n\t0, 1.0/100.0, 0,\n\t0, 0, -1.16/200.0\n);\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// Identity RGB\nconst mat3 primariesIdentity = mat3(1.0);\n\n// CIE 1931 RGB\nconst mat3 primariesCie = Primaries(\n\t0.72329, 0.27671,\n\t0.28557, 0.71045,\n\t0.15235, 0.02\n);\n\n// Original 1953 NTSC primaries\nconst mat3 primariesNtsc = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// Never-popular and antiquated 'HDTV' primaries based mostly on 1953 NTSC\nconst mat3 primaries240m = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat3 primariesEbu = Primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat3 primariesP22 = Primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC and Rec. 601 (525 lines)\nconst mat3 primariesSmpteC = Primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat3 primariesSony = Primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primariesAdobe = Primaries(\n\t0.64, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// DCI-P3 primaries\nconst mat3 primariesDciP3 = Primaries(\n\t0.68, 0.32,\n\t0.265, 0.69,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// If the HUNT XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesHunt = Primaries(\n\t0.8374, 0.1626,\n\t2.3, -1.3,\n\t0.168, 0.0\n);\n\n// If the CIECAM97_1 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam971 = Primaries(\n\t0.7, 0.306,\n\t-0.357, 1.26,\n\t0.136, 0.042\n);\n\n// If the CIECAM97_2 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam972 = Primaries(\n\t0.693, 0.316,\n\t-0.56, 1.472,\n\t0.15, 0.067\n);\n\n// If the CIECAM02 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam02 = Primaries(\n\t0.711, 0.295,\n\t-1.476, 2.506,\n\t0.144, 0.057\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://www.cvrl.org/ciepr8dp.htm, and\n// http://www.cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\n/*const mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);*/\n\n// Same as above, but in fractional form\nconst mat3 primariesLms = Primaries(\n\t194735469.0/263725741.0, 68990272.0/263725741.0,\n\t141445123.0/106612934.0, -34832189.0/106612934.0,\n\t36476327.0/229961670.0, 0.0\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec3 whiteC = white(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec3 whiteE = vec3(1.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec3 whiteP22 = white(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec3 whiteD65 = white(0.312713, 0.329016);\n\n// Standard illuminant D65 according to sRGB, Rec. 709, and other display standards\nconst vec3 whiteD65S = white(0.3127, 0.3290);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec3 whiteD50 = white(0.34567, 0.35850);\n\n// Standard illuminant D50 according to ICC standards (they specify a hex value\n// for the 16-bit integer representation, as well as a specific way to decode it,\n// so I did some math to figure out exactly the values they expect)\n//const vec3 whiteD50I = white(31595.0/91393.0, 32768.0/91393.0);\n\n// Floating point representation of ICC D50\nconst vec3 whiteD50I = white(3214.0/9297.0, 10000.0/27891.0);\n\n// White point for DCI-P3 Theater\nconst vec3 whiteTheater = white(0.314, 0.351);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec3 whiteSony = white(0.283, 0.298);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, before SMPTE 170M was modified to specify a more exact curve\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. This is the only difference between sRGB and Rec. 709\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n// Gamma for the CIE L*a*b* Lightness scale\nconst transfer gamLab = transfer(3.0, 0.16, 243.89/27.0, 0.08, 216.0/24389.0);\n\n\n/*\n * RGB Colorspaces\n */\n\n// CIE 1931 RGB\nconst rgb_space Cie1931 = rgb_space(primariesCie, whiteE, gam10);\n\n// Identity RGB\nconst rgb_space Identity = rgb_space(primariesIdentity, whiteE, gam10);\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65S, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65S, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65S, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65S, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65S, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65S, gamSrgb);\n\n// Adobe RGB monitors\nconst rgb_space AdobeRgb = rgb_space(primariesAdobe, whiteD65S, gam22);\n\n// DCI-P3 D65\nconst rgb_space DciP3D65 = rgb_space(primariesDciP3, whiteD65S, gam170m);\n\n// DCI-P3 D65\nconst rgb_space DciP3Theater = rgb_space(primariesDciP3, whiteTheater, gam170m);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65S, gam170m);\n\n// Hunt primaries, balanced against equal energy white point\nconst rgb_space HuntRgb = rgb_space(primariesHunt, whiteE, gam10);\n\n// CIE CAM 1997 primaries v1, balanced against equal energy white point\nconst rgb_space Ciecam971Rgb = rgb_space(primariesCiecam971, whiteE, gam10);\n\n// CIE CAM 1997 primaries v2, balanced against equal energy white point\nconst rgb_space Ciecam972Rgb = rgb_space(primariesCiecam972, whiteE, gam10);\n\n// CIE CAM 2002 primaries, balanced against equal energy white point\nconst rgb_space Ciecam02Rgb = rgb_space(primariesCiecam02, whiteE, gam10);\n\n// Lms primaries, balanced against equal energy white point\nconst rgb_space LmsRgb = rgb_space(primariesLms, whiteE, gam10);\n\n\n/**********************************************************\n *                                                        *\n *  Change these to adjust various conversion parameters  *\n *                                                        *\n **********************************************************/\n\n// Display colorspace\nconst rgb_space disp = rgb_space(primaries709, whiteD65S, gamSrgb);\n\nconst mat3 toRgb = xyzToRgb(disp);\n\n\n/*\n * Conversion Functions\n */\n\n// Converts display RGB colors to a linear light scale\nvec4 toLinear(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));\n\tvec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));\n\tvec4 lower = color/trc.slope;\n\n\tcolor = mix(higher, lower, cutoff);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec4 toGamma(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToGamma));\n\tvec4 higher = (1.0 + trc.off)*pow(color, vec4(1.0/trc.power)) - trc.off;\n\tvec4 lower = color*trc.slope;\n\n\tcolor = mix(higher, lower, cutoff);\n\n\treturn color;\n}\n\n// Converts display RGB colors to a linear light scale\nfloat toLinear(float color, const transfer trc)\n{\n\tfloat higher = pow((color + trc.off)/(1.0 + trc.off), trc.power);\n\tfloat lower = color/trc.slope;\n\n\tcolor = mix(higher, lower, color < trc.cutoffToLinear);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nfloat toGamma(float color, const transfer trc)\n{\n\tfloat higher = (1.0 + trc.off)*pow(color, 1.0/trc.power) - trc.off;\n\tfloat lower = color*trc.slope;\n\n\tcolor = mix(higher, lower, color < trc.cutoffToGamma);\n\n\treturn color;\n}\n\n// Turns colors that are out-of-gamut transparent\nvec4 gamutTrim(vec4 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tcolor.a = float(int(low == 0.0 && high == 1.0));\n\n\treturn color;\n}\n\n// Converts from XYZ to RGB, with white point adaptation\nvec4 convert(vec4 color)\n{\n\tfloat luma = color.y;\n\n\t// Convert from XYZ to RGB, then remove out-of-gamut colors\n\tcolor.rgb = toRgb*color.xyz;\n\tcolor = gamutTrim(color, luma);\n\n\treturn color;\n}\n\n\n// Perspective parameters\n// Chosen so that RGB #FF00FF barely touches the boundaries while spinning\n#define FAR (4.84469318)\n#define NEAR (3.15530682)\n#define FOV (2.0*atan(0.5))\n//#define RIGHT (1.25)\n//#define TOP (1.25)\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat minRes = min(iResolution.x, iResolution.y);\n\tvec2 uv = (fragCoord - iResolution.xy/2.0 - 0.5)/minRes;\n\n\t// Color chosen to match the background of this image:\n\t// https://en.wikipedia.org/wiki/File:Lab_color_space.png\n\tfragColor = vec4(vec3(toLinear(104.0/255.0, disp.trc)), 1);\n\n\tconst vec2 whiteUv = vec2(4, 9)*disp.white.xy/(dot(disp.white.xy, vec2(-2, 12)) + 3.0);\n\n\tvec4 color;\n\tvec3 angle = vec3(0);\n\n\tif (iMouse.z == 0.0) {\n\t\tangle = vec3(0, 0, iTime*PI*2.0/5.0);\n\t} else {\n\t\tangle.zx = (iMouse.xy - (iResolution.xy - minRes)/2.0)/minRes*PI*2.0 - PI;\n\t}\n\n\tvec3 sinAng = sin(angle);\n\tvec3 cosAng = cos(angle);\n\n\tmat4 movement = inverse(mat4( // View matrix\n\t\t1.0/tan(FOV/2.0), 0, 0, 0,\n\t\t0, 1.0/tan(FOV/2.0), 0, 0,\n\t\t0, 0, -FAR/(FAR - NEAR), -1,\n\t\t0, 0, -FAR*NEAR/(FAR - NEAR), 0\n\t)*mat4( // World matrix\n\t\t1, 0, 0, 0,\n\t\t0, 0, -1, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 0, 1\n\t)*mat4(\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 4, 0, 1\n\t)*mat4( // Model matrix\n\t\t1, 0, 0, 0,\n\t\t0, cosAng.x, -sinAng.x, 0,\n\t\t0, sinAng.x, cosAng.x, 0,\n\t\t0, 0, 0, 1\n\t)*mat4(\n\t\tcosAng.y, 0, -sinAng.y, 0,\n\t\t0, 1, 0, 0,\n\t\tsinAng.y, 0, cosAng.y, 0,\n\t\t0, 0, 0, 1\n\t)*mat4(\n\t\tcosAng.z, sinAng.z, 0, 0,\n\t\t-sinAng.z, cosAng.z, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\t)*mat4(\n\t\t1.0/200.0, 0, 0, 0,\n\t\t0, 1.0/200.0, 0, 0,\n\t\t0, 0, 1.0/200.0, 0,\n\t\t0, 0, 0, 1\n\t)*mat4(\n\t\t1, 0, 0, 0,\n\t\t0, -1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 50, 0, 1\n\t));\n\n\t// Steps is set to 120, but since white and black are\n\t// infinitely small, only perform steps 1 to 119\n\tconst float steps = 120.0 - 1.0;\n\tfor (float i = 1.0; i < steps; ++i) {\n\t\tcolor = vec4(uv, 1.0 - i/steps, 1);\n\n\t\tcolor = movement*color;\n\t\tcolor /= color.w;\n\t\tcolor.a = 1.0;\n\n\t\t// Convert to XYZ\n\t\tcolor.xz = color.xz/13.0/color.y + whiteUv;\n\t\tcolor.y = toLinear(color.y/100.0, gamLab);\n\t\tcolor.xz = color.y*vec2(9.0*color.x, 12.0 + dot(color.xz, vec2(-3, -20)))/4.0/color.z;\n\n\t\t// Convert to RGB\n\t\tcolor = convert(color);\n\t\tfragColor.rgb = mix(fragColor.rgb, color.rgb, color.a);\n\t}\n\n\tfragColor = toGamma(fragColor, disp.trc);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSGzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[11523, 11578, 11625, 11625, 11843], [11845, 11898, 11944, 11944, 12163], [12165, 12220, 12269, 12269, 12444], [12446, 12499, 12547, 12547, 12723], [12725, 12775, 12815, 12815, 13005], [13007, 13064, 13090, 13090, 13256], [13439, 13485, 13540, 13540, 15568]], "test": "error"}
{"id": "3ssSRB", "name": "midterms 5", "author": "jojo169", "description": "5", "tags": ["5"], "likes": 2, "viewed": 74, "published": "Public", "date": "1551559875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float shape(vec2 uv, float posX,float posY,float sizeNum,float handOne,float handTwo)\n{\n    float ratio =iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    vec2 shapePos= vec2(posX*ratio,posY);\n    float dist = distance(shapePos,uv)*sizeNum;\n    uv -=shapePos;\n    float angle= atan(uv.y,uv.x);\n    float radius = angle;\n    radius = abs(cos(angle*handOne)*sin(angle*handTwo+iTime));\n    float value = 1.-step(radius,dist);\n    \n    return value;\n}\nfloat circle(vec2 uv,float distanceAa, float distanceAb,float ditanceBa,float distanceBb,float size)\n{\n    \n    float val = distance(uv, vec2(distanceAa, distanceAb)) * distance(uv, vec2(ditanceBa, distanceBb));\n    \n\tval = step(val, size);\n    \n    return val;\n}\n\nfloat quad(vec2 uv,float h, float w,float posX, float posY)\n{\n    float quad = step(posX-h ,uv.x)-step(posX+h,uv.x);\n\tquad = quad + step(posY-w,uv.y)-step(0.,uv.y)-step(posY+w,uv.y);\n    return quad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 red = vec3(1.,0.,0.);\n    vec3 blue = vec3(0.,0.,1.);\n    vec3 green = vec3(0,1.,0.);\n    vec3 yellow = vec3(1.,1.,0.);\n    vec3 black = vec3(0.,0.,0.);\n    vec3 gray = vec3(.5,.5,.3);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 val = mix(black,red,shape(uv,.1,.9,(sin(iTime) * sin(iTime) + 1.0)*10.,20.,10.));\n    val = mix(val,yellow,circle(uv,.9,.9,.9,.9,.05));\n    \n    val = mix(val,yellow,shape(uv,.25,.6,(sin(iTime) * sin(iTime) + 1.0)*10.,20.,10.));\n    val = mix(val,green,shape(uv,.4,.78,(sin(iTime) * sin(iTime) + 1.0)*10.,20.,10.));\n    val = mix(val,red,shape(uv,.5,.70,(sin(iTime) * sin(iTime) + 1.0)*10.,20.,10.));\n    val = mix(val,yellow,shape(uv,.7,.4,(sin(iTime) * sin(iTime) + 1.0)*5.,20.,10.));\n    val = mix(val,blue,shape(uv,.5,.35,(sin(iTime) * sin(iTime) + 1.0)*10.,20.,10.));\n    \n    \n    \n    \n    val = mix(val,blue,quad(uv,.05,.1,.09,.1));\n    val = mix(val,blue,quad(uv,.05,.18,.21,.1));\n    val = mix(val,blue,quad(uv,.07,.1,.34,.1));\n\n \n    \n    \n    \n    val = mix(val,yellow,quad(uv,.005,.009,.06,.15));\n    val = mix(val,black,quad(uv,.005,.009,.06,.12));\n    val = mix(val,yellow,quad(uv,.005,.009,.06,.09));\n    val = mix(val,sin(iTime*2.)*yellow,quad(uv,.005,.009,.06,.06));\n    val = mix(val,yellow,quad(uv,.005,.009,.06,.03));\n    \n    val = mix(val,yellow,quad(uv,.005,.009,.08,.15));\n    val = mix(val,yellow,quad(uv,.005,.009,.08,.12));\n    val = mix(val,yellow,quad(uv,.005,.009,.08,.09));\n    val = mix(val,black,quad(uv,.005,.009,.08,.06));\n    val = mix(val,yellow,quad(uv,.005,.009,.08,.03));\n    \n    val = mix(val,black,quad(uv,.005,.009,.1,.15));\n    val = mix(val,sin(iTime*2.)*yellow,quad(uv,.005,.009,.1,.12));\n    val = mix(val,yellow,quad(uv,.005,.009,.1,.09));\n    val = mix(val,yellow,quad(uv,.005,.009,.1,.06));\n    val = mix(val,yellow,quad(uv,.005,.009,.1,.03));\n    \n    val = mix(val,black,quad(uv,.005,.009,.1,.15));\n    val = mix(val,sin(iTime*2.)*yellow,quad(uv,.005,.009,.1,.12));\n    val = mix(val,yellow,quad(uv,.005,.009,.1,.09));\n    val = mix(val,yellow,quad(uv,.005,.009,.1,.06));\n    val = mix(val,yellow,quad(uv,.005,.009,.1,.03));\n    \n    val = mix(val,yellow,quad(uv,.005,.009,.12,.15));\n    val = mix(val,yellow,quad(uv,.005,.009,.12,.12));\n    val = mix(val,yellow,quad(uv,.005,.009,.12,.09));\n    val = mix(val,black,quad(uv,.005,.009,.12,.06));\n    val = mix(val,yellow,quad(uv,.005,.009,.12,.03));\n    \n    val = mix(val,yellow,quad(uv,.005,.009,.18,.15));\n    val = mix(val,yellow,quad(uv,.005,.009,.18,.12));\n    val = mix(val,yellow,quad(uv,.005,.009,.18,.09));\n    val = mix(val,black,quad(uv,.005,.009,.18,.06));\n    val = mix(val,yellow,quad(uv,.005,.009,.18,.03));    \n    val = mix(val,yellow,quad(uv,.005,.009,.18,.18));\n    val = mix(val,black,quad(uv,.005,.009,.18,.21));\n    val = mix(val,yellow,quad(uv,.005,.009,.18,.24));\n    \n    val = mix(val,yellow,quad(uv,.005,.009,.2,.15));\n    val = mix(val,yellow,quad(uv,.005,.009,.2,.12));\n    val = mix(val,yellow,quad(uv,.005,.009,.2,.09));\n    val = mix(val,black,quad(uv,.005,.009,.2,.06));\n    val = mix(val,yellow,quad(uv,.005,.009,.2,.03));    \n    val = mix(val,yellow,quad(uv,.005,.009,.2,.18));\n    val = mix(val,black,quad(uv,.005,.009,.2,.21));\n    val = mix(val,yellow,quad(uv,.005,.009,.2,.24));\n    \n    val = mix(val,yellow,quad(uv,.005,.009,.22,.15));\n    val = mix(val,yellow,quad(uv,.005,.009,.22,.12));\n    val = mix(val,yellow,quad(uv,.005,.009,.22,.09));\n    val = mix(val,black,quad(uv,.005,.009,.22,.06));\n    val = mix(val,yellow,quad(uv,.005,.009,.22,.03));    \n    val = mix(val,yellow,quad(uv,.005,.009,.22,.18));\n    val = mix(val,black,quad(uv,.005,.009,.22,.21));\n    val = mix(val,yellow,quad(uv,.005,.009,.22,.24));    \n\n    val = mix(val,yellow,quad(uv,.005,.009,.24,.15));\n    val = mix(val,yellow,quad(uv,.005,.009,.24,.12));\n    val = mix(val,yellow,quad(uv,.005,.009,.24,.09));\n    val = mix(val,black,quad(uv,.005,.009,.24,.06));\n    val = mix(val,yellow,quad(uv,.005,.009,.24,.03));    \n    val = mix(val,yellow,quad(uv,.005,.009,.24,.18));\n    val = mix(val,black,quad(uv,.005,.009,.24,.21));\n    val = mix(val,yellow,quad(uv,.005,.009,.24,.24));  \n    \n    val = mix(val,black,quad(uv,.005,.009,.29,.15));\n    val = mix(val,black,quad(uv,.005,.009,.29,.12));\n    val = mix(val,black,quad(uv,.005,.009,.29,.09));\n    val = mix(val,black,quad(uv,.005,.009,.29,.06));\n    val = mix(val,black,quad(uv,.005,.009,.29,.03));\n\n    val = mix(val,black,quad(uv,.005,.009,.31,.15));\n    val = mix(val,black,quad(uv,.005,.009,.31,.12));\n    val = mix(val,black,quad(uv,.005,.009,.31,.09));\n    val = mix(val,black,quad(uv,.005,.009,.31,.06));\n    val = mix(val,black,quad(uv,.005,.009,.31,.03));\n    \n    val = mix(val,black,quad(uv,.005,.009,.37,.15));\n    val = mix(val,black,quad(uv,.005,.009,.37,.12));\n    val = mix(val,black,quad(uv,.005,.009,.37,.09));\n    val = mix(val,black,quad(uv,.005,.009,.37,.06));\n    val = mix(val,black,quad(uv,.005,.009,.37,.03));\n    \n    val = mix(val,black,quad(uv,.005,.009,.39,.15));\n    val = mix(val,black,quad(uv,.005,.009,.39,.12));\n    val = mix(val,black,quad(uv,.005,.009,.39,.09));\n    val = mix(val,black,quad(uv,.005,.009,.39,.06));\n    val = mix(val,black,quad(uv,.005,.009,.39,.03));\n    \n    \n    \n    fragColor = vec4(val,uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssSRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 87, 87, 449], [450, 450, 552, 552, 713], [715, 715, 776, 776, 916], [918, 918, 975, 975, 6299]], "test": "valid"}
{"id": "3sSSRD", "name": "Basic2DGyroid", "author": "bignobody", "description": "Gyroid experiments. Simple repeating 2D mapping with colour cycling.", "tags": ["gyroid"], "likes": 1, "viewed": 61, "published": "Public", "date": "1553043525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 cgyroid(vec3 p)\n{\n    \n  float g = (cos(p.x) * sin(p.y) + cos(p.y) * sin(p.z) + cos(p.z) * sin(p.x));\n\treturn vec3(g);\n // return vec3(g+p.x,g+p.y,g+p.z) * cos(atan(p.x,p.y));\n  //  return vec3(g+p.x,g+p.y,g+p.z) * cos(length(p));\n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    vec2 dc = uv -.5;\n    dc *= 8.0;\n\n    vec3 col = cgyroid(vec3(dc.x,dc.y,cos(iTime)*5.0));\n    col += vec3(sin(iTime), sin(iTime * 0.5), sin(iTime*0.15));\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 248], [251, 251, 308, 358, 661]], "test": "valid"}
{"id": "3ssSW2", "name": "Tuto007 Moiré's Sun", "author": "arthurstammet", "description": "Moiré's Sun\nmy step by step tutorial 7\nby Arthur Stammet, 03.2019\nInspired by Inigo Quilez https://www.youtube.com/watch?v=0ifChJ0nJfM&t=7s", "tags": ["tutorial"], "likes": 1, "viewed": 242, "published": "Public API", "date": "1552249331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Moiré's Sun\n// my step by step tutorial 7\n// by Arthur Stammet, 03.2019\n\n// Inspired by Inigo Quilez https://www.youtube.com/watch?v=0ifChJ0nJfM&t=7s\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set the center to the middle of the screen and make the pixels quadratic\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y; \n\n    // change values here --------------------------------------------------------------\n\n    float CenterX = 0.0;\n\tfloat CenterY = 0.0;\n\n    float radius = 0.25; // radius of the disk ( 0.5 = height of the screen ) \n    float blur = 0.1; // low values for sharper edges\n    \n    // Color of the Disk\n    float red = 0.8; \t// 0.0 <> 1.0\n\tfloat green = 0.5;\t// 0.0 <> 1.0\n\tgreen += sin(iTime*0.1)*0.2;\n    float blue = 0.0; \t// 0.0 <> 1.0\n\n    // Background-Color\n    float Bred = 0.0; \t// 0.0 <> 1.0\n\tfloat Bgreen = 0.0;\t// 0.0 <> 1.0\n\tfloat Bblue = 0.4; \t// 0.0 <> 1.0\n    Bblue += sin(iTime*0.1)*0.2;\n    \n    float ampSpeed = iTime * 0.1;\n    float distSpeed = iTime * 0.03;\n    float rotSpeed = iTime * 2.;\n    float modAmp = 0.5 * (sin(ampSpeed)*0.5); \n    float modFreq = 300. ; \n    float modPhase = rotSpeed; \n    float modDist = 400. + (sin(distSpeed)*400.); \n    \n    // ---------------------------------------------------------------------------------\n    \n\tvec2 CenterXY = p - vec2 ( CenterX, CenterY );\t// center of the disk\n    \n\tradius += modAmp * cos(atan(CenterXY.x,CenterXY.y) * modFreq + modDist * CenterXY.x + modPhase);\n    \n    vec3 disk = vec3 ( red, green, blue ); // disk\t\n\tvec3 back = vec3 ( Bred, Bgreen, Bblue );  // background\n    disk *= smoothstep ( radius, radius-blur, length(CenterXY)); // moving disk (animated)\n    vec3 col = disk + back;\n    \n    fragColor = vec4 ( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 156, 213, 293, 1770]], "test": "valid"}
{"id": "3ssSWj", "name": "#1 Ray_marching_shader", "author": "stupak_da", "description": "Homework", "tags": ["raymarching"], "likes": 1, "viewed": 60, "published": "Public", "date": "1552255119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Math constants\n#define M_PI 3.1415926535897932384626433832795\n#define e 0.01f\n\n// Raymarching constants\n#define MAX_MARCHING_STEPS 300\n#define MAX_DIST 100.0\n#define FOV (M_PI / 2.0) // In radians\n\n\n// Collision constants\n#define SPHERE 0\n#define PLANE 1\n#define CAPSULE 2\n#define BOX 3\n#define ROUNDBOX 4\n#define TORUS 5\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b*vec3(0.5,1.0,0.5)*2.;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) ;\n}\n\n// Signed-distance function of a sphere\nfloat sphereSDF(in vec3 pos, in float radius, in vec3 center) {\n    return length(pos + center) - radius;\n}\n\n// Signed-distance function of a plane\nfloat planeSDF(in vec3 pos, in vec4 normal) {\n    return dot(pos, normal.xyz) + normal.w;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) /dot(ab,ab);\n    t=clamp(t, 0., 1.);\n    \n    vec3 c = a+t*ab;\n    return length(p-c) - r;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sceneSDF(in vec3 pos, out int collision_id) {\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\n    float d_sphere = sphereSDF(pos, 1.0, vec3(-1.0, 1.0  *sin(iTime), 5));\n    float d_sphere1 = sphereSDF(pos, 1.0, vec3(0.0, 0.0, 3.0));\n    float d_plane = planeSDF(pos, vec4(0.0, 1.0, 0.0, 2.0));\n\tfloat d_box = sdBox(pos - vec3(-2.0,0,-3), vec3(0.2,0.3,0.5));\n    float d_capsule = sdCapsule(pos - vec3(6,0, -2), vec3(-2.0,0,-2),vec3(-2,1,-2), 0.5);\n    float d_Roundbox = sdRoundBox(pos - vec3(2,-1.2,-1), vec3(0.2,0.5,0.5), 0.3);\n    float d_torus = sdTorus(pos - vec3(-2.0/*sin(iTime)*/, (-1.0)*sin(iTime),-1.0), vec2(0.5,0.3));\n    \n    if (d_sphere <= d_plane || d_box <=d_plane || d_capsule <=d_plane || d_Roundbox <=d_plane || d_torus <=d_plane) {\n        float d = min(d_sphere, d_box);\n        d = min(d_capsule, d);\n        d= min(d, d_capsule);\n        d=min(d,d_Roundbox);\n        d=min(d,d_torus);\n        if (d == d_sphere || d == d_sphere1) {\n            collision_id = SPHERE;\n        } else if (d == d_capsule) {\n            collision_id = CAPSULE;\n        }\n        else if (d == d_box) {\n            collision_id = BOX;\n        }\n        else if (d == d_Roundbox) {\n            collision_id = ROUNDBOX;\n        } else if (d==d_torus) {\n            collision_id = TORUS;\n        }\n        return d;\n    } else {\n        collision_id = PLANE;\n        return d_plane;\n    }\n}\n\n// SDF of scene which doesn't tell you what you collide with\nfloat sceneSDF(in vec3 pos) {\n    int collision_id;\n    return sceneSDF(pos, collision_id);\n}\n\n// Estimate the normal off of the scene sdf\nvec3 Normal(in vec3 p) {\n    return normalize(vec3(\n            sceneSDF(vec3(p.x + e, p.y, p.z)) - sceneSDF(vec3(p.x - e, p.y, p.z)),\n            sceneSDF(vec3(p.x, p.y + e, p.z)) - sceneSDF(vec3(p.x, p.y - e, p.z)),\n            sceneSDF(vec3(p.x, p.y, p.z  + e)) - sceneSDF(vec3(p.x, p.y, p.z - e))\n        ));\n}\n\nvec3 board_color(vec3 p) {\n\treturn vec3(1.0, 1.0, 1.0);\n}\n\n//  BRDF\nvec3 blinnPhongContribForLight(in vec3 diffuse_color, in vec3 specular_color, in float alpha, in vec3 p, in vec3 eye,\n                          in vec3 lightPos, in vec3 lightIntensity, in float attenuation) {\n    vec3 N = Normal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n    // Light not visible from this point\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    // Light reflection in opposite direction as viewer, apply only diffuse lighting\n    if (dotRV < 0.0) {\n        vec3 d= lightIntensity*attenuation;\n        vec3 k = diffuse_color * dotLN;\n        return d*k;\n    }\n\n    // Blinn - phong calculation\n    vec3 half_direction = normalize(normalize(L) + V);\n    float specular = pow(max(dot(half_direction, N), 0.0), 16.0);\n    vec3 light = lightIntensity * diffuse_color * dotLN * attenuation;\n    vec3 color = specular_color * pow(dotRV, alpha) * specular * attenuation;\n    return light+color;\n\n}\n\n\n\nvec3 blinnPhongIllumination(vec3 diffuse_color,\n                            vec3 specular_color, float alpha, float attenuation,\n                            vec3 light_pos, float light_intense,\n                            vec3 point_pos, vec3 eye) {\n    vec3 light_I = light_intense * vec3(1.0, 1.0, 1.0);\n\n    vec3 color = blinnPhongContribForLight(diffuse_color, specular_color, alpha, point_pos, eye,\n                                  light_pos,\n                                  light_I, attenuation);\n    \n\n    return color;\n}\n\n//Camera rotation\nmat3 Rotation(vec2 angle)\n{\n  vec2 c = cos(angle);\n  vec2 s = sin(angle);\n  mat3 temp = mat3(\n      c.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x);\n    return temp;\n}\n\n//RayMarching algorithm\nfloat RayMarch(in vec3 eye, in vec3 ray_dir, out int collision_id) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i) {\n        float d = sceneSDF(eye + depth * ray_dir, collision_id);\n        if (d < e) {\n            return depth;\n        }\n        depth += d;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 rayDirection(in float fieldOfView, in vec2 size, in vec2 frag_coord) {\n    vec2 xy = frag_coord - size / 2.0;\n    float z = size.y / tan(fieldOfView / 2.0);\n    vec3 d = normalize(vec3(xy, -z));\n    return d;\n}\n\n\nfloat shadow_calculate(in vec3 ray_origin, in vec3 ray_direction, in float min_t, \n             in float max_t, in float k) {\n    float res = 1.0;\n    for (float t = min_t; t < max_t; ) {\n        float dist = sceneSDF(ray_origin + ray_direction * t);\n        if (dist < e) {\n            return 0.0;\n        }\n        res = min(res, k * dist / t);\n        t += dist;\n    }\n    return res;\n}\n\nvec3 calculate_color(vec3 eye, vec3 p, int collision_id, vec3 ray_dir) {\n\n    // Determine / define blinn-phong calculation components\n    vec3 ambient_color = vec3(0.2, 0.2, 0.2);\n    vec3 diffuse_color;\n    if (collision_id == SPHERE) {\n        diffuse_color = vec3(0.0, 0.5, 1.0);\n    } else if (collision_id == PLANE) {\n        diffuse_color = board_color(p);\n    } else if (collision_id == CAPSULE) {\n        diffuse_color = vec3(0.7,0.5,0);\n    } else if (collision_id == BOX) {\n        diffuse_color = vec3(0.5, 0.3, 0.3);\n    } else if (collision_id == ROUNDBOX) {\n        diffuse_color = vec3(0.2, 0.8,0.2);\n    } else if (collision_id == TORUS) {\n        diffuse_color = vec3(1.0,0.0,0.0);\n        ambient_color = vec3(0.5,0,0.5);\n    }\n    \n    vec3 specular_color = vec3(0, 1.0, 1.0);\n    float shininess = 50.0;\n\n    // Light attributes\n    vec3 lightPos1 = vec3(4.0 /** sin(iTime)*/,\n                              1.0,\n                              0.0 /* cos(iTime)*/);\n    float lightIntensity = 1.0f;\n    vec3 lightPos2 = vec3(-4.0, 1.0, 6.0);\n    \n\n    // Compute the ambient component of light\n    vec3 ambient_light = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambient_light * ambient_color;\n\n    // Compute if the point of calculation is obstructed by any objects from the light\n    vec3 shadow_ray1 = normalize(lightPos1 - p);\n    vec3 shadow_ray2 = normalize(lightPos2 - p);\n    float shadow_factor1 = shadow_calculate(p + shadow_ray1, shadow_ray1, 0.0, MAX_DIST, 8.0);\n\tfloat shadow_factor2 = shadow_calculate(p + shadow_ray2, shadow_ray2, 0.0, MAX_DIST, 8.0);\n    // Add the diffuse and specular components\n    vec3 blinn_phong_contribution = blinnPhongIllumination(diffuse_color, specular_color, shininess, 0.5,\n                                    lightPos1, lightIntensity, p, eye) * shadow_factor1;\n    color += blinn_phong_contribution;\n\tblinn_phong_contribution = blinnPhongIllumination(diffuse_color, specular_color, shininess, 0.5,\n                                    lightPos2, lightIntensity, p, eye) * shadow_factor2;\n    color += blinn_phong_contribution;\n    // Reflect light off of the sphere\n\t\n    return color;\n\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*158.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec3 eye = vec3(0, 0, 8);\n    mat3 rot = Rotation((iMouse.xy - iResolution.xy * 0.5).yx * vec2(0.01, -0.01));\n    \n    vec3 ray_dir = rayDirection(FOV, iResolution.xy, fragCoord);\n    vec3 eye1 = vec3(0,0,6);\n\t\n    eye = rot * eye;\n    ray_dir = rot * ray_dir;\n    int collision_id, collision_id1;\n    \n    float dist = RayMarch(eye, ray_dir, collision_id);\n    vec3 p = eye + dist * ray_dir;\n    //vec3 p1=e\n\t\n    vec3 color;\n    if (dist > MAX_DIST - e) {\n        // Create nice gradient effect for the background\n        color = vec3(0.0, .8-sqrt(ray_dir.y * 2.0), .8-sqrt(ray_dir.y * 3.0));\n        vec3 col = pow( color, vec3(0.4545) );\n\n    \t// vignetting    \n    \tcol *= 0.25 + 0.75*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    \t// dithering\n    \tcol += (1.0/255.0)*hash3(q.x+13.0*q.y);\n        fragColor = vec4(col, 1.0);\n        \n    } else {\n        // Something was hit\n        color = calculate_color(eye, p, collision_id, ray_dir);\n        \n    \tvec3 col = pow( color, vec3(0.4545) );\n   \n    \tcol *= 0.25 + 0.75*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    \tcol += (1.0/255.0)*hash3(q.x+13.0*q.y);\n        fragColor = vec4(col, 1.0);\n    \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 326, 357, 357, 470], [472, 512, 575, 575, 619], [621, 660, 705, 705, 751], [753, 753, 798, 798, 952], [955, 955, 1005, 1005, 1167], [1170, 1170, 1203, 1203, 1268], [1270, 1270, 1321, 1321, 2670], [2672, 2733, 2762, 2762, 2826], [2828, 2872, 2896, 2896, 3186], [3188, 3188, 3214, 3214, 3245], [3247, 3256, 3465, 3465, 4316], [4320, 4320, 4569, 4569, 4851], [4853, 4871, 4898, 4898, 5075], [5077, 5101, 5169, 5169, 5486], [5488, 5488, 5563, 5563, 5703], [5706, 5706, 5831, 5831, 6095], [6097, 6097, 6169, 6231, 8251], [8253, 8253, 8276, 8276, 8330], [8332, 8332, 8389, 8389, 9604]], "test": "valid"}
{"id": "3ssSWM", "name": "The Beast With Many Eyes", "author": "mathmasterzach", "description": "Use the mouse to move around. Remember that it is always watching you.", "tags": ["fractal", "mandelbrot", "eyes", "folding", "distance"], "likes": 14, "viewed": 438, "published": "Public API", "date": "1551555015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float AA=2.;\nvec3 fractal(vec2 crd){\n    vec2 c=((2.*crd-iResolution.xy)/iResolution.y)/35.;\n   \tvec2 ms=2.*iMouse.xy/iResolution.xy-1.;\n    c+=ms;\n   \tvec2 z=c;\n    float dz=dot(z,z);\n    float i;\n    float m=0.;\n    for(i=0.;i<20.;i++){\n\t\tz=abs(z)/dz-vec2(.9,.3);\n        m=max(m,dz);\n        dz=dot(z,z);\n\t}\n    for(i=0.;i<64.;i++){\n    \tz=vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)-vec2(.9,.3);\n        if(dot(z,z)>4.){\n        \tbreak;\n        }\n    }\n    float ic=5.*i/64.;\n    float it=clamp(sqrt(m)/(20.+15.*sin(iTime)),0.,8.);\n    vec3 col=cos(it-ic+vec3(1.,2.,3.));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col=vec3(0.);\n    for(float i=0.;i<AA;i++){\n    \tfor(float j=0.;j<AA;j++){\n    \t\tcol+=fractal(fragCoord+(vec2(i,j)/AA));\n    \t}\n    }\n    col/=AA*AA;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssSWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 36, 36, 582], [584, 584, 640, 640, 832]], "test": "valid"}
{"id": "3sSSWz", "name": "fbm thermography", "author": "takumifukasawa", "description": "fbm thermography", "tags": ["fbm"], "likes": 2, "viewed": 78, "published": "Public", "date": "1553340770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// ref.\n// https://thebookofshaders.com/13/?lan=jp\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n\n// Get random value\nfloat random(in vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm(in vec2 st) {\n  float value = 0.;\n  float amp = .5;\n  float freq = 0.;\n\n  for(int i = 0; i < OCTAVES; i++) {\n    value += amp * noise(st);\n    st *= 2.1;\n    amp *= .4;\n  }\n  return value;\n}\n\nfloat pattern(in vec2 p) {\n  float f = 0.;\n  vec2 q = vec2(\n    fbm(p + iTime * .2 + vec2(0., .4)),\n    fbm(p + iTime * .3 + vec2(2.4, 4.8))\n  );\n  vec2 r = vec2(\n    fbm(q + iTime * .3 + 4. * q + vec2(3., 9.)),\n    fbm(q + iTime * .2 + 8. * q + vec2(2.4, 4.))\n  );\n  f = fbm(p + r * 2. + iTime * .09);\n  return f;\n}\n\nfloat rect(float c, float min, float max, float s) {\n  return smoothstep(min, min + s, c) * (1. - smoothstep(max - s, max, c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // fix aspect uv\n  vec2 uv = (gl_FragCoord.xy - .5 * iResolution.xy);\n  uv = 2. * uv.xy / iResolution.y;\n\n  vec3 color = vec3(0.);\n  float f = pattern(uv);\n\n  color += vec3(1., 0., 0.) * rect(f, 0., .35, .01);\n  color += vec3(0., 1., 0.) * rect(f, .3, .55, .01);\n  color += vec3(0., 0., 1.) * rect(f, .5, .8, .01);\n\n  fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSSWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 129, 155, 155, 231], [233, 233, 259, 259, 639], [659, 659, 682, 682, 859], [861, 861, 887, 887, 1177], [1179, 1179, 1231, 1231, 1308], [1310, 1310, 1367, 1386, 1718]], "test": "valid"}
{"id": "3ssSz2", "name": "Well-Behaved Contrast", "author": "TheSandvichMaker", "description": "An easily controllable sigmoidal contrast operator which will not clip or reduce the range of the image.\nmouse.x = midpoint\nmouse.y = contrast\nEDIT: added an optimized version, in the graph in red. original version in the graph in white.", "tags": ["postprocessing", "imageprocessing", "contrast", "curve", "sigmoid"], "likes": 11, "viewed": 287, "published": "Public", "date": "1551707088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// uncomment this to apply saturation preserving contrast\n// #define SATURATION_PRESERVING\n\n\n// set whether to apply the optimized or original version to the image\n// optimized: optimizedSigmoidContrast\n// original: originalSigmoidContrast\n#define IMAGE_EFFECT originalSigmoidContrast\n\n\n// the optimized version has perhaps a slightly less smooth curve at intermediate contrast\n// levels and is limited to the range 0-2 before it starts clipping / creating odd curves\n// and it isn't as good at lowering contrast, but it uses fewer instruction slots and no pow().\n\n\n#define remap(v, a, b) (((v) - (a)) / ((b) - (a)))\n\n\nfloat graphFunction(float f, vec2 uv, float thickness)\n{\n    vec2 pix_size = 1.0 / iResolution.xy;\n\tthickness *= pix_size.y;\n    \n    f = (f - 0.5) * (1.0 - thickness) + 0.5;\n    \n    float dist = abs(f - uv.y);\n    return smoothstep(thickness, 0.0, dist);\n}\n\n\nfloat optimizedSigmoidContrast(float color, float contrast, float mid)\n{\t\n    // optimized version (range of [0;2] to match old function)\n    float scale_l = (1.0 / mid) * color;\n    float scale_h = (1.0 / (1.0 - mid)) - (1.0 / (1.0 - mid)) * color;\n    float lower = mid * (scale_l * scale_l);\n    float upper = 1.0 - (1.0 - mid) * (scale_h * scale_h);\n\tfloat curve = color < mid ? lower : upper;\n    return mix(color, curve, (contrast - 1.0));\n\n    // for a range of [-1;1]:\n    // return mix(color, curve, contrast);\n}\n\n\nvec3 optimizedSigmoidContrast(vec3 color, float contrast, float midpoint)\n{\n    return vec3(\n        optimizedSigmoidContrast(color.r, contrast, midpoint),\n    \toptimizedSigmoidContrast(color.g, contrast, midpoint),\n        optimizedSigmoidContrast(color.b, contrast, midpoint)\n    );\n}\n\n\nfloat originalSigmoidContrast(float color, float contrast, float mid)\n{\t\n    // rescaling contrast to more easily compare with optimized version:\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    \n\t// original version:\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);    \n\treturn color < mid ? lower : upper;\n}\n\n\nvec3 originalSigmoidContrast(vec3 color, float contrast, float midpoint)\n{\n    return vec3(\n        originalSigmoidContrast(color.r, contrast, midpoint),\n    \toriginalSigmoidContrast(color.g, contrast, midpoint),\n        originalSigmoidContrast(color.b, contrast, midpoint)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pix_size = 1.0/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 image_uv = uv;\n    \n    float contrast = sin(float(iFrame) / 60.0) * 0.8 + 1.2;\n    float midpoint = 0.4;\n    float graph_size = 0.2;\n    \n    if (iMouse.z > 0.5)\n    {\n        graph_size = 0.3;\n        image_uv.y = remap(image_uv.y, graph_size, 1.0);\n        \n        vec2 mouse = iMouse.xy / iResolution.xy;\n        contrast = clamp(mouse.y / graph_size, 0.0, 1.0) * 2.0;\n        midpoint = mouse.x;\n    }\n    \n    vec3 col = texture(iChannel0, image_uv).rgb;\n    \n#ifdef SATURATION_PRESERVING\n    float peak = max(col.r, max(col.g, col.b));\n    col /= peak+1e-6;\n    peak = IMAGE_EFFECT(peak, contrast, midpoint);\n    col *= peak;\n#else \n    col = IMAGE_EFFECT(col, contrast, midpoint);\n#endif\n    \n    if (uv.y < graph_size)\n    {\n     \tvec2 graph_uv = uv;\n        graph_uv.y = remap(graph_uv.y, 0.0, graph_size);\n        float f_1 = optimizedSigmoidContrast(graph_uv.x, contrast, midpoint);\n        float f_2 = originalSigmoidContrast(graph_uv.x, contrast, midpoint);\n        col = vec3(0.25) + vec3(0.25) * step(fract((graph_uv.x+pix_size.x) * 10.0), pix_size.x * 20.0);\n        col += graphFunction(f_1, graph_uv, 2.0 / graph_size) * vec3(1.0, 0.2, 0.2);\n        col += graphFunction(f_2, graph_uv, 2.0 / graph_size);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssSz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 619, 675, 675, 877], [880, 880, 952, 1017, 1401], [1404, 1404, 1479, 1479, 1690], [1693, 1693, 1764, 1838, 2179], [2182, 2182, 2256, 2256, 2464], [2467, 2467, 2524, 2524, 3878]], "test": "error"}
{"id": "3ssSzB", "name": "midterms 6", "author": "jojo169", "description": "6 added function   ", "tags": ["6"], "likes": 0, "viewed": 49, "published": "Public", "date": "1551716429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float leaf(float angle,float numbeleaf)\n{\n    float radius = abs(sin(angle+10.+iTime)*sin(angle*numbeleaf+iTime))*2.;\n    return radius;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \nvec3 red = vec3(1.,0.,0.);\nvec3 blue = vec3(0.,0.,1.);\nvec3 green = vec3(0,1.,0.);\nvec3 yellow = vec3(1.,1.,0.);\nvec3 black = vec3(0.,0.,0.);\nvec3 gray = vec3(.5,.5,.3);\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos= vec2(.5*ratio,.5);\n    float dist = distance(shapePos,uv)*2.;\n    \n    uv -=shapePos;\n    float angle= atan(uv.y,uv.x);\n    float radius = cos(.2*angle);\n  \n    \n    float value = 1.-step(leaf(angle,10.),dist);\n    \n    vec3 val = mix(yellow,sin(iTime)+green,value);\n    \n    fragColor = vec4(val,uv);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssSzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 138], [142, 142, 199, 199, 866]], "test": "valid"}
{"id": "3ssXDj", "name": "Emissive Square", "author": "Xor", "description": "Today I was experimenting with simple light attenuation and here's what I came up with.", "tags": ["square", "glow"], "likes": 12, "viewed": 554, "published": "Public", "date": "1552244527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\"Emissive Square\" by Xor (@XorDev)\n\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\t\n\tToday I was experimenting with simple light attenuation and here's what I came up with.\n*/\nvoid mainImage(out vec4 Color, in vec2 Coord)\n{\n    float Time = iTime*.75;\n\t\n    float Angle = (pow(fract(Time),6.)+floor(Time))*3.14159265/2.;\n    vec2 Trig = vec2(cos(Angle),sin(Angle));\n    \n    vec2 Pos = (Coord-.5*iResolution.xy)/iResolution.y*mat2(Trig.x,Trig.y,-Trig.y,Trig.x);\n    float Size = .2+.03*pow(1.-abs(fract(Time+.45)-.5),8.);\n    \n    float Dist = length(max(abs(Pos)-Size,0.));\n    float Glow = 1./(Dist*25.+.5);\n    \n    Color = vec4(Glow*vec3(.4,1,.1),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssXDj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 219, 266, 266, 699]], "test": "valid"}
{"id": "3ssXDS", "name": "Animated Greyscale Crystal", "author": "arthurstammet", "description": "Animated Greyscale Crystal\nmy step by step tutorial\n", "tags": ["greyscale", "crystal"], "likes": 4, "viewed": 262, "published": "Public API", "date": "1552086155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Animated Greyscale Crystal\n// my step by step tutorial\n// Inspired by https://www.youtube.com/watch?v=l-07BXzNdPw\n\n// create random numbers for x and y\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y; // -1 <> 1\n    \n    // Change values here ------------------------------------------------------\n    \n    float window = 1.3;\n    float t = (iTime+150.)*.1;\n    float density = 500.;\n    float brightness = .3; // high values for more brightness\n    float contrast = 2.; // low values for higher contrast\n    \n    // -------------------------------------------------------------------------\n    \n    float minDist = 50.;\n\tfloat xFactor = (iResolution.x/iResolution.y)*window;\n    float m = 0.;\n    float cellIndex = 0.;\n    float Greyscale = 1.;\n\n    for(float i=0.; i<density; i++) {\n        vec2 n = N22(vec2(i));\n        vec2 p = sin(n*t);\n\t\tp.x *= xFactor;\n\t\tp.y *= window;\n        \n        float d = length(uv-p);\n\n        if(d<minDist) {\n\t    \tminDist = d;\n            cellIndex = i;\n            Greyscale = brightness+(cellIndex/(density*contrast));\n\t\t}\n    }\n\n    vec3 col = vec3(Greyscale);\t\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssXDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 155, 173, 173, 299], [301, 301, 358, 358, 1356]], "test": "valid"}
{"id": "3ssXR2", "name": "Midterms_Co_Design6", "author": "johannco98", "description": "asd", "tags": ["asd"], "likes": 1, "viewed": 42, "published": "Public", "date": "1551704901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Spikes(float angle, float armSpeed, float armNum, float armWidth, float size)\n{\n    float spikes =  1.0 / (abs(cos(angle * 0.5 + (iTime * armSpeed)) \n                        * sin(angle * armNum )))\n        \t\t\t\t\t\t\t\t\t\t\t* armWidth +      size;\n    \n    return spikes;\n    \n}\n\nfloat GetRate(float rate)\n{\n    float s = clamp(sin(rate),0.1, 1.0);\n    return s;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos = vec2((0.5 * ratio) /*plus minus something to adjust Pos*/, 0.5);\n    float dist = distance(shapePos , uv) * 2.50;\n    \n    vec3 black = vec3(0.0 , 0.0, 0.0);\n    \n    uv -= shapePos;\n    \n    float angle = atan(uv.y, uv.x);\n    float radius = sin(4.0 * angle);\n    \n    float radius2 =  1.0 /  abs(cos(angle * 100.0 ) \n                           * sin(angle * 2.0 ))\n        \t\t\t\t\t\t\t\t\t\t* 0.5 + 0.1;\n    \n    float cross;\n\n    float rate = GetRate(15.0);\n   \n    \n    float value =  step(( radius2 * rate * rate * iTime) * 0.02, dist);\n    \n    \n        \n    // Output to screen\n    fragColor = vec4(value + vec4(vec3(0.4, 0.2, 0.2) , 1.0));\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssXR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 85, 85, 278], [280, 280, 307, 307, 364], [367, 367, 424, 474, 1257]], "test": "valid"}
{"id": "3ssXRj", "name": "Shader4 - Controlled movement", "author": "EmperorLem", "description": "3 Shapes with different movement", "tags": ["colorandfunctions"], "likes": 1, "viewed": 68, "published": "Public", "date": "1551703374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 black = vec3(0.0,0.0,0.0);\nvec3 maroon = vec3(0.7,0.0,0.0);\nvec3 blue = vec3(0.5,0.5,.5);\nvec3 yellow = vec3(0.9,0.9,0.0);\nvec3 white = vec3(1.0,1.0,1.0);\n\n\nfloat spikey(vec2 uv, vec2 pos, float r)\n{   \n    float dist = distance(pos, uv) * r;\n    float value = step(r, dist);\n    \n    uv -= pos;\n    \n    float speed = 0.5;\n\n    float angle = (atan(uv.y, uv.x) - iTime * speed);\n    \n    float radius = sin(angle * 74.0) * sin(angle * 40.0) * sin(angle * 8.0);\n    \n    value = step(radius , dist);\n    \n    return value;\n}\n\nfloat flower(vec2 uv, vec2 pos, float r)\n{   \n    float dist = distance(pos, uv) * r;\n    float value = step(r, dist);\n    \n    uv -= pos;\n    \n    float speed = 2.0;\n\n    float angle = (atan(uv.y, uv.x) + iTime * speed);\n    \n    float radius = abs(cos(angle * 10.0));\n    \n    value = step(radius , dist);\n    \n    return value;\n}\n\nfloat gear(vec2 uv, vec2 pos, float r)\n{   \n    float dist = distance(pos, uv) * r;\n    float value = step(r, dist);\n    \n    uv -= pos;\n    \n    float speed = 2.0;\n\n    float angle = (atan(uv.y, uv.x) + iTime * speed);\n    \n    float radius = smoothstep(-0.5, 1.0, cos(angle * 8.0)) * 0.2 + 0.5;\n    \n    value = step(radius , dist);\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col2 = 0.5 + 0.5*fract(iTime+uv.xyx+vec3(0,2,4));\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float mSpikey = spikey(uv, vec2(sin(0.9 * iTime) / 1.5 + 0.9, 0.2), 5.0);\n    float mFlower = flower(uv, vec2(sin(2.0 * iTime) / 2.5 + 0.7,\n                                    cos(2.0 * iTime) / 2.5 + 0.5), 5.0);\n    float mGear = gear(uv, vec2(sin(0.5 * iTime) / 1.5 + 1.0,\n                                    cos(2.0 * iTime) / 2.5 + 0.5), 5.0);\n    \n    vec3 spiCol = mix( col, black, mSpikey);\n    vec3 floCol = mix(col2, black, mFlower);\n    vec3 geCol = mix(col, black, mGear);\n    \n    vec3 image = mix(spiCol, blue, spiCol);\n    image = mix(floCol, vec3(mFlower), image);\n    image = mix(geCol, vec3(mGear), image);\n    \n    // Output to screen\n    fragColor = vec4(image,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 204, 204, 528], [530, 530, 572, 572, 862], [864, 864, 904, 904, 1223], [1225, 1225, 1282, 1332, 2235]], "test": "valid"}
{"id": "3ssXRl", "name": "Steel Alphabet", "author": "BlueLightning42", "description": "shitty practicing of drawing shapes/Glyphs from https://coppermind.net/wiki/Steel_alphabet\nlast minute domain warping added to background", "tags": ["glyph", "mistborn", "steelalphabet"], "likes": 12, "viewed": 335, "published": "Public", "date": "1551892248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#define PI      3.14159265358979323846264\n#define TWO_PI  6.28318530717958647692528\n#define HALF_PI 1.57079632679489661923132\n#define TRQT_PI 4.71238898038468985769396\n\n#define PHI 1.61803398874989484820459\n\n\nfloat rand( in vec2 st ){\n    return fract(sin(dot(st, vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat rand( in float st, in float seed ){\n    return fract(sin(dot(vec2(st,seed), vec2(12.9898,78.233)))*43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat getAngle(in vec2 st){\n    return atan(0.5-st.y,0.5-st.x);\n}\nfloat getRadius(in vec2 st){\n    return length(0.5-st)*2.0;\n}\n// better performance than sqrt versions\nfloat drawCircle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),_radius+(_radius*0.01),dot(dist,dist)*4.0);\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n// messed up space this helps me move nicly (ish)\nvec2 translate(vec2 _t){\n    return vec2(-_t.y,_t.x);\n}\n\nvoid fill(inout vec3 bg, in vec2 st, in float a){\n    if (a < 1.0){\n        bg = hsb2rgb(vec3(getRadius(st)*0.2+sin(0.676+iTime)*.2,0.2,clamp(1.0 - fbm(st*10.)*.5,0.5,0.7)));\n    }\n}\n\n\nfloat positive(in float x){\n    if ( x <= 0.0){\n        return 0.0;\n    }else{\n        return x;\n    }\n}\nfloat drawMoon(in vec2 st, in float offset, in float smallRad){\n    return positive(drawCircle(st+.5,.4)-drawCircle(st+.5-offset,smallRad));\n}\nfloat partMoon(in vec2 st, in float angle){\n    if (angle < 1.0)\n    \treturn getAngle(st) > angle ? positive(drawCircle(st+.5,.4)-drawCircle(st+.4,.4)) : 0.0;\n    else\n        return getAngle(st) < fract(angle) ? positive(drawCircle(st+.5,.4)-drawCircle(st+.4,.4)) : 0.0;\n}\nfloat drawSpike(in vec2 st){\n    float a=1.0;\n    st.y -= .5;\n    if (abs(st.y)-pow((st.x-0.5)*4.+0.036,3.)*0.01 < 0.017 && st.x < 0.936){\n        a = 0.;\n    }\n    \n    return 1.-a;\n}\n\n\n//really awful transformations due to drawn objects not having an origin and me trying to account for that by switching around some things\nfloat glyph2(in vec2 _st, in float seed){\n    float r = rand(seed, PHI);\n    float a = 0.0;\n\n    _st -= .5;\n    if(r <= 1./24.){\n        a = drawSpike(_st * rotate2d(TRQT_PI)+vec2(0.470,0.480));\n    }else{\n        // 7 have same cresent\n        if(r <= 7./24.){\n            a += drawMoon(_st, .1, .4);\n            if(r <= 2./24.){ // Iron\n                a += drawSpike(_st * rotate2d(-1.992) * scale(vec2(1.990,1.460)) + translate(vec2(0.430,-0.050)));\n                a += drawSpike(_st * rotate2d(-2.648) * scale(vec2(1.990,1.460)) + translate(vec2(0.490,0.020)));\n                a += drawCircle(_st-vec2(-0.560,-0.180),0.006);\n            }else if(r <= 3./24.){ // Zinc\n                a += drawSpike(_st * rotate2d(-1.032) * scale(vec2(1.690,1.560)) + translate(vec2(0.530,-1.080)));\n                a += drawSpike(_st * rotate2d(-1.060) * scale(vec2(1.690,1.560)) + translate(vec2(0.300,-0.990)));\n                a += drawCircle(_st-vec2(-0.360,-0.390),0.006);\n            }else if(r <= 4./24.){ // unkown/H\n                a += drawSpike(_st * rotate2d(-0.704) * scale(vec2(1.690,1.560)) + translate(vec2(0.600,-1.070)));\n                a += drawSpike(_st * rotate2d(0.348) * scale(vec2(1.690,1.560)) + translate(vec2(0.450,-1.070)));\n                a += drawCircle(_st-vec2(-0.360,-0.390),0.006);\n            }else if(r <= 5./24.){ // Malatium\n                a += drawSpike(_st * rotate2d(2.312) * scale(vec2(1.990,0.800)) + vec2(1.490,0.470));\n                a += drawSpike(_st * rotate2d(-1.824) * scale(vec2(1.790,1.560)) + translate(vec2(0.530,-1.120)));\n                a += drawSpike(_st * rotate2d(0.548) * scale(vec2(1.690,1.560)) + translate(vec2(0.460,-1.160)));\n                a += drawSpike(_st * rotate2d(-0.260) * scale(vec2(1.990,1.660)) + translate(vec2(0.450,-1.150)));\n                a += drawSpike(_st * rotate2d(-0.916) * scale(vec2(1.990,1.660)) + translate(vec2(0.500,-1.120)));\n                a += drawCircle(_st-vec2(-0.360,-0.390),0.006);\n            }else if(r <= 6./24.){ // Lerasium\n                _st += 0.012;\n                a += drawSpike(_st * rotate2d(1.928) * scale(vec2(1.690,1.560)) + translate(vec2(0.400,-0.270)));\n                a += drawSpike(_st * scale(vec2(1.430,1.360)) * rotate2d(2.648)  + translate(vec2(0.590,-0.30))); //slight curve to nail with different order of transforms failed\n                a += drawCircle(_st-vec2(-0.360,-0.390),0.006);\n                a += partMoon(_st* rotate2d(0.488) * scale(vec2(1.290,0.910))+ vec2(+0.230,+0.110),1.648);\n            }else if(r <= 7./24.){ // Electrum\n                a += partMoon(_st  * rotate2d(7.088)* scale(vec2(1.3,1.000))+vec2(0.080,-0.020),0.472);\n                _st += 0.012;\n                a += drawSpike(_st  * rotate2d(3.952) * scale(vec2(1.290,1.260))  + translate(vec2(0.590,-0.30))); //slight curve to nail with different order of transforms failed\n                a += drawCircle(_st-vec2(-0.350,-0.570),0.006);\n            }\n        }else if(r <= 10./24.){\n            a += drawMoon(_st* rotate2d(5.512)* scale(vec2(0.960,0.980)),0.050, .28);\n            if(r <= 8./24.){ // Cadmium\n                a += drawSpike(_st * rotate2d(-PI) * scale(vec2(1.090,1.260)) + translate(vec2(0.580,-0.470)));\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(1.990,1.460)) + translate(vec2(0.490,-1.120)));\n                a += drawCircle(_st-vec2(-0.480,-0.200),0.006);\n            }else if(r <= 9./24.){ // Chromium\n                a += drawSpike(_st * rotate2d(-2.160) * scale(vec2(1.390,1.060)) + translate(vec2(0.580,-0.870)));\n\t\t\t\ta += partMoon(_st  * rotate2d(5.076)* scale(vec2(1.3,1.300))+vec2(-0.110,-0.050),1.968);\n                a += drawCircle(_st-vec2(-0.480,-0.200),0.006);\n            }else if(r <= 10./24.){ // Malatium\n                _st = _st * rotate2d(-1.104); \n                a += drawSpike(_st * rotate2d(-2.524) * scale(vec2(1.790,1.560)) + translate(vec2(0.530,-1.120)));\n                a += drawSpike(_st * rotate2d(3.740) * scale(vec2(1.690,1.560)) + translate(vec2(0.560,-0.060)));\n\t\t\t\ta += drawSpike(_st * rotate2d(-1.500) * scale(vec2(1.990,1.660)) + translate(vec2(0.500,-1.120)));\n                a += drawSpike(_st * rotate2d(-0.404) * scale(vec2(1.990,1.660)) + translate(vec2(0.500,-1.120)));\n                a += drawCircle(_st-vec2(-0.310,-0.350),0.006);\n            }\n        }else if(r <= 14./24.){\n            if (r <= 12./24.) _st *= rotate2d(PI); // two left two right\n            a += drawMoon(_st* rotate2d(-0.600)* scale(vec2(0.780,-0.910))+ vec2(0.010,0.000),0.060, .29);\n            if(r <= 11./24.){ // unknown/C\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(1.990,1.460)) + translate(vec2(0.490,-1.120)));\n                a += drawSpike(_st * rotate2d(+HALF_PI) * scale(vec2(1.990,1.460)) + translate(vec2(0.490,-1.120)));\n                a += drawCircle(_st-vec2(-0.490,-0.500),0.006);\n            }else if(r <= 12./24.){ // unknown/X\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(0.790,1.460)) + translate(vec2(0.540,-0.580)));\n                a += drawCircle(_st-vec2(-0.60,-0.500),0.006);\n            }else if(r <= 13./24.){ // unknown/J\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(1.990,1.460)) + translate(vec2(0.490,-1.120)));\n                a += drawCircle(_st-vec2(-0.310,-0.520),0.006);\n            }else if(r <= 14./24.){ // Bendalloy\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(0.790,1.460)) + translate(vec2(0.540,-0.580)));\n                a += drawSpike(_st * rotate2d(-PI) * scale(vec2(0.790,1.460)) + translate(vec2(0.740,-0.580)));\n                a += drawCircle(_st-vec2(-0.350,-0.470),0.006);\n            }\n        }else if(r <= 21./24.){\n            if (r > 17./24.) _st *= rotate2d(PI) * scale(vec2(.8)); // three down rest up\n            a += drawMoon(_st* rotate2d(TRQT_PI/2.) * scale(vec2(1.3))+ vec2(0.010,0.000),0.036, .29);\n            if(r <= 15./24.){ // Tin\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(1.00,1.460)) + translate(vec2(0.520,-0.520)));\n                a += drawCircle(_st-vec2(-0.490,-0.040),0.006);\n                a += drawMoon(_st* rotate2d(TRQT_PI/2.) * scale(vec2(0.8))+ vec2(0.010,0.000),0.036, .29);\n            }else if(r <= 16./24.){ // unknown/X\n                a += drawSpike(_st * rotate2d(-2.440) * scale(vec2(1.00,1.460)) + translate(vec2(0.520,-0.520)));\n                a += drawCircle(_st-vec2(-0.470,-0.640),0.006);\n                a += drawMoon(_st* rotate2d(TRQT_PI/2.) * scale(vec2(0.8))+ vec2(0.010,0.000),0.036, .29);\n            }else if(r <= 17./24.){ // Pewter\n                a += drawSpike(_st * rotate2d(-2.440) * scale(vec2(1.00,1.460)) + translate(vec2(0.520,-0.520)));\n                a += drawCircle(_st-vec2(-0.580,-0.590),0.006);\n                a += partMoon(_st* rotate2d(TRQT_PI/2.376) * scale(vec2(0.8,1.2))+ vec2(0.010,0.200), 0.610);\n            }else if(r <= 18./24.){ // Copper\n                a += drawSpike(_st * rotate2d(0.720) * scale(vec2(0.990,1.460)) + translate(vec2(0.470,-0.7040)));\n                a += drawSpike(_st * rotate2d(0.736) * scale(vec2(1.990,1.370)) + translate(vec2(0.60,-1.120)));\n                a += drawCircle(_st-vec2(-0.350,-0.470),0.006);\n            }else if(r <= 19./24.){ // Bronze\n                a += drawSpike(_st * rotate2d(4.336) * scale(vec2(1.10,1.460)) + translate(vec2(0.490,-0.5240)));\n                a += drawSpike(_st * rotate2d(3.992) * scale(vec2(1.390,1.370)) + translate(vec2(0.40,-0.320)));\n                a += drawCircle(_st-vec2(-0.590,-0.640),0.006);\n            }else if(r <= 20./24.){ // Atrium\n                _st = _st * rotate2d(2.192); \n                a += drawSpike(_st * rotate2d(-2.524) * scale(vec2(2.990,1.560)) + translate(vec2(0.530,-1.380)));\n                a += drawSpike(_st * rotate2d(3.740) * scale(vec2(2.890,1.60)) + translate(vec2(0.540,-0.130)));\n\t\t\t\ta += drawSpike(_st * rotate2d(-1.500) * scale(vec2(2.890,1.660)) + translate(vec2(0.600,-1.220)));\n                a += drawSpike(_st * rotate2d(-0.404) * scale(vec2(2.80,1.660)) + translate(vec2(0.540,-1.220)));\n                a += drawCircle(_st-vec2(-0.310,-0.350),0.006);\n            }else if(r <= 21./24.){ // Aluminum\n                _st = _st * rotate2d(2.192); \n                a += drawSpike(_st * rotate2d(-2.588) * scale(vec2(2.990,1.560)) + translate(vec2(0.530,-1.380)));\n                a += drawSpike(_st * rotate2d(1.092) * scale(vec2(2.890,1.60)) + translate(vec2(0.460,-1.280)));\n                a += drawSpike(_st * rotate2d(-0.740) * scale(vec2(2.80,1.660)) + translate(vec2(0.540,-1.220)));\n                a += drawCircle(_st-vec2(-0.310,-0.350),0.006);\n            }\n        }else if(r <= 22./24.){//Duralumin\n        \ta += drawMoon(_st* rotate2d(TRQT_PI/1.520) * scale(vec2(-0.900,0.900))+ vec2(-0.010,0.040),0.036, .29);\n            a += drawSpike(_st * rotate2d(0.836) * scale(vec2(2.290,1.560)) + translate(vec2(0.480,-1.380)));\n            a += drawSpike(_st * rotate2d(2.364) * scale(vec2(2.000,1.560)) + translate(vec2(0.380,-1.380)));\n            a += drawSpike(_st * rotate2d(2.364) * scale(vec2(2.000,1.560)) + translate(vec2(0.580,-1.380)));\n            a += drawSpike(_st * rotate2d(2.364+PI) * scale(vec2(2.000,1.560)) + translate(vec2(0.650,-1.380)));\n            a += drawSpike(_st * rotate2d(2.364+PI) * scale(vec2(2.000,1.560)) + translate(vec2(0.450,-1.380)));\n            a += drawCircle(_st-vec2(-0.470,-0.50),0.006);\n        }else if(r <= 23./24.){//Duralumin\n            _st *= rotate2d(3.304);\n        \ta += drawMoon(_st* rotate2d(TRQT_PI/1.520) * scale(vec2(-0.900,0.900))+ vec2(-0.010,0.040),0.076, 0.402);\n            a += drawSpike(_st * rotate2d(2.024) * scale(vec2(0.990,1.460)) + translate(vec2(0.770,-0.6040)));\n            a += drawSpike(_st * rotate2d(2.054) * scale(vec2(1.890,1.570)) + translate(vec2(0.640,-0.210)));\n            a += drawCircle(_st-vec2(-0.350,-0.470),0.006);\n        }else{ // 24.  Brass\n\t        a += drawMoon(_st* rotate2d(-1.792) * scale(vec2(-0.900,0.900))+ vec2(-0.010,0.040),0.044, 0.282);\n            _st = _st * rotate2d(-2.584) * 0.98+vec2(0.030,0.080); \n            a += drawSpike(_st * rotate2d(-2.524) * scale(vec2(1.790,1.560)) + translate(vec2(0.530,-1.120)));\n            a += drawSpike(_st * rotate2d(1.644) * scale(vec2(1.690,1.560)) + translate(vec2(0.490,-1.090)));\n\t\t\ta += drawSpike(_st * rotate2d(-1.500) * scale(vec2(1.990,1.660)) + translate(vec2(0.500,-1.120)));\n            a += drawSpike(_st * rotate2d(-0.404) * scale(vec2(1.990,1.660)) + translate(vec2(0.500,-1.120)));\n            a += drawCircle(_st-vec2(-0.490,-0.500),0.006);\n        }\n    }\n\n      \n    return 1.-a;\n}\n\n//simple domain warping\nvec3 smoke(in vec2 st){\n    float a = fbm(st* 10. + (sin(iTime),iTime+cos(iTime*.5+.1)));\n    float b = fbm(st*4.+ a* vec2(sin(iTime),sin(iTime*.56))*.3);\n    float c = fbm(st * vec2(a,b));\n    return hsb2rgb(vec3(a*.2+0.832,b-.3,.3+c));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\t//st *= 20.;\n    vec3 color = smoke(st);\n    \n    st*=7.0;\n    vec2 ipos = floor(st);\n    \n    \n    st.y += +iTime * (rand(ipos.x,PI) * 2.+.2);\n    ipos.y = floor(st.y);\n    vec2 fpos = fract(st);\n    float a = glyph2(fpos, rand(ipos));\n\tfill(color, fpos, a);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 256, 281, 281, 351], [352, 352, 393, 393, 474], [475, 553, 579, 579, 951], [971, 971, 995, 1017, 1271], [1273, 1347, 1373, 1373, 1531], [1533, 1533, 1560, 1560, 1598], [1599, 1599, 1627, 1627, 1660], [1661, 1702, 1750, 1750, 1872], [1874, 1874, 1898, 1898, 1961], [1962, 1962, 1990, 1990, 2076], [2077, 2127, 2151, 2151, 2182], [2184, 2184, 2233, 2233, 2366], [2369, 2369, 2396, 2396, 2473], [2474, 2474, 2537, 2537, 2616], [2617, 2617, 2660, 2660, 2890], [2891, 2891, 2919, 2919, 3075], [3078, 3217, 3258, 3258, 13930], [13932, 13956, 13979, 13979, 14195], [14199, 14199, 14254, 14254, 14634]], "test": "valid"}
{"id": "3sSXRz", "name": "rainbow turbulence", "author": "julapy", "description": "learning SDF - this one cobbled together from some amazing existing Shadertoy works.\noriginal creators noted in shader comments.", "tags": ["raymarch", "sdf"], "likes": 53, "viewed": 1072, "published": "Public API", "date": "1552706938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat snoise( in vec3 x ) {\n    return noise(x) * 2.0 - 1.0;\n}\n\nfloat sfbm( vec3 p ) { // in [-1,1]\n    float f;\n    f  = 0.5000*snoise( p ); p = m * p * 2.02;\n    f += 0.2500*snoise( p ); p = m * p * 2.03;\n    f += 0.1250*snoise( p ); p = m * p * 2.01;\n    f += 0.0625*snoise( p );\n    return f;\n}\n\n// --------------------------------------------------------\n// SDF\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// --------------------------------------------------------\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\t\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Main SDF\n// --------------------------------------------------------\n\nfloat map(vec3 p) {\n    \n    float d1, d2;\n\n    vec3 p2 = p;\n    p2.x += 0.1 * sin( iTime + 2.0 * p.y ) ;\n    p2.y += 0.1 * sin( iTime + 2.0 * p.x ) ;\n    p2.z += 0.1 * sin( iTime + 2.0 * p.y ) ;\n    \n    d1 = sdSphere(p, 2.0);\n    d2 = sfbm( p2 * 1.5 + sin(0.1 * iTime) );\n    \n    float d = opSmoothSubtraction(d2, d1, 0.0);\n    \n    return d;\n}\n\n// --------------------------------------------------------\n// Rendering\n// raytracing colorization by Thomas Hooper.\n// https://www.shadertoy.com/view/WdB3Dw\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}       \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 camPos = vec3(0, -10, -10);\n    vec3 camTar = vec3(0,0,0);\n    vec3 camUp = vec3(0,0,-1);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n    float focalLength = 5.;\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n\n    float distance = 0.;\n    vec3 color = vec3(0);\n\n    vec3 c;\n\n    // Keep iteration count too low to pass through entire model,\n    // giving the effect of fogged glass\n    const float ITER = 82.;\n    const float FUDGE_FACTORR = .8;\n    const float INTERSECTION_PRECISION = .001;\n    const float MAX_DIST = 20.;\n\n    for (float i = 0.; i < ITER; i++) {\n\n        // Step a little slower so we can accumilate glow\n        rayLength += max(INTERSECTION_PRECISION, abs(distance) * FUDGE_FACTORR);\n        rayPosition = camPos + rayDirection * rayLength;\n        distance = map(rayPosition);\n\n        // Add a lot of light when we're really close to the surface\n        c = vec3(max(0., .01 - abs(distance)) * .5);\n        c *= vec3(1.4,2.1,1.7); // blue green tint\n\n        // Accumilate some purple glow for every step\n        c += vec3(.6,.25,.7) * FUDGE_FACTORR / 160.;\n        c *= smoothstep(20., 7., length(rayPosition));\n\n        // Fade out further away from the camera\n        float rl = smoothstep(MAX_DIST, .1, rayLength);\n        c *= rl;\n\n        // Vary colour as we move through space\n        c *= spectrum(rl * 6. - .6);\n\n        color += c;\n\n        if (rayLength > MAX_DIST) {\n            break;\n        }\n    }\n\n    // Tonemapping and gamma\n    color = pow(color, vec3(1. / 1.8)) * 2.;\n    color = pow(color, vec3(2.)) * 3.;\n    //color = pow(color, vec3(1. / 2.2));\n\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSXRz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 309, 332, 332, 371], [373, 373, 399, 411, 804], [806, 806, 833, 833, 868], [870, 870, 892, 905, 1104], [1106, 1304, 1339, 1339, 1363], [1365, 1365, 1396, 1396, 1546], [1548, 1548, 1600, 1600, 1699], [1701, 1701, 1759, 1759, 1859], [1861, 1861, 1920, 1920, 2019], [2021, 2214, 2282, 2282, 2325], [2327, 2327, 2351, 2351, 2449], [2452, 2585, 2604, 2604, 2932], [2934, 3154, 3204, 3204, 3347], [3356, 3356, 3413, 3413, 5213]], "test": "valid"}
{"id": "3ssXzX", "name": "DDemin_mashgraph", "author": "da_demin", "description": "На сцене имеется 5 примитивов 3 разных типов, есть 4 различных материала (разное восприятие типов освещения, разные константы альфа (блестят по-разному)). Имеется 2 источника света (движущийся желтый (уходит за плоскость) и стоящий на месте белый).\n", "tags": ["mashgraph"], "likes": 2, "viewed": 104, "published": "Public", "date": "1552121454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Constant parameters\nconst int STEPS = 1000;\nconst float MINDIST = 0.0;\nconst float MAXDIST = 1000.0;\nconst float EPS = 0.0001;\n\n/*\nПримитив кроме формы должен содержать цвет и материал.\nhttp://devernay.free.fr/cours/opengl/materials.html\nИх стоит возвращать при вызове ф-ции\n*/\n//Materials description\n//Parameters: ambient, diffuse, specular, alpha\nvec4[5] Materials=vec4[5](\n    vec4(0.5, 0.7, 0.8, 10.0),            \n    vec4(0.9, 0.7, 0.3, 20.0),\n    vec4(0.6, 0.7, 0.8, 64.0), \n    vec4(0.8, 0.2, 0.6, 1.0),\n    vec4(1.0, 1.0, 1.0, 0.0)//light\n);\n\n    \n//Colours description\nvec3[6] Colours = vec3[6](\n    vec3(1.0, 0.0, 1.0),\n    vec3(1.0, 0.0, 0.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.1, 1.0, 1.0),\n    vec3(1.0, 1.0, 1.0)//light\n);\n    \n//Structure, describes one point\nstruct pointdesc{\n    float dist;\n    int colour;\n    int material;\n};\n\n\n\n//SDF functions\nfloat SDFsphere(vec3 center, float r) {\n    return length(center) - r;\n}\n\nfloat SDFtorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat SDFplane( vec3 point, vec4 normal )\n{\n  // n must be normalized\n  return dot(point,normal.xyz) + normal.w;\n}\nfloat SDFroundbox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat SDFbox( vec3 p, vec3 b)\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat SDFmandelbulb(vec3 p, vec3 parameters, float detail, int iterations) {\n    vec3 temp = p;\n    float temp_detail = detail;   \n    for (int i=0; i < iterations; i++) {      \n        float r = length(temp);\n        if (r > 1.5){\n          break;\n        }\n        //to polar\n        float b = acos(temp.z/r);\n        float c = atan(temp.y/temp.x);\n        temp_detail = 5.0 * pow(r, parameters.z) * temp_detail + 1.0;\n        //scale, rotate\n        r = pow(r, parameters.z);\n        b = b * parameters.x;\n        c = c * parameters.y;\n        //to cartesian\n        temp = r * vec3(sin(b)*cos(c), sin(b)*sin(c), cos(b)) + p;\n    }\n    float z = length(temp);\n    float r = 0.5*z*log(z) / temp_detail;\n\treturn r;\n}\n\n\n//CSG operations\n\nfloat SDFunion(float dist1, float dist2) {\n    return min(dist1, dist2);\n}\nfloat SDFintersect(float dist1, float dist2) {\n    return max(dist1, dist2);\n}\nfloat SDFsubstract(float dist1, float dist2) {\n    return max(-dist1, dist2);\n}\n\n\n//Scene Description\npointdesc SDFscene(vec3 center) {\n   pointdesc ret;\n   //All SDFs must be repeated in getproperties\n   float SDF1 = SDFsphere(center + vec3(-1.5, 0.0, 4.0), 0.6);\n   float SDF2 = SDFsphere(center + vec3(1.6, 0.0, 0.0), 0.3);\n   float SDF3 = SDFtorus(center + vec3(1.0, 0.7, 0.3), vec2(0.6, 0.2));\n   float SDF4 = SDFplane(center + vec3(0.0, 0.9, 0.0), normalize(vec4(0.0, 1.0 , 0.0, 0.0)));\n   float SDF5_0 = SDFroundbox(center + vec3(-3.5, -0.8, 6.0), vec3(0.7, 0.7 , 0.1), 0.2);\n   float SDF5_1 = SDFsphere(center + vec3(-3.5, -0.8, 6.0 + sin(iTime/2.0)), 0.5);\n   float SDF5 = SDFsubstract(SDF5_1, SDF5_0);\n   float SDF6 = SDFmandelbulb(center + vec3(-0.3, -1.0, 6.0), vec3(8.0, 4.0, 7.0), 1.0, 2);\n   \n   if (SDF6 <= min(min(min(SDF2, SDF3), min(SDF1, SDF4)),SDF5)){\n       ret.dist = SDF6;\n       ret.colour = 3;\n       ret.material = 2;\n   } else if(SDF5 <= min(min(SDF2, SDF3), min(SDF1, SDF4))){\n       ret.dist = SDF5;\n       ret.colour = 4;\n       ret.material = 2;\n   } else if (SDF1 <= min(min(SDF2, SDF3),SDF4)){\n       ret.dist = SDF1;\n       ret.colour = 0;\n       ret.material = 0;\n   } else if (SDF2 <= min(SDF3, SDF4)){\n       ret.dist = SDF2;\n       ret.colour = 1;\n       ret.material = 1;\n   } else if (SDF3 <= SDF4){\n       ret.dist = SDF3;\n       ret.colour = 2;\n       ret.material = 2;\n   } else {\n       ret.dist = SDF4;\n       ret.colour = 3;\n       ret.material = 3;\n   }\n   \n   return ret;\n}\n\n//Distance calculating function\nfloat shortDistToSurf(vec3 eye, vec3 marchingDirection) {\n    float depth = MINDIST;\n    for (int i = 0; i < STEPS; i++) {\n        float dist = SDFscene(eye + depth * marchingDirection).dist;\n        if (dist < EPS) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAXDIST) {\n            return MAXDIST;\n        }\n    }\n    return MAXDIST;\n}\n            \n\n//Direction from eye to point\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    float x = fragCoord.x - size.x / 2.0;\n    float y = fragCoord.y - size.y / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(x ,y , -z));\n}\n\n\n//Phong lightig model will be realised\n//calculating normal to point\nvec3 getnormal(vec3 point){\n    return normalize(vec3(\n        SDFscene(vec3(point.x + EPS,point.y,point.z)).dist-SDFscene(vec3(point.x - EPS,point.y,point.z)).dist,\n        SDFscene(vec3(point.x,point.y + EPS,point.z)).dist-SDFscene(vec3(point.x,point.y - EPS,point.z)).dist,\n        SDFscene(vec3(point.x,point.y,point.z + EPS)).dist-SDFscene(vec3(point.x,point.y,point.z - EPS)).dist\n    ));\n}\n\n//How one light point changes colour\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, vec3 point, vec3 eye,\n                          vec3 LPosition, vec3 LIntensity, pointdesc properties) {\n    vec3 L = normalize(LPosition - point);\n    vec3 N = getnormal(point);\n    vec3 V = normalize(eye - point);\n    vec3 R = normalize(reflect(-L, N));\n      \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    //colour and material description\n    vec3 CLobject = vec3(1.0, 1.0, 1.0);\n    vec4 Material = vec4(1.0, 1.0, 1.0, 128.0);\n    CLobject = Colours[properties.colour];\n    Material = Materials[properties.material];\n   \n    if (/*dotLN < 0.0*/ shortDistToSurf(point + 0.003*N, L) <length(LPosition - point)) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return LIntensity * (k_d * dotLN * Material[1] * CLobject);\n    }\n    \n    return LIntensity * (k_d * Material[1] * CLobject * dotLN + k_s * Material[2] * CLobject * pow(dotRV, Material[3]));\n}\n\n//Phong lighting model\nvec3 PhongLighting(vec3 eye, vec3 point){\n    pointdesc Properties = SDFscene(point);\n    \n    //Ambient\n    vec3 CLambient = vec3(0.9, 0.9, 0.9)*Colours[Properties.colour];\n    float AmbientPower = 0.4;                   //Power of AmbientLight\n    vec3 ambient = CLambient * AmbientPower * Materials[Properties.material][0];\n    vec3 colour = ambient;\n    \n    //Light point 1\n    vec3 CLdiffuse1 = vec3(0.3, 0.3, 0.3);\n    vec3 CLspecular1 = vec3(0.5, 0.5, 0.5);    \n    vec3 lightpos1 = vec3(0.0, 5.0, 0.0);\n    vec3 lightInt1 = vec3(1.0, 1.0, 1.0);\n    colour += phongContribForLight(CLdiffuse1, CLspecular1, point,\n                                   eye, lightpos1, lightInt1, Properties);\n    //Light point 2\n    vec3 CLdiffuse2 = vec3(0.3, 0.3, 0.15);\n    vec3 CLspecular2 = vec3(0.5, 0.5, 0.25);    \n    vec3 lightpos2 = vec3(-1.0, sin(iTime)*3.0, -2.0);\n    vec3 lightInt2 = vec3(1.0, 1.0, 1.0);\n    colour += phongContribForLight(CLdiffuse2, CLspecular2, point, \n                                   eye, lightpos2, lightInt2, Properties);\n    return colour;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 4.0+sin(iTime/4.0)*4.0);\n    float dist = shortDistToSurf(eye, dir);\n    \n    if (dist > MAXDIST - EPS) {\n        fragColor = vec4(0.1, 0.1, 0.1, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * dir;\n    \n    vec3 colour = PhongLighting(eye, p);\n    \n    fragColor = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[956, 972, 1011, 1011, 1044], [1046, 1046, 1080, 1080, 1145], [1147, 1147, 1190, 1216, 1261], [1262, 1262, 1308, 1308, 1348], [1349, 1349, 1380, 1380, 1418], [1420, 1420, 1496, 1496, 2137], [2140, 2158, 2200, 2200, 2232], [2233, 2233, 2279, 2279, 2311], [2312, 2312, 2358, 2358, 2391], [2394, 2414, 2447, 2447, 3834], [3836, 3868, 3925, 3925, 4233], [4248, 4278, 4343, 4343, 4524], [4527, 4596, 4623, 4623, 4992], [4994, 5031, 5181, 5181, 6147], [6149, 6172, 6213, 6213, 7241], [7244, 7244, 7301, 7301, 7682]], "test": "valid"}
{"id": "3sXSD2", "name": "Sparkle sparkle little lightning", "author": "MacSlow", "description": "I am neglecting pure 2D stuff recently. Thus trying out simplex-noise with a bit of polar-coords to create some lightning-like lines. ", "tags": ["2d", "noise", "simplex", "lightning", "polar"], "likes": 28, "viewed": 1141, "published": "Public API", "date": "1552160919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Playing around with simplex noise and polar-coords with a lightning-themed\n// scene.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n\tp = vec2 (dot (p, vec2 (127.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (27.5);\n    float d = noise (p); p *= rot;\n    d += .5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .0625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn .5 + .5*d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 res = p;\n    res = res * 2. - 1.;\n    res.x *= iResolution.x / iResolution.y;\n    res *= scale;\n    \n    return res;\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n    float x = polar.x*cos (polar.y);\n    float y = polar.x*sin (polar.y);\n    return vec2 (x, y); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = mapToScreen (fragCoord.xy/iResolution.xy, 2.5);\n\n\tuv *= r2d (12.*iTime);\n    float len = length (uv);\n\tfloat thickness = .25;\n    float haze = 2.5;\n\n    // distort UVs a bit\n    uv = cart2polar (uv);\n    uv.y += .2*(.5 + .5*sin(cos (uv.x)*len));\n    uv = polar2cart (uv);\n\n    float d1 = abs ((uv.x*haze)*thickness / (uv.x + fbm (uv + 1.25*iTime)));\n    float d2 = abs ((uv.y*haze)*thickness / (uv.y + fbm (uv - 1.5*iTime)));\n    float d3 = abs ((uv.x*uv.y*haze)*thickness / (uv.x*uv.y + fbm (uv - 2.*iTime)));\n    vec3 col = vec3 (.0);\n    float size = .075;\n\tcol += d1*size*vec3 (.1, .8, 2.);\n\tcol += d2*size*vec3 (2., .1, .8);\n\tcol += d3*size*vec3 (.8, 2., .1);\n\n    fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXSD2.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 968, 996, 996, 1114], [1116, 1258, 1281, 1281, 1409], [1411, 1411, 1436, 1436, 1890], [1892, 1892, 1915, 1915, 2161], [2163, 2163, 2209, 2209, 2337], [2339, 2339, 2371, 2371, 2468], [2470, 2470, 2503, 2503, 2604], [2606, 2606, 2663, 2663, 3377]], "test": "valid"}
{"id": "3sXSDS", "name": "Flying Angelcrowd Greenscreen", "author": "arthurstammet", "description": "Created by inigo quilez - iq/2013 https://www.shadertoy.com/view/lssGRM\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nAdapted or video layering by Arthur Stammet\n", "tags": ["fractal", "animation", "angel"], "likes": 2, "viewed": 394, "published": "Public API", "date": "1552055739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nfloat hash1( vec2 p )\n{\n    return fract(sin(p.x+131.1*p.y)*1751.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// ripped from Kali's Lonely Tree shader\nmat3 rotationMat(vec3 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n                (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n                (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\nvec3 axis = normalize( vec3(-0.3,-1.,-0.4) );\n\nvec2 map( vec3 p )\n{\n    // animation\n    float atime = iTime+120.0;\n    vec2 o = floor( 0.5 + p.xz/50.0  );\n    float o1 = hash( o.x*57.0 + 12.1234*o.y );\n    float f = sin( 1.0 + (2.0*atime + 31.2*o1)/2.0 );\n    p.y -= 2.0*(atime + f*f);\n    p = mod( (p+25.0)/50.0, 1.0 )*50.0-25.0;\n    if( abs(o.x)>0.5 )  p += (-1.0 + 2.0*o1)*10.0;\n    mat3 roma = rotationMat(axis, 0.34 + 0.07*sin(31.2*o1+2.0*atime + 0.1*p.y) );\n    // modeling\n\tfor( int i=0; i<16; i++ )\n\t{\n        p = roma*abs(p);\n        p.y-= 1.0;\n    }\n\tfloat d = length(p*vec3(1.0,0.1,1.0))-0.75;\n    float h = 0.5 + p.z;\n    return vec2( d, h );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 140.0;\n    float precis = 0.001;\n    float t = 0.0;\n    float d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<200; i++ )\n    {\n        vec2 res = map( ro+rd*t );\n        if( res.x<precis||t>maxd ) break;\n        t += 0.6*min( res.x, 5.0 );\n        d = res.y;\n    }\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.5,0.0,0.0);\n    return normalize( vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.002 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float totao = 0.0;\n    for( int aoi=0; aoi<16; aoi++ )\n    {\n        vec3 aopos = -1.0+2.0*hash3(float(aoi)*213.47);\n        aopos *= sign( dot(aopos,nor) );\n        aopos = pos + aopos*0.5;\n        float dd = clamp( map( aopos ).x*4.0, 0.0, 1.0 );\n        totao += dd;\n    }\n    totao /= 16.0;\n    return clamp( totao*totao*1.5, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(-0.5,0.7,-1.0));\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 fc )\n{\n    // render\n    vec3 bgc = 0.6*vec3(0.0,1.,0.0)*(0.2 + 0.1*rd.y);\n    vec3 col = bgc;\n    // raymarch\n    vec3 tmat = intersect(ro,rd);\n    float dis = tmat.x;\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        // material\n        vec3 mate = 0.5 + 0.5*mix( sin( vec3(1.2,1.1,1.0)*tmat.y*3.0 ),\n                                  sin( vec3(1.2,1.1,1.0)*tmat.y*6.0 ),\n                                  1.0-abs(nor.y) );\n        // lighting\n        float occ = calcAO( pos, nor );\n        float amb = 0.8 + 0.2*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n        float sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.001*nor, lig, 0.1, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        // lights\n        vec3 brdf = vec3(0.0);\n        brdf += 1.0*dif*vec3(1.00,0.90,0.65)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        brdf += 1.0*amb*vec3(0.05,0.05,0.05)*occ;\n        brdf += 1.0*bac*vec3(0.03,0.03,0.03)*occ;\n        brdf += 1.0*fre*vec3(1.00,0.70,0.40)*occ*(0.2+0.8*sha);\n        brdf += 1.0*occ*vec3(1.00,0.70,0.30)*occ*max(dot(-nor,lig),0.0)*pow(clamp(dot(rd,lig),0.0,1.0),64.0)*tmat.y*2.0;\n        // surface-light interacion\n        col = mate * brdf;\n        // fogt\n        col = mix( col, bgc, clamp(1.0-1.2*exp(-0.0002*tmat.x*tmat.x ),0.0,1.0) );\n    }\n    else\n    {\n        // sun\n        // vec3 sun = vec3(1.0,0.9,0.3)*pow( clamp(dot(rd,lig),0.0,1.0), 32.0 );\n        // col += sun;\n        dis = 140.0;\n    }\n    \n    // god rays\n    #if 0\n    float gr = 0.0;\n    float t = 10.1 * hash1(fc);\n    for( int i=0; i<32; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float dt = clamp(0.3*t,1.0,10.0);\n        gr += dt*softshadow( pos, lig, 0.01, 128.0 );\n        t  += dt;\n        if( t>dis ) break;\n    }\n    col += vec3(1.0,0.9,0.5)*pow(gr*0.004,2.0) - 0.02;\n    #endif\n    \n    // sun scatter\n    // col += 0.6*vec3(0.2,0.14,0.1)*pow( clamp(dot(rd,lig),0.0,1.0), 5.0 );\n    // postprocessing\n    // gamma\n    col = pow( col, vec3(0.55) );\n    // contrast/brightness\n    col = 1.3*col-0.1;\n    // tint\n    col *= vec3( 1.0, 1.04, 1.0);\n\n     return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    // camera\n    float an = 2.5 + 0.12*iTime - 6.2*m.x;\n    float cr = 0.3*cos(0.2*iTime);\n    vec3 ro = vec3(15.0*sin(an),12.0-24.0*m.y,15.0*cos(an));\n    vec3 ta = vec3( 0.0, 2.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.2*ww );\n    vec3 col = render( ro, rd, fragCoord );\n    // vigneting\n    // col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n    fragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri + vec3( 3.0, 0.0, 14.0 );\n    vec3 rd = fragRayDir;\n    vec3 col = render( ro, rd, fragCoord );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXSDS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 125, 148, 148, 186], [188, 188, 211, 211, 261], [263, 263, 286, 286, 380], [382, 423, 462, 462, 844], [893, 893, 913, 930, 1503], [1505, 1505, 1547, 1547, 1890], [1892, 1892, 1924, 1924, 2139], [2141, 2141, 2206, 2206, 2459], [2461, 2461, 2503, 2503, 2851], [2897, 2897, 2948, 2962, 5208], [5210, 5210, 5267, 5267, 6081], [6083, 6083, 6177, 6177, 6334]], "test": "valid"}
{"id": "3sXSWs", "name": "neon bulbs", "author": "jcyuan", "description": "pratice, neon waves", "tags": ["pratice"], "likes": 6, "viewed": 172, "published": "Public", "date": "1552463850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SIZE 12.\n#define BGCOLOR vec3(.0, .0, .0)\n\n// hueShift: https://www.shadertoy.com/view/MsjXRt\nvec3 hueShift(in vec3 col, in float shift) {\n    vec3 P = vec3(0.55735) * dot(vec3(0.55735), col);\n    vec3 U = col - P;\n    vec3 V = cross(vec3(0.55735), U);    \n    col = U * cos(shift * 6.2832) + V * sin(shift * 6.2832) + P;\n    return col;\n}\n\nfloat sdCircle(in vec2 p) {\n    return length(p - .5);\n}\n\nfloat radialMask(in vec2 p) {\n    return vec2(sdCircle(p), atan(p.y, p.x)).x * 4.;\n}\n\nfloat sphereMask(in vec2 p, in float r, in float hard) {\n    float dist = sdCircle(p);\n    return 1. - smoothstep(r - (r * hard), r + (r * hard), dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y + .5;\n    vec2 ouv = uv;\n    \n    uv = fract(uv * SIZE);\n    ouv = floor(ouv * SIZE) / SIZE;\n    \n    float spMask = sphereMask(uv, .5, .3);\n    \n    vec3 color = vec3(spMask);\n\n    float flow = abs(sin(1. - radialMask(ouv) + iTime * 4.));\n    flow = pow(flow, 2.);\n    vec3 rainbow = hueShift(vec3(1., 0., 0.), flow);\n    \n    float flow2 = abs(sin(1. - radialMask(ouv) + iTime * 1.5));\n    flow2 = pow(flow2, 3.);\n\n    color *= rainbow * flow2;\n\n    color = mix(BGCOLOR, color, spMask);\n    \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 102, 146, 146, 347], [349, 349, 376, 376, 405], [407, 407, 436, 436, 491], [493, 493, 549, 549, 647], [649, 649, 704, 704, 1297]], "test": "valid"}
{"id": "4lsczj", "name": "Infinite Pinwheel Triangle Zoom", "author": "ttoinou", "description": "Forgot about this for 2 years, to improve by splitting apart dots continuously ", "tags": ["pinwheel"], "likes": 6, "viewed": 339, "published": "Public API", "date": "1552863226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHOW_CENTER 1\n#define SHOW_SEGMENTS 0\n\n#define PI 3.14159265359\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cnorm( vec2 z )  { return z/length(z); }\nvec2 cmuli( vec2 z )  { return vec2( -z.y , z.x ); }\nvec2 cconj( vec2 z )  { return vec2( z.x , -z.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\n\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n\nstruct Pinwheel\n{\n    vec2 A; // Right angle, divided into 1 acute and 1 obtuse\n    vec2 B; // Acute angle, stays acute\n    vec2 C; // Obtuse angle, stays obtuse\n    \n    vec2 D; // on GA\n    vec2 E; // on AB\n    vec2 F; // on BC, close to B\n    vec2 G; // on BC, close to C\n    \n    float r;\n    float ID;\n    float ID2;\n};\n\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Pinwheel T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C; \\\n    T.ID = Q.ID; \\\n    T.ID2 = Q.ID2; \\\n    T.r = Q.r; \n    \n#define EQUERRE_COMPUTE_DEFG(T) \\\n\tT.E = (T.A + T.B)/2.0; \\\n\tT.F = (3.0 * T.B + 2.0 * T.C)/5.0; \\\n\tT.G = (T.B + 4.0 * T.C)/5.0; \\\n\tT.D = (T.G + T.A)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.B; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.G; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.G;\n\n#define EQUERRE_GET4(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.A;\n\n#define EQUERRE_GET5(T,Q) \\\n\tT.A = Q.G; \\\n    T.B = Q.A; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND_12_345(X,T) \\\n\tpointsOnSameSideOfLine(X,T.F,T.E,T.G)\n \n#define EQUERRE_COND_1_2(X,T) \\\n\tpointsOnSameSideOfLine(X,T.B,T.E,T.F)\n\n#define EQUERRE_COND_34_5(X,T) \\\n\tpointsOnSameSideOfLine(X,T.E,T.A,T.G)\n        \n#define EQUERRE_COND_3_4(X,T) \\\n\tpointsOnSameSideOfLine(X,T.G,T.E,T.D)\n        \n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n\n        \n\n// Base Triangle\nPinwheel Tri;\n\nfloat TriangleAngle;\n//float k = 1./(1. - sqrt(3.)*.5);\nfloat RadiusCoeff;\nfloat AngleCoeff;\nfloat k;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,(n + logZoom)/2.) , (n)*AngleCoeff + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindTriangle(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool k = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        k = false;\n    }\n    \n    return k;\n}\n\nvec2 deformation_pole = vec2(.5,.0);\n\nvec2 deformation( vec2 uv )\n{\n    //uv = cdiv( uv + deformation_pole , uv - deformation_pole );\n    //uv = cdiv(vec2(1.,0.),uv);\n    return uv;\n    //return clog( uv + deformation_pole ) - clog( uv - deformation_pole );\n    //return cexp( cdiv( uv + deformation_pole , clog( uv - deformation_pole ) ) );\n}\n\nvec2 deformation_inverse(vec2 def )\n{\n    return cdiv(2.*deformation_pole,def -  vec2(1.,0.)) + deformation_pole;\n}\n\nfloat qLimit;\n\n\n\nvec3 colorTriangle(vec2 uv_s,Pinwheel Tri)\n{\n    \n    vec3 col = hash3point(vec2(\n        // coloring algorithm\n        Tri.ID+cos(Tri.ID2),sin(Tri.ID*3.)-Tri.ID2\n    ));\n    \n    //col = vec3(1.);\n    \n    //vec3 col = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID));\n    \n    /*Tri.A = deformation_inverse(Tri.A);\n    Tri.B = deformation_inverse(Tri.B);\n    Tri.C = deformation_inverse(Tri.C);\n    uv_s = uv;*/\n\n    float scale = 1./viewportMagnify/(1. + dot(uv_s,uv_s)*1.); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) col = mixColorLine(uv_s,col,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale *= 12.;\n    vec2 TriCenterMix = (Tri.A + Tri.B + Tri.C)/3.;\n   // TriCenterMix = Tri.B;\n    \n    #if SHOW_CENTER==1\n        //col *= 1.*(.5 + coeffDistPoint(uv_s,TriCenterMix,scale));\n        col = vec3( clamp( sqrt( 1. - coeffDistPoint(uv_s,TriCenterMix,scale) ) , .0 , 1. ) );\n    #endif\n    \n    return col;//*2./(1. + dot(uv_s,uv_s)/1e3 );\n}\n\nvec3 color(vec2 uv_s)\n{\n    float r = floor( log(dot(uv_s,uv_s))/log(k) - logZoom );\n    \n    \n    if( !FindTriangle(r+1.,uv_s) )\n    {\n        // inside circle\n        FindTriangle(r,uv_s);\n    }\n    \n    \n    \n\tint nbIterations = 16;//iMouse.z > .5 ? 3 : 2;\n    \n    Pinwheel Tri_TMP;\n    Tri.ID2 = 0.;\n    \n    bool direction = false;\n    #define ID_DIRECTION(x) (direction ? 4.-x : x)\n      \n    EQUERRE_COPY(Tri_TMP,Tri);\n    float q;\n    qLimit = ( 1. / mix( 1. , 1./.14  , iMouse.x/iResolution.x ) )/5.*viewportMagnify;\n    qLimit = .05;\n    \n    for(int i = 0 ; i < nbIterations ; i++)\n    {\n        Tri_TMP.ID2 *= 5.;\n        EQUERRE_COMPUTE_DEFG(Tri);\n        \n        if( EQUERRE_COND_12_345(uv_s,Tri) )\n        {\n            if( EQUERRE_COND_1_2(uv_s,Tri) )\n            {\n            \tEQUERRE_GET1(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(0.);\n            }\n            else\n            {\n            \tEQUERRE_GET2(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(1.);\n                direction = !direction;\n            }\n        }\n        else if( EQUERRE_COND_34_5(uv_s,Tri) )\n        {\n            if( EQUERRE_COND_3_4(uv_s,Tri) )\n            {\n            \tEQUERRE_GET3(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(2.);\n                direction = !direction;\n            }\n            else\n            {\n            \tEQUERRE_GET4(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(3.);\n            }\n        }\n        else \n        {\n            EQUERRE_GET5(Tri_TMP,Tri);\n            Tri_TMP.ID2 += ID_DIRECTION(4.);\n        }\n        \n        q = length(Tri_TMP.B - Tri_TMP.A)/qLimit;\n        if( q < 1. )\n        {\n            break;\n        }\n        else\n        {\n        \tEQUERRE_COPY(Tri,Tri_TMP);\n        }\n    }\n    \n    \n    \n    \n    q = max( \n        (q-1./sqrt(5.))/(1. - 1./sqrt(5.))\n        // nice effects here\n        //* pow(viewportMagnify/length(uv_s),.75)\n        * 1.\n    , 0. );\n    \n    //return colorTriangle(uv_s,Tri);\n    \n    return mix(\n        colorTriangle(uv_s,Tri),\n        colorTriangle(uv_s,Tri_TMP),\n        smoothstep(0.,1.,(q))\n    );\n    \n    //return colorTriangle(uv_s,Tri);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    TriangleAngle = atan(2.); // Pinwheel\n    //TriangleAngle = PI/3.; // Equerre \n    \n    //PI * ( mix( 1./12. ,  1./4. ,  iMouse.x/iResolution.x ) + .333 );\n    \n    angleShift = -iTime*.3;\n    logZoom = iTime/sqrt(3.);\n    \n    RadiusCoeff = 1. / ( 1./tan(TriangleAngle) - 1. );\n    k = 1. + 2.*(RadiusCoeff * (1. + RadiusCoeff ) );\n    \n    AngleCoeff = asin( - RadiusCoeff / sqrt(k) );\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.)));\n    \n    vec2 uv_s = deformation(uv);\n    \n    viewportMagnify = 1.;\n    //uv_s *= viewportMagnify;\n    \n    \n    fragColor.rgb = color(uv_s);\n    //fragColor.rgb = tanh(fragColor.rgb * 26. / (.2 + qLimit/viewportMagnify*16.)  ); // LOG correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsczj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 114, 114, 148], [150, 150, 173, 173, 195], [196, 196, 219, 219, 248], [249, 249, 272, 272, 301], [302, 302, 332, 332, 387], [388, 388, 409, 409, 442], [443, 443, 464, 464, 515], [516, 516, 546, 546, 616], [619, 843, 883, 883, 1247], [1577, 1688, 1709, 1709, 1830], [1832, 1832, 1857, 1885, 2132], [2134, 2134, 2165, 2165, 2199], [2201, 2201, 2230, 2230, 2264], [2267, 2267, 2324, 2452, 2567], [2569, 2569, 2639, 2639, 2751], [2754, 2754, 2845, 2845, 2992], [2994, 2994, 3071, 3071, 3200], [3232, 3232, 3264, 3264, 3358], [3360, 3360, 3402, 3402, 3601], [3935, 3935, 3963, 3963, 3995], [3997, 3997, 4044, 4044, 4250], [5623, 5679, 5714, 5714, 5957], [5960, 5960, 5996, 5996, 6816], [6856, 6856, 6885, 6984, 7161], [7163, 7163, 7200, 7200, 7278], [7297, 7297, 7341, 7341, 8417], [8419, 8419, 8442, 8442, 10606], [10608, 10608, 10665, 10665, 11415]], "test": "valid"}
{"id": "MtyBDV", "name": "Non-Photorealistic Try", "author": "WingStone", "description": "The idea is fron ABZU game, but the Non-Photorealistic cloud render is a little bad=.=", "tags": ["waternonphotorealisticcloud"], "likes": 13, "viewed": 545, "published": "Public API", "date": "1552137103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.001\n\n//value noise\n//reference: https://www.shadertoy.com/view/4sfGzS\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat NoiseCloud(vec3 pos)\n{\n    pos *=2.0;\n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n    vec2 uv = p.xy + vec2(37.0, 17.0)*p.z + f.xy;\n    \n    vec2 rg = texture(iChannel0, (uv+0.5)/256.0).yx;\n    return mix(rg.x, rg.y, f.z)*2.0-1.0;\n}\n\n// water\nfloat Noise( in vec3 pos )\n{\n    vec2 p = pos.xz;\n    \n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat Random(vec2 uv)\n{\n    return texture(iChannel0, uv).y;\n}\n\nfloat HightFunction(vec3 pos)\n{\n    float hight = 0.15*Noise(pos*0.2)*(sin(pos.x)\n                       + 1.1*sin(pos.z + iTime));\n    hight += 0.05*(pow((sin(pos.x - 1.5*pos.z + iTime*3.0)+1.)/2.,1.5));\n    return hight*0.3;\n}\n\nfloat CloudHightFunction_1(vec3 dir)\n{\n    float hight = 0.01*(sin(10.*dir.x + iTime*0.5)) + dir.y + 0.25;\n    return hight;\n}\n\nfloat CloudHightFunction_2(vec3 dir)\n{\n    float hight = NoiseCloud(dir*1.5)*0.2*(sin(10.*dir.x + 1.)) + dir.y+ 0.03 +0.05*Noise(dir*5.);\n    return hight ;\n}\n\nfloat CloudHightFunction_3(vec3 dir)\n{\n    float hight =  NoiseCloud(dir*6.2) + 0.4*(NoiseCloud(dir*12.))+ dir.y*8.;\n    return hight ;\n}\n\nfloat CloudDistanceFuntion(vec3 dir, vec3 dircenter, float noise_if, float noise_of)\n{\n    float c = distance(normalize(dircenter), dir) + NoiseCloud(dir*noise_if)*noise_of;\n    return c;\n}\n\nvec3 GetNormal(vec3 pos)\n{\n    vec3 dx = vec3(EPS, HightFunction(pos+vec3(EPS, 0.0, 0.0))-HightFunction(pos), 0.0);\n    vec3 dz = vec3(0, HightFunction(pos+vec3(0.0, 0.0, EPS))-HightFunction(pos), EPS);\n    return normalize(cross(dz, dx));\n}\n\nfloat RayMatching(vec3 rayOri, vec3 rayDir, float random)\n{\n    if(rayDir.y >= 0.0)\n        return -1.0;\n\n\tfloat nearDist = 0.1f;\n    float farDist = 100.0f;\n    float stp = 0.05f;\n    \n    float d = nearDist;\n    float lastHeight;\n    float lastPosy;\n    rayOri += random*stp*rayDir;  //dither\n    while(d < farDist)\n    {\n        vec3 pos = rayOri + rayDir*d;\n        float hight = HightFunction(pos);    \n        if(hight > pos.y)\n        {\n            //intersection\n            float delt = hight - pos.y;\n            float lastDelt = lastPosy -lastHeight;\n            return d + stp*lastDelt/(lastDelt + delt);\n        }\n        lastHeight = hight;\n        lastPosy = pos.y;\n        stp += 0.01;\n        d += stp;\n    }\n\n    return -1.0;\n}\n\nvec3 GetSkyCol(vec3 dir)\n{\n    vec3 lightDir = normalize(vec3(-0.3, 0.3, 1.));\n    float bk_factor = dot(dir, lightDir);\n    vec3 lightCol = vec3(1.0,0.97,0.94);\n    vec3 cloudCol1 = vec3(0.68, 0.86, 0.93);\n    vec3 cloudCol2 = vec3(0.87, 0.95, 0.96);\n    vec3 cloudCol3 = vec3(0.81, 0.93, 0.96);\n    vec3 col = mix(vec3(0.22, 0.59, 0.81), lightCol,\n                   clamp(0.0, 1.0, pow(bk_factor,64.0)) + smoothstep(0.998,1.0, bk_factor));\n    \n    vec3 cloud_light;\n\tfloat edgenoise = 0.014*Noise(dir*20.);\n    \n    float dis = CloudDistanceFuntion(dir+ vec3(0.005, 0.008, 0.), vec3(-0.6,0., 1.), 10., 0.05);\n    cloud_light = mix(cloudCol1, cloudCol2, smoothstep(0.3, 0.31, dis+edgenoise));\n    col = mix(cloud_light, col,\n              smoothstep(0.315, 0.32,CloudDistanceFuntion(dir, vec3(-0.6,0., 1.), 10., 0.05)));\n    \n    dis = CloudDistanceFuntion(dir+ vec3(0.005, 0.004, 0.), vec3(0.4,-0.1, 1.), 5., 0.05);\n    cloud_light = mix(cloudCol1, cloudCol2, smoothstep(0.3, 0.31, dis+edgenoise));\n    col = mix(cloud_light, col,\n              smoothstep(0.315, 0.32,CloudDistanceFuntion(dir, vec3(0.4,-0.1, 1.), 5., 0.05)));\n    \n    cloud_light = cloudCol1;\n    if(CloudHightFunction_2(dir + vec3(0.02, 0.015, 0.)) + edgenoise> 0.21)\n        cloud_light = cloudCol2;\n    col = mix(cloud_light, col,\n              smoothstep(0.2,0.205, CloudHightFunction_2(dir) +0.015*Noise(dir*14.)));\n    \n    cloud_light = cloudCol1;\n    if(CloudHightFunction_3(dir + vec3(0.02, 0.003, 0.)) + edgenoise> 0.32)\n        cloud_light = cloudCol2;\n    col = mix(cloud_light, col,\n              smoothstep(0.29, 0.3,CloudHightFunction_3(dir)));\n    \n    cloudCol3 = mix(  vec3(0.22, 0.59, 0.81),cloudCol3,smoothstep(-0.125,-0.05, dir.y));\n\tcol = mix(cloudCol3, col,\n              smoothstep(0.2, 0.21,CloudHightFunction_1(dir) +0.015*Noise(dir*15.) ));\n    \n\n    \n    return col;\n}\n\nvec3 CalculateCol(vec3 pos, vec3 nor, vec3 viewDir)\n{\n  \tvec3 specDir = normalize(reflect(viewDir, nor));\n    vec3 skycol = GetSkyCol(specDir);\n    return skycol;\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy)/iResolution.y;\n    vec3 camera = vec3(0, 10.0, 0.);\n    vec3 target = vec3(0.0, 9.98, 1.0);\n    \n    vec3 front = normalize(target - camera);\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), front);\n    vec3 up = cross(front,right);\n    vec3 rayDir = normalize(front*1.732 + uv.x*right + uv.y*up);\n    \n    float random = Random(uv);\n    float dist = RayMatching(camera, rayDir, random);\n    \n    vec3 pos = camera + rayDir*dist;\n    vec3 nor = GetNormal(pos);\n    \n    vec3 col;\n    if(dist < 0.0)\n    {\n        col = GetSkyCol(rayDir);\n    }\n    else\n    {\n    \tcol = CalculateCol(pos, nor, rayDir);\n        col = mix( col, vec3(0.22, 0.59, 0.81),smoothstep(80.,110., dist));\n    }\n    \n    //col = vec3(random,random,random);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyBDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 85, 142, 142, 257], [259, 259, 287, 287, 503], [505, 514, 542, 542, 1047], [1049, 1049, 1072, 1072, 1111], [1113, 1113, 1144, 1144, 1341], [1343, 1343, 1381, 1381, 1469], [1471, 1471, 1509, 1509, 1629], [1631, 1631, 1669, 1669, 1768], [1770, 1770, 1856, 1856, 1959], [1961, 1961, 1987, 1987, 2202], [2204, 2204, 2263, 2263, 2949], [2951, 2951, 2977, 2977, 4819], [4821, 4821, 4874, 4874, 4985], [4995, 4995, 5052, 5052, 5859]], "test": "error"}
{"id": "td23zV", "name": "Impossible Chainmail", "author": "BigWIngs", "description": "Playing around with hexagons.", "tags": ["escher", "hexagon", "knot", "impossible", "chainmail"], "likes": 56, "viewed": 762, "published": "Public", "date": "1551739962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Impossible Chainmail by Martijn Steinrucken aka BigWings - 2019\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Inspired by:\n// https://twitter.com/anniek_p/status/1092632749423370240\n//\n// After playing with it for a bit I realized that with the right settings, \n// this turns into a neat impossible knot\n//\n// Code is a bit of a mess, I know ;)\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define R3 1.73205080757\n\nvec2 s = vec2(1, R3);\nvec4 red = vec4(1, .3, .3,1);\nvec4 blue = vec4(.3, .3, 1,1);\n\n\nvec4 HexCoords(vec2 uv, float angle) {\n    \n    vec2 h = .5*s;\n    \n    vec2 a = mod(uv, s)-h;\n    vec2 b = mod(uv+h, s)-h;\n    \n    vec2 ab = dot(a,a)<dot(b,b) ? a : b;\n    \n    \n    vec2 id = uv-ab;\n    \n    float d = length(s);\n    vec2 hc = abs(ab);\n\n    float x = min(hc.x, min( abs(dot(ab, s/d)), abs(dot(ab, vec2(1,-R3)/d))));\n    float y = min(1.-2.*hc.x, 1.-dot(hc, s));\n    \n    return vec4(x, y, id.x, id.y);\n}\n\nvec4 HexCol(vec2 uv, vec2 offs, float waveSpeed, float size) {\n\n    vec4 hc = HexCoords(uv, 1.);\n\t\n    float cd = length(hc.zw-offs);\n    if(cd>1.75)  return vec4(0);\n    \n    \n    float center = size;//mix(.2, .37, sin(iTime)*.5+.5);\n    float c = abs(hc.y-center);\n    //cd = length(uv-offs);\n    float w = .15;//-sin(cd*3.+iTime*0.)*.05;\n    float mainMask = S(w, w*.9, c);\n    \n    vec4 col = vec4(1.);\n    \n    \n    vec2 hv = uv-hc.zw;\n    float x = atan(hv.x, hv.y);\n    float swap = sign(cos(x*3.))*.01;\n    float corners = S(.01, .0, hc.x);\n    corners *= S(center, center+swap, hc.y);\n\n    float edges = S(.01, .03, abs(c-w*.9))*S(.01, .02, c);\n    \n    float side = step(center, hc.y);\n    \n    float wave = sin(x*3.+iTime*waveSpeed);\n    \n    x = x/6.2831+.5;\n    \n    float sector = x;\n    \n    x = fract(x+.333+ .333*1.5*side)*3.;\t\t// three sectors\n    float shade = floor(x)/2.;\n    shade = shade*.7+.3 +(wave*.5+.5)*step(.75, shade);\n    //shade *= 1.+S(0., .5, wave)*step(shade, .75);\n    \n    col.r = shade*edges;\n    col.g = sector;\n    col.b = corners;\n    col.a = mainMask;\n    \n\n    return col;\n}\n\nfloat SS(float x) { return S(0.,1.,S(0.,1.,S(0.,1.,x)));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*2.;\n    \n    float fade = SS(cos(t)*.5+.5);\n    float fade2 = SS(cos(t*.5));\n    \n    float size = .3+fade*.2;\n    \n    vec3 col = vec3(.25,.2,.2)*3.-length(uv)*.5;\n\t\n    float grid = 4.;\n   \t\n    vec2 UV = uv*grid+vec2(.5,-.3);\n    \n    vec2 offs = (1.-fade)*vec2(sin(t), cos(t))*.03;\n    \n    vec4 hex1 = HexCol(UV+offs, vec2(.3,-.3), 1., size);\n    vec4 hex2 = HexCol(UV+vec2(.5,-.2886)-offs, vec2(1.,-.3), -1.,size);\n    \n    float sector = mod(floor(hex1.g*6.)+1., 2.);\n    \n    vec4 col1 = mix(red, blue, fade2);\n    col1-=hex1.b*step(sin((hex1.g+.1)*6.*3.1415), 0.);\n    \n    vec4 col2 = mix(blue, col1, fade);\n    //col2 = mix(col2, col1, colSwap);\n    col2-=hex2.b*step(sin((hex2.g+.2)*6.*3.1415), 0.);\n    \n    col1.a=col2.a=1.;\n    vec4 hexCol = mix(\n        hex1.x*col1, \n        hex2.x*col2, \n        hex2.a*max(sector, (1.-hex1.a))\n    );\n    hexCol.a = max(hex1.a, hex2.a);\n    //hexCol = hex1.x*vec4(1., .3, .3,1); hexCol.a = hex1.a; \n    col = mix(col, hexCol.rgb, hexCol.a);\n  \n    //if(abs(uv.x)<.002 || abs(uv.y)<.002) col += 1.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td23zV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 571, 609, 609, 992], [994, 994, 1056, 1056, 2111], [2113, 2113, 2132, 2132, 2170], [2172, 2172, 2229, 2229, 3435]], "test": "valid"}
{"id": "td2SDz", "name": "Cool Fractal", "author": "Txoka", "description": "I did this some time ago but kept it private for some reason", "tags": ["fractal", "julia", "dragon"], "likes": 3, "viewed": 64, "published": "Public API", "date": "1553539162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "highp float rand(vec2 co) {\n    return fract(cos(mod(dot(co.xy ,vec2(12.9898,78.233)),3.14))*43758.5453);\n}\nhighp float rand(float co) {\n    return fract(cos(mod(co,3.14))*43758.5453);\n}\nfloat a(float p, float d){;\n\treturn sign(fract(p*d*.5)*2.-1.);\n}\nconst int iter=16;\nconst int n=1<<iter;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y*1.;\n\tfloat u=float(n);\n    float i=float(iter);\n    float k=i;\n    while(true){\n\t\tuv.y-=a(uv.x,u)/(u*2.)*clamp((1.-cos(iTime/2.))*k/2.-i,0.,1.);\n        i--;\n        u/=2.; \n        if(u<1.)break;\n        \n        uv.x+=a(uv.y,u)/(u*2.)*clamp((1.-cos(iTime/2.))*k/2.-i,0.,1.);\n        i--;\n        u/=2.;\n        if(u<1.)break;\n    }\n    \n    vec2 z=floor(uv);\n    \n    vec3 col = vec3(rand(z),0,0);\n    col.y=rand(z+col.x);\n    col.z=rand(z+col.y);\n    \n\tcol*=1./(1.+2.*length(fract(uv)-0.5));\n    //col*=clamp(0.2/length(fract(uv)-0.5),0.,1.);\n    //col*=length(fract(uv)-0.5)*2.;\n    \n    fragColor = vec4(col,1.0);\n    //fragColor=texture(iChannel0,uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2SDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 213, 213, 251], [292, 292, 348, 348, 1066]], "test": "valid"}
{"id": "td2SRW", "name": "[twitch] Diamond Pulse", "author": "yx", "description": "I stream shader creation every Wednesday at 9pm UK time, over at [url]https://twitch.tv/lunasorcery[/url]\nCome and watch a show!\n\nOr watch the VOD for this shader here: [url]https://www.twitch.tv/videos/398555459[/url]", "tags": ["pulse", "diamond", "livecoding", "twitch"], "likes": 4, "viewed": 472, "published": "Public API", "date": "1553122975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    This shader was created live on stream!\n    You can watch the VOD here: https://www.twitch.tv/videos/398555459\n\n    I use the Bonzomatic tool by Gargaj/Conspiracy:\n    https://github.com/Gargaj/Bonzomatic\n\n    Wednesdays around 9pm UK time I stream at https://twitch.tv/lunasorcery\n    Come and watch a show!\n\n    ~yx\n*/\n\n//#define pi uintBitsToFloat(0x40490FDBu)\n#define pi acos(-1.)\n\nconst float BPM = 128./2.;\n\nvec2 rotate(vec2 a, float b)\n{\n\tfloat c=cos(b);\n\tfloat s=sin(b);\n\treturn vec2(\n\t\ta.x*c-a.y*s,\n\t\ta.x*s+a.y*c\n\t);\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n\tp=abs(p)-r;\n\treturn max(max(p.x,p.y),p.z);\n}\n\nvec3 p2;\n\nfloat sdOctahedron(vec3 p, float r)\n{\n\tp=abs(p);\n\treturn (p.x+p.y+p.z-r)/sqrt(3.);\n}\n\n\nfloat shape(vec3 p)\n{\n\tp=abs(p);\n\t\n\tp.xz=vec2(max(p.x,p.z),min(p.x,p.z));\n\tp.yx=vec2(max(p.x,p.y),min(p.x,p.y));\n\t\n\tfloat r = 1. + pow(cos(iTime*(BPM/60.)*pi*2.)*.5+.5,6.)*.2;\n\treturn min(\n\t\tmax(\n\t\t\tsdOctahedron(p,2.),\n\t\t\t-min(\n\t\t\t\tsdBox(p,vec3(r)),\n\t\t\t\tsdBox(p-vec3(0,1,0),vec3(r/2.))\n\t\t\t)\n\t\t),\n\t\tlength(p)-.5+(r-1.)*.5\n\t);\n}\n\nfloat tick(float t)\n{\n\tfloat a=floor(t);\n\tfloat b=fract(t);\n\tb=smoothstep(0.,1.,b);\n\tb=smoothstep(0.,1.,b);\n\treturn a+b;\n}\n\nfloat tick2(float t)\n{\n\tfloat a=floor(t);\n\tfloat b=fract(t);\n\tb=smoothstep(0.,1.,b);\n\tb=smoothstep(0.,1.,b);\n\tb=smoothstep(0.,1.,b);\n\tb=smoothstep(0.,1.,b);\n\tb=smoothstep(0.,1.,b);\n\tb=smoothstep(0.,1.,b);\n\treturn a+b;\n}\n\nfloat scene(vec3 p)\n{\n\tfloat outershape = -sdOctahedron(p,20.);\n\t\n\tp=-p;\n\t\n\tfloat mode = clamp(sin(iTime*.3)*6.,0.,1.);\n\t\n\tfloat radial=-atan(p.x,p.z);\n\t\n\tp.xz = rotate(p.xz, radial * mode * 2.);\n\t\n\tfor(float i=0.;i<mod(iTime*BPM/60.,3.);++i)\n\t\tp=p.yzx;\n\t\n\tp.xy = rotate(p.xy, tick(iTime*BPM/60.)*pi*.5);\n\t\n\tp2=p;\n\t\n\treturn min(outershape, shape(p));\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n\tvec3 accum = vec3(1);\n\tfor(int bounce=0;bounce<3;++bounce)\n\t{\n\t\tfloat t=0.;\n\t\tfloat k=0.;\n\t\tfor(int i=0;i<250;++i){\n\t\t\tk=scene(cam+dir*t)*.4;\n\t\t\tt+=k;\n\t\t\tif(abs(k)<.001||k>10.)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(abs(k)<.001)\n\t\t{\n\t\t\tvec3 h=cam+dir*t;\n\t\t\tvec2 o=vec2(.001,0);\n\t\t\tvec3 n=normalize(vec3(\n\t\t\t\tscene(h+o.xyy)-scene(h-o.xyy),\n\t\t\t\tscene(h+o.yxy)-scene(h-o.yxy),\n\t\t\t\tscene(h+o.yyx)-scene(h-o.yyx)\n\t\t\t));\n\t\t\t\n\t\t\tif (length(h) < 1.)\n\t\t\t{\n\t\t\t\t//return vec3(pow(n.y*.5+.5, 5.))+.25;\n\t\t\t\tfloat fresnel = pow(1.-dot(-dir,n),5.);\n\t\t\t\t//fresnel=mix(.002,1.,fresnel);\n\t\t\t\taccum *= fresnel;\n\t\t\t\tcam=h+n*.01;\n\t\t\t\tdir=reflect(dir,n);\n\t\t\t}\n\t\t\telse if (length(h) > 2.)\n\t\t\t{\n\t\t\t\th = mod(abs(h)-vec3(0,0,.5+tick2(iTime*BPM/120.)),2.)-1.;\n\t\t\t\taccum *= (step(0.,h.x*h.y*h.z))*.2+.4;\n\t\t\t\treturn accum;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfloat fresnel = pow(1.-dot(-dir,n),5.);\n\t\t\t\tvec3 color = sin(iTime+vec3(0,1,2)+h)*.5+.5;\n\t\t\t\t//accum *= mix(color,vec3(1),fresnel);\n\t\t\t\taccum *= mix(vec3(.1,.3,1).brg,vec3(0),(1.-fresnel)*.5);\n\t\t\t\tcam=h+n*.01;\n\t\t\t\tdir=reflect(dir,n);\n\t\t\t}\n\t\t}\n\t}\n\treturn accum;\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n\tvec3 cam=vec3(0,0,-5);\n\tvec3 dir=normalize(vec3(uv,1));\n\t\n\tcam.xz = rotate(cam.xz, iTime*.3);\n\tdir.xz = rotate(dir.xz, iTime*.3);\n\t\n\tcam.yz = rotate(cam.yz, iTime*.3);\n\tdir.yz = rotate(dir.yz, iTime*.3);\n\t\n\tout_color.rgb = trace(cam,dir);\n\tout_color.rgb = pow(out_color.rgb, vec3(.45));\n\tout_color.rgb *= 1.-dot(uv,uv)*.4;\n\tout_color.rgb = pow(out_color.rgb, vec3(1,1.3,1.1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2SRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 421, 451, 451, 534], [536, 536, 565, 565, 611], [623, 623, 660, 660, 707], [710, 710, 731, 731, 1036], [1038, 1038, 1059, 1059, 1160], [1162, 1162, 1184, 1184, 1381], [1383, 1383, 1404, 1404, 1735], [1737, 1737, 1769, 1769, 2830], [2832, 2832, 2884, 2884, 3352]], "test": "valid"}
{"id": "td2XDz", "name": "Postprocess : barrel blur chroma", "author": "flyingrub", "description": "Fork of : https://www.shadertoy.com/view/XssGz8", "tags": ["blur", "barrel", "rgb", "postprocess", "shift"], "likes": 4, "viewed": 246, "published": "Public", "date": "1553524375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define conrady\n#define barrel\nfloat amountBarrel = 2.;\nfloat amountZoom = .5;\n\nvec2 remap( vec2 t, vec2 a, vec2 b ) {\n\treturn clamp( (t - a) / (b - a), 0.0, 1.0 );\n}\n\nvec3 spectrum_offset_rgb( float t )\n{\n    float t0 = 3.0 * t - 1.5;\n\tvec3 ret = clamp( vec3( -t0, 1.0-abs(t0), t0), 0.0, 1.0);\n    \n    return ret;\n}\n\nvec2 barrelDistortion( vec2 p, vec2 amt )\n{\n    p = 2.0 * p - 1.0;\n    const float maxBarrelPower = 5.0;\n    float theta  = atan(p.y, p.x);\n    vec2 radius = vec2( length(p) );\n    radius = pow(radius, 1.0 + maxBarrelPower * amt);\n    p.x = radius.x * cos(theta);\n    p.y = radius.y * sin(theta);\n\n    return p * 0.5 + 0.5;\n}\n\nvec2 brownConradyDistortion(vec2 uv, float dist)\n{\n    uv = uv * 2.0 - 1.0;\n    float barrelDistortion1 = 0.1 * dist; // K1 in text books\n    float barrelDistortion2 = -0.025 * dist; // K2 in text books\n\n    float r2 = dot(uv,uv);\n    uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;\n    \n    return uv * 0.5 + 0.5;\n}\n\nvec2 distort( vec2 uv, float t, vec2 min_distort, vec2 max_distort )\n{\n    vec2 dist = mix( min_distort, max_distort, t );\n    \n    #ifdef conrady\n    return brownConradyDistortion( uv, 75.0 * dist.x );\n    #endif\n    \n    #ifdef barrel\n    return barrelDistortion( uv,1.75*dist );\n    #endif\n\n}\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec3 render( vec2 uv )\n{\n    return texture( iChannel0, uv ).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    \n    const float MAX_DIST_PX = 50.0;\n    float max_distort_px = MAX_DIST_PX * amountBarrel;\n\tvec2 max_distort = vec2(max_distort_px) / iResolution.xy;\n    vec2 min_distort = 0.5 * max_distort;\n    \n    vec2 oversiz = distort( vec2(1.0), 1.0, min_distort, max_distort );\n    uv = mix(uv,remap( uv, 1.0-oversiz, oversiz ),amountZoom);\n    \n    const int num_iter = 7;\n    const float stepsiz = 1.0 / (float(num_iter)-1.0);\n    float rnd = nrand( uv + fract(iTime) );\n    float t = rnd*stepsiz;\n    \n    vec3 sumcol = vec3(0.0);\n\tvec3 sumw = vec3(0.0);\n\tfor ( int i=0; i<num_iter; ++i )\n\t{\n\t\tvec3 w = spectrum_offset_rgb( t );\n\t\tsumw += w;\n        vec2 uvd = distort(uv, t, min_distort, max_distort);\n\t\tsumcol += w * render( uvd );\n        t += stepsiz;\n\t}\n    sumcol.rgb /= sumw;\n    \n    vec3 outcol = sumcol.rgb;\n    outcol =  outcol;\n    outcol += rnd/255.0;\n    \n\tfragColor = vec4( outcol, 1.0);\n}\n", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2XDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 118, 118, 166], [168, 168, 205, 205, 317], [319, 319, 362, 362, 644], [646, 646, 696, 696, 980], [982, 982, 1052, 1052, 1277], [1279, 1279, 1302, 1302, 1370], [1372, 1372, 1396, 1396, 1439], [1441, 1441, 1498, 1498, 2443]], "test": "error"}
{"id": "td2XWR", "name": "Rainbow fractal slurry", "author": "kvick", "description": "like the other one but slurrier", "tags": ["rainbowfractal"], "likes": 4, "viewed": 106, "published": "Public", "date": "1553488725", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 func(float t)\n{\n \treturn vec2(\n        t * sin(t),\n        t * cos(t)\n    );\n}\n\nvec3 getColor(vec2 st, float iter)\n{\n    vec3 col = vec3(0.0);\n    for (float i = 0.; i < iter; i += 0.25)\n    {\n        vec2 result = func(mod((iTime * sqrt(length(st)) * 0.01 + i * i) * 1.1, 30.0));\n\t\t\n        float dist = length(result - st);\n        float res = (dist < i * 0.01) ? 1.0: 0.0;\n        \n        float id = floor(mod(i, 3.0));\n        vec3 col1 = vec3(1., 0., 0.);\n        vec3 col2 = vec3(0., 1., 0.);\n        vec3 col3 = vec3(0., 0., 1.);\n        col += ((id == 0.) ? col1 : (id == 1.) ? col2 : col3)\n            * (res * 0.015 / dist);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv;\n    st -= vec2(0.5);\n    st *= vec2(0.5 * (iResolution.x / iResolution.y), 0.5);\n    \n    vec3 col = vec3(0.);\n    \n    st *= 55.0;\n    \n    col += getColor(st, 350.);\n    st /= length(st * sin(iTime * 0.01));\n    col += getColor(st, 55.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2XWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 83], [85, 85, 121, 121, 664], [666, 666, 723, 723, 1083]], "test": "valid"}
{"id": "tdBSWR", "name": "Channel Soup", "author": "Blokatt", "description": "Originally written on my phone during a bus ride, updated a bit later.", "tags": ["fbm", "plasma", "rgb", "smoke"], "likes": 8, "viewed": 617, "published": "Public API", "date": "1553461392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Channel Soup\n// 24/03/19:\n// Tiny thing written by @blokatt on his phone (hence why the code might be messy).\n// Might clean it up later, right now, I'm lazy.\n// 10/04/19: Update.\n\n\nmat2 rotate(float a) {\n  return mat2(\n    cos(a), -sin(a),\n    sin(a), cos(a));\n}\n\nfloat rand(vec2 p){\n\treturn fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat valueNoise(vec2 uv){\n    vec2 i = fract(uv);\n    vec2 f = floor(uv);\n\tfloat a = rand(f);\n    float b = rand(f + vec2(1.0, 0.0));\n    float c = rand(f + vec2(0.0, 1.0));\n    float d = rand(f + vec2(1.0, 1.0));    \n    return mix(mix(a, b, i.x), mix(c, d, i.x), i.y);\n}\n\nfloat noise(vec2 uv){\n    float v = 0.;\n    float freq = 1.;\n    float amp = 0.4;\n    uv  += 2.;\n    for (int i = 0; i < 5; ++i) {\n    \tv += valueNoise((uv + iTime) * freq) * amp;\n        amp *= .6;\n        freq *= 1.75;\n    }\n\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = iTime;\n  vec2 uv = fragCoord/iResolution.xy - .5;\n  uv.x *= iResolution.x / iResolution.y;\n  uv *= .5;  \n  vec2 nuv = uv;\n  uv *= rotate((length(uv) * 5. + time * .5));\n  uv *= 20. - length(uv) * 5.;\n  uv *= 1.5 + 2. * ((sin(time * .2 + length(uv) * .8) * .5) + .5);\n  vec3 color =vec3(1);\n    \n  float coff = 1. + length(uv) * .01;\n  color.r = sin(uv.y * uv.x + time * 5.) + cos(uv.y  + time) * 3.;\n  color.g = sin(uv.y * uv.x + time * 5. + .4 * coff) + cos(uv.y + time + .5 * coff) * 3.;\n  color.b = sin(uv.y * uv.x + time * 5. + .8 * coff) + cos(uv.y + time + 1. * coff) * 3.;\n  color *= 1.2 - pow(length(nuv), .1);\n\n  float overlay = noise(uv + vec2(noise(uv), noise(uv * 2.)) *  rotate(noise(uv)));\n  overlay = (overlay - .5) * 5. + .5;\n  fragColor = vec4(color - (.3 * overlay), 1.0 );\n\n}\n", "image_inputs": [{"id": "Xll3DM", "previewfilepath": "https://soundcloud.com/blokatt/scuttlemorph", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/blokatt/scuttlemorph", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 185, 207, 207, 266], [268, 268, 287, 287, 352], [354, 354, 380, 380, 627], [629, 629, 650, 650, 872], [874, 874, 931, 931, 1741]], "test": "valid"}
{"id": "tdBXWw", "name": "Trying iq's 'goo thing'-SDF", "author": "MacSlow", "description": "Trying out iq's odd SDF from https://www.shadertoy.com/view/tsSSRD to see how stable/artifact-free it is. Quickly thrown into a less empty scene with lighting (blinn-phong), shadows, ao and some 'post-processing'. Hardly any glitches... good Lipschitz!", "tags": ["3d", "phong", "raymarch", "sound", "sdf", "shadow", "post", "ao", "spheretrace", "blinn"], "likes": 6, "viewed": 422, "published": "Public API", "date": "1553983568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// iq's 'goo thing'-SDF - Trying out iq's odd SDF from ShaderToy-meeting\n// at GDC 2019\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float deg) {\n\tfloat rad = radians (deg);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (c,s,-s,c);\n}\n\n// iq's 'goo thing'-SDF from https://www.shadertoy.com/view/tsSSR\nfloat sdThingFromIQ (vec3 p) {\n    float s = 2. + 3.*(.5+.5*cos (4.*iTime));\n    p.xyz += .05 * sin(2.0 * p.yxx + iTime) * s;\n    p.xyz += .025 * cos(4.0 * p.yxx + iTime) * s;\n    p.xyz += .0125 * cos(8.0 * p.yxx + iTime) * s;\n    p.xyz += .00625 * sin(16.0 * p.yxx + iTime) * s;\n    float r = .5 + .3*(.5+.5*cos (6.*iTime));\n    return length(p) - r;\n}\n\n// sorry about the lazy-ass 'material-system' using call-by-reference id & pout\nfloat map (vec3 p, inout int id, inout vec3 pout) {\n\tfloat ground = p.y + 1.;\n\tfloat wall = p.z + 1.;\n\tfloat size = 3.;\n\tvec3 thingCenter = p;\n\tthingCenter.x = mod (p.x + .5*size, size) - .5*size;\n\tthingCenter.xz *= r2d (45.*iTime);\n\tthingCenter.yz *= r2d (65.*iTime);\n\tfloat thing = sdThingFromIQ (thingCenter);\n\tfloat d = min (ground, min (wall, thing));\n\tif (d == ground) {id = 1; pout = p;}\n\tif (d == wall) {id = 2; pout = p;}\n\tif (d == thing) {id = 3; pout = thingCenter;}\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout int id, inout vec3 pout)\n{\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0; i< 64; ++i) {\n\t\tvec3 p = ro+d*rd;\n\t\tt = map (p, id, pout);\n\t\tif (abs (t) < .0001*(1. + .125*t)) break;\n\t\td += t*.4;\n\t}\n\treturn d;\n}\n\nvec3 norm (vec3 p) {\n\tint ignored1;\n\tvec3 ignored2;\n\tfloat d = map (p, ignored1, ignored2);\n\tvec2 e = vec2 (.001, .0);\n\treturn normalize (vec3 (map (p+e.xyy, ignored1, ignored2),\n                            map (p+e.yxy, ignored1, ignored2),\n                            map (p+e.yyx, ignored1, ignored2))-d);\n}\n\nfloat sha (vec3 p, vec3 lp, vec3 n, vec3 ldir) {\n\tfloat d2l = distance (lp, p);\n\tint ignored1;\n\tvec3 ignored2;\n\tfloat d2w = march (p+.01*n, ldir, ignored1, ignored2);\n\treturn d2l < d2w ? 1. : .1;\n}\n\nfloat ao (vec3 p, vec3 n, float stepsize, float i){\n\tfloat ao = .0;\n\tfloat dist = .0;\n\tint ignored1;\n\tvec3 ignored2;\n\tfor (int a = 1; a <= 6; ++a) {\n\t\tdist = float (a)*stepsize;\n\t\tao += max (.0, (dist - map (p+n*dist, ignored1, ignored2))/dist);\n\t}\n\treturn 1. - ao*i;\n}\n\nvec3 shade (vec3 ro,\n            vec3 rd,\n            float d,\n            vec3 n,\n            vec3 lp,\n            vec3 lc,\n            float li,\n            int id,\n            vec3 pout) {\n    vec3 p = ro + d*rd;\n\tfloat ld = distance (p, lp); \n\tvec3 ldir = normalize (lp - p);\n\tfloat att = 5. / (ld*ld);\n\tvec3 mat = vec3 (.2);\n\tif (id == 1) mat = mix (vec3 (.3, .25, .1),\n                            vec3 (.25, .3, .2),\n                            smoothstep(.0, .9, cos (20.*p.x) * sin(20.*p.z)));\n\tif (id == 2) mat = mix (vec3 (.0, .3, .1),\n                            vec3 (.0, .1, .3),\n                            smoothstep (.0, .9, cos (5.*p.x) + sin (5.*p.y)));\n\tif (id == 3) mat = mix (vec3 (.3, .0, .0),\n                            vec3 (.3, .3, .0),\n                            smoothstep (.0,.9,cos (20.*pout.y)));\n\tfloat s = sha (p, lp, n, ldir);\n\tfloat diff = max (.0, dot (n, ldir));\n\tvec3 h = normalize (-rd + ldir);\n\n    float shiny = 100.;\n    if (id == 1 ) {\n        float hf = texture (iChannel0, .75*p.xz).r;\n        float lf = texture (iChannel0, .25*p.xz).r;\n        float fac = hf + lf;\n        shiny *= fac;\n    }\n    if (id == 2) {\n        float hf = texture (iChannel0, .75*p.xy).r;\n        float lf = texture (iChannel0, .25*p.xy).r;\n        float fac = hf + lf;\n        shiny *= fac;\n    }\n    if (id == 3) {\n        float hf = texture (iChannel0, 32.*pout.xz).r;\n        float lf = texture (iChannel0, .1*pout.xz).r;\n        float fac = mix (lf,\n                         hf,\n                         smoothstep (.0,\n                                     .9,\n                                     cos (20.*pout.y)));\n        shiny *= fac;\n    }\n\n    float sp = pow (max (.0, dot (h, n)), shiny);\n\n    vec3 am = vec3 (.05);\n\tfloat ao = ao (p, n, .1, .1);\n\treturn ao*att*s*(am + diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float zoom) {\n\tvec3 f =normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross (wu, f));\n\tvec3 u = normalize (cross (f, r));\n\tvec3 c = ro + f*zoom;\n\treturn normalize (c + r*uv.x+u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvRaw = fragCoord.xy/iResolution.xy;\n\tvec2 uv = uvRaw*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .5*length (uv);\n\n\tvec3 ro = vec3 (cos (iTime), 1.+.75*(.5+.5*cos(5.*iTime)), 2.);\n\tvec3 rd = cam (uv, ro, vec3 (.0), 2.);\n\tint id = 0;\n\tvec3 pout = vec3 (.0);\n\tfloat d = march (ro, rd, id, pout);\n\tvec3 p = ro + d*rd;\n\tvec3 n = norm (p);\n\tvec3 col = shade (ro, rd, d, n,\n                      vec3 (.0, .0, 2.),\n                      vec3 (.9, .85, .5),\n                      4.,id, pout);\n\tcol += shade (ro, rd, d, n,\n                  vec3 (.0, 3., .0),\n                  vec3 (.2, .2, .9),\n                  6.,id, pout);\n\tcol += shade (ro, rd, d, n,\n                  vec3 (-3., 1., .5),\n                  vec3 (.9, .5, .3), 2.,id, pout);\n\n\tcol = col / (1.25 + col*.5);\n\tcol *= 1. - .65*length(uvRaw*2.-1.);\n\tcol *= mix (1., .75, cos (700.*uvRaw.y));\n\tcol = pow (col, vec3 (1./2.2));\n\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "XtX3D7", "previewfilepath": "https://soundcloud.com/professorkliq/all-that-matters-1", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/professorkliq/all-that-matters-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBXWw.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 968, 990, 990, 1089], [1091, 1157, 1187, 1187, 1510], [1512, 1592, 1643, 1643, 2085], [2087, 2087, 2150, 2150, 2329], [2331, 2331, 2351, 2351, 2641], [2643, 2643, 2691, 2691, 2840], [2842, 2842, 2893, 2893, 3111], [3113, 3113, 3304, 3304, 4952], [4954, 4954, 5005, 5005, 5208], [5210, 5210, 5267, 5267, 6207]], "test": "error"}
{"id": "tdBXzR", "name": "Iridescent Box", "author": "polymonster", "description": "Experimenting with iridescent effect.", "tags": ["sdf", "box", "iridescence"], "likes": 14, "viewed": 479, "published": "Public", "date": "1552683619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14\n\nmat3 create_camera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = cross(cu,cw);\n    \n    return mat3( cu, cv, cw );\n}\n\nfloat sd_sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sd_box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat bsin(float v)\n{\n    return sin(v) * 0.5 + 1.0;\n}\n\nfloat bcos(float v)\n{\n    return cos(v) * 0.5 + 1.0;\n}\n\nfloat op_union( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat map(vec3 p)\n{\n    return sd_box(p, vec3(2.5));\n}\n\nvec3 sky(vec3 v)\n{\n    vec3 grad_a = vec3(0.9, 0.85, 0.7);\n    vec3 grad_b = vec3(0.5, 0.0, 1.0) * 0.5;\n    \n    float grad_t = v.y * 0.5 + 0.5;\n    \n    return mix(grad_b, grad_a, grad_t);\n}\n\nvec3 calc_normal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor;\n    \n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    \n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float eps = 0.05;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    vec3 ro = vec3(cos(iTime) * 10.0, 0.0, sin(iTime) * 10.0);\n    \n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    mat3 cam = create_camera( ro, ta, 0.0 );\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;  \n    \n    vec3 rd = cam * normalize( vec3(p.xy,2.0) );\n    \n    float d = 10.0;\n    float xt = 0.0;\n    vec3 pp = ro;\n   \n    vec3 l = normalize(vec3(0.0, 1.0, 1.0));\n    \n    for(float t = 0.0; t < 20.0; ++t)\n    {\n        pp = ro + rd * xt;\n        d = map(pp);\n        \n        if(d < eps)\n            break;\n        \n        xt += d;\n    }\n    \n    vec3 n = calc_normal(pp);\n    \n    float nv = dot(n, -rd);\n\n    col += sin(nv * vec3(0.0, 1.0, 0.0) * 10.0 * 1.5) * 0.5 + 0.5;  \n    col += sin(nv * vec3(1.0, 0.0, 0.0) * 20.0 * 1.5) * 0.5 + 0.5;  \n    col += sin(nv * vec3(0.0, 0.0, 1.0) * 5.0 * 1.5) * 0.5 + 0.5;\n    col = clamp(normalize(col), 0.0, 1.0);\n    \n    float mask = step(d, eps);\n    float inv_mask = 1.0 - mask;\n    \n    vec3 csky = sky(rd);\n    \n    fragColor = vec4(csky * inv_mask + col * mask, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 73, 73, 242], [244, 244, 280, 280, 306], [308, 308, 340, 340, 427], [429, 429, 450, 450, 483], [485, 485, 506, 506, 539], [541, 541, 579, 579, 604], [606, 606, 625, 625, 660], [662, 662, 680, 680, 853], [855, 855, 886, 886, 1124], [1126, 1126, 1183, 1183, 2400]], "test": "valid"}
{"id": "tdfSRj", "name": "MCG: parametric vs implicit", "author": "tale3d", "description": "In this lecture we have introduction into geometric objects and how they can be presented in an implicit and parametric forms. ", "tags": ["teachingmaterial"], "likes": 0, "viewed": 43, "published": "Public", "date": "1551647112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n\n    //Adding more to the common section:\n    //This example has a mouse as an input device.\n    //The mouse coordinates are taking in uv space, and then is modified in the same way\n    //  as the pixel coordinates (see above). \n    vec2 mouse = 2.0*(iMouse.xy / iResolution.xy) - vec2(1.0,1.0);\n    mouse.x *= aspect_ratio;\n\n\n    //Background colour (default)\n    vec3 colour = vec3(1.0,1.0,1.0);\n\n    //Here we define our triangle. \n    // It has three vertices, two with fixed position and third depends on the mouse\n    vec2 p2 = vec2(-0.6,0.5);\n    vec2 p1 = mouse;\n\n    //if the pixel we colouring is close enough to the point p1, we make it red\n    //\"close enough\" means distance, which we calculate by using dot product of vector to itself\n    //(see lecture on vectors)\n    if (dot(c-p1, c-p1) < 0.001) colour = vec3(1.0,0.0,0.0);\n    //the same is for second point, whose proximity we colour green\n    if (dot(c-p2, c-p2) < 0.001) colour = vec3(0.0,1.0,0.0);\n\n    //Direction for the line\n    vec2 dp = p2-p1;\n    \n    //For parametric representation we can generate the point for the given value of t\n    //As we are in the example that works for all the pixels, the idea of visualising that\n    //   might be the following: make t time-dependent and visualise the point that\n    //   corresponds to the value of t.\n    //\n    // Starting with time-dependent t: sin(iTime) iterates from -1 to 1\n    //    0.5+0.5[-1,1] = [0,1], so actually t iterates between 0 and 1\n    float t = 0.5+0.5*sin(iTime);\n\t\n    //find the point given the value of t\n    vec2 parametric = p1 + dp*t;\n\n    //as previously, if the point is close enough to the given pixel, we colour it blue\n    if (dot(c-parametric, c-parametric) < 0.001) colour = vec3(0.0,0.0,1.0);\n\n    //now the implicit equation: we use one of the equations from the lecture\n    float implicit = (c.x-p1.x)/dp.x - (c.y-p1.y)/dp.y;\n\n    //if it is equal to 0, then we are on our straight line, but as we work with pixels \n    //   which might be slightly off, we use proximity test once again.\n    if (abs(implicit) < 0.01) colour = vec3(0.0,0.0,0.0);     //Colour the line black.     \n    \n    //That is it, assign the colour to the pixel.\n    fragColor = vec4(colour,1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 404, 2976]], "test": "valid"}
{"id": "tdfXWS", "name": "Hypno spiral", "author": "JScotty", "description": "My very first Shadertoy shader :)\n\nI wanted to put some research in spirals and came up to this project while playing around with my research. :)\n\nHope you like it, and if you have any remarks or tips please let me know.", "tags": ["spiral", "hypno"], "likes": 3, "viewed": 175, "published": "Public", "date": "1551993724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 0.1 // speed over simulated z axis\n#define ROTATION_SPEED 4.0 // rotation speed of the spirals\n#define DISTANCE 20.0 // start distance of the spiral\n#define SIZE 10.0 // layer size ( put it 100+ for fun ;) )\n#define LAYERS 4.0 // amount of layers\n#define LAYER_ALPHA 0.4 // alpha of layer spiral\n#define SPIRALS 4.0 // alpha of layer spiral\n#define SPIRALS_STRENGTH 0.1 // strength of spiral edge fade\n\nfloat Spiral(vec2 uv){\n    // creating spiral\n\tfloat x = uv.x;\n\tfloat y = uv.y;\n    \n    float dis = length(uv);\n   \tfloat angle = atan(y, x) * SPIRALS;\n    \n    float c = sin(dis * DISTANCE + (angle + iTime * ROTATION_SPEED));\n\t\n    // make sure the spiral value can not be less than 0 so it won't affect layers.\n    if(c < 0.0) c *= 1.0;\n    c = smoothstep(0.0, SPIRALS_STRENGTH, c);\n\t\n    return c * LAYER_ALPHA;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // spiral value called c because it will represend color\n    float c = 0.0;\n    \n    // correcting uv coords to center of the screen\n   \tvec2 uv = fragCoord/iResolution.xy;\n   \tuv -= vec2(0.5, 0.5);\n   \tuv *= 2.0;\n    \n   \tfor(float i = 0.0; i <= 1.0; i+=1.0/LAYERS){\n        // calculating simulated z axis\n   \t   \tfloat z = fract((i) + (iTime * SPEED));\n       \tfloat size = mix(SIZE, 0.1, z);\n        \n        // fade on base of simulated z axis (to fade layer in and out)\n       \tfloat fade = smoothstep(0.0, 0.1, z) * smoothstep(1.0, 0.9, z);\n    \n        //apply new spiral\n       \tc += fade * Spiral(uv * size);\n   \t}\n    \n    // loop through color over time\n   \tvec3 colorChange = sin(iTime * 5.0 * vec3(0.3, 0.5, 0.6)) * 0.4 + 0.6;\n\tfragColor = vec4(c,c,c,c) * vec4(colorChange, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 417, 439, 462, 834], [836, 836, 893, 954, 1691]], "test": "valid"}
{"id": "tdfXzB", "name": "Midterms_Co_Design3", "author": "johannco98", "description": "A clock", "tags": ["asd"], "likes": 1, "viewed": 53, "published": "Public", "date": "1551543000", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Spikes(float angle, float armSpeed, float armNum, float armWidth, float size)\n{\n    float spikes =  -(abs(cos(angle * 0.5 + (iTime * armSpeed)) \n                        * sin(angle * armNum )))\n        \t\t\t\t\t\t\t\t\t\t\t* armWidth +      size;\n    \n    return spikes;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Colors in vec3\n    vec3 red = vec3(0.8 ,0.0 ,0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 yellow = vec3(0.9, 0.9, 0.3);\n    vec3 blue = vec3(0.0, 0.2, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos = vec2((0.5 * ratio) , 0.5);\n    float dist = distance(shapePos , uv) * 2.50;\n    \n    uv -= shapePos;\n    \n    float angle = atan(uv.y, uv.x);\n    float spikes = Spikes(angle, 0.25, 6.0, 10.0, 0.5);\n     \n    \n    vec3 test = mix(white, green, spikes);\n    test = mix(test, red, Spikes(angle, 3.0, 6.0, 10.0, 0.5));\n\t\n    float value =  step(spikes * 3.0, dist);\n    \n    // Output to screen\n    fragColor = vec4(test , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfXzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 85, 85, 273], [276, 276, 333, 354, 1193]], "test": "valid"}
{"id": "tdjSD1", "name": "Ray Cast Glow", "author": "xmmos", "description": "this shader add glow for the default raycast algorithm by counting the amount of steps", "tags": ["raycastglow"], "likes": 7, "viewed": 150, "published": "Public", "date": "1553686862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x<-0.5 )\n    {\n    res = opU( res, vec2( opS( \n                          sdRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                      sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS( \n                          sdTorus82(   pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)), \n                          sdCylinder(  \n                               opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\tres = opU( res, vec2( 0.5*sdSphere(pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(45.0*pos.x)*sin(45.0*pos.y)*sin(45.0*pos.z), 65.0 ) );\n\tres = opU( res, vec2( 0.6*sdTorus( \n                              opTwist( pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-2.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    }\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\tres = opU( res, vec2( sdOctahedron(pos-vec3(-1.0,0.15,-2.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n    res = opU( res, vec2( sdCappedCone(pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-2.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone( pos-vec3( 2.0,0.20,-2.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec3 castRay( in vec3 ro, in vec3 rd )\n{\n    float gb = 0.0; //glow base\n    float gf = 3.0; //glow factor - number of steps , is the glow :-)\n    vec3 res = vec3(-1.0,-1.0,0.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec3( tp1, 1.0,gb );\n    }\n    else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,0.0), rd, vec3(2.5,0.41,2.5) );\n    //if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        float g=res.z;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            res.z += gf/70.0;\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.001*t) )\n            { //https://www.shadertoy.com/signin\n                res = vec3(t,h.y,g); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec3 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    float g = res.z;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n    col = col + vec3(g,g/2.0,0 );\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    // camera\t\n    vec3 ro = vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjSD1.jpg", "access": "shaders20k", "license": "mit", "functions": [[1389, 1459, 1484, 1484, 1499], [1501, 1501, 1536, 1536, 1562], [1564, 1564, 1595, 1595, 1686], [1688, 1688, 1747, 1747, 1841], [1843, 1843, 1898, 1898, 1993], [1995, 1995, 2028, 2028, 2083], [2085, 2085, 2121, 2121, 2432], [2434, 2434, 2486, 2486, 2600], [2602, 2602, 2666, 2666, 2944], [2946, 2946, 2970, 2970, 2987], [2988, 2988, 3051, 3115, 3702], [3704, 3704, 3747, 3747, 3998], [4000, 4000, 4036, 4036, 4219], [4221, 4233, 4269, 4269, 4372], [4374, 4399, 4450, 4450, 4805], [4807, 4807, 4845, 4845, 5014], [5016, 5016, 5041, 5041, 5060], [5061, 5061, 5132, 5132, 5470], [5983, 5983, 6008, 6008, 6045], [6047, 6047, 6072, 6072, 6130], [6132, 6132, 6157, 6157, 6222], [6224, 6224, 6259, 6259, 6330], [6332, 6332, 6367, 6367, 6438], [6440, 6440, 6477, 6477, 6530], [6532, 6602, 6635, 6635, 6661], [6663, 6663, 6693, 6693, 6726], [6728, 6728, 6758, 6758, 6787], [6789, 6789, 6813, 6813, 6945], [7047, 7117, 7142, 7142, 9914], [9916, 9984, 10035, 10035, 10240], [10269, 10269, 10309, 10309, 11283], [11286, 11348, 11426, 11449, 11790], [11792, 11856, 11888, 11888, 12419], [12421, 12421, 12463, 12463, 12779], [12781, 12857, 12893, 12914, 13137], [13139, 13139, 13178, 13178, 14956], [14958, 14958, 15010, 15010, 15187], [15189, 15189, 15246, 15246, 16198]], "test": "valid"}
{"id": "tdjSDh", "name": "Certain People", "author": "grumdrig", "description": "This is based on a dream I had, wherein it was understood that this pattern represented certain people, but I don't remember which people.", "tags": ["fractal", "monochrome"], "likes": 5, "viewed": 94, "published": "Public", "date": "1553663651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 rotate(vec2 v, float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a)) * v;\n}\n\nbool test(float v) {\n    int n = int(floor(v));\n    return ((1 & n & n >> 3 & n >> 6 & n >> 9) == 1);\n}\n\nfloat f(vec2 v) {\n    float t = iTime / 4.0;\n    float p = fract(t);\n    float scale = 10.0 * pow(8.0, p);\n    ivec2 n = ivec2(floor(v * scale));\n    vec2 q = vec2(p,p);\n    return max(test(v.x * scale) || test(v.x * scale + q.x) || test(v.x * scale - q.x) ? 1.0 : 0.0,\n               test(v.y * scale) || test(v.y * scale + q.y) || test(v.y * scale - q.y) ? 1.0 : 0.0);\n}\n\nfloat C(vec2 fragCoord) {\n    vec2 uv = 4. * (2. * fragCoord.xy / iResolution.x - 1.);\n\n    float tr = iTime / 200.0;\n\tfloat r = 3.14159265 * sin(21.0 * tr) * sin(5.0 * tr);\n\tuv =rotate(uv, r);\n\n    uv += vec2(-2.0, -2.0);\n\n    float t = iTime / 20.0;\n    float x0 = sin(33.0 * t) * cos(9.0 * t);\n    float y0 = sin(40.0 * t) * sin(7.0 * t);\n    t /= 10.0;\n    x0 += 2.0 * sin(33.0 * t) * cos(9.0 * t);\n    y0 += 2.0 * sin(40.0 * t) * sin(7.0 * t);\n\n    return f(uv + vec2(x0, y0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float c = (C(fragCoord                 ) +\n               C(fragCoord + vec2(0.0, 0.5)) +\n               C(fragCoord + vec2(0.5, 0.0)) +\n               C(fragCoord + vec2(0.5, 0.5))) / 4.;\n    fragColor = vec4(c,c,c,1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjSDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 30, 30, 100], [102, 102, 122, 122, 205], [207, 207, 224, 224, 579], [581, 581, 606, 606, 1065], [1067, 1067, 1122, 1122, 1348]], "test": "valid"}
{"id": "tdjSWR", "name": "morning city isOutClosed", "author": "ollj", "description": "fork of\nhttps://www.shadertoy.com/view/XsBSRG\nmouse.y sets lame FoV\nmouse.x rotates around vertical axis.\n\npossibly faster than its parent.", "tags": ["tower", "city", "trace", "interval", "cars", "traverse", "isoutclosed", "isoutopen", "skyscraper"], "likes": 19, "viewed": 790, "published": "Public API", "date": "1553482685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define CARS\n#define I_MAX 270\n\n//self  :  https://www.shadertoy.com/view/tdjSWR\n//parent:  https://www.shadertoy.com/view/XsBSRG\n\n//child may have broken some minor things (some offsets may bebad)\n//child adds some useful subroutine identities to its parent;\n//by using more || than && it may run faster on some hardware\n//i increased I_MAX from 70 to 270\n//, seems that precision is a bigger issue than number of iterations.\n\n\n//opengl has no component wise [not] ?\nvoid bnot(inout bvec3 a){a.x=!a.x;a.y=!a.y;a.z=!a.z;}\n\n#define vec1 float\n//return if [a] is Outside of closed interval; [s..e] ;s<=e\nbool isOutClosed(vec1 a,vec1 s,vec1 e){return              e-s<abs(a*2.-e-s);}//return (a>e)&&(a<s)\nbool isOutClosed(vec2 a,vec2 s,vec2 e){return any(lessThan(e-s,abs(a*2.-e-s)));}\nbool isOutClosed(vec3 a,vec3 s,vec3 e){return any(lessThan(e-s,abs(a*2.-e-s)));}\nbool isOutClosed(vec4 a,vec4 s,vec4 e){return any(lessThan(e-s,abs(a*2.-e-s)));}\n//return if [a] is in closed interval; [s..e]  ;s<=e\n#define isInClosed(a,b,c) (!isOutClosed(a,b,c))\n//return if [a] is in open   interval; ]s..e[  ;s<=e\nbool isInOpen(vec1 a,vec1 s,vec1 e){return              abs(a*2.-e-s)<e-s;}//return (a>s)&& (a<e) \nbool isInOpen(vec2 a,vec2 s,vec2 e){return any(lessThan(abs(a*2.-e-s),e-s));}\nbool isInOpen(vec3 a,vec3 s,vec3 e){return any(lessThan(abs(a*2.-e-s),e-s));}\nbool isInOpen(vec4 a,vec4 s,vec4 e){return any(lessThan(abs(a*2.-e-s),e-s));}\n//return if [a] is Outside of open interval; ]s..e[   ;s<=e\n#define isOutOpen(a,b,c) (!isInOpen(a,b,c))\n//any() can perform faster than all(), therefore we define [all() == !(any(!(ivecN)))]\n//where [(a<b) == !(a>=b)]\n//where  (a< b) is isOutClosed()\n//where !(b>=a) is isOutOpen()   //note the swapped parameters \n\nfloat rand(vec2 n\n){return fract(sin((n.x*1e2+n.y*1e4+1475.4526)*1e-4)*1e6);}\n\nfloat noise(vec2 p){p=floor(p*200.);return rand(p);}\n\n//AxisAlignedQuad-tracing crunched by ollj\n#define pmpm vec4(1,-1,1,-1)\nvec4 setg(vec2 a,vec2 b){return pmpm*min(a.xxyy*pmpm,b.xxyy*pmpm);}\nvec3 polygon(vec2 c,vec4 g,vec3 d,vec3 u\n){if(any(lessThan(vec4(c.xy,g.yw),vec4(g.xz,c.xy)))||dot(d,u)<0.)return vec3(101,0,0)\n ;return vec3(length(u),c.xy-g.xz);}\nvec3 polygonXY(float z,vec2 a,vec2 b,vec3 u,vec3 d\n){vec2 c=u.xy-d.xy*(u.z-z)/d.z;return polygon(c,setg(a,b),d,vec3(c,z)-u);}\nvec3 polygonYZ(float x,vec2 a, vec2 b, vec3 u,vec3 d\n){vec2 c=u.yz-d.yz*(u.x-x)/d.x;return polygon(c,setg(a,b),d,vec3(x,c)-u);}\nvec3 polygonXZ(float y,vec2 a, vec2 b, vec3 u,vec3 d\n){vec2 c=u.xz-d.xz*(u.y-y)/d.y;return polygon(c,setg(a,b),d,vec3(c.x,y,c.y)-u);}\n\nvec3 textureWall(vec2 pos, vec2 maxPos, vec2 squarer,float s,float height,float dist,vec3 d,vec3 norm\n){float randB=rand(squarer*2.0)\n ;vec3 windowColor=(-0.4+randB*0.8)*vec3(0.3,0.3,0.0)\n +(-0.4+fract(randB*10.0)*0.8)*vec3(0.0,0.0,0.3)+(-0.4+fract(randB*10000.)*0.8)*vec3(0.3,0.0,0.0)\n ;float floorFactor=1.\n ;vec2 windowSize=vec2(0.65,0.35)\n ;vec3 wallColor=s*(0.3+1.4*fract(randB*100.))*vec3(0.1,0.1,0.1)\n +(-0.7+1.4*fract(randB*1000.))*vec3(0.02,0.,0.)\n ;wallColor*=1.3\n ;vec3 color=vec3(0)\n ;vec3 conturColor=wallColor/1.5\n ;if (height<0.51\n ){windowColor += vec3(.3,.3,.0)\n  ;windowSize=vec2(.4)\n  ;floorFactor=0.;}\n ;if (height<.6){floorFactor=0.;}\n ;if (height>.75)windowColor += vec3(0,0,.3)\n ;windowColor*=1.5\n ;float wsize=0.02\n ;wsize+=-0.007+0.014*fract(randB*75389.9365)\n ;windowSize+= vec2(0.34*fract(randB*45696.9365),0.50*fract(randB*853993.5783))\n ;windowSize/=2.\n ;vec2 contur=vec2(0.0)+(fract(maxPos/2.0/wsize))*wsize\n  ;vec2 pc=pos-contur\n ;if (contur.x<wsize)contur.x+=wsize\n ;if (contur.y<wsize)contur.y+=wsize\n ;vec2 winPos=(pc)/wsize/2.0-floor((pc)/wsize/2.0)\n ;float numWin=floor((maxPos-contur)/wsize/2.0).x\n ;vec3 n=floor(numWin*vec3(1,2,3)/4.)\n ;vec2 m=numWin*vec2(1,2)/3.\n ;float w=wsize*2.\n ;bvec3 bo=bvec3(isOutOpen(pc.x  ,w*n.y,w+w*n.y)||isOutOpen(maxPos.x,.5,.6)\n                ,isOutOpen(pc.xx ,w*m  ,w+w*m  )||isOutOpen(maxPos.x,.6,.7)\n                ,isOutOpen(pc.xxx,w*n  ,w+w*n  )||maxPos.x>.7)\n ;bnot(bo)\n ;if(any(bo))return (.9+.2*noise(pos))*conturColor \n ;if((maxPos.x-pos.x<contur.x)||(maxPos.y-pos.y<contur.y+w)||(pos.x<contur.x)||(pos.y<contur.y))\n            return (0.9+0.2*noise(pos))*conturColor\n ;if (maxPos.x<0.14)return (0.9+0.2*noise(pos))*wallColor\n ;vec2 window=floor(pc/w)\n ;float random=rand(squarer*s*maxPos.y+window)\n ;float randomZ=rand(squarer*s*maxPos.y+floor(pc.yy/w))\n ;float windows=floorFactor*sin(randomZ*5342.475379+(fract(975.568*randomZ)*0.15+0.05)*window.x)\n ;float blH=0.06*dist*600./iResolution.x/abs(dot(normalize(d.xy),normalize(norm.xy)))\n ;float blV=0.06*dist*600./iResolution.x/sqrt(abs(1.0-pow(abs(d.z),2.0)))\n ;windowColor +=vec3(1.0,1.0,1.0)\n ;windowColor*=smoothstep(.5-windowSize.x-blH,.5-windowSize.x+blH,winPos.x)\n ;windowColor*=smoothstep(.5+windowSize.x+blH,.5+windowSize.x-blH,winPos.x)\n ;windowColor*=smoothstep(.5-windowSize.y-blV,.5-windowSize.y+blV,winPos.y)\n ;windowColor*=smoothstep(.5+windowSize.y+blV,.5+windowSize.y-blV,winPos.y)\n ;if ((random <0.05*(3.5-2.5*floorFactor))||(windows>0.65)\n ){if (winPos.y<0.5)windowColor*=(1.0-0.4*fract(random*100.))\n  ;if ((winPos.y>0.5)&&(winPos.x<0.5))windowColor*=(1.0-0.4*fract(random*10.0))\n  ;return (.9+.2*noise(pos))*wallColor+(0.9+0.2*noise(pos))*windowColor\n ;} else windowColor*=0.08*fract(10.0*random)\n ;return (.9+.2*noise(pos))*wallColor+windowColor;}\n\nbool con(vec2 u,vec2 b,vec2 c\n){return any(lessThan(vec3(min(u.x,u.y),b),vec3(0,u)))||!(any(lessThan(min(abs(b-u),abs(u)),c)));}\n\nvec3 textureRoof(vec2 pos, vec2 maxPos,vec2 squarer\n){float wsize=0.025\n ;float randB=rand(squarer*2.0)\n ;vec3 wallColor=(0.3+1.4*fract(randB*100.))*vec3(.1)+(-0.7+1.4*fract(randB*1000.))*vec3(0.02,0.,0.)\n ;vec3 conturColor=wallColor*1.5/2.5\n ;vec2 contur=vec2(0.02)\n ;if ((maxPos.x-pos.x<contur.x)||(maxPos.y-pos.y<contur.y)||(pos.x<contur.x)||(pos.y<contur.y)\n )return (0.9+0.2*noise(pos))*conturColor\n ;float s=.06+.12*fract(randB*562526.2865)\n ;pos-=s;maxPos-=s*2.;if(con(pos,maxPos,contur))return(.9+.2*noise(pos))*conturColor\n ;pos-=s;maxPos-=s*2.;if(con(pos,maxPos,contur))return(.9+.2*noise(pos))*conturColor\n ;pos-=s;maxPos-=s*2.;if(con(pos,maxPos,contur))return(.9+.2*noise(pos))*conturColor\n ;return (.9+.2*noise(pos))*wallColor;}\n\n\nvoid carloop(inout vec3 c,vec2 u,vec3 car1,vec3 car2,vec2 s,vec3 e,float n,float t,float o\n){float carNumber=0.5\n ;float r=0.01\n ;for (float j=0.;j<10.; j++\n ){float i=.03+o+j*.094\n  ;vec2 a=vec2(fract(i+iTime/4.),e.x)\n  ;if(e.z>0.)a=a.yx;\n  ;if(fract(n*5./i)>carNumber)c+=car1*smoothstep(r,0.,length(u-a))\n  ;a=vec2(fract(i-iTime/4.),e.y)\n  ;if(e.z>0.)a=a.yx;\n  ;if(fract(n*10./i)>carNumber)c+=car2*smoothstep(r,0.,length(u-a))\n  ;if(c.x>0.) break;}}\n\nvec3 cars(vec2 squarer, vec2 u, float dist,float level\n){vec3 c=vec3(0)\n ;float carInten=3.5/sqrt(dist)\n ;float r=0.01\n ;if (dist>2.0)r*=sqrt(dist/2.0)\n ;vec3 car1=vec3(.5,.5,1)*carInten\n ;vec3 car2=vec3(1.,.1,.1)*carInten\n ;float carNumber=0.5\n ;float n=noise((level+1.)*squarer*1.24435824)\n ;float t=iTime/4.\n ;carloop(c,u,car1,car2,vec2(   5,  10),vec3(.025,.975,0),n, t,0.)\n ;carloop(c,u,car1,car2,vec2(  10,   5),vec3(.975,.025,1),n,-t,0.)\n ;carloop(c,u,car1,car2,vec2( 100,1000),vec3(.045,.955,0),n, t,.047)  \n ;carloop(c,u,car1,car2,vec2(1000, 100),vec3(.955,.045,1),n,-t,.047)\n ;return c;}\n\nvec3 textureGround(vec2 squarer, vec2 pos,vec2 a,vec2 b,float dist\n){vec3 color=(0.9+0.2*noise(pos))*vec3(0.1,0.15,0.1)\n ;float randB=rand(squarer*2.)\n ;vec3 wallColor=(.3+1.4*fract(randB*100.))*.1+(-.7+1.4*fract(randB*1000.))*vec3(.02,0,0)\n ;float fund=0.03\n ;float bl=0.01\n ;float f=smoothstep(a.x-fund-bl,a.x-fund,pos.x)\n ;f*=smoothstep(a.y-fund-bl,a.y-fund,pos.y)\n ;f*=smoothstep(b.y+fund+bl,b.y+fund,pos.y)\n ;f*=smoothstep(b.x+fund+bl,b.x+fund,pos.x)\n ;pos -= 0.0\n ;vec2 maxPos=vec2(1)\n ;vec2 contur=vec2(0.06,0.06)\n ;if((pos.x>0.&&pos.y>0.&&pos.x<maxPos.x&&pos.y<maxPos.y)&&((abs(maxPos.x-pos.x)<contur.x)||(abs(maxPos.y-pos.y)<contur.y)||(abs(pos.x)<contur.x)||(abs(pos.y)<contur.y)))\n            color= vec3(0.1,0.1,0.1)*(0.9+0.2*noise(pos))\n ;pos -= 0.06\n ;maxPos=vec2(.88)\n ;contur=vec2(.01)\n ;if ((pos.x>0.0&&pos.y>0.0&&pos.x<maxPos.x&&pos.y<maxPos.y)&&((abs(maxPos.x-pos.x)<contur.x)||(abs(maxPos.y-pos.y)<contur.y)||(abs(pos.x)<contur.x)||(abs(pos.y)<contur.y))) color=vec3(0)\n ;color=mix(color,(0.9+0.2*noise(pos))*wallColor*1.5/2.5,f)\n ;pos+=0.06    \n#ifdef CARS\n ;if (min(pos.x,pos.y)<0.07||max(pos.x,pos.y)>0.93) color+=cars(squarer,pos,dist,0.);\n#endif\n ;return color;}\n\nvec2 cs(float a){return vec2(cos(a),sin(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec2 pos=(fragCoord.xy*2.0 - iResolution.xy) / iResolution.y\n ;float t=-iTime\n ;float tt=-iTime-0.5\n ;vec3 camPos=vec3(5.0+12.0*sin(t*0.05),5.0+ 7.0*cos(t*0.05), 1.9)\n ;vec3 camTarget=vec3(5.0+0.0,5.0+7.0*sin(t*0.05), 0.0)\n ;if (fract(t/12.0)<0.25){camPos=vec3(5.*t,3.1*t,2.1);camTarget=vec3(5.*tt,3.1*tt,1.7);}\n ;if (fract(t/12.0)>0.75){camPos=vec3(35.,3.1,1.);camTarget=vec3(35.+sin(t/10.0),3.1+cos(t/10.0),0.7);}\n ;if(iMouse.z>0.)camTarget.xy=camPos.xy-cs(6.2*iMouse.x/iResolution.x)\n ;vec3 cd=normalize(camTarget-camPos)\n ;vec3 cs=cross(cd,normalize(vec3(0,0,-1)))\n  //FoV like its the 80s, makes sense here to debug the traverser\n ;vec3 d=normalize(cs*pos.x+cross(cd,cs)*pos.y+cd*(4.-8.*iMouse.y/iResolution.x))\n ;float angle=.03*pow(abs(acos(d.x)),4.0)\n ;//angle=min(0.0,angle)\n ;vec3 color=vec3(0.0)\n ;vec2 square=floor(camPos.xy)\n ;square.xy +=.5-.5*sign(d.xy)\n ;float mind=100.\n ;int k=0\n ;vec3 pol\n ;vec2 maxPos,crossG\n ;float tSky=-(camPos.z-3.9)/d.z\n ;vec2 crossSky=floor(camPos.xy + d.xy*tSky)\n ;for (int i=1; i<I_MAX; i++ //2d rectangle traverse loop\n ){vec2 squarer=square-vec2(0.5,0.5)+0.5*sign(d.xy)\n  ;if(crossSky==squarer&&crossSky!=floor(camPos.xy)\n  ){color+=vec3(vec2(.5,.15)*abs(angle)*exp(-d.z*d.z*30.),.2);break;}\n  ;float random=rand(squarer),t,height=0.\n  ;float quartalR=rand(floor(squarer/10.))\n  ;if (floor(squarer/10.)==vec2(0)) quartalR=.399\n  ;if (quartalR<.4\n  ){height=-.15+.4*random+smoothstep(12.,7.,length(fract(squarer/10.)*10.-vec2(5)))\n   *.8*random+.9*smoothstep(10.,0.,length(fract(squarer/10.)*10.-vec2(5)))\n   ;height*=quartalR/.4;}\n  ;float maxJ=2.\n  ;float roof=1.\n  ;if (height<0.3\n  ){height=0.3*(0.7+1.8*fract(random*100.543264));maxJ=2.0\n   ;if (fract(height*1000.)<0.04) height*=1.3;}\n  ;if (height>0.5)maxJ=3.\n  ;if (height>0.85)maxJ=4.\n  ;if (fract(height*100.)<0.15){height=pow(maxJ-1.0,0.3)*height; maxJ=2.0; roof=0.0;}\n  ;float maxheight=1.5*pow((maxJ-1.0),0.3)*height+roof*0.07\n  ;if (camPos.z+d.z*(length(camPos.xy - square) +0.71 - sign(d.z)*0.71)/length(d.xy)<maxheight\n  ){vec2 ar\n   ;vec2 br\n   ;float zz=0.\n   ;float prevZZ=0.\n   ;for(int nf=1;nf<8;nf++\n   ){float j=float(nf)\n    ;if(j>maxJ)break\n    ;prevZZ=zz\n    ;zz=1.5*pow(j,0.3)*height\n    ;//prevZZ=zz-0.8\n    ;float dia=1.0/pow(j,0.3)\n    ;if(j==maxJ\n    ){if (roof == 0.0)break\n     ;zz=1.5*pow((j-1.0),0.3)*height+0.03+0.04*fract(random*1535.347)\n     ;dia=1.0/pow((j-1.0),0.3)-0.2-0.2*fract(random*10000.);}\n    ;vec2 v1=vec2(0)//vec2(random*10.0,random*1.0);\n    ;vec2 v2=vec2(0)//vec2(random*1000.,random*100.);\n    ;float randomF=fract(random*10.0)\n    ;if(randomF<.25){ v1=vec2(fract(random*1000.),fract(random*100.));}\n   ;if(randomF>.25&&randomF<.5 ){v1=vec2(fract(random*100.),0.);v2=vec2(0.0,fract(random*1000.));}\n   ;if(randomF>.5 &&randomF<.75){v2=vec2(fract(random*1000.),fract(random*100.));}\n   ;if(randomF>.75             ){v1=vec2(0.,fract(random*1000.)); v2=vec2(fract(random*100.),0.);}\n   ;if(d.y<0.0){float y=v1.y;v1.y=v2.y;v2.y=y;}\n   ;if(d.x<0.0){float x=v1.x;v1.x=v2.x;v2.x=x;}\n   ;vec2 a=square+sign(d.xy)*(0.5-0.37*(dia*1.0-1.0*v1))\n   ;vec2 b=square+sign(d.xy)*(0.5+0.37*(dia*1.0-1.0*v2))\n   ;if (j==1.0\n   ){ar=vec2(min(a.x, b.x),min(a.y,b.y))\n    ;br=vec2(max(a.x, b.x),max(a.y,b.y));}\n   ;vec3 pxy=polygonXY(zz,a,b,camPos,d)\n   ;if (pxy.x<mind){mind=pxy.x; pol=pxy; k=1;maxPos=vec2(abs(a.x-b.x),abs(a.y-b.y));}\n   ;vec3 pyz=polygonYZ(a.x,vec2(a.y,prevZZ),vec2(b.y,zz),camPos,d)\n   ;if (pyz.x<mind){mind=pyz.x; pol=pyz; k=2;maxPos=vec2(abs(a.y-b.y),zz-prevZZ);}\n   ;vec3 pxz=polygonXZ(a.y,vec2(a.x,prevZZ),vec2(b.x,zz),camPos,d)\n   ;if (pxz.x<mind){mind=pxz.x; pol=pxz; k=3;maxPos=vec2(abs(a.x-b.x),zz-prevZZ);}}\n   ;if ((mind<100.)&&(k==1)\n   ){color += textureRoof(vec2(pol.y,pol.z),maxPos,squarer);if (mind>3.){color*=sqrt(3./mind);};break;}\n   ;if ((mind<100.)&&(k==2)\n   ){color += textureWall(vec2(pol.y,pol.z),maxPos,squarer,1.2075624928,height,mind,d,vec3(1,0,0))\n    ;if (mind>3.0)color*=sqrt(3.0/mind);break;} \n   ;if ((mind<100.)&&(k==3)\n   ){color += textureWall(vec2(pol.y,pol.z),maxPos,squarer,.8093856205,height,mind,d,vec3(0,1,0))\n    ;if (mind>3.0)color*=sqrt(3.0/mind);break;}\n   ;t=-camPos.z/d.z\n   ;crossG=camPos.xy + d.xy*t\n   ;if (floor(crossG) == squarer\n   ){mind=length(vec3(crossG,0.0)-camPos)\n    ;color += textureGround(squarer,fract(crossG),fract(ar),fract(br),mind)\n    ;if (mind>3.0)color*=sqrt(3.0/mind);break;}} \n  ;if ((square.x+sign(d.x)-camPos.x)/d.x<(square.y+sign(d.y)-camPos.y)/d.y\n  ){square.x += sign(d.x)*1.0;}else square.y += sign(d.y)*1.\n  ;if(i==I_MAX-1&&d.z>-0.1)color += vec3(vec2(0.5,0.15)*abs(angle)*exp(-d.z*d.z*30.0),0.2);}\n ;fragColor=vec4(color,1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[430, 469, 494, 494, 522], [543, 603, 642, 642, 681], [681, 703, 742, 742, 783], [784, 784, 823, 823, 864], [865, 865, 904, 904, 945], [1047, 1100, 1136, 1136, 1175], [1175, 1199, 1235, 1235, 1276], [1277, 1277, 1313, 1313, 1354], [1355, 1355, 1391, 1391, 1432], [1537, 1749, 1769, 1769, 1826], [1828, 1828, 1848, 1848, 1880], [1882, 1954, 1979, 1979, 2021], [2022, 2022, 2065, 2065, 2185], [2186, 2186, 2239, 2239, 2311], [2312, 2312, 2367, 2367, 2439], [2440, 2440, 2495, 2495, 2573], [2575, 2575, 2679, 2679, 5375], [5377, 5377, 5409, 5409, 5505], [5507, 5507, 5561, 5561, 6248], [6251, 6251, 6344, 6344, 6702], [6704, 6704, 6761, 6761, 7301], [7303, 7303, 7372, 7372, 8490], [8492, 8492, 8509, 8509, 8537], [8539, 8539, 8595, 8595, 13251]], "test": "valid"}
{"id": "tdjXWW", "name": "Me", "author": "daumkuchen", "description": "My icon.\nhttps://twitter.com/daumkuchen", "tags": ["2d"], "likes": 4, "viewed": 107, "published": "Public", "date": "1553852480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define TAU (PI*2.0)\n#define RATIO .125\n\nmat2 rot(float th) {\n    vec2 a = sin(vec2(1.570796, 0.) + th);\n    return mat2(a, -a.y, a.x);\n}\n\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n ) {\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdRect(vec2 p, vec2 t, vec2 b) {\n\tvec2 d = abs(p-t)-b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdBody(vec2 p) {\n    return sdCircle(p, 1. - RATIO * 2.);\n}\n\nfloat sdEye1(vec2 p) {\n    return sdCircle(p , 1. - RATIO * 4.);\n}\n\nfloat sdEye2(vec2 p) {\n    return sdCircle(p , 1. - RATIO * 6.);\n}\n\nfloat sdEyelid1(vec2 p) {\n    return sdCircle(vec2(p.x, p.y + floor(p.y)) , 1. - RATIO * 4.);\n}\n\nfloat sdEyelid2(vec2 p) {\n    return sdRect(\n        vec2(p.x, p.y),\n        vec2(0., RATIO),\n    \tvec2(.55, RATIO)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 p ) {\n    \n    p = (p.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    p *= rot(iTime * .8);\n    \n    vec3 col;\n    vec3 colBlack = vec3(0., 0., 0.);\n    vec3 colWhite = vec3(1., 1., 1.);\n    vec3 colYellow = vec3(.9411, .8627, .1568);\n    \n    float ss = 3. / min(iResolution.x, iResolution.y);\n    \n    col = colYellow;\n    col = mix(col, colBlack, smoothstep(ss, 0., sdBody(p)));\n    col = mix(col, colWhite, smoothstep(ss, 0., sdEye1(p)));\n    col = mix(col, colBlack, smoothstep(ss, 0., sdEye2(p)));\n    col = mix(col, colYellow, smoothstep(ss, 0., sdEyelid1(p)));\n    col = mix(col, colBlack, smoothstep(ss, 0., sdEyelid2(p)));\n\n    fragColor = vec4(col,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 81, 81, 157], [159, 159, 194, 194, 222], [224, 224, 257, 257, 291], [293, 293, 331, 331, 411], [413, 413, 435, 435, 478], [480, 480, 502, 502, 546], [548, 548, 570, 570, 614], [616, 616, 641, 641, 711], [713, 713, 738, 738, 837], [839, 839, 888, 888, 1577]], "test": "valid"}
{"id": "tdlSWj", "name": "ellipso-disco (113 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "1tweet", "golf", "hardwarederivatives"], "likes": 5, "viewed": 298, "published": "Public API", "date": "1552244836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define C cos( vec4(23,21,0,1) -iTime +.1*length(iResolution.xy*//\nvoid mainImage(out vec4 O, vec2 U) {\n    O  =  C.7-U)) + C.3-U)); O /= fwidth(O); }    /*                        /*\n\n\n\n\n\n/* // --- 118 chars\n\n#define C(v) cos( length(v*iResolution.xy)/9.  \\\n                  + vec4(23,21,0,1)-iTime)     //\n#define mainImage(O,U)                         \\\n    O  =  C(U-.7) + C(U-.3) ;                  \\\n    O /= fwidth(O)                             /*                 \n\n\n\n\n\n/* // --- 132 chars\n\n#define mainImage(O,U)                         \\\n    vec2 R = iResolution.xy;                   \\\n    O = vec4(23,21,0,1);                       \\\n    O =       cos(length(U-.7*R)/9. + O-iTime) \\\n            + cos(length(U-.3*R)/9. + O) ;     \\\n    O /= fwidth(O)\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 103, 103, 150]], "test": "valid"}
{"id": "tdlSz2", "name": "Shader10 - Unusual shape & color", "author": "EmperorLem", "description": "An unusual shape in with unusual colors", "tags": ["color"], "likes": 1, "viewed": 60, "published": "Public", "date": "1551718826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 background = vec3(0.1,0.1,1.0);\nvec3 orange = vec3(1.0,0.0,0.0);\n\nfloat createCircle(vec2 uv)\n{\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float dist = length(uv);\n    float ratio = 0.3;\n    float rate = clamp(sin(20.0 * ratio * iTime)*ratio , 0.25, 0.3);\n        \n    float angle = (atan(uv.y, uv.x) + iTime * 3.0);\n        \n    float value = smoothstep( rate,ratio = 0.2 ,dist);\n    \n    float radius = 0.0;\n    radius = smoothstep(-1.0, 20.0, cos(angle * 3.0)) * 10.0 + 0.15;\n    \n    value = 1.0 - step(radius, dist) + clamp(sin(20.0 * radius * iTime) , 0.25, 0.30);\n    \n    return value * radius * 5.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    background *= sin(iTime * 1.0) * 5.0 + 1.0 /0.5;\n    \n    vec3 mixed = mix(background, orange, vec3(createCircle(uv)));\n    \n    // Output to screen\n    fragColor = vec4(mixed,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlSz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 100, 100, 637], [639, 639, 696, 746, 979]], "test": "valid"}
{"id": "tdlXDM", "name": "Underwater Sun Rays", "author": "greenbird10", "description": "My one-week artwork! An underwater scene.", "tags": ["waves", "light", "underwater", "bubbles", "shafts"], "likes": 59, "viewed": 1896, "published": "Public", "date": "1551457516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Yilin Yan aka greenbird10\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nfloat hash(vec2 p) {\n\treturn 0.5*(\n    sin(dot(p, vec2(271.319, 413.975)) + 1217.13*p.x*p.y)\n    ) + 0.5;\n}\n\nfloat noise(vec2 p) {\n  vec2 w = fract(p);\n  w = w * w * (3.0 - 2.0*w);\n  p = floor(p);\n  return mix(\n    mix(hash(p+vec2(0,0)), hash(p+vec2(1,0)), w.x),\n    mix(hash(p+vec2(0,1)), hash(p+vec2(1,1)), w.x), w.y);\n}\n\n// wave octave inspiration\n// Alexander Alekseev - Seascape\n// https://www.shadertoy.com/view/Ms2SD1\nfloat map_octave(vec2 uv) {\n  uv = (uv + noise(uv)) / 2.5;\n  uv = vec2(uv.x*0.6-uv.y*0.8, uv.x*0.8+uv.y*0.6);\n  vec2 uvsin = 1.0 - abs(sin(uv));\n  vec2 uvcos = abs(cos(uv));\n  uv = mix(uvsin, uvcos, uvsin);\n  float val = 1.0 - pow(uv.x * uv.y, 0.65);\n  return val;\n}\n\nfloat map(vec3 p) {\n  vec2 uv = p.xz + iTime/2.;\n  float amp = 0.6, freq = 2.0, val = 0.0;\n  for(int i = 0; i < 3; ++i) {\n    val += map_octave(uv) * amp;\n    amp *= 0.3;\n    uv *= freq;\n    // uv = vec2(uv.x*0.6-uv.y*0.8, uv.x*0.8+uv.y*0.6);\n  }\n  uv = p.xz - 1000. - iTime/2.;\n  amp = 0.6, freq = 2.0;\n  for(int i = 0; i < 3; ++i) {\n    val += map_octave(uv) * amp;\n    amp *= 0.3;\n    uv *= freq;\n    // uv = vec2(uv.x*0.6-uv.y*0.8, uv.x*0.8+uv.y*0.6);\n  }\n  return val + 3.0 - p.y;\n}\n\nvec3 getNormal(vec3 p) {\n  float eps = 1./iResolution.x;\n  vec3 px = p + vec3(eps, 0, 0);\n  vec3 pz = p + vec3(0, 0, eps);\n  return normalize(vec3(map(px),eps,map(pz)));\n}\n\n// raymarch inspiration\n// Alexander Alekseev - Seascape\n// https://www.shadertoy.com/view/Ms2SD1\nfloat raymarch(vec3 ro, vec3 rd, out vec3 outP, out float outT) {\n    float l = 0., r = 26.;\n    int i = 0, steps = 16;\n    float dist = 1000000.;\n    for(i = 0; i < steps; ++i) {\n        float mid = (r+l)/2.;\n        float mapmid = map(ro + rd*mid);\n        dist = min(dist, abs(mapmid));\n        if(mapmid > 0.) {\n        \tl = mid;\n        }\n        else {\n        \tr = mid;\n        }\n        if(r - l < 1./iResolution.x) break;\n    }\n    outP = ro + rd*l;\n    outT = l;\n    return dist;\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\ttotal += noise(n) * amplitude; \n\t\tn += n;\n\t\tamplitude *= 0.4; \n\t}\n\treturn total;\n}\n\nfloat lightShafts(vec2 st) {\n    float angle = -0.2;\n    vec2 _st = st;\n    float t = iTime / 16.;\n    st = vec2(st.x * cos(angle) - st.y * sin(angle), \n              st.x * sin(angle) + st.y * cos(angle));\n    float val = fbm(vec2(st.x*2. + 200. + t, st.y/4.));\n    val += fbm(vec2(st.x*2. + 200. - t, st.y/4.));\n    val = val / 3.;\n    float mask = pow(clamp(1.0 - abs(_st.y-0.15), 0., 1.)*0.49 + 0.5, 2.0);\n    mask *= clamp(1.0 - abs(_st.x+0.2), 0., 1.) * 0.49 + 0.5;\n\treturn pow(val*mask, 2.0);\n}\n\nvec2 bubble(vec2 uv, float scale) {\n    if(uv.y > 0.2) return vec2(0.);\n    float t = iTime/4.;\n    vec2 st = uv * scale;\n    vec2 _st = floor(st);\n    vec2 bias = vec2(0., 4. * sin(_st.x*128. + t));\n    float mask = smoothstep(0.1, 0.2, -cos(_st.x*128. + t));\n    st += bias;\n    vec2 _st_ = floor(st);\n    st = fract(st);\n    float size = noise(_st_)*0.07+0.01;\n    vec2 pos = vec2(noise(vec2(t, _st_.y*64.1)) * 0.8 + 0.1, 0.5);\n    if(length(st.xy - pos) < size) {\n        return (st + pos) * vec2(.1, .2) * mask;\n    }\n    return vec2(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0.,0.,2.);\n    vec3 lightPos = vec3(8, 3, -3);\n    vec3 lightDir = normalize(lightPos - ro);\n\n    // adjust uv\n    vec2 uv = fragCoord;\n    uv = (-iResolution.xy + 2.0*uv) / iResolution.y;\n    uv.y *= 0.5;\n    uv.x *= 0.45;\n    uv += bubble(uv, 12.) + bubble(uv, 24.); // add bubbles\n\n    vec3 rd = normalize(vec3(uv, -1.));\n    vec3 hitPos;\n    float hitT;\n    vec3 seaColor = vec3(11,82,142)/255.;\n    vec3 color;\n    \n    // waves\n    float dist = raymarch(ro, rd, hitPos, hitT);\n    float diffuse = dot(getNormal(hitPos), rd) * 0.5 + 0.5;\n    color = mix(seaColor, vec3(15,120,152)/255., diffuse);\n    color += pow(diffuse, 12.0);\n\t// refraction\n    vec3 ref = normalize(refract(hitPos-lightPos, getNormal(hitPos), 0.05));\n    float refraction = clamp(dot(ref, rd), 0., 1.0);\n    color += vec3(245,250,220)/255. * 0.6 * pow(refraction, 1.5);\n\n    vec3 col = vec3(0.);\n    col = mix(color, seaColor, pow(clamp(0., 1., dist), 0.2)); // glow edge\n    col += vec3(225,230,200)/255. * lightShafts(uv); // light shafts\n\n    // tone map\n    col = (col*col + sin(col))/vec3(1.8, 1.8, 1.9);\n    \n    // vignette\n    // inigo quilez - Stop Motion Fox \n    // https://www.shadertoy.com/view/3dXGWB\n    vec2 q = fragCoord / iResolution.xy;\n    col *= 0.7+0.3*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlXDM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[0, 110, 130, 130, 217], [219, 219, 240, 240, 432], [434, 535, 562, 562, 801], [803, 803, 822, 822, 1290], [1292, 1292, 1316, 1316, 1463], [1465, 1563, 1628, 1628, 2054], [2056, 2056, 2075, 2075, 2228], [2230, 2230, 2258, 2258, 2731], [2733, 2733, 2768, 2768, 3278], [3280, 3280, 3335, 3335, 4682]], "test": "valid"}
{"id": "tdsSDj", "name": "MG", "author": "AlexRom", "description": "mg", "tags": ["mg"], "likes": 1, "viewed": 44, "published": "Public", "date": "1552250643", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define AA 2\n\n#define PI 3.14159265359\n\nconst int MAX_MARCHING_STEPS = 655;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nstruct DistanceField\n{\n    float distance;\n    int id;\n};\n\nstruct Material\n{\n    vec3 ambient;\n    vec3 specular;\n    vec3 diffuse;\n    float m;\n};\n    \nvec3 fresnel(vec3 f0, vec3 l, vec3 h)\n{\n    return f0 + (1.0 - f0) * pow(1.0 - max(0.0, dot(l, h)), 5.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nDistanceField opSmoothSubtraction( DistanceField Dist1, DistanceField Dist2, float k ) {\n    float d1 = Dist1.distance;\n    float d2 = Dist2.distance;\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    Dist1.distance = mix( d2, -d1, h ) + k*h*(1.0-h);\n    \n    return Dist1; \n}\n\nDistanceField df_union(DistanceField d1, DistanceField d2)\n{\n    if (d1.distance <= d2.distance)\n        return d1;\n    else\n        return d2;\n}\n\nDistanceField df_intersect(DistanceField d1, DistanceField d2)\n{\n    if (d1.distance <= d2.distance)\n        return d2;\n    else\n        return d1;\n}\n\nDistanceField df_difference(DistanceField d1, DistanceField d2)\n{\n    if (d1.distance <= -d2.distance)\n        return d1;\n    else\n        return d2;\n}\n\n\n#define SCENE_WHITE 1\n#define SCENE_PURPLE 2\n#define SCENE_GOLD 3\n#define SCENE_FLOOR 4\n#define SCENE_CRIMSON 5\n#define SCENE_LIME 6\n#define SCENE_BLUE 7\n#define SCENE_AQUA 8\n#define DEFAULT 10\n\nvoid df_material(vec3 pos, int id, inout Material mtl)\n{\n    if (id == SCENE_WHITE)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(1.0, 1.0, 1.0) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_PURPLE)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(0.4, 0.3, 0.5) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_CRIMSON)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(0.1, 0.2, 0.6) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_LIME)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(0.2, 1.0, 0.0) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_BLUE)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(0.0, 0.0, 0.9) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_AQUA)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(0.9, 0.44, 0.44) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_GOLD)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.85, 0.782, 0.344);\n        mtl.diffuse = vec3(0.0, 0.0, 0.0);\n        mtl.m = 8.0;\n    }\n    \n    else if (id == SCENE_FLOOR)\n    {\n        float checker_size = 0.5;\n        float alpha = floor(pos.x / checker_size) + floor(pos.z / checker_size);\n        alpha = abs(alpha);\n        alpha -= 2.0 * floor(alpha / 2.0);\n\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        /* mtl.diffuse = mix(vec3(0.95, 0.95, 0.95), vec3(0.25, 0.25, 0.25), alpha); */\n        mtl.diffuse = mix(vec3(0.25, 0.25, 0.95), vec3(0.95, 0.95, 0.25), alpha);\n        mtl.m = 128.0;\n    }\n    else\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(1.0, 0.0, 1.0) - mtl.specular;\n        mtl.m = 128.0;\n    }\n}\n\n\nDistanceField sceneSDF(vec3 samplePoint) {\n    float sphereDist1 = sdSphere(samplePoint + vec3(0.0,2.0,8.0),1.3);\n    float cubeDist2 = cubeSDF(samplePoint + vec3(0.0,2.0,8.0));\n    \n    float sphereDist2 = sdSphere(samplePoint + vec3(2.0,3.0,2.0),1.0);\n\n    \n    float cubeDist = cubeSDF(samplePoint + vec3(-4.0,2.0,2.0));\n    float planeDist = sdPlane(samplePoint + vec3(0.0,5.0,0.0),vec4(0.0,1.0,0.0,0.5));\n    float prismDist = sdTriPrism(samplePoint + vec3(9.0,4.0,7.0), vec2(1.0,2.0));\n    \n    float torusDist = sdTorus(samplePoint + vec3(-6.0,1.0, 7.0),vec2(2.20,0.55));\n    \n    float sphereDist3 = sdSphere(samplePoint + vec3(8.0,2.0,0.0),1.0);\n    float boxDist = sdBox(samplePoint + vec3(8.0,2.0,0.0),vec3(1.0,2.0,1.0));\n    \n    DistanceField sphereD3 = DistanceField(sphereDist3, SCENE_LIME);\n    DistanceField boxD = DistanceField(boxDist, SCENE_LIME);\n    \n    DistanceField torusD = DistanceField(torusDist, SCENE_PURPLE);\n    \n    DistanceField sphereD1 = DistanceField(sphereDist1, SCENE_CRIMSON);\n    DistanceField cubeD2 = DistanceField(cubeDist2, SCENE_CRIMSON);\n    \n    \n    DistanceField sphereD2 = DistanceField(sphereDist2, SCENE_GOLD);\n    \n    \n    DistanceField cubeD = DistanceField(cubeDist, SCENE_BLUE);\n    DistanceField planeD = DistanceField(planeDist, SCENE_FLOOR);\n    DistanceField prismD = DistanceField(prismDist, SCENE_AQUA);\n       \n    return df_union(opSmoothSubtraction(sphereD3,boxD,0.55),df_union(torusD,df_union(df_union(df_union(df_union(df_intersect(sphereD1,cubeD2),sphereD2),cubeD),planeD),prismD)));\n}\n\n\nDistanceField shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, DistanceField end) {\n    DistanceField depth = DistanceField(0.0,DEFAULT);\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        DistanceField dist = sceneSDF(eye + depth.distance * marchingDirection);\n        if (dist.distance < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth.distance += dist.distance;\n        depth.id = dist.id;\n        if (depth.distance >= end.distance) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).distance - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).distance,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).distance - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).distance,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).distance - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).distance\n    ));\n}\n\n\n\nfloat raymarch_shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t < maxt; )\n    {\n        float h = sceneSDF(ro + rd*t).distance;\n        if( h<0.001 )\n            return 0.15;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float c = 1.0;\n    float b = 0.00002;\n    float fogAmount = 1.0 - exp( -pow(distance,3.0) * b );\n    vec3  fogColor  = vec3(0.8,0.9,1.0);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n    float step = 8.;\n    float ao = 0.;\n    float dist;\n    for (int i = 1; i <= 3; i++) {\n        dist = step * float(i);\n\t\tao += max(0., (dist - sceneSDF(p + n * dist).distance) / dist);  \n    }\n    return 1. - ao * 0.1;\n}\n\nvec3 render(int id, float alpha, vec3 p, vec3 eye) {\n    \n    Material mtl;\n    df_material(p, id, mtl);\n    \n    vec3 k_a = mtl.ambient;\n    vec3 k_d = mtl.diffuse;\n    vec3 k_s = mtl.specular;\n    \n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    vec3 light_pos = 2.0 * vec3(cos( PI * iTime / 4.0), 1.0, sin( PI * iTime / 4.0));\n    vec3 camera_pos = eye;\n    vec3 pos = p;\n    vec3 normal = estimateNormal(p);\n    \n    vec3 l = normalize(light_pos - pos);\n    vec3 v = normalize(camera_pos - pos);\n    vec3 h = normalize(v + l);\n    float n_l = max(0.0, dot(normal, l));\n    float n_h = max(0.0, dot(normal, h));\n\n    float shadow = raymarch_shadow(light_pos, -l, 0.0, 0.9 * distance(light_pos, pos), 32.0);\n\n    // Lambertian BRDF diffuse + Blinn-Phong BRDF specular\n    color += mtl.ambient;\n    \n    color += shadow * n_l * (mtl.diffuse + (mtl.m + 2.0) / 8.0 * pow(n_h, mtl.m) * fresnel(mtl.specular, l, h));\n    \n    vec3 light_pos2 =     4.0 * vec3(cos( PI * iTime / 2.0), 1.0, sin( PI * iTime / 2.0));\n    \n    \n    vec3 l2 = normalize(light_pos2 - pos);\n    vec3 h2 = normalize(v + l);\n    \n    float n_l2 = max(0.0, dot(normal, l2));\n    float n_h2 = max(0.0, dot(normal, h2));\n    \n    float shadow2 = raymarch_shadow(light_pos2, -l2, 0.0, 0.9 * distance(light_pos2, pos), 32.0);\n    \n    color += shadow2 * n_l2 * (mtl.diffuse + (mtl.m + 2.0) / 8.0 * pow(n_h2, mtl.m) * fresnel(mtl.specular, l2, h2));\n    \n    \n    float ao = ambientOcclusion(p, normal);\n\tcolor *= ao;\n    \n     \n    return color;\n}\n\n\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3( 8, 12, 8 );\n    \n    mat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n    eye = eye * rot;\n    \n    vec3 ta = vec3( -0.5, -0.5, 0.5 );\n    mat3 ca = setCamera( eye, ta, 0.0 );\n    \n    \n    DistanceField Max = DistanceField(MAX_DIST,DEFAULT);\n    \n    vec3 tot = vec3(0.0);\n\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n           \n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pix = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        \n        dir = ca * normalize( vec3(pix.xy,2.0) );\n        \n        DistanceField dist = shortestDistanceToSurface(eye, dir, MIN_DIST, Max);\n\n        if (dist.distance > MAX_DIST - EPSILON) {\n            // Didn't hit anything\n            fragColor = vec4(0.0, 1.0, 1.0, 0.0);\n            return;\n        }\n\n        vec3 p = eye + dist.distance * dir;\n\n        float shininess = 10.0;\n\n        vec3 color = render(dist.id, shininess, p, eye);\n        \n        color = applyFog(color,dist.distance,eye,dir);\n        \n        tot += color;\n        \n    }\n    tot /= float(AA*AA);\n    \n    \n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 358, 358, 426], [428, 428, 463, 463, 487], [490, 490, 523, 523, 578], [581, 581, 614, 640, 671], [673, 673, 704, 704, 854], [856, 856, 879, 1030, 1467], [1469, 1469, 1505, 1505, 1592], [1594, 1594, 1682, 1682, 1878], [1880, 1880, 1940, 1940, 2025], [2027, 2027, 2091, 2091, 2176], [2178, 2178, 2243, 2243, 2329], [2527, 2527, 2583, 2583, 4863], [4866, 4866, 4908, 4908, 6421], [6424, 6424, 6531, 6531, 6956], [6971, 6971, 7036, 7036, 7168], [7170, 7170, 7199, 7199, 7563], [7567, 7567, 7649, 7649, 7992], [7995, 7995, 8236, 8236, 8424], [8426, 8426, 8466, 8466, 8691], [8693, 8693, 8745, 8745, 10261], [10265, 10265, 10296, 10296, 10452], [10454, 10454, 10506, 10506, 10683], [10686, 10686, 10743, 10743, 12022]], "test": "valid"}
{"id": "tdsSR2", "name": "pogi", "author": "jojo169", "description": "pogi", "tags": ["pogi"], "likes": 0, "viewed": 41, "published": "Public", "date": "1551716251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) \n{\n\tfloat d = length((pos) - uv) - rad;\n\tfloat t = clamp(d, 0.0, 2.0);\n    \n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n    \n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n    \n\n    // Background layer\n\t\n\t// Circle\n\tvec3 orange = vec3(1.0, 0.5, 0.3);\n\tvec4 circle = circle(uv, center , tan(iTime)*radius, orange);\n\t\n     uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 col = 0.5 + 0.5*sin(iTime+uv.xyxx+vec4(0,2,4,0));\n\n\t// Blend the two\n\tfragColor = mix(col, circle, circle.a);\n\n}\n\n//https://www.youtube.com/watch?v=GgGBR4z8C9o\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsSR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 161], [163, 163, 220, 220, 638]], "test": "valid"}
{"id": "tdSSWD", "name": "trippy voronoi", "author": "nexor", "description": "voronoi", "tags": ["voronoi"], "likes": 3, "viewed": 143, "published": "Public", "date": "1553785220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 ones = vec4(1.0);\n\nfloat sum(vec4 a)\n{\n\treturn dot(a,ones);   \n}\nfloat sum(vec3 a)\n{\t\n    return dot(a,ones.xxx);\n}\nfloat sum(vec2 a)\n{\n    return dot(a,ones.xx);\n}\n\nint floor_to_int(float x)\n{\n    return int(floor(x));\n}\n\nint quick_floor(float x)\n{\n    return int(x) - 1 + int(step(0.,x));\n}\n\nfloat integer_noise(int n)\n{\n    int nn;\n    n = (n + 1013) & 0x7fffffff;\n    n = (n >> 13) ^ n;\n    nn = (n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;\n    return 0.5 * (float(nn) / 1073741824.0);\n}\n\nuint hash(uint kx, uint ky, uint kz)\n{\n#define rot(x, k) (((x) << (k)) | ((x) >> (32 - (k))))\n#define final(a, b, c) \\\n{ \\\n    c ^= b; c -= rot(b, 14); \\\n    a ^= c; a -= rot(c, 11); \\\n    b ^= a; b -= rot(a, 25); \\\n    c ^= b; c -= rot(b, 16); \\\n    a ^= c; a -= rot(c, 4);  \\\n    b ^= a; b -= rot(a, 14); \\\n    c ^= b; c -= rot(b, 24); \\\n}\n    // now hash the data!\n    uint a, b, c, len = 3u;\n    a = b = c = 0xdeadbeefu + (len << 2u) + 13u;\n\n    c += kz;\n    b += ky;\n    a += kx;\n    final (a, b, c);\n\n    return c;\n#undef rot\n#undef final\n}\n\nuint hash(int kx, int ky, int kz)\n{\n    return hash(uint(kx), uint(ky), uint(kz));\n}\n\nfloat bits_to_01(uint bits)\n{\n    return (float(bits) / 4294967295.0);\n}\n\nfloat cellnoise(vec3 p)\n{\n    int ix = quick_floor(p.x);\n    int iy = quick_floor(p.y);\n    int iz = quick_floor(p.z);\n\n    return bits_to_01(hash(ix,iy,iz));\n}\n\nvec3 cellnoise_color(vec3 p)\n{\n    float r = cellnoise(p.xyz);\n    float g = cellnoise(p.yxz);\n    float b = cellnoise(p.yzx);\n\n    return vec3(r, g, b);\n}\n\nvoid node_tex_voronoi(vec3 co, float scale, float exponent, float coloring, float metric, float feature, out vec4 color, out float fac)\n{\n    vec3 p = co * scale;\n    int xx, yy, zz, xi, yi, zi;\n    float da[4];\n    vec3 pa[4];\n\n    xi = floor_to_int(p[0]);\n    yi = floor_to_int(p[1]);\n    zi = floor_to_int(p[2]);\n\n    da[0] = 1e+10;\n    da[1] = 1e+10;\n    da[2] = 1e+10;\n    da[3] = 1e+10;\n\n    for (xx = xi - 2; xx <= xi + 2; xx++) {\n        for (yy = yi - 2; yy <= yi + 2; yy++) {\n            for (zz = zi - 2; zz <= zi + 2; zz++) {\n                vec3 ip = vec3(xx, yy, zz);\n                vec3 vp = cellnoise_color(ip);\n                vec3 pd = p - (vp + ip);\n\n                float d = 0.0;\n                if (metric == 0.0) { /* SHD_VORONOI_DISTANCE 0 */\n                    d = dot(pd, pd);\n                }\n                else if (metric == 1.0) { /* SHD_VORONOI_MANHATTAN 1 */\n                    d = sum(abs(pd));\n                }\n                else if (metric == 2.0) { /* SHD_VORONOI_CHEBYCHEV 2 */\n                    d = max(abs(pd[0]), max(abs(pd[1]), abs(pd[2])));\n                }\n                else if (metric == 3.0) { /* SHD_VORONOI_MINKOWSKI 3 */\n                    d = pow(sum(pow(abs(pd), vec3(exponent))), 1.0/exponent);\n                }\n\n                vp += ip;\n                if (d < da[0]) {\n                    da[3] = da[2];\n                    da[2] = da[1];\n                    da[1] = da[0];\n                    da[0] = d;\n                    pa[3] = pa[2];\n                    pa[2] = pa[1];\n                    pa[1] = pa[0];\n                    pa[0] = vp;\n                }\n                else if (d < da[1]) {\n                    da[3] = da[2];\n                    da[2] = da[1];\n                    da[1] = d;\n\n                    pa[3] = pa[2];\n                    pa[2] = pa[1];\n                    pa[1] = vp;\n                }\n                else if (d < da[2]) {\n                    da[3] = da[2];\n                    da[2] = d;\n\n                    pa[3] = pa[2];\n                    pa[2] = vp;\n                }\n                else if (d < da[3]) {\n                    da[3] = d;\n                    pa[3] = vp;\n                }\n            }\n        }\n    }\n    /* Color output */\n    vec3 col = vec3(fac, fac, fac);\n    if (feature == 0.0) { /* F1 */\n        col = pa[0];\n        fac = abs(da[0]);\n    }\n    else if (feature == 1.0) { /* F2 */\n        col = pa[1];\n        fac = abs(da[1]);\n    }\n    else if (feature == 2.0) { /* F3 */\n        col = pa[2];\n        fac = abs(da[2]);\n    }\n    else if (feature == 3.0) { /* F4 */\n        col = pa[3];\n        fac = abs(da[3]);\n    }\n    else if (feature == 4.0) { /* F2F1 */\n        col = abs(pa[1] - pa[0]);\n        fac = abs(da[1] - da[0]);\n    }\n\n    if (coloring == 0.0) {\n        color = vec4(fac, fac, fac, 1.0);\n    }\n    else {\n        color = vec4(cellnoise_color(col), 1.0);\n    }\n}\n\nconst float scale = 0.005;\nconst float exponent = 0.5;\nconst float coloring = 1.;\nconst float metric = 0.;\nconst float feature = 1.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p = vec3(fragCoord.xy,iTime*50.);\n    vec4 color;\n    float fac;\n    node_tex_voronoi(p,  scale,  exponent,  coloring,  metric,  feature, color, fac);\n    fragColor = color * (1.-sin(fac*150.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 69], [70, 70, 89, 89, 120], [121, 121, 140, 140, 169], [171, 171, 198, 198, 226], [228, 228, 254, 254, 297], [299, 299, 327, 327, 511], [513, 513, 551, 551, 1059], [1061, 1061, 1096, 1096, 1145], [1147, 1147, 1176, 1176, 1219], [1221, 1221, 1246, 1246, 1381], [1383, 1383, 1413, 1413, 1538], [1540, 1540, 1677, 1677, 4454], [4591, 4591, 4648, 4648, 4854]], "test": "valid"}
{"id": "tdsSWf", "name": "Painter 3", "author": "fabiovergani", "description": "generative by mouse x", "tags": ["mouse", "paintergenerative"], "likes": 5, "viewed": 159, "published": "Public", "date": "1552428579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 v;\n//frag Color,Coord\nvoid mainImage(out vec4 a,in vec2 b){\n\n\tvec2 u=(b.xy/iResolution.y);\n\n\tvec3 p=vec3(u,2.+length(u)-1.*sin(u.x)),\n\to=p.xzy,\n\tc,\n\tq=vec3(-2.3,1.19,-3.4)+.601*vec3(.3,.98,.034);\n\n\tfloat T=iTime*.01,\n\tS=sin(T),\n\tm=v.z+=iMouse.x*.01,\n\tC=cos(T-m*S),\n\tx=o.x,\n\tz=o.z;\n\n\to.xz=vec2(S*x-C*z,C*x+S*z);\n\n\tz=0.;\n\tfor(int i=0;i<33;++i){\n\t\tp=q+z*o;\n\t\tfor(int i=0;i<33;++i){\n\t\t\tx=dot(p,p);\n\t\t\tv+=vec4(p=abs(p)/x,x);\n\t\t\tp-=vec3(.5,.4,1.5);\n\t\t};\n\t\tv/=32.;\n\t\tz+=max(\n\t\t\t.001*m*S,\n\t\t\tmin(.01/m,x=1.-abs(1.-x))\n\t\t)*(\n\t\t\t.3+3.*z\n\t\t);\n\t\tc+=(\n\t\t\t.5+.5*sin(v.xyz*30.)\n\t\t)/(\n\t\t\t1.+x*x*1E3\n\t\t);\n\t};\n\n\ta=vec4(\n\t\tpow(\n\t\t\tc/5.,\n\t\t\tvec3(.7)\n\t\t),\n\t\t1.\n\t);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[8, 27, 64, 64, 650]], "test": "valid"}
{"id": "tdsSWj", "name": "Task_1", "author": "kinzyabaev_i", "description": "mash_graph", "tags": ["mg"], "likes": 1, "viewed": 47, "published": "Public", "date": "1552246114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//константы максимального числа шагов в ray_march, расстояние до гранифы области, константы для света\n#define STEP 100\n#define SURF 0.01\n#define DIST 60.\n\n/////////////////////////Функции для вращения глаза по кругу//////////////////////////////////\nmat2 Rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n/////////////////////////////////////Примитивы///////////////////////////////////////////////////\nfloat sdSphere(vec3 p) {\n    vec4 Spherechr = vec4(0, 1, 6, 1);\n\treturn length(p - Spherechr.xyz) - Spherechr.w;\n}\n\nfloat displacement(vec3 p) {\n    return (exp(- (p.x*p.y*p.z + 8.) * 6.) );\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = sdTorus(p, vec2(1.0, 0.5));\n    float d2 = displacement(p);\n    return d1+d2;\n}\n\n\nfloat udBox( vec3 p)\n{\n    vec3 b = vec3(1., 1., 1.);\n    vec3 boxPos = vec3(4, 1, 6);\n  \treturn length(max(abs(p - boxPos)-b,0.0));\n}\n\nfloat dBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n/////////////////////////////Функция дистанции////////////////////////////////////////////////////\nvec2 obj_distance(vec3 p) {\n    float t = iTime;\n    \n\t//Плоскость\n    float planeDist = p.y;\n    \n    //Прыгающий тор\n    float y = -fract(t)*(fract(t)-1.);\t\t\n    vec3 tp = p;\n    tp -= vec3(-2, .8+3.*y, -4);\t\t\t\t\t\n    float squash = 1.+smoothstep(.15, .0, y)*.5;\n    tp.y *= squash;\n    tp = tp.xzy;\t\t\t\t\t\t\t\t\n    float scale = sdTorus(tp, vec2(1, .25))/squash;\n    \n\t//Квадрат, который превращается в кружок\n    float morph = mix(\n        length(p-vec3(4,1,2))-1., \n        dBox(p-vec3(4,1,2), vec3(1,1,1)), \n        sin(t)*.5+.5\n    );\n    \n\t//Примитивы попроще\n    float sphere = sdSphere(p);\n    float box = udBox(p);\n    float disp = opDisplace(p);\n    \n    float fklvavhrb = min(min(min(min(min(sphere, planeDist), box), scale), morph), disp);\n    \n    //возвращаем все объекты с флагами цветов\n    if (fklvavhrb == sphere) {\n        return vec2(1.0, sphere);\n    } else if (fklvavhrb == box) {\n        return vec2(2.0, box);\n    } else if (fklvavhrb == disp) {\n        return vec2(3.0, disp);\n\t} else if (fklvavhrb == scale) {\n        return vec2(4.0, scale);\n    } else if (fklvavhrb == morph) {\n        return vec2(5.0, morph);\n    } else {\n        return vec2(0.0, planeDist);\n    }\n}\n\n///////////////////////////////////Нормаль//////////////////////////////////////////////////////\nvec3 normal(vec3 p) {\n\tfloat d = obj_distance(p).y;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        obj_distance(p-e.xyy).y,\n        obj_distance(p-e.yxy).y,\n        obj_distance(p-e.yyx).y);\n    \n    return normalize(n);\n}\n\n/////////////////////////Сама функция RAY MARCHING///////////////////////////////////////////\nvec2 ray_march(vec3 eye, vec3 ray_dir) {\n\tfloat sum_dist = 0.;\n    vec2 dist1;\n    \n    for(int i = 0; i < STEP; ++i) {\n    \tvec3 p = eye + ray_dir * sum_dist;\n        dist1 = obj_distance(p);\n        float dist = dist1.y;\n        sum_dist += dist;\n        if (sum_dist > DIST) return vec2(dist1.x, sum_dist);\n        if (dist < SURF) return vec2(dist1.x, sum_dist);\n    }\n    \n    return vec2(dist1.x, sum_dist);\n}\n\n//////////////////////////////////Функция получения света////////////////////////////////////////////////////////////\nfloat Light(vec3 p) {\n    vec3 Light1 = vec3(0., 5., 3.);\n    vec3 l1 = normalize(Light1 - p);\n    vec3 n1 = normal(p);\n    \n    float dif_1 = clamp(dot(n1, l1), 0., 1.);\n    vec2 dist_1 = ray_march(p + n1 * SURF * 2., l1);\n    float d_1 = dist_1.y;\n    if(d_1<length(Light1 - p)) dif_1 *= .1;\n    \n    vec3 Light2 = vec3(0., 5., 3.);\n    Light2.xz += vec2(-sin(iTime)*6., -cos(iTime))*6.;\n    vec3 l2 = normalize(Light2-p);\n    vec3 n2 = normal(p);\n    \n    float dif_2 = clamp(dot(n2, l2), 0., 1.);\n    vec2 dist_2 = ray_march(p + n2 * SURF * 2., l2);\n    float d_2 = dist_2.y;\n    if(d_2<length(Light2-p)) dif_2 *= .1;\n    \n    dif_1 = dif_1 * 30. / ((length (Light1 - p) + 1.) * length (Light1 - p) );\n    dif_2 = dif_2 * 30. / ((length (Light2 - p) + 1.) * length (Light2 - p) );\n\n\n    return ((dif_2 + dif_1) / 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t//используем мышку для поворота экрана\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    \n    vec3 col = vec3(0);\n    //вращаем экрана\n    float t = iTime/20.;\n    vec3 ro = vec3(0, 3, -11.);\n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(iTime*.2-m.x*6.2831);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    rd = R(uv, ro, vec3(0,0,0), .7);\n    //получаем расстояние до ближайшего объекта\n    vec2 d = ray_march(ro, rd);\n    \n    vec3 p = ro + rd * d.y;\n    //получаем свет\n    float dif = Light(p);\n    //разукрашиваем все наши объекты по цветам\n    if (d.x == 1.0) {\n        col = vec3(dif, 0., 0.);\n    } else if (d.x == 2.0) {\n        col = vec3(0., dif, 0.);\n    } else if (d.x == 3.0) {\n        col = vec3(0., 0., dif);\n    } else if (d.x == 4.0) { \n        col = vec3(dif, dif, 0.);\n    } else if (d.x == 5.0) {\n        col = vec3(dif, 0., dif);\n    } else {\n        col = vec3(dif);\n    }\n    \n    //получаем результат\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 356, 375, 375, 451], [453, 453, 495, 495, 690], [692, 799, 823, 823, 913], [915, 915, 943, 943, 991], [993, 993, 1024, 1024, 1092], [1094, 1094, 1122, 1122, 1217], [1220, 1220, 1242, 1242, 1354], [1356, 1356, 1384, 1384, 1465], [1467, 1582, 1609, 1609, 2879], [2881, 2985, 3006, 3006, 3223], [3225, 3330, 3370, 3370, 3745], [3747, 3886, 3907, 3907, 4709], [4711, 4711, 4768, 4768, 5933]], "test": "valid"}
{"id": "tdsSzf", "name": "Carved out cube", "author": "MacSlow", "description": "The evening began with an attempt at doing a cave/tunnel and this came out... I guess I need to focus more next time. You can drag the ball around with the mouse (LMB pressed). It's a bit heavy due to the noise and small raymarch step-size.", "tags": ["3d", "noise", "sdf", "boolean", "pbr"], "likes": 5, "viewed": 580, "published": "Public API", "date": "1551810814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// It was meant to become a carved out tunnel. You can drag the ball around with\n// the mouse (LMB pressed). Technically it has a cave structure in the cube. It\n// is 'just' missing the corresponding camera-path to follow it ;)\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER    = 64;\nconst float STEP_SIZE = .6;\nconst float EPSILON   = .001;\nconst float PI = 3.14159265359;\n\nmat2 r2d (in float a)\n{\n    float c = cos(a);\n    float s = sin (a);\n    return mat2 (vec2 (c, s), vec2 (-s, c));\n}\n\nstruct Result {\n\tfloat d;\n\tint id;\n};\n\nfloat sdSphere (in vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat sdBox (in vec3 p, in vec3 size, in float r)\n{\n  vec3 d = abs(p) - size;\n  return min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;\n}\n\n// PBR toolbox\nfloat DistributionGGX (in vec3 N, in vec3 H, in float roughness)\n{\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX (in float NdotV, in float roughness)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith (in vec3 N, in vec3 V, in vec3 L, in float roughness)\n{\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = GeometrySchlickGGX (NdotV, roughness);\n    float ggx2 = GeometrySchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (in float cosTheta, in vec3 F0, float roughness)\n{\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\nfloat opCombine (in float d1, in float d2, in float r)\n{\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nfloat hashn (vec3 p, float t)\n{\n    p = fract (p*.3183099 + .1);\n    p *= 17.;\n    return max (fract (p.x*p.y*p.z*(p.x + p.y + p.z)), 1. - t); \n}\n\nfloat noise (in vec3 x, in float t)\n{\n    vec3 p = floor (x);\n    vec3 f = fract (x);\n    f = f*f*(3. - 2.*f);\n    \n    return mix(mix(mix( hashn(p+vec3(0,0,0), t), \n                        hashn(p+vec3(1,0,0), t),f.x),\n                   mix( hashn(p+vec3(0,1,0), t), \n                        hashn(p+vec3(1,1,0), t),f.x),f.y),\n               mix(mix( hashn(p+vec3(0,0,1), t), \n                        hashn(p+vec3(1,0,1), t),f.x),\n                   mix( hashn(p+vec3(0,1,1), t), \n                        hashn(p+vec3(1,1,1), t),f.x),f.y),f.z);\n}\n\nvec2 mapToScreen (in vec2 p)\n{\n    vec2 res = p;\n    res = res * 2. - 1.;\n    res.x *= iResolution.x / iResolution.y;\n    \n    return res;\n}\n\nfloat dd = .0;\n\n// ray-marching stuff\nResult scene (in vec3 p)\n{\n    float ground = p.y + 1.;\n\n\tvec3 sphereCenter = p;\n\tvec3 boxCenter = p;\n\tfloat offsetX = -2. * (iMouse.x / iResolution.x * 2. - 1.);\n\tfloat offsetY = 2. * (iMouse.y / iResolution.y * 2. - 1.);\n\tsphereCenter -= vec3 (offsetX, .25, offsetY);\n\tboxCenter -= vec3 (.0, .0, 1.25);\n\tboxCenter.xz *= r2d (-iTime);\n\n\tfloat sphere = sdSphere (sphereCenter, .6);\n\tfloat box = sdBox (boxCenter, vec3 (.8), .15);\n\n    float variation = 4. + 6.*(.5 + .5*cos (4.));\n\tvec3 structureCenter = boxCenter;\n\tstructureCenter.xz *= r2d (1.25*iTime);\n\tstructureCenter.yz *= r2d (.75*iTime);\n    float f = 2. + 1.5*(.5 + .5*cos (2.5*iTime));\n    float structure = noise (f*structureCenter, variation) - .65 + (sin (iTime) + 1.)*.05;\n    float combined = opCombine (box, sphere, .25);\n    float combinedAndCut = max (combined, structure);\n\tdd = combinedAndCut;\n\n    Result res = Result (.0, 0);\n\tres.d = min (combinedAndCut, ground);\n    res.id = (res.d == ground ) ? 1 : 2;\n    return res;\n}\n\nResult raymarch (in vec3 ro, in vec3 rd)\n{\n    Result res = Result (.0, 0);\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        vec3 p = ro + res.d * rd;\n        Result tmp = scene (p);\n        if (abs (tmp.d) < EPSILON*(1. + .125*tmp.d)) return res;\n        res.d += tmp.d * STEP_SIZE;\n        res.id = tmp.id;\n    }\n\n    return res;\n}\n\nvec3 normal (in vec3 p)\n{\n    vec2 e = vec2(.0001, .0);\n    float d = scene (p).d;\n    vec3 n = vec3 (scene (p + e.xyy).d - d,\n                   scene (p + e.yxy).d - d,\n                   scene (p + e.yyx).d - d);\n    return normalize(n);\n}\n\nfloat shadow (in vec3 ro, in vec3 rd)\n{\n    float result = 1.;\n    float t = .1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        float h = scene (ro + t * rd).d;\n        if (h < 0.00001) return .0;\n        result = min (result, 8. * h/t);\n        t += h;\n    }\n\n    return result;\n}\n\nvec3 shadePBR (in vec3 ro, in vec3 rd, in float d, in int id)\n{\n    vec3 p = ro + d * rd;\n    vec3 nor = normal (p);\n\n    // \"material\" hard-coded for the moment\n    float mask1 = .5 + .5 * cos (20.* p.x * p.z);\n    float mask2 = 0.;\n\tfloat mask = (id == 1) ? mask1 : mask2;\n\tfloat f = fract (dd*2.);\n    vec3 albedo1 = vec3 (1. - smoothstep (.025, .0125, f));\n    vec3 albedo2 = vec3 (.05, .65, .05);\n    vec3 albedo = (id == 1) ? albedo1 : albedo2;\n    float metallic  = (id == 1) ? .1 : .9;\n    float roughness = (id == 1) ? .9 : .1;\n    float ao = 1.;\n\n    // lights hard-coded as well atm\n    vec3 lightColors[2];\n    lightColors[0] = vec3 (.8, .8, .9) * 20.;\n    lightColors[1] = vec3 (.9, .8, .8) * 20.;\n\n    vec3 lightPositions[2];\n    lightPositions[0] = p + vec3 (.5, .75, -1.5);\n    lightPositions[1] = p + vec3 (-.3, .25, -.5);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (0.04); \n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3(.0);\n\t\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0);\n    for(int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - p);\n        vec3 H = normalize(V + L);\n        float distance    = length(lightPositions[i] - p);\n        float attenuation = 1. / (distance * distance);\n        vec3 radiance     = lightColors[i] * attenuation;\n\t        \n        // cook-torrance brdf\n        float aDirect = .125 * pow (roughness + 1., 2.);\n        float aIBL = .5 * roughness * roughness;\n        float NDF = DistributionGGX(N, H, roughness);        \n        float G   = GeometrySmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);\n\t        \n        vec3 kS = F;\n        kD = vec3(1.) - kS;\n        kD *= 1. - metallic;\t  \n\t        \n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = nominator / max(denominator, .001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL; \n\t    Lo *= shadow (p, L);\n    }\n\n    vec3 ambient = (kD * albedo) * ao;\n\n    return ambient + Lo;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = normalize (ro + camForward * zoom);\n\n    return normalize ((camCenter + uv.x*camRight + uv.y*camUp) - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalizing and aspect-correction\n\tvec2 uvRaw = fragCoord/iResolution.xy;\n\tvec2 uv = uvRaw;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // set up \"camera\", view origin (ro) and view direction (rd)\n    vec3 ro = vec3 (0.0, 2.0, -5.0);\n    vec3 aim = vec3 (0.0, 2.0, 0.0);\n    float zoom = 1.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // do the ray-march...\n    Result res = raymarch (ro, rd);\n    float fog = 1. / (1. + res.d * res.d * .1);\n    vec3 c = shadePBR (ro, rd, res.d, res.id);\n\n    // tonemapping, \"gamma-correction\", tint, vignette\n\tc *= fog;\n\tc = c / (1. + c);\n    c = .2 * c + .8 * sqrt (c);\n    c *= vec3 (.9, .8, .7);\n    c *= .2 + .8*pow(16.*uvRaw.x*uvRaw.y*(1. - uvRaw.x)*(1. - uvRaw.y), .3);\n\n\tfragColor = vec4(c, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsSzf.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 1227, 1250, 1250, 1342], [1383, 1383, 1420, 1420, 1449], [1451, 1451, 1502, 1502, 1602], [1604, 1619, 1685, 1685, 1938], [1940, 1940, 2003, 2003, 2111], [2113, 2113, 2188, 2188, 2407], [2409, 2409, 2479, 2479, 2559], [2561, 2561, 2617, 2617, 2721], [2723, 2723, 2754, 2754, 2868], [2870, 2870, 2907, 2907, 3418], [3420, 3420, 3450, 3450, 3560], [3578, 3600, 3626, 3626, 4596], [4598, 4598, 4640, 4640, 4936], [4938, 4938, 4963, 4963, 5180], [5182, 5182, 5221, 5221, 5465], [5467, 5467, 5530, 5530, 7750], [7752, 7752, 7818, 7818, 8157], [8159, 8159, 8216, 8257, 8995]], "test": "valid"}
{"id": "tdsSzj", "name": "Hometask_1_Popkov", "author": "popkover", "description": ".", "tags": [], "likes": 1, "viewed": 41, "published": "Public", "date": "1552230429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.0001\n#define COUNTER 100\n#define DIST 0.005\n#define FOCAL_LENGTH 1.2\n#define MIN 0.01\n#define MAX 6.0\n\nfloat Globe (vec3 param, float r)\n{\n\tfloat coord = length(param) - r;\n    return coord;\n}\n\nfloat Surface (vec3 param)\n{\n\treturn param.y;\n}\n\nfloat Cylinder (vec3 param, vec2 h)\n{\n    vec2 d = abs(vec2(length(param.xz),param.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat Cone (vec3 param, vec3 c)\n{\n    vec2 q = vec2(length(param.xz), param.y);\n    vec2 v = vec2(c.z*c.y/c.x, -c.z);\n    vec2 w = v - q;\n    vec2 vv = vec2(dot(v,v), v.x*v.x);\n    vec2 qv = vec2(dot(v,w), v.x*w.x);\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt(dot(w,w) - max(d.x,d.y)) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat Prism (vec3 param, vec2 h)\n{\n    vec3 q = abs(param);\n    return max(q.z-h.y,max(q.x*0.866025+param.y*0.5,-param.y)-h.x*0.5);\n}\n\nmat3 Rotation (vec2 alpha)\n{\n\tvec2 c = cos(alpha);\n\tvec2 s = sin(alpha );\n    vec3 first  = vec3(c.y,  0.0, -s.y);\n    vec3 second = vec3(s.y * s.x,  c.x,  c.y * s.x);\n    vec3 third = vec3(s.y * c.x, -s.x,  c.y * c.x);\n    return mat3(first, second, third);\n}\n\nfloat MakeFigure (vec3 p)\n{\n    float globe = Globe(p - vec3(0.5, 0.22, -1.1), 0.1);\n    float globe1 = Globe(p - vec3(0.3, 0.3, 0.0), 0.2);\n    float surface = Surface(p - vec3(0.0, 0.1, 0.0));\n    float cylinder = Cylinder(p - vec3(-0.3, 0.3, -1.0), vec2(0.1,0.2));\n    float cone = Cone(p - vec3(-1.2, 0.6, 0.6), vec3(0.3, 0.5, 0.4));\n    float prism = Prism(p - vec3(1.2, 0.2, 1.1), vec2(0.4, 0.2));\n    return min(min(min(globe, surface), min(cone, prism)), min(globe1, cylinder));\n}\n\nvec3 Normal (vec3 coord)\n{\n\treturn normalize(vec3(\n\t\tMakeFigure(coord + vec3(EPS, 0, 0)) - MakeFigure(coord - vec3(EPS, 0, 0)),\n\t\tMakeFigure(coord + vec3(0, EPS, 0)) - MakeFigure(coord - vec3(0, EPS, 0)),\n\t\tMakeFigure(coord + vec3(0, 0, EPS)) - MakeFigure(coord - vec3(0, 0, EPS))));\n}\n\nvoid RayMarching (vec3 ro, vec3 rd, out int steps, out float t)\n{\n\tt = 0.0;\n    for (int j = 0; j < COUNTER; ++j) {\n        vec3 p = ro + rd * t;\n        float d = MakeFigure(p);\n        if (d < DIST) {\n         \tsteps = j;   \n            break;\n        }\n        t += d;\n    }\n}\n\nfloat Darkness (vec3 p0, vec3 p1, float k)\n{\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0 * DIST;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < COUNTER; ++i)\n\t{\n\t\tfloat d = MakeFigure(p0 + rd * t);\n\t\tif (d < DIST)\n\t\t\treturn 0.0;\n\t\tf = min(f, k * d / t);\n\t\tt += d;\n\t\tif (t >= maxt)\n\t\t\tbreak;\n\t}\n\treturn f;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 eye = vec3(0, 0, -2.0);\n    vec3 up = vec3(0, 1.0, 0);\n    vec3 right = vec3(1.0, 0, 0);\n    vec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.y = uv.y * iResolution.y/iResolution.x;\n    vec3 ro = eye;\n    vec3 rd = normalize(vec3(0, 0, 1) * FOCAL_LENGTH + right * uv.x + up * uv.y);\n    \n    vec4 color1 = vec4(1.0, 0.6, 0.7, 1.0);\n    vec3 pos1 = vec3(sin(iTime) * 2.0, 2.0, cos(iTime) * 2.0);\n    vec4 color2 = vec4(0.5, 1.0, 0.8, 1.0);\n    vec3 pos2 = vec3(cos(iTime) * 2.0, 2.0, sin(iTime) * 2.0);\n    vec4 color = vec4(0.0, 0.8, 1.0, 1.0);\n    \n\tmat3 rot = Rotation(vec2(0.2, 0.0));\n\trd = rot * rd;\n\tro = rot * ro;\n    float t = 0.0;\n    int i = 0;\n    RayMarching(ro, rd, i , t);   \n    vec3 p;\n    if (t > MIN && t < MAX) {\n    \tp = ro + rd * t;\n        vec3 direct1 = normalize(pos1 - p);\n        vec3 direct2 = normalize(pos2 - p); \n    \tfloat intense1 = 0.0;\n        float intense2 = 0.0;\n    \tfloat shadow1 = Darkness(p, pos1, 6.0);\n        float shadow2 = Darkness(p, pos2, 8.0);\n        \n        if (shadow1 > 0.0) {\n            intense1 = clamp(dot(Normal(p), direct1), 0.0, 1.0) * shadow1;\n        }\n        \n        if (shadow2 > 0.0) {\n            intense2 = clamp(dot(Normal(p), direct2), 0.0, 1.0) * shadow2;\n        }\n        color = smoothstep(vec4(0.0), vec4(2.0), color1 * intense1 + color2 * intense2);\n        if (MakeFigure(p) == Globe(p - vec3(0.5, 0.22, -1.1), 0.1) ||\n            MakeFigure(p) == Cone(p - vec3(-1.2, 0.6, 0.6), vec3(0.3, 0.5, 0.4)))\n        {\n            color += vec4(0.1, 0.6, 0.0, 0.0) * (intense1 + intense2) * 1.5;\n        } \n        else if (MakeFigure(p) == Cylinder(p - vec3(-0.3, 0.3, -1.0), vec2(0.1,0.2)) ||\n                 MakeFigure(p) == Prism(p - vec3(1.2, 0.2, 1.1), vec2(0.4, 0.2)))\n        {\n            color += vec4(0.1, 0.1, 0.4, 0.0) * (intense1 + intense2) * 1.5;\n        }\n\n    }\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsSzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 152, 152, 206], [208, 208, 236, 236, 255], [257, 257, 294, 294, 405], [407, 407, 440, 440, 731], [733, 733, 767, 767, 866], [868, 868, 896, 896, 1128], [1130, 1130, 1157, 1157, 1618], [1620, 1620, 1646, 1646, 1905], [1907, 1907, 1972, 1972, 2186], [2188, 2188, 2232, 2232, 2518], [2520, 2520, 2576, 2576, 4472]], "test": "valid"}
{"id": "tdsXDS", "name": "hologreen", "author": "kvick", "description": "green", "tags": ["green"], "likes": 2, "viewed": 47, "published": "Public", "date": "1552431268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979\n#define PI2 6.28318530718\n\n//Draw line start\n#define DLS(adef) b = adef;\n//Draw line next\n#define DLN(bdef) a = b; b = bdef; color += vec3(1.0, 0., 0.) * getLine(st, a, b);\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n#define HASHSCALE 3.10432424231\nfloat hash2d(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat Hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 15.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash2d( i + vec2(0.0,0.0) ), \n                     hash2d( i + vec2(1.0,0.0) ), u.x),\n                mix( hash2d( i + vec2(0.0,1.0) ), \n                     hash2d( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(in vec2 uv)\n{\n    uv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    //f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\n//--------------------------------------------------------------------------------\nfloat Linear(float x, float v0, float v1) \n{\n\treturn (v1-v0)*x + v0;\n}\n\n//--------------------------------------------------------------------------------\nfloat Smoothstep(float x, float v0, float v1) \n{\n\tx = x*x*(3.0-2.0*x);\n\treturn (v1-v0)*x + v0;\n}\n\nfloat Line(vec2 st, vec2 a, vec2 b, float w)\n{\n \tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(aToST, ab) / dot(ab, ab), 0., 1.);\n    float d = length(aToST - ab * t) - w * 0.5;\n    return d;\n}\n\nfloat distToLine(vec2 st, vec2 a, vec2 b)\n{\n\tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(ab, aToST) / dot(ab, ab), 0., 1.);\n    float d = length(a + ab * t - st);\n    \n    //doing some fudging to achieve the falloff line look for vectrex\n    //d /= t * 1.;\n    \n    return d;\n}\n\nfloat getLine(vec2 st, vec2 start, vec2 end)\n{\n    float jitterIntensity = 0.001;\n    float jitter = Hash(sin(iTime * 250.)) * jitterIntensity;\n    \n    float f = 0.;\n    float dist2Line = distToLine(st, start, end) + jitter;\n    \n    f = (0.01 / (dist2Line));\n    \n    f *= 0.1;\n    \n    return clamp(f, 0., 1.);\n}\n\nvec3 rotZ(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d),\t-sin(d), \t0.,\n        sin(d), cos(d), \t0.,\n        0., \t0., \t\t1.\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotY(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d), \t\t0., \tsin(d), \n        0., \t\t\t1., \t0., \n        -sin(d), \t\t0., \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotX(vec3 b, float d)\n{\n    mat3 A = mat3(\n        1., \t0., \t\t0.,\n        0.,\t\tcos(d),\t\t-sin(d),\n        0.,\t\tsin(d), \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec2 pToS(vec3 p)\n{\n    p = rotY(p, iTime * 0.);\n    p = rotX(p, -0.85 + sin(iTime * 0.2) * 0.1 + 0.1);\n    p = rotZ(p, 0.0);\n    \n    //vec3 pCenter = vec3(-0., 0., pow(max(mod(-iTime * 25.0, 102.0), 4.), 0.25) * 0.75);\n    vec3 pCenter = vec3(0.15, 0.35, -1.45);\n    p += pCenter;\n    \n    p.x += sin(p.z * 1.0);\n    //p.y += cos(p.z * 1.0);\n    //p.y = cos(p.z * 1.0);\n    \n    return vec2(p.x / p.z, p.y / p.z);\n}\n\nvec3 hill(vec2 st)\n{\n    vec3 color = vec3(0.);\n    float flipOver = 5.;\n    float viewAngle = iMouse.x * 0.001;mod(iTime * 0.1, flipOver) - (flipOver * 0.5);\n    vec3 hillColor = vec3(0.5, 0., 0.);\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-1.0, 0.1), vec2(viewAngle, 0.) + vec2(-0.5, 0.2));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.5, 0.2), vec2(viewAngle, 0.) + vec2(-0.1, 0.4));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.1, 0.4), vec2(viewAngle, 0.) + vec2(0.4, 0.2));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.4, 0.2), vec2(viewAngle, 0.) + vec2(0.8, 0.1));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.6, 0.0), vec2(viewAngle, 0.) + vec2(1.0, 0.2));\n    \n    //HillPeak\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.3, 0.3), vec2(viewAngle, 0.) + vec2(-0.18, 0.32));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.18, 0.32), vec2(viewAngle, 0.) + vec2(-0.09, 0.29));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.09, 0.29), vec2(viewAngle, 0.) + vec2(0.01, 0.31));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.01, 0.31), vec2(viewAngle, 0.) + vec2(0.09, 0.29));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.09, 0.29), vec2(viewAngle, 0.) + vec2(0.15, 0.3));\n    \n    //Horizon\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(-1., 0.0), vec2(1., 0.0));\n    return color;\n}\n\nvec3 cube(vec2 st, vec3 pos, float scale, vec3 color)\n{\n \tfloat f = 0.;\n    float yScale = 1.0;\n    \n    vec3[] p = vec3[](\n        (vec3(-scale, -scale * yScale, -scale)),\n    \t(vec3(-scale,  scale * yScale, -scale)),\n        (vec3( scale,  scale * yScale, -scale)),\n    \t(vec3( scale, -scale * yScale, -scale)),\n        \n        (vec3(-scale, -scale * yScale, scale)),\n    \t(vec3(-scale,  scale * yScale, scale)),\n     \t(vec3( scale,  scale * yScale, scale)),\n        (vec3( scale, -scale * yScale, scale))\n    );\n    \n    vec2[8] p_;\n    for (int i = 0 ; i < 8; ++i)\n    {\n        p_[i] = pToS(p[i] + pos);\n    }\n    \n    const int k_edgeMax = 8 * 3;\n    int[] edges = int[](\n        /*\n        0, 1,\n        1, 2,\n        2, 3,\n        3, 0,*/\n\t\t        \n\n        //Top\n        4, 5,\n        5, 6,\n        6, 7,\n        7, 4/*,\n        \n        //Draw connecting lines\n        \n        0, 4,\n        1, 5,\n        2, 6,\n        3, 7\n\t\t*/\n\n    );\n    \n    for (int i = 0; i < k_edgeMax; i += 2)\n    {\n        const float jitterIntensity = 0.003;//pow(sin(iTime), 3.);\n        const float halfJitter = jitterIntensity * 0.5;\n        vec2 randPointA = vec2(Hash(iTime + float(i + 34)), Hash(iTime + float(i + 3424))) * jitterIntensity - halfJitter;\n        vec2 randPointB = vec2(Hash(iTime + float(i * 2 + 34)), Hash(iTime + float(i * 24))) * jitterIntensity - halfJitter;\n        \n        vec2 pointA = p_[edges[i]] + randPointA;\n        vec2 pointB = p_[edges[i + 1]] + randPointB;\n        \n        f += getLine(st, pointA, pointB);\n        \n    }\n    \n    //Color\n    return color * f * 0.08;   \n}\n\nvec3 Planet( in vec2 st)\n{\n    return vec3(0.0);\n}\n\nfloat getCircDist(in vec2 st, in vec2 p, in float r)\n{\n    vec2 vTo = p - st;\n    float degs = atan(vTo.y, vTo.x);\n    degs *= 0.03;\n    //float modTime = sin(iTime) * 252.0 + 128.0;\n    float modTime = 1.0;\n \treturn length(vTo) - r + sin(degs * modTime) * 0.1;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n//================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\tuv.x *= aspect;\n\tvec2 st = uv;\n    st -= vec2(0.5 * aspect, 0.5);\n    \n    //Cool warpy look\n    //st = vec2(pow(pow(st.x, st.x), 2.), pow(st.y, 2.));\n    \n    //Trying to get a CRT-style monitor warp\n    //float stDistortPow = 2.;\n    //st += vec2(pow(st.x, stDistortPow)* ((st.x < 0.) ? -1.: 1.), pow(st.y, stDistortPow) * ((st.y < 0.) ? -1.: 1.));\n    \n\tfloat f;\n    \n    float iTime = iTime * 1.0;\n    \n    vec3 color = vec3(0.);\n\t\n    float deg = iTime * PI * 0.25;\n    float halfPI = PI * 0.5;\n    /*\n\tf = getLine(st, \n                vec2(0.5, 0.5) + vec2(cos(deg), sin(deg)), \n                vec2(0.5, 0.5) + vec2(cos(deg + PI), sin(deg + PI))\n                );\n    f = 0.;\n    */\n    color += vec3(0.8, 0., 0.) * f;\n    \n    //Hills\n    //color += hill(st);\n    \n    //Grid\n    //vec3 gridColor = vec3(0.9, 0., 0.1) * 0.15;\n    //float gridSpacing = 0.2;\n    //color += gridColor * getLine(vec2(st.x, mod(st.y + 0.5, gridSpacing)), vec2(-1., 0.), vec2(1., 0.));\n    \n    //UI\n    color += Planet(st);\n    \n    //a = vec2(0.25, 0.);\n    //b = vec2(0.4, 0.2);\n    //color += vec3(1.0, 1., 1.) * getLine(st, a, b);\n    //a = vec2(0.25, 0.);\n    //color += vec3(1.0, 1., 1.) * getLine(st, vec2(0.4, 0.2), vec2(0.4, 0.2));\n    \n    vec3 smokeColor = vec3(0.5, 1.0, 0.0);\n    vec2 a = vec2(0., 0.);\n    vec2 b = vec2(0.5, 0.);\n    //color += vec3(1.0, 0., 0.) * getLine(st, a, b);\n    \n    st *= 3.5;\n    \n    //getCircDist\n    //sdBox\n    float distFunc = getCircDist(st, vec2(0., 0.), 0.3 + Hash(st.x + iTime * st.y) * 0.01);\n    //distFunc = step(distFunc, 0.1);\n    float y = mod((iTime * 0.1) + fbm(vec2(iTime * 0.001)), 2.2) - 1.1;\n    distFunc = min(distFunc,\n        getCircDist(st, vec2(0.3 + fbm(vec2(iTime * 0.01, y)) * 0.21, y), 0.2 + Hash(st.x + iTime) * 0.01)\n        );\n    \n    for (float i = 1.0; i <= 25.0; i += 1.0)\n    {\n        vec3 temp = rotZ(vec3(st.x, st.y, 0.), i + iTime * 0.02);\n        st = vec2(temp.x, temp.y);\n        y = y + mod(iTime * 0.1, 15.) * i;\n        distFunc = min(distFunc,\n        //getCircDist(st, vec2(-0.3 + fbm(vec2(iTime * 0.14, y)) * 0.11, y), 0.33 + Hash(st.x + iTime) * 0.015)\n                      \n        //sdBox(st + vec2(i * 0.3, 0.0), vec2(0.01 + i * 0.02, 0.2))\n        \n        \n        sdBox(vec2(mod(st.x + iTime, 2.5), st.y), vec2(0.01 + i * 0.02, 0.2))\n                       /*\n        getCircDist(st, \n                    vec2(\n                        (-0.3 * Hash(i) * 1.0) + fbm(vec2(iTime * 0.14, y)) * 0.81, \n                        y\n                    )\n                    , 0.33 * Hash(i) * 1.1 + Hash(st.x + iTime) * 0.015)//radius\n*/\n        );\n\n    }\n    \n    float circResult = (1.2 - pow(abs(distFunc), 0.15)) * 1.1;\n    color += smokeColor * circResult;\n    \n    \n    //float gamma = Smoothstep(st.y, 1.99, 8.0);\n    float gamma = 2.7;\n    color = vec3(pow(color.x, gamma), pow(color.y, gamma), pow(color.z, gamma));\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsXDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 336, 395, 395, 499], [501, 501, 522, 522, 639], [641, 641, 667, 667, 969], [971, 971, 994, 994, 1237], [1239, 1322, 1366, 1366, 1392], [1394, 1477, 1525, 1525, 1573], [1575, 1575, 1621, 1621, 1788], [1790, 1790, 1833, 1833, 2089], [2091, 2091, 2137, 2137, 2406], [2408, 2408, 2436, 2436, 2600], [2602, 2602, 2630, 2630, 2801], [2803, 2803, 2831, 2831, 2997], [2999, 2999, 3018, 3018, 3416], [3418, 3418, 3438, 3438, 5065], [5067, 5067, 5122, 5122, 6669], [6671, 6671, 6697, 6697, 6721], [6723, 6723, 6777, 6777, 6986], [6988, 6988, 7025, 7025, 7109], [7111, 7194, 7251, 7251, 10284]], "test": "error"}
{"id": "tdsXRj", "name": "Strawberry", "author": "EvilRyu", "description": "Yummy!", "tags": ["eyes", "fruit", "strawberry", "inversesphericalfibonacci"], "likes": 52, "viewed": 942, "published": "Public API", "date": "1552842382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash13(vec3 p)\n{\n    p=fract(p*vec3(5.3983,5.4472,6.9371));\n    p+=dot(p.yzx,p.xyz+vec3(21.5351,14.3137,15.3219));\n    return fract(p.x*p.y*p.z*95.4337);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  \tvec3 d=abs(p)-b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{    \n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvoid basis(vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.y<-0.999999) \n    {\n        b1=vec3(0,0,-1);\n        b2=vec3(-1,0,0);\n    } \n    else \n    {\n    \tfloat a=1./(1.+n.y);\n    \tfloat b=-n.x*n.z*a;\n    \tb1=vec3(1.-n.x*n.x*a,-n.x,b);\n    \tb2=vec3(b,-n.z,1.-n.z*n.z*a);\n    }\n}\n\nvoid rot2d(inout vec2 p, float t)\n{\n    float ct=cos(t),st=sin(t);\n    vec2 q=p;\n\tp.x=ct*q.x+st*q.y;\n    p.y=-st*q.x+ct*q.y;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a,b,-k);\n}\n\nconst float PI=3.14159265359;\nconst float PHI=1.61803398875;\n\n// from iq: https://www.shadertoy.com/view/lllXz4\nvec4 invsf(vec3 p, float n)\n{\n    float m=1.-1./n;\n    float phi=min(atan(p.y,p.x),PI);\n    float k=max(2.,floor(log(n*PI*sqrt(5.)*\n                             (1.-p.z*p.z))/log(PHI+1.)));\n    float Fk=pow(PHI,k)/sqrt(5.);\n    vec2  F=vec2(round(Fk), round(Fk*PHI));\n    vec2 ka=2.*F/n;\n    vec2 kb=2.*PI*(fract((F+1.)*PHI)-(PHI-1.));    \n    mat2 iB=mat2(ka.y,-ka.x, \n                    kb.y,-kb.x)/(ka.y*kb.x-ka.x*kb.y);\n    \n    vec2 c=floor(iB*vec2(phi, p.z-m));\n    float d=0.;\n    vec4 res=vec4(0);\n    for(int s=0; s<4; s++) \n    {\n        vec2 uv=vec2(s&1,s>>1);\n        float i=dot(F,uv+c); \n        float phi=2.*PI*fract(i*PHI);\n        float ct=m-2.*i/n; //costheta\n        float st=sqrt(1.-ct*ct); //sintheta\n        \n        vec3 q=vec3(cos(phi)*st, \n                    sin(phi)*st, \n                    ct);\n        float d1=dot(p,q);\n        if(d1>d) \n        {\n            d=d1;\n            res=vec4(q,d);\n        }\n    }\n    return res;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=textureLodOffset(sam, p.xy-vec2(.14), 1.5, ivec2(2));\n    vec4 p2=textureLod(sam, p.xz, 0.);\n    vec4 p3=textureLod(sam, p.yz, 1.5);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat id=0.;\n\nvec4 get_eye_params(vec3 p)\n{\n    vec3 r,f;\n    vec4 fibo=invsf(normalize(p),88.3);\n    vec3 q=p-fibo.xyz;\n    vec3 n=normalize(fibo.xyz);\n    basis(n,r,f);\n    q=vec3(dot(r,q),dot(n,q),dot(f,q));\n    rot2d(q.xz,hash13(fibo.xyz)*7.);\n    return vec4(q,0.1+0.088*hash13(fibo.xyz+vec3(13.399,71.137,151.11)));\n}\n\nvec3 deform(vec3 p)\n{\n    vec3 q=p;\n    q*=1.-(smoothstep(0.,1.,q.y)-smoothstep(1.,2.,q.y)*3.)*0.16;\n    q*=1.-(smoothstep(0.,.45,q.y)-smoothstep(.45,.9,q.y))*0.07;\n    q.xz*=(1.-smoothstep(-.6,0.2,q.y))*.2+1.;\n    q.y*=0.8;\n    return q;\n}\n\nvec2 polar_rep(vec2 p, float n)\n{\n    n=PI*0.5/n;\n    float a=atan(p.y, p.x);\n    float r=length(p);\n    a=mod(a+n/2.0, n)-n/2.0;\n    p=r*vec2(cos(a), sin(a));\n    return 0.5*(p+p-vec2(1,0));\n}\n\nfloat leaf(vec3 p)\n{\n    vec3 q=p;  \n    q.xz=polar_rep(q.xz,2.5);\n    q.y+=0.1*sin(q.x*6.);\n    vec3 q1=q;\n    q.z=abs(q.z)+0.6;\n    float d=cylinder(q,vec2(0.7,0.01));\n    float d1=box(q1-vec3(0.,0.01,0.),vec3(0.45,0.013,0.001));\n    d=smin(d,d1,0.05);\n    p.x+=0.1*sin(p.y*4.0);\n \tp.x-=0.05;\n    d1=cylinder(p,vec2(0.04,0.7));\n    d=smin(d,d1,0.3);\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    float lea=leaf(p.xyz-vec3(0.,1.32,0.));\n    p=deform(p);\n    float d0=sphere(p,1.)-0.1*texcube(iChannel0, p*0.45, normalize(p)).x;\n    vec4 q=get_eye_params(p);\n    float d1=sphere(q.xyz+vec3(0.,(-0.188+q.w)*.8,0.),q.w*.8);\n    d0=smin(d0,d1,0.09);\n    \n    float a=mod(iTime*q.w*1.3,1.);\n    d1=sphere(vec3(q.x,q.y-0.188+q.w*(smoothstep(0.,.1,a)-smoothstep(0.9,1.,a)),\n                   abs(q.z)+q.w*0.35),\n              q.w*0.7);\n    d0=smax(d0,-d1,0.09);\n    d1=sphere(q.xyz+vec3(0.,-0.09+q.w,0.),q.w);\n    \n    if(d0>d1){d0=d1;id=1.;}\n    if(d0>lea){d0=lea;id=2.;}\n    \n    return d0;\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec3 eps=vec3(0.001,0,0);\n    return normalize(vec3(map(p+eps.xyz)-map(p-eps.xyz),\n                     map(p+eps.yxz)-map(p-eps.yxz),\n                     map(p+eps.yzx)-map(p-eps.yzx)));\n}\n\n#define FAR 30.0\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t=0.1;\n    float d=0.;\n   \tfor(int i=0;i<96;++i)\n    {\n        d=map(ro+t*rd);\n        if(d<0.003&&t>FAR)\n        \tbreak;\n        t+=d;\n    }\n        \n    return t;\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p=floor(x);\n    vec2 f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float n=p.x + p.y*57.0;\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n}\nconst mat2 m=mat2(0.8,0.6,-0.6,0.8);\n\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    f+=.5*noise(p); p=m*p*2.;\n    f+=.25*noise(p); p=m*p*2.;\n    f+=.125*noise(p); p=m*p*2.;\n    f+=.0625*noise(p); p=m*p*2.;\n    f+=.03125*noise(p);\n    return f/0.984375;\n}\n\nfloat trace_sphere(vec3 ro, vec3 rd, vec4 sph)\n{\n    vec3 p=sph.xyz;\n    float t=-1.0;\n    vec3  ce=ro-p;\n    float b=dot(rd, ce);\n    float c=dot(ce, ce)-sph.w*sph.w;\n    float h=b*b - c;\n    if(h>0.0)\n    {\n        t=-b-sqrt(h);\n    }\n    \n    return t;\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r=0.0, w=1.0, d;\n    for(float i=1.; i<5.0+1.1; i++)\n    {\n        d=i/5.0;\n        r+=w*(d-map(p+n*d));\n        w*=0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nvec3 get_material(vec3 ro, vec3 rd, vec3 p)\n{\n    if(id<1.)\n    {\n    \t//return vec3(0.82,0.055,0.027)*0.4;   // real strawberry color  \n        return vec3(0.984,0.352,0.551)*0.75;\n    }\n    else if(id>1.1)\n    {\n        return vec3(0.05,0.15,0.);\n    }\n    \n\tp=deform(p);\n    vec4 eyes=get_eye_params(p);\n\n    vec3 col=vec3(1.);\n\tvec2 uv=vec2(eyes.xz);\n    float r=length(uv);\n    if(r<eyes.w*.13)\n    {\n        col=vec3(0.01);\n    }\n    else if(r<eyes.w*.3)\n    {\n        col=mix(vec3(.9,.8,.3)*.5,vec3(.01), fbm(50.*uv));\n    }\n\tcol=mix(col,vec3(0.2,0.,0.)*fbm(50.*uv),\n            smoothstep(eyes.w*.35, eyes.w*.6, r));\n   \n    return col;\n}\n\nfloat sss(vec3 p, vec3 n, float d, float i) \n{ \n    float o,v; \n    for(o=0.;i>0.;i--) \n        o+=(i*d+map(p+n*i*d))/exp2(i); \n    return o; \n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float s = 1.0,t = 0.01,h = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        h = map(ro + rd*t);\n        s = min( s, 16.*h/t );\n        if( s<0.0001 ) break;\n        t += clamp( h, .01, .05 );\n    }\n    return clamp(s,.0,1.);\n}\n\nvec3 lighting(vec3 ro, vec3 rd, vec3 n, float t, vec3 p)\n{\n    vec3 ld0=normalize(vec3(1,1.5,-1.7));\n    \n    float dif=max(0.,dot(ld0,n));\n    float spe=pow(max(0.,dot(rd,reflect(ld0,n))), 24.0);\n    float bac=max(0.,dot(-ld0,n));\n    float amb=clamp(0.3+0.7*n.y,0.0,1.0);\n    float sca=sss(p,-n,.5,10.);\n    float fre=clamp(1.-dot(n,-rd),0.,1.);\n    id=0.;\n    float d=map(p);\n    vec3 mate=get_material(ro,rd,p);\n    \n    float ao=get_ao(p,n);\n    float sha=shadow(p,ld0);\n    \n    vec3 col=(4.0*dif*sha+0.5*bac+1.*amb*sha+fre*fre*fre*10.*sha)*mate*ao*ao+1.5*spe*sha;\n    col+=2.*mate*sca;\n    col*=0.2;\n    return col;\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51;\n    const float b=0.03;\n    const float c=2.43;\n    const float d=0.59;\n    const float e=0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 bg(vec2 p)\n{\n    vec2 po;\n    po.x=atan(p.y, p.x);\n    po.y=length(p)-iTime*0.4;\n    float d=length(p);\n    vec3 col=vec3(d,d*.5,d*.7);\n    float c=pow(fbm(po*5.),5.)*(1.-(smoothstep(0.,0.01,d)-smoothstep(.4,1.,d)))\n        \t*max(0.,1.5-d);\n    col-=vec3(c*4.,c*7.,c*3.)*.2;\n    return clamp(col,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p=q*2.0-1.;\n    p.x*=iResolution.x/iResolution.y;\n\n    vec3 ro=vec3(0,0.7,-6);\n    vec3 ta=vec3(0,0,0);\n     // debugging camera\n    float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    if(iMouse.z>0.||iMouse.w>0.)\n    \tro=vec3(0.,0,-3)+vec3(cos(y_rot)*cos(x_rot),cos(y_rot)*cos(x_rot),cos(y_rot)*sin(x_rot))*5.;\n     \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(vec3(0,1,0),f));\n    vec3 u=normalize(cross(f,r));\n    \n    vec3 rd=normalize(mat3(r,u,f)*vec3(p.x,p.y,2.8));\n    \n    vec3 col=bg(p);\n    \n    float t=trace_sphere(ro,rd,vec4(0.,0.,0.,2.));\n    if(t>0.&&t<1000.)\n    {\n        float t=intersect(ro,rd);\n        if(t<FAR)\n        {\n            vec3 pos=ro+t*rd;\n            vec3 n=get_normal(pos);\n   \t        col=lighting(ro, rd,n,t,pos);\n    \t}\n    }\n    \n\tcol=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsXRj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 111, 134, 134, 276], [278, 278, 300, 300, 439], [441, 441, 472, 472, 498], [500, 500, 527, 527, 610], [612, 612, 644, 644, 749], [751, 751, 798, 798, 1029], [1031, 1031, 1066, 1066, 1157], [1159, 1159, 1198, 1198, 1281], [1283, 1283, 1322, 1322, 1349], [1413, 1463, 1492, 1492, 2421], [2423, 2423, 2468, 2468, 2663], [2679, 2679, 2708, 2708, 2988], [2990, 2990, 3011, 3011, 3230], [3232, 3232, 3265, 3265, 3425], [3427, 3427, 3447, 3447, 3794], [3796, 3796, 3815, 3815, 4411], [4413, 4413, 4438, 4438, 4633], [4652, 4652, 4687, 4687, 4864], [4866, 4866, 4887, 4887, 5097], [5137, 5137, 5156, 5156, 5348], [5350, 5350, 5398, 5398, 5607], [5609, 5609, 5639, 5639, 5811], [5813, 5813, 5858, 5858, 6459], [6461, 6461, 6507, 6507, 6605], [6607, 6607, 6639, 6639, 6870], [6872, 6872, 6930, 6930, 7496], [7498, 7498, 7521, 7521, 7697], [7699, 7699, 7716, 7716, 8009], [8011, 8011, 8068, 8068, 9121]], "test": "error"}
{"id": "tdsXRs", "name": "11koroch", "author": "korochucha", "description": "1", "tags": ["1"], "likes": 1, "viewed": 45, "published": "Public", "date": "1552250924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MXM_ITER 200\n#define MXM_LENGTH 200.0\n#define TOUCH_LENGTH 0.001\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec4 Dist(vec3 p){\n\t\n    float pld = p.y;\n    \n    float sd = sdSphere(p - vec3(0.6, 4.29, 2.5), 1.7 );\n    float bd = udBox(p - vec3(0.6, 1.3, 2.9), vec3 (2.5, 1.3, 1.3));\n   \tfloat cod = sdCone(p - vec3(3.6, 01.3, 1.5), normalize(vec2 (5.1, .3)));\n    float cod1 = sdCone(p - vec3(-3.6, 01.3, 1.5), normalize(vec2 (5.1, .3)));\n    float cod2 = sdCone(p - vec3(.0, 1.8, 1.5), normalize(vec2 (5.1, .3)));\n    float cyd = sdCylinder(p +  vec3(.0, 1.8, -12.5), vec3(2.,5.,2.));\n    float cyd1 = sdCylinder(p +  vec3(6.0, 1.8, -12.5), vec3(2.,5.,2.));\n    float cyd2 = sdCylinder(p +  vec3(-6.0, 1.8, -12.5), vec3(2.,5.,2.));\n    \n    \n    float d = min(sd, pld);\n    d = min(bd,d);\n    d = min(cod,d);\n    d = min(cod1,d);\n    d = min(cod2,d);\n    d = min(cyd,d);\n    d = min(cyd1,d);\n    d = min(cyd2,d);\n    \n    \n    if ((d == cod) || (d == cod1) || (d == cod2)) {return vec4 (d, 0.8, 0., 0.3);\n    } else if (d == bd) {return vec4 (d, 0., 1., 0.7);\n    } else if (d == sd) {return vec4 (d, 0.1, 0.7, 1.);\n    } else if ((d == cyd) || (d == cyd1) || (d == cyd2)) {return vec4 (d, 1., .4, 0.2);\n    } else{return vec4(d, 1., 1., 1.);\n    }\n}\n\nvec4 RayMarching(vec3 cPos, vec3 rDir){\n\tfloat dPos=0.;\n\tvec4 v;\n    int i=0;\n    while (i<MXM_ITER) {\n    \tvec3 p = cPos + rDir*dPos;\n        v = Dist(p);\n        float d = v.x;\n        dPos += d;\n        if (dPos>MXM_LENGTH || d<TOUCH_LENGTH) break;\n        i++;\n    }\n    return vec4(dPos, v.y, v.z, v.w);\n\n}\n\nvec3 Normal(vec3 p){\n    vec4 v = Dist(p);\n\tfloat d = v.x;\n    \n     vec4 q1 = Dist(p - vec3(0.005, .0, .0));\n     vec4 q2 = Dist(p - vec3(0.0, .005, .0));\n     vec4 q3 = Dist(p - vec3(0.0, .0, .005));\n    \n    vec3 n = d - vec3(\n        q1.x,\n        q2.x,\n        q3.x);\n    return normalize(n);\n}\n\nfloat Light1(vec3 p){\n\tvec3 lpos = vec3 (0,7,-1);\n    lpos.xz += vec2(cos(iTime), 1.-cos(iTime)*2.);\n    vec3 l = normalize(lpos - p);\n    vec3 n = Normal(p);\n    \n    float diff = clamp(dot(n,l), 0., 1.);\n    vec4 vc = RayMarching(p+n*TOUCH_LENGTH*3.,l);\n    float d = vc.x;\n    if (d < length(lpos - p)) diff *= 0.1;\n    \n    return diff;\n}\n\nfloat Light2(vec3 p){\n\tvec3 lpos = vec3 (-10,5,-4);\n   // lpos.xy += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lpos - p);\n    vec3 n= Normal(p);\n    \n    float diff = clamp(dot(n,l), 0., 1.);\n    vec4 vc = RayMarching(p+n*TOUCH_LENGTH*2.0,l);\n    float d = vc.x;\n    if (d < length(lpos - p)) diff *= .001;\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //координата на экране\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\t//vec3 col1 = vec3(.8, 0.3, 1.5);\n\t// позиция камеры\n    vec3 cPos = vec3(0,5,-17);\n    //ray direction\n    vec3 rDir = normalize(vec3(uv.x, uv.y, 1)); \n    \n    vec4 v = RayMarching(cPos, rDir);\n\n    vec3 p = cPos + rDir*v.x;\n    \n\tfloat diff = Light1(p);\n    diff += Light2(p);\n   \n   \n\tvec3 col1 = vec3(v.y, v.z, v.w);\n    col = vec3(diff)*col1;\n    \n    //цвет пикселя\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 107, 107, 131], [133, 133, 165, 193, 254], [256, 256, 287, 287, 325], [327, 327, 363, 363, 397], [399, 399, 417, 417, 1540], [1542, 1542, 1581, 1581, 1853], [1855, 1855, 1875, 1875, 2154], [2156, 2156, 2177, 2177, 2498], [2500, 2500, 2521, 2521, 2844], [2846, 2846, 2903, 2948, 3465]], "test": "valid"}
{"id": "tdSXzh", "name": "Spiral Pole and Zeroes", "author": "ttoinou", "description": "Made this two years ago but forgot to make it public", "tags": ["triangle", "equerre"], "likes": 2, "viewed": 269, "published": "Public API", "date": "1552863005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHOW_POINTS 1\n#define SHOW_SEGMENTS 1\n#define SHOW_DUAL_POINTS 1\n#define SHOW_DUAL 1\n\n#define PI 3.14159265359\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cpow( vec2 z , float k ) { return polar(pow(length(z),k) , k*atan(z.y,z.x) ); }\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n    \n    float r;\n    float ID;\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n\n        \n\n// Base Triangle\nEquerre Tri;\n\nfloat k = 1. - sqrt(3.)*.5;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,-(n + logZoom)/2.) , (n)/3.*PI + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindEquerre(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        return false;\n    }\n    \n    return true;\n}\n\nvec2 deformation_pole = vec2(.3,.0);\n\nvec2 deformation( vec2 uv )\n{\n    float nbPoles = 5.;\n    vec2 ret = vec2(1.,0.);\n    \n    for(float i = 0. ; i < nbPoles ; i += 1. )\n    {\n        ret = cmul(ret,uv - polar(deformation_pole.x,2.*PI*i/nbPoles));\n    }\n    \n    return cdiv( ret/nbPoles , cpow(uv,2.) );\n    //uv = cdiv( uv + deformation_pole , uv - deformation_pole );\n    //uv = cdiv(vec2(1.,0.),uv);\n    //return uv;\n    //return clog( uv + deformation_pole ) - clog( uv - deformation_pole );\n    //return cexp( cdiv( uv + deformation_pole , clog( uv - deformation_pole ) ) );\n}\n\nvec2 deformation_inverse(vec2 def )\n{\n    return cdiv(2.*deformation_pole,def -  vec2(1.,0.)) + deformation_pole;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n    int nbIterations = 1 + int(floor(pow((1.0 - cos(iTime*3.14/13.0))/2.0,0.5)*7.1));\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.)));\n    \n    vec2 uv_s = deformation(uv);\n    \n    viewportMagnify =1.; \n    //uv_s *= viewportMagnify;\n    \n    \n    angleShift = cos(iTime/7.5)*8.;\n    logZoom = sin(iTime/4.)*13.;\n    \n    float r = floor( -log(dot(uv_s,uv_s))/log(k) - logZoom );\n    \n    \n    if( !FindEquerre(r+1.,uv_s) )\n    {\n        // inside circle\n        FindEquerre(r,uv_s);\n    }\n    \n    fragColor.rgb = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID));\n    \n    /*Tri.A = deformation_inverse(Tri.A);\n    Tri.B = deformation_inverse(Tri.B);\n    Tri.C = deformation_inverse(Tri.C);\n    uv_s = uv;*/\n\n    float scale = 1./viewportMagnify/(1. + dot(uv_s,uv_s)*1.); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) fragColor.rgb = mixColorLine(uv_s,fragColor.rgb,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 3.;\n    vec2 TriCenterMix = (Tri.A + Tri.B + Tri.C)/3.;\n    \n    #if SHOW_DUAL_POINTS==1\n        fragColor.rgb *= 3.*(.5 + coeffDistPoint(uv_s,TriCenterMix,scale));\n    #endif\n    \n    \n    fragColor.rgb = tanh(fragColor.rgb *2./(1. + dot(uv_s,uv_s)/1e3 ) ); // LOG correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 161, 161, 195], [197, 197, 227, 227, 282], [283, 283, 304, 304, 337], [338, 338, 359, 359, 410], [411, 411, 441, 441, 511], [512, 512, 543, 543, 596], [598, 822, 862, 862, 1226], [1556, 1667, 1688, 1688, 1809], [1811, 1811, 1836, 1864, 2111], [2113, 2113, 2144, 2144, 2178], [2180, 2180, 2209, 2209, 2243], [2246, 2246, 2303, 2431, 2546], [2548, 2548, 2618, 2618, 2730], [2733, 2733, 2824, 2824, 2971], [2973, 2973, 3050, 3050, 3179], [3211, 3211, 3243, 3243, 3337], [3339, 3339, 3381, 3381, 3580], [3894, 4077, 4105, 4105, 4137], [4139, 4139, 4185, 4185, 4391], [5548, 5604, 5639, 5639, 5882], [5885, 5885, 5920, 5920, 6727], [6767, 6767, 6796, 6796, 7313], [7315, 7315, 7352, 7352, 7430], [7432, 7432, 7489, 7489, 8946]], "test": "error"}
{"id": "tdXXRX", "name": "Lerp and Optimized Shapes", "author": "TheMurrMan", "description": "Circle", "tags": ["mix", "lerp", "steps"], "likes": 0, "viewed": 199, "published": "Public", "date": "1551749197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2  center = vec2(0.85,0.5);\nfloat radius = 0.15;\nvec3  circColor = vec3(1.0,0.0,1.0);\nvec3  background = vec3(1.0,0.5,0.3);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y; \n    float t = abs(sin(iTime));\n    //creates layers using colors\n    vec4 layer1 = vec4(background, 1.0);\n    vec4 layer2 = vec4(circColor, 0.0);\n\t\n    // Linear \n     vec2 position = vec2(((1.0-t) * layer1) + ((t) * layer2));\n    \n    //step functions to change transparency\n     if(length(position-uv) < radius)\n        layer2.a = 1.0;  \n    \n   \n    //mixes each layer\n    vec4 mixed = mix(layer1, layer2, layer2.a);\n    \n    // Output to screen\n    fragColor = mixed;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 186, 236, 791]], "test": "valid"}
{"id": "tdXXWX", "name": "Infinite Spheres Ray Marching", "author": "Wheyerstrass", "description": "Infinite Spheres Ray Marching Test", "tags": ["raymarching", "spheres"], "likes": 7, "viewed": 576, "published": "Public", "date": "1552330420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXSTEPS 100\n#define MINDIST .01\n\nfloat DistanceEstimator(vec3 pos) {\n    \n    // translate\n    pos = pos + 1. * vec3(0,-0.5*iTime,iTime);\n\n    float d1 = distance(mod(pos, 2.), vec3(1,1,1))-.54321;\n    \n    return d1;\n}\n\nfloat trace(vec3 from, vec3 direction) {\n\tfloat totalDistance = 0.0;\n\tint steps;\n\tfor (steps=0; steps < MAXSTEPS; steps++) {\n\t\tvec3 p = from + totalDistance * direction;\n\t\tfloat dist = DistanceEstimator(p);\n\t\ttotalDistance += dist;\n\t\tif (dist < MINDIST) break;\n\t}\n\treturn 1.0-float(steps)/float(MAXSTEPS);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0, 2, 0);\n\tvec3 camViewDir = normalize(vec3(uv.xy, 1));\n    \n\tfloat dist = trace(camPos, camViewDir);\n    \n    fragColor = vec4(dist, dist, dist, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 77, 99, 228], [230, 230, 270, 270, 537], [539, 539, 596, 596, 847]], "test": "valid"}
{"id": "tdXXzB", "name": "RayTraycing_vers1.0", "author": "kinzyabaev_i", "description": "It's my hoework.", "tags": ["shaydertiy"], "likes": 1, "viewed": 44, "published": "Public", "date": "1551542404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i = 0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.0001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0., 5., 6.);\n    lightPos.xz += vec2(sin(iTime)*6., cos(iTime))*6.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    vec3 lightPos1 = vec3(0., 5., 6.);\n    lightPos1.xz += vec2(-sin(iTime)*6., -cos(iTime))*6.;\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n   \tfloat max_dif = max(dif, dif1);\n    float min_dif = min(dif, dif1);\n\n    return (15. * max_dif + min_dif) / 16.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    float t = iTime;\n    vec3 ro = vec3(0, 2., 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    \n    col = vec3(dif);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXXzB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 349, 372, 372, 540], [542, 542, 576, 576, 784], [786, 786, 810, 810, 1001], [1003, 1003, 1027, 1027, 1747], [1749, 1749, 1806, 1806, 2160]], "test": "valid"}
{"id": "ts2SRz", "name": "Retro-styled metaballs", "author": "MacSlow", "description": "Felt like metaballs again... with a retro-style non-realistic shading. Could use some Tron-esque glow. Bumps in floor come from 2D-simplex-noise. Also here on github... https://bit.ly/2W6KsvT", "tags": ["3d", "raymarching", "sound", "metaballs", "spheretracing", "nonrealistic"], "likes": 10, "viewed": 522, "published": "Public API", "date": "1552772645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Retro-styled non-realistic metaballs with iteration glow.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float EPSILON = .001;\nconst int MAX_ITER = 48;\nconst float STEP_BIAS = 1.1;\n\nmat2 r2d (in float a) {\n\tfloat c = cos (radians (a));\n    float s = sin (radians (a));\n    return mat2 (vec2(c, s), vec2(-s, c));\n}\n\nfloat opCombine (in float d1, in float d2, in float r)\n{\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nfloat sdSphere (in vec3 p, in float r) {\n    return length (p) - r;\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n    p = vec2 (dot (p, vec2 (127.1, 311.7)),\n              dot (p, vec2 (269.5, 183.3)));\n\n    return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n    vec2 i = floor (p + (p.x + p.y)*K1);\n    \n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2; \n    vec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n    vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n                           dot (b, hash (i + o)),\n                           dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p, in int iters)\n{\n    mat2 rot = r2d (35.);\n    float d = .0;\n    float f = 1.;\n    float fsum = .0;\n\n    for (int i = 0; i < iters; ++i) {\n        d += f*noise (p);\n        p *= rot;\n        fsum += f;\n        f *= .5;\n    }\n    d /= fsum;\n\n    return d;\n}\n\nfloat scene (in vec3 p) {\n\tfloat t = 2.*iTime;\n    vec3 pBottom = p;\n    pBottom.x += 3.*iTime;\n    float bottom = pBottom.y + 1. + .25*fbm(pBottom.xz, 4);\n\n    float t4 = 2. * iTime;\n    float t5 = 2.5 * iTime;\n    float t6 = 1.75 * iTime;\n    float t7 = 2.5 * iTime;\n    float r1 = .1 + .3 * (.5 + .5 * sin (2.*t4));\n    float r2 = .1 + .25 * (.5 + .5 * sin (3.*t5));\n    float r3 = .1 + .3 * (.5 + .5 * sin (4.*t6));\n    float r4 = .1 + .25 * (.5 + .5 * sin (5.*t7));\n\n    float t1 = 1.5 * iTime;\n    float t2 = 2. * iTime;\n    float t3 = 2.5 * iTime;\n    vec3 offset1 = vec3 (-.1*cos(t1), .1, -.2*sin(t2));\n    vec3 offset2 = vec3 (.2, .2*cos(t2), .3*sin(t3));\n    vec3 offset3 = vec3 (-.2*cos(t3), -.2*sin(t3), .3);\n    vec3 offset4 = vec3 (.1, -.4*cos(t2), .4*sin(t2));\n    vec3 offset5 = vec3 (.4*cos(t1), -.2, .3*sin(t1));\n    vec3 offset6 = vec3 (-.2*cos(t3), -.4, -.4*sin(t1));\n    vec3 offset7 = vec3 (.3*sin(t2), -.6*cos(t2), .6);\n    vec3 offset8 = vec3 (-.3, .5*sin(t3), -.4*cos(t1));\n\n    float ball1 = sdSphere (p + offset1, r4);\n    float ball2 = sdSphere (p + offset2, r2);\n    float metaBalls = opCombine (ball1, ball2, r1);\n\n    ball1 = sdSphere (p + offset3, r1);\n    ball2 = sdSphere (p + offset4, r3);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r2);\n\n    ball1 = sdSphere (p + offset5, r3);\n    ball2 = sdSphere (p + offset6, r2);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r3);\n\n    ball1 = sdSphere (p + offset7, r3);\n    ball2 = sdSphere (p + offset8, r4);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r4);\n\n    vec3 pTop = p;\n    float top = -(pTop.y - 3.);\n\n    return min (metaBalls, min (bottom, top));\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd, inout int iter) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        vec3 p = ro + d * rd;\n        t = scene (p);\n        if (abs (t) < EPSILON * (1. + .125*t)) break;\n        d += t*STEP_BIAS;\n        iter = i;\n    }\n\n    return d;\n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d) {\n\tvec3 p = ro + d*rd;\n\tvec3 balls = p;\n\tballs.xz *= r2d (-95.*iTime);\n\tballs.zy *= r2d (63.*iTime);\n\n\n\tfloat floorPhase = cos (45.*p.x);\n\tfloat ballsPhase = cos (75.*balls.z);\n\tfloat floorMask = smoothstep (.01*d, .0025*d, (.5 + .5*floorPhase));\n\tfloat ballsMask = smoothstep (.01*d, .0025*d, (.5 + .5*ballsPhase));\n\tvec3 floorColor = mix (vec3 (.3, .3, 1.), vec3 (.0), 1. - floorMask);\n\tvec3 ballsColor = mix (vec3 (1., .3, .3), vec3 (.0), 1. - ballsMask);\n\n    // don't do material assignment like this, it's a hack and I'm lazy\n\tbool isMetaBalls = (p.y > -.75 && p.y < 1.);\n\n\tfloat brightness = 5. / pow (.25*d*d, 1.75);\n\tballsColor += vec3 (1., .2, .1)*brightness;\n\tfloorColor += vec3 (.1, .2, 1.)*brightness;\n\n\treturn isMetaBalls ? ballsColor : floorColor;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n\t    \n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 uvRaw = uv;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1. + .5*length(fragCoord.xy/iResolution.xy*2. - 1.);\n\n    float angle = radians (300. + 30.*iTime);\n    float dist = 2.5;\n    vec3 ro = vec3 (dist*cos (angle), 2., dist*sin (angle));\n    vec3 aim = vec3 (.0);\n    float zoom = 2. + .5*cos (iTime);\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    int iter = 0;\n    float d = raymarch (ro, rd, iter);\n\tfloat fog = 1. / (1. + d*d*.25);\n    float glow = float (iter) / float (MAX_ITER);\n    vec3 p = ro + d * rd;\n\n    vec3 col = shade (ro, rd, d) + pow (glow, 1.05) * vec3 (1.);\n\n    col *= fog;\n    col = col / (1. + col);\n    col *= .8 + .2*pow (16.*uvRaw.x*uvRaw.y*(1. - uvRaw.x)*(1. - uvRaw.y), .3);\n    col *= mix (1., .75, .5 + .5*cos (900.*uvRaw.y));\n    col = pow (col, vec3 (1./2.2));\n\n\tfragColor = vec4 (col, 1.);\n}\n\n", "image_inputs": [{"id": "Xts3WN", "previewfilepath": "https://soundcloud.com/demoscenemusic/techno-chip", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/demoscenemusic/techno-chip", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2SRz.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 1024, 1047, 1047, 1155], [1157, 1157, 1213, 1213, 1317], [1319, 1319, 1359, 1359, 1388], [1390, 1532, 1555, 1555, 1698], [1700, 1700, 1725, 1725, 2228], [2230, 2230, 2267, 2267, 2507], [2509, 2509, 2534, 2534, 4216], [4218, 4218, 4275, 4275, 4526], [4528, 4528, 4577, 4577, 5340], [5342, 5342, 5408, 5408, 5738], [5740, 5740, 5797, 5797, 6697]], "test": "valid"}
{"id": "ts2SWz", "name": "Basic Ray marching", "author": "KavabONga", "description": "Now this is what I wanted", "tags": ["balls"], "likes": 3, "viewed": 119, "published": "Public", "date": "1553504988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 base = vec3(0., iTime * 2., 0.);\n    vec3 pos = mod(base + vec3(uv, 2.) + vec3(.5), 10.) - vec3(5.), dir = normalize(vec3(uv, 2.));\n    \n    const int Steps = 50;\n    int i;\n    float mind = 1e30;\n    float di = 0.;\n    for (i = 0; i < Steps; i++) {\n    \tfloat d = length(pos - vec3(0., 0., 5.)) - 1.4;\n        di = di + step(d, 0.001);\n        mind = min(mind, d);\n        pos = mod(pos + d * dir + vec3(5.), 10.) - vec3(5.);\n    }\n    \n    di /= float(Steps);\n    \n    fragColor = vec4(vec2(di) * vec2(1. - mind), 1., 1.) * (di);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2SWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 685]], "test": "valid"}
{"id": "ts2Szm", "name": "Bandeira lithuania dançando", "author": "xicomano", "description": "Bandeira animada", "tags": ["lithuania"], "likes": 0, "viewed": 226, "published": "Public API", "date": "1553897615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n   \n    float balanco=(sin((2.0*iTime)+(uv.x*1.0))/6.0);\n    \n\n    // Output to screen\n    \n    if(uv.y>0.9+balanco)\n        fragColor = vec4(0,0,0,0)*1.0;\n    \n    \n    else if(uv.y>0.6+balanco)\n        fragColor = vec4(1,1,0,0)*1.0;\n    \n       \n        \n                \n                else if(uv.y>0.3+balanco)\n        fragColor = vec4(0,1,0,1)*1.0;\n                    \n                    \n\n        \n                    \n                else if(uv.y>0.01+balanco)\n        fragColor = vec4(1,0,0,0)*1.0;\n                    \n  \n                    \n  \n    \n    \n    \n                    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2Szm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 747]], "test": "valid"}
{"id": "ts2SzR", "name": "Lightning Fragment Shader", "author": "jjxtra", "description": "I am working on a potential fragment only lightning effect... Lots of different lines and experimentation, the possibilities are endless. I would love any feedback. This shader code I release as public domain, feel free to use as you see fit. ", "tags": ["line", "lines", "lightning"], "likes": 2, "viewed": 454, "published": "Public", "date": "1552763238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//--------------------------------------------------------------------------------------\n//License CC0 - http://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n//----------------------------------------------------------------------------------------\n//^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n// - jjxtra\n//\n// lines can be used as great building blocks for many things:\n// lines, curves, grid, shapes, lightning and other special effects\n// mod and sin is cheap on modern GPU\n// throw some of these in an fbm style loop and watch things get crazy\n//\n// I spent an afternoon making all types of lines\n// I am trying them out in a fragment only lightning shader\n// this is one of my hobby projects at the moment as I research where this can go\n// I'm sharing my progress publicly in the hopes of getting feedback\n// \n// * hit pause to see the structure\n//\n// TODO:\n// - Make lightning more jagged and twisted\n// - Add smaller lightnings shooting out from sides\n// - Improve patchwork / foggy areas\n// - Option to isolate to a single column or row\n// - Optimize the code\n// maybe a custom noise texture for distortion and more detail is unavoidable but I am trying to not go that route yet...\n\n#define UVSCALE 8.0\n\n// https://gamedev.stackexchange.com/questions/141916/antialiasing-shader-grid-lines\n#define AA(v) abs(fract(v) - 0.5)\n\n// take only values that are very close to 1.0\n#define CCD 0.001\n#define CC(v) clamp(floor(v + CCD), 0.0, 1.0)\n\nvec2 getpos(vec2 uv)\n{\n    uv = UVSCALE * (uv / iResolution.xy);\n    float aspect = iResolution.x / iResolution.y;\n  \tvec2 ratio = vec2(aspect, 1.0);\n  \treturn (2.0 * uv - 1.0) * ratio;\n}\n\n// http://madebyevan.com/shaders/grid/\n#define AAG(v) abs(fract(v - 0.5) - 0.5) / fwidth(v)\nfloat grid(vec2 xy)\n{\n    vec2 gridLines = AAG(xy);\n    return 1.0 - min(gridLines.x, gridLines.y);\n}\n\nfloat checkerboard(vec2 xy)\n{\n    const float scalar = 0.25;\n    vec2 xyMod = mod(xy * scalar, 1.0);\n    return float((xyMod.x < 0.5f) ^^ (xyMod.y < 0.5f));\n}\n\n// must be >= 2.0, change to modify the spacing between some of the spaced out line calls\n#define MODP 3.0\n\nfloat lightningNoise(vec2 detailPos, vec2 detailPos2, vec2 shapePos)\n{\n    const float offsetScalar = 0.91; // chaos factor\n    const float offsetScalar2 = 0.213; // detail factor\n    const float noiseMultiplier = 1.0;\n    \n    float t = iTime * 4.0;\n    float t2 = t * 1.646579370;\n    \n    // detail #1 noise offset func\n    vec2 noiseXY = AA(((detailPos + t)));\n    float noiseZ = AA(detailPos.y - t2 + noiseXY.x);\n    vec2 offset = vec2(noiseZ, noiseXY.x + noiseXY.y);\n    \n    // modify shape pos by detail #1 noise offset\n    shapePos += (offset * offsetScalar);\n    \n    // detail #2 noise offset func\n    noiseXY = AA(((detailPos2 - t2)));\n    noiseZ = AA(detailPos2.y - t2 + noiseXY.y);\n    offset = vec2(noiseXY.x + noiseXY.y, noiseZ);\n    \n    // modify shape pos by detail #2 noise offset\n    shapePos += (offset * offsetScalar2);\n    \n    // shape pos noise func, swap the x and y for horizontal lightning\n    noiseZ = AA((shapePos.x) + AA((shapePos.y)));\n    \n    // diagonal lightning\n    //noiseZ = AA((shapePos.x) + ((shapePos.y)));\n    \n    return noiseZ * noiseMultiplier;\n}\n\n// simple fbm test with two positions in a loop that are scaled\nfloat lightningNoiseFBM(vec2 p)\n{\n    p *= 0.15;\n\n    const float intensity = 10.0;\n    const float power = 4.0;\n    const float detailScalar = 0.46213;\n    const float detail2Scalar = 1.96213;\n    const float shapeScalar = 1.06213;\n    const float decay = 0.3;\n    float amplitude = 0.8;    \n    float noise = 0.0;\n    vec2 detailPos = p;\n    vec2 detailPos2 = p;\n    vec2 shapePos = p;\n    \n    for (int i = 0; i < 5; i++)\n    {\n        detailPos *= detailScalar;\n        detailPos2 *= detail2Scalar;\n        shapePos *= shapeScalar;\n        \n\t\tnoise += (lightningNoise(detailPos, detailPos2, shapePos) * amplitude);\n\n        amplitude *= decay;\n    }\n    \n    return min(1.0, intensity * pow(noise, power));\n}\n\nvec4 lightningShader(vec2 p)\n{\n    float noise = lightningNoiseFBM(p);\n    vec3 color3 = mix(vec3(0.2, 0.2, 0.8), vec3(1.0, 1.0, 1.0), noise);\n    return vec4(color3 * noise, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat color = 0.0;\n    vec2 p = getpos(fragCoord);\n    fragColor = lightningShader(p);\n    return;\n    \n    // line testing functions...\n    \n\tfloat ax = AA(p.x); // anti alias\n\tfloat ay = AA(p.y);\n\tfloat sx = sin(p.x); // sin\n\tfloat sy = sin(p.y);\n    float asx = max(0.0, sx); // sin max of 0\n    float asy = max(0.0, sy); // \n    float mx = mod(p.x, MODP); // mod of p\n    float my = mod(p.y, MODP);\n    float _max = mod(p.x + ay, MODP); // mod of p + aa\n    float may = mod(p.y + ax, MODP);\n    float msx = mod(p.x + sy, MODP); // mod of p + sin\n    float msy = mod(p.y + sx, MODP);\n    float mxl = float(mx >= 0.5 && mx < 1.5); // if mod within a range (to spread out lines)\n    float myl = float(my >= 0.5 && my < 1.5);\n    float maxl = float(_max >= 0.5 && _max < 1.5); // if mod within a range (to spread out lines)\n    float mayl = float(may >= 0.5 && may < 1.5);\n    float msxl = float(msx >= 0.5 && msx < 1.5); // if mod within a range with sin (to spread out curved lines)\n    float msyl = float(msy >= 0.5 && msy < 1.5);\n    \n    // most of these line functions below can be used inside the lightning noise function\n    // in various ways...\n    \n    //color = checkerboard(vec2(p.x, p.y));\n\t//color = clamp((sx + sy), 0.0, 1.0); // iso checkerboard\n\t//color = ceil(min(1.0, (sx + sy))); // iso checkerboard hard\n    //color = grid(vec2(p.x, p.y)); // grid lines\n    //color = floor(min(1.0, max(ax, ay) + 0.53)); // grid lines without derivatives and division\n    //color = ceil(ay * asx * asy);\n\t//color = ax; // horizontal smoothed line\n\t//color = ay; // vertical smoothed line\n    //color = ay * myl; // horizontal lines spread out\n    //color = ax * mxl; // vertical lines spread out\n\t//color = AA(p.x + p.y); // diagonal top left to bottom right lines\n\t//color = AA(p.x - p.y); // diagonal bottom left to top right lines\n\t//color = max(0.0, sin(p.x + p.y)); // more spread out diagonal top left to bottom right lines\n\t//color = max(0.0, sin(p.x - p.y)); // more spread out diagonal bottom left to top right lines\n\t//color = CC(abs(sin(p.x + p.y))); // more spread out thin hard diagonal top left to bottom right lines\n\t//color = CC(abs(sin(p.x - p.y))); // more spread out thin hard diagonal bottom left to top right lines\n\t//color = AA(ax + p.y); // horizontal jagged line\n\t//color = AA(ay + p.x); // vertical jagged line\n    //color = mayl * AA(ax + p.y); // horizontal jagged line spread out more    \n    //color = maxl * AA(ay + p.x); // vertical jagged line spread out more    \n\t//color = AA(ax + p.x); // thinner vertical line\n\t//color = AA(ay + p.y); // thinner horizontal line\n\t//color = AA(p.x + sy); // curved vertical line\n\t//color = AA(p.y + sx); // curved horizontal line\n    //color = msxl * AA(p.x + sy); // curved vertical line spread out\n    //color = msyl * AA(p.y + sx); // curved horizontal line spread out\n\t//color = max(0.0, sin(p.y + sx)); // wavy horizontal line\n\t//color = max(0.0, sin(p.x + sy)); // wavy vertical line\n\t//color = CC(sin(p.y + sx)); // wavy thin hard horizontal line\n\t//color = CC(sin(p.x + sy)); // wavy thin hard vertical line\n\t//color = CC(abs(sin(p.y + sx))); // thin hard horizontal line\n\t//color = CC(abs(sin(p.x + sy))); // thin hard vertical line\n\t//color = CC(abs(sin(p.x + ay))); // thin hard jagged vertical line\n\t//color = CC(abs(sin(p.y + ax))); // thin hard jagged horizontal line\n    \n\tfragColor = vec4(color, color, color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2SzR.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1593, 1705, 1727, 1727, 1892], [1894, 1986, 2007, 2007, 2087], [2089, 2089, 2118, 2118, 2247], [2249, 2357, 2427, 2427, 3450], [3452, 3516, 3549, 3549, 4228], [4230, 4230, 4260, 4260, 4412], [4414, 4414, 4469, 4469, 7878]], "test": "valid"}
{"id": "ts2XRR", "name": "RayTracing tutorial - step 8", "author": "BrunoLevy", "description": "Refractions", "tags": ["raytracing"], "likes": 2, "viewed": 410, "published": "Public API", "date": "1552754527", "time_retrieved": "2021-10-01T00:00:00", "image_code": " \nconst float FARAWAY=1e30;\nconst float EPSILON=1e-5;\n\n// The viewing parameters\n// Gathers all parameters needed to launch primary rays\nstruct Camera {\n    vec3 Obs;    // The position of the observer\n    vec3 View;   // Unit vector, points to the target\n    vec3 Up;     // Unit vector, vertical direction\n    vec3 Horiz;  // Unit vector, horizontal direction\n    float H;     // Screen height in pixels\n    float W;     // Screen width in pixel\n    float z;     // offset of the screen along View\n};\n\n// \\brief A ray, in parametric form. \nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\n// \\brief Initializes a Camera\n// \\param[in] Obs the position of the observer\n// \\param[in] Target the point that will be in the center\n// \\param[in] aperture the aperture angle in degrees\n// \\return the initialized Camera\nCamera camera(in vec3 Obs, in vec3 Target, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(Target - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\n// \\brief Launches a primary Ray\n// \\param[in] C the Camera\n// \\param[in] XY the pixel coordinates in [0,W-1] x [0,H-1]\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\n// \\brief A sphere, defined by its center and radius\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\n// \\brief Material gathers all shading properties\nstruct Material {\n    vec3 Kd;       // diffuse color\n    vec3 Ke;       // emissive color\n    vec3 Kr;       // reflective material\n    float checker; // checkerboard size\n    vec3 Ks;       // specular\n    float s;       // specular factor\n    vec3 Kt;       // transmission\n    float n;       // refraction index\n};\n\n// \\brief Shorthand for the zero vector\nconst vec3 zero3 = vec3(0.0, 0.0, 0.0);\n\n// \\brief Creates a diffuse material\n// \\param[in] Kd the diffuse color\n// \\return the created Material\nMaterial diffuse(in vec3 Kd) {\n   return Material(Kd, zero3, zero3, 0.0, zero3, 0.0, zero3, 0.0);\n}\n\n// \\brief Creates a light (emissive) material\n// \\param[in] Ke the color of the light\n// \\return the created Material\nMaterial light(in vec3 Ke) {\n   return Material(zero3, Ke, zero3, 0.0, zero3, 0.0, zero3, 0.0);\n}\n\n// \\brief Creates a mirror material\n// \\param[in] Kd the diffuse color\n// \\param[in] Kr the reflection coefficient\n// \\return the created Material\nMaterial mirror(in vec3 Kd, in vec3 Kr) {\n   return Material(\n     Kd, zero3, Kr, 0.0, vec3(1.0, 1.0, 1.0), 30.0, zero3, 0.0\n   );\n}\n\nMaterial transparent(in vec3 Kd, in vec3 Kt) {\n   return Material(\n     Kd, zero3, zero3, 0.0, vec3(1.0, 1.0, 1.0), 30.0, Kt, 0.9\n   );\n}\n\n\n\n// \\brief Creates a shiny material\n// \\param[in] Kd the diffuse color\n// \\param[in] Ks the specular coefficient\n// \\return the created Material\nMaterial shiny(in vec3 Kd, in vec3 Ks) {\n   return Material(Kd, zero3, zero3, 0.0, Ks, 30.0, zero3, 0.0);\n}\n\n// \\brief Creates a checkerboard material\n// \\param[in] Kd the diffuse color\n// \\param[in] sz size of the checkers\n// \\return the created Material\nMaterial checkerboard(in vec3 Kd, in float sz) {\n   return Material(Kd, zero3, zero3, sz, zero3, 0.0, zero3, 0.0);\n}\n\n// \\brief An Object, with a shape (Sphere) and a Material\nstruct Object {\n   Sphere sphere;\n   Material material;\n};\n\n// \\brief The scene is stored in a global array\nObject scene[23];\n\n// \\brief Initializes the scene\nvoid init_scene() {\n\n   scene[0] = Object(\n      Sphere(vec3(0.0, 0.0, 0.0),0.5), \n  //    transparent(vec3(0.2, 0.5, 0.2), vec3(0.3, 0.7, 1.0))\n        mirror(vec3(0.2, 0.5, 0.2), vec3(0.9, 0.9, 0.9))\n   );\n\n   scene[1] = Object(\n      Sphere(vec3(0.0, 0.0, -10000.0),9999.5),\n      checkerboard(vec3(1.0, 0.2, 0.5), 0.1)\n   );\n\n   scene[2] = Object(\n      Sphere(vec3(1.0, 0.0, 1.0),0.02),\n      light(vec3(1.0, 1.0, 1.0)) \n   );\n\n   for(int i=0; i<20; ++i) {\n     float beta = float(iFrame)/30.0 + float(i)*6.28/19.0;\n     float s = sin(beta);\n     float c = cos(beta); \n\n       \n       if(((i >> 2) & 1) == 0) {   \n       scene[i+3] = Object(\n        Sphere(vec3(0.7*s, 0.7*c, 0.0),0.1), \n         mirror(vec3(0.2, 0.5, 0.2), vec3(0.9, 0.9, 0.9))\n        );\n       } else {\n       scene[i+3] = Object(\n        Sphere(vec3(0.7*s, 0.7*c, 0.0),0.1), \n         transparent(vec3(0.2, 0.5, 0.2), vec3(0.3, 0.3, 1.0))\n       );\n           \n       }\n   }\n}\n\n// \\brief Computes a Ray Sphere intersection\n// \\param[in] R the Ray\n// \\param[in] S the Sphere\n// \\param[out] t the intersection parameter\n// \\retval true if there was an intersection\n// \\retval false otherwise\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nbool intersect_sphere_2(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b+sqrt(delta)) / (2.0*a);\n   return true;\n}\n\n\n\n// \\brief Computes a reflected Ray\n// \\param[in] I the incident Ray\n// \\param[in] P the point at which the reflection occurs\n// \\param[in] N the normal at P\n// \\return the reflected Ray\nRay reflect_ray(in Ray I, in vec3 P, in vec3 N) {\n    return Ray(\n      P,\n      -2.0*dot(N,I.Dir)*N + I.Dir\n   );\n}\n\nRay refract_ray(in Ray I, in vec3 P, in vec3 N, in float n) {\n   return  Ray(\n     P,\n     refract(normalize(I.Dir), N, n)\n   );\n}\n\n// \\brief Tests whether a Ray is in shadow\n// \\param[in] R a Ray that connects a point to a lightsource\n// \\retval true if the point is in shadow w.r.t. the lightsource\n// \\retval false otherwise\nbool shadow(in Ray R) {\n   for(int i=0; i<scene.length(); ++i) {\n        float t;\n        if(\n          scene[i].material.Ke == vec3(0.0, 0.0, 0.0) &&\n          intersect_sphere(R, scene[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\n// \\brief Computes the lighting\n// \\param[in] P the intersection point\n// \\param[in] N the normal to the intersected surface at P\n// \\param[in] material the material\n// \\param[in] Ray the incident Ray\n// \\return the computed color\nvec3 lighting(\n   in vec3 P, in vec3 N, in Material material, in Ray R\n) {\n\n   // If it is a lightsource, then return its color\n   // (and we are done) \n   if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n      return material.Ke;\n   }  \n\n   vec3 result = vec3(0.0, 0.0, 0.0);\n\n   // Compute the influence of all lightsources\n   for(int i=0; i<scene.length(); ++i) {\n      if(scene[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n         Ray R2 = Ray(P, scene[i].sphere.Center);\n         if(!shadow(R2)) {\n           vec3 E = scene[i].sphere.Center - P;\n  \n           // Diffuse lighting\n           float lamb = max(0.0, dot(E,N) / length(E));\n           vec3 Kd = material.Kd;\n           if(material.checker != 0.0 && \n              sin(P.x/material.checker)*\n              sin(P.y/material.checker) > 0.0) {\n               Kd = vec3(1.0, 1.0, 1.0) - Kd;\n           }\n           result += lamb * Kd * scene[i].material.Ke;\n\n           // Specular lighting\n           if(material.Ks != zero3) {\n               vec3 Er = 2.0*dot(N,E)*N - E;\n               vec3 View = R.Origin - P;\n               float spec=max(dot(Er,View),0.0);\n               spec /= sqrt(dot(Er,Er)*dot(View,View));\n               spec = pow(spec, material.s);\n               result += \n                  spec * material.Ks * scene[i].material.Ke;\n           }\n         }\n      }\n   }\n\n   return result;\n}\n\n// \\brief Computes the nearest intersection along a Ray\n// \\param[in] R the ray\n// \\param[out] P the intersection point\n// \\param[out] N the normal to the intersected surface at P\n// \\param[out] material the material of the intersected object\nbool nearest_intersection(\n   in Ray R, \n   out vec3 P, out vec3 N, out Material material\n) {\n   const float FARAWAY=1e30; \n   float t = FARAWAY;\n\n   for(int i=0; i<scene.length(); ++i) {\n       float cur_t;\n       if(\n          intersect_sphere(R, scene[i].sphere, cur_t) \n          && cur_t < t && cur_t > EPSILON \n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - scene[i].sphere.Center);\n           material = scene[i].material;\n       } else if( \n          intersect_sphere_2(R, scene[i].sphere, cur_t) \n          && cur_t < t && cur_t > EPSILON       \n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = -normalize(P - scene[i].sphere.Center);\n           material = scene[i].material;\n           material.n = 1.0 / material.n;\n           material.Kt = vec3(1.0, 1.0, 1.0) * pow(length(R.Dir) / (4.0*t), 2.0);\n       }\n   }\n   return (t != FARAWAY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   // Yes, it is a bit stupid to call this for each pixel,\n   // but well, does not cost that much...\n   init_scene();\n\n   float beta = float(iFrame)/150.0;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   // Initialize the Camera (and make it orbit around the\n   // origin)\n   Camera C = camera(\n       vec3(2.0*c, 2.0*s, 0.5),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n\n   // Lauch the primary ray that corresponds to this pixel\n   Ray R = launch(C, fragCoord);\n   \n   \n   fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n   vec3 P;  // Current intersected point\n   vec3 N;  // Normal to the intersected object at P\n   Material material; // Material of the intersected object\n \n   // Compute up to 5 ray bounces\n   vec3 Kr_cumul = vec3(1.0, 1.0, 1.0);\n   for(int k=0; k<5; ++k) {\n       if(nearest_intersection(R, P, N, material)) {\n          fragColor.rgb += Kr_cumul * lighting(P,N,material,R);\n          if(material.Kr != zero3) {\n             Kr_cumul *= material.Kr;\n             R = reflect_ray(R, P, N);\n          } else if(material.Kt != zero3) {\n             Kr_cumul *= material.Kt;\n             R = refract_ray(R, P, N, material.n);\n          } else {\n            break;\n          }\n       } else {\n          fragColor.rgb += Kr_cumul * vec3(0.5, 0.5, 1.0);\n          break;\n       }\n   }  \n}\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2XRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[590, 813, 876, 876, 1174], [1176, 1296, 1333, 1333, 1430], [1984, 2088, 2118, 2118, 2187], [2189, 2307, 2335, 2335, 2404], [2406, 2553, 2594, 2594, 2685], [2687, 2687, 2733, 2733, 2824], [2828, 2972, 3012, 3012, 3079], [3081, 3228, 3276, 3276, 3344], [3531, 3563, 3582, 3582, 4515], [4517, 4729, 4788, 4788, 5054], [5056, 5056, 5117, 5117, 5383], [5387, 5573, 5622, 5622, 5689], [5691, 5691, 5752, 5752, 5821], [5823, 6019, 6042, 6042, 6326], [6328, 6559, 6633, 6711, 7920], [7922, 8165, 8258, 8258, 9099], [9101, 9101, 9158, 9261, 10470]], "test": "valid"}
{"id": "ts2XWD", "name": "Hexagon II. (Moving)", "author": "deerfeeder", "description": "AoC tut", "tags": ["tutorial"], "likes": 4, "viewed": 294, "published": "Public API", "date": "1553884351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float skew = 1.73;\nfloat blur = 0.01;\nfloat scale = 0.001;\nfloat HexDist(vec2 p) {\n    // vertical mirror\n\tp = abs(p);\n    \n    // hex skew;\n    float c = dot(p, normalize(vec2(1,skew)));\n    // vertical sides\n    c = max(c, p.x);\n    \n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t// middle & squared \n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\t\n    // Hex Gradient\n    //col += HexDist(uv);\n\t\n    // Animated Hex Gradient\n    float speed = 2.0;\n    col += 0.8 * sin(HexDist(uv) * 80.+iTime * speed);\n\n\n    // width\n    col += smoothstep(scale+blur,scale,HexDist(uv));\n\n\t\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2XWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 82, 105, 251], [254, 254, 311, 336, 712]], "test": "valid"}
{"id": "ts2XWW", "name": "Ray Marching onwards...", "author": "peterparnes", "description": "Learning ray marching ", "tags": ["raymarching"], "likes": 1, "viewed": 79, "published": "Public", "date": "1553862018", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    \n    float t = iTime;\n    \n    // ground plane\n    float pd = p.y;\n    \n    // rotating box\n    //vec3 bp = p;\n    //bp -= vec3(0,.75,3);\t\t// translation\n    // bp.xz *= Rot(iTime);\t\t// rotation\n    // float rotate = dBox(bp, vec3(.75));\n    \n    /*float morph = mix(\n        length(p-vec3(4,1,2))-1., \n        dBox(p-vec3(4,1,2), vec3(1,1,1)), \n        sin(t)*.5+.5\n    );*/\n    \n    float d = pd;\n\n    /*float blend = smin(\n        length(p-vec3(0,1,-3))-.75,\n        length(p-vec3(sin(t),1.5,-3))-.5,\n        .2\n    );\n    \n    float blend2 = smin(\n        length(p-vec3(0,1,3))-.75,\n        length(p-vec3(sin(t),1.5,3))-.5,\n        .2\n    );*/\n    \n    float blend;\n   \tfor(int j = -1; j<= 1; j++) {\n    \tfor(int i = -1; i <= 1; i++) {\n      \t\tblend = smin(\n        \t\tlength(p-vec3(j*2,1,i*2))-0.8,\n        \t\tlength(p-vec3(float(j*2)+sin(t)/1.5,\n                              1.8-abs(float(i))/9.,float(i)*1.2))-.5,\n        \t\t.2\n    \t\t); \n            d = min(d, blend);\n    \t}\n    }\n    \n    \n\n    //d = min(d, pd);\n    \n    // d = min(d, rotate);\n    //d = min(d, blend);\n    //d = min(d, blend2);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = abs( GetDist(p) );\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3, 5, 4);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, 5);\n    //ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(iTime*.2-m.x*6.2831);\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p);\n    \tcol = vec3(sin(dif)*1.2,0.,0.);\n        \n        if(dif<0.) {\n       \t  col = texture( iChannel0, vec2(dif) ).xyz;\n        }   \n        \n        // col = vec3(sin(dif),sin(dif/2.),sin(dif/4.));\n\n    }\n    \n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2XWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 163], [165, 165, 206, 206, 297], [299, 299, 349, 349, 517], [519, 519, 570, 570, 882], [884, 884, 915, 915, 983], [985, 985, 1013, 1013, 1094], [1097, 1097, 1120, 1120, 2248], [2250, 2250, 2284, 2284, 2497], [2499, 2499, 2523, 2523, 2713], [2715, 2715, 2739, 2739, 3009], [3011, 3011, 3053, 3053, 3248], [3252, 3252, 3309, 3309, 3953]], "test": "error"}
{"id": "tsBSDh", "name": "3D Line Drawing", "author": "gaz", "description": "inspired  https://www.shadertoy.com/view/tslXRj", "tags": ["3d"], "likes": 7, "viewed": 450, "published": "Public", "date": "1553607876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//inspired  https://www.shadertoy.com/view/tslXRj\nvec3 lookat(vec3 p, vec3 eye, vec3 target, vec3 up)\n{\n\tvec3 w = normalize(target-eye), u = normalize(cross(w,up));\n\treturn vec3(dot(p,u), dot(p,cross(u,w)), dot(p,w));\n}\n\nvec2 rotate(vec2 p, float theta)\n{\n    return p * cos(theta) + vec2(-p.y, p.x) * sin(theta);\n}\n\nvec3 rotate(vec3 p,vec3 axis,float theta)\n{\n    vec3 v = cross(axis,p), u = cross(v, axis);\n    return u * cos(theta) + v * sin(theta) + axis * dot(p, axis);   \n}\n\n\nfloat dePoint(vec3 ro, vec3 rd, vec3 a)\n{\n    return length(cross(a-ro, rd));\n}\n\nfloat deLine(vec3 ro, vec3 rd, vec3 a, in vec3 b)\n{\n    // http://www.sousakuba.com/Programming/gs_two_lines_intersect.html\n    vec3 ab =normalize(b-a),ao = a-ro;\n\tfloat d0 = dot(rd, ab), d1 = dot(rd, ao), d2 = dot(ab, ao);\n\tfloat len = (d0*d1-d2)/(1.0-d0*d0);\n    len= clamp(len,0.0,length(b-a));\n    vec3 p = a+ab*len;\n    return length(cross(p-ro, rd));\n}\n\nvec3 circle(vec3 p, vec3 nor, float r, float t)\n{\n    vec3 u = normalize(cross(nor,vec3(0,1,0))) * r;\n    return rotate(u, nor, t*6.283) + p;\n}\n\n\nfloat deCircle(vec3 ro,vec3 rd, vec3 pos, vec3 nor, float r)\n{\n    vec3 q;\n \tfloat ITR = 30.0, pitch = 1.0, t = 0.5, de = 1e10;   \n    for(int j=0; j<2; j++)\n    {\n        float t0 = t-pitch*0.5;\n        pitch /= ITR;\n        for(float i=0.0; i<ITR; i++) \n        {\n            t0 += pitch;\n            vec3 p = circle(pos,nor,r,t0);\n            float de0=dePoint(ro,rd,p);\n            if (de0<de)\n            {\n                de = de0;\n                t=t0;\n                q = ro+rd*dot(p-ro, rd);\n            }       \n        }\n    }\n    return de;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,7);\n    ro.xz = rotate(ro.xz, iTime*0.3);\n    vec3 ta = vec3(0,0,0);\n    vec3 rd = lookat(normalize(vec3(uv, 2.0)),ro,ta,vec3(0,1,0));\n    \n    vec3 col = vec3(0);\n    float de;\n    \n    vec3 o = vec3(0,0,3);\n    vec3 n = normalize(vec3(0,0.3,-1));\n    vec3 p = vec3(0);\n    float r = 2.0;\n    \n    de=dePoint(ro,rd,p);\n    col = mix(vec3(1,1,0), col, smoothstep(0.0,0.3,de));\n    \n    for(float i=0.0; i<5.0; i++)\n    {\n        vec3 a =circle(p,n,r,i*2.0/5.0); \n        vec3 b =circle(p,n,r,(i+1.0)*2.0/5.0); \n    \tde=deLine(ro, rd, a,b);\n    \tcol = mix(vec3(1.0,0.6,0.1), col, smoothstep(0.05,0.15+sin(iTime*3.0)*0.1,de));\n    }\n  \n    de = deCircle(ro, rd,  p, n, 2.0);\n    col = mix(vec3(1,1,1), col, 1.0-0.05/de);\n    \n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBSDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 103, 103, 219], [221, 221, 255, 255, 315], [317, 317, 360, 360, 479], [482, 482, 523, 523, 561], [563, 563, 614, 686, 921], [923, 923, 972, 972, 1066], [1069, 1069, 1131, 1131, 1623], [1625, 1625, 1682, 1682, 2523]], "test": "valid"}
{"id": "tsBSDz", "name": "Knit", "author": "dr2", "description": "3D knit pattern", "tags": ["loop", "knot", "weave", "knit"], "likes": 9, "viewed": 339, "published": "Public API", "date": "1553422359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Knit\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// 3D knit pattern (earlier 2D version is FabriceNeyret2's \"Weaving\")\n\nfloat PrTorus4Df (vec3 p, float ri, float rc);\nvec2 Rot2D (vec2 q, float a);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir;\nvec2 bSize, cId;\nfloat dstFar, tCur, cDiam;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p.y -= 0.5;\n  q = p;\n  q += vec3 ((q.z + abs (q.x) > 0.25) ? vec2 (0., -0.25) :\n     vec2 (((q.x > 0.) ? -0.5 : 0.5), 0.25), -0.25 * q.z * q.z).xzy;\n  d = PrTorus4Df (q.xzy, 0.035, 0.5 * cDiam);\n  DMIN (1);\n  q = p;\n  q.z -= cDiam;\n  q += vec3 ((q.z + abs (q.x) > 0.25) ? vec2 (0., -0.25) :\n     vec2 (((q.x > 0.) ? -0.5 : 0.5), 0.25), -0.25 * q.z * q.z).xzy;\n  d = PrTorus4Df (q.xzy, 0.035, 0.5 * cDiam);\n  DMIN (2);\n  q = p;\n  q.z += cDiam;\n  q += vec3 ((q.z + abs (q.x) > 0.25) ? vec2 (0., -0.25) :\n     vec2 (((q.x > 0.) ? -0.5 : 0.5), 0.25), -0.25 * q.z * q.z).xzy;\n  d = PrTorus4Df (q.xzy, 0.035, 0.5 * cDiam);\n  DMIN (2);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  dHit = eps;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  ro.xz /= bSize;\n  rd.xz /= bSize;\n  rdi.xz = 1. / rd.xz;\n  for (int j = 0; j < 180; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz);\n    s = (cId + step (0., rd.xz) - p.xz) * rdi.xz;\n    d = min (ObjDf (vec3 (bSize * (p.xz - cId - 0.5), p.y).xzy), abs (min (s.x, s.y)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  p.xz -= bSize * (cId + 0.5);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 FlatCvHt (vec2 p)\n{\n  float d, h;\n  p = mod (p, vec2 (1., 2. * cDiam)) - 0.5 * vec2 (1., 2. * cDiam);\n  d = length (p + ((p.y + abs (p.x) > 0.25) ? vec2 (0., -0.25) :\n     vec2 (((p.x > 0.) ? -0.5 : 0.5), 0.25))) - 0.5 * cDiam;\n  h = 0.6 * (1. - smoothstep (-0.01, 0.01, abs (d) - 0.05)) * (1. + 2. * p.y * p.y);\n  return vec2 (h, d);\n}\n\nvec3 FlrCol (vec2 p, vec3 col)\n{\n  vec3 c;\n  vec2 w, w1, w2;\n  p += 0.2 * sin (0.5 * tCur + vec2 (0.5 * pi, 0.));\n  w1 = FlatCvHt (p);\n  w2 = FlatCvHt (p + vec2 (0., cDiam));\n  if (w1.x > w2.x) {\n    c = vec3 (0.7, 0.65, 0.);\n    w = w1;\n  } else {\n    c = vec3 (0.7, 0.7, 0.75);\n    w = w2;\n  }\n  c *= w.x * (0.2 + 0.8 * cos (0.5 * pi * w.y / 0.06));\n  col = max (c, col);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, bgCol;\n  float dstObj, dstFlr, nDotL;\n  cDiam = sqrt (0.5);\n  bSize = vec2 (1., 2. * cDiam);\n  dstObj = ObjRay (ro, rd);\n  bgCol = vec3 (0.8, 0.5, 0.6) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    col = (idObj == 1) ? vec3 (0.7, 0.65, 0.) : vec3 (0.7, 0.7, 0.75);\n    vn = ObjNf (ro);\n    vn = VaryNf (128. * ro, vn, 0.3);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col * (0.2 + 0.8 * nDotL * nDotL) +\n       0.3 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.5, 1., dstObj / dstFar));\n  } else if (rd.y < 0.) {\n    dstFlr = - ro.y / rd.y;\n    if (dstFlr < dstFar) {\n      ro += dstFlr * rd;\n      col = FlrCol (ro.xz, bgCol);\n      col = mix (col, bgCol, smoothstep (0.5, 1., dstFlr / dstFar));\n    } else col = bgCol;\n  } else {\n    col = bgCol;\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.25 * pi;\n  if (mPtr.z > 0.) {\n    az += 1.5 * pi * mPtr.x;\n    el += 0.6 * pi * mPtr.y;\n  } else {\n    az -= 0.01 * pi * tCur;\n    el -= 0.15 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.5 * pi, -0.1 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -10.);\n  dstFar = 40.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 5.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrTorus4Df (vec3 p, float ri, float rc)\n{\n  vec2 q;\n  q = vec2 (length (p.xy) - rc, p.z);\n  q *= q;\n  return sqrt (sqrt (dot (q * q, vec2 (1.)))) - ri;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBSDz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[112, 453, 475, 475, 1173], [1175, 1175, 1208, 1208, 1743], [1745, 1745, 1766, 1766, 1989], [1991, 1991, 2015, 2015, 2332], [2334, 2334, 2366, 2366, 2723], [2725, 2725, 2760, 2760, 3667], [3684, 3684, 3740, 3740, 4982], [4984, 4984, 5031, 5031, 5143], [5145, 5145, 5175, 5175, 5288], [5322, 5322, 5346, 5346, 5476], [5478, 5478, 5503, 5503, 5689], [5691, 5691, 5720, 5720, 5932], [5934, 5934, 5973, 5973, 6153]], "test": "error"}
{"id": "tsBXRW", "name": "Complex Atanh", "author": "mla", "description": "Fun with atanh.\n\nMouse changes rotation parameters.", "tags": ["domain", "complex", "mapping", "atanh"], "likes": 20, "viewed": 535, "published": "Public API", "date": "1553035497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Complex Inverse Hyperbolic Tangent\n//\n// Domain mapping of sums of complex atanh.\n// Care needed for alignment across branch cuts.\n////////////////////////////////////////////////////////////////////////////////\n\nfloat A = 7.0, B = 2.0; // Rotation angle is atan(B,A)\nfloat K = 1.0;          // Extra subdivisions\nfloat scale = 1.5;\nfloat PI = 3.14159;\n\n//#define CIRCLE\n#define CHECKERBOARD\n\n// Complex functions\nvec2 cmul(vec2 z, vec2 w) {\n  //return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// Iq's hsv function, but just for hue.\nvec3 h2rgb(float h ) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= 20.0;\n    A = floor(m.x), B = floor(m.y);\n  }\n  //float theta = atan(B,A);\n  //vec2 rot = vec2(cos(theta),sin(theta));\n  vec2 rot = vec2(A,B);\n  //z = clog(z);\n  //z = 2.0*catanh(z);\n  z = /*0.5*clog(z) +*/ catanh(-0.5*z) + catanh(cmul(vec2(cos(0.1*iTime),sin(0.1*iTime)), z));\n  z /= PI; // Alignment\n  float px = 0.5*fwidth(z.x);\n  z.y = mod(z.y+0.1*iTime,1.0);\n  //px = 0.5*fwidth(length(z));\n  px *= K*length(rot);\n  z = K*cmul(rot,z);\n  //z.y += 2.0*iTime;\n  vec2 index = round(z);\n  z -= index;\n  float hx = index.x/(K*(B==0.0 ? 1.0 : B)); // Color for column\n  float hy = index.y/(K*(A==0.0 ? 1.0 : A)); // Color for row\n#if defined CIRCLE\n  float d = length(z); // Circle\n#else\n  float d = max(abs(z.x),abs(z.y)); // Square\n#endif  \n  vec3 colx = h2rgb(hx);\n  vec3 coly = h2rgb(hy+0.618);\n#if defined CHECKERBOARD\n  float k = z.x*z.y;\n  vec3 col = mix(colx,coly, smoothstep(-px,px,sign(k)*min(abs(z.x),abs(z.y)))); // Checkerboard\n#else  \n  vec3 col = mix(coly,colx, smoothstep(-px,px,d-0.15)); // Concentric\n#endif\n  col *= 1.0-smoothstep(-px,px,d-0.4);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[477, 498, 525, 577, 608], [610, 610, 629, 629, 680], [682, 682, 709, 709, 737], [739, 739, 758, 758, 820], [822, 853, 874, 874, 926], [928, 968, 990, 990, 1123], [1125, 1125, 1182, 1182, 2505]], "test": "valid"}
{"id": "tsBXWm", "name": "RationalBézierCurves", "author": "felipunkerito", "description": "Porting some research I've been doing for work to shaders.\nNext one I'll post(whenever I get my head around them): [url=https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline]NURBS[/url]\nMove mouse to change the blue point.\nEdit: Added construction.", "tags": ["2d", "bezier", "curves", "rational"], "likes": 7, "viewed": 591, "published": "Public API", "date": "1554009237", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// By Felipe Gutierrez, license: MIT as I don't give a f*** about what you do with this.\n// Uncomment or comment for the respective degree of curve(shitty implementation you must turn\n// only one of the Degrees at a time):\n// Degree 2\n//#define LINEAR    \n// Degree 3\n//#define QUADRATIC \n// Degree 4\n#define CUBIC    \n\n// Uncomment or comment for the construction process of the curve.\n// Degree 3\n//#define QUADRATICCONSTRUCT   \n// Degree 4\n#define CUBICCONSTRUCT    \n\nfloat lerp( float a, float b, float t )\n{\n\n\treturn mix( a, b, t );\n\n}\n\nvec2 lerp( vec2 a, vec2 b, float w1, float w2, float t, out float w )\n{\n\n    float temp = ( 1.0 - t ) * w1, tempO = w2 * t;\n    w = temp + tempO;\n    \n\treturn ( temp * a + tempO * b ) /\n            w;\n\n}\n\nfloat quad( float P0, float P1, float P2, float W0, float W1, float W2, float t )\n{\n\n    float ber = 1.0 - t, berO = t * t;\n    \n\treturn ( ber * ber * W0 * P0                 +\n\t\t   2.0 * ( t * P1 * W1 ) * ber           +\n\t\t   berO * P2 * W2 ) / \n           ( ber * ber * W0                      +\n\t\t   2.0 * ( t * W1 ) * ber                +\n\t\t   berO * W2 );\n\n}\n\nvec2 quad( vec2 P0, vec2 P1, vec2 P2, float W0, float W1, float W2, float t )\n{\n\n\treturn vec2( quad( P0.x, P1.x, P2.x, W0, W1, W2, t ),\n\t\t         quad( P0.y, P1.y, P2.y, W0, W1, W2, t )\n\t\t        );\n\n}\n\nfloat cub( float P0, float P1, float P2, float P3, float W0, float W1, float W2, float W3,\n\t         float t )\n{\n\n\tfloat ber = 1.0 - t, berO = t * t;\n\n\treturn ( pow( ber, 3.0 ) * P0 * W0           +\n\t\t     3.0 * ( ber * ber ) * t * P1 * W1   +\n\t\t     3.0 * ( ber ) * berO * P2 * W2      +\n\t\t     pow( t, 3.0 ) * P3 * W3\n           ) /\n           ( pow( ber, 3.0 ) * W0                +\n\t\t     3.0 * ( ber * ber ) * t * W1        +\n\t\t     3.0 * ( ber ) * berO * W2           +\n\t\t     pow( t, 3.0 ) * W3\n           ) ;\n\n}\n\nvec2 cub( vec2 P0, vec2 P1, vec2 P2, vec2 P3, float W0, float W1, float W2, float W3, float t )\n{\n\n\treturn vec2( cub( P0.x, P1.x, P2.x, P3.x, W0, W1, W2, W3, t ),\n\t\t         cub( P0.y, P1.y, P2.y, P3.y, W0, W1, W2, W3, t )\n\t\t        );\n\n}\n\nfloat cir( vec2 uv, float r, float b )\n{\n\n\treturn smoothstep( r, r - b, length( uv ) );\n\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdLine( p, a, b );\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tvec2 mou = iMouse.xy / iResolution.y;\n    \n    mou = iMouse.x < 0.1 ? vec2( 1.3, 0.2 ) : mou;\n\n    // r = size of interpolation, rO = size of points.\n\tfloat r = 0.02, rO = 0.015, b = 0.1, bO = 0.005;\n\n\tvec3 col = vec3( 0 );\n\n    // Points coordinates:\n\tvec2 A = uv - vec2( 0.1, 0.5 );\n    vec2 B = uv - vec2( 0.5, 0.9 );\n    vec2 C = uv - mou;\n\tvec2 D = uv - vec2( 1.7, 0.5 );\n    \n    // Weights for the Bézier. This allows us to get perfect Conic Sections from\n    // Bézier Curves.\n    float w0 = 1.0, w1 = 2.0, w2 = 1.0, w3 = 1.0;\n    \n    float t = 0.5 + sin( iTime * 0.5 ) * 0.5;\n    float tO = ( 1.0 - t );\n    \n    #ifdef QUADRATICCONSTRUCT   \n    // Process visualization.\n    float wOut = 0.0, wOutOne = 0.0;\n    col = line( col, A, C, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.6) );\n    vec2 inter = lerp( A, C, w0, w1, t, wOut );\n    col += cir( inter, rO, bO ) * vec3( 1, 0.25, 0 );\n    col = line( col, D, C, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.6) );\n    vec2 interT = lerp( D, C, w2, w1, tO, wOutOne );\n    col += cir( interT, rO, bO ) * vec3( 1, 0.25, 0 );\n    col = line( col, inter, interT, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.6) );\n    \n    #else\n    #endif\n    \n    #ifdef CUBICCONSTRUCT   \n    // Show construction.\n    float wOut = 0.0, wOutOne = 0.0, wOutTwo = 0.0, wOutThree = 0.0, wOutFour = 0.0;\n    \n    col = line( col, A, B, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n    vec2 inter = lerp( A, B, w0, w1, t, wOut );\n    col += cir( inter, rO, bO ) * vec3( 1, 1, 0 );\n    col = line( col, B, C, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n\n    vec2 interT = lerp( B, C, w1, w2, t, wOutOne );\n    col += cir( interT, rO, bO ) * vec3( 1, 1, 0 );\n    col = line( col, C, D, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n\n    vec2 interTh = lerp( C, D, w2, w3, t, wOutTwo );\n    col += cir( interTh, rO, bO ) * vec3( 1, 1, 0 );\n\n    vec2 interN = lerp( inter, interT, wOut, wOutOne, t, wOutThree );\n    col = line( col, inter, interT, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n    col += cir( interN, rO, bO ) * vec3( 1, 0.25, 0 );\n\n    vec2 interNT = lerp( interT, interTh, wOutOne, wOutTwo, t, wOutFour );\n    col = line( col, interT, interTh, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n    col += cir( interNT, rO, bO ) * vec3( 1, 0.25, 0 );\n    col = line( col, interN, interNT, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n\t#else\n    #endif\n    \n    // Notice the relation for the for loop:\n    //                                       if the exit condition is 10,\n    //                                       the multiplication of i is 0.1\n    // And yes Fabrice I know I can loop on floats :)\n    // Iteration exit condition and multiplier.\n    const int n = int( 1e+3 );\n    const float m = 1e-3; float wO = 0.0;\n\tfor( int i = 0; i < n; ++i )\n\t{\n\n        #ifdef LINEAR\n\t\tcol += cir( lerp( A, C, w0, w1, float( i ) * m, wO ), r, b );\n        #else\n        #endif\n        #ifdef QUADRATIC\n\t\tcol += cir( quad( A, C, D, w0, w1, w2, float( i ) * m ), r, b );\n        #else\n        #endif\n        #ifdef CUBIC\n        col += cir( cub( A, B, C, D, w0, w1, w2, w3, float( i ) * m ), r, b );\n\t\t#else\n        #endif\n\n\t}\n    \n    // Visualizing time t parameter of the basis-functions:\n    \n    #ifdef LINEAR\n    col += cir( lerp( A, C, w0, w1, t, wO ), rO, bO ) * vec3( 1, 0, 0 );\n    #else\n    #endif\n    #ifdef QUADRATIC\n    col += cir( quad( A, C, D, w0, w1, w2, t ), rO, bO ) * vec3( 1, 0, 0 );\n    #else\n    #endif\n    #ifdef CUBIC\n    col += cir( cub( A, B, C, D, w0, w1, w2, w3, t ), rO, bO ) * vec3( 1, 0, 0 );\n    #else\n    #endif\n\n    // PointA.\n    col += cir( A, rO, bO ) * vec3( 1, 0, 0 );\n    // PointC.\n\tcol += cir( C, rO, bO ) * vec3( 0, 0, 1 );\n    #ifdef LINEAR\n    #else\n    #ifdef QUADRATIC\n    // PointB.\n    #else\n\tcol += cir( B, rO, bO ) * vec3( 0, 1, 0 ); \n    #endif\n    // PointD.\n\tcol += cir( D, rO, bO ) * vec3( 0, 1, 1 );\n\t#endif\n\tfragColor = vec4( col, 1.0 );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBXWm.jpg", "access": "shaders20k", "license": "mit", "functions": [[387, 542, 613, 613, 745], [747, 747, 830, 830, 1110], [1112, 1112, 1191, 1191, 1314], [1316, 1316, 1428, 1428, 1835], [1837, 1837, 1934, 1934, 2075], [2077, 2077, 2117, 2117, 2167], [2169, 2169, 2218, 2218, 2337], [2339, 2339, 2422, 2422, 2556], [2559, 2559, 2616, 2616, 6618]], "test": "valid"}
{"id": "tsfSDl", "name": "ShrinkHelix", "author": "japoneris", "description": "Helix pattern for test", "tags": ["helicoidalhelixshrink"], "likes": 2, "viewed": 110, "published": "Public", "date": "1552501279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat line(vec2 uv, vec2 dir, vec2 ptx, float w) {\n    // pos: point of the line\n    // w: width of the line\n    // dir: direction of the line\n    // b: OO\n\n    vec2 pt = ((uv.xy - ptx.xy) * vec2(dir.y, -dir.x)) / sqrt(dir.x*dir.x + dir.y*dir.y);\n    return exp(-abs(pt.x+ pt.y)/w);\n    \n}\n\n\nfloat sineline(vec2 uv, float x, float phi, float loop, float speed, float w, float s, float alpha) {\n    // x: position of helix center\n    // phi: phase of the helix\n    // loop: Number of peaks\n    // speed: Speed \n    // w: width of the line\n    // s: size of the helix\n    // alpha: width of fade\n    \n    float f = 2. * 3.14 * uv.y * loop + phi;\n    return 0.5 * (1. - alpha + alpha * cos(f)) * exp(-abs(uv.x - x + s *cos(f + speed * iTime))/ w);\n    \n        \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float a1 = 0.6;\n    float w = 0.2 * 0.5 * (1.  + a1 *cos(iTime));\n    float w1 = min(0.1, w);\n    \n    float loop = 3.;\n    float speed = 5.;\n    float alpha = 0.5;\n    \n    float center = 0.5;\n    \n    // Sorry for copy/paste\n    vec2 dir = vec2(0., 1.);\n    vec2 pt0 = vec2(center + w, .5);\n    vec2 pt1 = vec2(center - w, pt0.y);\n    \n    \n    float l0 = line(uv, dir, pt0, .03);\n    float l1 = line(uv, dir, pt1, .03);\n    \n    \n    float h0 = sineline(uv, center, 0., loop, speed, 0.02, w, alpha);\n    float h1 = sineline(uv, center, 1., loop, speed, 0.02, w, alpha);\n    \n    float h2 = sineline(uv, center, 2.5, loop, speed*1.3, 0.02, w1, alpha);\n    float h3 = sineline(uv, center, 2.0, loop, speed*1.3, 0.02, w1, alpha);\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(h2 + h3, 0.6*(l0+l1) + max(h1+h0*0.8, 0.), h1+h0);// + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 51, 156, 290], [293, 293, 394, 594, 761], [764, 764, 821, 871, 1857]], "test": "valid"}
{"id": "tsfXDl", "name": "One-Pass Voronoi with Spirals", "author": "dr2", "description": "Based on \"One-Pass Voronoi\" (add color to taste)", "tags": ["voronoi", "hexagon"], "likes": 8, "viewed": 366, "published": "Public API", "date": "1552501743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"One-Pass Voronoi with Spirals\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nvec3 HsvToRgb (vec3 c);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\n\nfloat tCur;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\nvec3 ShowScene (vec2 p)\n{\n  vec4 vc;\n  vec3 col, ltDir, vn;\n  float a;\n  HexVorInit ();\n  vc = HexVor (p - 10. * sin (0.03 * tCur + vec2 (0.5 * pi, 0.)));\n  vn = normalize (vec3 (vc.yz * smoothstep (0.2, 0.3, vc.x), 0.5).xzy);\n  a = (atan (vc.y, vc.z) / (2. * pi) + 0.5 * tCur) * sign (vc.w - 0.5);\n  col = mix (vec3 (0.6, 0.7, 0.3), HsvToRgb (vec3 (mod (2. * vc.x + a, 1.), 0.8, 1.)),\n     smoothstep (0.2, 0.3, vc.x)) * (0.6 +\n     0.4 * mix (step (0.06, vc.x) * SmoothBump (0.25, 0.75, 0.05, mod (12. * vc.x, 1.)),\n     SmoothBump (0.25, 0.75, 0.05, mod ((8. * vc.x - a), 1.)), smoothstep (0.3, 0.4, vc.x)));\n  ltDir = normalize (vec3 (0., 1., 1.));\n  ltDir.xz = Rot2D (ltDir.xz, -0.2 * tCur);\n  col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n     0.2 * pow (max (dot (normalize (ltDir + vn), vn), 0.), 32.);\n  return col;\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv;\n  float pSize, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  tCur += 20.;\n  pSize = canvas.x / 240.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) \n     col += (1. / naa) * ShowScene (pSize * (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)));\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.3;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 0.5 * pi * (u.y - 0.5) * tCur;\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.2) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfXDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 490, 515, 515, 1324], [1341, 1341, 1394, 1394, 1989], [1991, 1991, 2015, 2015, 2245], [2247, 2247, 2271, 2271, 2331], [2357, 2357, 2377, 2377, 2597], [2599, 2599, 2621, 2621, 3231], [3233, 3233, 3257, 3257, 3393], [3395, 3395, 3440, 3440, 3543], [3545, 3545, 3602, 3602, 3685], [3687, 3687, 3717, 3717, 3775], [3809, 3809, 3833, 3833, 3893], [3895, 3895, 3919, 3919, 4049]], "test": "error"}
{"id": "tsfXW8", "name": "TimeWarp", "author": "asdhyq", "description": ":(", "tags": ["timewardeffect"], "likes": 1, "viewed": 47, "published": "Public", "date": "1551755987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(225./255., 95./255., 60./255.);\nvec3 white = vec3(1.,1.,1.);\nvec3 blue = vec3(0.,128./255.,1.);\nvec3 black = vec3(0.,0.,0.);\nvec3 pink = vec3(255./255.,192./255.,203./255.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float x = sin(iTime * 2. ) ;\n    \n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos = vec2(.5 * ratio, .5);\n    float dist = distance ( shapePos,uv) ;\n    \n    uv -= shapePos;\n    \n    //get angle\n    float angle = atan(uv.y, uv.x) + iTime + 2. * (sin(iTime ));\n    \n    float radius = cos(4. * angle + iTime) * .3;\n    float radius2 = cos(4. * (atan(uv.y, uv.x) + -iTime * .5) + iTime) * .3;\n    float radius3 = cos(4. * angle + iTime) * .3;\n   \n    radius = sin (angle * 74.) * sin(angle * 40.) * sin(angle * 8.);\n    radius2 = cos (angle * 74.) * cos(angle * 40.) * cos(angle * 8.);\n    radius3 = cos (angle * 74.) * cos(angle * 40.) * sin(angle * 8.);\n\n    radius = radius * -x;\n    radius2 = radius2 * -x;\n    radius3 = radius3 * -x;\n    \n    float value = 1. - step(radius,dist * .2);\n    float value2 = 1. - step(radius2,dist * .3);\n    float value3 = 1. - step(radius3,dist );\n    \n    vec3 color = mix(black,red,value);\n    color = mix(color,blue,value);\n    color = mix(color,red,value2);\n    color = mix(color,pink,value3);\n    \n    fragColor = vec4(color ,1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfXW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 248, 248, 1416]], "test": "valid"}
{"id": "tsjSDz", "name": "menga sponge - ambient occulusio", "author": "takumifukasawa", "description": "AO_TYPE\n  0 ... only ao\n  1 ... not use ao\n  2 ... use ao", "tags": ["raymarching", "ao", "ambientocculusion"], "likes": 3, "viewed": 81, "published": "Public", "date": "1553511484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------------\n// ref\n// https://speakerdeck.com/gam0022/motutoqi-li-dexie-shi-de-nahui-zuo-rigasitai-reimatinguxiang-kefalsesiedeinguji-shu\n//---------------------------------------------------------------\n\n#define EPS 0.0001\n#define PI 3.14159265359\n#define AO_TYPE 2 // 0 ~ 2\n\nprecision mediump float;\n\nconst int maxIterations = 64;\nconst float stepScale = 1.;\nconst float stopThreshold = .005;\n\nstruct Light {\n  vec3 position;\n  float intensity;\n  vec3 color;\n};\n\nfloat sphere(vec3 p, float size) {\n  return length(p) - size;\n}\n\nfloat box(vec3 p, vec3 size) {\n  vec3 d = abs(p) - size;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat tube2(vec2 p, float size) {\n  return length(p) - size;\n}\n\nfloat box2(vec2 p, float size) {\n  return length(max(abs(p) - size, 0.));\n}\n\nfloat cylindar(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat displacement(vec3 p, vec3 power) {\n  return sin(power.x * p.x) * sin(power.y * p.y) * sin(power.z * p.z);\n}\n\nvec3 repeat(vec3 p, float c) {\n  return mod(p, c) - c * .5;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nvec3 map(vec3 p) {\n  float d = box(p, vec3(1.));\n  float s = 1.;\n  for(int m = 0; m < 3; m++) {\n    vec3 a = mod(p * s, 2.) - 1.;\n    s *= 3.;\n    vec3 r = abs(1. - 3. * abs(a));\n    float da = max(r.x, r.y);\n    float db = max(r.y, r.z);\n    float dc = max(r.z, r.x);\n    float c = (min(da, min(db, dc)) - 1.) / s;\n    d = max(d, c);\n  }\n  return vec3(d, 0., 0.);\n}\n\nfloat scene(vec3 p) {\n  vec3 d = map(p);\n  return d.x;\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n  float k = 1.;\n  float occ = 0.;\n  for(int i = 0; i < 5; i++) {\n    float len = .15 * (float(i) + 1.);\n    float distance = scene(n * len + p);\n    occ += (len - distance) * k;\n    k *= .5;\n  }\n  return clamp(1. - occ, 0., 1.);\n}\n\nvec3 getNormal(vec3 p) {\n  const float e = EPS;\n  return normalize(vec3(\n    scene(p + vec3(e,   0.0, 0.0)) - scene(p + vec3(-e,  0.0, 0.0)),\n    scene(p + vec3(0.0,   e, 0.0)) - scene(p + vec3(0.0,  -e, 0.0)),\n    scene(p + vec3(0.0, 0.0,   e)) - scene(p + vec3(0.0, 0.0,  -e))\n  ));\n}\n\nfloat rayMarching(vec3 origin, vec3 dir, float start, float end) {\n  vec3 sceneDist = vec3(0.);\n  float rayDepth = start;\n\n  vec3 res = vec3(-1.);\n  vec3 h = vec3(1.);\n  for(int i = 0; i < maxIterations; i++) {\n    sceneDist.x = scene(origin + dir * rayDepth);\n    if((sceneDist.x < stopThreshold) || (rayDepth >= end)) {\n      break;\n    }\n    res = vec3(rayDepth, sceneDist.yz);\n    rayDepth += sceneDist.x * stepScale;\n  }\n  if (sceneDist.x >= stopThreshold) {\n    rayDepth = end;\n  } else {\n    rayDepth += sceneDist.x;\n  }\n  return rayDepth;\n}\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  vec3 lightDir = light.position - position;\n  vec3 ref = reflect(-normalize(lightDir), normal);\n  float specular = 0.;\n  if(diffuse > 0.) {\n    specular = max(0., dot(ref, normalize(cameraPos - normal)));\n    float specularPower = 32.;\n    specular = pow(specular, specularPower) * light.intensity;\n  }\n  return specular;\n}\n\nvec3 lighting(vec3 position, vec3 cameraPos) {\n  vec3 sceneColor = vec3(0.);\n  vec3 normal = getNormal(position);\n\n  vec3 objColor = vec3(.8, .4, .4);\n  vec3 specularColor = vec3(1., .6, .6);\n\n  Light directionalLight;\n  directionalLight.position = vec3(0., 2., 2.);\n  directionalLight.intensity = .8;\n  directionalLight.color = vec3(.8, .4, .4);\n\n  Light pointLight;\n  pointLight.position = vec3(0., 0., 0.);\n  pointLight.intensity = .8;\n  pointLight.color = vec3(.8, .5, .5);\n\n  Light ambientLight;\n  ambientLight.color = vec3(1., .6, .6);\n  ambientLight.intensity = .3;\n\n  // directional light\n  float dDiffuse = max(0., dot(normal, normalize(directionalLight.position)));\n  dDiffuse *= directionalLight.intensity;\n  vec3 dDiffuseColor = dDiffuse * directionalLight.color * objColor;\n  float dSpecular = getSpecular(position, normal, directionalLight, dDiffuse, cameraPos);\n  vec3 dSpecularColor = dSpecular * specularColor;\n\n  // point light\n  vec3 pLightDir = pointLight.position - position;\n  float pDiffuse = max(0., dot(normal, normalize(pLightDir)));\n  vec3 pDiffuseColor = pDiffuse * pointLight.color * objColor;\n  float d = distance(pointLight.position, position);\n  vec3 k = vec3(.05, .9, .06);\n  float attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n  pDiffuse *= pointLight.intensity;\n  pDiffuse *= attenuation;\n  float pSpecular = getSpecular(position, normal, pointLight, pDiffuse, cameraPos);\n  pSpecular *= attenuation;\n  vec3 pSpecularColor = pSpecular * specularColor;\n\n  // ambient\n  vec3 ambientColor = ambientLight.color * ambientLight.intensity * objColor;\n  float ao = calcAO(position, normal);\n\n  vec3 diffuse = dDiffuseColor + pDiffuseColor;\n  vec3 specular = dSpecularColor + pSpecularColor;\n  vec3 ambient = ambientColor;\n\n  // only ao\n  #if AO_TYPE == 0\n    return vec3(ao);\n  #endif\n  // not use ao\n  #if AO_TYPE == 1\n    return objColor * diffuse + specular + ambient;\n  #endif\n  // use ao\n  #if AO_TYPE == 2\n    return objColor * diffuse + specular + ambient * ao;\n  #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n  vec2 screenCoord = (2. * fragCoord.xy / iResolution.xy - 1.) * aspect;\n\n  // camera settings\n  vec3 lookAt = vec3(0., 0., 0.);\n  vec3 cameraPos = vec3(cos(iTime / 3.) * 3., sin(iTime / 3.) * 3., 1.2);\n  float fov = .9;\n  float nearClip = 0.;\n  float farClip = 80.;\n\n  // camera vectors\n  vec3 forward = normalize(lookAt - cameraPos);\n  vec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, forward));\n\n  // raymarch\n  vec3 rayOrigin = cameraPos;\n  vec3 rayDirection = normalize(forward + fov * screenCoord.x * right + fov * screenCoord.y * up);\n  float dist = rayMarching(rayOrigin, rayDirection, nearClip, farClip);\n\n  if(dist >= farClip) {\n    vec3 bgColor = vec3(0.);\n    fragColor = vec4(bgColor, 1.);\n    return;\n  }\n\n  vec3 position = rayOrigin + rayDirection * dist;\n  vec3 normal = getNormal(position);\n\n  vec3 sceneColor = lighting(position, cameraPos);\n\n  // sceneColor = fog(sceneColor, dist, vec3(0.), .04);\n\n  fragColor = vec4(sceneColor, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 520, 554, 554, 583], [585, 585, 615, 615, 707], [709, 709, 742, 742, 771], [773, 773, 805, 805, 848], [850, 850, 882, 882, 920], [922, 922, 962, 962, 1035], [1037, 1037, 1067, 1067, 1098], [1100, 1100, 1139, 1139, 1206], [1208, 1208, 1226, 1226, 1574], [1576, 1576, 1597, 1597, 1632], [1634, 1634, 1664, 1664, 1895], [1897, 1897, 1921, 1921, 2183], [2185, 2185, 2251, 2251, 2733], [2735, 2735, 2826, 2826, 3151], [3153, 3153, 3199, 3199, 5167], [5169, 5169, 5224, 5224, 6281]], "test": "valid"}
{"id": "tsjSWh", "name": "fbm: marble", "author": "takumifukasawa", "description": "thanks MacSlow.\n", "tags": ["noise", "fbm", "color", "marble"], "likes": 7, "viewed": 331, "published": "Public", "date": "1553675059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//-----------------------------------------------------------\n// fbm ref.\n// https://thebookofshaders.com/13/?lan=jp\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n//-----------------------------------------------------------\n\n\nconst vec3 red = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue = vec3(0., 0., 1.);\nconst vec3 orange = vec3(1., .5, .25);\nconst vec3 cyan = vec3(0., 1., 1.);\nconst vec3 white = vec3(1., 1., 1.);\nconst vec3 yellow = vec3(1., 1., 0.);\n\n// Get random value\nfloat random(in vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm(in vec2 st) {\n  float value = 0.;\n  float amp = .55;\n  float freq = 0.;\n\n  for(int i = 0; i < OCTAVES; i++) {\n    value += amp * noise(st);\n    st *= 2.1;\n    amp *= .35;\n  }\n  return value;\n}\n\nfloat pattern(in vec2 p) {\n  float f = 0.;\n  vec2 q = vec2(\n    fbm(p + iTime * .2 + vec2(0.)),\n    fbm(p + iTime * .3 + vec2(2.4, 4.8))\n  );\n  vec2 r = vec2(\n    fbm(q + iTime * .3 + 4. * q + vec2(3., 9.)),\n    fbm(q + iTime * .2 + 8. * q + vec2(2.4, 8.4))\n  );\n  f = fbm(p + r * 2. + iTime * .09);\n  return f;\n}\n\nvec3 gradient(float v) {\n  float steps = 7.;\n  float step = 1. / steps;\n  vec3 col = green;\n  // v: 0 ~ 1/7\n  if(v >= 0. && v < step) {\n    col = mix(yellow, orange, v * steps);\n  // v: 1/7 ~ 2/7\n  } else if (v >= step && v < step * 2.) {\n    col = mix(orange, red, (v - step) * steps);\n  // v: 2/7 ~ 3/7\n  } else if (v >= step * 2. && v < step * 3.) {\n    col = mix(red, white, (v - step * 2.) * steps);\n  // v: 3/7 ~ 4/7\n  } else if (v >= step * 3. && v < step * 4.) {\n    col = mix(white, cyan, (v - step * 3.) * steps);\n  // v: 4/7 ~ 5/7\n  } else if (v >= step * 4. && v < step * 5.) {\n    col = mix(cyan, blue, (v - step * 4.) * steps);\n  // v: 5/7 ~ 6/7\n  } else if (v >= step * 5. && v < step * 6.) {\n    col = mix(blue, green, (v - step * 5.) * steps);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // fix aspect uv\n  vec2 uv = (fragCoord.xy - .5 * iResolution.xy);\n  uv = 2. * uv.xy / iResolution.y;\n\n  vec3 color = gradient(pattern(uv));\n\n  fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 517, 543, 543, 619], [621, 621, 647, 647, 1027], [1047, 1047, 1070, 1070, 1249], [1251, 1251, 1277, 1277, 1564], [1566, 1566, 1590, 1590, 2346], [2348, 2348, 2403, 2422, 2580]], "test": "valid"}
{"id": "tsjSzw", "name": "Repetition", "author": "gyabo", "description": "Repetition of simple primitive and ground.", "tags": ["raymarching"], "likes": 12, "viewed": 281, "published": "Public", "date": "1553290825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\n\n//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n \nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n \n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n \n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n \n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n \n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n \n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n  \nvec2 rot(vec2 p, float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec2(\n\t\tc * p.x - s * p.y,\n\t\ts * p.x + c * p.y);\n}\n \n \nfloat map(vec3 p) {\n\tfloat t = length(mod(p.xz, 0.5) - 0.25) - 0.01;\n\tt = min(t, length(mod(p.xy, 0.5) - 0.25) - 0.01);\n\tt = min(t, length(mod(p.yz, 0.5) - 0.25) - 0.01);\n    vec3 tp = p + 0.15;\n    //tp.xy = rot(tp.xy, mod(tp.z * 0.5, 0.5 * 3.141592));\n    t = min(t, length(mod(tp.xz, 0.5) - 0.25) - 0.01);\n\tt = min(t, length(mod(tp.xy, 0.5) - 0.25) - 0.01);\n\tt = min(t, length(mod(tp.yz, 0.5) - 0.25) - 0.01);\n\n\tt = min(t, 5.0 - dot((p), vec3(0, 1, 0)));\n\tt = max(t, -(length(mod(p, 10.0) - 5.0) - 6.5));\n\tt = min(t, length(mod(p + vec3(0, 0, time), 4.0) - 2.0) - 0.25);\n\treturn t;\n}\n \nvec3 getnor(vec3 p) {\n\tfloat a = map(p);\n\tvec2 d = vec2(0.001, 0.0);\n\tvec3 N = vec3(0.0);\n\tN.x = a - map(p + d.xyy);\n\tN.y = a - map(p + d.yxy);\n\tN.z = a - map(p + d.yyx);\n\treturn normalize(N);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tfloat tm = 60.0 + time * 0.1;\n\tdir.xy = rot(dir.xy, tm);\n\tdir.zx = rot(dir.zx, tm);\n\tvec3 pos = vec3(-time * 0.333, 2.0 + sin(tm), time);\n\t//vec3 pos = vec3(0.0, 0.0 + sin(tm) * 5.0, time);\n\tfloat t = 0.0;\n\tfor(int i = 0 ; i < 128; i++) {\n\t\tt += map(t * dir + pos);\n\t}\n\tvec3 IP = t * dir + pos;\n\tfloat M = 64.0;\n\tvec3 grain = vec3(0.5) * vec3(\n\t\tnoise(IP.xyz * M) * 0.5,\n\t\tnoise(IP.zxy * M) * 0.5,\n\t\tnoise(IP.yzx * M) * 0.5);\n\t\t\n\tvec3 N = normalize(getnor(IP) + grain);\n\tvec3 V = normalize(IP + grain);\n\tvec3 H = normalize(N + V);\n\tvec3 L = normalize(vec3(1, -2, 3));\n\tfloat D = max(0.0, dot(N, L));\n\tfloat S = max(0.0, pow(dot(H, N), 64.0)) * 4.0;\n\tvec3 C = normalize(vec3(1,2,3));\n\tvec3 col = vec3(0.0);\n\tcol += C * D;\n\tcol += C * S;\n\tcol += vec3(t * 0.01) * vec3(3,2,1) + map(IP + 0.1);\n\tfragColor = vec4( (col + dir * 0.3) * 0.5, 1.0);\n \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 89, 111, 111, 156], [157, 157, 177, 177, 222], [223, 223, 241, 241, 280], [283, 283, 303, 303, 799], [803, 803, 830, 830, 927], [932, 932, 951, 951, 1518], [1521, 1521, 1542, 1542, 1715], [1717, 1717, 1774, 1774, 2744]], "test": "valid"}
{"id": "tsjXDh", "name": "Wavy__", "author": "s_das", "description": "using distance field, I created this.\n", "tags": ["raytracing", "distancefield", "waves", "waves", "gradient", "purple", "trigonometry"], "likes": 1, "viewed": 301, "published": "Public API", "date": "1553670217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\t//uv.x *= iResolution.x / iResolution.y;\n    \n    uv = uv*2. - 1.;\n    \n    float da = iTime/2.;\n    \n    vec3 col = vec3(1.);\n    float d = length(abs(uv)-atan(uv)*5.);\n    float a = atan(uv.x,uv.y);\n    d = sin(a * 10.) * cos(a * 10.);\n    d -= length(abs(uv)- sin(da)*5.);\n    \n    col *= smoothstep(0.4, 0.41, length(abs(uv)));\n    col = vec3(fract(d*dot(uv.x,uv.y)));\n    \n    col += vec3(.3, 0., 1.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 614]], "test": "error"}
{"id": "tslSRj", "name": "Midterms_Co_Design7", "author": "johannco98", "description": "asd", "tags": ["asd"], "likes": 0, "viewed": 41, "published": "Public", "date": "1551713960", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Spikes(float angle, float armSpeed, float armNum, float armWidth, float size)\n{\n    float spikes =  1.0 / (abs(cos(angle * 500.0 + (iTime * armSpeed)) \n                        * sin(angle * armNum + iTime )))\n        \t\t\t\t\t\t\t\t\t\t\t* armWidth +      size;\n    \n    return spikes;\n    \n}\n\nfloat Gear(float angle, float armCount, float rotationSpeed, float armLength, float gearSize, float direction)\n{\n    float  radius = smoothstep(-1.0 ,  1.0,  \n                      cos(angle * armCount + (direction * iTime * rotationSpeed))) \n        * armLength  + gearSize;\n    \n    return radius;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    vec2 ouv = uv;\n    uv.x *= ratio;\n    \n    //initialize position\n    vec2 shapePos = vec2((0.5 * ratio) , 0.5);\n    float dist = distance(shapePos , uv) * 2.50;\n    \n    vec3 black = vec3(0.0 , 0.0, 0.0);\n    vec4 mouse = iMouse/iResolution.xyxy;\n    \n    uv *= 3.0;\n    uv = fract(abs(sin(uv * 2.0)));\n    \n    \n    uv -= shapePos;\n    \n    float angle = atan(uv.x , uv.y);\n    float radius;\n   \n    float flakes = Spikes(angle, 1.0, 6.0, 0.5, 0.07);\n    //snoflakes\n    //radius = 1.0/abs(cos(angle * 500.0 + iTime) \n    //             * sin(angle * 6.0 + iTime)) \n      //  \t\t\t* 0.5 + 0.07;\n    float value =  step(flakes  , dist * 0.9 );\n    \n    uv = ouv;\n    uv.x *= ratio;\n    uv -= shapePos;\n    angle = atan(uv.x, uv.y);\n    \n    float direction = -1.0;\n    if(mouse.y < 0.6)\n    {\n        direction *= -1.0;\n    }\n    \n  \tradius = smoothstep(-0.75 , 0.0, cos(angle * (direction * 3.0) + iTime * 2.0)  ) \n        \t\t\t\t* 0.9 + 0.2;\n  \tvalue += step(radius, dist * 0.3);\n    \n        \n    // Output to screen\n    fragColor = vec4(value  * vec4(vec3(0.3, 0.9, 1.0) , 1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 85, 85, 288], [290, 290, 402, 402, 591], [595, 595, 652, 652, 1824]], "test": "valid"}
{"id": "tslSzj", "name": "Shader8 - Random Gear Movement", "author": "EmperorLem", "description": "Different gears with different movements each", "tags": ["gear"], "likes": 1, "viewed": 50, "published": "Public", "date": "1551712337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 brown = vec3(0.3,0.2,0.2);\nvec3 black = vec3(0.0,0.0,0.0);\nvec3 red = vec3(0.7,0.0,0.0);\nvec3 blue = vec3(0.,1.,1.);\nvec3 yellow = vec3(1.0,1.0,0.0);\nvec3 green = vec3(0.1,0.9,0.0);\nvec3 white = vec3(1.0,1.0,1.0);\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat blades(vec2 uv, vec2 pos, float r, float minPoint, float maxPoint, float val, float edgeCnt, float speed)\n{   \n    uv.x *= iResolution.x/iResolution.y;\n    float dist = distance(pos, uv) * r;\n    float value = step(r, dist);\n    \n    uv -= pos;\n\n    float angle = (atan(uv.y, uv.x) + ( val * iTime) * speed);\n    \n    float radius = smoothstep(minPoint, maxPoint, cos(angle * edgeCnt)) * 0.2 + 0.5;\n    \n    value = step(radius , dist);\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float Sin = sin(iTime);\n    float Cos = cos(iTime);\n    float Tan = tan(iTime);\n\n    float mBlades = blades(uv, vec2(Sin * 0.9 + 1.0, Cos * 0.45), 7.0, -0.1, 2.0, 1.0, 7.0, 0.5);\n    mBlades -= blades(uv, vec2(Sin * 0.9,0.45), 5.5, -0.1, 0.6, -1.0, 4.0, 2.0);\n    mBlades += blades(uv, vec2(0.9, Tan *0.45) + 0.5, 3.5, 0.9, 1.0, -1.0, 5.0, 1.0);\n    mBlades -= blades(uv, vec2(Tan * 0.9, Sin * 0.45), 2.3, 1.0, 0.9, -1.0, 5.0, 0.1);\n    mBlades += blades(uv, vec2(0.9, Cos * 0.45), 2.9, 0.5, -.1, 1.0, 2.0, 1.0);\n    mBlades -= blades(uv, vec2(Tan * 0.9,Tan * 0.45), 2.5, 0.9, 0.3, -1.0, 10.0, 1.0);\n    \n    vec3 color = mix(col, vec3(mBlades) * noise(uv * iTime * 2.0 ), mBlades);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslSzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 241, 416, 482], [484, 499, 524, 524, 1035], [1037, 1055, 1113, 1113, 1251], [1253, 1253, 1280, 1280, 1678], [1680, 1697, 1718, 1718, 1765], [1766, 1766, 1787, 1787, 1834], [1835, 1835, 1857, 1857, 1892], [1894, 1894, 1916, 1916, 2964], [2966, 2966, 3079, 3079, 3433], [3435, 3435, 3492, 3542, 4390]], "test": "valid"}
{"id": "tslXDB", "name": "atan3", "author": "Del", "description": "messing around", "tags": ["atan"], "likes": 4, "viewed": 141, "published": "Public", "date": "1552095624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// atan3 - messing around...\n\n#define\tPI 3.141592\n\nvec3 pat(vec2 uv,float t)\n{\n\tfloat ang = atan(uv.x, uv.y)/(2.*PI);\n\tfloat dist = length(uv);\n\tvec3 col = vec3(0.0);\n\tfor (float ray = 0.5; ray < 8.0; ray += 0.26)\n\t{\n\t\tfloat rayang = t*ray/3.0/PI;\n        rayang += sin(t*0.1+dist);\n\t\trayang = fract(rayang-dist+(dist*(ray*0.5)));\n\t\tif (rayang < ang - 0.5)\n            rayang += 1.0;\n\t\tif (rayang > ang + 0.5)\n            rayang -= 1.0;\n\t\tfloat b = 0.3 - abs(ang - rayang)*2.0*PI;\n\t\tb -= dist * 0.3;\n\t\tif (b > 0.0)\n\t\t\tcol.rgb += vec3(0.2+0.85*ray, 0.4+0.4*ray, 0.9+0.85*ray) *0.5*b;\n\t}\n    col.rg *= 1.2+sin(dist+t*0.45)*0.25;\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\n    uv /= dot(uv,uv);\n    // wibble...\n    uv.x += sin(uv.y*32.0+t*0.24)*0.01;\n    uv.y += sin(uv.x*32.0+t*0.24)*0.01;\n\tuv *= 0.25;\n\tuv *= 1.5+sin(t*0.9);\n\tfragColor = vec4( pat(uv,t)*0.6, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 51, 78, 78, 641], [643, 643, 700, 700, 989]], "test": "valid"}
{"id": "tslXR2", "name": "shadow study 1", "author": "mindtree", "description": "shadowy ray marching", "tags": ["shadowraymarch"], "likes": 2, "viewed": 83, "published": "Public", "date": "1551752686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching Primitives\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/Ff0jJyyiVyw\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// 0.0 no lights, 1.0 all lights.\n#define LIGHTS_AMP 1.0\n\n// 0.0 no light, 10.0 powerful light.\n#define LIGHT1_AMP 5.0\n#define LIGHT2_AMP 2.0\n#define LIGHT3_AMP 0.\n\n// 0.0 no pillar, 1.0 default.\n#define PILLAR_WIDTH 1.0\n// 0.0 no pillar, 30.0 can't see top.\n//#define PILLAR_HEIGHT 30.0\n#define PILLAR_HEIGHT 1.0\n// 0.0 no pillar, 6.0 fully sealed.\n#define PILLAR_LENGTH 3.7\n\n// Multiplier for the subtle humanish gimble movement.\n// 0.0 is none, 5.0 is max.\n#define GIMBLE_MOVEMENT 1.0\n// 0.0 is none, 10.0 is weird shakey.\n#define GIMBLE_FREQ 1.0\n\n\n// Light RGBs\n#define LIGHT1_COL vec3(0.2, 0.5, 0.8)\n#define LIGHT2_COL vec3(0.0, 1.0, 1.0)\n#define LIGHT3_COL vec3(1.0)\n\n#define MODULO_STEP_Z 10.0\n#define MODULO_STEP_X 20.0\n\nconst float PI = 3.1457;\n\nfloat bpm() { return 126.0; }\nfloat beats_per_bar() { return 4.; }\nfloat bar() { return iTime * bpm() / 60.0 / beats_per_bar(); }\nfloat bar_phase() { return mod(bar(), 1.0); }\nfloat bar4_phase() { return mod(bar(), 4.0) / 4.0; }\nfloat bar8_phase() { return mod(bar(), 8.0) / 8.0; }\nfloat bar16_phase() { return mod(bar(), 16.0) / 16.0; }\nfloat beat() { return iTime * bpm() / 60.0; }\nfloat beat_phase() { return mod(beat(), 1.0); }\nfloat minim_phase() { return mod(beat()*0.5, 1.0); }\nfloat quaver_phase() { return mod(beat()*2.0, 1.0); }\nfloat semiquaver_phase() { return mod(beat()*4.0, 1.0); }\n\nfloat light1_z_phase() { return bar_phase(); }\nfloat light2_z_phase() { return bar4_phase(); }\nfloat light_z_max() { return MODULO_STEP_Z * 16.0; }\nfloat cam_z_phase() { return bar16_phase(); }\n\n#define NUM_SHAPES 2\nfloat shape_shift_phase() { return minim_phase(); }\nint shape_index() { return int(floor(shape_shift_phase() * float(NUM_SHAPES))); }\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t*ab;\n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    vec3 c = a + t*ab;\n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat sdSphere(vec4 s) {\n    return length(s.xyz) - s.w;\n}\n\n\nfloat GetDist(vec3 p) {\n    float plane_dist = p.y;\n    \n    // Position modulo for box.\n    vec3 p_for_box = p;\n    p_for_box.z = mod(p.z, MODULO_STEP_Z);\n    p_for_box.x = mod(p.x, MODULO_STEP_X);\n    p_for_box.y = mod(p.y, 2.0);\n    vec3 pillar_dim = vec3(PILLAR_WIDTH, PILLAR_HEIGHT, PILLAR_LENGTH);\n    vec3 pillar_pos = vec3(MODULO_STEP_X*0.5, 1.0, 6);\n    float pillar_dist = dBox(p_for_box-pillar_pos, pillar_dim);\n    \n    // Position modulo for shape.\n    vec3 p_for_shape = p;\n    p_for_shape.z = mod(p.z, light_z_max() * 0.5);\n    float shape_dist = 0.0;\n    int shape_ix = shape_index();\n    if (shape_ix == 0) {\n      \tvec4 s = vec4(0, 1, 6, 0.5);\n        shape_dist = sdSphere(vec4(p_for_shape-s.xyz, s.w));\n    } else if (shape_ix == 1) {\n        vec3 bpos = vec3(0, 1, 6);\n        vec3 bdim = vec3(1, 1, 1) * 0.5;\n        shape_dist = dBox(p_for_shape-bpos, bdim);\n    } else {\n        // TODO: Add more shapes?\n        //float cd = sdCapsule(p, vec3(3, .5, 6), vec3(3, 2.5, 6), .5); \n    \t//float td = sdTorus(p-vec3(0,.5,6), vec2(1.5, .4));\n    \t//float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, .3, 5), .3);\n    }    \n    \n    \n    float d = plane_dist;\n    d = min(d, pillar_dist);\n    d = min(d, shape_dist);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat shadow_march(vec3 ro, vec3 rd, float min_light, float light_dist, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=min_light; t < light_dist; ) {\n        vec3 p = ro + rd*t;\n        float h = GetDist(p);\n        if(h<SURF_DIST)\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 GetNormal(vec3 p) {\n        //p.z = mod(p.z, 10.0);\n\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 light1() {\n    //vec3 pos = vec3(-.625*MODULO_STEP_X, 6, -0.5*MODULO_STEP_Z);\n    vec3 pos = vec3(-.625*MODULO_STEP_X, 6, 0.0);\n    pos.z += light1_z_phase() * light_z_max();\n\treturn pos;\n}\n\nvec3 light1_col() {\n    return LIGHT1_COL;\n}\n\nvec3 light2() {\n    vec3 pos = vec3(.625*MODULO_STEP_X, 10, 0.0);\n    pos.z += light2_z_phase() * light_z_max();\n\treturn pos;\n}\n\nvec3 light2_col() {\n    return LIGHT2_COL;\n}\n\nvec3 light3() {\n    vec3 pos = vec3(1, 4, light_z_max()*0.5+2.);\n    pos.xz += vec2(sin(iTime), cos(iTime))*2.;\n\treturn pos;\n}\n\nvec3 light3_col() {\n    return LIGHT3_COL;\n}\n\nfloat GetLight(vec3 p, vec3 light_p) {\n    p.z = mod(p.z, light_z_max());\n    vec3 l = normalize(light_p-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(light_p-p)) dif *= .1;\n\n    float s = shadow_march(p+n*SURF_DIST*2., l, 0.1, 1., 0.5);\n    //s = 1.;\n\n    return dif*s;\n}\n\nvec3 render(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    vec3 cam_pos = vec3(0, 2, 0);\n    cam_pos.xyz += vec3(sin(iTime*0.4*GIMBLE_FREQ), cos(iTime*0.37*GIMBLE_FREQ), sin(iTime*GIMBLE_FREQ)*0.5)*0.25*GIMBLE_MOVEMENT;\n    \n    cam_pos.z += cam_z_phase() * light_z_max();\n    \n    \n    float cam_yaw = uv.x-.07;\n    float cam_pitch = uv.y-.2;\n    \n    //cam_yaw += iMouse.x * PI * 4.0 / iResolution.x - PI * 2.0;\n    //cam_pitch += iMouse.y * PI * 2.0 / iResolution.y - PI;\n    \n    vec3 rd = normalize(vec3(cam_yaw, cam_pitch, 1));\n\n    float d = RayMarch(cam_pos, rd);\n    \n    vec3 p = cam_pos + rd * d;\n    \n    vec3 l1 = light1_col() * GetLight(p, light1());\n    vec3 l2 = light2_col() * GetLight(p, light2());\n    vec3 l3 = light3_col() * GetLight(p, light3());\n\n    float fade_dist = 1.0 - pow(d / MAX_DIST, 2.);\n    col = (l1*LIGHT1_AMP + l2*LIGHT2_AMP + l3*LIGHT3_AMP) * LIGHTS_AMP * fade_dist;\n    return col;\n}\n\nvec3 render_msaa(vec2 uv, int samples) {\n    int samples_per_side = samples / 2;\n    int half_samples_per_side = samples_per_side / 2;\n    int loop_end = samples_per_side - half_samples_per_side;\n    int loop_start = loop_end - samples_per_side;\n    float sample_step = 1.0 / iResolution.x;\n    vec3 acc = vec3(0.0);\n    for (int x = loop_start; x < loop_end; x++) {\n        for (int y = loop_start; y < loop_end; y++) {\n            vec2 coords = uv + vec2(float(x) * sample_step, float(y) * sample_step);\n            acc += render(coords);\n        }\n    }\n    return acc / float(samples_per_side * 2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    \n    //fragColor = vec4(render_msaa(uv, 4),1.0);\n    fragColor = vec4(render(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslXR2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[900, 1103, 1116, 1116, 1132], [1133, 1133, 1156, 1156, 1169], [1170, 1170, 1183, 1183, 1232], [1233, 1233, 1252, 1252, 1278], [1279, 1279, 1299, 1299, 1331], [1332, 1332, 1352, 1352, 1384], [1385, 1385, 1406, 1406, 1440], [1441, 1441, 1455, 1455, 1486], [1487, 1487, 1507, 1507, 1534], [1535, 1535, 1556, 1556, 1587], [1588, 1588, 1610, 1610, 1641], [1642, 1642, 1668, 1668, 1699], [1701, 1701, 1725, 1725, 1747], [1748, 1748, 1772, 1772, 1795], [1796, 1796, 1817, 1817, 1848], [1849, 1849, 1870, 1870, 1894], [1917, 1917, 1944, 1944, 1968], [1969, 1969, 1988, 1988, 2050], [2053, 2053, 2103, 2103, 2256], [2258, 2258, 2309, 2309, 2601], [2603, 2603, 2634, 2634, 2702], [2704, 2704, 2732, 2732, 2769], [2771, 2771, 2795, 2795, 2829], [2832, 2832, 2855, 2855, 4086], [4088, 4088, 4122, 4122, 4333], [4335, 4335, 4417, 4417, 4778], [4780, 4780, 4804, 4836, 5027], [5029, 5029, 5044, 5111, 5223], [5225, 5225, 5244, 5244, 5269], [5271, 5271, 5286, 5286, 5398], [5400, 5400, 5419, 5419, 5444], [5446, 5446, 5461, 5461, 5572], [5574, 5574, 5593, 5593, 5618], [5620, 5620, 5658, 5658, 5985], [5987, 5987, 6009, 6009, 6906], [6908, 6908, 6948, 6948, 7512], [7514, 7514, 7571, 7571, 7729]], "test": "valid"}
{"id": "tslXRj", "name": "Raytracing Line Segment 3D", "author": "bloxard", "description": "The shortest distance between a ray and a line segment in 3D is calculated once, rather than calculating\nthe distance between a point and 3D line segment multiple times while stepping forward.", "tags": ["distance", "analytical", "capsule", "linesegment"], "likes": 4, "viewed": 371, "published": "Public", "date": "1551711186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Per Bloksgaard/2019\n// The shortest distance between a ray and a line segment in 3D is calculated once, rather than calculating\n// the distance between a point and 3D line segment multiple times while stepping forward.\n\nfloat RayLineSegmentDistance(vec3 rP, vec3 rD, vec3 lS, vec3 lE)\n{\n\tfloat bL = length(lE-lS);\n\tvec3 bD = (lE-lS)/bL;\n\tvec3 tD = lS-rP;\n\tfloat aDb = dot(rD,bD);\n\tfloat aDt = dot(rD,tD);\n\tfloat bDt = dot(bD,tD);\n\tfloat u = (aDt-bDt*aDb)/(1.-aDb*aDb);\n\tfloat v = max(min(u*aDb-bDt,bL),0.);\n\tu = max(min(v*aDb+aDt,1e6),0.);\n\treturn length((rP+rD*u)-(lS+bD*v));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 s = (-iResolution.xy+2.*gl_FragCoord.xy)/iResolution.y;\n\tvec3 vCamPos = vec3(cos(iTime)*1.6,0.0,sin(iTime)*1.6);\n\tvec3 vCamTarget = vec3(cos(-iTime*0.21)*0.1,cos(iTime*0.12)*0.1,sin(iTime*0.15)*0.1);;\n\tvec3 vCamForward = normalize(vCamTarget-vCamPos);\n\tvec3 vCamRight = normalize(cross(vCamForward,vec3(0.,1.,0.)));\n\tvec3 vCamUp = normalize(cross(vCamRight,vCamForward));\n\tvec3 vRayDir = normalize(s.x*vCamRight+s.y*vCamUp+vCamForward*0.5);\n\n\tvec3 so = vec3(cos(0.174-iTime*0.747),sin(-0.33+iTime* 1.176),0.213+cos(0.3+iTime*1.713));\n\tvec3 sd = vec3(sin(0.433-iTime*1.723),cos(0.172+iTime*-1.331),0.635+sin(0.9-iTime*0.534));\n\t\n\tfloat dist = RayLineSegmentDistance(vCamPos, vRayDir, so, sd);\n\tfragColor = vec4(vec3(1.-dist*3.5),1.);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 234, 300, 300, 592], [594, 594, 649, 649, 1393]], "test": "valid"}
{"id": "tslXWl", "name": "Contour Tracing", "author": "mathmasterzach", "description": "Fake particles moving on a contour. Mouse x controls trail length. Mouse y controls speed.", "tags": ["noise", "particles", "tracing", "contour", "movement"], "likes": 9, "viewed": 423, "published": "Public API", "date": "1552769350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//uncomment this line to enable grayscale\n//#define GRAYSCALE\n\nconst float PI=acos(-1.);\nconst float AA=2.;\n\nfloat maxComp(vec3 c){\n\treturn max(c.x,max(c.y,c.z));\n}\n\n//from https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//noise functions from https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nfloat fNoise(vec2 p){\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f=0.;\n    float str=.5;\n    //change the number of iterations in this loop to make the contours more or less wobbly\n    for(int i=0;i<4;i++){\n        f += str*noise(p);\n    \tstr/=2.;\n        p = m*p;\n    }\n\treturn 0.5 + 0.5*f;\n}\n\nvec2 grad(vec2 p){\n    vec2 eps=vec2(.001,0);\n\treturn normalize(vec2(fNoise(p+eps.xy)-fNoise(p-eps.xy),\n                \t\t  fNoise(p+eps.yx)-fNoise(p-eps.yx)));\n}\n//palette from here https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 colorFromBand(vec2 p){\n    float t=hash12(p);\n    return pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\nvec3 render(vec2 crd,float t, float tc){\n    vec2 uv=2.*crd/iResolution.xy-1.;\n\tfloat sz=iResolution.x/5.;\n\n    float f=fNoise(uv);\n    float n = 5.*hash11(.1*floor(sz*f));\n    vec3 c=vec3(0.);\n    vec2 g=grad(uv);\n    for(float i=0.;i<4.;i+=1.){\n        float s=i*PI/4.;\n        vec2 d = vec2(cos(t+n+s),sin(t+n+s));\n        if(d.y*g.x > d.x*g.y){\n            c+=colorFromBand(vec2(f,i))*max(0.,(tc*dot(d,g)-tc+1.)*(3.*(.5-abs(fract(sz*f)-.5))));\n        }\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float tc=20.*iMouse.x/iResolution.x+1.;\n    float t=iTime*(2.*iMouse.y/iResolution.x+1.);\n    vec3 c;\n    for(float i=0.;i<AA;i++){\n    \tfor(float j=0.;j<AA;j++){\n    \t\tc+=render(fragCoord+(vec2(i,j)/AA),t,tc);\n    \t}\n    }\n    c/=AA*AA;\n    #ifdef GRAYSCALE\n    \tfragColor = vec4(vec3(maxComp(c)),1.0);\n    #else\n    \tfragColor = vec4(c,1.0);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 109, 131, 131, 164], [166, 211, 234, 234, 347], [348, 367, 389, 389, 506], [508, 569, 589, 589, 710], [712, 712, 737, 737, 1192], [1194, 1194, 1215, 1215, 1498], [1500, 1500, 1518, 1518, 1662], [1663, 1721, 1788, 1788, 1831], [1833, 1833, 1860, 1860, 1980], [1982, 1982, 2022, 2022, 2461], [2463, 2463, 2519, 2519, 2880]], "test": "error"}
{"id": "tslXWS", "name": "Task1_cmc_msu", "author": "Zen_nik", "description": "313_Zenkin_Nikita", "tags": ["raymarshing"], "likes": 2, "viewed": 85, "published": "Public", "date": "1552180108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 novec=vec3(-1,-1,-1);//no vector\nconst float eps=0.001;\nconst vec3 light1=vec3(-2,2,2.5);//light 1\nconst vec3 light2=vec3(2,-1,1);//light 2\nvec3 color=vec3(0.6,0.6,0.4);//backgroung color\nvec3 ud;\nconst vec3 cam=vec3(0.0,0,-1);//camera\n\nfloat sqr(float s)\n{\n    return s*s;\n}\n\nfloat sdSp(vec3 p) //fig1\n{\n  vec3 centr=vec3(-2.0,-1.0,2.0);\n  float rad=(cos(2.0*iTime)*0.6/2.0)+0.7;\n  return length(centr-p)-rad;\n}\n\nfloat sdBox(vec3 p)//fig2\n{\n    vec3 centr=vec3(1.0,-3.0*cos(iTime),2.5);\n    vec3 b=vec3(0.75,1.0,0.5);\n    return length(max(abs(centr-p)-b,0.0));\n}\n\nfloat sdCil(vec3 p)//fig3\n{\n    vec2 axis=vec2(sin(iTime/1.5)*6.0,4.5+cos(iTime));\n    float rad=0.5;\n    vec3 q=vec3(axis.x,p.y,axis.y);\n    return length(p-q)-rad;\n}\n\nfloat sdGlass(vec3 p)//fig4\n{\n    vec3 centr=vec3(sin(iTime),0.0,cos(iTime)*0.5+0.65);\n    vec3 b=vec3(0.7,0.7,0.1);\n    return length(max(abs(centr-p)-b,0.0));\n}\n\nfloat sdTorus(vec3 p)//fig5\n{\n    vec3 centr=vec3(1.0,sin(iTime)*1.0,2.5);\n\tfloat rad1=1.0;\n    float rad2=0.1;\n    vec3 q=centr-p;\n    vec3 n=rad1*normalize(vec3(q.x,0.0,q.z));\n  \treturn length(q-n)-rad2;\n}\n\n\n\nfloat min_dist(vec3 vec)//ditanse to figures\n{\n    return min(min(min(sdTorus(vec),sdBox(vec)),min(sdGlass(vec),sdCil(vec))),sdSp(vec));\n}\n\nvec3 cros(vec3 cam, vec3 ud)//coordinats of cross\n{\n    vec3 curp=cam;\n    float curl;\n    int i=0;\n    while (i<200)\n    {\n        curl=min_dist(curp);\n        if (curl<eps)\n        \treturn curp;\n        \telse curp=curp+normalize(ud-cam)*curl;\n        i++;\n    }\n    return novec;\n}\n\nint num_of_fig(vec3 veccros)//number of figure\n{\n    float dist=min_dist(veccros);\n    if (dist==sdSp(veccros)) //sphere\n        \treturn 1;\n    else if (dist==sdBox(veccros)) //box\n        \treturn 2;\n    else if (dist==sdCil(veccros)) //cilindr\n        \treturn 3;    \n    else if (dist==sdGlass(veccros)) //glass\n        \treturn 4;\n    else if (dist==sdTorus(veccros)) //torus\n        \treturn 5;    \n    return 0;\n}\n\nvec3 color_f(int num)//color of figure\n{\n\tswitch(num)\n\t{\n    \tcase 1:\n        \treturn vec3(0.2,0.0,0.0); //color of sphere\n    \tcase 2:\n        \treturn vec3(0.0,0.2,0.0); //color of box\n        case 3:\n        \treturn vec3(0.2,0.2,0.2); //color of cilindr\n        case 4:\n        \treturn vec3(0.1,0.1,0.15); //color of glass\n        case 5:\n            return vec3(0.2,0.2,0.0); //color of torus\n    }\n}\n\nvoid checklight(vec3 veccros)//add light from lights\n{\n    int num=num_of_fig(veccros);\n    color=color_f(num);\n    if (length(cros(light1,veccros)-veccros)<eps*4.0)\n       \tcolor+=color*20.0/(sqr(length(veccros-light1)+1.0));\n    if (length(cros(light2,veccros)-veccros)<eps*4.0)\n        color+=color*10.0/(sqr(length(veccros-light2)+1.0));\n}\n\nvoid mirrow(vec3 cv)//reflection for figure 3\n{\n    vec3 veccros=cv;\n    vec2 pc=vec2(cv.x,cv.z);\n    vec2 pb=vec2(sin(iTime/1.5)*6.0,4.5+cos(iTime));\n    vec2 p=vec2(ud.x-pc.x,ud.z-pc.y);\n    vec2 c=pc-pb;\n    float len=2.0*length(p)*(p.x*c.x+p.y*c.y)/length(c);\n    vec2 nv2=c*len-p;\n    vec3 nv=normalize(vec3(nv2.x,pc.y,nv2.y));\n    vec3 e=veccros+nv;;\n    vec3 b=veccros+nv/100.0;\n    veccros=cros(b,e);\n    if (veccros!=novec)\n    \tchecklight(veccros);\n}\n\nvoid glas(vec3 cv)//refraction for figure 4\n{\n    int num;\n    vec3 veccros=cv;\n    vec3 d=normalize(veccros-ud);\n    vec3 e=veccros+d;\n    vec3 b=e-normalize(veccros-ud)/2.0;\n    veccros=cros(b+vec3(0.5,-0.2,0.0),e+vec3(0.5,-0.2,0.0));\n    if (veccros!=novec){\n     \tchecklight(veccros);\n        num=num_of_fig(veccros);\n        if (num==3)\n   \t\t\tmirrow(veccros);\n    }\n    else color=vec3(0.7,0.7,0.7);\n    if (length(cros(light1,cv)-cv)<eps*4.0)\n    \tcolor+=color*20.0/(sqr(length(cv-light1)+1.0));\n    if (length(cros(light2,cv)-cv)<eps*4.0)\n        color+=color*10.0/(sqr(length(cv-light1)+1.0));\n    color=color-vec3(0.9,0.9,0.4)/4.0;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 veccros;\n    int num;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv=uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    ud=vec3(uv,0.0);\n    veccros=cros(cam,ud);\n    num=num_of_fig(veccros);\n    if (veccros!=novec)\n    {\n    \tchecklight(veccros);\n    \tif (num==3)\n    \t\tmirrow(veccros);\n        if (num==4)\n        \tglas(veccros);\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 248, 268, 268, 286], [288, 288, 315, 315, 423], [425, 425, 452, 452, 575], [577, 577, 604, 604, 744], [746, 746, 775, 775, 908], [910, 910, 939, 939, 1117], [1121, 1121, 1167, 1167, 1259], [1261, 1261, 1312, 1312, 1544], [1546, 1546, 1594, 1594, 1961], [1963, 1963, 2003, 2003, 2366], [2368, 2368, 2422, 2422, 2711], [2713, 2713, 2760, 2760, 3173], [3175, 3175, 3220, 3220, 3817], [3821, 3821, 3878, 3878, 4274]], "test": "error"}
{"id": "tsS3Dw", "name": "sun corridor", "author": "lexmar", "description": "corridor", "tags": ["raymarch"], "likes": 4, "viewed": 77, "published": "Public", "date": "1551560292", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float MAX_DIST = 100.0;\n\nmat3 genCamera(vec3 camP, vec3 targetP, float tilt)\n{\n    vec3 zaxis = normalize(targetP - camP);\n    vec3 up = vec3(0, 1, 0);\n    vec3 xaxis = normalize(cross(up, zaxis));\n    vec3 yaxis = normalize(cross(zaxis, xaxis));\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nfloat sphereSdf(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat worldSdf(vec3 p)\n{\n    float theta = p.z / 5.0*sin(iTime);\n    mat3 rot = mat3(vec3(cos(theta), sin(theta), 0.0), vec3(-sin(theta), cos(theta), 0.0), vec3(0.0, 0.0, 1.0));\n    p = rot*p;\n        \n    float lowPlane = -5.0;\n    float highPlane = 5.0;\n    float distToPlane = min(p.y - lowPlane, highPlane - p.y);\n    \n    return distToPlane;\n    //return length(p - vec3(3.0, 0.0, 20.0)) - 1.0;\n}\n\nvec3 worldNormal(vec3 p)\n{\n    float eps = 0.001;\n    float dx = (worldSdf(p + vec3(eps, 0, 0)) - worldSdf(p - vec3(eps, 0, 0)));\n    float dy = (worldSdf(p + vec3(0, eps, 0)) - worldSdf(p - vec3(0, eps, 0)));\n    float dz = (worldSdf(p + vec3(0, 0, eps)) - worldSdf(p - vec3(0, 0, eps)));\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat intersect(vec3 p, vec3 dir)\n{\n \tfloat t = 0.0;\n    while(t < MAX_DIST)\n    {\n        float dt = worldSdf(p);\n        if(dt < 0.001) break;\n        p = p + dt*dir;\n        t += dt;\n    }\n    \n    return t;\n}\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 botLeft = floor(p);\n    vec2 inside = fract(p);\n    \n    float a = random(botLeft);\n    float b = random(botLeft + vec2(1.0, 0.0));\n    float c = random(botLeft + vec2(0.0, 1.0));\n    float d = random(botLeft + vec2(1.0, 1.0));\n    \n    inside = inside * inside * (3.0 - 2.0*inside);\n    \n    float result = mix(mix(a, b, inside.x), mix(c, d, inside.x), inside.y);\n    return result;\n}   \n\n// technique from http://www.iquilezles.org\nfloat fbm(vec2 p, float speed)\n{\n    float amp = 0.5;\n    float v = 0.0;\n    for(int i = 0; i < 8; i++)\n    {\n        vec2 off = vec2(0.0, 0.0);\n        \n        if(int(i) % 2 == 0)\n        {\n            off = vec2(1.0, 0.0);\n        }\n        else\n        {\n            off = vec2(0.0, 1.0);\n        }\n        \n        off = speed * iTime * float(i) * off;\n        \n        vec2 np = p + off;\n        v += amp*noise(np);\n        p *= 2.0;\n        amp *= 0.5;\n    }\n    \n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord.xy/iResolution.xy) - 1.0;\n    uv.x *= (iResolution.x/iResolution.y)/2.0;\n    uv.y *= 0.5;\n    \n    vec3 camP = vec3(0.0, 0.0, 0.0);\n    vec3 targetP = camP + vec3(0.0, 0.0, 1.0);\n    mat3 cameraSpaceFromUnitSpace = genCamera(camP, targetP, 0.0);\n    vec3 ray = normalize(vec3(uv, 4.0));\n    float dist = intersect(camP, ray);\n    vec3 hit = camP + dist*ray;\n    \n    if(dist < MAX_DIST) {\n        vec3 normal = worldNormal(hit);\n        float c = 5.0*dot(normal, -ray);\n        vec2 p = 0.25*hit.xy;\n        vec2 np = vec2(fbm(p, 1.0), fbm(p + vec2(3.5, 4.67), 1.0));\n        vec2 nnp = vec2(fbm(p + 4.0*np, 1.0), fbm(p + 4.0*np + vec2(6.2, 1.6), 1.0));\n        float t = fbm(np + 4.0*nnp, 1.0);\n        fragColor = 0.3*c*vec4(0.4, 0.4, 0.0, 1.0) + (hit.z/100.0)*vec4(t, t, 0.0, 1.0);\n    } else {\n        vec2 p = 1.0*hit.xy;\n        vec2 np = vec2(fbm(p, 1.0), fbm(p + vec2(3.5, 4.67), 1.0));\n        vec2 nnp = vec2(fbm(p + 4.0*np, 1.0), fbm(p + 4.0*np + vec2(6.2, 1.6), 1.0));\n        float t = fbm(np + 4.0*nnp, 1.0);\n        fragColor = vec4(2.0*t, t, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsS3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 84, 84, 292], [294, 294, 333, 333, 366], [368, 368, 392, 392, 769], [771, 771, 797, 797, 1102], [1104, 1104, 1139, 1139, 1316], [1318, 1318, 1341, 1341, 1413], [1415, 1415, 1436, 1436, 1831], [1836, 1880, 1912, 1912, 2366], [2369, 2369, 2426, 2426, 3532]], "test": "valid"}
{"id": "tsSXR1", "name": "Sinusoid (Work In Progress)", "author": "letters", "description": "I know what comes next, just need to stop for the night\ntodo: color shifts", "tags": ["sine", "unfinished", "sinusoid", "sinusoidal", "sinewave"], "likes": 2, "viewed": 77, "published": "Public", "date": "1552885935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat smoothit(float center, float radius, float n) {\n    radius = abs(radius);\n    float dist = abs(center - n);\n    if(dist > radius) return 0.0;\n    \n    return sin((radius - dist)/radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    float c; //unsclased pixel color\n    float period = 0.25; //seconds\n    float theta = 2.0 * 3.1415912 * (iTime - floor(iTime / period) * period) / period;\n    //float theta = 0.;\n    \n    float scale;  //for scaling x coordinates\n\tscale = (iTime - floor(iTime / 100.0) * 100.0) / 100. ; // (0 to 100)/100\n\t//scale = 0.1;\n    \n    float y, dy;\n    \n    y  = sin((fragCoord.x * scale) + theta);\n    dy = cos((fragCoord.x * scale) + theta); // dsin = cosx\n        \n    \n    //float ysc = (y + 1.)/2.0, dysc = dy * scale;\n    float ysc = (y + 1.)/2.0, dysc = dy * scale;\n    \n\n    c = smoothit(ysc,dysc,uv.y);\n    \n    \n    vec3 col; // RGB output vector\n    col = vec3(c);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 55, 55, 196], [198, 198, 255, 312, 1094]], "test": "valid"}
{"id": "tsXSRB", "name": "Midterms_Co_Design1", "author": "johannco98", "description": "diversity and chaos", "tags": ["midterms"], "likes": 1, "viewed": 44, "published": "Public", "date": "1551543282", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Gear(float angle, float armCount, float rotationSpeed, float armLength, float gearSize, float direction)\n{\n    //gear          \t\t \t\t\t\t\t\t       armCount                   rotationSpeed   armLength     gearSize\n    float  radius = smoothstep(-1.0 ,  1.0,  cos(angle * armCount + (direction * iTime * rotationSpeed))) * armLength  + gearSize;\n    \n    return radius;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos = vec2((0.5 * ratio) , 0.5);\n    float dist = distance(shapePos , uv) * 2.50;\n    \n    uv -= shapePos;\n    \n    float angle = atan(uv.y, uv.x);\n    \n    float gear = Gear(angle, 8.0, 2.0, 0.2, 0.4, 1.0);\n    \n    float spikes =  abs(cos(angle * 75.0 + iTime) * sin(angle * 7.0 + iTime)) * 0.5 + 0.1;\n\t\n    float value =  step(gear + spikes * clamp(sin(iTime * 1.0)*5.0, 0.1, 10.0), dist);\n    \n    // Output to screen\n    fragColor = vec4(value + \n                     vec4(//colors\n                         vec3(clamp(sin(iTime), 0.0, 1.0),\n                              clamp(sin(iTime), 0.0, 0.5), \n                             clamp(sin(iTime), 0.0, 0.5)) \n                          , 1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXSRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 112, 214, 371], [376, 376, 433, 483, 1310]], "test": "valid"}
{"id": "tsXXRB", "name": "Midterms_Co_Design2", "author": "johannco98", "description": "asd", "tags": ["asd"], "likes": 1, "viewed": 46, "published": "Public", "date": "1551542508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Gear(float angle, float armCount, float rotationSpeed, float armLength, float gearSize, float direction)\n{\n    float  radius = smoothstep(-1.0 ,  1.0,  cos(angle * armCount + (direction * iTime * rotationSpeed))) * armLength  + gearSize;\n    \n    return radius;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Colors in vec3\n    vec3 red = vec3(0.8 ,0.0 ,0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 yellow = vec3(0.9, 0.9, 0.3);\n    vec3 blue = vec3(0.0, 0.2, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos = vec2((0.5 * ratio), 0.5);\n    float dist = distance(shapePos , uv) * 4.50;\n    \n    \n    uv -= shapePos;\n    float angle = atan(uv.y, uv.x);\n    \n    float gear = Gear(angle, 12.0, 20.0, 0.2, 0.5, -1.0);\n    \n   \n    \n     vec3 test = mix(black, red, Gear(angle, 12.0, 20.0, 0.2, 0.5, -1.0));\n    test = mix(test, white, Gear(angle, 8.0, 10.0, 2.0, 0.1, 1.0));\n    \n    float value =  step(gear , dist);\n    vec3 val = value * vec3(1.0, 1.0, 1.0);\n        \n    // Output to screen\n    fragColor = vec4(test  , 1.0);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 112, 112, 269], [274, 274, 331, 352, 1249]], "test": "valid"}
{"id": "wd2SWD", "name": "raymarching: emissive cube", "author": "takumifukasawa", "description": "test emissive", "tags": ["raymarch", "glow", "emissive"], "likes": 11, "viewed": 624, "published": "Public", "date": "1553945707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.0001\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n#define DBL_MAX 1.7976931348623158e+308\n#define DBL_MIN 2.2250738585072014e-308\n\nprecision mediump float;\n\nconst int maxIterations = 64;\nconst float stepScale = 1.;\nconst float stopThreshold = .005;\n\nstruct Light {\n  vec3 position;\n  float intensity;\n  vec3 color;\n};\n    \nstruct Surface {\n  float dist;\n  vec3 position;\n  vec3 baseColor;\n  vec3 normal;\n  vec3 emissiveColor;\n};\n    \nstruct Hit {\n  Surface surface;\n  Surface near;\n};\n    \nfloat saturate(float s) {\n  return clamp(s, 0., 1.);\n}\n\nfloat invert(float m) {\n  return 1.0 / m;\n}\n\nmat2 invert(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 invert(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 invert(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\nmat4 scale(vec3 s) {\n  return invert(mat4(\n    s.x, 0., 0., 0.,\n    0., s.y, 0., 0.,\n    0., 0., s.z, 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateX(float angle) {\n  return invert(mat4(\n    1., 0., 0., 0.,\n    0., cos(angle), -sin(angle), 0.,\n    0., sin(angle), cos(angle), 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateY(float angle) {\n  return invert(mat4(\n    cos(angle), 0., sin(angle), 0.,\n    0., 1., 0., 0.,\n    -sin(angle), 0., cos(angle), 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateZ(float angle) {\n  return invert(mat4(\n    cos(angle), -sin(angle), 0., 0.,\n    sin(angle), cos(angle), 0., 0.,\n    0., 0., 1., 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 translate(vec3 p) {\n  return invert(mat4(\n    1., 0., 0., p.x,\n    0., 1., 0., p.y,\n    0., 0., 1., p.z,\n    0., 0., 0., 1.\n  ));\n}\n\nfloat sphere(vec3 p, float size) {\n  return length(p) - size;\n}\n\nfloat box(vec3 p, vec3 size) {\n  vec3 d = abs(p) - size;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat tube2(vec2 p, float size) {\n  return length(p) - size;\n}\n\nfloat box2(vec2 p, float size) {\n  return length(max(abs(p) - size, 0.));\n}\n\nfloat cylindar(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat displacement(vec3 p, vec3 power) {\n  return sin(power.x * p.x) * sin(power.y * p.y) * sin(power.z * p.z);\n}\n\nvec3 repeat(vec3 p, float c) {\n  return mod(p, c) - c * .5;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat scene(vec3 p) {\n  vec3 _p = p;\n\n  _p = (vec4(_p, 1.)\n      * translate(vec3(cos(iTime) * 2., sin(iTime), 0.))\n      * rotateX(iTime)\n      * rotateY(iTime)\n      * rotateZ(iTime)\n      // * scale(vec3(1. + sin(iTime) * .1))\n   ).xyz;\n \n  return box(_p, vec3(.5));\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n  float k = 1.;\n  float occ = 0.;\n  for(int i = 0; i < 5; i++) {\n    float len = .15 * (float(i) + 1.);\n    float distance = scene(n * len + p);\n    occ += (len - distance) * k;\n    k *= .5;\n  }\n  return clamp(1. - occ, 0., 1.);\n}\n\nvec3 getNormal(vec3 p) {\n  const float e = EPS;\n  return normalize(vec3(\n    scene(p + vec3(e,   0.0, 0.0)) - scene(p + vec3(-e,  0.0, 0.0)),\n    scene(p + vec3(0.0,   e, 0.0)) - scene(p + vec3(0.0,  -e, 0.0)),\n    scene(p + vec3(0.0, 0.0,   e)) - scene(p + vec3(0.0, 0.0,  -e))\n  ));\n}\n\nSurface near(Surface needle, Surface target) {\n  if(needle.dist < 0. || needle.dist < target.dist) {\n    return needle;\n  }\n  return target;\n}\n\nHit rayMarching(vec3 origin, vec3 dir, float start, float end) {\n  Surface cs;  // current surface\n  cs.dist = -1.;\n    \n  Surface ns; // near surface\n  ns.dist = FLT_MAX;\n    \n  Hit hit;\n\n  float sceneDist = 0.;\n  float rayDepth = start;\n\n  for(int i = 0; i < maxIterations; i++) {\n    sceneDist = scene(origin + dir * rayDepth);\n      \n    // cache near distance\n    if(sceneDist < ns.dist) {\n      ns.dist = sceneDist;\n    }\n\n    if((sceneDist < stopThreshold) || (rayDepth >= end)) {\n     break;\n    }\n    rayDepth += sceneDist * stepScale;\n    cs.dist = rayDepth;\n  }\n    \n  /*\n  if (sceneDist >= stopThreshold) {\n    rayDepth = end;\n  } else {\n    rayDepth += sceneDist;\n  }\n  */\n    \n  cs.dist = rayDepth;\n  hit.surface = cs;\n  hit.near = ns;\n\n  return hit;\n}\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  vec3 lightDir = light.position - position;\n  vec3 ref = reflect(-normalize(lightDir), normal);\n  float specular = 0.;\n  if(diffuse > 0.) {\n    specular = max(0., dot(ref, normalize(cameraPos - normal)));\n    float specularPower = 32.;\n    specular = pow(specular, specularPower) * light.intensity;\n  }\n  return specular;\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos) {\n  vec3 position = surface.position;\n\n  vec3 color = vec3(0.);\n  vec3 sceneColor = vec3(0.);\n  vec3 normal = getNormal(position);\n\n  vec3 objColor = vec3(.8, .4, .4);\n  vec3 specularColor = vec3(1., .6, .6);\n\n  Light directionalLight;\n  directionalLight.position = vec3(5., 5., 5.);\n  directionalLight.intensity = .8;\n  directionalLight.color = vec3(.8, .4, .4);\n\n  Light pointLight;\n  pointLight.position = vec3(5., 5., 5.);\n  pointLight.intensity = .8;\n  pointLight.color = vec3(.8, .5, .5);\n\n  Light ambientLight;\n  ambientLight.color = vec3(.1, .1, .1);\n  ambientLight.intensity = .3;\n    \n  // directional light\n  float dDiffuse = max(0., dot(normal, normalize(directionalLight.position)));\n  dDiffuse *= directionalLight.intensity;\n  vec3 dDiffuseColor = dDiffuse * directionalLight.color * objColor;\n  float dSpecular = getSpecular(position, normal, directionalLight, dDiffuse, cameraPos);\n  vec3 dSpecularColor = dSpecular * specularColor;\n\n  // point light\n  vec3 pLightDir = pointLight.position - position;\n  float pDiffuse = max(0., dot(normal, normalize(pLightDir)));\n  vec3 pDiffuseColor = pDiffuse * pointLight.color * objColor;\n  float d = distance(pointLight.position, position);\n  vec3 k = vec3(.05, .9, .06);\n  float attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n  pDiffuse *= pointLight.intensity;\n  pDiffuse *= attenuation;\n  float pSpecular = getSpecular(position, normal, pointLight, pDiffuse, cameraPos);\n  pSpecular *= attenuation;\n  vec3 pSpecularColor = pSpecular * specularColor;\n    \n  // ambient\n  vec3 ambientColor = ambientLight.color * ambientLight.intensity * objColor;\n  float ao = calcAO(position, normal);\n\n  vec3 diffuse = dDiffuseColor + pDiffuseColor;\n  vec3 specular = dSpecularColor + pSpecularColor;\n  vec3 ambient = ambientColor * ao;\n\n  color += objColor * diffuse + specular + ambient * ao;\n    \n  return color;\n}\n\nfloat distanceToLine(vec3 origin, vec3 dir, vec3 point) {\n\tvec3 pointToOrigin = point - origin;\n    float pointToOriginLength = length(pointToOrigin);\n    vec3 pointToOriginNorm = normalize(pointToOrigin);\n    float theta = dot(dir, pointToOriginNorm);\n    return pointToOriginLength * sqrt(1. - theta * theta);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n  vec2 screenCoord = (2. * fragCoord.xy / iResolution.xy - 1.) * aspect;\n  vec2 mouse = iMouse.xy / iResolution.xy - .5;\n  \n  // camera settings\n  vec3 lookAt = vec3(0., 0., 0.);\n  //vec3 cameraPos = vec3(mouse.x * 3., mouse.y * 3., 3.);\n  vec3 cameraPos = vec3(0., 0., 5.);\n  float fov = .6;\n  float nearClip = 0.;\n  float farClip = 80.;\n\n  // camera vectors\n  vec3 forward = normalize(lookAt - cameraPos);\n  vec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, forward));        \n\n  // raymarch\n  vec3 rayOrigin = cameraPos;\n  vec3 rayDirection = normalize(forward + fov * screenCoord.x * right + fov * screenCoord.y * up);\n  Hit hit = rayMarching(rayOrigin, rayDirection, nearClip, farClip);\n  Surface surface = hit.surface;\n  Surface near = hit.near;\n\n  surface.position = rayOrigin + rayDirection * surface.dist;\n    \n  // color\n  vec3 sceneColor = vec3(0.);\n    \n  // emissive\n  vec3 eColor = vec3(2., .1, .1);\n  float ea = 1.;\n  float em = pow(near.dist + 2., -2.);\n  sceneColor += em * eColor;\n  \n  // no hit or too far\n  if(surface.dist >= farClip) {\n    vec3 bgColor = vec3(0.);\n    fragColor = vec4(sceneColor + bgColor, 1.);\n    return;\n  }\n\n  sceneColor += eColor;\n  // sceneColor += lighting(surface, cameraPos);\n\n  fragColor = vec4(sceneColor, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2SWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 573, 573, 602], [604, 604, 627, 627, 647], [649, 649, 670, 670, 775], [777, 777, 798, 798, 1340], [1342, 1342, 1363, 1363, 2821], [2824, 2824, 2844, 2844, 2956], [2958, 2958, 2985, 2985, 3127], [3129, 3129, 3156, 3156, 3298], [3300, 3300, 3327, 3327, 3469], [3471, 3471, 3495, 3495, 3607], [3609, 3609, 3643, 3643, 3672], [3674, 3674, 3704, 3704, 3796], [3798, 3798, 3831, 3831, 3860], [3862, 3862, 3894, 3894, 3937], [3939, 3939, 3971, 3971, 4009], [4011, 4011, 4051, 4051, 4124], [4126, 4126, 4156, 4156, 4187], [4189, 4189, 4228, 4228, 4295], [4297, 4297, 4318, 4318, 4568], [4570, 4570, 4600, 4600, 4831], [4833, 4833, 4857, 4857, 5119], [5121, 5121, 5167, 5167, 5263], [5265, 5265, 5329, 5329, 6031], [6033, 6033, 6124, 6124, 6449], [6451, 6451, 6499, 6499, 8365], [8367, 8367, 8424, 8424, 8680], [8682, 8682, 8737, 8737, 10100]], "test": "valid"}
{"id": "Wd2Szh", "name": "Orange Tunnel", "author": "moditone", "description": "A simple shader that generates a striped tunnel.\nUsed for tutorials and videos about Wire, our real-time shader editing software.\nhttps://moditone.com/wire", "tags": ["tunnel", "orange", "stripe"], "likes": 8, "viewed": 753, "published": "Public API", "date": "1552925589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License: Do What the Fuck You Want to Public License (http://www.wtfpl.net/)\n\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Compute the center of the tunnel\n\tvec2 center = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    // Fix aspect ratio\n    center.x *= iResolution.x / iResolution.y;\n    \n    // Animate the center of the tunnel\n    center.x += sin(iTime) * 0.2;\n    center.y += cos(iTime) * 0.15;\n    \n    // Generate the tunnel stripes\n    float a = 1. / length(center) + atan(center.x, center.y) / PI * 1.0 + iTime;\n    float b = sin(a * PI * 8.) * dot(center, center) * iResolution.y / 150. - 0.3;\n    float c = b * sin(length(center) - .1);\n\t\n    fragColor = mix(vec4(0, 0, 0, 1), vec4(0.5, 0.25, 0, 1), c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2Szh.jpg", "access": "shaders20k", "license": "wtfpl-2.0", "functions": [[0, 107, 164, 204, 771]], "test": "valid"}
{"id": "wd2Szm", "name": "Infinite Yin Yangs Mini", "author": "KilledByAPixel", "description": "This is a minified version of my recursive Yin Yang shader that I made for JS1K. In addition to the nice infinite recursion, it also features a special smooth yin yang formula I developed.\n\nOfficial JS1k Entry Here: https://js1k.com/2019-x/demo/4187", "tags": ["procedural", "2d", "fractal", "zoom", "recursion"], "likes": 8, "viewed": 554, "published": "Public API", "date": "1553378282", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Infinite Yin Yangs Mini - By Frank Force - Copyright 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\n// official JS1k entry - https://js1k.com/2019-x/demo/4187\n\n#define T iTime\n#define R iResolution\n#define M iMouse\n\n//////////////////////////////////////////////////////////////////////////////////\n\n// code minified with ctrl-alt-test + a few tweaks\n\n// it may seem like some stuff could be smaller, but for my javascript\n// version it gets compressed with with jscrush which works really\n// well on duplicate code sections. So rather then save a calcuation in\n// a local variable, it's often better to copy paste.\n\n/*\n#define P(i)vec2(-(step(.5,fra\\\nct(3.7*sin(i)))-.5)*sin(A(i)),(step(.5,fract(3.7*sin(i)))-.5)*cos(A(i)))\n#define A(i)(6.283*fract(3.7*sin(i))+.7*mix(-1.,1.,fract(3.7*sin(i)))*T)\nvoid mainImage( out vec4 U, in vec2 Z ){vec2 p=(2.*Z.rg-R.rg)/R.g+.5*ve\\\nc2(sin(.2*T),sin(.3*T));float i=floor(T-length(p)),m=T-i-length(p),z=po\\\nw(2.718,-log(3.333)*m)*.08,v=0.;p=p*z+P(i);for(float r=0.;r<9.;++r)p+=P\\\n(i+r+1.)/3.333*pow(.3,r);for(float r=0.;r<9.;++r){m=-A(i);p=vec2(p.r*co\\\ns(m)-p.g*sin(m),p.r*sin(m)+p.g*cos(m));float b=5.*z/min(R.g,R.r),c=1.,l\\\n=length(2.*p+vec2(0,1)),d=l;if(p.r<0.)c=mix(c,0.,smoothstep(1.-b,1.+b,l\\\n));l=length(2.*p-vec2(0,1));if(p.r>0.)c=mix(0.,c,smoothstep(1.-b,1.+b,l\\\n));if(p.g>0.)d=l;v=mix(c,v,smoothstep(1.-b,1.,length(p)));if(d>.6){v=mi\\\nx(step(0.,p.g),v,smoothstep(.72,.72+b,d));if(d<.72+b&&p.g>0.)++i;break;\\\n}p.g+=mix(.5,-.5,v=step(0.,p.g));z*=2./.6;p*=2./.6;m=A(i);p=vec2(p.r*co\\\ns(m)-p.g*sin(m),p.r*sin(m)+p.g*cos(m));++i;}U=vec4(v*vec3(1.+sin(i+T+i)\\\n,1.+sin(i+T+1.),1.+sin(i+T+2.)),1.);} // Infinite Yin Yangs Mini\n*/\n\n// magic stuff\n#define A(i)(6.283*fract(3.7*sin(i))+.7*mix(-1.,1.,fract(3.7*sin(i)))*T)\n#define P(i)vec2(-(step(.5,fract(3.7*sin(i)))-.5)*sin(A(i)),(step(.5,fract(3.7*sin(i)))-.5)*cos(A(i)))\n\nvoid mainImage( out vec4 _FragColor, in vec2 _FragCoord )\n{\n    // standard uv fixup\n\tvec2 p = (2.0*_FragCoord.xy-R.xy)/R.y + 0.5*vec2(sin(0.2*T),sin(0.3*T));\n    \n    // get the recursion values\n\tfloat i = floor(T-length(p)),\n        m = T - i-length(p), \n        z = pow(2.718, -log(3.333)*m) * .08,\n        v = 0.;\n    \n    // get the zoom position\n    p = p*z+ P(i);\n\tfor (float r = 0.; r < 9.; ++r)\n\t\tp += (P(i+r+1.) / 3.333) * pow(1. / 3.333, r);\n    \n\t// recursion\n    for (float r = 0.; r<9.; ++r)\n    {\n        // rotate\n        m = -A(i);\n        p=vec2(p.x*cos(m) - p.y*sin(m), p.x*sin(m) + p.y*cos(m));\n\n        // yin yang function\n        float b = 5.*z/min(R.y, R.x),\n        c = 1.0,\n        l = length(2.0*p + vec2(0, 1)),\n        d = l;\n        if (p.x < 0.0)\n            c = mix(c, 0.0, smoothstep(1.0-b, 1.0+b, l));\n\n        l = length(2.0*p - vec2(0, 1));\n        if (p.x > 0.0)\n            c = mix(0.0, c, smoothstep(1.0-b, 1.0+b, l));\n        if (p.y > 0.0)\n            d = l;\n\n        v = mix(c, v, smoothstep(1.0-b, 1.0, length(p)));\n\n        if (d > .6)\n        {\n\t\t\t// stop if outside\n            v = mix(step(0.0, p.y), v, smoothstep(.6+.12,.6+.12+b,d));\n\n\t\t\t// fix color around the edges\n            if (d < .72+b && p.y > 0.0) ++i;\n            break;\n        }\n\n        // which side are we on?\n        p.y += mix(0.5, -0.5,  v = step(0.0,p.y));\n\n        // update zoom and position\n        z *= 2./.6;\n        p *= 2./.6;\t \n        \n        // unrotate\n        m = A(i);\n        p=vec2(p.x*cos(m) - p.y*sin(m), p.x*sin(m) + p.y*cos(m));\n       \t++i;\n    }\n    \n\t// final coloring\n    _FragColor = vec4(v*vec3(1.+sin(i+T+i),1.+sin(i+T+1.),1.+sin(i+T+2.)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2Szm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1885, 2077, 2136, 2161, 3768]], "test": "valid"}
{"id": "Wd2XDm", "name": "(RE)fractor", "author": "fabiovergani", "description": "descent, refactor", "tags": ["fract"], "likes": 11, "viewed": 233, "published": "Public", "date": "1554059382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\noriginal by mathmasterzach in 2018-09-28\nhttps://www.shadertoy.com/view/4tGczc\nrefactor by fabiovergani 2019-03-31\nhttps://www.shadertoy.com/view/Wd2XDm\n*/\n\nvec2 g(float n){\n\treturn vec2(\n\t\t  .01*sin(n*40.)+.03*sin(n*13.),\n\t\t  .03*cos(n*21.)+.08*cos(n*3.)+1.*n\n\t );\n}\n\nfloat f(vec3 p,int l){\n\t vec2 q=g(p.z);\n\t float m,s=1.,t=-max(abs(p.x+q.x),abs(p.y+q.y));\n\t p=fract(p)-.5;\n\t for(int i=1;i<l;++i){\n\t\t  s*=m=dot(p,p)*.7;\n\t\t  p/=m;\n\t\t  p.xy=fract(p.xy)-.5;\n\t\t  p=p.yzx;\n\t }\n\t s=clamp(.5+.5*((m=min(m,(length(p)-1.)*s))-t)/.05,.0,1.);\n\t return mix(t,m,s)+s*(1.-s)*.05;\n}\n\nfloat h(vec3 p){\n\t return min(\n\t\t  (\n\t\t\t\tmax(\n\t\t\t\t\t f(p,11),\n\t\t\t\t\t (\n\t\t\t\t\t\t  p.xy+=g(p.z),\n\t\t\t\t\t\t  .012-max(abs(p.x),abs(p.y))\n\t\t\t\t\t )\n\t\t\t\t)\n\t\t  ),\n\t\t  (\n\t\t\t\tp.y+=.01,\n\t\t\t\tmax(abs(p.x),abs(p.y))-.001\n\t\t  )\n\t );\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\n\t vec2 M=iMouse.xy,R=iResolution.xy,u=2.*(fragCoord/R)-1.;\n\n\t float c,X=M.x,Y=M.y,x=R.x,y=R.y,i=X/x,j=Y/y,l=128.+i*j,t=iTime/20.;\n\n\t R=vec2(i,j)*10.;\n\t u.x*=x/y;\n\n\t vec3 p=vec3(c,.1,c),\n\t o=vec3(-g(t),t),\n\t n=normalize(o),\n\t q=normalize(cross(n,p)),\n\t r=vec3(u.xy,1.5);\n\n\t vec4 k=vec4(1.,.6,.3,3.);\n\n\t p=vec3(R.x,R.y,c);\n\t r.yz*=mat2(c=cos(x=p.y),y=sin(x),-y,c);\n\t r.xy*=mat2(c=cos(x=p.z),y=sin(x),-y,c);\n\t r.xz*=mat2(c=cos(x=p.x),y=sin(x),-y,c);\n\n\t r=mat3(q,cross(q,n),n)*normalize(r);\n\n\t c=47.;\n\t M=vec2(i=t=.0,y=.0001);\n\t while(i<l){\n\t\t  if(x=h(p=o+r*t),x<y){break;};\n\t\t  t+=x*.5;\n\t\t  j=++i;\n\t };\n\t x=dot(\n\t\t  -r,\n\t\t  normalize(\n\t\t\t\tvec3(\n\t\t\t\t\t (r=M.yxx,h(p+r)-h(p-r)),\n\t\t\t\t\t (r=M.xyx,h(p+r)-h(p-r)),\n\t\t\t\t\t (r=M.xxy,h(p+r)-h(p-r))\n\t\t\t\t)\n\t\t  )\n\t )*.5+c*.01;\n\t fragColor=vec4(\n\t\t  mix(\n\t\t\t\tmix(\n\t\t\t\t\t n=k.xxx,\n\t\t\t\t\t clamp(abs(fract((c*f(p,6))+k.xyz)*6.-k.www)-n,.0,1.),\n\t\t\t\t\t 1.\n\t\t\t\t)*(x+pow(x,c)),\n\t\t\t\tr,\n\t\t\t\tj/l\n\t\t  ),1.\n\t );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2XDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 160, 176, 176, 270], [272, 272, 294, 294, 572], [574, 574, 590, 590, 786], [788, 788, 841, 841, 1773]], "test": "valid"}
{"id": "wd2XDW", "name": "Ray Marching OnOnOn", "author": "peterparnes", "description": "Just learning ray marching.... interact using mouse. ", "tags": ["raymarching"], "likes": 2, "viewed": 52, "published": "Public", "date": "1553875075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= max(iResolution.x, iResolution.y) / iResolution.y;\n    uv.y *= max(iResolution.x, iResolution.y) / iResolution.x;\n    \n    float basey = iMouse.y/iResolution.y * iTime * 2.; \n    // if(basey == 0.) basey = iTime * 2.;\n    \n    float basez = iMouse.x/iResolution.x*iTime*2.0;   \n    if(basez == 0.) basez = iTime*2.0;\n    \n    vec3 base = vec3(sin(basey*2.0), basey, basez);\n    vec3 pos = mod(base + vec3(uv, 2.) + vec3(.5), 10.) - vec3(5.); \n    vec3 dir = sin(normalize((vec3(uv*1., 2.))));\n    \n    const int Steps = 100;\n    int i;\n    float mind = 10000000.;\n    float di;\n    for (i = 0, di = 0.; i < Steps; i++) {\n    \tfloat d = length(pos - vec3(0., 0., 0.1)) - 1.4;\n        di = di + step(d, 0.000001);\n        mind = min(mind, d);\n        pos = mod(pos + d * dir + vec3(5.), 10.) - vec3(5.);\n    }\n    \n    float c = di / float(Steps) * (1. - mind)*abs(sin(iTime/2.));\n    fragColor = vec4(c, 1.0-c, c, 0.) * 1.3*(di / float(Steps));\n    \n    float bgcol = abs(sin(iTime*2.))*0.25;\n    if(c==0.) fragColor=vec4(0.,0.,bgcol,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2XDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1159]], "test": "valid"}
{"id": "wd2XRR", "name": "RayTracing tutorial - step 7", "author": "BrunoLevy", "description": "Ray tracing tutorial - step 7\nMultiple reflections", "tags": ["raytracing"], "likes": 5, "viewed": 570, "published": "Public API", "date": "1552754550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FARAWAY=1e30;\nconst float EPSILON=1e-6;\n\n// The viewing parameters\n// Gathers all parameters needed to launch primary rays\nstruct Camera {\n    vec3 Obs;    // The position of the observer\n    vec3 View;   // Unit vector, points to the target\n    vec3 Up;     // Unit vector, vertical direction\n    vec3 Horiz;  // Unit vector, horizontal direction\n    float H;     // Screen height in pixels\n    float W;     // Screen width in pixel\n    float z;     // offset of the screen along View\n};\n\n// \\brief A ray, in parametric form. \nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\n// \\brief Initializes a Camera\n// \\param[in] Obs the position of the observer\n// \\param[in] Target the point that will be in the center\n// \\param[in] aperture the aperture angle in degrees\n// \\return the initialized Camera\nCamera camera(in vec3 Obs, in vec3 Target, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(Target - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\n// \\brief Launches a primary Ray\n// \\param[in] C the Camera\n// \\param[in] XY the pixel coordinates in [0,W-1] x [0,H-1]\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\n// \\brief A sphere, defined by its center and radius\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\n// \\brief Material gathers all shading properties\nstruct Material {\n    vec3 Kd;       // diffuse color\n    vec3 Ke;       // emissive color\n    vec3 Kr;       // reflective material\n    float checker; // checkerboard size\n    vec3 Ks;       // specular\n    float s;       // specular factor\n};\n\n// \\brief Shorthand for the zero vector\nconst vec3 zero3 = vec3(0.0, 0.0, 0.0);\n\n// \\brief Creates a diffuse material\n// \\param[in] Kd the diffuse color\n// \\return the created Material\nMaterial diffuse(in vec3 Kd) {\n   return Material(Kd, zero3, zero3, 0.0, zero3, 0.0);\n}\n\n// \\brief Creates a light (emissive) material\n// \\param[in] Ke the color of the light\n// \\return the created Material\nMaterial light(in vec3 Ke) {\n   return Material(zero3, Ke, zero3, 0.0, zero3, 0.0);\n}\n\n// \\brief Creates a mirror material\n// \\param[in] Kd the diffuse color\n// \\param[in] Kr the reflection coefficient\n// \\return the created Material\nMaterial mirror(in vec3 Kd, in vec3 Kr) {\n   return Material(\n     Kd, zero3, Kr, 0.0, vec3(1.0, 1.0, 1.0), 30.0\n   );\n}\n\n// \\brief Creates a shiny material\n// \\param[in] Kd the diffuse color\n// \\param[in] Ks the specular coefficient\n// \\return the created Material\nMaterial shiny(in vec3 Kd, in vec3 Ks) {\n   return Material(Kd, zero3, zero3, 0.0, Ks, 30.0);\n}\n\n// \\brief Creates a checkerboard material\n// \\param[in] Kd the diffuse color\n// \\param[in] sz size of the checkers\n// \\return the created Material\nMaterial checkerboard(in vec3 Kd, in float sz) {\n   return Material(Kd, zero3, zero3, sz, zero3, 0.0);\n}\n\n// \\brief An Object, with a shape (Sphere) and a Material\nstruct Object {\n   Sphere sphere;\n   Material material;\n};\n\n// \\brief The scene is stored in a global array\nObject scene[23];\n\n// \\brief Initializes the scene\nvoid init_scene() {\n\n   scene[0] = Object(\n      Sphere(vec3(0.0, 0.0, 0.0),0.5), \n      mirror(vec3(0.2, 0.5, 0.2), vec3(0.5, 0.5, 0.5))\n   );\n\n   scene[1] = Object(\n      Sphere(vec3(0.0, 0.0, -10000.0),9999.5),\n      checkerboard(vec3(1.0, 0.2, 0.5), 0.5)\n   );\n\n   scene[2] = Object(\n      Sphere(vec3(1.0, 0.0, 1.0),0.02),\n      light(vec3(1.0, 1.0, 1.0)) \n   );\n\n   for(int i=0; i<20; ++i) {\n     float beta = float(iFrame)/30.0 + float(i)*6.28/19.0;\n     float s = sin(beta);\n     float c = cos(beta); \n\n     scene[i+3] = Object(\n        Sphere(vec3(0.7*s, 0.7*c, 0.0),0.1), \n        mirror(vec3(1.0, 0.7, 0.7), vec3(0.3, 0.3, 0.3))\n     );\n   }\n}\n\n// \\brief Computes a Ray Sphere intersection\n// \\param[in] R the Ray\n// \\param[in] S the Sphere\n// \\param[out] t the intersection parameter\n// \\retval true if there was an intersection\n// \\retval false otherwise\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n\n// \\brief Computes a reflected Ray\n// \\param[in] I the incident Ray\n// \\param[in] P the point at which the reflection occurs\n// \\param[in] N the normal at P\n// \\return the reflected Ray\nRay reflect_ray(in Ray I, in vec3 P, in vec3 N) {\n   return Ray(\n      P,\n      -2.0*dot(N,I.Dir)*N + I.Dir\n   );\n}\n\n// \\brief Tests whether a Ray is in shadow\n// \\param[in] R a Ray that connects a point to a lightsource\n// \\retval true if the point is in shadow w.r.t. the lightsource\n// \\retval false otherwise\nbool shadow(in Ray R) {\n   for(int i=0; i<scene.length(); ++i) {\n        float t;\n        if(\n          scene[i].material.Ke == vec3(0.0, 0.0, 0.0) &&\n          intersect_sphere(R, scene[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\n// \\brief Computes the lighting\n// \\param[in] P the intersection point\n// \\param[in] N the normal to the intersected surface at P\n// \\param[in] material the material\n// \\param[in] Ray the incident Ray\n// \\return the computed color\nvec3 lighting(\n   in vec3 P, in vec3 N, in Material material, in Ray R\n) {\n\n   // If it is a lightsource, then return its color\n   // (and we are done) \n   if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n      return material.Ke;\n   }  \n\n   vec3 result = vec3(0.0, 0.0, 0.0);\n\n   // Compute the influence of all lightsources\n   for(int i=0; i<scene.length(); ++i) {\n      if(scene[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n         Ray R2 = Ray(P, scene[i].sphere.Center);\n         if(!shadow(R2)) {\n           vec3 E = scene[i].sphere.Center - P;\n  \n           // Diffuse lighting\n           float lamb = max(0.0, dot(E,N) / length(E));\n           vec3 Kd = material.Kd;\n           if(material.checker != 0.0 && \n              sin(P.x/material.checker)*\n              sin(P.y/material.checker) > 0.0) {\n               Kd = vec3(1.0, 1.0, 1.0) - Kd;\n           }\n           result += lamb * Kd * scene[i].material.Ke;\n\n           // Specular lighting\n           if(material.Ks != zero3) {\n               vec3 Er = 2.0*dot(N,E)*N - E;\n               vec3 View = R.Origin - P;\n               float spec=max(dot(Er,View),0.0);\n               spec /= sqrt(dot(Er,Er)*dot(View,View));\n               spec = pow(spec, material.s);\n               result += \n                  spec * material.Ks * scene[i].material.Ke;\n           }\n         }\n      }\n   }\n\n   return result;\n}\n\n// \\brief Computes the nearest intersection along a Ray\n// \\param[in] R the ray\n// \\param[out] P the intersection point\n// \\param[out] N the normal to the intersected surface at P\n// \\param[out] material the material of the intersected object\nbool nearest_intersection(\n   in Ray R, \n   out vec3 P, out vec3 N, out Material material\n) {\n   const float FARAWAY=1e30; \n   float t = FARAWAY;\n\n   for(int i=0; i<scene.length(); ++i) {\n       float cur_t;\n       if(\n          intersect_sphere(R, scene[i].sphere, cur_t) \n          && cur_t < t && cur_t > EPSILON \n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - scene[i].sphere.Center);\n           material = scene[i].material;\n       } \n   }\n   return (t != FARAWAY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   // Yes, it is a bit stupid to call this for each pixel,\n   // but well, does not cost that much...\n   init_scene();\n\n   float beta = float(iFrame)/150.0;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   // Initialize the Camera (and make it orbit around the\n   // origin)\n   Camera C = camera(\n       vec3(2.0*c, 2.0*s, 1.0),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n\n   // Lauch the primary ray that corresponds to this pixel\n   Ray R = launch(C, fragCoord);\n   \n   \n   fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n   vec3 P;  // Current intersected point\n   vec3 N;  // Normal to the intersected object at P\n   Material material; // Material of the intersected object\n \n   // Compute up to 5 ray bounces\n   vec3 Kr_cumul = vec3(1.0, 1.0, 1.0);\n   for(int k=0; k<5; ++k) {\n       if(nearest_intersection(R, P, N, material)) {\n          fragColor.rgb += Kr_cumul * lighting(P,N,material,R);\n          if(material.Kr == zero3) {\n              break;\n          }\n          Kr_cumul *= material.Kr;\n          R = reflect_ray(R, P, N);\n       } else {\n          fragColor.rgb += Kr_cumul * vec3(0.5, 0.5, 1.0);\n          break;\n       }\n   }  \n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2XRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[588, 811, 874, 874, 1172], [1174, 1294, 1331, 1331, 1428], [1908, 2012, 2042, 2042, 2099], [2101, 2219, 2247, 2247, 2304], [2306, 2453, 2494, 2494, 2573], [2575, 2719, 2759, 2759, 2814], [2816, 2963, 3011, 3011, 3067], [3254, 3286, 3305, 3305, 3940], [3942, 4154, 4213, 4213, 4479], [4481, 4667, 4716, 4716, 4782], [4784, 4980, 5003, 5003, 5287], [5289, 5520, 5594, 5672, 6881], [6883, 7126, 7219, 7219, 7648], [7650, 7650, 7707, 7810, 8863]], "test": "valid"}
{"id": "wdBSDD", "name": "EmeraldCanyons", "author": "bignobody", "description": "Took my raymarcher with shadows and reflections (usual thanks to iq, Jamie Wong, BigWIngs) and added some noise and simple fog.", "tags": ["noise", "raymarch", "reflections"], "likes": 1, "viewed": 113, "published": "Public", "date": "1553867350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/WsfSDB\n#define NUM_LIGHTS 1\n#define MAX_REFLECTIONS 2\n#define AMBIENT_LIGHT 1.61\n\n\nvec3 colours[9] = vec3[](vec3(0.2,0.4,0.6), vec3(0.0,0.6,0.13), vec3(0.5,0.5,0.55), vec3(0.8,0.7,0.2), vec3(0.18,0.64,0.38), vec3(0.75,0.51,0.1), vec3(0.95,0.41,0.51), vec3(0.3,0.4,0.8), vec3(0.2,0.6,0.6));\nvec3 speculars[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9));\nfloat shine[9] = float[](10.0,10.0,10.0,10.0,10.0,100.0,1.0,10.0,10.0);\nfloat reflectivity[9] = float[](0.4,0.3,0.85,0.65,0.65,0.65,0.75,0.75,0.5);\n\nvec3 intensities[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.8,0.8,0.8), vec3(0.4,0.4,0.4), vec3(0.1,0.4,0.8), vec3(0.25,0.51,0.1), vec3(0.35,0.81,0.01), vec3(0.1,0.3,0.4), vec3(0.9,0.9,0.9));\n\n// noise from bookofshaders.com\n// 2D Random\nfloat random (in vec2 st) \n{\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) \n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// adapted sdf functions by iq\nfloat sdfSphere(vec3 p, vec3 t, float r)\n{\n\treturn length(p-t)-r;   \n}\nfloat sdfPlane( vec3 p, vec3 t, vec4 n )\n{\n  // n must be normalized\n  return dot(p-t,n.xyz) + n.w;\n}\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nfloat opSmoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n////////\n\n// objects map\nfloat distanceToClosest(vec3 p, inout int pick)\n{\n    float def = 500.0;\n    float n = noise(vec2(p.x,p.z)*0.132471795);\n    float q = noise(vec2(p.x,p.z)*1.32471795) * 0.888;\n    vec3 pn = p*n;\n    float d = sdfPlane( pn * n,vec3(0.0,-2.0,0.0),normalize(vec4(0.0,1.0,0.0,1.0)));\n    d = opSmoothSub(sdfPlane( pn * q,vec3(0.0,-2.0,0.0),normalize(vec4(0.0,1.0,0.0,1.0))),d,0.5);\n    pick = 1;\n    \n    if (d > def)\n    {\n      d = def;\n      pick = 0;\n    }\n\n\tfloat s = sdfSphere(p, vec3(0.0,1.5, -10.0 + iTime * 2.8), 0.5);\n    if (s < d)\n    {\n     \td = s;\n        pick = 6;\n    }\n    return d;\n}\n\nvec3 estimateNormal(vec3 p, inout int pick)\n{\n    const float EPSILON = 0.001;\n return normalize(vec3(\n        distanceToClosest(vec3(p.x + EPSILON, p.y, p.z),pick) - distanceToClosest(vec3(p.x - EPSILON, p.y, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y + EPSILON, p.z),pick) - distanceToClosest(vec3(p.x, p.y - EPSILON, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y, p.z  + EPSILON),pick) - distanceToClosest(vec3(p.x, p.y, p.z - EPSILON),pick)\n    ));   \n}\n\nvec3 getLightPosition(int l)\n{\n\tvec3 lps[6] = vec3[](vec3(0.0,4.0,-10.0 + iTime * 2.8),\n\t\t\t\tvec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,5.5* cos(iTime * 0.5)),\n                vec3(5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 1.3)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 2.7)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 4.5)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 0.5)));\n    if (l > 5)\n    {\n        return lps[0];\n    }\n\n    return lps[l];\n}\n// soft shadows from iq's tutorial\nfloat shadowMarch( vec3 lightOrigin, vec3 surfacePoint )\n{\n    vec3 direction = normalize((lightOrigin)-surfacePoint);\n    float blendFactor = 128.18;\n    int pickTarget = 0;\n  \tfloat res = 1.0;\n    float ph = 1e20;\n    float end = distance(lightOrigin, surfacePoint);\n    for( float s=0.0001; s < end; )\n    {\n        vec3 marchStep = lightOrigin + direction * s;\n        float distNow = distanceToClosest(marchStep, pickTarget);\n        if( distNow<0.001)\n            return 0.0;\n        float y = distNow*distNow/(2.0*ph);\n        float d = sqrt(distNow*distNow-y*y);\n        res = min( res, blendFactor*d/max(0.0,s-y) );\n        ph = distNow;\n        s += distNow;\n    }\n    return res; \n}\nvec3 lightSurfacePoint(vec3 eye, vec3 surfacePoint, vec3 surfaceNormal, float ambientLight, int materialPick)\n{\n\tvec3 surfaceColour = vec3(0.0);\n    float shadow = 1.0;\n\t\n    for (int l = 0; l < NUM_LIGHTS; l ++)\n    {\n        vec3 lightPos = getLightPosition(l);\n        vec3 N = surfaceNormal;\n    \tvec3 L = normalize(lightPos - surfacePoint);\n    \tvec3 V = normalize(eye - surfacePoint);\n    \tvec3 R = normalize(reflect(-L, N));\n        \n    \tfloat dotLN = dot(L, N);\n    \tfloat dotRV = dot(R, V);\n    \tvec3 colour = colours[materialPick] * 0.01;\n    \tif (dotLN < 0.0) \n\t\t{\n        \t// Light not visible from this point on the surface\n        \tcolour =  colours[materialPick] * 0.01;\n    \t} \n    \telse if (dotRV < 0.0) \n\t\t{\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        \tcolour = intensities[l] * (colours[materialPick] * dotLN);\n            shadow = min(shadow, shadowMarch(lightPos, -surfacePoint));\n    \t}\n        else\n        {\n    \t\tcolour = intensities[l] * (colours[materialPick] * dotLN + speculars[materialPick] * pow(dotRV, shine[materialPick]));\n            shadow = min(shadow, shadowMarch(lightPos, -surfacePoint));\n        }\n\n        surfaceColour += colour;//phongLight((colours[materialPick]* shadow *ambientLight), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], surfacePoint, normal, eye);\n    }\n\treturn surfaceColour * ambientLight * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 1.0;\n\tfloat ext = iTime * 2.8;\n    vec3 lookAt = vec3(cos(ext*0.09),-1.9,ext);\n    vec3 camOrigin = vec3(0.0,-2.8,-10.0 + ext);\t\n    vec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n    \n    // config and work variables\n    int numReflections = MAX_REFLECTIONS;\n    vec3 surfacePoint = vec3(0.0);\n    vec3 col = vec3(0.1,0.3,0.44);\n\n\tfloat marchDistance = 0.0f;\n    vec3 marchVec = camOrigin;\n    int pickTarget = 0;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const int MAX_STEPS = 96;\n    const float MAX_DISTANCE = 96.0;\n    const float CLOSE_ENOUGH = 0.0001;\n\tconst int MAX_REFLECT_STEPS = 96;\n\tconst float MAX_REFLECT_DISTANCE = 64.0;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n\n    vec3 colAccum = vec3(0.0);\n  \n    for (int i = 0; i < MAX_STEPS; i ++)\n    {\n        marchStep = marchVec + rayDirection * marchDistance;\n     \tdistNow = distanceToClosest(marchStep, pickTarget);\n        \n        if (distNow <= CLOSE_ENOUGH)\n        {\n            // hit something!\n            surfacePoint = marchStep;\n    \t\tsurfaceNormal = estimateNormal(surfacePoint, pickTarget);\n            \n            colAccum = lightSurfacePoint(camOrigin, surfacePoint, surfaceNormal, AMBIENT_LIGHT, pickTarget);\n\n            vec3 lastDirection = rayDirection;\n            vec3 lastSurfacePoint = surfacePoint;\n            vec3 lastSurfaceNormal = surfaceNormal;\n\t\t\t\n            for(int r = 0; r < numReflections; r ++)\n            {\n\t\t\t\t\n                vec3 reflectOrigin = lastSurfacePoint;\n                vec3 reflectDirection = normalize(reflect((lastDirection), lastSurfaceNormal));\n                float reflectDistance = 0.001;\n    \t\t\tvec3 reflectVec = reflectOrigin;\n    \t\t\tvec3 reflectNormal = vec3(0.0);\n    \n        \t\tfloat reflectDist = 0.0;\n                float refMixVal = 0.35;\n\t\t    \tfor (int k = 0; k < MAX_REFLECT_STEPS; k ++)\n    \t\t\t{\n                    // march again from our new origin and accumulate colour from hit materials\n        \t\t\treflectVec = reflectOrigin + reflectDirection * reflectDistance;\n     \t\t\t\treflectDist = distanceToClosest(reflectVec, pickTarget);\n        \n        \t\t\tif (reflectDist <= CLOSE_ENOUGH)\n        \t\t\t{\n\t\t\t\t\t\t// hit something else!\n            \t\t\tlastSurfacePoint = reflectVec;\n    \t\t\t\t\tlastSurfaceNormal = estimateNormal(lastSurfacePoint, pickTarget);\n                        lastDirection = reflectDirection;\n                        colAccum = mix (colAccum, lightSurfacePoint(reflectOrigin, lastSurfacePoint, lastSurfaceNormal, AMBIENT_LIGHT, pickTarget), mix(reflectivity[pickTarget],refMixVal,0.5));\n                \t\trefMixVal = min(0.95, refMixVal+0.1);\n\t\t\t\t\t\t\n                        reflectDistance = 0.001;\n                        reflectDist = 0.0;\n                        reflectOrigin = lastSurfacePoint;\n                \t\treflectDirection = normalize(reflect((lastDirection), lastSurfaceNormal));\n                        break;\n       \t\n        \t\t\t}\n        \t\t\telse\n                    {\n        \t\t\t\treflectDistance += reflectDist;   \n        \n        \t\t\t\tif (reflectDistance >= MAX_REFLECT_DISTANCE)\n        \t\t\t\t{\n            \t\t\t\t// sky colour\n            \t\t\t\t pickTarget = 0;\n        \t\t\t\t\tcolAccum = mix(colAccum, colours[pickTarget] - reflectDirection.y * 0.5, mix(reflectivity[pickTarget],refMixVal,0.5));\n                        \tbreak;\n        \t\t\t\t}\n                    }\n        \n    \t\t\t}\n\n            }\n\n\t\t\tbreak;         \t\n        }\n        else\n        {\n         \tmarchDistance += distNow;   \n        }\n        if (marchDistance >= MAX_DISTANCE)\n        {\n            // sky colour\n        \tpickTarget = 0;\n\t\t\tcolAccum =  colours[pickTarget] - rayDirection.y * 0.5;\n            break;\n        }\n    }\n    \n    col = colAccum;\n\n\tvec3 fog = colours[0];\n\tfloat fogamt = 1.0 - exp(-marchDistance*0.01);\n\t\n    float cn = noise(vec2(col.x,col.z)*random(uv*marchDistance));\n\tcol = mix(col,vec3(cn),0.33);\n\tcol = mix(col,fog,clamp(fogamt,0.0,1.0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[884, 929, 957, 957, 1074], [1076, 1163, 1190, 1190, 1707], [1709, 1740, 1782, 1782, 1810], [1811, 1811, 1853, 1879, 1912], [1913, 1913, 1950, 1950, 1972], [1973, 1973, 2026, 2026, 2126], [2127, 2127, 2177, 2177, 2277], [2278, 2278, 2313, 2313, 2335], [2337, 2337, 2374, 2374, 2395], [2406, 2421, 2470, 2470, 3018], [3020, 3020, 3065, 3065, 3492], [3494, 3494, 3524, 3524, 4115], [4116, 4151, 4209, 4209, 4844], [4845, 4845, 4956, 4956, 6285], [6287, 6287, 6344, 6384, 10783]], "test": "valid"}
{"id": "WdBSDm", "name": "Pink wave 1", "author": "bjwebb", "description": "Pink wave 1", "tags": ["pink"], "likes": 0, "viewed": 229, "published": "Public API", "date": "1553955817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float angle =  iTime / 2. + uv.y;\n    float intensity = 0.5 + 0.5*sin(cos(angle)*fragCoord.x/10.0 + sin(angle)*fragCoord.y/10.0);\n\n    // Output to screen\n    fragColor = vec4(intensity*vec3(1.0,0.0,1.0),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBSDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 396]], "test": "valid"}
{"id": "WdBSR1", "name": "PUMA CELL", "author": "yasuo", "description": "Just an experiment.", "tags": ["cell", "puma"], "likes": 4, "viewed": 296, "published": "Public API", "date": "1552837741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdLine( p, a, b );\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\n\nvec4 map(vec3 p){\n    p *= matRotateZ(radians(iTime*5.0));\n    p.y-= iTime*0.3;\n    vec3 pref = p;\n    \n    float animateH = sin(iTime*3.0)*0.02;\n    \n    pref.x = mod(pref.x,0.4)-0.2;\n    pref.y = mod(pref.y,0.7)-0.35;\n    pref*= matRotateZ(radians(30.0));\n    float d0 = sdHexPrism(pref+ vec3(0.0,0.0,-1.0),vec2(0.17,0.06+animateH));\n    float d01 = sdHexPrism(pref+ vec3(0.0,0.0,-1.0),vec2(0.2,0.05+animateH));\n    d0 = max(-d0,d01);\n    pref = p;\n    \n    animateH =  sin(iTime*2.0)*0.02;\n    pref += vec3(0.2,-0.35,-1.0);\n    pref.x = mod(pref.x,0.4)-0.2;\n    pref.y = mod(pref.y,0.7)-0.35;\n    pref*= matRotateZ(radians(30.0));\n    float d1 = sdHexPrism(pref,vec2(0.17,0.06+animateH));\n    float d11 = sdHexPrism(pref,vec2(0.2,0.05+animateH));\n    d1 = max(-d1,d11);\n    pref = p;\n    \n    return vec4(vec3(0.0,0.7,0.0),opSmoothUnion(d0,d1,0.07));\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tmat3 camRotY = matRotateY(radians(sin(iTime)*3.0));\n    \n\tvec3 ro=vec3(0.,0.0,0.0);\n    vec3 rd=normalize(vec3(p,1.0));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 30; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>13.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t)*camRotY;\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 13.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n        vec3 V = distPos;\n        vec3 L = normalize(lightDir-V);\n        \n        vec3 E = normalize(-V);\n        vec3 R = normalize(-reflect(L, normal));\n        \n\t\t// difuse color\n        float diffuseVal = 2.7;\n        float diffuse = diffuseVal * max(dot(normal, L), 0.0);\n        diffuse = clamp(diffuse, 0.0, 1.0);\n        \n\t\tfloat specVal = 0.9;\n\t\tfloat shininess = 10.0;\n\t\tfloat spec = specVal * pow(max(dot(R, E), 0.0), 0.3*shininess);\n        spec = clamp(spec, 0.0, 1.0);\n\t\t\t\t\n        float AmbientVal = 1.5;\n        vec3 AmbientColor = vec3(0.5);\n        vec3 DiffuseColor = vec3(0.3,0.3,0.3);\n        vec3 SpecularColor = vec3(0.9);\n\t\tvec3 ambient = AmbientVal * AmbientColor;        \n        \n\t\tfloat lambert = max(.0, dot( normal, light));\n\n\t\t// result\n\t\tcolor = (distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        color *= ambient +(DiffuseColor * diffuse)+ (SpecularColor*spec);\n\t}else{\n        color =.84*max(mix(vec3(0.1,0.11,0.15)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n    vec3 white = vec3(1.0);\n    vec3 logoCol = vec3(0.0);\n    vec2 logoPos = vec2(0.4,0.0);\n    \n    p.x+=(mod(iTime,2.0)<0.3)?sin(floor(p.y*20.0)*iTime*30.)*0.03:0.0;\n    \n\tlogoCol = line( logoCol, vec2(0.0, 0.07), vec2(0.0, -0.07), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n\tlogoCol = line( logoCol, vec2(0.0, -0.1), vec2(0.12, -0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.0, 0.1), vec2(0.12, 0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    \n    logoCol = line( logoCol, vec2(0.2, 0.07), vec2(0.2, -0.07), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n\tlogoCol = line( logoCol, vec2(0.2, -0.1), vec2(0.32, -0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.2, 0.1), vec2(0.32, 0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.24, 0.0), vec2(0.32, 0.0), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    \n\tlogoCol = line( logoCol, vec2(0.4, 0.1), vec2(0.4, -0.07), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.4, -0.1), vec2(0.52, -0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.6, 0.1), vec2(0.6, -0.07), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.6, -0.1), vec2(0.72, -0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    \n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = color*brightness;\n\tfragColor = vec4(dst+logoCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 293, 293, 576], [578, 578, 630, 630, 730], [732, 732, 781, 781, 891], [893, 893, 976, 976, 1110], [1112, 1112, 1129, 1129, 1967], [1969, 1969, 1992, 1992, 2242], [2244, 2244, 2300, 2300, 5438]], "test": "valid"}
{"id": "WdBSWR", "name": "Electric Ball", "author": "kubiak", "description": "Just a weird electric ball.", "tags": ["ball", "electric", "electricity"], "likes": 6, "viewed": 754, "published": "Public API", "date": "1553316315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float ringAmp = 0.025;\nfloat ringThickness = 0.01;\nfloat ringFreq = 20.0;\n\n// random/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nvec4 quatForAxisAngle(float angle, vec3 axis) {\n    vec4 q;\n    \n    float half_angle = angle/2.0;\n    q.x = axis.x * sin(half_angle);\n    q.y = axis.y * sin(half_angle);\n    q.z = axis.z * sin(half_angle);\n    q.w = cos(half_angle);\n    return q;\n}\n\nvec3 spherePos(vec2 uv, vec3 ro, float radius, out float h) {\n    //vec3( 0.0, 0.0, 5.0 );\n    vec3 rd = normalize( vec3( uv, -radius ) );\n\n    // intersect sphere\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - 1.0; \n    h = b*b - c;\n    \n    float t = -b - sqrt(h);\n    vec3 pos = ro + t*rd;\n    return pos;\n}\n\nvec3 rotateVectorY(vec3 v, float angle) {\n    vec4 q = quatForAxisAngle(angle, vec3(0.0, 1.0, 0.0));\n    vec3 temp = cross(q.xyz, v) + q.w * v;\n    return v + 2.0*cross(q.xyz, temp); \n}\n\nvec3 ringColor(vec3 bg, float pct) {\n    vec3 baseColor = vec3(0.3, 0.3, 1.0);\n    vec3 boost = (1.0 + (1.0-pct)) * vec3(3.5, 3.5, 3.5);\n    float a = (1.0 - pct) * 0.6;\n    \n    return mix(bg, baseColor * boost, a);\n}\n\nvec3 doRing(vec3 col, vec3 pos, vec2 uv, float down) {\n    float centerDist = 0.7 - abs(0.5 - uv.x);\n    centerDist = pow(centerDist, 4.0);\n    \n    float normSin = sin(pos.z * ringFreq + iTime * 15.0) * ringAmp + 0.5 - (centerDist * 0.5 * down);\n    \n    normSin += noise(pos*15.0) * 0.02;\n    normSin += noise(pos*2.0) * 0.02;\n    //normSin += noise(pos*15.0) * 0.02;\n    \n    float d = abs(normSin - uv.y);\n    if(d < ringThickness)\n    {\n        col = ringColor(col, d / ringThickness);\n    }\n    \n    return col;\n}\n\nvec2 rotate2d(vec2 p, float a) {\n    vec2 rpt = vec2(0.5, 0.5);\n    p = p - rpt;\n\tfloat x = p.x * cos(a) - p.y * sin(a);\n\tfloat y = p.y * cos(a) + p.x * sin(a);\n    return vec2(x, y) + rpt;\n}\n\nvec3 DoRings(vec2 uv, vec2 p, float angle) {\n    float h;\n    uv = rotate2d(uv, angle);\n    \n    vec3 pos = spherePos(p, vec3( 0.0, 0.0, -2.5 ), -2.0, h);\n    vec3 posRotated = rotateVectorY(pos, iTime * -0.5);    \n    vec3 col;\n    col = doRing(col.rgb, posRotated, uv, -1.0);    \n    pos = spherePos(p, vec3( 0.0, 0.0, 2.5 ), 2.0, h);\n    \n    posRotated = rotateVectorY(pos, iTime * -0.5); \n    col = doRing(col.rgb, posRotated, uv, 1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n        \n    vec4 col = vec4(0.0);      \n\n#if 1\n\tcol.rgb += DoRings(uv, p, 0.0);\n    col.rgb += DoRings(uv, p, 3.14 * 0.5);\n    col.rgb += DoRings(uv, p, 3.14 * 0.35);\n    col.rgb += DoRings(uv, p, 3.14 * 0.65);\n#else     \n    col.rgb += DoRings(uv, p, 0.0 + iTime *0.2);\n    //col.rgb += DoRings(uv, p, 3.14 * 0.5 + iTime*0.3);\n    col.rgb += DoRings(uv, p, 3.14 * 0.25 + iTime*-0.25);\n    //col.rgb += DoRings(uv, p, 3.14 * 0.75 + iTime*-0.1);\n    //col.rgb += DoRings(uv, p, 3.14 * 0.15 + iTime*0.05);\n    //col.rgb += DoRings(uv, p, 3.14 * 0.65 + iTime*-0.15);\n#endif\n    \n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 113, 136, 136, 174], [176, 197, 223, 223, 540], [542, 542, 563, 563, 676], [678, 678, 704, 704, 1228], [1230, 1230, 1277, 1277, 1479], [1481, 1481, 1542, 1571, 1797], [1799, 1799, 1840, 1840, 1984], [1986, 1986, 2022, 2022, 2204], [2206, 2206, 2260, 2260, 2725], [2727, 2727, 2759, 2759, 2918], [2920, 2920, 2964, 2964, 3384], [3386, 3386, 3443, 3443, 4162]], "test": "valid"}
{"id": "wdBXRW", "name": "Polygon - distance 2D", "author": "iq", "description": "Distance to an arbitrary polygon, based on [url]https://www.shadertoy.com/view/WdSGRd[/url]", "tags": ["2d", "sdf", "distance", "polygon"], "likes": 36, "viewed": 5419, "published": "Public API", "date": "1553035020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a regular pentagon, without trigonometric functions. \n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N = 5;\n\nfloat sdPolygon( in vec2 p, in vec2[N] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n\tvec2 v0 = 0.8*cos( 0.40*iTime + vec2(0.0,2.00) + 0.0 );\n\tvec2 v1 = 0.8*cos( 0.45*iTime + vec2(0.0,1.50) + 1.0 );\n\tvec2 v2 = 0.8*cos( 0.50*iTime + vec2(0.0,3.00) + 2.0 );\n\tvec2 v3 = 0.8*cos( 0.55*iTime + vec2(0.0,2.00) + 4.0 );\n    vec2 v4 = 0.8*cos( 0.60*iTime + vec2(0.0,1.00) + 5.0 );\n    \n    // add more points\n    vec2[] polygon = vec2[](v0,v1,v2,v3,v4);\n    \n\tfloat d = sdPolygon(p, polygon);\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdPolygon( m, polygon );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBXRW.jpg", "access": "shaders20k", "license": "mit", "functions": [[1148, 1305, 1330, 1330, 1349], [1350, 1350, 1390, 1390, 1422], [1442, 1442, 1486, 1486, 2089], [2091, 2091, 2148, 2148, 3149]], "test": "error"}
{"id": "wdBXWw", "name": "Mandlebrot Set Fractal", "author": "v00doo32", "description": "Plain and simple", "tags": ["fractal"], "likes": 1, "viewed": 278, "published": "Public API", "date": "1553967588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// pal by iq\nvec3 pal (in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 pal_mandlebrot(float x) {\n\treturn pal( x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n}\n\nvec3 mandlebrot (vec2 uv) {\n\tvec2 c = uv;\n    vec2 z = uv;\n    int i = 0;\n    for(; i < 1000 && dot(z,z) < 32.0 ; ++i) {\n    \tz = vec2(z.x * z.x - z.y * z.y + c.x, 2.0 * z.x * z.y + c.y);\n    }\n    if(i == 1000) {\n    \treturn vec3(1.0);\n    }\n    float smooth_i = float(i) - log2(log2(dot(z,z)));\n    float ratio = smooth_i / 1000.0;\n    return pal_mandlebrot(ratio * 10.0);\n}\n\nvec2 remap (vec2 p) {\n\treturn -1.0 + 2.0 * p;\n}\n\nmat2 rotate (float time) {\n\tfloat s = sin(time);\n    float c = cos(time);\n    return mat2(\n    \tc, -s,\n        s, c\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 c = remap(uv) * 2.0;\n    c.x *= iResolution.x / iResolution.y;\n    float zoom = exp(-iTime);\n    vec2 offset = vec2(1.0, 0.0);\n    vec2 focus_point = vec2(-0.7463, 0.1102);\n    vec2 sub = offset - focus_point;\n    float angle = atan(sub.y, sub.x);\n    c += offset;\n    c *= zoom;\n    c *= rotate(angle);\n    c += focus_point;\n\tvec3 col = mandlebrot(c);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 80, 80, 123], [125, 125, 155, 155, 250], [252, 252, 279, 279, 628], [630, 630, 651, 651, 677], [679, 679, 705, 705, 803], [805, 805, 862, 862, 1299]], "test": "valid"}
{"id": "wdBXzz", "name": "Kurakin_Mashgraph_312", "author": "sheogarat1488", "description": "t-1000", "tags": ["raymarching"], "likes": 1, "viewed": 52, "published": "Public", "date": "1552676618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define max_steps 100\n#define max_dist 100.\n#define surface_dist .01\n//все фигуры взяты с distfunctions.htm\n//5 различных типа примитвов - тор, капсула, сфера, гексагональная призма и коробка\n//5 объектов - один анимирован\n//2 источника света\n\nfloat sdBox(vec3 p, vec3 b)//первый аргумент сдвиг, остальные размеры\n{\n  return length(max(abs(p) - b, 0.));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max((q.x*0.866025 + q.y*0.5), q.y) - h.x);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float t = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.); //нормализация путем / потом сужение t \n    return length(pa - ba*t) - r; //t - суть шаги\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat opS(float d1, float d2)//вычитание фигур\n{\n    return max(-d1, d2);\n}\n\n\n\n\nfloat GetDist (vec3 p) \n{\n    float dP = p.y; //planedistance - пока плоская поверхность\n    float hd = sdHexPrism(p - vec3(2, 1.5, 6), vec2 (0.3, 0.2));\n    float cd = sdCapsule(p, vec3(0, 1, 6), vec3 (1, 2, 6), .2);\n    float bd = sdBox(p - vec3(-3, .75, 6), vec3(.75));\n    float sd = sdSphere(p - vec3(-3, .75, 6), 1.); \n    float td = sdTorus(p - vec3(0, 0.5,6), vec2(1.5, .2)); //когда вычитаем - передвигаем тор\n  \t\n    float bd1 = sdBox(p - vec3(4, .75, 6), vec3(.75));\n    float sd1 = sdSphere(p - vec3(4, .75, 6), 1.); \n    float e = mix(sd1, bd1, sin(iTime) * .9); //анимированный объект\n    \n    float c = opS(sd, bd);//использование конструктивной сплошной геометрии\n    float d = min(cd, dP);\n    d = min(d, td);\n    d = min(d, hd);\n    d = min(d, c);\n    d = min(d, e);\n    return d;\n}\n\nfloat RayMarch (vec3 ro, vec3 rd) \n{\n\tfloat dO = 0.; //dO - расстояние от глаза\n\tfor (int i = 0; i < max_steps; i++) //не хотим слишком близко приближаться\n    {\n        vec3 p = ro + dO * rd; //p - текущее положение марша\n        float dS = GetDist(p);\n        dO = dO + dS;\n        if (dS < surface_dist || dO > max_dist) //на случай если мы вообще не видим объект или достигли желаемой точности\n        \tbreak;\n    }\n    return dO;\n}\n\nvec3 GetNormal (vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01, .0);\n    vec3 n = vec3(\n        d - GetDist(p - e.xyy),\n        d - GetDist(p - e.yxy),\n        d - GetDist(p - e.yyx)); //e.xyy =def= vec3(.01, 0, 0)\n    return normalize(n);\n}\n\nfloat GetLight (vec3 p) //на вход точка, ля которой хотим найти тень\n{\n    vec3 lightPos = vec3(0, 5, 6); //позиция первого источника\n    lightPos.xz = lightPos.xz + vec2(sin(iTime), cos(iTime)) * 6.;//движение лампочки \n    vec3 l = normalize(lightPos - p); //вектор света\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.); //clamp сжимает первое между 2 и 3 параметрами\n    float d = RayMarch(p + n * surface_dist * 2., l); //чуть отодвигаем от поверхности - иначе нууу все темное\n    if (d < length(lightPos - p)) //проверяем в тени ли мы\n    \tdif = dif * .1;\n    return dif;\n}\n\nfloat GetLight1 (vec3 p) \n{\n    vec3 lightPos = vec3(3, 5, -6); \n    vec3 l = normalize(lightPos - p); //вектор света\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);  \n    float d = RayMarch(p + n * surface_dist * 2., l); \n    if (d < length(lightPos - p)) \n    \tdif = dif * .1;\n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) //взято из ролика на ютубе, я сделал только поворот\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nmat2 Rot(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy; //даем возможность управления мышкой\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(5, 4, 3); //Задаем камеру, это координаты глаза\n    ro.yz *= Rot(-m.y);\n    ro.xz *= Rot(-m.x * 5.); //ускоряем потому что камера збрасывается\n\tvec3 rd = R(uv, ro, vec3(0,0,0), .7); //это ray direction = куда мы смотрим, вектор нормализован в функции R\n    \n  \n    float d = RayMarch(ro, rd); //from ray origin to ray dir\n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p) + GetLight1(p);//diffused lightning\n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 360, 466, 466, 506], [508, 508, 543, 543, 567], [569, 569, 605, 605, 697], [699, 699, 750, 750, 975], [977, 977, 1008, 1008, 1078], [1080, 1080, 1142, 1142, 1169], [1174, 1174, 1199, 1199, 2086], [2088, 2088, 2124, 2124, 2654], [2656, 2656, 2681, 2681, 2908], [2910, 2910, 3014, 3014, 3685], [3687, 3687, 3714, 3714, 4015], [4017, 4017, 4151, 4151, 4346], [4348, 4348, 4368, 4368, 4444], [4448, 4448, 4505, 4505, 5301]], "test": "valid"}
{"id": "wdfSD7", "name": "Cube-O-Sphere", "author": "cbrpnk", "description": "Everyday", "tags": ["raymarching"], "likes": 5, "viewed": 94, "published": "Public", "date": "1551404666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p)\n{\n    return fract(sin(dot(p, vec2(123.2345, 3456.5678))) * 123789.234235);\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 d)\n{\n    p = abs(p) - d;\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat noise(vec2 p)\n{\n\n    p *= 5.;\n    vec2 fl = floor(p);\n    vec2 fr = pow(fract(p), vec2(20.));\n    \n    float tl = rand(fl);\n    float tr = rand(vec2(fl.x + 1., fl.y));\n    float bl = rand(vec2(fl.x, fl.y+1.));\n    float br = rand(vec2(fl.x + 1., fl.y + 1.));\n    \n    float left = mix(tl, bl, fr.y);\n    float right = mix(tr, br, fr.y);\n    return mix(left, right, fr.x);\n}\n\nvec2 map(vec3 p)\n{\n    p.xz *= rot(iTime);\n    p.yz *= rot(iTime);\n    float s = length(p)-1.;\n    float s2 = length(p)-.9;\n    s = max(min(max(s, -s2), length(p)-.8), box(p, vec3(1.*abs(sin(iTime)))));\n    float lat = dot(normalize(p), vec3(0, 0, -1));\n    float lon = dot(normalize(p), vec3(0, 1, 0));\n    return vec2(s + noise(vec2(lat, lon)*sin(iTime))*.1*abs(sin(iTime)), 0.);  \n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    vec2 t = vec2(0.);\n    for(int i=0; i<128; ++i) {\n    \tvec2 d = map(ro+rd*t.x);\n        if(d.x < .0001) break;\n        t.x += d.x*.6;\n        t.y = d.y;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(.001, 0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyy).x - map(p-eps.xyy).x,\n        map(p+eps.yxy).x - map(p-eps.yxy).x,\n        map(p+eps.yyx).x - map(p-eps.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy) / iResolution.y;\n\n    vec3 cam = vec3(0, 0, 2.5-abs(sin(iTime)));\n    vec3 dir = normalize(vec3(uv, -1));\n    vec2 res = march(cam, dir);\n    vec3 col = vec3(1.);\n    \n    if(abs(uv.y) > .7) {\n        col = vec3(0);\n    } else if(res.x < 100.) {\n            vec3 p = cam+dir*res.x;\n            vec3 normal = getNormal(p);\n            col = vec3(.1) * (1.-pow(max(0., dot(dir, -normal)), 2.));\n            col += vec3(.1) * (pow(max(0., dot(dir, -normal)), 100.));\n            col += vec3(.05) * max(0., dot(normal, vec3(1.))) * 1.5;\n            col += vec3(.05) * max(0., dot(normal, vec3(-1.))) * 1.5;\n    }\n    col += rand(uv*iTime)*.03;\n    //col = vec3(1.) * noise(uv);\n    col *= 1.-length(uv)*.2;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfSD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 96], [98, 98, 117, 117, 193], [195, 195, 222, 222, 280], [282, 282, 303, 303, 661], [663, 663, 681, 681, 1048], [1050, 1050, 1080, 1080, 1259], [1261, 1261, 1285, 1285, 1484], [1486, 1486, 1543, 1593, 2398]], "test": "valid"}
{"id": "WdfSDj", "name": "[TWITCH] Foldable Dbl Standards", "author": "evvvvil", "description": "\"Foldable double standards\" - Shader showdown practice session 010.\nLive coded on Twitch with 25 minutes time limit.\nPracticing live on TWITCH every Tuesdays around 21:00 UK time.\nhttps://www.twitch.tv/evvvvil_", "tags": ["time", "demoscene", "abstract", "double", "scene", "limit", "live", "battle", "shadershowdown", "coding", "twitch", "showdown"], "likes": 19, "viewed": 679, "published": "Public API", "date": "1552145019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\"Foldable double standards\" - Shader Showdown practice session 010\n\n// WHAT THE FUCK IS THE SHADER SHOWDOWN?\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader from memory on stage. \n// The audience votes for the winner by making noise or by voting on their phone.\n// Winner goes through to the next round until the final where champion is crowned.\n// Live coding shader software used is BONZOMATIC made by Gargaj from Conspiracy:\n// https://github.com/Gargaj/Bonzomatic\n\n// Every tuesdays around 21:00 UK time I practise live on TWITCH. This is the result of session 010.\n\n// COME SEE LIVE CODING EVERY TUESDAYS HERE: https://www.twitch.tv/evvvvil_\n\n// evvvvil / DESiRE demogroup\n\n// \"Fools running where angels fear to tread\" - Alexander Pope\n\nvec2 sc,e=vec2(.00035,-.00035);float t,tt,st,ct;vec3 np,op;//Some fucking globals, about as exciting as a flooded wellbeing yoga centre \nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}//box function stolen from UNC because UNC from QUITE always finds my shit jokes funny.\nvec2 fb( vec3 p )//Fucking bits function which makes the fucking bit/piece it is a base shape which we clone and repeate to create the whole geometry in mp function\n{\n  vec2 h,t=vec2(bo(p,vec3(6,0.5,0.5)),5);  //Bunch of fucking mediocre boxes\n  t.x=min(t.x,bo(abs(p)-vec3(3,0,0),vec3(0.8,0.5,100)));//more fucknig boxes\n  h=vec2(bo(p,vec3(6.2,0.7,0.2)),3);//Dude this fucking box thing again? Yeah but with different material id, fucking cheer up yeah?\n  h.x=min(h.x,bo(abs(p)-vec3(3,0,0),vec3(1,0.2,100)));  //Stacking boxes mengo\n  h.x=min(h.x,length(abs(p)-vec3(7,0,0))-1.2);//Oh look little fucking spheres on the sides? cute\n  t=(t.x<h.x)?t:h;//Merge both shapes while retaining material id, a friendly and colourful handshake basically\n  h=vec2(bo(p,vec3(0.5,(15.+sin(op.z*.4+tt*10.)*5.)*(1.-ct),0.5)),6.);//Makes the spikes in scene 01\n  t=(t.x<h.x)?t:h;//Merge both shapes while retaining material id, a friendly and colourful handshake basically\n  t.x*=0.8; return t;\n}\nfloat noise(vec3 p){//Noise function stolen from Virgil who stole it from Shane who I assume understands this shit, unlike me who is too busy argueing about the poetry of football hooliganism\n  vec3 ip=floor(p),s=vec3(7,157,113);\n  p-=ip; vec4 h=vec4(0,s.yz,s.y+s.z)+dot(ip,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//simple rotate function, it is useful as fuck and short. Bit like Muggsy Bogues in the 90's\nvec2 mp( vec3 p ) //This is the main MAP function where all geometry is made/defined. It's centre stage broski, bit like a drunken Belgian monk in a hipster's shitty brewing party\n{\n  op=p;//Remember that orignal position broski? Yeah I agree, there was more individual freedom in the 90s, bring back smoking and football hooliganism\n  p.xy*=r2(sin(p.z*0.2)*0.2+tt);//overall we're sort of twisting the fucker\n  p.z=mod(p.z+tt*10.,20.)-10.;//modulo is fucking shit, avoid it but hey to make it infinite on one axis is alright broski, it's even suitable for vegans\n  vec4 pp=vec4(p,1);//we make a new position which is vec4 to remember how much we scale it and apply that shit back to tweak domain scale and avoid artifact on line 61\n  vec2 h,t=vec2(10000,0);//We start with number super high, just like me on any given good saturday afternoon\n  for(int i=0;i<4;i++)//Pseudo fractal bullshit loop de loopo motherfucker\n  {\n    pp.xy*=r2(0.785*(2.*st));//Sometimes we rotate, sometimes we dont, depends on b animation variable\n    pp.xyz=abs(pp.xyz)-mix(vec3(0,3,6),vec3(0,10,2),st);//Abs symetry clone geometry to get more, each iteration\n    pp*=1.5;//Each iteration we make fractal piece smaller\n    pp.xz*=r2(0.785*(1.+st));//rotate the fucking piece\n    h=fb(pp.xyz);h.x/=pp.w;//Finally each iteration we draw the piece of fractal\n    t=(t.x<h.x)?t:h;//Merge this iteration fractal piece with rest, like building blocks but without the DMT smoking and throwing pieces at the neighbour in euphoria\n  }\n  np=pp.xyz;//Aye remember the fucking position for later on lighting and gloss map bitch\n  p.xy*=r2(cos(p.z*1.5+tt*10.)*0.5+tt*5.);//create pos for those shitty spheres in scene 2\n  h=vec2(length(p-vec3(cos(p.z*25.)*0.05+cos(p.x),0,0))-5.*st,6.);//Shitty sphere from scene 02 with nice twisty animation and frills\n  h.x*=0.5;//Scale sphere distance field to avoid artifact, keep it shallow and beautiful\n  t=(t.x<h.x)?t:h;//Merge the fucking fractal and spheres and shit\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd,float near,float far,int it )\n{\n  vec2 h,t=vec2(near);//Near plane because we all started as annoying little shits yeah, and nah, your kids aren't cute\n  for(int i=0;i<it;i++){//Main loop de loop \n    h=mp(ro+rd*t.x);//Marching forward like any good fascist army: without any care for culture theft\n    if(h.x<.0001||t.x>far) break;//Don't let the bastards break you down! Fuck the system!\n    t.x+=h.x;t.y=h.y;//Remember the postion and the material id? Because I can be a poncy interior designer too when I'v drunk enough Sherry\n  }\n  if(t.x>far) t.x=0.;//If we've gone to far then it's time to get on yer bike and get job\n  return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);//boilerplate code to get uvs in BONZOMATIC live coding software i use.\n    tt=mod(iTime*.5,50.);//MAin time variable, it's modulo'ed to avoid ugly artifact. Holding time in my hand: playing god seems better thanspending two months in rehab.\n\tst=0.5+clamp(sin(tt*0.5),-0.5,0.5);//These are just aniimation variables used in mp or fb\n  \tct=1.2+sin(tt*0.5);//Yeah this one too broski\n    vec3 ro=vec3(20,0,cos(tt)*10.),//Ro=ray origin=camera position because everything is relative to a view point, even your wife's failed wellbeing yoga centre\n    cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n    rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n    co,fo,ld=normalize(vec3(.5,.3,-.1));//ld=light direction, because god wouldn't be much without good lighting and vfx\n    co=fo=vec3(.04)*(1.-(length(uv)-.2));//By default the color fog color and it's a dark coloured vignette, because it's the colour of the sky in Loretta Lynn's \"Fist city\"\n    sc=tr(ro,rd,0.1,50.,128);t=sc.x;//This is where we shoot the fucking rays to get the fucking scene. Like a soldier but with a pixel gun and less intentions to invade and pillage.\n\t\n    if(t>0.){//If t>0 then we must have hit some geometry so let's fucking shade it. Grab an umbrella, it's like dinning at the beach\n        //We hit some geometry so let's get the current position (po) and build some normals (no). You do the Maths while I light up Diogenes' lamp as he searches for an honest person.\n        vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x),\n        //LIGHTING MICRO ENGINE BROSKI \n        al=vec3(0,.2,.4);//Albedo is base colour.\n        if(sc.y<5.)  al=vec3(0.9);//Change colour depending on material id, it's like a painting/decorating job but without the football banter, so it's kinda shit\n        //More colour change, color is gradient over y axis because Roy Hodgson is still in charge of Crystal Palace and they should be staying up this year\n        if(sc.y>5.)  al=mix(vec3(0.9,0.9,0.9),vec3(1,.5,0),0.5+0.5*sin(op.z*0.4+tt*10.));\n        no*=(1.+.6*ceil(cos(np*0.5)));no=normalize(no);//TRICK to add more detail to geometry by tweaking the normals don't forget to normalize after though, \"Honky Tonk girls better know not to break the rules!\"\n        float dif=max(0.,dot(no,ld)),//dif=diffuse because i ain't got time to cook torrance\n        aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),//aor =amibent occlusion range, ao = ambient occlusion\n        fr=pow(1.+dot(no,rd),4.),//Fr=fresnel which adds reflections on edges to composite geometry better, yeah could be reflected, but who gives a shit? Anyways just like your ex, it doesn't do much.\n        spo= exp2(1.+3.*noise(np/vec3(1,2,4)));//TRICK making a gloss map from a 3d noise function is a thing of fucking beauty\n        vec3 sss=vec3(0.5)*smoothstep(0.,1.,mp(po+ld*0.4).x/0.4),//sss=subsurface scatterring made by tekf from the wax shader, big up tekf! https://www.shadertoy.com/view/lslXRj\n        sp=vec3(0.5)*pow(max(dot(reflect(-ld,no),-rd),0.),spo);//Sp=specualr, sotlen from Shane and it's better than walking into cold puddle of water in the bathroom while only wearing socks\n        co=mix(sp+al*(.8*ao+0.2)*(dif+sss),fo,fr);//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n        co=mix(co,fo,1.-exp(-.00003*t*t*t));//Fog soften things, but it won't save your failed marriage, God will though! Grab a bible and put on some lingerie.\n    }\n    fragColor = vec4(pow(co,vec3(0.45)),1);//Cheap tone mapping, even cheaper than a date with your future ex girlfriend\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[966, 1044, 1068, 1068, 1114], [1114, 1202, 1368, 1368, 2181], [2182, 2182, 2202, 2373, 2596], [2597, 2597, 2614, 2614, 2657], [2657, 2750, 2931, 2931, 4739], [4740, 4740, 4797, 4797, 5404], [5405, 5405, 5462, 5462, 9374]], "test": "valid"}
{"id": "wdfSDX", "name": "study perlin noise", "author": "jfwf", "description": "study perlin noise", "tags": ["noise"], "likes": 1, "viewed": 57, "published": "Public", "date": "1552338544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat wrand1d(float x)\n{\n    return fract( sin(x)*10000.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x += iTime*0.1;\n    uv.x = uv.x * 10.0;\n    float samplei=floor(uv.x);\n    float samplef=fract(uv.x);\n    \n    float r = wrand1d( samplei*1.0 );\n    \n    float rnext = wrand1d( samplei+1.0 );\n    \n    float curvef=samplef*samplef*(3.0-2.0*samplef);\n    float rx=mix( r, rnext , curvef );\n    \n    int outputY = int(rx*iResolution.y);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4( vec3(r),1.0);\n    \n    if( outputY ==int(fragCoord.y) )\n    {\n        fragColor=vec4(0.);\n    }else\n    {\n        fragColor=vec4(1.);\n    }\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfSDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 26, 26, 63], [67, 67, 124, 124, 895]], "test": "valid"}
{"id": "WdfSRf", "name": "Mandelbrot 3", "author": "saidwho12", "description": "Just another mandelbrot shader", "tags": ["2d", "mandelbrot", "animation"], "likes": 0, "viewed": 55, "published": "Public", "date": "1551740364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define AA 2\n#define LOG2 0.30102999566\n#define PI 3.14159\n#define TAU 6.28\n\n#define time (.04*iTime)\n\nvec2 cmul(in float a1, in float b1, in float a2, in float b2) {\n\t\n    // (a1+b1)*(a2+b2)\n    // a1*a2 + a1*b2i + b1i*a2 + b1i*b2i\n    // a1*a2 + a1*b2i + b1i*a2 -b1i*b2i\n    return vec2(a1*a2 - b1*b2, a1*b2 + b1*a2);\n}\n\nvec2 cexp2(in float a, in float b) {\n    // (a+bi)(a+bi)\n    // a^2 + abi + abi + bi^2\n    // a^2 + 2abi + bi^2\n    // (a^2, 2abi + bi^2)\n    // (a^2 - b^2, 2abi)\n\treturn vec2(a*a - b*b, 2.*a*b);\n}\n\nvec3 hsv(in float x) {\n\treturn sin( TAU*(x + vec3(0,2,4)/3.) );\n}\n\nvec3 fire_color(float x)\n{\n    return\n        // red\n        vec3(1., 0., 0.) * x\n        // yellow\n        + vec3(1., 1., 0.) * clamp(x - .5, 0., 1.)\n        // white\n        + vec3(1., 1., 1.) * clamp(x - .7, 0., 1.);\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    O-=O;\n    \n    float S = TAU;\n    float i, N = 256., r = 2., zoom = exp(-5. + 5.*cos(S*time) );\n    vec2 L[] = vec2[](\n        vec2(-0.7453,0.1127),\n        vec2(-0.7463, 0.1102),\n        vec2(-1.25066, 0.02012),\n        vec2(-0.925, 0.266)\n    );\n    \n    vec2 R = iResolution.xy,\n        mo = iMouse.xy, p = iMouse.z > 0. ?\n        (mo+mo-R)/R.y :\n    \tL[int(floor(time))%L.length()];\n    \n    \n    for(int n = 0; n<AA; ++n) {\n        for(int m = 0; m<AA; ++m) {\n            vec2 z = vec2(0), c = (2.* (u + vec2(n,m)/float(AA)) -R)/R.y*zoom + p;\n            \n            i = -1.;\n            while(++i<N && !(length(z = cexp2(z.x,z.y)+c) > r));\n\n            O.w += (i+1.-log(log(length(z)+r))/LOG2);\n    \t}\n\t}\n\n\tO.rgb += fire_color( O.w/float(AA*AA)/N );\n    O.rgb = sqrt(O.rgb);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfSRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 212, 318, 367], [369, 369, 405, 531, 566], [568, 568, 590, 590, 633], [635, 635, 661, 661, 856], [858, 858, 899, 899, 1687]], "test": "error"}
{"id": "WdfSRS", "name": "Ancient Coin", "author": "spookyfox", "description": "Needed to get this idea out of my head. I need to create perhaps a centerpiece for the coin as well as experiment with parameters for the procedurally generated glyphs. Alas I am sleepy 💤.\n\nhttps://upload.wikimedia.org/wikipedia/commons/0/05/Palenque_gly", "tags": ["tiling", "polar"], "likes": 3, "viewed": 134, "published": "Public", "date": "1551653218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Many techniques from\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm.\n\nint   AA   = 1;\nfloat PI   = 3.14159265358;\nfloat PID2 = 1.57079632679;\nfloat PIM2 = 6.28318530718;\nfloat RT2  = 1.41421356237;\n\n// Tools\n\nfloat nrand(vec2 n) {\n    // https://www.shadertoy.com/view/4ssXRX\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n    float r = length(p);\n    float theta = atan(p.y, p.x);\n    if(theta < 0.0) {\n        theta = PIM2 + theta;\n    }\n    return vec2(r, theta);\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0));\n}\n\nfloat capsule(vec3 p, float h, float r) {\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\nfloat cylinder(vec3 p, vec2 h) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat tube(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nmat3 rotateX(float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1.0, 0.0, 0.0, 0.0, cx, sx, 0.0, -sx, cx);\n}\n\nmat3 rotateY(float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0.0, -sy, 0.0, 1.0, 0.0, sy, 0.0, cy);\n\n}\n\nmat3 rotateZ(float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, sy, 0.0, -sy, cy, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat smoothMin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat subtract(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat smoothSubtract(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nvec3 bend(vec3 p, float k) {\n    float c = cos(k * p.x);\n    float s = sin(k * p.x);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xy, p.z);\n}\n\nfloat repeat(float p, float c) {\n    return mod(p, c) - 0.5 * c;\n}\n\nvec4 tex(vec3 p, sampler2D s) {\n    // Inspired by https://www.shadertoy.com/view/4dj3Dw.\n\treturn texture(s, p.yz) + texture(s, p.xz) + texture(s, p.xy);\n}\n\n// Constructions\n\nfloat bars(vec3 p, float r) {\n    float s = 0.3 + 0.1 * r;\n    mat3 rot = rotateZ(PID2);\n    p += vec3(-2, -2.0, 0.8);\n    float d = capsule(rot * p, 3.0, s);\n    p.y += 0.5;\n    d = smoothMin(d, capsule(rot * p, 3.0, s), 0.1);\n    p.y += 0.5;\n    d = smoothMin(d, capsule(rot * p, 3.0, s), 0.1);\n    return d;\n}\n\nfloat wheel(vec3 p, float r) {\n    float d = sphere(p / vec3(1.0, 1.0, 0.5) + vec3(-3.3, 0.7, 0.8), 1.3 + 0.2 * r);\n    d = smoothMin(d, torus(rotateX(PID2) * (p + vec3(-3.3, 0.7, 0.8)), vec2(1.4, 0.2)), 0.3);\n    return d;\n}\n\nfloat glyph(vec3 p, float r) {\n    float d;\n    \n    float head = sphere(p / vec3(0.9, 2.2, 1.0) + vec3(-2.4, 0.0, 0.0), 1.0);\n    \n    float face = sphere(p / vec3(2.0, 1.8, 1.0), 1.0) - sin(p.x) * 0.5;\n    d = smoothMin(head, face, 0.8);\n    \n    float eyelid = sphere(bend(rotateY(-0.1) * rotateZ(r * 0.25) * p + vec3(-0.8, -0.3, 0.8), -0.7 + r) / vec3(1.2, 0.8, 1.0), 0.6);\n    d = smoothMin(d, eyelid, .3);\n    \n    float eye = sphere(p / vec3(1.0, 0.8, 1.0) + vec3(-0.8, 0.1, 0.8), 0.6);\n    d = smoothMin(eye, d, 0.1);\n    \n    vec3 pn = p + vec3(0.6, 0.5, 0.0);\n  \tpn *= rotateY(PI);\n    pn *= rotateZ(-0.3);\n    pn.y = pn.y + pn.x * (30. - pn.x) / 100.;\n    float nose = sphere(pn / vec3(1.0, 1.0, 0.7), 1.0 + r * 0.2) + sin(pn.x) * 0.5;\n    \n    float nostril = sphere(p + vec3(0.2, 0.9, 0.7), 0.5 + r * 0.2);\n    d = smoothMin(d, nose, 0.4);\n    d = smoothMin(nostril, d, 0.6);\n    \n    float hole = sphere(p + vec3(0.2, 1.3, 0.8), 0.2);\n    d = smoothSubtract(hole, d, 0.4);\n    \n    float mouth = sphere(bend(p + vec3(-0.5, 2., 0.0), -0.0) / vec3(1.0, 0.8, 0.8), 1.0 - r * 0.2);\n    d = smoothMin(d, mouth, 0.8);\n    \n    d = smoothMin(d, bars(p, r), 0.6);\n    \n    d = smoothMin(d, wheel(p, r), 0.6);\n    \n    float piece = sphere(bend(rotateZ(PI * 0.6) * (p + vec3(0.1, -1.7, 0.0)), -0.8 + 0.2 * r) / vec3(1.5, 0.7, 1.0), 0.7);\n    d = smoothMin(d, piece, 0.4);\n    \n    return d;\n}\n\nfloat coin(vec3 p) {\n    return cylinder(p, vec2(13.0, 0.8));\n}\n\nfloat rings(vec3 p) {\n    // TODO: Clean up.\n    p = vec3(toPolar(p.xy), p.z);\n    float r = 3.0;\n    p.x = mod(p.x, r) - 0.5 * r;\n    p.x /= r; \n    return tube(p, vec3(0.3, -0.4, 0.85));\n}\n\nfloat glyphs(vec3 p) {\n    // TODO: Clean up.\n    p = vec3(toPolar(p.xy), p.z);\n    p.x -= 0.45;\n    \n    float r = 3.0;\n    float ring = floor(p.x / r);\n    if (ring > 3.0 || ring < 1.0) {\n        return 100000.0;\n\t}\n    p.x = mod(p.x, r) - 0.5 * r;\n    p.x /= r;\n    \n    p.y /= PIM2;\n\tfloat theta = 1.0 / (4.0 * (ring + 2.0));\n    float pos = floor(p.y / theta);\n    p.y = mod(p.y, theta) - 0.5 * theta;\n    p.y /= theta;\n    \n    float f = nrand(vec2(ring, pos));\n \n    return glyph(rotateZ(PID2) * p / vec3(0.11) + vec3(1.5, 0.0, -3.0), f) * 0.11;\n}\n\nfloat map(vec3 p) {\n    float d;\n    \n    //float mx = iMouse.x / iResolution.x;\n    //p *= rotateY(mx * PIM2);\n    p *= rotateY(iTime);\n    \n    float r = 4.0 * PI;\n    d = coin(inverse(rotateX(PID2 + r)) * p);\n    \n    float dh = box(p, vec3(1.0));\n    d = subtract(dh, d);\n    \n    p.z = abs(p.z);\n    p.z -= 1.0;\n    p *= rotateX(PI * 1.0);\n    \n    float dr = rings(inverse(rotateX(r)) * p);\n    d = subtract(dr, d) + tex(p * 0.1, iChannel0).x * 0.1;\n    \n    float dg = glyphs(inverse(rotateX(r)) * p) + tex(p * 0.3, iChannel0).x * 0.02;\n    d = smoothMin(d, dg, 0.2);\n    \n    return d;\n}\n\nvec3 normal(vec3 p) {\n    // http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    float h = 0.001;\n\tvec2 k = vec2(1.0, -1.0);\n    return normalize(\n        k.xxx * map(p + k.xxx * h) +\n        k.xyy * map(p + k.xyy * h) +\n        k.yxy * map(p + k.yxy * h) +\n        k.yyx * map(p + k.yyx * h));\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float d;\n    float s = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 p = ro + rd * s;\n        d = map(p);\n        s += d;\n        if (d < 0.01) {\n            break;\n        }\n    }\n    return vec2(d, s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 c = vec3(0.0);\n    \n    // https://www.shadertoy.com/view/Xds3zN.\n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            vec2 o = vec2(i, j) / float(AA) - 0.5;\n    \t\tvec2 xy = (2.0 * (fragCoord.xy + o) - iResolution.xy) / iResolution.y;\n            \n\t\t\tvec3 ro = vec3(0.0, 0.0, -14.0);\n    \t\tvec3 rd = normalize(vec3(xy, 1));\n            vec2 dp = rayMarch(ro, rd);\n            \n            if (dp.x < 0.01) {\n                vec3 p = ro + rd * dp.y;\n                vec3 l = vec3(-5.0, 5.0, -3.0);\n                vec3 n = normal(p);\n                // Gold\n                // http://devernay.free.fr/cours/opengl/materials.html\n                vec3 kd = vec3(0.75164, 0.60648, 0.22648);\n                vec3 d = vec3(clamp(dot(n, normalize(l - p)), 0.0, 1.0));\n                vec3 ks = vec3(0.628281, 0.555802, 0.366065);\n                float es = 4.0;\n                vec3 v = normalize(ro - l);\n                vec3 h = normalize(v + l);\n                float s = dot(n, l) > 0.0 ? pow(clamp(dot(n, h), 0.0, 1.0), es) : 0.0;\n                //vec3 t = tex(p * 0.3, iChannel0).xyz * 0.2;\n                c += d * kd + s * ks;\n            }\n        }\n    }\n    c /= float(AA * AA);\n    \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfSRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 240, 261, 306, 375], [377, 377, 399, 399, 545], [547, 547, 574, 574, 629], [631, 631, 672, 672, 731], [733, 733, 765, 765, 866], [868, 868, 899, 899, 924], [926, 926, 955, 955, 1025], [1027, 1027, 1055, 1055, 1093], [1095, 1095, 1118, 1118, 1215], [1217, 1217, 1240, 1240, 1338], [1340, 1340, 1363, 1363, 1460], [1462, 1462, 1506, 1506, 1609], [1611, 1611, 1647, 1647, 1674], [1676, 1676, 1727, 1727, 1835], [1837, 1837, 1865, 1865, 1987], [1989, 1989, 2021, 2021, 2055], [2057, 2057, 2088, 2146, 2212], [2214, 2232, 2261, 2261, 2544], [2546, 2546, 2576, 2576, 2771], [2773, 2773, 2803, 2803, 4170], [4172, 4172, 4192, 4192, 4235], [4237, 4237, 4258, 4281, 4427], [4429, 4429, 4451, 4474, 4983], [4985, 4985, 5004, 5004, 5580], [5582, 5582, 5603, 5671, 5891], [5893, 5893, 5926, 5926, 6143], [6145, 6145, 6200, 6200, 7463]], "test": "error"}
{"id": "wdfSWf", "name": "[twitch] Attack Flower", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/AttackFlower.glsl", "tags": ["3d", "voxel", "live", "twitch"], "likes": 42, "viewed": 823, "published": "Public", "date": "1552345884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/AttackFlower.glsl\n\nThis is a voxel rendering technique (3D DDA I think), mainly found from IQ's https://www.shadertoy.com/view/4dfGzs\n*/\n\n#define MARCH_STEPS 300\n#define STOP_MOTION 0\n#define TEST_RAYMARCH 0\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat smin(float a,float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k * (1.0-k) * h;\n}\n\nfloat noise(vec3 p) {\n  vec3 ip = floor(p);\n  p=fract(p);\n  //p=smoothstep(0,1,p);\n  vec3 st = vec3(7,193,385);\n  vec4 val = dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 v = mix(fract(sin(val)*7845.558), fract(sin(val+st.x)*7845.558), p.x);\n  vec2 v2 = mix(v.xz,v.yw, p.y);\n  return mix(v2.x,v2.y, p.z);\n}\n\n\nfloat rnd(float t) {\n  return fract(sin(t*784.535)*5384.669);\n}\n\nfloat rnd(vec3 p) {\n  return fract(dot(sin(p*vec3(784.535,584.653,387.627)),vec3(5384.669)));\n}\n\nvec2 moda(vec2 p, float rep, float off) {\n  vec2 inter = vec2(atan(p.y,p.x), length(p.xy));\n  inter.x /= (2.0*PI);\n  //inter.x = (fract(inter.x*rep+0.5)-0.5)/rep;\n  inter.x = (fract(inter.x*rep+0.5)-0.5)/rep;\n  inter.x *= 2.0*PI;\n  return vec2(cos(inter.x),sin(inter.x))*inter.y;\n}\n\nfloat mapid = 0.0;\nfloat map(vec3 p) {\n\n#if STOP_MOTION\n  float framy = 0.15;\n  float t2 = floor(time/framy)*framy;\n#else\n  float t2 = time;\n#endif\n\n  vec3 pe = p;\n  pe.xz = moda(pe.xz, 12.0, 0.0);\n  //\n  pe.x -= 20.0;\n  float ps =6.0+clamp(pe.x*10.0,0.0,10.0);\n  float tmp = pe.x;\n  float anim = clamp((sin(t2*0.2)-0.5)*2.0,0.0,1.0);\n  pe.xy *= rot(0.5 + (tmp*0.1*(1.0+sin(t2*0.1)) + fract(t2*0.2)*2.0*PI)*anim);\n  pe.x = (fract(pe.x/ps+0.1)-0.5)*ps;\n  pe.y += tmp*0.2;\n  //pe.xy *= rot(0.5 + tmp*0.5);\n  float s = length((pe)*vec3(5,0.5,1))-5.0;\n  s = smin(s, length(p)-60.0, -30.0);\n  s = min(s, length((p-vec3(0,8,0))*vec3(0.3,1,0.3))-8.0);\n\n  float f = noise(p*0.1)-0.5;\n  float f2 = (noise(p*0.2)-0.4);\n  f += f2;\n  f = max(f, -5.0-p.y + 30.0 - min(30.0,length(p.xz)*0.7));\n\n  vec3 rp = p;\n  float dur = 0.1;\n  float stime = floor(t2/dur)*dur;\n  rp.xz *= rot(sin(rp.y*0.1 + t2*0.5)*0.5);\n  rp.zy *= rot(sin(rp.x*0.3)*0.3);\n  float size = 60.0-clamp(length(p.xz)*0.8-30.0,0.0,50.0);\n  rp.xz = (fract(rp.xz/size)-0.5)*size;\n  float c = length(rp.xz)-3.0;\n  c = smin(c, -30.0-p.y, -20.0);\n\n  float first = min(f,c);\n  float f3 = (noise(p*vec3(0.1,0.8,0.1)*0.5)-0.4);\n  float clouds = max(f3+0.2, +30.0+p.y);\n  first = min(first, clouds);\n\n  mapid = (s<first)?1.0:0.0;\n\n  return min(s, first);\n}\n\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 5.0));\n}\n\nvoid cam(inout vec3 p) {\n\n  p.yz *= rot(0.3 + sin(time*0.3)*0.17);\n  p.xz *= rot(time*0.2 + curve(time, 5.2)*2.0);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s = vec3(0,0,-50.0 - curve(time, 2.3)*10.0);\n  vec3 r = normalize(vec3(-uv, 0.5+0.3*curve(time, 1.3)));\n\n  cam(s);\n  cam(r);\n\n#if TEST_RAYMARCH\n  // Classic raymarching for test\n  vec3 p = s;\n  for(int i=0; i<150; ++i) {\n    float d = map(p);\n    if(d<0.001) break;\n    p+=r*d*0.5;\n    //p+=r*1;\n  }\n  vec2 off=vec2(0.01,0.0);\n  vec3 n = normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  vec3 id = vec3(1);\n  float t = length(p-s);\n  float fog = 1.0-pow(clamp(t/200.0,0.0,1.0), 2.0);\n#else\n\n  // Voxel stepping: 3D DDA\n\n  vec3 p = floor(s);\n  vec3 ri = 1.0/r;\n  vec3 rs = sign(r);\n  // find next 3 inner plane\n  vec3 offset = 0.5 + rs * 0.5;\n  // position of the next voxel\n  vec3 nextplane = p + offset;\n  // intersect with it\n  // this is the distance to the next voxel plane of the 3 axis\n  vec3 dist = (nextplane - s) * ri;\n\n  vec3 nearestaxis = vec3(0.0);\n  const int steps = MARCH_STEPS;\n  for(int i=0; i<steps; ++i) {\n\n    // break if the voxel is inside the surface\n    float curdist = map(p);\n    if(curdist<0.0) break;\n\n    // this will select an axis as the next one (1,0,0) or (0,1,0) or (0,0,1)\n    // it's depending on the smallest distance to the next plane\n    nearestaxis = step(dist.xyz, dist.yzx) * step(dist.xyz, dist.zxy);\n\n    // compute distance to the next voxel\n    dist += nearestaxis * rs * ri;\n\n    // step one around the selected axis\n    p += nearestaxis * rs;\n  }\n\n  // the center of the intersected voxel\n  vec3 id = p;\n  \n  // Get the 3 outer planes of the voxel\n  vec3 voxelpos = p + 1.0 - offset;\n  // Get the distance to the 3 planes\n  vec3 intersection = (voxelpos - s) * ri;\n  // Get the final distance, the biggest of the 3 planes\n  float t = max(intersection.x, max(intersection.y, intersection.z));\n\n  float maxdist = float(steps) / sqrt(3.0);\n\n  t = min(t, maxdist);\n\n  // final pixel intersection position\n  p = s + t*r;\n\n  float fog = 1.0-pow(clamp(t/maxdist,0.0,1.0), 2.0);\n  \n  // Compute the normal\n  vec3 n = (p-id-0.5)*2.0;\n  n = pow(abs(n),vec3(8.0)) * sign(n);\n  n = normalize(n);\n\n#endif\n\n  vec3 l = normalize(vec3(-1,-3,-2));\n  float f = pow(1.0-abs(dot(n,r)), 5.0);\n\n  vec3 base = mix(vec3(0.3), vec3(1,1,0.5), step(noise(id*0.3),0.5));\n  base = mix(base, vec3(0.5,1.0,0.5), step(id.y,-4.0));\n  base = mix(base, vec3(1.0,0.2,0.2)*1.0, mapid);\n  float clselect = step(id.y,-29.0) * (1.0-mapid);\n  if(clselect>0.5) n=-n;\n  base = mix(base, vec3(0.5,0.5,1.0)*100.0, clselect);\n\n  vec3 diff = base*(rnd(id) * 0.5+0.5);\n\n  vec3 col = vec3(0);\n  //col += (dot(n,l)*0.5+0.5);\n  \n  float ao = (getao(p,n,10.0) * 0.9+0.1) * (getao(p,n,3.0)*0.5+0.5);\n\n  col += diff * (dot(n,l)*0.5+0.5)*min(1.0,30.0*fog/t);\n  col += diff * f * fog;\n\n  col *= vec3(5.0*ao);\n  \n  col += exp(t*0.06) * 0.0005 * vec3(0.5,0.6,1.0);\n\n\n  col *= pow(max(0.0,1.1-length(uv*vec2(0.8,1.7))),1.5);\n\n  col = pow(col, vec3(0.4545));\n\n  //col = vec3(noise(vec3(uv*50,time)));\n\n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 461, 480, 480, 549], [551, 551, 589, 589, 672], [674, 674, 695, 695, 983], [986, 986, 1006, 1006, 1049], [1051, 1051, 1070, 1070, 1146], [1148, 1148, 1189, 1189, 1429], [1450, 1450, 1469, 1469, 2728], [2731, 2731, 2762, 2762, 2867], [2869, 2869, 2893, 2893, 2985], [2987, 2987, 3028, 3028, 3074], [3076, 3076, 3133, 3133, 6222]], "test": "valid"}
{"id": "wdfSzl", "name": "Sine wave (using ML) v2", "author": "baldand", "description": "A small neural network with 3 hidden layers trained to generate sine waves\nShader is performing one NN inference for every pixel of every frame to render wave\nVisually much improved version of https://www.shadertoy.com/view/wdsXzf with similar complexity", "tags": ["2d", "nn", "ml"], "likes": 2, "viewed": 449, "published": "Public API", "date": "1551869696", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// (c) 2019 Andrew Baldwin (twitter:baldand)\n// License = Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) (http://creativecommons.org/licenses/by-sa/4.0/)\n\n// Small neural network with 3 hidden layers trained to generate sin waves\n// We are doing one inference with this for every pixel of every frame\n\n// Visually much improved version of https://www.shadertoy.com/view/wdsXzf\n// with similar complexity \n\n// Hold down mouse button to see training function overlayed for reference\n\n// See also twitter thread: https://twitter.com/baldand/status/1103012877064196098\n\nfloat infer(float x) {\n    vec4 v0 = vec4(-1.0264335,0.016575987,0.7683726,-0.57450604);\n    vec4 b0 = vec4(0.0,-0.042287465,0.049600255,0.0);\n    mat4 m1 = mat4(-0.56684726,-0.42447406,-0.36447382,-0.8339071,0.24432479,0.2496291,-0.709689,-0.12151086,0.9585465,-0.041398026,1.0177039,0.9430456,-0.5929886,-0.3974017,0.3334772,0.16827136);\n    vec4 b1 = vec4(-0.23816654,-0.0063188616,0.17527269,0.07215821);\n    mat4 m2 = mat4(-0.9948269,-1.838438,-0.21110824,-0.6786317,-0.6233567,0.44844365,0.64205533,-0.22527963,1.2259004,0.65223193,-0.21527317,0.75108105,0.71074504,0.11111804,0.21951368,0.36050126);\n    vec4 b2 = vec4(-0.09698069,0.4032268,-0.0001141361,0.31100145);\n    vec4 v3 = vec4(-1.6929443,1.7160753,-0.46278292,2.285155);\n    float b3 = -0.102938406;\n    vec4 l1 = v0*fract(x)+b0;\n    vec4 l2 = m1*max(l1,0.)+b1;\n    vec4 l3 = m2*max(l2,0.)+b2;\n    vec4 l4 = v3*clamp(l3*l3*l3,0.,1.);\n    return smoothstep(0.,1.,b3+l4.x+l4.y+l4.z+l4.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float x = uv.x + iTime*.2;\n    float y = 0.25+0.5*infer(x);\n    float y_train = 0.5+0.25*sin(x*6.283185);\n    float r = smoothstep(y, y+.005, uv.y);\n    float r_train = smoothstep(y_train-.002, y_train, uv.y)*smoothstep(y_train+.002,y_train, uv.y);\n    vec3 col = mix(vec3(0.,0.3,0.5), vec3(0.,.9,1.), r);\n    if (iMouse.z > 0.) col += r_train;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfSzl.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[491, 575, 597, 597, 1530], [1532, 1532, 1589, 1589, 2011]], "test": "valid"}
{"id": "wdfXDS", "name": "fx2", "author": "fabiovergani", "description": "tmp", "tags": ["tmp"], "likes": 4, "viewed": 98, "published": "Public", "date": "1552256378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 R(in vec3 p, in float x){\n\tfloat y=p.y,\n\tc=cos(x),\n\ts=sin(x);\n\tx=p.x;\n\treturn vec3(\n\t\tc*x+s*y,\n\t\tc*y-s*x,\n\t\tp.z\n\t);\n}\n//=====================================================\n\n\nfloat box(in vec3 p, in vec3 b, in float r) {\n\treturn length(max(abs(p) - b + r, 0.0)) - r;\n}\n\n\n\n\n\n\n\n\nfloat getDistance(vec3 p,out vec4 q){\n\n\tfloat d=p.z;\n\t\n\tq.xyz=(p+=vec3(\n        2.*sin(d*.2+iTime*2.),\n        sin(d*.1+iTime),\n        .0\n    ));\n\n\tq.w=-2.;\n\n\td=-length(q.xy)+4.+.5*sin(atan(q.y,q.x)*6.)*sin(q.z);\n\n\td=min(d,max((d-.01)*clamp(.8,.0,1.)+.01,d-.4));\n\n\n\t// Flow of boxes and spheres\n\tvec3 r=p;\n\n\tr.z+=iTime*20.;\n\n\tfor(int i=0;i<3;++i){\n        \n \t   \tfloat a=floor(r.z/1.5+.5),\n\t\tb=a*3.+float(i);\n\n\t\tvec3 s=r-vec3(.4*sin(b),.4*sin(b*13.),1.5*a);\n        \n\t\ta=.08;\n        b=mod(b,2.);\n\t\tif(b<.5){\n            b=length(s)-a;\n\t\t}else{\n            b=box(R(s,b),vec3(a),.01);\n        };\n\n\t\tif(b<d){\n\t\t\tq.xyz=s;\n\t\t\tq.w=1.;\n\t\t\td=b;\n\t\t}\n        \n\t\tr.z+=.5;\n\t};\n\treturn d;\n}\n\n\n\nvec3 hsv2rgb(in vec3 hsv) {\n\n\treturn hsv.z *(1.0 + hsv.y * clamp(abs(fract(hsv.x + vec3(0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\n}\n\n\n\n\n//frag:color,coord\nvoid mainImage(out vec4 a,in vec2 b){\n    \n    //S,l,j\n\tfloat S=sin(iTime),l,j;\n\n    //c,d,n,g,z,p\n\tvec3 c,d,n,\n\t\n\tg=normalize(\n        vec3(\n            .2*cos(iTime),\n            .2*S,\n            cos(iTime*.3)\n        )\n    ),\n\t\n\tz=normalize(\n        cross(\n            R(\n                vec3(.0,1.,.0),\n                3.14*S*sin(iTime*.2)\n            ),\n            g\n        )\n    ),\n\t\n\tp=vec3(.0,.0,iTime*6.);\n\n    //#\n\tg=mat3(z,cross(g,z),g)*normalize(vec3((2.*b.xy-iResolution.xy)/iResolution.y,2.));\n\n\n\tvec4 q;\n\n\n\tl=.0;\n\tfor(int i=0;i<50;++i){\n        j=getDistance(p,q);\n\t\tif(j<.01||(l+=j)>50.){break;};\n\t\tp+=j*g;\n\t};\n\n\n\tif(l>50.){\n\t\tc=vec3(.0);\n\t}else{\n\n\n        b=vec2(.01,.0);\n\n        n=normalize(vec3(\n            getDistance(p+(d=b.xyy),q)-getDistance(p-d,q),\n            getDistance(p+(d=b.yxy),q)-getDistance(p-d,q),\t\t\n            getDistance(p+(d=b.yyx),q)-getDistance(p-d,q)\n        ));\n\n\n\n\t\td=normalize(vec3(.5,.0,-2.));\n\n\t\tc=pow(\n\t\t\t(\n\t\t\t\tmax(.2,dot(n,d))*\n\t\t\t\thsv2rgb(\n\t\t\t\t\tvec3(\n\t\t\t\t\t\tp.z*.1,\n\t\t\t\t\t\t.8+.2*sin(q.y*10.)*sin(q.z*10.),\n\t\t\t\t\t\t.6\n\t\t\t\t\t)\n\t\t\t\t)+\n\t\t\t\tpow(max(.0,dot(reflect(g,n),d)),4.)*.2\n\t\t\t)*\n\t\t\tpow(1.-l/50.,3.)*\n\t\t\tmax(1.,sin(p.z*.1)),\n\t\t\tvec3(.5)\n\t\t);\n\t};\n\n\ta=vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfXDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 122], [123, 181, 226, 226, 274], [283, 283, 320, 320, 962], [966, 966, 993, 993, 1117], [1122, 1141, 1178, 1195, 2354]], "test": "valid"}
{"id": "wdfXRj", "name": "Rainbow Cave 1", "author": "fabiovergani", "description": "Rainbow Cave", "tags": ["rainbow", "cave"], "likes": 7, "viewed": 186, "published": "Public", "date": "1551651351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 path(float z){\n\treturn vec2(\n\t\t.01*sin(z*40.),\n\t\t.03*cos(z*21.)+.5*sin(cos(z))\n\t);\n}\n\n\n\nfloat g(vec3 p){\n\n\tvec2 q=path(p.z);\n\tvec3 n=fract(p)-.5;\n\tfloat m,s=1.,a=.01,b=.001,t=max(abs(p.x+q.x),abs(p.y+q.y));\n\n\tfor(int i=1;i<9;++i){\n\t\tn/=m=dot(n,n)*.7;\n\t\tn.xy=fract(n.xy)-.5;\n\t\ts*=m;\n\t\tn.xyz=n.yzx;\n\t};\n\n\ts=min(9.,(length(n)-1.)*s);\n\n\tm=clamp(.3+.5*s/.05,a,1.);\n\n\tm=mix(-t,-s,m+t)+m*.05*sin(1.);\n\tp.xy+=path(p.z);\n\treturn min(\n\t\tmax(\n\t\t\tm,\n\t\t\ta-max(m=abs(p.x),abs(p.y))\n\t\t),\n\t\tmax(\n\t\t\tm-b,\n\t\t\tabs(p.y+=a)-b\n\t\t)\n\t);\n}\n\n\nvec3 f(float i){\n\ti+=iTime/20.;\n\treturn vec3(-path(i),i);\n}\n\n//fragColor,fragCoord\nvoid mainImage(out vec4 a,in vec2 b){\n\n\tfloat d,t=0.,n=.0001;\n\n\tvec2 q=2.*(b/iResolution.xy)-1.;\n\n\tvec3 c,p,o=f(t),\n\tw=normalize(f(.01)-o),\n\tr=cross(w,vec3(n,1.,t));\n\n\tr=mat3(\n\t\tr,\n\t\tnormalize(cross(r,w)),\n\t\tw\n\t)*normalize(\n\t\tvec3(q.xy,1.5)\n\t);\n\n\tvec4 K=vec4(1.,.7,.3,3.);\n\n\tfor(int i=0;i<128;++i){\n\t\td=g(p=o+r*t);\n\t\tif(d<n){break;};\n\t\tt+=d*.5;\n\t};\n\tq=vec2(.0,n);\n\n\td=max(n,dot(-r,normalize(\n\t\tvec3(\n\t\t\tg(p+(c=q.yxx))-g(p-c),\n\t\t\tg(p+(c=q.xyx))-g(p-c),\n\t\t\tg(p+(c=q.xxy))-g(p-c)\n\t\t)\n\t))*.5+.4);\n\n\n\n\tc=vec3(\n\t\t22.*mix(t=p.y,t,n),\n\t\tn,\n\t\tt\n\t);\n\n\ta=vec4(mix(\n\t\tmix(\n\t\t\tp=K.xyz*cos(t)*cos(p.y),\n\t\t\tclamp(\n\t\t\t\tabs(fract(c.xxx+p)*5.-3.)-p,\n\t\t\t\tt,\n\t\t\t\t1.\n\t\t\t),\n\t\t\t.5\n\t\t)*d,\n\t\tc,\n\t\tn\n\t),t);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 89], [93, 93, 109, 109, 519], [522, 522, 538, 538, 581], [583, 605, 642, 642, 1288]], "test": "valid"}
{"id": "WdfXRX", "name": "Task 1 Raymarching", "author": "TrickyFox", "description": "Задание №1\nОсновная часть 15 баллов\n+ поворот мышкой 2 балла\n+ мягкие тени 3 балла\n+ туман 1 балл\n+ фрактал 2 балла\n\nВсего: 23 балла\n\nPress F  ̶t̶o̶ ̶p̶a̶y̶ ̶r̶e̶s̶p̶e̶c̶t̶  to watch fractal", "tags": ["raymarching"], "likes": 2, "viewed": 73, "published": "Public", "date": "1552066321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 300\n#define MIN 0.0\n#define MAX 100.0\n#define EPS 0.0001\n#define M_PI 3.14159265359\nvec3 c = vec3(0.0, 0.0, 0.1);\n\nvec4 unite(float first, float second, vec3 c1, vec3 c2){\n    return first < second ? vec4(c1, first) : vec4(c2, second);\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat torus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat box(vec3 p, vec3 r){\n \tvec3 d = abs(p) - r;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat plane(vec3 p, float r){\n    return  p.y + r;\n}\n\nfloat mandelbox(vec3 p){\n    vec3 np = p;\n    float d = 1.0;\n    float r;\n    int i;\n    for(i = 0; i < 9; ++i){\n        np = clamp(np, -1.0, 1.0) * 2.0 - np;\n        r = dot(np, np);\n    \tif(r < EPS){\n            np *= 20.0;\n            d *= 20.0;\n        } else if(r < 2.0){\n            np *= 2.0 / r;\n            d *= 2.0 / r;\n        }\n        np*= -1.8;\n        np += p;\n        d *= 1.8;\n        d += 1.0;\n    }\n    return length(np) / abs(d);\n}\n\nfloat scene(vec3 p){\n    vec4 ret;\n    vec3 c1 = vec3(0.0, 0.0, 0.1);\n    vec3 c2 = vec3(0.0, 0.1, 0.0);\n    vec3 c3 = vec3(0.1, 0.0, 0.1);\n    vec3 c4 = vec3(0.0, 0.1, 0.1);\n    vec3 c5 = vec3(0.1, 0.0, 0.0);\n    vec3 c6 = vec3(0.1, 0.1, 0.1);\n    vec3 c7 = vec3(0.2, 0.1, 0.0);\n    if(texture(iChannel0, vec2(70.5/256.0, 0.75)).x > 0.0){\n        ret = unite(mandelbox(vec3(p.x, p.y, p.z)), plane(p, 5.0), c7, c6);\n    } else {\n        ret = unite(torus(p, vec2(2.0 + 0.8 * sin(1.2 * iTime), 0.1)), sphere(p, 0.9), c2, c1);\n        ret = unite(torus(p, vec2(2.5 + 0.8 * sin(1.2 * iTime), 0.1)), ret.w, c3, ret.xyz);\n        ret = unite(torus(p, vec2(3.0 + 0.8 * sin(1.2 * iTime), 0.1)), ret.w, c4, ret.xyz);\n        ret = unite(capsule(p, vec3(0.1, -1.9, 0.6), vec3(-0.2, 1.75, -0.75), 0.1), ret.w, c5, ret.xyz);\n        ret = unite(plane(p, 5.0), ret.w, c6, ret.xyz);\n        ret = unite(box(vec3(p.x, p.y + 4.0, p.z + 15.0), vec3(1.0, 1.0, 1.0)), ret.w, c1, ret.xyz);\n        ret = unite(box(vec3(p.x - 15.0, p.y + 4.0, p.z - 2.0), vec3(1.0, 1.0, 1.0)), ret.w, c1, ret.xyz);\n        ret = unite(box(vec3(p.x + 15.0, p.y + 4.0, p.z - 2.0), vec3(1.0, 1.0, 1.0)), ret.w, c1, ret.xyz);\n        ret = unite(box(vec3(p.x + 15.0, p.y + 4.0, p.z + 13.0), vec3(1.0, 1.0, 1.0)), ret.w, c1, ret.xyz);\n    }\n    c = ret.xyz;\n    return ret.w;\n}\n\nfloat raymarching(vec3 eye, vec3 dir, float beg, float end){\n    float dep = beg;\n    int i;\n    for(i = 0; i < STEPS; ++i){\n        float dist = scene(eye + dep * dir);\n        dep += dist;\n        if(dep >= end || dist < EPS){\n            return dep;\n        }\n    }\n    return end;\n}          \n\nvec3 illumination(vec3 c, float shine, vec3 p, vec3 eye, vec3 pos){\n    vec3 ints = vec3(1.7, 1.7, 1.7);\n    vec3 f = normalize(vec3(\n        scene(vec3(p.x + EPS, p.y, p.z)) - scene(vec3(p.x - EPS, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPS, p.z)) - scene(vec3(p.x, p.y - EPS, p.z)),\n        scene(vec3(p.x, p.y, p.z + EPS)) - scene(vec3(p.x, p.y, p.z - EPS))\n    ));\n    vec3 s = normalize(pos - p);\n    float tmp1 = dot(s, f);\n    float tmp2 = dot(normalize(reflect(-s, f)), normalize(eye - p));\n    return (tmp1 < 0.0) ? vec3(0.0, 0.0, 0.0) : \n    \t((tmp2 < 0.0) ? ints * c * tmp1 : ints * c * (tmp1 + pow(tmp2, shine)));\n}\n\nfloat shadow(vec3 p, vec3 light, float mn, float mx, float sft){\n    float r = 1.0;\n    float h;\n    vec3 np = normalize(light - p);\n    float t;\n    for(t = mn; t < mx; t += h){\n        h = scene(p + np * t);\n        if(h < EPS){\n            return 0.0;\n        }\n        r = min(r, sft * h / t);\n    }\n    return r;\n}\n\nvec3 fog(vec3 c, vec3 fc, float d){\n    float b = 0.07;\n    float am = (1.0 - exp(-d * b)) * 0.9;\n    return mix(c, fc, am);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec2 m = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y) * M_PI;\n    float x = fragCoord.x - iResolution.x / 2.0;\n    float y = fragCoord.y - iResolution.y / 2.0;\n    float z = -iResolution.x;\n    \n    vec3 eye = vec3(14.0 * cos(m.y) * cos(m.x), 11.0 * sin(m.y), 13.0 * cos(m.y) * sin(m.x));\n\n    vec3 v1 = normalize(vec3(0.0, 0.0, 0.0) - eye);\n    vec3 v2 = normalize(cross(v1, vec3(0.0, 1.0, 0.0)));\n    vec3 v3 = cross(v2, v1);\n    \n    vec3 wdir = mat3(v2, v3, -v1) * normalize(vec3(x, y, z));\n    \n    float dist = raymarching(eye, wdir, MIN, MAX);\n    \n    if(dist > MAX - EPS){\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * wdir;\n    float shine = 60.0;\n\n    vec3 fpos = vec3(5.0 * sin(iTime), 2.0, 5.0 * cos(iTime));\n    vec3 spos = vec3(2.0 * sin(0.5 * iTime), 2.0, 3.0 * cos(0.5 * iTime));\n    vec3 color1 = c, color2 = c;\n\n    color1 += illumination(c * 2.0, shine, p, eye, fpos);\n    color2 += illumination(c * 2.0, shine, p, eye, spos);\n\n    color1 *= shadow(p, fpos, 0.1, distance(fpos, p), 30.3);\n    color2 *= shadow(p, spos, 0.1, distance(spos, p), 30.3);\n    \n    if(p.y < -3.4){\n        color1 = fog(color1, vec3(0.5, 0.6, 0.7), distance(fpos, p));\n        color2 = fog(color2, vec3(0.5, 0.6, 0.7), distance(spos, p));\n    }\n    \n    fragColor = vec4(color1 + color2, 1.0);\n\t\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 185, 185, 251], [253, 253, 283, 283, 311], [313, 313, 341, 341, 415], [417, 417, 464, 464, 593], [595, 595, 621, 621, 711], [713, 713, 742, 742, 765], [767, 767, 791, 791, 1218], [1220, 1220, 1240, 1240, 2555], [2557, 2557, 2617, 2617, 2843], [2855, 2855, 2922, 2922, 3485], [3487, 3487, 3551, 3551, 3806], [3808, 3808, 3843, 3843, 3934], [3936, 3936, 3990, 3990, 5352]], "test": "error"}
{"id": "wdfXW2", "name": "Trippy Music Visualizer", "author": "IsaacAndersen", "description": "simple pattern that looks pretty good with music. ", "tags": ["test"], "likes": 3, "viewed": 619, "published": "Public", "date": "1553960081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SS smoothstep\n#define PI 3.14159\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat maxFreq() {\n    float numChannels = 64.; // all 512 seems overkill\n    float maxFreq = 0.;\n    for(float i = 0.; i < 1.; i += 1./numChannels) {\n        float fft  = texture( iChannel0, vec2(i,0.25) ).x;\n        \n        if (fft > 0.5) maxFreq = i;\n    }\n    \n    return maxFreq;\n}\n\nfloat CC(vec2 uv, vec2 p, float freq) {\n    float dist = length(p-uv);\n    return .5+.5*sin(2.*PI*freq*dist);\n}\n\nfloat C(vec2 uv, vec2 p) {\n    return length(p-uv);\n}\n\nvec3 circleGrid(vec2 uv, float td, float direction) {\n    float t = iTime + td;\n    \n    float sF = 4.; // scale\n    \n    float tp = mod(t,sF)/sF;\n    float stp = SS(.8,.1,tp);\n    \n    vec3 col = vec3(0);\n    \n    vec2 p = vec2(0,0);\n    \n    vec2 newUV = 2.*uv*(mod(-t,sF));\n    \n\n    float a = PI*t*0.25*direction;\n    newUV *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    \n    vec2 cellID = floor(newUV);\n    \n    vec2 pv = 1.*(fract(newUV)-.5);\n    \n    \n    float r = 0.25+stp;\n    float fracPercent = 1.-stp;\n    \n   \tfloat mx = maxFreq();\n    \n    for (int i = 0; i < 3; i++) {\n        r *= 0.95;\n        \n        float freq = 5.+10.*mx;\n    \tcol[i] += fracPercent*smoothstep(r, r*.5,max(CC(pv,p,freq),C(pv,p)));\n    \n    }\n    \n    col = col.bgr;\n    \n   \treturn col;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float t = iTime/3.0;\n    vec3 R = iResolution;\n    vec2 uv = (U - R.xy*.5)/ R.y;\n\n    vec3 col = vec3(0);\n    \n    vec2 shift = vec2(0);\n    \n    col += circleGrid(uv,0.0,1.);  \n    col += circleGrid(uv,2.5,-1.);\n   \n    if (maxFreq() > 0.75) {\n        col += circleGrid(uv,0.0,-1.);\n    \tcol += circleGrid(uv,2.5,1.);\n    }\n    \n    O = vec4(col,1.0);\n}", "image_inputs": [{"id": "4tfGD7", "previewfilepath": "https://soundcloud.com/lowkey-darksoul/fkj-masego-tadow", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lowkey-darksoul/fkj-masego-tadow", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfXW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 70, 70, 178], [180, 258, 285, 285, 667], [692, 692, 718, 718, 1056], [1058, 1058, 1075, 1075, 1344], [1346, 1346, 1385, 1385, 1457], [1459, 1459, 1485, 1485, 1512], [1514, 1514, 1567, 1567, 2295], [2297, 2297, 2338, 2338, 2697]], "test": "error"}
{"id": "WdfXWl", "name": "Hatching Remix", "author": "Rloret", "description": "Different hatching pattern try \noriginal :https://www.shadertoy.com/view/4lfXDM ", "tags": ["remix", "hatch"], "likes": 7, "viewed": 236, "published": "Public", "date": "1552445958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define ITR 80\n#define FAR 15.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat torus(in vec3 p, in vec2 t){\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat map(vec3 p)\n{\n    float d = torus(p,vec2(.9,0.33));\n    d = min(d, -length(p)+5.);   \n    return d;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n//iq noise https://www.shadertoy.com/view/lsf3WH\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat noise(float x)\n{\n    float i=floor(x);\n    float f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float y=3.0*mix(hash11(i), hash11(i+1.), f);\n    return y;\n}\n//---------------------------------------------------------\n\n\nvec2 rot (vec2 p ,float a){\n    float c = cos(a);\n    float s=sin(a);\n\treturn vec2(p.x*c -p.y*s,p.x*s + p.y*c);\n}\n\nfloat sdCircunf(vec2 p,float r,float t){\n\n\treturn abs(length(p)-r)-t;\n}\n\nvec2 fMod(inout vec2 p, vec2 cellsize){\n\tvec2 cell =  floor(p/cellsize);\n    p = mod(p,cellsize)-cellsize*0.5;\n    return cell;\n}\n\nfloat scribbleTexture(vec2 uv,int str,float ink){\n    \n    float cs;\n    float c,ln,m;\n    float fc=0.;\n\tvec2 duv,cell;\n    \n    for(int i=1;i<str;i++){\n    \n     \tcs= float(i+1)/(float(str)*2.);\n        float h =noise(float(i)*2. );\n\t\tduv = uv + rot(uv+ noise(uv*0.1 +iTime*0.1),h) ;/*vec2(cos(float(iTime)),sin(float(iTime)))*0.3*/;\n\n\t\tcell =fMod(duv,vec2(cs));\n    \t\n    \tln =noise(duv *10./cs +cell.x/cs +cell.y);\n    \tc = sdCircunf(duv,mix(cs*0.45,cs*0.49,ln),mix(0.04*cs,0.006*cs,ln)*smoothstep(ink,0.,1.));\n        m =1.- round(smoothstep(c,cs*0.1*ink*ink,-cs*0.01*ink*ink));\n        \n        fc += m*ink;\n\n    \t\n    }\n    return (1.0-fc*pow(smoothstep(ink,0.,0.18),.4) );\n    \n   \n    \n   \n}\n\n\nvec3 cubeproj(in vec3 p, in float str,float ink)\n{\n    vec3 x = vec3(scribbleTexture(p.zy/p.x,int(str),ink));\n    vec3 y = vec3(scribbleTexture(p.xz/p.y,int(str),ink));\n    vec3 z = vec3(scribbleTexture(p.xy/p.z,int(str),ink));\n    \n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return x;\n    else if (p.y > p.x && p.y > p.z) return y;\n    else return z;\n}\n\nfloat texcube(in vec3 p, in vec3 n, in float str,float ink)\n{\n\tfloat x = scribbleTexture(p.yz,int(str),ink);\n\tfloat y = scribbleTexture(p.zx,int(str),ink);\n\tfloat z = scribbleTexture(p.xy,int(str),ink);\n    n *= n;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec3 normal(in vec3 p, in vec3 rd)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;\n\tvec3 n = (e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n\tn -= max(.0, dot (n, rd))*rd;\n    return normalize(n);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<21; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 6.0*h/t );\n        t += clamp( h, 0.03, 0.2 );\n        if( abs(h)<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 sepia(in vec3 col)\n{\n    return vec3(dot(col, vec3(0.393,0.769,0.189)),\n                dot(col, vec3(0.349,0.686,0.168)),\n                dot(col, vec3(0.272,0.534,0.131)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = q-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n\tmo.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,2.+sin(time*0.5)-.7,0.);\n    ro.x += sin(time*.5)*4.;\n    ro.z += cos(time*.5)*4.;\n    \n    vec3 tgt = vec3(0,0,.5+sin(time));\n    vec3 eye = normalize( tgt - ro);\n    vec3 rgt = normalize(cross( vec3(0.0,1.0,0.0), eye ));\n    vec3 up = normalize(cross(eye,rgt));\n    vec3 rd = normalize( p.x*rgt + p.y*up + 1.5*eye );\n\n\tfloat rz = march(ro,rd);\n\t\n    vec3 col = vec3(0.);\n    vec3 ligt = vec3(1,2,3);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos,rd);\n        float nl  = max(dot(nor,normalize(ligt)),0.);\n       // float sh = shadow(pos,normalize(ligt-pos),0.1,distance(pos,ligt));\n        nl *= 0.8+0.2;\n        nl = 1.-nl;\n        nl = clamp(nl,0.,1.);\n        const float st = 25.;\n        vec3 col1 = vec3(texcube (pos/1.1,nor,st,nl));\n        vec3 col2 = \t cubeproj(pos/1.1,st,nl);\n        col = mix(col1,col2, .5);\n    }\n    \n    if (distance(ro,ligt) < rz)\n    {\n\t\tfloat lball = pow(max(dot(normalize(rd), normalize(ligt-ro)),0.), 4000.0);\n    \tcol += lball*vec3(1)*2.;\n    }\n    \n   // col = sepia(col);\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 )*0.5+0.5; //form iq\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 74, 74, 126], [128, 128, 162, 162, 215], [217, 217, 236, 236, 324], [326, 326, 363, 363, 591], [592, 642, 699, 699, 803], [805, 805, 831, 831, 1125], [1127, 1127, 1150, 1150, 1292], [1294, 1294, 1316, 1316, 1448], [1449, 1511, 1538, 1538, 1624], [1626, 1626, 1666, 1666, 1697], [1699, 1699, 1738, 1738, 1828], [1830, 1830, 1879, 1879, 2529], [2532, 2532, 2582, 2582, 2890], [2892, 2892, 2953, 2953, 3154], [3156, 3156, 3192, 3192, 3390], [3392, 3392, 3462, 3462, 3725], [3727, 3727, 3752, 3752, 3908], [3910, 3910, 3967, 3967, 5331]], "test": "valid"}
{"id": "wdjSDW", "name": "Evil Disturbed", "author": "snakebyteme2", "description": "Derivative work using mash-up of multiple shaders.\n", "tags": ["fire", "hell", "smoke", "demon", "soul"], "likes": 8, "viewed": 325, "published": "Public", "date": "1553865724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\t//-----------------CONSTANTS MACROS-----------------\n\n\t#define PI 3.14159265359\n\t#define E 2.7182818284\n\t#define GR 1.61803398875\n\n\t//-----------------UTILITY MACROS-----------------\n\n\t#define time ((sin(float(__LINE__))/PI/GR+1.0/GR)*iTime+1000.0)\n\t#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n\t#define clip(x) (smoothstep(0.25, .75, x))\n\t#define TIMES_DETAILED (1.0)\n\t#define angle(uv) (atan(uv.y, uv.x))\n\t#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n\n\t#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\n\t#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n\t//-----------------LOGO COLOR/POSITION/SIZE MACROS-----------------\n\n\t#define WHITE (vec4(vec3(255.0,255.0,255.0)/255.0, 1.0))\n\t#define BROWN (vec4(vec3(165.0,42.0,42.0)/255.0, 1.0))\n\t#define SKIN (vec4((sin(time+seedling)*.25+.5)*WHITE.rgb+(cos(time-seedling)*.25+.75)*BROWN.rgb, 1.0))\n\t#define CLOTHING (vec4((flux(time+seedling)+(sin(-time/GR/PI-seedling)*.25+.5))*(sin(-time/E/PI)*.125+.875), 1.0))\n\t#define RED (vec4(vec3(255.0,0.0,0.0)/255.0, 1.0))\n\t#define GREEN (vec4(vec3(0.0,255.0,0.0)/255.0, 1.0))\n\t#define BLUE (vec4(vec3(0.0,0.0,255.0)/255.0, 1.0))\n\t#define YELLOW (vec4(vec3(255.0,255.0,0.0)/255.0, 1.0))\n\n\t#define female_size (1.0/GR)\n\t#define female_target (vec2(-sqrt(2.0)/GR/2.0, sqrt(2.0)/GR-female_size/GR))\n\t#define male_size (1.0/GR)\n\t#define male_target (vec2(-female_target.x, female_target.y))\n\n\tfloat saw(float x)\n\t{\n\t\tx /= PI;\n\t\tfloat f = mod(floor(abs(x)), 2.0);\n\t\tfloat m = mod(abs(x), 1.0);\n\t\treturn f*(1.0-m)+(1.0-f)*m;\n\t}\n\tvec2 saw(vec2 x)\n\t{\n\t\treturn vec2(saw(x.x), saw(x.y));\n\t}\n\n\tvec3 saw(vec3 x)\n\t{\n\t\treturn vec3(saw(x.x), saw(x.y), saw(x.z));\n\t}\n\n\t//-----------------SEEDLINGS-----------------------\n\tfloat seedling = 0.0;\n\tvec2 offset = vec2(0.0);\n\tfloat last_height = 0.0;\n\tfloat scale = 1.0;\n\tfloat extraTurns = 0.0;\n\tfloat aspect = 1.0;\n\n\t//-----------------AUDIO ALGORITHM-----------------\n\n\tfloat lowAverage()\n\t{\n\t\tconst int iters = 32;\n\t\tfloat product = 1.0;\n\t\tfloat sum = 0.0;\n\t\t\n\t\tfloat smallest = 0.0;\n\t\t\n\t\tfor(int i = 0; i < iters; i++)\n\t\t{\n\t\t\tfloat sound = texture(iChannel1, vec2(float(i)/float(iters), 0.5)).r;\n\t\t\tsmallest = \n\t\t\t\n\t\t\tproduct *= sound;\n\t\t\tsum += sound;\n\t\t}\n\t\treturn max(sum/float(iters), pow(product, 1.0/float(iters)));\n\t}\n\n\t//-----------------SIMPLEX ALGORITHM-----------------\n\n\tvec3 random3(vec3 c) {\n\t\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\t\tvec3 r;\n\t\tr.z = fract(512.0*j);\n\t\tj *= .125;\n\t\tr.x = fract(512.0*j);\n\t\tj *= .125;\n\t\tr.y = fract(512.0*j);\n\t\treturn r-0.5;\n\t}\n\n\tfloat simplex3d(vec3 p) {\n\t\tconst float F3 =  0.3333333;\n\t\tconst float G3 =  0.1666667;\n\t\t\n\t\tvec3 s = floor(p + dot(p, vec3(F3)));\n\t\tvec3 x = p - s + dot(s, vec3(G3));\n\t\t\n\t\tvec3 e = step(vec3(0.0), x - x.yzx);\n\t\tvec3 i1 = e*(1.0 - e.zxy);\n\t\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t\t\n\t\tvec3 x1 = x - i1 + G3;\n\t\tvec3 x2 = x - i2 + 2.0*G3;\n\t\tvec3 x3 = x - 1.0 + 3.0*G3;\n\t\t\n\t\tvec4 w, d;\n\t\t\n\t\tw.x = dot(x, x);\n\t\tw.y = dot(x1, x1);\n\t\tw.z = dot(x2, x2);\n\t\tw.w = dot(x3, x3);\n\t\t\n\t\tw = max(0.6 - w, 0.0);\n\t\t\n\t\td.x = dot(random3(s), x);\n\t\td.y = dot(random3(s + i1), x1);\n\t\td.z = dot(random3(s + i2), x2);\n\t\td.w = dot(random3(s + 1.0), x3);\n\t\t\n\t\tw *= w;\n\t\tw *= w;\n\t\td *= w;\n\t\t\n\t\treturn dot(d, vec4(52.0));\n\t}\n\n\t//-----------------LOGO RENDERING CODE-----------------\n\n\tfloat getEyes(vec2 uv)\n\t{\n\t\tvec2 p = uv;\n\n\t\tp.y += 1.0/PI;\n\n\t\tp.x *= GR;\n\n\t\tvec4 a = vec4(-1.0/GR, 1.0/GR, 0, 0);\n\t\tvec4 b = vec4(1.0/GR, 1.0/GR, 0, 0);\n\n\t\tp.y += cos(uv.x*8.0)/PI;\n\n\t\tfloat distA = length(p.xy-a.xy);\n\t\tfloat distB = length(p.xy-b.xy);\n\n\t\tfloat fade_lengthA = .20;\n\t\tfloat fade_lengthB = .20;\n\n\t\tfloat color = clamp((1.0-distA/fade_lengthA)*distB, 0.0, 1.0)\n\t\t\t\t\t  +clamp((1.0-distB/fade_lengthB)*distA, 0.0, 1.0);\n\t\treturn color;\n\t}\n\n\tfloat getTeeth(vec2 uv)\n\t{\n\t\tvec2 p = uv;\n\t\tp.x *= PI;\n\t\tp.y *= PI*(cos(p.x/PI/PI));\n\t\tp.y += 1.5*cos(p.x)+1.0;\n\t\tp.y *= (sin(time*PI+seedling))+2.0;\n\n\t\tfloat r = p.x*p.x+p.y*p.y;\n\t\t\n\t\tfloat xy = sin(p.x*PI*10.0)+cos(p.y*3.0+PI);\n\n\t\treturn clamp(clamp((3.0/(r*r*r)-p.y*p.y), 0.0, 1.0)*xy, 0.0, 1.0);\n\t}\n\n\tvec4 demon(vec2 uv)\n\t{\n\t\tfloat eyes = getEyes(uv);\n\t\tfloat teeth = getTeeth(uv);\n\t\t\n\t\tvec3 col = clamp(eyes+flux(seedling)*eyes+teeth, 0.0, 1.0);\n\t\t\n\t\treturn vec4(col, clamp(length(col), 0.0, 1.0));\n\t}\n\n\n\t//-----------------ITERATED FUNCTION SYSTEM-----------------\n\n\tvec2 mobius(vec2 uv)\n\t{\n\t\tfloat r = length(uv);\n\t\tuv = normalize(uv)/log(r+1.0);\n\t\t\n\t\tfloat turns = 4.0*extraTurns;\n\t\tfloat theta = atan(uv.y, uv.x);\n\t\t\n\t\tuv = vec2((theta*turns), (turns/(length(uv))-time*PI));\n\t\t\n\t\tseedling += floor(uv.x/PI)+floor(uv.y/PI);\n\t\t\n\t\treturn vec2(saw(uv));\n\t}\n\n\tvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n\t{\n\t\tuv += offset;\n\t\t\n\t\tvec2 a = uv+vec2(0.0, \t\t0.0);\n\t\tvec2 b = uv+vec2(dxdy.x, \t0.0);\n\t\tvec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n\t\tvec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n\t\tvec2 ma = mobius(a);\n\t\tvec2 mb = mobius(b);\n\t\tvec2 mc = mobius(c);\n\t\tvec2 md = mobius(d);\n\t\t\n\t\tfloat da = length(mb-ma);\n\t\tfloat db = length(mc-mb);\n\t\tfloat dc = length(md-mc);\n\t\tfloat dd = length(ma-md);\n\t\t\n\t\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n\t\t\n\t\tmagnification = stretch;\n\t\t\n\t\treturn mobius(uv);\n\t}\n\t\t\n\tvec4 getEvil( in vec2 fragCoord )\n\t{\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\tfloat scale = E;\n\t\tuv = uv*scale-scale/2.0;\n\t\t\n\t\tfloat aspect = iResolution.x/iResolution.y;\n\t\t\n\t\tuv.x *= aspect;\n\t\t\n\t\tvec2 uv0 = uv;\n\t\t\n\t\tconst int max_iterations = 4;\n\t\tint target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n\t\t\n\t\tfloat antispeckle = 1.0; \n\t\tfloat magnification = 1.0;\n\t  \n\t\tvec4 color = vec4(0.0);\n\t\tfloat border = 1.0;\n\t\t\n\t\tseedling = 0.0;\n\t\t\n\t\t\t\n\t\toffset = sin(vec2(time+seedling,\n\t\t\t\t\t\t  -time-seedling))*(.5/E);\n\t\t\n\t\tcolor += demon(uv);\n\t\tborder *= (1.0-color.a);//*antispeckle;\n\t\t\n\t\tfor(int i = 0; i < max_iterations; i++)\n\t\t{\n\t\t\tfloat iteration = float(i)/float(max_iterations);\n\t\t\t\n\t\t\tseedling = float(i);\n\t\t\textraTurns = float(i*i+1);\n\t\t\t\n\t\t\tuv = (iterate(uv0, .5/iResolution.xy, magnification)*2.0-1.0);\n\t\t\tuv = uv*(saw(time+seedling)+1.0);\n\t\t\t\n\t\t\tuv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, -1.0), sin(seedling+time)*PI).xy;\n\n\t\t\tcolor += demon(uv)*border*antispeckle;\n\t\t\t\n\t\t\tborder *= smoothstep(1.0-1.0/GR/E/PI, 1.0, 1.0-color.a);//*antispeckle;\n\t\t\t\n\t\t\tfloat weight = smoothstep(0.0, 0.25, magnification);\n\t\t\tantispeckle *= 1.0/magnification;\n\t\t}\n\t\t\n\t\t//fragColor = vec4(everything(uv*2.0-1.0, o).a);\n\t\t//fragColor = everything(uv*2.0-1.0, o);\n\t\t\n\t\treturn color;\n\t}\n\n\t#define STEPS 1./50.\n\t#define VOLUME_BIAS 0.01\n\t#define MIN_DIST 0.005\n\t#define STEP_DAMPING .9\n\t#define TAU PI*2.\n\n\t// raymarch toolbox\n\tfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\n\tmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\tfloat sdSphere (vec3 p, float r) { return length(p)-r; }\n\tfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\n\tfloat sdIso(vec3 p, float r) { return max(0.,dot(p,normalize(sign(p))))-r; }\n\tfloat sdBox( vec3 p, vec3 b ) {\n\t  vec3 d = abs(p) - b;\n\t  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t}\n\tfloat amod (inout vec2 p, float count) {\n\t\tfloat an = TAU/count;\n\t\tfloat a = atan(p.y,p.x)+an/2.;\n\t\tfloat c = floor(a/an);\n\t\ta = mod(a,an)-an/2.;\n\t\tp.xy = vec2(cos(a),sin(a))*length(p);\n\t\treturn c;\n\t}\n\n\tfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\n\tfloat smin (float a, float b, float r) {\n\t\tfloat h = clamp(.5+.5*(b-a)/r, 0., 1.);\n\t\treturn mix(b,a,h)-r*h*(1.-h);\n\t}\n\n\t// geometry for spell\n\tfloat tubes (vec3 pos) {\n\t\t\n\t\t// cylinder made of 8 tube\n\t\tfloat cylinderRadius = .02; // change shape\n\t\tvec3 p = pos;\n\t\tp.xz *= rot(p.y*.5); // twist amount\n\t\tfloat c = amod(p.xz, 8.); // amount of tubes\n\t\tp.x -= 2.; // tube cylinder radius\n\t\tfloat tube = sdCylinder(p.xz, cylinderRadius);\n\t\t\n\t\t// another cylinder made of tubes 16\n\t\tp = pos;\n\t\tp.xz *= rot(-p.y*.5); // twist amount\n\t\tc = amod(p.xz, 16.); // amount of tubes\n\t\tp.x -= 2.; // tube cylinder radius\n\t\ttube = smin(tube, sdCylinder(p.xz, cylinderRadius), .15);\n\t\treturn tube;\n\t}\n\n\t// geometry for spell\n\tfloat disks (vec3 pos) {\n\t\tfloat radius = 1.5;\n\t\tfloat radiusInner = .57;\n\t\tfloat thin = .01;\n\t\tfloat repeatY = 2.;\n\t\tfloat cellY = floor(pos.y/repeatY);\n\t\tfloat a = atan(pos.z,pos.x)-iTime*.3+cellY*.1;\n\t\tvec3 p = pos;\n\t\tp.y += sin(a*6.)*.1;\n\t\tp.y = repeat(p.y, repeatY);\n\t\tfloat disk = max(-sdCylinder(p.xz, radiusInner), sdCylinder(p.xz, radius));\n\t\tdisk = max(abs(p.y)-thin,disk);\n\t\treturn disk;\n\t}\n\n\tvec3 anim1 (vec3 p) {\n\t\tfloat t = iTime*.5;\n\t\tp.xz *= rot(t);\n\t\tp.xy *= rot(t*.7);\n\t\tp.yz *= rot(t*.5);\n\t\treturn p;\n\t}\n\n\tvec3 anim2 (vec3 p) {\n\t\tfloat t = -iTime*.4;\n\t\tp.xz *= rot(t*.9);\n\t\tp.xy *= rot(t*.6);\n\t\tp.yz *= rot(t*.3);\n\t\treturn p;\n\t}\n\n\tfloat map (vec3 pos) {\n\t\tfloat scene = 1000.;\n\t\t\n\t\t// ground and ceiling\n\t\tfloat bump = texture(iChannel0, pos.xz*.1).r;\n\t\tfloat ground = 2. - bump*.1;\n\t\tscene = min(scene, pos.y+ground);\n\t\tscene = min(scene, -(pos.y-ground));\n\t\t\n\t\t// spell geometry 1\n\t\tvec3 p = pos;\n\t\tp.y += sin(atan(p.z,p.x)*10.)*3.; // change numbers to get new distortion\n\t\tp.xz *= rot(p.y*.2-iTime);\n\t\tp = anim1(p);\n\t\tp.x = length(p.xyz)-3.;\n\t\tscene = smin(scene, tubes(p), .5);\n\t\tscene = smin(scene, disks(p), .5);\n\t\t\n\t\t// spell geometry 2\n\t\tp = pos;\n\t\tp.y += sin(atan(p.z,p.x)*3.)*2.; // change numbers to get new distortion\n\t\tp = anim2(p);\n\t\tp.xz *= rot(p.y+iTime);\n\t\tp.x = length(p.xyz)-3.;\n\t\tscene = smin(scene, tubes(p), .3);\n\t\tscene = smin(scene, disks(p), .3);\n\t\t\n\t\treturn scene;\n\t}\n\n\tvoid camera (inout vec3 p) {\n\t\tp.xz *= rot((-PI*(0./iResolution.x-.5)));\n\t}\n\n\tvec4 getSoulMask( in vec2 uv )\n\t{\n\t\tuv = (uv.xy-.5*iResolution.xy)/iResolution.y;\n\t\tvec2 mouse = vec2(0.)/iResolution.xy;\n\t\tvec3 eye = vec3(0.,0.,-7.+mouse.y*3.);\n\t\tvec3 ray = normalize(vec3(uv,.7));\n\t\tcamera(eye);\n\t\tcamera(ray);\n\t\tvec3 pos = eye;\n\t\tfloat shade = 0.;\n\t\tfor (float i = 0.; i <= 1.; i += STEPS) {\n\t\t\tfloat dist = map(pos);\n\t\t\tif (dist < VOLUME_BIAS) {\n\t\t\t\tshade += STEPS;\n\t\t\t}\n\t\t\tif (shade >= 1.) break;\n\t\t\tdist *= STEP_DAMPING + .1 * rng(uv+fract(iTime));\n\t\t\tdist = max(MIN_DIST, dist);\n\t\t\tpos += dist * ray;\n\t\t}\n\t\tvec4 color = vec4(1);\n\t\tcolor.rgb *= shade;\n\t\treturn color;\n\t}\n\t//-------------------------------------------------------------------\n\n\tvec3 mod289(vec3 x) {\n\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t}\n\n\tvec4 mod289(vec4 x) {\n\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t}\n\n\tvec4 permute(vec4 x) {\n\t\t return mod289(((x*34.0)+1.0)*x);\n\t}\n\n\tvec4 taylorInvSqrt(vec4 r)\n\t{\n\t  return 1.79284291400159 - 0.85373472095314 * r;\n\t}\n\n\tfloat snoise(vec3 v)\n\t  { \n\t  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\t  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\t  vec3 i  = floor(v + dot(v, C.yyy) );\n\t  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n\t  vec3 g = step(x0.yzx, x0.xyz);\n\t  vec3 l = 1.0 - g;\n\t  vec3 i1 = min( g.xyz, l.zxy );\n\t  vec3 i2 = max( g.xyz, l.zxy );\n\n\t  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t  //   x1 = x0 - i1  + 1.0 * C.xxx;\n\t  //   x2 = x0 - i2  + 2.0 * C.xxx;\n\t  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\t  vec3 x1 = x0 - i1 + C.xxx;\n\t  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\t  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\t  i = mod289(i); \n\t  vec4 p = permute( permute( permute( \n\t\t\t\t i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\t\t\t   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\t  float n_ = 0.142857142857; // 1.0/7.0\n\t  vec3  ns = n_ * D.wyz - D.xzx;\n\n\t  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\t  vec4 x_ = floor(j * ns.z);\n\t  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n\t  vec4 x = x_ *ns.x + ns.yyyy;\n\t  vec4 y = y_ *ns.x + ns.yyyy;\n\t  vec4 h = 1.0 - abs(x) - abs(y);\n\n\t  vec4 b0 = vec4( x.xy, y.xy );\n\t  vec4 b1 = vec4( x.zw, y.zw );\n\n\t  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\t  vec4 s0 = floor(b0)*2.0 + 1.0;\n\t  vec4 s1 = floor(b1)*2.0 + 1.0;\n\t  vec4 sh = -step(h, vec4(0.0));\n\n\t  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\t  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\t  vec3 p0 = vec3(a0.xy,h.x);\n\t  vec3 p1 = vec3(a0.zw,h.y);\n\t  vec3 p2 = vec3(a1.xy,h.z);\n\t  vec3 p3 = vec3(a1.zw,h.w);\n\n\t//Normalise gradients\n\t  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\t  p0 *= norm.x;\n\t  p1 *= norm.y;\n\t  p2 *= norm.z;\n\t  p3 *= norm.w;\n\n\t// Mix final noise value\n\t  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\t  m = m * m;\n\t  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n\t\t\t\t\t\t\t\t\tdot(p2,x2), dot(p3,x3) ) );\n\t  }\n\n\tfloat normnoise(float noise) {\n\t\treturn 0.5*(noise+1.0);\n\t}\n\n\tfloat clouds(vec2 uv) {\n\t\tuv += vec2(iTime*0.05, + iTime*0.01);\n\t\t\n\t\tvec2 off1 = vec2(50.0,33.0);\n\t\tvec2 off2 = vec2(0.0, 0.0);\n\t\tvec2 off3 = vec2(-300.0, 50.0);\n\t\tvec2 off4 = vec2(-100.0, 200.0);\n\t\tvec2 off5 = vec2(400.0, -200.0);\n\t\tvec2 off6 = vec2(100.0, -1000.0);\n\t\tfloat scale1 = 3.0;\n\t\tfloat scale2 = 6.0;\n\t\tfloat scale3 = 12.0;\n\t\tfloat scale4 = 24.0;\n\t\tfloat scale5 = 48.0;\n\t\tfloat scale6 = 96.0;\n\t\treturn normnoise(snoise(vec3((uv+off1)*scale1,iTime*0.5))*0.8 + \n\t\t\t\t\t\t snoise(vec3((uv+off2)*scale2,iTime*0.4))*0.4 +\n\t\t\t\t\t\t snoise(vec3((uv+off3)*scale3,iTime*0.1))*0.2 +\n\t\t\t\t\t\t snoise(vec3((uv+off4)*scale4,iTime*0.7))*0.1 +\n\t\t\t\t\t\t snoise(vec3((uv+off5)*scale5,iTime*0.2))*0.05 +\n\t\t\t\t\t\t snoise(vec3((uv+off6)*scale6,iTime*0.3))*0.025);\n\t}\n\n\n\tvec4 getSmoke( in vec2 fragCoord )\n\t{\n\t  \n\t\tvec2 uv =  fragCoord.xy/iResolution.x;\n\t\t   \n\t\tfloat cloud = clouds(uv);\n\t\t\n\t\treturn vec4(cloud,cloud,cloud,1.0);\n\n\t}\n\n\t//--------------------------------------------------------------------------\n\n\tvec4 dnoise(vec3 p);\n\n\tvec4 quat_rotation( float half_angr, vec3 unitVec );\n\n\tvec2 screen_uv;\n\tvec4 quat;\n\n\tfloat Checker2(vec2 uv)\n\t{\n\t\tfloat s = sin(uv.x)*cos(uv.y);\n\t\t//s = s*s*s*s*s;\n\t\treturn s;\n\t}\n\n\tvec4 FlowNoise(vec3 uvw, vec2 uv)\n\t{\n\t\tvec4 n = vec4(0.);\n\n\t\tfloat f = 1.;\n\t\tfloat a = 1.;\n\t\t\t\t\n\t\tfloat lac = 2.13;\n\t\t\n\t#if 0\t\n\t\tfor (int i=0; i<5; i++)\n\t\t{\t\n\t\t\t//offsetting swirl angle relative to position seems to flow along the gradient\n\t\t\tfloat ang = iTime*.4;//+uv.y*0.5;\n\t\t\t\n\t\t\tang *= Checker2(uvw.xy*0.0125);\n\t\t\t\n\t\t\tvec3 ax = normalize(vec3(1,1,1)); \n\t//\t\tvec3 ax = texture(u_tex1,vec2(float(i)*0.1,0.)).xyz*2.-1.;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\n\t\t\tfloat e = 0.1;//*f;\n\t\t\t\n\t\t\t//advect by going back in domain along noise gradient\n\t\t\tvec4 dn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\t\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\t\t}\n\t#else\n\t\tvec3 ax = normalize(vec3(1,1,1)); \n\t\tfloat e = 0.1;//*f;\n\t\tfloat ang;\n\t\tvec4 dn;\n\t\t\tang = iTime*.4+uv.y*0.5;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\t\tdn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\t\t\n\t\t\tang = iTime*.4+uv.y*0.5;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\t\tdn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\n\t\t\tang = iTime*.4+uv.y*0.5;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\t\tdn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\n\t\t\tang = iTime*.4+uv.y*0.5;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\t\tdn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\n\t\t\tang = iTime*.4+uv.y*0.5;\n\t\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\t\tdn = dnoise(uvw);\n\t\t\tuvw -= 0.01*dn.xyz;\n\t\t\tn += abs(a*dn);\n\t\t\tuvw *= lac;\n\t\t\tf *= lac;\n\t\t\ta *= (1./lac);\n\t\t\n\t#endif\n\t\t\n\t\treturn n;\n\t}\n\t\t\n\tvec3 hsv2rgb(vec3 c)\n\t{\n\t\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\t\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\t\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n\t}\n\n\t//thanks iq..\n\t// Smooth HSV to RGB conversion \n\tvec3 hsv2rgb_smooth( in vec3 c )\n\t{\n\t\tvec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\t\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\t\treturn c.z * mix( vec3(1.0), rgb, c.y);\n\t}\n\n\tvec3 hsv2rgb_trigonometric( in vec3 c )\n\t{\n\t\tvec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\t\treturn c.z * mix( vec3(1.0), rgb, c.y);\n\t}\n\n\tvec3 FlameColour(float f)\n\t{\n\t\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n\t}\n\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t{\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\tuv.x *= iResolution.x/iResolution.y;\t\n\t\tuv.y = 1. - uv.y;\n\t\tscreen_uv = uv;\n\t\t\n\t\tfloat t = iTime*0.8;\n\t\tvec3 uvw = vec3(uv*1.15+vec2(0.,t),t*0.5);\n\n\n\t\tvec4 d = FlowNoise(uvw,uv);\n\t\tfloat de = d.w;\n\t\tde = length(d.xyz)*.15+.2-d.w*.2;\n\t\tvec3 n = FlameColour(de);\n\n\t\tvec4 soulMask = vec4(1.0) - getSoulMask(fragCoord);\n\t\tvec4 smoke = getSmoke(fragCoord) * 0.25;\n        vec4 evil = getEvil(fragCoord) * 0.35;\n\t\tfragColor = vec4(soulMask.xyz,1.0);\n\t\tfragColor.xyz = vec3(n) * 1.6 - fragColor.xyz;\n        \n\t\tfragColor.x = max(evil.x,fragColor.x);\n\t\tfragColor.y = max(evil.y,fragColor.y);\n\t\tfragColor.z = max(evil.z,fragColor.z);\n        \n        fragColor.x = max(smoke.x,fragColor.x);\n\t\tfragColor.y = max(smoke.y,fragColor.y);\n\t\tfragColor.z = max(smoke.z,fragColor.z);\n\t\t\n\t}\n\n\tvec4 quat_rotation( float half_angr, vec3 unitVec )\n\t{\n\t\tfloat s, c;\n\t\ts = sin( half_angr );\n\t\tc = cos( half_angr );\n\t\treturn vec4( unitVec*s, c );\n\t}\n\n\tvec3 quat_times_vec(vec4 q, vec3 v)\n\t{\n\t\t//http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n\t\tvec3 t = 2. * cross(q.xyz, v);\n\t\treturn v + q.w * t + cross(q.xyz, t);\n\t}\n\n\t/* Created by Nikita Miropolskiy, nikat/2013\n\t * This work is licensed under a \n\t * Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\t * http://creativecommons.org/licenses/by-nc-sa/3.0/\n\t *  - You must attribute the work in the source code \n\t *    (link to https://www.shadertoy.com/view/XsX3zB).\n\t *  - You may not use this work for commercial purposes.\n\t *  - You may distribute a derivative work only under the same license.\n\t */\n\n\t/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\n\tvec3 random3a(vec3 c) \n\t{\n\t\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\t\tvec3 r;\n\t\tr.z = fract(512.0*j);\n\t\tj *= .125;\n\t\tr.x = fract(512.0*j);\n\t\tj *= .125;\n\t\tr.y = fract(512.0*j);\n\t\tr = r-0.5;\n\n\t\t\n\t\t//rotate for extra flow!\n\t\tr=quat_times_vec(quat,r);\n\t\t\n\t\treturn r;\n\t}\n\n\t/* skew constants for 3d simplex functions */\n\tconst float F3 =  0.3333333;\n\tconst float G3 =  0.1666667;\n\n\tvec4 dnoise(vec3 p) \n\t{\n\t\t /* 1. find current tetrahedron T and its four vertices */\n\t\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t\t \n\t\t vec3 s = floor(p + (p.x+p.y+p.z)*F3);\n\t\t vec3 x = p - s + (s.x+s.y+s.z)*G3;\n\t\t \n\t\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t\t vec3 i1 = e*(1.0 - e.zxy);\n\t\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t\t\t\n\t\t vec3 x1 = x - i1 + G3;\n\t\t vec3 x2 = x - i2 + 2.0*G3;\n\t\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t\t\t\t \n\t\t /* calculate surflet weights */\n\t\t vec4 w;\n\t\t w.x = dot(x, x);\n\t\t w.y = dot(x1, x1);\n\t\t w.z = dot(x2, x2);\n\t\t w.w = dot(x3, x3);\n\t\t \n\t\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t\t w = max(0.6 - w, 0.0);\t\t//aka t0,t1,t2,t3\n\t\t vec4 w2 = w*w;\t\t\t\t//aka t20,t21,t22,t23\n\t\t vec4 w4 = w2*w2;\t\t\t//aka t40,t41,t42,t43\n\t\t \n\t\t /* 2. find four surflets and store them in d */\n\t\t vec3 g0 = random3a(s);\n\t\t vec3 g1 = random3a(s + i1);\n\t\t vec3 g2 = random3a(s + i2);\n\t\t vec3 g3 = random3a(s + 1.0);\n\t\t \n\t\t vec4 d;\n\t\t /* calculate surflet components */\n\t\t d.x = dot(g0, x);\t\t//aka graddotp3( gx0, gy0, gz0, x0, y0, z0 )\n\t\t d.y = dot(g1, x1);\n\t\t d.z = dot(g2, x2);\n\t\t d.w = dot(g3, x3);\n\t\t \n\t\t //derivatives as per\n\t\t //http://webstaff.itn.liu.se/~stegu/aqsis/flownoisedemo/srdnoise23.c\n\t\t vec4 w3 = w*w2;\n\t\t vec4 temp = w3*d;\n\t\t vec3 dnoise = temp[0]*x;\n\t\t\t dnoise += temp[1]*x1;\n\t\t\t dnoise += temp[2]*x2;\n\t\t\t dnoise += temp[3]*x3;\n\t\t\t dnoise *= -8.;\n\t\t\t dnoise += w4[0]*g0+w4[1]*g1+w4[2]*g2+w4[3]*g3;\n\t\t\t dnoise *= 52.; //???\n\t\t\t \n\t\t d *= w4;\t//aka n0,n1,n2,n3\n\t\t \n\t\tfloat n = (d.x+d.y+d.z+d.w)*52.;\n\t\t\n\t\treturn vec4(dnoise,n);\n\t}\t", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[655, 1476, 1497, 1497, 1608], [1610, 1610, 1629, 1629, 1667], [1670, 1670, 1689, 1689, 1737], [1935, 1989, 2010, 2010, 2344], [2347, 2403, 2425, 2425, 2607], [2610, 2610, 2635, 2635, 3301], [3304, 3362, 3387, 3387, 3811], [3814, 3814, 3840, 3840, 4116], [4119, 4119, 4141, 4141, 4320], [4324, 4387, 4410, 4410, 4675], [4678, 4678, 4738, 4738, 5311], [5316, 5316, 5352, 5352, 6616], [6736, 6757, 6780, 6780, 6847], [6849, 6849, 6869, 6869, 6919], [6921, 6921, 6955, 6955, 6977], [6979, 6979, 7015, 7015, 7037], [7039, 7039, 7069, 7069, 7115], [7117, 7117, 7148, 7148, 7238], [7240, 7240, 7280, 7280, 7440], [7443, 7443, 7476, 7476, 7500], [7502, 7502, 7542, 7542, 7619], [7622, 7645, 7669, 7701, 8185], [8188, 8211, 8235, 8235, 8612], [8615, 8615, 8636, 8636, 8733], [8736, 8736, 8757, 8757, 8858], [8861, 8861, 8883, 8883, 9624], [9627, 9627, 9655, 9655, 9702], [9705, 9705, 9738, 9738, 10298], [10300, 10372, 10393, 10393, 10444], [10447, 10447, 10468, 10468, 10519], [10522, 10522, 10544, 10544, 10583], [10586, 10586, 10615, 10615, 10669], [10672, 10672, 10697, 10697, 12856], [12859, 12859, 12889, 12889, 12918], [12921, 12921, 12944, 12944, 13667], [13671, 13671, 13708, 13708, 13832], [13835, 14022, 14048, 14048, 14115], [14118, 14118, 14154, 14154, 15868], [15873, 15873, 15896, 15896, 16060], [16063, 16112, 16147, 16147, 16326], [16329, 16329, 16371, 16371, 16486], [16489, 16489, 16517, 16517, 16592], [16595, 16595, 16653, 16653, 17471], [17474, 17474, 17528, 17528, 17624], [17627, 17627, 17665, 17761, 17837], [18302, 18376, 18401, 18401, 18654], [18657, 18765, 18788, 19014, 20455]], "test": "error"}
{"id": "WdjSRR", "name": "cg_task1", "author": "inaara98", "description": "Трассировка лучей.", "tags": ["raytrace"], "likes": 2, "viewed": 58, "published": "Public", "date": "1552679429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nstruct Dif {\n    float first, second;\n};\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    \n    float t = iTime;\n    \n    float pd = p.y;\n    \n    vec3 bp = p;\n    bp -= vec3(0,.75,3);\n    float rotate = dBox(bp, vec3(.75));\n    \n    vec3 tp = p;\n    tp -= vec3(-2, 1.5, -4);\n    tp = tp.xzy;\n    float scale = sdTorus(tp, vec2(1, .25));\n    \n    float morph = mix(\n        length(p-vec3(4,1,2))-1., \n        dBox(p-vec3(4,1,2), vec3(1,1,1)), \n        .5\n    );\n    \n    float subtract = max(\n        -dBox(p - vec3(1., 1,0), vec3(1, .5, 2)), \n        length(p - vec3(0, 1, 0)) - 1.    \n    );\n    \n    float intersect = max(\n        dBox(p - vec3(-3., 1, 0), vec3(1, .5 ,2)), \n        length(p - vec3(-4, 1, 0)) - 1.\n    );\n    \n    float blend = smin(\n        length(p - vec3(3, 1, -3)) - .75,\n        length(p - vec3(3., 1.5, -3)) - .5,\n        .2\n    );\n    \n    float d = min(morph, pd);\n    d = min(d, subtract);\n    d = min(d, intersect);\n    d = min(d, rotate);\n    d = min(d, scale);\n    d = min(d, blend);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = abs( GetDist(p) );\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nDif GetLight(vec3 p) {\n    vec3 lightPos1 = vec3(3, 5, 4);\n    vec3 lightPos2 = vec3(-3, 1, 4);\n    vec3 l = normalize(lightPos1-p);\n    vec3 m = normalize(lightPos2-p);\n    vec3 n = GetNormal(p);\n    \n    Dif dif;\n    dif.first = clamp(dot(n, l)*.5+.5, 0., 1.);\n    dif.second = clamp(dot(n, m)*.5+.5, 0., 1.);\n    float d1 = RayMarch(p+n*SURF_DIST*2., l);\n    float d2 = RayMarch(p+n*SURF_DIST*2., m);\n    if(p.y<.01 && d1<length(lightPos1-p)) dif.first *= .5;\n    if(p.y<.01 && d2<length(lightPos2-p)) dif.second *= .5;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(iTime*.2-m.x*6.2831);\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\n    float d = RayMarch(ro, rd);\n    \n    Dif dif;\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tdif = GetLight(p);\n        col = vec3(dif.second, 0., 0.);\n        col += vec3(dif.first);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 129, 129, 205], [207, 207, 248, 248, 339], [341, 341, 391, 391, 559], [561, 561, 612, 612, 896], [898, 898, 929, 929, 997], [999, 999, 1027, 1027, 1108], [1111, 1111, 1134, 1134, 2084], [2086, 2086, 2120, 2120, 2333], [2335, 2335, 2359, 2359, 2549], [2551, 2551, 2573, 2573, 3096], [3098, 3098, 3140, 3140, 3335], [3339, 3339, 3396, 3396, 3918]], "test": "valid"}
{"id": "WdjSWm", "name": "The cake is a lie.", "author": "kaneta", "description": "It is a video of the original game.\nhttps://youtu.be/LXDT7b0sqIs?t=583", "tags": ["3d", "raymarching", "portal", "cake"], "likes": 47, "viewed": 1173, "published": "Public API", "date": "1554045012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAT_SPONGE 0.0\n#define MAT_CREAM 1.0\n#define MAT_BALL 2.0\n#define MAT_CANDLE 3.0\n#define MAT_DISH 4.0\n#define MAT_FRAME 5.0\n#define MAT_OUTSIDE 6.0\n#define MAT_INSIDE 7.0\n#define MAT_HEART 8.0\n#define MAT_SHELF 9.0\n#define MAT_FLOOR 10.0\n#define MAT_CORE 11.0\n\nvec3 RayOrigin, Target, Coord, CoreCoord;\nvec4 CoreID;\nfloat CameraLight, CubeLight;\nfloat Black;\n\nconst float pi = acos(-1.);\nconst float pi2 = pi * 2.0;\n\n// Grab from https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(.1031,.11369,.13787)\n//#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec2 hash12(float n) { return vec2(fract(sin(n) * vec2(12345.6, 78901.2))); }\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.74));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\n// ========= Noise ===========\nfloat value_noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(hash21(ip),hash21(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(hash21(ip+vec2(0.0,1.0)),hash21(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res * 2.0 - 1.0;\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    // thx nikita: https://www.shadertoy.com/view/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat noise(vec3 p) {\n    return simplex_noise(p);\n}\n\nfloat noise_sum(vec3 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat fbm(vec2 uv)\n{\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise( uv ); uv = m*uv;\n\tf += 0.2500*value_noise( uv ); uv = m*uv;\n\tf += 0.1250*value_noise( uv ); uv = m*uv;\n    return f;\n}\n\nfloat height(vec3 p)\n{\n    float base = noise(p * 10.5) * 0.25 + 0.5;\n    return base * 0.03;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n///////////////////// Distance Functions /////////////////////\n// Rotate fold technique\n// https://gam0022.net/blog/2017/03/02/raymarching-fold/\nvec2 pMod(in vec2 p, in float s) {\n    float a = pi / s - atan(p.x, p.y);\n    float n = pi2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\nfloat opRep( in float p, in float c )\n{\n    return mod(p,c)-0.5*c;\n}\nvec2 opRep( in vec2 p, in vec2 c )\n{\n    return mod(p,c)-0.5*c;\n}\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat sdPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdCream(vec3 p, float phiScale, float radiusOffset, float thickness)\n{\n    p.zx = vec2(atan(p.x, p.z) / pi * phiScale, length(p.zx));\n    p.x -= radiusOffset;\n\n    vec2 theta = vec2(1.6, 0.) + p.z * pi * 4.;\n    float k1 = length(p.yx + sin(theta) * 2.) - thickness;\n    float k2 = length(p.yx + sin(theta + pi) * 2.) - thickness;\n\n    return smin(k1, k2, 2.5);\n}\n\nfloat sdDish(vec3 p)\n{\n    vec2 q = vec2(atan(p.z, p.x), length(p.xz));\n    float d = q.y - 1.2 - sin(q.x * 16.0) * 0.02;\n    vec2 w = vec2( d, abs(p.y) - 0.03);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nfloat sdChamferedCube1( vec3 p, vec3 size, float corner)\n{\n    vec3 s = max(size - corner, 0.0);\n    p = p - clamp( p, -s, s );\n    p = abs(p);\n    return (p.x+p.y+p.z-corner)*0.57735027;\n}\n\nfloat sdChamferedCube2( vec3 p, vec3 size, float corner)\n{\n    vec3 s = max(size - corner, 0.0);\n    p = p - clamp( p, -s, s );\n    p = abs(p);\n    return max((p.z+p.y-corner) * 0.7071067, p.x);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdFrame(vec3 p)\n{\n    vec3 q = p;\n    p *= 6.0; // normalize frame size\n    p=abs(p) - 4.0;\n    float d = sdChamferedCube1(p, vec3(2.0), 0.5);\n    \n\tif (p.x>p.y) {p.xy = p.yx;}\n\tif (p.x>p.z) {p.xz = p.zx;}\n    p.x += 3.5;\n    p.zy -= 0.7;\n    d = min(d, sdChamferedCube2(p, vec3(1.0, 1.0, 1.0), 0.2));\n    \n    p = q;\n    p = abs(p);\n\tif (p.x<p.y) {p.xy = p.yx;}\n\tif (p.x<p.z) {p.xz = p.zx;}\n    p.x -= 2.79;\n    return max(-sdSphere(p, 2.0), d/6.0);\n}\n\nfloat sdHeartCylinder(vec3 p)\n{\n    p = abs(p);\n\tif (p.y<p.x) {p.xy = p.yx;}\n\tif (p.y<p.z) {p.yz = p.zy;}\n    float c = sdRoundedCylinder( p, 0.2, 0.02, 0.95 );\n    return c;\n}\n\nfloat sdHeart(vec2 p)\n{\n    p.y = -0.1 - p.y*1.2 + abs(p.x)*(1.0-abs(p.x));\n    return length(p) - 0.5;\n}\n\nfloat sdCross(vec3 p)\n{\n    p.xy = abs(p.xy);\n    p.xy *= rot(-1.0);\n    return sdRoundedCylinder(p, 0.02, 0.02, 1.8027);\n}\n\nvec2 sdDesk(vec3 p)\n{\n    vec3 q = p;\n    q.xz = abs(q.xz) - vec2(0.8, 0.6);\n    float legs = sdBox(q, vec3(0.03, 0.5, 0.03));\n    p.y -= 0.5;\n    float top = sdBox(p, vec3(1.1, 0.03, 0.8));\n    float d = min(legs, top);\n    return vec2(d, MAT_OUTSIDE);\n}\n\nvec2 sdStage(vec3 p)\n{\n    vec2 flor = vec2(-abs(p.y - 4.5) + 5.5, MAT_FLOOR);\n    vec2 d = flor;\n    vec3 q = p;\n    q.y -= 9.0;\n    q.xz = opRep(q.xz, vec2(8.0));\n    q = abs(q) - vec3(0.4, 1.0, 0.25);\n    vec2 beams = vec2((min(max(q.x, q.y), max(q.z, q.y + 0.4))), MAT_OUTSIDE);\n    d = opU(d, beams);\n\n    p.xz = pMod(p.xz, 8.0);\n    p.xz = opRep(p.xz, vec2(24.0, 12.0));\n    q = abs(p) - vec3(0.7);\n    vec2 pillars = vec2(max(q.x, q.z), MAT_OUTSIDE);\n    d = opU(d, pillars);\n    return d;\n}\n\nvec2 sdShelf(vec3 p, vec2 size)\n{\n    float width = 1.5;\n    \n    /// Core\n    vec3 q = p;\n    q.x += 1.6;\n    q.y -= 0.295;\n    float id1 = (floor(q.x / 3.2));\n    float id3 = (floor(q.y));\n    q.xy = opRep(q.xy, vec2(3.2, 1.0));\n    q.x += 0.5;\n    float id2 = (floor(q.x/(3.2*0.3333)));\n    q.x = opRep(q.x, 3.2*0.3333);\n    float core;\n    float rnd = hash31(vec3(id1, id2, id3) + CoreID.w + 1.0) * 0.5 + 0.5;\n    if (rnd <= 0.5 || (id1 == 0.0 && id2 == 0.0 && id3 == 0.0)) {\n    \tcore = 99999.9;\n    } else {\n        CoreID.xyz = vec3(id1, id2, id3);\n        vec3 h = hash33(CoreID.xyz + CoreID.w);\n        q.xz += h.xz * 0.05;\n        h *= pi2;\n        q.xz *= rot(h.x);\n        q.xy *= rot(h.y);\n        q.yz *= rot(h.z);\n        core = sdSphere(q, 0.4);\n        CoreCoord = q;\n    }\n    \n    /// Shelf\n    p.x += size.x * 1.6;\n    vec3 o = p;\n    p.y += 0.2;\n    p.xy = opRep(p.xy, vec2(3.2, 1.0));\n    \n    q = p;\n    q.xz = abs(q.xz) - vec2(width, 1.0);\n    \n    float legs = sdBox(q, vec3(0.05, 1.0, 0.05));\n    float flor = sdBox(p, vec3(width, 0.05, 1.0)) * 0.6;\n    \n    float d = min(legs, flor);\n    \n    p = o;\n    p.y += 0.7;\n    p.z += 1.0;\n    p.xy = opRep(p.xy, vec2(3.2, 2.0));\n    float cros = sdCross(p);\n    d = max(o.y - size.y + 1.0, d);\n    cros = max(o.y - size.y + 1.7, cros);\n    d = min(d, cros);\n    //core = max(abs(o.y - 0.8) - size.y + 1.6, core);\n    core = max(o.y - size.y + 0.8, core);\n    core = max(-o.y - 0.8, core);\n    vec2 ret = opU(vec2(d, MAT_SHELF), vec2(core, MAT_CORE));\n    ret.x = max(o.x - size.x * 3.0 - size.x * 0.2, ret.x);\n    ret.x = max(-o.x, ret.x);\n\n    return ret;\n}\n\nvec2 sdCake(vec3 p)\n{\n    float ss = sdSphere(p, 2.0);\n    if (ss > 1.0) {\n    \treturn vec2(ss, 0.0);\n    }\n    p.y += 0.15;\n    vec3 q = p;\n    q.y = abs(p.y) - 0.2;\n    vec2 sponge = vec2(sdRoundedCylinder(q, 0.5, 0.2, 0.15), MAT_SPONGE);\n    \n    q = p;\n    q.xz = pMod(q.xz, 8.0);\n    q.yz -= vec2(0.58, 0.6);\n    vec3 s = vec3(50.0, 75.0, 50.0);\n    vec2 cream = vec2(sdCream(q * s, 1., 3.0, 2.5) / s.y * 0.75, MAT_CREAM);\n    q.y -= 0.06;\n    vec2 redBall = vec2(sdSphere(q, 0.08), MAT_BALL);\n    \n    q = p;\n    q.y -= 0.8;\n    vec2 candle = vec2(sdCappedCylinder(q, vec2(0.03, 0.4)), MAT_CANDLE);\n    \n    q.y += 1.25;\n    vec2 dish = vec2(sdDish(q), MAT_DISH);\n    \n    vec2 d = opU(sponge, cream);\n    d = opU(redBall, d);\n    d = opU(candle, d);\n    d = opU(dish, d);\n    \n    return d;\n}\n\nvec2 sdInsideBox(vec3 p)\n{\n    vec2 b1 = vec2(sdBox(p, vec3(0.9)), MAT_INSIDE);\n    p = abs(p) - 0.47;\n    vec2 b2 = vec2(sdBox(p, vec3(.45)), MAT_OUTSIDE);\n    return opU(b1, b2);\n}\n\nvec2 sdCube(vec3 p)\n{\n    float ss = sdSphere(p, 2.0);\n    if (ss > 1.0) {\n    \treturn vec2(ss, 0.0);\n    }\n    vec3 q = p;\n\tvec2 f = vec2(sdFrame(p), MAT_FRAME);\n    vec2 b = sdInsideBox(p);\n    vec2 c = vec2(sdHeartCylinder(p), MAT_HEART);\n    vec2 d = opU(f, b);\n    d = opU(d, c);\n    \n    return d;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 pp = sdStage(p);\n    vec3 cubePos = p * 2.0;\n    cubePos -=  vec3(-4.5, -0.5, -13.0) * 2.0;\n    cubePos.xz *= rot(1.);\n    \n    vec3 cakePos = p * 2.0;\n    cakePos -=  vec3(0.0, 0.07, -8.0) * 2.0;\n    \n    vec2 d = opU(sdCube(cubePos), sdCake(cakePos)) * vec2(0.5, 1.0);\n    \n    Coord = cubePos;\n    \n    vec3 deskPos = p - vec3(0.0, -0.8, -8.0);\n    deskPos.xz *= rot(0.25);\n    \n    vec2 desk = sdDesk(deskPos);\n    d = opU(d, desk);\n    d = opU(d, pp);\n    \n    vec3 q = p;\n    p.xz = pMod(p.xz, 8.0);\n    q = p;\n    CoreID.w = abs(floor(p.z / 6.0));\n    p.z = opRep(p.z, 6.0);\n    \n    vec2 size = floor(hash12(CoreID.w) * vec2(3.0, 5.0)) + vec2(5.0, 3.0);\n\tif (abs(CoreID.w) == 2.0) {\n    \tsize = vec2(3.0, 3.0);\n    }\n    p.z *= -1.0;\n    vec2 shelf = sdShelf(p, size);\n    shelf.x = max(-q.z + 12.0, shelf.x) * 0.7;\n    d = opU(d, shelf);\n    return d;\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.03;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 48; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 20.0 * d / t);\n    }\n    \n    return res;\n}\n\nvec3 normal( vec3 pos, float eps, vec4 h )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*(map( pos + e.xyy ).x + h.x) +\n\t\t\t\t\t  e.yyx*(map( pos + e.yyx ).x + h.y) +\n\t\t\t\t\t  e.yxy*(map( pos + e.yxy ).x + h.z) +\n\t\t\t\t\t  e.xxx*(map( pos + e.xxx ).x + h.w) );\n}\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (pi * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - min(1.0, cosTheta), 5.0);\n}\n\nvec3 PBR(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), roughness);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\n\tvec3 diffuseBRDF = kd * albedo / pi;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL;\n}\n\nvec3 pointLight(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\n{\n    vec3 lightVector = L - pos;\n    float lightDistance = length(lightVector);\n    vec3 lightDir = lightVector / lightDistance;\n    \n    float shadow = shadow(pos, lightDir, lightDistance);\n    return PBR(pos, albedo, metalness, roughness, N, V, lightDir, Lradiance) * shadow / (lightDistance * lightDistance);\n}\n    \nvec3 ambient(vec3 n, vec3 albedo)\n{\n    return albedo * clamp(0.5+0.5*n.y,0.0,1.0) * 0.02;\n}\n\nfloat linerFog(float x, float ma, float len)\n{\n  return pow(min(max(x - ma, 0.0) / len, 1.0), 1.7);\n}\n\n// Thanks \"Candlestick\" by P_Malin\n// https://www.shadertoy.com/view/Xss3DH\nvec3 GetFlameWander()\n{\n    vec3 vFlameWander = vec3(0.0, 0.0, 0.0);\n\n\tvFlameWander.x = sin(iTime * 20.0);\n\tvFlameWander.z = sin(iTime * 10.0) * 2.0;\n\n    return vFlameWander;\t\n}\n\nvec3 vFlameColour1 = vec3(1.0, 0.5, 0.1);\nvec3 vFlameColour2 = vec3(1.0, 0.05, 0.01);\n\nvec3 GetFlameIntensity( const in vec3 vOrigin, const in vec3 vDir, const in float fDistance )\n{\n\tvec3 vFlamePos = vec3(0.0, 0.65, -8.0);\n\tvec3 vToFlame = vFlamePos - vOrigin;\n\t\n\tfloat fClosestDot = dot(vDir, vToFlame);\n\tfClosestDot = clamp(fClosestDot, 0.0, fDistance);\n\t\n\tvec3 vClosestPos = vOrigin + vDir * fClosestDot;\n\tvec3 vClosestToFlame = vClosestPos - vFlamePos;\n\t\n\tvClosestToFlame.xz *= (vClosestToFlame.y + 1.0) * 1.5;\n\tvClosestToFlame.y *= 0.5;\n\tvClosestToFlame *= 40.0;\n\n\tfloat fSwayAmount = (1.0 + vClosestToFlame.y ) * 0.05;\n\tvClosestToFlame += GetFlameWander() * fSwayAmount;\n\t\n\tfloat fClosestDist = length(vClosestToFlame);\n\t\t\n\tfloat fBrightness = smoothstep(1.0, 0.5, fClosestDist) * 2.0;\n\t\t\t\n\tfloat fHeightFade = (vClosestToFlame.y * 0.5 + 0.5);\n\tfBrightness *= clamp(dot(vClosestToFlame.xz, vClosestToFlame.xz) + fHeightFade, 0.0, 1.0);\n\n\treturn mix(vFlameColour1 * 32.0, vFlameColour2, 1.0 - fBrightness) * fBrightness;\n}\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    RayOrigin.z = opRep(RayOrigin.z, 120.0);\n    vec3 col = vec3(0.0);\n    vec3 sky = vec3(0.1, 0.3, 0.5) * 1.5;\n\n    float roughness = 0.0, metalness = 0.0;\n    vec3 albedo = vec3(0.0), n = vec3(0.0), emissive = vec3(0.0);\n    CubeLight = 4.0;\n    vec4 h = vec4(0.0);\n    \n    if (mat.y == MAT_SPONGE) {\n    \tvec3 q = p * 3.5;\n    \tvec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n        h = vec4(height(q + e.xyy), height(q + e.yyx), height(q + e.yxy), height(q + e.xxx));\n        albedo = vec3(0.12, 0.04, 0.04) * 0.5;\n        roughness = 0.5;\n\t} else if (mat.y == MAT_CREAM) {\n        albedo = vec3(0.5);\n        roughness = 0.4;\n    } else if (mat.y == MAT_BALL) {\n        albedo = vec3(0.2, 0.0, 0.0);\n        roughness = 0.2;\n    } else if (mat.y == MAT_CANDLE) {\n\t\talbedo = vec3(0.8);\n        roughness = 0.2;\n        emissive = vec3(1.0, 0.5, 0.01) * smoothstep(0.35,  0.65, p.y) * 2.0;\n    } else if (mat.y == MAT_DISH) {\n\t\talbedo = vec3(0.3, 0.1, 0.01);\n        roughness = 0.2;\n    } else if (mat.y == MAT_FRAME) {\n    \talbedo = vec3(0.8);\n        roughness = 0.2;\n        CubeLight = 1.0;\n    } else if (mat.y == MAT_OUTSIDE) {\n    \talbedo = vec3(0.3);\n        roughness = 0.3;\n        CubeLight = 1.0;\n    } else if (mat.y == MAT_INSIDE) {\n    \talbedo = vec3(1.0, 0.2, 0.5);\n        emissive = vec3(1.0, 0.2, 0.5) * 10.0 * (sin(iTime) * 0.5 + 0.5);\n        roughness = 0.2;\n    } else if (mat.y == MAT_HEART) {\n        vec3 q = Coord * 2.0;\n        float heart = min(sdHeart(q.xy), min(sdHeart(q.zx), sdHeart(q.yz))) * 0.5;\n        heart = smoothstep(0.0, 0.01, heart);\n    \talbedo = mix(vec3(0.5, 0.1, 0.2), vec3(0.8), heart);\n        emissive = mix(vec3(0.5, 0.1, 0.2) * 5.0, vec3(0.0), heart) * (sin(iTime) * 0.5 + 0.5);\n        roughness = mix(0.6, 0.2, heart);\n        CubeLight = 0.3;\n    } else if (mat.y == MAT_SHELF) {\n        float a = smoothstep(0.7, 0.9, noise(p * 3.0) * 0.5 + 0.5);\n    \talbedo = mix(vec3(0.5), vec3(0.5, 0.2, 0.05), a);\n        roughness = mix(0.6, 0.9, a);\n        metalness = 1.0;\n    } else if (mat.y == MAT_FLOOR) {\n    \tfloat checker = mod(floor(p.x) + floor(p.z), 2.0);\n        float c = mix(0.2, 0.3, checker);\n        float dirty = smoothstep(0.5, 1.0, noise_sum(p * 0.25) * 0.5 + 0.5);\n        float wet = smoothstep(0.2, 1.0, noise_sum(p *0.1) * 0.5 + 0.5);\n        c = mix(c, 0.6, dirty);\n        c = mix(c, c * 0.2, wet);\n        albedo = vec3(c);\n        \n    \tvec3 q = p * 1.0;\n    \tvec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n        h = vec4(noise_sum(q + e.xyy), noise_sum(q + e.yyx), noise_sum(q + e.yxy), noise_sum(q + e.xxx)) * 0.01;\n        roughness = mix(0.5, 0.8, checker);\n        roughness = mix(roughness, 0.6, dirty);\n        roughness = mix(roughness, 0.2, wet);\n    } else if (mat.y == MAT_CORE) {\n        albedo = vec3(1.0);\n        \n        float len = length(CoreCoord.xy);\n        float corePattern = mix(0.4, 1.0, smoothstep(0.2, 0.21, len));\n        corePattern = mix(0.4, corePattern, smoothstep(0.01, 0.02, abs(CoreCoord.y)));\n        corePattern = mix(1.0, corePattern, smoothstep(0.17, 0.175, len));\n        corePattern = mix(0.4, corePattern, smoothstep(0.11, 0.12, len));\n\n        roughness = mix(0.2, 0.5, corePattern);\n        albedo = vec3(corePattern);\n        \n        float hash = hash31(CoreID.xyz + CoreID.w);\n        float wave = max(0.0, sin(iTime * 0.3 + hash * pi2));\n        emissive += mix(vec3(1.0, 0.01, 0.01) * 3.0, vec3(0.0), smoothstep(0.0, 0.22, len)) * wave;\n        emissive += mix(vec3(1.0, 0.5, 0.1) * 40.0, vec3(0.0), smoothstep(0.0, 0.15, len)) * wave;\n    }\n    n = normal(p, 0.001, h);\n    vec3 l1 = vec3(0.0, 1.0, -8.0) + vec3(fbm(vec2(0.0, iTime)), fbm(vec2(iTime, 0.0)), fbm(vec2(iTime))) * 0.1;\n    vec3 l2 = vec3(sin(iTime * 1.0)*5., 1.0, cos(iTime * 1.0)*5.) + vec3(0.0, 0.0, -8.0);\n\n    col = pointLight(p, albedo, metalness, roughness, n, -ray, l1, vec3(1.0, 0.5, 0.1) * 20.0 * mix(0.8, 1.0, sin(iTime * 20.0) * 0.5 + 0.5));\n    col += pointLight(p, albedo, metalness, roughness, n, -ray, RayOrigin + vec3(0.0, -0.05, 0.0), vec3(0.5) * CameraLight);\n    col += pointLight(p, albedo, metalness, roughness, n, -ray, vec3(-4.1, -0.5, -12.35), vec3(0.5, 0.1, 0.2) * CubeLight * (sin(iTime) * 0.5 + 0.5));\n    col += ambient(n, albedo);\n    col += emissive;\n\n    float fo = linerFog(depth, 9.0, 50.0);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo ) + GetFlameIntensity(RayOrigin, ray, depth);\n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    for (int i = 0; i < 150; i++) {\n        pos = p + ray * t;\n        pos.z = opRep(pos.z, 120.0);\n        mat = map(pos);\n        if (mat.x < 0.00001 || t > 50.0) {\n        \tbreak;\n        }\n        t += mat.x;\n    }\n    return materialize(pos, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nfloat sm(float start, float end, float t, float smo)\n{\n    return smoothstep(start, start + smo, t) - smoothstep(end - smo, end, t);\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat exponentialOut(float t) {\n\treturn t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid cameraPath()\n{\n    float t = mod(iTime, 51.0);\n    vec3 origin = vec3(0.0, 0.0, -60.0);\n    vec3 cube = origin + vec3(-4.5, -0.5, -13.0);\n    vec3 cake = origin + vec3(0.0, 0.07, -8.0);\n    CameraLight = 0.0;\n    Black = 1.0;\n    if (t < 10.0) {\n    \t// far camera\n    \tRayOrigin =  vec3(sin(-t * 0.1) * 24.0, 6.0, cos(-t * 0.1) * 24.0) + vec3(0.0, 0.0, -60.0);\n    \tTarget = vec3(-0.0, 1.0, -68.0);\n        Black = sm(0.0, 10.0, t, 1.0);\n    } else if(t < 16.0) {\n    \t// core camera\n    \tt -= 10.0;\n    \tRayOrigin =  vec3(-t, 1.0, 0.0) + vec3(0.0, 0.0, -72.0);\n    \tTarget = RayOrigin + vec3(1.0, 0.0, -1.0);\n        Black = sm(0.0, 6.0, t, 1.0);\n    } else if(t < 26.0) {\n    \t// companion cube camera\n        t -= 16.0;\n    \tRayOrigin = cube + vec3(-t * 0.5 + 3.0, 1.0, 3.0);\n    \tTarget = cube;\n        Black = sm(0.0, 10.0, t, 1.0);\n    } else if(t < 36.0) {\n    \t// cake camera\n        t -= 26.0;\n    \tfloat dist = t * 0.2 + 0.5;\n    \tRayOrigin = cake + vec3(sin(t*0.2) * dist, 1.0 - t * 0.05, cos(t*0.2) * dist);\n    \tTarget = cake + vec3(0.0, 0.4 - t * 0.03, 0.0);\n    \tCameraLight = 3.0;\n        Black = sm(0.0, 10.0, t, 1.0);\n    } else if(t < 51.0) {\n    \t// the cake is a lie\n    \tt -= 36.0;\n        RayOrigin = mix(vec3(0.0, 1.0, 52.0), vec3(0.0, 1.0, -62.0), exponentialOut(min(1.0, t*0.06)));\n        RayOrigin.y = mix(1.0, 1.3, quadraticInOut(clamp((t-4.0)*0.2, 0.0, 1.0)));\n    \tTarget = vec3(-0.0, 1.0, -68.0);\n    \tCameraLight = 30.0;\n        Black = sm(0.0, 15.0, t, 1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    cameraPath();\n\n    mat3 c = camera(RayOrigin, Target, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.0));\n    vec3 col = trace(RayOrigin, ray);\n    \n    col = reinhard(col, 1.0, 5.0);\n    col = pow(col, vec3(1.0/2.2));\n\n    p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 200.0;\n    vig = pow(vig, 0.1);\n    \n    fragColor = vec4(col * vig * Black,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[515, 564, 587, 587, 702], [704, 704, 726, 726, 878], [880, 880, 902, 902, 957], [959, 959, 981, 981, 1081], [1083, 1114, 1140, 1140, 1365], [1367, 1367, 1396, 1396, 2113], [2115, 2115, 2136, 2136, 2167], [2169, 2169, 2194, 2194, 2333], [2335, 2335, 2355, 2355, 2550], [2552, 2552, 2574, 2574, 2647], [2649, 2649, 2670, 2670, 2738], [2740, 2885, 2919, 2919, 3040], [3041, 3041, 3080, 3080, 3109], [3110, 3110, 3146, 3146, 3175], [3176, 3176, 3212, 3212, 3241], [3243, 3243, 3271, 3271, 3304], [3306, 3306, 3329, 3329, 3344], [3346, 3346, 3379, 3379, 3407], [3409, 3409, 3451, 3451, 3550], [3552, 3552, 3616, 3616, 3737], [3739, 3739, 3782, 3782, 3881], [3883, 3883, 3959, 3959, 4252], [4254, 4254, 4276, 4276, 4472], [4475, 4475, 4533, 4533, 4664], [4666, 4666, 4724, 4724, 4862], [4864, 4864, 4895, 4895, 5045], [5047, 5047, 5070, 5070, 5505], [5507, 5507, 5538, 5538, 5683], [5685, 5685, 5708, 5708, 5790], [5792, 5792, 5815, 5815, 5915], [5917, 5917, 5938, 5938, 6172], [6174, 6174, 6196, 6196, 6672], [6674, 6674, 6707, 6707, 8303], [8305, 8305, 8326, 8326, 9104], [9106, 9106, 9132, 9132, 9288], [9290, 9290, 9311, 9311, 9595], [9597, 9597, 9615, 9615, 10487], [10489, 10489, 10535, 10535, 10869], [10871, 10871, 10915, 10915, 11149], [11151, 11151, 11195, 11195, 11366], [11368, 11368, 11409, 11409, 11452], [11454, 11454, 11517, 11517, 11628], [11630, 11630, 11703, 11703, 11797], [11799, 11799, 11906, 11906, 12476], [12478, 12478, 12592, 12592, 12905], [12911, 12911, 12946, 12946, 13003], [13005, 13005, 13051, 13051, 13106], [13108, 13184, 13207, 13207, 13362], [13451, 13451, 13546, 13546, 14392], [14394, 14394, 14453, 14453, 18889], [18891, 18891, 18921, 18921, 19231], [19233, 19233, 19275, 19275, 19453], [19455, 19455, 19482, 19482, 19541], [19543, 19543, 19597, 19597, 19739], [19741, 19741, 19795, 19795, 19875], [19877, 19877, 19908, 19908, 19980], [19982, 19982, 20013, 20013, 20065], [20067, 20067, 20086, 20086, 21573], [21575, 21575, 21632, 21632, 22114]], "test": "error"}
{"id": "wdjSzh", "name": "raymarching prac", "author": "imMurried", "description": "basic raymarching", "tags": ["raymarching"], "likes": 1, "viewed": 248, "published": "Public API", "date": "1553002396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p)\n{\n    float r = 1.33;\n    float i = 5.0;\n    \n    p.y += sin(iTime);\n    \n    float displacement = sin(i * i * p.x) * cos(i * i * p.y) * sin(i * i * p.z) * 0.1;\n    \n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n    return length(q) - r + (displacement * sin(iTime * 5.0));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    // t = intersect\n    float t = 0.0;\n    for\t(int i = 0; i < 32; ++i)\n    {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = iTime * 0.25;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec3 o = vec3(0.5, iTime * 0.2, iTime);\n    \n    float t = trace(o, r);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);   \n    \n    vec3 fc = vec3(fog);    \n    \n    vec3 color = vec3(0.7 * sin(iTime * 0.5) * (t * t * 0.1 ) + 0.2,  4.0 * cos(iTime * 0.5) * (t * t * 0.4) + 0.1, 2.0 * sin((iTime + 2.0) * 0.75) * t * t * 0.15 + 0.2);\n    \n    fc *= color;\n    \n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 287], [289, 289, 318, 339, 495], [497, 497, 554, 604, 1376]], "test": "valid"}
{"id": "wdjSzW", "name": "Rgb Crown", "author": "Oggy", "description": "Rotating sine waves.", "tags": ["rgb", "trigonometry"], "likes": 1, "viewed": 331, "published": "Public API", "date": "1553128655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n\n    vec2 uv = (iResolution.xy - 2. * fragCoord.xy) / iResolution.y;\n\n\n\n    vec3 color =\n        uv.y + cos(tan(uv.x) + vec3(0, pi, pi * 9.42 ) + iTime);\n\n     \n    fragColor.rgb = 1. - sqrt(color);\n    \n    // fragColor.rgb = vec3(mainSound( in int samp,iTime), 1) * pi. * 1.144; // for debug\n    fragColor.a = 1.; \n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.45015815807 + 0.45015815807*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,0.45015815807);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 73, 73, 392], [394, 394, 485, 515, 637]], "test": "valid"}
{"id": "wdjXWR", "name": "Sine Wave Illusion", "author": "SouthernPotato", "description": "One wave will become many", "tags": ["illusion", "opticalillusion", "sinewave"], "likes": 1, "viewed": 91, "published": "Public", "date": "1553485817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float amplitude = 0.25;\nfloat dialationFactor = 3.0;\nfloat radius = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0,0,0);\n    \n    for (float f = fragCoord.x - radius*iResolution.y; f < fragCoord.x + radius*iResolution.y; f += 1.) {\n        float dialation = f/500.0f * dialationFactor;\n\n        float targety = 0.5f + sin(iTime * (1.0f + dialation)) * amplitude;\n\n        float distSqr = pow(uv.y - targety, 2.) + pow((f - fragCoord.x)/iResolution.y, 2.);\n\n\n        if (distSqr < radius*radius)\n            col.y += 1. - sqrt(distSqr)/radius;//1. - abs(uv.y - targety) / radius;//1.0f;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 132, 182, 784]], "test": "valid"}
{"id": "WdjXz1", "name": "[twitch] Smoke Screen", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS or VOLUME_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SmokeScreen.glsl", "tags": ["3d", "volumetric", "live", "twitch"], "likes": 18, "viewed": 364, "published": "Public", "date": "1552948077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS or VOLUME_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SmokeScreen.glsl\n*/\n\n#define MARCH_STEPS 100\n#define VOLUME_STEPS 50\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat box(vec3 p, vec3 r) {\n  vec3 ap=abs(p)-r;\n  return length(max(vec3(0),ap)) + min(0.0, max(ap.x,max(ap.y,ap.z)));\n}\n\nfloat cyl(vec3 p, float r, float s) {\n  return max(length(p.xy)-r,abs(p.z)-s);\n}\n\nfloat map(vec3 p) {\n  \n  float b1 = box(p, vec3(10,8,1));\n  b1 = max(b1, -box(p-vec3(0,0,-1), vec3(9,7,1)));\n  b1 = min(b1, -box(p+vec3(0,0,20), vec3(30,10,20)));\n  \n  vec3 ap=abs(p)-vec3(10,8,0);\n  b1 = min(b1, abs(cyl(ap+vec3(-4,5,0), 1.2, 1.0))-0.2);\n  \n  return b1;\n}\n\nvec3 rnd(float t) {\n  return fract(sin(t*78.65)*vec3(7893.854,5847.655,3874.951));\n}\n\nfloat rnd1(float t) {\n  return fract(sin(t*943.522)*7983.221);\n}\n\nvec3 noise(vec2 p) {\n  vec2 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  p=smoothstep(0.0,1.0,p);\n  p=smoothstep(0.0,1.0,p);\n  vec2 st=vec2(7,133);\n  vec2 val=dot(ip,st)+vec2(0,st.y);\n  vec3 v1 = mix(rnd(val.x), rnd(val.x+st.x), p.x);\n  vec3 v2 = mix(rnd(val.y), rnd(val.y+st.x), p.x);\n  return mix(v1,v2,p.y);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,133,381);\n  vec4 val=dot(ip,st)+vec4(0,st.y,st.z,st.y+st.z);\n  vec4 v1 = mix(fract(sin(val)*4985.655), fract(sin(val+st.x)*4985.655), p.x);\n  vec2 v2 = mix(v1.xz,v1.yw, p.y);\n  return mix(v2.x,v2.y,p.z);\n}\n\nvec3 moving(vec2 p, float t, float d) {\n  float g=t/d;\n  vec3 a=noise(p+rnd1(floor(g))*987.565);\n  vec3 b=noise(p+rnd1(floor(g+1.0)*987.565));\n  return mix(a,b,pow(smoothstep(0.0,1.0,fract(g)),10.0));\n}\n\n\nvec3 window(vec2 p) {\n  \n  p*=rot(time*0.3);\n  p=abs(p)-0.8;\n  p*=rot(time*0.4);\n  p=abs(p)-0.5;\n  \n  vec3 f = moving(p, time, 0.5);\n  \n  f.xy *= rot(p.x);\n  f.yz *= rot(p.y*2.2);\n  \n  f = vec3(0.2,0.5,8.0)*f.x;\n  \n  f += step(sin(length(p.xy)-time*3.0),0.5) * exp(-fract(time*0.5));\n  f=clamp((f-0.7)*10.0,0.0,1.0);\n  \n  return f;\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd1(floor(g)), rnd1(floor(g+1.0)), pow(smoothstep(0.0,1.0,fract(g)),10.0));\n}\n\nfloat masking(vec3 p) {\n  vec2 ap=abs(p.xy)-vec2(10,8);\n  float mask = step(max(ap.x,ap.y),-1.1);\n  \n  mask = max(mask, 5.0*step(length(ap+vec2(-4,5)),1.0));\n  \n  return mask;\n}\n\nvec3 volume(vec3 p) {\n  vec2 p2 = p.xy*3.0/(-1.0+p.z*0.1-curve(time, 0.3)*10.0);\n  vec2 sel = abs(p.xy)-vec2(10,8);\n  float sel2 = max(sel.x,sel.y);\n  p2 = mix(p2, floor(p.xy/10.0), step(0.0,sel2));\n  vec3 val = window(p2);\n  return val * masking(p);\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*vec2(798.655)+uv.yx*vec2(942.642)),vec2(9865.655)));\n}\n\nfloat fractal(vec3 p) {\n  float n=noise(p) * 0.5;\n  float t=time*1.8;\n  p.y+=t*0.7;\n  n += noise(p*2.0)*0.25;\n  p.z+=t*0.5;\n  n += noise(p*4.0)*0.125;\n  p.x+=t*0.7;\n  return n;\n}\n\nfloat cloud(vec3 p) {\n  float n = fractal(p*0.5);\n  n=clamp((n-0.3)*30.0,0.0,1.0);\n  //n=pow(n, 3);\n  return clamp(n*0.12+0.9,0.0,1.0);\n}\n\nvoid cam(inout vec3 p) {\n  float t=time*0.3;\n  p.yz*=rot(0.0+sin(t*0.3)*0.2);\n  p.xz*=rot(sin(t)+0.25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0,0,-30);\n  vec3 r=normalize(vec3(-uv, 0.7+curve(time, 1.5)*0.7));\n  \n  cam(s);\n  cam(r);\n  \n  s.y += (curve(time,1.5)-0.5)*4.0;\n  \n  float rand = rnd(uv);\n  \n  vec3 col=vec3(0);\n  \n  vec2 off=vec2(0.01,0);\n  \n  \n  vec3 backcol = vec3(0);\n  for(int i=-3;i<3; ++i) {\n    for(int j=-3;j<3; ++j) {  \n      backcol += volume(vec3(i,j,0)*0.5);\n    }\n  }\n  backcol /= 49.0;\n  \n  // First raymarching with distance field, to get first collision (and reflections)\n  vec3 p=s;\n  float dd=0.0;\n  float prod = 1.0;\n  vec3 ray = r;\n  bool first = false;\n  float limit=0.0;\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n  \n      vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n      float fog = 1.0-clamp(dd/100.0,0.0,1.0);\n      \n      vec3 l=normalize(vec3(0,0,-5)-p);\n      float aodist=0.5;\n      float ao=clamp(map(p+n*aodist)/aodist,0.0,1.0);\n      float f=pow(1.0-abs(dot(ray,n)),1.0);\n      float mas = 1.0-masking(p);\n      \n      vec3 diff=vec3(noise(p.yz*vec2(0.8,15)).x*0.5+noise(p.yz*vec2(0.8,15)*2.0).x*0.4)*2.0*vec3(0.8,0.7,0.2);\n      diff=mix(diff, vec3(1), step(abs(p.x), 29.9));\n      \n      col += prod * diff*max(0.0, dot(n, l)) * 2.0 * fog * backcol * ao * (mas*0.7+0.3);\n      col += prod * diff*volume(p) * fog;    \n      \n      float size = 2.0;\n      vec3 mat1 = (fract(p/size+0.01)-0.5)*size;\n      float mat=max(mat1.x,max(mat1.y,mat1.z));\n      //col += mat*3;\n      float mas2=step(7.9,p.y);\n      if(mat*mas*mas2>size*0.48) break;\n\n      prod *= f;\n      if(!first) {first=true;limit=dd;}\n      if(prod<0.1) break;\n      ray = reflect(ray, n);\n      d = 0.01;\n      //break;\n    }\n    if(dd>100.0) { dd=100.0; break; }\n    p+=ray*d;\n    dd+=d;\n  }\n    \n  // second raymarching with fixed step size\n  const float maxdist=40.0;\n  const int steps=VOLUME_STEPS;\n  const float fstep = maxdist/float(steps);\n  vec3 or=fstep*r;\n  float prog = rand*fstep;\n  vec3 vp=s+prog*r;\n  vec3 val=vec3(0);\n  float alpha = 1.0;\n  for(int i=0; i<steps; ++i) {\n    if(prog>limit) break;\n    if(alpha<0.01) break;\n    float fade = 1.0-clamp(-(vp.z)/20.0,0.0,1.0);\n    alpha *= cloud(vp);\n    val += alpha * volume(vp)*fade*fade;\n    vp+=or;\n    prog += fstep;\n  }\n  col *= (1.0-alpha*0.7);\n  col += val*0.3*alpha;\n    \n    \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 338, 357, 357, 426], [428, 428, 455, 455, 548], [550, 550, 587, 587, 630], [632, 632, 651, 651, 903], [905, 905, 924, 924, 989], [991, 991, 1012, 1012, 1055], [1057, 1057, 1077, 1077, 1380], [1382, 1382, 1403, 1403, 1687], [1689, 1689, 1728, 1728, 1891], [1894, 1894, 1915, 1915, 2227], [2229, 2229, 2260, 2260, 2367], [2369, 2369, 2392, 2392, 2546], [2548, 2548, 2569, 2569, 2800], [2802, 2802, 2822, 2822, 2903], [2905, 2905, 2928, 2928, 3083], [3085, 3085, 3106, 3106, 3222], [3224, 3224, 3248, 3248, 3329], [3331, 3331, 3388, 3388, 5850]], "test": "valid"}
{"id": "WdjXzh", "name": "Doctor, I Think I Have Gyroids", "author": "bignobody", "description": "First experiments with the Gyroid equation: cos X * sin Y + cos Y * sin Z + cos z * sin X = 0\nThanks to BigWIngs for suggesting it (and for your awesome ArtOfCode videos, they're pretty great!), and to iq and Jamie Wong.", "tags": ["raymarch", "gyroid"], "likes": 6, "viewed": 123, "published": "Public", "date": "1553016482", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define EPSILON 0.001\n#define MAX_DIST 500.0\n\nfloat gyroid(vec3 p )\n{\n\tfloat g = cos(p.x) * sin(p.y) + cos(p.y) * sin(p.z) + cos(p.z) * sin(p.x);\n    return length(normalize(p)*g);\n\n// I also got some interesting results by making a vector from the component parts of the Gyroid equation:\n//\tvec3 g = normalize(vec3(cos(p.x) * sin(p.y), cos(p.y) * sin(p.z), cos(p.z) * sin(p.x)));\n//\treturn cos(length(g));\t\n//return (sqrt(p.x+g.y*p.y+g.x));\n\t//return atan(p.x+g.y,p.y+g.x);\n\t//return distance(p,g);\n    //return length(cross(p,g));\n\t//return length(sqrt(cross(p,g)));\n}\n\nfloat sceneSDF(vec3 p)\n{\n    return gyroid(p);\n}\n\nfloat distToSurface( vec3 eye, vec3 dir, float startDist, float endDist )\n{\n\tfloat depth = startDist;\n\tfor (int i = 0; i < MAX_STEPS; i++) \n    {\n    \tfloat dist = sceneSDF(eye + depth * dir);\n    \tif (dist < EPSILON) \n        {\n        // We're inside the scene surface!\n        return depth;\n    \t}\n    \t// Move along the view ray\n    \tdepth += dist;\n\n    \tif (depth >= MAX_DIST) \n        {\n        \t// Gone too far; give up\n        \treturn endDist;\n    \t}\n    }\n    return endDist;\n}\n\nvec3 estimateNormal(vec3 p) \n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 0.45;\n    float ext = iTime * 0.6;\n    vec3 lookAt = vec3(0.0,0.5,0.0);\n    vec3 camOrigin = vec3(10.0 * cos(iTime * 0.1)+ext,6.5 * cos(iTime * 0.5)+4.2+ext,-10.0 * sin(iTime * 0.1)+ext);\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n\n    float d = distToSurface(camOrigin,rayDirection, 0.0,MAX_DIST);\n\tvec3 g = estimateNormal(camOrigin + rayDirection * d);\n    d = d/length(g);\n  \tvec3 p = camOrigin + rayDirection * d;\n  \n   \t\n    if (d > MAX_DIST-EPSILON)\n    {\n     \t// no hit\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        return;\n    }\n    vec3 col = vec3(clamp(d,0.0,0.9))*(g);\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 90, 90, 591], [593, 593, 617, 617, 641], [643, 643, 718, 718, 1129], [1131, 1131, 1161, 1161, 1471], [1474, 1474, 1531, 1572, 2640]], "test": "valid"}
{"id": "wdlSD2", "name": "experiment v1", "author": "fabiovergani", "description": "experiment 1", "tags": ["experiment1"], "likes": 2, "viewed": 116, "published": "Public", "date": "1552261419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 light;\nfloat ui;\nmat2 m,n,nn;\nfloat map (vec3 p) {\n    float d = length(p-light.xyz)-light.w;\n    d = min(d,max(10.-p.z,0.));\n    float t = 2.5;\n    for (int i = 0; i < 13; i++) {\n        t = t*0.66;\n        p.xy = m*p.xy;\n        p.yz = n*p.yz;\n        p.zx = nn*p.zx;\n        p.xz = abs(p.xz) - t;\n\n    }\n    d = min(d,length(p)-1.4*t);\n\n    return d;\n}\nvec3 norm (vec3 p) {\n    vec2 e = vec2 (.001,0.);\n    return normalize(vec3(\n        map(p+e.xyy) - map(p-e.xyy),\n        map(p+e.yxy) - map(p-e.yxy),\n        map(p+e.yyx) - map(p-e.yyx)\n    ));\n}\nvec3 dive (vec3 p, vec3 d) {\n    for (int i = 0; i < 20; i++) {\n        p += d*map(p);\n    }\n    return p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v = fragCoord/iResolution.xy*2.-1.;\n\tv.x *= iResolution.x/iResolution.y;\n    ui = 100.*iTime;\n    float y = -0.001*ui;\n    m = mat2(sin(y),cos(y),-cos(y),sin(y));\n    y = 0.0035*ui;\n    n = mat2(sin(y),cos(y),-cos(y),sin(y));\n    y = 0.0023*ui;\n    nn = mat2(sin(y),cos(y),-cos(y),sin(y));\n    vec3 r = vec3(0,0,-15.+2.*sin(0.01*ui));\n    light = vec4(10.*sin(0.01*ui),2,-23,1);\n    vec3 d = normalize(vec3(v,5.));\n    vec3 p = dive(r,d);\n    d = normalize(light.xyz-p);\n    vec3 no = norm(p);\n\n    vec3 bounce = dive(p+0.01*d,d),\n    col = mix(no,vec3(0),dot(no, normalize(light.xyz-p)));\n    if (length(bounce-light.xyz) > light.w+0.1) col *= 0.2;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 55, 55, 360], [361, 361, 381, 381, 557], [558, 558, 586, 586, 666], [667, 667, 724, 724, 1417]], "test": "valid"}
{"id": "wdlSDB", "name": "atan1", "author": "Del", "description": "messing around", "tags": ["atan"], "likes": 5, "viewed": 148, "published": "Public", "date": "1552093941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// atan1 - messing around...\n\n#define\tPI 3.141592\n\nvec3 pat(vec2 uv,float t)\n{\n\tfloat ang = atan(uv.x, uv.y)/(2.*PI);\n\tfloat dist = length(uv);\n    //dist*=dist;\n\tvec3 col = vec3(0.3, 0.5, 0.7) * (pow(dist, -1.0) * 0.05);\n\tfor (float ray = 0.5; ray < 8.0; ray += 0.6)\n\t{\n\t\tfloat rayang = t*ray/3.0/PI;\n\t\trayang = fract(rayang-dist+(dist*(ray*0.5)));\n\t\tif (rayang < ang - 0.5)\n            rayang += 1.0;\n\t\tif (rayang > ang + 0.5)\n            rayang -= 1.0;\n\t\tfloat b = 0.3 - abs(ang - rayang)*2.0*PI;\n\t\tb -= dist * 0.3;\n\t\tif (b > 0.0)\n\t\t\tcol.rgb += vec3(0.7+0.85*ray, 0.4+0.4*ray, 0.4+0.85*ray) *0.5*b;\n\t}\n    col.g *= 1.2+sin(dist+t*0.45)*0.25;\n    \n    col.rb *= 0.75+sin(t*0.661+uv.x*uv.y)*0.5;\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\tuv *= 0.25;\n    \n    // wibble...\n    if (iMouse.z>0.5)\n    {\n    \tuv.x += sin(uv.y*32.0+t*0.4)*0.01;\n    \tuv.y += sin(uv.x*32.0+t*0.4)*0.01;\n    }\n    \n\tuv *= 1.1+sin(t*0.9);\n\tfragColor = vec4( pat(uv,t), 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 51, 78, 78, 716], [718, 718, 775, 775, 1081]], "test": "valid"}
{"id": "wdlSDl", "name": "Triskel - Animate", "author": "flyingrub", "description": "Fork of https://www.shadertoy.com/view/XlVXRW", "tags": ["triskel", "celtic"], "likes": 3, "viewed": 98, "published": "Public", "date": "1552581718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pixel_width 100./iResolution.y\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n\tvec2 R = iResolution.xy;\n    U = (U+U-R)/R.y + vec2(0,.1);\n    \n    float tau = 6.283,                                       // 3 symmetries\n            a = -floor((atan(U.y,U.x)-.33)*3./tau)/3.*tau -.05, l;\n    U *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    U = 3.*(U-(vec2(0,.350)+vec2(0,.350)*cos(iTime*.03)));\n    \n\n    l = length(U), a = atan(U.y,U.x);                        // spiral\n\tO = vec4( l + fract((a+2.25)/tau) < 5. + cos(iTime*.2) * 2. ? 0.5+.5*sin(a+tau*l*sin(iTime*.2)*5.) : 0.);\n    \n\tO = smoothstep(pixel_width,.0,abs(O-.5));   // optional decoration\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 79, 79, 651]], "test": "valid"}
{"id": "WdlSDs", "name": "Diffuse Sphere Intersection", "author": "PhiWei", "description": "A simple ray intersection with a diffuse sphere.", "tags": ["sphere", "diffuse", "rayintersection"], "likes": 1, "viewed": 87, "published": "Public", "date": "1552646283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n*   Intersection with a sphere centered at origin\n**/\nfloat intersectWithSphere(in vec3 ro , in vec3 wd){\n    // Sphere centered at (0,0,0) radius\n    float R = 1.0;\n\t\n    // b²- 4*a*c : a is 1 since direction is normalized\n    float b = 2.0 * dot(wd, ro);\n    float c = dot(ro.xyz, ro)- R*R;\n\n    float delta = b*b - 4.0*c;\n\n\tif(delta > 0.0)\n        return (-b + sqrt(delta)) * 0.5;\n    else if(delta == 0.0)\n        return -b * 0.5;\n    else\n        return -1.0; // \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightColor = vec3(1.0,1.0,1.0);\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * lightColor;\n\n    vec3 albedo = vec3(0.7,0.5,0.0);\n    //pixel coordinates from 0 to 1\n\tfloat aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Ray origin\n    vec4 ro = vec4(0.0, 0.0, 2.0, 1.0);\n    // Ray direction going inside screen\n    vec3 wd = normalize(vec3((-1.0 + 2.0 * uv) * vec2(aspectRatio, 1.0) , -1)); \n\n    // get distance to first intersection\n    float t = intersectWithSphere(ro.xyz,wd);\n    // normalize distance\n    \n    //point light source\n    vec3 pls = vec3(-5.0*cos(iTime),5.0*sin(iTime),-5.0*sin(iTime));\n\n    vec3 color;\n\n    // Output to screen a lambertian diffuse material simulation Incident Light Energy ∗ cos(theta)\n    if(t > 0.0){\n        vec3 its = ro.xyz + wd * t;\n        // calculate normal at intersection\n\n        float cosTheta = dot(normalize(its),normalize(pls-its));\n        vec3 diffuse = lightColor * max(0.0,cosTheta);\n\n        color = (diffuse + ambient)*albedo;\n    \n    }else{\n        color = vec3(0.2);\n    }\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 58, 109, 150, 475], [479, 479, 536, 536, 1687]], "test": "valid"}
{"id": "wdlSDX", "name": "Sierpinski tree?", "author": "saidwho12", "description": "A friend sent me something looking similar to this and I thought it looked a lot like a Sierpinski triangle but as a tree. You can move the mouse while clicking horizontally to change depth or vertically to change alpha.", "tags": ["2d", "fractal", "transparency", "sdf", "antialiasing", "tree", "ao", "aa", "serpinski"], "likes": 17, "viewed": 318, "published": "Public", "date": "1552422096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n#define TAU 6.28\n\nfloat udLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = TAU/repetitions;\n    float r = length(p);\n    float a = atan(p.y, p.x) + /*(.5+.5*cos(iTime))*angle/2. */angle/2. + .15 * sin(5. * iTime - 1.5 * r);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvoid mainImage( out vec4 O, in vec2 u ) {\n    vec2 R = iResolution.xy;\n    vec3 p = vec3((u+u-R)/R.y,1);\n    O -= O++;\n    \n    float vignette = .8+.2*smoothstep(2.5,.2,length((u+u-R)/R));\n    \n    bool clicked = iMouse.z > 0.;\n    float alpha = clicked ? iMouse.y/R.y : 1.;\n    \n    float X = 10.0;\n    for(float i = -1., N = clicked ? 1.+floor(X*iMouse.x/R.x) : X; ++i < N;) {\n        float x = (i+.5)/N;\n        \n        float angle = pModPolar(p.xy, 3.);\n        //p.xy*=rot(TAU/N*.3*sin(x-iTime));\n    \t\n        float t = udLine(p.xy, vec2(0), vec2(.5,0)) / p.z  - (.0014+.012*pow(1.-x,2.5));\n    \t\n        // Anti-aliasing\n        float s = smoothstep(3./R.y, 0., t);\n        vec4 col = vec4(mix(vec3(.55,.4,.07), vec3(.3,.97,.12), x), pow(1.-x,1.2)*s*alpha);\n        \n        // Ambient occlusion\n        //O.rgb *= 1.-.3*exp(-.25*clamp(t,0.,1.)*R.y)*(1.-s);\n        O.rgb *= 1.-.3*pow(1.-x,3.5)*exp(-(.2-.15*x)*clamp(t,0.,1.)*R.y);\n        \n        // Alpha blending\n        O = (1.-col.a)*O + col.a*col;\n        \n        p += p;\n        //p.x -= scale+.1*texture(iChannel0, vec2(.5)).r;\n        p.x--;\n        //p.x-=fract(iTime);\n    }\n    \n    O.rgb = clamp(O.rgb,0.,1.);\n    //O.rgb *= vignette;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlSDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 81, 81, 201], [203, 203, 253, 253, 564], [617, 617, 658, 658, 1826]], "test": "valid"}
{"id": "WdlSRS", "name": "midterm2", "author": "jojo169", "description": "2 ", "tags": ["2"], "likes": 1, "viewed": 35, "published": "Public", "date": "1551543735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat quad(vec2 uv,float posX, float posY)\n{\n    float quad = step(posX,uv.x)-step(posY,uv.x);\n\tquad = quad + step(posX,uv.y)-step(0.,uv.y)-step(posY,uv.y);\n    return quad;\n}\n\nfloat shape(vec2 uv,float pos1,float pos2,float hands,float size)\n{\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos = vec2(pos1*ratio,pos2);\n    float dist = distance(shapePos,uv)*2.;\n    \n    uv -=shapePos;\n    float angle= atan(uv.y,uv.x);\n    float radius = tan(2.*angle);\n    radius = abs(cos(quad(uv,.5,.5)*(hands/2.)+iTime));\n    \n    float value = 1.-step(radius/size,dist);\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 bgcolor = vec3((cos(iTime)+1.)/3.,1.,0);\n    vec3 red = vec3(1.,0,0);\n\n\tvec3 val = mix(bgcolor+.2,red, shape(uv,.5,.5,5.,5.));\n\n    // Output to screen\n    fragColor = vec4(val,uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlSRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 46, 46, 177], [179, 179, 246, 246, 621], [623, 623, 680, 730, 963]], "test": "valid"}
{"id": "WdlSRX", "name": "Checkerboard 1", "author": "OliverSchaff", "description": "Irregular checkerboard pattern with circles.", "tags": ["2d", "grid", "warping"], "likes": 15, "viewed": 302, "published": "Public", "date": "1551796362", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This shader by vug is very similar and served as inspiration: \n// https://www.shadertoy.com/view/Xs2GDd\n\n#define PI 3.14159265\n\n// number of tiles in y direction\nconst float numOfTilesY = 5.0;\n    \n// palette by Inigo Quilez\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 color(float c) {\n// 0.0 < c < 1.0 covers the full palette\n    return pal( c, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat vnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // aa is used in smoothstep for antialiasing. It scales with the number of tiles\n    // and with iResolution.\n    float aa = 3.0/min(iResolution.x, iResolution.y)*numOfTilesY;\n\n    // distort the uv plane with a shift per pixel\n    // the noise has to be scaled by the number of tiles\n    float noise = 2.0*PI*vnoise(.5*numOfTilesY*uv+0.2*iTime);\n    vec2 shift = .1/(numOfTilesY) * vec2(cos(noise), sin(noise));\n    uv += shift;\n\n    // tile the image\n    uv *= numOfTilesY;\n    vec2 fuv = fract(uv); // fractional part within tile, runs from 0-1\n    vec2 iuv = floor(uv); // integer-part index vector of tile\n    \n    // distance function to the edges of the tiles, based on the fractional part\n    // later it will be used as a basis for drawing different sized disks\n    vec2 dist = 1.0-2.0*abs(fuv);\n    \n    // background color\n    vec3 col = vec3(0.);\n    \n    // parameters for moving two layers of disks around, using the integer part of the tiles for randomness\n    float phase1 = 10.0*random(iuv);\n\tvec2 shapeShift1 = 0.2*vec2(cos(iTime+phase1),sin(iTime+phase1));\n    float phase2 = -4.3*random(iuv);\n\tvec2 shapeShift2 = 0.3*vec2(cos(2.*iTime+phase2),sin(iTime+phase2));\n    \n    // first layer of disks, fixed in the local uv coordinate system of the tile\n    // colors are controlled by the integer index of the tiles.\n    col = mix (color(iuv.y/numOfTilesY+0.1).xyz, col , 1.0-smoothstep(0.1, 0.1+aa, 1.0-length(dist)));\n    // second layer of disks, moving around by shapeShift1\n    col = mix (color(0.4*iuv.x/numOfTilesY+0.1).xyz, col , 1.0-smoothstep(0.4, 0.4+aa, 1.0-length(dist+shapeShift1)));\n    // third layer of disks, moving around with shapeshift2\n    col = mix (color(0.5*(iuv.x+iuv.y)/numOfTilesY+0.2).xyz, col , 1.0-smoothstep(0.6, 0.6+aa, 1.0-length(dist+shapeShift2)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 228, 296, 296, 339], [341, 341, 362, 403, 501], [503, 503, 525, 525, 664], [666, 666, 693, 693, 810], [813, 895, 918, 918, 1322], [1325, 1325, 1382, 1432, 3381]], "test": "valid"}
{"id": "WdlSz2", "name": "Shader5 - Windmill", "author": "EmperorLem", "description": "3 Windmills", "tags": ["color"], "likes": 2, "viewed": 63, "published": "Public", "date": "1551705671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 brown = vec3(0.3,0.2,0.2);\nvec3 black = vec3(0.0,0.0,0.0);\nvec3 red = vec3(0.7,0.0,0.0);\nvec3 blue = vec3(0.5,0.5,.5);\nvec3 yellow = vec3(0.5,0.5,0.0);\nvec3 green = vec3(0.1,0.9,0.0);\nvec3 white = vec3(1.0,1.0,1.0);\n\nfloat circle(vec2 uv, vec2 pos, float r)\n{       \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float dist = distance(pos, uv);\n    float value = step(r, dist);\n    \n    return value;\n}\n\nfloat land(vec2 uv, vec2 pos, float r)\n{       \n    uv.x *= 0.4;\n    \n    float dist = distance(pos, uv);\n    float value = smoothstep(r, r + 0.03, dist);\n    \n    return value;\n}\n\nfloat windMill(vec2 uv, vec2 pos, float r)\n{   \n    float dist = distance(pos, uv) * r;\n    float value = step(r, dist);\n    \n    uv -= pos;\n    \n    float speed = 2.0;\n\n    float angle = (atan(uv.y, uv.x) + iTime * speed);\n    \n    float radius = cos(angle * 6.0);\n    \n    value = step(radius , dist);\n    \n    return value;\n}\n\nfloat leaf(vec2 uv, vec2 pos, float r)\n{   \n    float dist = distance(pos, uv) * r;\n    float value = step(r, dist);\n    \n    uv -= pos;\n    \n    float speed = 4.0;\n\n    float angle = (atan(uv.y, uv.x) + iTime * speed);\n    \n    float radius = cos(angle * 2.0);\n    \n    value = step(radius , dist);\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float mLand = land(uv, vec2(0.2,-0.2), 0.4);\n    vec3 landCol = mix(brown, sin(yellow * iTime * 2.0) / 1.5 + 0.3, mLand);\n    \n    float height = step(0.07,uv.y) - step(0.3,uv.y);\n    float width = step(0.1,uv.x) -step(0.12,uv.x);\n    \n    vec3 rectangle = mix(landCol, red, height * width);\n    \n    height = step(0.1,uv.y) - step(0.35,uv.y);\n    width = step(0.4,uv.x) - step(0.42,uv.x);\n    \n    rectangle = mix(rectangle, red, height * width);\n    \n    height = step(0.07,uv.y) - step(0.3,uv.y);\n    width = step(0.8,uv.x) -step(0.82,uv.x);\n    \n    rectangle = mix(rectangle, red, height * width);\n    \n    float mWindMill = windMill(uv, vec2(0.11,0.3), 6.0);\n    vec3 millCol = mix(green, rectangle, mWindMill);\n    \n    float mWindMill2 = windMill(uv, vec2(0.41,0.35), 6.0);\n    millCol = mix(green, millCol, mWindMill2);\n    \n    float mWindMill3 = windMill(uv, vec2(0.81,0.3), 6.0);\n    millCol = mix(green, millCol, mWindMill3);\n    \n    float mLeaf = leaf(uv, vec2(clamp(sin(0.5 * iTime) + 0.5, -0.1, 2.0),0.8), 10.0);\n    millCol = mix(green, millCol, mLeaf);\n    \n    \n    \n    \n\n    // Output to screen\n    fragColor = vec4(millCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlSz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 264, 264, 411], [413, 413, 453, 453, 592], [594, 594, 638, 638, 922], [924, 924, 964, 964, 1248], [1250, 1250, 1307, 1357, 2616]], "test": "valid"}
{"id": "WdlSzf", "name": "Warm Smoke", "author": "polymonster", "description": "Prototype background screen.", "tags": ["noise"], "likes": 4, "viewed": 321, "published": "Public", "date": "1551793115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// fbm thanks to iq!\n#define NUM_OCTAVES 6\n\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat rand(vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(float p)\n{\n\tfloat fl = floor(p);\n  \tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\t\nfloat fbm_2(vec2 x) \n{\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) \n    {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat sb(float t)\n{\n    return sin(t) * 0.5 + 0.5;\n}\n\nfloat cb(float t)\n{\n\treturn cos(t) * 0.5 + 0.5; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = 1.0 / (iResolution.xx / iResolution.xy); \n    \n    vec2 ndc = uv * 2.0 - 1.0;\n    \n    uv *= aspect;\n    \n    vec2 c1 = vec2(1.0, 1.0) + vec2(sb(iTime * 0.3) * 0.2, cb(iTime * 0.11) * 0.2);\n    vec2 c2 = vec2(-1.0, -1.0) - vec2(cb(iTime * 0.5) * 0.2, sb(iTime * 2.0) * 0.2);\n    \n    float s1 = 1.0 + cb(iTime * 0.1) * 0.8;\n    float s2 = 1.0 + sb(iTime * 0.1) * 0.8;\n    \n    vec3 p1 = vec3(255.0, 87.0, 51.0) / 255.0;\n    vec3 p2 = vec3(87.0, 24.0, 69.0) / 255.0;\n    vec3 p3 = vec3(199.0, 0.0, 57.0) / 255.0;\n    \n    float nt = iTime * 0.4;\n    vec2 nuv = uv * 5.0;\n    \n    float n = fbm_2(nuv + nt) + fbm_2(nuv - nt * vec2(1.0, 0.0));\n\tfloat n2 = fbm_2(nuv - cos(nt));\n\tfloat n3 = fbm_2(nuv + vec2(0.0, 1.0) * cos(nt));\n        \n    float r2 = max(1.0 - length(c1 - ndc) * s1, 0.0);\n    float r3 = max(1.0 - length(c2 - ndc) * s2, 0.0);\n    float rr = 0.1 + (r2*r2 + r3*r3);\n    \n    vec3 col = p1 * n + p2 * n2 + p3 * n3;\n\n    fragColor = vec4(col * rr, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 65, 65, 109], [111, 111, 132, 132, 199], [201, 201, 223, 223, 314], [316, 316, 337, 337, 546], [549, 549, 571, 571, 815], [817, 817, 836, 836, 869], [871, 871, 890, 890, 921], [923, 923, 980, 980, 2007]], "test": "valid"}
{"id": "WdlXDf", "name": "Seed scatter simulation", "author": "codebro", "description": "Mathmatical simulation various possibilities of scattering seeds.\n\nInspired by https://www.youtube.com/watch?v=sj8Sg8qnjOg (The Golden Ratio (why it is so irrational) - Numberphile)", "tags": ["spiral", "goldenratio", "seeds"], "likes": 3, "viewed": 151, "published": "Public", "date": "1552397773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EMPTY_C vec4(0)\n#define PI 3.14159265359\n#define NUMBER_OF_DOTS 64.0\n#define GOLDEN_RATIO 1.61803398875\n\nvec4 circle(in float distance, in vec3 color) {\n  float t = smoothstep(0.0, 1.0, distance);\n  return mix(\n           vec4(\n             color,\n             1.0\n           ),\n           EMPTY_C,\n           t\n         );\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0 );\n\trgb = rgb * rgb * (3.0 - 2.0 * rgb);\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 color(in vec2 pos, in vec2 origin) {\n  return hsv2rgb(vec3(distance(pos, origin) * 1.75, 1.0, 1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 coord = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n  float time = (\n      GOLDEN_RATIO\n      + iTime * 0.01 // comment out this line to see the most efficient way \n      //to scatter seeds developed in nature through years of evolution\n  );\n\n  vec4 circles;\n    \n  for (float i = 0.0; i <= NUMBER_OF_DOTS; i++) {\n    float radius = 0.014 * i;\n    float radians = time * i * PI * 2.0;\n    vec2 d = coord;\n    float x = sin(radians) * radius;\n    float y = cos(radians) * radius;\n    vec2 pos = d - vec2(x, y);\n    circles += circle(\n      length(pos) * 50.0,\n      hsv2rgb(vec3(length(d) * 1.75, 1.0, 1.0))\n    );\n  }    \n  fragColor = circles;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 160, 160, 333], [335, 335, 362, 362, 533], [535, 535, 576, 576, 642], [645, 645, 702, 702, 1365]], "test": "valid"}
{"id": "wdlXDj", "name": "ray_tracing", "author": "inaara98", "description": "Машграф 2019\nРеализация трассировки лучей на примере трёх объемных фигур. Выполнено для случая с одним источником света.\n", "tags": ["raytracing"], "likes": 1, "viewed": 138, "published": "Public", "date": "1552251349", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n    \nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float td = sdTorus(p-vec3(0,.5,6), vec2(1.5, .4));\n    float bd = dBox(p-vec3(-3.5, 1, 6), vec3(1,.75,1));\n    float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, .3, 5), .3);\n    \n    float d = min(td, planeDist);\n    d = min(d, bd);\n    \n    d = min(d, cyld);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*10.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 2, 0);\n    vec3 rd = normalize(vec3(uv.x-.15, uv.y-.2, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 123, 123, 407], [409, 409, 440, 440, 508], [510, 510, 538, 538, 575], [578, 578, 601, 601, 997], [999, 999, 1033, 1033, 1239], [1241, 1241, 1265, 1265, 1455], [1457, 1457, 1481, 1481, 1782], [1784, 1784, 1841, 1841, 2173]], "test": "valid"}
{"id": "wdlXDS", "name": "Tier Map 1", "author": "parameterized", "description": "tilemap generator", "tags": ["procedural", "2d"], "likes": 3, "viewed": 364, "published": "Public API", "date": "1552077776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float M_PI = 3.1415926535897932384626433832795;\n\nfloat rand(vec2 n)\n{\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n//(n1x, n1y, n2x, n2y) n=closest points\nvec4 voronoi(vec2 pos, float jitter)\n{\n\tvec2 posi = floor(pos);\n\tvec2 pos2 = vec2(0, 0);\n\tfloat dist = 0.0;\n\tvec2 n1 = vec2(0, 0);\n\tvec2 n2 = vec2(0, 0);\n\tfloat n1d = 9.0;\n\tfloat n2d = 9.0;\n\tfor (int i=-2; i < 2; i++) {\n\t\tfor (int j=-2; j < 2; j++) {\n\t\t\tpos2 = posi+vec2(i,j)+vec2(0.5)+(vec2(rand(posi+vec2(i,j)), rand(posi+vec2(i,j)+0.5))*2.0-1.0)*jitter*0.5;\n\t\t\tdist = dot(pos-pos2, pos-pos2);\n\t\t\tif (dist < n2d) {\n\t\t\t\tif (dist < n1d) {\n\t\t\t\t\tn2d = n1d;\n\t\t\t\t\tn1d = dist;\n\t\t\t\t\tn2 = n1;\n\t\t\t\t\tn1 = pos2;\n\t\t\t\t} else {\n\t\t\t\t\tn2d = dist;\n\t\t\t\t\tn2 = pos2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn vec4(n1, n2);\n}\n\nvec4 voronoi(vec2 pos)\n{\n\treturn voronoi(pos, 1.0);\n}\n\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n        dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\n// 1: water, 2: sand, 3: grass, 4: rock, 5: path, 6: floor, 7: wall, 8: platform\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord - iResolution.xy*0.5;\n    float scale = sin(iTime*0.5)*0.5 + 0.75;\n    uv += (iMouse.xy - iResolution.xy*0.5)/scale*(1.25 - scale);\n    uv.y = -uv.y;\n    uv *= scale;\n    vec2 p = floor(uv);\n\n    // grass/sand/water\n    int tileChoices[3] = int[](3, 2, 1);\n    float r1 = snoise(p/32.0)*0.5 + 0.5;\n    int choice = 0;\n    for (int i=0; i < 3; i++) {\n        if (r1 < float(i+1)/3.0) {\n            choice = tileChoices[i];\n            break;\n        }\n    }\n\t// rock\n    float r2 = snoise(1000.0 + p/64.0)*0.5 + 0.5;\n    if (r1 < 0.2 && r2 < 0.5) {\n        choice = 4;\n    }\n\n    // buildings\n    float freq = 64.0;\n    vec2 vp = p/freq;\n    vec4 vpts = voronoi(vp, 0.5);\n    vec2 vd = vec2(floor(abs(vp.x - vpts.x)*freq), floor(abs(vp.y - vpts.y)*freq));\n    // inside\n\t// floor\n    if (vd.x <= 4.0 && vd.y <= 6.0) {\n        choice = 6;\n    }\n\t// path\n    if (distance(vp, vpts.xy)*freq < 2.0) {\n        choice = 5;\n    }\n    // walls\n    if ((vd.x == 4.0 && vd.y <= 6.0 || vd.y == 6.0 && vd.x <= 4.0)\n    && vd.x > 1.0  && vd.y > 1.0) {\n        choice = 7;\n    }\n\n    // paths\n    float d = length(p);\n    float angle = atan(p.y, p.x);\n    angle += snoise(2000.0 + p/64.0)/d*4.0;\n    if (distance(mod(angle/(2.0*M_PI)*8.0, 1.0), 0.5) < 0.3/(d/8.0)) {\n        choice = 5;\n    }\n\n    // platform\n    if (length(p) < 8.0) {\n        choice = 8;\n    }\n    \n    vec3 tileColors[10] = vec3[](\n        vec3(0.0, 0.0, 0.0),\n    \tvec3(41.0, 137.0, 214.0),\n    \tvec3(251.0, 228.0, 125.0),\n    \tvec3(98.0, 195.0, 116.0),\n    \tvec3(98.0, 98.0, 98.0),\n    \tvec3(205.0, 140.0, 79.0),\n    \tvec3(183.0, 163.0, 43.0),\n    \tvec3(104.0, 88.0, 0.0),\n    \tvec3(73.0, 73.0, 73.0),\n    \tvec3(73.0, 73.0, 73.0)\n\t);\n\n    fragColor = vec4(tileColors[choice]/255.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlXDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 76, 76, 142], [144, 144, 174, 174, 258], [260, 300, 338, 338, 889], [891, 891, 915, 915, 944], [946, 946, 968, 968, 1007], [1009, 1009, 1031, 1031, 1900], [1903, 1985, 2040, 2040, 3811]], "test": "valid"}
{"id": "wdlXRf", "name": "317_Дарья_Петренко", "author": "daria_snz", "description": "Задание №1 курса по компьютерной графике.", "tags": ["raymarching"], "likes": 3, "viewed": 78, "published": "Public", "date": "1552045495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nconst int MAX_MARCHING_STEPS = 500;\nconst float EPS = 0.01;\nconst float MAX_DEPTH = 500.0;\n\nmat3\nrotateY(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat3(\n        vec3(c, 0., s),\n        vec3(0., 1., 0),\n        vec3(-s, 0., c)\n    );\n}\n\nmat3\nrotateX(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat3(\n        vec3(1., 0., 0),\n        vec3(0., c,  s),\n        vec3(0.,-s, c)\n    );\n}\n\nmat3\nrotateZ(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,  s, 0.),\n        vec3(-s, c, 0.),\n        vec3(0., 0., 1.)\n    );\n}\n\nstruct Sphere {\n    vec3 p;\n    float r;\n    vec3 a_col;\n    vec3 d_col;\n    vec3 s_col;\n    float shininess;\n};\n   \nstruct Box {\n    vec3 p;\n    float b;\n    vec3 a_col;\n    vec3 d_col;\n    vec3 s_col;\n    float shininess;\n};\n    \nstruct Plane {\n    vec4 norm;\n    vec3 a_col;\n    vec3 d_col;\n    vec3 s_col;\n    float shininess;\n};\n    \nstruct Torus {\n    vec3 p;\n    vec2 t;\n    vec3 a_col;\n    vec3 d_col;\n    vec3 s_col;\n    float shininess;\n};\n  \n// initialization of objects;\n    \nSphere sph_1 = Sphere(vec3(0.5, 3., 0.5), 0.5, vec3(0.05, 0.18, 0.45), vec3(0.2, 0.3, 0.7), vec3(1.0, 1.0, 1.0), 32.0);\nSphere sph_2 = Sphere(vec3(0.5, 3., 0.5), 0.5, vec3(0.05, 0.18, 0.45), vec3(0.2, 0.3, 0.7), vec3(1.0, 1.0, 1.0), 32.0);\nSphere sph_3 = Sphere(vec3(0.5, 3, 0.5), 1.5, vec3(0.4, 0.03, 0.1), vec3(0.9, 0.04, 0.23), vec3(1.0, 1.0, 1.0), 32.0);\n\nBox box_1 = Box(vec3(0.5, 3., 0.5), 1.2, vec3(0.4, 0.03, 0.1), vec3(0.9, 0.04, 0.23), vec3(1.0, 1.0, 1.0), 32.0);\nTorus torus_1 = Torus(vec3(0.5, 3., 0.5), vec2(2.1, 0.2), vec3(0.4, 0.4, 0.18), vec3(0.8, 0.9, 0.07), vec3(1.0, 1.0, 1.0), 20.0);\nPlane pl_1 = Plane(normalize(vec4(0., 1., 0., 1.)), vec3(0.2, 0.2, 0.2), vec3(0.5, 0.5, 0.45), vec3(1.0, 1.0, 1.0), 10.0);\nvec3 background_col = vec3(0.5, 0.5, 0.5);\n\nfloat \nintersection(float d1, float d2)\n{\n    return max(d1, d2);\n}\n    \nfloat \nsphere_dist_1(Sphere s, vec3 point) \n{\n    vec3 p = point - s.p - vec3(-3. * sin(iTime), 0., 3. * cos(iTime));\n\treturn length(p) - s.r;\n}\n\nfloat \nsphere_dist_2(Sphere s, vec3 point) \n{\n    vec3 p = point - s.p - vec3(0., 3. * sin(iTime), -3. * cos(iTime));\n\treturn length(p) - s.r;\n}\n\n\nfloat \nsphere_dist_3(Sphere s, vec3 point) \n{\n    vec3 p = point - s.p;\n\treturn length(p) - s.r;\n}\n\n  \nfloat box_dist(Box b, vec3 point)\n{\n  vec3 p = (point - b.p) * rotateZ(45.) * rotateY(45.) * rotateX(45.);\n  vec3 d = abs(p) - b.b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat\nplane_dist(Plane p, vec3 point) \n{\n  return dot(point, p.norm.xyz) + p.norm.w;\n}\n\nfloat \ntorus_dist(Torus tor, vec3 point)\n{\n  vec3 p = (point - tor.p) * rotateX(sin(iTime)) * rotateZ(cos(iTime));\n  vec2 q = vec2(length(p.xz)-tor.t.x,\n                p.y);\n  return length(q)-tor.t.y;\n}\n\n\nfloat\nget_dist(vec3 dot)\n{\n    float sph_dist_1 = sphere_dist_1(sph_1, dot);\n    float sph_dist_2 = sphere_dist_2(sph_2, dot);\n    float sph_dist_3 = sphere_dist_3(sph_3, dot);\n    float box_dist_1 = box_dist(box_1, dot);\n    float its = intersection(sph_dist_3,box_dist_1);\n    float pl_dist_1 = plane_dist(pl_1, dot); \n    float torus_dist_1 = torus_dist(torus_1, dot);\n    return min(torus_dist_1, min(pl_dist_1, min(sph_dist_1, min(sph_dist_2, its))));\n}\n\nvec3 \nestimate_normal(vec3 dot) \n{\n    float dx = get_dist(vec3(dot.x + EPS, dot.y, dot.z)) - \n        get_dist(vec3(dot.x - EPS, dot.y, dot.z));\n    float dy = get_dist(vec3(dot.x, dot.y + EPS, dot.z)) - \n        get_dist(vec3(dot.x, dot.y - EPS, dot.z));\n    float dz = get_dist(vec3(dot.x, dot.y, dot.z + EPS)) - \n        get_dist(vec3(dot.x, dot.y, dot.z - EPS));\n    return normalize(vec3(dx, dy, dz)); \n}\n                    \nstruct Ray{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Hit{\n    bool exist;\n    vec3 point;\n    vec3 a_col;\n    vec3 d_col;\n    vec3 s_col;\n    float shininess;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 intensity;\n};\n        \n\n// lights initialization\nLight lights[2] = Light[](Light(vec3(0., 7., 0.), vec3(30.0, 30., 30.)),\n                          Light(vec3(3., 2., 8.), vec3(30.0, 30., 30.)));\n    \nHit\nhit_info(vec3 dot) {\n    Hit rez;\n    if(intersection(box_dist(box_1, dot), \n                    sphere_dist_3(sph_3, dot)) < EPS) {\n        rez.a_col = box_1.a_col;\n        rez.d_col = box_1.d_col;\n        rez.s_col = box_1.s_col;\n        rez.shininess = box_1.shininess;\n        return rez;\n    } else if(torus_dist(torus_1, dot) < EPS) {\n        rez.a_col = torus_1.a_col;\n        rez.d_col = torus_1.d_col;\n        rez.s_col = torus_1.s_col;\n        rez.shininess = torus_1.shininess;\n        return rez;\n    } else if(sphere_dist_1(sph_1, dot) < EPS) {\n        rez.a_col = sph_1.a_col;\n        rez.d_col = sph_1.d_col;\n        rez.s_col = sph_1.s_col;\n        rez.shininess = sph_1.shininess;\n        return rez;\n    } else if(sphere_dist_2(sph_2, dot) < EPS) {\n        rez.a_col = sph_2.a_col;\n        rez.d_col = sph_2.d_col;\n        rez.s_col = sph_2.s_col;\n        rez.shininess = sph_2.shininess;\n        return rez;\n    } else if(plane_dist(pl_1, dot) < EPS) {\n        rez.a_col = pl_1.a_col;\n        rez.d_col = pl_1.d_col;\n        rez.s_col = pl_1.s_col;\n        rez.shininess = pl_1.shininess;\n        return rez;\n    }  \n}\n\n\nvec3 \nray_dir(float fov, vec2 size, vec2 pos) \n{\n\tvec2 xy = pos - size * 0.5;\n    float cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD);\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\treturn normalize( vec3( xy, -z ));\n}\n \n\nHit\nray_marching(Ray ray)\n{\n    Hit hit;\n    float depth = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++){\n        float dist = get_dist(ray.pos + depth * ray.dir);\n        if(dist < EPS){\n            hit = hit_info(ray.pos + depth * ray.dir);\n            hit.point = ray.pos + depth * ray.dir;\n            hit.exist = true;\n            return hit;\n        }\n        depth += abs(dist);\n        if(depth > MAX_DEPTH) {\n            hit.exist = false;\n    \t\treturn hit;\n        }\n    }\n    hit.exist = false;\n    return hit;\n}\n\nbool \nis_visible(Light light, vec3 point)\n{\n    vec3 dir = normalize(point - light.pos);\n    Ray ray = Ray(light.pos, dir);\n    Hit hit = ray_marching(ray);\n    if(distance(point, hit.point) < EPS * 1.5) {\n        return true;\n    } else {\n    \treturn false;\n    }\n}\n\n/*\ndiffuse_colour - diffuse colour\nspecular_colour - specular colour\nshininess - shininess coefficient\nhit - information about the hit\nray - ray from camera\nlight_pos - position of light\nlight_intensity - intensity of light\n*/\nvec3 \nPhong_light(Ray ray, Hit hit, Light light ) \n{\n    float att = distance(hit.point, light.pos);\n    att = 1. / (att * att);\n    vec3 N = estimate_normal(hit.point); \n    vec3 L = normalize(light.pos - N); \n    vec3 V = -ray.dir; \n    vec3 R = reflect(-L, N); \n    \n    float dotLN = dot(L, N); \n    float dotRV = dot(R, V); \n    vec3 colour = vec3(0.);\n    if (dotLN > 0.) { \n        colour += hit.d_col * dotLN * att;\n    }\n    if (dotRV > 0.) { \n        colour += hit.s_col * pow(dotRV, hit.shininess) * att;\n    }\n    colour *= light.intensity; \n    return colour;\n}\n  \n        \n\nvec3 \nray_trace(Ray ray)\n{\n    Hit hit = ray_marching(ray);\n    if(!hit.exist) {\n        return background_col;\n    }\n    vec3 colour = hit.a_col;\n    for(int i = 0; i < 2; i++) {\n        if(is_visible(lights[i], hit.point)) {\n            colour += Phong_light(ray, hit, lights[i]);\n        }\n    }\n    return colour;\n}\n \n\n      \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \tRay ray;\n   \tray.pos = vec3(1, 1, 15.);\n    ray.dir = ray_dir(45.0, iResolution.xy, fragCoord.xy);\n    \n    fragColor = vec4(ray_trace(ray),1.0);\n}\n    \t\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlXRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 189, 189, 341], [343, 343, 371, 371, 523], [525, 525, 553, 553, 706], [1161, 1967, 2008, 2008, 2034], [2040, 2040, 2085, 2085, 2184], [2186, 2186, 2231, 2231, 2330], [2333, 2333, 2378, 2378, 2431], [2436, 2436, 2471, 2471, 2631], [2633, 2633, 2673, 2673, 2719], [2721, 2721, 2763, 2763, 2925], [2928, 2928, 2954, 2954, 3386], [3388, 3388, 3422, 3422, 3798], [4047, 4224, 4248, 4248, 5365], [5368, 5368, 5416, 5416, 5590], [5594, 5594, 5621, 5621, 6125], [6127, 6127, 6170, 6170, 6393], [6395, 6622, 6674, 6674, 7196], [7210, 7210, 7236, 7236, 7529], [7540, 7540, 7595, 7595, 7747]], "test": "error"}
{"id": "wdlXz2", "name": "valley of the squares", "author": "elenzil", "description": "recreating a vague Amiga memory", "tags": ["checkerboard"], "likes": 3, "viewed": 321, "published": "Public API", "date": "1551721849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fn1(float v, float a) {\n    return v * 0.35 + (sin(v * 0.02f + iTime * a) * 15.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 xy )\n{\n    float tx = sin(iTime * 0.03) * 0.05 + 0.2;\n    float ty = cos(iTime * 0.03) * 0.05 + 0.2;\n    \n    float x = sin(fn1(xy.x, tx));\n    float y = sin(fn1(xy.y, ty));\n    float f = x * y;\n    \n    float q = 1.5;\n    \n    vec3 col1 = vec3(0.0);\n    vec3 col2 = vec3(1.0);\n    float b = smoothstep(-q, q, f / fwidth(f));\n    \n    vec3 col  = mix(col1, col2, b);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlXz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 90], [92, 92, 142, 142, 540]], "test": "valid"}
{"id": "WdlXzj", "name": "midterms7", "author": "jojo169", "description": "7", "tags": ["7"], "likes": 1, "viewed": 41, "published": "Public", "date": "1551698191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(1.,0.,0.);\nvec3 blue = vec3(0.,0.,1.);\nvec3 green = vec3(0,1.,0.);\nvec3 yellow = vec3(1.,1.,0.);\nvec3 black = vec3(0.,0.,0.);\nvec3 gray = vec3(.5,.5,.3);\n\nfloat circle(vec2 uv,float distanceAa, float distanceAb,float ditanceBa,float distanceBb,float size)\n{\n    \n    float val = distance(uv, vec2(distanceAa, distanceAb)) * distance(uv, vec2(ditanceBa, distanceBb));\n    \n\tval = step(val, size);\n    \n    return val;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos= vec2(.5*ratio,.5);\n    float dist = distance(shapePos,uv)*2.;\n    \n    uv -=shapePos;\n    float angle= atan(uv.y,uv.x);\n    float radius = cos(.2*angle);\n    radius = abs(sin(circle(uv,.5,.5,.5,.5,5.)+10.+iTime)*sin(angle*10.+iTime))*2.;\n    \n    float value = 1.-step(radius,dist);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 val = mix(col,green,value);\n\n    // Output to screen\n    fragColor = vec4(val,uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 273, 273, 434], [437, 437, 494, 544, 1146]], "test": "valid"}
{"id": "WdsSDH", "name": "Godel Escher Bach ", "author": "Danielhu", "description": "Godel Escher Bach ", "tags": ["sdf", "text", "csg", "font"], "likes": 18, "viewed": 834, "published": "Public API", "date": "1551521876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MARCH_STEP 64\n#define EPSILON 0.001\n\nfloat rect(vec2 c, vec2 hsize, vec2 p) {\n    return length(max(abs(p-c)-hsize,0.0));\n}\n\nfloat roundrect(vec2 c, vec2 hsize, vec2 p, float r) {\n    return rect(c, hsize - r, p) - r;\n}\n\nfloat circle(vec2 c, float r, vec2 p) {\n    return length((p - c)) - r;\n}\n\nfloat Sub(float a, float b) {\n    return max(a, -b);\n}\n\nfloat Uni(float a, float b) {\n    return min(a, b);\n}\n\n\nfloat ring(vec2 c, float r1, float r2, vec2 p) {\n    return Sub(circle(c, r1, p), circle(c, r2, p));\n}\n\nfloat rightring(vec2 c, float r1, float r2, vec2 p) {\n    return max(-p.x, Sub(circle(c, r1, p), circle(c, r2, p)));\n}\n\nfloat halfB(vec2 p) {\n    float ring = rightring(vec2(0.0), 0.175, 0.075, p - vec2(0.125, 0.0));\n    float c1 = rect(vec2(-0.05, 0.125), vec2(0.2 ,0.05), p);\n    float c2 = rect(vec2(-0.05, -0.125), vec2(0.2 ,0.05), p);\n    return min(min(ring, c1), c2);\n}\n\nfloat B(vec2 p) {\n    float h1 = halfB(p - vec2(0.0, 0.125));\n    float h2 = halfB(p + vec2(0.0, 0.125));\n    float c = rect(vec2(-0.25, 0.0), vec2(0.05, 0.3), p);\n    return min(min(h1, h2), c);\n}\n\nfloat E(vec2 p) {\n    float c1 = rect(vec2(0.0, 0.25), vec2(0.3, 0.05), p);\n    float c2 = rect(vec2(0.0), vec2(0.3, 0.05), p);\n    float c3 = rect(vec2(0.0, -0.25), vec2(0.3, 0.05), p);\n\tfloat r = rect(vec2(-0.25, 0.0), vec2(0.05, 0.3), p);\n   return Uni(Uni(c1, c2), Uni(c3, r));\n}\n\n\nfloat G(vec2 p) {\n    float c1 = roundrect(vec2(0.0, 0.25), vec2(0.3, 0.05), p, 0.02);\n    float c2 = roundrect(vec2(-0.25, 0.0), vec2(0.05, 0.3), p, 0.02);\n    float c3 = roundrect(vec2(0.0, -0.25), vec2(0.3, 0.05), p, 0.02);\n    float c4 = roundrect(vec2(0.25, -0.15), vec2(0.05, 0.15), p, 0.02);\n    float c5 = roundrect(vec2(0.15, 0.0), vec2(0.15, 0.05), p, 0.02);\n    return Uni(Uni(Uni(c1, c2), Uni(c3, c4)), c5);\n}\n\nfloat extrudeB(vec3 p) {\n    return B(p.xy);\n}\n\nfloat extrudeE(vec3 p) {\n    return E(p.xz);\n}\n\nfloat extrudeG(vec3 p) {\n    \n    //return -1.0;\n    return G(vec2(-p.z, p.y));\n}\n\n\nfloat plane(vec3 p, vec3 center, vec3 dir) {\n   return dot(p - center, dir);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat wall(vec3 p) {\n    float planeZ = plane(p, vec3(0.0, 0.0, -2.0), vec3(0.0, 0.0, 1.0));\n    float planeX = plane(p, vec3(-2.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0));\n    float planeY = plane(p, vec3(0.0, -1.0, 0.0), vec3(0.0, 1.0, 0.0));\n    return Uni(planeX, Uni(planeY, planeZ));\n}\n\nmat3 trans() {\n    return rotateY(radians(-45.0) + sin(iTime) * radians(45.0));\n}\n\nfloat obj(vec3 p) {\n    return max(extrudeE(p), max(extrudeG(p), extrudeB(p)));\n}\n\n\nfloat sdf(vec3 p) {\n    p = trans() * p;\n    return Uni(obj(p), wall(p));\n}\n\nvec3 central_diff(vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nbool march(vec3 eye, vec3 ray, out vec3 p) {\n    p = eye;\n    for (int i = 0; i < MARCH_STEP; ++i) {\n        float s = max(sdf(p), 0.0);\n        p += s * ray ;\n        if(abs(s) < 0.01) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool marchobj(vec3 eye, vec3 ray, out vec3 p) {\n    p = eye;\n    for (int i = 0; i < MARCH_STEP; ++i) {\n        float s = max(obj(trans() * p), 0.0);\n        p += s * ray ;\n        if(abs(s) < 0.01) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\nfloat shadowX(vec3 p) {\n    vec3 occ;\n    if(marchobj(p + vec3(1.0, 0.0, 0.0) * trans(), vec3(1, 0, 0) * trans(), occ))\n        return 0.1;\n    return 1.0;\n}\n\n\nfloat shadowY(vec3 p) {\n    vec3 occ;\n    if(marchobj(p + vec3(0.0, 1.0, 0.0)* trans(), vec3(0, 1, 0)* trans(), occ))\n        return 0.1;\n    return 1.0;\n}\n\nfloat shadowZ(vec3 p) {\n    vec3 occ;\n    if(marchobj(p + vec3(0.0, 0.0, 1.0) * trans(), vec3(0, 0, 1)* trans(), occ))\n        return 0.1;\n    return 1.0;\n}\n\n\nvec3 fill(float a, vec3 color) {\n    return step(a, 0.0) * color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc = (fragCoord - iResolution.xy / 2.0) / iResolution.yy * 2.0;\n    vec3 p;\n    vec3 ray = normalize(vec3(ndc, -3.0));\n    if(!march(vec3(0, 0, 4), ray, p)) {\n        fragColor.rgb = vec3(0.0);\n        return;\n    }\n    vec3 lightDir =  normalize(vec3(10.0, 10.0, 10.0) - p) * trans();\n    vec3 nor = central_diff(p);\n    vec3 hal = normalize(nor + lightDir);\n    vec3 dif = dot(lightDir, nor) * vec3(1.0, 1.0, 0.8);\n    fragColor.rgb = dif * shadowX(p) * shadowY(p) * shadowZ(p) + vec3(0.05);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsSDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 85, 85, 131], [133, 133, 187, 187, 227], [229, 229, 268, 268, 302], [304, 304, 333, 333, 358], [360, 360, 389, 389, 413], [416, 416, 464, 464, 518], [520, 520, 573, 573, 638], [640, 640, 661, 661, 896], [898, 898, 915, 915, 1095], [1097, 1097, 1114, 1114, 1380], [1383, 1383, 1400, 1400, 1804], [1806, 1806, 1830, 1830, 1852], [1854, 1854, 1878, 1878, 1900], [1902, 1902, 1926, 1950, 1983], [1986, 1986, 2030, 2030, 2064], [2066, 2066, 2093, 2093, 2240], [2242, 2242, 2269, 2269, 2416], [2418, 2418, 2445, 2445, 2592], [2594, 2594, 2614, 2614, 2877], [2879, 2879, 2893, 2893, 2960], [2962, 2962, 2981, 2981, 3043], [3046, 3046, 3065, 3065, 3121], [3123, 3123, 3150, 3150, 3430], [3433, 3433, 3477, 3477, 3681], [3683, 3683, 3730, 3730, 3944], [3947, 3947, 3970, 3970, 4104], [4107, 4107, 4130, 4130, 4262], [4264, 4264, 4287, 4287, 4420], [4423, 4423, 4455, 4455, 4490], [4495, 4495, 4552, 4552, 5058]], "test": "valid"}
{"id": "wdsSDj", "name": "Fractal Experiment 29 : NDP Test", "author": "aiekick", "description": "the uniforms widgets are inserted between tags @UNIFORMS_START and @UNIFORMS_ELSE\nthe replaces vars are between tags @UNIFORMS_ELSE and @UNIFORMS_END\nsee demo in this video : [url=https://twitter.com/aiekick/status/1104900482236104705]video[/url]", "tags": ["fractal", "experiment", "29"], "likes": 6, "viewed": 334, "published": "Public API", "date": "1552251003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2019 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via NoodlesPlate\n\n//@NOTE_START\n//Test to integrate the uniforms widget in NoodlesPlate after import\n//the uniforms widgets are inserted between tags @UNIFORMS_START and @UNIFORMS_ELSE\n//the replaces vars are between tags @UNIFORMS_ELSE and @UNIFORMS_END\n//see demo in this video : https://twitter.com/aiekick/status/1104900482236104705\n//@NOTE_END\n                          \n//@UNIFORMS_START\n//uniform vec2(0.0:1.0:0.924,0.) \t_c; fractal params\n//uniform int(0:200:100) \t\t\t_niter; fractal iterations\n//uniform float(0.0:1.0:0.25912) \t_k; zmul coef\n//uniform float(0.0:5.0:2.2) \t\t_scale; scale\n//uniform float(0.0:.5:0.03) \t\t_limit; moving limit\n//uniform float(0.0:100.0:8.) \t\t_dist; fractal distance\n//uniform vec3(color:1,0,1) \t\t_color; color\n//uniform vec2(0:5:1,1.5) \t\t\t_colorVar; color mix variation\n//@UNIFORMS_ELSE\n#define _c vec2(0.9240,0)\n#define _niter 100\n#define _k 0.25912\n#define _scale 2.2\n#define _limit 0.03\n#define _dist 8.\n#define _color vec3(1,0,1)\n#define _colorVar vec2(1,1.5)\n//@UNIFORMS_END\n\nvec2 zmul(vec2 a, vec2 b){return mat2(a,-a.y,a.x)*b;} // z * z \nvec2 zinv(vec2 a){return vec2(a.x, -a.y) / dot(a,a);} // 1 / z\n\nconst float AA = 2.;\n    \nfloat shape(vec2 z)\n{\n\t//return max(abs(z.x), abs(z.y)) * 0.8 + dot(z,z) * 0.2;\n\t//return max(abs(z.x)-z.y,z.y);\n\treturn dot(z,z);\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    f = vec4(0);\n    \n\tvec2 si = iResolution.xy;\n        \n    for( float m=0.; m<AA; m++ )\n    for( float n=0.; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n) / AA - .5;\n        vec2 uv = ((g+o)*2.-si)/min(si.x,si.y) * _scale;\n        vec2 z = uv, zz;\n        vec2 c = _c;\n\t\tc.y += sin(iTime) * _limit;\n        float it = 0.;\n        for (int i=0;i<_niter;i++)\n        {\n\t\t\tzz = z;\n            z = zinv( _k * zmul(z, z) - c);\n\t\t\tif( shape(z) > _dist ) break;\n            it++;\n        }\n\n\t\tvec4 sec = _colorVar.x + it * _colorVar.y + vec4(_color,1);\n\t\t\n\t\tf += .5 + .5 * sin(sec - shape(zz) / shape(z));\n    }\n    \n    f /= AA * AA;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsSDj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1166, 1183, 1209, 1209, 1236], [1237, 1247, 1265, 1265, 1300], [1301, 1337, 1358, 1449, 1469], [1471, 1471, 1512, 1512, 2144]], "test": "valid"}
{"id": "WdsSDM", "name": "WKWKWKW", "author": "winstonrenatan", "description": "kebanyakakn becanda", "tags": ["shapesquare"], "likes": 1, "viewed": 60, "published": "Public", "date": "1551416452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n \nvec3 ambientColor = vec3(1.9, 0.35, 0.5);\nvec3 diffuseColor = vec3(0.95, 0.25, 0.9);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n\n//Make Polygon\nfloat polygon(vec2 uv, vec2 pos, float size, float blur, int sides){\n    uv = uv-pos;\n    //Angle and radius of polygon\n    float angle = atan(uv.x,uv.y)+PI;\n    float rad = TWO_PI/float(sides);\n    float dist = cos(floor(0.5+angle/rad)*rad-angle)*length(uv);\n    float poly = smoothstep(size, size-blur, dist);\n    \n    return poly;\n}\n\nfloat boxSDF( vec3 p, vec3 b ) {\n    return length(max(abs(p)-b,0.0));\n}\n\nfloat sceneSDF(vec3 p) {\n    return boxSDF(p, vec3(0.5));\n}\n\n//Move Rectangle Function\nvec4 moveRectangle(vec4 try,vec2 uv){\n    vec2 translate = vec2(cos(iTime),sin(iTime));\n    uv += translate*0.35;\n    float rectangle = polygon(uv, vec2(0.0,0.0), 0.1, 0.001, 4);\n    \n    vec3 giveColor = vec3(1.0,1.0,0.0) * rectangle;\n    try = vec4(giveColor,1.0);\n    \n    return try;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec3 eye = vec3(0.0, 1.0, 2.0);\n    vec2 rot = 6.2831 * (vec2(0.1 + iTime * 0.25, 0.0) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.0, 0.2, 1.0);\n\t\n    //Phong Model\n    vec3 cw = normalize(ta - eye);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.5));\n    vec3 color;\n    float tmin = 0.1;\n    float tmax = 50.0;\n    \n    //Move Object\n    vec2 translate = vec2(cos(iTime),sin(iTime));\n    p += translate*0.35;\n    float rectangle = polygon(p, vec2(0.0,0.0), 0.5, 0.001, 4);\n    \n    float t = rectangle;\n    if (t > tmin && t < tmax) {\n        vec3 pos = ro + rd * t;\n        vec3 norm = normalize(pos - spherePos);\n        float occ = 0.5 + 0.5 * norm.y;\n\n        float amb = clamp(0.5 + 0.5 * norm.y, 0.0, 1.0);\n        float dif = clamp(dot(lightDir, norm), 0.0, 1.0);\n        vec3 h = normalize(-rd + lightDir);\n        float spe = pow(clamp(dot(h, norm), 0.0, 1.0), 64.0);\n\n        color = amb * ambientColor * occ;\n        color += dif * diffuseColor * occ;\n        color += dif * spe * specularColor * occ;\n    }\n\n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor += vec4(pow(color, gamma), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsSDM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[357, 372, 440, 440, 707], [709, 709, 741, 741, 781], [783, 783, 807, 807, 842], [844, 870, 907, 907, 1162], [1164, 1164, 1221, 1221, 2744]], "test": "valid"}
{"id": "WdsSRf", "name": "Dithered cube", "author": "mensab", "description": "Quick dithering test", "tags": ["raymarching", "pixel", "effect", "dithering", "aliased"], "likes": 5, "viewed": 134, "published": "Public", "date": "1551788069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MIN_DIST .2\n#define MAX_DIST 20.\n#define MAX_MARCHING_STEPS 100\n#define EPS .001\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat scene(vec3 p) {\n    //  rotate + bob around\n    float t = iTime;\n    p += vec3(cos(2. * t), sin(.5 * t), sin(t));\n    float theta = .9 * t;\n    mat4 rot = mat4(cos(theta), 0., sin(theta), 0.,\n                    0., 1., 0., 0.,\n                    -sin(theta), 0., cos(theta), 0.,\n                    0., 0., 0., 1.);\n    p = vec3(rot * vec4(p, 0.));\n    \n    return box(p, vec3(.5));\n}\n\n//  simple raymarcher\nfloat raymarch(vec3 cam_pos, vec3 march_dir) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(cam_pos + depth * march_dir);\n        if (dist < EPS) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 cam_dir(float fov, vec2 uv) {\n    vec2 xy = (uv * iResolution.xy) - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 normal(vec3 p) {\n    vec2 eps = vec2(EPS, 0.);\n    return normalize(vec3(scene(p + eps.xyy) - scene(p - eps.xyy),\n                          scene(p + eps.yxy) - scene(p - eps.yxy),\n                          scene(p + eps.yyx) - scene(p - eps.yyx)));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 pos = vec3(0., 0., 3.);\n    \n    //  border\n    vec2 px_dist = uv / iResolution.xy;\n\n    vec3 dir = cam_dir(90., uv);\n    float dist = raymarch(pos, dir);\n    \n    float acc = 0.;\n    float sc = 4.;\n    for (float i = 0.; i < 6.28318530; i += 6.28318530 / sc) {\n        vec2 off = vec2(cos(i), sin(i));\n    \tvec3 dir_d = cam_dir(90., uv + px_dist * off);\n    \tfloat dist_d = raymarch(pos, dir_d);\n        acc += abs(dist - dist_d);\n    }\n    \n    float v_d = ceil(acc / (sc * MAX_DIST) - 0.1);\n    \n    //  light\n    float d_n = 1. - (dist / MAX_DIST);\n    vec3 n = normal(pos + dir * dist);\n    vec3 ld = vec3(cos(iTime), sin(0.3 * iTime), sin(iTime));\n    float v = dot(n, ld) * ceil(d_n);\n    \n    //  dither\n    vec2 uvi0 = fragCoord / iChannelResolution[0].xy;\n    float b = texture(iChannel0, uvi0).r;\n\n    fragColor = vec4(1. - step(v, b) + v_d);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsSRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 117, 117, 206], [208, 208, 229, 257, 600], [602, 624, 670, 670, 992], [994, 994, 1028, 1028, 1181], [1183, 1183, 1204, 1204, 1439], [1442, 1442, 1496, 1496, 2408]], "test": "error"}
{"id": "wdsSRj", "name": "Shader7 - Mixed of Gears", "author": "EmperorLem", "description": "Different Gears in one simple design", "tags": ["gears"], "likes": 4, "viewed": 78, "published": "Public", "date": "1551710396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 brown = vec3(0.3,0.2,0.2);\nvec3 black = vec3(0.0,0.0,0.0);\nvec3 red = vec3(0.7,0.0,0.0);\nvec3 blue = vec3(0.,1.,1.);\nvec3 yellow = vec3(1.0,1.0,0.0);\nvec3 green = vec3(0.1,0.9,0.0);\nvec3 white = vec3(1.0,1.0,1.0);\n\nfloat blades(vec2 uv, vec2 pos, float r, float minPoint, float maxPoint, float val, float edgeCnt, float speed)\n{   \n    uv.x *= iResolution.x/iResolution.y;\n    float dist = distance(pos, uv) * r;\n    float value = step(r, dist);\n    \n    uv -= pos;\n\n    float angle = (atan(uv.y, uv.x) + ( val * iTime) * speed);\n    \n    float radius = smoothstep(minPoint, maxPoint, cos(angle * edgeCnt)) * 0.2 + 0.5;\n    \n    value = step(radius , dist);\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float mBlades = blades(uv, vec2(0.9,0.45), 7.0, -0.1, 2.0, 1.0, 3.0, 0.5);\n    mBlades -= blades(uv, vec2(0.9,0.45), 5.5, -0.1, 2.0, -1.0, 10.0, 2.0);\n    mBlades += blades(uv, vec2(0.9,0.45), 3.5, 0.5, 1.0, 1.0, 20.0, 25.0);\n    mBlades -= blades(uv, vec2(0.9,0.45), 2.3, 1.0, 0.9, -1.0, 2.0, 0.1);\n    mBlades += blades(uv, vec2(0.9,0.45), 1.9, 1., 0.9, 1.0, 5.0, 1.0);\n    mBlades -= blades(uv, vec2(0.9,0.45), 1.5, 1., 0.9, 1.0, 10.0, 1.0);\n\n    // Output to screen\n    fragColor = vec4(vec3(mBlades),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 333, 333, 687], [689, 689, 746, 796, 1354]], "test": "valid"}
{"id": "wdsSWs", "name": "Cube Singularity", "author": "dracusa", "description": "It's very dense, there's an infinity of cubes in a single point.", "tags": ["raymarching", "sdf", "spiral", "recursive", "polar", "zoomer", "logpolar", "loopless"], "likes": 34, "viewed": 996, "published": "Public API", "date": "1552592526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nLog-polar tiled cubes. The log-polar mapping is applied to the xz coordinates of\nthe 3D SDF. The remaining dimension is shrunk by a factor of length(xz). In this\nway, the mapping becomes uniform and the SDF distortion is greatly reduced.\n*/\n\n#define AA 2\n#define HEIGHT 0.25\n#define M_PI 3.1415926535897932384626433832795\n#define LONGSTEP (M_PI*4.)\n\nfloat gTime;\n\n/* \nThe tiling switches between 3 different densities at regular time points. These\nswitches are not instant, but propagate like a shockwave from the origin. So at\nany given time during the transitions, there are two different densities, and a\nboundary position between the two. These are stored in globals, set in main()\nand consumed in the sdf: \n*/\nfloat gABPos;\nfloat gDensA;\nfloat gDensB;\n\n// Modified from http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCube( vec3 p, float b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Axis rotation taken from tdhooper. R(p.xz, a) rotates \"x towards z\".\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// spiked surface distance (h >= 0)\n// https://www.shadertoy.com/view/3ssSR7\nfloat sdSpike2D(vec2 p, float h)\n{\n\tfloat d = p.y - (h*0.1)/(abs(p.x)+0.1);\n\td = min(d, length(p - vec2(0, min(h, p.y))));\n\tfloat d2 = abs(p.x) - ((h*0.1)-0.1*p.y)/p.y;\n\tif (p.y<h && d>0.0)\n\t\td = min(d, d2);\n\treturn d;\n}\n\n/*\nTile space in a spiked log-polar grid.\n\n- in `pin`: point with length(pin.xz) precomputed in pin.w\n- out `density`: density of tiling\n- out `cubsz`: size of cube\n- returns: tiled point coordinates\n*/\nvec3 tile(in vec4 pin, out float density, out float cubsz)\n{\n\tfloat r = pin.w;\n\t// switch densities in shockwaves\n\tdensity = mix(gDensA, gDensB, smoothstep(0., 0.1, r-gABPos));\n\t// log-polar transformation in xz; spike and proportional shrink in y\n\tvec3 p = vec3(\n\t\tlog(r), \n\t\t(pin.y-HEIGHT*0.1/(r+0.1))/r, \n\t\tatan(pin.z, pin.x)\n\t);\n\t// scaling in the log-polar domain creates density\n\tp *= density;\n\t// rho-translation causes zooming\n\tp.x -= gTime*2.0;\n\t// make it a spiral by rotating the tiled plane\n\tpR(p.xz, 0.6435); // atan(3/4)\n\t// convert to single-tile coordinates\n\tp.xz = mod(p.xz, 2.0) - 1.0;\n\t// scale and rotate the individual cubes\n\t// using an oscillation that spreads from the center over time\n\tfloat osc = sin(sqrt(r)-gTime*0.25-1.0);\n\tfloat cubrot = smoothstep(0.5, 0.8, osc);\n\tcubsz = sin(p.x*0.1)*0.29 + 0.5;\n\tcubsz = mix(cubsz, 0.96, smoothstep(0.7, 1.0, abs(osc)));\n\tpR(p.xy, cubrot);\n\treturn p;\n}\n\nfloat sdf(in vec3 pin)\n{\n\t// tile the coordinates and get cube distance\n\tfloat r = length(pin.xz);\n\tfloat cubsz, density; // out\n\tvec3 tiled = tile(vec4(pin, r), density, cubsz);\n\tfloat ret = sdCube(tiled, cubsz);\n\t// adjust the distance based on how much scaling occured\n\tret *= r/density;\n\n\t// avoid overstepping:\n\t// add hidden surface to bring rays into the right tiles\n\tfloat pkofs = r * cubsz / density;\n\tfloat pk = sdSpike2D(vec2(r, pin.y), HEIGHT) - pkofs;\n\tif (pk < 0.002) pk = ret;\n\tret = min(ret, pk);\n\t// shorten steps near the peak\n\tfloat shorten = length(pin - vec3(0., 0.25, 0.));\n\tshorten = 1. + 1.5*(1.-smoothstep(0., 0.22, shorten));\n\tret /= shorten;\n\n\treturn ret;\n}\n\n// Color the faces of cubes, reusing the tiling function.\nvec3 colr(in vec3 pin)\n{\n\tfloat a = 0.26;\n\tfloat b = 0.65;\n\tfloat z = 0.19;\n\tfloat cubsz, density; // out\n\tvec3 p = tile(vec4(pin, length(pin.xz)), density, cubsz);\n\tif (p.x > abs(p.y) && p.x > abs(p.z)) return vec3(z,a,b);\n\tif (p.x < -abs(p.y) && p.x < -abs(p.z)) return vec3(z,b,a)*0.7;\n\tif (p.z > abs(p.x) && p.z > abs(p.y)) return vec3(z,a,a);\n\tif (p.z < -abs(p.x) && p.z < -abs(p.y)) return vec3(b*0.5,z,a);\n\treturn vec3(b,b,a);\n}\n\n// Adapted from http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(in vec3 pos)\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773;\n\tconst float eps = 0.0005;\n\treturn normalize(\n\t\te.xyy*sdf(pos + e.xyy*eps) + \n\t\te.yyx*sdf(pos + e.yyx*eps) + \n\t\te.yxy*sdf(pos + e.yxy*eps) + \n\t\te.xxx*sdf(pos + e.xxx*eps)\n\t);\n}\n\nfloat time2density(float x)\n{\n\tfloat fullMod = fract(x/(LONGSTEP*3.))*3.;\n\tif (fullMod > 2.) return 45.;\n\telse if (fullMod > 1.) return 25.;\n\telse return 15.;\n}\n\n// Based on http://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\t// automate the shockwave transitions between densities\n\tgTime = iTime+1.8;\n\tfloat ltime = gTime + M_PI*6.3;\n\tgABPos = smoothstep(0.45, 0.6, fract(ltime/LONGSTEP))*2.2-0.2;\n\tgDensA = floor(time2density(ltime))/M_PI;\n\tgDensB = floor(time2density(ltime-LONGSTEP))/M_PI;\n\n\t // camera movement\t\n\tfloat camera_y = pow(sin(gTime*0.2), 3.)*0.2+0.7;\n\tvec3 ro = vec3(0., camera_y, 1.);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\t// camera matrix\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\n\tvec3 tot = vec3(0.0);\n\t\n\t#if AA>1\n\tfor(int m=0; m<AA; m++)\n\tfor(int n=0; n<AA; n++)\n\t{\n\t\t// pixel coordinates\n\t\tvec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n\t\tvec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\t#else    \n\t\tvec2 p = (-iRes.xy + 2.0*fragCoord)/iRes.y;\n\t\t#endif\n\n\t\t// create view ray\n\t\tvec3 rd = normalize(p.x*uu + p.y*vv + 3.5*ww); // fov\n\n\t\t// raymarch\n\t\tconst float tmax = 3.0;\n\t\tfloat t = 0.0;\n\t\tfor(int i=0; i<256; i++)\n\t\t{\n\t\t\tvec3 pos = ro + t*rd;\n\t\t\tfloat h = sdf(pos);\n\t\t\tif( h<0.0001 || t>tmax ) break;\n\t\t\tt += h;\n\t\t}\n\t\n\t\t// shading/lighting\t\n\t\tvec3 bg = vec3(0.1, 0.15, 0.2)*0.3;\n\t\tvec3 col = bg;\n\t\tif(t<tmax)\n\t\t{\n\t\t\tvec3 pos = ro + t*rd;\n\t\t\tvec3 nor = calcNormal(pos);\n\t\t\tfloat dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n\t\t\tfloat amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n\t\t\tcol = colr(pos)*amb + colr(pos)*dif;\n\t\t}\n\t\t// fog\n\t\tcol = mix(col, bg, smoothstep(2., 3., t));\n\n\t\t// gamma        \n\t\tcol = sqrt(col);\n\t\ttot += col;\n\t#if AA>1\n\t}\n\ttot /= float(AA*AA);\n\t#endif\n\n    // Output to screen\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[761, 849, 882, 882, 967], [969, 1041, 1073, 1073, 1115], [1117, 1194, 1228, 1228, 1414], [1416, 1619, 1679, 1679, 2538], [2540, 2540, 2564, 2611, 3224], [3226, 3284, 3308, 3308, 3719], [3721, 3798, 3828, 3828, 4038], [4040, 4040, 4069, 4069, 4200], [4202, 4281, 4338, 4388, 6053]], "test": "valid"}
{"id": "wdSXDm", "name": "Audio Architecture", "author": "yasuo", "description": "Try to make it look like Audio Architecture...\nhttps://www.youtube.com/watch?v=RvNpY-gF_LE", "tags": ["audioarchitecture"], "likes": 2, "viewed": 292, "published": "Public API", "date": "1554019922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec4 map(vec3 p){\n    vec3 pref = p;\n    \n    float speed = 5.0;\n    pref.y += sin((iTime*speed)+pref.x*10.0)*0.2;\n    \n    float d = sdBox((pref+vec3(0.0,0.0,-1.2)),vec3(0.5,0.02,0.05));\n    float d2 = sdBox((pref+vec3(0.0,0.0,-1.0)),vec3(0.5,0.02,0.05));\n    float d3 = sdBox((pref+vec3(0.0,0.0,-1.4)),vec3(0.5,0.02,0.05));\n    float d4 = sdBox((pref+vec3(0.0,0.0,-1.6)),vec3(0.5,0.02,0.05));\n    pref = p;\n    \n    float resD = min(min(min(d,d2),d3),d4);\n    \n    float size = 0.7;\n    float thickness = 0.005;\n    float barD = sdBox((pref+vec3(0.0,-size,-0.8)),vec3(size,thickness,thickness));\n    float barD2 = sdBox((pref+vec3(0.0,size,-0.8)),vec3(size,thickness,thickness));\n    float barD3 = sdBox((pref+vec3(size,0.0,-0.8)),vec3(thickness,size,thickness));\n    float barD4 = sdBox((pref+vec3(-size,0.0,-0.8)),vec3(thickness,size,thickness));\n    \n    float barD5 = sdBox((pref+vec3(0.0,-size,-0.8-size)),vec3(size,thickness,thickness));\n    float barD6 = sdBox((pref+vec3(0.0,size,-0.8-size)),vec3(size,thickness,thickness));\n    float barD7 = sdBox((pref+vec3(size,0.0,-0.8-size)),vec3(thickness,size,thickness));\n    float barD8 = sdBox((pref+vec3(-size,0.0,-0.8-size)),vec3(thickness,size,thickness));\n    \n    float barD9 = sdBox((pref+vec3(-size,-size,-0.8-(size*0.5))),vec3(thickness,thickness,size*0.5));\n    float barD10 = sdBox((pref+vec3(-size,size,-0.8-(size*0.5))),vec3(thickness,thickness,size*0.5));\n    float barD11 = sdBox((pref+vec3(size,-size,-0.8-(size*0.5))),vec3(thickness,thickness,size*0.5));\n    float barD12 = sdBox((pref+vec3(size,size,-0.8-(size*0.5))),vec3(thickness,thickness,size*0.5));\n    \n    float resBarD = min(min(min(min(min(min(min(barD,barD2),barD3),barD4),barD5),barD6),barD7),barD8);\n    float resBarD2 = min(min(min(min(resBarD,barD9),barD10),barD11),barD12);\n    \n    return vec4(vec3(0.5),min(resD,resBarD2));\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    mat3 camRotY = matRotateY(radians(sin(iTime)*3.0));\n    \n\tvec3 ro=vec3(0.,0.0,0.0);\n    vec3 rd=normalize(vec3(p,1.0));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 30; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>13.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t)*camRotY;\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 13.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n        vec3 V = distPos;\n        vec3 L = normalize(lightDir-V);\n        \n        vec3 E = normalize(-V);\n        vec3 R = normalize(-reflect(L, normal));\n        \n\t\t// difuse color\n        float diffuseVal = 2.7;\n        float diffuse = diffuseVal * max(dot(normal, L), 0.0);\n        diffuse = clamp(diffuse, 0.0, 1.0);\n        \n\t\tfloat specVal = 0.9;\n\t\tfloat shininess = 10.0;\n\t\tfloat spec = specVal * pow(max(dot(R, E), 0.0), 0.3*shininess);\n        spec = clamp(spec, 0.0, 1.0);\n\t\t\t\t\n        float AmbientVal = 1.5;\n        vec3 AmbientColor = vec3(0.5);\n        vec3 DiffuseColor = vec3(0.3,0.3,0.3);\n        vec3 SpecularColor = vec3(0.9);\n\t\tvec3 ambient = AmbientVal * AmbientColor;        \n        \n\t\tfloat lambert = max(.0, dot( normal, light));\n\n\t\t// result\n\t\tcolor = (distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        color *= ambient +(DiffuseColor * diffuse)+ (SpecularColor*spec);\n\t}else{\n        color =.84*max(mix(vec3(1.5,1.51,1.55)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n    \n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = color*brightness;\n\tfragColor = vec4(dst, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 289, 289, 385], [387, 387, 404, 404, 2251], [2253, 2253, 2276, 2276, 2526], [2528, 2528, 2584, 2584, 4342]], "test": "valid"}
{"id": "wdSXDz", "name": "circle Line", "author": "superzhan", "description": "demo circle", "tags": ["demo"], "likes": 1, "viewed": 71, "published": "Public", "date": "1553609872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float len=1000.0;\n    \n    bool isInCircle=false;\n    for(float i=0.0;i<5.0;++i){\n        float t = i *0.15+0.2;\n        vec2 centerPos = t* iResolution.xy;\n        float x= fragCoord.x - centerPos.x;\n        float y= fragCoord.y - centerPos.y;\n        if(x*x + y*y <=len){\n          fragColor = vec4(sin(iTime*t),cos(iTime*t),1,0);\n          isInCircle=true;\n          break;\n        }\n    }\n    \n    if(!isInCircle){\n       fragColor=vec4(1,1,1,0);\n    }\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 531]], "test": "valid"}
{"id": "WdsXRf", "name": "Too much color", "author": "rcargou", "description": "thanks IQ for the palette function and the normal function !", "tags": ["color"], "likes": 4, "viewed": 563, "published": "Public API", "date": "1551790488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 2\n\nfloat rand31(vec3 uv) {\n    return fract(sin(dot(uv, vec3(35.9898, 10.0, 56.0f))) * 43758.5453);\n}\n\nfloat weirdDist(vec3 p, float id) {\n    \n    vec3 t = p;\n    p = abs(p);\n    float boxDist = max(p.x, max(p.y, p.z))-.2f;\n    float sDist =    length(t) - .2f;\n    return mix(boxDist,sDist, (.5f + sin(iTime + id * 12.0f)/2.0f) * 3.0f);\n   \n\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 material(float id, out float spec) {\n    \n    vec3 col = palette( id, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    \n    spec = id;\n    return  col;\n}\n\nfloat map(vec3 p, out int matid) {\n    p.z -= 1.0f;\n    float a = abs(-(p.y)+ 3.0f);\n    float oui = abs((p.y)+ 3.0f);\n    float c = abs((p.x)+ 5.0f);\n    float d = abs((-p.x +5.0f));\n    float aa = iTime/5.0f;\n    \n    p.xy *= mat2(cos(aa), sin(aa), -sin(aa), cos(aa));\n    p.y +=.1f;\n  \t p.z += iTime*.5f;\n    \n    float id = rand31(floor(p));\n   // p.x += sin(iTime) * id;\n    p = mod(p, 1.0f) - vec3(.5f);\n    float b =  weirdDist(p, id);\n  \n    float ki = min(a, min(b, min(d, c)));\n    matid = 1;\n     \n    //if (d == ki)\n    \tmatid = int(id * 255.0);\n  \n    return ki;\n}\n\nvec3 normal (in vec3 p)\n{\n    int u;\n    vec2 e = vec2(.0001, .0);\n    float d = map (p, u);\n    vec3 n = vec3 (map (p + e.xyy,u) - d,\n                   map (p + e.yxy,u) - d,\n                   map (p + e.yyx,u) - d);\n    return normalize(n);\n}\n\nfloat rand21(vec2 uv) {\n    return fract(sin(dot(uv, vec2(35.9898, 10.0))) * 43758.5453);\n}\n\n\nvec3 raymarch(vec3 ro, vec3 rd, float dither, out int mask, out int mat) {\n      float t = 1000.0;\n    int u;\n    vec3 p = ro;\n    for (int i = 0; i <128; ++i) {\n        t = map(p, u);\n        if (abs(t) < .0001f){ mask = 1;  break ; }\n     \tp += rd * t * dither;    \n    }\n    \n    mat = u;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n       \n    vec3 fcol  = vec3(.0f);\n    for (int i = 0; i < AA; ++i) {\n        for (int j = 0; j < AA; ++j) {\n            \n\tvec2 off = vec2((.001f/float(AA)) * float(i), (.001f/float(AA))  * float(j));\n    vec2 uv = (2.0f * fragCoord - iResolution.xy)/iResolution.y;\n            uv *= 2.0f;\n            uv += off;\n\tfloat dither = .5f + .5f * rand21(uv);\n    // Time varying pixel color\n \nvec3 col = vec3(.0f);\n    vec3 ro = vec3(.0f, 0.0f, .0f);\n    \n    vec3 rd = normalize(vec3(uv.xy, 2.5f));\n       int mat = 0;\n    int refMat = 0;\n        int mask = 0;\nvec3 p = raymarch(ro,rd, dither, mask, mat);\n    vec3 grassCol = vec3(1.0f);\n    vec3 pg = ro;\n    float d = 1.0f;\n\n \n    vec3 lig = vec3(10.0f*cos(iTime*1.0f), 10.0f, -10.0f);\n    vec3 ldir = normalize(lig-p);\n    vec3 lcol = vec3(1.0f);//vec3(.5f, .2f, .8f);\n    vec3 albedo = vec3(1.0f, 1.0f, .2f);\n    vec3 back = vec3(.1f, .1f, .25f) + lcol * max(-0.0f, dot(normalize(rd), normalize(-lig - ro)))/4.0f;\n    vec3 amb = vec3(.0f, .3f, .2f);\n    float ao = 1.0f;\n    float fog = clamp(.0f, 1.0, pow(length(p) / 10.0f, 10.0f));\n  \n    vec3 trans = back;\n    col = back;\n    vec3 nor = normal(p);\n    \n    for (int i = 0; i < 12; ++i) {\n        d /= 2.0f;\n       //col += grass(uv * d);\n    }\n float spec;\n    if (mask == 1) {\n        albedo = material(float(mat) / 255.0f, spec);\n    \t//col.x = 1.0f / length(p);\n        col = albedo * lcol * max(0.0, dot(ldir, nor)) + amb * ao;\n        \n        col += lcol * pow(max(.0, dot(reflect(rd, nor), ldir)), (.1f + spec) / .1);\n  \t\tcol = mix(col, back, fog);\n        mask = 0;\n        \n        vec3 refPos =raymarch(p + nor * .2f , reflect(rd, nor), dither, mask, refMat);\n        float fogRef = clamp(.0f, 1.0, pow(length(refPos - p) / 5.0f, 100.0f));\n    //    col = albedo;\n        if (mask == 1)\n            col += col * mix(lcol * max(.0f, dot(normal(refPos), normalize(lig - refPos)) ) * .7f * material(float(refMat) / 255.0f, spec)\n                       + .5f * pow(max(.0, dot(reflect(reflect(rd, nor), normal(refPos)), ldir)), (.1f + spec) / .1)\n                       , back,  fogRef);\n            ;\n \n    }\n            \n            \n          //  col.yz =vec2(.0f);\n           // col.x = float(mat) / 4.0f;\n    fcol += col;\n        }\n    }\n\n    fcol /= (float(AA*AA));\n    // Output to screen\n    fragColor = vec4(fcol*.8f,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsXRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 37, 37, 112], [114, 114, 149, 149, 356], [358, 358, 430, 430, 473], [475, 475, 516, 516, 665], [667, 667, 701, 701, 1244], [1246, 1246, 1271, 1271, 1492], [1494, 1494, 1517, 1517, 1585], [1588, 1588, 1662, 1662, 1895], [1897, 1897, 1954, 2004, 4349]], "test": "valid"}
{"id": "wdSXRh", "name": "Don't know or fish?", "author": "telpenair", "description": "May be it is a portal to another world? Just learning some basis and try to little experiment.", "tags": ["fish"], "likes": 0, "viewed": 77, "published": "Public", "date": "1552854654", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, float r, float blur){\n\tfloat d = length(uv);\n    float c = smoothstep(r, r + blur, d);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec2 muv = uv;\n    \n    // uv = fract(uv*4.) - .5;\n    // float swing =  sin(iTime + length(uv)*59.)*.5 + .5;\n    \n    float swing =  sin(iTime)*.5 + .5;\n    uv.y += mix(-.1, -.15, swing);\n    \n    // uv.x += sin(iTime*1.9)*.1;\n    \n    float outerMainCircle = Circle(uv*3., mix(.8, .6 , swing), -0.8);    \n    float innerMainCircle = Circle(uv*9., mix(.8, .6 , swing), -0.8);\n    \n    float body = outerMainCircle - innerMainCircle;\n   \t\n    vec2 rightEyePos = vec2(uv.x*mix(6., 8., swing) + 0.95, uv.y*8.);\n    float rightEye = Circle(rightEyePos +.4, 1.2, -.7) - Circle(rightEyePos, 1.2, -1.2) ;\n    \n    vec2 leftEyePos = vec2(uv.x*mix(6., 8., swing) -0.95, uv.y*8.);\n    float leftEye = Circle(leftEyePos -.4, 1., -0.5) - Circle(leftEyePos, 1.2, -1.5);\n    \n    float fish = body + rightEye + leftEye;\n    \n    muv += fish;\n    \n    vec4 res = texture(iChannel0, muv+.09);\n\n    // Output to screen\n    // Uncomment/comment one of next two lines for two variants.\n    \n    // \"Fish in darkness\"\n     fragColor = vec4(vec3(fish, fish, fish-.1),1.0);\n    \n    // \"Breathing of leaves\"\n\t// fragColor = res;\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 124], [126, 126, 183, 233, 1447]], "test": "error"}
{"id": "WdsXW2", "name": "shadermmt", "author": "mmtaipov", "description": "sphere", "tags": ["gg"], "likes": 0, "viewed": 45, "published": "Public", "date": "1552238136", "time_retrieved": "2021-10-01T00:00:00", "image_code": " #define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\nfloat GetDist(vec3 p)\n{\n    \n vec4 s=vec4(0,1,6,1);   \n float sphereDist=length(p-s.xyz)-s.w;\n float planeDist=p.y;\n float d=min(sphereDist,planeDist);\n    return d;\n}\nfloat RayMarch(vec3 ro,vec3 rd)\n{\n float dO=0.; \n    for (int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p=ro+rd*dO;\n        float dS=GetDist(p);\n        dO+=dS;\n        if(dO>MAX_DIST||dS<SURF_DIST)\n            break;\n        \n    }\n    \n    return dO;\n    \n}\nvec3 GetNormal(vec3 p)\n{\n float d=GetDist(p);\n vec2 e=vec2(0.01,0);\n vec3 n=d-vec3(\n     GetDist(p-e.xyy),\n     GetDist(p-e.yxy),\n     GetDist(p-e.yyx)\n         );    \n    return normalize(n);\n}\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos=vec3(0,5,6);\n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*2.;\n    vec3 l=normalize(lightPos-p);\n    vec3 n=GetNormal(p);\n    float dif=clamp(dot(n,l),0.,1.);\n    float d=RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p))\n    dif*=0.1;\n    return dif;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.2*iResolution.xy)/iResolution.y;\n\n      vec3 col=vec3(0);\n    vec3 ro=vec3(0,1,0);\n     \n    vec3 rd=normalize(vec3(uv.x,uv.y,1));\n    float d=RayMarch(ro,rd);\n    vec3 p=ro+rd*d;\n    \n    float dif=GetLight(p);\n    col=vec3(dif);\n     \n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsXW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 91, 91, 235], [236, 236, 269, 269, 493], [494, 494, 518, 518, 688], [689, 689, 713, 713, 997], [998, 998, 1055, 1105, 1400]], "test": "valid"}
{"id": "wdsXWl", "name": "Rounding the Square L1 Style", "author": "paniq", "description": "Mapping the unit square into the unit circle, shown as a mesh here. This is a modification of IQ's shader and uses a L1 circle based formula which is both radius and angle conforming.", "tags": ["circle", "map", "square", "hemisphere"], "likes": 45, "viewed": 1261, "published": "Public API", "date": "1552590217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// for a ready-to-use implementation with comparisons, see https://www.shadertoy.com/view/flcXRl\n\n// Original by by inigo quilez - iq/2019\n// Modified by Leonard Ritter <leonard.ritter@duangle.com>\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// except cart2rad() and rad2cart() which I release in the public domain.\n\n// this is a modification of https://www.shadertoy.com/view/3dsSWs\n// where the points of a square are mapped as equidistant points on a L1 circle\n// and then projected to L2, resulting in sets of equidistant points on\n// concentric circles.\n\n// it's unlikely the same technique will work in 3D as it depends\n// on a polar coordinate system, but it might work again in 4D?\n\n// comment for simple 2D square -> circle distortion demo\n#define HEMISPHERIC\n\n// uncomment to compare hexgrid to square grid\n//#define SQUAREGRID\n\n// when HEMISPHERIC is defined:\n\n// uncomment to compare L1 mapping to octahedral mapping\n//#define OCTAHEDRAL_MAPPING\n\n//-----------------------------------------------\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat maxcomp( in vec2 v ) { return max(v.x,v.y); }\n\nfloat sdLineSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn dot2( pa - ba*h );\n}\n\nfloat sdPointSq( in vec2 p, in vec2 a )\n{\n    return dot2(p-a);\n}\n\n//-----------------------------------------------\n\nvec2 oct_wrap (vec2 v) {\n    return (1.0 - abs(v.yx)) * sign(v);\n}\n\n// https://jcgt.org/published/0003/02/01/\n// uv is [-1..1]x[-1..1]\nvec3 octahedral_surface(vec2 uv) {\n    float z = 1.0 - abs(uv.x) - abs(uv.y);\n    return vec3((z >= 0.0)?uv:oct_wrap(uv), z);\n}\n\n// spherical coordinates from points on L1 surface\nvec2 L1_to_spherical(vec3 o) {\n    // L1 to L2 arclength\n    float r = abs(o.x) + abs(o.y);\n    float h = o.x * ((r == 0.0) ? 0.0 : (1.0 / r)) - 1.0;\n    float phi = ((o.y >= 0.0)? -h : h) * radians(90.0);\n    // L1 to L2 radius\n    // inverse of https://en.wikipedia.org/wiki/Collignon_projection\n    float z = 1.0 - abs(o.z);    \n    float rho = radians(90.0) - asin(1.0 - z*z)*sign(o.z);\n    return vec2(phi, rho);\n}\n\n//-----------------------------------------------\n\n// convert from unit grid to unit circle\nvec2 cart2rad(vec2 o) {\n#ifdef OCTAHEDRAL_MAPPING\n    vec2 p = vec2(o.x + o.y, o.y - o.x)*0.5;\n    \n    vec3 n = vec3(p, 1.0 - abs(p.x) - abs(p.y));\n    float t = max(-n.z,0.0);\n    n.x += (n.x>0.0)?-t:t;\n    n.y += (n.y>0.0)?-t:t;\n    vec2 q = normalize(n).xy;\n    \n    return vec2(q.x - q.y, q.x + q.y)*sqrt(0.5);    \n#else\n    vec2 p = vec2(o.x + o.y, o.y - o.x)*0.5;    \n    vec2 s = L1_to_spherical(octahedral_surface(p));\n    \n    s.x += radians(45.0);\n\n    // radius\n    float r = abs(p.x) + abs(p.y);\n#ifdef HEMISPHERIC\n    // hemispheric distortion\n    r = sin(s.y);\n#endif\n    return r * vec2(cos(s.x), sin(s.x));\n#endif\n}\n\n//-----------------------------------------------\n\n// convert from circle to grid\nvec2 rad2cart(vec2 q) {\n    float r = length(q);\n#ifdef HEMISPHERIC\n    // hemispheric distortion\n    r = asin(r) / (0.5 * 3.1415926);\n#endif   \n    float a = atan(q.y, q.x) / (2.0 * 3.1415926) - 0.125;\n    \n    float px = abs(fract(a) - 0.5);\n    float py = abs(fract(a - 0.25) - 0.5);\n\t\n    return (4.0 * r) * vec2(px - py, px + py - 0.5);\n}\n\n//-----------------------------------------------\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a); float s = sin(a);\n    return vec2(p.x*c + p.y*s, s*p.x - c*p.y);\n}\n\nvec2 vertex( int i, int j, int num)\n{\n    // unit square\n#if !defined(SQUAREGRID)\n    vec2 s = vec2(i,j)/vec2(num, num*2);\n    s.x -= float(j%2)*0.5/float(num);\n    s = -1.0+2.0*s;\n    //s.x *= 2.0;\n#else\n    vec2 s = vec2(i,j)/float(num);\n    s = -1.0+2.0*s;\n#endif\n   \n    // unit circle\n#if 1\n#ifdef HEMISPHERIC   \n    vec2 q = cart2rad(s);\n    vec3 c = vec3(q, sqrt(max(0.0, 1.0 - q.x*q.x - q.y*q.y)));\n#else\n    vec2 c = cart2rad(s);\n#endif\n#else\n    // old function\n    vec2 c = maxcomp(abs(s))*normalize(s);\n#endif\n\n#ifdef HEMISPHERIC\n    vec3 sp = vec3(s, 0.0);\n    vec3 p = mix(c,sp,smoothstep(-0.5,0.5,sin(iTime*2.0)));\n    \n    p.xy = rotate(p.xy, iTime * 0.125);\n    \n    return vec2(p.x, (p.y + p.z) * sqrt(0.5));\n    //return vec2(p.x, p.z);\n#else\n    // blend\n    return mix(c,s,smoothstep(-0.5,0.5,sin(iTime*2.0)));\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // plane coords\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float w = 2.0/iResolution.y;\n    \n    // scale\n\tp *= 1.15;\n\tw *= 1.15;\n    \n    // mesh: body\n    vec2 di = vec2(10.0);\n#if !defined(SQUAREGRID)\n    const int num = 8;\n    for (int k = 0; k < num; ++k) {\n        int ring = num-k;\n        int ofsx = k/2 + k%2;\n        int ofsy = k;\n        for (int i = 0; i < ring; ++i) {\n            {\n            vec2 a = vertex(i+0+ofsx,ofsy,num);\n            vec2 b = vertex(i+1+ofsx,ofsy,num);\n            vec2 c = vertex(i+1+ofsx-(k%2),ofsy+1,num);\n            di = min( di, vec2(min(sdLineSq(p,a,b),min(sdLineSq(p,a,c),sdLineSq(p,b,c))),\n                               sdPointSq(p,a)));\n            }\n            {\n            vec2 a = vertex(ring+ofsx,i*2+0+ofsy,num);\n            vec2 b = vertex(ring+ofsx,i*2+2+ofsy,num);\n            vec2 c = vertex(ring+ofsx-k%2,i*2+1+ofsy,num);\n            di = min( di, vec2(min(sdLineSq(p,a,b),min(sdLineSq(p,a,c),sdLineSq(p,b,c))),\n                               sdPointSq(p,a)));\n            }\n            {\n            vec2 a = vertex(ring-i+ofsx,ring*2+ofsy,num);\n            vec2 b = vertex(ring-i-1+ofsx,ring*2+ofsy,num);\n            vec2 c = vertex(ring-i-1+ofsx+((k+1)%2),ring*2-1+ofsy,num);\n            di = min( di, vec2(min(sdLineSq(p,a,b),min(sdLineSq(p,a,c),sdLineSq(p,b,c))),\n                               sdPointSq(p,a)));\n            }\n            {\n            vec2 a = vertex(ofsx,ring*2-i*2+0+ofsy,num);\n            vec2 b = vertex(ofsx,ring*2-i*2-2+ofsy,num);\n            vec2 c = vertex(ofsx+(k+1)%2,ring*2-i*2-2+1+ofsy,num);\n            di = min( di, vec2(min(sdLineSq(p,a,b),min(sdLineSq(p,a,c),sdLineSq(p,b,c))),\n                               sdPointSq(p,a)));\n            }\n        }\n    }\n    \n    // mesh: center\n    di.y = min( di.y, sdPointSq(p,vertex(num/2 + num%2,num,num)));\n#else\n    const int num = 10;\n\tfor( int j=0; j<num; j++ )\n\tfor( int i=0; i<num; i++ )\n    {\n        vec2 a = vertex(i+0,j+0,num);\n        vec2 b = vertex(i+1,j+0,num);\n        vec2 c = vertex(i+0,j+1,num);\n        di = min( di, vec2(min(sdLineSq(p,a,b), \n                               sdLineSq(p,a,c)),\n                               sdPointSq(p,a)));\n    }\n\n    // mesh: top and right edges\n\tfor( int j=0; j<num; j++ )\n    {\n        vec2 a = vertex(num,j+0,num);\n        vec2 b = vertex(num,j+1,num);\n        vec2 c = vertex(j+0,num,num);\n        vec2 d = vertex(j+1,num,num);\n        di = min( di, vec2(min(sdLineSq(p,a,b), \n                               sdLineSq(p,c,d)),\n                           min(sdPointSq(p,a),\n                               sdPointSq(p,c))));\n    }\n    // mesh: top-right corner\n    di.y = min( di.y, sdPointSq(p,vertex(num,num,num)));\n#endif\n    di = sqrt(di);\n\n    \n    // color\n    float col = 1.0;\n    col *= 0.9+0.1*smoothstep(0.0,0.05,di.x);\n    col *= smoothstep(0.0,0.008,di.x);\n    col *= smoothstep(0.03,0.03+w,di.y );\n    \n    // vignette\n    col *= 1.0 - 0.15*length(p);\n    \n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsXWl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1002, 1053, 1078, 1078, 1097], [1098, 1098, 1126, 1126, 1149], [1151, 1151, 1202, 1202, 1310], [1312, 1312, 1353, 1353, 1377], [1379, 1430, 1454, 1454, 1496], [1498, 1565, 1599, 1599, 1692], [1694, 1745, 1775, 1801, 2164], [2217, 2258, 2281, 2281, 2890], [2943, 2974, 2997, 2997, 3317], [3319, 3370, 3400, 3400, 3489], [3491, 3491, 3528, 3547, 4331], [4333, 4333, 4390, 4415, 7429]], "test": "valid"}
{"id": "WdsXWS", "name": "drop", "author": "nabehide", "description": "loop", "tags": ["loop"], "likes": 5, "viewed": 339, "published": "Public API", "date": "1553083735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\n/*\nconst float speed = 3.0;\nconst float MAX =  0.5;\nconst float MIN = -0.5;\nconst float circleSize = 0.3;\nconst int Ncircle = 3;\n*/\nconst float speed = 1.0;\nconst float MAX =  1.5;\nconst float MIN = -1.5;\nconst float circleSize = 0.1;\nconst int Ncircle = 15;\n\nconst float period = 6.0*speed;\n// const vec3 color = vec3(188, 163, 82)/255.;\n// const vec3 color = vec3(160, 128, 160)/255.;\nconst vec3 color = vec3(0, 134, 204)/255.;\nconst vec3 bg = vec3(1.);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rand2(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\nvec2 loopRand2(vec2 co, float t){\n    if(0.0 < t && t < period - 1.){\n    \treturn rand2(co);\n    }else{\n        return vec2(0.5);\n    }\n}\n\nfloat circle(vec2 p){\n    return 1.-length(p);\n}\n\nfloat morphing(vec2 p, float i){\n    float t = mod(rand(vec2(i))*period+time*speed,period);\n    vec2 pa1=vec2(loopRand2(vec2(floor(t-1.),0.1*i),t-1.))*(MAX-MIN)+MIN;\n    vec2 pa2=vec2(loopRand2(vec2(floor(t-0.),0.1*i),t   ))*(MAX-MIN)+MIN;\n\n    return mix(circle(p-pa1), circle(p-pa2), pow(fract(t),0.3));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.-iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    vec3 draw = bg;\n    \n    for(int i=0; i<Ncircle; i++){\n\t    float d = morphing(p, float(i+1));\n        vec3 c = vec3(\n            color.r+rand(vec2(float(i),0.1))*0.5,\n            color.g+rand(vec2(float(i),0.2))*0.5,\n            color.b+rand(vec2(float(i),0.3))*0.5\n        );\n        if(1.-circleSize<d){\n            draw += c-draw;\n        }\n    }\n    \n    fragColor = vec4(draw,1.0);\n}", "image_inputs": [{"id": "lll3D4", "previewfilepath": "https://soundcloud.com/nabehide/dmwtrp", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/nabehide/dmwtrp", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 477, 497, 497, 567], [569, 569, 592, 592, 684], [686, 686, 719, 719, 823], [825, 825, 846, 846, 873], [875, 875, 907, 907, 1182], [1184, 1184, 1241, 1241, 1717]], "test": "valid"}
{"id": "wdsXzf", "name": "Sine wave (using ML)", "author": "baldand", "description": "A small neural network with 3 hidden layers trained to generate sine waves\nShader is performing one NN inference for every pixel of every frame to render wave", "tags": ["2d", "nn", "ml"], "likes": 3, "viewed": 467, "published": "Public API", "date": "1551812977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// (c) 2019 Andrew Baldwin (twitter:baldand)\n// License = Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) (http://creativecommons.org/licenses/by-sa/4.0/)\n\n// Small neural network with 3 hidden layers trained to generate sin waves\n// We are doing one inference with this for every pixel of every frame\n\n// See https://www.shadertoy.com/view/wdfSzl \n// for visually much improved version with similar complexity\n\n// See also twitter thread: https://twitter.com/baldand/status/1103012877064196098\n\nfloat infer(float x) {\n    // Trained parameters\n    mat4 m0 = mat4(-0.12571095,-0.26496017,0.9719571,0.21379238,-0.012421567,-0.5054736,0.73711926,0.5343512,0.5220842,-0.77656305,-0.5207267,-0.32392937,0.4735854,-0.70736265,0.81603307,-1.9917549);\n    vec4 b0 = vec4(-0.14748195,0.0,-0.03197732,0.3572576);\n    mat4 m1 = mat4(0.40561008,0.4723408,0.8758184,-1.0912322,0.529556,-0.8380854,-0.7847434,0.71776015,-0.21837308,0.5915957,0.19515494,0.9023054,1.1809518,0.34930748,1.483023,-0.02533237);\n    vec4 b1 = vec4(0.10530137,-0.37976393,-0.14090052,-0.046417937);\n    mat4 m2 = mat4(0.07913667,0.7634938,-0.04178363,-0.19418743,-0.14935172,-0.4280477,-0.08846402,0.4486952,-0.6807784,0.29692093,-0.2470401,0.95824474,-0.6653977,-2.042718,0.011264741,-0.31809056);\n    vec4 b2 = vec4(0.0,0.07556404,0.0,-0.14975327);\n    vec4 v3 = vec4(-0.9077474,0.45764312,0.24416518,1.6874518);\n    float b3 = 0.007885284;\n    // Use x as input to neural network to calculate y\n    vec4 i = vec4(x,x+.25,x+.5,x+.75);\n    vec4 l1 = m0*fract(i)+b0;\n    vec4 l2 = m1*max(l1,0.0)+b1;\n    vec4 l3 = m2*max(l2,0.0)+b2;\n    vec4 l4 = v3*max(l3,0.0);\n    float y = clamp(b3+l4.x+l4.y+l4.z+l4.w,0.,1.);\n    return 0.5+(y-0.5)*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float x = uv.x + iTime*.2;\n    float y = infer(x);\n    float r = smoothstep(y, y+.005, uv.y);\n    vec3 col = mix(vec3(0.,0.3,0.5), vec3(0.,.9,1.), r);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsXzf.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[420, 504, 526, 552, 1715], [1717, 1717, 1774, 1774, 2002]], "test": "valid"}
{"id": "wdSXzh", "name": "ShaderDojo 024", "author": "antonOTI", "description": "Part 2 of my shaders inspired by the ES2 Riftborn prologue\nit's a comment from @ollj that motivated me trying.\nStill some weird artifact and performance I have to look into :)", "tags": ["raymarch", "training", "dojo", "cookie", "riftborn", "endlessspace"], "likes": 7, "viewed": 387, "published": "Public API", "date": "1552863465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shattered dimention\n// Inspired by the Riftborn intro from ES2\n// https://www.youtube.com/watch?v=h8H8DedCW_I\n//\n// \n\n#define PI 3.14159\n#define TAU (PI * 2.)\n\n#define time (iTime)\n\n#define RID(p, r) (floor((p + r/2.) / r))\n#define REP(p, r) (mod(p + r/2., r) - r/2.)\n\n// from https://www.shadertoy.com/view/4tdSWr\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 2; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n    n += time * .5;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// from https://www.shadertoy.com/view/ltl3D8\n// I've modified it to tape into a 2d fbm instead of a texture\n// It's far from perfect but it's close to the feeling I searched for\n float cubemap( in vec3 d )\n{\n    vec3 n = abs(d);\n    vec3 v = (n.x>n.y && n.x>n.z) ? d.xyz: \n             (n.y>n.x && n.y>n.z) ? d.yzx:\n                                    d.zxy;\n    vec2 uv = 0.5+0.5*v.yz;///v.x;\n\n    return fbm(uv * 8.);\n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a); float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\n// from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n  return dot(p,n.xyz) - n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat distortion = 0.;\n\nfloat map(vec3 p)\n{\n\n  vec3 cp = p;\n\n  float t = time  * 1.;\n\n  vec3 orbit = normalize(vec3(1.,0.,1.));\n  orbit.xy *= rot(t * .12);\n  orbit.yz *= rot(sin(t * .23) * .2);\n\n  vec3 distOrb = p + orbit * 2.9;\n    \n  distortion = clamp(1.5 - length(distOrb), 0., 1.);\n  distortion*= distortion;\n\n  p = cp;\n\n  p *= 1.;\n  float dist = 1000.;\n\n  p.xy *= rot(-t *.05);\n  p.yz *= rot(-t * .025);\n  p.zx *= rot(-t * .00125);\n\n    if(distortion > 0.)\n    {\n        float diff = cubemap(normalize(p));\n        diff *= 10.;\n        diff = 1. - exp(-.3 - diff * 1.2);\n        diff *= 1.;\n\n        p = p + normalize(distOrb - p) * diff * distortion;\n    }\n  dist = max(sdOctahedron(p,3.5), sdBox(p,vec3(2.15))) ;\n\n  p = cp;\n\n  p += orbit * 4.3;\n\n  p.xy *= rot(-t *.27);\n  p.yz *= rot(-t * .135);\n  p.zx *= rot(-t * .0125);\n  \n    if(distortion > 0.)\n    {\n        float diff = cubemap(normalize(p)*.5);\n        diff *= 10.;\n        diff = 1. - exp(-.3 - diff * 1.2);\n        diff *= .3;\n\n        p+= normalize(p) * diff * distortion;\n    }\n  float octahedre = sdOctahedron(p, .7) ;\n  dist = min(dist, octahedre);\n\n  return dist * (1. - distortion * .85);\n}\n\nvoid ray(inout vec3 cp,vec3 rd, out float st, out float cd)\n{\n  for(st = 0.; st < 1.; st += 1./64.)\n  {\n    cd = map(cp);\n    if(cd < .01)\n      break;\n    cp += rd * cd * .75;\n  }\n}  \n\nvec3 normal(vec3 p)\n{\n  vec2 e = vec2(.01,.0);\n  float d = map(p);\n  return normalize(vec3(\n    d - map(p + e.xyy),\n    d - map(p + e.yxy),\n    d - map(p + e.yyx)\n  ));\n}\n\nvec3 lookAt(vec3 eye, vec3 tar, vec2 uv)\n{\n  vec3 fd = normalize(tar - eye);\n  vec3 ri = cross(fd, vec3(0.,1.,0.));\n  vec3 up = cross(ri,fd);\n  return normalize(fd + ri * uv.x + up * uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  uv*= sin(time * .1) *.1 + 1.1;\n    \n  vec3 eye = vec3(0.,0.,-10.);\n  vec3 tar = vec3(0.);\n  vec3 rd = lookAt(eye, tar, uv);\n  vec3 cp = eye;\n  float st,cd;\n  ray(cp,rd,st,cd);\n\n  float dist = length(eye - cp);\n\n  fragColor = mix(vec4(1.), vec4(.6,.6,.68,1.), pow((fragCoord.x / iResolution.x * .75 + .1), 1.2));\n  if(cd < .01)\n  {\n    vec3 norm = normal(cp);\n    vec3 ld = normalize(vec3(1.,-1.,1.));\n    float li = dot(norm,ld);\n    fragColor = mix(\n        fragColor,\n        mix(\n          mix(vec4(.84,.84,.855,1.),\n              vec4(.85,.85,.87,1.),\n                1. - pow(1. - distortion, 2.)),\n          vec4(.4,.4,.52,1.),\n        li),\n        exp(-distance(cp,eye) * .007));\n  }\n  \n  fragColor = pow(fragColor, vec4(2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 365, 386, 386, 499], [501, 501, 527, 527, 1051], [1053, 1053, 1072, 1072, 1246], [1248, 1428, 1456, 1456, 1670], [1672, 1672, 1691, 1691, 1762], [1764, 1840, 1884, 1884, 1941], [1943, 1943, 1974, 1974, 2005], [2007, 2007, 2038, 2038, 2188], [2214, 2214, 2233, 2233, 3354], [3356, 3356, 3417, 3417, 3538], [3542, 3542, 3563, 3563, 3712], [3714, 3714, 3756, 3756, 3905], [3907, 3907, 3963, 3963, 4840]], "test": "valid"}
{"id": "wdXSDs", "name": "[twitch] Fractured World", "author": "yx", "description": "I stream shader creation every Wednesday at 9pm UK time, over at [url]https://twitch.tv/lunasorcery[/url]\nCome and watch a show!\n\nOr watch the VOD for this shader here: [url]https://www.twitch.tv/videos/395087279[/url]", "tags": ["livecoding", "twitch"], "likes": 13, "viewed": 594, "published": "Public API", "date": "1552517077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThis shader was created live on stream!\nYou can watch the VOD here: https://www.twitch.tv/videos/395087279\n\nI use the Bonzomatic tool by Gargaj/Conspiracy:\nhttps://github.com/Gargaj/Bonzomatic\n\nWednesdays around 9pm UK time I stream at https://twitch.tv/lunasorcery\nCome and watch a show!\n\n~yx\n*/\n\n#define pi acos(-1.)\n\nvec2 rotate(vec2 a, float b)\n{\n    float c=cos(b);\n    float s=sin(b);\n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c\n    );\n}\n\nfloat noise(vec3 a)\n{\n    return fract(sin(dot(a,vec3(12.341242,3.432432,17.34242)))*1435.432432);\n}\n\nfloat smoothnoise(vec3 p)\n{\n    vec3 fl = floor(p);\n    vec3 fr = fract(p);\n\n    float a=noise(fl+vec3(0,0,0));\n    float b=noise(fl+vec3(1,0,0));\n    float c=noise(fl+vec3(0,1,0));\n    float d=noise(fl+vec3(1,1,0));\n    float e=noise(fl+vec3(0,0,1));\n    float f=noise(fl+vec3(1,0,1));\n    float g=noise(fl+vec3(0,1,1));\n    float h=noise(fl+vec3(1,1,1));\n    return mix(\n        mix(\n            mix(a,b,fr.x),\n            mix(c,d,fr.x),\n            fr.y\n        ),\n        mix(\n            mix(e,f,fr.x),\n            mix(g,h,fr.x),\n            fr.y\n        ),\n        fr.z\n    );\n}\n\nfloat side=1.;\nint mat = 0;\n\nfloat orb(vec3 p)\n{\n    float d=length(p)-12.;\n\n    if (d > .5)\n        return d;\n\n    vec3 offset = vec3(0,iTime*.5,0);\n\n    float midpoint = .5+sin(iTime*.3)*.1;\n\n    float n = smoothnoise(p-offset)-midpoint;\n    side=sign(n);\n    if(side>0.){\n        p*=1.+smoothnoise(p*4.)*.01;\n        d=length(p)-12.;\n    }\n    d = max(d, .05-abs(n));\n    return d;\n}\n\nfloat shatter(vec3 p)\n{\n    float d = -1e9;\n\n    for(int i=0;i<5;++i)\n    {\n        float f=float(i)+iTime*.00001;\n        vec3 n = normalize(vec3(\n            noise(vec3(f,0,0)),\n            noise(vec3(0,f,0)),\n            noise(vec3(0,0,f))\n        )-.5);\n\n        float s=sin(iTime*.1)*.5+.7;\n        vec3 o = vec3(\n            noise(vec3(-i,0,0)),\n            noise(vec3(0,-i,0)),\n            noise(vec3(0,0,-i))\n        )*s*2.-s;\n        o*=sign(dot(o,n));\n\n        p -= o*sign(dot(p,n));\n        d = max(d,length(o)-abs(dot(p,n))+.01);\n    }\n\n    d = max(d,orb(p));\n    return d;\n}\n\nfloat scene(vec3 p)\n{\n    float d = 40.-length(p);\n    float n = smoothnoise(p+vec3(0,iTime,0));\n    d = max(d, .05-abs(n-.5));\n\n    float d2 = shatter(p);\n    mat = d<d2?0:1;\n    return min(d,d2);\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float t=0.;\n    float k=0.;\n    vec3 accum=vec3(1);\n    for (int b=0;b<4;++b){\n        for(int i=0;i<100;++i){\n            k=scene(cam+dir*t);\n            t+=k;\n            if(abs(k)<.001)\n            {\n                break;\n            }\n        }\n        vec3 h=cam+dir*t;\n        vec2 o=vec2(.001,0);\n        vec3 n=normalize(vec3(\n            scene(h+o.xyy)-scene(h-o.xyy),\n            scene(h+o.yxy)-scene(h-o.yxy),\n            scene(h+o.yyx)-scene(h-o.yyx)\n        ));\n        if (mat == 0) {\n            return accum*(dot(n,-normalize(h))*.5+.5);\n        } else {\n            // orb\n            if (side > 0.) {\n                float fresnel = pow(1.-max(0.,dot(n,-dir)),5.);\n                accum *= fresnel;\n                cam=h+n*.01;\n                dir=reflect(dir,n);\n            } else {\n                return accum*vec3(n.y*.5+.5);\n            }\n        }\n    }\n    return accum;\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-35);\n    vec3 dir = normalize(vec3(uv,1));\n\n    cam.yz = rotate(cam.yz, .3);\n    dir.yz = rotate(dir.yz, .3);\n\n    cam.xz = rotate(cam.xz, iTime*.1);\n    dir.xz = rotate(dir.xz, iTime*.1);\n\n    out_color.rgb = trace(cam,dir);\n    out_color.rgb = pow(out_color.rgb, vec3(.45));\n    out_color.rgb *= 1.-dot(uv,uv)*.4;\n    out_color.rgb = pow(out_color.rgb, vec3(1.4,1.2,1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 323, 353, 353, 460], [462, 462, 483, 483, 562], [564, 564, 591, 591, 1148], [1179, 1179, 1198, 1198, 1536], [1538, 1538, 1561, 1561, 2125], [2127, 2127, 2148, 2148, 2326], [2328, 2328, 2360, 2360, 3264], [3266, 3266, 3318, 3318, 3809]], "test": "valid"}
{"id": "wdXSW2", "name": "LowPoly Landscape using Voronoi", "author": "TheWifflebrain", "description": "This is a low-poly landscape using the Voronoi effect and a noise effect for the sky. ", "tags": ["terrain"], "likes": 3, "viewed": 99, "published": "Public", "date": "1552545970", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CREATION OF THE VORONOI EFFECT\n//Based on http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\nvec2 hash(vec2 p) \n{ \n    p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); \n}\n//Return distance, and cell id\nvec2 voronoi(in vec2 x, bool isMoving)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 r;\n    vec2 o;\n\n\tvec3 m = vec3(8.0);\n    for(int j=-1; j<=1; j++)\n    for(int i=-1; i<=1; i++)\n    {\n        vec2 g = vec2(float(i), float(j));\n        if(isMoving == true)\n        {\n        \to = hash( n + g );\n\t    \tr = g - f + (0.5+0.5*sin(iTime+6.2831*o));\n        }\n        else \n        {\n            o = hash( n + g + 42.);\n\t    \tr = g - f + (0.5+0.5*sin(6.2831*o));\n        }\n\t\tfloat d = dot(r, r);\n        if(d<m.x)\n            m = vec3(d, o);\n    }\n\n    return vec2(sqrt(m.x), m.y+m.z);\n}\n\n//CREATING THE SKY\n//Getting a vec2 and returning a float\nfloat N21(vec2 p) \n{\n    return fract(sin(p.x*100.0+p.y*6574.0)*5647.0);\n}\n\nfloat SmoothNoise(vec2 uv) \n{\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.0-2.0*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n    float c = SmoothNoise(uv*4.0);\n    c += SmoothNoise(uv*8.0)*0.5;\n    c += SmoothNoise(uv*16.0)*0.25;\n    c += SmoothNoise(uv*32.0)*0.16;\n    c += SmoothNoise(uv*64.0)*0.0625;\n    \n    return c / 2.;\n}\n\n//Creating a circle for the sun\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) \n{\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n    \n\treturn vec4(color, 1.0-t);\n}\n\n//Checking if a pixel is inside the desired triangle\nbool isInTriangle(vec2 v1, vec2 v2, vec2 v3, vec2 uv) \n{\n    //CCW direction vectors along triangle edges.\n    vec2 v21 = v2 - v1;\n    vec2 v32 = v3 - v2;\n    vec2 v13 = v1 - v3;\n    \n    //Normals point inward from triangle edges.  Just rotate triangle edges\n    //90 degrees CCW.\n    vec2 n21 = vec2(-v21.y, v21.x);\n    vec2 n32 = vec2(-v32.y, v32.x);\n    vec2 n13 = vec2(-v13.y, v13.x);\n    \n    return (dot(v1-uv,n21) < 0.0) && \n           (dot(v2-uv,n32) < 0.0) && \n           (dot(v3-uv, n13)< 0.0);\n}\n\n//MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Setting up the stage\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uvFillIn = fragCoord.xy/iResolution.xy;\n    //Slowing down time\n    uv += iTime*.1;\n    \n    //SKY using the noise effect\n    //Setting boundaries for the sky\n    vec2 centerSky = iResolution.xy * 0.5;\n\tfloat width = 1.0 * iResolution.x;\n\tfloat height = 0.57 * iResolution.x;\n    //Starting noise effects\n    float c = SmoothNoise2(uv);\n    //vec2 col = vec2(c);\n    //vec4 skyLayer = vec4(col,1.5,255.0);\n    \n    //SUN using voronoi effect\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    vec2 uvSun = fragCoord.xy;\n\tvec2 center = (iResolution.xy * 0.87 * sin(((iTime)*.7)));//could multiply it by time to make the sun move\n    float darkness = (iResolution.y * 0.87 * sin(((iTime)*.7)));\n\tfloat radius = 0.1 * iResolution.y;\n    //Adding voroni effect\n    vec2 cSun = voronoi((14.0+6.0*cos(0.01*iTime))*p, true);\n    //The color of the sun\n    \t//Changes the intesisty of the sun \n    \t//Higher number more clouds and lighter/lower number darker yellow with less clouds\n    \t//+ The color of the sun in rgb\n    vec3 colorSun = (cSun.y*0.48 + (vec3(255.,255.,0.0)));//The white shapes are meant to be clouds\n\t//Cropping out a circle for the sun\n\tvec4 sunLayer = circle(uvSun, center, radius, colorSun);\n    \n    //changing the background color to the sky by the y coordinate\n    vec2 col;\n    vec4 skyLayer;\n    if(darkness < 120.0)\n    {\n        col = vec2(c-1.0);\n    \tskyLayer = vec4(col,0.1,0.0);\n    }\n    else if(darkness < 250.0)\n    {\n        col = vec2(c-1.0);\n    \tskyLayer = vec4(col,0.35,0.0);\n    }\n    else\n    {\n        col = vec2(c);\n        skyLayer = vec4(col,1.0,0.0);\n    }\n    \n    //Variables to shift the location of the mountains and the lake all at once\n    float mHeight = 0.28;\n    float mShift = 0.18;\n    float lHeight = 0.1;\n    \n    //Forest voronoi variables\n    \t//Density of the shapes (first two variables)\n    \t//Position of the shapes mostly (thrid and fouth variables)\n    vec2 cF = voronoi(8.0*(9.0+9.0*sin(0.2*(iTime*.001)))*p, true);\n    \t//Intensity of the shade (first two variables)\n    \t//Color of shapes (the vec3)\n    vec3 colorF = 0.2 + .8*cos(cF.y + vec3(0.1,5.5,0.1));\t\n    colorF *= clamp(4.0 - 0.4*cF.x*cF.x,1.0,0.8);\n    \n    //Lake voronoi variables\n    \t//iTime ebb and flows the lake\n    vec2 cL = voronoi(6.0*(42.0+6.0*cos(0.3*iTime))*p, true);\n    vec3 colorL = (cL.y*0.55 + (vec3(0.,0.,200.0)));\n    \n    //Mountain caps voronoi variables\n    vec2 cMC = voronoi((100.0+6.0*cos(15.7))*p, true);\n    vec3 colorMC = 0.9 + 0.1*cos(cMC.y*6.2831 + vec3(0.0,0.0,0.0));\t\n    colorMC *= clamp(1.0 - 0.4*cMC.x*cMC.x,0.0,1.0);\n    \n    //Shading the different components of the landscape\n    //Forest shading\n    //vec2 from left to right is right vertex, left vertex, then top vertex\n    if (isInTriangle(vec2(0,0.3), vec2(0,-0.2), vec2(0.3,0.0), uvFillIn)) \n    {\n    \tfragColor = vec4(colorF, 1.0);\n    }\n    else if (isInTriangle(vec2(1,0.3), vec2(0,-0.7), vec2(1.0,-0.3), uvFillIn)) \n    {\n    \tfragColor = vec4(colorF, 1.0);\n    }\n    //Lake shading\n    else if (isInTriangle(vec2(0.0,0.0-lHeight), vec2(1,0.33-lHeight), vec2(0.0,0.33-lHeight), uvFillIn)) \n    {\n    \tfragColor = vec4(colorL, 0.0);\n    }\n    else if (isInTriangle(vec2(1,0.33-lHeight), vec2(0,0.0-lHeight), vec2(1.0,0.0-lHeight), uvFillIn)) \n    {\n        fragColor = vec4(colorL, 0.0);\n    }\n    //Mountain caps shading\n    else if (isInTriangle(vec2(0.73,0.7), vec2(0.81,0.7), vec2(0.95-mShift,1.1-mHeight), uvFillIn)) \n    {\n    \tfragColor = vec4(sqrt(max(colorMC, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.173,0.7), vec2(0.295,0.7), vec2(0.41-mShift,1.2-mHeight), uvFillIn))\n    {\n\t\tfragColor = vec4(sqrt(max(colorMC, 0.0)), 1);\n    }\n    //Mountain shading\n    else if (isInTriangle(vec2(0.7-mShift,0.5-mHeight), vec2(0.9-mShift,0.5-mHeight), vec2(0.8-mShift,0.8-mHeight), uvFillIn)) \n    {\n        vec2 cM1 = voronoi((17.0*cos(0.17))*p, false);\n        vec3 colorM1 = 0.3 + 0.2*cos(cM1.y*6.2831 + vec3(0.8,0.8,0.8));\t\n    \tcolorM1 *= clamp(1.0 - 0.4*cM1.x*cM1.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM1, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.75-mShift,0.5-mHeight), vec2(1.15-mShift,0.5-mHeight), vec2(0.95-mShift,1.1-mHeight), uvFillIn)) \n    {\n    \tvec2 cM2 = voronoi((17.0+6.0*cos(15.7))*p, false);\n        vec3 colorM2 = 0.3 + 0.2*cos(cM2.y*6.2831 + vec3(0.8,0.8,0.8));\t\n    \tcolorM2 *= clamp(1.0 - 0.4*cM2.x*cM2.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM2, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.58-mShift,0.5-mHeight), vec2(0.98-mShift,0.5-mHeight), vec2(0.78-mShift,1.-mHeight), uvFillIn)) \n    {\n    \tvec2 cM3 = voronoi((19.0+6.0*cos(0.28))*p, false);\n        vec3 colorM3 = 0.3 + 0.2*cos(cM3.y*6.2831 + vec3(0.8,0.8,0.8));\t\n    \tcolorM3 *= clamp(1.0 - 0.4*cM3.x*cM3.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM3, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.21-mShift,0.5-mHeight), vec2(0.61-mShift,0.5-mHeight), vec2(0.41-mShift,.9-mHeight), uvFillIn)) \n    {\n    \tvec2 cM4 = voronoi((15.0+6.0*cos(6.27))*p, false);\n        vec3 colorM4 = 0.3 + 0.2*cos(cM4.y*6.2831 + vec3(0.8,0.8,0.8) );\t\n    \tcolorM4 *= clamp(1.0 - 0.4*cM4.x*cM4.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM4, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.41-mShift,0.5-mHeight), vec2(0.81-mShift,0.5-mHeight), vec2(0.61-mShift,1.05-mHeight), uvFillIn)) \n    {\n    \tvec2 cM5 = voronoi((14.5+6.0*cos(1.57))*p, false);\n        vec3 colorM5 = 0.3 + 0.2*cos(cM5.y*6.2831 + vec3(0.8,0.8,0.8));\t\n    \tcolorM5 *= clamp(1.0 - 0.4*cM5.x*cM5.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM5, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.23-mShift,0.5-mHeight), vec2(0.61-mShift,0.5-mHeight), vec2(0.41-mShift,1.2-mHeight), uvFillIn))\n    {\n    \tvec2 cM6 = voronoi((14.0+6.0*cos(1.57))*p, false);\n        vec3 colorM6 = 0.3 + 0.2*cos(cM6.y*6.2831 + vec3(0.8,0.8,0.8));\t\n    \tcolorM6 *= clamp(1.0 - 0.4*cM6.x*cM6.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM6, 0.0)), 1);\n    }\n    //Shading the background\n    else \n    {\n        //Mixing the two layers of the sun and the sky\n    \tfragColor = mix(skyLayer, sunLayer, sunLayer.a);\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 113, 133, 133, 230], [231, 262, 302, 302, 855], [857, 915, 935, 935, 989], [991, 991, 1020, 1020, 1341], [1343, 1343, 1372, 1372, 1577], [1579, 1611, 1667, 1667, 1768], [1770, 1823, 1879, 1929, 2330], [2332, 2339, 2394, 2421, 8600]], "test": "valid"}
{"id": "WdXSWj", "name": "Blob Map", "author": "parameterized", "description": "tilemap generator (referencing https://simblob.blogspot.com/2010/01/simple-map-generation.html)", "tags": ["procedural", "2d"], "likes": 2, "viewed": 278, "published": "Public API", "date": "1552115210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n        dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat noiseAlt(vec2 uv)\n{\n    vec2 _uv = uv;\n    uv /= 512.0;\n    uv += vec2(500.0);\n    float v = snoise(uv)*0.5+0.5;\n    v += snoise(uv*2.0)*0.4;\n    v += snoise(uv*4.0)*0.2;\n    v += snoise(uv*8.0)*0.1;\n    v += snoise(uv*16.0)*0.05;\n    v += snoise(uv*32.0)*0.02;\n    v -= 0.2;\n    v = max(v, 0.0);\n    v = pow(v, 2.0);\n    float d = length(_uv);\n    v -= pow(d/256.0, 2.0);\n    v += snoise(_uv/128.0 - vec2(500.0))*0.15 + 0.7;\n    //v = max(v, 0.0);\n    return v;\n}\n\nfloat noiseMoist(vec2 uv)\n{\n    uv /= 512.0;\n    float v = snoise(uv)*0.5+0.5;\n    v += snoise(uv*2.0)*0.4;\n    v += snoise(uv*4.0)*0.2;\n    v += snoise(uv*8.0)*0.1;\n    v += snoise(uv*16.0)*0.05;\n    v += snoise(uv*32.0)*0.02;\n    v += 0.1;\n    v = max(v, 0.0);\n    v = pow(v, 2.0);\n    return v;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord - iResolution.xy*0.5;\n    float scale = sin(iTime*0.5)*0.5 + 0.75;\n    //scale = 1.0;\n    uv += (iMouse.xy - iResolution.xy*0.5)/scale*(1.25 - scale);\n    uv.y = -uv.y;\n    uv *= scale;\n    vec2 p = floor(uv);\n    \n    float alt = noiseAlt(p);\n    float moist = noiseMoist(p);\n    \n    vec3 c = vec3(0.0, 0.0, 152.0); // ocean\n    if (alt > 0.01) {\n        c = vec3(173.0, 139.0, 75.0); // sand\n    }\n    if (alt > 0.1) {\n        c = vec3(195.0, 190.0, 142.0); // sand2\n        if (moist > 0.1) {\n            c = vec3(150.0, 152.0, 44.0); // grass1\n        }\n        if (moist > 0.2) {\n            c = vec3(48.0, 60.0, 31.0); // grass2\n        }\n        if (moist > 0.4) {\n            c = vec3(80.0, 96.0, 57.0); // grass3\n        }\n        if (moist > 0.6) {\n            c = vec3(72.0, 147.0, 79.0); // grass4\n        }\n        if (moist > 0.8) {\n            c = vec3(95.0, 137.0, 40.0); // grass5\n        }\n    }\n    if (alt > 0.8) {\n        if (moist < 0.6) {\n            c = vec3(254.0, 254.0, 254.0); // snow\n        } else {\n            c = vec3(181.0, 214.0, 223.0); // ice\n        }\n    }\n    \n    float adx = alt - noiseAlt(p - vec2(1.0, 0.0));\n    float ady = alt - noiseAlt(p - vec2(0.0, 1.0));\n    vec3 normal = normalize(vec3(adx, ady, 0.1));\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    float light_val = max(dot(normal, light), 0.0) + 0.4;\n    \n    fragColor = vec4(c/255.0*light_val, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 62], [64, 64, 86, 86, 955], [957, 957, 982, 982, 1427], [1429, 1429, 1456, 1456, 1728], [1731, 1731, 1786, 1786, 3226]], "test": "valid"}
{"id": "wdXSWs", "name": "earth and moon", "author": "ghost7", "description": "earth and moon. Feel free to use this as long as you credit me <3", "tags": ["earth"], "likes": 0, "viewed": 71, "published": "Public", "date": "1552509739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//noise (translated into glsl by ghost7 from Ken Perlin's Java implementation)\nint b(int N, int B) { return N>>B & 1; }\nint T[] = int[](0x15,0x38,0x32,0x2c,0x0d,0x13,0x07,0x2a);\nint A[] = int[](0,0,0);\n\nint b(int i, int j, int k, int B) { return T[b(i,B)<<2 | b(j,B)<<1 | b(k,B)]; }\n\nint shuffle(int i, int j, int k) {\n    return b(i,j,k,0) + b(j,k,i,1) + b(k,i,j,2) + b(i,j,k,3) +\n        b(j,k,i,4) + b(k,i,j,5) + b(i,j,k,6) + b(j,k,i,7) ;\n}\n\nfloat K(int a, vec3 uvw, vec3 ijk)\n{\n    float s = float(A[0]+A[1]+A[2])/6.0;\n    float x = uvw.x - float(A[0]) + s,\n        y = uvw.y - float(A[1]) + s,\n        z = uvw.z - float(A[2]) + s,\n        t = 0.6 - x * x - y * y - z * z;\n    int h = shuffle(int(ijk.x) + A[0], int(ijk.y) + A[1], int(ijk.z) + A[2]);\n    A[a]++;\n    if (t < 0.0)\n        return 0.0;\n    int b5 = h>>5 & 1, b4 = h>>4 & 1, b3 = h>>3 & 1, b2= h>>2 & 1, b = h & 3;\n    float p = b==1?x:b==2?y:z, q = b==1?y:b==2?z:x, r = b==1?z:b==2?x:y;\n    p = (b5==b3 ? -p : p); q = (b5==b4 ? -q : q); r = (b5!=(b4^b3) ? -r : r);\n    t *= t;\n    return 8.0 * t * t * (p + (b==0 ? q+r : b2==0 ? q : r));\n}\n    \nfloat noise(float x, float y, float z)\n{\n    float s = (x + y + z) / 3.0;  \n    vec3 ijk = vec3(int(floor(x+s)), int(floor(y+s)), int(floor(z+s)));\n    s = float(ijk.x + ijk.y + ijk.z) / 6.0;\n    vec3 uvw = vec3(x - float(ijk.x) + s, y - float(ijk.y) + s, z - float(ijk.z) + s);\n    A[0] = A[1] = A[2] = 0;\n    int hi = uvw.x >= uvw.z ? uvw.x >= uvw.y ? 0 : 1 : uvw.y >= uvw.z ? 1 : 2;\n    int lo = uvw.x <  uvw.z ? uvw.x <  uvw.y ? 0 : 1 : uvw.y <  uvw.z ? 1 : 2;\n    return K(hi, uvw, ijk) + K(3 - hi - lo, uvw, ijk) + K(lo, uvw, ijk) + K(0, uvw, ijk);\n}\n//endnoise\n\n\nfloat normalizedDistance(vec2 normalizedCoord, vec2 otherNormalizedCoord)\n{\n    vec2 coord = normalizedCoord * iResolution.xy;\n    vec2 otherCoord = otherNormalizedCoord * iResolution.xy;\n    return distance(coord, otherCoord);\n}\n\nvec3 circle(vec2 coord, vec2 center, float radius)\n{\n    return vec3(step(distance(coord, center), abs(radius)));\n}\n\nvec3 normalizedCircle(vec2 normalizedCoord, vec2 normalizedCenter, float normalizedRadius)\n{\n    vec2 coord = normalizedCoord * iResolution.xy;\n    vec2 center = normalizedCenter * iResolution.xy;\n    \n    //use the smaller of the two resolution lengths to de-normalize the radius\n    float radius = (iResolution.y < iResolution.x) ? normalizedRadius * iResolution.y : normalizedRadius * iResolution.x;\n    \n    return circle(coord, center, radius);\n}\n\nvec3 screenColor;\nvoid addImageToScreen(vec3 color)\n{\n    screenColor += color;\n}\n\n//TODO: Add layering system.\n//have an ordered list of layers. adding layer to the screen must subtracts all the layers below it.\n\n\nvec3 addColorToShape(vec3 shape, vec3 color)\n{\n    return vec3(shape.x * color.x, shape.y * color.y, shape.z * color.z);\n}\n\nvec3 getStars(vec2 normalizedCoord) {\n    return vec3(noise(normalizedCoord.x * 300.0 + iTime / 8.0, normalizedCoord.y * 300.0 + iTime / 8.0, 0.0));\n}\n\nvec3 getLighting(vec2 normalizedCoord) {\n    return vec3(smoothstep(0.0, 0.7, noise(normalizedCoord.x * 0.9 + iTime / 8.0 - 10.0, normalizedCoord.y * 0.9 + iTime / 8.0 - 10.0, 0.0)));\n}\n\nvoid drawEarth(vec2 normalizedCoord, vec2 centerOfTheEarth)\n{\n    //shape\n    vec3 circle = normalizedCircle(normalizedCoord, centerOfTheEarth, 0.2);\n    \n    //color\n    float noiseSize = 8.0;// + iIime\n    float noiseyPt = iTime / 8.0 - 1.0/noise(normalizedCoord.x * noiseSize, normalizedCoord.y * noiseSize, 0.0);\n   \tnoiseyPt = smoothstep(0.1, 0.5, noiseyPt);\n    vec3 color = sin(noiseyPt + vec3(-1, 1, 2));   \n    //remove stars from texture\n    color -= getStars(normalizedCoord);\n    \n    //image\n    vec3 image = addColorToShape(circle, color);\n    addImageToScreen(image);\n}\n\nvoid drawMoon(vec2 normalizedCoord, vec2 centerOfTheEarth)\n{\n    //shape\n    vec2 centerOfTheMoon = vec2(sin(iTime) * 0.25 + centerOfTheEarth.x, cos(iTime) * 0.4 + centerOfTheEarth.y);\n    vec3 circle = normalizedCircle(normalizedCoord, centerOfTheMoon, 0.1);\n    \n    //color\n    //vec3 color = vec3(sin(iTime), 1.0, 1.0);\n    \n    //color\n    float noiseSize = 8.0 + iTime;\n    float noiseyPt = iTime / 8.0 - 1.0/noise(normalizedCoord.x * noiseSize, normalizedCoord.y * noiseSize, 0.0);\n   \tnoiseyPt = smoothstep(0.1, 0.5, noiseyPt);\n    vec3 color = sin(noiseyPt + vec3(1, 1, 1));\n    //remove stars from texture\n    color -= getStars(normalizedCoord);\n    \n    //image\n    vec3 image = addColorToShape(circle, color);\n\taddImageToScreen(image); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 normalizedCoord = fragCoord.xy / iResolution.xy;\n    \n    screenColor = getStars(normalizedCoord);\n\tscreenColor += getLighting(normalizedCoord);\n    \n    //stationary\n    //vec2 centerOfTheEarth = vec2(0.4);\n    \n    //moving (orbits, yay!)\n    vec2 centerOfTheEarth = vec2(cos(iTime / 2.0) * 0.2 + 0.5, sin(iTime / 2.0) * 0.3 + 0.5);\n    \n    drawEarth(normalizedCoord, centerOfTheEarth);\n    drawMoon(normalizedCoord, centerOfTheEarth);\n    \n    fragColor = vec4(screenColor, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 79, 100, 100, 119], [203, 203, 238, 238, 282], [284, 284, 318, 318, 443], [445, 445, 481, 481, 1107], [1113, 1113, 1153, 1153, 1669], [1670, 1683, 1758, 1758, 1912], [1914, 1914, 1966, 1966, 2029], [2031, 2031, 2123, 2123, 2482], [2502, 2502, 2537, 2537, 2565], [2567, 2699, 2745, 2745, 2821], [2823, 2823, 2860, 2860, 2973], [2975, 2975, 3015, 3015, 3160], [3162, 3162, 3223, 3235, 3746], [3748, 3748, 3808, 3820, 4498], [4500, 4500, 4557, 4557, 5056]], "test": "error"}
{"id": "wdXXD2", "name": "Main Building of MSU", "author": "Nikita_Pimenov", "description": "Home work", "tags": ["mashgraph"], "likes": 1, "viewed": 120, "published": "Public", "date": "1552246722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 1000.0\n#define SMALL_DIST 0.01\n\nfloat DistSquare(vec3 p, vec4 square) {\n    float Dx, Dy, Dz;\n    if (p.x - square.x <= square.w) {\n        if (p.x - square.x >= -square.w) {\n            Dx = 0.0;\n        } else {\n            Dx = square.x - square.w - p.x;\n        }\n    } else {\n        Dx = p.x - square.x - square.w;\n    }\n    if (p.y - square.y <= square.w) {\n        if (p.y - square.y >= -square.w) {\n            Dy = 0.0;\n        } else {\n            Dy = square.y - square.w - p.y;\n        }\n    } else {\n        Dy = p.y - square.y - square.w;\n    }\n    if (p.z - square.z <= square.w) {\n        if (p.z - square.z >= -square.w) {\n            Dz = 0.0;\n        } else {\n            Dz = square.z - square.w - p.z;\n        }\n    } else {\n        Dz = p.z - square.z - square.w;\n    }\n    return sqrt(Dx * Dx+ Dy * Dy + Dz * Dz);\n}\nfloat DistRectangle(vec3 p, vec3 rectangle, vec3 size) {\n    float Dx, Dy, Dz;\n    if (p.x - rectangle.x <= size.x) {\n        if (p.x - rectangle.x >= -size.x) {\n            Dx = 0.0;\n        } else {\n            Dx = rectangle.x - size.x - p.x;\n        }\n    } else {\n        Dx = p.x - rectangle.x - size.x;\n    }\n    if (p.y - rectangle.y <= size.y) {\n        if (p.y - rectangle.y >= -size.y) {\n            Dy = 0.0;\n        } else {\n            Dy = rectangle.y - size.y - p.y;\n        }\n    } else {\n        Dy = p.y - rectangle.y - size.y;\n    }\n    if (p.z - rectangle.z <= size.z) {\n        if (p.z - rectangle.z >= -size.z) {\n            Dz = 0.0;\n        } else {\n            Dz = rectangle.z - size.z - p.z;\n        }\n    } else {\n        Dz = p.z - rectangle.z - size.z;\n    }\n    return sqrt(Dx * Dx + Dy * Dy + Dz * Dz);\n}\nfloat DistSphere(vec3 p, vec4 sphere) {\n    return length(p - sphere.xyz) - sphere.w;\n}\nfloat DistTorus(vec3 p, vec3 torus, vec2 size) {\n    vec3 v = torus - p;\n    vec2 q = vec2(length(v.xz) - size.x, v.y);\n\treturn length(q) - size.y;\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 torus1 = vec3(3.0, 0.4, 8.0);\n    vec2 SizeTorus1 = vec2(1.0, 0.1);\n    vec3 torus2 = vec3(-3.0, 0.4, 8.0);\n    vec2 SizeTorus2 = vec2(1.0, 0.1);\n    \n    vec4 sphere0 = vec4(0.0, 0.7, 7.0, 0.5); //sphere, which is forward\n    sphere0.xz += vec2(sin(4.0 * iTime), 4.0 * cos(iTime)); \n    \n    vec4 sphere1 = vec4(0.0, 11.0, 15.0, 0.3);//Main building of Moscow State University\n    vec3 rectangle1 = vec3(0.0, 2.4, 15);\n    vec3 SizeRectangle1 = vec3(1.2, 2.4, 1.2);\n    vec4 square2 = vec4(0.0, 5.6, 15.0, 0.9);\n    vec4 square3 = vec4(0.0, 7.2, 15.0, 0.7);\n    vec3 rectangle2 = vec3(0.0, 9.3, 15.0);\n    vec3 SizeRectangle2 = vec3(0.2, 1.4, 0.2);\n    \n    vec3 rectangle3 = vec3(2.6, 1.2, 15.0);\n    vec3 SizeRectangle3 = vec3(1.3, 1.2, 1.0);\n    vec3 rectangle4 = vec3(4.5, 1.2, 15.0);\n    vec3 SizeRectangle4 = vec3(0.6, 1.2, 3.6);\n    vec4 square4 = vec4(4.5, 2.9, 12.0, 0.5);\n    vec4 sphere2 = vec4(4.5, 3.7, 12.0, 0.3);\n    vec4 square5 = vec4(4.5, 2.9, 18.0, 0.5);\n    vec4 sphere3 = vec4(4.5, 3.7, 18.0, 0.3);\n    \n    vec3 rectangle5 = vec3(-2.6, 1.2, 15.0);\n    vec3 SizeRectangle5 = vec3(1.3, 1.2, 1.0);\n    vec3 rectangle6 = vec3(-4.5, 1.2, 15.0);\n    vec3 SizeRectangle6 = vec3(0.6, 1.2, 3.6);\n    vec4 square6 = vec4(-4.5, 2.9, 12.0, 0.5);\n    vec4 sphere4 = vec4(-4.5, 3.7, 12.0, 0.3);\n    vec4 square7 = vec4(-4.5, 2.9, 18.0, 0.5);\n    vec4 sphere5 = vec4(-4.5, 3.7, 18.0, 0.3);\n    float DistPlane = p.y;\n    float Torus = min(DistTorus(p, torus1, SizeTorus1),\n                    DistTorus(p, torus2, SizeTorus2));\n    float Sphere = min(DistSphere(p, sphere1),\n                   min(DistSphere(p, sphere2),\n                   min(DistSphere(p, sphere3),\n                   min(DistSphere(p, sphere4),\n                   min(DistSphere(p, sphere5),\n                   DistSphere(p, sphere0))))));\n    float Square = min(DistSquare(p, square2),\n                   min(DistSquare(p, square3),\n                   min(DistSquare(p, square4),\n                   min(DistSquare(p, square5),\n                   min(DistSquare(p, square6),\n                   DistSquare(p, square7))))));\n    float Rectangle = min(DistRectangle(p, rectangle1, SizeRectangle1),\n                      min(DistRectangle(p, rectangle2, SizeRectangle2),\n                      min(DistRectangle(p, rectangle3, SizeRectangle3),\n                      min(DistRectangle(p, rectangle4, SizeRectangle4),\n                      min(DistRectangle(p, rectangle5, SizeRectangle5),\n                      DistRectangle(p, rectangle6, SizeRectangle6))))));\n    float minimum = min(Torus, min(Sphere,\n                    min(Square, min(Square, \n                    min(Rectangle, DistPlane)))));\n    if (minimum == Torus) {\n        return vec4(0.0, 0.0, 1.0, Torus);\n    }\n    if (minimum == Sphere) {\n        return vec4(1.0, 1.0, 0.0, Sphere);\n    }\n    if (minimum == Square) {\n        return vec4(1.0, 1.0, 1.0, Square);\n    }\n    if (minimum == Rectangle) {\n        return vec4(1.0, 0.0, 0.0, Rectangle);\n    }\n    if (minimum == DistPlane) {\n        return vec4(0.2, 0.817, 0.2, DistPlane);\n    }\n    return vec4(MAX_DIST, 0.0, 0.0, 0.0);\n}\nfloat RayMarch (vec3 RayOri, vec3 RayDi) {\n    float DistOrig = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = RayOri + DistOrig * RayDi;\n        float dist = GetDist(p).w;\n        DistOrig += dist;\n        if (dist < SMALL_DIST || DistOrig > MAX_DIST) break;\n    }\n    return DistOrig;\n}\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    float d = GetDist(p).w;\n    vec3 norm = d - vec3(\n        GetDist(p - e.xyy).w,\n        GetDist(p - e.yxy).w,\n        GetDist(p - e.yyx).w);\n    \n    return normalize(norm); \n}\nvec3 GetColour(vec3 p) {\n    vec3 LightPos[2];\n    LightPos[0] = vec3(0, 15, 12);\n    LightPos[1] = vec3(0, 15, 12);\n    LightPos[0].xz += vec2(sin(iTime), cos(iTime)) * 8.0;\n    LightPos[1].xz += vec2(sin(iTime + 3.14 * 0.2), cos(iTime + 3.14 * 0.2)) * 8.0;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 2; ++i) {\n        vec3 LightDi = normalize(LightPos[i] - p);\n        vec3 norm = GetNormal(p);\n        vec3 e = normalize(-p);\n        vec3 refl = normalize(-reflect(LightDi, norm));\n        \n        vec3 amb = GetDist(p).xyz * 0.3;\n        vec3 dif = amb * 0.8 * max(dot(norm, LightDi), 0.0);\n        dif = clamp(dif, 0.0, 1.0);\n        vec3 spec = vec3(1.0) * pow(max(dot(refl, e), 0.0), 60.0);\n        spec = clamp(spec, 0.0, 1.0);\n        col += 0.5 * (amb + dif + spec);\n    }\n    float light = 1.0;\n    float d = RayMarch(p + GetNormal(p) * SMALL_DIST * 2.0, normalize(LightPos[0] - p));\n    if (d < length(LightPos[0] - p)) {\n        col *= 0.7;\n    }\n    d = RayMarch(p + GetNormal(p) * SMALL_DIST * 2.0, normalize(LightPos[1] - p));\n    if (d < length(LightPos[1] - p)) {\n        col *= 0.7;\n    }\n    /*float fog = clamp(length(p) / 17.0, 0.0, 1.0); \n\tcol = col * (1.0 - fog) + fog * vec3(0.7, 0.7, 0.7); */\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(1.0, 1.0, 0.0);\n    \n    vec3 RayOri = vec3(0, 1, 0);\n    uv.y = uv.y + 0.2;\n    vec3 RayDi = normalize(vec3(uv.x, uv.y, 1));\n    float d = RayMarch(RayOri, RayDi);\n    vec3 p = RayOri + RayDi * d;\n    col = GetColour(p);\n    \n    float red;\n    float green;\n\tif (d > MAX_DIST) {\n        red = -1.0 * uv.y + 1.0;\n        green = -0.35 * uv.y + 1.0;\n        col = vec3(red, green, 1.0);\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXXD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 111, 111, 879], [880, 880, 936, 936, 1717], [1718, 1718, 1757, 1757, 1805], [1806, 1806, 1854, 1854, 1955], [1957, 1957, 1979, 1979, 5113], [5114, 5114, 5156, 5156, 5419], [5420, 5420, 5444, 5444, 5653], [5654, 5654, 5678, 5678, 6898], [6899, 6899, 6954, 6954, 7471]], "test": "valid"}
{"id": "WdXXz2", "name": "ShaderShader", "author": "overlord", "description": "3 simple sphere", "tags": ["lighttrace"], "likes": 2, "viewed": 245, "published": "Public API", "date": "1552060135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 background_color = vec3(0.5, 0.5, 0.5);\nconst float eps = 1e-3;\n\n//Light type\n//1 - ambient\n//2 - point\n//3 - directional\nstruct Light {\n    vec3 position;\n    vec3 direction;\n    float intensity;\n    vec3 color;\n\tint type;\n};\n\nstruct Ray {\n\tvec3 position;\n    vec3 direction;\n};\n\nstruct Material {\n\tvec3 color;\n    float reflective;\n    float specular;\n};\n\nstruct Sphere {\n\tfloat radius;\n\tvec3 position;\n\tMaterial material;\n};\n\nstruct ClosestIntersection {\n\tSphere sphere;\n    float t;\n};\n\nvec3 CanvasToViewport(vec2 uv) {\n    uv /= iResolution.xy;\n    uv -= vec2(0.5);\n\tuv.x *= iResolution.x / iResolution.y;\n    return vec3(uv.x, uv.y, 1.0);\n}\n\nvec3 ReflectRay(vec3 R, vec3 N) {\n    return 2.0 * N * dot(N, R) - R;\n}\n\nfloat IntersectRaySphere(Ray ray, Sphere sphere, float t_min, float t_max) {\n\tvec3 O = ray.position;\n    vec3 D = ray.direction;\n    vec3 C = sphere.position;\n    float r = sphere.radius;\n    vec3 OC = O - C;\n\n    float k1 = dot(D, D);\n    float k2 = 2.0*dot(OC, D);\n    float k3 = dot(OC, OC) - r*r;\n\n    float discriminant = k2*k2 - 4.0*k1*k3;\n    if (discriminant < 0.0)\n        return 1000000.0;\n\n    float t1 = (-k2 + sqrt(discriminant)) / (2.0*k1);\n    float t2 = (-k2 - sqrt(discriminant)) / (2.0*k1);\n\n    if ((t1 <= t2) && (t1 >= t_min) && (t1 <= t_max))\n        return t1;\n    if ((t2 < t1) && (t2 >= t_min) && (t2 <= t_max))\n        return t2;\n\treturn 1000000.0;\n}\n\nClosestIntersection closestIntersection(Ray ray, float t_min, float t_max) {\n\n    const int spheres_num = 4;\n    Sphere spheres[spheres_num];\n    spheres[0] = Sphere(1.0\t  , vec3(0.0, \t  -1.0, 3.0), Material(vec3(1.0, 0.0, 0.0), 0.2, 500.0));\n    spheres[1] = Sphere(1.0\t  , vec3(2.0 , \t   0.0, 4.0), Material(vec3(0.0, 0.0, 1.0), 0.3, 500.0));\n    spheres[2] = Sphere(1.0\t  , vec3(-2.0, \t   0.0, 4.0), Material(vec3(0.0, 1.0, 0.0), 0.4, 10.0));\n\tspheres[3] = Sphere(5000.0, vec3(0.0 , -5001.0, 0.0), Material(vec3(1.0, 1.0, 0.0), 0.0, 1000.0));\n\n    float closest_t = 1000000.0;\n    Sphere closest_sphere = Sphere(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\n\n    for (int i = 0; i < spheres_num; i++) {\n        float t = IntersectRaySphere(ray, spheres[i], t_min, t_max);\n            if (t < closest_t) {\n            closest_t = t;\n            closest_sphere = spheres[i];\n        }\n    }\n    return ClosestIntersection(closest_sphere, closest_t);\n}\n\nfloat ComputeLighting(vec3 P, vec3 N, vec3 V, float s) {\n    const int light_num = 3;\n    Light light[light_num];\n    light[0] = Light(vec3(0.0, 0.0, 0.0), vec3( 0.0,  0.0,  0.0), 0.2, vec3(1.0, 1.0, 1.0), 1);\n    light[1] = Light(vec3(2.0, 1.0, 0.0), vec3( 0.0,  0.0,  0.0), 0.6, vec3(1.0, 1.0, 1.0), 2);\n    light[2] = Light(vec3(0.0, 0.0, 0.0), vec3( 1.0,  4.0,  4.0), 0.2, vec3(1.0, 1.0, 1.0), 3);\n\n    float i = 0.0;\n    for (int j = 0; j < light_num; j++) {\n        if (light[j].type == 1) {\n            i += light[j].intensity;\n        } else {\n            vec3 L;\n            if (light[j].type == 2)\n                L = light[j].position - P;\n            else\n                L = light[j].direction;\n\n            float n_dot_l = dot(N, L);\n\n            ClosestIntersection temp = closestIntersection(Ray(P, L), eps, 100.0);\n            if (temp.sphere.radius != 0.0)\n                continue;\n\n            if (n_dot_l > 0.0)\n                i += light[j].intensity* n_dot_l/(length(N)*length(L));\n\n            if (s != -1.0) {\n                vec3 R = 2.0*N*dot(N, L) - L;\n                float r_dot_v = dot(R, V);\n                if (r_dot_v > 0.0)\n                    i += light[j].intensity*pow(r_dot_v/(length(R)*length(V)), s);\n            }\n        }\n    }\n    return i;\n}\n\nvec3 TraceRay(Ray ray, float t_min, float t_max, int depth) {\n\n    ClosestIntersection clos_inter = closestIntersection(ray, t_min, t_max);\n\n    if (clos_inter.sphere.radius == 0.0)\n        return background_color;\n\n    vec3 P = ray.position + clos_inter.t*ray.direction;\n    vec3 N = P - clos_inter.sphere.position;\n    N = N / length(N);\n    vec3 oppositeD = -ray.direction;\n    vec3 local_color = clos_inter.sphere.material.color*ComputeLighting(P, N, oppositeD, clos_inter.sphere.material.specular);\n\n    //return local_color;\n\n    float r = clos_inter.sphere.material.reflective;\n    if (r <= 0.0)\n        return local_color;\n\n    vec3 R = ReflectRay(oppositeD, N);\n    ClosestIntersection refl = closestIntersection(Ray(P, R), eps, 1000000.0);\n\n    return local_color*(1.0 - r) + refl.sphere.material.color*r;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n\n    vec3 xyz = CanvasToViewport(uv);\n\n    Ray ray = Ray(vec3(0.0, 0.0, 0.0-cos(iTime)), xyz);\n    vec3 color = TraceRay(ray, 1.0, 100.0, 5);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXXz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 502, 534, 534, 657], [659, 659, 692, 692, 730], [732, 732, 808, 808, 1407], [1409, 1409, 1485, 1485, 2363], [2365, 2365, 2421, 2421, 3652], [3654, 3654, 3715, 3715, 4472], [4474, 4474, 4531, 4531, 4735]], "test": "error"}
{"id": "ws2GDt", "name": "hello pathtracer!", "author": "danim", "description": "Pathtracer implementation from \"raytracing in a weekend\" book.", "tags": ["raytracing", "pathtracer"], "likes": 1, "viewed": 271, "published": "Public API", "date": "1552247706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// chapter's of the book\n#define CH_3 0\n#define CH_4 0\n#define CH_5 0\n#define CH_6 0\n#define CH_7 0\n#define CH_8 0\n#define CH_9 0\n#define CH_10 0\n#define CH_11 1\n#define CH_12 0 // careful with this one\n\n#if CH_4\n\nconst int nSP = 1;\n\nvec4[] sp_defs = vec4[1]\n(\n    vec4( 0.,0.,-1., 0.5 )\n);\n\n#elif CH_5\n\nconst int nSP = 2;\n\nvec4[] sp_defs = vec4[2]\n(\n    vec4( 0.,0.,-1., 0.5 ),\n    vec4( 0., -100.5, -1, 100 )\n);\n\n#elif CH_6\n\nconst int nSP = 2;\n\nvec4[] sp_defs = vec4[2]\n(\n    vec4( 0.,0.,-1., 0.5 ),\n    vec4( 0., -100.5, -1, 100 )\n);\n\n#elif CH_7\n\nconst int nSP = 2;\n\nvec4[] sp_defs = vec4[2]\n(\n    vec4( 0.,0.,-1., 0.5 ),\n    vec4( 0., -100.5, -1, 100 )\n);\n\n#elif CH_8\n\nconst int nSP = 4;\n\nvec4[] sp_defs = vec4[4]\n(\n    vec4( 0.,0.,-1., 0.5 ),\n    vec4( 0., -100.5, -1, 100 ),\n    vec4( 1., 0., -1., 0.5 ),\n    vec4( -1., 0., -1., 0.5 )\n);\n\nvec3[] albedos = vec3[4]\n(\n    vec3( 0.8, 0.3, 0.3 ),\n    vec3( 0.8, 0.8, 0. ),\n    vec3( 0.8, 0.6, 0.2 ),\n    vec3( 0.8, 0.8, 0.8 )\n);\n\nvec2[] m_r = vec2[4] // metallic and roughness factor\n(\n    vec2( 0., 1. ),\n    vec2( 0., 1. ),\n    vec2( 1., 1. ),\n    vec2( 1., 0.3 )\n);\n\n#elif CH_9 || CH_10 || CH_11\n\n#define N_SP 5\n\nconst int nSP = N_SP;\n\n\nvec4[] sp_defs = vec4[N_SP]\n(\n    vec4( 0.,0.,-1., 0.5 ),\n    vec4( 0., -100.5, -1, 100 ),\n    vec4( 1., 0., -1., 0.5 ),\n    vec4( -1., 0., -1., 0.5 ),\n    vec4( -1., 0., -1., -0.49 )\n);\n\nvec3[] albedos = vec3[N_SP]\n(\n    vec3( 0.8, 0.3, 0.3 ),\n    vec3( 0.8, 0.8, 0. ),\n    vec3( 0.8, 0.6, 0.2 ),\n    vec3( 1., 1., 1. ),\n    vec3( 1., 1., 1. )\n);\n\nvec3[] m_r_i = vec3[N_SP] // metallic, roughness, refraction factor\n(\n    vec3( 0., 1., 0. ),\n    vec3( 0., 1., 0. ),\n    vec3( 1., 1., 0. ),\n    vec3( 1., 0., 1.5 ),\n    vec3( 1., 0., 1.5 )\n);\n\n#elif CH_12\n\n#define N_SP 485\nconst int nSP = N_SP;\n\nvec4[] sp_defs = vec4[N_SP] (\nvec4( 0, -1000, 0, 1000),\nvec4( -10.9625, 0.2, -10.9991, 0.2),\nvec4( -10.2518, 0.2, -9.79014, 0.2),\nvec4( -10.2116, 0.2, -8.73162, 0.2),\nvec4( -10.2663, 0.2, -7.9309, 0.2),\nvec4( -10.389, 0.2, -6.65946, 0.2),\nvec4( -10.553, 0.2, -5.83212, 0.2),\nvec4( -10.5115, 0.2, -4.61495, 0.2),\nvec4( -10.9261, 0.2, -3.69914, 0.2),\nvec4( -10.3914, 0.2, -2.93316, 0.2),\nvec4( -10.1318, 0.2, -1.47983, 0.2),\nvec4( -10.1406, 0.2, -0.269945, 0.2),\nvec4( -10.8263, 0.2, 0.000452506, 0.2),\nvec4( -10.5266, 0.2, 1.76802, 0.2),\nvec4( -10.3188, 0.2, 2.86948, 0.2),\nvec4( -10.8711, 0.2, 3.71997, 0.2),\nvec4( -10.6177, 0.2, 4.14673, 0.2),\nvec4( -10.1516, 0.2, 5.27791, 0.2),\nvec4( -10.1261, 0.2, 6.63187, 0.2),\nvec4( -10.6596, 0.2, 7.26673, 0.2),\nvec4( -10.5271, 0.2, 8.19895, 0.2),\nvec4( -10.4707, 0.2, 9.41113, 0.2),\nvec4( -10.8131, 0.2, 10.1587, 0.2),\nvec4( -9.70359, 0.2, -10.422, 0.2),\nvec4( -9.6265, 0.2, -9.45067, 0.2),\nvec4( -9.74935, 0.2, -8.8372, 0.2),\nvec4( -9.72287, 0.2, -7.83669, 0.2),\nvec4( -9.15791, 0.2, -6.45632, 0.2),\nvec4( -9.81139, 0.2, -5.95509, 0.2),\nvec4( -9.74304, 0.2, -4.96953, 0.2),\nvec4( -9.23989, 0.2, -3.38197, 0.2),\nvec4( -9.40414, 0.2, -2.20195, 0.2),\nvec4( -9.41138, 0.2, -1.28922, 0.2),\nvec4( -9.90921, 0.2, -0.579172, 0.2),\nvec4( -9.96583, 0.2, 0.0567724, 0.2),\nvec4( -9.41531, 0.2, 1.43844, 0.2),\nvec4( -9.33318, 0.2, 2.8197, 0.2),\nvec4( -9.56824, 0.2, 3.38343, 0.2),\nvec4( -9.76214, 0.2, 4.02629, 0.2),\nvec4( -9.86083, 0.2, 5.07261, 0.2),\nvec4( -9.76958, 0.2, 6.05929, 0.2),\nvec4( -9.21892, 0.2, 7.36462, 0.2),\nvec4( -9.5786, 0.2, 8.51864, 0.2),\nvec4( -9.19623, 0.2, 9.1624, 0.2),\nvec4( -9.19211, 0.2, 10.4524, 0.2),\nvec4( -8.59047, 0.2, -10.7648, 0.2),\nvec4( -8.28414, 0.2, -9.92377, 0.2),\nvec4( -8.91142, 0.2, -8.15943, 0.2),\nvec4( -8.31284, 0.2, -7.78363, 0.2),\nvec4( -8.54314, 0.2, -6.52597, 0.2),\nvec4( -8.19335, 0.2, -5.89567, 0.2),\nvec4( -8.59282, 0.2, -4.16551, 0.2),\nvec4( -8.63245, 0.2, -3.96524, 0.2),\nvec4( -8.54919, 0.2, -2.96169, 0.2),\nvec4( -8.16882, 0.2, -1.22441, 0.2),\nvec4( -8.46756, 0.2, -0.611504, 0.2),\nvec4( -8.48172, 0.2, 0.0533377, 0.2),\nvec4( -8.97138, 0.2, 1.00141, 0.2),\nvec4( -8.62557, 0.2, 2.09445, 0.2),\nvec4( -8.38198, 0.2, 3.37908, 0.2),\nvec4( -8.49897, 0.2, 4.15638, 0.2),\nvec4( -8.38174, 0.2, 5.67744, 0.2),\nvec4( -8.63284, 0.2, 6.01237, 0.2),\nvec4( -8.64016, 0.2, 7.33704, 0.2),\nvec4( -8.33998, 0.2, 8.11074, 0.2),\nvec4( -8.60065, 0.2, 9.81104, 0.2),\nvec4( -8.35842, 0.2, 10.3309, 0.2),\nvec4( -7.52785, 0.2, -10.2721, 0.2),\nvec4( -7.57464, 0.2, -9.86644, 0.2),\nvec4( -7.80492, 0.2, -8.56937, 0.2),\nvec4( -7.27596, 0.2, -7.76148, 0.2),\nvec4( -7.43262, 0.2, -6.68864, 0.2),\nvec4( -7.35569, 0.2, -5.5677, 0.2),\nvec4( -7.2247, 0.2, -4.45407, 0.2),\nvec4( -7.37631, 0.2, -3.90581, 0.2),\nvec4( -7.47847, 0.2, -2.4532, 0.2),\nvec4( -7.97979, 0.2, -1.95354, 0.2),\nvec4( -7.38158, 0.2, -0.370212, 0.2),\nvec4( -7.48682, 0.2, 0.371153, 0.2),\nvec4( -7.44422, 0.2, 1.2097, 0.2),\nvec4( -7.37814, 0.2, 2.39873, 0.2),\nvec4( -7.21505, 0.2, 3.5994, 0.2),\nvec4( -7.71604, 0.2, 4.80635, 0.2),\nvec4( -7.48045, 0.2, 5.66946, 0.2),\nvec4( -7.16276, 0.2, 6.7236, 0.2),\nvec4( -7.1165, 0.2, 7.49758, 0.2),\nvec4( -7.43525, 0.2, 8.47913, 0.2),\nvec4( -7.30335, 0.2, 9.43176, 0.2),\nvec4( -7.63567, 0.2, 10.2826, 0.2),\nvec4( -6.52003, 0.2, -10.5587, 0.2),\nvec4( -6.14888, 0.2, -9.21857, 0.2),\nvec4( -6.94473, 0.2, -8.83199, 0.2),\nvec4( -6.23591, 0.2, -7.77644, 0.2),\nvec4( -6.36056, 0.2, -6.58803, 0.2),\nvec4( -6.45229, 0.2, -5.75367, 0.2),\nvec4( -6.61393, 0.2, -4.81829, 0.2),\nvec4( -6.63099, 0.2, -3.15441, 0.2),\nvec4( -6.47146, 0.2, -2.50693, 0.2),\nvec4( -6.60398, 0.2, -1.91842, 0.2),\nvec4( -6.14923, 0.2, -0.650811, 0.2),\nvec4( -6.19884, 0.2, 0.827709, 0.2),\nvec4( -6.43945, 0.2, 1.26362, 0.2),\nvec4( -6.11276, 0.2, 2.81068, 0.2),\nvec4( -6.78825, 0.2, 3.6567, 0.2),\nvec4( -6.92523, 0.2, 4.67414, 0.2),\nvec4( -6.25392, 0.2, 5.62834, 0.2),\nvec4( -6.47565, 0.2, 6.12503, 0.2),\nvec4( -6.91936, 0.2, 7.08973, 0.2),\nvec4( -6.73612, 0.2, 8.66211, 0.2),\nvec4( -6.93017, 0.2, 9.04144, 0.2),\nvec4( -6.16948, 0.2, 10.4849, 0.2),\nvec4( -5.88568, 0.2, -10.5642, 0.2),\nvec4( -5.5771, 0.2, -9.58814, 0.2),\nvec4( -5.3469, 0.2, -8.91876, 0.2),\nvec4( -5.76134, 0.2, -7.77458, 0.2),\nvec4( -5.56789, 0.2, -6.76519, 0.2),\nvec4( -5.60781, 0.2, -5.98273, 0.2),\nvec4( -5.94903, 0.2, -4.23858, 0.2),\nvec4( -5.53401, 0.2, -3.71533, 0.2),\nvec4( -5.4002, 0.2, -2.17463, 0.2),\nvec4( -5.99331, 0.2, -1.42108, 0.2),\nvec4( -5.10146, 0.2, -0.837913, 0.2),\nvec4( -5.78101, 0.2, 0.0823501, 0.2),\nvec4( -5.51996, 0.2, 1.54129, 0.2),\nvec4( -5.80676, 0.2, 2.51375, 0.2),\nvec4( -5.71551, 0.2, 3.5312, 0.2),\nvec4( -5.37301, 0.2, 4.17595, 0.2),\nvec4( -5.22314, 0.2, 5.4684, 0.2),\nvec4( -5.80502, 0.2, 6.45391, 0.2),\nvec4( -5.87699, 0.2, 7.52847, 0.2),\nvec4( -5.25213, 0.2, 8.4579, 0.2),\nvec4( -5.97923, 0.2, 9.42443, 0.2),\nvec4( -5.88144, 0.2, 10.1907, 0.2),\nvec4( -4.20197, 0.2, -10.7567, 0.2),\nvec4( -4.8071, 0.2, -9.16919, 0.2),\nvec4( -4.50533, 0.2, -8.58725, 0.2),\nvec4( -4.42097, 0.2, -7.53857, 0.2),\nvec4( -4.11937, 0.2, -6.70433, 0.2),\nvec4( -4.6188, 0.2, -5.53679, 0.2),\nvec4( -4.66125, 0.2, -4.99396, 0.2),\nvec4( -4.15022, 0.2, -3.65734, 0.2),\nvec4( -4.68036, 0.2, -2.42684, 0.2),\nvec4( -4.53593, 0.2, -1.76469, 0.2),\nvec4( -4.36749, 0.2, -0.914268, 0.2),\nvec4( -4.74533, 0.2, 0.0840712, 0.2),\nvec4( -4.5425, 0.2, 1.77961, 0.2),\nvec4( -4.25977, 0.2, 2.51225, 0.2),\nvec4( -4.77312, 0.2, 3.85528, 0.2),\nvec4( -4.58346, 0.2, 4.59341, 0.2),\nvec4( -4.53292, 0.2, 5.88795, 0.2),\nvec4( -4.31823, 0.2, 6.14144, 0.2),\nvec4( -4.47067, 0.2, 7.11616, 0.2),\nvec4( -4.72285, 0.2, 8.83456, 0.2),\nvec4( -4.69692, 0.2, 9.49559, 0.2),\nvec4( -4.76025, 0.2, 10.3445, 0.2),\nvec4( -3.14536, 0.2, -10.2662, 0.2),\nvec4( -3.18215, 0.2, -9.56385, 0.2),\nvec4( -3.95669, 0.2, -8.73237, 0.2),\nvec4( -3.64983, 0.2, -7.33464, 0.2),\nvec4( -3.89856, 0.2, -6.53777, 0.2),\nvec4( -3.84976, 0.2, -5.76108, 0.2),\nvec4( -3.43314, 0.2, -4.60598, 0.2),\nvec4( -3.79916, 0.2, -3.20827, 0.2),\nvec4( -3.95943, 0.2, -2.98675, 0.2),\nvec4( -3.2566, 0.2, -1.67146, 0.2),\nvec4( -3.7438, 0.2, -0.48378, 0.2),\nvec4( -3.84404, 0.2, 0.361758, 0.2),\nvec4( -3.85337, 0.2, 1.86359, 0.2),\nvec4( -3.39244, 0.2, 2.06584, 0.2),\nvec4( -3.90431, 0.2, 3.82692, 0.2),\nvec4( -3.23448, 0.2, 4.72122, 0.2),\nvec4( -3.26696, 0.2, 5.28203, 0.2),\nvec4( -3.36371, 0.2, 6.39125, 0.2),\nvec4( -3.4634, 0.2, 7.23164, 0.2),\nvec4( -3.93721, 0.2, 8.29241, 0.2),\nvec4( -3.58233, 0.2, 9.28244, 0.2),\nvec4( -3.69753, 0.2, 10.7399, 0.2),\nvec4( -2.12805, 0.2, -10.2609, 0.2),\nvec4( -2.59836, 0.2, -9.48858, 0.2),\nvec4( -2.29754, 0.2, -8.12558, 0.2),\nvec4( -2.81247, 0.2, -7.89729, 0.2),\nvec4( -2.73398, 0.2, -6.10468, 0.2),\nvec4( -2.70374, 0.2, -5.31451, 0.2),\nvec4( -2.10664, 0.2, -4.30687, 0.2),\nvec4( -2.76763, 0.2, -3.18854, 0.2),\nvec4( -2.6097, 0.2, -2.7557, 0.2),\nvec4( -2.44391, 0.2, -1.95085, 0.2),\nvec4( -2.81676, 0.2, -0.753757, 0.2),\nvec4( -2.15842, 0.2, 0.351271, 0.2),\nvec4( -2.2325, 0.2, 1.02287, 0.2),\nvec4( -2.15031, 0.2, 2.7882, 0.2),\nvec4( -2.84867, 0.2, 3.19318, 0.2),\nvec4( -2.45848, 0.2, 4.51614, 0.2),\nvec4( -2.25633, 0.2, 5.78889, 0.2),\nvec4( -2.78467, 0.2, 6.5075, 0.2),\nvec4( -2.75543, 0.2, 7.74521, 0.2),\nvec4( -2.49543, 0.2, 8.12296, 0.2),\nvec4( -2.54047, 0.2, 9.45484, 0.2),\nvec4( -2.82866, 0.2, 10.7366, 0.2),\nvec4( -1.61306, 0.2, -10.9699, 0.2),\nvec4( -1.48901, 0.2, -9.17104, 0.2),\nvec4( -1.52351, 0.2, -8.47281, 0.2),\nvec4( -1.65314, 0.2, -7.37369, 0.2),\nvec4( -1.24193, 0.2, -6.26093, 0.2),\nvec4( -1.57856, 0.2, -5.36988, 0.2),\nvec4( -1.1649, 0.2, -4.69392, 0.2),\nvec4( -1.64355, 0.2, -3.23992, 0.2),\nvec4( -1.36782, 0.2, -2.58386, 0.2),\nvec4( -1.44905, 0.2, -1.86986, 0.2),\nvec4( -1.46226, 0.2, -0.465248, 0.2),\nvec4( -1.32646, 0.2, 0.503009, 0.2),\nvec4( -1.70459, 0.2, 1.89417, 0.2),\nvec4( -1.56933, 0.2, 2.50593, 0.2),\nvec4( -1.94181, 0.2, 3.59254, 0.2),\nvec4( -1.95176, 0.2, 4.84017, 0.2),\nvec4( -1.31837, 0.2, 5.58298, 0.2),\nvec4( -1.28807, 0.2, 6.40885, 0.2),\nvec4( -1.27145, 0.2, 7.31507, 0.2),\nvec4( -1.37907, 0.2, 8.2902, 0.2),\nvec4( -1.28272, 0.2, 9.3333, 0.2),\nvec4( -1.71686, 0.2, 10.7568, 0.2),\nvec4( -0.614621, 0.2, -10.7559, 0.2),\nvec4( -0.134218, 0.2, -9.26429, 0.2),\nvec4( -0.171595, 0.2, -8.72891, 0.2),\nvec4( -0.262218, 0.2, -7.43301, 0.2),\nvec4( -0.637177, 0.2, -6.39981, 0.2),\nvec4( -0.37833, 0.2, -5.19741, 0.2),\nvec4( -0.190381, 0.2, -4.54035, 0.2),\nvec4( -0.49754, 0.2, -3.91819, 0.2),\nvec4( -0.661557, 0.2, -2.82712, 0.2),\nvec4( -0.113126, 0.2, -1.60223, 0.2),\nvec4( -0.297972, 0.2, -0.903513, 0.2),\nvec4( -0.346252, 0.2, 0.514309, 0.2),\nvec4( -0.768702, 0.2, 1.13014, 0.2),\nvec4( -0.152378, 0.2, 2.58358, 0.2),\nvec4( -0.835537, 0.2, 3.69193, 0.2),\nvec4( -0.194827, 0.2, 4.51844, 0.2),\nvec4( -0.971382, 0.2, 5.40187, 0.2),\nvec4( -0.523792, 0.2, 6.74939, 0.2),\nvec4( -0.309375, 0.2, 7.58925, 0.2),\nvec4( -0.58636, 0.2, 8.20387, 0.2),\nvec4( -0.945238, 0.2, 9.86934, 0.2),\nvec4( -0.611926, 0.2, 10.8351, 0.2),\nvec4( 0.804082, 0.2, -10.1925, 0.2),\nvec4( 0.524149, 0.2, -9.88448, 0.2),\nvec4( 0.446149, 0.2, -8.19254, 0.2),\nvec4( 0.700837, 0.2, -7.32747, 0.2),\nvec4( 0.747016, 0.2, -6.50389, 0.2),\nvec4( 0.0923239, 0.2, -5.80895, 0.2),\nvec4( 0.735807, 0.2, -4.8763, 0.2),\nvec4( 0.0493524, 0.2, -3.21338, 0.2),\nvec4( 0.22856, 0.2, -2.94815, 0.2),\nvec4( 0.702863, 0.2, -1.45214, 0.2),\nvec4( 0.0866998, 0.2, -0.940212, 0.2),\nvec4( 0.862663, 0.2, 0.10744, 0.2),\nvec4( 0.29213, 0.2, 1.00433, 0.2),\nvec4( 0.0973795, 0.2, 2.64241, 0.2),\nvec4( 0.327865, 0.2, 3.05901, 0.2),\nvec4( 0.394942, 0.2, 4.83079, 0.2),\nvec4( 0.136978, 0.2, 5.03945, 0.2),\nvec4( 0.260317, 0.2, 6.44927, 0.2),\nvec4( 0.377964, 0.2, 7.391, 0.2),\nvec4( 0.0188821, 0.2, 8.06949, 0.2),\nvec4( 0.423936, 0.2, 9.60373, 0.2),\nvec4( 0.0292886, 0.2, 10.8281, 0.2),\nvec4( 1.41418, 0.2, -10.1817, 0.2),\nvec4( 1.13487, 0.2, -9.97217, 0.2),\nvec4( 1.35785, 0.2, -8.42396, 0.2),\nvec4( 1.05799, 0.2, -7.94608, 0.2),\nvec4( 1.85365, 0.2, -6.91041, 0.2),\nvec4( 1.46496, 0.2, -5.94034, 0.2),\nvec4( 1.56808, 0.2, -4.14954, 0.2),\nvec4( 1.75263, 0.2, -3.14999, 0.2),\nvec4( 1.23115, 0.2, -2.90814, 0.2),\nvec4( 1.80889, 0.2, -1.96515, 0.2),\nvec4( 1.87693, 0.2, -0.962202, 0.2),\nvec4( 1.29771, 0.2, 0.326903, 0.2),\nvec4( 1.24627, 0.2, 1.74389, 0.2),\nvec4( 1.87683, 0.2, 2.599, 0.2),\nvec4( 1.8755, 0.2, 3.71237, 0.2),\nvec4( 1.31129, 0.2, 4.27777, 0.2),\nvec4( 1.6606, 0.2, 5.50552, 0.2),\nvec4( 1.47739, 0.2, 6.25494, 0.2),\nvec4( 1.07686, 0.2, 7.4521, 0.2),\nvec4( 1.50604, 0.2, 8.84963, 0.2),\nvec4( 1.10089, 0.2, 9.05175, 0.2),\nvec4( 1.60634, 0.2, 10.2324, 0.2),\nvec4( 2.26373, 0.2, -10.7472, 0.2),\nvec4( 2.27501, 0.2, -9.56432, 0.2),\nvec4( 2.05334, 0.2, -8.27771, 0.2),\nvec4( 2.47714, 0.2, -7.62551, 0.2),\nvec4( 2.11287, 0.2, -6.85414, 0.2),\nvec4( 2.46121, 0.2, -5.42734, 0.2),\nvec4( 2.48027, 0.2, -4.53792, 0.2),\nvec4( 2.24386, 0.2, -3.36874, 0.2),\nvec4( 2.85442, 0.2, -2.9842, 0.2),\nvec4( 2.43261, 0.2, -1.1738, 0.2),\nvec4( 2.3488, 0.2, -0.152538, 0.2),\nvec4( 2.27154, 0.2, 0.490598, 0.2),\nvec4( 2.63699, 0.2, 1.30696, 0.2),\nvec4( 2.0043, 0.2, 2.67099, 0.2),\nvec4( 2.18054, 0.2, 3.89553, 0.2),\nvec4( 2.41205, 0.2, 4.09487, 0.2),\nvec4( 2.0638, 0.2, 5.35325, 0.2),\nvec4( 2.17001, 0.2, 6.80897, 0.2),\nvec4( 2.34511, 0.2, 7.62044, 0.2),\nvec4( 2.00013, 0.2, 8.01388, 0.2),\nvec4( 2.10597, 0.2, 9.16633, 0.2),\nvec4( 2.47932, 0.2, 10.2253, 0.2),\nvec4( 3.35661, 0.2, -10.8654, 0.2),\nvec4( 3.18799, 0.2, -9.61783, 0.2),\nvec4( 3.13371, 0.2, -8.57396, 0.2),\nvec4( 3.13837, 0.2, -7.90834, 0.2),\nvec4( 3.36029, 0.2, -6.28333, 0.2),\nvec4( 3.50181, 0.2, -5.42125, 0.2),\nvec4( 3.61217, 0.2, -4.66646, 0.2),\nvec4( 3.66956, 0.2, -3.46794, 0.2),\nvec4( 3.0749, 0.2, -2.6635, 0.2),\nvec4( 3.78634, 0.2, -1.15464, 0.2),\nvec4( 3.06085, 0.2, -0.711168, 0.2),\nvec4( 3.54975, 0.2, 1.42917, 0.2),\nvec4( 3.51646, 0.2, 2.04974, 0.2),\nvec4( 3.64272, 0.2, 3.13191, 0.2),\nvec4( 3.42818, 0.2, 4.88466, 0.2),\nvec4( 3.6408, 0.2, 5.69325, 0.2),\nvec4( 3.59693, 0.2, 6.50565, 0.2),\nvec4( 3.33509, 0.2, 7.31208, 0.2),\nvec4( 3.61734, 0.2, 8.16647, 0.2),\nvec4( 3.76807, 0.2, 9.58517, 0.2),\nvec4( 3.54924, 0.2, 10.6597, 0.2),\nvec4( 4.55491, 0.2, -10.7192, 0.2),\nvec4( 4.51885, 0.2, -9.7482, 0.2),\nvec4( 4.55923, 0.2, -8.33562, 0.2),\nvec4( 4.41738, 0.2, -7.43506, 0.2),\nvec4( 4.30424, 0.2, -6.32072, 0.2),\nvec4( 4.4496, 0.2, -5.50773, 0.2),\nvec4( 4.18484, 0.2, -4.80086, 0.2),\nvec4( 4.54549, 0.2, -3.53224, 0.2),\nvec4( 4.39241, 0.2, -2.83971, 0.2),\nvec4( 4.30381, 0.2, -1.55274, 0.2),\nvec4( 4.02376, 0.2, 1.69046, 0.2),\nvec4( 4.20319, 0.2, 2.16065, 0.2),\nvec4( 4.30433, 0.2, 3.80704, 0.2),\nvec4( 4.20039, 0.2, 4.61444, 0.2),\nvec4( 4.49142, 0.2, 5.31551, 0.2),\nvec4( 4.76697, 0.2, 6.68223, 0.2),\nvec4( 4.8544, 0.2, 7.30169, 0.2),\nvec4( 4.57113, 0.2, 8.20588, 0.2),\nvec4( 4.27065, 0.2, 9.82548, 0.2),\nvec4( 4.27844, 0.2, 10.8308, 0.2),\nvec4( 5.80005, 0.2, -10.5327, 0.2),\nvec4( 5.16042, 0.2, -9.6436, 0.2),\nvec4( 5.80788, 0.2, -8.9536, 0.2),\nvec4( 5.86073, 0.2, -7.73807, 0.2),\nvec4( 5.45345, 0.2, -6.56017, 0.2),\nvec4( 5.00828, 0.2, -5.74859, 0.2),\nvec4( 5.4564, 0.2, -4.9432, 0.2),\nvec4( 5.12304, 0.2, -3.46755, 0.2),\nvec4( 5.44373, 0.2, -2.19931, 0.2),\nvec4( 5.19283, 0.2, -1.25439, 0.2),\nvec4( 5.16044, 0.2, -0.551263, 0.2),\nvec4( 5.42419, 0.2, 0.0499236, 0.2),\nvec4( 5.66812, 0.2, 1.82038, 0.2),\nvec4( 5.23828, 0.2, 2.03698, 0.2),\nvec4( 5.61414, 0.2, 3.49581, 0.2),\nvec4( 5.85466, 0.2, 4.20929, 0.2),\nvec4( 5.44142, 0.2, 5.00407, 0.2),\nvec4( 5.7392, 0.2, 6.45109, 0.2),\nvec4( 5.00872, 0.2, 7.21968, 0.2),\nvec4( 5.75168, 0.2, 8.1819, 0.2),\nvec4( 5.36391, 0.2, 9.51854, 0.2),\nvec4( 5.65997, 0.2, 10.0016, 0.2),\nvec4( 6.22322, 0.2, -10.6403, 0.2),\nvec4( 6.84478, 0.2, -9.97302, 0.2),\nvec4( 6.17196, 0.2, -8.94082, 0.2),\nvec4( 6.19204, 0.2, -7.3296, 0.2),\nvec4( 6.1167, 0.2, -6.43121, 0.2),\nvec4( 6.1802, 0.2, -5.73312, 0.2),\nvec4( 6.68254, 0.2, -4.3847, 0.2),\nvec4( 6.23271, 0.2, -3.97935, 0.2),\nvec4( 6.17368, 0.2, -2.80498, 0.2),\nvec4( 6.75379, 0.2, -1.67269, 0.2),\nvec4( 6.2864, 0.2, -0.527823, 0.2),\nvec4( 6.01602, 0.2, 0.407877, 0.2),\nvec4( 6.04683, 0.2, 1.40776, 0.2),\nvec4( 6.05282, 0.2, 2.32703, 0.2),\nvec4( 6.80845, 0.2, 3.855, 0.2),\nvec4( 6.09077, 0.2, 4.10639, 0.2),\nvec4( 6.54422, 0.2, 5.79929, 0.2),\nvec4( 6.38627, 0.2, 6.7064, 0.2),\nvec4( 6.81109, 0.2, 7.6108, 0.2),\nvec4( 6.41759, 0.2, 8.66216, 0.2),\nvec4( 6.60758, 0.2, 9.80937, 0.2),\nvec4( 6.52981, 0.2, 10.1489, 0.2),\nvec4( 7.19926, 0.2, -10.6745, 0.2),\nvec4( 7.02268, 0.2, -9.51243, 0.2),\nvec4( 7.37482, 0.2, -8.9486, 0.2),\nvec4( 7.7181, 0.2, -7.1393, 0.2),\nvec4( 7.17361, 0.2, -6.23328, 0.2),\nvec4( 7.60853, 0.2, -5.96818, 0.2),\nvec4( 7.79936, 0.2, -4.71702, 0.2),\nvec4( 7.163, 0.2, -3.72001, 0.2),\nvec4( 7.49951, 0.2, -2.16035, 0.2),\nvec4( 7.11624, 0.2, -1.63849, 0.2),\nvec4( 7.4731, 0.2, -0.381137, 0.2),\nvec4( 7.8821, 0.2, 0.681072, 0.2),\nvec4( 7.25336, 0.2, 1.02524, 0.2),\nvec4( 7.44414, 0.2, 2.76639, 0.2),\nvec4( 7.35181, 0.2, 3.44362, 0.2),\nvec4( 7.38445, 0.2, 4.54549, 0.2),\nvec4( 7.39586, 0.2, 5.37008, 0.2),\nvec4( 7.13835, 0.2, 6.02727, 0.2),\nvec4( 7.32973, 0.2, 7.169, 0.2),\nvec4( 7.35264, 0.2, 8.8989, 0.2),\nvec4( 7.09098, 0.2, 9.69046, 0.2),\nvec4( 7.50207, 0.2, 10.7148, 0.2),\nvec4( 8.83528, 0.2, -10.6105, 0.2),\nvec4( 8.04391, 0.2, -9.52705, 0.2),\nvec4( 8.19231, 0.2, -8.19078, 0.2),\nvec4( 8.54909, 0.2, -7.3846, 0.2),\nvec4( 8.60871, 0.2, -6.16769, 0.2),\nvec4( 8.25728, 0.2, -5.58475, 0.2),\nvec4( 8.49613, 0.2, -4.95184, 0.2),\nvec4( 8.27583, 0.2, -3.35641, 0.2),\nvec4( 8.26312, 0.2, -2.79334, 0.2),\nvec4( 8.88703, 0.2, -1.92339, 0.2),\nvec4( 8.02094, 0.2, -0.808899, 0.2),\nvec4( 8.16051, 0.2, 0.0107472, 0.2),\nvec4( 8.48617, 0.2, 1.65403, 0.2),\nvec4( 8.29876, 0.2, 2.75469, 0.2),\nvec4( 8.60544, 0.2, 3.57467, 0.2),\nvec4( 8.53077, 0.2, 4.82242, 0.2),\nvec4( 8.53725, 0.2, 5.29621, 0.2),\nvec4( 8.69198, 0.2, 6.56717, 0.2),\nvec4( 8.06438, 0.2, 7.52167, 0.2),\nvec4( 8.32085, 0.2, 8.4591, 0.2),\nvec4( 8.87652, 0.2, 9.26258, 0.2),\nvec4( 8.18151, 0.2, 10.1525, 0.2),\nvec4( 9.28324, 0.2, -10.1928, 0.2),\nvec4( 9.41873, 0.2, -9.42038, 0.2),\nvec4( 9.38658, 0.2, -8.36399, 0.2),\nvec4( 9.19869, 0.2, -7.69503, 0.2),\nvec4( 9.81442, 0.2, -6.92493, 0.2),\nvec4( 9.70064, 0.2, -5.90552, 0.2),\nvec4( 9.03149, 0.2, -4.48215, 0.2),\nvec4( 9.13124, 0.2, -3.99997, 0.2),\nvec4( 9.25741, 0.2, -2.63052, 0.2),\nvec4( 9.19972, 0.2, -1.93063, 0.2),\nvec4( 9.85934, 0.2, -0.563229, 0.2),\nvec4( 9.8778, 0.2, 0.665473, 0.2),\nvec4( 9.32052, 0.2, 1.29599, 0.2),\nvec4( 9.37208, 0.2, 2.49758, 0.2),\nvec4( 9.76717, 0.2, 3.14318, 0.2),\nvec4( 9.2479, 0.2, 4.82525, 0.2),\nvec4( 9.67817, 0.2, 5.40198, 0.2),\nvec4( 9.81447, 0.2, 6.17914, 0.2),\nvec4( 9.51787, 0.2, 7.6555, 0.2),\nvec4( 9.47426, 0.2, 8.55278, 0.2),\nvec4( 9.80233, 0.2, 9.82811, 0.2),\nvec4( 9.75816, 0.2, 10.5494, 0.2),\nvec4( 10.3009, 0.2, -10.1596, 0.2),\nvec4( 10.3906, 0.2, -9.89138, 0.2),\nvec4( 10.0731, 0.2, -8.10317, 0.2),\nvec4( 10.4909, 0.2, -7.95402, 0.2),\nvec4( 10.4572, 0.2, -6.19775, 0.2),\nvec4( 10.8145, 0.2, -5.67705, 0.2),\nvec4( 10.3911, 0.2, -4.18323, 0.2),\nvec4( 10.3883, 0.2, -3.68971, 0.2),\nvec4( 10.3941, 0.2, -2.55709, 0.2),\nvec4( 10.454, 0.2, -1.50691, 0.2),\nvec4( 10.6508, 0.2, -0.702788, 0.2),\nvec4( 10.5254, 0.2, 0.235729, 0.2),\nvec4( 10.028, 0.2, 1.41827, 0.2),\nvec4( 10.177, 0.2, 2.88993, 0.2),\nvec4( 10.7825, 0.2, 3.7847, 0.2),\nvec4( 10.4053, 0.2, 4.8279, 0.2),\nvec4( 10.7285, 0.2, 5.88093, 0.2),\nvec4( 10.7223, 0.2, 6.39622, 0.2),\nvec4( 10.8957, 0.2, 7.6157, 0.2),\nvec4( 10.1374, 0.2, 8.02655, 0.2),\nvec4( 10.3895, 0.2, 9.58647, 0.2),\nvec4( 10.3005, 0.2, 10.1631, 0.2),\nvec4( 0, 1, 0, 1),\nvec4( -4, 1, 0, 1),\nvec4( 0, 0, 0, 0)\n);\nvec3[] albedos = vec3[N_SP] (\nvec3( 0.5, 0.5, 0),\nvec3( 0.256642, 0.0084296, -10.9991),\nvec3( 0.0145086, 0.0282673, -9.79014),\nvec3( 0.167, 0.417721, -8.73162),\nvec3( 0.0255632, 0.701255, -7.9309),\nvec3( 0.0780969, 0.00388971, -6.65946),\nvec3( 0.325107, 0.257698, -5.83212),\nvec3( 0.0404452, 0.716053, -4.61495),\nvec3( 1, 1, -3.69914),\nvec3( 0.43329, 0.291538, -2.93316),\nvec3( 0.588464, 0.696414, -1.47983),\nvec3( 0.843094, 0.569458, -0.269945),\nvec3( 0.347306, 0.0124492, 0.000452506),\nvec3( 0.0880927, 0.366705, 1.76802),\nvec3( 0.0170179, 0.113404, 2.86948),\nvec3( 0.835526, 0.283486, 3.71997),\nvec3( 0.095833, 0.482036, 4.14673),\nvec3( 0.955692, 0.965256, 5.27791),\nvec3( 0.00345279, 0.0775949, 6.63187),\nvec3( 0.00501775, 0.11417, 7.26673),\nvec3( 0.0656274, 0.0456579, 8.19895),\nvec3( 0.111921, 0.330161, 9.41113),\nvec3( 0.996322, 0.579457, 10.1587),\nvec3( 0.860631, 0.911741, -10.422),\nvec3( 0.30899, 0.0122732, -9.45067),\nvec3( 0.382135, 0.307276, -8.8372),\nvec3( 0.975727, 0.504591, -7.83669),\nvec3( 0.0616108, 0.197499, -6.45632),\nvec3( 0.20869, 0.271875, -5.95509),\nvec3( 0.521792, 0.853051, -4.96953),\nvec3( 0.0130348, 0.00511327, -3.38197),\nvec3( 0.546489, 0.53817, -2.20195),\nvec3( 0.0353144, 0.184097, -1.28922),\nvec3( 0.018765, 0.00825492, -0.579172),\nvec3( 0.723657, 0.638333, 0.0567724),\nvec3( 0.221861, 0.284549, 1.43844),\nvec3( 0.0355126, 0.00964554, 2.8197),\nvec3( 0.535657, 0.554443, 3.38343),\nvec3( 1, 1, 4.02629),\nvec3( 0.0726093, 0.12085, 5.07261),\nvec3( 0.742099, 0.00600814, 6.05929),\nvec3( 0.711667, 0.60424, 7.36462),\nvec3( 0.0134826, 0.126047, 8.51864),\nvec3( 0.260949, 0.116378, 9.1624),\nvec3( 1, 1, 10.4524),\nvec3( 0.0882757, 0.0159222, -10.7648),\nvec3( 0.0954786, 0.00528704, -9.92377),\nvec3( 0.507119, 0.588821, -8.15943),\nvec3( 0.740525, 0.77118, -7.78363),\nvec3( 0.0976803, 0.00716312, -6.52597),\nvec3( 0.350329, 0.140975, -5.89567),\nvec3( 0.186241, 0.279322, -4.16551),\nvec3( 0.764891, 0.552581, -3.96524),\nvec3( 0.335572, 0.0121388, -2.96169),\nvec3( 0.078961, 0.171491, -1.22441),\nvec3( 0.374835, 0.579853, -0.611504),\nvec3( 0.914327, 0.775587, 0.0533377),\nvec3( 0.0339681, 0.130254, 1.00141),\nvec3( 0.0780904, 0.00205855, 2.09445),\nvec3( 0.543519, 0.0539181, 3.37908),\nvec3( 0.515438, 0.1925, 4.15638),\nvec3( 0.853954, 0.680366, 5.67744),\nvec3( 0.00416706, 0.0548508, 6.01237),\nvec3( 0.506965, 0.314564, 7.33704),\nvec3( 0.0899137, 0.0369762, 8.11074),\nvec3( 0.816617, 0.344103, 9.81104),\nvec3( 0.57607, 0.249295, 10.3309),\nvec3( 0.087562, 0.34968, -10.2721),\nvec3( 0.149737, 0.0862633, -9.86644),\nvec3( 0.603871, 0.551352, -8.56937),\nvec3( 0.41623, 0.189282, -7.76148),\nvec3( 0.331584, 0.326902, -6.68864),\nvec3( 0.510804, 0.376079, -5.5677),\nvec3( 0.414442, 0.0615464, -4.45407),\nvec3( 0.105429, 0.201477, -3.90581),\nvec3( 0.655109, 0.0471245, -2.4532),\nvec3( 0.407302, 0.396118, -1.95354),\nvec3( 0.333757, 0.325914, -0.370212),\nvec3( 0.0325347, 0.0701656, 0.371153),\nvec3( 0.32735, 0.102958, 1.2097),\nvec3( 0.37912, 0.464048, 2.39873),\nvec3( 0.546133, 0.575584, 3.5994),\nvec3( 0.247134, 0.148231, 4.80635),\nvec3( 0.823277, 0.922735, 5.66946),\nvec3( 0.114355, 0.802027, 6.7236),\nvec3( 0.0182898, 0.0886437, 7.49758),\nvec3( 0.686194, 0.0889335, 8.47913),\nvec3( 0.59897, 0.645862, 9.43176),\nvec3( 0.0334077, 0.0407074, 10.2826),\nvec3( 0.0168858, 0.371165, -10.5587),\nvec3( 0.117816, 0.171087, -9.21857),\nvec3( 0.59548, 0.655177, -8.83199),\nvec3( 1, 1, -7.77644),\nvec3( 0.30352, 0.0030672, -6.58803),\nvec3( 0.597206, 0.609099, -5.75367),\nvec3( 0.0337066, 0.579547, -4.81829),\nvec3( 0.642072, 0.849556, -3.15441),\nvec3( 0.0794482, 0.6958, -2.50693),\nvec3( 0.164556, 0.272637, -1.91842),\nvec3( 0.521445, 0.277972, -0.650811),\nvec3( 0.285998, 0.0535989, 0.827709),\nvec3( 0.117388, 0.166026, 1.26362),\nvec3( 0.0268941, 0.00505215, 2.81068),\nvec3( 0.118137, 0.0112871, 3.6567),\nvec3( 0.822677, 0.365078, 4.67414),\nvec3( 0.443859, 0.646529, 5.62834),\nvec3( 0.750387, 0.598422, 6.12503),\nvec3( 0.454007, 0.12677, 7.08973),\nvec3( 0.607774, 0.0261489, 8.66211),\nvec3( 1, 1, 9.04144),\nvec3( 0.72873, 0.28696, 10.4849),\nvec3( 0.251263, 0.265283, -10.5642),\nvec3( 0.0991927, 0.0350839, -9.58814),\nvec3( 0.338993, 0.220763, -8.91876),\nvec3( 0.582262, 0.289514, -7.77458),\nvec3( 0.263896, 0.0435131, -6.76519),\nvec3( 0.269056, 0.0908812, -5.98273),\nvec3( 0.203332, 0.0154469, -4.23858),\nvec3( 0.226949, 0.439181, -3.71533),\nvec3( 0.161463, 0.00709597, -2.17463),\nvec3( 0.124509, 0.0333273, -1.42108),\nvec3( 0.079554, 0.329335, -0.837913),\nvec3( 0.448681, 0.159657, 0.0823501),\nvec3( 0.00991566, 0.474276, 1.54129),\nvec3( 0.681201, 0.440621, 2.51375),\nvec3( 0.14426, 0.0108192, 3.5312),\nvec3( 0.481465, 0.021734, 4.17595),\nvec3( 1, 1, 5.4684),\nvec3( 0.284398, 0.00021766, 6.45391),\nvec3( 0.0130052, 0.668873, 7.52847),\nvec3( 0.443992, 0.396702, 8.4579),\nvec3( 0.414207, 0.139481, 9.42443),\nvec3( 0.237385, 0.591076, 10.1907),\nvec3( 0.202026, 0.368379, -10.7567),\nvec3( 0.217339, 0.522713, -9.16919),\nvec3( 0.00126557, 0.00218113, -8.58725),\nvec3( 0.0995903, 0.00910007, -7.53857),\nvec3( 0.540709, 0.51971, -6.70433),\nvec3( 0.0590298, 0.127842, -5.53679),\nvec3( 0.0137182, 0.0406951, -4.99396),\nvec3( 0.847702, 0.911919, -3.65734),\nvec3( 0.154427, 0.408495, -2.42684),\nvec3( 0.0824904, 0.0588604, -1.76469),\nvec3( 0.0431585, 0.334143, -0.914268),\nvec3( 0.0707412, 0.186798, 0.0840712),\nvec3( 0.294514, 0.557602, 1.77961),\nvec3( 0.00305759, 0.570344, 2.51225),\nvec3( 0.556832, 0.334229, 3.85528),\nvec3( 0.538865, 0.32093, 4.59341),\nvec3( 0.988038, 0.535027, 5.88795),\nvec3( 0.0783874, 0.0920207, 6.14144),\nvec3( 0.354267, 0.173399, 7.11616),\nvec3( 0.122565, 0.109975, 8.83456),\nvec3( 0.0712731, 0.519207, 9.49559),\nvec3( 0.442009, 0.00586789, 10.3445),\nvec3( 0.0249989, 0.135656, -10.2662),\nvec3( 0.0307784, 0.00820357, -9.56385),\nvec3( 0.276473, 0.124793, -8.73237),\nvec3( 0.338562, 0.189991, -7.33464),\nvec3( 0.862568, 0.60665, -6.53777),\nvec3( 0.658089, 0.779865, -5.76108),\nvec3( 0.0310661, 0.139826, -4.60598),\nvec3( 0.852867, 0.219888, -3.20827),\nvec3( 0.289298, 0.0068956, -2.98675),\nvec3( 0.487513, 0.133035, -1.67146),\nvec3( 0.855066, 0.53012, -0.48378),\nvec3( 0.0654042, 0.0934969, 0.361758),\nvec3( 0.19407, 0.311404, 1.86359),\nvec3( 0.309507, 0.119627, 2.06584),\nvec3( 0.236492, 0.454228, 3.82692),\nvec3( 0.0357126, 0.0111424, 4.72122),\nvec3( 1, 1, 5.28203),\nvec3( 1, 1, 6.39125),\nvec3( 0.112522, 0.0218068, 7.23164),\nvec3( 0.376543, 0.115535, 8.29241),\nvec3( 0.271697, 0.00825908, 9.28244),\nvec3( 0.376789, 0.285599, 10.7399),\nvec3( 0.410554, 0.154387, -10.2609),\nvec3( 0.596637, 0.946459, -9.48858),\nvec3( 0.766297, 0.941108, -8.12558),\nvec3( 0.646771, 0.20115, -7.89729),\nvec3( 0.939843, 0.352433, -6.10468),\nvec3( 0.0316863, 0.248168, -5.31451),\nvec3( 0.356307, 0.225951, -4.30687),\nvec3( 0.489929, 0.511389, -3.18854),\nvec3( 0.121455, 0.82533, -2.7557),\nvec3( 0.0697612, 0.347257, -1.95085),\nvec3( 0.126453, 0.0668206, -0.753757),\nvec3( 0.746981, 0.884165, 0.351271),\nvec3( 0.532656, 0.75236, 1.02287),\nvec3( 0.100237, 0.105183, 2.7882),\nvec3( 0.110708, 0.000999516, 3.19318),\nvec3( 1, 1, 4.51614),\nvec3( 0.703572, 0.625181, 5.78889),\nvec3( 0.0685162, 0.0203391, 6.5075),\nvec3( 0.302258, 0.0248937, 7.74521),\nvec3( 0.0664432, 0.261371, 8.12296),\nvec3( 0.922715, 0.821051, 9.45484),\nvec3( 0.135085, 0.0871164, 10.7366),\nvec3( 0.282366, 0.092356, -10.9699),\nvec3( 1, 1, -9.17104),\nvec3( 0.172502, 0.294355, -8.47281),\nvec3( 0.366073, 0.0265071, -7.37369),\nvec3( 0.820893, 0.16356, -6.26093),\nvec3( 0.439347, 0.0577274, -5.36988),\nvec3( 0.425024, 0.189688, -4.69392),\nvec3( 0.123083, 0.723425, -3.23992),\nvec3( 0.00673464, 0.109112, -2.58386),\nvec3( 0.0190857, 0.32209, -1.86986),\nvec3( 0.0878539, 0.117352, -0.465248),\nvec3( 0.0197987, 0.226641, 0.503009),\nvec3( 0.0810694, 0.363216, 1.89417),\nvec3( 0.30477, 0.541464, 2.50593),\nvec3( 1, 1, 3.59254),\nvec3( 0.0357912, 0.25047, 4.84017),\nvec3( 0.194342, 0.0218016, 5.58298),\nvec3( 0.414117, 0.44746, 6.40885),\nvec3( 0.0619738, 0.212957, 7.31507),\nvec3( 0.18724, 0.602318, 8.2902),\nvec3( 0.101329, 0.349895, 9.3333),\nvec3( 0.543018, 0.535676, 10.7568),\nvec3( 0.207822, 0.0908619, -10.7559),\nvec3( 0.382228, 0.175085, -9.26429),\nvec3( 0.0958863, 0.540706, -8.72891),\nvec3( 0.758027, 0.94179, -7.43301),\nvec3( 0.7932, 0.239385, -6.39981),\nvec3( 0.841142, 0.150942, -5.19741),\nvec3( 0.0983364, 0.446539, -4.54035),\nvec3( 0.50405, 0.579153, -3.91819),\nvec3( 0.151736, 0.0351382, -2.82712),\nvec3( 0.577742, 0.625098, -1.60223),\nvec3( 0.118193, 0.818371, -0.903513),\nvec3( 0.229454, 0.0276603, 0.514309),\nvec3( 0.0971641, 0.262699, 1.13014),\nvec3( 0.239357, 0.267025, 2.58358),\nvec3( 0.0518397, 0.348195, 3.69193),\nvec3( 0.148329, 0.118569, 4.51844),\nvec3( 0.439851, 0.160078, 5.40187),\nvec3( 0.432783, 0.0753733, 6.74939),\nvec3( 0.180832, 0.494749, 7.58925),\nvec3( 0.578015, 0.948466, 8.20387),\nvec3( 0.0748517, 0.0162141, 9.86934),\nvec3( 0.00481667, 0.636413, 10.8351),\nvec3( 0.00319551, 0.527986, -10.1925),\nvec3( 0.304594, 0.219835, -9.88448),\nvec3( 0.656962, 0.852987, -8.19254),\nvec3( 0.572986, 0.701912, -7.32747),\nvec3( 0.944961, 0.619115, -6.50389),\nvec3( 0.329155, 0.355039, -5.80895),\nvec3( 0.0317327, 0.787785, -4.8763),\nvec3( 0.1652, 0.237671, -3.21338),\nvec3( 0.0332137, 0.0783273, -2.94815),\nvec3( 0.0105308, 0.450752, -1.45214),\nvec3( 0.0356951, 0.0396022, -0.940212),\nvec3( 0.86605, 0.924152, 0.10744),\nvec3( 0.511189, 0.75222, 1.00433),\nvec3( 0.426302, 0.0539764, 2.64241),\nvec3( 0.372206, 0.187684, 3.05901),\nvec3( 0.0631557, 0.010296, 4.83079),\nvec3( 0.13192, 0.323469, 5.03945),\nvec3( 0.0356964, 0.234255, 6.44927),\nvec3( 0.0431104, 0.317185, 7.391),\nvec3( 0.552154, 0.800255, 8.06949),\nvec3( 0.632366, 0.399033, 9.60373),\nvec3( 0.372132, 0.00487413, 10.8281),\nvec3( 0.0117604, 0.0243807, -10.1817),\nvec3( 0.346367, 0.27439, -9.97217),\nvec3( 0.575717, 0.581844, -8.42396),\nvec3( 0.0614552, 0.457644, -7.94608),\nvec3( 0.457212, 0.0131218, -6.91041),\nvec3( 0.260037, 0.207178, -5.94034),\nvec3( 0.128707, 0.0946782, -4.14954),\nvec3( 0.0393188, 0.506813, -3.14999),\nvec3( 0.580058, 0.817253, -2.90814),\nvec3( 0.0473536, 0.0164753, -1.96515),\nvec3( 0.161598, 0.353752, -0.962202),\nvec3( 0.0215255, 0.265688, 0.326903),\nvec3( 0.424075, 0.480756, 1.74389),\nvec3( 0.960784, 0.820083, 2.599),\nvec3( 0.454444, 0.42956, 3.71237),\nvec3( 0.0826003, 0.00510788, 4.27777),\nvec3( 0.927632, 0.819931, 5.50552),\nvec3( 0.77532, 0.610148, 6.25494),\nvec3( 0.227362, 0.0390091, 7.4521),\nvec3( 0.00667047, 0.438438, 8.84963),\nvec3( 0.602946, 0.949485, 9.05175),\nvec3( 0.020357, 0.0146567, 10.2324),\nvec3( 0.440306, 0.0261446, -10.7472),\nvec3( 0.34538, 0.459867, -9.56432),\nvec3( 0.0791653, 0.040167, -8.27771),\nvec3( 0.771564, 0.125415, -7.62551),\nvec3( 0.192059, 0.253188, -6.85414),\nvec3( 0.169496, 0.472063, -5.42734),\nvec3( 0.0229668, 0.5698, -4.53792),\nvec3( 0.0931123, 0.115334, -3.36874),\nvec3( 0.755879, 0.396545, -2.9842),\nvec3( 0.748538, 0.826781, -1.1738),\nvec3( 0.228854, 0.120451, -0.152538),\nvec3( 0.831959, 0.768466, 0.490598),\nvec3( 0.920566, 0.968366, 1.30696),\nvec3( 0.673368, 0.982972, 2.67099),\nvec3( 0.246236, 0.072132, 3.89553),\nvec3( 0.421269, 0.0806433, 4.09487),\nvec3( 0.830382, 0.864103, 5.35325),\nvec3( 0.191982, 0.314805, 6.80897),\nvec3( 0.50819, 0.664678, 7.62044),\nvec3( 0.300398, 0.933867, 8.01388),\nvec3( 0.320918, 0.4236, 9.16633),\nvec3( 0.113678, 0.131303, 10.2253),\nvec3( 0.150871, 0.112916, -10.8654),\nvec3( 0.532998, 0.131486, -9.61783),\nvec3( 1, 1, -8.57396),\nvec3( 0.0819346, 0.0520657, -7.90834),\nvec3( 0.0719441, 0.232986, -6.28333),\nvec3( 0.775028, 0.0126652, -5.42125),\nvec3( 0.281489, 0.0591197, -4.66646),\nvec3( 0.500156, 0.0269831, -3.46794),\nvec3( 0.899115, 0.67573, -2.6635),\nvec3( 0.294851, 0.519292, -1.15464),\nvec3( 0.0139313, 0.117258, -0.711168),\nvec3( 0.605212, 0.660645, 1.42917),\nvec3( 0.803842, 0.99533, 2.04974),\nvec3( 0.980932, 0.956277, 3.13191),\nvec3( 0.287843, 0.427194, 4.88466),\nvec3( 0.704793, 0.421553, 5.69325),\nvec3( 0.134306, 0.687986, 6.50565),\nvec3( 1, 1, 7.31208),\nvec3( 0.019358, 0.215625, 8.16647),\nvec3( 1, 1, 9.58517),\nvec3( 0.0683034, 0.12419, 10.6597),\nvec3( 0.384232, 0.284907, -10.7192),\nvec3( 0.0299427, 0.440582, -9.7482),\nvec3( 0.0923979, 0.331448, -8.33562),\nvec3( 0.375519, 0.879087, -7.43506),\nvec3( 0.542548, 0.0986272, -6.32072),\nvec3( 0.0808579, 0.0435609, -5.50773),\nvec3( 0.838766, 0.825417, -4.80086),\nvec3( 0.306892, 0.338349, -3.53224),\nvec3( 0.455349, 0.0867803, -2.83971),\nvec3( 0.552426, 0.97636, -1.55274),\nvec3( 0.00505332, 0.36542, 1.69046),\nvec3( 0.63783, 0.189218, 2.16065),\nvec3( 0.447832, 0.0144733, 3.80704),\nvec3( 0.744347, 0.848544, 4.61444),\nvec3( 0.0140967, 0.218708, 5.31551),\nvec3( 0.257816, 0.179212, 6.68223),\nvec3( 0.166588, 0.058651, 7.30169),\nvec3( 0.0805105, 0.517847, 8.20588),\nvec3( 0.668007, 0.299517, 9.82548),\nvec3( 0.178524, 0.0831568, 10.8308),\nvec3( 0.93924, 0.773759, -10.5327),\nvec3( 0.0595089, 0.108525, -9.6436),\nvec3( 0.715585, 0.00728262, -8.9536),\nvec3( 0.71121, 0.348984, -7.73807),\nvec3( 0.201366, 0.0730971, -6.56017),\nvec3( 0.580079, 0.603044, -5.74859),\nvec3( 0.521686, 0.753741, -4.9432),\nvec3( 0.270509, 0.595104, -3.46755),\nvec3( 0.317996, 0.018914, -2.19931),\nvec3( 0.109457, 0.122661, -1.25439),\nvec3( 0.0871007, 0.27106, -0.551263),\nvec3( 1, 1, 0.0499236),\nvec3( 0.903671, 0.579095, 1.82038),\nvec3( 0.611818, 0.161221, 2.03698),\nvec3( 0.375419, 0.238883, 3.49581),\nvec3( 0.83945, 0.797637, 4.20929),\nvec3( 0.338615, 0.232736, 5.00407),\nvec3( 0.65088, 0.182263, 6.45109),\nvec3( 0.556756, 0.53737, 7.21968),\nvec3( 0.246008, 0.244544, 8.1819),\nvec3( 0.0684649, 0.390265, 9.51854),\nvec3( 0.0956194, 0.777449, 10.0016),\nvec3( 0.660157, 0.518356, -10.6403),\nvec3( 0.90094, 0.8985, -9.97302),\nvec3( 0.264091, 0.414859, -8.94082),\nvec3( 0.0225116, 0.128989, -7.3296),\nvec3( 0.459998, 0.345451, -6.43121),\nvec3( 0.116939, 0.000290367, -5.73312),\nvec3( 0.259136, 0.0348051, -4.3847),\nvec3( 0.318828, 0.00926881, -3.97935),\nvec3( 0.880035, 0.792072, -2.80498),\nvec3( 0.0998123, 0.289023, -1.67269),\nvec3( 0.329608, 0.446171, -0.527823),\nvec3( 0.272298, 0.0810999, 0.407877),\nvec3( 0.827092, 0.0445578, 1.40776),\nvec3( 0.250933, 0.283386, 2.32703),\nvec3( 0.692653, 0.971536, 3.855),\nvec3( 1, 1, 4.10639),\nvec3( 0.0388854, 0.0677302, 5.79929),\nvec3( 0.125828, 0.34127, 6.7064),\nvec3( 0.00212257, 0.0869673, 7.6108),\nvec3( 0.0754152, 0.439034, 8.66216),\nvec3( 0.404322, 0.00315216, 9.80937),\nvec3( 0.156796, 0.0924223, 10.1489),\nvec3( 0.00641898, 0.25191, -10.6745),\nvec3( 0.321735, 0.050295, -9.51243),\nvec3( 0.0939251, 0.0376009, -8.9486),\nvec3( 0.296058, 0.35314, -7.1393),\nvec3( 0.0102747, 0.243435, -6.23328),\nvec3( 0.626203, 0.559557, -5.96818),\nvec3( 0.738742, 0.691761, -4.71702),\nvec3( 0.514457, 0.156897, -3.72001),\nvec3( 0.0696125, 0.0530956, -2.16035),\nvec3( 0.697011, 0.68285, -1.63849),\nvec3( 0.360153, 0.258151, -0.381137),\nvec3( 0.947081, 0.595109, 0.681072),\nvec3( 0.193641, 0.143828, 1.02524),\nvec3( 0.0319494, 0.00952086, 2.76639),\nvec3( 0.248648, 0.233272, 3.44362),\nvec3( 0.0800729, 0.136926, 4.54549),\nvec3( 0.00707992, 0.0638797, 5.37008),\nvec3( 0.575468, 0.657203, 6.02727),\nvec3( 0.252335, 0.0112519, 7.169),\nvec3( 0.0634193, 0.00240683, 8.8989),\nvec3( 0.00829897, 0.215634, 9.69046),\nvec3( 0.0316738, 0.340018, 10.7148),\nvec3( 0.11117, 0.0959946, -10.6105),\nvec3( 0.324446, 0.00339041, -9.52705),\nvec3( 0.308131, 0.0135654, -8.19078),\nvec3( 0.159782, 0.361801, -7.3846),\nvec3( 0.453949, 0.0971925, -6.16769),\nvec3( 0.852993, 0.886425, -5.58475),\nvec3( 0.0193524, 0.628822, -4.95184),\nvec3( 0.00982844, 0.225891, -3.35641),\nvec3( 0.0130822, 0.0121612, -2.79334),\nvec3( 0.715377, 0.432915, -1.92339),\nvec3( 0.489381, 0.00340269, -0.808899),\nvec3( 0.152443, 0.0646186, 0.0107472),\nvec3( 0.0896619, 0.000451988, 1.65403),\nvec3( 0.0425527, 0.354135, 2.75469),\nvec3( 0.0267988, 0.00779299, 3.57467),\nvec3( 0.0661772, 0.173997, 4.82242),\nvec3( 0.944987, 0.334494, 5.29621),\nvec3( 0.00355988, 0.178816, 6.56717),\nvec3( 0.388862, 0.00803628, 7.52167),\nvec3( 0.482581, 0.4727, 8.4591),\nvec3( 0.820675, 0.571457, 9.26258),\nvec3( 0.127977, 0.483014, 10.1525),\nvec3( 0.0919932, 0.117109, -10.1928),\nvec3( 0.00028112, 0.11956, -9.42038),\nvec3( 0.242891, 0.0321258, -8.36399),\nvec3( 0.870756, 0.773452, -7.69503),\nvec3( 0.68655, 0.220784, -6.92493),\nvec3( 0.361474, 0.365057, -5.90552),\nvec3( 0.0967874, 0.00787319, -4.48215),\nvec3( 0.261269, 0.47365, -3.99997),\nvec3( 0.598839, 0.0569951, -2.63052),\nvec3( 0.22723, 0.0143389, -1.93063),\nvec3( 0.00757139, 0.307276, -0.563229),\nvec3( 0.182086, 0.200679, 0.665473),\nvec3( 0.202785, 0.175643, 1.29599),\nvec3( 0.541119, 0.0779776, 2.49758),\nvec3( 0.741006, 0.0250536, 3.14318),\nvec3( 0.777345, 0.931802, 4.82525),\nvec3( 1, 1, 5.40198),\nvec3( 0.122629, 0.0272108, 6.17914),\nvec3( 0.810875, 0.0231249, 7.6555),\nvec3( 0.0262958, 0.194797, 8.55278),\nvec3( 0.178631, 0.625915, 9.82811),\nvec3( 0.127074, 0.423943, 10.5494),\nvec3( 0.876208, 0.337257, -10.1596),\nvec3( 0.621608, 0.253262, -9.89138),\nvec3( 0.00684613, 0.785122, -8.10317),\nvec3( 0.0673679, 0.984584, -7.95402),\nvec3( 0.533911, 0.53629, -6.19775),\nvec3( 0.709642, 0.501649, -5.67705),\nvec3( 0.185351, 0.834229, -4.18323),\nvec3( 0.741474, 0.0163272, -3.68971),\nvec3( 0.191902, 0.228104, -2.55709),\nvec3( 0.172597, 0.0638007, -1.50691),\nvec3( 0.0889745, 0.4659, -0.702788),\nvec3( 0.926307, 0.636329, 0.235729),\nvec3( 0.0404632, 0.16928, 1.41827),\nvec3( 0.302632, 0.070967, 2.88993),\nvec3( 0.0434039, 0.036601, 3.7847),\nvec3( 0.225124, 0.307379, 4.8279),\nvec3( 0.439163, 0.341115, 5.88093),\nvec3( 0.789942, 0.520136, 6.39622),\nvec3( 0.660259, 0.584727, 7.6157),\nvec3( 0.126573, 0.73793, 8.02655),\nvec3( 0.319456, 0.0267164, 9.58647),\nvec3( 0.171435, 0.805647, 10.1631),\nvec3( 1, 1, 0),\nvec3( 0.4, 0.2, 0),\nvec3( 0, 0, 0)\n);\nvec3[] m_r_i = vec3[N_SP] (\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 1, 0.0559345, 0),\nvec3( 1, 0.0634937, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.168859, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.340785, 0),\nvec3( 1, 0.328991, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.495377, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.00162606, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.324691, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.492412, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.20719, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.286477, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.0620288, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.331277, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.115496, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.337406, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.0488634, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.148502, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.144756, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 1, 0.186811, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.14649, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.456476, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.320753, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.173157, 0),\nvec3( 1, 0.252697, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.394308, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.0844826, 0),\nvec3( 1, 0.0213637, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.423811, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 1, 0.355404, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.0384848, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.11736, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.113515, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.138216, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.0197906, 0),\nvec3( 1, 0.203419, 0),\nvec3( 1, 0.0528989, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.14514, 0),\nvec3( 1, 0.468878, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.224295, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.283265, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.198965, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.455539, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.113623, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.344487, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.407318, 0),\nvec3( 1, 0.466376, 0),\nvec3( 1, 0.483819, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.368918, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.00854127, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.311035, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.128793, 0),\nvec3( 1, 0.398156, 0),\nvec3( 1, 0.0154137, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.46284, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.209817, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.106807, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.0152386, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.488516, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 1.5),\nvec3( 1, 0.18119, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.18015, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.465409, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.482656, 0),\nvec3( 1, 0.141522, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.122156, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.264441, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.019637, 0),\nvec3( 1, 0.347118, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.332581, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.229778, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.13168, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.20688, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.322185, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.2051, 0),\nvec3( 0, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.445021, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.196602, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0.155389, 0),\nvec3( 1, 0.0703193, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0),\nvec3( 1, 0, 1.5),\nvec3( 0, 0, 0),\nvec3( 0, 0, 0)\n);\n\n#else\n\nconst int nSP = 0;\n\nvec4[] sp_defs = vec4[1]\n(\n    vec4( 0.,0.,0., 0.5 )\n);\n\n#endif\n\n\nfloat hash(float seed)\n{\n\t// Return a \"random\" number based on the \"seed\"\n    return fract(sin(seed) * 43758.5453);\n}\n\nvec2 noise( in vec2 seed )\n{\n    return vec2( hash( seed.x ), hash( seed.y ) );\n}\n\nvec2 random_in_udisk( in vec2 seed )\n{\n\tfloat x = hash( seed.x );\n    float y = min( hash( seed.y ), sqrt( 1. - x * x ) );\n    \n    return 2. * vec2( x, y ) - 1.;\n}\n\nvec3 random_in_usphere( in vec3 seed )\n{\n\tfloat x = hash( seed.x );\n    float y = min( hash( seed.y ), sqrt( 1. - x * x ) );\n    float z = min( hash( seed.z ), sqrt( 1. - x * x - y * y ) );\n    \n    vec3 p = 2. * vec3( x, y, z ) - 1.;\n    \n    return mix( p, normalize( p ), step( 1., dot( p, p ) ) );\n}\n\nfloat schlick( in float cosine, in float ref_idx )\n{\n\tfloat r0 = ( 1. - ref_idx ) / ( 1. + ref_idx );\n    r0 *= r0;\n    return r0 + ( 1. - r0 ) * pow( 1. -cosine, 5. );\n}\n\nfloat sp_solve( in vec3 p, in vec3 dir, in vec3 center, in float r, in float T_MIN, out float t )\n{\n    vec3 oc = p - center;\n    float a = dot( dir, dir );\n    float b = 2. * dot( dir, oc );\n    float c = dot(oc,oc) - r * r;\n    \n    float d = b * b - 4. * a * c;\n\tfloat t1 = ( - b - sqrt( max( 0., d ) ) ) * 0.5 / a;\n    float t2 = ( - b + sqrt( max( 0., d ) ) ) * 0.5 / a;\n    float selector = step( T_MIN, t1 );\n    t = mix( t2, t1, selector );\n    return step( 0., d );\n}\n\n\nfloat sp_hit( in vec3 p, in vec3 dir, in vec3 center, in float r )\n{\n    vec3 oc = p - center;\n    float a = dot( dir, dir );\n    float b = 2. * dot( dir, oc );\n    float c = dot(oc,oc) - r * r;\n    \n    float d = b * b - 4. * a * c;\n    return step( 0., d );\n}\n\nfloat scatter( in vec3 p, in vec3 din, in vec3 n, in float metallic, in float roughness, \n              out vec3 dout )\n{\n    vec3 r = reflect( din, n );\n    vec3 l = normalize( n + random_in_usphere( p ) );\n    dout = mix( l, normalize( r + random_in_usphere( p ) * roughness ), \n               step( 0.0001, metallic ) );\n    return dot( dout, n );\n}\n\nfloat refraction( in vec3 i, in vec3 n, in float ior, out vec3 r )\n{\n    float r_mat = step( 1., ior ); // refraction index of 1 is vacuum, less than that is impossible\n    ior = max( 1., ior );\n    \n    float c1 = dot( i, n );\n    \n    float _in = step( 0., c1 ); // if c1 < 0, we are going from the outside (air) to inside\n    n = mix( n, -n, _in );\n    float r1 = mix( 1., ior, _in );\n    float r2 = mix( ior, 1., _in );\n    c1 = mix( -c1, c1, _in );\n    float r_idx = r1 / r2;\n    \n    float c2 = 1. - r_idx * r_idx * ( 1. - c1 * c1 );\n    float valid = step( 0., c2 ); // careful with the negative discriminant\n    \n    \n    r = r_idx * i + ( r_idx * c1 - sqrt( max( 0., c2 ) )) * n;\n    //r = r_idx * ( i + n * c1 ) - sqrt( max( 0., c2 ) ) * n;\n    \n    float reflect_prob = min( valid, schlick( mix( c1, ior * c1, _in ), r_idx ) );\n    //float reflect_prob = 1.;\n    \n    //float p = 1.;\n    float p = hash( c1 );\n    \n    \n    return ( 1.- step( p, reflect_prob ) ) * r_mat;\n}\n\nfloat scene( in vec3 ro, in vec3 rd, out float d )\n{\n    const float T_MAX = 999999.;\n\tconst float T_MIN = 0.001;\n    \n    float idx = -1.;\n    d = T_MAX;\n    \n    for( int i = 0; i != nSP; ++i )\n    {\n        float t = 0.;\n        float h = sp_solve( ro, rd, sp_defs[i].xyz, sp_defs[i].w, T_MIN, t );\n        float valid = step( T_MIN, t ); // make sure the hit point is positive\n        \n        h *= valid;\n        t = mix( T_MAX, t, h ); // no hit or negative hit == T_MAX\n        \n        idx = mix( float( i ), idx, step( d, t ) );\n        d = min( d, t );\n    }\n    \n    return idx;\n}\n\n#if CH_3\n\nvec3 trace( in vec3 from, in vec3 d )\n{\n    float t = 0.5 * ( d.y + 1. );\n    return mix( vec3( 0.5, 0.7, 1. ), vec3( 1. ), t );\n}\n\n#elif CH_4\n\nvec3 trace( in vec3 from, in vec3 d )\n{\n    float hit = sp_hit( from, d, sp_defs[0].xyz, sp_defs[0].w );\n    float t = 0.5 * ( d.y + 1. );\n    vec3 bg = mix( vec3( 0.5, 0.7, 1. ), vec3( 1. ), t );\n    return mix( bg, vec3( 1., 0., 0. ), hit );\n}\n\n#elif CH_5\n\nvec3 trace( in vec3 from, in vec3 d )\n{\n    const float T_MAX = 999999.;\n    float hit_t = T_MAX;\n    float idx = scene( from, d, hit_t );\n    int id = max( 0, int( idx ) );\n    vec3 normal = normalize( ( from + d * hit_t ) - sp_defs[id].xyz );\n    \n    float t = 0.5 * ( d.y + 1. );\n    vec3 bg = mix( vec3( 0.5, 0.7, 1. ), vec3( 1. ), t );\n    return mix( bg, 0.5 * ( normal + 1. ) , step( 0., idx ) );\n}\n\n#elif CH_6\n\nvec3 trace( in vec3 from, in vec3 d )\n{\n    const float T_MAX = 999999.;\n    \n    float hit_t = T_MAX;\n    float idx = scene( from, d, hit_t );\n    \n    int id = max( 0, int( idx ) );\n    vec3 normal = normalize( ( from + d * hit_t ) - sp_defs[id].xyz );\n    \n    float t = 0.5 * ( d.y + 1. );\n    vec3 bg = mix( vec3( 0.5, 0.7, 1. ), vec3( 1. ), t );\n    return mix( bg, 0.5 * ( normal + 1. ) , step( 0., idx ) );\n}\n\n#elif CH_7\n\nvec3 trace_it( in vec3 from, in vec3 d, in int depth )\n{\n    const float T_MAX = 999999.;\n\tconst float T_MIN = 0.001;\n    vec3 bg = mix( vec3( 0.5, 0.7, 1. ), vec3( 1. ), 0.5 * ( d.y + 1. ) );\n    for( int i = 0; i != depth; ++i )\n    {\n        float hit_t = T_MAX;\n        float idx = scene( from, d, hit_t );\n        \n        if( idx < 0. )\n        {    \n            return bg;\n        }\n        \n        int id = int( idx );\n        from = ( from + d * hit_t );\n        vec3 normal = normalize( from - sp_defs[id].xyz );\n        //d = normalize( ( from + normal + random_in_usphere( from ) ) - from );        \n        d = normalize( normal + random_in_usphere( from ) );        \n        bg *= 0.5;\n    }\n    \n    return bg;\n}\n\n\nvec3 trace( in vec3 from, in vec3 d )\n{\n    return trace_it( from, d, 50 );\n}\n\n#elif CH_8\n\nvec3 trace_it( in vec3 from, in vec3 d, in int depth )\n{\n    const float T_MAX = 999999.;\n\tconst float T_MIN = 0.001;\n    vec3 bg = mix( vec3( 0.5, 0.7, 1. ), vec3( 1. ), 0.5 * ( d.y + 1. ) );\n    int i = 0;\n    for( i = 0; i != depth; ++i )\n    {\n        float hit_t = T_MAX;\n        float idx = scene( from, d, hit_t );\n        \n        if( idx < 0. )\n        {    \n            break;\n        }\n        \n        from = ( from + d * hit_t );\n        int id = int( idx );\n        vec3 normal = normalize( from - sp_defs[id].xyz );\n        vec3 s;\n        float sf = scatter( from, d, normal, \n                           m_r[id].x, m_r[id].y,\n                          s );\n        \n        \n        if( sf < 0. )\n        {\n            bg = vec3(0.);\n            break;\n        }\n        \n        d = s;\n        bg *= albedos[id];\n    }\n    \n    return mix( bg, vec3( 0. ), step( float( depth ), float( i ) ) );\n}\n\n\nvec3 trace( in vec3 from, in vec3 d )\n{\n    return trace_it( from, d, 50 );\n}\n\n#elif CH_9 || CH_10 || CH_11 || CH_12\n\nvec3 trace_it( in vec3 from, in vec3 d, in int depth )\n{\n    const float T_MAX = 999999.;\n\tconst float T_MIN = 0.01;\n    vec3 bg = mix( vec3( 0.5, 0.7, 1. ), vec3( 1. ), 0.5 * ( d.y + 1. ) );\n    int i = 0;\n    for( i = 0; i != depth; ++i )\n    {\n        float hit_t = T_MAX;\n        float idx = scene( from, d, hit_t );\n        \n        if( idx < 0. )\n        {    \n            break;\n        }\n        \n        from = ( from + d * hit_t );\n        int id = int( idx );\n        vec3 normal = normalize( ( from - sp_defs[id].xyz ) / sp_defs[id].w );\n        vec3 s;\n        float sf = scatter( from, d, normal, \n                           m_r_i[id].x, m_r_i[id].y,\n                          s );\n        vec3 r;\n        float rf = refraction( d, normal, m_r_i[id].z, r );\n        \n        sf = mix( sf, 1., rf );\n        d = mix( s, r , rf );\n        \n        if( sf < 0. )\n        {\n            bg = vec3(0.);\n            break;\n        }\n        \n        bg *= albedos[id];\n    }\n    \n    //return mix( bg, vec3( 0. ), step( float( depth ), float( i ) ) );\n    return bg;\n}\n\n\nvec3 trace( in vec3 from, in vec3 d )\n{\n    return trace_it( from, d, 50 );\n}\n\n\n#else\n\n// default trace\nvec3 trace( in vec3 from, in vec3 d )\n{   \n    return vec3(0.);\n}\n\n#endif\n\nmat4 create_camera( in vec3 from, in vec3 to, in vec3 up, in float fov, in float n, in float ar)\n{\n    vec3 z = normalize( from - to );\n    vec3 x = normalize( cross( up, z ) );\n    vec3 y = ( cross( z, x ) );\n    \n    float hh = tan( fov * 0.5 ) * n;\n    vec3 hs = vec3( ar * hh, hh, n );\n    vec3 t = from - hs.x * x - hs.y * y - hs.z * z;\n    vec3 s = 2. * hs;\n    \n    return mat4( vec4( s.x * x, 0.), vec4( s.y * y, 0), vec4( z, 0 ), vec4( t, 1. ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 from = vec3( 0. );\n    vec3 d = vec3( 0., 0., -1. );\n \tvec3 color = vec3( 0. );   \n#if CH_3\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 bl = vec3( -2., -1., -1. );\n    vec3 p = bl + uv.x * vec3( 4., 0, 0 ) + uv.y * vec3( 0., 2., 0. ); \n    d = normalize( p );\n    color = trace( from, d );\n#elif CH_4\n  \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 bl = vec3( -2., -1., -1. );\n    vec3 p = bl + uv.x * vec3( 4., 0, 0 ) + uv.y * vec3( 0., 2., 0. ); \n    d = normalize( p );\n    \n    color = trace( from, d );\n    \n#elif CH_5\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 p = vec4( uv.x, uv.y, 0., 1. );\n    mat4 camera = create_camera( from, vec3(0.,0.,-1), vec3( 0.,1.,0. ), 1.57, 1., 2. );\n    vec4 to = camera * p;\n    d = normalize( to.xyz );\n    color = trace( from, d );\n    \n#elif CH_6\n    const int NUM_SAMPLES = 200;\n    mat4 camera = create_camera( from, vec3(0.,0.,-1), vec3( 0.,1.,0. ), 1.57, 1., 2. );\n    for( int i = 0; i != NUM_SAMPLES; ++i )\n    {\n        vec2 sp = fragCoord + noise( float( i ) + fragCoord + iTime );\n    \tvec2 uv = sp / iResolution.xy;\n        vec4 p = vec4( uv.x, uv.y, 0., 1. );\n        vec4 to = camera * p;\n        d = normalize( to.xyz );\n        color += trace( from, d );\n    }\n    \n    color /= float( NUM_SAMPLES );\n    \n#elif CH_7\n    \n    const int NUM_SAMPLES = 200;\n    mat4 camera = create_camera( from, vec3(0.,0.,-1), vec3( 0.,1.,0. ), 1.57, 1., 2. );\n    for( int i = 0; i != NUM_SAMPLES; ++i )\n    {\n        vec2 sp = fragCoord + noise( float( i ) + fragCoord + iTime );\n    \tvec2 uv = sp / iResolution.xy;\n        vec4 p = vec4( uv.x, uv.y, 0., 1. );\n        vec4 to = camera * p;\n        d = normalize( to.xyz );\n        color += trace( from, d );\n    }\n    \n    color /= float( NUM_SAMPLES );\n    \n    color = sqrt( color );\n\n#elif CH_8\n    \n    const int NUM_SAMPLES = 200;\n    mat4 camera = create_camera( from, vec3(0.,0.,-1), vec3( 0.,1.,0. ), 1.57, 1., 2. );\n    for( int i = 0; i != NUM_SAMPLES; ++i )\n    {\n        vec2 sp = fragCoord + noise( float( i ) + fragCoord + iTime );\n    \tvec2 uv = sp / iResolution.xy;\n        vec4 p = vec4( uv.x, uv.y, 0., 1. );\n        vec4 to = camera * p;\n        d = normalize( to.xyz );\n        color += trace( from, d );\n    }\n    \n    color /= float( NUM_SAMPLES );\n    \n    color = sqrt( color );\n    \n#elif CH_9\n    \n    const int NUM_SAMPLES = 200;\n    mat4 camera = create_camera( from, vec3(0.,0.,-1), vec3( 0.,1.,0. ), \n                                1.57, 1., 2. );\n    for( int i = 0; i != NUM_SAMPLES; ++i )\n    {\n        vec2 sp = fragCoord + noise( float( i ) + fragCoord + iTime );\n    \tvec2 uv = sp / iResolution.xy;\n        vec4 p = vec4( uv.x, uv.y, 0., 1. );\n        vec4 to = camera * p;\n        d = normalize( to.xyz );\n        color += trace( from, d );\n    }\n    \n    color /= float( NUM_SAMPLES );\n    \n    color = sqrt( color );\n\n#elif CH_10\n    \n    const int NUM_SAMPLES = 200;\n    float ar = iResolution.x/iResolution.y;\n    from = vec3( -2. , 2. , 1. );\n    vec3 at = vec3(0.,0.,-1.);\n    mat4 camera = create_camera( from, at, vec3( 0.,1.,0. ), \n                                0.785, 1., ar );\n    /*\n    vec3 fwd = normalize( from - at );\n    vec3 right = normalize( cross( vec3( 0., 1., 0. ), fwd ) );\n    vec3 up = cross( fwd, right );\n    */\n    \n    for( int i = 0; i != NUM_SAMPLES; ++i )\n    {\n        vec2 sp = fragCoord + noise( float( i ) + fragCoord + iTime );\n    \tvec2 uv = sp / iResolution.xy;\n        \n        vec4 p = vec4( uv.x, uv.y, 0., 1. );\n        vec4 to = camera * p;\n        d = normalize( to.xyz - from );\n        \n        /*\n        vec3 hs = vec3( ar, 1, 0. );\n        vec3 s = 2. * hs;\n        vec3 bl = from - hs.x * right - hs.y * up - fwd;\n        vec3 p = bl + uv.x * right * s.x + uv.y * up * s.y; \n        d = normalize( p - from );\n        */\n        \n        color += trace( from, d );\n    }\n    \n    color /= float( NUM_SAMPLES );\n    \n    color = sqrt( color );\n\n#elif CH_11\n    \n    const int NUM_SAMPLES = 200;\n    float ar = iResolution.x/iResolution.y;\n    from = vec3( 3. , 3. , 2. );\n    vec3 at = vec3(0.,0.,-1.);\n    mat4 camera = create_camera( from, at, vec3( 0.,1.,0. ), \n                                0.35, length( from - at ), ar );\n    float lens_radius = 0.25;\n    for( int i = 0; i != NUM_SAMPLES; ++i )\n    {\n        vec2 sp = fragCoord + noise( float( i ) + fragCoord + iTime );\n    \tvec2 uv = sp / iResolution.xy;\n        \n        vec4 p = vec4( uv.x, uv.y, 0., 1. );\n        vec4 to = camera * p;\n        vec3 offset = vec3( random_in_udisk( sp ) * lens_radius, 0. );\n        vec3 f = from + offset;\n        d = normalize( to.xyz - f );\n        \n        color += trace( f, d );\n    }\n    \n    color /= float( NUM_SAMPLES );\n    \n    color = sqrt( color );\n\n#elif CH_12\n    \n    const int NUM_SAMPLES = 10;\n    float ar = iResolution.x/iResolution.y;\n    from = vec3( 13. , 2. , 3. );\n    vec3 at = vec3(0.,0., 0.);\n    mat4 camera = create_camera( from, at, vec3( 0.,1.,0. ), \n                                0.35, 10., ar );\n    float lens_radius = 0.1;\n    for( int i = 0; i != NUM_SAMPLES; ++i )\n    {\n        vec2 sp = fragCoord + noise( float( i ) + fragCoord + iTime );\n    \tvec2 uv = sp / iResolution.xy;\n        \n        vec4 p = vec4( uv.x, uv.y, 0., 1. );\n        vec4 to = camera * p;\n        vec3 offset = vec3( random_in_udisk( sp ) * lens_radius, 0. );\n        vec3 f = from + offset;\n        d = normalize( to.xyz - f );\n        \n        color += trace( f, d );\n    }\n    \n    color /= float( NUM_SAMPLES );\n    \n    color = sqrt( color );\n\n\n    \n    \n#else\n    \n#endif\n    \n    \n    fragColor = vec4( color, 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2GDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45326, 45350, 45399, 45443], [45445, 45445, 45473, 45473, 45526], [45528, 45528, 45566, 45566, 45692], [45694, 45694, 45734, 45734, 45997], [45999, 45999, 46051, 46051, 46169], [46171, 46171, 46270, 46270, 46647], [46650, 46650, 46718, 46718, 46911], [46913, 46913, 47034, 47034, 47265], [47267, 47267, 47335, 47335, 48251], [48253, 48253, 48305, 48305, 48844], [53221, 53221, 53319, 53319, 53678], [53680, 53680, 53737, 53737, 59492]], "test": "error"}
{"id": "Ws2SDw", "name": "TestShader1", "author": "Jonas44444444", "description": "my fist test", "tags": ["lelz"], "likes": 1, "viewed": 36, "published": "Public", "date": "1554040095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WEIGHT (3.0 / iResolution.x)\nconst vec3 RED = vec3(1.0,0.0,0.0);\nconst vec3 GREEN = vec3(0.0,1.0,0.0);\nconst vec3 BLUE = vec3(0.0,0.8,1.0);\nconst vec3 WHITE = vec3(1.0,1.0,0.97);\nconst vec3 YELLOW = vec3(1.0,1.0,0.0);\nconst vec3 COLOR = vec3(1.0,1.0,1.0);\n\nconst float NOICESCALE = 0.01;\nconst float PI = 3.1415926535897932384626433832795;\nconst float SIZE = 0.5;\nconst float WIDTH = 1000.0;\nconst float SPEED = 0.5;\nconst int NROFRINGS = 1;\n\n    // noice\n\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return .5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\nvec3 mix3(vec3 a, vec3 b, vec3 c, float t) {\n    if(t>0.5) return mix(b,c,t*2.0-1.0);\n    else return mix(a,b,t*2.0);\n}\nvec3 fragment(vec3 p) {\n    float t = sin(p.x*0.8+iTime*0.5)*0.5+0.5;\n    float fog = min(pow(p.z,3.0)*400.0,1.0);\n    return mix3(RED,GREEN,BLUE,t) * fog;\n}    \nvec2 getAnglePoint(float angle,float size)\n{\n    float x = sin(angle)*size;\n    float y = cos(angle)*size;\n    vec2 noiceVal = vec2(x*NOICESCALE,y*NOICESCALE);\n    float noise = snoise(vec3(noiceVal,iTime*SPEED));\n    return vec2(iResolution.x*0.5,iResolution.y*0.5)+vec2(x,y)+vec2(x,y)*noise;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float iColor = 0.0;\n\n\n    // draw circle\n    \n    vec2 prefpoint = getAnglePoint(0.0,SIZE*iResolution.y*0.5) ;\n    float stepsize = 0.1;\n    for(int i = 0; i < NROFRINGS; i++) {\n         for(float i = 0.0; i < PI*2.0; i+=stepsize) {\n        \n        vec2 point = getAnglePoint(i+stepsize,SIZE);\n        iColor+=line(fragCoord,prefpoint,point,WIDTH);\n        prefpoint=point;\n    }\n    }\n   \n\tvec3 col = COLOR*iColor;\n\tfragColor = vec4(fragment(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2SDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[455, 2097, 2144, 2144, 2346], [2347, 2347, 2391, 2391, 2466], [2467, 2467, 2490, 2490, 2624], [2629, 2629, 2673, 2673, 2924], [2925, 2925, 2982, 3032, 3538]], "test": "error"}
{"id": "ws2SRz", "name": "Sea Turtle", "author": "cx", "description": "Creating a sea turtle", "tags": ["turtle"], "likes": 1, "viewed": 76, "published": "Public", "date": "1553149869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//ray marching\n#define MAX_STEPS 1000\n#define SURFACE_DIST 0.01\n#define MAX_DIST 100.\n\n//math constants\n#define PI 3.14159\n\n//colors\nvec3 darkblue = vec3(0.18,0.43,.59);\nvec3 shellgreen = vec3(114./255.,132./255.,106./255.);\nvec3 shelldarkgreen = vec3(48./255.,63./255.,0.2);\nvec3 finngreen = vec3(.36, .37, .29);\nvec3 beige = vec3(0.79,0.78,0.62);\nvec3 lightyellow = vec3(0.94,0.89,0.69);\n\n//parts\nfloat ibody, ilegs, ihead, ieyes, ieyesockets, imouth;\n\n//helpers\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 align(vec3 fw, vec3 up) {\n  fw = normalize(fw);\n  vec3 rt = normalize(cross(fw, normalize(up)));\n  return mat3(rt, cross(rt, fw), fw);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h)-k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(a-b)/k, 0.0, 1.0);\n  return mix(b, a, h)-k*h*(1.0-h);\n}\n\n\n//primative distance functions\nfloat dCap(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    float t = dot(p-a, ab)/dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = t*(ab) + a;\n    return length(p-c) - r;\n}\n\nfloat dS(vec3 p, vec3 s, float r) {\n    return length(p - s) - r;\n}\n\nfloat dRCone( vec3 p, float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n//turtle distance functions\nfloat dShell(vec3 p) {\n    p.xy *= rot(2.);\n    float s = dS(p, vec3(-2.75, -3., 0), 4.);\n    float c = dCap(p, vec3(0, 0, 0), vec3(1, -0.5, 0), .75);\n    float shell = smax(s, c, 0.075);\n    return shell;\n}\n\nfloat dEyes(vec3 p) {\n    p += vec3(-1, -.55, 0.);\n    p.xy *= rot(-2.25);\n    p.xz *= rot(PI);\n    float es1 = dS(p, vec3(-0.1, 0.1, -0.2), .1);\n    float e1 = dS(p, vec3(-0.1, 0.1, -0.15), .05);\n    \n    float es2 = dS(p, vec3(-0.1, 0.1, 0.2), .1);\n    float e2 = dS(p, vec3(-0.1, 0.1, 0.15), .05);\n    \n    float eyesockets = min(es1, es2);\n    float eyes = min(e1, e2);\n    \n    float eyestot = max(-eyes, eyesockets);\n    \n    if (eyes < MAX_DIST/2.) {\n        ieyes = 1. - step(0.001, abs(eyestot+eyes));\n        ieyesockets = 1. - step(.0001, abs(eyestot-eyesockets));\n    }   \n    return eyestot;\n}\n\nfloat dHead(vec3 p) {\n    p += vec3(-1, -.55, 0.);\n    p.xy *= rot(-2.25);\n    p.xz *= rot(PI);\n    float s = dS(p, vec3(-3.75, -1.2, 0), 4.);\n    float c = dRCone(p, 0.25, 0.10, 1.);\n    float topHead = smax(s, c, .01);\n\n    p.xy *= rot(-.5);\n    p+= vec3(-0.075, -0.15, 0.);\n    float breathe = (sin(iTime*1.)/20.);\n    float belowHead = dRCone(p, 0.15+breathe, 0.10, .5);\n\n    float head = smin(topHead, belowHead, 0.2);\n    return head;\n}\n\nfloat dFinns(vec3 p) {\n    p += vec3(-0.5,-0.3,0);\n    p.xy *= rot(1.75);\n    vec3 lp = p;\n    vec3 rp = p;\n    lp.z += .4;\n    rp.z -= .4;\n    float move = (sin(iTime*1.)/10.-0.05);\n    float mover = (cos(iTime*1.)/10.-0.05);\n    lp.yz *= rot(1.+move*2.);\n    rp.yz *= rot(-1.-move*2.);\n    lp.xy *= rot(move*2.+.25);\n    rp.xy *= rot(mover*2.);\n    lp.xz *= rot(-1.);\n    rp.xz *= rot(1.);\n    \n    float lupper = dRCone(lp, 0.15, 0.15, .25);\n    float rupper = dRCone(rp, 0.15, 0.15, .25);\n\n    lp.y -= 0.3;\n    rp.y -= 0.3;\n    lp.yz *= rot(1.);\n    rp.yz *= rot(-1.);\n    lp.xy *= rot(move*3.-.25);\n    rp.xy *= rot(mover*3.-.25);\n    float llower = dRCone(lp, 0.15, 0.05, .6);\n    float rlower = dRCone(rp, 0.15, 0.05, .6);\n    \n    float lfinn = smin(lupper, llower, 0.1);\n    float rfinn = smin(rupper, rlower, 0.1);\n    \n    float upperfinns = min(lfinn, rfinn);\n    \n    p += vec3(-.85,1.5,0);\n    p.xy *= rot(2.);\n    lp = p;\n    rp = p;\n    lp.z += .4;\n    rp.z -= .4;\n    lp.yz *= rot(.5 + move);\n    rp.yz *= rot(-.5 -move);\n    lp.xy *= rot(-move*1.5);\n    rp.xy *= rot(-move);\n    \n    float lback = dRCone(lp, 0.075, 0.125, .3);\n    float rback = dRCone(rp, 0.075, 0.125, .3);\n    float lowerfinns = min(lback, rback);\n    \n    return min(upperfinns, lowerfinns);\n}\n\nfloat getDist(vec3 p) {\n    ibody = 0.;\n    ihead = 0.;\n    ilegs = 0.;\n    ieyes = 0.;\n    ieyesockets = 0.;\n    \n    //shapes\n    float shell = dShell(p);\n    float head = dHead(p);\n    float eyes = dEyes(p);\n    float finn = dFinns(p);\n    float res = min(head, shell);\n    res = smax(res, -eyes, 0.0);\n    res = smin(res, finn, 0.1);\n\n    //which turtle part is hit\n    if (res < MAX_DIST - 10.) {\n        ibody = 1. - step(0.02, abs(res-shell));\n        ihead = 1. - step(.001, abs(res-head));\n        ilegs = 1. - step(.15, abs(res-finn));\n    }\n\n    return res;\n}\n\n\n\n//generative patterns\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),\n        dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat voronoi(vec2 st) {\n    \n    float color = .0;\n\n    // Scale\n    st *= 3.5;\n\n    // Tile the space\n    vec2 i_st = mod(floor(st), 10.);\n    vec2 f_st = mod(fract(st), 10.);\n\n\n    float m_dist = 50.;  // minimun distance\n    vec2 m_point;        // minimum point\n\n    for (int j=-1; j<=1; j++ ) {\n        for (int i=-1; i<=1; i++ ) {\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = random2(i_st + neighbor);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n            if( dist < m_dist ) {\n                m_dist = dist;\n                m_point = point;\n            }\n        }\n    }\n\n    // Assign a color using the closest point position\n    color += dot(m_point,vec2(.9,.9));\n    return color;\n}\n\n//voronoi with boundaries\nvec3 bvoronoi(vec2 st) {\n    st *= 2.5;\n    vec2 n = floor(st);\n    vec2 f = fract(st);\n\n    // voronoi\n    vec2 mg, mr;\n    float md = 8.0;\n    for (int j= -1; j <= 1; j++) {\n        for (int i= -1; i <= 1; i++) {\n            vec2 g = vec2(float(i),float(j));\n            vec2 o = random2( n + g );\n            o = 0.5 + 0.5*sin( 6.2831*o );\n            vec2 r = g + o - f;\n            float d = dot(r,r);\n            if( d<md ) {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n\n    // distance to borders\n    md = 8.0;\n    for (int j= -2; j <= 2; j++) {\n        for (int i= -2; i <= 2; i++) {\n            vec2 g = mg + vec2(float(i),float(j));\n            vec2 o = random2( n + g );\n            o = 0.5 + 0.5*sin(6.2831*o );\n            vec2 r = g + o - f;\n            if (dot(mr-r,mr-r)>0.00001) {\n                md = min(md, dot( 0.5*(mr+r), normalize(r-mr) ));\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\n\nvec3 getColor(vec3 p, vec3 n) {\n    vec3 col = vec3(0);\n    if (ihead > 0.) {\n        col += beige;\n        if (n.x >0.15 && n.y>-0.1) {\n            col = lightyellow;\n        } else if (n.y >0.25 && n.x <0.) {\n            //top of head pattern\n            vec2 st = vec2(n.x+p.x, n.y+p.y);\n            vec3 c = bvoronoi(st);\n            col = mix( beige, finngreen*1.2, smoothstep( 0.07, 0.08, c.x ) );\n        }\n    } else if (ibody > 0.){\n        vec2 st = vec2(n.x+p.x, n.y+p.y);\n        if (n.y > 0.) {\n            //top of shell\n            col += mix( shelldarkgreen*0.5, lightyellow*shellgreen, voronoi(st));\n        } else {\n            //bottom of shell\n            col += mix( shellgreen, lightyellow, voronoi(st));\n        }\n    } else if (ieyes > 0.) {\n        col = vec3(0);\n    } else if (ilegs>0.) {\n        col += beige;\n        if (n.y >0.25) {\n            //top of legs\n            vec2 st = vec2(n.x/2.+p.x*3., n.y/2.+p.y*3.);\n            vec3 c = bvoronoi(st);\n            col = mix( lightyellow, finngreen*1.2, smoothstep( 0.05, 0.06, c.x ) );\n        }\n    } else if (ieyesockets > 0.) {\n        col += mix(shellgreen, beige, 0.3);\n    }  else {\n        //background water\n        col = darkblue*1.5;\n    }\n    return col;\n    \n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.01, 0.);\n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    return normalize(n);\n}\n\n\nfloat getLight(vec3 p, vec3 lightPos, vec3 n, float sh) {\n    float dif = clamp(dot(lightPos,n), 0.0, .50);\n    vec3 hal = normalize(lightPos - p);\n    float spe = pow(clamp(dot(hal,n), 0.0, 1.0 ), 50.);\n    return pow((dif+spe*.25)*sh, 2.);\n}\n\n\nfloat shadow(vec3 p, vec3 dir) {\n  float sh = 1.0;\n  float t = .001;\n  float d = 10.;\n  for (int i=0; i<10; i++) {\n      vec3 pos = p+t*dir;\n      d = getDist(pos);\n      sh = min(sh, 1.*d/t);\n      t += d;\n  }\n  return clamp(sh, 0.0, 1.0);\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + dO * rd;\n        float dS = getDist(p);\n        dO += dS;\n        if (dS<SURFACE_DIST || dO>MAX_DIST) break;\n    }\n    vec3 p = ro+rd*dO;\n    vec3 n = getNormal(p);\n    vec3 col = getColor(p, n);\n    vec3 light = vec3(0, 15, 0);\n    float sh = shadow(p, light);\n    col += getLight(p, light, n, sh);\n    return col/1.25;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -4);  \n    vec3 rd = normalize(vec3(uv.x , uv.y, 1));\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    mat2 mx = rot(m.x*8.5);\n    mat2 my = rot(m.y*7.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    ro.xz *= rot(sin(iTime/15.)); \n    rd.xz *= rot(sin(iTime/15.));\n    ro.xy *= rot(-sin(iTime/30.)); \n    rd.xy *= rot(-sin(iTime/30.));\n    \n    vec3 d = rayMarch(ro, rd);\n    vec3 col = vec3(d);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2SRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[455, 465, 484, 484, 560], [562, 562, 592, 592, 703], [705, 705, 746, 746, 833], [835, 835, 874, 874, 957], [960, 991, 1036, 1036, 1176], [1178, 1178, 1213, 1213, 1245], [1247, 1247, 1300, 1300, 1578], [1580, 1608, 1630, 1630, 1815], [1817, 1817, 1838, 1838, 2423], [2425, 2425, 2446, 2446, 2867], [2869, 2869, 2891, 2891, 4151], [4153, 4153, 4176, 4176, 4723], [4727, 4749, 4773, 4773, 4875], [4877, 4877, 4901, 4901, 5649], [5651, 5677, 5701, 5701, 6655], [6658, 6658, 6689, 6689, 7910], [7912, 7912, 7936, 7936, 8120], [8123, 8123, 8180, 8180, 8366], [8369, 8369, 8401, 8401, 8611], [8613, 8613, 8646, 8646, 9047], [9051, 9051, 9108, 9108, 9644]], "test": "valid"}
{"id": "ws2SWD", "name": "shiny quadtree truchet", "author": "abje", "description": "the quadtree truchet is so pretty, it just had to be raymarched.\noriginal in 2d: [url]https://www.shadertoy.com/view/4t3BW4[/url]\n3d version (ugly): [url]https://www.shadertoy.com/view/MlcfRl[/url]", "tags": ["truchet", "quadtree"], "likes": 5, "viewed": 337, "published": "Public API", "date": "1553881868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//some function\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n//some macros\n#define subs 0.4\n#define limit 4.0\n\n#define STEPS 100\n#define FAR 20.0\n\n//some constant macros\n#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\n//it seems to make a weird truchet pattern\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z*15.3023+0.434);\n}\n\n#define checktree(i)                        \\\nfor (j = 0.0; j < i; j++) {             \\\n    vec2 h = floor(r*exp2(j))*exp2(-j); \\\n    float rand = hash13(vec3(h,int(j)));\\\n    if (rand >= subs) {                 \\\n        break;                          \\\n    }                                   \\\n}\n\nfloat truchet(vec2 p, int type) {\n    float len;\n    if (type == 0)\n    {\n        p = p+step(p.x+p.y,0.0)-0.5;\n        len = abs(length(p)-0.5)-0.1667;\n    }\n    else if (type == 1)\n    {\n        len = -length(abs(p)-0.5)+0.3333;\n    }\n    else if (type == 2)\n    {\n        vec2 dir;\n        if (abs(p.x) > abs(p.y)) {\n            dir = vec2(sign(p.x),0.0);\n        } else {\n            dir = vec2(0.0,sign(p.y));\n        }\n        len = abs(length(p-dir*0.5))-0.1667;\n    }\n    else if (type == 3)\n    {\n        vec2 dir;\n        if (abs(p.x) > abs(p.y)) {\n            dir = vec2(sign(p.x),0.0);\n        } else {\n            dir = vec2(0.0,sign(p.y));\n        }\n        len = min(abs(length(p-0.5)-0.5),abs(length(p-dir*0.5)))-0.1667;\n    }\n    else if (type == 4)\n    {\n        p = abs(p)-0.1667;\n\n        len = -length(min(p,0.0))+max(min(p.x,p.y),0.0);\n    }\n    else if (type == 5)\n    {\n        p.y = abs(p.y);\n\n        len = min(p.y,length(p-vec2(0,0.5)))-0.1667;\n    }\n    else if (type == 6)\n    {\n        p.x = abs(p.x);\n        len = min(max(-p.y-0.1667,-length(p-0.5)+0.3333),length(p+vec2(0,0.5))-0.1667);      \n    }\n    return len;\n}\n\nfloat quadtruchet(vec2 p) {\n    float len = 0.0;\n    \n    float j;\n    vec2 r = p;\n    checktree(limit);\n    float i = j;\n    \n    //the position in the bottom left corner of the truchet cell\n    vec2 fp = floor(p*exp2(i))*exp2(-i);\n\n    //the local position on the truchet cell (always 0-1)\n    vec2 lp = (p-fp)*exp2(i);\n    \n    float rand = fract(hash13(vec3(fp,-i))*10.0);\n    vec2 q = lp-0.5;\n\n    int celltype = int(rand*7.0);\n    int rots = int(fract(rand*7.0)*4.0);\n\n    for (int i = 0; i < rots; i++) {\n        q = vec2(q.y,-q.x);\n    }\n    \n    float l = truchet(q,celltype);\n    \n    len = l*exp2(-i)*(1.0-mod(i,2.0)*2.0);\n    //len = l*exp2(-i);\n    \n    for (float i = 1.0; i <= limit; i++) {\n        \n        if (i <= j) continue;\n        \n        //the position in the bottom left corner of the truchet cell\n        fp = floor(p*exp2(i))*exp2(-i);\n\t\t\n        //the local position on the truchet cell (always 0-1)\n        lp = (p-fp)*exp2(i);\n\n        //check for the overlapping black dots\n        vec2 p2 = p*exp2(i);\n        vec2 fp2 = floor(p2-0.5);\n        for(int x = -0; x <= 1; x++) {\n            for(int y = -0; y <= 1; y++) {\n                r = (fp2+vec2(x,y))*exp2(-i);\n                //this branch doesn't do anything, but it skips the random() once\n                if (r != fp)\n                {\n                    checktree(i);\n\n                    if (i==j) {\n                        float l = length(abs(p2-fp2-vec2(x,y)-0.5)-0.5)-0.3333;\n                        float s = mod(i,2.0)*2.0-1.0;\n                        len = min(l*exp2(-i),len*s)*s;\n                    }\n                }\n            }\n        }\n\t}\n    return len;\n}\n\nfloat map(vec3 p) {\n    vec2 q = vec2(p.y+0.02,quadtruchet(p.xz)+0.02);\n    q.y = -(length(max(q,vec2(0.0)))+min(max(q.x,q.y),0.0)-0.06);\n    q.x = -p.y-0.05;\n    return -(length(max(q,vec2(0.0)))+min(max(q.x,q.y),0.0)-0.04);\n}\n\nvec3 findnormal(vec3 p, float len, float d) {\n    vec2 eps = vec2(d/iResolution.y*2.0,0.0);\n    \n    return normalize(vec3(\n        len-map(p-eps.xyy),\n        len-map(p-eps.yxy),\n        len-map(p-eps.yyx)));\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n    mat3 tex = mat3(\n        texture(t, p.yz).xyz,\n        texture(t, p.zx).xyz,\n        texture(t, p.xy).xyz);\n    \n    tex = matrixCompMult(tex,tex);\n    \n    return tex*n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.5,0.4,iTime);\n    vec3 rd = normalize(vec3(uv,1));\n    \n    if (length(iMouse.xy) > 40.0) {\n    \trd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n    \trd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    float d = 0.0;\n    float l;\n    for (int i = 0; i < STEPS; i++) {\n        l = map(ro+rd*d);\n        \n        if (l < d/iResolution.y*2.0 || d > FAR) break;\n        \n        d += l;\n    }\n    \n    vec3 col = vec3(0);\n    \n    vec3 sky = vec3(0.1,0.3,0.4)+(rd*0.07);\n    \n    if (d < FAR) {\n        vec3 p = ro+rd*d;\n        vec3 n = findnormal(p, l, d);\n        \n        vec3 tex = tex3D(iChannel0,p*5.0,n);\n        \n        float light = max(dot(n,normalize(vec3(1))),0.1);\n        \n        col = tex*light;\n        \n        rd = reflect(rd,n);\n        \n        float sun = max(dot(rd,normalize(vec3(1))),0.0);\n        vec3 suncol = vec3(1.4,2.0,0.0);\n        sun = pow(sun,1000.0);\n        \n        col += sun*suncol*0.8;\n        \n        float dist = d/FAR;\n        col = mix(col,sky,dist*dist);\n    } else {\n        float sun = max(dot(rd,normalize(vec3(1))),0.0);\n        sun = pow(sun,1000.0);\n        vec3 suncol = vec3(1.4,2.0,0.0);\n        col = mix(sky,suncol,sun);\n    }\n    \n    fragColor = vec4(sqrt(col),1);\n    \n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2SWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 373, 396, 396, 518], [821, 821, 854, 854, 1969], [1971, 1971, 1998, 1998, 3636], [3638, 3638, 3657, 3657, 3865], [3867, 3867, 3912, 3912, 4078], [4080, 4238, 4285, 4285, 4521], [4523, 4523, 4580, 4630, 5968]], "test": "error"}
{"id": "Ws2SWh", "name": "metaball 简单demo", "author": "superzhan", "description": "simple metaball demo, just for test metaball algorithm.", "tags": ["metaball"], "likes": 1, "viewed": 73, "published": "Public", "date": "1553609830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 center1 = vec2(100,100);\nfloat radius1 = 30.0;\nvec2 center2 = vec2(100,100);\nfloat radius2 = 30.0;\n\nfloat startX=150.0;\n\nfloat metaball(vec2 point ,vec2 center,float radius){\n    vec2 lenDir = point - center;\n    float magSqr = lenDir.x*lenDir.x + lenDir.y*lenDir.y;\n    \n    float res = radius*radius / magSqr;\n    return res;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    center2.x= startX+ sin(iTime)*100.0;\n    \n    if( metaball(fragCoord,center1,radius1) + metaball(fragCoord,center2,radius2) >=1.0){\n       fragColor= vec4(0,1,0,0);\n    }else{\n       fragColor = vec4(0,0,0,0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2SWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 180, 180, 335], [340, 340, 397, 397, 623]], "test": "valid"}
{"id": "ws2Sz1", "name": "Impulse function", "author": "miccall", "description": "learn function \nfrom thebookofshaders.com ", "tags": ["function"], "likes": 3, "viewed": 85, "published": "Public", "date": "1552987091", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float impulse( float k, float x ){\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float impulse_term = mod(-iTime,20.0);\n    \n\tfloat y = impulse( impulse_term ,uv.x );\n    vec3 color = vec3(y);\n\t\n    // draw line \n    float pct = plot(uv,y);\n    color = (1.0-pct)*color + pct*vec3(0.0,1.0,0.0);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2Sz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 80], [82, 82, 113, 113, 204], [206, 206, 263, 313, 635]], "test": "valid"}
{"id": "Ws2SzW", "name": "Emanating circles 2", "author": "corban", "description": "Emanating circles", "tags": ["circle"], "likes": 3, "viewed": 108, "published": "Public", "date": "1553095235", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float speed = 10.0;\nfloat thickness = 0.1;\nfloat spread = 10.0;\nfloat direction = 1.0; // 1.0 OR -1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy;\n    vec2 center = iResolution.xy / 2.0;\n\tfloat dist = length(center - coord);\n    float distToEdge = 1.0 - dist / (iResolution.x / 2.0);\n\n\tvec3 col = vec3(1.0, 1.0, 1.0);\n\tfloat x = center.x - coord.x;\n\tfloat y = center.y - coord.y;\n\n\tfloat r = -(x * x + y * y);\n    \n    float circles = cos((r / (spread * 100.0)  + (iTime * direction) * speed));\n        circles *= thickness * 10.0;\n\n\tfloat c = smoothstep(1.0 - thickness, 1.0, circles);\n    \n    // fade out towards the edge\n    c *= distToEdge;    \n\t\n\tfragColor = vec4(c, c, c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2SzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 103, 160, 160, 731]], "test": "valid"}
{"id": "Ws2Szz", "name": "ShaderDojo 022", "author": "antonOTI", "description": "Inspired by the Endless Space 2 Rift Born intro\nit's a comment from @ollj that motivated me trying.\nThe artefacts and performances are far from optimal.\nI think the main weak point is the way I compute the solids (stacking planes in random directions)", "tags": ["raymarch", "training", "dojo", "cookie", "riftborn"], "likes": 24, "viewed": 604, "published": "Public API", "date": "1552740694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shattered dimention\n// Inspired by the Riftborn intro from ES2\n// https://www.youtube.com/watch?v=h8H8DedCW_I\n//\n// Disclamier: I work at Amplitude at the moment =)\n\n#define time (iTime)\n\n#define PI 3.14159\n#define TAU (PI * 2.)\n\n#define RID(p, r) (floor((p + r/2.) / r))\n#define REP(p, r) (mod(p + r/2., r) - r/2.)\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { // in [0,1]\n\n    float res = (hash(x.x) + hash(x.y + 1523.) + hash(x.z + 423.)) / 3.0;\n    return res;\n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a); float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n  return dot(p,n.xyz) - n.w;\n}\n\nfloat solid(vec3 p, float s)\n{\n  float dist = -1000.;\n  vec3 dir = vec3(0.,1.,0.);\n  float h = 3.;\n  float v = 6.;\n  mat2 hr = rot(TAU / h);\n  mat2 vr = rot(TAU / v);\n\n  for(float j = 0.; j < v; ++j)\n  {\n    for(float i = 0.; i < h; ++i)\n    {\n      float ran = (hash(s + j * i)-.5) ;\n      dist = max(dist,sdPlane(p, vec4(dir,1. + ran)));\n      dir.xz *= hr;\n    }\n\n    dir.yz *= vr;\n  }\n\n  return dist;\n}\n\nfloat map(vec3 p)\n{\n\n  vec3 cp = p;\n\n  vec3 pid = RID(p, 80.);\n  p = REP(p, 80.);\n  p.xy *= rot(pid.z * .5);\n  p.zy *= rot(pid.x * .5);\n  p.xz *= rot(pid.y * .5);\n\n  p.z -= time;\n\n  p.y += 2.;\n  p.xy *= rot(p.z * .1);\n  p.y -= 2.;\n\n  p.xy *= rot(time * .05);\n\n  float dist = 1000.;\n\n  p *= 2.;\n  float r = 6.;\n\n  vec3 id = RID(p, r);\n  p = REP(p , r);\n\n\n  float nois = noise(id);\n  float t = time * (nois + .2); ;\n\n  p.xz *= rot(t);\n  p.xy *= rot(t * .5);\n  p.yz *= rot(t * .25);\n  dist = solid(p, nois) *.25;\n\n  dist = max(dist, length(id.xy) - 2.);\n\n  return dist;\n}\n\nvoid ray(inout vec3 cp,vec3 rd, out float st, out float cd)\n{\n  for(st = 0.; st < 1.; st += 1./200.)\n  {\n    cd = map(cp);\n    if(cd < .01 || cd > 60.)\n      break;\n    cp += rd * cd * st;\n  }\n}  \n\nvec3 normal(vec3 p)\n{\n  vec2 e = vec2(.05,.0);\n  float d = map(p);\n  return normalize(vec3(\n    d - map(p + e.xyy),\n    d - map(p + e.yxy),\n    d - map(p + e.yyx)\n  ));\n}\n\nvec3 lookAt(vec3 eye, vec3 tar, vec2 uv)\n{\n  vec3 fd = normalize(tar - eye);\n  vec3 ri = cross(fd, vec3(0.,1.,0.));\n  vec3 up = cross(ri,fd);\n  return normalize(fd + ri * uv.x + up * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 eye = vec3(10.,10.,-20.);\n  vec3 tar = vec3(0.);\n  vec3 rd = lookAt(eye, tar, uv);\n  vec3 cp = eye;\n  float st,cd;\n  ray(cp,rd,st,cd);\n\n  float dist = length(eye - cp);\n\n  fragColor = mix(vec4(1.), vec4(.6,.6,.65,1.), pow((fragCoord.x / iResolution.x * .75 + .1), 1.2));\n  if(cd < .01)\n  {\n    vec3 norm = normal(cp);\n    vec3 ld = normalize(vec3(1.,-1.,1.));\n    float li = dot(norm,ld);\n    fragColor = mix(\n        fragColor,\n        mix(vec4(.75,.75,.74999,1.), vec4(.4,.4,.52,1.), li),\n        exp(-distance(cp,eye) * .007));\n  }\n  \n  fragColor = pow(fragColor, vec4(2.2));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2Szz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 320, 343, 343, 382], [384, 384, 410, 422, 515], [517, 517, 536, 536, 607], [609, 609, 640, 640, 671], [673, 673, 703, 703, 1079], [1081, 1081, 1100, 1100, 1649], [1651, 1651, 1712, 1712, 1845], [1849, 1849, 1870, 1870, 2019], [2021, 2021, 2063, 2063, 2212], [2214, 2214, 2271, 2271, 2997]], "test": "valid"}
{"id": "ws2XDW", "name": "Mandelbother", "author": "minerscale", "description": "Fancy shadermajig.", "tags": ["2d", "fractal"], "likes": 1, "viewed": 261, "published": "Public API", "date": "1553875328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const highp vec2 center = vec2(0.2799803,0.010018);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int iterations = int(200.0 * (iTime + 5.0)/20.0);\n    \n    highp float zoom = 1.0/(pow(2.0,iTime - 2.0));\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (center) + zoom * vec2(iResolution.x/iResolution.y,1) *\n              ((fragCoord - 0.5*iResolution.xy)/iResolution.xy);\n\n    vec2 real_uv = fragCoord/iResolution.xy;\n    vec2 iter = uv;\n    vec2 c = vec2(0,0);\n    int i = 0;\n    for (;i < iterations; ++i){\n        vec2 cpy = iter;\n        iter.x = (cpy.x*cpy.x - cpy.y*cpy.y) + c.x;\n        iter.y = 2.0*cpy.x*cpy.y + c.y;\n        \n        if (iter.x*iter.x + iter.y*iter.y >= 4.0){\n            break;\n        }\n    }\n    vec3 col;\n    // Output to screen\n    if (i != iterations) {\n    \tcol = 0.66*(0.5*-cos(6.28*float(i)/17.0) + 1.0)*\n              vec3(0.5*-cos(6.28*float(i)/16.0) + 1.0,\n                   0.5*-sin(6.28*float(i)/19.0) + 1.0,\n                   0.5*cos(6.28*float(i)/13.0) + 1.0\n                  );\n    } else {\n        col = 0.5*vec3(0.6*real_uv.x + 0.14*(sin(iTime)+1.0),\n                   0.6*real_uv.y + 0.14*(cos(iTime)+1.0),\n                   0.6*real_uv.y*real_uv.x + 0.14*(sin(iTime)*sin(iTime)+1.0));\n    }\n    \n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2XDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 111, 111, 1314]], "test": "valid"}
{"id": "ws2XRR", "name": "Simplex-noise motion-path", "author": "MacSlow", "description": "This is a first experiment of trying to create a random (but looping) motion-path for an object (ball in this case). The x-, y- and z-coordinates are offset by sampling 2D simplex-noise values at different areas in the noise-domain.", "tags": ["3d", "raymarching", "noise", "phong", "simplex", "spheretracing", "motion", "blinn", "path"], "likes": 1, "viewed": 241, "published": "Public API", "date": "1552755585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Trying out a looping motion-path for a ball by sampling 2D simplex-noise.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float EPSILON = .001;\nconst int MAX_ITER = 48;\nconst float STEP_BIAS = 1.2;\n\nmat2 r2d (in float degree) {\n\tfloat c = cos (radians (degree));\n    float s = sin (radians (degree));\n    return mat2 (vec2(c, s), vec2(-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n    p = vec2 (dot (p, vec2 (127.1, 311.7)),\n              dot (p, vec2 (269.5, 183.3)));\n\n    return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n    vec2 i = floor (p + (p.x + p.y)*K1);\n    \n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2; \n    vec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n    vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n                           dot (b, hash (i + o)),\n                           dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p, in int iters)\n{\n    mat2 rot = r2d (27.5);\n    float d = .0;\n    float f = 1.;\n    float fsum = .0;\n\n    for (int i = 0; i < iters; ++i) {\n        d += f*noise (p);\n        p *= rot;\n        fsum += f;\n        f *= .5;\n    }\n    d /= fsum;\n\n    return d;\n}\n\nfloat sdSphere (in vec3 p, in float r) {\n    return length (p) - r;\n}\n\nfloat scene (in vec3 p) {\n    vec3 pBottom = p;\n\tfloat phase = p.x*p.x + p.z*p.z;\n    float bottom = pBottom.y + 1. + .25*(.5 + .5*cos (phase));\n\n    vec3 pTop = p;\n    float top = -(pTop.y - 3.);\n\n    // this, apart from the simplex-noise, is the most interesting piece\n    // of code imo... here a pseudo-random (but looping) motion-path for\n    // the ball is created\n\tfloat t = iTime;\n\tvec3 ballCenter = p;\n    int iters = 4;\n    vec2 sampleAt = vec2 (cos (t), sin(t));\n\tballCenter.x += fbm (1. + sampleAt, iters);\n\tballCenter.y += .5*fbm (2. + sampleAt, iters);\n\tballCenter.z += fbm (3. + sampleAt, iters);\n\tfloat ball = sdSphere (ballCenter, .3);\n\n    return min (ball, min (bottom, top));\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        vec3 p = ro + d * rd;\n        t = scene (p);\n        if (abs (t) < EPSILON * (1. + .125*t)) break;\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (in vec3 p, in float epsilon) {\n\tfloat d = scene (p);\n    vec2 e = vec2 (epsilon, .0);\n    return normalize (vec3 (scene (p + e.xyy) - d,\n                            scene (p + e.yxy) - d,\n                            scene (p + e.yyx) - d));\n}\n\nfloat shadow (in vec3 p, in vec3 lPos)\n{\n\tfloat distanceToLight = distance (p, lPos);\n\tvec3 n = normal (p, EPSILON);\n\tfloat distanceToObject = raymarch (p + .01*n,\n\t\t\t\t\t\t\t\t\t   normalize (lPos - p));\n\tbool isShadowed = distanceToObject < distanceToLight;\n\treturn isShadowed ? .1 : 1.;\n}\n\nfloat falloff (in float dist) {\n\treturn 8. / (dist*dist);\n}\n\nvec3 shadeBlinnPhong (in vec3 ro, in vec3 rd, in float d) {\n\tvec3 p = ro + d*rd;\n    vec3 amb = vec3 (.1);\n\tvec3 diffC = vec3 (.95, .9, .5);\n    vec3 specC = vec3 (1., .95, .9);\n\tvec3 diffC2 = vec3 (.5, .5, .95);\n    vec3 specC2 = vec3 (.9, .9, 1.);\n\n    vec3 n = normal (p, d*EPSILON);\n    vec3 lPos = ro + vec3 (.5, 1.0, -3.);\n    vec3 lPos2 = ro + vec3 (-1., 1.2, 2.);\n    vec3 lDir = lPos - p;\n    vec3 lDir2 = lPos2 - p;\n    vec3 lnDir = normalize (lDir);\n    vec3 lnDir2 = normalize (lDir2);\n    float sha = shadow (p, lPos);\n    float sha2 = shadow (p, lPos2);\n\tfloat lDist = distance (p, lPos);\n\tfloat lDist2 = distance (p, lPos2);\n\n    float diff = max (dot (n, lnDir), .0);\n    float diff2 = max (dot (n, lnDir2), .0);\n\tvec3 h = normalize (lDir - rd);\n\tvec3 h2 = normalize (lDir2 - rd);\n    float spec = pow (max (dot (h, n), .0), 20.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n\tfloat phase = cos (13.*p.x);\n\tfloat phase2 = cos (13.*p.z);\n\tfloat mask = smoothstep (.01, .001, (.5 + .5*phase));\n\tfloat mask2 = smoothstep (.01, .001, (.5 + .5*phase2));\n\n    // coloring/texturing the floor and ball is on major hack ;)\n\tvec3 matC = mix (vec3 (1.), vec3 (.0), 1. - mask);\n\tvec3 matC2 = mix (vec3 (1.), vec3 (.0), 1. - mask2);\n\tmatC = (p.y > -1.9 && p.y < -.5) ? matC : vec3 (1.);\n\tmatC2 = (p.y > -1.9 && p.y < -.5) ? matC2 : vec3 (1.);\n\tvec3 color = matC + matC2;\n\n    vec3 diffTerm = sha * falloff (lDist) * diff * diffC * color;\n    vec3 diffTerm2 = sha2 * falloff (lDist2) * diff2 * diffC2 * color;\n    vec3 specTerm = (sha > .1) ? falloff (lDist) * spec * specC : vec3 (.0);\n    vec3 specTerm2 = (sha2 > .1) ? falloff (lDist2) * spec2 * specC2 : vec3 (.0);\n\n\treturn amb + diffTerm + specTerm + diffTerm2 + specTerm2;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n\t    \n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct UVs\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 uvRaw = uv;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // setup camera motion, position and view-ray\n    float angle = radians (300. + 55.*iTime);\n    float dist = 3. + cos (.125*iTime);\n    vec3 ro = vec3 (dist*cos (angle), 1., dist*sin (angle));\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // sphere-trace/ray-march the thing\n    float d = raymarch (ro, rd);\n\tfloat fog = 1. / (1. + d*d*.125);\n    vec3 p = ro + d * rd;\n\n    // shade the result\n    vec3 col = shadeBlinnPhong (ro, rd, d);\n\n    // fog, tone-mapping, gamme-correction, vignette\n\tcol *= fog;\n    col = col / (1. + col);\n    col = .1 * col + .9*sqrt (col);\n\tcol *= .8 + .2 * pow (16.*uvRaw.x*uvRaw.y*(1. - uvRaw.x)*(1. - uvRaw.y), .3);\n\n\tfragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2XRR.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 1040, 1068, 1068, 1186], [1188, 1330, 1353, 1353, 1496], [1498, 1498, 1523, 1523, 2026], [2028, 2028, 2065, 2065, 2306], [2308, 2308, 2348, 2348, 2377], [2379, 2379, 2404, 2404, 3076], [3078, 3078, 3119, 3119, 3352], [3354, 3354, 3397, 3397, 3609], [3611, 3611, 3651, 3651, 3896], [3898, 3898, 3929, 3929, 3957], [3959, 3959, 4018, 4018, 5700], [5702, 5702, 5768, 5768, 6098], [6100, 6100, 6157, 6197, 7050]], "test": "valid"}
{"id": "Ws2XWR", "name": "test: menga sponge", "author": "takumifukasawa", "description": "menga sponge\nref: https://www.iquilezles.org/www/articles/menger/menger.htm", "tags": ["fractal"], "likes": 3, "viewed": 94, "published": "Public", "date": "1553441921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------------\n// ref\n// https://www.iquilezles.org/www/articles/menger/menger.htm\n//---------------------------------------------------------------\n\n#define EPS 0.0001\n#define PI 3.14159265359\n\nprecision mediump float;\n\nconst int maxIterations = 64;\nconst float stepScale = 1.;\nconst float stopThreshold = .005;\n\nstruct Light {\n  vec3 position;\n  float intensity;\n  vec3 color;\n};\n\nfloat sphere(vec3 p, float size) {\n  return length(p) - size;\n}\n\nfloat box(vec3 p, vec3 size) {\n  vec3 d = abs(p) - size;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat tube2(vec2 p, float size) {\n  return length(p) - size;\n}\n\nfloat box2(vec2 p, float size) {\n  return length(max(abs(p) - size, 0.));\n}\n\nfloat cylindar(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat displacement(vec3 p, vec3 power) {\n  return sin(power.x * p.x) * sin(power.y * p.y) * sin(power.z * p.z);\n}\n\nvec3 repeat(vec3 p, float c) {\n  return mod(p, c) - c * .5;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nvec3 map(vec3 p) {\n  float d = box(p, vec3(1.));\n  float s = 1.;\n  for(int m = 0; m < 3; m++) {\n    vec3 a = mod(p * s, 2.) - 1.;\n    s *= 3.;\n    vec3 r = abs(1. - 3. * abs(a));\n    float da = max(r.x, r.y);\n    float db = max(r.y, r.z);\n    float dc = max(r.z, r.x);\n    float c = (min(da, min(db, dc)) - 1.) / s;\n    d = max(d, c);\n  }\n  return vec3(d, 0., 0.);\n}\n\nfloat scene(vec3 p) {\n  vec3 d = map(p);\n  return d.x;\n}\n\nvec3 getNormal(vec3 p) {\n  const float e = EPS;\n  return normalize(vec3(\n    scene(p + vec3(e,   0.0, 0.0)) - scene(p + vec3(-e,  0.0, 0.0)),\n    scene(p + vec3(0.0,   e, 0.0)) - scene(p + vec3(0.0,  -e, 0.0)),\n    scene(p + vec3(0.0, 0.0,   e)) - scene(p + vec3(0.0, 0.0,  -e))\n  ));\n}\n\nfloat rayMarching(vec3 origin, vec3 dir, float start, float end) {\n  vec3 sceneDist = vec3(0.);\n  float rayDepth = start;\n\n  vec3 res = vec3(-1.);\n  vec3 h = vec3(1.);\n  for(int i = 0; i < maxIterations; i++) {\n    sceneDist.x = scene(origin + dir * rayDepth);\n    if((sceneDist.x < stopThreshold) || (rayDepth >= end)) {\n      break;\n    }\n    res = vec3(rayDepth, sceneDist.yz);\n    rayDepth += sceneDist.x * stepScale;\n  }\n  if (sceneDist.x >= stopThreshold) {\n    rayDepth = end;\n  } else {\n    rayDepth += sceneDist.x;\n  }\n  return rayDepth;\n}\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  vec3 lightDir = light.position - position;\n  vec3 ref = reflect(-normalize(lightDir), normal);\n  float specular = 0.;\n  if(diffuse > 0.) {\n    specular = max(0., dot(ref, normalize(cameraPos - normal)));\n    float specularPower = 32.;\n    specular = pow(specular, specularPower) * light.intensity;\n  }\n  return specular;\n}\n\nvec3 lighting(vec3 position, vec3 cameraPos) {\n  vec3 sceneColor = vec3(0.);\n  vec3 normal = getNormal(position);\n\n  vec3 objColor = vec3(.6, .8, .8);\n  vec3 specularColor = vec3(.8, 1., 1.);\n\n  Light directionalLight;\n  directionalLight.position = vec3(0., 2., 2.);\n  directionalLight.intensity = .4;\n  directionalLight.color = vec3(0., 0., .5);\n\n  Light pointLight;\n  pointLight.position = vec3(0., 0., 0.);\n  pointLight.intensity = .8;\n  pointLight.color = vec3(.5, .5, .9);\n\n  Light ambientLight;\n  ambientLight.color = vec3(0., 0., 1.);\n  ambientLight.intensity = .2;\n\n  // directional light\n  float dDiffuse = max(0., dot(normal, normalize(directionalLight.position)));\n  dDiffuse *= directionalLight.intensity;\n  vec3 dDiffuseColor = dDiffuse * directionalLight.color * objColor;\n  float dSpecular = getSpecular(position, normal, directionalLight, dDiffuse, cameraPos);\n  vec3 dSpecularColor = dSpecular * specularColor;\n\n  // point light\n  vec3 pLightDir = pointLight.position - position;\n  float pDiffuse = max(0., dot(normal, normalize(pLightDir)));\n  vec3 pDiffuseColor = pDiffuse * pointLight.color * objColor;\n  float d = distance(pointLight.position, position);\n  vec3 k = vec3(.05, .9, .06);\n  float attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n  pDiffuse *= pointLight.intensity;\n  pDiffuse *= attenuation;\n  float pSpecular = getSpecular(position, normal, pointLight, pDiffuse, cameraPos);\n  pSpecular *= attenuation;\n  vec3 pSpecularColor = pSpecular * specularColor;\n\n  vec3 ambientColor = ambientLight.color * ambientLight.intensity * objColor;\n\n  vec3 diffuse = dDiffuseColor + pDiffuseColor;\n  vec3 specular = dSpecularColor + pSpecularColor;\n  vec3 ambient = ambientColor;\n\n  return objColor * diffuse + specular + ambient;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n  vec2 screenCoord = (2. * fragCoord.xy / iResolution.xy - 1.) * aspect;\n\n  // camera settings\n  vec3 lookAt = vec3(0., 0., 0.);\n  vec3 cameraPos = vec3(cos(iTime / 3.) * 3., sin(iTime / 3.) * 3., 2.);\n  float fov = .9;\n  float nearClip = 0.;\n  float farClip = 80.;\n\n  // camera vectors\n  vec3 forward = normalize(lookAt - cameraPos);\n  vec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, forward));\n\n  // raymarch\n  vec3 rayOrigin = cameraPos;\n  vec3 rayDirection = normalize(forward + fov * screenCoord.x * right + fov * screenCoord.y * up);\n  float dist = rayMarching(rayOrigin, rayDirection, nearClip, farClip);\n\n  if(dist >= farClip) {\n    vec3 bgColor = vec3(0.);\n    fragColor = vec4(bgColor, 1.);\n    return;\n  }\n\n  vec3 position = rayOrigin + rayDirection * dist;\n  vec3 normal = getNormal(position);\n\n  vec3 sceneColor = lighting(position, cameraPos);\n\n  // sceneColor = fog(sceneColor, dist, vec3(0.), .04);\n\n  fragColor = vec4(sceneColor, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2XWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 435, 469, 469, 498], [500, 500, 530, 530, 622], [624, 624, 657, 657, 686], [688, 688, 720, 720, 763], [765, 765, 797, 797, 835], [837, 837, 877, 877, 950], [952, 952, 982, 982, 1013], [1015, 1015, 1054, 1054, 1121], [1123, 1123, 1141, 1141, 1489], [1491, 1491, 1512, 1512, 1547], [1549, 1549, 1573, 1573, 1835], [1837, 1837, 1903, 1903, 2385], [2387, 2387, 2478, 2478, 2803], [2805, 2805, 2851, 2851, 4562], [4564, 4564, 4620, 4620, 5676]], "test": "valid"}
{"id": "Ws2XWz", "name": "Complex Atanh Circle Spiral?", "author": "mla", "description": "Generating a double spiral of hexagonally symmetric 'circles' (like a Doyle spiral, but not quite as I'm not sure the circles are exactly circular).\n\nMouse changes spiral angle.", "tags": ["circle", "complex", "log", "atanh"], "likes": 19, "viewed": 512, "published": "Public API", "date": "1553466901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Complex atanh generating a spiral of hexagonally touching circles.\n// Almost.\n////////////////////////////////////////////////////////////////////////////////\n\nfloat A = 3.0, B = 2.0; // Rotation angle is atan(B,A)\n//float K = 1.0;          // Extra subdivisions, should be >= 1.0\nfloat scale = 1.5;\nfloat PI = 3.14159;\n\n// Complex functions\nvec2 cmul(vec2 z, vec2 w) {\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// Iq's hsv function, but just for hue.\nvec3 h2rgb(float h ) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float X = sqrt(3.0);\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= 20.0;\n    A = floor(m.x), B = floor(m.y);\n  }\n  vec2 rot = vec2(X*A,B);\n  //z = clog(z);\n  z = 2.0*catanh(z)/PI;\n  float eps = length(rot)*fwidth(z.x);\n  z = cmul(rot,z);\n\n  z.y /= X;\n  z += iTime*vec2(0,1);\n  vec2 index = round(z);\n  z -= index;\n  z.y *= X;\n\n  if (mod(index.x + index.y, 2.0) == 0.0) z.x = -z.x;\n\n  float hx = index.x/(B==0.0 ? 1.0 : B); // Color for column\n  float hy = index.y/(A==0.0 ? 1.0 : A); // Color for row\n  vec3 col = 0.2+0.8*h2rgb(0.5*hy);\n  vec2 P = vec2(1,X);\n  float r = min(distance(-0.5*P,z),distance(0.5*P,z));\n  col = mix(col,vec3(0),smoothstep(-eps,eps,r-0.95));\n  col = mix(col,vec3(1,0,0),smoothstep(-eps,+eps,r-1.0));\n  z = 0.5*P-abs(z);\n  col *= smoothstep(-eps,eps,min(z.x,z.y)-0.05);\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2XWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 426, 453, 453, 484], [486, 486, 505, 505, 556], [558, 558, 585, 585, 613], [615, 615, 634, 634, 696], [698, 729, 750, 750, 802], [804, 844, 866, 866, 999], [1002, 1002, 1059, 1059, 2040]], "test": "valid"}
{"id": "WsBSRD", "name": "XOR the slow way II", "author": "matonga", "description": "XOR texture with floating point operations. With zoom.\nMy eyes hurt!", "tags": ["xorproceduraltexture"], "likes": 1, "viewed": 73, "published": "Public", "date": "1553013719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = mod (fragCoord * (2.01 - sin(iTime * .1) * 2.0), 256.0);\n\n    // Time varying pixel color\n    float color = 0.0, m = 128.0;\n    for (int i=0; i<8; i++) {\n        if ((uv.x - m) * (uv.y - m) < 0.0) {\n            color += m;\n        }\n        uv = mod (uv, m);\n        m *= .5;\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(color/256.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 475]], "test": "valid"}
{"id": "WsBSRm", "name": "GATAU AH", "author": "sanddroo", "description": "GG", "tags": ["gg"], "likes": 3, "viewed": 271, "published": "Public API", "date": "1553186588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching Primitives\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/Ff0jJyyiVyw\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n//Coordinate positioning of each shape\nfloat GetDist(vec3 p) {\t\n\n \t\n    float planeDist = p.y;\n  \tfloat sp = sdSphere (p-vec3(0.0), 1.0);\n    float bx = sdBox (p-vec3(-2.,0.5,6.),vec3(0.65,0.5,0.5));\n    float co = sdCone (p-vec3(0.,0.2,3.5),vec2(0.4,0.05));\n    float tri = sdTriPrism (p-vec3(2,0.2,6),vec2(1.1,0.2));\n    float tor = sdTorus(p-vec3(-3.,0.1,4.5),vec2(0.4,0.15));\n    float d = min(sp , planeDist); \n    d = min(d, bx);\n    d = min(d,co);\n    d = min(d,tri);\n    d = min(d,tor);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    //Color of each object\n    vec3 ro = vec3(0, 2, 0);\n    vec3 rd = normalize(vec3(uv.x-.15, uv.y-.2, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = (ro + rd * d )+texture(iChannel0, uv).x;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBSRm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[348, 365, 398, 398, 463], [464, 482, 518, 518, 587], [588, 603, 634, 634, 784], [785, 805, 841, 841, 928], [929, 945, 977, 1005, 1066], [1068, 1107, 1130, 1130, 1578], [1580, 1580, 1614, 1614, 1848], [1850, 1850, 1874, 1874, 2106], [2108, 2108, 2132, 2132, 2516], [2518, 2518, 2575, 2575, 2990]], "test": "error"}
{"id": "wsBSWh", "name": "007- Blurred from time", "author": "kbooz", "description": "Blurring line based on x ", "tags": ["helloworld"], "likes": 2, "viewed": 73, "published": "Public", "date": "1553565080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat Band(float size, float start, float end, float blur) {\n\tfloat step1 = smoothstep(start - blur, start + blur, size);\n\tfloat step2 = smoothstep(end + blur, end - blur, size);\n\n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur) {\n\tfloat band1 = Band(uv.x, left, right, blur);\n\tfloat band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1 * band2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // 0 <> 1.\n\tuv -= .5; // -0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    // First Rectangle\n    vec3 color = vec3(1., 1., 0.);\n    \n    float deformer = -sin(time+x*8.)*.1;\n    y+=deformer;\n    \n    float width = .5;\n    \n    float left = -width - .2;\n    float right = width;\n    \n    float blur = (-sin(x)+.5) * .05;\n    \n    float rect = Rect(vec2(x, y), left, right, -.1, .1, blur);\n    color *= rect;\n\n    \n    fragColor = vec4(color,1.0); // [...c, 1.0]\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 61, 61, 208], [210, 210, 293, 293, 418], [421, 421, 478, 478, 1068]], "test": "valid"}
{"id": "wsBXRz", "name": "videoeffu1", "author": "visy", "description": "based on the work of dracusa", "tags": ["videeffu"], "likes": 8, "viewed": 317, "published": "Public API", "date": "1553010716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on the work of dracusa\n\n#define M_PI 3.1415926535897932384626433832795\n#define AA 2\n\nfloat density = 22.;\nfloat height = 0.8;\nfloat fov = 0.5;\nfloat camera_y = 1.;\n\nfloat camera_ty = -0.17;\nfloat interpos = -0.4;\nfloat shorten = 1.;\nfloat line_width = 0.217;\nfloat rot_XY = 0.;\nfloat rot_YZ = 0.785;\nfloat radius = 0.01;\nfloat rho_offset = 0.;\nfloat vcut;\nfloat lpscale;\n\nfloat sdCone( vec3 p, vec2 c )\n{\n\tfloat q = length(p.xz);\n\treturn dot(c,vec2(q,p.y));\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul)\n{\n\tfloat r = length(p);\n\tp = vec3(log(r), acos(p.y / length(p)), atan(p.x, p.x));\n\tfloat xshrink = 1.0/(abs(p.y-M_PI)) + 1.0/(abs(p.y)) - 1.0/M_PI;\n\tp.y += height;\n\tp.z += p.x * 0.3;\n\tmul = r/lpscale/xshrink;\n\tp *= lpscale;\n\tsp = p;\n\tp.x -= rho_offset + iTime*1.5;\n\tp = fract(p*0.5) * 2.0 - 1.0;\n\tp.x *= xshrink;\n\ttp = p;\n\tpR(p.xy, rot_XY);\n\tpR(p.yz, rot_YZ);\n\trp = p;\n}\n\nfloat sdf(in vec3 p)\n{\n\tvec3 sp, tp, rp;\n\tfloat mul;\n\ttile(p, sp, tp, rp, mul);\n\t\n\tfloat spheres = abs(rp.x) - 0.22;\n\tfloat leaves = max(spheres, max(-rp.y, rp.z));\n\tleaves = max(leaves, vcut-sp.y);\n\tspheres = max(spheres, vcut-sp.y+1.07);\n\tfloat ret = min(leaves, spheres);\n\n\tvec3 pi = rp;\n\tpi.x += interpos;\n\tfloat interS = abs(pi.x) - 0.02;\n\tfloat interL = max(interS, max(-rp.y, rp.z));\n\tinterL = max(interL, vcut-sp.y+2.);\n\tinterS = max(interS, vcut-sp.y+3.);\n\tret = min(ret, min(interL, interS));\n\n\tfloat ol = abs(rp.y) - radius*0.8;\n\tol = min(ol, abs(rp.z) - radius*0.8);\n\n    ret = max(ret, -ol);\n\n\treturn ret * mul / shorten;\n}\n\nvec3 colr(in vec3 p)\n{\n\tvec3 sp, tp, rp, ret;\n\tfloat mul;\n\ttile(p, sp, tp, rp, mul);\n\n\tfloat ol = abs(rp.y) - radius;\n\tol = min(ol, abs(rp.z) - radius);\n\n\tvec3 pi = rp;\n\tpi.x += interpos;\n\tfloat inter = abs(pi.x) - 0.2;\n\tinter = max(inter, vcut-sp.y+3.);\n\n\tfloat dark = smoothstep(density*0.25, density*0.5, density - sp.y);\n\tdark *= dark;\n\t\n\tif (ol < line_width)\n\t\tret = vec3 (0.6, 0.5, 0.8)*dark;\n\telse if (inter < 0.02)\n\t\tret = vec3 (0.1, 0.35, 0.05)*dark;\n\telse\n\t\tret = vec3 (0.1, 0.25, 0.25)*dark;\n\treturn ret;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773;\n\tconst float eps = 0.0005;\n\treturn normalize(\n\t\te.xyy*sdf(pos + e.xyy*eps) + \n\t\te.yyx*sdf(pos + e.yyx*eps) + \n\t\te.yxy*sdf(pos + e.yxy*eps) + \n\t\te.xxx*sdf(pos + e.xxx*eps)\n\t);\n}\n\nfloat gain(float x, float k) \n{\n\tfloat a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n\treturn (x<0.5)?a:1.0-a;\n}\n\nvec3 gain(vec3 v, float k)\n{\n\treturn vec3(gain(v.x, k), gain(v.y, k), gain(v.z, k));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvcut = floor(density*0.25)*2.+0.9;\n\tlpscale = floor(density)/M_PI;\n\tvec2 myfragCoord = fragCoord.xy;\n    vec2 iUV = fragCoord.xy/iResolution.xy;\n    \n\n\tfloat an = 0.002*iTime + 7.0;\n\tvec3 ro = vec3(1.0*cos(an), camera_y, 1.0*sin(an));\n\tvec3 ta = vec3( 0.0, camera_ty, 0.0 );\n\t\n    vec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\n\tvec3 bg = vec3(0.06, 0.08, 0.21)*0.3;\n\tbg *= 1.-smoothstep(0.1, 2., length(iUV*2.-1.));\n\tvec3 tot = bg;\n\t\n\t#if AA>1\n\tfor(int m=0; m<AA; m++)\n\tfor(int n=0; n<AA; n++)\n\t{\n\t\tvec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n\t\tvec2 p = (-iResolution.xy + 2.0*(myfragCoord+o))/iResolution.y;\n\t\t#else    \n\t\tvec2 p = (-iResolution.xy + 2.0*myfragCoord)/iResolution.y;\n\t\t#endif\n\n\t\tvec3 rd = normalize(p.x*uu + p.y*vv + fov*ww);\n\n\t\tconst float tmax = 3.5;\n\t\tfloat t = 0.0;\n\t\tvec3 pos;\n\t\tint iout;\n\t\tfor( int i=0; i<64; i++ )\n\t\t{\n\t\t\tpos = ro + t*rd;\n\t\t\tfloat h = sdf(pos);\n\t\t\tif( h<0.0001 || t>tmax ) break;\n\t\t\tt += h;\n\t\t\tiout = i;\n\t\t}\n\t\tfloat fSteps = float(iout) / 64.;\n\t\n\t\tvec3 col = vec3(0.0);\n\t\tif( t<tmax )\n\t\t{\n\t\t\tvec3 nor = calcNormal(pos);\n\t\t\tfloat dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n\t\t\tfloat amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n\t\t\tcol = colr(pos)*amb + colr(pos)*dif;\n\t\t}\n\n\t\tfloat gloamt = smoothstep(0.04, 0.5, length(pos));\n\t\tfloat gain_pre = 1. - gloamt*0.6;\n\t\tfloat gain_k = 1.5 + gloamt*2.5;\n\t\tcol += gain(fSteps*vec3(0.7, 0.8, 0.9)*gain_pre, gain_k);\n\n\t\tcol = mix(col, bg, smoothstep(0.2+camera_y, 1.6+camera_y, t));\n\n\t\tcol = sqrt( col );\n\t\ttot += col;\n\t#if AA>1\n\t}\n\ttot /= float(AA*AA);\n\t#endif\n\n\tfragColor = vec4(tot, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 381, 413, 413, 468], [470, 470, 502, 502, 544], [546, 546, 622, 622, 991], [993, 993, 1015, 1015, 1629], [1631, 1631, 1653, 1653, 2148], [2150, 2150, 2180, 2180, 2390], [2392, 2392, 2423, 2423, 2496], [2498, 2498, 2526, 2526, 2584], [2586, 2586, 2641, 2641, 4299]], "test": "valid"}
{"id": "WsfSDB", "name": "SonOfAnotherRaymarchPractice", "author": "bignobody", "description": "Second generation of my practice raymarcher. Last one wasn't doing more than 1 reflection depth properly and shadows were backwards. Probably still doing lots of things incorrectly, but progress! Thanks as always to iq and Jamie Wong for their tutorials.", "tags": ["raymarch", "reflections"], "likes": 3, "viewed": 153, "published": "Public", "date": "1552070166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_LIGHTS 1\n#define MAX_REFLECTIONS 2\n#define AMBIENT_LIGHT 1.61\n#define NUM_SPHERES\t6\n\nvec3 colours[9] = vec3[](vec3(0.2,0.4,0.6), vec3(0.0,0.6,0.13), vec3(0.5,0.5,0.55), vec3(0.8,0.7,0.2), vec3(0.18,0.64,0.38), vec3(0.75,0.51,0.1), vec3(0.95,0.41,0.51), vec3(0.3,0.4,0.8), vec3(0.2,0.6,0.6));\nvec3 speculars[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9));\nfloat shine[9] = float[](10.0,10.0,10.0,10.0,10.0,10.0,10.0,10.0,10.0);\nfloat reflectivity[9] = float[](0.4,0.3,0.85,0.65,0.65,0.65,0.75,0.75,0.5);\n\nvec3 intensities[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.8,0.8,0.8), vec3(0.4,0.4,0.4), vec3(0.1,0.4,0.8), vec3(0.25,0.51,0.1), vec3(0.35,0.81,0.01), vec3(0.1,0.3,0.4), vec3(0.9,0.9,0.9));\n\n// adapted sdf functions by iq\nfloat sdfSphere(vec3 p, vec3 t, float r)\n{\n\treturn length(p-t)-r;   \n}\nfloat sdfBox( vec3 p, vec3 t, vec3 b )\n{\n  vec3 d = abs(p - t) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat sdfPlane( vec3 p, vec3 t, vec4 n )\n{\n  // n must be normalized\n  return dot(p-t,n.xyz) + n.w;\n}\nfloat sdfTorus( vec3 p, vec3 tr, vec2 t )\n{\n\tp = p-tr;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n////////\n\n// objects map\nfloat distanceToClosest(vec3 p, inout int pick)\n{\n    float def = 500.0;\n    float d = sdfPlane(p,vec3(0.0,-2.0,0.0),normalize(vec4(0.0,1.0,0.0,1.0)));\n    pick = 1;\n    \n    if (d > def)\n    {\n      d = def;\n      pick = 0;\n    }\n\n    float so = opUnion( sdfBox(p, vec3(0.0), vec3(4.0,6.0,1.0)), sdfBox(p, vec3(0.0), vec3(1.0,6.0,4.0)) );\n    if (so < d)\n    {\n        pick = 2;\n        d = so;\n    }\n    \n    float offset = 0.0;\n    float offset2 = 0.0;\n    float offsetinc = 6.28318 / float(NUM_SPHERES);\n\t\n\tfor (int s = 0; s < NUM_SPHERES; s ++)\n    {\n        so = sdfSphere(p,vec3(6.5 * cos(iTime+offset),0.75*cos(iTime*offset),6.5 * sin(iTime+offset)),1.0);\n\t\toffset += offsetinc;    \n    \tif (so < d)\n    \t{\n        \tpick = int(mod(float(s),float(6))+3.0);\n        \td = so;\n    \t}\n\n        so = sdfSphere(p,vec3(8.5 * cos(-iTime+offset2),0.95*cos(-iTime*offset2 * 0.33),8.5 * sin(-iTime+offset2)),1.2);\n\t\toffset2 += offsetinc;    \n    \tif (so < d)\n    \t{\n        \tpick = int(mod(float(s),float(6))+3.0);\n        \td = so;\n    \t}\n\n    }\n\n    return d;\n    \n}\n\nvec3 estimateNormal(vec3 p, inout int pick)\n{\n    const float EPSILON = 0.0001;\n return normalize(vec3(\n        distanceToClosest(vec3(p.x + EPSILON, p.y, p.z),pick) - distanceToClosest(vec3(p.x - EPSILON, p.y, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y + EPSILON, p.z),pick) - distanceToClosest(vec3(p.x, p.y - EPSILON, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y, p.z  + EPSILON),pick) - distanceToClosest(vec3(p.x, p.y, p.z - EPSILON),pick)\n    ));   \n}\n\nvec3 getLightPosition(int l)\n{\n\tvec3 lps[6] = vec3[](vec3(-8.0 * cos(iTime * 0.25),3.5,-8.0 * sin(iTime * 0.25)),\n\t\t\t\tvec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,5.5* cos(iTime * 0.5)),\n                vec3(5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 1.3)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 2.7)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 4.5)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 0.5)));\n    if (l > 5)\n    {\n        return lps[0];\n    }\n\n    return lps[l];\n}\n// soft shadows from iq's tutorial\nfloat shadowMarch( vec3 lightOrigin, vec3 surfacePoint )\n{\n    vec3 direction = normalize((lightOrigin)-surfacePoint);\n    float blendFactor = 128.18;\n    int pickTarget = 0;\n  \tfloat res = 1.0;\n    float ph = 1e20;\n    float end = distance(lightOrigin, surfacePoint);\n    for( float s=0.0001; s < end; )\n    {\n        vec3 marchStep = lightOrigin + direction * s;\n        float distNow = distanceToClosest(marchStep, pickTarget);\n        if( distNow<0.001)\n            return 0.0;\n        float y = distNow*distNow/(2.0*ph);\n        float d = sqrt(distNow*distNow-y*y);\n        res = min( res, blendFactor*d/max(0.0,s-y) );\n        ph = distNow;\n        s += distNow;\n    }\n    return res; \n}\nvec3 lightSurfacePoint(vec3 eye, vec3 surfacePoint, vec3 surfaceNormal, float ambientLight, int materialPick)\n{\n\tvec3 surfaceColour = vec3(0.0);\n    float shadow = 1.0;\n\t\n    for (int l = 0; l < NUM_LIGHTS; l ++)\n    {\n        vec3 lightPos = getLightPosition(l);\n        vec3 N = surfaceNormal;\n    \tvec3 L = normalize(lightPos - surfacePoint);\n    \tvec3 V = normalize(eye - surfacePoint);\n    \tvec3 R = normalize(reflect(-L, N));\n        \n    \tfloat dotLN = dot(L, N);\n    \tfloat dotRV = dot(R, V);\n    \tvec3 colour = colours[materialPick] * 0.01;\n    \tif (dotLN < 0.0) \n\t\t{\n        \t// Light not visible from this point on the surface\n        \tcolour =  colours[materialPick] * 0.01;\n    \t} \n    \telse if (dotRV < 0.0) \n\t\t{\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        \tcolour = intensities[l] * (colours[materialPick] * dotLN);\n            shadow = min(shadow, shadowMarch(lightPos, -surfacePoint));\n    \t}\n        else\n        {\n    \t\tcolour = intensities[l] * (colours[materialPick] * dotLN + speculars[materialPick] * pow(dotRV, shine[materialPick]));\n            shadow = min(shadow, shadowMarch(lightPos, -surfacePoint));\n        }\n\n        surfaceColour += colour;//phongLight((colours[materialPick]* shadow *ambientLight), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], surfacePoint, normal, eye);\n    }\n\treturn surfaceColour * ambientLight * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 1.0;\n    vec3 lookAt = vec3(0.0,0.5,0.0);\n    vec3 camOrigin = vec3(10.0 * cos(iTime * 0.1),6.5 * cos(iTime * 0.5)+4.2,-10.0 * sin(iTime * 0.1));\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n    \n    // config and work variables\n    int numReflections = MAX_REFLECTIONS;\n    vec3 surfacePoint = vec3(0.0);\n    vec3 col = vec3(0.1,0.3,0.44);\n\n\tfloat marchDistance = 0.0f;\n    vec3 marchVec = camOrigin;\n    int pickTarget = 0;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const int MAX_STEPS = 256;\n    const float MAX_DISTANCE = 96.0;\n    const float CLOSE_ENOUGH = 0.0001;\n\tconst int MAX_REFLECT_STEPS = 256;\n\tconst float MAX_REFLECT_DISTANCE = 64.0;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n\n    vec3 colAccum = vec3(0.0);\n  \n    for (int i = 0; i < MAX_STEPS; i ++)\n    {\n        marchStep = marchVec + rayDirection * marchDistance;\n     \tdistNow = distanceToClosest(marchStep, pickTarget);\n        \n        if (distNow <= CLOSE_ENOUGH)\n        {\n            // hit something!\n            surfacePoint = marchStep;\n    \t\tsurfaceNormal = estimateNormal(surfacePoint, pickTarget);\n            \n            colAccum = lightSurfacePoint(camOrigin, surfacePoint, surfaceNormal, AMBIENT_LIGHT, pickTarget);\n\n            vec3 lastDirection = rayDirection;\n            vec3 lastSurfacePoint = surfacePoint;\n            vec3 lastSurfaceNormal = surfaceNormal;\n\t\t\t\n            for(int r = 0; r < numReflections; r ++)\n            {\n\t\t\t\t\n                vec3 reflectOrigin = lastSurfacePoint;\n                vec3 reflectDirection = normalize(reflect((lastDirection), lastSurfaceNormal));\n                float reflectDistance = 0.001;\n    \t\t\tvec3 reflectVec = reflectOrigin;\n    \t\t\tvec3 reflectNormal = vec3(0.0);\n    \n        \t\tfloat reflectDist = 0.0;\n                float refMixVal = 0.35;\n\t\t    \tfor (int k = 0; k < MAX_REFLECT_STEPS; k ++)\n    \t\t\t{\n                    // march again from our new origin and accumulate colour from hit materials\n        \t\t\treflectVec = reflectOrigin + reflectDirection * reflectDistance;\n     \t\t\t\treflectDist = distanceToClosest(reflectVec, pickTarget);\n        \n        \t\t\tif (reflectDist <= CLOSE_ENOUGH)\n        \t\t\t{\n\t\t\t\t\t\t// hit something else!\n            \t\t\tlastSurfacePoint = reflectVec;\n    \t\t\t\t\tlastSurfaceNormal = estimateNormal(lastSurfacePoint, pickTarget);\n                        lastDirection = reflectDirection;\n                        colAccum = mix (colAccum, lightSurfacePoint(reflectOrigin, lastSurfacePoint, lastSurfaceNormal, AMBIENT_LIGHT, pickTarget), mix(reflectivity[pickTarget],refMixVal,0.5));\n                \t\trefMixVal = min(0.95, refMixVal+0.1);\n\t\t\t\t\t\t\n                        reflectDistance = 0.001;\n                        reflectDist = 0.0;\n                        reflectOrigin = lastSurfacePoint;\n                \t\treflectDirection = normalize(reflect((lastDirection), lastSurfaceNormal));\n                        break;\n       \t\n        \t\t\t}\n        \t\t\telse\n                    {\n        \t\t\t\treflectDistance += reflectDist;   \n        \n        \t\t\t\tif (reflectDistance >= MAX_REFLECT_DISTANCE)\n        \t\t\t\t{\n            \t\t\t\t// sky colour\n            \t\t\t\t pickTarget = 0;\n        \t\t\t\t\tcolAccum = mix(colAccum, colours[pickTarget] - reflectDirection.y * 0.5, mix(reflectivity[pickTarget],refMixVal,0.5));\n                        \tbreak;\n        \t\t\t\t}\n                    }\n        \n    \t\t\t}\n\n            }\n\n\t\t\tbreak;         \t\n        }\n        else\n        {\n         \tmarchDistance += distNow;   \n        }\n        if (marchDistance >= MAX_DISTANCE)\n        {\n            // sky colour\n        \tpickTarget = 0;\n\t\t\tcolAccum =  colours[pickTarget] - rayDirection.y * 0.5;\n            break;\n        }\n    }\n    \n    col = colAccum;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[855, 886, 928, 928, 956], [957, 957, 997, 997, 1151], [1152, 1152, 1194, 1220, 1253], [1254, 1254, 1297, 1297, 1373], [1374, 1374, 1411, 1411, 1433], [1435, 1435, 1470, 1470, 1492], [1494, 1494, 1531, 1531, 1552], [1563, 1578, 1627, 1627, 2641], [2643, 2643, 2688, 2688, 3116], [3118, 3118, 3148, 3148, 3765], [3766, 3801, 3859, 3859, 4494], [4495, 4495, 4606, 4606, 5935], [5937, 5937, 5994, 6034, 10234]], "test": "valid"}
{"id": "WsfSDl", "name": "Repitation Torus ", "author": "kiyamada96", "description": "Raymaching test", "tags": ["raymaching"], "likes": 3, "viewed": 82, "published": "Public", "date": "1552547964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCTAVES 5\n#define CS(a) vec2(cos(a),sin(a))\n\nconst float sphereSize=1.;\nconst vec3 lightDir=vec3(-0.577,0.577,0.577);\n\nconst float PI=3.14;\nconst float angle=90.0;\nconst float fov=angle*0.5*PI/180.0;\n\nvec3 trans(vec3 p)\n{\n\treturn mod(p,4.0)-2.0;\n}\n\nfloat smooth_min(float d1,float d2,float k)\n{\n\tfloat h=exp(-k*d1)+exp(-k*d2);\n    return -log(h)/k;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat dist_sphere(vec3 p)\n{\n\treturn length(p)-1.0;\n}\n\nfloat dist_cube(vec3 p)\n{\n\n\treturn length(max(abs(p)-vec3(2.5,0.1,0.5),0.0))-0.1;\n}\n\nfloat dist_tolus(vec3 p,vec2 r)\n{   \n    vec2 d= vec2(length(p.xy) - r.x, p.z);\n    return length(d) - r.y;\n}\n\nfloat dist_func_floor(vec3 p)\n{\n\treturn dot(p,vec3(0.0,1.0,0.0))+1.0;\n}\n\nfloat dist_cylinder(vec3 p,vec2 r)\n{\n\tvec2 d=abs(vec2(length(p.xy),p.z))-r;\n    return min(max(d.x,d.y),0.0)+length(max(d,0.0))-0.1;\n\n}\nfloat dist_func(vec3 p)\n{\n    float rot = 60.0*3.14 / 180.0;\n\trot *= iTime;\n\tvec3 q = rotate(p,rot,vec3(1,1,1));\n    \n    q.x*=sin(iTime*0.5);\n    vec3 e=trans(q);\n   \n    float d2=dist_cube(e);\n    float d1=dist_tolus(e,vec2(1.5,0.25));\n    float d3=dist_cylinder(e,vec2(0.75,0.25));\n    \n    return smooth_min(smooth_min(d1,d2,16.0),d3,16.0) ;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat d=0.01;\n\treturn normalize(vec3(\n        dist_func(p+vec3(d,0.0,0.0))-dist_func(p+vec3(-d,0.0,0.0)),\n        dist_func(p+vec3(0.0,d,0.0))-dist_func(p+vec3(0.0,-d,0.0)),\n        dist_func(p+vec3(0.0,0.0,d))-dist_func(p+vec3(0,0.0,-d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    vec3 cPos=vec3(0.0,0.0,5.0);\n    vec3 cDir=vec3(0.,0.,-1);\n    vec3 cUp=vec3(0.,1.0,0.);\n    vec3 cSide=cross(cDir,cUp);\n    float targetDepth=1.0;\n    \n  \tvec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    float dist=0.0;\n    float rlen=0.0;\n   \tvec3 rPos=cPos;\n    \n    for(int i=0;i<128;i++)\n    {\n    \tdist=dist_func(rPos);\n        rlen+=dist;\n        rPos=cPos+ray*rlen;\n    }\n   \t\n    vec3 color;\n    if(abs(dist)<0.001)\n    {\n   \t\tvec3 nor=getNormal(rPos);\n        float diff=clamp(dot(lightDir,nor),0.1,1.0);\n        color=vec3(1.0,1.0,1.0)*nor;\n    }\n    else\n    {\n    \tcolor=vec3(0.0);\n    }\n    fragColor=vec4(color,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 229, 229, 255], [257, 257, 302, 302, 358], [360, 360, 405, 405, 834], [836, 836, 863, 863, 888], [890, 890, 915, 915, 973], [975, 975, 1008, 1008, 1084], [1086, 1086, 1117, 1117, 1157], [1159, 1159, 1195, 1195, 1294], [1295, 1295, 1320, 1320, 1642], [1644, 1644, 1668, 1668, 1918], [1920, 1920, 1977, 1977, 2729]], "test": "valid"}
{"id": "wsfSDs", "name": "HSV curtain", "author": "gyabo", "description": "HSV robot curtain effect.", "tags": ["curtain"], "likes": 1, "viewed": 70, "published": "Public", "date": "1552519165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv(float h, float s, float v) {\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nvec3 gcol(vec2 uv) {\n    uv = uv * vec2(2.0, 1.5);\n    return hsv(uv.x, uv.y, uv.x * uv.y) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat bt = fract((iTime * 1.6666 * 0.5) / 4.0) * 4.0;\n\n\t//float tm0 = clamp(bt - 0.0, 0.0, 1.0);\n\t//float tm1 = clamp(bt - 1.0, 0.0, 1.0);\n\t//float tm2 = clamp(bt - 2.0, 0.0, 1.0);\n\t//float tm3 = clamp(bt - 3.0, 0.0, 1.0);\n\t//uv.x += smoothstep(0.05, 0.995, tm0 - tm2);\n\t//uv.y += smoothstep(0.05, 0.995, tm1 - tm3);\n\t\n\t//rewrite\n\tfor(int i = 0; i < 4; i++) {\n\t    float tm = clamp(bt - 1.0 * float(i), 0.0, 1.0);\n    \tuv.x += smoothstep(0.05, 0.995, tm) * (i >= 2 ? -1.0 : 1.0);\n    \tuv = uv.yx;\n\t}\n\tfragColor = vec4(gcol(uv), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 216], [218, 218, 238, 238, 317], [319, 319, 376, 376, 953]], "test": "valid"}
{"id": "wsfXD8", "name": "Windmill", "author": "asdhyq", "description": "Rotateeru", "tags": ["windmill"], "likes": 1, "viewed": 48, "published": "Public", "date": "1551755991", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 colorA = vec3(0.2509,0.1568,0.2901);\nvec3 colorB = vec3(0.4509,0.2627,0.2941);\nvec3 colorC = vec3(0.7019,0.3019,0.1450);\nvec3 colorD = vec3(0.9411,0.4941,0.0274);\nvec3 colorE = vec3(0.9686,0.8705,0.3333);\n\nvec3 red = vec3(225./255., 95./255., 60./255.);\nvec3 white = vec3(1.,1.,1.);\nvec3 blue = vec3(0.,128./255.,1.);\nvec3 black = vec3(0.,0.,0.);\nvec3 pink = vec3(255./255.,192./255.,203./255.);\n\n\nvec3 rgb(float r, float g, float b) \n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\nvec4 rectangle(vec2 uv, vec2 pos, float width, float height, vec3 color) {\n\tfloat t = 0.0;\n    \n\tif ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)\n\t\t&& (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {\n\t\tt = 1.0;\n\t}\n\treturn vec4(color, t);\n}\n\nmat2 scale2d(vec2 value)\n{\n    return mat2(value.x,0.,0.,value.y);\n}\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), - sin(angle),sin(angle),cos(angle));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    \n    float x = sin(iTime * 1.5 ) ;\n    \n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5 * ratio,0.5);\n    uv -= pos;\n    \n   uv2 *= rotate2d(sin(iTime));\n    uv *= scale2d(vec2(1.0,1.0));\n    \n    uv+=pos;\n    vec2 shapePos = vec2(.5 * ratio, .5);\n    float dist = distance ( shapePos,uv) ;\n    \n    uv -= shapePos;\n    \n\tfloat angle = atan(uv.y, uv.x)  + iTime ;\n    float radius = cos(5. * angle + iTime ) * .3;\n    \n    // rectangle Properties\n\tvec2 center = vec2(0., 0.);\n\tfloat width = .2;\n\tfloat height = .2;\n\n    // Background layer\n\tvec4 bg = vec4(rgb(1.0, 1.0, 1.0), 1.0);\n\t\n\t// Rectangle\n\tvec3 col = rgb(255.0, 255.0, 0.0);\n\tvec4 rect = rectangle(uv, center, width, height, col);\n\t\n\t// Blend the two\n\tvec3 color = mix(vec3(0.), white, rect.a);\n    color = mix(color,white,rectangle(uv,vec2(.0,.0),.08,.3,col).a);\n     color = mix (color, white,rectangle(uv,vec2(.0,-.36),.08,.4,col).a);\n    \n    float value = 1. - step(radius,dist);\n    \n    color = mix(color,red,value);\n    //\n    vec3 color2 = mix(colorA,colorB,uv.y);\n    color2 = mix(color,colorC,uv.y);\n\tcolor2 = mix(color,colorD,uv.y);\n    color2 = mix(colorE,color,uv.y);\n    \n    color2 = mix(colorA,color,sin(iTime - uv.y)) + mix(colorA,color,sin(iTime + uv.y)) ;\n       // Output to screen\n    color = mix(color,color2,1.);\n    //fragColor = vec4(color2 + color,1.0);\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 441, 441, 490], [492, 492, 566, 566, 764], [766, 766, 792, 792, 834], [835, 835, 863, 863, 930], [931, 931, 988, 988, 2503]], "test": "valid"}
{"id": "wsfXDf", "name": "Ray Sphere", "author": "kiyamada96", "description": "ray", "tags": ["raym"], "likes": 1, "viewed": 75, "published": "Public", "date": "1552368900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 lightDir=vec3(-0.577,0.577,0.577);\nconst float PI=3.14;\nconst float angle=90.0;\nconst float fov=angle*0.5*PI/180.0;\n\nfloat distanceFunc(vec3 p)\n{\n    return length(p) - (1.0+sin((p.y+iTime) * 10.0) * 0.1);\n}\n\n\nvec3 getNormal(vec3 p)\n{\n\tfloat d=0.01;\n\treturn normalize(vec3(\n        distanceFunc(p+vec3(d,0.0,0.0))-distanceFunc(p+vec3(-d,0.0,0.0)),\n        distanceFunc(p+vec3(0.0,d,0.0))-distanceFunc(p+vec3(0.0,-d,0.0)),\n        distanceFunc(p+vec3(0.0,0.0,d))-distanceFunc(p+vec3(0,0.0,-d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    vec3 cPos=vec3(0.0,0.0,2.0);\n    vec3 cDir=vec3(0.0,0.0,-1.0);\n    vec3 cUp=vec3(0.0,1.0,0.0);   \n    vec3 cSide=cross(cDir,cUp);\n    float targetDepth=1.0;\n    \n    vec3 ray=normalize(vec3(sin(fov)*p.x,sin(fov)*p.y,-cos(fov)));\n    \n    float dist=0.0;\n    float rlen=0.0;\n   \tvec3 rPos=cPos;\n    \n    for(int i=0;i<64;i++)\n    {\n    \tdist=distanceFunc(rPos);\n        rlen+=dist;\n        rPos=cPos+ray*rlen;\n    }\n   \n    if(abs(dist)<0.001)\n    {\n   \t\tvec3 nor=getNormal(rPos);\n        float diff=clamp(dot(nor,lightDir),0.1,1.0);\n        fragColor=vec4(vec3(nor),1.0);\n    }\n    else\n    {\n    \tfragColor=vec4(vec3(0.),1.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 156, 156, 218], [221, 221, 245, 245, 513], [515, 515, 572, 572, 1298]], "test": "valid"}
{"id": "WsfXW2", "name": "Ray Tracing Parametric Patches", "author": "blackle", "description": "analytic intersection of a bicubic patch defined by 16 control points.", "tags": ["bicubic"], "likes": 3, "viewed": 204, "published": "Public", "date": "1552237918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n// here be jragons (jort dragons)\n\n// Influential/helpful papers:\n// \"Ray Tracing Parametric Patches\" - James T. Kajiya\n// \"The Bernstein Basis and its Applications in Solving Geometric Constraint Systems\" - Sebti Foufou & Dominique Michelucci\n// \"On de Casteljau’s algorithm\" - Wolfgang Boehm & Andreas Müller\n\n//I solve using the bernstein basis & related techniques, unlike Kajiya's extremely computer algebra influenced approach\n\n#define ONLY_MIDDLE 0\n#define SPLIT_QUEUE_SIZE 16\n\nuniform int donttouch;\n\nstruct IntersectProblem\n{\n    mat4 cpX;\n    mat4 cpY;\n    mat4 cpZ;\n    vec3 plane1;\n    vec3 plane2;\n    vec3 cameraOrigin;\n    vec3 point;\n    vec3 normal;\n};\n\nstruct Split\n{\n    vec2 topleft;\n    vec2 size;\n    mat4 A;\n    mat4 B;\n};\n\nvoid deCasteljauSplit(in mat4 A, in int axis, out mat4 A1, out mat4 A2, float splitpos) {\n    if (axis == 1) { A = transpose(A); }\n\n    vec4 b11 = mix(A[0],A[1], splitpos);\n    vec4 b12 = mix(A[1],A[2], splitpos);\n    vec4 b13 = mix(A[2],A[3], splitpos);\n    vec4 c11 = mix(b11,b12, splitpos);\n    vec4 c12 = mix(b12,b13, splitpos);\n    vec4 d11 = mix(c11,c12, splitpos);\n\n    A1[0] = A[0];\n    A2[0] = d11;\n\n    A1[1] = b11;\n    A2[1] = c12;\n\n    A1[2] = c11;\n    A2[2] = b13;\n\n    A1[3] = d11;\n    A2[3] = A[3];\n\n    if (axis == 1) { A1 = transpose(A1); A2 = transpose(A2); }\n}\n\nmat4 middleHalf(mat4 A) {\n    mat4 A1; mat4 A2; mat4 A3;\n    deCasteljauSplit(A, 0, A1, A2, 1.0/4.0);\n    deCasteljauSplit(A2, 0, A1, A3, 2.0/3.0);\n\n    deCasteljauSplit(A1, 1, A3, A2, 1.0/4.0);\n    deCasteljauSplit(A2, 1, A1, A3, 2.0/3.0);\n    return A1;\n}\n\nbool isSystemFeasible(mat4 A, mat4 B) {\n    // does there exist an X and Y such that B*X + A*Y has components that are all positive?\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            //TODO: figure out a more numerically stable way to do this test\n            vec2 smplold = vec2(A[i][j], B[i][j]);\n            float lensmpl = length(smplold); //if length is too small, the value of test could be erroniously close to zero\n            smplold = normalize(smplold);\n            mat4 test = (A*smplold.y - B*smplold.x);\n            vec4 epsi = vec4(-0.000001);\n            if (all(greaterThanEqual(test[0], epsi)) &&\n                all(greaterThanEqual(test[1], epsi)) &&\n                all(greaterThanEqual(test[2], epsi)) &&\n                all(greaterThanEqual(test[3], epsi)) &&\n                lensmpl > 0.02) return true;\n        }\n    }\n    return false;\n}\n\nvec3 evalBernstein(mat4 cpX, mat4 cpY, mat4 cpZ, vec2 uv) {\n    vec4 uvec_d3 = vec4(pow(1.0-uv.x, 3.), 3.0*uv.x*pow(1.0-uv.x, 2.), 3.0*pow(uv.x,2.)*(1.0-uv.x), pow(uv.x, 3.)); \n    vec4 vvec_d3 = vec4(pow(1.0-uv.y, 3.), 3.0*uv.y*pow(1.0-uv.y, 2.), 3.0*pow(uv.y,2.)*(1.0-uv.y), pow(uv.y, 3.)); \n\n    return vec3(dot((uvec_d3 * cpX), vvec_d3), dot((uvec_d3 * cpY), vvec_d3), dot((uvec_d3 * cpZ), vvec_d3));\n}\n\nmat3 jacobian(mat4 A, mat4 B, mat4 C, vec2 uv) {\n    vec2 epsilon= vec2(0.00001,0.0);\n    vec3 uv000 = evalBernstein(A, B, C, uv);\n    return mat3(\n        (uv000-evalBernstein(A, B, C, uv - epsilon.xy))/epsilon.x,\n        (uv000-evalBernstein(A, B, C, uv - epsilon.yx))/epsilon.x,\n         uv000);//passing the calculated point back in this unused column so the callers can use it\n}\n\nvec2 newtonsMethod(mat4 A, mat4 B, vec2 uv) {\n    mat3 fjcb = jacobian(A, B, B, uv);\n\n    mat2 jcb = mat2(fjcb[0].xy, fjcb[1].xy);\n\n    return uv - inverse(jcb) * fjcb[2].xy;\n}\n\n// the crux of the intersection routine comes down to the fact that if the system of equations\n// A*X + B*Y > 0 has no solutions, then the patch must not contain an intersection with the ray\n// if the system is feasible, then we can split the patch into quarters using de Casteljau's method\n// and test each quarter. We can repeatedly do this until we've isolated one or more very small areas\n// of the patch that might have an intersection. Then, we refine the midpoint of those areas\n// using newton's method, and then finally we decide which one is closest to the camera, and if it actually\n// intersects with the ray at all. the point that we find after all of this is the intersection point.\nbool doesIntersect(inout IntersectProblem p) {\n    // plane1 and 2 are planes in 3d space (defined by their normal + intersection along that normal)\n    // the intersection of plane1 and plane2 gives you the camera ray\n    vec4 plane1 = vec4(p.plane1, -dot(p.plane1, p.cameraOrigin));\n    vec4 plane2 = vec4(p.plane2, -dot(p.plane2, p.cameraOrigin));\n\n    mat4 A = plane1.x * p.cpX + plane1.y * p.cpY + plane1.z * p.cpZ + plane1.w;\n    mat4 B = plane2.x * p.cpX + plane2.y * p.cpY + plane2.z * p.cpZ + plane2.w;\n    \n    int read = 0;\n    int write = 0;\n    Split splits[SPLIT_QUEUE_SIZE];\n\n    if(!isSystemFeasible(A, B)) splits[write++ % SPLIT_QUEUE_SIZE] = Split(vec2(0.0), vec2(1.0), A, B);\n\n    // ugly hack to force this not to unroll, otherwise it can take minutes to compile\n    for (int i = 0; i < 12+donttouch && write != read; i++) {\n        Split s = splits[read++ % SPLIT_QUEUE_SIZE];\n        mat4 A1; mat4 A2;\n        deCasteljauSplit(s.A, 0, A1, A2, 0.5);\n        mat4 B1; mat4 B2;\n        deCasteljauSplit(s.B, 0, B1, B2, 0.5);\n\n        mat4 A11; mat4 A12;\n        deCasteljauSplit(A1, 1, A11, A12, 0.5);\n        mat4 B11; mat4 B12;\n        deCasteljauSplit(B1, 1, B11, B12, 0.5);\n        mat4 A21; mat4 A22;\n        deCasteljauSplit(A2, 1, A21, A22, 0.5);\n        mat4 B21; mat4 B22;\n        deCasteljauSplit(B2, 1, B21, B22, 0.5);\n\n        vec3 newsize = vec3(s.size/2.0, 0.0);\n        if (!isSystemFeasible(A11, B11)) splits[write++ % SPLIT_QUEUE_SIZE] = Split(s.topleft + newsize.zz, newsize.xy, A11, B11);\n        if (!isSystemFeasible(A12, B12)) splits[write++ % SPLIT_QUEUE_SIZE] = Split(s.topleft + newsize.xz, newsize.xy, A12, B12);\n        if (!isSystemFeasible(A21, B21)) splits[write++ % SPLIT_QUEUE_SIZE] = Split(s.topleft + newsize.zy, newsize.xy, A21, B21);\n        if (!isSystemFeasible(A22, B22)) splits[write++ % SPLIT_QUEUE_SIZE] = Split(s.topleft + newsize.xy, newsize.xy, A22, B22);\n    }\n\n    if (write == read) return false;\n\n    float mindist = -1.0;\n    for (int i = read; i < write; i++) {\n\n        Split s = splits[i % SPLIT_QUEUE_SIZE];\n        vec2 uv = s.topleft + s.size/2.0;\n        for (int j = 0; j < 6; j++) {\n        \tuv = newtonsMethod(A, B, uv);\n        }\n        mat3 jcb = jacobian(p.cpX, p.cpY, p.cpZ, uv);\n        vec4 point = vec4(jcb[2], 1.0);\n        float dist = distance(point.xyz, p.cameraOrigin);\n        if ((mindist < 0.0 || dist < mindist) && all(lessThan(uv, vec2(1.0))) && all(greaterThan(uv, vec2(0.0))) && abs(dot(point, plane1)) < 0.001 && abs(dot(point, plane2)) < 0.001 ) {\n            mindist = dist;\n            p.point = point.xyz;\n            p.normal = normalize(cross(jcb[0], jcb[1]));\n        }\n    }\n    \n    return (mindist != -1.0);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)*2.0 - vec2(1.0,1.0);\n    uv.y *= iResolution.y/iResolution.x;\n    // Camera parameters\n    float orbitdist = -5.0;\n    vec3 cameraOrigin = vec3(orbitdist*cos(iTime*0.1), orbitdist*sin(iTime*0.1), 2.0);\n    vec3 cameraDirection = normalize(-cameraOrigin);\n\n    vec3 plateXAxis = normalize(cross(cameraDirection, vec3(0.0,0.0,-1.0)));\n    vec3 plateYAxis = normalize(cross(cameraDirection, plateXAxis));\n    \n    float fov = radians(50.0);\n    vec3 platePoint = (plateXAxis * uv.x + plateYAxis * uv.y) * tan(fov /2.0);\n    \n    vec3 rayDirection = normalize(platePoint + cameraDirection);\n    vec3 rayPlane1 = normalize(cross(rayDirection, vec3(0.0,0.0,-1.0)));\n    vec3 rayPlane2 = normalize(cross(rayDirection, rayPlane1));\n\n\t//these are the control points for the parametric patch, arranged like so:\n    \n    //  cp11 -- cp12 -- cp13 -- cp14\n    //    |       |       |       |\n    //    |       |       |       |\n    //  cp21 -- cp22 -- cp23 -- cp24\n    //    |       |       |       |\n    //    |       |       |       |\n    //  cp31 -- cp32 -- cp33 -- cp34\n    //    |       |       |       |\n    //    |       |       |       |\n    //  cp41 -- cp42 -- cp43 -- cp44\n\n    // currently the values have the x and y lie in a grid, but this can be changed\n    \n    vec3 cp11 = vec3(-1.00, -1.00,  cos(iTime));\n    vec3 cp12 = vec3(-1.00, -0.33, -cos(iTime));\n    vec3 cp13 = vec3(-1.00,  0.33,  cos(iTime));\n    vec3 cp14 = vec3(-1.00,  1.00, -cos(iTime));\n\n    vec3 cp21 = vec3(-0.33, -1.00,  sin(iTime));\n    vec3 cp22 = vec3(-0.33, -0.33, -sin(0.5*iTime)*2.0);\n    vec3 cp23 = vec3(-0.33,  0.33,  sin(0.5*iTime)*2.0);\n    vec3 cp24 = vec3(-0.33,  1.00, -sin(iTime));\n\n    vec3 cp31 = vec3( 0.33, -1.00, -cos(iTime));\n    vec3 cp32 = vec3( 0.33, -0.33,  cos(0.5*iTime)*2.0);\n    vec3 cp33 = vec3( 0.33,  0.33, -cos(0.5*iTime)*2.0);\n    vec3 cp34 = vec3( 0.33,  1.00,  cos(iTime));\n\n    vec3 cp41 = vec3( 1.00, -1.00, -sin(iTime));\n    vec3 cp42 = vec3( 1.00, -0.33,  sin(iTime));\n    vec3 cp43 = vec3( 1.00,  0.33, -sin(iTime));\n    vec3 cp44 = vec3( 1.00,  1.00,  sin(iTime));\n    \n    \n    mat4 cpX = mat4(cp11.x, cp12.x, cp13.x, cp14.x,\n                    cp21.x, cp22.x, cp23.x, cp24.x,\n                    cp31.x, cp32.x, cp33.x, cp34.x,\n                    cp41.x, cp42.x, cp43.x, cp44.x);\n\n    mat4 cpY = mat4(cp11.y, cp12.y, cp13.y, cp14.y,\n                    cp21.y, cp22.y, cp23.y, cp24.y,\n                    cp31.y, cp32.y, cp33.y, cp34.y,\n                    cp41.y, cp42.y, cp43.y, cp44.y);\n    \n    mat4 cpZ = mat4(cp11.z, cp12.z, cp13.z, cp14.z,\n                    cp21.z, cp22.z, cp23.z, cp24.z,\n                    cp31.z, cp32.z, cp33.z, cp34.z,\n                    cp41.z, cp42.z, cp43.z, cp44.z);\n\n    // if you are interested in subdivision modelling and the mathematics behind it,\n    // each quad face with no extraordinary verticies can be modelled as the middle portion\n    // of a bicubic patch. Change the ONLY_MIDDLE define to see\n#if ONLY_MIDDLE\n    cpX = middleHalf(cpX);\n    cpY = middleHalf(cpY);\n    cpZ = middleHalf(cpZ);\n#endif\n    \n    vec3 col = vec3(0);\n    IntersectProblem p = IntersectProblem(cpX, cpY, cpZ, rayPlane1, rayPlane2, cameraOrigin, vec3(0.0), vec3(0.0));\n    if (doesIntersect(p)) {\n        vec3 r = reflect(cameraDirection, p.normal);\n        float fac = length(sin(r*2.5)*0.5+0.5)/sqrt(3.);\n        col = mix(srgb(0.05,0.01,0.01), srgb(0.8,0.4,0.3), fac) + pow(fac, 9.);\n    }\n\n    fragColor = vec4(sqrt(col), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfXW2.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[509, 944, 1033, 1033, 1523], [1525, 1525, 1550, 1550, 1782], [1784, 1784, 1823, 1916, 2681], [2683, 2683, 2742, 2742, 3089], [3091, 3091, 3139, 3139, 3474], [3476, 3476, 3521, 3521, 3652], [3654, 4351, 4397, 4569, 7070], [7072, 7072, 7110, 7110, 7142], [7144, 7144, 7201, 7252, 10772]], "test": "error"}
{"id": "WsjSRR", "name": "HW 1", "author": "aredosbyk", "description": ".", "tags": ["none"], "likes": 4, "viewed": 112, "published": "Public", "date": "1552681061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 2   // make this 2 or 3 for antialiasing, make 1 to turn if off\n#define Mandelbulb 0 // make this 1 to turn it on - makes render slower\n\n\n//------------------------------------------------------------------\n// Distance functions\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdMandelbulb(vec3 pos) {\n    float Power = 8.0;\n    \n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 15 ; i++) {\n\t\tr = length(z);\n\t\tif (r>10.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n//------------------------------------------------------------------\n// Operation functions\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d2 : d1;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    // sky 0\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    \n    // lamp - stand 2\n    res = opU( res, opU( opU (\n        \t\t\t\tvec2(sdBox( pos-vec3(0.0, -0.05, 0.0), vec3(0.15)), 2.0),\n\t\t\t\t\t\tvec2(sdCylinder(  pos-vec3( 0.0,0.0,0.0), vec2(0.05,1.0) ), 2.0 ) ),\n                        vec2(sdCappedCone( pos-vec3( 0.0, 1.0, 0.0), 0.05, 0.05, 0.2), 2.0) ) );\n    \n    // lamp - light 3\n    res = opU( res, vec2(sdSphere(pos-vec3(0.0, 1.2, 0.0), 0.2), 3.0) );\n    \n    // torus 4\n    res = opU( res, vec2( sdBox(   pos-vec3( -2.0,0.25, 0.0), vec3(0.5,0.1, 0.5) ),4.0 ) );\n    \n#if Mandelbulb\n    // mandelbulb 7\n    res = opU( res, vec2( sdMandelbulb(   pos-vec3( 0.0,1.0, 3.0)),7.0 ) );\n#else\n    // sphere 7\n    res = opU( res, vec2( sdSphere(   pos-vec3( 0.0,0.25, 2.0), 0.2),7.0 ) );\n#endif\n    \n    // mirror 105\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(2.0,1.0, 0.0), vec3(0.05, 0.65, 0.85) ), 105.0 ) );\n    \n    // lens 106\n    res = opU( res, opI(\n        \t\t\tvec2(sdSphere(pos-vec3(0.0, 1.0, -2.3), 0.6), 106.0),\n                    vec2(sdSphere(pos-vec3(0.0, 1.0, -1.7), 0.6), 106.0)) );\n    \n    \n    return res;\n}\n\nvec2 map2( in vec3 pos )\n{\n    // sky 0\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    \n    // lamp - stand 2\n    res = opU( res, opU( opU (\n        \t\t\t\tvec2(sdBox( pos-vec3(0.0, -0.05, 0.0), vec3(0.15)), 2.0),\n\t\t\t\t\t\tvec2(sdCylinder(  pos-vec3( 0.0,0.0,0.0), vec2(0.05,1.0) ), 2.0 ) ),\n                        vec2(sdCappedCone( pos-vec3( 0.0, 1.0, 0.0), 0.05, 0.05, 0.2), 2.0) ) );\n    \n    // lamp - light 3\n    res = opU( res, vec2(sdSphere(pos-vec3(0.0, 1.2, 0.0), 0.2), 3.0) );\n    \n    // torus 4\n    res = opU( res, vec2( sdBox(   pos-vec3( -2.0,0.25, 0.0), vec3(0.5,0.1, 0.5) ),4.0 ) );\n    \n#if Mandelbulb\n    // mandelbulb 7\n    res = opU( res, vec2( sdMandelbulb(   pos-vec3( 0.0,1.0, 3.0)),7.0 ) );\n#else\n    // sphere 7\n    res = opU( res, vec2( sdSphere(   pos-vec3( 0.0,0.25, 2.0), 0.2),7.0 ) );\n#endif\n\n    // mirror 105\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(2.0,1.0, 0.0), vec3(0.05, 0.65, 0.85) ), 105.0 ) );\n    \n    \n    return res;\n}\n\nvec2 map3( in vec3 pos )\n{\n    // sky 0\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    \n    // lamp - stand 2\n    res = opU( res, opU( opU (\n        \t\t\t\tvec2(sdBox( pos-vec3(0.0, -0.05, 0.0), vec3(0.15)), 2.0),\n\t\t\t\t\t\tvec2(sdCylinder(  pos-vec3( 0.0,0.0,0.0), vec2(0.05,1.0) ), 2.0 ) ),\n                        vec2(sdCappedCone( pos-vec3( 0.0, 1.0, 0.0), 0.05, 0.05, 0.2), 2.0) ) );\n    \n    // lamp - light 3\n    res = opU( res, vec2(sdSphere(pos-vec3(0.0, 1.2, 0.0), 0.2), 3.0) );\n    \n    // torus 4\n    res = opU( res, vec2( sdBox(   pos-vec3( -2.0,0.25, 0.0), vec3(0.5,0.1, 0.5) ),4.0 ) );\n    \n#if Mandelbulb\n    // mandelbulb 7\n    res = opU( res, vec2( sdMandelbulb(   pos-vec3( 0.0,1.0, 3.0)),7.0 ) );\n#else\n    // sphere 7\n    res = opU( res, vec2( sdSphere(   pos-vec3( 0.0,0.25, 2.0), 0.2),7.0 ) );\n#endif\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n// Tetrahedrone trick\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, inout vec3 respos)\n{\n    vec2 res = vec2(-1.0,105);\n    while (res.y > 100.0) {\n    \tres = vec2(-1.0, -1.0);\n\t\t\n        float tmin = 1.0;\n        float tmax = 200.0;\n\n        // raytrace floor plane\n        float tp1 = (0.0-ro.y)/rd.y;\n        if( tp1>0.0 )\n        {\n            tmax = min( tmax, tp1 );\n            res = vec2( tp1, 1.0 );\n        }\n\n        // raymarch primitives \n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; ++i )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n        \n        if(res.y > 105.5) {\n        \tro = ro + rd * res.x;\n            vec3 nor = calcNormal(ro);\n            ro = ro - nor * 0.002;\n            rd = rd - nor;\n            \n            float r = 6.1;\n            float l = 0.0001;\n            float m = 0.0;\n            while (r - l > 0.001) {\n                m = (l + r) / 2.0;\n                if (map(ro + m * rd).x > 0.0) {\n                \tr = m;    \n                } else {\n                    l = m;\n                }\n            }\n            \n            ro = ro + m * rd;\n            nor = calcNormal(ro);\n            ro = ro + nor * 0.002;\n            rd = rd - nor;\n            \n            continue;\n        }\n        \n        if(res.y > 104.5) {\n        \tro = ro + rd * res.x;\n            vec3 nor = calcNormal(ro);\n            ro = ro + nor * 0.002;\n            rd = reflect(rd, nor);\n            continue;\n        }\n        \n        \n    }\n    \n    respos = ro + rd * res.x;\n    return res;\n}\n\nfloat calcFirstshadow( in vec3 pos)\n{\n    vec3 rd = normalize(pos - vec3(0.0, 1.2, 0.0));\n    vec3 ro = vec3(0.0, 1.2, 0.0) + rd * 0.2001;\n    \n    \n    float tmin = 1.0;\n    float tmax = 200.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n    }\n    \n    float t = tmin;\n    float light = 5.0;\n    float realdist = length(pos - vec3(0.0, 1.2, 0.0)) * 0.7;\n\n    // raymarch primitives   \n    for( int i=0; i<70 && t<tmax; ++i )\n    {\n        vec2 h = map2( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            if (length(ro + rd * t - pos) < 0.01) {\n                return light / (1.0 + realdist + realdist * realdist);\n            } else {\n                return 0.0;\n            }\n            break;\n        }\n        if (h.x < 0.1) {\n            light = light * h.x / 0.1;    \n        }\n        t += h.x;\n    }\n    \n    return light / (1.0 + realdist + realdist * realdist);\n}\n\nfloat calcMirrorshadow( in vec3 pos)\n{\n    if (pos.x > 2.0) {\n        return 0.0;\n    }\n    \n    vec3 rd = normalize(pos - vec3(4.0, 1.2, 0.0));\n    vec3 ro = vec3(4.0, 1.2, 0.0) + rd * 0.2001;\n    \n    \n    float tmin = 1.0;\n    float tmax = 200.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n    }\n    \n    float t = tmin;\n    float light = 5.0;\n    float realdist = length(pos - vec3(4.0, 1.2, 0.0)) * 0.7;\n\n    // raymarch primitives \n\n    for( int i=0; i<70 && t<tmax; ++i )\n    {\n        vec2 h = map3( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            if (length(ro + rd * t - pos) < 0.01) {\n                return light / (1.0 + realdist + realdist * realdist);\n            } else {\n                return 0.0;\n            }\n            break;\n        }\n        if (h.x < 0.1) {\n            light = light * h.x / 0.1;    \n        }\n        t += h.x;\n    }\n    \n    return light / (1.0 + realdist + realdist * realdist);\n}\n                         \nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec3 pos = vec3(0.0);\n    vec2 res = castRay(ro,rd,pos);\n    float t= res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material   \n        if (m > 6.5) {\n            col = vec3(0.8, 0.3, 0.3);\n        } else if (m > 3.5) {\n            col = vec3(0.3, 0.3, 0.8);\n        } else if (m > 2.5) {\n            return vec3(1.0);\n        } else if (m > 1.5) {\n            col = vec3(0.1);\n        } else {\n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float light = calcAO( pos, nor )/2.0 + calcFirstshadow(pos) + calcMirrorshadow(pos);\n        col = col*light;\n\n        // fog\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    // camera\t\n    vec3 ro = vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 241, 266, 266, 281], [283, 283, 318, 318, 344], [346, 346, 377, 377, 468], [470, 470, 529, 529, 623], [625, 625, 661, 661, 764], [767, 767, 792, 792, 811], [812, 812, 883, 883, 1221], [1223, 1223, 1253, 1253, 1798], [1800, 1893, 1926, 1926, 1952], [1954, 1954, 1984, 1984, 2017], [2019, 2019, 2049, 2049, 2082], [2084, 2154, 2179, 2192, 3305], [3307, 3307, 3333, 3346, 4267], [4269, 4269, 4295, 4308, 5105], [5107, 5193, 5225, 5225, 5433], [5435, 5435, 5493, 5493, 7096], [7098, 7098, 7135, 7135, 8066], [8068, 8068, 8106, 8106, 9090], [9117, 9117, 9159, 9159, 9472], [9474, 9550, 9586, 9607, 9830], [9832, 9832, 9871, 9871, 10814], [10816, 10816, 10868, 10868, 11045], [11047, 11047, 11104, 11104, 12050]], "test": "valid"}
{"id": "WsjXRD", "name": "magnetismilogo", "author": "kahvi", "description": "magnetismilogoa", "tags": ["magnetismilogo"], "likes": 4, "viewed": 107, "published": "Public", "date": "1553108409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec3 viiva(vec2 uv,float t)\n{\n    \n    float n;\n    float h = 4.;\n    float f = 5.4;\n    float c = step(mod(uv.x*40.,2.),.5);\n \tn = abs(step(uv.y*h,sin(uv.x*f+t))- step(uv.y*h,cos(uv.x*f+t)));\n    vec3 y = vec3(n*c*abs(sin(uv.x*49.+t)),n*c*abs(sin(uv.x*149.+t)),n*c*abs(sin(uv.x*89.+t)));\n    return y;\n}\nvec3 ympyra(vec2 offset,vec2 uv,float r,float v ,float t)\n{\n    float c =  step(0.,1.- length(uv+offset)-r)-step(0.,1.- length(uv+offset)-(r+0.01));\n    vec3 y= vec3(abs(sin(v*190.)*c),abs(sin(v*200.)*c),abs(sin(v*100.)*c));\n    return y;\n}\n\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;  \n    uv.x *= iResolution.x / iResolution.y;\n\tfloat skip = 2.;\n    float ymp = 2.;\n     float t = iTime/2.;\n    float vari;\n    vec3 c;\n     c += viiva(uv,t);\n        for(float i = 0.; i < 3.1415*ymp; i= i + 0.1){\n            \t c += ympyra(vec2(sin(i*skip),cos(i*skip+t))*0.4,uv,.97,i,t);\n        }\n      for(float i = 0.; i < 3.14*ymp; i= i + 0.1){\n            \t c += ympyra(vec2(sin(i*skip+t),cos(i*skip))*0.65,uv,.96,i,t);\n        }\n      for(float i = 0.; i < 3.14*ymp; i= i + 0.1){\n            \t c += ympyra(vec2(sin(i*skip+t),cos(i*skip+t))*0.9,uv,.95,i,t);\n        }\n    \n\n    fragColor = vec4(c,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjXRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 31, 31, 306], [307, 307, 366, 366, 547], [555, 555, 612, 612, 1283]], "test": "valid"}
{"id": "wsjXWR", "name": "Rainbow Fractal Spiral", "author": "kvick", "description": "runs slow cause of branching but was fun to make", "tags": ["fractal", "rainbow"], "likes": 4, "viewed": 105, "published": "Public", "date": "1553488154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 func(float t)\n{\n \treturn vec2(\n        t * sin(t),\n        t * cos(t)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv;\n    st -= vec2(0.5);\n    st *= vec2(0.5 * (iResolution.x / iResolution.y), 0.5);\n    \n    vec3 col = vec3(0.);\n    \n    st *= 55.0;\n    \n    for (float i = 0.; i < 350.; i += 0.25)\n    {\n        vec2 result = func(mod((iTime + i * i) * 1.1, 30.0));\n\t\t\n        float dist = length(result - st);\n        float res = (dist < i * 0.01) ? 1.0: 0.0;\n        \n        float id = floor(mod(i, 3.0));\n        vec3 col1 = vec3(1., 0., 0.);\n        vec3 col2 = vec3(0., 1., 0.);\n        vec3 col3 = vec3(0., 0., 1.);\n        col += ((id == 0.) ? col1 : (id == 1.) ? col2 : col3)\n            * (res * 0.015 / dist);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 83], [85, 85, 142, 142, 872]], "test": "valid"}
{"id": "wsjXz1", "name": "gun", "author": "changjiu", "description": "gun", "tags": ["gun"], "likes": 2, "viewed": 287, "published": "Public API", "date": "1552989793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * @author changjiu\n * @date 2019.3.19\n**/\n\n#define triangleCount 550\n\nstruct Triangle\n{\n    \n    vec3 a; //pointA\n    vec3 b;\t//pointB\n    vec3 c;\t//pointC\n    vec3 n; //normal\n\n};\n\nTriangle triangles[triangleCount];\n\nvoid getOneCube( void )\n{ \n\ntriangles[0].a = vec3(-3.494937612924673,0.6099995117187405,-1.5881999990344047);\ntriangles[0].b = vec3(1.146358773794077,0.6118000488281155,-1.5881999990344047);\ntriangles[0].c = vec3(-3.494937612924673,0.6096943359374905,-1.1174000239372253);\ntriangles[0].n = vec3(0.00038793829257979443,-0.9999997146659426,-0.0006482066914085197);\ntriangles[1].a = vec3(1.146358773794077,0.6114948730468655,-1.1173000073432922);\ntriangles[1].b = vec3(-3.494937612924673,0.6096943359374905,-1.1174000239372253);\ntriangles[1].c = vec3(1.146358773794077,0.6118000488281155,-1.5881999990344047);\ntriangles[1].n = vec3(0.0003879522580327873,-0.9999997147497575,-0.0006480690158914141);\ntriangles[2].a = vec3(1.4524653411768895,1.6920002441406155,0.2742999458312989);\ntriangles[2].b = vec3(1.4525568939112645,1.4491108398437405,0.19520005226135262);\ntriangles[2].c = vec3(2.4785578704737645,1.7071064453124905,0.3196999692916871);\ntriangles[2].n = vec3(-0.03748531942118247,-0.3094506428614092,0.9501763786058632);\ntriangles[3].a = vec3(2.478664681997202,1.4108112792968655,0.22320004940032967);\ntriangles[3].b = vec3(2.4785578704737645,1.7071064453124905,0.3196999692916871);\ntriangles[3].c = vec3(1.4525568939112645,1.4491108398437405,0.19520005226135262);\ntriangles[3].n = vec3(-0.03747891974207218,-0.3094727418084698,0.9501694336551327);\ntriangles[4].a = vec3(1.4525568939112645,1.4491108398437405,0.19520005226135262);\ntriangles[4].b = vec3(1.4525568939112645,1.4492023925781155,-0.060300025939941326);\ntriangles[4].c = vec3(2.478664681997202,1.4108112792968655,0.22320004940032967);\ntriangles[4].n = vec3(-0.03728935243293821,-0.9993044460898816,-0.00035807838164552113);\ntriangles[5].a = vec3(2.478664681997202,1.4110859374999905,-0.08840003967285148);\ntriangles[5].b = vec3(2.478664681997202,1.4108112792968655,0.22320004940032967);\ntriangles[5].c = vec3(1.4525568939112645,1.4492023925781155,-0.060300025939941326);\ntriangles[5].n = vec3(-0.037145110273241515,-0.9993094940562095,-0.0008808359163811753);\ntriangles[6].a = vec3(1.4525568939112645,1.4492023925781155,-0.060300025939941326);\ntriangles[6].b = vec3(1.4524653411768895,1.6923054199218655,-0.13909998893737785);\ntriangles[6].c = vec3(2.478664681997202,1.4110859374999905,-0.08840003967285148);\ntriangles[6].n = vec3(-0.03747877860843745,-0.3081441130668077,-0.9506011501867071);\ntriangles[7].a = vec3(2.4785578704737645,1.7074116210937405,-0.18450001239776603);\ntriangles[7].b = vec3(2.478664681997202,1.4110859374999905,-0.08840003967285148);\ntriangles[7].c = vec3(1.4524653411768895,1.6923054199218655,-0.13909998893737785);\ntriangles[7].n = vec3(-0.03751923178032297,-0.3082833065771293,-0.9505544224990414);\ntriangles[8].a = vec3(1.4524653411768895,1.6923054199218655,-0.13909998893737785);\ntriangles[8].b = vec3(1.452358529653452,1.8422993164062405,0.06769999504089363);\ntriangles[8].c = vec3(2.4785578704737645,1.7074116210937405,-0.18450001239776603);\ntriangles[8].n = vec3(-0.03786859107080683,0.8089016250673263,-0.5867232147902032);\ntriangles[9].a = vec3(2.4784663177393895,1.8903950195312405,0.06769999504089363);\ntriangles[9].b = vec3(2.4785578704737645,1.7074116210937405,-0.18450001239776603);\ntriangles[9].c = vec3(1.452358529653452,1.8422993164062405,0.06769999504089363);\ntriangles[9].n = vec3(-0.03791056942970515,0.8088109335150325,-0.5868455184731817);\ntriangles[10].a = vec3(2.4784663177393895,1.8903950195312405,0.06769999504089363);\ntriangles[10].b = vec3(3.3773615814112645,1.8430927734374905,0.06769999504089363);\ntriangles[10].c = vec3(2.4785578704737645,1.7074116210937405,-0.18450001239776603);\ntriangles[10].n = vec3(0.042554536586253876,0.8086734678374891,-0.5867165702718979);\ntriangles[11].a = vec3(3.377468392934702,1.6930073242187405,-0.13909998893737785);\ntriangles[11].b = vec3(2.4785578704737645,1.7074116210937405,-0.18450001239776603);\ntriangles[11].c = vec3(3.3773615814112645,1.8430927734374905,0.06769999504089363);\ntriangles[11].n = vec3(0.042594741291915386,0.8085971669318419,-0.5868188047805505);\ntriangles[12].a = vec3(2.4785578704737645,1.7074116210937405,-0.18450001239776603);\ntriangles[12].b = vec3(3.377468392934702,1.6930073242187405,-0.13909998893737785);\ntriangles[12].c = vec3(2.478664681997202,1.4110859374999905,-0.08840003967285148);\ntriangles[12].n = vec3(0.04305956863118548,-0.308188109742196,-0.9503504419753949);\ntriangles[13].a = vec3(3.377559945669077,1.4499958496093655,-0.060300025939941326);\ntriangles[13].b = vec3(2.478664681997202,1.4110859374999905,-0.08840003967285148);\ntriangles[13].c = vec3(3.377468392934702,1.6930073242187405,-0.13909998893737785);\ntriangles[13].n = vec3(0.04304771422607352,-0.3081524900451345,-0.9503625293428261);\ntriangles[14].a = vec3(2.478664681997202,1.4110859374999905,-0.08840003967285148);\ntriangles[14].b = vec3(3.377559945669077,1.4499958496093655,-0.060300025939941326);\ntriangles[14].c = vec3(2.478664681997202,1.4108112792968655,0.22320004940032967);\ntriangles[14].n = vec3(0.04327333329471131,-0.9990628824736452,-0.0008806185419435158);\ntriangles[15].a = vec3(3.377559945669077,1.4498127441406155,0.19520005226135262);\ntriangles[15].b = vec3(2.478664681997202,1.4108112792968655,0.22320004940032967);\ntriangles[15].c = vec3(3.377559945669077,1.4499958496093655,-0.060300025939941326);\ntriangles[15].n = vec3(0.04332516532443803,-0.9990607676308785,-0.0007159821298475845);\ntriangles[16].a = vec3(2.478664681997202,1.4108112792968655,0.22320004940032967);\ntriangles[16].b = vec3(3.377559945669077,1.4498127441406155,0.19520005226135262);\ntriangles[16].c = vec3(2.4785578704737645,1.7071064453124905,0.3196999692916871);\ntriangles[16].n = vec3(0.043014153713381444,-0.30937746313880077,0.9499659824868054);\ntriangles[17].a = vec3(3.377468392934702,1.6927937011718655,0.2742999458312989);\ntriangles[17].b = vec3(2.4785578704737645,1.7071064453124905,0.3196999692916871);\ntriangles[17].c = vec3(3.377559945669077,1.4498127441406155,0.19520005226135262);\ntriangles[17].n = vec3(0.04305668671308032,-0.30924827174985753,0.9500061200587174);\ntriangles[18].a = vec3(2.4785578704737645,1.7071064453124905,0.3196999692916871);\ntriangles[18].b = vec3(3.377468392934702,1.6927937011718655,0.2742999458312989);\ntriangles[18].c = vec3(2.4784663177393895,1.8903950195312405,0.06769999504089363);\ntriangles[18].n = vec3(0.04254527185687707,0.8079869606013591,0.5876622936183691);\ntriangles[19].a = vec3(3.3773615814112645,1.8430927734374905,0.06769999504089363);\ntriangles[19].b = vec3(2.4784663177393895,1.8903950195312405,0.06769999504089363);\ntriangles[19].c = vec3(3.377468392934702,1.6927937011718655,0.2742999458312989);\ntriangles[19].n = vec3(0.04251553882314582,0.8079323845392,0.5877394754237458);\ntriangles[20].a = vec3(2.4785578704737645,1.7071064453124905,0.3196999692916871);\ntriangles[20].b = vec3(2.4784663177393895,1.8903950195312405,0.06769999504089363);\ntriangles[20].c = vec3(1.4524653411768895,1.6920002441406155,0.2742999458312989);\ntriangles[20].n = vec3(-0.03790440317340679,0.8081241488816152,0.5877913032824092);\ntriangles[21].a = vec3(1.452358529653452,1.8422993164062405,0.06769999504089363);\ntriangles[21].b = vec3(1.4524653411768895,1.6920002441406155,0.2742999458312989);\ntriangles[21].c = vec3(2.4784663177393895,1.8903950195312405,0.06769999504089363);\ntriangles[21].n = vec3(-0.03787553831353478,0.8080635548763557,0.5878764622589059);\ntriangles[22].a = vec3(3.1057551360987645,1.9398945312499905,-1.3517999982833862);\ntriangles[22].b = vec3(3.1057551360987645,1.8599079589843655,-1.1591000294685363);\ntriangles[22].c = vec3(3.555568978872202,1.8820026855468655,-1.3519000148773193);\ntriangles[22].n = vec3(0.11812083124417173,0.9171293388302658,0.3806852309755995);\ntriangles[23].a = vec3(3.555568978872202,1.8190144042968655,-1.2001999950408935);\ntriangles[23].b = vec3(3.555568978872202,1.8820026855468655,-1.3519000148773193);\ntriangles[23].c = vec3(3.1057551360987645,1.8599079589843655,-1.1591000294685363);\ntriangles[23].n = vec3(0.11816674552781181,0.9170812411684309,0.3807868397782882);\ntriangles[24].a = vec3(3.1057551360987645,1.8599079589843655,-1.1591000294685363);\ntriangles[24].b = vec3(3.105861947622202,1.6670063476562405,-1.0793000197410583);\ntriangles[24].c = vec3(3.555568978872202,1.8190144042968655,-1.2001999950408935);\ntriangles[24].n = vec3(0.11834953436852495,0.379633882586707,0.9175355594781577);\ntriangles[25].a = vec3(3.555660531606577,1.6673115234374905,-1.137400004863739);\ntriangles[25].b = vec3(3.555568978872202,1.8190144042968655,-1.2001999950408935);\ntriangles[25].c = vec3(3.105861947622202,1.6670063476562405,-1.0793000197410583);\ntriangles[25].n = vec3(0.11824857509668035,0.3798663807422406,0.9174523460482272);\ntriangles[26].a = vec3(3.105861947622202,1.6670063476562405,-1.0793000197410583);\ntriangles[26].b = vec3(3.105861947622202,1.4742878417968655,-1.1593000030517577);\ntriangles[26].c = vec3(3.555660531606577,1.6673115234374905,-1.137400004863739);\ntriangles[26].n = vec3(0.11871319120181771,-0.3806813533179459,0.9170544615619609);\ntriangles[27].a = vec3(3.555660531606577,1.5156086425781155,-1.2003999984264373);\ntriangles[27].b = vec3(3.555660531606577,1.6673115234374905,-1.137400004863739);\ntriangles[27].c = vec3(3.105861947622202,1.4742878417968655,-1.1593000030517577);\ntriangles[27].n = vec3(0.11877288824936118,-0.3808133680424543,0.9169919191231007);\ntriangles[28].a = vec3(3.105861947622202,1.4742878417968655,-1.1593000030517577);\ntriangles[28].b = vec3(3.1059687591456395,1.3945148925781155,-1.3522000050544738);\ntriangles[28].c = vec3(3.555660531606577,1.5156086425781155,-1.2003999984264373);\ntriangles[28].n = vec3(0.11896376397021012,-0.9175119594079797,0.37949891594755586);\ntriangles[29].a = vec3(3.5557673431300145,1.4528034667968655,-1.3522000050544738);\ntriangles[29].b = vec3(3.555660531606577,1.5156086425781155,-1.2003999984264373);\ntriangles[29].c = vec3(3.1059687591456395,1.3945148925781155,-1.3522000050544738);\ntriangles[29].n = vec3(0.11889091421670141,-0.9174519291308701,0.3796668384923315);\ntriangles[30].a = vec3(3.5557673431300145,1.4528034667968655,-1.3522000050544738);\ntriangles[30].b = vec3(3.1059687591456395,1.3945148925781155,-1.3522000050544738);\ntriangles[30].c = vec3(3.555660531606577,1.5157917480468655,-1.5037999933958053);\ntriangles[30].n = vec3(0.11881819662601997,-0.916890785377439,-0.38104267981485174);\ntriangles[31].a = vec3(3.105861947622202,1.4745014648437405,-1.544900003671646);\ntriangles[31].b = vec3(3.555660531606577,1.5157917480468655,-1.5037999933958053);\ntriangles[31].c = vec3(3.1059687591456395,1.3945148925781155,-1.3522000050544738);\ntriangles[31].n = vec3(0.11896570951589823,-0.9170128503342821,-0.3807027610632402);\ntriangles[32].a = vec3(3.555660531606577,1.5157917480468655,-1.5037999933958053);\ntriangles[32].b = vec3(3.105861947622202,1.4745014648437405,-1.544900003671646);\ntriangles[32].c = vec3(3.555660531606577,1.6674946289062405,-1.566599998474121);\ntriangles[32].n = vec3(0.11869260533115944,-0.3797852723645686,-0.9174285870489715);\ntriangles[33].a = vec3(3.105861947622202,1.6674030761718655,-1.6246999984979629);\ntriangles[33].b = vec3(3.555660531606577,1.6674946289062405,-1.566599998474121);\ntriangles[33].c = vec3(3.105861947622202,1.4745014648437405,-1.544900003671646);\ntriangles[33].n = vec3(0.11859385452082069,-0.37956672417459025,-0.9175317975793892);\ntriangles[34].a = vec3(3.555660531606577,1.6674946289062405,-1.566599998474121);\ntriangles[34].b = vec3(3.105861947622202,1.6674030761718655,-1.6246999984979629);\ntriangles[34].c = vec3(3.555568978872202,1.8191975097656155,-1.5036000049114226);\ntriangles[34].n = vec3(0.11837177908174998,0.38089266697077817,-0.9170108495350038);\ntriangles[35].a = vec3(3.1057551360987645,1.8600910644531155,-1.5447000002861022);\ntriangles[35].b = vec3(3.555568978872202,1.8191975097656155,-1.5036000049114226);\ntriangles[35].c = vec3(3.105861947622202,1.6674030761718655,-1.6246999984979629);\ntriangles[35].n = vec3(0.11841086290274926,0.3808026699736537,-0.9170431800561862);\ntriangles[36].a = vec3(3.555568978872202,1.8191975097656155,-1.5036000049114226);\ntriangles[36].b = vec3(3.1057551360987645,1.8600910644531155,-1.5447000002861022);\ntriangles[36].c = vec3(3.555568978872202,1.8820026855468655,-1.3519000148773193);\ntriangles[36].n = vec3(0.11811676847398299,0.9174784204042996,-0.3798444116973353);\ntriangles[37].a = vec3(3.1057551360987645,1.9398945312499905,-1.3517999982833862);\ntriangles[37].b = vec3(3.555568978872202,1.8820026855468655,-1.3519000148773193);\ntriangles[37].c = vec3(3.1057551360987645,1.8600910644531155,-1.5447000002861022);\ntriangles[37].n = vec3(0.11801094035046159,0.9175890184562667,-0.3796100777983442);\ntriangles[38].a = vec3(1.1320612884425145,1.8591145019531155,-1.1591000294685363);\ntriangles[38].b = vec3(1.132168099965952,1.6662128906249905,-1.0793000197410583);\ntriangles[38].c = vec3(3.1057551360987645,1.8599079589843655,-1.1591000294685363);\ntriangles[38].n = vec3(-0.00015367650936867004,0.38226440641959103,0.9240529746547046);\ntriangles[39].a = vec3(3.105861947622202,1.6670063476562405,-1.0793000197410583);\ntriangles[39].b = vec3(3.1057551360987645,1.8599079589843655,-1.1591000294685363);\ntriangles[39].c = vec3(1.132168099965952,1.6662128906249905,-1.0793000197410583);\ntriangles[39].n = vec3(-0.00015367650936867004,0.38226440641959103,0.9240529746547046);\ntriangles[40].a = vec3(1.132168099965952,1.6662128906249905,-1.0793000197410583);\ntriangles[40].b = vec3(1.132259652700327,1.4734943847656155,-1.1593000030517577);\ntriangles[40].c = vec3(3.105861947622202,1.6670063476562405,-1.0793000197410583);\ntriangles[40].n = vec3(0.00015412998636157133,-0.38339241299801013,0.9235855314476893);\ntriangles[41].a = vec3(3.105861947622202,1.4742878417968655,-1.1593000030517577);\ntriangles[41].b = vec3(3.105861947622202,1.6670063476562405,-1.0793000197410583);\ntriangles[41].c = vec3(1.132259652700327,1.4734943847656155,-1.1593000030517577);\ntriangles[41].n = vec3(0.00015413716135284327,-0.3833924754557588,0.9235855055194625);\ntriangles[42].a = vec3(1.132259652700327,1.4734943847656155,-1.1593000030517577);\ntriangles[42].b = vec3(1.132259652700327,1.3938129882812405,-1.3522000050544738);\ntriangles[42].c = vec3(3.105861947622202,1.4742878417968655,-1.1593000030517577);\ntriangles[42].n = vec3(0.0003715817302100182,-0.924252387477388,0.3817818567839051);\ntriangles[43].a = vec3(3.1059687591456395,1.3945148925781155,-1.3522000050544738);\ntriangles[43].b = vec3(3.105861947622202,1.4742878417968655,-1.1593000030517577);\ntriangles[43].c = vec3(1.132259652700327,1.3938129882812405,-1.3522000050544738);\ntriangles[43].n = vec3(0.0003286340442255228,-0.9240974997071119,0.3821566472465575);\ntriangles[44].a = vec3(3.1059687591456395,1.3945148925781155,-1.3522000050544738);\ntriangles[44].b = vec3(1.132259652700327,1.3938129882812405,-1.3522000050544738);\ntriangles[44].c = vec3(3.105861947622202,1.4745014648437405,-1.544900003671646);\ntriangles[44].n = vec3(0.00032845538583065666,-0.9235951239523829,-0.3833691942872333);\ntriangles[45].a = vec3(1.132259652700327,1.4737995605468655,-1.5449999979138374);\ntriangles[45].b = vec3(3.105861947622202,1.4745014648437405,-1.544900003671646);\ntriangles[45].c = vec3(1.132259652700327,1.3938129882812405,-1.3522000050544738);\ntriangles[45].n = vec3(0.0003479133417202171,-0.9236655739269446,-0.3831994082700477);\ntriangles[46].a = vec3(3.105861947622202,1.4745014648437405,-1.544900003671646);\ntriangles[46].b = vec3(1.132259652700327,1.4737995605468655,-1.5449999979138374);\ntriangles[46].c = vec3(3.105861947622202,1.6674030761718655,-1.6246999984979629);\ntriangles[46].n = vec3(0.0001827688451973268,-0.38226441625663743,-0.9240529652890692);\ntriangles[47].a = vec3(1.132168099965952,1.6666096191406155,-1.6246999984979629);\ntriangles[47].b = vec3(3.105861947622202,1.6674030761718655,-1.6246999984979629);\ntriangles[47].c = vec3(1.132259652700327,1.4737995605468655,-1.5449999979138374);\ntriangles[47].n = vec3(0.00015357427429407147,-0.3820101006036454,-0.9241581355221278);\ntriangles[48].a = vec3(3.105861947622202,1.6674030761718655,-1.6246999984979629);\ntriangles[48].b = vec3(1.132168099965952,1.6666096191406155,-1.6246999984979629);\ntriangles[48].c = vec3(3.1057551360987645,1.8600910644531155,-1.5447000002861022);\ntriangles[48].n = vec3(-0.0001541508286243381,0.383444257325017,-0.9235640084812684);\ntriangles[49].a = vec3(1.1320612884425145,1.8593891601562405,-1.5447000002861022);\ntriangles[49].b = vec3(3.1057551360987645,1.8600910644531155,-1.5447000002861022);\ntriangles[49].c = vec3(1.132168099965952,1.6666096191406155,-1.6246999984979629);\ntriangles[49].n = vec3(-0.00013630895325686678,0.38328892360585226,-0.9236284872506568);\ntriangles[50].a = vec3(3.1057551360987645,1.8600910644531155,-1.5447000002861022);\ntriangles[50].b = vec3(1.1320612884425145,1.8593891601562405,-1.5447000002861022);\ntriangles[50].c = vec3(3.1057551360987645,1.9398945312499905,-1.3517999982833862);\ntriangles[50].n = vec3(-0.0003286182449504312,0.9240459293010517,-0.3822813264497824);\ntriangles[51].a = vec3(1.1320612884425145,1.9391010742187405,-1.3519000148773193);\ntriangles[51].b = vec3(3.1057551360987645,1.9398945312499905,-1.3517999982833862);\ntriangles[51].c = vec3(1.1320612884425145,1.8593891601562405,-1.5447000002861022);\ntriangles[51].n = vec3(-0.0003521540028380696,0.924130855218931,-0.38207595896612706);\ntriangles[52].a = vec3(1.1320612884425145,1.9391010742187405,-1.3519000148773193);\ntriangles[52].b = vec3(1.1320612884425145,1.8591145019531155,-1.1591000294685363);\ntriangles[52].c = vec3(3.1057551360987645,1.9398945312499905,-1.3517999982833862);\ntriangles[52].n = vec3(-0.0003907471412490603,0.9236655540733184,0.3831994148418043);\ntriangles[53].a = vec3(3.1057551360987645,1.8599079589843655,-1.1591000294685363);\ntriangles[53].b = vec3(3.1057551360987645,1.9398945312499905,-1.3517999982833862);\ntriangles[53].c = vec3(1.1320612884425145,1.8591145019531155,-1.1591000294685363);\ntriangles[53].n = vec3(-0.0003713002751182929,0.9235951535769414,0.38336908381518153);\ntriangles[54].a = vec3(3.555568978872202,1.8191975097656155,-1.5036000049114226);\ntriangles[54].b = vec3(14.490360543813608,1.8235004882812405,-1.5035000032186507);\ntriangles[54].c = vec3(3.555660531606577,1.6674946289062405,-1.566599998474121);\ntriangles[54].n = vec3(-0.00014247722496019342,0.38352811523660146,-0.9235291898599094);\ntriangles[55].a = vec3(14.490360543813608,1.8235004882812405,-1.5035000032186507);\ntriangles[55].b = vec3(3.555568978872202,1.8191975097656155,-1.5036000049114226);\ntriangles[55].c = vec3(14.490360543813608,1.8862141113281155,-1.3517000114917754);\ntriangles[55].n = vec3(-0.000360205044348979,0.9242320900935779,-0.3818310017449904);\ntriangles[56].a = vec3(3.555568978872202,1.8820026855468655,-1.3519000148773193);\ntriangles[56].b = vec3(14.490360543813608,1.8862141113281155,-1.3517000114917754);\ntriangles[56].c = vec3(3.555568978872202,1.8191975097656155,-1.5036000049114226);\ntriangles[56].n = vec3(-0.0003488521318536756,0.9239462539984988,-0.38252215363862496);\ntriangles[57].a = vec3(3.555568978872202,1.8820026855468655,-1.3519000148773193);\ntriangles[57].b = vec3(3.555568978872202,1.8190144042968655,-1.2001999950408935);\ntriangles[57].c = vec3(14.490360543813608,1.8862141113281155,-1.3517000114917754);\ntriangles[57].n = vec3(-0.00036271069652548673,0.9235518004327081,0.3834735197617355);\ntriangles[58].a = vec3(14.490360543813608,1.8232868652343655,-1.1999999916553497);\ntriangles[58].b = vec3(14.490360543813608,1.8862141113281155,-1.3517000114917754);\ntriangles[58].c = vec3(3.555568978872202,1.8190144042968655,-1.2001999950408935);\ntriangles[58].n = vec3(-0.00036791132761749483,0.9236833619620175,0.38315651041813154);\ntriangles[59].a = vec3(3.555568978872202,1.8190144042968655,-1.2001999950408935);\ntriangles[59].b = vec3(3.555660531606577,1.6673115234374905,-1.137400004863739);\ntriangles[59].c = vec3(14.490360543813608,1.8232868652343655,-1.1999999916553497);\ntriangles[59].n = vec3(-0.0001663464748815805,0.3824889008856128,0.9239600711222138);\ntriangles[60].a = vec3(14.490459725942515,1.6714924316406155,-1.1372999882698058);\ntriangles[60].b = vec3(14.490360543813608,1.8232868652343655,-1.1999999916553497);\ntriangles[60].c = vec3(3.555660531606577,1.6673115234374905,-1.137400004863739);\ntriangles[60].n = vec3(-0.00015442394620207984,0.38177204030979905,0.924256504110703);\ntriangles[61].a = vec3(3.555660531606577,1.6673115234374905,-1.137400004863739);\ntriangles[61].b = vec3(3.555660531606577,1.5156086425781155,-1.2003999984264373);\ntriangles[61].c = vec3(14.490459725942515,1.6714924316406155,-1.1372999882698058);\ntriangles[61].n = vec3(0.00013819439048384734,-0.3835281888042909,0.923529159959127);\ntriangles[62].a = vec3(14.490459725942515,1.5199116210937405,-1.2003000116348266);\ntriangles[62].b = vec3(14.490459725942515,1.6714924316406155,-1.1372999882698058);\ntriangles[62].c = vec3(3.555660531606577,1.5156086425781155,-1.2003999984264373);\ntriangles[62].n = vec3(0.00014258311959668444,-0.38379172603621253,0.9234196720322775);\ntriangles[63].a = vec3(3.555660531606577,1.5156086425781155,-1.2003999984264373);\ntriangles[63].b = vec3(3.5557673431300145,1.4528034667968655,-1.3522000050544738);\ntriangles[63].c = vec3(14.490459725942515,1.5199116210937405,-1.2003000116348266);\ntriangles[63].n = vec3(0.0003601234884771476,-0.9240352202205981,0.3823071829078603);\ntriangles[64].a = vec3(14.49055890807142,1.4571064453124905,-1.35200000166893);\ntriangles[64].b = vec3(14.490459725942515,1.5199116210937405,-1.2003000116348266);\ntriangles[64].c = vec3(3.5557673431300145,1.4528034667968655,-1.3522000050544738);\ntriangles[64].n = vec3(0.0003565879355463047,-0.923946169079194,0.3825223516200403);\ntriangles[65].a = vec3(14.49055890807142,1.4571064453124905,-1.35200000166893);\ntriangles[65].b = vec3(3.5557673431300145,1.4528034667968655,-1.3522000050544738);\ntriangles[65].c = vec3(14.490459725942515,1.5200031738281155,-1.5037000066041946);\ntriangles[65].n = vec3(0.00037051214786058796,-0.9237490169406942,-0.3829981937579467);\ntriangles[66].a = vec3(3.555660531606577,1.5157917480468655,-1.5037999933958053);\ntriangles[66].b = vec3(14.490459725942515,1.5200031738281155,-1.5037000066041946);\ntriangles[66].c = vec3(3.5557673431300145,1.4528034667968655,-1.3522000050544738);\ntriangles[66].n = vec3(0.0003591703732343534,-0.9234620827112688,-0.3836895265591814);\ntriangles[67].a = vec3(14.490459725942515,1.5200031738281155,-1.5037000066041946);\ntriangles[67].b = vec3(3.555660531606577,1.5157917480468655,-1.5037999933958053);\ntriangles[67].c = vec3(14.490459725942515,1.6717976074218655,-1.5664000025391578);\ntriangles[67].n = vec3(0.00015548692051206515,-0.3817720876873807,-0.9242564843627752);\ntriangles[68].a = vec3(3.555660531606577,1.6674946289062405,-1.566599998474121);\ntriangles[68].b = vec3(14.490459725942515,1.6717976074218655,-1.5664000025391578);\ntriangles[68].c = vec3(3.555660531606577,1.5157917480468655,-1.5037999933958053);\ntriangles[68].n = vec3(0.00016741326814232157,-0.3824890640001346,-0.923960003405504);\ntriangles[69].a = vec3(14.490459725942515,1.6717976074218655,-1.5664000025391578);\ntriangles[69].b = vec3(3.555660531606577,1.6674946289062405,-1.566599998474121);\ntriangles[69].c = vec3(14.490360543813608,1.8235004882812405,-1.5035000032186507);\ntriangles[69].n = vec3(-0.0001338235063116546,0.3830087345740041,-0.9237447111249348);\ntriangles[70].a = vec3(3.4795649505518895,1.2953022460937405,-0.1727999782562255);\ntriangles[70].b = vec3(3.7046626068018895,1.2953937988281155,-0.1728999948501586);\ntriangles[70].c = vec3(3.4795649505518895,1.2949970703124905,0.3074999713897706);\ntriangles[70].n = vec3(0.0004064420782882973,-0.9999997155449177,-0.000635385647377492);\ntriangles[71].a = vec3(3.7046626068018895,1.2950886230468655,0.3074999713897706);\ntriangles[71].b = vec3(3.4795649505518895,1.2949970703124905,0.3074999713897706);\ntriangles[71].c = vec3(3.7046626068018895,1.2953937988281155,-0.1728999948501586);\ntriangles[71].n = vec3(0.00040672439622322715,-0.9999997155141744,-0.0006352533636095222);\ntriangles[72].a = vec3(3.4795649505518895,1.2949970703124905,0.3074999713897706);\ntriangles[72].b = vec3(3.7046626068018895,1.2950886230468655,0.3074999713897706);\ntriangles[72].c = vec3(3.479366586294077,1.7518146972656155,0.45630010604858406);\ntriangles[72].n = vec3(0.00012596888404431438,-0.30971549623695427,0.9508292672833213);\ntriangles[73].a = vec3(3.704464242544077,1.7519062499999905,0.45630010604858406);\ntriangles[73].b = vec3(3.479366586294077,1.7518146972656155,0.45630010604858406);\ntriangles[73].c = vec3(3.7046626068018895,1.2950886230468655,0.3074999713897706);\ntriangles[73].n = vec3(0.00012596888404431438,-0.30971549623695427,0.9508292672833213);\ntriangles[74].a = vec3(3.479366586294077,1.7518146972656155,0.45630010604858406);\ntriangles[74].b = vec3(3.704464242544077,1.7519062499999905,0.45630010604858406);\ntriangles[74].c = vec3(3.4792597747706395,2.0344990234374905,0.06780001163482674);\ntriangles[74].n = vec3(-0.00032887685261955935,0.8085985549739566,0.5883606621231959);\ntriangles[75].a = vec3(3.7043574310206395,2.0345905761718655,0.06780001163482674);\ntriangles[75].b = vec3(3.4792597747706395,2.0344990234374905,0.06780001163482674);\ntriangles[75].c = vec3(3.704464242544077,1.7519062499999905,0.45630010604858406);\ntriangles[75].n = vec3(-0.00032887685261955935,0.8085985549739566,0.5883606621231959);\ntriangles[76].a = vec3(3.7043574310206395,2.0345905761718655,0.06780001163482674);\ntriangles[76].b = vec3(3.704464242544077,1.7523945312499905,-0.32100001335144035);\ntriangles[76].c = vec3(3.4792597747706395,2.0344990234374905,0.06780001163482674);\ntriangles[76].n = vec3(-0.00032916118623984566,0.8092976365683672,-0.5873986951788099);\ntriangles[77].a = vec3(3.479458139028452,1.7523945312499905,-0.32100001335144035);\ntriangles[77].b = vec3(3.4792597747706395,2.0344990234374905,0.06780001163482674);\ntriangles[77].c = vec3(3.704464242544077,1.7523945312499905,-0.32100001335144035);\ntriangles[77].n = vec3(0,0.8093883169098522,-0.5872738308913796);\ntriangles[78].a = vec3(3.704464242544077,1.7523945312499905,-0.32100001335144035);\ntriangles[78].b = vec3(3.7046626068018895,1.2953937988281155,-0.1728999948501586);\ntriangles[78].c = vec3(3.479458139028452,1.7523945312499905,-0.32100001335144035);\ntriangles[78].n = vec3(0,-0.3082853856877514,-0.9512939193389992);\ntriangles[79].a = vec3(3.4795649505518895,1.2953022460937405,-0.1727999782562255);\ntriangles[79].b = vec3(3.479458139028452,1.7523945312499905,-0.32100001335144035);\ntriangles[79].c = vec3(3.7046626068018895,1.2953937988281155,-0.1728999948501586);\ntriangles[79].n = vec3(-0.00029722376414427097,-0.3084179170469204,-0.9512509133254343);\ntriangles[80].a = vec3(3.1381648040675145,1.6259907226562405,0.06749996185302742);\ntriangles[80].b = vec3(3.479458139028452,1.7523945312499905,-0.32100001335144035);\ntriangles[80].c = vec3(3.4795649505518895,1.2953022460937405,-0.1727999782562255);\ntriangles[80].n = vec3(-0.6956824835546832,-0.22169889076529295,-0.6832828725415461);\ntriangles[81].a = vec3(3.1381648040675145,1.6259907226562405,0.06749996185302742);\ntriangles[81].b = vec3(3.4792597747706395,2.0344990234374905,0.06780001163482674);\ntriangles[81].c = vec3(3.479458139028452,1.7523945312499905,-0.32100001335144035);\ntriangles[81].n = vec3(-0.6957233001641999,0.5812228597904638,-0.4220770982482102);\ntriangles[82].a = vec3(3.4795649505518895,1.2949970703124905,0.3074999713897706);\ntriangles[82].b = vec3(3.1381648040675145,1.6259907226562405,0.06749996185302742);\ntriangles[82].c = vec3(3.4795649505518895,1.2953022460937405,-0.1727999782562255);\ntriangles[82].n = vec3(-0.6959142445134938,-0.7181247496682146,-0.0004562862887586917);\ntriangles[83].a = vec3(-3.4120366119481105,1.9726093749999905,-1.111200008392334);\ntriangles[83].b = vec3(-3.4120366119481105,1.9724873046874905,-0.8667000269889831);\ntriangles[83].c = vec3(-3.480045034799673,2.1877888183593655,-1.1109999752044677);\ntriangles[83].n = vec3(-0.9535101124679914,-0.30136098417572116,-0.0001504590278595975);\ntriangles[84].a = vec3(-3.480045034799673,2.1876972656249905,-0.86660001039505);\ntriangles[84].b = vec3(-3.480045034799673,2.1877888183593655,-1.1109999752044677);\ntriangles[84].c = vec3(-3.4120366119481105,1.9724873046874905,-0.8667000269889831);\ntriangles[84].n = vec3(-0.9535223711239468,-0.30132221130409875,-0.00011287592612512824);\ntriangles[85].a = vec3(-3.480045034799673,2.1877888183593655,-1.1109999752044677);\ntriangles[85].b = vec3(-3.480045034799673,2.1876972656249905,-0.86660001039505);\ntriangles[85].c = vec3(-3.2963444732762355,2.3190144042968655,-1.1109000182151794);\ntriangles[85].n = vec3(-0.5812702441190166,0.8137105200180338,0.0003048176506712961);\ntriangles[86].a = vec3(-3.2963444732762355,2.3188923339843655,-0.8664999938011169);\ntriangles[86].b = vec3(-3.2963444732762355,2.3190144042968655,-1.1109000182151794);\ntriangles[86].c = vec3(-3.480045034799673,2.1876972656249905,-0.86660001039505);\ntriangles[86].n = vec3(-0.5811807438280304,0.8137744022747042,0.00040645534233612);\ntriangles[87].a = vec3(-3.2963444732762355,2.3190144042968655,-1.1109000182151794);\ntriangles[87].b = vec3(-3.2963444732762355,2.3188923339843655,-0.8664999938011169);\ntriangles[87].c = vec3(-3.114841177377798,2.1847980957031155,-1.1109999752044677);\ntriangles[87].n = vec3(0.5945678975509782,0.8040453058892245,0.0004015959572400447);\ntriangles[88].a = vec3(-3.114841177377798,2.1846149902343655,-0.86660001039505);\ntriangles[88].b = vec3(-3.114841177377798,2.1847980957031155,-1.1109999752044677);\ntriangles[88].c = vec3(-3.2963444732762355,2.3188923339843655,-0.8664999938011169);\ntriangles[88].n = vec3(0.5947426653630176,0.8039159155254022,0.0006022971429748417);\ntriangles[89].a = vec3(-3.114841177377798,2.1847980957031155,-1.1109999752044677);\ntriangles[89].b = vec3(-3.114841177377798,2.1846149902343655,-0.86660001039505);\ntriangles[89].c = vec3(-3.186343862924673,1.9706867675781155,-1.1110999917984008);\ntriangles[89].n = vec3(0.9485074084718053,-0.31675485750993515,-0.00023731405488713547);\ntriangles[90].a = vec3(-3.186343862924673,1.9705952148437405,-0.8667000269889831);\ntriangles[90].b = vec3(-3.186343862924673,1.9706867675781155,-1.1110999917984008);\ntriangles[90].c = vec3(-3.114841177377798,2.1846149902343655,-0.86660001039505);\ntriangles[90].n = vec3(0.9484666954135927,-0.31687681139661455,-0.00011870271162278545);\ntriangles[91].a = vec3(-3.186343862924673,1.9706867675781155,-1.1110999917984008);\ntriangles[91].b = vec3(-3.186343862924673,1.9705952148437405,-0.8667000269889831);\ntriangles[91].c = vec3(-3.4120366119481105,1.9726093749999905,-1.111200008392334);\ntriangles[91].n = vec3(-0.008518218138326176,-0.9999636491609252,-0.00037458845964923027);\ntriangles[92].a = vec3(-3.4120366119481105,1.9724873046874905,-0.8667000269889831);\ntriangles[92].b = vec3(-3.4120366119481105,1.9726093749999905,-1.111200008392334);\ntriangles[92].c = vec3(-3.186343862924673,1.9705952148437405,-0.8667000269889831);\ntriangles[92].n = vec3(-0.008383180802572894,-0.9999647358939974,-0.0004992475136355464);\ntriangles[93].a = vec3(-2.954440786752798,0.6331013183593655,-1.4505000001192092);\ntriangles[93].b = vec3(-2.778537466440298,0.41929516601561545,-1.4506000018119811);\ntriangles[93].c = vec3(-2.954532339487173,0.6330097656249905,-1.2550999855995177);\ntriangles[93].n = vec3(-0.772235577860734,-0.6353359562790649,-0.0006595036499648042);\ntriangles[94].a = vec3(-2.778537466440298,0.41920361328124045,-1.2552000021934508);\ntriangles[94].b = vec3(-2.954532339487173,0.6330097656249905,-1.2550999855995177);\ntriangles[94].c = vec3(-2.778537466440298,0.41929516601561545,-1.4506000018119811);\ntriangles[94].n = vec3(-0.7720733988133623,-0.6355333021770946,-0.00029777283374758174);\ntriangles[95].a = vec3(-2.778537466440298,0.41929516601561545,-1.4506000018119811);\ntriangles[95].b = vec3(-2.7784306549168605,0.09361157226561545,-1.450800005197525);\ntriangles[95].c = vec3(-2.778537466440298,0.41920361328124045,-1.2552000021934508);\ntriangles[95].n = vec3(-0.9999999462208083,-0.00032796090748791497,-1.5366283473512152e-7);\ntriangles[96].a = vec3(-2.7784306549168605,0.09348950195311545,-1.2554000055789947);\ntriangles[96].b = vec3(-2.778537466440298,0.41920361328124045,-1.2552000021934508);\ntriangles[96].c = vec3(-2.7784306549168605,0.09361157226561545,-1.450800005197525);\ntriangles[96].n = vec3(-0.9999999462308866,-0.00032793014796073946,-2.0486456355111739e-7);\ntriangles[97].a = vec3(-2.7784306549168605,0.09361157226561545,-1.450800005197525);\ntriangles[97].b = vec3(-2.596133901987173,-0.08339038085938455,-1.4509000068902969);\ntriangles[97].c = vec3(-2.7784306549168605,0.09348950195311545,-1.2554000055789947);\ntriangles[97].n = vec3(-0.6966109343810102,-0.7174489565211387,-0.0004482048029493904);\ntriangles[98].a = vec3(-2.596133901987173,-0.08351245117188455,-1.2554999923706054);\ntriangles[98].b = vec3(-2.7784306549168605,0.09348950195311545,-1.2554000055789947);\ntriangles[98].c = vec3(-2.596133901987173,-0.08339038085938455,-1.4509000068902969);\ntriangles[98].n = vec3(-0.696610934362153,-0.7174489565394695,-0.0004482047687808445);\ntriangles[99].a = vec3(-2.596133901987173,-0.08339038085938455,-1.4509000068902969);\ntriangles[99].b = vec3(-1.318637564096548,-0.08290209960938455,-1.4509000068902969);\ntriangles[99].c = vec3(-2.596133901987173,-0.08351245117188455,-1.2554999923706054);\ntriangles[99].n = vec3(0.00038221723582999834,-0.9999997318174726,-0.0006247199114234119);\ntriangles[100].a = vec3(-1.318637564096548,-0.08299365234375955,-1.2554999923706054);\ntriangles[100].b = vec3(-2.596133901987173,-0.08351245117188455,-1.2554999923706054);\ntriangles[100].c = vec3(-1.318637564096548,-0.08290209960938455,-1.4509000068902969);\ntriangles[100].n = vec3(0.0004061058439158306,-0.999999807774152,-0.00046853996915630606);\ntriangles[101].a = vec3(-1.318637564096548,-0.08299365234375955,-1.2554999923706054);\ntriangles[101].b = vec3(-1.318637564096548,-0.08290209960938455,-1.4509000068902969);\ntriangles[101].c = vec3(-0.9784428619481105,-0.08299365234375955,-1.176099989414215);\ntriangles[101].n = vec3(0.00010935525317276506,-0.9999998842558396,-0.00046854000499104055);\ntriangles[102].a = vec3(-0.9784428619481105,-0.08268847656250955,-1.530299994945526);\ntriangles[102].b = vec3(-0.9784428619481105,-0.08299365234375955,-1.176099989414215);\ntriangles[102].c = vec3(-1.318637564096548,-0.08290209960938455,-1.4509000068902969);\ntriangles[102].n = vec3(0.00042685147346898956,-0.9999995377290263,-0.0008615912913900763);\ntriangles[103].a = vec3(-1.987735464487173,0.6435078124999905,-1.2550999855995177);\ntriangles[103].b = vec3(-1.8683354400731105,0.48060498046874045,-1.2550999855995177);\ntriangles[103].c = vec3(-1.318942739877798,0.6438129882812405,-1.254999998807907);\ntriangles[103].n = vec3(-0.00014945342043325572,-0.00010954224568098782,0.9999999828320857);\ntriangles[104].a = vec3(-1.8683354400731105,0.48060498046874045,-1.2550999855995177);\ntriangles[104].b = vec3(-1.8682438873387355,0.14289746093749045,-1.2554000055789947);\ntriangles[104].c = vec3(-1.318942739877798,0.6438129882812405,-1.254999998807907);\ntriangles[104].n = vec3(0.00008191564866324538,-0.000888379272379166,0.9999996020359683);\ntriangles[105].a = vec3(-1.318637564096548,-0.08299365234375955,-1.2554999923706054);\ntriangles[105].b = vec3(-1.318942739877798,0.6438129882812405,-1.254999998807907);\ntriangles[105].c = vec3(-1.8682438873387355,0.14289746093749045,-1.2554000055789947);\ntriangles[105].n = vec3(-0.00010083670332888245,-0.0006879741967141426,0.999999758261703);\ntriangles[106].a = vec3(-1.998141958627798,0.01280102539061545,-1.2554000055789947);\ntriangles[106].b = vec3(-1.318637564096548,-0.08299365234375955,-1.2554999923706054);\ntriangles[106].c = vec3(-1.8682438873387355,0.14289746093749045,-1.2554000055789947);\ntriangles[106].n = vec3(0.00012898974617817915,-0.00012879306934258025,0.9999999833869953);\ntriangles[107].a = vec3(-1.318637564096548,-0.08299365234375955,-1.2554999923706054);\ntriangles[107].b = vec3(-1.998141958627798,0.01280102539061545,-1.2554000055789947);\ntriangles[107].c = vec3(-2.596133901987173,-0.08351245117188455,-1.2554999923706054);\ntriangles[107].n = vec3(4.226599413190644e-7,-0.001040762811973962,0.9999994584061488);\ntriangles[108].a = vec3(-2.536533071909048,0.01258740234374045,-1.2554000055789947);\ntriangles[108].b = vec3(-2.596133901987173,-0.08351245117188455,-1.2554999923706054);\ntriangles[108].c = vec3(-1.998141958627798,0.01280102539061545,-1.2554000055789947);\ntriangles[108].n = vec3(4.129303264401787e-7,-0.0010407024027225189,0.9999994584690226);\ntriangles[109].a = vec3(-2.536533071909048,0.01258740234374045,-1.2554000055789947);\ntriangles[109].b = vec3(-2.6782414459324855,0.14320263671874045,-1.2554000055789947);\ntriangles[109].c = vec3(-2.596133901987173,-0.08351245117188455,-1.2554999923706054);\ntriangles[109].n = vec3(-0.0006101871425387705,-0.0006620102795277525,0.9999995947069383);\ntriangles[110].a = vec3(-2.7784306549168605,0.09348950195311545,-1.2554000055789947);\ntriangles[110].b = vec3(-2.596133901987173,-0.08351245117188455,-1.2554999923706054);\ntriangles[110].c = vec3(-2.6782414459324855,0.14320263671874045,-1.2554000055789947);\ntriangles[110].n = vec3(0.0001854983574579852,-0.0003738435282594018,0.9999999129156841);\ntriangles[111].a = vec3(-2.6782414459324855,0.14320263671874045,-1.2554000055789947);\ntriangles[111].b = vec3(-2.6783329986668605,0.41938671874999045,-1.2552000021934508);\ntriangles[111].c = vec3(-2.7784306549168605,0.09348950195311545,-1.2554000055789947);\ntriangles[111].n = vec3(0.0003592670055491725,-0.0007240476238293021,0.9999996733410753);\ntriangles[112].a = vec3(-2.778537466440298,0.41920361328124045,-1.2552000021934508);\ntriangles[112].b = vec3(-2.7784306549168605,0.09348950195311545,-1.2554000055789947);\ntriangles[112].c = vec3(-2.6783329986668605,0.41938671874999045,-1.2552000021934508);\ntriangles[112].n = vec3(0.0000011220563306904951,-0.0006140453269703734,0.9999998114735211);\ntriangles[113].a = vec3(-2.6783329986668605,0.41938671874999045,-1.2552000021934508);\ntriangles[113].b = vec3(-2.502536489877798,0.6333149414062405,-1.254999998807907);\ntriangles[113].c = vec3(-2.778537466440298,0.41920361328124045,-1.2552000021934508);\ntriangles[113].n = vec3(0.0000017109445452587327,-0.0009363144023928414,0.9999995616561103);\ntriangles[114].a = vec3(-2.954532339487173,0.6330097656249905,-1.2550999855995177);\ntriangles[114].b = vec3(-2.778537466440298,0.41920361328124045,-1.2552000021934508);\ntriangles[114].c = vec3(-2.502536489877798,0.6333149414062405,-1.254999998807907);\ntriangles[114].n = vec3(-0.00022077315575633148,-0.0006495206634396791,0.9999997646910331);\ntriangles[115].a = vec3(-1.318942739877798,0.6438129882812405,-1.254999998807907);\ntriangles[115].b = vec3(-1.318637564096548,-0.08299365234375955,-1.2554999923706054);\ntriangles[115].c = vec3(-0.978732778940298,0.6438129882812405,-1.1757000124454497);\ntriangles[115].n = vec3(-0.2270060108775379,-0.0007652888190596078,0.9738930564279071);\ntriangles[116].a = vec3(-0.9784428619481105,-0.08299365234375955,-1.176099989414215);\ntriangles[116].b = vec3(-0.978732778940298,0.6438129882812405,-1.1757000124454497);\ntriangles[116].c = vec3(-1.318637564096548,-0.08299365234375955,-1.2554999923706054);\ntriangles[116].n = vec3(-0.22728722963736853,-0.0006265807180485142,0.9738275630933712);\ntriangles[117].a = vec3(-5.1800419830418605,0.09251293945311545,-1.0034000015258788);\ntriangles[117].b = vec3(-8.97703905335436,-1.1872111816406345,-0.9948000049591064);\ntriangles[117].c = vec3(-9.056537344369985,-1.3998881835937595,-1.1055000162124633);\ntriangles[117].n = vec3(0.1720018373377057,-0.5046515351024057,0.8460154821699417);\ntriangles[118].a = vec3(-5.1800419830418605,0.09251293945311545,-1.0034000015258788);\ntriangles[118].b = vec3(-3.998843862924673,1.3862141113281155,-1.0065999960899352);\ntriangles[118].c = vec3(-8.97703905335436,-1.1872111816406345,-0.9948000049591064);\ntriangles[118].n = vec3(0.0020675049718247417,0.0005858031252474921,0.9999976911262796);\ntriangles[119].a = vec3(-3.998843862924673,1.3862141113281155,-1.0065999960899352);\ntriangles[119].b = vec3(-5.1800419830418605,0.09251293945311545,-1.0034000015258788);\ntriangles[119].c = vec3(-4.7025334381199855,-0.05799975585938455,-1.003500018119812);\ntriangles[119].n = vec3(0.0007680710813121451,0.0017722365313830011,0.9999981346205058);\ntriangles[120].a = vec3(-4.7025334381199855,-0.05799975585938455,-1.003500018119812);\ntriangles[120].b = vec3(-3.938632681284048,0.5861958007812405,-1.005899999141693);\ntriangles[120].c = vec3(-3.998843862924673,1.3862141113281155,-1.0065999960899352);\ntriangles[120].n = vec3(0.002260407326079787,0.0010450967968284744,0.9999968991608953);\ntriangles[121].a = vec3(-3.938632681284048,0.5861958007812405,-1.005899999141693);\ntriangles[121].b = vec3(-4.7025334381199855,-0.05799975585938455,-1.003500018119812);\ntriangles[121].c = vec3(-3.8195378326512355,0.47880444335936545,-1.1350000238418578);\ntriangles[121].n = vec3(0.40787772610666684,-0.4807782866497468,0.7762010046580646);\ntriangles[122].a = vec3(-4.531741812143423,-0.12049975585938455,-1.1933000123500823);\ntriangles[122].b = vec3(-3.8195378326512355,0.47880444335936545,-1.1350000238418578);\ntriangles[122].c = vec3(-4.7025334381199855,-0.05799975585938455,-1.003500018119812);\ntriangles[122].n = vec3(0.47052587708799787,-0.6202221059758768,0.6276383817529158);\ntriangles[123].a = vec3(-3.8195378326512355,0.47880444335936545,-1.1350000238418578);\ntriangles[123].b = vec3(-4.531741812143423,-0.12049975585938455,-1.1933000123500823);\ntriangles[123].c = vec3(-3.8195378326512355,0.47910961914061545,-1.570800002515316);\ntriangles[123].n = vec3(0.6438806117659903,-0.7651257875143676,-0.0005357913524226603);\ntriangles[124].a = vec3(-4.531741812143423,-0.12028613281250955,-1.513200003504753);\ntriangles[124].b = vec3(-3.8195378326512355,0.47910961914061545,-1.570800002515316);\ntriangles[124].c = vec3(-4.531741812143423,-0.12049975585938455,-1.1933000123500823);\ntriangles[124].n = vec3(0.6438883325225275,-0.7651193071606085,-0.0005109319229068436);\ntriangles[125].a = vec3(-9.07744188538561,-0.09590258789063455,-0.9238999819755553);\ntriangles[125].b = vec3(-8.97703905335436,-1.1872111816406345,-0.9948000049591064);\ntriangles[125].c = vec3(-3.998843862924673,1.3862141113281155,-1.0065999960899352);\ntriangles[125].n = vec3(0.0342369795361517,-0.061656251432341186,0.9975100680652569);\ntriangles[126].a = vec3(-9.07744188538561,-0.09590258789063455,-0.9238999819755553);\ntriangles[126].b = vec3(-3.998843862924673,1.3862141113281155,-1.0065999960899352);\ntriangles[126].c = vec3(-9.181537344369985,0.8170002441406155,-0.9966000056266784);\ntriangles[126].n = vec3(-0.006711606370735715,0.07862248329496224,0.9968818683577597);\ntriangles[127].a = vec3(-9.181537344369985,0.8170002441406155,-0.9966000056266784);\ntriangles[127].b = vec3(-3.998843862924673,1.3862141113281155,-1.0065999960899352);\ntriangles[127].c = vec3(-9.295230581674673,0.9935139160156155,-1.1221999859809875);\ntriangles[127].n = vec3(-0.05915203380627519,0.553177769355508,0.8309605239645537);\ntriangles[128].a = vec3(-4.0062443756199855,1.4870136718749905,-1.1997999882698058);\ntriangles[128].b = vec3(-9.295230581674673,0.9935139160156155,-1.1221999859809875);\ntriangles[128].c = vec3(-3.998843862924673,1.3862141113281155,-1.0065999960899352);\ntriangles[128].n = vec3(-0.07557636193190106,0.8828598903693317,0.463515509442985);\ntriangles[129].a = vec3(-9.295230581674673,0.9935139160156155,-1.1221999859809875);\ntriangles[129].b = vec3(-4.0062443756199855,1.4870136718749905,-1.1997999882698058);\ntriangles[129].c = vec3(-9.295230581674673,0.9939106445312405,-1.5831000021100043);\ntriangles[129].n = vec3(-0.0928910180716976,0.9956759132528284,0.0008570471106205979);\ntriangles[130].a = vec3(-4.0062443756199855,1.4871967773437405,-1.5046999937295913);\ntriangles[130].b = vec3(-9.295230581674673,0.9939106445312405,-1.5831000021100043);\ntriangles[130].c = vec3(-4.0062443756199855,1.4870136718749905,-1.1997999882698058);\ntriangles[130].n = vec3(-0.0928724201371013,0.9956778374741551,0.0005979470445720856);\ntriangles[131].a = vec3(-2.536533071909048,0.01270947265624045,-1.450800005197525);\ntriangles[131].b = vec3(-2.6782414459324855,0.14338574218749045,-1.450800005197525);\ntriangles[131].c = vec3(-2.536533071909048,0.01258740234374045,-1.2554000055789947);\ntriangles[131].n = vec3(0.6779117208240187,0.7351431750692038,0.00045925873740088654);\ntriangles[132].a = vec3(-2.6782414459324855,0.14320263671874045,-1.2554000055789947);\ntriangles[132].b = vec3(-2.536533071909048,0.01258740234374045,-1.2554000055789947);\ntriangles[132].c = vec3(-2.6782414459324855,0.14338574218749045,-1.450800005197525);\ntriangles[132].n = vec3(0.6777404564411278,0.7353008900664432,0.0006890358977008937);\ntriangles[133].a = vec3(-2.6782414459324855,0.14338574218749045,-1.450800005197525);\ntriangles[133].b = vec3(-2.6783329986668605,0.41950878906249045,-1.4506000018119811);\ntriangles[133].c = vec3(-2.6782414459324855,0.14320263671874045,-1.2554000055789947);\ntriangles[133].n = vec3(0.9999999450323607,0.00033156474346165483,3.1070275276890223e-7);\ntriangles[134].a = vec3(-2.6783329986668605,0.41938671874999045,-1.2552000021934508);\ntriangles[134].b = vec3(-2.6782414459324855,0.14320263671874045,-1.2554000055789947);\ntriangles[134].c = vec3(-2.6783329986668605,0.41950878906249045,-1.4506000018119811);\ntriangles[134].n = vec3(0.999999945056655,0.00033149154452659,2.0708943966462055e-7);\ntriangles[135].a = vec3(-2.6783329986668605,0.41950878906249045,-1.4506000018119811);\ntriangles[135].b = vec3(-2.502536489877798,0.6334064941406155,-1.4503999984264373);\ntriangles[135].c = vec3(-2.6783329986668605,0.41938671874999045,-1.2552000021934508);\ntriangles[135].n = vec3(0.7725583686400784,-0.6349436271854286,-0.0003966620631613273);\ntriangles[136].a = vec3(-2.502536489877798,0.6333149414062405,-1.254999998807907);\ntriangles[136].b = vec3(-2.6783329986668605,0.41938671874999045,-1.2552000021934508);\ntriangles[136].c = vec3(-2.502536489877798,0.6334064941406155,-1.4503999984264373);\ntriangles[136].n = vec3(0.7726027811574668,-0.6348896392748916,-0.0002974712518702661);\ntriangles[137].a = vec3(-1.987735464487173,0.6435993652343655,-1.4505000001192092);\ntriangles[137].b = vec3(-1.8683354400731105,0.48069653320311545,-1.4505000001192092);\ntriangles[137].c = vec3(-1.987735464487173,0.6435078124999905,-1.2550999855995177);\ntriangles[137].n = vec3(-0.8065514510721583,-0.5911638352041624,-0.0002769839383563543);\ntriangles[138].a = vec3(-1.8683354400731105,0.48060498046874045,-1.2550999855995177);\ntriangles[138].b = vec3(-1.987735464487173,0.6435078124999905,-1.2550999855995177);\ntriangles[138].c = vec3(-1.8683354400731105,0.48069653320311545,-1.4505000001192092);\ntriangles[138].n = vec3(-0.8065514510721583,-0.5911638352041624,-0.0002769839383563543);\ntriangles[139].a = vec3(-1.8683354400731105,0.48069653320311545,-1.4505000001192092);\ntriangles[139].b = vec3(-1.8682438873387355,0.14298901367186545,-1.450700003504753);\ntriangles[139].c = vec3(-1.8683354400731105,0.48060498046874045,-1.2550999855995177);\ntriangles[139].n = vec3(-0.9999999632522281,-0.00027110058352562797,-1.2702148346016668e-7);\ntriangles[140].a = vec3(-1.8682438873387355,0.14289746093749045,-1.2554000055789947);\ntriangles[140].b = vec3(-1.8683354400731105,0.48060498046874045,-1.2550999855995177);\ntriangles[140].c = vec3(-1.8682438873387355,0.14298901367186545,-1.450700003504753);\ntriangles[140].n = vec3(-0.9999999632522384,-0.0002711005458487465,-1.2708651575328182e-7);\ntriangles[141].a = vec3(-1.8682438873387355,0.14289746093749045,-1.2554000055789947);\ntriangles[141].b = vec3(-1.8682438873387355,0.14298901367186545,-1.450700003504753);\ntriangles[141].c = vec3(-1.998141958627798,0.01280102539061545,-1.2554000055789947);\ntriangles[141].n = vec3(-0.7076460274670192,0.7065670457221128,0.00033122450456817584);\ntriangles[142].a = vec3(-1.998141958627798,0.01289257812499045,-1.450800005197525);\ntriangles[142].b = vec3(-1.998141958627798,0.01280102539061545,-1.2554000055789947);\ntriangles[142].c = vec3(-1.8682438873387355,0.14298901367186545,-1.450700003504753);\ntriangles[142].n = vec3(-0.7076461547431852,0.706566918331036,0.00033105493100517443);\ntriangles[143].a = vec3(-1.998141958627798,0.01289257812499045,-1.450800005197525);\ntriangles[143].b = vec3(-2.536533071909048,0.01270947265624045,-1.450800005197525);\ntriangles[143].c = vec3(-1.998141958627798,0.01280102539061545,-1.2554000055789947);\ntriangles[143].n = vec3(-0.00034009743761545595,0.999999832401979,0.0004685400164261859);\ntriangles[144].a = vec3(-2.536533071909048,0.01258740234374045,-1.2554000055789947);\ntriangles[144].b = vec3(-1.998141958627798,0.01280102539061545,-1.2554000055789947);\ntriangles[144].c = vec3(-2.536533071909048,0.01270947265624045,-1.450800005197525);\ntriangles[144].n = vec3(-0.0003967803017240693,0.9999997261451472,0.0006247199555207998);\ntriangles[145].a = vec3(-8.97703905335436,-1.1866923828125095,-1.7133000007271766);\ntriangles[145].b = vec3(-9.056537344369985,-1.3996135253906345,-1.602800000309944);\ntriangles[145].c = vec3(-9.07744188538561,-0.09541430664063455,-1.782699998319149);\ntriangles[145].n = vec3(-0.6952090432435143,-0.10914520816181328,-0.710472877545478);\ntriangles[146].a = vec3(-9.17393846741686,-0.11351123046875955,-1.6409000007808208);\ntriangles[146].b = vec3(-9.07744188538561,-0.09541430664063455,-1.782699998319149);\ntriangles[146].c = vec3(-9.056537344369985,-1.3996135253906345,-1.602800000309944);\ntriangles[146].n = vec3(-0.8177936590438343,-0.09148422920043447,-0.5681937759561428);\ntriangles[147].a = vec3(-9.056537344369985,-1.3996135253906345,-1.602800000309944);\ntriangles[147].b = vec3(-9.056537344369985,-1.3998881835937595,-1.1055000162124633);\ntriangles[147].c = vec3(-9.17393846741686,-0.11351123046875955,-1.6409000007808208);\ntriangles[147].n = vec3(-0.9958592990631103,-0.09090794216487535,-0.00005020835078068641);\ntriangles[148].a = vec3(-9.17393846741686,-0.11390795898438455,-1.0657999849319457);\ntriangles[148].b = vec3(-9.17393846741686,-0.11351123046875955,-1.6409000007808208);\ntriangles[148].c = vec3(-9.056537344369985,-1.3998881835937595,-1.1055000162124633);\ntriangles[148].n = vec3(-0.995858827068329,-0.09091310475849221,-0.0000627157365809822);\ntriangles[149].a = vec3(-9.17393846741686,-0.11390795898438455,-1.0657999849319457);\ntriangles[149].b = vec3(-9.056537344369985,-1.3998881835937595,-1.1055000162124633);\ntriangles[149].c = vec3(-9.07744188538561,-0.09590258789063455,-0.9238999819755553);\ntriangles[149].n = vec3(-0.8179127174420033,-0.09220186166756575,0.5679063332554699);\ntriangles[150].a = vec3(-9.17393846741686,-0.11390795898438455,-1.0657999849319457);\ntriangles[150].b = vec3(-9.07744188538561,-0.09590258789063455,-0.9238999819755553);\ntriangles[150].c = vec3(-9.295230581674673,0.9935139160156155,-1.1221999859809875);\ntriangles[150].n = vec3(-0.8217417992905798,-0.061147664159160384,0.5665698354718145);\ntriangles[151].a = vec3(-9.181537344369985,0.8170002441406155,-0.9966000056266784);\ntriangles[151].b = vec3(-9.295230581674673,0.9935139160156155,-1.1221999859809875);\ntriangles[151].c = vec3(-9.07744188538561,-0.09590258789063455,-0.9238999819755553);\ntriangles[151].n = vec3(-0.7656444167282161,-0.03615799264585382,0.6422470137733084);\ntriangles[152].a = vec3(-8.97703905335436,-1.1872111816406345,-0.9948000049591064);\ntriangles[152].b = vec3(-9.07744188538561,-0.09590258789063455,-0.9238999819755553);\ntriangles[152].c = vec3(-9.056537344369985,-1.3998881835937595,-1.1055000162124633);\ntriangles[152].n = vec3(-0.6949377563098231,-0.11010141311198854,0.7105907357162857);\ntriangles[153].a = vec3(-9.181537344369985,0.8173969726562405,-1.7087999990582465);\ntriangles[153].b = vec3(-9.07744188538561,-0.09541430664063455,-1.782699998319149);\ntriangles[153].c = vec3(-9.295230581674673,0.9939106445312405,-1.5831000021100043);\ntriangles[153].n = vec3(-0.7652976558854775,-0.035240205471375914,-0.6427111527074417);\ntriangles[154].a = vec3(-9.17393846741686,-0.11351123046875955,-1.6409000007808208);\ntriangles[154].b = vec3(-9.295230581674673,0.9939106445312405,-1.5831000021100043);\ntriangles[154].c = vec3(-9.07744188538561,-0.09541430664063455,-1.782699998319149);\ntriangles[154].n = vec3(-0.8216176684465435,-0.06040425849647167,-0.5668295444416755);\ntriangles[155].a = vec3(-9.17393846741686,-0.11351123046875955,-1.6409000007808208);\ntriangles[155].b = vec3(-9.17393846741686,-0.11390795898438455,-1.0657999849319457);\ntriangles[155].c = vec3(-9.295230581674673,0.9939106445312405,-1.5831000021100043);\ntriangles[155].n = vec3(-0.9940558179436884,-0.10887159947228227,-0.00007510427206058052);\ntriangles[156].a = vec3(-9.295230581674673,0.9935139160156155,-1.1221999859809875);\ntriangles[156].b = vec3(-9.295230581674673,0.9939106445312405,-1.5831000021100043);\ntriangles[156].c = vec3(-9.17393846741686,-0.11390795898438455,-1.0657999849319457);\ntriangles[156].n = vec3(-0.9940548755442136,-0.10888018930552607,-0.00009372070812004225);\ntriangles[157].a = vec3(-4.531741812143423,-0.12028613281250955,-1.513200003504753);\ntriangles[157].b = vec3(-4.531741812143423,-0.12049975585938455,-1.1933000123500823);\ntriangles[157].c = vec3(-4.7025334381199855,-0.05760302734375955,-1.7030000014603137);\ntriangles[157].n = vec3(-0.34392871475693143,-0.9389955516308703,-0.0006270431268767141);\ntriangles[158].a = vec3(-4.7025334381199855,-0.05799975585938455,-1.003500018119812);\ntriangles[158].b = vec3(-4.7025334381199855,-0.05760302734375955,-1.7030000014603137);\ntriangles[158].c = vec3(-4.531741812143423,-0.12049975585938455,-1.1933000123500823);\ntriangles[158].n = vec3(-0.34417731146578173,-0.9389045184181983,-0.0005325092277012063);\ntriangles[159].a = vec3(-4.7025334381199855,-0.05760302734375955,-1.7030000014603137);\ntriangles[159].b = vec3(-4.7025334381199855,-0.05799975585938455,-1.003500018119812);\ntriangles[159].c = vec3(-5.179935171518423,0.09290966796874045,-1.7028999997675418);\ntriangles[159].n = vec3(-0.30068497457154536,-0.9537233631819434,-0.0005409138859233868);\ntriangles[160].a = vec3(-5.1800419830418605,0.09251293945311545,-1.0034000015258788);\ntriangles[160].b = vec3(-5.179935171518423,0.09290966796874045,-1.7028999997675418);\ntriangles[160].c = vec3(-4.7025334381199855,-0.05799975585938455,-1.003500018119812);\ntriangles[160].n = vec3(-0.3006237959215273,-0.9537426219674237,-0.0005868291370367653);\ntriangles[161].a = vec3(-5.179935171518423,0.09290966796874045,-1.7028999997675418);\ntriangles[161].b = vec3(-5.1800419830418605,0.09251293945311545,-1.0034000015258788);\ntriangles[161].c = vec3(-9.056537344369985,-1.3996135253906345,-1.602800000309944);\ntriangles[161].n = vec3(0.359287602437498,-0.9332267643257105,-0.00047442689580858786);\ntriangles[162].a = vec3(-9.056537344369985,-1.3998881835937595,-1.1055000162124633);\ntriangles[162].b = vec3(-9.056537344369985,-1.3996135253906345,-1.602800000309944);\ntriangles[162].c = vec3(-5.1800419830418605,0.09251293945311545,-1.0034000015258788);\ntriangles[162].n = vec3(0.3592931154378543,-0.9332246200901186,-0.0005154188728381687);\ntriangles[163].a = vec3(14.490360543813608,1.8232868652343655,-1.1999999916553497);\ntriangles[163].b = vec3(14.490459725942515,1.6714924316406155,-1.1372999882698058);\ntriangles[163].c = vec3(14.490360543813608,1.8862141113281155,-1.3517000114917754);\ntriangles[163].n = vec3(0.9999996356419453,0.0007885010861522834,0.0003270810507935064);\ntriangles[164].a = vec3(14.490459725942515,1.6717976074218655,-1.5664000025391578);\ntriangles[164].b = vec3(14.490360543813608,1.8862141113281155,-1.3517000114917754);\ntriangles[164].c = vec3(14.490459725942515,1.6714924316406155,-1.1372999882698058);\ntriangles[164].n = vec3(0.9999998931677813,0.0004622383782004248,3.287437741787159e-7);\ntriangles[165].a = vec3(14.490459725942515,1.6717976074218655,-1.5664000025391578);\ntriangles[165].b = vec3(14.490459725942515,1.6714924316406155,-1.1372999882698058);\ntriangles[165].c = vec3(14.49055890807142,1.4571064453124905,-1.35200000166893);\ntriangles[165].n = vec3(0.9999998931373858,0.0004623041303780603,3.2879053710463415e-7);\ntriangles[166].a = vec3(14.490459725942515,1.5200031738281155,-1.5037000066041946);\ntriangles[166].b = vec3(14.490459725942515,1.6717976074218655,-1.5664000025391578);\ntriangles[166].c = vec3(14.49055890807142,1.4571064453124905,-1.35200000166893);\ntriangles[166].n = vec3(0.9999996357135179,-0.00032586721150865253,-0.0007889127911433835);\ntriangles[167].a = vec3(14.490459725942515,1.5199116210937405,-1.2003000116348266);\ntriangles[167].b = vec3(14.49055890807142,1.4571064453124905,-1.35200000166893);\ntriangles[167].c = vec3(14.490459725942515,1.6714924316406155,-1.1372999882698058);\ntriangles[167].n = vec3(0.999999634337416,-0.00032820926185620045,0.0007896858331766434);\ntriangles[168].a = vec3(-3.2963444732762355,2.3188923339843655,-0.8664999938011169);\ntriangles[168].b = vec3(-3.480045034799673,2.1876972656249905,-0.86660001039505);\ntriangles[168].c = vec3(-3.114841177377798,2.1846149902343655,-0.86660001039505);\ntriangles[168].n = vec3(-0.000006358992065779125,-0.0007534461193186019,0.999999716139214);\ntriangles[169].a = vec3(-3.186343862924673,1.9705952148437405,-0.8667000269889831);\ntriangles[169].b = vec3(-3.114841177377798,2.1846149902343655,-0.86660001039505);\ntriangles[169].c = vec3(-3.480045034799673,2.1876972656249905,-0.86660001039505);\ntriangles[169].n = vec3(-0.000003933066873361676,-0.0004660100126091008,0.9999998914095937);\ntriangles[170].a = vec3(-3.186343862924673,1.9705952148437405,-0.8667000269889831);\ntriangles[170].b = vec3(-3.480045034799673,2.1876972656249905,-0.86660001039505);\ntriangles[170].c = vec3(-3.4120366119481105,1.9724873046874905,-0.8667000269889831);\ntriangles[170].n = vec3(-0.000003906482456850776,-0.00046597404854257927,0.9999998914264568);\ntriangles[171].a = vec3(4.3661616302393895,1.5745991210937405,-0.9522000288963317);\ntriangles[171].b = vec3(4.1916621185206395,1.5745075683593655,-0.8774000144004821);\ntriangles[171].c = vec3(4.3661616302393895,1.5748127441406155,-1.1782999968528747);\ntriangles[171].n = vec3(0.00011965887356425305,-0.9999995465017918,-0.0009448163656457922);\ntriangles[172].a = vec3(3.7303584075831395,1.5745075683593655,-1.1782999968528747);\ntriangles[172].b = vec3(4.3661616302393895,1.5748127441406155,-1.1782999968528747);\ntriangles[172].c = vec3(4.1916621185206395,1.5745075683593655,-0.8774000144004821);\ntriangles[172].n = vec3(0.0004799844552493299,-0.999999614066454,-0.0007358545141619024);\ntriangles[173].a = vec3(3.7303584075831395,1.5745075683593655,-1.1782999968528747);\ntriangles[173].b = vec3(4.1916621185206395,1.5745075683593655,-0.8774000144004821);\ntriangles[173].c = vec3(3.7302668548487645,1.5735920410156155,0.26019999027252205);\ntriangles[173].n = vec3(0.000415124644952162,-0.9999997113209962,-0.0006364192435549335);\ntriangles[174].a = vec3(3.928158090200327,1.5737141113281155,0.21080001831054695);\ntriangles[174].b = vec3(3.7302668548487645,1.5735920410156155,0.26019999027252205);\ntriangles[174].c = vec3(4.1916621185206395,1.5745075683593655,-0.8774000144004821);\ntriangles[174].n = vec3(0.00046281316654389826,-0.9999997025096752,-0.0006170774134120346);\ntriangles[175].a = vec3(3.928066537465952,1.7560871582031155,0.21090003490448006);\ntriangles[175].b = vec3(4.191555306997202,1.7569111328124905,-0.877299997806549);\ntriangles[175].c = vec3(3.7302668548487645,1.7559956054687405,0.26030000686645516);\ntriangles[175].n = vec3(-0.00029136902726251536,0.9999997218146082,0.0006866402235100852);\ntriangles[176].a = vec3(3.7302668548487645,1.7569111328124905,-1.1780999934673309);\ntriangles[176].b = vec3(3.7302668548487645,1.7559956054687405,0.26030000686645516);\ntriangles[176].c = vec3(4.191555306997202,1.7569111328124905,-0.877299997806549);\ntriangles[176].n = vec3(-0.0004150465066824238,0.9999997113084574,0.0006364899049169546);\ntriangles[177].a = vec3(3.7302668548487645,1.7569111328124905,-1.1780999934673309);\ntriangles[177].b = vec3(4.191555306997202,1.7569111328124905,-0.877299997806549);\ntriangles[177].c = vec3(4.366054818715952,1.7571857910156155,-1.1780999934673309);\ntriangles[177].n = vec3(-0.00043199640891964134,0.999999687247483,0.0006624832369643753);\ntriangles[178].a = vec3(4.366054818715952,1.7570026855468655,-0.9521000123023986);\ntriangles[178].b = vec3(4.366054818715952,1.7571857910156155,-1.1780999934673309);\ntriangles[178].c = vec3(4.191555306997202,1.7569111328124905,-0.877299997806549);\ntriangles[178].n = vec3(-0.00017736243317181772,0.9999996560584121,0.0008102009780203745);\ntriangles[179].a = vec3(3.7046626068018895,1.2950886230468655,0.3074999713897706);\ntriangles[179].b = vec3(3.7046626068018895,1.2953937988281155,-0.1728999948501586);\ntriangles[179].c = vec3(3.704464242544077,1.7519062499999905,0.45630010604858406);\ntriangles[179].n = vec3(0.9999999057608104,0.0004341408691319584,2.757895258546489e-7);\ntriangles[180].a = vec3(3.7043574310206395,2.0345905761718655,0.06780001163482674);\ntriangles[180].b = vec3(3.704464242544077,1.7519062499999905,0.45630010604858406);\ntriangles[180].c = vec3(3.7046626068018895,1.2953937988281155,-0.1728999948501586);\ntriangles[180].n = vec3(0.9999999173117775,0.0004061434791659682,0.000020589135618507183);\ntriangles[181].a = vec3(3.7043574310206395,2.0345905761718655,0.06780001163482674);\ntriangles[181].b = vec3(3.7046626068018895,1.2953937988281155,-0.1728999948501586);\ntriangles[181].c = vec3(3.704464242544077,1.7523945312499905,-0.32100001335144035);\ntriangles[181].n = vec3(0.9999999098005148,0.0004234776223236528,-0.00003264453578660924);\ntriangles[182].a = vec3(-0.7932316803074855,2.0485065917968655,-1.0060999727249145);\ntriangles[182].b = vec3(-1.5127446197606105,2.0482929687499905,-1.0061999893188476);\ntriangles[182].c = vec3(-0.486942007455923,1.9033039550781155,-1.0061999893188476);\ntriangles[182].n = vec3(-0.0001387145212590108,-0.0009814103473668194,0.9999995087958854);\ntriangles[183].a = vec3(-1.7956425689793605,1.8368061523437405,-1.0063000059127807);\ntriangles[183].b = vec3(-0.486942007455923,1.9033039550781155,-1.0061999893188476);\ntriangles[183].c = vec3(-1.5127446197606105,2.0482929687499905,-1.0061999893188476);\ntriangles[183].n = vec3(-0.00005621514905320756,-0.00039772425019995626,0.9999999193276357);\ntriangles[184].a = vec3(-1.7956425689793605,1.8368061523437405,-1.0063000059127807);\ntriangles[184].b = vec3(-3.494937612924673,0.7198017578124905,-1.0070000028610229);\ntriangles[184].c = vec3(-0.486942007455923,1.9033039550781155,-1.0061999893188476);\ntriangles[184].n = vec3(-0.00004831665423961653,-0.0005531693449574654,0.9999998458345765);\ntriangles[185].a = vec3(-1.7956425689793605,1.8368061523437405,-1.0063000059127807);\ntriangles[185].b = vec3(-3.4954411529637355,1.8361958007812405,-1.0063000059127807);\ntriangles[185].c = vec3(-3.494937612924673,0.7198017578124905,-1.0070000028610229);\ntriangles[185].n = vec3(2.2514436309531078e-7,-0.0006270157940022858,0.9999998034255524);\ntriangles[186].a = vec3(-3.494937612924673,0.7198017578124905,-1.0070000028610229);\ntriangles[186].b = vec3(-3.4954411529637355,1.8361958007812405,-1.0063000059127807);\ntriangles[186].c = vec3(-3.938632681284048,0.5861958007812405,-1.005899999141693);\ntriangles[186].n = vec3(0.002667623959058746,-0.0006258104559287852,0.9999962460647972);\ntriangles[187].a = vec3(-3.998843862924673,1.3862141113281155,-1.0065999960899352);\ntriangles[187].b = vec3(-3.938632681284048,0.5861958007812405,-1.005899999141693);\ntriangles[187].c = vec3(-3.4954411529637355,1.8361958007812405,-1.0063000059127807);\ntriangles[187].n = vec3(-0.0012911822419548948,0.0007777978782460073,0.999998863938794);\ntriangles[188].a = vec3(1.146267221059702,0.7216938476562405,-1.0070000028610229);\ntriangles[188].b = vec3(-0.486942007455923,1.9033039550781155,-1.0061999893188476);\ntriangles[188].c = vec3(-3.494937612924673,0.7198017578124905,-1.0070000028610229);\ntriangles[188].n = vec3(2.758604327018031e-7,-0.0006766722933320697,0.9999997710572396);\ntriangles[189].a = vec3(1.146267221059702,0.7216938476562405,-1.0070000028610229);\ntriangles[189].b = vec3(1.145962045278452,1.6659992675781155,-1.0064000225067138);\ntriangles[189].c = vec3(-0.486942007455923,1.9033039550781155,-1.0061999893188476);\ntriangles[189].n = vec3(0.000030167088523825827,-0.0006353569660982297,0.9999997977057157);\ntriangles[190].a = vec3(0.7480586028956395,1.9037922363281155,-1.0061999893188476);\ntriangles[190].b = vec3(-0.486942007455923,1.9033039550781155,-1.0061999893188476);\ntriangles[190].c = vec3(1.145962045278452,1.6659992675781155,-1.0064000225067138);\ntriangles[190].n = vec3(3.323674953174964e-7,-0.0008406508740160066,0.9999996466529365);\ntriangles[191].a = vec3(0.7480586028956395,1.9041889648437405,-1.697500001490116);\ntriangles[191].b = vec3(1.145962045278452,1.6664875488281155,-1.6977000011503696);\ntriangles[191].c = vec3(-0.4868351959324855,1.9037006835937405,-1.6975999994575977);\ntriangles[191].n = vec3(0.00008059090791246109,0.0009762960939056372,-0.9999995201754062);\ntriangles[192].a = vec3(1.146267221059702,0.7220905761718655,-1.6983000001311301);\ntriangles[192].b = vec3(-0.4868351959324855,1.9037006835937405,-1.6975999994575977);\ntriangles[192].c = vec3(1.145962045278452,1.6664875488281155,-1.6977000011503696);\ntriangles[192].n = vec3(0.00003105597228646183,0.0006353348795891417,-0.9999997976925383);\ntriangles[193].a = vec3(1.146267221059702,0.7220905761718655,-1.6983000001311301);\ntriangles[193].b = vec3(-3.494937612924673,0.7202900390624905,-1.698400001823902);\ntriangles[193].c = vec3(-0.4868351959324855,1.9037006835937405,-1.6975999994575977);\ntriangles[193].n = vec3(0.000021305242455150002,0.0006218584085888139,-0.9999998064190844);\ntriangles[194].a = vec3(-1.7956425689793605,1.8372944335937405,-1.6975999994575977);\ntriangles[194].b = vec3(-0.4868351959324855,1.9037006835937405,-1.6975999994575977);\ntriangles[194].c = vec3(-3.494937612924673,0.7202900390624905,-1.698400001823902);\ntriangles[194].n = vec3(-0.000039378215051436465,0.0007761091493156966,-0.9999996980519267);\ntriangles[195].a = vec3(-1.7956425689793605,1.8372944335937405,-1.6975999994575977);\ntriangles[195].b = vec3(-1.5127446197606105,2.0488117675781155,-1.697500001490116);\ntriangles[195].c = vec3(-0.4868351959324855,1.9037006835937405,-1.6975999994575977);\ntriangles[195].n = vec3(-0.00002573341740383913,0.0005071824780323753,-0.9999998710518544);\ntriangles[196].a = vec3(-0.7931401275731105,2.0489948730468655,-1.6973999997973441);\ntriangles[196].b = vec3(-0.4868351959324855,1.9037006835937405,-1.6975999994575977);\ntriangles[196].c = vec3(-1.5127446197606105,2.0488117675781155,-1.697500001490116);\ntriangles[196].n = vec3(0.00013854280597204213,0.0016685851343528108,-0.9999985983137879);\ntriangles[197].a = vec3(3.7302668548487645,1.5735920410156155,0.26019999027252205);\ntriangles[197].b = vec3(3.7302668548487645,1.7559956054687405,0.26030000686645516);\ntriangles[197].c = vec3(3.7303584075831395,1.5745075683593655,-1.1782999968528747);\ntriangles[197].n = vec3(-0.9999999979746844,3.4897960332801356e-8,-0.00006364456243235202);\ntriangles[198].a = vec3(3.7302668548487645,1.7569111328124905,-1.1780999934673309);\ntriangles[198].b = vec3(3.7303584075831395,1.5745075683593655,-1.1782999968528747);\ntriangles[198].c = vec3(3.7302668548487645,1.7559956054687405,0.26030000686645516);\ntriangles[198].n = vec3(-0.9999998740362765,-0.000501923628642903,-3.194694148986123e-7);\ntriangles[199].a = vec3(3.928158090200327,1.5737141113281155,0.21080001831054695);\ntriangles[199].b = vec3(3.928066537465952,1.7560871582031155,0.21090003490448006);\ntriangles[199].c = vec3(3.7302668548487645,1.5735920410156155,0.26019999027252205);\ntriangles[199].n = vec3(0.24219972811887464,-0.0004105030121216937,0.9702263257541616);\ntriangles[200].a = vec3(3.7302668548487645,1.7559956054687405,0.26030000686645516);\ntriangles[200].b = vec3(3.7302668548487645,1.5735920410156155,0.26019999027252205);\ntriangles[200].c = vec3(3.928066537465952,1.7560871582031155,0.21090003490448006);\ntriangles[200].n = vec3(0.24230523074602744,-0.0005319857213520333,0.9701999238014332);\ntriangles[201].a = vec3(4.191555306997202,1.7569111328124905,-0.877299997806549);\ntriangles[201].b = vec3(3.928066537465952,1.7560871582031155,0.21090003490448006);\ntriangles[201].c = vec3(4.1916621185206395,1.5745075683593655,-0.8774000144004821);\ntriangles[201].n = vec3(0.9719147862617973,0.0004400929853362052,0.23533264661718567);\ntriangles[202].a = vec3(3.928158090200327,1.5737141113281155,0.21080001831054695);\ntriangles[202].b = vec3(4.1916621185206395,1.5745075683593655,-0.8774000144004821);\ntriangles[202].c = vec3(3.928066537465952,1.7560871582031155,0.21090003490448006);\ntriangles[202].n = vec3(0.971911717012493,0.00035883988929727065,0.2353454600534319);\ntriangles[203].a = vec3(4.366054818715952,1.7571857910156155,-1.1780999934673309);\ntriangles[203].b = vec3(4.366054818715952,1.7570026855468655,-0.9521000123023986);\ntriangles[203].c = vec3(4.3661616302393895,1.5748127441406155,-1.1782999968528747);\ntriangles[203].n = vec3(0.999999828492026,0.0005856754166479613,4.745149585760969e-7);\ntriangles[204].a = vec3(4.3661616302393895,1.5745991210937405,-0.9522000288963317);\ntriangles[204].b = vec3(4.3661616302393895,1.5748127441406155,-1.1782999968528747);\ntriangles[204].c = vec3(4.366054818715952,1.7570026855468655,-0.9521000123023986);\ntriangles[204].n = vec3(0.999999828549243,0.0005855776454220126,5.532635936550948e-7);\ntriangles[205].a = vec3(4.366054818715952,1.7570026855468655,-0.9521000123023986);\ntriangles[205].b = vec3(4.191555306997202,1.7569111328124905,-0.877299997806549);\ntriangles[205].c = vec3(4.3661616302393895,1.5745991210937405,-0.9522000288963317);\ntriangles[205].n = vec3(0.3939839689158722,-0.00027326741708372124,0.9191172708431804);\ntriangles[206].a = vec3(4.1916621185206395,1.5745075683593655,-0.8774000144004821);\ntriangles[206].b = vec3(4.3661616302393895,1.5745991210937405,-0.9522000288963317);\ntriangles[206].c = vec3(4.191555306997202,1.7569111328124905,-0.877299997806549);\ntriangles[206].n = vec3(0.3939839689158722,-0.00027326741708372124,0.9191172708431804);\ntriangles[207].a = vec3(1.452358529653452,1.8422993164062405,0.06769999504089363);\ntriangles[207].b = vec3(1.4524653411768895,1.6923054199218655,-0.13909998893737785);\ntriangles[207].c = vec3(1.4524653411768895,1.6920002441406155,0.2742999458312989);\ntriangles[207].n = vec3(-0.9999997469679512,-0.0007113815840030651,-5.251486814734913e-7);\ntriangles[208].a = vec3(1.4525568939112645,1.4491108398437405,0.19520005226135262);\ntriangles[208].b = vec3(1.4524653411768895,1.6920002441406155,0.2742999458312989);\ntriangles[208].c = vec3(1.4524653411768895,1.6923054199218655,-0.13909998893737785);\ntriangles[208].n = vec3(-0.9999999289953315,-0.0003768411533582704,-2.781877395496265e-7);\ntriangles[209].a = vec3(1.4525568939112645,1.4491108398437405,0.19520005226135262);\ntriangles[209].b = vec3(1.4524653411768895,1.6923054199218655,-0.13909998893737785);\ntriangles[209].c = vec3(1.4525568939112645,1.4492023925781155,-0.060300025939941326);\ntriangles[209].n = vec3(-0.9999999290695345,-0.0003766442725363436,-1.3496204494394687e-7);\ntriangles[210].a = vec3(12.943462655630015,1.9268024902343655,-1.705499999076128);\ntriangles[210].b = vec3(13.310360238637827,1.9268940429687405,-1.705499999076128);\ntriangles[210].c = vec3(12.94385938414564,0.9596088867187405,-2.0447000002861024);\ntriangles[210].n = vec3(-0.00008258099063295781,0.3309433199615784,-0.943650630346416);\ntriangles[211].a = vec3(13.310665414419077,0.9597919921874905,-2.0447000002861024);\ntriangles[211].b = vec3(12.94385938414564,0.9596088867187405,-2.0447000002861024);\ntriangles[211].c = vec3(13.310360238637827,1.9268940429687405,-1.705499999076128);\ntriangles[211].n = vec3(-0.00016521712118354193,0.3309711980109304,-0.9436408420530095);\ntriangles[212].a = vec3(12.94385938414564,0.9593952636718655,-1.7988999968767165);\ntriangles[212].b = vec3(13.310665414419077,0.9596088867187405,-1.7988999968767165);\ntriangles[212].c = vec3(12.943661019887827,1.4816120605468655,-1.5814000031352042);\ntriangles[212].n = vec3(0.00022391568704401306,-0.3844792286322164,0.923133615795753);\ntriangles[213].a = vec3(13.31055860289564,1.4817036132812405,-1.5813000014424323);\ntriangles[213].b = vec3(12.943661019887827,1.4816120605468655,-1.5814000031352042);\ntriangles[213].c = vec3(13.310665414419077,0.9596088867187405,-1.7988999968767165);\ntriangles[213].n = vec3(-0.00015558705229526661,-0.3847065829185168,0.9230389053836395);\ntriangles[214].a = vec3(13.31026105650892,2.0041950683593655,-1.6050000002980231);\ntriangles[214].b = vec3(13.310360238637827,1.9268940429687405,-1.705499999076128);\ntriangles[214].c = vec3(12.943462655630015,2.0040119628906155,-1.6050000002980231);\ntriangles[214].n = vec3(-0.0003956898203897301,0.7926491456198772,-0.609677927579509);\ntriangles[215].a = vec3(12.943462655630015,1.9268024902343655,-1.705499999076128);\ntriangles[215].b = vec3(12.943462655630015,2.0040119628906155,-1.6050000002980231);\ntriangles[215].c = vec3(13.310360238637827,1.9268940429687405,-1.705499999076128);\ntriangles[215].n = vec3(-0.00019787856725877721,0.7929983582895497,-0.60922373935538);\ntriangles[216].a = vec3(12.943661019887827,1.4813068847656155,-1.1249000167846679);\ntriangles[216].b = vec3(12.943661019887827,1.4816120605468655,-1.5814000031352042);\ntriangles[216].c = vec3(13.310459420766733,1.4814899902343655,-1.1249000167846679);\ntriangles[216].n = vec3(0.0004991990275330102,-0.9999996519460221,-0.0006685119039587827);\ntriangles[217].a = vec3(13.31055860289564,1.4817036132812405,-1.5813000014424323);\ntriangles[217].b = vec3(13.310459420766733,1.4814899902343655,-1.1249000167846679);\ntriangles[217].c = vec3(12.943661019887827,1.4816120605468655,-1.5814000031352042);\ntriangles[217].n = vec3(0.00024965965217759654,-0.9999998593198792,-0.00046800670952442633);\ntriangles[218].a = vec3(12.943462655630015,2.0040119628906155,-1.6050000002980231);\ntriangles[218].b = vec3(12.943462655630015,2.0037067871093655,-1.1005999779701232);\ntriangles[218].c = vec3(13.31026105650892,2.0041950683593655,-1.6050000002980231);\ntriangles[218].n = vec3(-0.00049919904771323,0.9999996923712067,0.0006050271091597104);\ntriangles[219].a = vec3(13.31026105650892,2.0037983398437405,-1.1005999779701232);\ntriangles[219].b = vec3(13.31026105650892,2.0041950683593655,-1.6050000002980231);\ntriangles[219].c = vec3(12.943462655630015,2.0037067871093655,-1.1005999779701232);\ntriangles[219].n = vec3(-0.00024959951565975245,0.9999996595311599,0.0007865352160777615);\ntriangles[220].a = vec3(12.94385938414564,0.9587849121093655,-0.9080999827384948);\ntriangles[220].b = vec3(12.94385938414564,0.9586933593749905,-0.6622000074386596);\ntriangles[220].c = vec3(12.943661019887827,1.4813068847656155,-1.1249000167846679);\ntriangles[220].n = vec3(-0.9999999279188123,-0.0003796871741510397,-1.4136397922878442e-7);\ntriangles[221].a = vec3(12.943462655630015,1.9263142089843655,-1.0002000069618224);\ntriangles[221].b = vec3(12.943661019887827,1.4813068847656155,-1.1249000167846679);\ntriangles[221].c = vec3(12.94385938414564,0.9586933593749905,-0.6622000074386596);\ntriangles[221].n = vec3(-0.9999999060056629,-0.0004298413420038623,-0.00005678984094474685);\ntriangles[222].a = vec3(12.943661019887827,1.4813068847656155,-1.1249000167846679);\ntriangles[222].b = vec3(12.943462655630015,1.9263142089843655,-1.0002000069618224);\ntriangles[222].c = vec3(12.943462655630015,2.0037067871093655,-1.1005999779701232);\ntriangles[222].n = vec3(-0.9999998928891036,-0.00036657313460703816,-0.00028257020070509566);\ntriangles[223].a = vec3(12.943661019887827,1.4813068847656155,-1.1249000167846679);\ntriangles[223].b = vec3(12.943462655630015,2.0037067871093655,-1.1005999779701232);\ntriangles[223].c = vec3(12.943661019887827,1.4816120605468655,-1.5814000031352042);\ntriangles[223].n = vec3(-0.9999999279118615,-0.00037970542176082124,-2.5383768279401447e-7);\ntriangles[224].a = vec3(12.943462655630015,2.0040119628906155,-1.6050000002980231);\ntriangles[224].b = vec3(12.943661019887827,1.4816120605468655,-1.5814000031352042);\ntriangles[224].c = vec3(12.943462655630015,2.0037067871093655,-1.1005999779701232);\ntriangles[224].n = vec3(-0.9999999279034428,-0.0003797276083243543,-2.2974556780896664e-7);\ntriangles[225].a = vec3(12.943462655630015,1.9268024902343655,-1.705499999076128);\ntriangles[225].b = vec3(12.943661019887827,1.4816120605468655,-1.5814000031352042);\ntriangles[225].c = vec3(12.943462655630015,2.0040119628906155,-1.6050000002980231);\ntriangles[225].n = vec3(-0.9999998929192306,-0.0003669805307425468,0.00028193406565409616);\ntriangles[226].a = vec3(12.943462655630015,1.9268024902343655,-1.705499999076128);\ntriangles[226].b = vec3(12.94385938414564,0.9596088867187405,-2.0447000002861024);\ntriangles[226].c = vec3(12.943661019887827,1.4816120605468655,-1.5814000031352042);\ntriangles[226].n = vec3(-0.9999999060124821,-0.00042990077601360915,0.000056216987916490427);\ntriangles[227].a = vec3(12.94385938414564,0.9593952636718655,-1.7988999968767165);\ntriangles[227].b = vec3(12.943661019887827,1.4816120605468655,-1.5814000031352042);\ntriangles[227].c = vec3(12.94385938414564,0.9596088867187405,-2.0447000002861024);\ntriangles[227].n = vec3(-0.9999999279089905,-0.0003797129246604889,-3.300058209059147e-7);\ntriangles[228].a = vec3(12.94385938414564,0.9586933593749905,-0.6622000074386596);\ntriangles[228].b = vec3(12.94385938414564,0.9587849121093655,-0.9080999827384948);\ntriangles[228].c = vec3(13.310665414419077,0.9587849121093655,-0.6622000074386596);\ntriangles[228].n = vec3(0.0002495943840113233,-0.9999998995413667,-0.000372316935233945);\ntriangles[229].a = vec3(13.310665414419077,0.9589985351562405,-0.9080999827384948);\ntriangles[229].b = vec3(13.310665414419077,0.9587849121093655,-0.6622000074386596);\ntriangles[229].c = vec3(12.94385938414564,0.9587849121093655,-0.9080999827384948);\ntriangles[229].n = vec3(0.0005823866360008673,-0.9999994530589177,-0.0008687391276688863);\ntriangles[230].a = vec3(12.943462655630015,1.9263142089843655,-1.0002000069618224);\ntriangles[230].b = vec3(12.94385938414564,0.9586933593749905,-0.6622000074386596);\ntriangles[230].c = vec3(13.310360238637827,1.9264057617187405,-1.0002000069618224);\ntriangles[230].n = vec3(-0.00008228829214559225,0.32977033077346096,0.9440611856072674);\ntriangles[231].a = vec3(13.310665414419077,0.9587849121093655,-0.6622000074386596);\ntriangles[231].b = vec3(13.310360238637827,1.9264057617187405,-1.0002000069618224);\ntriangles[231].c = vec3(12.94385938414564,0.9586933593749905,-0.6622000074386596);\ntriangles[231].n = vec3(-0.00008230883257363044,0.3297703377062503,0.9440611831837816);\ntriangles[232].a = vec3(13.310459420766733,1.4814899902343655,-1.1249000167846679);\ntriangles[232].b = vec3(13.310665414419077,0.9589985351562405,-0.9080999827384948);\ntriangles[232].c = vec3(12.943661019887827,1.4813068847656155,-1.1249000167846679);\ntriangles[232].n = vec3(0.0001913191514417506,-0.38325211849437685,-0.9236437500825493);\ntriangles[233].a = vec3(12.94385938414564,0.9587849121093655,-0.9080999827384948);\ntriangles[233].b = vec3(12.943661019887827,1.4813068847656155,-1.1249000167846679);\ntriangles[233].c = vec3(13.310665414419077,0.9589985351562405,-0.9080999827384948);\ntriangles[233].n = vec3(0.00022318990669133057,-0.3832330119252068,-0.9236516706838136);\ntriangles[234].a = vec3(12.943462655630015,1.9263142089843655,-1.0002000069618224);\ntriangles[234].b = vec3(13.310360238637827,1.9264057617187405,-1.0002000069618224);\ntriangles[234].c = vec3(12.943462655630015,2.0037067871093655,-1.1005999779701232);\ntriangles[234].n = vec3(-0.00019763109666372908,0.7920066198798943,0.6105124691669896);\ntriangles[235].a = vec3(13.31026105650892,2.0037983398437405,-1.1005999779701232);\ntriangles[235].b = vec3(12.943462655630015,2.0037067871093655,-1.1005999779701232);\ntriangles[235].c = vec3(13.310360238637827,1.9264057617187405,-1.0002000069618224);\ntriangles[235].n = vec3(-0.00019768451245575142,0.7920065254445968,0.6105125916588543);\ntriangles[236].a = vec3(12.103359506215952,1.8426044921874905,-1.4421999937295913);\ntriangles[236].b = vec3(12.209255502309702,2.1811970214843655,-1.424500007033348);\ntriangles[236].c = vec3(12.555660531606577,1.8427875976562405,-1.4421000069379806);\ntriangles[236].n = vec3(0.00019965322828249842,0.052141630560459964,-0.9986396800153122);\ntriangles[237].a = vec3(12.555568978872202,2.1812885742187405,-1.424500007033348);\ntriangles[237].b = vec3(12.555660531606577,1.8427875976562405,-1.4421000069379806);\ntriangles[237].c = vec3(12.209255502309702,2.1811970214843655,-1.424500007033348);\ntriangles[237].n = vec3(-0.000013726771325714729,0.05192380033473691,-0.998651049551531);\ntriangles[238].a = vec3(12.555568978872202,2.1812885742187405,-1.2771999871730804);\ntriangles[238].b = vec3(12.209255502309702,2.1811054687499905,-1.2771999871730804);\ntriangles[238].c = vec3(12.555660531606577,1.8426960449218655,-1.2599999940395354);\ntriangles[238].n = vec3(-0.000026823975209029098,0.0507330784453437,0.9987122478631836);\ntriangles[239].a = vec3(12.103359506215952,1.8425129394531155,-1.2599999940395354);\ntriangles[239].b = vec3(12.555660531606577,1.8426960449218655,-1.2599999940395354);\ntriangles[239].c = vec3(12.209255502309702,2.1811054687499905,-1.2771999871730804);\ntriangles[239].n = vec3(-0.000020540918991421864,0.05073949339531058,0.9987119221217189);\ntriangles[240].a = vec3(12.209255502309702,2.1811054687499905,-1.2771999871730804);\ntriangles[240].b = vec3(12.209255502309702,2.1811970214843655,-1.424500007033348);\ntriangles[240].c = vec3(12.103359506215952,1.8425129394531155,-1.2599999940395354);\ntriangles[240].n = vec3(-0.9544083725231471,0.29850397658259953,0.00018553191848767414);\ntriangles[241].a = vec3(12.103359506215952,1.8426044921874905,-1.4421999937295913);\ntriangles[241].b = vec3(12.103359506215952,1.8425129394531155,-1.2599999940395354);\ntriangles[241].c = vec3(12.209255502309702,2.1811970214843655,-1.424500007033348);\ntriangles[241].n = vec3(-0.954413296885438,0.29848825141456403,0.00014998581581944582);\ntriangles[242].a = vec3(12.555568978872202,2.1812885742187405,-1.2771999871730804);\ntriangles[242].b = vec3(12.555568978872202,2.1812885742187405,-1.424500007033348);\ntriangles[242].c = vec3(12.209255502309702,2.1811054687499905,-1.2771999871730804);\ntriangles[242].n = vec3(-0.0005287274551763991,0.9999998602236294,0);\ntriangles[243].a = vec3(12.209255502309702,2.1811970214843655,-1.424500007033348);\ntriangles[243].b = vec3(12.209255502309702,2.1811054687499905,-1.2771999871730804);\ntriangles[243].c = vec3(12.555568978872202,2.1812885742187405,-1.424500007033348);\ntriangles[243].n = vec3(-0.0002643637042387642,0.9999997719004986,0.0006215390437741696);\ntriangles[244].a = vec3(12.555660531606577,1.8426960449218655,-1.2599999940395354);\ntriangles[244].b = vec3(12.555660531606577,1.8427875976562405,-1.4421000069379806);\ntriangles[244].c = vec3(12.555568978872202,2.1812885742187405,-1.2771999871730804);\ntriangles[244].n = vec3(0.9999999634421901,0.0002703989644664219,1.3594597921788927e-7);\ntriangles[245].a = vec3(12.555568978872202,2.1812885742187405,-1.424500007033348);\ntriangles[245].b = vec3(12.555568978872202,2.1812885742187405,-1.2771999871730804);\ntriangles[245].c = vec3(12.555660531606577,1.8427875976562405,-1.4421000069379806);\ntriangles[245].n = vec3(0.9999999634242898,0.0002704651902517913,0);\ntriangles[246].a = vec3(10.674663827505015,1.3599995117187405,-1.3520999884605407);\ntriangles[246].b = vec3(10.674663827505015,1.2688129882812405,-1.5102999991178512);\ntriangles[246].c = vec3(5.2038691497706395,1.3578022460937405,-1.3522000050544738);\ntriangles[246].n = vec3(-0.00033883995885378116,0.8663815431008445,-0.49938252568715513);\ntriangles[247].a = vec3(5.2038691497706395,1.2665852050781155,-1.5102999991178512);\ntriangles[247].b = vec3(5.2038691497706395,1.3578022460937405,-1.3522000050544738);\ntriangles[247].c = vec3(10.674663827505015,1.2688129882812405,-1.5102999991178512);\ntriangles[247].n = vec3(-0.0003527174028571557,0.8661724747670373,-0.499745054549197);\ntriangles[248].a = vec3(10.674663827505015,1.2688129882812405,-1.5102999991178512);\ntriangles[248].b = vec3(10.67475538023939,1.0861958007812405,-1.510400000810623);\ntriangles[248].c = vec3(5.2038691497706395,1.2665852050781155,-1.5102999991178512);\ntriangles[248].n = vec3(-2.2299137080713786e-7,0.0005476026584997696,-0.9999998500656282);\ntriangles[249].a = vec3(5.2039607025050145,1.0840900878906155,-1.510400000810623);\ntriangles[249].b = vec3(5.2038691497706395,1.2665852050781155,-1.5102999991178512);\ntriangles[249].c = vec3(10.67475538023939,1.0861958007812405,-1.510400000810623);\ntriangles[249].n = vec3(-2.1091365290782065e-7,0.0005479689538525548,-0.9999998498649795);\ntriangles[250].a = vec3(10.67475538023939,1.0861958007812405,-1.510400000810623);\ntriangles[250].b = vec3(10.67475538023939,0.9948872070312405,-1.3522999918460845);\ntriangles[250].c = vec3(5.2039607025050145,1.0840900878906155,-1.510400000810623);\ntriangles[250].n = vec3(0.0003333068523960803,-0.8659553551954802,-0.5001211970260929);\ntriangles[251].a = vec3(5.2039607025050145,0.9926899414062405,-1.3524000084400176);\ntriangles[251].b = vec3(5.2039607025050145,1.0840900878906155,-1.510400000810623);\ntriangles[251].c = vec3(10.67475538023939,0.9948872070312405,-1.3522999918460845);\ntriangles[251].n = vec3(0.0003568104605285122,-0.8656008581118757,-0.5007344876501716);\ntriangles[252].a = vec3(5.2039607025050145,0.9926899414062405,-1.3524000084400176);\ntriangles[252].b = vec3(10.67475538023939,0.9948872070312405,-1.3522999918460845);\ntriangles[252].c = vec3(5.2039607025050145,1.0839069824218655,-1.194299999475479);\ntriangles[252].n = vec3(0.0003387493723282631,-0.8661724993386763,0.4997450216242817);\ntriangles[253].a = vec3(10.67475538023939,1.0861042480468655,-1.1942000126838683);\ntriangles[253].b = vec3(5.2039607025050145,1.0839069824218655,-1.194299999475479);\ntriangles[253].c = vec3(10.67475538023939,0.9948872070312405,-1.3522999918460845);\ntriangles[253].n = vec3(0.0003387520770349612,-0.8661724585604669,0.4997450923004114);\ntriangles[254].a = vec3(5.2039607025050145,1.0839069824218655,-1.194299999475479);\ntriangles[254].b = vec3(10.67475538023939,1.0861042480468655,-1.1942000126838683);\ntriangles[254].c = vec3(5.2038691497706395,1.2664936523437405,-1.1940999960899352);\ntriangles[254].n = vec3(-0.000017836504399384294,-0.001095397043972599,0.9999993998934076);\ntriangles[255].a = vec3(10.674663827505015,1.2685993652343655,-1.1940999960899352);\ntriangles[255].b = vec3(5.2038691497706395,1.2664936523437405,-1.1940999960899352);\ntriangles[255].c = vec3(10.67475538023939,1.0861042480468655,-1.1942000126838683);\ntriangles[255].n = vec3(2.1094508094977602e-7,-0.0005480506061829492,0.999999849820233);\ntriangles[256].a = vec3(5.2038691497706395,1.2664936523437405,-1.1940999960899352);\ntriangles[256].b = vec3(10.674663827505015,1.2685993652343655,-1.1940999960899352);\ntriangles[256].c = vec3(5.2038691497706395,1.3578022460937405,-1.3522000050544738);\ntriangles[256].n = vec3(-0.0003333068523960803,0.8659553551954802,0.5001211970260929);\ntriangles[257].a = vec3(10.674663827505015,1.3599995117187405,-1.3520999884605407);\ntriangles[257].b = vec3(5.2038691497706395,1.3578022460937405,-1.3522000050544738);\ntriangles[257].c = vec3(10.674663827505015,1.2685993652343655,-1.1940999960899352);\ntriangles[257].n = vec3(-0.0003568104605285122,0.8656008581118757,0.5007344876501716);\ntriangles[258].a = vec3(10.674663827505015,1.3599995117187405,-1.3520999884605407);\ntriangles[258].b = vec3(10.674663827505015,1.2685993652343655,-1.1940999960899352);\ntriangles[258].c = vec3(10.674663827505015,1.2688129882812405,-1.5102999991178512);\ntriangles[258].n = vec3(1,0,0);\ntriangles[259].a = vec3(10.67475538023939,0.9948872070312405,-1.3522999918460845);\ntriangles[259].b = vec3(10.674663827505015,1.2688129882812405,-1.5102999991178512);\ntriangles[259].c = vec3(10.674663827505015,1.2685993652343655,-1.1940999960899352);\ntriangles[259].n = vec3(0.9999999441033827,0.0003343548723501501,2.2588838040787389e-7);\ntriangles[260].a = vec3(10.67475538023939,1.0861042480468655,-1.1942000126838683);\ntriangles[260].b = vec3(10.67475538023939,0.9948872070312405,-1.3522999918460845);\ntriangles[260].c = vec3(10.674663827505015,1.2685993652343655,-1.1940999960899352);\ntriangles[260].n = vec3(0.9999998321675484,0.0005018308366538666,-0.00028953529439111343);\ntriangles[261].a = vec3(10.674663827505015,1.2688129882812405,-1.5102999991178512);\ntriangles[261].b = vec3(10.67475538023939,0.9948872070312405,-1.3522999918460845);\ntriangles[261].c = vec3(10.67475538023939,1.0861958007812405,-1.510400000810623);\ntriangles[261].n = vec3(0.9999998325197792,0.000501178311342925,0.0002894489831242604);\ntriangles[262].a = vec3(10.043560311880015,1.5203999023437405,-1.465899992585182);\ntriangles[262].b = vec3(10.043667123403452,1.2852924804687405,-1.465999994277954);\ntriangles[262].c = vec3(9.55366163023939,1.5201862792968655,-1.465899992585182);\ntriangles[262].n = vec3(-1.85473864693274e-7,0.00042534456427444675,-0.9999999095409796);\ntriangles[263].a = vec3(9.553768441762827,1.2851093749999905,-1.465999994277954);\ntriangles[263].b = vec3(9.55366163023939,1.5201862792968655,-1.465899992585182);\ntriangles[263].c = vec3(10.043667123403452,1.2852924804687405,-1.465999994277954);\ntriangles[263].n = vec3(-1.589982412014284e-7,0.0004253997943344217,-0.9999999095174907);\ntriangles[264].a = vec3(10.043560311880015,1.5203083496093655,-1.2380999958515166);\ntriangles[264].b = vec3(9.55366163023939,1.5200947265624905,-1.2380999958515166);\ntriangles[264].c = vec3(10.043667123403452,1.2852009277343655,-1.2382999992370605);\ntriangles[264].n = vec3(3.7094762871988874e-7,-0.000850688897691482,0.9999996381640655);\ntriangles[265].a = vec3(9.553768441762827,1.2849873046874905,-1.2382000124454497);\ntriangles[265].b = vec3(10.043667123403452,1.2852009277343655,-1.2382999992370605);\ntriangles[265].c = vec3(9.55366163023939,1.5200947265624905,-1.2380999958515166);\ntriangles[265].n = vec3(0.00020428231665657492,-0.0004253152124978597,0.9999998886878464);\ntriangles[266].a = vec3(10.043667123403452,1.2852009277343655,-1.2382999992370605);\ntriangles[266].b = vec3(10.043667123403452,1.2852924804687405,-1.465999994277954);\ntriangles[266].c = vec3(10.043560311880015,1.5203083496093655,-1.2380999958515166);\ntriangles[266].n = vec3(0.9999998968015319,0.00045430924735971633,1.8266690712997327e-7);\ntriangles[267].a = vec3(10.043560311880015,1.5203999023437405,-1.465899992585182);\ntriangles[267].b = vec3(10.043560311880015,1.5203083496093655,-1.2380999958515166);\ntriangles[267].c = vec3(10.043667123403452,1.2852924804687405,-1.465999994277954);\ntriangles[267].n = vec3(0.9999998968014966,0.00045430932509019333,1.8258674960692447e-7);\ntriangles[268].a = vec3(1.6525691009425145,0.44648632812499045,-1.751399997472763);\ntriangles[268].b = vec3(1.2772639251612645,0.6792133789062405,-1.7513000032305717);\ntriangles[268].c = vec3(4.715664193715952,0.44770703124999045,-1.751399997472763);\ntriangles[268].n = vec3(-1.7111916262833046e-7,0.0004293871757937368,-0.9999999078133078);\ntriangles[269].a = vec3(1.2769587493800145,1.4310139160156155,-1.7508000022172927);\ntriangles[269].b = vec3(4.715664193715952,0.44770703124999045,-1.751399997472763);\ntriangles[269].c = vec3(1.2772639251612645,0.6792133789062405,-1.7513000032305717);\ntriangles[269].n = vec3(0.00001569784221626492,0.0006650775951275847,-0.9999997787126608);\ntriangles[270].a = vec3(4.715664193715952,0.44770703124999045,-1.751399997472763);\ntriangles[270].b = vec3(1.2769587493800145,1.4310139160156155,-1.7508000022172927);\ntriangles[270].c = vec3(5.154568002309702,0.8596943359374905,-1.7510999998450278);\ntriangles[270].n = vec3(0.000025861498081966407,0.000700620724757061,-0.9999997542308613);\ntriangles[271].a = vec3(5.154262826528452,1.4325092773437405,-1.7508000022172927);\ntriangles[271].b = vec3(5.154568002309702,0.8596943359374905,-1.7510999998450278);\ntriangles[271].c = vec3(1.2769587493800145,1.4310139160156155,-1.7508000022172927);\ntriangles[271].n = vec3(-2.0198523189887153e-7,0.0005237250345020302,-0.9999998628560144);\ntriangles[272].a = vec3(1.2769587493800145,1.4310139160156155,-1.7508000022172927);\ntriangles[272].b = vec3(1.1468623138331395,1.5608967285156155,-1.620700001567602);\ntriangles[272].c = vec3(5.154262826528452,1.4325092773437405,-1.7508000022172927);\ntriangles[272].n = vec3(-0.0002728852290516192,0.7075607689561592,-0.7066524490637677);\ntriangles[273].a = vec3(5.284267709340952,1.5625141601562405,-1.620700001567602);\ntriangles[273].b = vec3(5.154262826528452,1.4325092773437405,-1.7508000022172927);\ntriangles[273].c = vec3(1.1468623138331395,1.5608967285156155,-1.620700001567602);\ntriangles[273].n = vec3(-0.00027658360312566324,0.7075034660747213,-0.7067098195113509);\ntriangles[274].a = vec3(5.154262826528452,1.4325092773437405,-1.7508000022172927);\ntriangles[274].b = vec3(5.284267709340952,1.5625141601562405,-1.620700001567602);\ntriangles[274].c = vec3(5.154568002309702,0.8596943359374905,-1.7510999998450278);\ntriangles[274].n = vec3(0.7069917680885576,0.0007470501741847149,-0.7072213810194461);\ntriangles[275].a = vec3(5.2845576263331395,0.8032978515624905,-1.6211999988555907);\ntriangles[275].b = vec3(5.154568002309702,0.8596943359374905,-1.7510999998450278);\ntriangles[275].c = vec3(5.284267709340952,1.5625141601562405,-1.620700001567602);\ntriangles[275].n = vec3(0.7070223914921978,0.0007357208610688351,-0.707190778109746);\ntriangles[276].a = vec3(5.154568002309702,0.8596943359374905,-1.7510999998450278);\ntriangles[276].b = vec3(5.2845576263331395,0.8032978515624905,-1.6211999988555907);\ntriangles[276].c = vec3(4.715664193715952,0.44770703124999045,-1.751399997472763);\ntriangles[276].n = vec3(0.4838041773599553,-0.5148974025260332,-0.7076822612168552);\ntriangles[277].a = vec3(4.7671626068018895,0.31761059570311545,-1.6215000002086162);\ntriangles[277].b = vec3(4.715664193715952,0.44770703124999045,-1.751399997472763);\ntriangles[277].c = vec3(5.2845576263331395,0.8032978515624905,-1.6211999988555907);\ntriangles[277].n = vec3(0.4838416094830727,-0.5149918154622775,-0.7075879641003637);\ntriangles[278].a = vec3(1.6525691009425145,0.44648632812499045,-1.751399997472763);\ntriangles[278].b = vec3(1.615566537465952,0.31651196289061545,-1.6215000002086162);\ntriangles[278].c = vec3(1.2772639251612645,0.6792133789062405,-1.7513000032305717);\ntriangles[278].n = vec3(-0.37270704669333127,-0.6007387722638738,-0.7072498744036854);\ntriangles[279].a = vec3(1.1472590423487645,0.6352070312499905,-1.6213000005483627);\ntriangles[279].b = vec3(1.2772639251612645,0.6792133789062405,-1.7513000032305717);\ntriangles[279].c = vec3(1.615566537465952,0.31651196289061545,-1.6215000002086162);\ntriangles[279].n = vec3(-0.43041221389700457,-0.6320662228841937,-0.6443893357413577);\ntriangles[280].a = vec3(1.2772639251612645,0.6792133789062405,-1.7513000032305717);\ntriangles[280].b = vec3(1.1472590423487645,0.6352070312499905,-1.6213000005483627);\ntriangles[280].c = vec3(1.2769587493800145,1.4310139160156155,-1.7508000022172927);\ntriangles[280].n = vec3(-0.7071245081813111,0.0001832240740170745,-0.7070890300084407);\ntriangles[281].a = vec3(1.1468623138331395,1.5608967285156155,-1.620700001567602);\ntriangles[281].b = vec3(1.2769587493800145,1.4310139160156155,-1.7508000022172927);\ntriangles[281].c = vec3(1.1472590423487645,0.6352070312499905,-1.6213000005483627);\ntriangles[281].n = vec3(-0.7070389138276372,0.00015534531264038243,-0.7071746249698648);\ntriangles[282].a = vec3(4.715664193715952,0.44770703124999045,-1.751399997472763);\ntriangles[282].b = vec3(4.7671626068018895,0.31761059570311545,-1.6215000002086162);\ntriangles[282].c = vec3(1.6525691009425145,0.44648632812499045,-1.751399997472763);\ntriangles[282].n = vec3(0.0002815605977685983,-0.7065164884732715,-0.707696525524202);\ntriangles[283].a = vec3(1.615566537465952,0.31651196289061545,-1.6215000002086162);\ntriangles[283].b = vec3(1.6525691009425145,0.44648632812499045,-1.751399997472763);\ntriangles[283].c = vec3(4.7671626068018895,0.31761059570311545,-1.6215000002086162);\ntriangles[283].n = vec3(0.0002464360561711005,-0.7069394770798278,-0.7072740027848966);\ntriangles[284].a = vec3(1.1468623138331395,1.5608967285156155,-1.620700001567602);\ntriangles[284].b = vec3(1.1468623138331395,1.5604999999999905,-1.0835000014305114);\ntriangles[284].c = vec3(5.284267709340952,1.5625141601562405,-1.620700001567602);\ntriangles[284].n = vec3(-0.00039092883615314956,0.9999996508876449,0.000738511498549759);\ntriangles[285].a = vec3(5.284267709340952,1.5620869140624905,-1.0833999848365783);\ntriangles[285].b = vec3(5.284267709340952,1.5625141601562405,-1.620700001567602);\ntriangles[285].c = vec3(1.1468623138331395,1.5604999999999905,-1.0835000014305114);\ntriangles[285].n = vec3(-0.00038357202709133503,0.9999996102869219,0.0007951719969152579);\ntriangles[286].a = vec3(5.284267709340952,1.5620869140624905,-1.0833999848365783);\ntriangles[286].b = vec3(1.1468623138331395,1.5604999999999905,-1.0835000014305114);\ntriangles[286].c = vec3(5.154262826528452,1.4319904785156155,-0.953500006198883);\ntriangles[286].n = vec3(-0.0002881660268563379,0.7067164349518419,0.7074968533705999);\ntriangles[287].a = vec3(1.2769587493800145,1.4304951171874905,-0.9536000227928161);\ntriangles[287].b = vec3(5.154262826528452,1.4319904785156155,-0.953500006198883);\ntriangles[287].c = vec3(1.1468623138331395,1.5604999999999905,-1.0835000014305114);\ntriangles[287].n = vec3(-0.0002907950790447661,0.7066756551846204,0.7075375847314471);\ntriangles[288].a = vec3(5.154262826528452,1.4319904785156155,-0.953500006198883);\ntriangles[288].b = vec3(1.2769587493800145,1.4304951171874905,-0.9536000227928161);\ntriangles[288].c = vec3(5.1544611907862645,0.8591145019531155,-0.9539000129699706);\ntriangles[288].n = vec3(-0.000025526094592158643,-0.0006982518961775511,0.9999997558963243);\ntriangles[289].a = vec3(4.715664193715952,0.44718823242186545,-0.9542000031471252);\ntriangles[289].b = vec3(5.1544611907862645,0.8591145019531155,-0.9539000129699706);\ntriangles[289].c = vec3(1.2769587493800145,1.4304951171874905,-0.9536000227928161);\ntriangles[289].n = vec3(-0.00002588507905680512,-0.0007006880352187209,0.9999997541830898);\ntriangles[290].a = vec3(1.2769587493800145,1.4304951171874905,-0.9536000227928161);\ntriangles[290].b = vec3(1.2772639251612645,0.6786030273437405,-0.9540999865531921);\ntriangles[290].c = vec3(4.715664193715952,0.44718823242186545,-0.9542000031471252);\ntriangles[290].n = vec3(-0.00001566484707872072,-0.0006649470543304037,0.9999997787999894);\ntriangles[291].a = vec3(1.652462289419077,0.44599804687499045,-0.9542000031471252);\ntriangles[291].b = vec3(4.715664193715952,0.44718823242186545,-0.9542000031471252);\ntriangles[291].c = vec3(1.2772639251612645,0.6786030273437405,-0.9540999865531921);\ntriangles[291].n = vec3(1.6696289225445777e-7,-0.0004297153925651589,0.9999999076723226);\ntriangles[292].a = vec3(4.715664193715952,0.44718823242186545,-0.9542000031471252);\ntriangles[292].b = vec3(1.652462289419077,0.44599804687499045,-0.9542000031471252);\ntriangles[292].c = vec3(4.767055795278452,0.31730541992186545,-1.0841999983787536);\ntriangles[292].n = vec3(0.00027484410009936266,-0.7073711935249622,0.7068422165036488);\ntriangles[293].a = vec3(1.615566537465952,0.31611523437499045,-1.0843000149726867);\ntriangles[293].b = vec3(4.767055795278452,0.31730541992186545,-1.0841999983787536);\ntriangles[293].c = vec3(1.652462289419077,0.44599804687499045,-0.9542000031471252);\ntriangles[293].n = vec3(0.0002448596467641559,-0.7077319759370134,0.7064809907421742);\ntriangles[294].a = vec3(1.615566537465952,0.31611523437499045,-1.0843000149726867);\ntriangles[294].b = vec3(1.615566537465952,0.31651196289061545,-1.6215000002086162);\ntriangles[294].c = vec3(4.767055795278452,0.31730541992186545,-1.0841999983787536);\ntriangles[294].n = vec3(0.00037768143993581477,-0.9999996559786712,-0.0007385115227947973);\ntriangles[295].a = vec3(1.615566537465952,0.31611523437499045,-1.0843000149726867);\ntriangles[295].b = vec3(1.1472590423487645,0.6348103027343655,-1.0840999817848205);\ntriangles[295].c = vec3(1.615566537465952,0.31651196289061545,-1.6215000002086162);\ntriangles[295].n = vec3(-0.5626069848266793,-0.8267242634992017,-0.0006105456048089129);\ntriangles[296].a = vec3(1.1472590423487645,0.6352070312499905,-1.6213000005483627);\ntriangles[296].b = vec3(1.615566537465952,0.31651196289061545,-1.6215000002086162);\ntriangles[296].c = vec3(1.1472590423487645,0.6348103027343655,-1.0840999817848205);\ntriangles[296].n = vec3(-0.5626069847968059,-0.8267242635195592,-0.0006105455667187055);\ntriangles[297].a = vec3(4.7671626068018895,0.31761059570311545,-1.6215000002086162);\ntriangles[297].b = vec3(4.767055795278452,0.31730541992186545,-1.0841999983787536);\ntriangles[297].c = vec3(1.615566537465952,0.31651196289061545,-1.6215000002086162);\ntriangles[297].n = vec3(0.00034859561454273906,-0.9999997779791798,-0.0005679108103978617);\ntriangles[298].a = vec3(3.4792597747706395,2.0344990234374905,0.06780001163482674);\ntriangles[298].b = vec3(3.1381648040675145,1.6259907226562405,0.06749996185302742);\ntriangles[298].c = vec3(3.479366586294077,1.7518146972656155,0.45630010604858406);\ntriangles[298].n = vec3(-0.69580425598029,0.5806699632675332,0.4227041886693305);\ntriangles[299].a = vec3(3.479366586294077,1.7518146972656155,0.45630010604858406);\ntriangles[299].b = vec3(3.1381648040675145,1.6259907226562405,0.06749996185302742);\ntriangles[299].c = vec3(3.4795649505518895,1.2949970703124905,0.3074999713897706);\ntriangles[299].n = vec3(-0.6958794903805496,-0.2226980448345514,0.6827571425437999);\ntriangles[300].a = vec3(-2.686343862924673,0.01399121093749045,-1.364800009727478);\ntriangles[300].b = vec3(-2.6866337799168605,0.6172016601562405,-1.3957999980449676);\ntriangles[300].c = vec3(-2.361240103159048,0.01411328124999045,-1.364800009727478);\ntriangles[300].n = vec3(0.000019271162252005616,-0.05132392286765396,-0.9986820588005462);\ntriangles[301].a = vec3(-2.3614384674168605,0.6173847656249905,-1.3957000112533569);\ntriangles[301].b = vec3(-2.361240103159048,0.01411328124999045,-1.364800009727478);\ntriangles[301].c = vec3(-2.6866337799168605,0.6172016601562405,-1.3957999980449676);\ntriangles[301].n = vec3(0.00033586701305925897,-0.05115355138890965,-0.9986907436106796);\ntriangles[302].a = vec3(-2.3614384674168605,0.6172932128906155,-1.3098000025749206);\ntriangles[302].b = vec3(-2.6866337799168605,0.6172016601562405,-1.3098000025749206);\ntriangles[302].c = vec3(-2.361240103159048,0.01411328124999045,-1.3414999878406524);\ntriangles[302].n = vec3(0.000014775433939102284,-0.05248234135169132,0.9986218521682425);\ntriangles[303].a = vec3(-2.686343862924673,0.01399121093749045,-1.3414999878406524);\ntriangles[303].b = vec3(-2.361240103159048,0.01411328124999045,-1.3414999878406524);\ntriangles[303].c = vec3(-2.6866337799168605,0.6172016601562405,-1.3098000025749206);\ntriangles[303].n = vec3(0.000019705130527821196,-0.0524796888782198,0.9986219914797356);\ntriangles[304].a = vec3(-3.8361393951512355,1.1457966308593655,-1.6897999996691941);\ntriangles[304].b = vec3(-3.8361393951512355,1.1458881835937405,-1.7661000004410743);\ntriangles[304].c = vec3(-0.8177372955418605,1.1469868164062405,-1.6897999996691941);\ntriangles[304].n = vec3(0.00039430949167025347,-0.9999992023751221,-0.0011999038063444233);\ntriangles[305].a = vec3(-1.065341665659048,1.1469868164062405,-1.7661000004410743);\ntriangles[305].b = vec3(-0.8177372955418605,1.1469868164062405,-1.6897999996691941);\ntriangles[305].c = vec3(-3.8361393951512355,1.1458881835937405,-1.7661000004410743);\ntriangles[305].n = vec3(0.00039650379563342593,-0.999999093578985,-0.0012867112919226942);\ntriangles[306].a = vec3(-1.065341665659048,1.1469868164062405,-1.7661000004410743);\ntriangles[306].b = vec3(-0.9987370514012355,1.1469868164062405,-1.7892999982833862);\ntriangles[306].c = vec3(-0.8177372955418605,1.1469868164062405,-1.6897999996691941);\ntriangles[306].n = vec3(0,-1,0);\ntriangles[307].a = vec3(-0.8177372955418605,1.1469868164062405,-1.6897999996691941);\ntriangles[307].b = vec3(-0.9987370514012355,1.1469868164062405,-1.7892999982833862);\ntriangles[307].c = vec3(-0.9192387603856105,1.1472004394531155,-2.088700000047684);\ntriangles[307].n = vec3(0.00034227062648131066,-0.9999997475962268,-0.0006226221175255002);\ntriangles[308].a = vec3(-0.981235220346548,1.1472004394531155,-2.088600013256073);\ntriangles[308].b = vec3(-0.9192387603856105,1.1472004394531155,-2.088700000047684);\ntriangles[308].c = vec3(-0.9987370514012355,1.1469868164062405,-1.7892999982833862);\ntriangles[308].n = vec3(-0.000001151219021491565,-0.9999997452374305,-0.0007138093224357547);\ntriangles[309].a = vec3(-0.9193303131199855,1.3364094238281155,-2.08849999666214);\ntriangles[309].b = vec3(-0.817844107065298,1.3361958007812405,-1.6896999998390674);\ntriangles[309].c = vec3(-0.9192387603856105,1.1472004394531155,-2.088700000047684);\ntriangles[309].n = vec3(0.9691124138286499,0.0007296132966945542,-0.24661832257082);\ntriangles[310].a = vec3(-0.8177372955418605,1.1469868164062405,-1.6897999996691941);\ntriangles[310].b = vec3(-0.9192387603856105,1.1472004394531155,-2.088700000047684);\ntriangles[310].c = vec3(-0.817844107065298,1.3361958007812405,-1.6896999998390674);\ntriangles[310].n = vec3(0.9691183592386845,0.0006774122148367626,-0.2465951072085812);\ntriangles[311].a = vec3(-3.8361393951512355,1.3350056152343655,-1.6896999998390674);\ntriangles[311].b = vec3(-3.8361393951512355,1.3350971679687405,-1.7659999987483024);\ntriangles[311].c = vec3(-3.8361393951512355,1.1457966308593655,-1.6897999996691941);\ntriangles[311].n = vec3(-1,0,0);\ntriangles[312].a = vec3(-3.8361393951512355,1.1458881835937405,-1.7661000004410743);\ntriangles[312].b = vec3(-3.8361393951512355,1.1457966308593655,-1.6897999996691941);\ntriangles[312].c = vec3(-3.8361393951512355,1.3350971679687405,-1.7659999987483024);\ntriangles[312].n = vec3(-1,0,0);\ntriangles[313].a = vec3(-0.9813420318699855,1.3364094238281155,-2.08849999666214);\ntriangles[313].b = vec3(-0.9987370514012355,1.3361958007812405,-1.7891999965906142);\ntriangles[313].c = vec3(-0.9193303131199855,1.3364094238281155,-2.08849999666214);\ntriangles[313].n = vec3(0,0.9999997452861182,0.0007137420394627253);\ntriangles[314].a = vec3(-0.817844107065298,1.3361958007812405,-1.6896999998390674);\ntriangles[314].b = vec3(-0.9193303131199855,1.3364094238281155,-2.08849999666214);\ntriangles[314].c = vec3(-0.9987370514012355,1.3361958007812405,-1.7891999965906142);\ntriangles[314].n = vec3(-0.0003425970928113553,0.9999997473436255,0.000622848229777606);\ntriangles[315].a = vec3(-0.9987370514012355,1.3361958007812405,-1.7891999965906142);\ntriangles[315].b = vec3(-1.065433218393423,1.3361958007812405,-1.7659999987483024);\ntriangles[315].c = vec3(-0.817844107065298,1.3361958007812405,-1.6896999998390674);\ntriangles[315].n = vec3(0,1,0);\ntriangles[316].a = vec3(-1.065433218393423,1.3361958007812405,-1.7659999987483024);\ntriangles[316].b = vec3(-3.8361393951512355,1.3350971679687405,-1.7659999987483024);\ntriangles[316].c = vec3(-0.817844107065298,1.3361958007812405,-1.6896999998390674);\ntriangles[316].n = vec3(-0.00039651689736656004,0.9999990936210742,0.0012866745432376344);\ntriangles[317].a = vec3(-3.8361393951512355,1.3350056152343655,-1.6896999998390674);\ntriangles[317].b = vec3(-0.817844107065298,1.3361958007812405,-1.6896999998390674);\ntriangles[317].c = vec3(-3.8361393951512355,1.3350971679687405,-1.7659999987483024);\ntriangles[317].n = vec3(-0.0003943234455040904,0.9999992023695847,0.0011999038356299812);\ntriangles[318].a = vec3(-3.8361393951512355,1.3350971679687405,-1.7659999987483024);\ntriangles[318].b = vec3(-1.065433218393423,1.3361958007812405,-1.7659999987483024);\ntriangles[318].c = vec3(-3.8361393951512355,1.1458881835937405,-1.7661000004410743);\ntriangles[318].n = vec3(-2.0956928383805208e-7,0.0005285250017860741,-0.9999998603306295);\ntriangles[319].a = vec3(-1.065341665659048,1.1469868164062405,-1.7661000004410743);\ntriangles[319].b = vec3(-3.8361393951512355,1.1458881835937405,-1.7661000004410743);\ntriangles[319].c = vec3(-1.065433218393423,1.3361958007812405,-1.7659999987483024);\ntriangles[319].n = vec3(-2.0956231904111302e-7,0.0005285249003849804,-0.9999998603306832);\ntriangles[320].a = vec3(-0.9987370514012355,1.3361958007812405,-1.7891999965906142);\ntriangles[320].b = vec3(-0.9813420318699855,1.3364094238281155,-2.08849999666214);\ntriangles[320].c = vec3(-0.9987370514012355,1.1469868164062405,-1.7892999982833862);\ntriangles[320].n = vec3(-0.9983153577843287,0.00003066559454228702,-0.05802107782150851);\ntriangles[321].a = vec3(-0.981235220346548,1.1472004394531155,-2.088600013256073);\ntriangles[321].b = vec3(-0.9987370514012355,1.1469868164062405,-1.7892999982833862);\ntriangles[321].c = vec3(-0.9813420318699855,1.3364094238281155,-2.08849999666214);\ntriangles[321].n = vec3(-0.9982944942960205,-0.0005326952878102291,-0.05837652690922362);\ntriangles[322].a = vec3(-0.9813420318699855,1.3364094238281155,-2.08849999666214);\ntriangles[322].b = vec3(-0.9193303131199855,1.3364094238281155,-2.08849999666214);\ntriangles[322].c = vec3(-0.981235220346548,1.1472004394531155,-2.088600013256073);\ntriangles[322].n = vec3(0,0.0005286037567934044,-0.9999998602890244);\ntriangles[323].a = vec3(-0.9192387603856105,1.1472004394531155,-2.088700000047684);\ntriangles[323].b = vec3(-0.981235220346548,1.1472004394531155,-2.088600013256073);\ntriangles[323].c = vec3(-0.9193303131199855,1.3364094238281155,-2.08849999666214);\ntriangles[323].n = vec3(-0.001612779275786982,0.0010562678097387616,-0.9999981416189341);\ntriangles[324].a = vec3(-1.065433218393423,1.3361958007812405,-1.7659999987483024);\ntriangles[324].b = vec3(-0.9987370514012355,1.3361958007812405,-1.7891999965906142);\ntriangles[324].c = vec3(-1.065341665659048,1.1469868164062405,-1.7661000004410743);\ntriangles[324].n = vec3(-0.3285374208542909,0.00034021740097198687,-0.9444908932067745);\ntriangles[325].a = vec3(-0.9987370514012355,1.1469868164062405,-1.7892999982833862);\ntriangles[325].b = vec3(-1.065341665659048,1.1469868164062405,-1.7661000004410743);\ntriangles[325].c = vec3(-0.9987370514012355,1.3361958007812405,-1.7891999965906142);\ntriangles[325].n = vec3(-0.32894016302796103,0.000499112990259516,-0.9443506340514425);\ntriangles[326].a = vec3(13.01546125182142,-2.9232036132812595,-3.2226000165939332);\ntriangles[326].b = vec3(13.264759347524546,-2.9231120605468845,-3.2226000165939332);\ntriangles[326].c = vec3(13.013965890493296,0.9781025390624905,-1.838299993276596);\ntriangles[326].n = vec3(0.00012280661636717932,-0.3344024163678293,0.9424303734737608);\ntriangles[327].a = vec3(13.263164804067515,0.9781940917968655,-1.838299993276596);\ntriangles[327].b = vec3(13.013965890493296,0.9781025390624905,-1.838299993276596);\ntriangles[327].c = vec3(13.264759347524546,-2.9231120605468845,-3.2226000165939332);\ntriangles[327].n = vec3(0.00012285549284822022,-0.3344024135751181,0.9424303744583277);\ntriangles[328].a = vec3(13.264759347524546,-2.9231120605468845,-3.2226000165939332);\ntriangles[328].b = vec3(13.140064523305796,-2.8747111816406345,-3.3593000507354738);\ntriangles[328].c = vec3(13.263164804067515,0.9781940917968655,-1.838299993276596);\ntriangles[328].n = vec3(0.7582332015508304,0.21830009655582305,-0.6143512675250993);\ntriangles[329].a = vec3(13.13856153258314,0.9717854003906155,-1.9943999981880187);\ntriangles[329].b = vec3(13.263164804067515,0.9781940917968655,-1.838299993276596);\ntriangles[329].c = vec3(13.140064523305796,-2.8747111816406345,-3.3593000507354738);\ntriangles[329].n = vec3(0.7583123425906542,0.21826405912147612,-0.6142663848612353);\ntriangles[330].a = vec3(13.013965890493296,0.9781025390624905,-1.838299993276596);\ntriangles[330].b = vec3(13.13856153258314,0.9717854003906155,-1.9943999981880187);\ntriangles[330].c = vec3(13.01546125182142,-2.9232036132812595,-3.2226000165939332);\ntriangles[330].n = vec3(-0.7585113169369169,0.217658419685415,-0.6142356179990474);\ntriangles[331].a = vec3(13.140064523305796,-2.8747111816406345,-3.3593000507354738);\ntriangles[331].b = vec3(13.01546125182142,-2.9232036132812595,-3.2226000165939332);\ntriangles[331].c = vec3(13.13856153258314,0.9717854003906155,-1.9943999981880187);\ntriangles[331].n = vec3(-0.7585379818334154,0.21764983775881425,-0.6142057295724707);\ntriangles[332].a = vec3(13.787258431997202,-3.0636149902343845,-3.044299993515015);\ntriangles[332].b = vec3(12.499264047231577,-3.0641032714843845,-3.044299993515015);\ntriangles[332].c = vec3(13.787258431997202,-2.8751994628906345,-3.5748999452590944);\ntriangles[332].n = vec3(0.00035724690382861945,-0.9423503485054302,-0.3346276931850444);\ntriangles[333].a = vec3(12.499264047231577,-2.8756877441406345,-3.5749999618530275);\ntriangles[333].b = vec3(13.787258431997202,-2.8751994628906345,-3.5748999452590944);\ntriangles[333].c = vec3(12.499264047231577,-3.0641032714843845,-3.044299993515015);\ntriangles[333].n = vec3(0.0003832349251932328,-0.9423702247327039,-0.3345716853952611);\ntriangles[334].a = vec3(12.49915723570814,-2.7929851074218845,-3.545599970817566);\ntriangles[334].b = vec3(12.499264047231577,-2.9813090820312595,-3.0149000024795534);\ntriangles[334].c = vec3(13.787258431997202,-2.7925883789062595,-3.545599970817566);\ntriangles[334].n = vec3(-0.0002902609498418124,0.9424214847229337,0.33442736263828987);\ntriangles[335].a = vec3(13.787258431997202,-2.9807902832031345,-3.0149000024795534);\ntriangles[335].b = vec3(13.787258431997202,-2.7925883789062595,-3.545599970817566);\ntriangles[335].c = vec3(12.499264047231577,-2.9813090820312595,-3.0149000024795534);\ntriangles[335].n = vec3(-0.0003796309981666115,0.9424897810365788,0.3342347506198705);\ntriangles[336].a = vec3(12.499264047231577,-2.8756877441406345,-3.5749999618530275);\ntriangles[336].b = vec3(12.49915723570814,-2.7929851074218845,-3.545599970817566);\ntriangles[336].c = vec3(13.787258431997202,-2.8751994628906345,-3.5748999452590944);\ntriangles[336].n = vec3(-0.000053814861774917394,0.33495507921130274,-0.9422340961855025);\ntriangles[337].a = vec3(13.787258431997202,-2.7925883789062595,-3.545599970817566);\ntriangles[337].b = vec3(13.787258431997202,-2.8751994628906345,-3.5748999452590944);\ntriangles[337].c = vec3(12.49915723570814,-2.7929851074218845,-3.545599970817566);\ntriangles[337].n = vec3(-0.00010295394766144299,0.3342716692206167,-0.9424767586295948);\ntriangles[338].a = vec3(12.499264047231577,-3.0641032714843845,-3.044299993515015);\ntriangles[338].b = vec3(12.499264047231577,-2.9813090820312595,-3.0149000024795534);\ntriangles[338].c = vec3(12.499264047231577,-2.8756877441406345,-3.5749999618530275);\ntriangles[338].n = vec3(-1,0,0);\ntriangles[339].a = vec3(12.49915723570814,-2.7929851074218845,-3.545599970817566);\ntriangles[339].b = vec3(12.499264047231577,-2.8756877441406345,-3.5749999618530275);\ntriangles[339].c = vec3(12.499264047231577,-2.9813090820312595,-3.0149000024795534);\ntriangles[339].n = vec3(-0.9999992414507868,-0.0012103723194081823,-0.00022824701480905974);\ntriangles[340].a = vec3(13.787258431997202,-3.0636149902343845,-3.044299993515015);\ntriangles[340].b = vec3(13.787258431997202,-2.9807902832031345,-3.0149000024795534);\ntriangles[340].c = vec3(12.499264047231577,-3.0641032714843845,-3.044299993515015);\ntriangles[340].n = vec3(0.00012681596862680424,-0.33451674724339203,0.9423897971282429);\ntriangles[341].a = vec3(12.499264047231577,-2.9813090820312595,-3.0149000024795534);\ntriangles[341].b = vec3(12.499264047231577,-3.0641032714843845,-3.044299993515015);\ntriangles[341].c = vec3(13.787258431997202,-2.9807902832031345,-3.0149000024795534);\ntriangles[341].n = vec3(0.00013478607147955385,-0.33462624392909235,0.9423509212106829);\ntriangles[342].a = vec3(13.787258431997202,-2.8751994628906345,-3.5748999452590944);\ntriangles[342].b = vec3(13.787258431997202,-2.7925883789062595,-3.545599970817566);\ntriangles[342].c = vec3(13.787258431997202,-3.0636149902343845,-3.044299993515015);\ntriangles[342].n = vec3(1,0,0);\ntriangles[343].a = vec3(13.787258431997202,-2.9807902832031345,-3.0149000024795534);\ntriangles[343].b = vec3(13.787258431997202,-3.0636149902343845,-3.044299993515015);\ntriangles[343].c = vec3(13.787258431997202,-2.7925883789062595,-3.545599970817566);\ntriangles[343].n = vec3(1,0,0);\ntriangles[344].a = vec3(-3.4745366119481105,1.9110859374999905,-1.5946000030636787);\ntriangles[344].b = vec3(-3.474643423471548,2.2056110839843655,-1.594299997985363);\ntriangles[344].c = vec3(-2.261630728159048,1.9115131835937405,-1.5945000013709067);\ntriangles[344].n = vec3(0.00008208916616024148,0.0010186352279580304,-0.9999994778216842);\ntriangles[345].a = vec3(-3.474643423471548,2.2056110839843655,-1.594299997985363);\ntriangles[345].b = vec3(-2.386844351205923,2.3310993652343655,-1.594299997985363);\ntriangles[345].c = vec3(-2.261630728159048,1.9115131835937405,-1.5945000013709067);\ntriangles[345].n = vec3(-0.00005315831890323335,0.00046080454214634067,-0.9999998924166777);\ntriangles[346].a = vec3(-3.474643423471548,2.2056110839843655,-1.594299997985363);\ntriangles[346].b = vec3(-3.349734976205923,2.3307026367187405,-1.594299997985363);\ntriangles[346].c = vec3(-2.386844351205923,2.3310993652343655,-1.594299997985363);\ntriangles[346].n = vec3(0,0,-1);\ntriangles[347].a = vec3(-2.2617375396824855,2.2060993652343655,-1.594299997985363);\ntriangles[347].b = vec3(-2.261630728159048,1.9115131835937405,-1.5945000013709067);\ntriangles[347].c = vec3(-2.386844351205923,2.3310993652343655,-1.594299997985363);\ntriangles[347].n = vec3(0.0006785958420811423,0.0006791756969266706,-0.9999995391139217);\ntriangles[348].a = vec3(12.499264047231577,-3.0662089843750095,0.3326999807357789);\ntriangles[348].b = vec3(12.49915723570814,-2.8785869140625095,0.8636001014709473);\ntriangles[348].c = vec3(12.499264047231577,-2.9835063476562595,0.3035000228881837);\ntriangles[348].n = vec3(-0.9999999820084355,-0.00006315413372288963,-0.00017887057939714265);\ntriangles[349].a = vec3(12.49915723570814,-2.7959147949218845,0.8344000244140626);\ntriangles[349].b = vec3(12.499264047231577,-2.9835063476562595,0.3035000228881837);\ntriangles[349].c = vec3(12.49915723570814,-2.8785869140625095,0.8636001014709473);\ntriangles[349].n = vec3(-0.9999999820077798,-0.0000631762416309662,-0.0001788664380849878);\ntriangles[350].a = vec3(12.499264047231577,-2.9835063476562595,0.3035000228881837);\ntriangles[350].b = vec3(13.787258431997202,-2.9829875488281345,0.3035000228881837);\ntriangles[350].c = vec3(12.499264047231577,-3.0662089843750095,0.3326999807357789);\ntriangles[350].n = vec3(0.00013410264185973196,-0.33292952939352866,-0.9429517010294245);\ntriangles[351].a = vec3(13.787258431997202,-3.0658122558593845,0.3326999807357789);\ntriangles[351].b = vec3(12.499264047231577,-3.0662089843750095,0.3326999807357789);\ntriangles[351].c = vec3(13.787258431997202,-2.9829875488281345,0.3035000228881837);\ntriangles[351].n = vec3(0.00010241465842809827,-0.3324931276121452,-0.9431056725531511);\ntriangles[352].a = vec3(13.787258431997202,-2.9829875488281345,0.3035000228881837);\ntriangles[352].b = vec3(13.787159249868296,-2.7953959960937595,0.8344000244140626);\ntriangles[352].c = vec3(13.787258431997202,-3.0658122558593845,0.3326999807357789);\ntriangles[352].n = vec3(0.9999999844862925,0.000058567336457335514,0.00016612429747322238);\ntriangles[353].a = vec3(13.787159249868296,-2.8780986328125095,0.8636001014709473);\ntriangles[353].b = vec3(13.787258431997202,-3.0658122558593845,0.3326999807357789);\ntriangles[353].c = vec3(13.787159249868296,-2.7953959960937595,0.8344000244140626);\ntriangles[353].n = vec3(0.9999999844885447,0.000058640162841434165,0.00016608504406189626);\ntriangles[354].a = vec3(-3.310641958627798,2.9659870605468655,-1.4589999949932098);\ntriangles[354].b = vec3(-3.419040396127798,2.9658955078124905,-1.4589999949932098);\ntriangles[354].c = vec3(-3.310245230112173,1.9192951660156155,-1.4597000068426131);\ntriangles[354].n = vec3(5.648518974493232e-7,-0.0006687846465799987,0.9999997763633639);\ntriangles[355].a = vec3(-3.418643667612173,1.9192951660156155,-1.4596000051498412);\ntriangles[355].b = vec3(-3.310245230112173,1.9192951660156155,-1.4597000068426131);\ntriangles[355].c = vec3(-3.419040396127798,2.9658955078124905,-1.4589999949932098);\ntriangles[355].n = vec3(0.0009225375947310223,-0.0005729444009382139,0.9999994103293761);\ntriangles[356].a = vec3(-3.419040396127798,3.0547932128906155,-1.539900000989437);\ntriangles[356].b = vec3(-3.310641958627798,3.0548847656249905,-1.539900000989437);\ntriangles[356].c = vec3(-3.418643667612173,1.9192951660156155,-1.5405999979376792);\ntriangles[356].n = vec3(-5.206643494841717e-7,0.0006164665897892593,-0.9999998099843184);\ntriangles[357].a = vec3(-3.310245230112173,1.9193867187499905,-1.5405999979376792);\ntriangles[357].b = vec3(-3.418643667612173,1.9192951660156155,-1.5405999979376792);\ntriangles[357].c = vec3(-3.310641958627798,3.0548847656249905,-1.539900000989437);\ntriangles[357].n = vec3(-5.206643494841717e-7,0.0006164665897892593,-0.9999998099843184);\ntriangles[358].a = vec3(-3.310641958627798,3.0546101074218655,-1.1640000081062316);\ntriangles[358].b = vec3(-3.310641958627798,3.0548847656249905,-1.539900000989437);\ntriangles[358].c = vec3(-3.419040396127798,3.0546101074218655,-1.1640000081062316);\ntriangles[358].n = vec3(0,0.9999997330620356,0.0007306680899396463);\ntriangles[359].a = vec3(-3.419040396127798,3.0547932128906155,-1.539900000989437);\ntriangles[359].b = vec3(-3.419040396127798,3.0546101074218655,-1.1640000081062316);\ntriangles[359].c = vec3(-3.310641958627798,3.0548847656249905,-1.539900000989437);\ntriangles[359].n = vec3(-0.0008445941931513357,0.9999995246911815,0.00048711195845978114);\ntriangles[360].a = vec3(-3.418643667612173,1.9192951660156155,-1.5405999979376792);\ntriangles[360].b = vec3(-3.418643667612173,1.9192951660156155,-1.4596000051498412);\ntriangles[360].c = vec3(-3.419040396127798,3.0547932128906155,-1.539900000989437);\ntriangles[360].n = vec3(-0.9999999389642878,-0.000349387207227901,0);\ntriangles[361].a = vec3(-3.419040396127798,2.9658955078124905,-1.4589999949932098);\ntriangles[361].b = vec3(-3.419040396127798,3.0547932128906155,-1.539900000989437);\ntriangles[361].c = vec3(-3.418643667612173,1.9192951660156155,-1.4596000051498412);\ntriangles[361].n = vec3(-0.9999998416029937,-0.0003788252949637976,-0.00041627561003389647);\ntriangles[362].a = vec3(-3.419040396127798,3.0547932128906155,-1.539900000989437);\ntriangles[362].b = vec3(-3.419040396127798,2.9658955078124905,-1.4589999949932098);\ntriangles[362].c = vec3(-3.419040396127798,3.0546101074218655,-1.1640000081062316);\ntriangles[362].n = vec3(-1,0,0);\ntriangles[363].a = vec3(-3.419040396127798,2.9658039550781155,-1.245099995136261);\ntriangles[363].b = vec3(-3.419040396127798,3.0546101074218655,-1.1640000081062316);\ntriangles[363].c = vec3(-3.419040396127798,2.9658955078124905,-1.4589999949932098);\ntriangles[363].n = vec3(-1,0,0);\ntriangles[364].a = vec3(-3.419040396127798,3.0546101074218655,-1.1640000081062316);\ntriangles[364].b = vec3(-3.419040396127798,2.9658039550781155,-1.245099995136261);\ntriangles[364].c = vec3(-3.418643667612173,1.9191120605468655,-1.1647999918460845);\ntriangles[364].n = vec3(-0.9999998655708761,-0.00034965693017182075,0.00038288152373426403);\ntriangles[365].a = vec3(-3.418643667612173,1.9191120605468655,-1.2457000052928924);\ntriangles[365].b = vec3(-3.418643667612173,1.9191120605468655,-1.1647999918460845);\ntriangles[365].c = vec3(-3.419040396127798,2.9658039550781155,-1.245099995136261);\ntriangles[365].n = vec3(-0.9999999281678162,-0.0003790308200531113,0);\ntriangles[366].a = vec3(-3.310245230112173,1.9191120605468655,-1.1647999918460845);\ntriangles[366].b = vec3(-3.310245230112173,1.9192036132812405,-1.2457000052928924);\ntriangles[366].c = vec3(-3.310641958627798,3.0546101074218655,-1.1640000081062316);\ntriangles[366].n = vec3(0.9999999389643071,0.0003493869286644483,3.953933665925177e-7);\ntriangles[367].a = vec3(-3.310641958627798,2.9658955078124905,-1.245099995136261);\ntriangles[367].b = vec3(-3.310641958627798,3.0546101074218655,-1.1640000081062316);\ntriangles[367].c = vec3(-3.310245230112173,1.9192036132812405,-1.2457000052928924);\ntriangles[367].n = vec3(0.9999998420154477,0.00037926861428930686,-0.0004148787748710715);\ntriangles[368].a = vec3(-3.310641958627798,3.0546101074218655,-1.1640000081062316);\ntriangles[368].b = vec3(-3.310641958627798,2.9658955078124905,-1.245099995136261);\ntriangles[368].c = vec3(-3.310641958627798,3.0548847656249905,-1.539900000989437);\ntriangles[368].n = vec3(1,0,0);\ntriangles[369].a = vec3(-3.310641958627798,2.9659870605468655,-1.4589999949932098);\ntriangles[369].b = vec3(-3.310641958627798,3.0548847656249905,-1.539900000989437);\ntriangles[369].c = vec3(-3.310641958627798,2.9658955078124905,-1.245099995136261);\ntriangles[369].n = vec3(1,0,0);\ntriangles[370].a = vec3(-3.310641958627798,3.0548847656249905,-1.539900000989437);\ntriangles[370].b = vec3(-3.310641958627798,2.9659870605468655,-1.4589999949932098);\ntriangles[370].c = vec3(-3.310245230112173,1.9193867187499905,-1.5405999979376792);\ntriangles[370].n = vec3(0.9999998654465719,0.00034915066331058745,0.00038366737199331974);\ntriangles[371].a = vec3(-3.310245230112173,1.9192951660156155,-1.4597000068426131);\ntriangles[371].b = vec3(-3.310245230112173,1.9193867187499905,-1.5405999979376792);\ntriangles[371].c = vec3(-3.310641958627798,2.9659870605468655,-1.4589999949932098);\ntriangles[371].n = vec3(0.999999928167833,0.0003790305331841485,4.289404888048168e-7);\ntriangles[372].a = vec3(-3.418643667612173,1.9191120605468655,-1.2457000052928924);\ntriangles[372].b = vec3(-3.419040396127798,2.9658039550781155,-1.245099995136261);\ntriangles[372].c = vec3(-3.310245230112173,1.9192036132812405,-1.2457000052928924);\ntriangles[372].n = vec3(-4.841587979684661e-7,0.000573244016794664,-0.999999835695518);\ntriangles[373].a = vec3(-3.310641958627798,2.9658955078124905,-1.245099995136261);\ntriangles[373].b = vec3(-3.310245230112173,1.9192036132812405,-1.2457000052928924);\ntriangles[373].c = vec3(-3.419040396127798,2.9658039550781155,-1.245099995136261);\ntriangles[373].n = vec3(-4.841587979684661e-7,0.000573244016794664,-0.999999835695518);\ntriangles[374].a = vec3(-3.419040396127798,2.9658039550781155,-1.245099995136261);\ntriangles[374].b = vec3(-3.419040396127798,2.9658955078124905,-1.4589999949932098);\ntriangles[374].c = vec3(-3.310641958627798,2.9658955078124905,-1.245099995136261);\ntriangles[374].n = vec3(0.0008445942159892015,-0.9999995517312146,-0.000428016331912086);\ntriangles[375].a = vec3(-3.310641958627798,2.9659870605468655,-1.4589999949932098);\ntriangles[375].b = vec3(-3.310641958627798,2.9658955078124905,-1.245099995136261);\ntriangles[375].c = vec3(-3.419040396127798,2.9658955078124905,-1.4589999949932098);\ntriangles[375].n = vec3(0.0008445942159892015,-0.9999995517312146,-0.000428016331912086);\ntriangles[376].a = vec3(-3.310245230112173,1.9191120605468655,-1.1647999918460845);\ntriangles[376].b = vec3(-3.310641958627798,3.0546101074218655,-1.1640000081062316);\ntriangles[376].c = vec3(-3.418643667612173,1.9191120605468655,-1.1647999918460845);\ntriangles[376].n = vec3(0,-0.0007045221641005513,0.9999997518242294);\ntriangles[377].a = vec3(-3.419040396127798,3.0546101074218655,-1.1640000081062316);\ntriangles[377].b = vec3(-3.418643667612173,1.9191120605468655,-1.1647999918460845);\ntriangles[377].c = vec3(-3.310641958627798,3.0546101074218655,-1.1640000081062316);\ntriangles[377].n = vec3(0,-0.0007045221641005513,0.9999997518242294);\ntriangles[378].a = vec3(-4.0062443756199855,1.4871967773437405,-1.5046999937295913);\ntriangles[378].b = vec3(-3.998843862924673,1.3866108398437405,-1.697900000810623);\ntriangles[378].c = vec3(-9.295230581674673,0.9939106445312405,-1.5831000021100043);\ntriangles[378].n = vec3(-0.0755199017494256,0.883266751583875,-0.46274894920056436);\ntriangles[379].a = vec3(-9.181537344369985,0.8173969726562405,-1.7087999990582465);\ntriangles[379].b = vec3(-9.295230581674673,0.9939106445312405,-1.5831000021100043);\ntriangles[379].c = vec3(-3.998843862924673,1.3866108398437405,-1.697900000810623);\ntriangles[379].n = vec3(-0.05904865872698999,0.5535458517145075,-0.8307227250726948);\ntriangles[380].a = vec3(-3.998843862924673,1.3866108398437405,-1.697900000810623);\ntriangles[380].b = vec3(-9.07744188538561,-0.09541430664063455,-1.782699998319149);\ntriangles[380].c = vec3(-9.181537344369985,0.8173969726562405,-1.7087999990582465);\ntriangles[380].n = vec3(-0.006682940138348477,0.07993569240701298,-0.996777619828274);\ntriangles[381].a = vec3(-9.07744188538561,-0.09541430664063455,-1.782699998319149);\ntriangles[381].b = vec3(-3.998843862924673,1.3866108398437405,-1.697900000810623);\ntriangles[381].c = vec3(-8.97703905335436,-1.1866923828125095,-1.7133000007271766);\ntriangles[381].n = vec3(0.034251258328239845,-0.06029080265416879,-0.9975930384772382);\ntriangles[382].a = vec3(-5.179935171518423,0.09290966796874045,-1.7028999997675418);\ntriangles[382].b = vec3(-8.97703905335436,-1.1866923828125095,-1.7133000007271766);\ntriangles[382].c = vec3(-3.998843862924673,1.3866108398437405,-1.697900000810623);\ntriangles[382].n = vec3(0.002074823445931752,0.0019706425275311788,-0.9999959058294675);\ntriangles[383].a = vec3(-8.97703905335436,-1.1866923828125095,-1.7133000007271766);\ntriangles[383].b = vec3(-5.179935171518423,0.09290966796874045,-1.7028999997675418);\ntriangles[383].c = vec3(-9.056537344369985,-1.3996135253906345,-1.602800000309944);\ntriangles[383].n = vec3(0.1720320678879788,-0.5036086601071869,-0.8466305481632646);\ntriangles[384].a = vec3(-5.179935171518423,0.09290966796874045,-1.7028999997675418);\ntriangles[384].b = vec3(-3.998843862924673,1.3866108398437405,-1.697900000810623);\ntriangles[384].c = vec3(-4.7025334381199855,-0.05760302734375955,-1.7030000014603137);\ntriangles[384].n = vec3(0.0007835050774698989,0.0031495539111134653,-0.9999947332011079);\ntriangles[385].a = vec3(-3.938632681284048,0.5867145996093655,-1.699700001478195);\ntriangles[385].b = vec3(-4.7025334381199855,-0.05760302734375955,-1.7030000014603137);\ntriangles[385].c = vec3(-3.998843862924673,1.3866108398437405,-1.697900000810623);\ntriangles[385].n = vec3(0.002277307158831922,0.00242170169005285,-0.9999944746012495);\ntriangles[386].a = vec3(-3.938632681284048,0.5867145996093655,-1.699700001478195);\ntriangles[386].b = vec3(-3.8195378326512355,0.47910961914061545,-1.570800002515316);\ntriangles[386].c = vec3(-4.7025334381199855,-0.05760302734375955,-1.7030000014603137);\ntriangles[386].n = vec3(0.4077871698864656,-0.47949127701453353,-0.7770442325524068);\ntriangles[387].a = vec3(-4.531741812143423,-0.12028613281250955,-1.513200003504753);\ntriangles[387].b = vec3(-4.7025334381199855,-0.05760302734375955,-1.7030000014603137);\ntriangles[387].c = vec3(-3.8195378326512355,0.47910961914061545,-1.570800002515316);\ntriangles[387].n = vec3(0.4706587776806074,-0.6196016108305639,-0.6281513821113245);\ntriangles[388].a = vec3(-4.0062443756199855,1.4871967773437405,-1.5046999937295913);\ntriangles[388].b = vec3(-3.502841665659048,1.9372089843749905,-1.5822000017762183);\ntriangles[388].c = vec3(-3.998843862924673,1.3866108398437405,-1.697900000810623);\ntriangles[388].n = vec3(-0.6501207107528058,0.6634754317976604,-0.3703287902002421);\ntriangles[389].a = vec3(-3.4954411529637355,1.8367145996093655,-1.6975999994575977);\ntriangles[389].b = vec3(-3.998843862924673,1.3866108398437405,-1.697900000810623);\ntriangles[389].c = vec3(-3.502841665659048,1.9372089843749905,-1.5822000017762183);\ntriangles[389].n = vec3(-0.5478920174276787,0.6131498518696148,-0.5690883906664217);\ntriangles[390].a = vec3(-3.502841665659048,1.9372089843749905,-1.5822000017762183);\ntriangles[390].b = vec3(-1.796939566049673,1.9380024414062405,-1.5821000000834464);\ntriangles[390].c = vec3(-3.4954411529637355,1.8367145996093655,-1.6975999994575977);\ntriangles[390].n = vec3(-0.00031226180675562296,0.7541211279538885,-0.6567352791392579);\ntriangles[391].a = vec3(-1.7956425689793605,1.8372944335937405,-1.6975999994575977);\ntriangles[391].b = vec3(-3.4954411529637355,1.8367145996093655,-1.6975999994575977);\ntriangles[391].c = vec3(-1.796939566049673,1.9380024414062405,-1.5821000000834464);\ntriangles[391].n = vec3(-0.0002571085641645035,0.7537205218630885,-0.6571950310353998);\ntriangles[392].a = vec3(-1.796939566049673,1.9380024414062405,-1.5821000000834464);\ntriangles[392].b = vec3(-1.514041616830923,2.1493977050781155,-1.5819999983906745);\ntriangles[392].c = vec3(-1.7956425689793605,1.8372944335937405,-1.6975999994575977);\ntriangles[392].n = vec3(-0.48903352899339575,0.6547176934416763,-0.5763600865905593);\ntriangles[393].a = vec3(-1.5127446197606105,2.0488117675781155,-1.697500001490116);\ntriangles[393].b = vec3(-1.7956425689793605,1.8372944335937405,-1.6975999994575977);\ntriangles[393].c = vec3(-1.514041616830923,2.1493977050781155,-1.5819999983906745);\ntriangles[393].n = vec3(-0.48944279971025767,0.6548869661410563,-0.5758201172157392);\ntriangles[394].a = vec3(-1.514041616830923,2.1493977050781155,-1.5819999983906745);\ntriangles[394].b = vec3(-0.794437124643423,2.1496113281249905,-1.5819999983906745);\ntriangles[394].c = vec3(-1.5127446197606105,2.0488117675781155,-1.697500001490116);\ntriangles[394].n = vec3(-0.0002238680098840342,0.7541153818665037,-0.6567419133232258);\ntriangles[395].a = vec3(-0.7931401275731105,2.0489948730468655,-1.6973999997973441);\ntriangles[395].b = vec3(-1.5127446197606105,2.0488117675781155,-1.697500001490116);\ntriangles[395].c = vec3(-0.794437124643423,2.1496113281249905,-1.5819999983906745);\ntriangles[395].n = vec3(-0.00010046379376388344,0.7537355242663012,-0.6571778673738417);\ntriangles[396].a = vec3(-0.794437124643423,2.1496113281249905,-1.5819999983906745);\ntriangles[396].b = vec3(-0.488132193002798,2.0044086914062405,-1.5821000000834464);\ntriangles[396].c = vec3(-0.7931401275731105,2.0489948730468655,-1.6973999997973441);\ntriangles[396].n = vec3(0.33708124060149663,0.7114974345642335,-0.6165611387713875);\ntriangles[397].a = vec3(-0.4868351959324855,1.9037006835937405,-1.6975999994575977);\ntriangles[397].b = vec3(-0.7931401275731105,2.0489948730468655,-1.6973999997973441);\ntriangles[397].c = vec3(-0.488132193002798,2.0044086914062405,-1.5821000000834464);\ntriangles[397].n = vec3(0.33708506305517755,0.7114815317516248,-0.6165774000411051);\ntriangles[398].a = vec3(-0.4868351959324855,1.9037006835937405,-1.6975999994575977);\ntriangles[398].b = vec3(-0.488132193002798,2.0044086914062405,-1.5821000000834464);\ntriangles[398].c = vec3(0.7472651458643895,2.0048969726562405,-1.5819999983906745);\ntriangles[398].n = vec3(-0.0002447042874503321,0.7537205932064932,-0.6571949539491794);\ntriangles[399].a = vec3(0.7472651458643895,2.0048969726562405,-1.5819999983906745);\ntriangles[399].b = vec3(0.7476618743800145,1.9545124511718655,-1.6398000007867812);\ntriangles[399].c = vec3(-0.4868351959324855,1.9037006835937405,-1.6975999994575977);\ntriangles[399].n = vec3(-0.0002608021281302453,0.7538055644782293,-0.6570974835927377);\ntriangles[400].a = vec3(0.7472651458643895,2.0048969726562405,-1.5819999983906745);\ntriangles[400].b = vec3(1.145656869497202,2.0048969726562405,-1.4383000022172927);\ntriangles[400].c = vec3(0.7476618743800145,1.9545124511718655,-1.6398000007867812);\ntriangles[400].n = vec3(0.23031860664749287,0.7343230866975231,-0.6385318659041064);\ntriangles[401].a = vec3(1.1457636810206395,1.8809040527343655,-1.6147000005841254);\ntriangles[401].b = vec3(0.7476618743800145,1.9545124511718655,-1.6398000007867812);\ntriangles[401].c = vec3(1.145656869497202,2.0048969726562405,-1.4383000022172927);\ntriangles[401].n = vec3(0.1843168177356961,0.8041484700718744,-0.5651305590576838);\ntriangles[402].a = vec3(1.1457636810206395,1.8809040527343655,-1.6147000005841254);\ntriangles[402].b = vec3(1.145962045278452,1.6664875488281155,-1.6977000011503696);\ntriangles[402].c = vec3(0.7476618743800145,1.9545124511718655,-1.6398000007867812);\ntriangles[402].n = vec3(0.12458294326784043,0.3582821412886313,-0.9252637448210944);\ntriangles[403].a = vec3(0.7480586028956395,1.9041889648437405,-1.697500001490116);\ntriangles[403].b = vec3(0.7476618743800145,1.9545124511718655,-1.6398000007867812);\ntriangles[403].c = vec3(1.145962045278452,1.6664875488281155,-1.6977000011503696);\ntriangles[403].n = vec3(0.41096950053648634,0.6884506784014655,-0.5976116908472866);\ntriangles[404].a = vec3(0.7480586028956395,1.9041889648437405,-1.697500001490116);\ntriangles[404].b = vec3(-0.4868351959324855,1.9037006835937405,-1.6975999994575977);\ntriangles[404].c = vec3(0.7476618743800145,1.9545124511718655,-1.6398000007867812);\ntriangles[404].n = vec3(-0.000244764991978737,0.7536365018753985,-0.6572913837341179);\ntriangles[405].a = vec3(-4.0062443756199855,1.4870136718749905,-1.1997999882698058);\ntriangles[405].b = vec3(-3.998843862924673,1.3862141113281155,-1.0065999960899352);\ntriangles[405].c = vec3(-3.502841665659048,1.9369038085937405,-1.1217000222206115);\ntriangles[405].n = vec3(-0.6501692600057257,0.6631203965342601,0.3708790544690446);\ntriangles[406].a = vec3(-3.4954411529637355,1.8361958007812405,-1.0063000059127807);\ntriangles[406].b = vec3(-3.502841665659048,1.9369038085937405,-1.1217000222206115);\ntriangles[406].c = vec3(-3.998843862924673,1.3862141113281155,-1.0065999960899352);\ntriangles[406].n = vec3(-0.5478984405272886,0.612564150982517,0.5697126115848526);\ntriangles[407].a = vec3(-3.4954411529637355,1.8361958007812405,-1.0063000059127807);\ntriangles[407].b = vec3(-1.7956425689793605,1.8368061523437405,-1.0063000059127807);\ntriangles[407].c = vec3(-3.502841665659048,1.9369038085937405,-1.1217000222206115);\ntriangles[407].n = vec3(-0.0002705367585655644,0.7534313457671686,0.6575265272407917);\ntriangles[408].a = vec3(-1.796939566049673,1.9376057128906155,-1.1217000222206115);\ntriangles[408].b = vec3(-3.502841665659048,1.9369038085937405,-1.1217000222206115);\ntriangles[408].c = vec3(-1.7956425689793605,1.8368061523437405,-1.0063000059127807);\ntriangles[408].n = vec3(-0.00030988512998122433,0.7531421252530635,0.6578577681691579);\ntriangles[409].a = vec3(-1.7956425689793605,1.8368061523437405,-1.0063000059127807);\ntriangles[409].b = vec3(-1.5127446197606105,2.0482929687499905,-1.0061999893188476);\ntriangles[409].c = vec3(-1.796939566049673,1.9376057128906155,-1.1217000222206115);\ntriangles[409].n = vec3(-0.48921562940266905,0.6541325085186119,0.5768697680129361);\ntriangles[410].a = vec3(-1.514041616830923,2.1490009765624905,-1.1214999890327453);\ntriangles[410].b = vec3(-1.796939566049673,1.9376057128906155,-1.1217000222206115);\ntriangles[410].c = vec3(-1.5127446197606105,2.0482929687499905,-1.0061999893188476);\ntriangles[410].n = vec3(-0.489215115230726,0.6541421952174912,0.5768592197978889);\ntriangles[411].a = vec3(-1.5127446197606105,2.0482929687499905,-1.0061999893188476);\ntriangles[411].b = vec3(-0.7932316803074855,2.0485065917968655,-1.0060999727249145);\ntriangles[411].c = vec3(-1.514041616830923,2.1490009765624905,-1.1214999890327453);\ntriangles[411].n = vec3(-0.0003150555565585514,0.753155655084625,0.6578422758944926);\ntriangles[412].a = vec3(-0.794437124643423,2.1493061523437405,-1.1214999890327453);\ntriangles[412].b = vec3(-1.514041616830923,2.1490009765624905,-1.1214999890327453);\ntriangles[412].c = vec3(-0.7932316803074855,2.0485065917968655,-1.0060999727249145);\ntriangles[412].n = vec3(-0.0003193987258563267,0.7531421955692182,0.6578576831181888);\ntriangles[413].a = vec3(-0.7932316803074855,2.0485065917968655,-1.0060999727249145);\ntriangles[413].b = vec3(-0.486942007455923,1.9033039550781155,-1.0061999893188476);\ntriangles[413].c = vec3(-0.794437124643423,2.1493061523437405,-1.1214999890327453);\ntriangles[413].n = vec3(0.3371638669131231,0.7107864500950568,0.617335524013852);\ntriangles[414].a = vec3(-0.488132193002798,2.0041035156249905,-1.1216000056266784);\ntriangles[414].b = vec3(-0.794437124643423,2.1493061523437405,-1.1214999890327453);\ntriangles[414].c = vec3(-0.486942007455923,1.9033039550781155,-1.0061999893188476);\ntriangles[414].n = vec3(0.337139678037122,0.7107708334418456,0.6173667142156354);\ntriangles[415].a = vec3(-0.488132193002798,2.0041035156249905,-1.1216000056266784);\ntriangles[415].b = vec3(-0.486942007455923,1.9033039550781155,-1.0061999893188476);\ntriangles[415].c = vec3(0.7480586028956395,1.9037922363281155,-1.0061999893188476);\ntriangles[415].n = vec3(-0.00029776930977779844,0.7531423320464272,0.6578575370193057);\ntriangles[416].a = vec3(0.7480586028956395,1.9037922363281155,-1.0061999893188476);\ntriangles[416].b = vec3(0.7476618743800145,1.9542072753906155,-1.0639000272750854);\ntriangles[416].c = vec3(-0.488132193002798,2.0041035156249905,-1.1216000056266784);\ntriangles[416].n = vec3(-0.00031620536296669756,0.7530442645981842,0.6579697831739302);\ntriangles[417].a = vec3(0.7480586028956395,1.9037922363281155,-1.0061999893188476);\ntriangles[417].b = vec3(1.145962045278452,1.6659992675781155,-1.0064000225067138);\ntriangles[417].c = vec3(0.7476618743800145,1.9542072753906155,-1.0639000272750854);\ntriangles[417].n = vec3(0.41133351163926735,0.6877889479279593,0.5981229851047856);\ntriangles[418].a = vec3(1.1457636810206395,1.8805073242187405,-1.089099977016449);\ntriangles[418].b = vec3(0.7476618743800145,1.9542072753906155,-1.0639000272750854);\ntriangles[418].c = vec3(1.145962045278452,1.6659992675781155,-1.0064000225067138);\ntriangles[418].n = vec3(0.1246935496364321,0.3570177371568584,0.9257374649621042);\ntriangles[419].a = vec3(1.1457636810206395,1.8805073242187405,-1.089099977016449);\ntriangles[419].b = vec3(1.145656869497202,2.0048054199218655,-1.2653000092506408);\ntriangles[419].c = vec3(0.7476618743800145,1.9542072753906155,-1.0639000272750854);\ntriangles[419].n = vec3(0.18454450843680884,0.8031567564850721,0.56646495824384);\ntriangles[420].a = vec3(0.7472651458643895,2.0045917968749905,-1.1216000056266784);\ntriangles[420].b = vec3(0.7476618743800145,1.9542072753906155,-1.0639000272750854);\ntriangles[420].c = vec3(1.145656869497202,2.0048054199218655,-1.2653000092506408);\ntriangles[420].n = vec3(0.23016106635680134,0.7338032594474443,0.6391859353566902);\ntriangles[421].a = vec3(0.7472651458643895,2.0045917968749905,-1.1216000056266784);\ntriangles[421].b = vec3(-0.488132193002798,2.0041035156249905,-1.1216000056266784);\ntriangles[421].c = vec3(0.7476618743800145,1.9542072753906155,-1.0639000272750854);\ntriangles[421].n = vec3(-0.000297712824281462,0.7532413560093753,0.6577441531205216);\ntriangles[422].a = vec3(1.145656869497202,2.0048969726562405,-1.4383000022172927);\ntriangles[422].b = vec3(0.7472651458643895,2.0048969726562405,-1.5819999983906745);\ntriangles[422].c = vec3(1.145656869497202,2.0048054199218655,-1.2653000092506408);\ntriangles[422].n = vec3(-0.00019088491746617502,0.9999998417517045,0.0005292064948498805);\ntriangles[423].a = vec3(0.7472651458643895,2.0045917968749905,-1.1216000056266784);\ntriangles[423].b = vec3(1.145656869497202,2.0048054199218655,-1.2653000092506408);\ntriangles[423].c = vec3(0.7472651458643895,2.0048969726562405,-1.5819999983906745);\ntriangles[423].n = vec3(-0.0002971235889138488,0.999999736174316,0.0006628490563274741);\ntriangles[424].a = vec3(0.7472651458643895,2.0045917968749905,-1.1216000056266784);\ntriangles[424].b = vec3(0.7472651458643895,2.0048969726562405,-1.5819999983906745);\ntriangles[424].c = vec3(-0.488132193002798,2.0041035156249905,-1.1216000056266784);\ntriangles[424].n = vec3(-0.0003952421534606593,0.9999997022073549,0.0006628490338125001);\ntriangles[425].a = vec3(-0.488132193002798,2.0044086914062405,-1.5821000000834464);\ntriangles[425].b = vec3(-0.488132193002798,2.0041035156249905,-1.1216000056266784);\ntriangles[425].c = vec3(0.7472651458643895,2.0048969726562405,-1.5819999983906745);\ntriangles[425].n = vec3(-0.0003952957974705498,0.9999997022815537,0.0006627050902650784);\ntriangles[426].a = vec3(-0.488132193002798,2.0044086914062405,-1.5821000000834464);\ntriangles[426].b = vec3(-0.794437124643423,2.1496113281249905,-1.5819999983906745);\ntriangles[426].c = vec3(-0.488132193002798,2.0041035156249905,-1.1216000056266784);\ntriangles[426].n = vec3(0.4283534377139337,0.9036110744141403,0.0005988278369162405);\ntriangles[427].a = vec3(-0.794437124643423,2.1493061523437405,-1.1214999890327453);\ntriangles[427].b = vec3(-0.488132193002798,2.0041035156249905,-1.1216000056266784);\ntriangles[427].c = vec3(-0.794437124643423,2.1496113281249905,-1.5819999983906745);\ntriangles[427].n = vec3(0.42835343773772006,0.9036110744028775,0.0005988278175315129);\ntriangles[428].a = vec3(-0.794437124643423,2.1496113281249905,-1.5819999983906745);\ntriangles[428].b = vec3(-1.514041616830923,2.1493977050781155,-1.5819999983906745);\ntriangles[428].c = vec3(-0.794437124643423,2.1493061523437405,-1.1214999890327453);\ntriangles[428].n = vec3(-0.000296861668975091,0.9999997363475209,0.0006627050913965285);\ntriangles[429].a = vec3(-1.514041616830923,2.1490009765624905,-1.1214999890327453);\ntriangles[429].b = vec3(-0.794437124643423,2.1493061523437405,-1.1214999890327453);\ntriangles[429].c = vec3(-1.514041616830923,2.1493977050781155,-1.5819999983906745);\ntriangles[429].n = vec3(-0.00042408801483005763,0.9999995389692758,0.0008615164487708039);\ntriangles[430].a = vec3(-1.514041616830923,2.1493977050781155,-1.5819999983906745);\ntriangles[430].b = vec3(-1.796939566049673,1.9380024414062405,-1.5821000000834464);\ntriangles[430].c = vec3(-1.514041616830923,2.1490009765624905,-1.1214999890327453);\ntriangles[430].n = vec3(-0.5985888075511404,0.8010561548382455,0.0006901233719503184);\ntriangles[431].a = vec3(-1.796939566049673,1.9376057128906155,-1.1217000222206115);\ntriangles[431].b = vec3(-1.514041616830923,2.1490009765624905,-1.1214999890327453);\ntriangles[431].c = vec3(-1.796939566049673,1.9380024414062405,-1.5821000000834464);\ntriangles[431].n = vec3(-0.5985889641457199,0.8010560376938951,0.0006902732146990338);\ntriangles[432].a = vec3(-1.796939566049673,1.9380024414062405,-1.5821000000834464);\ntriangles[432].b = vec3(-3.502841665659048,1.9372089843749905,-1.5822000017762183);\ntriangles[432].c = vec3(-1.796939566049673,1.9376057128906155,-1.1217000222206115);\ntriangles[432].n = vec3(-0.00046517489064618083,0.9999995205394853,0.000861703615301948);\ntriangles[433].a = vec3(-3.502841665659048,1.9369038085937405,-1.1217000222206115);\ntriangles[433].b = vec3(-1.796939566049673,1.9376057128906155,-1.1217000222206115);\ntriangles[433].c = vec3(-3.502841665659048,1.9372089843749905,-1.5822000017762183);\ntriangles[433].n = vec3(-0.00041145625149903247,0.9999996957628007,0.0006627051073893132);\ntriangles[434].a = vec3(-3.502841665659048,1.9369038085937405,-1.1217000222206115);\ntriangles[434].b = vec3(-3.502841665659048,1.9372089843749905,-1.5822000017762183);\ntriangles[434].c = vec3(-4.0062443756199855,1.4870136718749905,-1.1997999882698058);\ntriangles[434].n = vec3(-0.6664072067816896,0.7455878154916908,0.000494105003658707);\ntriangles[435].a = vec3(-4.0062443756199855,1.4871967773437405,-1.5046999937295913);\ntriangles[435].b = vec3(-4.0062443756199855,1.4870136718749905,-1.1997999882698058);\ntriangles[435].c = vec3(-3.502841665659048,1.9372089843749905,-1.5822000017762183);\ntriangles[435].n = vec3(-0.6664267923252694,0.7455703387299162,0.0004477468150693212);\ntriangles[436].a = vec3(1.146358773794077,0.6118000488281155,-1.5881999990344047);\ntriangles[436].b = vec3(-3.494937612924673,0.6099995117187405,-1.5881999990344047);\ntriangles[436].c = vec3(1.146267221059702,0.7220905761718655,-1.6983000001311301);\ntriangles[436].n = vec3(0.00027407657607320877,-0.7064950872655937,-0.7077178933385898);\ntriangles[437].a = vec3(-3.494937612924673,0.7202900390624905,-1.698400001823902);\ntriangles[437].b = vec3(1.146267221059702,0.7220905761718655,-1.6983000001311301);\ntriangles[437].c = vec3(-3.494937612924673,0.6099995117187405,-1.5881999990344047);\ntriangles[437].n = vec3(0.00028944855304627537,-0.706816382368716,-0.7073970015731874);\ntriangles[438].a = vec3(-3.494937612924673,0.7202900390624905,-1.698400001823902);\ntriangles[438].b = vec3(-3.494937612924673,0.6099995117187405,-1.5881999990344047);\ntriangles[438].c = vec3(-3.938632681284048,0.5867145996093655,-1.699700001478195);\ntriangles[438].n = vec3(0.2100671561246593,-0.6910451884405218,-0.6916128522886933);\ntriangles[439].a = vec3(-3.8195378326512355,0.47910961914061545,-1.570800002515316);\ntriangles[439].b = vec3(-3.938632681284048,0.5867145996093655,-1.699700001478195);\ntriangles[439].c = vec3(-3.494937612924673,0.6099995117187405,-1.5881999990344047);\ntriangles[439].n = vec3(0.2186649538218192,-0.640178547641962,-0.7364489562142987);\ntriangles[440].a = vec3(-3.8195378326512355,0.47880444335936545,-1.1350000238418578);\ntriangles[440].b = vec3(-3.494937612924673,0.6096943359374905,-1.1174000239372253);\ntriangles[440].c = vec3(-3.938632681284048,0.5861958007812405,-1.005899999141693);\ntriangles[440].n = vec3(0.2187632025403716,-0.6414005134552616,0.7353557251790505);\ntriangles[441].a = vec3(-3.494937612924673,0.7198017578124905,-1.0070000028610229);\ntriangles[441].b = vec3(-3.938632681284048,0.5861958007812405,-1.005899999141693);\ntriangles[441].c = vec3(-3.494937612924673,0.6096943359374905,-1.1174000239372253);\ntriangles[441].n = vec3(0.21015733143313556,-0.6922320968593694,0.6903974363528473);\ntriangles[442].a = vec3(-3.494937612924673,0.6096943359374905,-1.1174000239372253);\ntriangles[442].b = vec3(1.146358773794077,0.6114948730468655,-1.1173000073432922);\ntriangles[442].c = vec3(-3.494937612924673,0.7198017578124905,-1.0070000028610229);\ntriangles[442].n = vec3(0.0002594602129348421,-0.7080444192479902,0.7061678504804464);\ntriangles[443].a = vec3(1.146267221059702,0.7216938476562405,-1.0070000028610229);\ntriangles[443].b = vec3(-3.494937612924673,0.7198017578124905,-1.0070000028610229);\ntriangles[443].c = vec3(1.146358773794077,0.6114948730468655,-1.1173000073432922);\ntriangles[443].n = vec3(0.0002883997146847015,-0.7074305452966687,0.7067828099259791);\ntriangles[444].a = vec3(-3.8195378326512355,0.47880444335936545,-1.1350000238418578);\ntriangles[444].b = vec3(-3.8195378326512355,0.47910961914061545,-1.570800002515316);\ntriangles[444].c = vec3(-3.494937612924673,0.6096943359374905,-1.1174000239372253);\ntriangles[444].n = vec3(0.3740051980436594,-0.9274263798586148,-0.0006494448918669705);\ntriangles[445].a = vec3(-3.494937612924673,0.6099995117187405,-1.5881999990344047);\ntriangles[445].b = vec3(-3.494937612924673,0.6096943359374905,-1.1174000239372253);\ntriangles[445].c = vec3(-3.8195378326512355,0.47910961914061545,-1.570800002515316);\ntriangles[445].n = vec3(0.3739472021083587,-0.9274497984358697,-0.000601179336828553);\ntriangles[446].a = vec3(-3.998843862924673,1.3866108398437405,-1.697900000810623);\ntriangles[446].b = vec3(-3.4954411529637355,1.8367145996093655,-1.6975999994575977);\ntriangles[446].c = vec3(-3.938632681284048,0.5867145996093655,-1.699700001478195);\ntriangles[446].n = vec3(-0.0013267880082888442,0.0021504132174842458,-0.9999968076731922);\ntriangles[447].a = vec3(-3.494937612924673,0.7202900390624905,-1.698400001823902);\ntriangles[447].b = vec3(-3.938632681284048,0.5867145996093655,-1.699700001478195);\ntriangles[447].c = vec3(-3.4954411529637355,1.8367145996093655,-1.6975999994575977);\ntriangles[447].n = vec3(0.0027138334943545527,0.0007177965859783722,-0.9999960599301511);\ntriangles[448].a = vec3(-3.4954411529637355,1.8367145996093655,-1.6975999994575977);\ntriangles[448].b = vec3(-1.7956425689793605,1.8372944335937405,-1.6975999994575977);\ntriangles[448].c = vec3(-3.494937612924673,0.7202900390624905,-1.698400001823902);\ntriangles[448].n = vec3(-2.444375454502241e-7,0.0007165750970543175,-0.9999997432600023);\ntriangles[449].a = vec3(1.145656869497202,2.0048969726562405,-1.4383000022172927);\ntriangles[449].b = vec3(1.145656869497202,2.0048054199218655,-1.2653000092506408);\ntriangles[449].c = vec3(1.1457636810206395,1.8809040527343655,-1.6147000005841254);\ntriangles[449].n = vec3(0.9999996295252364,0.0008607840511131463,4.555325825995233e-7);\ntriangles[450].a = vec3(1.145656869497202,2.0048054199218655,-1.2653000092506408);\ntriangles[450].b = vec3(1.1457636810206395,1.8805073242187405,-1.089099977016449);\ntriangles[450].c = vec3(1.1457636810206395,1.8809040527343655,-1.6147000005841254);\ntriangles[450].n = vec3(0.9999996299953706,0.0008602375837226711,6.493165227782537e-7);\ntriangles[451].a = vec3(1.145962045278452,1.6659992675781155,-1.0064000225067138);\ntriangles[451].b = vec3(1.1457636810206395,1.8809040527343655,-1.6147000005841254);\ntriangles[451].c = vec3(1.1457636810206395,1.8805073242187405,-1.089099977016449);\ntriangles[451].n = vec3(0.9999995721787032,0.0009250091475601963,6.982067914687813e-7);\ntriangles[452].a = vec3(1.145962045278452,1.6659992675781155,-1.0064000225067138);\ntriangles[452].b = vec3(1.146267221059702,0.7216938476562405,-1.0070000028610229);\ntriangles[452].c = vec3(1.1457636810206395,1.8809040527343655,-1.6147000005841254);\ntriangles[452].n = vec3(0.9999999252900077,0.00032330946405906687,-0.000211874891870718);\ntriangles[453].a = vec3(1.146358773794077,0.6114948730468655,-1.1173000073432922);\ntriangles[453].b = vec3(1.1457636810206395,1.8809040527343655,-1.6147000005841254);\ntriangles[453].c = vec3(1.146267221059702,0.7216938476562405,-1.0070000028610229);\ntriangles[453].n = vec3(0.9999998034068316,0.000570639653569427,0.00025991668646003135);\ntriangles[454].a = vec3(1.146358773794077,0.6114948730468655,-1.1173000073432922);\ntriangles[454].b = vec3(1.146358773794077,0.6118000488281155,-1.5881999990344047);\ntriangles[454].c = vec3(1.1457636810206395,1.8809040527343655,-1.6147000005841254);\ntriangles[454].n = vec3(0.9999998900597314,0.0004689140994232429,3.038887856351795e-7);\ntriangles[455].a = vec3(1.146267221059702,0.7220905761718655,-1.6983000001311301);\ntriangles[455].b = vec3(1.1457636810206395,1.8809040527343655,-1.6147000005841254);\ntriangles[455].c = vec3(1.146358773794077,0.6118000488281155,-1.5881999990344047);\ntriangles[455].n = vec3(0.9999998253669133,0.00046119114940257913,-0.00036955225165926785);\ntriangles[456].a = vec3(1.146267221059702,0.7220905761718655,-1.6983000001311301);\ntriangles[456].b = vec3(1.145962045278452,1.6664875488281155,-1.6977000011503696);\ntriangles[456].c = vec3(1.1457636810206395,1.8809040527343655,-1.6147000005841254);\ntriangles[456].n = vec3(0.9999987348953419,0.000322153486746506,0.0015576985738496568);\ntriangles[457].a = vec3(14.490360543813608,1.8862141113281155,-1.3517000114917754);\ntriangles[457].b = vec3(14.490459725942515,1.6717976074218655,-1.5664000025391578);\ntriangles[457].c = vec3(14.490360543813608,1.8235004882812405,-1.5035000032186507);\ntriangles[457].n = vec3(0.9999996356759517,0.0007889326860626705,-0.0003259343200236374);\ntriangles[458].a = vec3(13.310665414419077,0.9596088867187405,-1.7988999968767165);\ntriangles[458].b = vec3(13.310665414419077,0.9597919921874905,-2.0447000002861024);\ntriangles[458].c = vec3(13.31055860289564,1.4817036132812405,-1.5813000014424323);\ntriangles[458].n = vec3(0.9999999790859472,0.00020451914868324818,1.523538407996912e-7);\ntriangles[459].a = vec3(13.310360238637827,1.9268940429687405,-1.705499999076128);\ntriangles[459].b = vec3(13.31055860289564,1.4817036132812405,-1.5813000014424323);\ntriangles[459].c = vec3(13.310665414419077,0.9597919921874905,-2.0447000002861024);\ntriangles[459].n = vec3(0.9999999034251525,0.00038797190555149976,-0.00020646424963694844);\ntriangles[460].a = vec3(13.31055860289564,1.4817036132812405,-1.5813000014424323);\ntriangles[460].b = vec3(13.310360238637827,1.9268940429687405,-1.705499999076128);\ntriangles[460].c = vec3(13.31026105650892,2.0041950683593655,-1.6050000002980231);\ntriangles[460].n = vec3(0.9999996832172894,0.0005935329116866241,0.0005303621438672041);\ntriangles[461].a = vec3(13.31026105650892,2.0041950683593655,-1.6050000002980231);\ntriangles[461].b = vec3(13.31026105650892,2.0037983398437405,-1.1005999779701232);\ntriangles[461].c = vec3(13.31055860289564,1.4817036132812405,-1.5813000014424323);\ntriangles[461].n = vec3(0.9999998378368645,0.0005694963075353371,4.4792905380867905e-7);\ntriangles[462].a = vec3(13.310459420766733,1.4814899902343655,-1.1249000167846679);\ntriangles[462].b = vec3(13.31055860289564,1.4817036132812405,-1.5813000014424323);\ntriangles[462].c = vec3(13.31026105650892,2.0037983398437405,-1.1005999779701232);\ntriangles[462].n = vec3(0.999999908023453,0.0003696653438917237,0.00021748705556013176);\ntriangles[463].a = vec3(13.310360238637827,1.9264057617187405,-1.0002000069618224);\ntriangles[463].b = vec3(13.310459420766733,1.4814899902343655,-1.1249000167846679);\ntriangles[463].c = vec3(13.31026105650892,2.0037983398437405,-1.1005999779701232);\ntriangles[463].n = vec3(0.9999996903834852,0.0004110038629140039,-0.0006710504888692233);\ntriangles[464].a = vec3(13.310360238637827,1.9264057617187405,-1.0002000069618224);\ntriangles[464].b = vec3(13.310665414419077,0.9587849121093655,-0.6622000074386596);\ntriangles[464].c = vec3(13.310459420766733,1.4814899902343655,-1.1249000167846679);\ntriangles[464].n = vec3(0.9999999543445586,0.0002640863333869574,-0.0001468648671745067);\ntriangles[465].a = vec3(13.310665414419077,0.9589985351562405,-0.9080999827384948);\ntriangles[465].b = vec3(13.310459420766733,1.4814899902343655,-1.1249000167846679);\ntriangles[465].c = vec3(13.310665414419077,0.9587849121093655,-0.6622000074386596);\ntriangles[465].n = vec3(0.9999999222263057,0.00039439480920323605,3.4262638990080463e-7);\ntriangles[466].a = vec3(13.310665414419077,0.9596088867187405,-1.7988999968767165);\ntriangles[466].b = vec3(12.94385938414564,0.9593952636718655,-1.7988999968767165);\ntriangles[466].c = vec3(13.310665414419077,0.9597919921874905,-2.0447000002861024);\ntriangles[466].n = vec3(0.0005823866941747311,-0.9999995529475971,-0.0007449364701077481);\ntriangles[467].a = vec3(12.94385938414564,0.9596088867187405,-2.0447000002861024);\ntriangles[467].b = vec3(13.310665414419077,0.9597919921874905,-2.0447000002861024);\ntriangles[467].c = vec3(12.94385938414564,0.9593952636718655,-1.7988999968767165);\ntriangles[467].n = vec3(0.0004991885674500805,-0.9999994977443739,-0.0008690925004823081);\ntriangles[468].a = vec3(9.55366163023939,1.5201862792968655,-1.465899992585182);\ntriangles[468].b = vec3(9.553768441762827,1.2851093749999905,-1.465999994277954);\ntriangles[468].c = vec3(9.55366163023939,1.5200947265624905,-1.2380999958515166);\ntriangles[468].n = vec3(-0.9999998967747005,-0.00045436830330045314,-1.8261045292779917e-7);\ntriangles[469].a = vec3(9.553768441762827,1.2849873046874905,-1.2382000124454497);\ntriangles[469].b = vec3(9.55366163023939,1.5200947265624905,-1.2380999958515166);\ntriangles[469].c = vec3(9.553768441762827,1.2851093749999905,-1.465999994277954);\ntriangles[469].n = vec3(-0.9999998968014954,-0.0004543092991873274,-2.4344900152024473e-7);\ntriangles[470].a = vec3(5.154262826528452,1.4319904785156155,-0.953500006198883);\ntriangles[470].b = vec3(5.1544611907862645,0.8591145019531155,-0.9539000129699706);\ntriangles[470].c = vec3(5.284267709340952,1.5620869140624905,-1.0833999848365783);\ntriangles[470].n = vec3(0.7069460014840208,-0.0002490573319615235,0.7072674804882523);\ntriangles[471].a = vec3(5.2845576263331395,0.8029011230468655,-1.083900008201599);\ntriangles[471].b = vec3(5.284267709340952,1.5620869140624905,-1.0833999848365783);\ntriangles[471].c = vec3(5.1544611907862645,0.8591145019531155,-0.9539000129699706);\ntriangles[471].n = vec3(0.7068021534648847,-0.00019601025377705554,0.7074112505730893);\ntriangles[472].a = vec3(5.1544611907862645,0.8591145019531155,-0.9539000129699706);\ntriangles[472].b = vec3(4.715664193715952,0.44718823242186545,-0.9542000031471252);\ntriangles[472].c = vec3(5.2845576263331395,0.8029011230468655,-1.083900008201599);\ntriangles[472].n = vec3(0.48371277452343986,-0.5157812257777115,0.7071008972544706);\ntriangles[473].a = vec3(4.767055795278452,0.31730541992186545,-1.0841999983787536);\ntriangles[473].b = vec3(5.2845576263331395,0.8029011230468655,-1.083900008201599);\ntriangles[473].c = vec3(4.715664193715952,0.44718823242186545,-0.9542000031471252);\ntriangles[473].n = vec3(0.48381641412807386,-0.5160423032721025,0.7068394574823023);\ntriangles[474].a = vec3(5.2845576263331395,0.8029011230468655,-1.083900008201599);\ntriangles[474].b = vec3(4.767055795278452,0.31730541992186545,-1.0841999983787536);\ntriangles[474].c = vec3(5.2845576263331395,0.8032978515624905,-1.6211999988555907);\ntriangles[474].n = vec3(0.684269418131687,-0.7292290953381801,-0.0005384440379236558);\ntriangles[475].a = vec3(5.2845576263331395,0.8032978515624905,-1.6211999988555907);\ntriangles[475].b = vec3(5.284267709340952,1.5625141601562405,-1.620700001567602);\ntriangles[475].c = vec3(5.2845576263331395,0.8029011230468655,-1.083900008201599);\ntriangles[475].n = vec3(0.9999999270901753,0.00038186328031920543,2.8195804021573384e-7);\ntriangles[476].a = vec3(5.284267709340952,1.5620869140624905,-1.0833999848365783);\ntriangles[476].b = vec3(5.2845576263331395,0.8029011230468655,-1.083900008201599);\ntriangles[476].c = vec3(5.284267709340952,1.5625141601562405,-1.620700001567602);\ntriangles[476].n = vec3(0.9999999270843125,0.00038187861606763304,3.036593000577354e-7);\ntriangles[477].a = vec3(4.7671626068018895,0.31761059570311545,-1.6215000002086162);\ntriangles[477].b = vec3(5.2845576263331395,0.8032978515624905,-1.6211999988555907);\ntriangles[477].c = vec3(4.767055795278452,0.31730541992186545,-1.0841999983787536);\ntriangles[477].n = vec3(0.6844131085112237,-0.7290943831793242,-0.00027805460767216933);\ntriangles[478].a = vec3(1.1468623138331395,1.5604999999999905,-1.0835000014305114);\ntriangles[478].b = vec3(1.1472590423487645,0.6348103027343655,-1.0840999817848205);\ntriangles[478].c = vec3(1.2769587493800145,1.4304951171874905,-0.9536000227928161);\ntriangles[478].n = vec3(-0.7069529743863122,-0.0007613896950969157,0.7072601447077861);\ntriangles[479].a = vec3(1.2772639251612645,0.6786030273437405,-0.9540999865531921);\ntriangles[479].b = vec3(1.2769587493800145,1.4304951171874905,-0.9536000227928161);\ntriangles[479].c = vec3(1.1472590423487645,0.6348103027343655,-1.0840999817848205);\ntriangles[479].n = vec3(-0.7069657335512853,-0.0007572188815792647,0.7072473953319719);\ntriangles[480].a = vec3(1.1472590423487645,0.6348103027343655,-1.0840999817848205);\ntriangles[480].b = vec3(1.615566537465952,0.31611523437499045,-1.0843000149726867);\ntriangles[480].c = vec3(1.2772639251612645,0.6786030273437405,-0.9540999865531921);\ntriangles[480].n = vec3(-0.43040456506990854,-0.6328633463762914,0.6436116027390938);\ntriangles[481].a = vec3(1.652462289419077,0.44599804687499045,-0.9542000031471252);\ntriangles[481].b = vec3(1.2772639251612645,0.6786030273437405,-0.9540999865531921);\ntriangles[481].c = vec3(1.615566537465952,0.31611523437499045,-1.0843000149726867);\ntriangles[481].n = vec3(-0.3728193150852307,-0.6016717627134768,0.7063970896405487);\ntriangles[482].a = vec3(-0.989444448862173,-1.3527080078125095,-1.5598000025749206);\ntriangles[482].b = vec3(-0.990237905893423,0.6402119140624905,-1.5585000029206275);\ntriangles[482].c = vec3(0.804958627309702,-0.9297038574218845,-1.5594000032544135);\ntriangles[482].n = vec3(0.0000691362082314393,0.0006523364119772624,-0.9999997848386721);\ntriangles[483].a = vec3(0.8043635345362645,0.6407917480468655,-1.5584000012278556);\ntriangles[483].b = vec3(0.804958627309702,-0.9297038574218845,-1.5594000032544135);\ntriangles[483].c = vec3(-0.990237905893423,0.6402119140624905,-1.5585000029206275);\ntriangles[483].n = vec3(0.00005551787308716521,0.0006367638706437799,-0.9999997957247486);\ntriangles[484].a = vec3(0.8043635345362645,0.6404865722656155,-1.1469999885559081);\ntriangles[484].b = vec3(-0.990237905893423,0.6398151855468655,-1.1469999885559081);\ntriangles[484].c = vec3(0.804958627309702,-0.9298869628906345,-1.1479999756813049);\ntriangles[484].n = vec3(2.3822976655226724e-7,-0.0006367827516813341,0.9999997972538148);\ntriangles[485].a = vec3(-0.989444448862173,-1.3530131835937595,-1.1483000254631042);\ntriangles[485].b = vec3(0.804958627309702,-0.9298869628906345,-1.1479999756813049);\ntriangles[485].c = vec3(-0.990237905893423,0.6398151855468655,-1.1469999885559081);\ntriangles[485].n = vec3(-0.000013384884944511761,-0.0006523628782633915,0.9999997871217374);\ntriangles[486].a = vec3(-0.989444448862173,-1.3530131835937595,-1.1483000254631042);\ntriangles[486].b = vec3(-0.989444448862173,-1.3527080078125095,-1.5598000025749206);\ntriangles[486].c = vec3(0.804958627309702,-0.9298869628906345,-1.1479999756813049);\ntriangles[486].n = vec3(0.22950898160979355,-0.9733062757088616,-0.000721821432821777);\ntriangles[487].a = vec3(0.804958627309702,-0.9297038574218845,-1.5594000032544135);\ntriangles[487].b = vec3(0.804958627309702,-0.9298869628906345,-1.1479999756813049);\ntriangles[487].c = vec3(-0.989444448862173,-1.3527080078125095,-1.5598000025749206);\ntriangles[487].n = vec3(0.22944627082491587,-0.9733212322446254,-0.0004332047363385476);\ntriangles[488].a = vec3(-0.990237905893423,0.6398151855468655,-1.1469999885559081);\ntriangles[488].b = vec3(-0.990237905893423,0.6402119140624905,-1.5585000029206275);\ntriangles[488].c = vec3(-0.989444448862173,-1.3530131835937595,-1.1483000254631042);\ntriangles[488].n = vec3(-0.9999999207358437,-0.0003981559484035249,-3.8386345779660674e-7);\ntriangles[489].a = vec3(-0.989444448862173,-1.3527080078125095,-1.5598000025749206);\ntriangles[489].b = vec3(-0.989444448862173,-1.3530131835937595,-1.1483000254631042);\ntriangles[489].c = vec3(-0.990237905893423,0.6402119140624905,-1.5585000029206275);\ntriangles[489].n = vec3(-0.9999999207431333,-0.00039813771532313337,-2.9526608767176607e-7);\ntriangles[490].a = vec3(0.804958627309702,-0.9298869628906345,-1.1479999756813049);\ntriangles[490].b = vec3(0.804958627309702,-0.9297038574218845,-1.5594000032544135);\ntriangles[490].c = vec3(0.8043635345362645,0.6404865722656155,-1.1469999885559081);\ntriangles[490].n = vec3(0.99999992819855,0.0003789496885461896,1.6866250778650193e-7);\ntriangles[491].a = vec3(0.8043635345362645,0.6407917480468655,-1.5584000012278556);\ntriangles[491].b = vec3(0.8043635345362645,0.6404865722656155,-1.1469999885559081);\ntriangles[491].c = vec3(0.804958627309702,-0.9297038574218845,-1.5594000032544135);\ntriangles[491].n = vec3(0.9999999282097134,0.0003789201622472185,2.8108228727105415e-7);\ntriangles[492].a = vec3(-0.9784428619481105,-0.08268847656250955,-1.530299994945526);\ntriangles[492].b = vec3(-1.318637564096548,-0.08290209960938455,-1.4509000068902969);\ntriangles[492].c = vec3(-0.978732778940298,0.6440876464843655,-1.5298000013828277);\ntriangles[492].n = vec3(-0.22728754063506063,0.0005792883909903811,-0.9738275197882968);\ntriangles[493].a = vec3(-1.318942739877798,0.6439045410156155,-1.4503999984264373);\ntriangles[493].b = vec3(-0.978732778940298,0.6440876464843655,-1.5298000013828277);\ntriangles[493].c = vec3(-1.318637564096548,-0.08290209960938455,-1.4509000068902969);\ntriangles[493].n = vec3(-0.227277862490729,0.0005745179122955784,-0.9738297814047453);\ntriangles[494].a = vec3(-1.318637564096548,-0.08290209960938455,-1.4509000068902969);\ntriangles[494].b = vec3(-1.8682438873387355,0.14298901367186545,-1.450700003504753);\ntriangles[494].c = vec3(-1.318942739877798,0.6439045410156155,-1.4503999984264373);\ntriangles[494].n = vec3(-0.00008116484378402331,0.000687918280339499,-0.9999997600903251);\ntriangles[495].a = vec3(-1.8683354400731105,0.48069653320311545,-1.4505000001192092);\ntriangles[495].b = vec3(-1.318942739877798,0.6439045410156155,-1.4503999984264373);\ntriangles[495].c = vec3(-1.8682438873387355,0.14298901367186545,-1.450700003504753);\ntriangles[495].n = vec3(0.000006085558954799925,0.0005922400184984748,-0.999999824607348);\ntriangles[496].a = vec3(-1.8683354400731105,0.48069653320311545,-1.4505000001192092);\ntriangles[496].b = vec3(-1.987735464487173,0.6435993652343655,-1.4505000001192092);\ntriangles[496].c = vec3(-1.318942739877798,0.6439045410156155,-1.4503999984264373);\ntriangles[496].n = vec3(0.0001494756936695151,0.00010955857090333043,-0.9999999828269681);\ntriangles[497].a = vec3(-2.954440786752798,0.6331013183593655,-1.4505000001192092);\ntriangles[497].b = vec3(-2.502536489877798,0.6334064941406155,-1.4503999984264373);\ntriangles[497].c = vec3(-2.778537466440298,0.41929516601561545,-1.4506000018119811);\ntriangles[497].n = vec3(0.00022085092474897033,0.0006494204150851654,-0.9999997647389691);\ntriangles[498].a = vec3(-2.6783329986668605,0.41950878906249045,-1.4506000018119811);\ntriangles[498].b = vec3(-2.778537466440298,0.41929516601561545,-1.4506000018119811);\ntriangles[498].c = vec3(-2.502536489877798,0.6334064941406155,-1.4503999984264373);\ntriangles[498].n = vec3(-0.000001996887768375501,0.0009366829982087082,-0.9999995613103906);\ntriangles[499].a = vec3(-2.778537466440298,0.41929516601561545,-1.4506000018119811);\ntriangles[499].b = vec3(-2.6783329986668605,0.41950878906249045,-1.4506000018119811);\ntriangles[499].c = vec3(-2.7784306549168605,0.09361157226561545,-1.450800005197525);\ntriangles[499].n = vec3(-0.0000013091882518346205,0.0006141028035569967,-0.9999998114379988);\ntriangles[500].a = vec3(-2.6782414459324855,0.14338574218749045,-1.450800005197525);\ntriangles[500].b = vec3(-2.7784306549168605,0.09361157226561545,-1.450800005197525);\ntriangles[500].c = vec3(-2.6783329986668605,0.41950878906249045,-1.4506000018119811);\ntriangles[500].n = vec3(-0.00035978751979154485,0.0007242074969194616,-0.9999996730381676);\ntriangles[501].a = vec3(-2.7784306549168605,0.09361157226561545,-1.450800005197525);\ntriangles[501].b = vec3(-2.6782414459324855,0.14338574218749045,-1.450800005197525);\ntriangles[501].c = vec3(-2.596133901987173,-0.08339038085938455,-1.4509000068902969);\ntriangles[501].n = vec3(-0.00018567668360333807,0.0003737440541200238,-0.9999999129197719);\ntriangles[502].a = vec3(-2.536533071909048,0.01270947265624045,-1.450800005197525);\ntriangles[502].b = vec3(-2.596133901987173,-0.08339038085938455,-1.4509000068902969);\ntriangles[502].c = vec3(-2.6782414459324855,0.14338574218749045,-1.450800005197525);\ntriangles[502].n = vec3(0.0006104594994357197,0.0006619964235473527,-0.9999995945498853);\ntriangles[503].a = vec3(-2.536533071909048,0.01270947265624045,-1.450800005197525);\ntriangles[503].b = vec3(-1.998141958627798,0.01289257812499045,-1.450800005197525);\ntriangles[503].c = vec3(-2.596133901987173,-0.08339038085938455,-1.4509000068902969);\ntriangles[503].n = vec3(-3.539805808436355e-7,0.0010408209012072363,-0.9999994583457166);\ntriangles[504].a = vec3(-1.318637564096548,-0.08290209960938455,-1.4509000068902969);\ntriangles[504].b = vec3(-2.596133901987173,-0.08339038085938455,-1.4509000068902969);\ntriangles[504].c = vec3(-1.998141958627798,0.01289257812499045,-1.450800005197525);\ntriangles[504].n = vec3(-3.9792411050111675e-7,0.001041093824355453,-0.9999994580615984);\ntriangles[505].a = vec3(-1.318637564096548,-0.08290209960938455,-1.4509000068902969);\ntriangles[505].b = vec3(-1.998141958627798,0.01289257812499045,-1.450800005197525);\ntriangles[505].c = vec3(-1.8682438873387355,0.14298901367186545,-1.450700003504753);\ntriangles[505].n = vec3(-0.0000340150217089647,0.0008026364886797298,-0.9999996773087706);\ntriangles[506].a = vec3(-2.2617375396824855,2.2060993652343655,-1.5378000026941299);\ntriangles[506].b = vec3(-2.386844351205923,2.3310993652343655,-1.537700001001358);\ntriangles[506].c = vec3(-2.261630728159048,1.9113911132812405,-1.537999998629093);\ntriangles[506].n = vec3(0.00012133034690657988,-0.000678579329355551,0.9999997624044922);\ntriangles[507].a = vec3(-3.474643423471548,2.2056110839843655,-1.5378000026941299);\ntriangles[507].b = vec3(-2.261630728159048,1.9113911132812405,-1.537999998629093);\ntriangles[507].c = vec3(-2.386844351205923,2.3310993652343655,-1.537700001001358);\ntriangles[507].n = vec3(-0.000009158612426679644,-0.0007175087269382558,0.9999997425486403);\ntriangles[508].a = vec3(-3.349734976205923,2.3307026367187405,-1.537700001001358);\ntriangles[508].b = vec3(-3.474643423471548,2.2056110839843655,-1.5378000026941299);\ntriangles[508].c = vec3(-2.386844351205923,2.3310993652343655,-1.537700001001358);\ntriangles[508].n = vec3(3.295144016266594e-7,-0.0007997568000095661,0.9999996801944251);\ntriangles[509].a = vec3(-3.474643423471548,2.2056110839843655,-1.5378000026941299);\ntriangles[509].b = vec3(-3.4745366119481105,1.9109943847656155,-1.537999998629093);\ntriangles[509].c = vec3(-2.261630728159048,1.9113911132812405,-1.537999998629093);\ntriangles[509].n = vec3(2.2203936257659596e-7,-0.0006788341112250399,0.9999997695920735);\ntriangles[510].a = vec3(-3.474643423471548,2.2056110839843655,-1.5378000026941299);\ntriangles[510].b = vec3(-3.474643423471548,2.2056110839843655,-1.594299997985363);\ntriangles[510].c = vec3(-3.4745366119481105,1.9109943847656155,-1.537999998629093);\ntriangles[510].n = vec3(-0.9999999342809222,-0.0003625439993767586,0);\ntriangles[511].a = vec3(-3.4745366119481105,1.9110859374999905,-1.5946000030636787);\ntriangles[511].b = vec3(-3.4745366119481105,1.9109943847656155,-1.537999998629093);\ntriangles[511].c = vec3(-3.474643423471548,2.2056110839843655,-1.594299997985363);\ntriangles[511].n = vec3(-0.999999934240103,-0.00036265609813768477,-5.866105092031605e-7);\ntriangles[512].a = vec3(-2.386844351205923,2.3310993652343655,-1.537700001001358);\ntriangles[512].b = vec3(-2.386844351205923,2.3310993652343655,-1.594299997985363);\ntriangles[512].c = vec3(-3.349734976205923,2.3307026367187405,-1.537700001001358);\ntriangles[512].n = vec3(-0.00041201822060618544,0.9999999151204895,0);\ntriangles[513].a = vec3(-3.349734976205923,2.3307026367187405,-1.594299997985363);\ntriangles[513].b = vec3(-3.349734976205923,2.3307026367187405,-1.537700001001358);\ntriangles[513].c = vec3(-2.386844351205923,2.3310993652343655,-1.594299997985363);\ntriangles[513].n = vec3(-0.00041201822060618544,0.9999999151204895,0);\ntriangles[514].a = vec3(-2.261630728159048,1.9113911132812405,-1.537999998629093);\ntriangles[514].b = vec3(-2.261630728159048,1.9115131835937405,-1.5945000013709067);\ntriangles[514].c = vec3(-2.2617375396824855,2.2060993652343655,-1.5378000026941299);\ntriangles[514].n = vec3(0.9999999343216339,0.0003624308417175252,7.830450258607574e-7);\ntriangles[515].a = vec3(-2.2617375396824855,2.2060993652343655,-1.594299997985363);\ntriangles[515].b = vec3(-2.2617375396824855,2.2060993652343655,-1.5378000026941299);\ntriangles[515].c = vec3(-2.261630728159048,1.9115131835937405,-1.5945000013709067);\ntriangles[515].n = vec3(0.9999999342673053,0.00036258155702222815,0);\ntriangles[516].a = vec3(-3.349734976205923,2.3307026367187405,-1.537700001001358);\ntriangles[516].b = vec3(-3.349734976205923,2.3307026367187405,-1.594299997985363);\ntriangles[516].c = vec3(-3.474643423471548,2.2056110839843655,-1.5378000026941299);\ntriangles[516].n = vec3(-0.7076244918613958,0.7065886911902154,0);\ntriangles[517].a = vec3(-3.474643423471548,2.2056110839843655,-1.594299997985363);\ntriangles[517].b = vec3(-3.474643423471548,2.2056110839843655,-1.5378000026941299);\ntriangles[517].c = vec3(-3.349734976205923,2.3307026367187405,-1.594299997985363);\ntriangles[517].n = vec3(-0.7076244918613958,0.7065886911902154,0);\ntriangles[518].a = vec3(-2.2617375396824855,2.2060993652343655,-1.5378000026941299);\ntriangles[518].b = vec3(-2.2617375396824855,2.2060993652343655,-1.594299997985363);\ntriangles[518].c = vec3(-2.386844351205923,2.3310993652343655,-1.537700001001358);\ntriangles[518].n = vec3(0.7068047371413183,0.7074086962672935,0);\ntriangles[519].a = vec3(-2.386844351205923,2.3310993652343655,-1.594299997985363);\ntriangles[519].b = vec3(-2.386844351205923,2.3310993652343655,-1.537700001001358);\ntriangles[519].c = vec3(-2.2617375396824855,2.2060993652343655,-1.594299997985363);\ntriangles[519].n = vec3(0.7068047371413183,0.7074086962672935,0);\ntriangles[520].a = vec3(-2.2617375396824855,2.2057941894531155,-1.1108000016212463);\ntriangles[520].b = vec3(-2.386844351205923,2.3307941894531155,-1.1106999850273132);\ntriangles[520].c = vec3(-2.261630728159048,1.9110859374999905,-1.1109999752044677);\ntriangles[520].n = vec3(0.00012152530384630193,-0.000678503415110148,0.9999997624323299);\ntriangles[521].a = vec3(-3.474643423471548,2.2053059082031155,-1.1108000016212463);\ntriangles[521].b = vec3(-2.261630728159048,1.9110859374999905,-1.1109999752044677);\ntriangles[521].c = vec3(-2.386844351205923,2.3307941894531155,-1.1106999850273132);\ntriangles[521].n = vec3(-0.00000917383482589166,-0.0007174955165138847,0.9999997425579792);\ntriangles[522].a = vec3(-3.349734976205923,2.3303974609374905,-1.1106999850273132);\ntriangles[522].b = vec3(-3.474643423471548,2.2053059082031155,-1.1108000016212463);\ntriangles[522].c = vec3(-2.386844351205923,2.3307941894531155,-1.1106999850273132);\ntriangles[522].n = vec3(3.2956350223622853e-7,-0.0007998759709659602,0.9999996800991101);\ntriangles[523].a = vec3(-3.474643423471548,2.2053059082031155,-1.1108000016212463);\ntriangles[523].b = vec3(-3.4745366119481105,1.9106892089843655,-1.1109999752044677);\ntriangles[523].c = vec3(-2.261630728159048,1.9110859374999905,-1.1109999752044677);\ntriangles[523].n = vec3(2.220145472511546e-7,-0.0006787582440941165,0.999999769643572);\ntriangles[524].a = vec3(-3.4745366119481105,1.9108112792968655,-1.1676000094413757);\ntriangles[524].b = vec3(-3.474643423471548,2.2053974609374905,-1.1674000060558318);\ntriangles[524].c = vec3(-2.261630728159048,1.9112080078124905,-1.1674999928474425);\ntriangles[524].n = vec3(0.00008223820927213685,0.0006789596227582561,-0.9999997661253265);\ntriangles[525].a = vec3(-3.474643423471548,2.2053974609374905,-1.1674000060558318);\ntriangles[525].b = vec3(-2.386844351205923,2.3307941894531155,-1.1672999894618987);\ntriangles[525].c = vec3(-2.261630728159048,1.9112080078124905,-1.1674999928474425);\ntriangles[525].n = vec3(0.00003576540696525557,0.00048734130626434735,-0.9999998806096364);\ntriangles[526].a = vec3(-3.474643423471548,2.2053974609374905,-1.1674000060558318);\ntriangles[526].b = vec3(-3.349734976205923,2.3304890136718655,-1.1672999894618987);\ntriangles[526].c = vec3(-2.386844351205923,2.3307941894531155,-1.1672999894618987);\ntriangles[526].n = vec3(-2.534863099587724e-7,0.0007998000051819187,-0.9999996801598927);\ntriangles[527].a = vec3(-2.2617375396824855,2.2058857421874905,-1.1672999894618987);\ntriangles[527].b = vec3(-2.261630728159048,1.9112080078124905,-1.1674999928474425);\ntriangles[527].c = vec3(-2.386844351205923,2.3307941894531155,-1.1672999894618987);\ntriangles[527].n = vec3(0.0006778878909276792,0.0006789644292347963,-0.9999995397375497);\ntriangles[528].a = vec3(-3.4745366119481105,1.9106892089843655,-1.1109999752044677);\ntriangles[528].b = vec3(-3.474643423471548,2.2053059082031155,-1.1108000016212463);\ntriangles[528].c = vec3(-3.4745366119481105,1.9108112792968655,-1.1676000094413757);\ntriangles[528].n = vec3(-0.9999999342808089,-0.0003625434686527301,-7.81904023733156e-7);\ntriangles[529].a = vec3(-3.474643423471548,2.2053974609374905,-1.1674000060558318);\ntriangles[529].b = vec3(-3.4745366119481105,1.9108112792968655,-1.1676000094413757);\ntriangles[529].c = vec3(-3.474643423471548,2.2053059082031155,-1.1108000016212463);\ntriangles[529].n = vec3(-0.9999999342672775,-0.00036258115883706454,-5.864892919355566e-7);\ntriangles[530].a = vec3(-3.349734976205923,2.3303974609374905,-1.1106999850273132);\ntriangles[530].b = vec3(-2.386844351205923,2.3307941894531155,-1.1106999850273132);\ntriangles[530].c = vec3(-3.349734976205923,2.3304890136718655,-1.1672999894618987);\ntriangles[530].n = vec3(-0.00041201768159818716,0.9999986069066155,0.0016175370964732285);\ntriangles[531].a = vec3(-2.386844351205923,2.3307941894531155,-1.1672999894618987);\ntriangles[531].b = vec3(-3.349734976205923,2.3304890136718655,-1.1672999894618987);\ntriangles[531].c = vec3(-2.386844351205923,2.3307941894531155,-1.1106999850273132);\ntriangles[531].n = vec3(-0.0003169371037574274,0.9999999497754349,0);\ntriangles[532].a = vec3(-2.2617375396824855,2.2057941894531155,-1.1108000016212463);\ntriangles[532].b = vec3(-2.261630728159048,1.9110859374999905,-1.1109999752044677);\ntriangles[532].c = vec3(-2.2617375396824855,2.2058857421874905,-1.1672999894618987);\ntriangles[532].n = vec3(0.9999999343217199,0.000362430974610029,5.872841396236514e-7);\ntriangles[533].a = vec3(-2.261630728159048,1.9112080078124905,-1.1674999928474425);\ntriangles[533].b = vec3(-2.2617375396824855,2.2058857421874905,-1.1672999894618987);\ntriangles[533].c = vec3(-2.261630728159048,1.9110859374999905,-1.1109999752044677);\ntriangles[533].n = vec3(0.9999999343080296,0.00036246837590070836,7.831259132901973e-7);\ntriangles[534].a = vec3(-3.474643423471548,2.2053059082031155,-1.1108000016212463);\ntriangles[534].b = vec3(-3.349734976205923,2.3303974609374905,-1.1106999850273132);\ntriangles[534].c = vec3(-3.474643423471548,2.2053974609374905,-1.1674000060558318);\ntriangles[534].n = vec3(-0.7076244865913348,0.7065877720986306,0.0011429335254970396);\ntriangles[535].a = vec3(-3.349734976205923,2.3304890136718655,-1.1672999894618987);\ntriangles[535].b = vec3(-3.474643423471548,2.2053974609374905,-1.1674000060558318);\ntriangles[535].c = vec3(-3.349734976205923,2.3303974609374905,-1.1106999850273132);\ntriangles[535].n = vec3(-0.7076244865913348,0.7065877720986306,0.0011429335254970396);\ntriangles[536].a = vec3(-2.386844351205923,2.3307941894531155,-1.1106999850273132);\ntriangles[536].b = vec3(-2.2617375396824855,2.2057941894531155,-1.1108000016212463);\ntriangles[536].c = vec3(-2.386844351205923,2.3307941894531155,-1.1672999894618987);\ntriangles[536].n = vec3(0.7068047371413183,0.7074086962672936,0);\ntriangles[537].a = vec3(-2.2617375396824855,2.2058857421874905,-1.1672999894618987);\ntriangles[537].b = vec3(-2.386844351205923,2.3307941894531155,-1.1672999894618987);\ntriangles[537].c = vec3(-2.2617375396824855,2.2057941894531155,-1.1108000016212463);\ntriangles[537].n = vec3(0.7065450696666725,0.707667117786104,0.0011467057275006457);\ntriangles[538].a = vec3(13.263164804067515,0.9776142578124905,-0.8681000208854674);\ntriangles[538].b = vec3(13.26466016539564,-2.9254924316406345,0.5112000370025636);\ntriangles[538].c = vec3(13.013965890493296,0.9774921874999905,-0.8680000042915343);\ntriangles[538].n = vec3(-0.00021520409142273387,-0.3331924179751585,-0.9428588262783917);\ntriangles[539].a = vec3(13.01546125182142,-2.9256145019531345,0.5112000370025636);\ntriangles[539].b = vec3(13.013965890493296,0.9774921874999905,-0.8680000042915343);\ntriangles[539].c = vec3(13.26466016539564,-2.9254924316406345,0.5112000370025636);\ntriangles[539].n = vec3(0.00016320402349938084,-0.3331708137225173,-0.9428664710593555);\ntriangles[540].a = vec3(13.13856153258314,0.9709919433593655,-0.711900029182434);\ntriangles[540].b = vec3(13.140064523305796,-2.8772136230468845,0.6478999519348145);\ntriangles[540].c = vec3(13.263164804067515,0.9776142578124905,-0.8681000208854674);\ntriangles[540].n = vec3(0.75853383427989,0.21736867727486803,0.6143104104542124);\ntriangles[541].a = vec3(13.26466016539564,-2.9254924316406345,0.5112000370025636);\ntriangles[541].b = vec3(13.263164804067515,0.9776142578124905,-0.8681000208854674);\ntriangles[541].c = vec3(13.140064523305796,-2.8772136230468845,0.6478999519348145);\ntriangles[541].n = vec3(0.7583990682416569,0.2174298915986159,0.6144551208425243);\ntriangles[542].a = vec3(13.140064523305796,-2.8772136230468845,0.6478999519348145);\ntriangles[542].b = vec3(13.13856153258314,0.9709919433593655,-0.711900029182434);\ntriangles[542].c = vec3(13.01546125182142,-2.9256145019531345,0.5112000370025636);\ntriangles[542].n = vec3(-0.7584696459662006,0.21686684247844054,0.6145669766439927);\ntriangles[543].a = vec3(13.013965890493296,0.9774921874999905,-0.8680000042915343);\ntriangles[543].b = vec3(13.01546125182142,-2.9256145019531345,0.5112000370025636);\ntriangles[543].c = vec3(13.13856153258314,0.9709919433593655,-0.711900029182434);\ntriangles[543].n = vec3(-0.7585442233895113,0.21684295116954325,0.6144833567237492);\ntriangles[544].a = vec3(12.49915723570814,-2.8785869140625095,0.8636001014709473);\ntriangles[544].b = vec3(12.499264047231577,-3.0662089843750095,0.3326999807357789);\ntriangles[544].c = vec3(13.787159249868296,-2.8780986328125095,0.8636001014709473);\ntriangles[544].n = vec3(0.00035743545778547627,-0.9428533034187795,0.33320792378361674);\ntriangles[545].a = vec3(13.787258431997202,-3.0658122558593845,0.3326999807357789);\ntriangles[545].b = vec3(13.787159249868296,-2.8780986328125095,0.8636001014709473);\ntriangles[545].c = vec3(12.499264047231577,-3.0662089843750095,0.3326999807357789);\ntriangles[545].n = vec3(0.00029040230108980336,-0.9428022398073193,0.3333524445400179);\ntriangles[546].a = vec3(13.787258431997202,-2.9829875488281345,0.3035000228881837);\ntriangles[546].b = vec3(12.499264047231577,-2.9835063476562595,0.3035000228881837);\ntriangles[546].c = vec3(13.787159249868296,-2.7953959960937595,0.8344000244140626);\ntriangles[546].n = vec3(-0.0003797842690877705,0.9428702986381972,-0.3331598050633153);\ntriangles[547].a = vec3(12.49915723570814,-2.7959147949218845,0.8344000244140626);\ntriangles[547].b = vec3(13.787159249868296,-2.7953959960937595,0.8344000244140626);\ntriangles[547].c = vec3(12.499264047231577,-2.9835063476562595,0.3035000228881837);\ntriangles[547].n = vec3(-0.00037978201877065555,0.9428702969247182,-0.33315980991516964);\ntriangles[548].a = vec3(13.787159249868296,-2.7953959960937595,0.8344000244140626);\ntriangles[548].b = vec3(12.49915723570814,-2.7959147949218845,0.8344000244140626);\ntriangles[548].c = vec3(13.787159249868296,-2.8780986328125095,0.8636001014709473);\ntriangles[548].n = vec3(-0.00013410233430117925,0.3329307379273439,0.9429512743295478);\ntriangles[549].a = vec3(12.49915723570814,-2.8785869140625095,0.8636001014709473);\ntriangles[549].b = vec3(13.787159249868296,-2.8780986328125095,0.8636001014709473);\ntriangles[549].c = vec3(12.49915723570814,-2.7959147949218845,0.8344000244140626);\ntriangles[549].n = vec3(-0.00012625538565395108,0.33304000721071364,0.9429126882467249);\n\n\n    \n}\n\n\nmat4 getPerspectiveProjectMatrix(float fovy, float aspect, float near, float far){\n    mat4 projectMatrix;\n    \n\tfloat rd, s, ct;\n\n\n  \tfovy = 3.1415926 * fovy / 180.0 / 2.0;\n  \ts = sin(fovy);\n\n\n  \trd = 1.0 / (far - near);\n  \tct = cos(fovy) / s;\n\n\n      projectMatrix[0][0]  = ct / aspect;\n      projectMatrix[0][1]  = 0.0;\n      projectMatrix[0][2]  = 0.0;\n      projectMatrix[0][3]  = 0.0;\n\n      projectMatrix[1][0]  = 0.0;\n      projectMatrix[1][1]  = ct;\n      projectMatrix[1][2]  = 0.0;\n      projectMatrix[1][3]  = 0.0;\n\n      projectMatrix[2][0]  = 0.0;\n      projectMatrix[2][1]  = 0.0;\n      projectMatrix[2][2]  = -(far + near) * rd;\n      projectMatrix[2][3]  = -1.0;\n\n      projectMatrix[3][0]  = 0.0;\n      projectMatrix[3][1]  = 0.0;\n      projectMatrix[3][2]  = -2.0 * near * far * rd;\n      projectMatrix[3][3]  = 0.0;\n\n      return projectMatrix;\n\n}\n\nmat4 matTranslate(mat4 e, float x, float y, float z) {\n    \n  e[3][0] += e[0][0] * x + e[1][0] * y + e[2][0] * z;\n  e[3][1] += e[0][1] * x + e[1][1] * y + e[2][1] * z;\n  e[3][2] += e[0][2] * x + e[1][2] * y + e[2][2] * z;\n  e[3][3] += e[0][3] * x + e[1][3] * y + e[2][3] * z;\n    \n  return e;\n}\n\nmat4 getViewMatrix(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ){\n    mat4 viewMatrix;\n    \n\tfloat fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\n\n\n  \t  fx = centerX - eyeX;\n      fy = centerY - eyeY;\n      fz = centerZ - eyeZ;\n\n      // Normalize f.\n      rlf = 1.0 / sqrt(fx*fx + fy*fy + fz*fz);\n      fx *= rlf;\n      fy *= rlf;\n      fz *= rlf;\n\n      // Calculate cross product of f and up.\n      sx = fy * upZ - fz * upY;\n      sy = fz * upX - fx * upZ;\n      sz = fx * upY - fy * upX;\n\n      // Normalize s.\n      rls = 1.0 / sqrt(sx*sx + sy*sy + sz*sz);\n      sx *= rls;\n      sy *= rls;\n      sz *= rls;\n\n      // Calculate cross product of s and f.\n      ux = sy * fz - sz * fy;\n      uy = sz * fx - sx * fz;\n      uz = sx * fy - sy * fx;\n\n\n      viewMatrix[0][0]  = sx;\n      viewMatrix[0][1]  = ux;\n      viewMatrix[0][2]  = -fx;\n      viewMatrix[0][3]  = 0.0;\n\n      viewMatrix[1][0]  = sy;\n      viewMatrix[1][1]  = uy;\n      viewMatrix[1][2]  = -fy;\n      viewMatrix[1][3]  = 0.0;\n\n      viewMatrix[2][0]  = sz;\n      viewMatrix[2][1]  = uz;\n      viewMatrix[2][2]  = -fz;\n      viewMatrix[2][3]  = 0.0;\n\n      viewMatrix[3][0]  = 0.0;\n      viewMatrix[3][1]  = 0.0;\n      viewMatrix[3][2]  = 0.0;\n      viewMatrix[3][3]  = 1.0;\n    \n      viewMatrix = matTranslate(viewMatrix, -eyeX, -eyeY, -eyeZ);\n\n      return viewMatrix;\n\n}\n\n\nvec3 getCameraPosition(){\n\tvec3 cameraPosition;\n    cameraPosition.x = sin(iTime)*20.0;\n    cameraPosition.y = 0.0;\n    cameraPosition.z = cos(iTime)*20.0;\n\treturn cameraPosition;\n}\n\nvec4 getFinalV4(vec4 v4) {\n    \n    mat4 modelMatrix = mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n\t//mat4 viewMatrix = mat4(1, 0, -0, 0, -0, 1, -0, 0, 0, 0, 1, 0, 0, 0, -100, 1);\n    \n    vec3 cameraPosition = getCameraPosition();\n    mat4 viewMatrix = getViewMatrix(cameraPosition.x, cameraPosition.y, cameraPosition.z, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n\n\t//mat4 projectMatrix = mat4(2.4142136573791504, 0, 0, 0, 0, 2.4142136573791504, 0, 0, 0, 0, -1.0202020406723022, -1, 0, 0, -2.0202019214630127, 0);\t\n    \n    mat4 projectMatrix  = getPerspectiveProjectMatrix(45.0, iResolution.x/iResolution.y, 1.0, 100.0);\n    \n    mat4 mvpMatrix = projectMatrix * viewMatrix * modelMatrix;\n    \n    return mvpMatrix * v4;\n}\n\nvec4 V3ToV4(vec3 v3) {\n    \n    return vec4(v3.xyz, 1.0);\n    \n}\n\nvec2 V3ToV2(vec3 v3) {\n\n    //v3 project to iResolution.xy\n\n    float x = round(iResolution.x/2.0 + v3.x*iResolution.x/2.0);\n    float y = round(iResolution.y/2.0 + v3.y*iResolution.y/2.0);\n    return vec2(x, y);\n\n}\n\nvec2 V4ToV2(vec4 v4) {\n\n    //v4 project to between -1.0 and 1.0\n\n    vec3 v3 = vec3(v4.xyz);\n\n    v3 = v3 / v4.w;\n\n    return V3ToV2(v3);\n}\n\nfloat v2Cross(vec2 v2a, vec2 v2b) {\n    return v2a.x * v2b.y - v2a.y * v2b.x;\n}\n\nbool isPointInTriangle2D(vec2 point,vec2 tpA, vec2 tpB, vec2 tpC) {\n    vec2 PA = tpA - point;\n    vec2 PB = tpB - point;\n    vec2 PC = tpC - point;\n    \n    float t1 = v2Cross(PA,PB);\n    float t2 = v2Cross(PB,PC);\n    float t3 = v2Cross(PC,PA);\n    //return t1 * t2 > 0.0 && t1 * t3 > 0.0;\n    return t1 >= 0.0 && t2 >= 0.0 && t3 > 0.0;\n}\n\nfloat getLightWeightByNormal(vec3 normal){\n\tfloat lightWeight = 1.0;\n    \n    vec3 lightDirection1 = normalize(vec3(1.0, 0.6, 0.3));\n    \n    vec3 lightDirection2 = -1.0*lightDirection1;\n    \n    float lightWeight1 = max(0.0,dot(lightDirection1, normal));\n    \n    float lightWeight2 = max(0.0,dot(lightDirection2, normal));\n    \n\treturn lightWeight1 + lightWeight2;\n}\n\nvec3 getColorOnTriangle(Triangle triangle){\n\n    vec3 color = vec3(0,0.9,0.9);\n    \n    float lightWeight = getLightWeightByNormal(triangle.n);\n    \n    color = color * lightWeight;\n    \n    color += 0.0;\n        \n    return color;\n    \n}\n\nvec2 getV2form2Line(vec3 line1, vec3 line2){\n    vec2 v2;\n    \n\t//((b1c2-b2c1)/(a1b2-a2b1)，(a2c1-a1c2)/(a1b2-a2b1))\n    \n    v2.x = (line1.y*line2.z-line2.y*line1.z)/(line1.x*line2.y-line2.x*line1.y);\n    v2.y = (line2.x*line1.z-line1.x*line2.z)/(line1.x*line2.y-line2.x*line1.y);\n    \n\treturn v2;\n}\n\nvec3 getLineABCfrom2Point(vec2 p1, vec2 p2){\n    vec3 lineABC;\n    lineABC.x = p2.y - p1.y; //A\n\n\tlineABC.y = p2.x - p1.x; //B\n\n\tlineABC.z = p2.x * p1.y - p2.y * p1.x; //C\n    \n    return lineABC;\n\n}\n\nvec3 getV3from3v2and2v3(vec3 v3a, vec3 v3b, vec2 v2p, vec2 v2a, vec2 v2b){\n    vec3 v3;\n    \n    float ap = distance(v2a,v2p);\n    float pb = distance(v2b,v2p);\n    v3 = v3a + (v3b-v3a)*ap/(ap+pb);\n\treturn v3;\n}\n\nfloat getPointZonTriangle(vec2 v2a, vec2 v2b, vec2 v2c, vec3 v3a, vec3 v3b, vec3 v3c, vec2 p){\n\tfloat z;\n    \n    vec3 lineab = getLineABCfrom2Point(v2a, v2b);\n    vec3 linecp = getLineABCfrom2Point(v2c, p);\n    \n    vec2 v2ab = getV2form2Line(lineab, linecp);\n    \n    vec3 v3ab = getV3from3v2and2v3(v3a, v3b, v2ab, v2a, v2b);\n    \n    vec3 v3p = getV3from3v2and2v3(v3c, v3ab, p, v2c, v2ab);\n    \n    return v3p.z;\n}\n\nbool isTriangleV2clockwise(vec2 p1, vec2 p2, vec2 p3){\n    bool isTriangleV2clockwise = false;\n    \n    if ((p2.x - p1.x) *(p3.y - p1.y) -(p3.x - p1.x) *(p2.y-p1.y) < 0.0){  \n\t\tisTriangleV2clockwise = true;\n    } \n    \n    return isTriangleV2clockwise;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord;\n    \n    vec3 col;\n    \n    bool isCurrentPixInCube = false;\n    \n    getOneCube();\n    \n    int index = -1;\n    \n    float zBuffer = 99999.0;\n    \n    for(int i=0; i<triangleCount; i++ ){\n        vec2 pA = V4ToV2( getFinalV4( V3ToV4(triangles[i].a)));\n    \tvec2 pB = V4ToV2( getFinalV4( V3ToV4(triangles[i].b)));\n    \tvec2 pC = V4ToV2( getFinalV4( V3ToV4(triangles[i].c)));\n        \n        if(isPointInTriangle2D(uv, pA, pB, pC)){\n            vec4 finalV4a = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3a = finalV4a.xyz / finalV4a.w;\n            vec4 finalV4b = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3b = finalV4b.xyz / finalV4b.w;\n            vec4 finalV4c = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3c = finalV4c.xyz / finalV4c.w;\n            //float z = (finalV3a.z+finalV3b.z+finalV3c.z)/3.0;\n            \n            //float z = getPointZonTriangle(pA, pB, pC, finalV3a, finalV3b, finalV3c, uv);\n            \n            if(!isTriangleV2clockwise(pA, pB, pC)){            \n            \tindex = i;\n                break;\n            }\n            /*\n            if(z < zBuffer){\n            \tzBuffer = z;\n                index = i;\n            }\n\t\t\t*/\n\n        };\n    \t\n    }\n    \n    \n    if(index != -1){\n    \tcol = getColorOnTriangle(triangles[index-0]);\n    }else{\n    \tcol = vec3(0.2,0.2,0);\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 222, 247, 247, 185969], [185972, 185972, 186054, 186054, 186839], [186841, 186841, 186895, 186895, 187135], [187137, 187137, 187270, 187270, 188547], [188550, 188550, 188575, 188575, 188731], [188733, 188733, 188759, 188759, 189456], [189458, 189458, 189480, 189480, 189522], [189524, 189524, 189546, 189582, 189739], [189741, 189741, 189763, 189805, 189881], [189883, 189883, 189918, 189918, 189962], [189964, 189964, 190031, 190031, 190304], [190306, 190306, 190348, 190348, 190674], [190676, 190676, 190719, 190719, 190914], [190916, 190916, 190960, 190960, 191217], [191219, 191219, 191263, 191263, 191418], [191420, 191420, 191494, 191494, 191631], [191633, 191633, 191727, 191727, 192050], [192052, 192052, 192106, 192106, 192307], [192309, 192309, 192366, 192458, 193909]], "test": "valid"}
{"id": "wsjXzD", "name": "Audio Spectrum Analysis Test", "author": "quaternion", "description": "Just a cool little effect that spins and you can assign data into a texture which will be used for visualisations", "tags": ["spectrumaudioaudiowaveformfftvisualiser"], "likes": 6, "viewed": 685, "published": "Public", "date": "1553510722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float GetIntensityInRange(float beginNorm, float endNorm, float incrementSize)\n{\n    if (incrementSize == 0.0) return 0.0;\n        \n    float range = endNorm - beginNorm;\n    float incrementCount = range / incrementSize;\n    if (incrementCount == 0.0) return 0.0;\n    \n    float result = 0.0;\n    \n    for (int i = 0; i < int(incrementCount); i++) {\n        float lookupCoord = beginNorm+float(i)*incrementSize;\n        result += texture(iChannel1, vec2(lookupCoord, 0.25)).x * 2.0;\n    }\n    \n    result = result / incrementCount;\n    \n    return result;\n}\n\nfloat GetCornerIntensity(vec2 fragCoord, float checkDist, vec2 corner, float beginSample, float endSample)\n{\n    float distanceN = 1.0 - (clamp(distance(fragCoord, corner), 0.0, checkDist) / checkDist);\n    float intensity = GetIntensityInRange(beginSample, endSample, 0.05);\n    float color = distanceN * intensity;\n    return color;\n}\n\nbool IsWithin(float val, float min, float max)\n{\n    return val >= min && val <= max;\n}\n\nvec4 innerColour = vec4(0.0, 168.0, 181.0, 255.0) / 255.0;\nvec4 outerRingColour = vec4(119.0, 72.0, 152.0, 255.0) / 255.0;\nvec4 highsColour = vec4(243.0, 174.0, 75.0, 255.0) / 255.0;\nvec4 lowsColour = vec4(222.0, 67.0, 131.0, 255.0) / 255.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float smallestDimen = min(iResolution.x, iResolution.y);\n    vec2 halfDimen = iResolution.xy * 0.5;\n    float halfSDimen = smallestDimen * 0.5;\n    \n    vec2 centerOffset = fragCoord - (iResolution.xy/2.0);\n    vec2 nOffset = centerOffset / halfSDimen;\n    \n    float fragAngle = atan(centerOffset.y, centerOffset.x);\n    float fragAngleDegrees = fragAngle*180.0/3.14159;\n    \n    float overAllPulse = GetIntensityInRange(0.0, 0.3, 0.05);\n    \n    float pixelDistanceToCenter = distance(fragCoord, halfDimen.xy);\n    float idealRingDistance = (halfSDimen * 0.8);\n    float ringDistance = idealRingDistance + (halfSDimen * overAllPulse * 0.2);\n    float pixelRingDist = abs(ringDistance - pixelDistanceToCenter);\n    \n    const float ringWidth = 20.0;\n    float outerRingIntensity = 1.0 - (pixelRingDist / ringWidth);\n    if (IsWithin(outerRingIntensity, 0.0, 1.0))\n    {\n        outerRingIntensity *= sin(fragAngle * 3.0 + iTime)*0.5+0.5;\n    \tfragColor += outerRingIntensity * outerRingColour;\n    }\n        \n    // --- Inner ring\n    //Start=Close to center, End is going further away\n    float innerRingEnd = ringDistance - ringWidth * 0.5;\n    float spectrumPixelCount = iChannelResolution[1].x;// * iChannelResolution[1].y;\n    float skipRate = spectrumPixelCount / 360.0;\n    float lookupAngle = mod(fragAngleDegrees+180.0, 360.0);\n    float pixelLookupIndex = ((lookupAngle)*skipRate)/spectrumPixelCount;\n    \n    float pixelLookupColor = texture(iChannel1, vec2(pixelLookupIndex, 0.25)).x*2.0;\n    float pulseA = (sin(fragAngle*3.0+iTime)*0.5+0.5)*0.2;\n    float pulseB = (cos(fragAngle*6.0-iTime*1.5)*0.5+0.5)*0.2;\n    float pulse = 0.1 + pulseA + pulseB;\n    float innerRingStart = innerRingEnd*(1.0-pixelLookupColor-pulse);\n    float innerRingLength = innerRingEnd-innerRingStart;\n    float innerRingFragProgress = (pixelDistanceToCenter-innerRingStart)/innerRingLength;\n    float innerRingIntensity = 1.0 * innerRingFragProgress;        \n    if (pixelDistanceToCenter < innerRingStart || pixelDistanceToCenter > innerRingEnd) \n        innerRingIntensity = 0.0;\n    \n    // Inner ring separators\n    float angleMod = mod(fragAngleDegrees, 3.0);\n    if (IsWithin(angleMod, 0.0, 1.0))\n        innerRingIntensity = 0.0;\n    \n    fragColor += innerColour * innerRingIntensity;\n        \n    //Corners\n    float topRightIntensity = GetCornerIntensity(fragCoord, smallestDimen, iResolution.xy, 0.3, 0.65);\n    float topLeftIntensity = GetCornerIntensity(fragCoord, smallestDimen, vec2(0.0, iResolution.y), 0.0, 0.25) * 2.0;\n    \n    if (topRightIntensity > 0.0)\n    {\n        fragColor += highsColour * topRightIntensity;\n    }\n    \n    if (topLeftIntensity > 0.0)\n    {\n        fragColor += lowsColour * topLeftIntensity;\n    }\n    \n    //if ( fragAngleDegrees < -90.0 || fragAngleDegrees > 70.0) innerRingColor = 0.0;\n    \n    /*\n    fragColor = vec4(clamp(texture(iChannel1, vec2(uv.x, 0.25)).x + topLeftColor, 0.0, 1.0),//(1.0 - abs(nOffset.x)) * (1.0 - abs(nOffset.y)), \n                     outerRingColor,//outerRingColor, \n                     clamp(innerRingColor + topRightColor, 0.0, 1.0), \n                     1.0);\n*/\n    float texIntensity = texture(iChannel1, vec2(uv.x, 0.25)).x;\n    fragColor += lowsColour * texIntensity;\n    \n    //fragColor = mix(vec4(1.0, 1.0, 1.0, 1.0), fragColor, fragColor.a);\n    \n    fragColor.x = clamp(fragColor.x, 0.0, 1.0);\n    fragColor.y = clamp(fragColor.y, 0.0, 1.0);\n    fragColor.z = clamp(fragColor.z, 0.0, 1.0);\n    //fragColor *= 0.5 + (texture(iChannel0, uv).r*0.5);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 80, 80, 557], [559, 559, 667, 667, 895], [897, 897, 945, 945, 984], [1229, 1229, 1286, 1385, 4965]], "test": "error"}
{"id": "wslSD2", "name": "Rainy Bridge Shader Shogun Remix", "author": "crundle", "description": "I couldn't resist..\nThis is yet another remix of a shader coded live on twitch by Nusan (https://www.twitch.tv/nusan_fx)\nOriginal shader: https://www.shadertoy.com/view/wd2GDG\nThis one is based on the remix by Alkama: https://www.shadertoy.com/view/tdsSW2", "tags": ["3d", "raymarching", "rain", "live", "twitch"], "likes": 8, "viewed": 236, "published": "Public", "date": "1552262942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch by NuSan (https://www.twitch.tv/nusan_fx)\nOriginal shader: https://www.shadertoy.com/view/wd2GDG\n\nthis is based on Alkamas remix: https://www.shadertoy.com/view/tdsSW2\n\nYou can lower the MARCH_STEPS if too slow\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/RainyBridge.glsl\n*/\n\n#define MARCH_STEPS 100\n#define RAIN_STEPS 50\n#define SHAD_STEP 30\n\n#define time iTime\n\n#define sat(v) clamp(v,0.,1.)\n\nfloat PI = acos(-1.0);\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 s) {\n  vec3 ap = abs(p)-s;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off = vec3(0.0);\n  off.x += sin(p.z*0.2) + sin(p.z*0.137)*3.0;\n  off.y += sin(p.z*0.5)*0.2 + p.z*0.3;\n  return off;\n}\n\nfloat smin(float a, float b, float h) {\n  float k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a, b, k) - k*(1.0-k)*h;\n}\n\nfloat shogun(vec3 p) {\n    \n    vec3 rp = p - vec3(0,0,1.0);\n  float size = 6.0 * 2.0;\n  rp.z = (fract(rp.z/size-0.5)-0.5)*size+0.f;\n    vec3 pb = rp; \n    pb.x=abs(pb.x)-1.4f;\n    float sho = box(pb, vec3(.24f,1.8f,.1f));\n    pb =rp;\n    pb.y=pb.y-sin((pb.x+1.07f)*1.5f)*.1f;\n    pb.x=pb.x-sin((pb.y+0.3f)*3.f)*0.08f*sign(pb.x);\n    sho = min(sho,box(pb+vec3(0.f,1.7f,0.f),vec3(2.f,.26f,.12f)));\n    sho = min(sho,box(pb+vec3(0.f,1.2f,0.f),vec3(1.9f,.1f,.08f)));\n    return sho;\n}\n\nfloat mat = 0.0f;\nfloat map(vec3 p) {\n  vec3 pw = p;\n  pw.y += .015*pw.z*sin(time*2.+sin(time+pw.x)+sin(-time+pw.y*8.+pw.z)+cos(-time+pw.z*6.));\n  float water = 5.0-pw.y-pw.z*0.3;\n    \n  float hill = -p.y+8.f*sin(p.x*.1f)*sin(p.z*.1f)+10.f-p.z*.5f;\n\n  p += tunnel(p);\n\n  vec3 rp = p;\n  float sizerepeat = 2.0;\n  rp.z = (fract(rp.z/sizerepeat-0.5)-0.5)*sizerepeat;\n  \n  rp.yz *= rot(-rp.z*0.2);\n  float bridge = box(rp + vec3(0,-1,0), vec3(1.0,0.2,2.0));\n  \n  vec3 rp4 = rp + vec3(0,-0.8,0);\n  rp4.x += sin(p.z*8.0)*0.05;\n  rp4.y += cos(p.z*7.0)*0.05;\n  float size4 = 0.14;\n  rp4.xz = (fract(rp4.xz/size4-0.5)-0.5)*size4;\n  float bricks = box(rp4, vec3(0.05))-0.015;\n  bricks = max(bricks, bridge - 0.05);\n\n  bridge = smin(bridge, bricks, 0.09);\n\n  rp.x = abs(rp.x) - 1.0;\n  \n  float bar = box(rp + vec3(0,-0.5,0), vec3(0.05,0.05,2.0));\n  vec3 rp2 = rp;\n  float size2 = 0.2;\n  rp2.z = (fract(rp2.z/size2-0.5)-0.5)*size2;\n  bar = min(bar, box(rp2 + vec3(0,-0.8,0), vec3(0.03,0.3,0.03)));\n\n  bridge = min(bridge, bar);\n\n  vec3 rp3 = p + vec3(1,0,1.0);\n  float size3 = sizerepeat * 2.0;\n  rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;\n  float def = sin(rp3.y*17.0+2.0)*0.5+0.5;\n  def = sin(rp3.y*10.0 + def*3.0);\n  def = smoothstep(0.0,1.0,def);\n  def = smoothstep(0.0,1.0,def);\n  float lsize = 0.05 + (def)*0.02;\n  float lamp = max(cyl(rp3.xz + vec2(0,0), lsize), abs(rp3.y)-1.0);\n\n  vec3 lpos = rp3 + vec3(0,1,0);\n  float top = sph(lpos, 0.3);\n  top = max(top, -sph(lpos-vec3(0,0.3,0), 0.5));\n\n  lpos.y = max(abs(lpos.y)-0.1,0.0);\n  \n  lpos = abs(lpos)-0.1;\n  lpos.xz *= rot(PI*0.25);\n  bridge = min(bridge, lamp);\n  bridge = min(bridge,shogun(p));\n    mat = bridge<hill?1.f:2.f;\n\tbridge = min(bridge,hill);\n    mat = bridge<water?mat:3.0f;\n  bridge = min(bridge, water);\n\n  return bridge;\n}\n\n\nfloat lighting(vec3 p) {\n  p += tunnel(p);\n\n  float sizerepeat = 2.0;\n  vec3 rp3 = p + vec3(1,0,1.0);\n  float size3 = sizerepeat * 2.0;\n  rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;\n\n  vec3 lpos = rp3 + vec3(0,1,0);\n  float top = sph(lpos, 0.3);\n  return sph(lpos, 0.12);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nvec3 getlightdir(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(lighting(p)-vec3(lighting(p-off.xyy), lighting(p-off.yxy), lighting(p-off.yyx)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*745.523)*7894.552);\n}\n\nfloat rain(vec3 p) {\n  p.y -= time*4.0;\n  p.xy *= 60.0;\n  p.x += sin((p.y+p.x+time)*.05);\n  p.y += rnd(floor(p.x))*80.0;\n  \n  return clamp(1.0-length(vec2(cos(p.x * PI), sin(p.y*0.1) - 1.7)), 0.0, 1.0);\n}\n\nfloat ripple(vec3 p) {\n  float t2 = time*5.0;\n\n  float size3 = 0.2;\n  vec3 rp3 = p * vec3(.5,1.,2.) + vec3(1.,0.,1.0);\n  \n  float id = dot(floor(rp3.xz/size3-0.5), vec2(7.52,5.48));\n  rp3.xz = (fract(rp3.xz/size3-0.5)-0.5)*size3;\n  \n\n  float r = clamp(1.0-length(rp3.xz)*20.0, 0.0, 1.0);\n  float looplen = 0.5;\n  float off = rnd(id * 75.5238);\n  float fl = 1.0-fract(time*looplen + off);\n  fl = pow(fl,10.0);\n  float r2 = cos(r*10.0 + t2) * fl;\n\n  return r2*r;\n\n}\n\nfloat ripples(vec3 p) {\n\n  float r = 0.0;\n  for(int i=0; i<5; ++i) {\n    vec3 cur = p + vec3(rnd(float(i)), 0, rnd(float(i)+75.523));\n    cur *= rnd(float(i)+12.71)*0.2+0.8;\n    cur *= 3.0;\n    r += ripple(cur);\n  }\n  return r;\n}\n\nvec3 ripplenorm(vec3 n, vec3 p) {\n\n  vec2 off = vec2(0.01,0.0);\n\n  vec3 rn = normalize(vec3(ripples(p+off.xyy)-ripples(p-off.xyy), 1.9, ripples(p+off.yyx)-ripples(p-off.yyx)));\n  n.xz += .75 * rn.xz * (abs(n.y));\n  return n;\n  \n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot( sin(uv*vec2(784.553) + uv.yx*vec2(546.124)), vec2(7845.523) ));\n}\n\nfloat curve(float t, float r, float p) {\n  float g = t/r;\n  return mix(step(rnd(floor(g)), p), step(rnd(floor(g)+1.0), p), fract(g));\n}\n\nfloat shadow(vec3 s, vec3 r, float maxdist, float rn) {\n  float shad = 1.0;\n  int steps = SHAD_STEP;\n  vec3 raystep = r*maxdist/float(steps);\n  vec3 p = s + raystep*rn;\n  for(int i=0; i<steps; ++i) {\n    float d = map(p);\n    if(d<0.01) {\n      shad = 0.0;\n      break;\n    }\n    p += raystep;\n  }\n  return shad;\n}\n\n// Fake noise approximation to Bonzomatic noise texture (by LunaSorcery)\nfloat noise(vec2 a) {\n    float b = 0.;\n    b += texture(iChannel0, a*.25).r*.5;\n    b += texture(iChannel0, a*.5).r*.25;\n    b += texture(iChannel0, a*1.).r*.125;\n    b += texture(iChannel0, a*2.).r*.0625;\n    return b*.75;\n}\n\nvec3 skycolor(vec3 dir) {\n  float noise = noise(vec2(time*.02, 0) + 2.*vec2(3.5*dir.y, ((time*-.05)+2.*atan(dir.x,dir.z)))/PI);\n  noise = 3.*pow(noise,3.);\n  noise *= sat(-dir.y-.2);\n  return vec3(noise);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float ourmoon = sat(\n      smoothstep(.06, .02, length(uv-vec2(-.54,.35))) -\n  \t  smoothstep(.06, .05, length(uv-vec2(-.51,.37)))\n  );\n  \n  vec3 s = vec3(1,sin(time*0.3)*0.3+.4f,-3);\n  vec3 t = vec3(0,0,0);\n  vec3 r = normalize(vec3(-uv,0.7));\n  \n  vec3 p = s;\n  float dd=0.0;\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d = map(p);\n    if(d<0.001) {\n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=r*d;\n    dd+=d;\n  }\n\n  vec3 col = vec3(0.0);\n  if(mat==1.f) col = vec3(.01,.0,.0); else if(mat==2.f) col = vec3(0.1,.2,.1); else if(mat==3.f) col = vec3(0.05f,0.08f,0.15f);\n      col*=(100.f/dd)*.01;\n  vec3 n = norm(p);\n\n  n = ripplenorm(n, p);\n\n  float lightning = curve(time, 0.2, 0.1);\n  float idlightning = 0.0;\n\n  float fog = 1.0-pow(clamp(dd/50.0,0.0,1.0),0.2);\n  vec3 lmoon = normalize(vec3(-8,-3.+5.*floor(10.*mod(lightning,.2)),-3.0 + sin(idlightning)*3.0+5.*floor(3.*mod(lightning,.5))));\n\n  vec3 shad = vec3(.6, .8, 1.) * shadow(p + n * 0.02, lmoon, 3.0, rnd(uv));\n\n  col += lightning * 5.0 * max(0.0, dot(n, lmoon)) * fog * shad;\n\n  vec3 l = -getlightdir(p);\n  float ldist = lighting(p);\n\n  vec3 h = normalize(l-r);\n\n  col += vec3(.7, .3, .2) * max(0.0, dot(n, l)) * fog * 10.0 * (0.4 + 2.0*pow(max(0.0, dot(n,h)),30.0) )/(ldist*ldist*ldist*ldist);\n\n  float at = 0.0;\n  vec3 raining = vec3(0.0);\n  int steps = RAIN_STEPS;\n  float stepsize = 30.0 / float(steps);\n  vec3 raystep = r * stepsize / r.z;\n  for(int i=0; i<steps; ++i) {\n    vec3 raypos = s + raystep * (float(i)+1.0);\n    float tot = length(raypos-s);\n\n    if(tot>dd) break;\n    float fog2 = 1.0-pow(clamp(tot/40.0,0.0,1.0),0.5);\n\n    \n    vec3 ldir = getlightdir(raypos);\n    float l2dist = lighting(raypos);\n    float curlight = 1.0/pow(l2dist,2.0);\n\n    vec3 rainpos = raypos;\n    rainpos.xy *= rot(sin(float(i)*0.2)*0.01 + sin(time)*0.009);\n    rainpos.xy += rnd(float(i))*vec2(7.52,13.84);\n    raining += rain(rainpos) * fog2 * (lightning*0.5 + pow(curlight,2.0));\n\n    at += 0.04*curlight * fog2;\n  }\n  col += at * vec3(.7, .3, .1);\n  col += raining*.3;\n\n  vec3 sc = skycolor(r);\n  sc = ourmoon*.5*vec3(1., .8, .5)*sc + col*sc*vec3(.5, .7, 1.)*dd/140.f;\n  col += (lightning+.25)*80.*sc;\n  \n  col += pow(col, vec3(0.4545));\n  fragColor = vec4(col, 1);\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 510, 538, 538, 562], [564, 564, 592, 592, 616], [618, 618, 645, 645, 742], [744, 744, 763, 763, 832], [834, 834, 855, 855, 980], [982, 982, 1021, 1021, 1104], [1106, 1106, 1128, 1128, 1587], [1607, 1607, 1626, 1626, 3376], [3379, 3379, 3403, 3403, 3652], [3654, 3654, 3673, 3673, 3781], [3783, 3783, 3809, 3809, 3937], [3939, 3939, 3959, 3959, 4002], [4004, 4004, 4024, 4024, 4208], [4210, 4210, 4232, 4232, 4673], [4675, 4675, 4698, 4698, 4904], [4906, 4906, 4939, 4939, 5135], [5137, 5137, 5157, 5157, 5243], [5245, 5245, 5285, 5285, 5380], [5382, 5382, 5437, 5437, 5696], [5698, 5771, 5792, 5792, 5997], [5999, 5999, 6024, 6024, 6205], [6207, 6207, 6264, 6264, 8674]], "test": "error"}
{"id": "WslSDf", "name": "Alea", "author": "flyingrub", "description": "My first post on shadertoy, trying to recreate what I already made on alea.xyz", "tags": ["audio", "audioreactive", "rgbshift"], "likes": 7, "viewed": 577, "published": "Public API", "date": "1552387475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat random(float seed, float min, float max) {\n\treturn floor(min + random(vec2(seed)) * (max/min));\n}\n\nvec2 rotate2D(vec2 _uv, float _angle){\n    _uv =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _uv;\n    return _uv;\n}\n\nfloat polygon(vec2 _uv, float size, float width, float sides) {\n\t// Angle and radius from the current pixel\n\tfloat a = atan(_uv.x,_uv.y)+PI;\n\tfloat r = TWO_PI/float(sides);\n\n\t// Shaping function that modulate the distance\n\tfloat d = cos(floor(.5+a/r)*r-a)*length(_uv);\n\n\treturn smoothstep(0.005,0.0,abs(d-size)-width/2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = uv*2.-1.;\n\n\tuv.x *= iResolution.x/iResolution.y;\n   \n    float bass = 0.;\n    for (float i = 0.; i < 10.; i ++) {\n    \tbass+= texelFetch( iChannel0, ivec2(i,0), 0 ).x;\n    }\n    bass/=10.;\n    \n    float med = 0.;\n    for (float i = 0.; i < 20.; i ++) {\n    \tmed+= texelFetch( iChannel0, ivec2(240.-i,0), 0 ).x;\n    }\n    med/=20.;\n    \n    float high = 0.;\n    for (float i = 0.; i < 20.; i ++) {\n    \thigh+= texelFetch( iChannel0, ivec2(500.-i,0), 0 ).x;\n    }\n\n    high/=20.;\n    float vol = (bass+med+high)/3.;\n    uv = rotate2D(uv, iTime*0.1 +  bass);\n\t\n    float seed = 8.; // = floor(bass * 5.);\n    float size = .6 * bass;\n    float width = .02+.3 * vol;\n    float rgbShift = 0.02 * vol;\n    float colorR = polygon(uv-vec2(rgbShift,0),size,width, random(seed,3.,10.));\n    float colorG = polygon(uv,size,width, random(seed,3.,10.));\n    float colorB = polygon(uv+vec2(rgbShift,0),size,width, random(seed,3.,10.));\n\tvec3 color = vec3(colorR, colorG, colorB);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "Xll3D4", "previewfilepath": "https://soundcloud.com/youngstauk/lx-one-youngsta", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/youngstauk/lx-one-youngsta", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslSDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 79, 79, 151], [153, 153, 201, 201, 256], [258, 258, 296, 296, 404], [406, 406, 469, 513, 729], [732, 732, 789, 789, 1840]], "test": "error"}
{"id": "wslSRn", "name": "Ray marched Caustics0", "author": "bearworks", "description": "A Fake Caustics Effect by InvertAO.... For Fun", "tags": ["procedural", "3d", "raymarching", "distancefields", "primitives", "caustics", "ambientocclusion"], "likes": 21, "viewed": 712, "published": "Public", "date": "1553480647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nBased on https://www.shadertoy.com/view/Xds3zN\n\nA Fake Caustics Effect by Ray marched Invert ambient occlusion\n\n*/\n\n#define SAMPLES 32\n#define MAXDEPTH 10\n\n#if 1 \n#define INVERSEAO 1      //0, 1 for ao or caustics\n#define MINWEIGHTMODE 0  //0, 1, 2 for weaker, normal, stronger value\n#define WEIGHTMODE 1     //0, 1 for normal, stronger value\n#else\n#define INVERSEAO 0\n#define MINWEIGHTMODE 1\n#define WEIGHTMODE 0\n#endif\n\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n}\n\nfloat length2( vec2 p )\n{\n    return sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n    p = p*p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n    p = p*p; p = p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------\n\nfloat map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n                    vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n    res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n    res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n    res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n    res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n    res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );\n    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n                               sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n                               sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n    res = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 65.0 ) );\n    res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n        \n    return res.x;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, float tmax)\n{\n    float tmin = 1.0;\n    \n    float t = tmin;\n    float precis = 0.0005;\n    for( int i=0; i<64; i++ )\n    {\n        float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n    return t;\n}\n\nfloat castRayAO( in vec3 ro, in vec3 rd)\n{\n    float tmin = 0.1;\n    \n    float t = tmin;\n    float precis = 0.005;\n    for( int i=0; i<MAXDEPTH; i++ )\n    {\n        float res = map( ro+rd*t );\n        if( res<precis  ) \n        {\n#if MINWEIGHTMODE>1\n        return max(res, 0.0);\n#elif MINWEIGHTMODE>0\n        return 1. / max(t, 1.001);\n#else\n        return max(t, 0.0);\n#endif\n        }\n\n        t += res;\n    }\n#if WEIGHTMODE>0\n    return 1. / max(t, 0.001);\n#else\n    return 1. / max(t, 1.001);\n#endif\n\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) +\n                      e.yyx*map( pos + e.yyx ) +\n                      e.yxy*map( pos + e.yxy ) +\n                      e.xxx*map( pos + e.xxx ) );\n}\n\n#define PI 3.1415926535897932384626\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nvec3 jitter(vec3 d, float phi, float sina, float cosa) {\n    vec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n    return (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float ao = .0;\n    for( int i=0; i<SAMPLES; i++ )\n    {\n        float r2 = rand();\n        vec3 d = jitter(nor, 2.*PI*rand(), sqrt(r2), sqrt(1. - r2));\n        \n        ao += castRayAO(pos, d);\n    }\n    ao /= float(SAMPLES);\n#if INVERSEAO > 0\n    return clamp( ao, 0.0, 1.0 ); \n#else\n    return clamp( 1. - ao, 0.0, 1.0 ); \n#endif\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    float t = castRay(ro,rd, 20.0);\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n        \n    float occ = calcAO( pos, nor );\n    return vec3(occ, occ, occ);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float time = 15.0 + iTime;\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // camera    \n    vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n     // render    \n     fragColor.rgb = render( ro, rd );\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}, {"id": "XsXGR8", "previewfilepath": "/media/previz/buffer01.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer01.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 427, 452, 452, 470], [472, 472, 507, 507, 533], [535, 535, 566, 566, 657], [659, 659, 702, 702, 762], [764, 764, 809, 809, 851], [853, 853, 886, 886, 941], [943, 943, 979, 979, 1221], [1223, 1223, 1275, 1275, 1398], [1400, 1400, 1436, 1436, 1684], [1686, 1686, 1722, 1722, 1821], [1823, 1823, 1861, 1861, 2030], [2032, 2032, 2104, 2104, 2319], [2321, 2321, 2388, 2427, 2796], [2798, 2798, 2823, 2823, 2863], [2865, 2865, 2890, 2890, 2954], [2956, 2956, 2981, 2981, 3052], [3054, 3054, 3089, 3089, 3160], [3162, 3162, 3197, 3197, 3268], [3270, 3270, 3307, 3307, 3360], [3362, 3432, 3465, 3465, 3491], [3493, 3493, 3523, 3523, 3559], [3561, 3561, 3591, 3591, 3620], [3622, 3622, 3646, 3646, 3778], [3780, 3850, 3876, 3876, 6051], [6053, 6053, 6105, 6105, 6333], [6335, 6335, 6377, 6377, 6843], [6846, 6846, 6878, 6878, 7113], [7168, 7168, 7182, 7182, 7225], [7227, 7227, 7283, 7283, 7417], [7419, 7419, 7461, 7461, 7799], [7801, 7801, 7840, 7840, 8066], [8068, 8068, 8120, 8120, 8309], [8311, 8311, 8368, 8368, 8882]], "test": "valid"}
{"id": "WslSzX", "name": "Ray_trace_319group", "author": "Krause", "description": "...", "tags": ["raytrace"], "likes": 2, "viewed": 256, "published": "Public API", "date": "1552228425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 512;\nconst float MIN_DIST = 0.0001;\nconst float MAX_DIST = 512.;\nconst float EPSILON = 0.0001;\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \nstruct Hit {\n    vec3 normal;\n    vec3 pos;\n    float t;\n    bool exist;\n};\n    \nstruct material{\n\tvec3 k_a;\n    vec3 k_d;\n    float alpha;\n    vec3 k_s;\n};\n    \nstruct Options{\n    vec4 sphere; \n    vec3 sph_color;\n    vec4 plane; \n    vec3 pl_color;\n    vec2 torus;\n    vec3 torus_center;\n    vec3 tor_color;\n    vec2 hex;\n    vec3 hex_center;\n    vec3 hex_color;\n    vec3 box;\n    vec3 box_center;\n    vec3 box_color;\n    material material1;\n    material material2;\n    material material3;\n};\n    \n \nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec3 c, vec2 t )\n{\n  vec2 q = vec2(length8((p-c).xz)-t.x,(p-c).y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus( vec3 p, vec3 c, vec2 t )\n{\n  vec2 q = vec2(length((p-c).xz)-t.x,(p-c).y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere(vec3 p, vec3 c, float s) \n{\n  \treturn length(p-c)-s;\n}\n\nfloat udRoundBox(vec3 p, vec3 c, vec3 b, float r)\n{\n  return length(max(abs(p-c)-b,0.0))-r;\n}\n\nfloat sdHexPrism( vec3 p, vec3 c, vec2 h )\n{\n    vec3 q = abs(p-c);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat minimal(float f1, float f2, float f3, float f4, float f5) \n{\n    return min(min(f1,f4), min(min(f2,f3),f5)) ;\n}\n\nfloat scene(vec3 pos, Options data)\n{  \n    float dPlane = sdPlane(pos, data.plane);\n    float dSphere = sdSphere(pos, data.sphere.xyz, data.sphere.w);\n    float dTorus = sdTorus(pos, data.torus_center, data.torus);\n    float dHex = sdHexPrism(pos, data.hex_center, data.hex);\n    float dBox = udRoundBox(pos, data.box_center, data.box, 0.4);\n    \n    return minimal(dPlane, dSphere, dTorus, dBox, dHex);  \n}\n\nvec3 scene_normal( vec3 pos, float d, Options data)\n{\n    vec3 n;\n\t\n    n.x = scene( vec3( pos.x + EPSILON, pos.y, pos.z ), data ) - d;\n    n.y = scene( vec3( pos.x, pos.y + EPSILON, pos.z ), data ) - d;\n    n.z = scene( vec3( pos.x, pos.y, pos.z + EPSILON ), data ) - d;\n\t\n    return normalize(n);\n}\n\nHit ray_march(const Ray ray, Options data) \n{\n    Hit res;\n    \n    res.t = MIN_DIST;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(ray.pos + res.t*ray.dir, data);\n        if (dist < EPSILON) {\n\t\t\tbreak;\n        }\n        res.t += dist;\n        if (res.t > MAX_DIST) {\n            res.exist = false;\n            return res;\n        }\n    }\n    \n    res.pos = ray.pos + res.t*ray.dir;\n    res.normal = scene_normal(res.pos, scene(res.pos,data), data);\n    res.exist = true;\n    \n    return res;  \n}\n\nbool Visible(vec3 pos, vec4 light, Options data) \n{\n    Ray ray;\n    ray.pos = light.xyz;\n    ray.dir = normalize(pos - light.xyz);\n    \n    Hit hit = ray_march(ray, data);\n    \n    if( length(pos-light.xyz) > hit.t+0.1 )\n        return true;\n    else\n        return false;\n    \n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxlen, Options data)\n{\n    for( float t=MIN_DIST; t < maxlen ;)\n    {\n        float h = scene(ro + rd*t, data);\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvec3 shade(vec3 pos, vec3 nrm, vec4 light, Options data)\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat res = 0.1;\n\tfloat vis = shadow( pos, toLight, toLightLen, data );\n\t\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n\t\tres += diff * attn * vis;\n\t}\n\t\n\treturn vec3( res, res, res );\n    \n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 intensity, Options data) \n{\n    vec3 N = scene_normal(p, scene(p,data), data);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float LN = dot(L, N);\n    float RV = dot(R, V);\n    \n    if (LN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (RV < 0.0) {\n        return intensity * (k_d * LN);\n    }\n    return intensity * (k_d * LN + k_s * pow(RV, alpha));\n}\n\nvec3 phong(vec4 lights[2], material m, vec3 p, vec3 eye, Options data) \n{\n    vec3 color = vec3(0);\n    vec3 intensity = vec3(0.8, 0.8, 0.8);\n    \n    for(int i=0; i<2; i++)\n    \tcolor += phongContribForLight(m.k_d, m.k_s, m.alpha, p, eye,\n                                  lights[i].xyz,\n                                  intensity, data);\n      \n    return color;\n}\n\nvec3 RayTrace(const Ray ray, vec4 lights[2], Options data)\n{\n    \n\tvec3 color = vec3(0,0,0);\n\tHit hit = ray_march(ray, data); \n    \n\tif (!hit.exist)\n\t\treturn color;\n    \n    if (sdSphere(hit.pos, data.sphere.xyz, data.sphere.w)<(EPSILON)) {\n        color = data.sph_color;\n        color += phong(lights, data.material1, hit.pos, ray.pos, data);\n    } else if (sdPlane(hit.pos, data.plane)<EPSILON) {\n        color += phong(lights, data.material2, hit.pos, ray.pos, data);\n    } else if (sdTorus(hit.pos, data.torus_center, data.torus)<EPSILON) {\n        color = data.tor_color;\n        color += phong(lights, data.material2, hit.pos, ray.pos, data);\n    } else if (udRoundBox(hit.pos, data.box_center, data.box, 0.4)<EPSILON) {\n        color = data.box_color;\n        color += phong(lights, data.material1, hit.pos, ray.pos, data);\n    } else if (sdHexPrism(hit.pos, data.hex_center, data.hex)<EPSILON) {\n        color = data.hex_color;\n        color += phong(lights, data.material3, hit.pos, ray.pos, data);\n    }\n    \n    vec3 help = normalize(vec3(1.0,0.9,0.7));\n    \n    for(int i=0;i<2;i++){\n    \tif(!Visible(hit.pos, lights[i],data))\n            color += clamp( dot( hit.normal, help ), 0.0, 1.0 )*shade(hit.pos,hit.normal,lights[i], data);\n    }\n   \n        \n\treturn color;\n}\n\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {   //??????\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Options data;\n    data.sphere = vec4(4,1.5+abs(2.*sin(iTime)),4,1.5);\n    data.sph_color = vec3(1.0,0.0,0.0);\n    \n    data.plane = vec4(0.0,1.0,0.0,0.9);\n    data.pl_color = vec3(0.0,1.0,0.0);\n    \n    data.torus = vec2(1.5+abs(sin(iTime)),0.5);\n    data.torus_center = vec3(4.+2.*sin(iTime),0,4.+4.*sin(iTime)) ;\n    data.tor_color = vec3(0.5,0.0,0.5);\n    \n    data.hex = vec2(1.5,1.5); \n    data.hex_center = vec3(-5.,7.2+2.*sin(iTime),-3.+4.*abs(cos(iTime))) ;\n    data.hex_color = vec3(0.1,0.0,0.2);\n    \n    data.box_center = vec3(-5.,1.3,-3);\n    data.box = vec3(2,2,2);\n    data.box_color = vec3(0.5);\n    \n    data.material1.k_a = vec3(0.2, 0.2, 0.2);\n    data.material1.k_d = vec3(0.7, 0.4, 0.3);\n    data.material1.k_s = vec3(1.0, 1.0, 1.0);\n    data.material1.alpha = 12.0;\n    \n    data.material2.k_a = vec3(0.0, 0.0, 0.0);\n    data.material2.k_d = vec3(0.2, 0.2, 0.2);\n    data.material2.k_s = vec3(1.0, 1.0, 1.0);\n    data.material2.alpha = 10.0;\n    \n    data.material3.k_a = vec3(0.1, 0.1, 0.1);\n    data.material3.k_d = vec3(0.1, 0.2, 0.5);\n    data.material3.k_s = vec3(1.0, 1.0, 1.0);\n    data.material3.alpha = 6.0;\n    \n    \n    vec4 lights[2];\n    lights[0] = vec4(4.*sin(iTime),5,5.*cos(iTime),5);\n    lights[1] = vec4(-2.,7,7,15);\n    \n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 4.0, 35.0);\n    \n    \n    Ray ray;\n    ray.pos = eye;\n    ray.dir = dir;\n    \n    fragColor = vec4(RayTrace(ray,lights,data),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslSzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[679, 679, 704, 704, 769], [771, 771, 814, 814, 889], [891, 891, 932, 932, 1005], [1007, 1007, 1038, 1038, 1070], [1072, 1072, 1114, 1114, 1141], [1143, 1143, 1194, 1194, 1236], [1238, 1238, 1282, 1282, 1368], [1370, 1370, 1436, 1436, 1487], [1489, 1489, 1526, 1526, 1897], [1899, 1899, 1952, 1952, 2199], [2201, 2201, 2246, 2246, 2735], [2737, 2737, 2788, 2788, 3017], [3019, 3019, 3079, 3079, 3254], [3256, 3256, 3314, 3314, 3711], [3713, 3713, 3863, 3863, 4280], [4282, 4282, 4355, 4355, 4649], [4651, 4651, 4711, 4711, 5933], [5937, 5937, 6002, 6013, 6145], [6147, 6147, 6199, 6199, 6376], [6378, 6378, 6435, 6435, 7921]], "test": "valid"}
{"id": "WslXDf", "name": "Hot and cold", "author": "Sabouh", "description": "Hot then cold colors", "tags": ["colorchange"], "likes": 3, "viewed": 79, "published": "Public", "date": "1552397551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col1 = 0.5 + 0.5*sin(-iTime+uv.xyx+vec3(0,2,4));\n\tcol = (col + col1)/2.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 380]], "test": "valid"}
{"id": "WslXRX", "name": "LineColor", "author": "kiyamada96", "description": "color line", "tags": ["line"], "likes": 5, "viewed": 123, "published": "Public", "date": "1551945347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI=3.14\n\nvec3 hsv(float h,float s,float v)\n{\n\tvec4 t=vec4(1.0,2.0/3.0,1.0/3.0,3.0);\n    vec3 p=abs(fract(vec3(h)+t.xyz)*6.0-vec3(t.w));\n    return v*mix(vec3(t.x),clamp(p-vec3(t.x),0.0,1.0),s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    vec3 line=vec3(0.);\n    \n    for(float fi=0.0;fi<50.0;++fi)\n    {\n    \tfloat offset=fi*3.14/20.0;\n        float value=1.0+sin(iTime*fi*0.15+0.1)*0.5;\n        float timer=iTime+fi*0.01;\n        vec3 color=hsv((fi+iTime)*0.0675,1.0,value);\n        line+=0.0015/abs(p.y+sin(p.x*1.0+offset+timer)*1.0+0.93)*color;\n    }\n    \n    fragColor = vec4(line,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 52, 52, 203], [205, 205, 262, 262, 681]], "test": "valid"}
{"id": "WslXW2", "name": "327_Бурков_Никита", "author": "Gor4i4ka", "description": "Курсы компьютерной графики. Задание №1.\n- Обязательная часть (15 баллов)", "tags": ["raymarching"], "likes": 2, "viewed": 62, "published": "Public", "date": "1552237734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// global parameters\nint MAX_STEPS = 300;\nfloat MAX_D = 100.0;\nfloat EPSN = 0.0001;\nfloat EPSR = 0.001;\nfloat PI = 3.14;\nint CLOSEST_FIGURE = 0;\n//constructing the Scene\n\nfloat intersect2(float obj1, float obj2, int num1, int num2) \n{\n    CLOSEST_FIGURE = num2;\n    if (obj1>obj2) {\n     \t   CLOSEST_FIGURE = num1;\n    }\n \treturn max(obj1,obj2);   \n}\nfloat union2(float obj1, float obj2, int num1, int num2)\n{\n    CLOSEST_FIGURE = num2;\n    if (obj1<obj2) {\n     \t   CLOSEST_FIGURE = num1;\n    }\n \treturn min(obj1, obj2);   \n}\nfloat substract(float obj1, float obj2, int num1, int num2)\n{\n    CLOSEST_FIGURE = num2;\n    if (obj1>obj2) {\n     \t   CLOSEST_FIGURE = num1;\n    }\n\treturn max(-obj1, obj2);   \n}\n//moving figures\nvec3 move( vec3 p, vec3 center, mat3 rot )\n{\n    vec3 q = vec3(p - center);\n    q = inverse(rot)*q;\n    return q;\n}\n//SDF's\nfloat planeSDF(vec3 p, float d){\n    return  p.y + d;\n}\nfloat boxSDF(vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sphereSDF(vec3 p, float radius, float amplitude, float pulse)\n{\n \treturn length(p) - radius + amplitude * sin(pulse*iTime);\n}\nfloat torusSDF( vec3 p, vec2 b )\n{\n  vec2 q = vec2(length(p.xz)-b.x,p.y);\n  return length(q)-b.y;\n}\n//the scene itslef\nfloat scene(vec3 p) {\n    float body;\n    vec3 p1;\n    float plane1 = planeSDF(p, 3.0);\n    float sphere1 = sphereSDF(p, 0.75, 0.05, 1.0);\n    float box1 = boxSDF(p,vec3(0.5, 0.5, 0.5));\n    float torus1 = torusSDF(p, vec2(2.0, 0.1));\n    mat3 MAT;\n    mat3 MAT1;\n    for (int i; i<3; i++) {\n        for (int j; j<3; j++) {\n         \tMAT[i][j] = 0.0;\n            if (i==j){\n             \tMAT[i][i] = 1.0;\n            }\n        }\n    }\n    //sphere2\n    MAT1 = MAT;\n    p1 = move(p, vec3(2.0 * sin(2.0*iTime + 2.3), 0.0, 2.0*cos(2.0*iTime + 2.3)), MAT1);\n    float sphere2 = sphereSDF(p1, 0.3, 0.0, 0.0);\n    \n    //Torus2\n    MAT1 = MAT;\n    MAT1[0][0] = cos(2.3*PI/3.0 *iTime * 0.3);\n    MAT1[0][1] = sin(2.3*PI/3.0 * iTime * 0.3);\n    MAT1[1][0] = -sin(2.3*PI/3.0 * iTime * 0.3);\n    MAT1[1][1] = cos(2.3*PI/3.0 * iTime * 0.3);\n    p1 = move(p, vec3(0.0, 0.0, 0.0), MAT1);\n    float torus2 = torusSDF(p1, vec2(2.0, 0.1));\n    //Torus2 end\n    \n    //sphere3\n    MAT1=MAT1;\n    p1 = move(p1, vec3(2.1*sin(2.0*iTime), 0.0, 2.1*cos(2.0*iTime)), MAT1);\n    float sphere3 = sphereSDF(p1, 0.3, 0.0, 0.0);\n    //sphere3 end\n    \n    body = intersect2(sphere1, box1, 1, 6);\n    body = union2(torus1, body, 4, CLOSEST_FIGURE);\n    body = union2(sphere2, body, 2, CLOSEST_FIGURE);\n    body = union2(torus2, body, 5, CLOSEST_FIGURE);\n    body = union2(sphere3, body, 3, CLOSEST_FIGURE);\n    body = union2(plane1, body, 7, CLOSEST_FIGURE);\n    return body;\n}\n//colors of vody components\nstruct Colors {\n \tvec3 sphere1; //1\n    vec3 sphere2; //2\n    vec3 sphere3; //3\n    vec3 torus1; //4\n    vec3 torus2; //5\n    vec3 box1; //6\n    vec3 plane1; //7\n};\n//calculating normal\nvec3 estimateNormal(vec3 p) {\n    float dx = scene(vec3(p.x + EPSN, p.y, p.z)) - scene(vec3(p.x - EPSN, p.y, p.z));\n    float dy = scene(vec3(p.x, p.y + EPSN, p.z)) - scene(vec3(p.x, p.y - EPSN, p.z));\n    float dz = scene(vec3(p.x, p.y, p.z  + EPSN)) - scene(vec3(p.x, p.y, p.z - EPSN));\n    //no need to divide by 2 * EPSN\n    return normalize(vec3(dx,dy,dz));\n}\n//raymarching algorithm\nfloat rayMarch(vec3 rayDir, vec3 eye)\n{\n vec3 color = vec3(0.0,0.0,0.0);\n float dist = 0.0;\n for (int i = 0; i < MAX_STEPS; i++) {\n        float norm = scene(eye + dist * rayDir);\n        if (norm < EPSR) {\n\t\t\treturn dist;\n        }\n        dist += norm;\n        if (dist >= MAX_D) {\n            return MAX_D;\n        }\n    }\n    return MAX_D;\n}\n//Illumination model by Phong (modelled after tutorial by jlfwong (shadertoy))\n// the struct of a point light\nstruct PointLight\n{\n\tvec3 position;\n\tvec3  diffusePower;\n\tvec3 specularColor;\n\tvec3  specularPower;\n};\n\nvec3 phong1source(PointLight src, float alpha, vec3 p, vec3 eye, vec3 clr) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(src.position - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return clr * (src.diffusePower * dotLN);\n    }\n    return src.diffusePower * clr * dotLN + src.specularPower * src.specularColor * pow(dotRV, alpha);\n}\n\nvec3 phongIllumination(vec3 p, vec3 eye) {\n    //exact colors of body components\n    Colors bd;\n    vec3 clr = vec3(0.0, 0.0, 0.0);\n    bd.sphere1 = 0.7*vec3(1.0,0.0,0.0);\n    bd.sphere2 = 0.7*vec3(0.0,1.0,0.0);\n    bd.sphere3 = 0.7*vec3(0.0, 0.0, 1.0);\n    bd.torus1 = 0.7*vec3(1.0,1.0,0.0);\n    bd.torus2 = 0.7*vec3(1.0,0.0,1.0);\n    bd.box1 = 0.7*vec3(0.0,1.0,1.0);\n    bd.plane1 = 0.7*vec3(0.1,0.3,0.1);\n    //colors of light sources\n    vec3 k_a = vec3(0.2, 0.2, 0.2);\n    vec3 k_d = vec3(0.4, 0.4, 0.4);\n    vec3 k_s = vec3(1.0, 1.0, 1.0);\n    float alpha = 10.0;\n    //choosing th component\n    if (CLOSEST_FIGURE == 1) {\n    \tclr = bd.sphere1;   \n    }\n    if (CLOSEST_FIGURE == 2) {\n    \tclr = bd.sphere2;   \n    }\n    if (CLOSEST_FIGURE == 3) {\n    \tclr = bd.sphere3;   \n    }\n    if (CLOSEST_FIGURE == 4) {\n    \tclr = bd.torus1;   \n    }\n    if (CLOSEST_FIGURE == 5) {\n    \tclr = bd.torus2;   \n    }\n    if (CLOSEST_FIGURE == 6) {\n    \tclr = bd.box1;   \n    }\n    if (CLOSEST_FIGURE == 7) {\n    \tclr = bd.plane1;   \n    }\n    //ambient light\n    const vec3 ambientLight = 0.45 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    //First light source\n    PointLight src1;\n    src1.position = vec3(4.1 * sin(iTime),\n                          2.2,\n                          4.1 * cos(iTime));\n    src1.specularColor = k_s;\n    src1.diffusePower = vec3(0.4, 0.4, 0.4);\n    src1.specularPower = vec3(0.4, 0.4, 0.4);\n    \n    color += phong1source(src1, alpha, p, eye, clr);\n    \n    //Second light source\n    vec3 light2Pos = vec3(2.04 * sin(0.36 * iTime),\n                          2.03 * cos(0.355 * iTime),\n                          2.01);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    PointLight src2;\n    src2.position = light2Pos;\n    src2.specularColor = k_s;\n    src2.diffusePower = light2Intensity;\n    src2.specularPower = light2Intensity;\n    \n    color += phong1source(src2, alpha, p, eye, clr);\n    \n    //Final color\n    return color;\n}\n//calculating ray direction & view matrix\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n//main body\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CLOSEST_FIGURE = 0;\n    \n\tvec3 vwDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(7.5, 5.5, 7.3);\n    \n    mat4 vtWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 wdDir = (vtWorld * vec4(vwDir, 0.0)).xyz;\n    \n    float dist = rayMarch(wdDir, eye);\n    \n    if (dist > MAX_D - EPSR) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * wdDir;\n    \n    vec3 color = phongIllumination(p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslXW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 171, 234, 234, 350], [351, 351, 409, 409, 526], [527, 527, 588, 588, 705], [706, 723, 767, 767, 838], [839, 847, 879, 879, 902], [903, 903, 934, 934, 1021], [1022, 1022, 1091, 1091, 1153], [1154, 1154, 1188, 1188, 1253], [1254, 1273, 1294, 1294, 2721], [2915, 2936, 2965, 2965, 3300], [3301, 3325, 3364, 3364, 3670], [3671, 3885, 3961, 3961, 4591], [4593, 4593, 4635, 4673, 6572], [6573, 6615, 6680, 6680, 6812], [6814, 6814, 6863, 6898, 7124], [7125, 7137, 7194, 7194, 7835]], "test": "error"}
{"id": "wssSR2", "name": "Midterms_Co_Design9", "author": "johannco98", "description": "asd", "tags": ["asd"], "likes": 1, "viewed": 40, "published": "Public", "date": "1551717339", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Spikes(float angle, float armSpeed, float armNum, float armWidth, float size)\n{\n    float spikes =  -(abs(cos(angle * 0.5 + (iTime * armSpeed)) \n                        * sin(angle * armNum )))\n        \t\t\t\t\t\t\t\t\t\t\t* armWidth +      size;\n    \n    return spikes;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Colors in vec3\n    vec3 red = vec3(0.8 ,0.0 ,0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 yellow = vec3(0.9, 0.9, 0.3);\n    vec3 blue = vec3(0.0, 0.2, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.y *= ratio;\n    uv *= 1.0;\n    uv = fract(sin(uv * 10.));\n    vec2 shapePos = vec2((0.5 * ratio) , 0.5);\n    float dist = distance(shapePos , uv) * 2.50;\n    \n    uv -= shapePos;\n    \n    float angle = atan(uv.y, uv.x);\n    float spikes = Spikes(angle, 1.0, 6.0, 10.0, 0.5 );\n     \n    \n    vec3 test = mix(white, green, spikes);\n    test = mix(test, red, Spikes(angle, 1.0, 6.0, 10.0, 0.5 ));\n    test = mix(red+ yellow, test, Spikes(angle, 2.0, 6.0, 10.0, 0.5 ));\n    test = mix(black, test, Spikes(angle, 3.0, 6.0, 10.0, 1.5 ));\n    \n    // Output to screen\n    fragColor = vec4(test , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssSR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 85, 85, 273], [276, 276, 333, 354, 1326]], "test": "valid"}
{"id": "wsSSRD", "name": "hyperpastel tunnel", "author": "samlo", "description": "a tube", "tags": ["noise", "palette", "tube", "blah"], "likes": 6, "viewed": 440, "published": "Public API", "date": "1553053885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nuniform vec2 mouse;\n\n\n\nvec3 hash3( vec2 p ) {\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n\n//iq voronoise\nfloat iqnoise( in vec2 x, float u, float v ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\n//iq palette\nvec3 palette(in float t) {\n\t//colors\n\tvec3 a = vec3(0.5, 0.5, 0.5);  \n\tvec3 b = vec3(0.5, 0.5, 0.5);\n\tvec3 c = vec3(1.0, 1.0, 1.0);\n\tvec3 d = vec3(0.3, 0.15, 0.87);\n\t\n\treturn a + b * cos(6.28318 * (c * t + d));\n}\n\nfloat sin01(in float t){\n\treturn (sin(t) + 1.) * 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 point = gl_FragCoord.xy / iResolution.xy;\n\t//vec2 mouse = (mouse.xy - 0.5) * 0.1; mouse is kind of ugly?\n\tvec2 center = vec2(0.5 - (sin(iTime * 0.5) * 0.05), 0.5 - (sin(iTime * 0.25) * 0.1));\n\n\t//aspect ratio\n\tfloat aspect = iResolution.x / iResolution.y;\n\tpoint.x *= aspect;\n\tcenter.x *= aspect;\n\t\n\t//center circle\n\tfloat circle = pow(smoothstep(0.3, 0., length(point - center)), 1.2) * 0.55;\n\t\n\t//circle glow\n\tfloat glow = pow(smoothstep(1.4, 0.2, length(point - center)), 1.2) * 0.45;\n\t\n\t\n\t//planar distortion\n\tfloat rInv = 1. / length(point - center);\n\tpoint = point * rInv - vec2(rInv, 0.0);\n\t\n\t//sample noise\n\tvec2 uv = vec2(point.x, point.y + iTime * 0.5) * 1.7;\n\tfloat noise = iqnoise(uv, 0.5, 1.2);\n\tfloat stepNoise = floor(noise * 10.3) / 11.; //stepping irregularly gives nice shapes \n\t\n\t//draw outline around stepped noise\n\tfloat outline = 1.0 - step(smoothstep(stepNoise - 0.03, stepNoise, noise) - (smoothstep(stepNoise, stepNoise + 0.03, noise)), 0.03);\n\tvec3 outlineCol = outline * palette(sin01(iTime * 0.2));\n\t\n\t//get tunnel color from palette. I tried directly attenuating this by length of the fragment but it kept blowing out to white\n\tvec3 palette = palette((stepNoise * 0.5) + sin01(iTime * 0.4) * 0.2);\n\t\n\t//combine\n\tvec3 finalColor = palette + outlineCol + circle + glow;\n\t//finalColor = vec3(glow + circle);\n\tfragColor = vec4(finalColor, 1.0);\t\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 46, 46, 197], [200, 215, 261, 261, 696], [698, 711, 737, 747, 923], [925, 925, 949, 949, 980], [983, 983, 1040, 1040, 2419]], "test": "error"}
{"id": "wssSRX", "name": "MCG: Ellipse", "author": "tale3d", "description": "In this lecture we have introduction into geometric objects and how they can be presented in an implicit and parametric forms. ", "tags": ["teachingmaterial"], "likes": 0, "viewed": 39, "published": "Public", "date": "1551797100", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n\n    //Adding more to the common section:\n    //This example has a mouse as an input device.\n    //The mouse coordinates are taking in uv space, and then is modified in the same way\n    //  as the pixel coordinates (see above). \n    vec2 mouse = 2.0*(iMouse.xy / iResolution.xy) - vec2(1.0,1.0);\n    mouse.x *= aspect_ratio;\n\n\n    //Background colour (default)\n    vec3 colour = vec3(1.0,1.0,1.0);\n\n    //For parametric representation we can generate the point for the given value of t\n    //As we are in the example that works for all the pixels, the idea of visualising that\n    //   might be the following: make t time-dependent and visualise the point that\n    //   corresponds to the value of t.\n\n    //Ellipse, parametric definition\n    vec2 centre = vec2(0.1,0.1);\n    float t = iTime;\n    float a = 1.0, b = 0.6;\n\tvec2 parametric = centre + vec2(a*cos(t), b*sin(t));\n    \n    //as previously, if the point is close enough to the given pixel, we colour it blue\n    if (dot(c-parametric, c-parametric) < 0.001) colour = vec3(0.0,0.0,1.0);\n\n    //now the implicit equation: we use one of the equations from the lecture\n    float implicit = (c.x-centre.x)*(c.x-centre.x)/(a*a) + (c.y-centre.y)*(c.y-centre.y)/(b*b)-1.0;\n\n    //if it is equal to 0, then we are on our straight line, but as we work with pixels \n    //   which might be slightly off, we use proximity test once again.\n    if (abs(implicit) < 0.01) colour = vec3(0.0,0.0,0.0);     //Colour the line black.     \n    \n    //That is it, assign the colour to the pixel.\n    fragColor = vec4(colour,1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 404, 2309]], "test": "valid"}
{"id": "WssSWf", "name": "grass box", "author": "twopointfive", "description": "grass box", "tags": ["grassbox"], "likes": 5, "viewed": 235, "published": "Public", "date": "1552377666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// lorry    twopointfive@163.com    crapell engine\n// https://blog.csdn.net/twopointfive/article/details/8925003\n\n\n//闪烁 三角雨\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\nfloat sdBox( vec3 p, vec3 b ,out vec2 uv)\n{\n    vec3 d = abs(p) - b;\n    /*\n    vec3 uv_ = abs(p);\n    if(uv_.x>uv_.y)\n    {\n        if(uv_.x>uv_.z)\n            uv = p.yz;\n        else\n            uv = p.xy;\n    }\n    else\n    {\n        if(uv_.y>uv_.z)\n            uv = p.zx;\n        else\n            uv = p.xy;\n    }\n    */\n    uv = p.xy;\n    uv = uv*0.5 +0.5;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\n\nvec3 hash( vec2 p ) // rand in [0,1]\n{  \t\t\t\t\t\t\n\tvec3 r = vec3( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)),\n              dot(p,vec2(173.7,153.3)));\n\treturn  fract(sin(r+20.)*53758.5453123);\n}\n\n// rotation\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 p, vec3 axis, float angle)\n{\n    mat4 R = rotationMatrix(axis, angle);\n    return (R*vec4(p,1.0)).xyz;\n}\n        \n//xz轴边长gridSize划分格子 一个格子一个三角形\nfloat gridSize = 1.;\nfloat maxStep( in vec3 pos ,in vec3 rd,in vec3 gridFloorPos)\n{\n    //return gridSize*0.2;\n    float res = 1e10;\n    /*\n        a b\n\t\tc d\n       比如射线依次穿过cdb，cb里的球等高，d里球特高，相交d球时可能返回很大的跨步\n\t*/\n    if( rd.x>0.)\n    {\n        vec3 planeNormal = vec3(-1.,0.,0.);\n        vec3 planePos = gridFloorPos + vec3(gridSize,0.,0.);\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.001,res);\n    }\n    else if( rd.x<0.)\n    {\n        vec3 planeNormal = vec3(1.,0.,0.);\n        vec3 planePos = gridFloorPos;\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.001,res);\n    }\n    \n    if( rd.y>0.)\n    {\n        vec3 planeNormal = vec3(0.,-1.,0.);\n        vec3 planePos = gridFloorPos + vec3(0.,gridSize,0.);\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.001,res);\n    }\n    else if( rd.y<0.)\n    {\n        vec3 planeNormal = vec3(0.,1.,0.);\n        vec3 planePos = gridFloorPos;\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.0001,res);\n    }\n    \n    if( rd.z>0.)\n    {\n        vec3 planeNormal = vec3(0.,0.,-1.);\n        vec3 planePos = gridFloorPos + vec3(0.,0.,gridSize);\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.001,res);\n    }\n    else if( rd.z<0.)\n    {\n        vec3 planeNormal = vec3(0.,0.,1.);\n        vec3 planePos = gridFloorPos;\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.001,res);\n    }\n    return res;\n}\n\n\nfloat map( in vec3 pos ,in vec3 rd,out vec2 uv)\n{\n    float time = mod(iTime,100.);\n    float res = 1e10;\n    vec3 gridFloor = floor(pos/gridSize);\n    \n    //if(gridFloor.z ==-3.)\n    {\n        \n    vec3 gridNoise = hash(gridFloor.xz);\n        \n\tvec3 primPos = (gridFloor*gridSize) + vec3(gridSize*0.5,0.,gridSize*0.5);\n\tprimPos.y = 0.;\n    \n\n\t//trans\n\tvec3 posLocal = (pos-primPos);\n\t//rot\n    vec3 axis = gridNoise*2.-1.;\n    axis. y = 0.;\n\t\n\tposLocal = rotate(posLocal, axis, sin(time+sin(pos.x))*0.4);\n    posLocal = rotate(posLocal, vec3(0.,1.,0.), (gridNoise.x*2.-1.)*1.5 );\n        \n\t//scale 导致dist被缩放而不正确\n    vec3 scale = vec3(gridNoise.xy*0.6+0.4,1.)*2.3;//max 2.5;\n\t//posLocal *= scale;\n\n    vec2 uvP;\n    float resP = sdBox(  posLocal, vec3(scale.xy*0.4,0.02) ,uvP );\n    if(resP<res)\n    {\n        uv = uvP;\n        vec4 color = texture(iChannel0,uv);\n        \n        if(length(color.rgb-vec3(0.05,0.61,0.15))>0.3)\n\t\t\tres = opU( res,  resP);\n    }\n    }\n    \n    /////////////////////\n    vec3 gridFloorPos = gridFloor*gridSize;\n\tfloat maxstep = maxStep( pos , rd, gridFloorPos);\n    res = min(maxstep,res);\n    return res;\n}\n\nconst float maxHei = 0.8;\n\nfloat castRay( in vec3 ro, in vec3 rd ,out vec2 uv)\n{\n    float res = -0.0;\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    //floor plane\n    float tp1 = (-1.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = tp1;\n    } \n    \n    //sky\n    tp1 = (10.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = tp1;\n    } \n    \n    // raymarch primitives   \n    {\n        tmin = 1.;\n        tmax = 30.;\n        float t = tmin;\n        for( int i=0; i<100 ; i++ )\n        {\n            if(t>=tmax) break;\n            vec2 uvT;\n            float h = map( ro+rd*t ,rd,uvT);\n            uv = uvT;\n            if( h<0.0001 )\n            { \n                //uv = uvT;\n                res = t; \n                break;\n            }\n\t\t\tt += h;\n        }\n    }\n     \n    return res;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        vec2 uv;\n\t\tfloat h = map( ro + rd*t ,rd,uv);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos , in vec3 rd)\n{\n    rd = vec3(0.,0.,0.);\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    vec2 uv;\n    return normalize( e.xyy*map( pos + e.xyy ,rd,uv) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx  ,rd,uv) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy  ,rd,uv) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx  ,rd,uv) );   \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in vec3 rd )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        vec2 uv;\n        float dd = map( aopos,rd ,uv);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) ;\n    vec2 uv;\n    \n    float res = castRay(ro,rd,uv);\n    float t = res;\n\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor =  calcNormal( pos,rd );\n        // material   \n        \n        //reflect\n        col = texture(iChannel0,uv).rgb;\n\n        // lighting\n        //float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        //dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00);//*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n        //fog\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.001*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\t\n    vec3 ro = vec3( 0., 2., 0. );\n    vec3 ta = vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    vec3 col = render( ro, rd );\n\n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n\n", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 136, 161, 161, 176], [179, 179, 222, 222, 606], [608, 608, 641, 641, 667], [669, 669, 702, 702, 731], [734, 734, 772, 772, 938], [940, 952, 997, 997, 1625], [1627, 1627, 1672, 1672, 1748], [1758, 1841, 1903, 1930, 3615], [3618, 3618, 3667, 3667, 4775], [4804, 4804, 4857, 4857, 5641], [5643, 5643, 5721, 5744, 6103], [6105, 6105, 6149, 6149, 6417], [6419, 6419, 6473, 6473, 6807], [6809, 6809, 6848, 6848, 7913], [7915, 7915, 7967, 7967, 8144], [8146, 8146, 8203, 8203, 8638]], "test": "error"}
{"id": "wssSWj", "name": "ShaderTaskmt", "author": "mmtaipov", "description": " cylinder, torus, cube,sphere,capsule", "tags": ["homework"], "likes": 1, "viewed": 39, "published": "Public", "date": "1552245597", "time_retrieved": "2021-10-01T00:00:00", "image_code": " #define MAX_STEPS 150\n#define MAX_DISTANCE 100.\n#define SURFACE_DIST 0.0084\nbool cylinder=false,cube=false; \nfloat Capsule(vec3 p,vec3 a,vec3 b,float r)\n{\n vec3 abd=b-a;\n vec3 apd=p-a;\n    float tr=dot(abd,apd)/dot(abd,abd);\n    tr=clamp(tr,0.,1.);\n    vec3 m=a+tr*abd;\n    return(length(p-m)-r);\n    \n}\nfloat  Cylinder(vec3 p,vec3 a,vec3 b,float radius)\n{\n vec3 abd=b-a;\n vec3 apd=p-a;\n    float tr=dot(abd,apd)/dot(abd,abd);\n     \n    vec3 c=a+tr*abd;\n    float x=length(p-c)-radius;\n    float y=(abs(tr-0.5)-0.5)*length(abd);\n        float e=length(max(vec2(x,y),0.));\n    return e;\n    return(length(p-c)-radius);\n    \n}\nfloat  Torus(vec3 p ,vec2 radius)\n{\n  float x=length(p.xz)-radius.x;\n  return length(vec2(x,p.y))-radius.y;\n}\nfloat dBox(vec3 p,vec3 s)\n{\n    return length(max(abs(p)-s,0.));\n    \n}\nfloat GetDistance(vec3 p)\n{\n    \n vec4 s=vec4(3,2,8,0.7);   \n float sphereDist=length(p-s.xyz)-s.w;\n float planeDist=p.y;\n float cd=Capsule(p,vec3(0,1,6),vec3(1,2,6),0.2);\n    float td=Torus(p-vec3(0.2,0.6,12),vec2(1.5,0.5));\n    float bd=dBox(p-vec3(-2.,0.5,6),vec3(.5));\n    float cyld=Cylinder(p,vec3(0,1,3),vec3(3,0.3,4),0.2);\n float d=min(cd,planeDist);\n    d=min(d,td);\n    d=min(d,bd);\n    d=min(d,sphereDist);\n    d=min(d,cyld);\n    if (d==bd)\n        cube=true;\n    if (d==cd)\n        cylinder=true;\n    return d;\n}\n \nfloat RayMarch(vec3 ro,vec3 rd)\n{\n float dO=0.; \n    for (int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p=ro+rd*dO;\n        float dS=GetDistance(p);\n        dO+=dS;\n        if(dO>MAX_DISTANCE||dS<SURFACE_DIST)\n            break;\n        \n    }\n    \n    return dO;\n    \n}\n \n \nvec3  Normal(vec3 p)\n{\n float d=GetDistance(p);\n vec2 e=vec2(0.01,0);\n vec3 n=d-vec3(\n     GetDistance(p-e.xyy),\n     GetDistance(p-e.yxy),\n     GetDistance(p-e.yyx)\n         );    \n    return normalize(n);\n}\n \nfloat GetL(vec3 p)\n{\n    vec3 lightPos=vec3(0,6,6);\n    vec3 lightPos2=vec3(3,5,17);\n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*3.;\n    vec3 l=normalize(lightPos-p);\n    vec3 l2=normalize(lightPos2-p);\n    vec3 n= Normal(p);\n    float diff,diff2;\n    if (cube==true)\n    {\n      diff=clamp(dot(n,l),0.,0.3);\n     diff2=clamp(dot(n,l2),0.,0.3);\n    }else if (cylinder==true)\n    { diff=clamp(dot(n,l),0.,0.7);\n     diff2=clamp(dot(n,l2),0.,0.7);\n    } else\n    {\n        diff=clamp(dot(n,l),0.,1.);\n     diff2=clamp(dot(n,l2),0.,1.);\n        \n    }\n    float d=RayMarch(p+n*SURFACE_DIST*2.,l);\n    float d2=RayMarch(p+n*SURFACE_DIST*2.,l2);\n    if(d<length(lightPos-p))\n    diff*=0.1;\n    if(d2<length(lightPos2-p))\n    diff2*=0.1;\n    return (diff+diff2);\n    \n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n    vec2 uv = (fragCoord-0.35*iResolution.xy)/iResolution.y;\n\n      vec3 col=vec3(0.0);\n    vec3 ro=vec3(0,0.73,0);\n     \n    vec3 rd=normalize(vec3(uv.x,uv.y,1));\n    float dd=RayMarch(ro,rd);\n     \n    vec3 p=ro+rd*dd;\n     \n    float diff=GetL(p);\n    col=vec3(diff);\n    \n    \n    \n     \n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 155, 155, 304], [305, 305, 357, 357, 625], [626, 626, 661, 661, 735], [736, 736, 763, 763, 807], [808, 808, 835, 835, 1332], [1335, 1335, 1368, 1368, 1603], [1608, 1608, 1630, 1630, 1816], [1819, 1819, 1839, 1839, 2583], [2586, 2586, 2643, 2643, 2972]], "test": "valid"}
{"id": "WsSSWR", "name": "Hypno Ball", "author": "kubiak", "description": "Just a hypnotizing ball of green.", "tags": ["noise", "ball", "scary", "spooky", "hypnotize"], "likes": 5, "viewed": 444, "published": "Public API", "date": "1553311941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 calcNormal(vec2 center, vec2 pos, float radius) {\n    vec2 rpos = pos - center;\n    rpos = rpos / radius;\n    float z = sqrt(1.0 - rpos.x*rpos.x + rpos.y*rpos.y);\n    \n    return -vec3(rpos.x, rpos.y, z);\n}\n\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nbool intersectsBall(\n    vec2 p2, \n    vec2 center, \n    float radius, \n    float noiseAmp,\n    float noiseFreq,\n    float edgeWidth,\n    out float edginess) {\n    \n    float n = noise(p2 * noiseFreq + iTime) * noiseAmp;\n    radius += n;\n    vec2 to = p2 - center;\n    float l = length(to);\n    edginess = 0.0;\n    \n    if(l < radius && l > (radius - edgeWidth)) {\n        edginess = 1.0 - (radius - l) / edgeWidth;\n    }\n    return l < radius;\n}\n\n#define STEPS 20.0\n#define STEP (1.0 / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tp = p;\n    \n    vec2 p2 = p * 1.0;\n    float aspect = iResolution.x / iResolution.y;\n\tp2.x *= aspect;\n    p2.y = 1.0 - p2.y;\n    \n    float radius = 0.45;\n    vec2 center = vec2(0.5 * aspect, 0.5);    \n    \n    vec4 col;    \n    vec3 normal = calcNormal(center, p2, radius);\n\n    \n    float edginess = 0.0;\n    if(intersectsBall(p2, center, radius, 0.015, 5.0, 0.1, edginess)) {\n     \n        float e = edginess;\n        \n        col = mix(vec4(0.6, 1.0, 0.6, 1.0), vec4(0.0, 0.0, 0.0, 0.0), e);\n        \n        vec4 edgeColor = vec4(0.95, 1.0, 0.75, 1.0);\n        \n        \n        for(float i = 1.0; i < 25.0; i+= 1.0) {\n            \n            radius *= 0.9;\n            if(intersectsBall(p2, center, radius, 0.0325, 8.0, 0.01, edginess)) {\n                float e = edginess * edginess;\n                col = mix(vec4(STEP*i*0.135, STEP*i, STEP*i*0.1235, 1.0), edgeColor, e);\n            }\n        }\n        \n    }\n    else \n    {        \n        col = vec4(0.0);\n    }\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 211], [214, 214, 235, 235, 348], [351, 351, 377, 377, 901], [903, 903, 1062, 1062, 1349], [1398, 1398, 1455, 1455, 2521]], "test": "valid"}
{"id": "WssXDj", "name": "Tuto006 Rotating Gear", "author": "arthurstammet", "description": "Rotating Gear\nmy step by step tutorial 6\nby Arthur Stammet, 03.2019\nInspired by Inigo Quilez https://www.youtube.com/watch?v=0ifChJ0nJfM&t=7s", "tags": ["tutorial", "animation", "cosine", "gear", "modulation"], "likes": 2, "viewed": 266, "published": "Public API", "date": "1552249320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rotating Gear\n// my step by step tutorial 6\n// by Arthur Stammet, 03.2019\n\n// Inspired by Inigo Quilez https://www.youtube.com/watch?v=0ifChJ0nJfM&t=7s\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set the center to the middle of the screen and make the pixels quadratic\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y; \n\n    // change values here --------------------------------------------------------------\n\n    float CenterX = 0.0;\n\tfloat CenterY = 0.0;\n\n    float radius = 0.4; // radius of the disk ( 0.5 = height of the screen ) \n    float blur = 0.015; // low values for sharper edges\n    \n    // Color of the Gear\n    float red = 0.8; \t// 0.0 <> 1.0\n\tfloat green = 0.8;\t// 0.0 <> 1.0\n\tfloat blue = 0.8; \t// 0.0 <> 1.0\n\n    // Background-Color\n    float Bred = 0.0; \t// 0.0 <> 1.0\n\tfloat Bgreen = 0.0;\t// 0.0 <> 1.0\n\tfloat Bblue = 0.0; \t// 0.0 <> 1.0\n    \n    float rotSpeed = iTime * 10.;\n    float modAmp = 0.04; \t\t// amplitude of the cosine modulation\n    float modFreq = 25.; \t\t// frequency = number of cosine cycles\n    float modPhase = rotSpeed; \t// phase of the cosine modulation\n    float modDist = 0.; \t\t// distortion\n    \n    // ---------------------------------------------------------------------------------\n    \n\tvec2 CenterXY = p - vec2( CenterX, CenterY );\t// center of the disk\n    \n\tradius += modAmp * cos(atan(CenterXY.x,CenterXY.y) * modFreq + modDist * CenterXY.x + modPhase);\n    \n    vec3 disk = vec3( red, green, blue ); // colorized disk (animated)\t\n\tvec3 back = vec3 ( Bred, Bgreen, Bblue );  // colorized screen (animated)\n    disk *= smoothstep( radius, radius-blur, length(CenterXY)); // moving disk (animated)\n    vec3 col = disk + back;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 156, 213, 293, 1747]], "test": "valid"}
{"id": "WssXDl", "name": "Main Building of MSU in fog", "author": "Nikita_Pimenov", "description": "Home work", "tags": ["mashgraph"], "likes": 2, "viewed": 85, "published": "Public", "date": "1552553732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 1000.0\n#define SMALL_DIST 0.01\n\nfloat DistSquare(vec3 p, vec4 square) {\n    float Dx, Dy, Dz;\n    if (p.x - square.x <= square.w) {\n        if (p.x - square.x >= -square.w) {\n            Dx = 0.0;\n        } else {\n            Dx = square.x - square.w - p.x;\n        }\n    } else {\n        Dx = p.x - square.x - square.w;\n    }\n    if (p.y - square.y <= square.w) {\n        if (p.y - square.y >= -square.w) {\n            Dy = 0.0;\n        } else {\n            Dy = square.y - square.w - p.y;\n        }\n    } else {\n        Dy = p.y - square.y - square.w;\n    }\n    if (p.z - square.z <= square.w) {\n        if (p.z - square.z >= -square.w) {\n            Dz = 0.0;\n        } else {\n            Dz = square.z - square.w - p.z;\n        }\n    } else {\n        Dz = p.z - square.z - square.w;\n    }\n    return sqrt(Dx * Dx+ Dy * Dy + Dz * Dz);\n}\nfloat DistRectangle(vec3 p, vec3 rectangle, vec3 size) {\n    float Dx, Dy, Dz;\n    if (p.x - rectangle.x <= size.x) {\n        if (p.x - rectangle.x >= -size.x) {\n            Dx = 0.0;\n        } else {\n            Dx = rectangle.x - size.x - p.x;\n        }\n    } else {\n        Dx = p.x - rectangle.x - size.x;\n    }\n    if (p.y - rectangle.y <= size.y) {\n        if (p.y - rectangle.y >= -size.y) {\n            Dy = 0.0;\n        } else {\n            Dy = rectangle.y - size.y - p.y;\n        }\n    } else {\n        Dy = p.y - rectangle.y - size.y;\n    }\n    if (p.z - rectangle.z <= size.z) {\n        if (p.z - rectangle.z >= -size.z) {\n            Dz = 0.0;\n        } else {\n            Dz = rectangle.z - size.z - p.z;\n        }\n    } else {\n        Dz = p.z - rectangle.z - size.z;\n    }\n    return sqrt(Dx * Dx + Dy * Dy + Dz * Dz);\n}\nfloat DistSphere(vec3 p, vec4 sphere) {\n    return length(p - sphere.xyz) - sphere.w;\n}\nfloat DistTorus(vec3 p, vec3 torus, vec2 size) {\n    vec3 v = torus - p;\n    vec2 q = vec2(length(v.xz) - size.x, v.y);\n\treturn length(q) - size.y;\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 torus1 = vec3(3.0, 0.4, 8.0);\n    vec2 SizeTorus1 = vec2(1.0, 0.1);\n    vec3 torus2 = vec3(-3.0, 0.4, 8.0);\n    vec2 SizeTorus2 = vec2(1.0, 0.1);\n    \n    vec4 sphere0 = vec4(0.0, 0.7, 7.0, 0.5); //sphere, which is forward\n    sphere0.xz += vec2(sin(4.0 * iTime), 4.0 * cos(iTime)); \n    \n    vec4 sphere1 = vec4(0.0, 11.0, 15.0, 0.3);//Main building of Moscow State University\n    vec3 rectangle1 = vec3(0.0, 2.4, 15);\n    vec3 SizeRectangle1 = vec3(1.2, 2.4, 1.2);\n    vec4 square2 = vec4(0.0, 5.6, 15.0, 0.9);\n    vec4 square3 = vec4(0.0, 7.2, 15.0, 0.7);\n    vec3 rectangle2 = vec3(0.0, 9.3, 15.0);\n    vec3 SizeRectangle2 = vec3(0.2, 1.4, 0.2);\n    \n    vec3 rectangle3 = vec3(2.6, 1.2, 15.0);\n    vec3 SizeRectangle3 = vec3(1.3, 1.2, 1.0);\n    vec3 rectangle4 = vec3(4.5, 1.2, 15.0);\n    vec3 SizeRectangle4 = vec3(0.6, 1.2, 3.6);\n    vec4 square4 = vec4(4.5, 2.9, 12.0, 0.5);\n    vec4 sphere2 = vec4(4.5, 3.7, 12.0, 0.3);\n    vec4 square5 = vec4(4.5, 2.9, 18.0, 0.5);\n    vec4 sphere3 = vec4(4.5, 3.7, 18.0, 0.3);\n    \n    vec3 rectangle5 = vec3(-2.6, 1.2, 15.0);\n    vec3 SizeRectangle5 = vec3(1.3, 1.2, 1.0);\n    vec3 rectangle6 = vec3(-4.5, 1.2, 15.0);\n    vec3 SizeRectangle6 = vec3(0.6, 1.2, 3.6);\n    vec4 square6 = vec4(-4.5, 2.9, 12.0, 0.5);\n    vec4 sphere4 = vec4(-4.5, 3.7, 12.0, 0.3);\n    vec4 square7 = vec4(-4.5, 2.9, 18.0, 0.5);\n    vec4 sphere5 = vec4(-4.5, 3.7, 18.0, 0.3);\n    float DistPlane = p.y;\n    float Torus = min(DistTorus(p, torus1, SizeTorus1),\n                    DistTorus(p, torus2, SizeTorus2));\n    float Sphere = min(DistSphere(p, sphere1),\n                   min(DistSphere(p, sphere2),\n                   min(DistSphere(p, sphere3),\n                   min(DistSphere(p, sphere4),\n                   min(DistSphere(p, sphere5),\n                   DistSphere(p, sphere0))))));\n    float Square = min(DistSquare(p, square2),\n                   min(DistSquare(p, square3),\n                   min(DistSquare(p, square4),\n                   min(DistSquare(p, square5),\n                   min(DistSquare(p, square6),\n                   DistSquare(p, square7))))));\n    float Rectangle = min(DistRectangle(p, rectangle1, SizeRectangle1),\n                      min(DistRectangle(p, rectangle2, SizeRectangle2),\n                      min(DistRectangle(p, rectangle3, SizeRectangle3),\n                      min(DistRectangle(p, rectangle4, SizeRectangle4),\n                      min(DistRectangle(p, rectangle5, SizeRectangle5),\n                      DistRectangle(p, rectangle6, SizeRectangle6))))));\n    float minimum = min(Torus, min(Sphere,\n                    min(Square, min(Square, \n                    min(Rectangle, DistPlane)))));\n    if (minimum == Torus) {\n        return vec4(0.0, 0.0, 1.0, Torus);\n    }\n    if (minimum == Sphere) {\n        return vec4(1.0, 1.0, 0.0, Sphere);\n    }\n    if (minimum == Square) {\n        return vec4(1.0, 1.0, 1.0, Square);\n    }\n    if (minimum == Rectangle) {\n        return vec4(1.0, 0.0, 0.0, Rectangle);\n    }\n    if (minimum == DistPlane) {\n        return vec4(0.2, 0.817, 0.2, DistPlane);\n    }\n    return vec4(MAX_DIST, 0.0, 0.0, 0.0);\n}\nfloat RayMarch (vec3 RayOri, vec3 RayDi) {\n    float DistOrig = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = RayOri + DistOrig * RayDi;\n        float dist = GetDist(p).w;\n        DistOrig += dist;\n        if (dist < SMALL_DIST || DistOrig > MAX_DIST) break;\n    }\n    return DistOrig;\n}\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    float d = GetDist(p).w;\n    vec3 norm = d - vec3(\n        GetDist(p - e.xyy).w,\n        GetDist(p - e.yxy).w,\n        GetDist(p - e.yyx).w);\n    \n    return normalize(norm); \n}\nvec3 GetColour(vec3 p) {\n    vec3 LightPos[2];\n    LightPos[0] = vec3(0, 15, 12);\n    LightPos[1] = vec3(0, 15, 12);\n    LightPos[0].xz += vec2(sin(iTime), cos(iTime)) * 8.0;\n    LightPos[1].xz += vec2(sin(iTime + 3.14 * 0.2), cos(iTime + 3.14 * 0.2)) * 8.0;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 2; ++i) {\n        vec3 LightDi = normalize(LightPos[i] - p);\n        vec3 norm = GetNormal(p);\n        vec3 e = normalize(-p);\n        vec3 refl = normalize(-reflect(LightDi, norm));\n        \n        vec3 amb = GetDist(p).xyz * 0.3;\n        vec3 dif = amb * 0.8 * max(dot(norm, LightDi), 0.0);\n        dif = clamp(dif, 0.0, 1.0);\n        vec3 spec = vec3(1.0) * pow(max(dot(refl, e), 0.0), 60.0);\n        spec = clamp(spec, 0.0, 1.0);\n        col += 0.5 * (amb + dif + spec);\n    }\n    float light = 1.0;\n    float d = RayMarch(p + GetNormal(p) * SMALL_DIST * 2.0, normalize(LightPos[0] - p));\n    if (d < length(LightPos[0] - p)) {\n        col *= 0.7;\n    }\n    d = RayMarch(p + GetNormal(p) * SMALL_DIST * 2.0, normalize(LightPos[1] - p));\n    if (d < length(LightPos[1] - p)) {\n        col *= 0.7;\n    }\n    float fog = clamp(length(p) / 15.5, 0.0, 1.0); \n\tcol = col * (1.0 - fog) + fog * vec3(0.7, 0.7, 0.7);\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(1.0, 1.0, 0.0);\n    \n    vec3 RayOri = vec3(0, 1, 0);\n    uv.y = uv.y + 0.2;\n    vec3 RayDi = normalize(vec3(uv.x, uv.y, 1));\n    float d = RayMarch(RayOri, RayDi);\n    vec3 p = RayOri + RayDi * d;\n    col = GetColour(p);\n    \n    float red;\n    float green;\n\t/*if (d > MAX_DIST) {\n        red = -1.0 * uv.y + 1.0;\n        green = -0.35 * uv.y + 1.0;\n        col = vec3(red, green, 1.0);\n    }*/\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 111, 111, 879], [880, 880, 936, 936, 1717], [1718, 1718, 1757, 1757, 1805], [1806, 1806, 1854, 1854, 1955], [1957, 1957, 1979, 1979, 5113], [5114, 5114, 5156, 5156, 5419], [5420, 5420, 5444, 5444, 5653], [5654, 5654, 5678, 5678, 6893], [6894, 6894, 6949, 6949, 7470]], "test": "valid"}
{"id": "wssXDM", "name": "Glass Distortion Ball", "author": "kubiak", "description": "Magnifying and distorting to give a weird glass effect.", "tags": ["magnification", "distorition"], "likes": 12, "viewed": 239, "published": "Public", "date": "1551482762", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 calcNormal(vec2 center, vec2 pos, float radius) {\n    vec2 rpos = pos - center;\n    rpos = rpos / radius;\n    float z = sqrt(1.0 - rpos.x*rpos.x + rpos.y*rpos.y);\n    \n    return -vec3(rpos.x, rpos.y, z);\n}\n\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nvec4 quatForAxisAngle(float angle, vec3 axis) {\n    vec4 q;\n    \n    float half_angle = angle/2.0;\n    q.x = axis.x * sin(half_angle);\n    q.y = axis.y * sin(half_angle);\n    q.z = axis.z * sin(half_angle);\n    q.w = cos(half_angle);\n    return q;\n}\n\nbool intersectsBall(vec2 p2, vec2 center, float radius, out float edginess) {\n    float n = noise(p2 * 5.0 + iTime) * 0.015;\n    radius += n;\n    vec2 to = p2 - center;\n    float l = length(to);\n    edginess = 0.0;\n    \n    float edgeWidth = 0.05;\n    if(l < radius && l > (radius - edgeWidth)) {\n        edginess = 1.0 - (radius - l) / edgeWidth;\n    }\n    return l < radius;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tp = p;\n    \n    vec2 p2 = p * 1.0;\n    float aspect = iResolution.x / iResolution.y;\n\tp2.x *= aspect;\n    p2.y = 1.0 - p2.y;\n    \n    float s = sin(iTime)*0.5 + 0.5 * aspect;\n    //s = 1.0;\n    \n    vec2 center = vec2(s, 0.5);\n    float radius = 0.25;\n    \n    vec4 col;\n    \n    vec3 normal = calcNormal(center, p2, radius);\n    \n    // Rotation\n    vec4 q = quatForAxisAngle(0.0, vec3(0.0, 1.0, 0.0));\n    vec3 temp = cross(q.xyz, normal) + q.w * normal;\n    normal = normal + 2.0*cross(q.xyz, temp);\n    \n    float edginess = 0.0;\n    if(!intersectsBall(p2, center, radius, edginess)) {\n     \n        col = vec4(0.0);\n        col = texture(iChannel0, p);\n    }\n    else \n    {\n        vec3 r = reflect(vec3(0.0, 0.0, 1.0), normalize(normal));\n        //r = normal;\n        vec3 t = (r * 0.5 + 0.5) * 0.5;\n        \n        t += noise(t.xy * 10.0 + iTime) * 0.05;\n        t.x -= s;\n        col = texture(iChannel0, t.xy);\n        \n        // Brighten\n        col = col * (1.5) + vec4(edginess * edginess);\n        //col = vec4(vec3(t.x), 1.0);\n\t\t//col = vec4(normal, 1.0);\n    }\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 211], [214, 214, 235, 235, 348], [351, 351, 377, 377, 901], [903, 903, 950, 950, 1152], [1154, 1154, 1231, 1231, 1532], [1535, 1535, 1592, 1592, 2762]], "test": "error"}
{"id": "wsSXDz", "name": "Colorful Tiles", "author": "OliverSchaff", "description": "I tried to reproduce the look of this shader: https://www.shadertoy.com/view/lssGR7", "tags": ["warp", "valuenoise", "tiles"], "likes": 6, "viewed": 167, "published": "Public", "date": "1553438625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415927\n#define numOfTilesY 5.0\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat vnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash22(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( hash22(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( hash22(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 hsvToRgb(float h, float s, float v) \n{\n    return v* (1. + s * ( cos(2.*PI * (h + vec3(3,2,1)/3.) ) - .5));\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy,\n    // prepare uv to be tiled later\n        uv = numOfTilesY * U/R.y;\n\t\n    // aa is for antialiasing\n    // noise adds a distortion to the uv plane\n    float aa = numOfTilesY * 1.5 / min(R.x, R.y),\n       noise = 2.*PI* vnoise(.5*uv + .05*iTime);\n    // add noise \n    uv += .15 * vec2(cos(noise), sin(noise));\n    \n    // tile the uv plane\n    // fuv is the coordinate within each tile\n    // iuv is the index of the tile\n    // cshift is used for shifting the color effects, depending on tile index\n    // c is the white grid\n    vec2 fuv = fract(uv) - .5,\n         iuv = floor(uv),\n      cshift = .1*hash22(iuv*10.),\n           c = smoothstep( .48-aa, .51, abs(fuv) );\n    \n    // the effect looks better when applied after a 45° rotation\n    // rotate the fuv plane of each tile by 45°\n    fuv *= mat2(1,1,-1,1)/sqrt(2.);\n    \n    // time is distorted with the position within the tile\n    // this adds the curvature on the colored segments\n    // h,s,v are hue saturation and value of the color in the tile\n    // first h,s,v are set to values that depend on position and time\n    float time = -.2*iTime + 2.*length(fuv),\n          h = length(2.*fuv.x+cshift) + length(2.*fuv.y)        + time,\n          s = length(2.*fuv.x)        + length(1.*fuv.y+cshift) + 2.*time,\n          v = length(1.*fuv.x-cshift) + length(1.*fuv.y+cshift) + time;\n\n    // generate a color based on the value-noise of the h,s,v values defined above\n    // plus vary the hue with time\n    // then add the white grid that was defined above\n    O.rgb = hsvToRgb( 2.*vnoise(.6*h+5.*iuv) +sin(.5*iTime),\n                      3.*vnoise(.4*s+3.*iuv) +.2,\n                      2.*vnoise(   v+   iuv) +.6)\n            + c.x + c.y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 258, 279, 279, 398], [400, 482, 505, 505, 905], [907, 907, 950, 950, 1021], [1023, 1023, 1061, 1111, 2850]], "test": "valid"}
{"id": "wssXR2", "name": "Midterms_Co_Design10", "author": "johannco98", "description": "asd", "tags": ["asd"], "likes": 1, "viewed": 36, "published": "Public", "date": "1551718621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 mouse = iMouse.xyz/iResolution.xyz;\n    \n    vec2 xy = fragCoord.xy;\n    xy.x = xy.x/iResolution.x;\n    xy.y = xy.y/iResolution.y;\n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    col.r = xy.x;\n    col.g = xy.x;\n    col.b = xy.x;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float value = uv.x;\n    value = 0.5;\n    \n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    vec2 pos = vec2(0.5*ratio, 0.5);\n    \n    \n    uv *= 3.0;\n    \n    uv = fract(uv);\n\n     uv -= pos ;\n    uv += pos;\n    \n    \n    //x \n    float valx = uv.x;\n    valx = fract(sin(abs(uv.x * 3.0)));\n    vec3 mCol2 = vec3(sin(valx * iTime * 4.0) * 0.5,\n                     sin(valx * iTime * 8.0) * 0.8, \n                     (sin(valx * iTime) * 6.0) + 0.0);\n    \n    //y \n    float valy = uv.y;\n    valy = fract(sin(abs(uv.y * 3.0)));\n    vec3 mCol3 = vec3(sin(valy * iTime * 4.0) * 0.5,\n                     sin(valy * iTime * 8.0) * 0.1, \n                     (sin(valy * iTime) * 6.0) + 0.0);\n    \n    \n    fragColor = vec4(mCol2 * mCol3, 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssXR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1110]], "test": "valid"}
{"id": "wssXWB", "name": "Nostalgia 2 da bone", "author": "deuZige", "description": "Let loose my nostalgia kick on some stuff other people created here on shadertoy!", "tags": ["oldschool", "stuff", "scroller"], "likes": 2, "viewed": 294, "published": "Public", "date": "1552092427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nMy first working shader thingy! \nRipped, eerm, loaded or re-used some stuff from other people here on shadertoy:\nLighting stuff: https://www.shadertoy.com/view/MdGXWG by Shane\nOriginal tentative of glenz: https://www.shadertoy.com/view/ldlSW2 by rix\nFonts: https://www.shadertoy.com/view/4s3XDn by Andre\n\n*/\n\nvec3 cubevec;\nvec2 coord;\n\n#define scrolltext BOLD d_ e_ u_ Z_ i_ g_ e_  _ p_ r_ e_ s_ e_ n_ t_ s_  _ _exclam _exclam  _ A_ n_ o_ t_ h_ e_ r_  _ o_ n_ e_  _ o_ f_  _ h_ i_ s_  _ n_ o_ s_ t_ a_ l_ g_ i_ a_  _ i_ n_ s_ p_ i_ r_ e_ d_  _ w_ a_ s_ t_ e_ s_  _ o_ f_  _ t_ i_ m_ e_  _\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat bb(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n    float x = _o(uv);\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right \n                        length(uv+vec2(-.22734,-.254)));\n}\nfloat dd(vec2 uv) {\n    uv.x *= -1.;\n    return bb(uv);\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ff(vec2 uv) {\n    uv.x *= -1.;\n    uv.x += .05;\n    float x = _j(vec2(uv.x,-uv.y));\n    uv.y -= .4;\n    x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = _o(uv);\n    return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n               _u(uv,0.25,-0.2):\n               length(uv+vec2(.23,.7)));\n}\nfloat hh(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x += .25;\n    uv.y *= -1.;\n    return min(x,_l(uv));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.6)));\n}\nfloat jj(vec2 uv) {\n    uv.x+=.05;\n    return min(_j(uv),length(vec2(uv.x-.05,uv.y-.6)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n    return _l(uv);\n}\nfloat mm(vec2 uv) {\n    //uv.x *= 1.4;\n    uv.y *= -1.;\n    uv.x-=.175;\n    float x = _u(uv,.175,.175);\n    uv.x+=.35;\n    x = min(x,_u(uv,.175,.175));\n    uv.x+=.175;\n    return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n    return _o(uv);\n}\nfloat pp(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    uv.y += .4;\n    return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n    uv.x = -uv.x;\n    return pp(uv);\n}\nfloat rr(vec2 uv) {\n    uv.x -= .05;\n    float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n    \n    //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n    \n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n    if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    float b = length(vec2(uv.x-.231505,uv.y-.284));\n    float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b;\n    return x;\n}\nfloat tt(vec2 uv) {\n    uv.x *= -1.;\n    uv.y -= .4;\n    uv.x += .05;\n    float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat uu(vec2 uv) {\n    return _u(uv,.25,.25);\n}\nfloat vv(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.4), vec2(0.,-0.4));\n}\nfloat ww(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.1)));\n}\nfloat xx(vec2 uv) {\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.4));\n}\nfloat yy(vec2 uv) {\n    return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)),\n               line(uv,vec2(.3,.4), vec2(-.3,-0.8)));\n}\nfloat zz(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4));\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4));\n    return min(x,l);\n}\n\n// Capitals\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat BB(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.25))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat CC(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n    uv.y -=.1;\n    //uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                max(0.0,abs(uv.y)-.25)))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n    uv.y -=.1;\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat GG(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    float a = atan(uv.x,max(0.,abs(uv.y)-0.25));\n    x = uv.x<0.||a<1.14 || a>3.?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n    x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354)));\n    return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1)));\n}\nfloat HH(vec2 uv) {\n    uv.y -=.1;\n    uv.x = abs(uv.x);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y));\n    return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat JJ(vec2 uv) {\n    uv.x += .125;\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,max(-uv.x,uv.y-.6))));\n    return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6)));\n}\nfloat KK(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6));\n    x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4)));\n//    uv.x+=.25;\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5))));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat OO(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\nfloat PP(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n}\nfloat QQ(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y += .3;\n    uv.x -= .2;\n    return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.));\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat SS(vec2 uv) {\n    uv.y -= .1;\n    if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n    float b = length(vec2(uv.x-.236,uv.y-.332));\n    float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n    return x;\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\nfloat WW(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n    uv.y -= .1;\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\nfloat YY(vec2 uv) {\n    return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)),\n                   line(uv,vec2(.0, .1), vec2( .3, 0.6))),\n                   length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25))));\n}\nfloat ZZ(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4));\n    uv.y-=.1;\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5));\n    return min(x,l);\n}\n\nfloat _11(vec2 uv) {\n    return min(min(\n             line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n             \n}\nfloat _22(vec2 uv) {\n    float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n//Symbols\nfloat ddot(vec2 uv) {\n    uv.y+=.4;\n    return length(uv)*0.97;//-.03;\n}\nfloat comma(vec2 uv) {\n    return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52)));\n}\nfloat exclam(vec2 uv) {\n    return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06);\n}\nfloat question(vec2 uv) {\n    float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125))));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275):\n               length(uv+vec2(.225,-.16))-.0);\n}\nfloat open1(vec2 uv) {\n    uv.x-=.62;\n    return abs(atan(uv.x,uv.y)+1.57)<1.?\n            abs(length(uv)-.8)\n           :length(vec2(uv.x+.435,abs(uv.y)-.672));\n}\nfloat close1(vec2 uv) {\n    uv.x = -uv.x;\n    return open1(uv);\n}\nfloat dotdot(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return length(uv);\n}\nfloat dotcomma(vec2 uv) {\n    uv.y -= .1;\n    float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32));\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return min(length(uv),x);\n}\nfloat eequal(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15));\n}\nfloat aadd(vec2 uv) {\n    uv.y -= .1;\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n               length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ssub(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\nfloat mmul(vec2 uv) {\n    uv.y -= .1;\n    uv = abs(uv);\n    return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.))\n              ,length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ddiv(vec2 uv) {\n    return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat lt(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    return line(uv,vec2(0.25,0.25),vec2(-0.25,0.));\n}\nfloat gt(vec2 uv) {\n    uv.x=-uv.x;\n    return lt(uv);\n}\nfloat hash(vec2 uv) {\n    uv.y-=.1;\n    uv.x -= uv.y*.1;\n    uv = abs(uv);\n    return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.3))),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125)));\n}\nfloat and(vec2 uv) {\n    uv.y-=.44;\n    uv.x+=.05;\n    float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0;\n    x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712)));\n    x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397)));\n    uv.x-=.025;\n    uv.y+=.54;\n    x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0);\n    return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177)));\n}\nfloat or(vec2 uv) {\n    uv.y -= .1;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n}\nfloat und(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4));\n}\nfloat open2(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))),\n               length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5)));\n}\nfloat close2(vec2 uv) {\n    uv.x=-uv.x;\n    return open2(uv);\n}\nfloat open3(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2((uv.x*sign(uv.y-.25)-.2),\n                            max(0.0,abs(uv.y-.25)-.05) ))-0.2)\n               ,max(0.,abs(uv.x)-.2)));\n    return  x;\n    \n}\nfloat close3(vec2 uv) {\n    uv.x=-uv.x;\n    return open3(uv);\n}\n\nvec2 clc(vec2 uv, float cp, float w, float ital) {\n    return uv-vec2(cp-(w*.5)+uv.y*ital,0.);\n}\nbool hit(vec2 uv,inout float cp,float w, float px) {\n    return abs((cp+=w)-uv.x)<w+.2;\n}\n\n#define ch(l,w) if (hit(uv,cp,w,px)) { x=min(x,l(clc(uv,cp,w,ital))); us=cur;}\n#define a_ ch(aa,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n#define _ cp+=.5;\n#define BOLD cur.w = 1.5-cur.w;\n#define ITAL ital = 0.15-ital;\n#define RED cur.r = 0.8-cur.r;\n#define GREEN cur.g = 0.6-cur.g;\n#define BLUE cur.b = 1.0-cur.b;\n#define crlf uv.y += 2.0; cp = 0.;\n\n// the test scroller\nvec3 Scroller(vec2 fragCoord )\n{\n    float ms = float(iMouse.w>0.);\n    float scale = 1.5;\n    vec2 mouseOffs = vec2(0);\n\tvec2 uv = (fragCoord+mouseOffs-.5*iResolution.xy) / iResolution.x * 22.0 * scale;\n    uv.x+=8.*iTime;\n    uv.x-=290.;\n    uv.y-=0.55;\n    uv.x=mod(uv.x,150.)-30.;\n  \n    float px = 22.0/iResolution.x*scale;\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0.,0.,0.,0.5);\n    vec4 us = cur;\n    float ital = 0.0;\n    uv.x += 10.1;\n\n    uv.x=uv.x+0.5*sin(uv.y+2.*iTime);\n    uv.y = mod(uv.y,2.0)-1.;\n    scrolltext\n    float weight  = 0.05;\n    return vec3(mix(us.rgb,vec3(0.5),smoothstep(weight-px,weight+px, x)));\n}\n\n\n// Sinus bars function\nvec3 calcSine(vec2 uv, float frequency, float amplitude, float shift, float offset, vec3 color, float width, float exponent)\n{\n    float y = sin(iTime * frequency + shift + uv.x) * amplitude + offset;\n    float d = distance(y, uv.y);\n    float scale = smoothstep(width, 0.0, distance(y, uv.y));\n    return color * scale;\n}\n\n// Render the bars calling 3 CalcSines() and adding rgb componants\nvec3 Bars(vec2 f)\n{\n    vec2 uv = f / iResolution.xy;\n    vec3 color = vec3(0.0);\n    color += calcSine(uv, 2.0, 0.25, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.10, 3.0);\n    color += calcSine(uv, 2.6, 0.15, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.10, 1.0);\n    color += calcSine(uv, 0.9, 0.35, 0.4, 0.5, vec3(1.0, 0.0, 0.0), 0.10, 1.0);\n    return color;\n}\n\n// Classic iq twist function\nvec3 Twist(vec3 p)\n{\n    float f = sin(iTime/3.)*1.45;\n    float c = cos(f*p.y);\n    float s = sin(f/2.*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// The distance function which generate a rotating twisted rounded cube \n// and we save its pos into cubevec\nfloat Cube( vec3 p )\n{\n    p=Twist(p);\n    cubevec.x = sin(iTime);\n    cubevec.y = cos(iTime);\n    mat2 m = mat2( cubevec.y, -cubevec.x, cubevec.x, cubevec.y );\n    p.xy *= m;p.xy *= m;p.yz *= m;p.zx *= m;p.zx *= m;p.zx *= m;\n    cubevec = p;\n    return length(max(abs(p)-vec3(0.8),0.0))-0.08;\n}\n\n// Split the face in 4 triangles zones\n// return color index 0 or 1 if color1 or color2\nfloat Face( vec2 uv )\n{\n        uv.y = mod( uv.y, 1.0 );\n        return ( ( uv.y < uv.x ) != ( 1.0 - uv.y < uv.x ) ) ? 1.0 : 0.0;\n}\n\n//Classic iq normal\nvec3 getNormal( in vec3 p )\n{\n    vec2 e = vec2(0.005, -0.005);\n    return normalize(\n        e.xyy * Cube(p + e.xyy) +\n        e.yyx * Cube(p + e.yyx) +\n        e.yxy * Cube(p + e.yxy) +\n        e.xxx * Cube(p + e.xxx));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x;\n    float pat = iTime*5.0;\n    float Step = 1.0;\n    float Distance = 0.0;\n    float Near = -1.0;\n    float Far = -1.0;\n    vec3 lightPos = vec3(1.5, 0, 0);\n    vec2 kp = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*kp;\n    vec4 m = iMouse / iResolution.xxxx;\n    float hd=-1.;\n    float ay=0.1;\n      \n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 2.1 );\n    vec3 rd = normalize( vec3( p, -2. ) );\n    for( int i = 0; i < 256; i++ )\n        {\n        \tStep = Cube( ro + rd*Distance );\n            Distance += Step*.5;\n\n            if( Distance > 4.0 ) break;\n            if( Step < 0.001 )\n            \t{\n                 \tFar = Face( cubevec.yx ) + Face( -cubevec.yx ) + Face( cubevec.xz ) + Face( -cubevec.xz ) + Face( cubevec.zy ) + Face( -cubevec.zy );\n            \t\tif(hd<0.) hd=Distance;\n                    if( Near < 0.0 ) Near = Far;\n            \t\tif(m.z<=0.0) Distance += 0.05; else break;\n                }\n        }\n\n    vec3 Color=Bars(fragCoord);\n    \n    if( Near > 0.0 )\n    \t{\n            vec3 sp = ro + rd*hd;\n        \tvec3 ld = lightPos - sp;\n            float lDist = max(length(ld), 0.001);\n            ld /= lDist;\n            float atten = 1./(1. + lDist*.2 + lDist*.1); \n            float ambience = 0.7;\n            vec3 sn = getNormal( sp);\n            float diff = min(0.3,max( dot(sn, ld), 0.0));\n            float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n            \n            if(m.z<=0.) Color = Color/5. + mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            else Color = mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            Color = Color*(diff+ambience)+vec3(0.78,0.5,1.)*spec/1.5;\n        }\n\n    vec3 rainbow = vec3(0.5 + 0.5 * sin(kp.x*8. + 3.14 + pat), 0.5 + 0.5 * cos (kp.x*8. + pat), 0.5 + 0.5 * sin (kp.x*8. + pat));\n    if (kp.y > ay && kp.y < ay+0.006 || kp.y > (1.-ay) && kp.y < 1.-ay+0.006 ) Color = rainbow;\n    if(kp.y>1.-ay+0.006 || kp.y<0.1) Color=vec3(0.20,0.17,0.35);\n    \n    if(kp.y<=ay)\n    \t{\n        vec3 cc = Scroller(fragCoord);\n        if(cc!=vec3(0.5)) Color=rainbow;\n        }\n    \n    \n    // Presenting color to the screen\n    fragColor = vec4( Color, 1.0 );\n}", "image_inputs": [{"id": "MtfGDN", "previewfilepath": "https://soundcloud.com/deuzige/lala", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/deuzige/lala", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssXWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 593, 629, 629, 754], [756, 806, 843, 843, 1002], [1003, 1003, 1022, 1022, 1076], [1077, 1077, 1096, 1096, 1327], [1328, 1328, 1347, 1347, 1417], [1418, 1418, 1437, 1437, 1501], [1503, 1527, 1546, 1546, 1796], [1797, 1797, 1816, 1816, 1883], [1884, 1884, 1903, 1903, 2142], [2143, 2143, 2162, 2162, 2200], [2201, 2201, 2220, 2220, 2403], [2404, 2404, 2423, 2423, 2586], [2587, 2587, 2606, 2606, 2754], [2755, 2755, 2774, 2774, 2883], [2884, 2884, 2903, 2903, 2956], [2957, 2957, 2976, 2976, 3048], [3049, 3049, 3068, 3068, 3222], [3223, 3223, 3242, 3242, 3263], [3264, 3264, 3283, 3302, 3459], [3460, 3460, 3479, 3479, 3569], [3570, 3570, 3589, 3589, 3610], [3611, 3611, 3630, 3630, 3713], [3714, 3714, 3733, 3733, 3772], [3773, 3773, 3792, 3792, 4010], [4011, 4011, 4030, 4030, 4292], [4293, 4293, 4312, 4312, 4450], [4451, 4451, 4470, 4470, 4499], [4500, 4500, 4519, 4519, 4592], [4593, 4593, 4612, 4612, 4743], [4744, 4744, 4763, 4763, 4828], [4829, 4829, 4848, 4848, 4957], [4958, 4958, 4977, 4977, 5136], [5138, 5150, 5169, 5169, 5394], [5396, 5396, 5415, 5415, 5678], [5679, 5679, 5698, 5698, 5999], [6000, 6000, 6019, 6019, 6297], [6298, 6298, 6317, 6317, 6543], [6544, 6544, 6563, 6563, 6767], [6768, 6768, 6787, 6787, 7222], [7223, 7223, 7242, 7242, 7400], [7401, 7401, 7420, 7420, 7577], [7578, 7578, 7597, 7597, 7856], [7857, 7857, 7876, 7876, 8072], [8073, 8073, 8092, 8092, 8229], [8230, 8230, 8249, 8249, 8498], [8499, 8499, 8518, 8518, 8717], [8718, 8718, 8737, 8737, 8804], [8805, 8805, 8824, 8824, 9053], [9054, 9054, 9073, 9073, 9258], [9259, 9259, 9278, 9278, 9562], [9563, 9563, 9582, 9582, 9856], [9857, 9857, 9876, 9876, 10012], [10013, 10013, 10032, 10032, 10207], [10208, 10208, 10227, 10227, 10300], [10301, 10301, 10320, 10320, 10451], [10452, 10452, 10471, 10471, 10552], [10553, 10553, 10572, 10572, 10757], [10758, 10758, 10777, 10777, 10950], [10952, 10952, 10972, 10972, 11176], [11177, 11177, 11197, 11197, 11470], [11471, 11471, 11491, 11491, 11665], [11666, 11666, 11686, 11686, 11876], [11877, 11877, 11897, 11897, 12249], [12250, 12250, 12270, 12270, 12565], [12566, 12566, 12586, 12586, 12707], [12708, 12708, 12728, 12728, 12890], [12891, 12891, 12911, 12911, 13192], [13193, 13193, 13213, 13213, 13291], [13293, 13303, 13324, 13324, 13375], [13376, 13376, 13398, 13398, 13469], [13470, 13470, 13493, 13493, 13573], [13574, 13574, 13599, 13599, 13827], [13828, 13828, 13850, 13850, 13991], [13992, 13992, 14015, 14015, 14057], [14058, 14058, 14081, 14081, 14159], [14160, 14160, 14185, 14185, 14325], [14326, 14326, 14349, 14349, 14446], [14447, 14447, 14468, 14468, 14601], [14602, 14602, 14623, 14623, 14681], [14682, 14682, 14703, 14703, 14854], [14855, 14855, 14876, 14876, 14931], [14932, 14932, 14951, 14951, 15041], [15042, 15042, 15061, 15061, 15098], [15099, 15099, 15120, 15120, 15299], [15300, 15300, 15320, 15320, 15713], [15714, 15714, 15733, 15733, 15803], [15804, 15804, 15824, 15824, 15882], [15883, 15883, 15905, 15905, 16068], [16069, 16069, 16092, 16092, 16132], [16133, 16133, 16155, 16155, 16403], [16404, 16404, 16427, 16427, 16467], [16469, 16469, 16519, 16519, 16565], [16566, 16566, 16618, 16618, 16655], [19055, 19076, 19108, 19108, 19723], [19726, 19749, 19875, 19875, 20071], [20073, 20140, 20159, 20159, 20481], [20483, 20512, 20532, 20532, 20682], [20684, 20793, 20815, 20815, 21088], [21090, 21178, 21201, 21201, 21309], [21311, 21331, 21360, 21360, 21554], [21557, 21557, 21614, 21614, 23920]], "test": "valid"}
{"id": "WssXWf", "name": "RayRepitation", "author": "kiyamada96", "description": "Ray fbm repitation", "tags": ["rayfbm"], "likes": 7, "viewed": 205, "published": "Public", "date": "1552381350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCTAVES 5\n#define CS(a) vec2(cos(a),sin(a))\n\nconst float sphereSize=1.;\nconst vec3 lightDir=vec3(-0.577,0.577,0.577);\n\nconst float PI=3.14;\nconst float angle=90.0;\nconst float fov=angle*0.5*PI/180.0;\n\nvec3 trans(vec3 p)\n{\n\treturn mod(p,4.0)-2.0;\n}\n\nfloat random(in vec2 st)\n{\n\treturn fract(sin(dot(st.xy,vec2(12.443,78.4)))*43758.2);\n}\n\nfloat noise(in vec2 st)\n{\n\tvec2 i=floor(st);\n    vec2 f=fract(st);\n    float a=random(i);\n    float b=random(i+vec2(1.0,0.0));\n    float c=random(i+vec2(0.0,1.0));\n    float d=random(i+vec2(1.0,1.0));\n    \n    vec2 u=smoothstep(0.0,1.0,f);\n    return mix(a,b,u.x)+(c-a)*u.y*(1.0-u.x)+(d-b)*u.x*u.y;\n    \n}\n\nfloat fbm(vec2 p)\n{\n\tfloat result=0.0;\n    float amplitude=1.0;\n    \n    for(int i=0;i<OCTAVES;i++)\n    {\n    \tresult+=amplitude*noise(p);\n        amplitude*=0.5;\n        p*=2.;\n    }\n    return result;\n}\n\nfloat distanceFunc(vec3 p)\n{\n    return length(trans(p)) - (1.0+sin((p.y+iTime) * 10.0) * 0.1);\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat d=0.01;\n\treturn normalize(vec3(\n        distanceFunc(p+vec3(d,0.0,0.0))-distanceFunc(p+vec3(-d,0.0,0.0)),\n        distanceFunc(p+vec3(0.0,d,0.0))-distanceFunc(p+vec3(0.0,-d,0.0)),\n        distanceFunc(p+vec3(0.0,0.0,d))-distanceFunc(p+vec3(0,0.0,-d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n   \tp+=fbm(p+iTime*0.1);\n    \n    vec3 cPos=vec3(0.0,0.0,2.0);\n    vec3 cDir=vec3(0.0,0.0,-1.0);\n    vec3 cUp=vec3(0.0,1.0,0.0);   \n    vec3 cSide=cross(cDir,cUp);\n    float targetDepth=1.0;\n    \n    vec3 ray=normalize(vec3(sin(fov)*p.x,sin(fov)*p.y,-cos(fov)));\n    \n    float dist=0.0;\n    float rlen=0.0;\n   \tvec3 rPos=cPos;\n    \n    for(int i=0;i<128;i++)\n    {\n    \tdist=distanceFunc(rPos);\n        rlen+=dist;\n        rPos=cPos+ray*rlen;\n    }\n   \n    if(abs(dist)<0.001)\n    {\n   \t\tvec3 nor=getNormal(rPos);\n        float diff=clamp(dot(nor,lightDir),0.1,1.0);\n        fragColor=vec4(vec3(nor),1.0);\n    }\n    else\n    {\n    \tfragColor=vec4(vec3(0.),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssXWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 229, 229, 255], [257, 257, 283, 283, 343], [345, 345, 370, 370, 650], [652, 652, 671, 671, 856], [858, 858, 886, 886, 955], [957, 957, 981, 981, 1249], [1251, 1251, 1308, 1308, 2055]], "test": "valid"}
{"id": "wssXWl", "name": "[TWITCH] The gamma ray feast", "author": "evvvvil", "description": "\"The gamma ray feast\" - Shader showdown practice session 011.\nLive coded on Twitch with 25 minutes time limit.\nPracticing live on TWITCH every Tuesdays around 21:00 UK time.\nhttps://www.twitch.tv/evvvvil_", "tags": ["ray", "time", "demoscene", "abstract", "glow", "gamma", "limit", "live", "battle", "shadershowdown", "coding", "twitch", "showdown"], "likes": 37, "viewed": 1553, "published": "Public API", "date": "1552589519", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\"The gamma ray feast\" - Shader Showdown practice session 011\n\n// WHAT THE FUCK IS THE SHADER SHOWDOWN?\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader from memory on stage. \n// The audience votes for the winner by making noise or by voting on their phone.\n// Winner goes through to the next round until the final where champion is crowned.\n// Live coding shader software used is BONZOMATIC made by Gargaj from Conspiracy:\n// https://github.com/Gargaj/Bonzomatic\n\n// Every tuesdays around 21:00 UK time I practise live on TWITCH. This is the result of session 011.\n\n// COME SEE LIVE CODING EVERY TUESDAYS HERE: https://www.twitch.tv/evvvvil_\n\n// evvvvil / DESiRE demogroup\n\n// \"Science in my day was fucking weldin' fucking ships together, and sending them to the fucking sea\" - Limmy (The armadillo sketch)\n\nvec2 sc,y,e=vec2(.000035,-.000035);float t,tt,b,bb,g1=0.,g2=0.;vec3 np,bp;//Some fucking globals, about as exciting as a vegetarian sausage\nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}//box function stolen from UNC because Russian is math.\nfloat cy(vec3 p,float r){p.y=0.;return length(p)-r;}//Did you know you could make an infinite cylinder by taking a sphere and making an axis 0? \nfloat cz(vec3 p,float r){p.z=0.;return length(p)-r;}//Did you know you could ... I just fucking told you, didn't I? Pay attention this isn't your ex girlfriend's nitting class\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//Simple rotate function, it is useful as fuck and short. Bit like the key to your ex girlfriend's dad's tool shed\nvec2 fb(vec3 p,vec3 m, float s)//Fucking bits function which makes the fucking bit/piece it is a base shape which we clone and repeate to create the whole geometry in mp function\n{\n  p.xz*=r2(s);//constantly giving it a little shake, like a juicing diet but without the pretention or the juices\n  p.xy*=r2(s+bb*1.4);//Every so often we flip the fuck outta everything, it's like those brexit promises that got flipped into nothingness\n  vec2 h,t=vec2(bo(abs(p)-vec3(0,0,1),vec3(2.2,0.3,0.7)),m.x);//set the tone make a bunch of fucking boxes with abs symetry cloning\n  t.x=min(0.6*cy(abs(abs(p)-vec3(0.5,0,0))-vec3(0.5,0,1),0.1),t.x);//Erecting major fucking poles, because it's not a good shader if it doesn't have sexual innuendo\n  if(m.x<6.) g2+=0.1/(0.1+pow(abs(t.x),2.));//glow trick by Balkhan, we pass the distance field of shape to g2 glow variable which we gonnu add to light at end\n  h=vec2(bo(abs(p)-vec3(0,0,1),vec3(2.0,0.5,0.5)),m.y);//More fucking boxes, double outline grapphitti style mother fucker, \"yeah I come from the streets\". Not really, i was born in a hospital\n  t=(t.x<h.x)?t:h;//Blending two shapes while retinaing material ID, like a melting headbutt with colours punched in the face\n  h=vec2(bo(p,vec3(1.8,0.2,2.8)),m.z);//yet more fucking boxes, this time white one for structure and comfort, take off your shoes broski, we share slipers here. Gross, yes, but at least we're family\n  t=(t.x<h.x)?t:h;//Blending two shapes while retinaing material ID, like a melting headbutt with colours punched in the face\n  t.x*=0.7;//bit more definition so we avoid artifact, i like my shaders looking good, well at least handsome, because cute is for puppies.\n  return t;\n}\nfloat noise(vec3 p){//Noise function stolen from Virgil who stole it from Shane who I assume understands this shit, unlike me who is too busy throwing toilet paper at my math teacher's house\n  vec3 ip=floor(p),s=vec3(7,157,113);\n  p-=ip; vec4 h=vec4(0,s.yz,s.y+s.z)+dot(ip,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nvec2 mp( vec3 p ) //This is the main MAP function where all geometry is made/defined. It's centre stage broski, bit like someone drunk at a funeral\n{//Technique is to make a new position np and tweak it, clone it, rotate it and then pass np to fb to create complex geometry from simple piece\n  b=sin(p.z-tt*10.)*0.1;//animation variable based on sin of z axis\n  np=p;//new position is set to original position\n  for(int i=0;i<5;i++){//In the loop we push, rotate np into more complex \"position\"\n    np=abs(np)-vec3(2.5,1.7,0);//symetry clone the fucker out\n    np.xy*=r2(cos(p.y*0.05)*0.5);//rotate the bitch along xy axis\n    np.xz*=r2(20.);//and again mega rotate the whole shit along xz so it looks symetrical\n  }\n  vec2 h,t=fb(np,vec3(5,3,6),b);//push np to fucking bit function to make complex geometry base don single piece, like flipping a coin in the air and getting a gram of coke back!\n  bp=np;bp.yz*=r2(.785);bp=abs(bp*0.5)-vec3(3.2);//we make one more new position, called \"bp\" for the outter bits\n  np.xz*=r2(b);//This line is to keep track of the final result of np as it's being rotated in fb function and we msut track it as w euse np for the gloss map further down\n  np.xy*=r2(b+bb*1.4);//Same just keeping track of final np otherwise the  gloss map slides, like your ex when she is drunk and walking in high hells but without the ensuing hospital drama\n  h=fb(bp,vec3(7,8,9),0.1);//this line makes outter bits using same fb function but with different position \"bp\" this time, making it totally different, nifty shit broski\n  h.x*=2.0;//Outterb bits bp position is at different scale so we must adjust the distance field to avoid warpnig artefact\n  t=(t.x<h.x)?t:h;//Blending the inner red/black/white bits with outter blue/black/white bits, bit like diplomacy really but with fun coloured stickers rather than corrupt politicians\n  h=vec2(cz(p,0.5-b),8);//Make a fucking wobbly tube that glows, bit like a fat wobbly glow stick. Well fuck, i guess the metaphore is ironic, it's not the fucking nineties anymore.\n  h.x=min(length(p)-6.+b,h.x);//Also make a glow sphere inside the inner bits, it is about feeding after all\n  g1+=0.1/(0.1+pow(abs(h.x),2.));//glow trick by Balkhan, we pass the distance field of shape to g1 glow variable which we gonnu add to light at end\n  t=(t.x<h.x)?t:h;//This again a colourful handshake between two shapes blending the glowy bits and rest\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t=vec2(0.1);//Near plane because we all started as annoying little shits yeah, and nah, your kids aren't cute\n  for(int i=0;i<128;i++){//Main loop de loop \n    h=mp(ro+rd*t.x);//Marching forward like any good fascist army: without any care for culture theft\n    if(h.x<.0001||t.x>50.) break;//Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y;//Remember the postion and the material id? Yeah let me hold your beer while you hold my paint brush. Artist? Yes,...but albcoholic first\n  }\n  if(t.x>50.) t.x=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised he left his Iphone charger in Greece. (10 points whoever gets the reference)\n  return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);//boilerplate code to get uvs in BONZOMATIC live coding software i use.\n    tt=mod(iTime,100.);//MAin time variable, it's modulo'ed to avoid ugly artifact. Holding time in my hand: playing god is nearly as good as this crystal meth bag\n  \tbb=0.5+clamp(sin(tt),-0.5,0.5);//This is just animation variables used in mp or fb\n    vec3 ro=vec3(cos(tt*0.5)*15.,sin(tt*0.5)*15.,-20),//Ro=ray origin=camera position because everything is relative to a view point, even your ex girlfriend's dubious taste in men\n    cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n    rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n    co,fo,ld=normalize(vec3(0,0.5,-0.5));//ld=light direction, light is in front a bit above to cheat light effect being lit from ray, whatever it works broh innit.\n    co=fo=vec3(.04)*(1.-(length(uv)-.2));//By default the color fog color and it's pretty black with reverse vignette because I'm not scared of the dark anymore since getting revenge on my math teacher\n    sc=tr(ro,rd);t=sc.x;//This is where we shoot the fucking rays to get the fucking scene. Like a soldier but with a pixel gun and less intentions to invade and pillage.\n\t\n    if(t>0.){//If t>0 then we must have hit some geometry so let's fucking shade it. \n        //We hit some geometry so let's get the current position (po) and build some normals (no). You do the Maths while I make a jug of PIM's and drink it without you\n        vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x),\n        //LIGHTING MICRO ENGINE BROSKI \n        al=vec3(1,0.05,0);//Albedo is base colour.\n        float dif=max(0.,dot(no,ld)),//dif=diffuse because i ain't got time to cook torrance\n        aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),//aor =amibent occlusion range, ao = ambient occlusion\n        fr=pow(1.+dot(no,rd),4.),//Fr=fresnel which adds reflections on edges to composite geometry better, yeah could be reflected, but who gives a shit? Anyways just like your ex, it doesn't do much.\n        spo=exp(1.+3.*noise(np/vec3(.1,.2,.4)));//TRICK making a gloss map from a 3d noise function is a thing of fucking beauty\n        //Change colour depending on material id, it's like art school but without the whinging PC babies\n        if(sc.y<5.) al=vec3(0);//albedo is black \n        if(sc.y>5.) al=vec3(1);//albedo becomes white\n        if(sc.y>6.) {al=vec3(0.1,0.5,0.9);spo=exp(1.+3.*noise(bp/vec3(.1,.2,.4))); no*=(1.+.6*ceil(cos(bp*4.)));no=normalize(no);}//Yeah we re make the gloos map for outter bits as they need gloss map based on bp not np\n        if(sc.y>7.) {al=vec3(0);}//Yeah i know not exactly elegant but neither am I wearing a little black dress.\n        if(sc.y>8.) {al=vec3(1);}//Anyway it's easy way of redefining materials to include the gloss map based on bp rather than np as these materials are all for outter bits\n        \n        vec3 sss=vec3(0.5)*smoothstep(0.,1.,mp(po+ld*0.4).x/0.4),//sss=subsurface scatterring made by tekf from the wax shader, big up tekf! https://www.shadertoy.com/view/lslXRj\n        sp=vec3(0.5)*pow(max(dot(reflect(-ld,no),-rd),0.),spo);//Sp=specualr, sotlen from Shane and it's better than being punched in the stomach by your ex girlfriend's new and tougher boyfriend\n        co=mix(sp+al*(.8*ao+0.2)*(dif+sss),fo,fr);//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n        co=mix(co,fo,1.-exp(-.0001*t*t*t));//Fog soften things, but it won't save your ex's failed pet rescue center, money will.\n    }\n    co+=g1*0.3;//Adding the white gamma ray glow at the end\n  \tco+=vec3(1,0.05,0)*g2*(0.004*bb);//and the red cylinder glow too, it's that simple broski look above for more glow explanation, line 31 and 65\n    fragColor = vec4(pow(co,vec3(0.45)),1);//Cheap tone mapping, even cheaper than the presents your ex used to get you for christmas\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1046, 1112, 1136, 1136, 1182], [1182, 1238, 1263, 1263, 1290], [1290, 1383, 1408, 1408, 1435], [1435, 1559, 1576, 1576, 1619], [1619, 1734, 1914, 1914, 3423], [3424, 3424, 3444, 3614, 3837], [3838, 3838, 3987, 4129, 6245], [6246, 6246, 6275, 6275, 6985], [6986, 6986, 7043, 7043, 11209]], "test": "valid"}
{"id": "WsSXWm", "name": "Ballicorn", "author": "OliverSchaff", "description": "My first steps into raymarching. I want to color and tile a sphere based on polar coordinates.", "tags": ["3d", "polar"], "likes": 10, "viewed": 159, "published": "Public", "date": "1553958405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 300;\nconst float EPS_NORMAL = 0.001;\nconst float SCALE_DIST = 0.2;\n\nconst float PI = 3.14159265359;\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdUnion( float d0, float d1 ) {\n    return min( d0, d1 );\n}\n\nfloat sdInter( float d0, float d1 ) {\n    return max( d0, d1 );\n}\n\nfloat sdSub( float d0, float d1 ) {\n    return max( d0, -d1 );\n}\n\nfloat sdUnion_s( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sfDisp( vec3 p ) {\n    return sin(p.x)*sin(p.y)*sin(p.z) ;\n}\n\nvec3 sdTwist( vec3 p, float a ) {\n    float c = cos(a*p.y);\n    float s = sin(a*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 sdRep( vec3 p, vec3 c ) {\n    return mod(p,c)-0.5*c;\n}\n\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nvec3 carToPol(vec3 p) {\n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    vec3 pol = carToPol(pos);\n\n    \n    float d1 = opOnion(sdSphere( pos, 1.1 ), 0.0001);\n    float wave = -0.1+0.5*sin(8.*(pol.y+0.2*iTime))*sin(8.*(pol.z));\n    float d2 = d1 + wave;\n\n    float d = sdSub(d1,d2);\n\n\tvec2 res = vec2(d, 1.0);\n    \n \t//vec2 res = vec2( sdSphere( pos - vec3( .0 , .0 , .0 ) , 1.1 ) , 1. ); \n    //res = opU( res , vec2( sdBox( pos- vec3( -.8 , -.4 , 0.2 ), vec3( .4 , .3 , .2 )) , 2. ));\n    \n    return res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h*SCALE_DIST;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( EPS_NORMAL, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = vec3( 0.5 );\n    \n  vec3 lightPos = vec3( 1. , 4. , 3. );\n    \n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n      \n    vec3 lightDir = normalize( lightPos - pos );\n    \n    float match = max( 0. , dot( lightDir , norm ));\n      \n   \tcolor = vec3( 1. , 1., 1.) * match * 0.3 ;\n    \n    vec3 pol = carToPol(pos);\n    vec3 selfColor = spectrum(1.0*pol.z/PI/2.0+0.5*pol.y/PI);\n\n    color += selfColor * 01.0;\n  }\n   \n  return color;\n    \n    \n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro = vec3( 3.0*cos(0.5*iTime), 0.0, 3.0*sin(0.5*iTime));\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.5*sin(iTime) );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n        \t// rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\trd = rot * rd;\n\tro = rot * ro;\n\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\t\n    vec3 color = render( res , ro , rd );\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 595, 617, 617, 739], [741, 741, 762, 762, 881], [883, 954, 1022, 1022, 1065], [1067, 1067, 1091, 1091, 1189], [1193, 1224, 1288, 1288, 1466], [1468, 1562, 1591, 1591, 1634], [1636, 1636, 1667, 1667, 1763], [1765, 1765, 1800, 1800, 1824], [1826, 1826, 1863, 1863, 1891], [1893, 1893, 1930, 1930, 1958], [1960, 1960, 1995, 1995, 2024], [2026, 2026, 2072, 2072, 2165], [2167, 2167, 2191, 2191, 2233], [2235, 2235, 2268, 2268, 2381], [2383, 2383, 2413, 2413, 2442], [2445, 2445, 2496, 2496, 2529], [2531, 2531, 2554, 2554, 2669], [2672, 2756, 2777, 2777, 3225], [3229, 3229, 3277, 3277, 3755], [3759, 3872, 3903, 3903, 4134], [4139, 4139, 4183, 4183, 4699], [4701, 4733, 4764, 4764, 4920], [4925, 4925, 4982, 4982, 5672]], "test": "valid"}
{"id": "WsSXWw", "name": "Web Cam Sphere", "author": "kindpotato", "description": "I try and render a sphere based only on what I know. Point your camera at a mercator projection of the world map for a spinning GLOBE.", "tags": ["imtryingtomakeasphere"], "likes": 3, "viewed": 167, "published": "Public", "date": "1553921057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float quadraticRoots(float a, float b, float c){\n    if ((b*b) - (4.*a*c) > 0.)\n\t\treturn (-b-sqrt((b*b) - (4.*a*c)))/(2.*a);\n   \treturn 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    float aspect = iResolution.x/iResolution.y;\n    //Based on uv\n    vec3 viewingNormal = normalize( vec3( uv-vec2(0.5,0.5/aspect),-1));\n    \n    const vec3 ballPos = vec3(0,0,-100.);\n    const float ballRadius =  20.;\n    float bailOut = length(ballPos)+ballRadius;\n    //Start marching out close to the ball\n    vec3 marching = viewingNormal*(length(ballPos)-ballRadius-0.5);\n    vec3 quadEquation = vec3(1.,\n                             -2.*dot(viewingNormal,ballPos),\n                             ballPos.x*ballPos.x + ballPos.y*ballPos.y + ballPos.z*ballPos.z\n                        \t-ballRadius*ballRadius);\n    //t is how long the viewingVector goes before meeting the circle\n    float t = quadraticRoots(quadEquation.x,quadEquation.y,quadEquation.z);\n   \n    vec3 normal = vec3(0);\n    vec3 position = vec3(0);\n    if (t != 0.){\n    \tposition = viewingNormal*t;\n        normal = normalize(viewingNormal*t-ballPos);\n    }\n    /*while (length(marching) < bailOut) {\n    \tif (distance(marching,ballPos) < ballRadius){\n            vec3 a = marching-10.*viewingNormal;\n            for (int i = 0; i < 6; ++i){\n                if (length((a+marching)/2. - ballPos) < ballRadius)\n                \tmarching = (a+marching)/2.;\n                else\n                    a = (a+marching)/2.;\n                \n\t\t\t\t\n            }\n            //After this point marching will be sufficiently close the\n            //surface of the ball\n            normal = normalize(marching - ballPos);\n            \n            break;\n        }\n        marching += 10.*viewingNormal;\n        \n\t}*/\n    if (normal != vec3(0)){\n        vec3 color = vec3(0);\n    \tvec3 lightPos = vec3(400.*cos(iTime),400.*sin(iTime),200.+30.*cos(5.*iTime));\n        vec3 reflected = reflect(viewingNormal,normal);\n        vec3 surfaceToLight = lightPos-marching;\n        float lightLen = length(surfaceToLight);\n        \n        /*float intoLight = max(0.,dot (reflected,normalize(surfaceToLight)));\n        float awayFromLight = sqrt(1.-intoLight*intoLight);\n        float lightDist = awayFromLight*lightLen/intoLight;\n        \n        if (lightDist < 40.){\n            color += vec3(1);\n        }*/\n        float latitude = 0.5+asin(dot(vec3(0,1,0),normal))/3.14159;\n        vec2 orientation = vec2(sin(iTime),cos(iTime));\n        vec2 nOrientation = normalize(vec2(normal.x,normal.z));\n        \n        float longitude = 0.5 * (0.5+asin(dot(orientation,nOrientation))/3.14159);\n        if (dot(vec2(orientation.y,-orientation.x),nOrientation) < 0.){\n            longitude = 1.-longitude;\n        }\n        longitude = 1. - longitude;\n        \n        vec3 textureColor = texture(iChannel0,vec2(longitude,latitude)).rgb;\n        \n        \n        //Diffuse\n        color += max(0.,0.8*dot(normal,surfaceToLight/lightLen));\n        color *= vec3(0.8,1,1);\n        //Sky Diffuse\n        color += 0.9*vec3(0.8,0.8,1)*(0.5+asin(dot(vec3(0,1,0),normal))/3.14159);\n        color *= textureColor;\n        //Shine\n        color += 0.75*pow(max(0.,dot (reflected,normalize(surfaceToLight))),10.);\n        fragColor = vec4(color,1);\n        \n        \n        return;\n    \t\n    }\n    fragColor = vec4(0.8,0.8,1,1);\n    if (viewingNormal.y < 0.)\n        fragColor = vec4(0,0,0,1);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 141], [143, 143, 200, 200, 3476]], "test": "error"}
{"id": "WsSXWz", "name": "One Tweet Spiral Machine", "author": "KilledByAPixel", "description": "This is a version of my spiral shader minified to fit in 1 tweet!\nWhat I find really intersting is how the number of arms evolve, I think it may be related to prime numbers.", "tags": ["spiral", "sunflower", "vogel"], "likes": 3, "viewed": 518, "published": "Public API", "date": "1553360744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// 1 Tweet Spiral Machine - By Frank Force - Copyright 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\n\n#define S(v)step(.5,fract(v*a*t))\nvoid mainImage(out vec4 c, vec2 p){ vec2 r=iResolution.xy,u=99.*(p.xy-r/2.)/r.x;float P=6.28,t=.01*iTime,A=atan(u.y,u.x),a=A+P*floor(length(u)-A/P+.5),s=S(.5),v=S(1.);c=vec4(v-s*v*.5)+vec4(s*v)*cos(P*(.002*a+t+vec4(1.,.6,.3,1.)));}\n\n\n/*\n#define S(v) step(.5, fract(v*a*t))\n#define mainImage(c,p)\t\t\t\t\t\t\t\t\\\n    vec2 r = iResolution.xy,\t\t\t\t\t\t\\\n        u = 99.*(p.xy - r / 2.)/ r.x;\t\t\t\t\\\n    float P = 6.28,\t\t\t\t\t\t\t\t\t\\\n          t = .01*iTime,\t\t\t\t\t\t\t\\\n          A = atan(u.y, u.x),\t\t\t\t\t\t\\\n          a = A + P*floor(length(u) - A/P + .5),\t\\\n          s = S(.5),\t\t\t\t\t\t\t\t\\\n          v = S(1.);\t\t\t\t\t\t\t\t\\\n    c = vec4(v - s * v * .5) + vec4(s * v) * \t\t\\\n      cos(P * (.002*a + t + vec4(1., .6, .3, 1.)));\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSXWz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 349, 384, 384, 580]], "test": "valid"}
{"id": "WssXz2", "name": "midterms 10", "author": "jojo169", "description": "10", "tags": ["10"], "likes": 4, "viewed": 45, "published": "Public", "date": "1551709449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(1.,0.,0.);\nvec3 blue = vec3(0.,0.,1.);\nvec3 green = vec3(0,1.,0.);\nvec3 yellow = vec3(1.,1.,0.);\nvec3 black = vec3(0.,0.,0.);\nvec3 gray = vec3(.5,.5,.3);\n\n\n\nfloat gear(vec2 uv,float posX,float posY,float handSize,float midSize,float handNum)\n{\n    float ratio = iResolution.x / iResolution.y;\n\n    uv.x *= ratio;\n\n    vec2 shapePos = vec2(posX * ratio, posY);\n\n    float dist = distance(shapePos, uv) * 2.0;\n\n    uv -= shapePos;\n    \n    float speed = 0.5;\n\n    float angle = (atan(uv.y, uv.x) + iTime * speed);\n\n    float radius = 0.0;\n\n\n    radius = smoothstep(-0.5, 1.0, cos(angle * handNum)) * handSize + midSize;\n\n\n    float value = 1.0 - step(radius, dist);\n    \n    return value;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 col = vec3(clamp(sin(iTime), 0.0, 1.0) - 1.0, 0.0, clamp(sin(iTime), 1.0, 1.0));\n\n    vec3 value = mix(sin(iTime)*col,yellow,gear(uv,.08,.01,5.,.8,6.));\n\t   \n\n\n    // Output to screen\n    fragColor = vec4(value,uv);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssXz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 259, 259, 705], [709, 709, 766, 816, 1090]], "test": "valid"}
{"id": "WssXzf", "name": "Colliding Meta Black Holes", "author": "gordathgfx", "description": "First attempt on a 2D meta-ball effect.\n\nSpinning black holes with accretion disks gravitating and colliding.\n", "tags": ["2d", "metaballs", "flame", "fire", "animated", "blackhole", "spinning"], "likes": 6, "viewed": 232, "published": "Public", "date": "1551816296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define USE_TEXTURE\n\nconst float TWO_PI = 6.28318530718;\nconst float vertices = 11.;\nconst float startIndex = vertices;\nconst float endIndex = vertices * 2.;\n\n//based on: https://www.shadertoy.com/view/4lKXzd\nfloat metaballs(vec2 uv, float time, float size) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    float radSegment = TWO_PI / vertices;\n    for(float i = startIndex; i < endIndex; i++) {\t\t\t\t\t\n        float rads = i * radSegment;\n        float radius = 0.1 + 1.5 * sin(time + rads);\n        vec2 ctrlPoint = radius * vec2(tan(rads), atan(rads));\n\t\tsize += 1. / pow(i, distance(uv, ctrlPoint));\n    }\n    return size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float dist = metaballs(p * 3.0, iTime * 0.7 , 0.1);\n    \n#ifdef USE_TEXTURE \n    vec3 startColor = vec3(0.001, 0.3, 0.6);\n    vec3 endColor = smoothstep(texture(iChannel0, \n                                \t(p - vec2(sin(iTime), cos(iTime))*1.6 - vec2(dist))).rgb + vec3(0.3, 0.9, 0.9), \n                                    vec3(0.2, 0.4, 0.6), \n                                    vec3(dist));\n#else\n    vec3 startColor = vec3(0.2, 0.4, 0.0);\n    vec3 endColor = vec3(0.55, 1.0, 0.4);\n#endif\n        \n    fragColor = vec4(smoothstep(startColor, \n                          \t\tendColor, \n                          \t\tvec3(dist)), 1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 209, 259, 259, 604], [606, 606, 663, 663, 1371]], "test": "error"}
{"id": "WsSXzz", "name": "Voronoi Comparison", "author": "dr2", "description": "Compare 1-pass (red - mine) and 2-pass (green - Shane) rounded hexagonal Voronoi \nmethods. For complete edge-distance contours two passes are needed, with  double the \nwork; one pass is enough for the outer contours.\n", "tags": ["voronoi", "hexagon", "contour"], "likes": 9, "viewed": 466, "published": "Public API", "date": "1552642227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Voronoi Comparison\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Hashv2v2 (vec2 p);\n\nvec2 gVec[7], hVec[7];\nfloat tCur;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\nvec2 PRand (vec2 p)\n{\n  vec2 u;\n  u = Hashv2v2 (p);\n  return 0.3 * (0.4 + 0.6 * u.x) * sin ((u.y - 0.5) * pi * tCur + vec2 (0.5 * pi, 0.));\n}\n\nfloat HexVor1 (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    d = hVec[k] + PRand (ip + gVec[k]) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, 0.2) - sd.x;\n}\n\nfloat HexVor2 (vec2 p)\n{\n  vec2 ip, ipMin, fp, hm, pMin, hr, sp;\n  float dd, ddm, d, sd1, sd2;\n  ip = PixToHex (p);\n  sp = HexToPix (ip) - p;\n  ddm = 4.;\n  for (int i = 0; i < 7; i ++) {\n    fp = sp + hVec[i] + PRand (ip + gVec[i]);\n    dd = dot (fp, fp);\n    if (dd < ddm) {\n      ddm = dd;\n      ipMin = ip + gVec[i];\n    }\n  }\n  pMin = HexToPix (ipMin);\n  hm = pMin + PRand (ipMin);\n  sd1 = 4.;\n  sd2 = 4.;\n  for (int j = 0; j < 7; j ++) {\n    hr = pMin + hVec[j] + PRand (ipMin + gVec[j]);\n    fp = hr - hm;\n    if (dot (fp, fp) > 0.) {\n      d = dot (0.5 * (hr + hm) - p, normalize (fp));\n      sd1 = min (sd1, d);\n      sd2 = SmoothMin (sd2, d, 0.1);\n    }\n  }\n  return mix (sd1, sd2, 0.9);\n}\n\nvec3 ShowScene (vec2 p)\n{\n  vec3 col;\n  float s;\n  col = vec3 (0.1, 0.1, 0.6);\n  s = HexVor1 (p - 10. * sin (0.03 * tCur + vec2 (0.5 * pi, 0.)));\n  col = mix (col, vec3 (1., 0., 0.), smoothstep (0.02, 0.05, s) *\n     SmoothBump (0.35, 0.65, 0.02, mod (8. * s, 1.)));\n  s = HexVor2 (p - 10. * sin (0.03 * tCur + vec2 (0.5 * pi, 0.)));\n  col = mix (col, vec3 (0., 1., 0.), smoothstep (0.02, 0.05, s) *\n     SmoothBump (0.4, 0.6, 0.02, mod (8. * s, 1.)));\n  return col;\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv;\n  float pSize, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  tCur += 20.;\n  pSize = canvas.x / 300.;\n  HexVorInit ();\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) \n     col += (1. / naa) * ShowScene (pSize * (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)));\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSXzz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 432, 453, 453, 573], [575, 575, 599, 599, 993], [995, 995, 1019, 1019, 1693], [1695, 1695, 1720, 1720, 2163], [2180, 2180, 2236, 2236, 2864], [2866, 2866, 2890, 2890, 3120], [3122, 3122, 3146, 3146, 3206], [3208, 3208, 3228, 3228, 3448], [3450, 3450, 3495, 3495, 3598], [3600, 3600, 3657, 3657, 3740], [3742, 3742, 3772, 3772, 3885], [3919, 3919, 3943, 3943, 4073]], "test": "error"}
{"id": "WsXSD2", "name": "Uff", "author": "valler", "description": "uff", "tags": ["uff"], "likes": 2, "viewed": 57, "published": "Public", "date": "1552159622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "# define time iTime * .02 + 1000.\n\nvoid mainImage (out vec4 _, in vec2 uv)\n{\n    vec2 s = (2.*uv - iResolution.xy)/min(iResolution.x,iResolution.y);\n\t\n    vec3 b = texture(iChannel0,.5*s+vec2(.01*time,.2*time+.5)).rrr;\n    \n    float z = 70.*time;\n    s += .25*vec2(sin(z),cos(z));\n    s += 4.*vec2(sin(time),cos(time));\n    \n    float l = length(s);\n    float a = acos(dot(vec2(cos(time),sin(time)),s/l))/3.14159;\n    \n    l = smoothstep(2.,1.,1.+.5*tan(10.*sin(time*.4)*a))*l;\n    \n    vec3 n = normalize(vec3(exp(-a*a),exp(-l*l),.2));\n    \n    vec3 L = normalize(vec3(cos(.5*time),sin(.5*time),1));\n    \n    vec3 c = mix(vec3(1,1,0), vec3(.7,cos(2.+time)*.5+.5,.4), .5+.5*dot(n,L));\n    \n    c = mix(c,vec3(.5,.1,.5),smoothstep(.3,.4,b*b*b));\n\n\tc = fract(pow(c*(1.+sin(.1*time))*500.,vec3(.75)));\n    \n    _ = vec4(mix(c,sqrt(c),cos(30.*time)),1);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 76, 76, 852]], "test": "error"}
{"id": "WsXSW8", "name": "AnotherRaymarchPracticeShader", "author": "bignobody", "description": "More raymarch practice. First try at soft shadows and reflections. Thanks as always to iq and Jamie Wong for the tutorials. Constructive feedback is welcome... math is hard.", "tags": ["raymarch", "practice"], "likes": 3, "viewed": 65, "published": "Public", "date": "1551928427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_LIGHTS 1\n#define AMBIENT_LIGHT 1.61\n\nvec3 colours[6] = vec3[](vec3(0.8,0.04,0.01), vec3(0.04,0.8,0.01), vec3(0.01,0.04,0.8), vec3(0.25,0.51,0.1), vec3(0.35,0.81,0.01), vec3(0.1,0.3,0.4));\n\n// sdf functions by iq\nfloat sdfSphere(vec3 p, vec3 t, float r)\n{\n\treturn length(p-t)-r;   \n}\nfloat sdfBox( vec3 p, vec3 t, vec3 b )\n{\n  vec3 d = abs(p - t) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat sdfPlane( vec3 p, vec3 t, vec4 n )\n{\n  // n must be normalized\n  return dot(p-t,n.xyz) + n.w;\n}\nfloat sdfTorus( vec3 p, vec3 tr, vec2 t )\n{\n\tp = p-tr;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothInter( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n////////\n\n// objects map\nfloat distanceToClosest(vec3 p, inout int pick)\n{\n    float def = 500.0;\n    float d = sdfPlane(p,vec3(0.0,-2.5,0.0),normalize(vec4(0.0,1.0,0.0,1.0)));\n    pick = 4;\n    \n    if (d > def)\n    {\n      d = def;   \n    }\n    \n     float so = sdfTorus(p,vec3(0.0,1.75 ,0.0),vec2(2.0,1.0));//sdfSphere(p,vec3(0.0),1.0);\n   // float so = sdfTorus(p,vec3(0.0,1.75 * cos(iTime),0.0),vec2(2.0,1.0));//sdfSphere(p,vec3(0.0),1.0);\n   //float so = sdfSphere(p,vec3(0.0,1.75 * cos(iTime),0.0),2.0);\n   // float so = sdfBox(p,vec3(0.0,1.75,0.0),vec3(1.0));\n    if (so < d)\n    {\n        pick = 2;\n        d = so;\n    }\n    \n\tso = sdfSphere(p,vec3(-5.5 * cos(iTime),0.25,5.5 * sin(iTime)),2.0);\n    \n    if (so < d)\n    {\n        pick = 1;\n        d = so;\n    }\n\n\tso = sdfSphere(p,vec3(5.5 * cos (iTime),5.5* sin(iTime),0.0),2.0);\n    \n    if (so < d)\n    {\n        pick = 0;\n        d = so;\n    }\n\n\n    return d;\n    \n}\n\nvec3 estimateNormal(vec3 p, inout int pick)\n{\n    const float EPSILON = 0.0001;\n return normalize(vec3(\n        distanceToClosest(vec3(p.x + EPSILON, p.y, p.z),pick) - distanceToClosest(vec3(p.x - EPSILON, p.y, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y + EPSILON, p.z),pick) - distanceToClosest(vec3(p.x, p.y - EPSILON, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y, p.z  + EPSILON),pick) - distanceToClosest(vec3(p.x, p.y, p.z - EPSILON),pick)\n    ));   \n}\n\nvec3 getGroundColour(vec2 dc)\n{\n \tvec2 sc = vec2(cos(dc.x * 500.0),sin(dc.y * 500.0));\n    //float r = sin(sc.x * sc.y + dc.x * dc.y); \n    float r = sin(sc.x * sc.y); \n    float a = cos(length(dc) * 0.5) - 0.5;\n    return vec3(r,r+a,r*a) + vec3(dc.x,dc.y,dc.x+dc.y) * 10.0;   \n}\n\nvec3 getLightPosition(int l)\n{\n    if (l == 0)\n    {\n        return vec3(0.0,5.5*cos(iTime*0.5)+4.95,0.0);\n      //  return vec3(-5.5* sin(iTime),2.0 + cos(iTime) * 5.0 ,-5.5* cos(iTime));\n        //return vec3(0.0,5.5* cos(iTime)+2.0 , 0.0);\n      // return vec3(-8.80 * sin(iTime),8.0 ,-8.5* cos(iTime));\n   //     return vec3(-4.0, 34.0 ,-4.0);\n    }\n    return vec3(80.80 * sin(iTime*0.5),80.0 ,80.5* cos(iTime * 0.5));\n    //return vec3(4.0,34.0,4.0);\n}\n\n// lighting adapted from Jamie Wong's tutorials\nvec3 phongLight(vec3 diffuse, vec3 specular, float shine, vec3 lightPos, vec3 lightIntensity, vec3 surfacePoint, vec3 surfaceNormal, vec3 eye) \n{\n \tvec3 N = surfaceNormal;\n    vec3 L = normalize(lightPos - surfacePoint);\n    vec3 V = normalize(eye - surfacePoint);\n    vec3 R = normalize(reflect(-L, N));\n        \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return diffuse * 0.01;\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (diffuse * dotLN);\n    }\n    return lightIntensity * (diffuse * dotLN + specular * pow(dotRV, shine));\n}\n\nvec3 lightSurfacePoint(vec3 eye, vec3 surfacePoint, vec3 normal, float ambientLight, float shadow, int materialPick)\n{\n\tvec3 surfaceColour = vec3(0.0);\n    \n    vec3 lightIntensity[2] = vec3[2](vec3(0.6,0.6,0.6),vec3(0.6,0.6,0.6));\n    vec3 lightSpec[2] = vec3[2](vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0));\n\t\n    for (int l = 0; l < NUM_LIGHTS; l ++)\n    {\n    \t//surfaceColour = mix(surfaceColour, phongLight(colours[pick]-shadow, lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], normal, eye, pick), 0.5);\n//        surfaceColour = max(surfaceColour, \n //                           phongLight((colours[pick]-shadow), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], normal, eye, pick)\n  //                          );\n\n        \t\t\t\t\t\t//\t(vec3 diffuse, vec3 specular, float shine, vec3 lightPos, vec3 lightIntensity, vec3 p, vec3 eye, inout int pick) \n        surfaceColour += phongLight((colours[materialPick]* shadow *ambientLight), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], surfacePoint, normal, eye);\n    }\n\treturn surfaceColour;\n}\n\n// soft shadows from iq's tutorial\nfloat shadowMarch( vec3 lightOrigin, vec3 surfacePoint, float start, float end )\n{\n    vec3 direction = normalize((lightOrigin)-surfacePoint);\n    float blendFactor = 128.18;\n    int pickTarget = 0;\n  \tfloat res = 1.0;\n    float ph = 1e20;\n    for( float s=start; s < end; )\n    {\n        vec3 marchStep = lightOrigin + direction * s;\n        float distNow = distanceToClosest(marchStep, pickTarget);\n        if( distNow<0.001)\n            return 0.0;\n        float y = distNow*distNow/(2.0*ph);\n        float d = sqrt(distNow*distNow-y*y);\n        res = min( res, blendFactor*d/max(0.0,s-y) );\n        ph = distNow;\n        s += distNow;\n    }\n    return res; \n}\n\nfloat calcSurfaceShadow(vec3 p)\n{\n    float darken = 1.0;\n\tfor (int i  = 0; i < NUM_LIGHTS; i ++)\n    {\n    \t//vec3 lv = p + getLightPosition(i);\n        //darken += shadowMarch(getLightPosition(i),p, 0.9, 200.0);\n        darken = min(darken, shadowMarch(getLightPosition(i),p, 0.0001, 500.0));\n    }\n    return darken;\n}\n\n// since we can't have recursion, marching reflections here\nvec3 reflectMarch( vec3 origin, vec3 direction, inout int pickTarget, inout vec3 surfacePoint)\n{\n\tfloat marchDistance = 0.01;\n    vec3 marchVec = origin;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const int MAX_STEPS = 1000;\n    const float MAX_DISTANCE = 500.0;\n    const float CLOSE_ENOUGH = 0.0001;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n\n    for (int i = 0; i < MAX_STEPS; i ++)\n    {\n        marchStep = marchVec + direction * marchDistance;\n     \tdistNow = distanceToClosest(marchStep, pickTarget);\n        \n        if (distNow <= CLOSE_ENOUGH)\n        {\n            surfacePoint = marchStep;\n    \t\tsurfaceNormal = estimateNormal(surfacePoint, pickTarget);\n\t\t\tbreak;         \t\n        }\n        \n        marchDistance += distNow;   \n        \n        if (marchDistance >= MAX_DISTANCE)\n        {\n            // sky colour\n            pickTarget = 5;\n        \treturn colours[pickTarget] - direction.y * 0.5;   \n        }\n        \n    }\n\n    return lightSurfacePoint(origin, surfacePoint, surfaceNormal, AMBIENT_LIGHT, calcSurfaceShadow(surfacePoint), pickTarget);\n}\n\n\nvec3 rayMarch( vec3 origin, vec3 direction, int numReflections, inout vec3 surfacePoint )\n{\n\tfloat marchDistance = 0.0f;\n    vec3 marchVec = origin;\n    int pickTarget = 0;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const int MAX_STEPS = 1024;\n    const float MAX_DISTANCE = 500.0;\n    const float CLOSE_ENOUGH = 0.0001;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n    vec3 colAccum = vec3(0.0);\n    for (int i = 0; i < MAX_STEPS; i ++)\n    {\n        marchStep = marchVec + direction * marchDistance;\n     \tdistNow = distanceToClosest(marchStep, pickTarget);\n        \n        if (distNow <= CLOSE_ENOUGH)\n        {\n            // hit something!\n            surfacePoint = marchStep;\n    \t\tsurfaceNormal = estimateNormal(surfacePoint, pickTarget);\n            float shadowVal = calcSurfaceShadow(marchStep);\n            colAccum = lightSurfacePoint(origin, surfacePoint, surfaceNormal, AMBIENT_LIGHT, shadowVal, pickTarget);\n            \n            float mixVal = 0.5;\n            for(int r = 0; r < numReflections; r ++)\n            {\n                vec3 org = surfacePoint;\n            \tcolAccum = mix(colAccum, reflectMarch( org, normalize(reflect((direction), surfaceNormal)), pickTarget, surfacePoint),mixVal);\n              //  colAccum = max(colAccum, reflectMarch( surfacePoint, reflect(normalize(direction), surfaceNormal), pickTarget, surfacePoint));\n                mixVal -= 0.1;\n            }\n\t\t\tbreak;         \t\n        }\n        else\n        {\n         \tmarchDistance += distNow;   \n        }\n        if (marchDistance >= MAX_DISTANCE)\n        {\n            // sky colour\n        \t pickTarget = 5;\n        \treturn colours[pickTarget] - direction.y * 0.5;    \n        }\n        \n        \n    }\n    \n    return colAccum;\n   \n}\n\n\nvec3 castRay(vec3 origin, vec3 lookAt, vec2 fragCoord, float zoom)\n{\n    vec3 forwardVec = normalize(lookAt - origin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = origin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + fragCoord.x * rightVec + fragCoord.y * upVec;\n    return normalize(intersectVec - origin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 dc = uv * 2.0 - 1.0;\n\t//vec2 dc = uv - vec2(0.5);\n    dc.x *= iResolution.x/iResolution.y;\n   // vec3 rayOrigin = vec3(3.0 * cos(iTime),6.0 + sin(iTime * 0.5),5.0 * sin(iTime));\n     //vec3 rayOrigin = vec3(20.0 * sin(iTime*0.5),6.0 * sin(iTime)+3.0 ,20.0 * cos(iTime));\n  //vec3 rayOrigin = vec3(10.0 * cos(iTime),5.5 ,10.0 * sin(iTime));    \n   vec3 rayOrigin = vec3(0.0,8.0,9.0);\n    vec3 rayDirection = castRay(rayOrigin, vec3(0.0,0.0,0.0), dc, 1.0);\n   // colours[4] = getGroundColour(rayDirection.xy * length(dc));\n    int numReflections = 1;\n    vec3 surfacePoint = vec3(0.0);\n    vec3 col = rayMarch(rayOrigin, rayDirection, numReflections, surfacePoint);\n//    col *= calcSurfaceShadow(surfacePoint);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXSW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 224, 266, 266, 294], [295, 295, 335, 335, 489], [490, 490, 532, 558, 591], [592, 592, 635, 635, 711], [712, 712, 749, 749, 771], [773, 773, 808, 808, 830], [832, 832, 869, 869, 890], [892, 892, 944, 944, 1043], [1045, 1045, 1095, 1095, 1195], [1197, 1197, 1249, 1249, 1348], [1360, 1375, 1424, 1424, 2280], [2282, 2282, 2327, 2327, 2755], [2757, 2757, 2788, 2788, 3036], [3038, 3038, 3068, 3068, 3496], [3498, 3546, 3691, 3691, 4309], [4311, 4311, 4429, 4429, 5380], [5382, 5417, 5499, 5499, 6080], [6082, 6082, 6115, 6115, 6403], [6405, 6465, 6561, 6561, 7559], [7562, 7562, 7653, 7653, 9322], [9325, 9325, 9393, 9393, 9739], [9741, 9741, 9798, 9848, 10637]], "test": "valid"}
{"id": "wsXSWj", "name": "Ray marching. Apocalypse.", "author": "kirillserious", "description": "First task of computer graphic course on CS MSU.", "tags": ["raytracing", "raymarching"], "likes": 3, "viewed": 85, "published": "Public", "date": "1552230839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///////////////////////////////////////////////////////////////\n///                                                         ///\n///                   Важные константы                      ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\n/* Константы */\nfloat EPS        = 0.01;                  // Эпслилон пересечений\nfloat MAX_VIEW   = 500.;                  // Максимальный обзор\nvec3  STD_BRIGHT = vec3(0.1, 0.1, 0.1);   // Яркость дневного цвета\nfloat SHADOW     = 10.;                   // Твёрдость тени\nfloat MIN_STEP   = 0.01;                  // Минимальный шаг\n\n\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                Фигура. Работа с фигурами.               ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\nconst int FIGURE_NUMBER = 5; // Количество фигур\n\n/* Определение класса фигуры и массива figures */\nconst int FIG_SPHERE     = 1;\nconst int FIG_UDROUNDBOX = 2;\nconst int FIG_PLANE      = 3;\nconst int FIG_ELLIPSE    = 4;\nconst int FIG_TORUS      = 5;\n\nstruct Figure {\n    int  type;  // Тип фигуры\n    vec3 point; // Точка фигуры\n    vec3 color; // Цвет фигуры\n    \n    // koeffs.x - specular reflection constant\n    // koeffs.y - diffuse reflection constant\n    // koeffs.z - ambient reflection constant\n    // koeffs.w - shininess constant\n    // Считаем, что коэффициенты для R, G и В равны, потому что лень придумывать случаи, когда это не так.\n    // И что у всей фигуры эи коэффициенты постоянны -- поэтому же.\n    vec4 koeffs;\n    float reflection; // Коэффициент отражения \n};\nFigure[FIGURE_NUMBER] figures;\n\n/* Цвет фигуры */\nvec3\ngetFigureColor(vec3 point,\n               int  fig)\n{\n    Figure figure = figures[fig];\n    switch (figure.type) {\n    case FIG_SPHERE:\n    case FIG_UDROUNDBOX:\n    case FIG_ELLIPSE:\n    case FIG_TORUS:\n        return figure.color;\n    case FIG_PLANE:\n        float x = mod(point.x, 20.);\n        float z = mod(point.z, 20.);\n        if ((x > 10. && z > 10.) || (x < 10. && z < 10.)) {\n        \treturn figure.color;\n        } else {\n        \treturn 0.8 * figure.color;\n        }\n    }\n}\n\n/* Расстояние до фигуры */\nfloat\ngetDist (int  fig,\n         vec3 point)\n{\n    Figure figure = figures[fig];\n\tvec3 p = figure.point - point;\n    \n    switch (figure.type) {\n   \tcase FIG_SPHERE:\n    \tfloat radius = 5.;\n    \n    \treturn length(p) - radius;\n    \n    case FIG_UDROUNDBOX:\n        vec3 b = vec3(3., 3.*sin(iTime) + 4., 3.);\n    \tfloat r = 1.;\n  \t\n    \treturn length(max(abs(p)-b,0.0))-r;\n        \n    case FIG_PLANE:\n  \t\tvec3 bb = vec3(500., 1., 500.);\n        \n        vec3 d = abs(p) - bb;\n  \t\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\n    case FIG_ELLIPSE:\n        vec3 rr = vec3(10., 15., 20.);\n        vec3 cc = vec3(1., 3., 8.);\n        float ellipse = (length( p/rr ) - 1.0) * min(min(rr.x,rr.y),rr.z);\n    \tfloat cilindr = length(p.xz-cc.xy)-cc.z;\n        return max(-cilindr, ellipse);\n    \n    case FIG_TORUS:\n        vec2 tt = vec2(15., 2.);\n        vec2 q = vec2(length(p.xz)-tt.x,p.y);\n  \t\tfloat torus = length(q)-tt.y;\n        float problem = sin(100.*p.x)*sin(100.*p.y)*sin(100.*p.z);\n        return torus + problem;\n    }\n}\n\n/* Нормаль фигуры в точке */\nvec3\ngetNormal (int  fig,\n           vec3 point)\n{\n\tvec3 z1 = point + vec3(EPS, 0, 0);\n \tvec3 z2 = point - vec3(EPS, 0, 0);\n \tvec3 z3 = point + vec3(0, EPS, 0);\n \tvec3 z4 = point - vec3(0, EPS, 0);\n \tvec3 z5 = point + vec3(0, 0, EPS);\n \tvec3 z6 = point - vec3(0, 0, EPS);\n \tfloat dx = getDist(fig, z1) - getDist(fig, z2);\n \tfloat dy = getDist(fig, z3) - getDist(fig, z4);\n \tfloat dz = getDist(fig, z5) - getDist(fig, z6);\n \treturn normalize(vec3(dx, dy, dz));\n}\n\n/* Самая близкая фигура и расстояие до неё */\nstruct Dist \n{\n\tfloat dist;\n    int   fig;\n};\nDist\ngetMinDist (vec3 point)\n{\n\tfloat min_dist = getDist(0, point);\n    int   fig      = 0;\n    for (int cur_fig = 1; cur_fig < FIGURE_NUMBER; ++cur_fig) {\n        float dist = getDist(cur_fig, point);\n        if (dist < min_dist) {\n         \tmin_dist = dist;\n            fig      = cur_fig; \n        }\n    }\n    Dist result;\n    result.dist = min_dist;\n    result.fig  = fig;\n    return result;\n}\n    \n\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                    Источник света.                      ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\nconst int LIGHT_NUMBER = 3;\n\n/* Определение класса источника света и массива lights */\nstruct Light {\n    vec3 point;\n    vec3 bright;\n};\nLight[LIGHT_NUMBER] lights;\n\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                 Пересечение с фигурой.                  ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\n\n/* Структура пересечения */\nstruct Hit\n{\n    bool  is_hit;  // Было ли попадание в фигуру\n\tvec3  point;   // Точка попадания\n    int   fig;     // Фигура, в которую попали\n    float dist;    // Расстояние до фигуры\n};\n\n/* Поиск пересечения */\nHit\ngetHit (vec3 ray_point,\n        vec3 ray_dir)\n{\n    Hit result;\n    while (true) {\n        Dist  dist     = getMinDist(ray_point);\n        float min_dist = dist.dist;\n        int   fig      = dist.fig;\n    \t\n        /* Слишком далеко ушли */\n        if (length(ray_point) > MAX_VIEW) {\n         \tresult.is_hit = false;\n            result.point = ray_point;\n            return result;\n        }\n            \n        /* Попали в фигуру */\n        if (min_dist < EPS) {\n         \tresult.is_hit = true;\n            result.point  = ray_point;\n            result.fig    = fig;\n            result.dist   = min_dist;\n            return result;\n        }\n        /* Увеличиваем луч */\n        if (min_dist < MIN_STEP) {\n        \tray_point = ray_point + MIN_STEP * ray_dir;\n        }\n        ray_point = ray_point + min_dist * ray_dir;        \n    }\n}\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                  Освещение фигуры.                      ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\n/* Интенсивность света в точке по модели Фонга */\nvec3\ngetPhong (vec3 point,\n          vec3 light_point,\n          vec3 eye_point,\n          vec3 bright,\n          int  fig)\n{\n\tFigure figure = figures[fig];\n    \n    vec3 normal_dir  = getNormal(fig, point);\n    vec3 light_dir   = normalize(light_point - point);\n    vec3 eye_dir     = normalize(eye_point - point);\n    vec3 reflect_dir = normalize(reflect(-light_dir, normal_dir));\n    \n    float dotLN = dot(light_dir,  normal_dir);\n    float dotRE = dot(reflect_dir, eye_dir);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }     \n    if (dotRE < 0.0) {\n        return bright * (figure.koeffs.y * dotLN);\n    }\n    return bright * (figure.koeffs.y * dotLN + figure.koeffs.x * pow(dotRE, figure.koeffs.w));\n\n}\n\n/* Коэффициент тени */\nfloat\ngetShadow (vec3 point,\n           vec3 light_point)\n{\n    vec3  light_dir = normalize(light_point - point);    \n    float maxt      = length(light_point - point) + 10.*EPS;\n    float t         = 100. * EPS;\n    float phi       = EPS;\n    \n    float result = 1.0;\n    while (t < maxt)\n    {\n        vec3 cur_point = point + t*light_dir;\n    \tDist dist = getMinDist(cur_point);\n        float min_dist = dist.dist;\n        \n        if (min_dist < EPS) {\n        \treturn 0.;\n        }\n        \n        float y = min_dist*min_dist/(2.0*phi);\n        float d = sqrt(min_dist*min_dist - y*y);\n        result  = min(result, SHADOW*d/max(0., t - y));\n        \n        phi = min_dist;\n        t  += (min_dist < MIN_STEP)? MIN_STEP : min_dist;\n        \n    }\n    return result;\n}\n\n/* Цвет точки */\nvec3\ngetColor (vec3 point, \n          vec3 eye_point, \n          vec3 color, \n          int  fig)\n{\n    Figure figure = figures[fig];\n    \n    vec3 result = figure.koeffs.x * STD_BRIGHT;\n    \n    for (int i = 0; i < LIGHT_NUMBER; ++i) {\n        Light light = lights[i];\n        float shadow = getShadow(point, light.point);\n        vec3 phong  = getPhong(point, light.point, eye_point, light.bright, fig);\n        result += shadow * phong / (length(point - light.point) / 80.);    \n    } \n    return result * color;\n}\n\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                     Цвет фона.                          ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\n/* Белый шум из Интернета */\nfloat rand2D(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/* Белый шум из Интернета для звёзд */\nfloat dotNoise2D(in float x, in float y, in float fractionalMaxDotSize, in float dDensity)\n{\n    float integer_x = x - fract(x);\n    float fractional_x = x - integer_x;\n\n    float integer_y = y - fract(y);\n    float fractional_y = y - integer_y;\n\n   \tif (rand2D(vec2(integer_x+1.0, integer_y +1.0)) > dDensity)\n      \t{return 0.0;}\n\n    float xoffset = (rand2D(vec2(integer_x, integer_y)) -0.5);\n    float yoffset = (rand2D(vec2(integer_x+1.0, integer_y)) - 0.5);\n    float dotSize = 0.5 * fractionalMaxDotSize * max(0.25,rand2D(vec2(integer_x, integer_y+1.0)));\n\n   \tvec2 truePos = vec2 (0.5 + xoffset * (1.0 - 2.0 * dotSize) , 0.5 + yoffset * (1.0 -2.0 * dotSize));\n\n   \tfloat distance = length(truePos - vec2(fractional_x, fractional_y));\n\n   \treturn 1.0 - smoothstep (0.3 * dotSize, 1.0* dotSize, distance);\n\n}\n\n/* Цвет фона. Белый шум + подходящие параметры. */\nfloat getBackgroundColor(vec2 coord)\n{\n    float wavelength = 0.003;\n    float fractionalMaxDotSize = 100.;\n    float dDensity = 0.01;\n    return dotNoise2D(coord.x/wavelength, coord.y/wavelength, fractionalMaxDotSize, dDensity);\n}\n\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                Начальные точки и векторы.               ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\n/* Матрицы поворота */\nstruct Rotate\n{\n\tmat3 x;\n    mat3 y;\n};\n\nRotate\ngetRotate (float x, float y, float eye_dist)\n{\n\tfloat y_hypotenuse = sqrt(x*x + eye_dist*eye_dist);\n    float y_cos = eye_dist / y_hypotenuse;;\n    float y_sin = - x / y_hypotenuse;\n    mat3  y_mat = mat3(1.);\n    y_mat[0][0] =  y_cos;\n    y_mat[0][2] =  y_sin;\n    y_mat[2][0] = -y_sin;\n    y_mat[2][2] =  y_cos;\n    \n    float x_hypotenuse = sqrt(y*y + eye_dist*eye_dist);\n    float x_cos = eye_dist / x_hypotenuse;;\n    float x_sin = y / x_hypotenuse;\n    mat3  x_mat = mat3(1.);\n    x_mat[1][1] =  x_cos;\n    x_mat[2][1] =  x_sin;\n    x_mat[1][2] = -x_sin;\n    x_mat[2][2] =  x_cos;\n    \n    Rotate result;\n    result.x = x_mat;\n    result.y = y_mat;\n    return result;\n}\n\n/* Направление первых лучей */\nstruct StartRays\n{\n\tvec3 point;\n    vec3 dir;\n    vec3 eye_point;\n};\n    \nStartRays\ngetStart (float x,\n          float y,\n          float screen_width,\n          float screen_height)\n{\n\tStartRays start;\n    \n    /* Будем считать оси из центра экрана */\n    float screen_x = x - screen_width / 2.0;\n    float screen_y = y - screen_height / 2.0;\n    \n    /* Задали начальный луч */\n    start.point = vec3(10.* screen_x/screen_width,\n                            10.* screen_y/screen_width,\n                            10.);\n    start.dir   = normalize(start.point);\n    \n    /* Меняем направление, в зависимости от мышки */\n    float mouse_x = iMouse.x - screen_width / 2.0;\n    float mouse_y = iMouse.y - screen_height / 2.0;\n    \n    Rotate rotate = getRotate (mouse_x, mouse_y, screen_width);\n    \n    start.point = rotate.x * rotate.y * start.point;\n    start.dir   = rotate.x * rotate.y * start.dir;\n    \n    start.eye_point  = vec3(0., 0., 0.);\n    \n    return start;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ////////////////////////////////////////////////////////////\n\t///                                                      ///\n\t///            Положение фигур и источников света.       ///\n\t///                                                      ///\n\t////////////////////////////////////////////////////////////\n    \n    figures[0].type   = FIG_SPHERE;\n    float v0z  = 2.;\n    float v0x  = -1.;\n    float v0y  = 20.;\n    float g    = 9.8;\n    float time = mod(iTime, 2.*v0y/g);\n    figures[0].point  = vec3(15. + v0x * iTime,-4. - g * time*time/2. + v0y*time, 30. + v0z*iTime);\n    figures[0].color  = vec3(1., 0., 0.);\n    figures[0].koeffs = vec4(0.4, 0.8, 0.5, 3);\n    figures[0].reflection = 0.;\n    \n    figures[1].type   = FIG_UDROUNDBOX;\n    figures[1].point  = vec3(-30., 0., 80.);\n    figures[1].color  = vec3(1., 1., 1.);\n    figures[1].koeffs = vec4(0.2, 0.6, 0.3, 1);\n    figures[1].reflection = 0.;\n    \n    figures[2].type   = FIG_PLANE;\n    figures[2].point  = vec3(0., -10., 100.);\n    figures[2].color  = vec3(0., 1., 0.);\n    figures[2].koeffs = vec4(0.4, 0.3, 0.3, 6);\n    figures[2].reflection = 0.1;\n    \n    figures[3].type   = FIG_ELLIPSE;\n    figures[3].point  = vec3(30., 20., 60.);\n    figures[3].color  = vec3(0., 1., 1.);\n    figures[3].koeffs = vec4(0.4, 0.5, 0.3, 0.5);\n    figures[3].reflection = 0.3;\n    \n    figures[4].type   = FIG_TORUS;\n    figures[4].point  = vec3(-50., 20., 60.);\n    figures[4].color  = vec3(1., 0., 1.);\n    figures[4].koeffs = vec4(0.4, 0.5, 0.3, 0.5);\n    figures[4].reflection = 0.;\n    \n    lights[0].point  = vec3(30., 100., 40.*sin(iTime));\n    lights[0].bright = vec3(0.9, 0.9, 0.9);\n    \n    lights[1].point  = vec3(-10.*sin(iTime), 25. + 10.*sin(iTime), 90.*sin(iTime));\n    lights[1].bright = vec3(0.5, 0.5, 0.5);\n    \n    lights[2].point  = vec3(-10., 10., 2.);\n    lights[2].bright = vec3(0.9, 0.9, 0.9) * abs(sin(1. + 0.25*iTime));\n\n    \n    ////////////////////////////////////////////////////////////\n\t///                                                      ///\n\t///                     Алгоритм.                        ///\n\t///                                                      ///\n\t////////////////////////////////////////////////////////////\n    \n    StartRays start = getStart(fragCoord.x, fragCoord.y, iResolution.x, iResolution.y);\n    vec3 ray_point = start.point;\n    vec3 ray_dir   = start.dir;\n    vec3 eye_point = start.eye_point;\n    \n    /* Первый луч */\n    Hit hit    = getHit(ray_point, ray_dir);    \n    if (!hit.is_hit) {\n    \tfragColor = vec4(getBackgroundColor(hit.point.xz) * vec3(1.), 1.);\n        return;\n    }\n    \n    /* Отражение */\n    int  fig    = hit.fig;\n    vec3 point  = hit.point;\n    vec3 color = getFigureColor(point, fig);\n    Figure figure = figures[fig];\n    \n    if (figure.reflection < EPS) {\n    \tcolor = getColor(point, eye_point, color, fig);\n        fragColor = vec4(color, 1.);\n        return;\n    }\n        \n    vec3 normal      = getNormal(fig, point);\n    vec3 reflect_dir = normalize(reflect(ray_dir, normal));\n    \n    hit = getHit(hit.point+10.*EPS*reflect_dir, reflect_dir);\n    if (!hit.is_hit) {\n    \tcolor = figure.reflection * getBackgroundColor(hit.point.xz) * vec3(1.) +\n            (1. - figure.reflection) * color;\n    } else {\n    \tcolor = figure.reflection * getColor(hit.point, eye_point, getFigureColor(hit.point, hit.fig), hit.fig)       +      (1. - figure.reflection) * color;\n    }\n    \n    color = getColor(point, eye_point, color, fig);\n    \n    fragColor = vec4(color, 1.);\n       \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2142, 2170, 2228, 2228, 2661], [2663, 2708, 2755, 2755, 3752], [3754, 3802, 3852, 3852, 4263], [4265, 4390, 4420, 4420, 4787], [5990, 6030, 6081, 6081, 6919], [7257, 7344, 7469, 7469, 8076], [8078, 8116, 8175, 8175, 8890], [8892, 8918, 9017, 9017, 9435], [9767, 9815, 9837, 9837, 9909], [9911, 9977, 10069, 10069, 10791], [10793, 10879, 10917, 10917, 11110], [11456, 11535, 11588, 11588, 12217], [12219, 12346, 12456, 12456, 13327], [13330, 13330, 13387, 13730, 16977]], "test": "error"}
{"id": "WsXSWS", "name": "cos", "author": "densy", "description": "cosine", "tags": ["cos"], "likes": 2, "viewed": 89, "published": "Public", "date": "1551956123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = uv * 2. -1.;\n    \n    \n    float y = cos(vec2(uv2.x + iTime/2., 0) * 3.14 * 2.).x / 2.;\n    \n    vec3 col;\n    \n    float delta = 1.- abs(uv2.y - y)/1.2;\n    \n    if (uv2.y > y){\n    \tcol = vec3(1, 0, 0) * delta;\n    }\n    else{\n    \tcol = vec3(0, 1, 0) * delta;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 489]], "test": "valid"}
{"id": "WsXXDj", "name": "4D Rotating Hipercube.", "author": "Txoka", "description": "4D hipercube projected into a 3D space and then projected into a plane.\n", "tags": ["cube", "4d", "proyection", "hipercube"], "likes": 7, "viewed": 366, "published": "Public API", "date": "1552145019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define showpoints\n//#define sampleRotation\n\nvec2 project(vec3 point,vec3 focus){\n    return point.xy-point.z*(point.xy-focus.xy)/(point.z-focus.z)-focus.xy;\n}\nvec3 project(vec4 point,vec4 focus){\n    return point.xyz-point.w*(point.xyz-focus.xyz)/(point.w-focus.w)-focus.xyz;\n}\nfloat point(vec4 p,vec4 focus,vec2 uv){\n    vec2 w=project(project(p,focus),focus.xyz);\n\treturn 0.03/dot(uv-w,uv-w);\n}\nfloat line(vec4 p_,vec4 p2_,vec4 focus,vec2 uv){\n    vec2 p=project(project(p_,focus),focus.xyz);\n    vec2 p2=project(project(p2_,focus),focus.xyz);\n    vec2 n=uv-p;\n\tvec2 w=p2-p;\n\treturn smoothstep(30./iResolution.y,0.0,length(n-w*clamp(dot(n,w)/dot(w,w),0.,1.)));\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord ){\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y*10.;\n\to=vec4(0);\n    \n    vec4 eye=vec4(0,0,-30,-10);\n    \n    vec4 points[16];\n    points[0]=vec4(10,10,5,5);\n    points[1]=vec4(10,-10,5,5);\n    points[2]=vec4(-10,10,5,5);\n    points[3]=vec4(-10,-10,5,5);\n    points[4]=vec4(10,10,5,25);\n    points[5]=vec4(10,-10,5,25);\n    points[6]=vec4(-10,10,5,25);\n    points[7]=vec4(-10,-10,5,25);\n    \n    points[8]=vec4(10,10,25,5);\n    points[9]=vec4(10,-10,25,5);\n    points[10]=vec4(-10,10,25,5);\n    points[11]=vec4(-10,-10,25,5);\n    points[12]=vec4(10,10,25,25);\n    points[13]=vec4(10,-10,25,25);\n    points[14]=vec4(-10,10,25,25);\n    points[15]=vec4(-10,-10,25,25);\n    \n    vec4 center=vec4(0,0,15,15);\n    vec4 move=vec4(0,0,0,0);\n    for(int i=0;i<16;i++){\n        points[i]-=center;\n        #ifdef sampleRotation\n        points[i].wx*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n        points[i].zx*=mat2(cos(0.6),sin(0.6),-sin(0.6),cos(0.6));\n        points[i].yz*=mat2(cos(0.35),sin(0.35),-sin(0.35),cos(0.35));\n        #else\n\t\tpoints[i].xy*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n        points[i].xz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n        points[i].xw*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n        points[i].yz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n        points[i].yw*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n        points[i].zw*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n        #endif\n        \n        points[i]+=center+move;\n    }\n    \n    for(int i=0;i<16;i++){\n        for(int u=0;u<16;u++){\n            if(i<=u)continue;\n        \tif(distance(points[i],points[u])<21.)o+=line(points[u],points[i],eye,uv);\n        }\n    }\n    \n    #ifdef showpoints\n    for(int u=0;u<16;u++){\n        o+=point(points[u],eye,uv);\n    }\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 45, 81, 81, 159], [160, 160, 196, 196, 278], [279, 279, 318, 318, 397], [398, 398, 446, 446, 665], [667, 667, 715, 715, 2568]], "test": "valid"}
{"id": "wsXXW7", "name": "echspam", "author": "derive_by", "description": "moose", "tags": ["trippy"], "likes": 2, "viewed": 111, "published": "Public", "date": "1551399995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 kale(vec2 uv, float angle, float base, float spin) {\n\tfloat a = atan(uv.y*uv.x-uv.y*spin,uv.x*spin*uv.y+uv.x)+spin;\n\tfloat d = length(uv);\n\ta = mod(a,angle*2.0);\n\ta = abs(a-angle*angle/2.0);\n\tuv.x = sin(a+base)*d;\n\tuv.y = cos(a+base)*d;\n    return uv;\n}\n\nvec4 dcAdd( vec4 a, vec4 b )\n{\n    return a + b;\n}\n\nvec4 dcMul( vec4 a, vec4 b )\n{\n    return vec4( a.x*b.x - a.y*b.y, \n\t\t\t\t a.x*b.y + a.y*b.x,\n\t\t\t\t a.x*b.z + a.z*b.x - a.y*b.w - a.w*b.y,\n\t\t\t\t a.x*b.w + a.w*b.x + a.z*b.y + a.y*b.z );\n}\n\nvec4 dcSqr( vec4 a )\n{\n    return vec4( a.x*a.x - a.y*a.y, \n\t\t\t\t 2.0*a.x*a.y,\n\t\t\t\t 2.0*(a.x*a.z - a.y*a.w),\n\t\t\t\t 2.0*(a.x*a.w + a.y*a.z) );\n}\n\nconst float dots = 6.; \n\n//--------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float pi = 3.14159265359;\n    float myTime = iTime*(1.0/3.0);//+pow(2.,17.);\n    \n    vec2 p = -3.0 + 2.0 * fragCoord.xy*2. / iResolution.xy*2.;\n    p.x *= iResolution.x/iResolution.y;\n    \n    for(float i=0.;i<dots; i++){\n        float vol =  texture(iChannel0, vec2(i/dots, 0.0)).x/(pi*8.);\n        p = kale(p, -pi/1.0, (myTime*dots*vol*vol)/(dots*dots*atan(myTime)), sin(myTime*0.3));\n    }\n    \n    // animation\t\n\t//float tz = 0.5 + cos(0.0111225*myTime);\n    //float zo = pow( 0.5, 1.0*tz );\n    float tz = 0.5 - 0.5*cos(0.225*myTime);\n    float zo = pow( 0.5, 13.0*tz );\n\t\n    vec4 c = vec4( vec2(-0.05,.6805) + p*zo, 1.0, 0.0 );\n\n\tfloat m2 = 1.0;\n    float co = 0.0;\n\t\n\tvec4 z = vec4( 0.0, 0.0, 0.0, 0.0 );\n\t\n    for( int i=0; i<256; i++ )\n    {\n        if( m2>1024.0 ) continue;\n        float vol =  texture(iChannel0, vec2(float(i)/dots, 0.0)).x;\n\t\t\t\n        // Z -> ZÂ² + c\t\t\n\t\tz = dcAdd( dcSqr(z), c );\n\t\t\n\t\tm2 = dot( (z.xy+vol)/2., (z.xy-vol)/2. );\n        co += 1.0;\n    }\n\n    // distance\t\n\t// d(c) = |Z|Â·log|Z|/|Z'|\n\tfloat d = 0.0;\n\tif( co<256.0 ) d = sqrt( dot(z.xy,z.xy)/dot(z.zw,z.zw) )*log(dot(z.xy,z.xy));\n\n\t\n    // do some soft coloring based on distance\n\td =  4.0*d/zo, 0.0, 1.0 ;\n\td = pow( d, 0.825 );\n    vec3 col = vec3( d );\n    \n    \n    vec2 q = p;\n\n    // Time varying pixel color\n    vec3 bol = 0.8 + 0.2*sin(myTime+p.xxx+vec3(0,2,6)) - 0.2*cos(myTime+p.yyy+vec3(6,1,3));\n    \n    float r = 0.5 + 0.4 * cos(atan(q.y,q.x)*16.0*sin(myTime+q.x-q.y) - 32.0*q.x*q.y*(cos(myTime+q.x-q.y)));\n    bol *= smoothstep(d, r-0.1-zo/2.0, length(atan(q.x,q.y)-d+1.0));\n    \n    fragColor = vec4(bol, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXXW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 258], [260, 260, 290, 290, 310], [312, 312, 342, 342, 495], [497, 497, 519, 519, 638], [665, 719, 776, 776, 2414]], "test": "error"}
{"id": "wsXXzf", "name": "Drunk Mondrian", "author": "japoneris", "description": "Piet Mondrian - Tableau (1921)", "tags": ["drunkmondrian"], "likes": 2, "viewed": 137, "published": "Public", "date": "1551769218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float expfilter(float x, float s) {\n \treturn exp(- x*x / (s*s));\n}\n\nfloat linefilter(float p, float pr, float w) {\n    \n    return step(pr, p) * step(1. - pr - w, 1.-p);\n}\n\nfloat rectangle(vec2 uv, float x0, float x1, float y0, float y1) {\n \t//return 0.;   \n\treturn step(uv.x, x1) * step(1.-uv.x, 1.-x0) * step(1. - uv.y, 1. - y0) * step(uv.y, y1);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    \n    float il0 = 0.35 + 0.05 * cos(0.5*iTime);\n    float il1 = 0.70 + 0.05 * cos(0.51*iTime);\n    float il3 = 0.15 + 0.1 * cos(iTime*1.1);\n    float il4 = 0.80 + 0.08 * cos(iTime*1.2);\n    float il5 = 0.95 + 0.03 * cos(iTime*1.3);\n    \n    float ih0 = 0.50 + 0.1 * cos(iTime*1.4);\n    float ih1 = 0.70 + 0.08 * cos(iTime*1.5);\n    float ih2 = 0.15 + 0.1 * cos(iTime*1.6);\n    \n    \n    \n    float lv0 = linefilter(uv.x, il0, 0.01);\n    float lv1 = linefilter(uv.x, il1, 0.01);\n    float lv2 = linefilter(uv.x, il4, 0.01);\n    float lv3 = linefilter(uv.x, il5, 0.01);\n    \n    \n    float lh0 = linefilter(uv.y, ih0, 0.01);\n    float lh1 = linefilter(uv.y, ih1, 0.01);\n    \n    float lhv0 = linefilter(uv.y, ih2, 0.01) * linefilter(uv.x, il0, 1.);\n    float lvh0 = linefilter(uv.x, il3, 0.01) * linefilter(uv.y, ih0, 1.);\n    \n    \n    \n    float lines = lv0 + lv1 +lv3 + lh0 + lh1 + lhv0 + lvh0;\n    \n    float rectr = rectangle(uv, 0., il0, ih0, 1.); \n    float rectb = rectangle(uv, il1, 1., 0., ih2);  \n    float rectj = rectangle(uv, il5, 1., ih0, 1.);  \n                            \n    \n    vec4 RectJ = vec4(rectj * vec3(0., 0., 0.9), 1.);\n    vec4 RectB = vec4(rectb * vec3(1., 1., 0.), 1.);\n    vec4 RectR = vec4(rectr * vec3(0.1, 1., 0.9), 1.);\n    \n    \n    // Output to screen R G B\n    fragColor = vec4(0.98 - lines, 1. - lines, 0.9 - lines, 1.0) - RectJ - RectB - RectR;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 66], [68, 68, 114, 114, 171], [173, 173, 239, 257, 355], [357, 357, 414, 464, 1900]], "test": "valid"}
{"id": "XlsSW4", "name": "Many Hearts", "author": "rubixcom", "description": "Many", "tags": ["pattern"], "likes": 3, "viewed": 84, "published": "Public", "date": "1553663481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(in vec2 uv)\n{\n    float ang = atan(uv.x,uv.y);\n    float l = length(uv);\n    uv.x = l*cos(iTime + ang);    \n    uv.y = l*sin(iTime + ang);\n\n    uv = mod(-3.*sin(0.1*iTime)*uv+vec2(iTime*2.,iTime*2.),1.0);\n    uv -= .5;\n    \n    uv *= length(uv) * 120. * (1.0 + .25 * fract(iTime));\n    float t = atan(uv.x,uv.y);\n    vec2 p;\n    p.x = 16. * sin(t);\n\tp.y = 13. * cos(t) - 5.*cos(2.*t)-2.*cos(3.*t)-cos(4.*t);\n    return (1.0/((length(p)-length(uv))*3.0 ));\n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5,.5);\n    uv. x *= iResolution.x / iResolution.y;\n\tvec2 pixelsize = 1.0 / iResolution.xy;\n    \n    vec3 o = vec3(uv.x,map(uv),uv.y);\n    \n    vec3 nx = o;\n    nx.x += pixelsize.x;\n    nx.y = map(nx.xz);\n    nx.x = o.x + 1.0;\n    nx = normalize(nx - o);\n\n    vec3 nz = o;\n    nz.z += pixelsize.y;\n    nz.y = map(nz.xz);\n    nz.z = o.z + 1.0;\n    nz = normalize(nz - o);\n\n    vec3 normal = cross(nz,nx);\n\n    vec3 lightLoc = vec3(\n        iMouse.x/ iResolution.x - .5,\n        /*1. + .5*sin(iTime),*/\n        .4,\n        iMouse.y/ iResolution.y - .5);\n    vec3 lightVec = normalize(lightLoc - o);\n\n    fragColor = \n        vec4(o.y > 0. ? 0.9 : 0., o.y < 0. ? 0.4 : 0. , o.y < 0. ? 0.7 : 0.,0.0) * \n        dot(normal,lightVec) / length(lightLoc - o);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsSW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 468], [470, 470, 527, 527, 1329]], "test": "valid"}
