{"id": "3d3SWr", "name": "shader cloth", "author": "MapleSyrupCS6", "description": "it's like a cloth", "tags": ["maplestudy"], "likes": 1, "viewed": 80, "date": "1571743533", "time_retrieved": "2024-06-20T19:45:41.957462", "image_code": "#define PI 3.141592653589793\n\nfloat rand(vec2 id)\n{\n    return sin(dot(id, vec2(12.9898, 78.233)) *43758.5453); \n}\n\nfloat distanceFunction(vec3 pos, float size){\n    return length(pos) - size;\n}\n\nfloat distanceFunction2( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat distanceFunction3(vec3 pos, vec3 b, float r){\n    \n    vec3 q = abs(pos) - b;\n    return length(max(q, 0.0) + min(max(q.x, max(q.y, q.z)), 0.0)) - r;\n}\n\nfloat df(vec3 p){\n    \n    float df1 = distanceFunction(p, 1.7);\n    p.x -= 5.5;\n    p.y += 0.2;\n    float df2 = distanceFunction2(p, vec2(2.0, 2.0));\n    p.x -= 5.5;\n    p.y -= 0.2;\n    float df3 = distanceFunction3(p, vec3(1.0, 1.0, 1.0), 0.5);\n    float m = min(df1, df2);\n    m = min(m ,df3);\n    return m;\n}\n\n\n\nvec3 normal(vec3 p, float size){\n    vec2 e = vec2(0.0001, 0);\n    float d  = df(p);\n    vec3 n = d- vec3(\n        df(p - e.xyy), \n        df(p - e.yxy),\n    \tdf(p - e.yyx));\n    return normalize(n);\n}\n\n\nvec3 image(vec2 uv){\n    \n    vec2 st = uv*2.0;\n    st = fract(st);\n    vec2 id = (floor(uv*2.0)+0.5)/2.0;\n    \n    float offs = rand(id)*60.;\n    float size = (1. + sin(iTime*3. + offs))*0.2;\n   \n    \n    float d = distance(st, vec2(0.5, 0.5));\n\td = step(d*sin(iTime*5.+offs), size);\n    \n    \n    vec3 col = vec3(0.0);\n    vec3 c1 = vec3(0.3, 0.5, 0.2);\n    vec3 c2 = vec3(0.7, 0.4, 0.3);\n   // col = mix(c1, c2, d);\n    col = vec3(0.2 , d, 0.4);\n    \n    return col;\n}\n\n\nvec3 image2(vec2 uv)\n{    \n    uv *= 10.0;\n    vec2 f_st = fract(uv);\n    vec2 id = uv;\n    \n\tfloat y = uv.y/abs(sin(iTime))*2.0 -cos(iTime)- sin(id.x*1.5 + iTime *PI);\n    y = smoothstep(0.05, 0.1, y);\n    \n    vec3 c1 = vec3(0.9, 0.75, 0.2);\n    vec3 c2 = vec3(0.3, 0.9, 0.9);\n    vec3 col = mix(c2, c1, y);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 CameraPos = vec3(5.5, 0, -15.);\n    float screenZ = 2.5;\n    vec3 RayDir = normalize(vec3(uv, screenZ));\n    vec3 lightDir = normalize(vec3(1.0, 1.0, -10.));\n    vec3 lightDir2 = normalize(vec3(3.0, 1.0, -100.));\n    vec3 lightDir3 = normalize(vec3(-3.0, 1.0, -100.));\n    \n    //float size = abs(sin(iTime*2.))*2.;\n    float depth = 0.0;\n    float dist = 0.0;\n    vec3 rayPos = vec3(0.0);\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 99; i++){\n     \trayPos = CameraPos + (RayDir * depth);   \n        dist = df(rayPos);\n        \n        if(dist < 0.0001) break;\n        \n        depth += dist;     \n    }\n    \n    \n    if(dist < 0.0001){\n     \t\n        vec3 n = normal(rayPos, 2.0);\n        float diff = dot(n, lightDir2+lightDir3);\n        vec3 c1 = vec3(0.5, 0.3, 0.2);\n        vec3 c2 = vec3(0.7, 0.9, 0.4);\n        vec3 im = image2(uv);\n        float d = rand(uv);\n        col = mix(c1, im, d);\n    }else{\n        float d = rand(uv);\n        vec3 cb = vec3(0.9, 0.2, 0.3);\n        vec3 cbr = vec3(0.4, 0.5, 0.8);\n     \tcol = mix(cb, cbr, d);  \n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d3SWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3d3XDr", "name": "raymarch v4", "author": "jorge2017a1", "description": "raymarch v4", "tags": ["raymarchv4"], "likes": 1, "viewed": 54, "date": "1571752196", "time_retrieved": "2024-06-20T19:45:42.631859", "image_code": "//Created by UltimateKimera in 2019-10-21\n//modificado por jorge2017a1 in 2019-10--22\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\n\n\n//Sphere function\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(c - p) - r;\n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(0,1,6,1);\n    vec4 sphere2 = vec4(0,0.5,3.0,0.25);\n    \n    //float dSphere = length(p-sphere.xyz)-sphere.w;\n    \n    \n    float dSphere, dSphere2;\n    dSphere=sdSphere( sphere.xyz, p ,sphere.w );\n    dSphere2=sdSphere( sphere2.xyz, p ,sphere2.w );\n    \n    float dPlane = p.y;\n    float d;\n     d= min(dSphere, dPlane);\n     d= min(d, dSphere2);\n    \n    \n    \n    float bx1, bx2, bx3, bx4, bx5, bx6;\n    float bxl1, bxl2, bxl3, bxl4, bxl5, bxl6;\n    \n    //bx1=sdBox( p-vec3(0.5,0.1,0), vec3(0.8,0.5,0.5) );\n    \n    \n    \n    bx1 = sdBox(p- vec3(0, 0, 16), vec3(5.5, 5.8, 0.5));\n    bx2 = sdBox(p- vec3(1.5, 0, 6), vec3(0.5, 1.8, 0.5));\n    bx3 = sdBox(p- vec3(3.5, 0, 6), vec3(0.15, 1.0, 1.5));\n    bx4 = sdBox(p- vec3(3.7, 1.5, 6), vec3(0.15, 0.5, 1.5));\n    bx5 = sdBox(p- vec3(3.9, 2.5, 6), vec3(0.15, 0.5, 1.5));\n    bx6 = sdBox(p- vec3(4.1, 3.5, 6), vec3(0.15, 0.5, 1.5));\n    \n    \n    bxl1 = sdBox(p- vec3(-0.1, 0,10), vec3(4.5, 2.8, 0.5));\n    bxl2 = sdBox(p- vec3(-1.5, 0, 6), vec3(0.5, 1.8, 0.5));\n    bxl3 = sdBox(p- vec3(-3.5, 0, 6), vec3(0.15, 1.0, 1.5));\n    bxl4 = sdBox(p- vec3(-3.7, 1.5, 6), vec3(0.15, 0.5, 1.5));\n    bxl5 = sdBox(p- vec3(-3.9, 2.5, 6), vec3(0.15, 0.5, 1.5));\n    bxl6 = sdBox(p- vec3(-4.1, 3.5, 6), vec3(0.15, 0.5, 1.5));\n    \n    \n    d= min(d, bx1); \t\n  \td= min(d, bx2);\n  \td= min(d, bx3);\n  \td= min(d, bx4);\n  \td= min(d, bx5);\n  \td= min(d, bx6);\n    \n    d= min(d, bxl1); \t\n  \td= min(d, bxl2);\n  \td= min(d, bxl3);\n  \td= min(d, bxl4);\n  \td= min(d, bxl5);\n  \td= min(d, bxl6);\n    \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + dO*rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dS<SURFACE_DIST || dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 e = vec2(.01, 0);\n    float d = GetDist(p);\n    vec3 n = vec3(\n    \td-GetDist(p-e.xyy),\n        d-GetDist(p-e.yxy),\n        d-GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n    if (d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,3.5+2.5*sin(iTime),0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d3XDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3d3XRn", "name": "Out of sync", "author": "nucleomancer", "description": "Just a test building on the first tutorial.", "tags": ["gradients", "sinewaves"], "likes": 4, "viewed": 104, "date": "1571252621", "time_retrieved": "2024-06-20T19:45:42.753143", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(7.8*((fract(iTime)*0.002)+0.34)*(uv.y+0.74)*sin(3.9*(uv.x+0.7)*cos(iTime+uv.xyx+vec3(0,2,4))));\n\n    // Output to screen\n    fragColor = vec4(col,0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d3XRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3d3XWM", "name": "Helix (1)", "author": "Synth4NTAGONIST", "description": "An animated helix with blue and red spheres.", "tags": ["helix3draymarchsdspheresdcapsule"], "likes": 3, "viewed": 68, "date": "1572125176", "time_retrieved": "2024-06-20T19:45:42.753143", "image_code": "#define PI (acos(-1.))\n\nstruct mapdata {\n    int id;\n    float dist;\n};\n\nstruct hitpoint {\n    bool hit;\n    mapdata data;\n\tvec3 pos;\n    vec3 normal;\n};\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nmapdata mapMin(mapdata d1, mapdata d2) {\n    mapdata result = d1;\n    if (d2.dist < d1.dist) {\n        result.id = d2.id;\n        result.dist = d2.dist;\n    }\n    return result;\n}\n\nmapdata map(vec3 p) {\n    mapdata result;\n    \n    vec3 pp1 = p;\n    vec3 pp2 = p;\n    \n    float r = 0.2;\n    float t = PI + 0.5 * iTime;\n    float twist = -0.67 * p.y;\n    pp1.x += r * cos(t + twist);\n    pp1.z += r * sin(t + twist);\n    pp2.x += r * cos(t + PI + twist);\n    pp2.z += r * sin(t + PI + twist);\n    \n    float rep = 0.33;\n    pp1.y = mod(p.y, rep)-0.5*rep;\n    pp2.y = pp1.y;\n    \n    // Spheres\n    float spr = 0.09;\n    float spd1 = sdSphere(pp1, spr);\n    float spd2 = sdSphere(pp2, spr);\n    result = mapMin(mapdata(1, spd1), mapdata(2, spd2));\n    \n    // Connecting line\n   \tfloat cad = sdCapsule(pp1, vec3(0, 0, 0), pp1 - pp2, 0.02);\n    result = mapMin(result, mapdata(3, cad));\n    \n    return result;\n}\n\nvec3 lookAt(vec2 uv, vec3 origin, vec3 target, float fov) {\n\tvec3 zz = normalize(target - origin);\n    vec3 xx = normalize(cross(zz, vec3(0,1,0)));\n    vec3 yy = normalize(cross(xx, zz));\n    return normalize(uv.x * xx + uv.y * yy + fov * zz); \n}\n\nvec3 normal(vec3 pos) {\n    vec2 e = vec2(0.0005, 0.);\n    return normalize(\n        vec3(\n            map(pos + e.xyy).dist - map(pos - e.xyy).dist,\n            map(pos + e.yxy).dist - map(pos - e.yxy).dist,\n            map(pos + e.yyx).dist - map(pos - e.yyx).dist\n        )\n    );\n}\n\nfloat diffuse(vec3 nor, vec3 lightDir) {\n    return clamp( dot(nor, lightDir), 0.0, 1.0);\n}\n\nhitpoint raycast(vec3 ro, vec3 rd) {\n    hitpoint h;\n    \n    // Raymarching\n    float t = 0.0;\n    mapdata m;\n    for(int i=0; i<100; i++) {\n        mapdata m = map(ro + t * rd);\n        float d = m.dist; \n        if (abs(d) < 0.001) {\n            h.hit = true;\n            h.data = m;\n            h.pos = ro + t * rd;\n            h.normal = normal(h.pos);\n            break;\n        }\n        t += d;\n        if (t > 20.) {\n            break;\n        }\n    }\n    return h; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.1, 0.1, .6 * (uv.y + 0.5));\n    \n    // Camera\n    float ct = -0.5 * iTime;\n    vec3 ro = vec3(0, ct, 1.);\n    vec3 rd = lookAt(uv, ro, vec3(0, -2. + ct, 0), 1.);\n    \n    // Render\n    hitpoint h = raycast(ro, rd);\n    if (h.hit) {\n    \tfloat c = 0.0;\n    \tc += (2. * uv.y + 0.8) * diffuse(h.normal, vec3(1, 1, 2));\n        float shadow = 0.8 * diffuse(h.normal, vec3(-1, 0, 0));\n    \tc += pow(shadow, 3.);\n        \n        vec3 mat = vec3(0);\n        if (h.data.id == 1) {\n            mat = vec3(0.9, 0.1, 0.1);\n        } else if (h.data.id == 2) {\n            mat = vec3(0.1, 0.1, 0.9);\n        } else if (h.data.id == 3) {\n            mat = vec3(0.3, 0.6, 0.3);\n        }\n        \n\t    col = mat * c;\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d3XWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dc3z8", "name": "square asdfasdf", "author": "patrickgh3", "description": "asdf", "tags": ["neon"], "likes": 2, "viewed": 57, "date": "1571429787", "time_retrieved": "2024-06-20T19:45:43.480584", "image_code": "bool inSquare(float x, float y, float w, float h,\n              float px, float py) {\n \treturn px > x-w/2.0 && px < x+w/2.0\n        && py > y-h/2.0 && py < y+h/2.0;\n}\n\nbool inSquareOutline(float x, float y, float w, float h,\n                     float px, float py) {\n    return inSquare(x, y, w, h, px, py)\n        && !inSquare(x, y, w-0.012, h-0.012, px, py);\n}\n\nbool inArc(float x, float y, float r,\n           float angle, float timeScalar, float timeOffset,\n           float size,\n           float px, float py) {\n    float dist = distance(vec2(x, y), vec2(px, py));\n    \n    bool inAngle = dot(vec2(px-x, py-y),\n        vec2(cos(angle), sin(angle))) < size;\n    float angleShift = iTime*timeScalar + timeOffset;\n    bool inAngleShifting = dot(vec2(px-x, py-y),\n        vec2(cos(angleShift), sin(angleShift))) < size;\n    \n    return dist < r && dist > r-0.005 && inAngle && inAngleShifting;\n}\n\nbool inCircle(float x, float y, float r,\n              float px, float py) {\n    float dist = distance(vec2(x, y), vec2(px, py));\n    return dist < r && dist > r-0.005;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Temp scale it down so it's a square in ShaderToy\n    uv.x *= 800.0/450.0;\n    \n    // Mirror x and y\n    uv.x = abs(uv.x-0.5)+0.5;\n    uv.y = abs(uv.y-0.5)+0.5;\n    \n    vec4 outColor = vec4(0, 0, 0, 0);\n\n    // White glow from center\n    //float r = distance(uv, vec2(0.5, 0.5));\n    //float alpha = 1.0-r*2.0;\n    //outColor = vec4(alpha, alpha, alpha, 1);\n    \n    vec4 squareColor = vec4(0.9, 0.4, 0.7, 1.0);\n    \n    // Static square\n    outColor += float(inSquareOutline(0.5, 0.5, 0.25, 0.25, uv.x, uv.y))\n        \t* (-outColor + squareColor*0.3);\n    \n    // Moving squares\n    float squareT = mod(iTime*0.25, 1.0);\n    float w0 = mix(0.05, 0.2, squareT);\n    float a0 = mix(0.0, 1.0, squareT);\n    float w1 = mix(0.2, 0.4, squareT);\n    float a1 = 1.0;\n    float w2 = mix(0.4, 0.65, squareT);\n    float a2 = mix(1.0, 0.0, squareT);\n    outColor += float(inSquareOutline(0.5, 0.5, w0, w0, uv.x, uv.y))\n        \t* (-outColor + squareColor*a0);\n    outColor += float(inSquareOutline(0.5, 0.5, w1, w1, uv.x, uv.y))\n        \t* (-outColor + squareColor*a1);\n    outColor += float(inSquareOutline(0.5, 0.5, w2, w2, uv.x, uv.y))\n        \t* (-outColor + squareColor*a2);\n    \n    // Center square\n    outColor += float(inSquareOutline(0.5, 0.5, 0.05, 0.05, uv.x, uv.y))\n        \t* (-outColor + squareColor);\n    \n    // Inner arcs\n    float inX = 0.013;\n    float inY = 0.12;\n    float inR = 0.1;\n    float inA = 0.2;\n    float inAS = 3.0;\n    float inAO = 3.0;\n    float inSize = -0.03;\n    vec4 inArcColor = vec4(1.0, 1.0, 0.7, 1.0);\n    \n    outColor += float(inArc(0.5-inX, 0.5+inY, inR,\n                            inA, -inAS, 0.0, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5-inX, 0.5-inY, inR,\n                            -inA, inAS, 0.0, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5+inX, 0.5+inY, inR,\n                            3.14-inA, inAS, inAO, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5+inX, 0.5-inY, inR,\n                            3.14+inA, -inAS, inAO, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    // Outer arcs\n    inX = 0.22;\n    inY = 0.15;\n    inR = 0.2;\n    inA = 4.3;\n    inAS = -3.0;\n    inAO = 3.0;\n    inSize = -0.05;\n    inArcColor = vec4(0.7, 0.8, 1.0, 1.0);\n    \n    outColor += float(inArc(0.5-inX, 0.5+inY, inR,\n                            inA, -inAS, 0.0, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5-inX, 0.5-inY, inR,\n                            -inA, inAS, 0.0, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5+inX, 0.5+inY, inR,\n                            3.14-inA, inAS, inAO, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5+inX, 0.5-inY, inR,\n                            3.14+inA, -inAS, inAO, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    // Static circles\n    //outColor += float(inCircle(0.7, 0.5, 0.012, uv.x, uv.y))\n    //    \t* (-outColor + vec4(0.5, 1.0, 0.7, 1.0));\n    \n    // Final output assignment\n    fragColor = outColor;\n}\n\n// Time varying pixel color\n//vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n// Output to screen\n//fragColor = vec4(col,1.0);", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dc3z8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dcSDn", "name": "some early 2000s movie company", "author": "SputNix", "description": "idk what to write here", "tags": ["glowyshiny"], "likes": 4, "viewed": 79, "date": "1571736360", "time_retrieved": "2024-06-20T19:45:43.480584", "image_code": "vec2 rotate2D(vec2 _st, float _angle){\n    _st =  mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle)) * _st;\n    return _st;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    vec2 polar = vec2(length(uv), atan(uv.y / uv.x));   \n    uv = rotate2D(uv, iTime);    \n    vec3 bg = vec3(sin((abs(uv.x) + abs(uv.y)) * 2. - iTime), sin((abs(uv.x) + abs(uv.y)) *3.  - iTime), sin((abs(uv.x) + abs(uv.y)) *4.  - iTime));    \n    float glowy = length(uv) * 2. * smoothstep(0.1, sin(length(vec2(polar.x, polar.y)) * 5. - iTime *2.), 0.3);        \n    vec3 col = clamp(glowy * bg + bg * 0.5 + glowy * 0.5, -.4 ,1.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dcSDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dcSDr", "name": "raymarch v3", "author": "jorge2017a1", "description": "raymarch v3", "tags": ["raymarchv3"], "likes": 0, "viewed": 60, "date": "1571751474", "time_retrieved": "2024-06-20T19:45:44.171383", "image_code": "//Created by UltimateKimera in 2019-10-21\n//modificado por jorge2017a1 in 2019-10--22\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\n\n\n//Sphere function\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(c - p) - r;\n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(0,1,6,1);\n    vec4 sphere2 = vec4(0,0.5,3.0,0.25);\n    \n    //float dSphere = length(p-sphere.xyz)-sphere.w;\n    \n    \n    float dSphere, dSphere2;\n    dSphere=sdSphere( sphere.xyz, p ,sphere.w );\n    dSphere2=sdSphere( sphere2.xyz, p ,sphere2.w );\n    \n    float dPlane = p.y;\n    float d;\n     d= min(dSphere, dPlane);\n     d= min(d, dSphere2);\n    \n    \n    \n    float bx1, bx2, bx3, bx4, bx5, bx6;\n    float bxl1, bxl2, bxl3, bxl4, bxl5, bxl6;\n    \n    //bx1=sdBox( p-vec3(0.5,0.1,0), vec3(0.8,0.5,0.5) );\n    \n    \n    \n    bx1 = sdBox(p- vec3(0, 0, 16), vec3(5.5, 5.8, 0.5));\n    bx2 = sdBox(p- vec3(1.5, 0, 6), vec3(0.5, 1.8, 0.5));\n    bx3 = sdBox(p- vec3(3.5, 0, 6), vec3(0.15, 1.0, 1.5));\n    bx4 = sdBox(p- vec3(3.7, 1.5, 6), vec3(0.15, 0.5, 1.5));\n    bx5 = sdBox(p- vec3(3.9, 2.5, 6), vec3(0.15, 0.5, 1.5));\n    bx6 = sdBox(p- vec3(4.1, 3.5, 6), vec3(0.15, 0.5, 1.5));\n    \n    \n    bxl1 = sdBox(p- vec3(-0.1, 0,10), vec3(4.5, 2.8, 0.5));\n    bxl2 = sdBox(p- vec3(-1.5, 0, 6), vec3(0.5, 1.8, 0.5));\n    bxl3 = sdBox(p- vec3(-3.5, 0, 6), vec3(0.15, 1.0, 1.5));\n    bxl4 = sdBox(p- vec3(-3.7, 1.5, 6), vec3(0.15, 0.5, 1.5));\n    bxl5 = sdBox(p- vec3(-3.9, 2.5, 6), vec3(0.15, 0.5, 1.5));\n    bxl6 = sdBox(p- vec3(-4.1, 3.5, 6), vec3(0.15, 0.5, 1.5));\n    \n    \n    d= min(d, bx1); \t\n  \td= min(d, bx2);\n  \td= min(d, bx3);\n  \td= min(d, bx4);\n  \td= min(d, bx5);\n  \td= min(d, bx6);\n    \n    d= min(d, bxl1); \t\n  \td= min(d, bxl2);\n  \td= min(d, bxl3);\n  \td= min(d, bxl4);\n  \td= min(d, bxl5);\n  \td= min(d, bxl6);\n    \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + dO*rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dS<SURFACE_DIST || dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 e = vec2(.01, 0);\n    float d = GetDist(p);\n    vec3 n = vec3(\n    \td-GetDist(p-e.xyy),\n        d-GetDist(p-e.yxy),\n        d-GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n    if (d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dcSDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dcSzf", "name": "Deep Trip", "author": "jin_x", "description": "My first shader!", "tags": ["fractal", "julia"], "likes": 2, "viewed": 42, "date": "1572461420", "time_retrieved": "2024-06-20T19:45:44.171383", "image_code": "const int MAX_ITER = 128;\nconst int LIM = MAX_ITER / 2;\n\nconst float PARAM = 0.387;\nconst float COEF = 0.80;\n\nconst float ROT = 5.0;\n\nconst float PRE = 15.0;\nconst float DUR = 60.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = iTime - PRE;\n    if (t > 0.0) {\n        t = mod(t, DUR);\n    \tif (t >= DUR / 2.0) { t = DUR - t; }\n    }\n    float zoom = pow(COEF, t + PRE);\n    \n    float mxy = min(iResolution.x, iResolution.y);\n    vec2 cxy = iResolution.xy / mxy;\n    vec2 uv = (fragCoord / mxy - 0.5 * cxy) * 75.0 * zoom;\n    \n    // Rotate : x' = x*cos(a) - y*sin(a), y' = x*sin(a) + y*cos(a)\n    \n    float sa = sin(iTime/ROT), ca = cos(iTime/ROT);\n    uv *= mat2(ca, -sa, sa, ca);\n    \n    // Julia : x = x^2 - y^2 + x, y = 2 * x * y + y\n    \n    vec2 xy = uv;\n    int iter = 0;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        vec2 xy2 = xy * xy;\n        if (xy2.x + xy2.y > 4.0) { break; }\n        xy = vec2(xy2.x - xy2.y + (PARAM + zoom), 2.0 * xy.x * xy.y + (PARAM + zoom));\n        ++iter;\n    }\n\n    if (iter < LIM) {\n        fragColor = vec4(0.0, 1.0 - float(iter)/float(LIM), float(iter)/float(LIM), 1.0);\n    } else if (iter == MAX_ITER) {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } else {\n        fragColor = vec4(1.0 - float(iter-LIM)/float(LIM), 0.0, 1.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dcSzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dcSzS", "name": "Shadertober 27 Julia -jaburns", "author": "jaburns", "description": "Explore the relationship between the Mandelbrot set and the Julia sets.", "tags": ["fractal", "julia", "mandelbrot"], "likes": 0, "viewed": 275, "date": "1572216185", "time_retrieved": "2024-06-20T19:45:44.171383", "image_code": "float map( vec2 z, vec2 c )\n{\n    float i = 0.;\n    \n    for( ; i < 150.; ++i ) {\n        z = vec2(\n            z.r*z.r - z.g*z.g + c.r,\n            2.*z.r*z.g + c.g\n        );  \n        if (length(z) > 40.) break;\n    }\n    \n    if (i >= 150.) return 0.;\n    \n    i = i - log(length(z)) / log(40.);\n    \n    return( i / 35. );\n}\n\nfloat sampJulia( vec2 uv, vec2 muv, vec2 offset )\n{\n    return map( uv + offset / iResolution.xy, muv );\n}\n\nfloat sampMandelbrot( vec2 uv, vec2 offset )\n{\n    return map( vec2( 0 ), uv + offset / iResolution.xy );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = 2.*( fragCoord/iResolution.yy - vec2(.5 * iResolution.x/iResolution.y, .5) ) - vec2(.5, 0);\n    vec2 muv;\n    \n    if( iMouse.z > 0.0 ) {\n        muv = 2.*( iMouse.xy/iResolution.yy - vec2(.5 * iResolution.x/iResolution.y, .5) ) - vec2(.5, 0);\n    } else {\n        float t = .1*iTime;\n        muv = vec2(.9*sin( t ) - .4, .8*cos( t ));\n    }\n    \n    float lm = length(uv - muv) + .01;\n    float c = clamp(.0002 / lm /lm, 0., 1.);\n    \n    float ja = sampJulia(uv, muv, vec2(-.75, .25));\n    float jb = sampJulia(uv, muv, vec2(-.25,-.75));\n    float jc = sampJulia(uv, muv, vec2( .25, .75));\n    float jd = sampJulia(uv, muv, vec2( .75,-.25));\n    float j = 0.25*(ja + jb + jc + jd);\n    \n    float ma = sampMandelbrot(uv, vec2(-.75, .25));\n    float mb = sampMandelbrot(uv, vec2(-.25,-.75));\n    float mc = sampMandelbrot(uv, vec2( .25, .75));\n    float md = sampMandelbrot(uv, vec2( .75,-.25));\n    float m = 0.25*(ma + mb + mc + md);\n\n    fragColor = vec4(c, j, m, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dcSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dcXz8", "name": "shadetober #17 (ornament)", "author": "percentcer", "description": "Inktober, but with shaders.\n\nThis one feels unsuccessful to me (theme wise) but I kinda like where it ended up.", "tags": ["inktober", "shadertober", "shadetober", "inktober2019"], "likes": 0, "viewed": 197, "date": "1571730663", "time_retrieved": "2024-06-20T19:45:44.789622", "image_code": "#define NUMBEADS 10\n#define PI2 6.283\nvec3 path(float t) {\n    // I wanted a spiral of beads that would chase each other around\n    // (i.e. by doing something like opTwist) but I couldn't get it\n    // looking right, settled for this spiral-y effect where the beads\n    // end up intersecting, so I just used soft min to have them glob\n    // together without discontinuities which ended up looking interesting\n    float k = .2;\n    vec3 p = vec3(cos(t) * (1. - abs(sin(t*k))), sin(t*k) * 1.2, sin(t) * (1. - abs(sin(t*k))));\n    return p;\n}\n\nfloat sdSphere(vec3 p, float t) {\n    return length(p - path(t)) - .1;\n}\n\nfloat sdGround(vec3 p) {\n    return p.y + 1.5;\n}\n\n//https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p ) {\n    // this seems like it could be sped up, NUMBEADS impacts performance more than I expected\n    float dist = sdGround(p);\n    for(int i = 0; i < NUMBEADS; i++) {\n        float slice = float(i)/float(NUMBEADS);\n        dist = smin(dist, sdSphere(p, iTime + slice * PI2), .5);\n    }\n\treturn dist;\n}\n\nvec3 grad(vec3 p) {\n    vec2 eps = vec2(.001,0.);\n    return normalize(map(p) - vec3(map(p - eps.xyy), map(p - eps.yxy), map(p-eps.yyx)));\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0.;\n    vec3 p;\n    for (int i = 0; i < 100; i++) {\n        p = ro + rd * t;\n        float d = map(p);\n        if (d < 0.001 || t > 100.) break;\n        t += d;\n    }\n    return p;\n}\n\n// https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    // start the ray a little bit away from\n    // the surface to avoid self intersection\n    float t = .1;\n    float result = 1.;\n    for (int i = 0; i < 10; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        result = min(result, k * d / t);\n        if (result < 0.001) {\n            return 0.0;\n        }\n        t += d;\n        if(t>10.){break;}\n    }\n    return result;\n}\n\nvec3 light(vec3 p, vec3 c, vec3 ld) {\n    vec3 n = grad(p);\n    float incid = dot(n, ld);\n    vec3 diffuse = c * incid;\n    // this shadow calculation also slows things down a lot (it's doing \n    // the ray march a second time from the initial contact point), \n    // wonder if there's a way to speed that up as well\n    diffuse *= shadow(p, ld, 4.);\n    return diffuse;\n}\n\n// basic y rotation used for moving the lights around\nmat3 roty(float a) {\n    return mat3(\n        cos(a), 0., -sin(a),\n        0., 1., 0.,\n        sin(a), 0., cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0., 0., 2.);\n    vec3 rd = normalize(vec3(uv, -1.));\n\n    // scene has a red and green light that rotate around the ornament\n    vec3 ld2 = normalize(vec3(-.45, .2, .45));\n    vec3 ld3 = normalize(vec3(.0, .2, -.45));\n    ld2 *= roty(iTime * .21);\n    ld3 *= roty(iTime * .21);\n    \n    // march and do lighting calcs\n    vec3 p = march(ro, rd);\n    vec3 col = light(p, vec3(16, 233, 25)/255., ld2);\n    col += light(p, vec3(227, 21, 25)/255., ld3);\n    \n    // iq's gamma\n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dcXz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ddSWn", "name": "magic key", "author": "lnae", "description": "An anaglyph shader for the 3rd issue of https://fanzine.cookie.paris/\n(Use red/cyan glasses)", "tags": ["anaglyph", "key", "npr"], "likes": 23, "viewed": 201, "date": "1571791681", "time_retrieved": "2024-06-20T19:45:44.795683", "image_code": "#define STEREO 1\n\n#define PI 3.14159\n#define STEPS 100.\n#define EPS 0.00001\n#define EPSN 0.001\n#define EPSOUT 0.0015\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * (a - b) / k, 0., 1.);\n    return mix(a, b, f) - k * f * (1. - f);\n}\n\nvec2 repeat(vec2 pos, float t){\n\tt = 2. * PI / t;\n    float angle = mod(atan(pos.y, pos.x) , t) - 0.5 * t;\n    float r = length(pos);\n    return r * vec2(cos(angle), sin(angle));\n}\n\nfloat distEllipsoid(vec3 p, vec3 r){\n    float lg = length(p /(r * r));\n\treturn (length(p / r) - 1.) * (length(p / r)) / lg;\n}\n\nfloat distRing(vec3 p, vec2 r){\n  vec2 t = vec2(length(p.xz)-r.x,p.y);\n  return length(t)-r.y;\n}\n\nfloat distBox(vec3 p, vec3 r){\n  vec3 t = abs(p) - r;\n  return length(max(t,0.0)) + min(max(t.x,max(t.y,t.z)),0.0);\n}\n\nfloat distScene(in vec3 pos, out int object){\n\t \n    pos.yz = rot(0.2 + 0.25 * (0.5 + 0.5 * sin(0.25 * iTime - 0.5 * PI))) * pos.yz;\n    pos.xz = rot(0.25 * iTime) * pos.xz;\n    pos.y += 0.1 + 0.0125 * sin(iTime);\n    \n    pos.xy = rot(-0.4) * pos.xy;\n    pos.xz = rot(0.6) * pos.xz;\n    pos.yz = rot(0.4) * pos.yz;\n\n    //gem\n    vec3 p = pos;\n    p.y -= 0.155;\n    float dist = length(p) - 0.05;\n    object = 1;\n    \n    //gold ?\n    p = pos;        \n    p.y -= 0.11;\n    float distGold = distEllipsoid(p, vec3(0.03, 0.01, 0.03));\n    distGold = smoothmin(distGold, max(max(length(p.xz) - 0.0175, p.y), -p.y - 0.25), 0.035);\n    distGold = smoothmin(distGold, distEllipsoid(p - vec3(0., -0.25, 0.), vec3(0.01, 0.01, 0.01)), 0.035);\n\tdistGold = min(distGold, distEllipsoid(p, vec3(0.04, 0.01, 0.04)));\n    distGold = min(distGold, distEllipsoid(p - vec3(0., -0.05, 0.), vec3(0.0225, 0.01, 0.0225)));\n    distGold = min(distGold, distEllipsoid(p - vec3(0., -0.25, 0.), vec3(0.025, 0.01, 0.025)));\n    distGold = min(distGold, distEllipsoid(p - vec3(0., -0.175, 0.), vec3(0.0225, 0.01, 0.0225)));\n\n    p.y -= 0.115;\n    distGold = smoothmin(distGold, distRing(p.xzy, vec2(0.12, 0.0075)), 0.02);\n    \n    p.y -= 0.015;\n    p.xy = rot(3. * PI/2.) * p.xy;\n    p.xy = repeat(p.xy, 5.);\n    distGold = smoothmin(distGold, max(max(length(p.yz), length(p) - 0.15), -(length(p) - 0.08)), 0.03);\n    \n    float distStar = distEllipsoid(p, vec3(0.02, 0.02, 0.015));\n    p.x -= 0.03;\n    distStar = smoothmin(distStar, length(p), 0.03);\n\tdistGold = min(distGold, distStar);\n    \n    p = pos;\n    p.y -= 0.15;\n    distGold = smoothmin(distGold, distRing(p.xzy, vec2(0.055, 0.006)), 0.00015);\n    p.y += 0.24;\n    p.x -= 0.02;\n    distGold = min(distGold, distBox(p, vec3(0.02, 0.0075, 0.005)));\n    p.y += 0.029;\n    distGold = min(distGold, distBox(p, vec3(0.02, 0.01, 0.005)));\n    p.y -= 0.01;\n    distGold = min(distGold, distBox(p, vec3(0.01, 0.02, 0.005)));\n    \n    dist = min(dist, distGold);\n    \n    if(dist == distGold){\n        object = 3;\n    }\n    \n    if(dist == distStar){\n        object = 4;\n    }\n    \n    //wings\n    p = pos;\n    p.y -= 0.05 + 0.008 * sin(1.5 * iTime);\n    p.x = abs(p.x) - 0.05;\n    float distWing = length(p) - 0.015;\n    vec3 pBranch = p;\n    pBranch -= vec3(0.055, 0.04, 0.);\n    float rt = 10. * pBranch.x;\n    pBranch.xy = rot(rt * rt) * pBranch.xy;\n    distWing = smoothmin(distWing, distEllipsoid(pBranch, vec3(0.08, 0.015, 0.02)), 0.01);\n    pBranch = p;\n    pBranch.xy = rot(-0.25) * pBranch.xy;\n    pBranch -= vec3(0.052, 0.035, 0.);\n    rt = 8. * pBranch.x;\n    pBranch.xy = rot(rt * rt) * pBranch.xy;\n\tdistWing = smoothmin(distWing, distEllipsoid(pBranch, vec3(0.07, 0.015, 0.0175)), 0.005);\n    pBranch = p;\n    pBranch.xy = rot(-0.5) * pBranch.xy;\n    pBranch -= vec3(0.04, 0.025, 0.);\n    rt = 8. * pBranch.x;\n    pBranch.xy = rot(rt * rt) * pBranch.xy;\n\tdistWing = smoothmin(distWing, distEllipsoid(pBranch, vec3(0.05, 0.0125, 0.015)), 0.0075);\n        \n    dist = min(dist, distWing);\n    if(dist == distWing){\n        object = 2;\n    }\n    return 0.5 * dist;\n\n}\n\n\nvec3 getNormal(vec3 p){\n    int o;\n\treturn normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), o) - distScene(p - vec3(EPSN, 0., 0.), o),\n    \t\t\t\t\t  distScene(p + vec3(0., EPSN, 0.), o) - distScene(p - vec3(0., EPSN, 0.), o),\n                          distScene(p + vec3(0., 0., EPSN), o) - distScene(p - vec3(0., 0., EPSN), o)));\n}\n\n\nvec3 render(vec2 uv, float eyeOffset){\n    \n    //background\n    vec3 bgColor = vec3(0.);\n    vec3 inkColor = bgColor;\n    vec2 uvbg = 5. * uv - vec2(0.25 * eyeOffset, 0.);\n    float time = 0.05 * iTime;\n    float angle = atan(uvbg.y, uvbg.x) + 2.0 * sin(PI * time);\n    float radius = length(uvbg);      \n    float k = 10. / 7.;\n    float offset = 0.1 + sin(2.6 * sin(1.9 * sin(PI * time)));\n        \n    float res = 10000.0;    \n    for(float i = 0.0; i < 7.; i++){\n    \tangle += 2.0 * PI;\n        res = min(res, abs(radius - (1. / (cos(k * angle) + offset))));\n    }    \n  \tres = min(res, abs(radius - offset - 0.8));\n    res = min(res, abs(radius - offset - 1.));\n    \n    float bg = smoothstep(0., 0.01, res);\n    vec3 col = mix(vec3(0.1, 0.1, 0.1), bgColor,  bg);\n    \n    //raymarch\n    vec3 eye = vec3(eyeOffset, 0., 2.);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 forward = normalize(-eye);\n    vec3 ray = normalize(1.5 * forward + normalize(cross(forward, up)) * uv.x + up * uv.y);\n    int o;\n    float dist, step, c, prevDist;\n    bool hit = false;\n    vec3 pos = eye;\n    dist = distScene(pos, o);\n    float outline = 1.;\n    \n    for(step = 0.; step < STEPS; step++){\n        prevDist = dist;\n    \tdist = distScene(pos, o);\n        if(dist > prevDist + EPS && dist < EPSOUT ){\n        \toutline = min(outline, dist);\n        }\n        if(abs(dist) < EPS){\n        \thit = true;\n            break;\n        }\n        if(length(pos) > 3.) break;\n    \tpos += dist * ray;\n    }\n    outline /= EPSOUT;\n    \n    vec3 normal = getNormal(pos);\n    \n    //shading\n    if(hit){\n    \tvec3 light = vec3(10., 5., 12.);\n        light.yz = rot(0.5) * light.yz;\n        float shine = 30.;\n        \n        if(o == 1){\n            col = vec3(0.65, 0.4, 0.9);\n        }\n        if(o == 2){\n            col = vec3(0.75, 0.75, 0.75);\n        \tshine = 5.;\n        }\n\t\tif(o == 3){\n            col = vec3(0.95, 0.85, 0.4);\n            shine = 20.;\n        }\n        if(o == 4){\n        \tcol = vec3(0.75, 0.75, 0.75);\n        }\n        \n        //diffuse\n        vec3 l = normalize(light - pos);\n        if(o == 1){\n            float diff = dot(-normal, l);\n            if(o != 0) col = mix(col, vec3(0., 0., 0.15), 0.45 * (1. - diff));\n        }else{\n        \tfloat diff = dot(normal, l);\n        \tdiff = smoothstep(0.3, 0.35, diff);\n            if(o != 0) col = mix(col, vec3(0., 0., 0.5), 0.3 * (1. - diff));\n        }\n        \n        //specular\n        vec3 refl = reflect(-l, normal);\n        float spec = pow(dot(normalize(eye - pos), refl), shine);\n        spec = smoothstep(0.5, 0.55, spec);\n        col += 0.02 * shine * spec;\n        \n        //outline\n        outline = smoothstep(0.75, 0.95, outline);\n        col = mix(inkColor, col, outline);\n    }  \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    uv *= 0.8;\n#if STEREO\n    //using the Dubois anaglyph method for the colors\n    vec3 colorLeft = render(uv, -0.05);\n    mat3 transfoLeft = mat3(vec3(0.42, -0.05, -0.05),\n    \t\t\t\t\t\tvec3(0.47, -0.05, -0.06),\n                           \tvec3(0.17, -0.03, 0.01));\n    vec3 colorRight = render(uv, 0.05);\n    mat3 transfoRight = mat3(vec3(-0.01, 0.38, -0.07),\n    \t\t\t\t\t\tvec3(-0.04, 0.73, -0.13),\n                           \tvec3(-0.01, 0.01, 1.30));\n    fragColor = vec4(pow(transfoLeft * colorLeft + transfoRight * colorRight, vec3(1. / 2.2)),1.0);\n#else\n    fragColor = vec4(pow(render(uv, 0.), vec3(1./2.2)), 1.);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ddSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ddSWr", "name": "Test_drgsrthdrhdrtyjhr", "author": "MallSerg", "description": "clone https://www.shadertoy.com/view/XdsGDB", "tags": ["ray"], "likes": 7, "viewed": 154, "date": "1571787927", "time_retrieved": "2024-06-20T19:45:47.056511", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float tau = 6.28318530717958647692;\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n    return pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n    \n}\n\nvec3 localRay;\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\n{\n\t\n\n  //    rotation = vec2(.34,.3);    \n    \n    // get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;// смещение камеры 0.5 центр\n    \n    \n\tray.z = iResolution.y*zoom*1.3; // зум камеры\n\tray = normalize(ray);\n\tlocalRay = ray;\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\n// Noise functions, distinguished by variable types\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\n\tvec4 rg = textureLod( iChannel0, (uv+f.xy+0.5)/256.0, 0.0 );\n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nvec2 NoisePrecise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\n\tvec4 rg = mix( mix(\n\t\t\t\ttextureLod( iChannel0, (uv+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (uv+vec2(1,0)+0.5)/256.0, 0.0 ),\n\t\t\t\tf.x ),\n\t\t\t\t  mix(\n\t\t\t\ttextureLod( iChannel0, (uv+vec2(0,1)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (uv+1.5)/256.0, 0.0 ),\n\t\t\t\tf.x ),\n\t\t\t\tf.y );\n\t\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nvec4 Noise( in vec2 x )\n{\n    vec2 p = floor(x.xy);\n    vec2 f = fract(x.xy);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = p.xy + f.xy;\n\treturn textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n}\n\nvec4 Noise( in ivec2 x )\n{\n\treturn textureLod( iChannel0, (vec2(x)+0.5)/256.0, 0.0 );\n}\n\nvec2 Noise( in ivec3 x )\n{\n\tvec2 uv = vec2(x.xy)+vec2(37.0,17.0)*float(x.z);\n\treturn textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).xz;\n}\n\n\nfloat Waves( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 5;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\t\tpos += iTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*2.0+abs(Noise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf /= exp2(float(octaves));\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WavesDetail( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 8;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\t\tpos += iTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*2.0+abs(NoisePrecise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf /= exp2(float(octaves));\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WavesSmooth( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 2;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\t\tpos += iTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\t//f  = f*2.0+abs(Noise(pos).x-.5)*2.0;\n\t\tf  = f*2.0+sqrt(pow(NoisePrecise(pos).x-.5,2.0)+.01)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf /= exp2(float(octaves));\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WaveCrests( vec3 ipos, in vec2 fragCoord )\n{\n\tvec3 pos = ipos;\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves1 = 6;\n\tconst int octaves2 = 16;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\tpos += iTime*vec3(0,.1,.1);\n\tvec3 pos2 = pos;\n\tfor ( int i=0; i < octaves1; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*1.5+abs(Noise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tpos = pos2 * exp2(float(octaves1));\n\tpos.y = -.05*iTime;\n\tfor ( int i=octaves1; i < octaves2; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*1.5+pow(abs(Noise(pos).x-.5)*2.0,1.0);\n\t\tpos *= 2.0;\n\t}\n\tf /= 1500.0;\n\t\n\tf -= Noise(ivec2(fragCoord.xy)).x*.01;\n\t\n\treturn pow(smoothstep(.4,-.1,f),6.0);\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn vec3(.4,.45,.5);\n    //return vec3(.01,.1,.01);\n}\n\n\nvec3 boatRight, boatUp, boatForward;\nvec3 boatPosition;\n\nvoid ComputeBoatTransform( void )\n{\n\tvec3 samples[5];\n\t\n\tsamples[0] = vec3(0,0, 0);\n\tsamples[1] = vec3(0,0, .5);\n\tsamples[2] = vec3(0,0,-.5);\n\tsamples[3] = vec3( .5,0,0);\n\tsamples[4] = vec3(-.5,0,0);\n\t\n\tsamples[0].y = WavesSmooth(samples[0]);\n\tsamples[1].y = WavesSmooth(samples[1]);\n\tsamples[2].y = WavesSmooth(samples[2]);\n\tsamples[3].y = WavesSmooth(samples[3]);\n\tsamples[4].y = WavesSmooth(samples[4]);\n\n\tboatPosition = (samples[0]+samples[1]+samples[2]+samples[3]+samples[4])/5.0;\n\t\n\tboatRight = samples[3]-samples[4];\n\tboatForward = samples[1]-samples[2];\n\tboatUp = normalize(cross(boatForward,boatRight));\n\tboatRight = normalize(cross(boatUp,boatForward));\n\tboatForward = normalize(boatForward);\n\t\n\tboatPosition += .0*boatUp;\n}\n\nvec3 BoatToWorld( vec3 dir )\n{\n\treturn dir.x*boatRight+dir.x*boatUp+dir.x*boatForward;\n    //return vec3(0.5,0.5,0.5);\n}\n\nvec3 WorldToBoat( vec3 dir )\n{\n\treturn vec3( dot(dir,boatRight), dot(dir,boatUp), dot(dir,boatForward) );\n    //return vec3(0.5,0.3,0.1);\n}\n\nfloat TraceBoat( vec3 pos, vec3 ray )\n{\n\tvec3 c = boatPosition;\n\tfloat r = 0.8;\n\t\n\tc -= pos;\n\t\n\tfloat t = dot(c,ray);\n\t\n\tfloat p = length(c-t*ray);\n\tif ( p > r )\n\t\treturn 0.0;\n\t//return 0.4;\n\treturn t-sqrt(r*r-p*p);\n}\n\n\nvec3 ShadeBoat( vec3 pos, vec3 ray )\n{\n\tpos -= boatPosition;\n\tvec3 norm = normalize(pos);\n\tpos = WorldToBoat(pos);\n\t\n\tvec3 lightDir = normalize(vec3(-2,3,1));\n\tfloat ndotl = dot(norm,lightDir);\n\t\n\t// allow some light bleed, as if it's subsurface scattering through plastic\n\tvec3 light = smoothstep(-.1,1.0,ndotl)*vec3(1.0,.9,.8)+vec3(.06,.1,.1);\n\n\t// anti-alias the albedo\n\tfloat aa = 4.0/iResolution.x;\n\t\n    // Цвет на шаре\n    vec3 albedo = vec3(1.0,1.0,1.0);\n    float sin_factor = sin(iTime/4.);\n    float cos_factor = cos(iTime/4.);\n    vec2 coord = mat2(cos_factor, sin_factor, -sin_factor, cos_factor) * vec2(pos.y,pos.x);\n    float x = coord.x;\n    float y = coord.y;\n    if (x < -0.15 && y < -0.15) albedo = vec3(0.7,.0,.0);\n    if (x < -0.15 && y > 0.15)  albedo = vec3(0.9,0.9,.0);\n    if (x > 0.15 && y < -0.15)  albedo = vec3(0.0,0.0,0.8);\n    if (x > 0.15 && y > 0.15)\talbedo = vec3(0.0,0.9,0.0);\n        \n\tvec3 col = albedo*light;\n\t\n\t// specular\n\tvec3 h = normalize(lightDir-ray);\n\tfloat s = pow(max(0.0,dot(norm,h)),100.0)*100.0/32.0;\n\t\n\tvec3 specular = s*vec3(1,1,1);\n\n\tvec3 rr = reflect(ray,norm);\n\tspecular += mix( vec3(0,.04,.04), Sky(rr), smoothstep( -.1, .1, rr.y ) );\n\t\n\tfloat ndotr = dot(norm,ray);\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0);\n\tfresnel = mix( .001, 1.0, fresnel );\n\n\tcol = mix( col, specular, fresnel );\n\t\n\treturn col;\n}\n\n\nfloat OceanDistanceField( vec3 pos )\n{\n\treturn pos.y - Waves(pos);\n}\n\nfloat OceanDistanceFieldDetail( vec3 pos )\n{\n\treturn pos.y - WavesDetail(pos);\n}\n\nvec3 OceanNormal( vec3 pos )\n{\n\tvec3 norm;\n\tvec2 d = vec2(.01*length(pos),0);\n\t\n\tnorm.x = OceanDistanceFieldDetail( pos+d.xyy )-OceanDistanceFieldDetail( pos-d.xyy );\n\tnorm.y = OceanDistanceFieldDetail( pos+d.yxy )-OceanDistanceFieldDetail( pos-d.yxy );\n\tnorm.z = OceanDistanceFieldDetail( pos+d.yyx )-OceanDistanceFieldDetail( pos-d.yyx );\n\n\treturn normalize(norm);\n}\n\nfloat TraceOcean( vec3 pos, vec3 ray )\n{\n\tfloat h = 1.0;\n\tfloat t = 0.0;\n\tfor ( int i=0; i < 100; i++ )\n\t{\n\t\tif ( h < .01 || t > 100.0 )\n\t\t\tbreak;\n\t\th = OceanDistanceField( pos+t*ray );\n\t\tt += h;\n\t}\n\t\n\tif ( h > .1 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\n\nvec3 ShadeOcean( vec3 pos, vec3 ray, in vec2 fragCoord )\n{\n\tvec3 norm = OceanNormal(pos);\n\tfloat ndotr = dot(ray,norm);\n\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0);\n\t\n\tvec3 reflectedRay = ray-2.0*norm*ndotr;\n\tvec3 refractedRay = ray+(-cos(1.33*acos(-ndotr))-ndotr)*norm;\t\n\trefractedRay = normalize(refractedRay);\n\n\tconst float crackFudge = .0;\n\t\n\t// reflection\n\tvec3 reflection = Sky(reflectedRay);\n\tfloat t=TraceBoat( pos-crackFudge*reflectedRay, reflectedRay );\n\t\n\tif ( t > 0.0 )\n\t{\n\t\treflection = ShadeBoat( pos+(t-crackFudge)*reflectedRay, reflectedRay );\n\t}\n\n\t\n\t// refraction\n\tt=TraceBoat( pos-crackFudge*refractedRay, refractedRay );\n\t\n\tvec3 col = vec3(0,.04,.04); // under-sea colour\n\tif ( t > 0.0 )\n\t{\n\t\tcol = mix( col, ShadeBoat( pos+(t-crackFudge)*refractedRay, refractedRay ), exp(-t) );\n\t}\n\t\n\tcol = mix( col, reflection, fresnel );\n\t\n\t// foam\n\tcol = mix( col, vec3(1), WaveCrests(pos,fragCoord) );\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tComputeBoatTransform();\n\t\n\tvec2 camRot = vec2(.5,.5)+vec2(-.35,4.5)*(iMouse.yx/iResolution.yx);\n\tvec3 pos, ray;\n\tCamPolar( pos, ray, vec3(0), camRot, 3.0, 1.0, fragCoord );\n\t\n\tfloat to = TraceOcean( pos, ray );\n\tfloat tb = TraceBoat( pos, ray );\n\t\n\tvec3 result;\n\tif ( to > 0.0 && ( to < tb || tb == 0.0 ) )\n\t\tresult = ShadeOcean( pos+ray*to, ray, fragCoord );\n\telse if ( tb > 0.0 )\n\t\tresult = ShadeBoat( pos+ray*tb, ray );\n\telse\n\t\tresult = Sky( ray );\n\t\n\t// vignette effect\n\tresult *= 1.1*smoothstep( .35, 1.0, localRay.z );\n\t\n\tfragColor = vec4(ToGamma(result),1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ddSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ddSz4", "name": "Floating Sandbox Rain", "author": "GabrieleGiuseppini", "description": "Experiments for Floating Sandbox's rain.", "tags": ["rain"], "likes": 1, "viewed": 173, "date": "1571606638", "time_retrieved": "2024-06-20T19:45:47.553627", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y /= (iResolution.x / iResolution.y); // obey aspect ratio\n    \n    float paramRainDensity = 1.; //.3;    \n    float paramTime = float(iFrame) / 10.;\n    \n    \n    //\n    // ---------------------------------------------\n    //\n    \n    #define RainSpatialDensityX 45.\n    #define RainSpatialDensityY 30.\n    #define RainMaxDensity .4\n    #define RainSpeed 7.\n    #define DropletLength .9\n    #define DropletWidth .08\n    \n    vec2 scaledUV = uv * vec2(RainSpatialDensityX, RainSpatialDensityY);\n        \n    // Calculate tile X coordinate\n    float tileX = floor(scaledUV.x);\n    \n\t// Offset Y based off time, and in two different ways to provide \n    // a sense of depth\n    scaledUV.y += \n        paramTime \n        * RainSpeed \n        * (.8 + mod(tileX, 3.) * .1);\n                \n    // Offset Y randomly based off its tile X coordinate\n    scaledUV.y += 407.567 * fract(351.5776456 * tileX);\n    \n    // Calculate tile Y coordinate\n    float tileY = floor(scaledUV.y);\n    \n    // Decide whether tile is turned off\n    float randOnOff = fract(sin(tileX * 71. + tileY * 7.));\n    float onOffThickness = 1. - step(paramRainDensity * RainMaxDensity, randOnOff);\n    \n    //if (onOffThickness == 0.)\n    //    discard;\n    \n    // Calculate coords within the tile\n    vec2 inTile = fract(scaledUV);\n    \n    // Shuffle tile center X based on its tile coordinates\n    float rand = fract(sin(77.7 * tileY + 7.7 * tileX));\n    float tileCenterX = .5 + (abs(rand) - .5) * (1. - DropletWidth);\n        \n    // Distance from center of tile\n    float xDistance = abs(tileCenterX - inTile.x);\n    float yDistance = abs(.5 - inTile.y);\n    \t    \n    // Thickness of droplet:\n    //    > 0.0 only within Width\n    //    ...with some tile-specific randomization\n    float clampedXDistance = smoothstep(.0, DropletWidth, xDistance);\n    float dropletThickness = (1. - clampedXDistance) * smoothstep(1. - DropletLength + rand/2.4, 1., 1. - yDistance);\n    \n    // TODOTEST\n    vec2 dropletHead = vec2(tileCenterX, .2);\n    dropletThickness = 1.0 * mix(\n        dropletThickness, \n        1. - min(1., distance(inTile, dropletHead)),\n        0.);\n    //dropletThickness = 1. - min(1., distance(inTile, dropletHead));\n    \n    \n    //\n    // ---------------------------------------------\n    //\n\n    // Turning off tiles\n    dropletThickness *= onOffThickness;\n    \n    //vec3 c = mix(vec3(.5, .7, .95), vec3(dropletThickness), smoothstep(.4, 1., dropletThickness));\n    vec3 c = mix(vec3(.5, .7, .95), vec3(1.), smoothstep(.4, 1., dropletThickness));\n\n    // Output to screen\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ddSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ddXRn", "name": "ShaderTober - Legend", "author": "Flopine", "description": "A small doodle with inktober's theme \"Legend\".. Slowly recovering from the end of a serie I've watched for 9 years... but the magic of friendship grows ;) ", "tags": ["raymarching", "mlp", "gems", "inktober"], "likes": 5, "viewed": 158, "date": "1571314231", "time_retrieved": "2024-06-20T19:45:48.256704", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n#define ITER 100.\n\nstruct EoH\n{\n    float dist;\n    vec3 color;\n};\n\nEoH struct_min(EoH a, EoH b)\n{\n   if (a.dist < b.dist)return a;\n    else return b;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat od (vec3 p, float d)\n{  \n    p.xz *= rot(iTime);\n    return dot(p,normalize(sign(p)))-d;\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y, q.z))) + length(max(q,0.));\n}\n\nfloat plane (vec3 p, vec3 n, float dist)\n{return dot(p,normalize(n))-dist;}\n\n\nfloat crystal (vec3 p)\n{\n  p.xz *= rot(iTime);\n  float b = box(p, vec3(.5, 0.7, 0.15));\n  p = abs(p);\n  float p1 = plane (p, vec3(0.6,1.,0.7), 0.5);\n  float p2 = plane (p, vec3(1.,0.,0.8), 0.3);\n  float d = max(p2,max(b,p1));\n  return d;\n}\n\nEoH SDF (vec3 p)\n{\n    EoH magic = EoH(stmin(crystal(p),od(p,0.4),0.2,4.), vec3(.8,0.1,0.7));\n    p.xy *= rot(iTime*0.5);\n    EoH honesty = EoH(crystal(p+vec3(0.,-2.,0.)),vec3(0.8,0.3,0.));\n    EoH generosity = EoH(crystal(p+vec3(2.,-.5,0.)), vec3(0.5,0.,0.6));\n    EoH laughter = EoH(crystal(p+vec3(-2.,-.5,0.)), vec3(0.,0.5,0.8));\n    EoH loyalty = EoH(crystal(p+vec3(1.,1.8,0.)), vec3(0.8,0.1,0.));\n    EoH kindness = EoH(crystal(p+vec3(-1.,1.8,0.)), vec3(.8,0.4,0.7));   \n    return struct_min(honesty, \n                      struct_min(generosity,\n                      \t\t\tstruct_min(laughter,\n                                           struct_min(loyalty, \n                                                      struct_min(kindness, magic)\n                                                                )\n                                          )\n                                )\n                     );\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p).dist-vec3(SDF(p-eps.xyy).dist,\n                                 SDF(p-eps.yxy).dist,\n                                 SDF(p-eps.yyx).dist));\n}\n\nvoid crystal_shading (inout vec3 color, vec3 n, vec3 l, vec3 rd)\n{\n    // fresnel\n    float fre = pow(clamp(1.-dot(-rd,n),0.,1.), 4.);\n    color += fre* color*3.;\n    \n    // specular\n    vec3 h = normalize(l-rd);\n    float spe = pow(max(0.,dot(h,n)),7.);\n    color += spe*0.8;\n}\n\n// courtesy of Alkama\nvec3 pales (vec2 uv)\n{\n  uv *= rot(-iTime*.2);\n  return floor(smoothstep(0.1, 0.2,cos(atan(uv.y, uv.x)*5.)))*vec3(0.4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.,0.,-3.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        col = mix(vec3(0.5,0.,0.6),vec3(0.8,0.5,1.),pales(uv))*0.8;\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p).dist;\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += d * rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        vec3 l = vec3(0.,6.,-6.);\n        col = SDF(p).color;\n        crystal_shading(col,n,l,rd);\n        col *= 1.-shad;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ddXRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ddXRX", "name": "Blood Flow", "author": "bitless", "description": "Based on \"Smooth Voronoi\" by Inigo Quiles\nhttp://www.iquilezles.org/www/articles/smoothvoronoi/smoothvoronoi.htm", "tags": ["2d", "voronoi", "smoothvoronoi"], "likes": 6, "viewed": 184, "date": "1572511343", "time_retrieved": "2024-06-20T19:45:48.565813", "image_code": "// Author: bitless\n// Title: another triangular voronoi \n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration \n// Thanks to Inigo Quiles for his amazing articles\n// \"Smooth Voronoi\"  http://www.iquilezles.org/www/articles/smoothvoronoi/smoothvoronoi.htm\n\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat sm_vr (in vec2 st) {\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float c = 0.;\n    for (int j=-1; j<=1; j++ ) {\n        for (int i=-1; i<=1; i++ ) {\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff)+(sin(iTime*length(random2(i_st + neighbor)))*0.25+0.25);\n            c +=  exp( -16.*dist );\n        }\n    }\n    return -(1.0/16.)*log(c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.135,0.077,0.095);\n\n    // Scale\n    st *= 5.;\n\n    float c=0.;\n    for (float i = 3.;i >= 0.; i--)   {\n        float vr = sm_vr(st*pow(2.,i)+vec2(sin(iTime)+iTime,0.));\n        vr = smoothstep(0.,1.5,vr*(sin(iTime+i)+4.25)*0.25);\n        c = mix(c,vr,1.0-smoothstep(0.4,0.5,vr));\n        c = (c + 0.325)*(1.-i*0.25);\n\n    }\n    color = vec3(0.425,0.110,0.103)*(c);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ddXRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ddXz4", "name": "whirling cosFlower", "author": "adrenoide", "description": "Seven flowers based on trig functions, dancing around a circle, are expanding, shrinking and turning in time ...", "tags": ["cosine", "flowers", "arctangent"], "likes": 2, "viewed": 235, "date": "1571584610", "time_retrieved": "2024-06-20T19:45:48.565813", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    vec2 p = U / iResolution.y;\n    p += vec2(-0.9, -0.5);\n    p *= (1.5 + 0.1 * (cos(3. * iTime) + sin(2. * iTime)));\n    \n    float cosTime = cos(iTime);\n\n    vec3 col = vec3 (1., 1., 1.);\n\n    const int n = 7;\n    const float pi = 4. * atan(1.);\n    \n    vec2 q[n];\n    \n    for (int i=0; i < n; i++) {\n        q[i] = 0.4 * vec2(cos(iTime / 5. + 2. * float(i) * pi / float(n)),\n                          sin(iTime / 5. + 2. * float(i) * pi / float(n)));\n    }\n    \n    float r[n];\n    \n    for (int i=0; i < n; i++) {\n        r[i] = 0.05 + 0.05 * sin(iTime / 2.) +\n        0.05 * cos((float (i) + 2. + 3. * cosTime) * atan(p.y - q[i].y, p.x - q[i].x) + 4. * iTime);\n    }\n    \n    for (int i = 0; i < n; i++) {\n    \tcol *= smoothstep (r[i], r[i] + 0.01, length (p - q[i]));\n    }\n\n    vec3 bGround = vec3 (0.3 + 0.2 * cosTime,\n                            0.4 + 0.2 * cosTime,\n                            0.9 + 0.2 * cosTime);\n    \n    vec3 fGround = vec3 (2. * p.x, 2. * p.y, 0.5 + p.x * p.y);\n    \n    vec3 invCol = 1. - col;\n    \n    O = vec4(bGround * col + fGround * invCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ddXz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dfXzS", "name": "Anaglyph Structure", "author": "leon", "description": "Anaglyph Structure. Framed for https://fanzine.cookie.paris/", "tags": ["anaglyph", "cookiezine", "cookieparty"], "likes": 5, "viewed": 375, "date": "1571874713", "time_retrieved": "2024-06-20T19:45:48.571847", "image_code": "// Anaglyph Structure\n// Framed for https://fanzine.cookie.paris/\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.10.24\n// Using code from Inigo Quilez\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat random (in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\n\nvec3 look (vec3 eye, vec3 target, vec2 anchor) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * .5 + right * anchor.x + up * anchor.y);\n}\n\n\nfloat map (vec3 pos) {\n    float scene = 10.0;\n    float r = 1.0;\n    const float count = 7.0;\n    for (float index = count; index > 0.0; --index)\n    {\n        pos.xz = abs(pos.xz)-1.5*r;\n        pos.xz *= rot(0.4/r + iTime * 0.1);\n        pos.yz *= rot(1.5/r + iTime * 0.05);\n        pos.yx *= rot(.2/r + iTime * 0.05);\n        scene = min(scene, length(pos.xy)-0.001);\n        scene = min(scene, length(pos)-0.3*r);\n        r /= 1.8;\n    }\n    return scene;\n}\n\nvec4 raymarch (vec3 eye, vec3 ray) {\n    float dither = random(ray.xy+fract(iTime));\n    vec4 result = vec4(eye, 0);\n    float total = 0.0;\n    float maxt = 20.0;\n    const float count = 30.;\n    for (float index = count; index > 0.0; --index) {\n        result.xyz = eye + ray * total;\n        float dist = map(result.xyz);\n        if (dist < 0.001 + total * .002 || total > maxt) {\n            result.w = index / count;\n            break;\n        }\n        dist *= 0.9 + 0.1 * dither;\n        total += dist;\n    }\n    result.w *= step(total, maxt);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(1.,0.5,-4.);\n    vec3 at = vec3(0);\n    vec3 ray = look(eye, at, uv);\n    vec3 eyeoffset = 0.02*normalize(cross(normalize(at-eye), vec3(0,1,0)));\n\n    vec4 resultLeft = raymarch(eye-eyeoffset, ray);\n    vec4 resultRight = raymarch(eye+eyeoffset, ray);\n    fragColor = vec4(resultLeft.w,vec2(resultRight.w),1);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "unknown-license-reference", "thumbnail": "https://www.shadertoy.com/media/shaders/3dfXzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dG3WR", "name": "Shadertober 01 Ring", "author": "GreenChicken", "description": "like inking but with shader. Today the theme is Ring !", "tags": ["ring", "inktober", "shadertober"], "likes": 6, "viewed": 326, "date": "1569953156", "time_retrieved": "2024-06-20T19:45:48.571847", "image_code": "// SHADERTOBER #01 Ring\n// Poulet Vert 01/10/2019\n// using code from Leon, iq\n\n#define VOLUME 0.001\n#define PI 3.14159\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRing( vec3 p, vec2 t, float s)\n{\n    float c = 0.0;\n    vec3 pr = p + vec3(0.0, -0.15, 0.0);\n    pr.xy *= rot(PI/2.);\n    float c1 = sdCappedCylinder(pr, t.x, t.y);\n    float c2 = sdCappedCylinder(pr, t.x-s, t.y+s);\n    return sSDF(c2,c1);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\n\n\nfloat map(vec3 pos)\n{\n    float t = 0.0;\n    \n    vec3 ringPos = pos + vec3(1.8, -1.15, 0.0);\n    t = sdRing(ringPos, vec2(0.3, .05), .09);\n    \n    vec3 wallPos = pos + vec3(1.8, 0.0, 0.0);\n    float rightWall = sdBox(wallPos, vec3(1.0, 8., 4.0));\n    vec3 subWallPos = pos + vec3(0.0, -3.5, 0.0);\n    rightWall = sSDF(sdBox(subWallPos, vec3(5.0, 2.5, 2.0)), rightWall);\n    \n    wallPos = pos + vec3(-3.0, 0.0, -4.0);\n    float backgroundWall = sdBox(wallPos, vec3(5.0, 8.0, 1.0));\n    \n    t = uSDF(t, rightWall);\n    t = uSDF(t, backgroundWall);\n    \n    return t;\n}\n\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        float ray = map(ro + rd * t);\n        \n        if(ray < (0.0001*t))\n        {\n            return t;\n        }\n        \n        t += ray;\n    }\n    \n    return -1.0;\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 1.; i += 1./15.) {\n        float dist = map(pos + dir * t);\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 screenUV)\n{\n    float t = CastRay(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t == -1.0)\n    {\n        col = vec3(rd.y);\n        vec2 rain = screenUV;\n        rain *= rot(PI/16.);\n        rain.x *= 100.;\n        \n        float randRain = fract(sin(floor(rain.x)));\n        col = vec3(step(fract(rain.x), .5)*(fract(rain.y+iTime*randRain)));\n        col = mix(vec3(0.0, 0.1, 0.2), vec3(0.0, 0.44, .94), col.r);\n        col *= .5;\n        \n    }\n    else\n    {\n        vec3 pos = ro + rd * t;\n        vec3 N = GetNormal(pos);\n        vec3 L = vec3(-5.0, 5.0, 0.0);\n        float light = dot(N,  L)*.2;\n    \n        col = vec3(.5);\n        col *= light*.2 + .5;\n        col *= GetShadow(pos, L, 4.);\n        \n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cp = vec3(3.0, 2.0, -4.0);\n    cp.x += sin(iTime*0.05)*0.52;\n    vec3 ct = vec3(1.0, 2.5, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    col = Render(cp, vd, screenUV);\n    \n    // compositing\n    col *= 1.-vec3(step(screenUV.x, .4)); // COMPOSITING CHEAT CODE\n    \n    \n    \n    col.x = .2*screenUV.x; // horizontal red ramp\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "ltXGDj", "previewfilepath": "https://soundcloud.com/tauqeer-ahmad-waheedi/relaxing-rain-and-thunder", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/tauqeer-ahmad-waheedi/relaxing-rain-and-thunder", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dG3WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dGGWt", "name": "ShaderTober - Ash", "author": "Flopine", "description": "A small doodle with inktober's theme \"Ash\". Kind of dark... like my heart as I saw the last episode of My little Pony... Snif this is it already TvT", "tags": ["raymarching", "noise", "inktober"], "likes": 9, "viewed": 231, "date": "1571143058", "time_retrieved": "2024-06-20T19:45:49.166722", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 100.\n#define PI 3.141592\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(vec2(22.44,54.5),x))*1245.5);}\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat od (vec3 p, float d)\n{\n    p.xz *= rot(iTime);\n    return dot(p,normalize(sign(p)))-d;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat pillars (vec3 p)\n{\n    float per = 3.;\n    p.xz = mod(p.xz,per)-per*0.5;\n    float c = cyl(p.xz, 0.45);\n    p.y = abs(p.y)-3.;\n    p.xz = mod(p.xz,per)-per*0.5;\n    return min(od(p,0.5),c);\n}\n\nfloat ashes (vec3 p)\n{\n    float r = 0.2;\n    float per = 0.5;\n    vec3 id = floor(p/per);\n    p.y -= iTime*hash21(id.xz*5.+1.5);\n    p.x += texNoise(p.yz*0.5+iTime*0.1).r;\n    p.z += texNoise(p.xy*0.8+iTime*0.1).r;\n    p = mod(p, per)-per*0.5;\n    return length(p)-r;\n}\n\nfloat SDF (vec3 p)\n{\n    return max(ashes(p),stmin(-box(p, vec3(15.,4., 15.)),pillars(p), 0.5, 4.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.001,0.001,-5.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        col = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.9+dither*0.21;\n        p+=d*rd;\n    }\n   \n    float t = length(ro-p);\n    \n    col = vec3(shad);\n\tcol = mix(col, vec3(0.1,0.05,0.05), 1.-exp(-0.006*t*t*texNoise(uv*0.5-vec2(0.,iTime*0.1)).r));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dGGWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dK3Dd", "name": "le parterne de truchet!", "author": "Cewein", "description": "A simple pattern, pretty easy to made, can serve as a good texture, happy halloween.", "tags": ["truchet", "pattern"], "likes": 4, "viewed": 358, "date": "1571230090", "time_retrieved": "2024-06-20T19:45:49.166722", "image_code": "float random (vec2 st) {\n    highp float a = 12.9898;\n    highp float b = 8.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(st.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 3.5;\n    \n    uv = abs(uv + sin(uv)) + iTime * 0.5;\n    vec2 coord = floor(uv);\n    \n    float rand = random(coord) - 0.51;\n    \n    vec2 gv = (fract(uv) -.5 );\n    vec3 col = vec3(0.);\n    \n    float width = 0.25;\n    \n    float d = abs(abs(gv.x + (gv.y * sign(rand))) - 0.5);\n    \n    float mask = smoothstep(0.01,-0.01,(d-width));\n    \n    \n    col = vec3(1.,.32,0.0) * mask ;\n    \n    //if(gv.x > 0.48 || gv.y > 0.48) col = vec3(1.,0.,0.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dK3Dd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dK3zK", "name": "大龙猫 - Quicky#016", "author": "totetmatt", "description": "Unfinished but that's fine", "tags": ["quicky"], "likes": 3, "viewed": 262, "date": "1570564637", "time_retrieved": "2024-06-20T19:45:49.166722", "image_code": "float hash21(vec2 p) {\n    return fract(abs(cos(24.54*fract(dot(p,p+vec2(23.23,54.553))))));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy )/ iResolution.y;\n    \n    uv*=7.;\n    vec2 uuv = uv;\n    \n    vec2 gid = floor(uv+ vec2(iTime,0.));\n    \n    \n    uv=mod(uv+vec2(iTime*abs(1.+abs(gid.y)/2.),0.),1.)-.5;\n               \n    uv*=4.*length(uuv+2.*vec2(tan(cos(iTime)),tan(sin(iTime))));\n    float d = 1.-(length(uv)-.5+uv.x/2.);\n    vec3 col = vec3(0);\n   \n     col.r =d*hash21(gid);\n     col.g =d*hash21(gid.yx);\n     col.b =d*hash21(vec2(hash21(gid.yx),hash21(gid)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dK3zK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dKGR1", "name": "fake 3d functions", "author": "Plento", "description": "fake 3d is fun. This is like a straight on view of the function e^|sin(x)|. \nhttps://www.desmos.com/calculator/omkuyyvxby ", "tags": ["2d", "pattern", "fake3d"], "likes": 7, "viewed": 450, "date": "1569896240", "time_retrieved": "2024-06-20T19:45:49.166722", "image_code": "//plento\n\nvec2 R;\nconst float pi = 3.1415926;\nfloat hsh(vec2 p)//Dave hoshkin hash ya\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);}\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - .5*R.xy)/R.y;\n    vec3 col = vec3(1);\n    \n    float d = .75; // speed factor\n    \n    \n    float m = exp(abs(sin(uv.x*2. -iTime*d)));\n    \n    //m = min(m,2.0); // makes flat planes\n   // m = max(m,1.5);\n    \n    uv.y*=m; // remmapping y coords to the function\n    \n    uv.y+=iTime*.7;\n    uv.x-=iTime*(d/2.);\n    col*=(step(0., sin(-uv.x*2.)) + .3); // dark shadow every other crest\n    uv.x*=(3./pi)*4.; \n    \n    // id and repeated coord\n\tvec2 fuv = fract(uv*6.);\n    vec2 id = floor(uv*6.);\n    \n    //checkerboard value\n    float chk = mod(id.y+id.x,2.);\n   \n    // shading/color\n    col*=mix(vec3(1., 0., .5), vec3(0.,.6, .2), hsh(id));\n    col *= smoothstep(.7, .27,abs(fuv.y-.5))*chk;\n    col *= smoothstep(3.4, .9, m);\n    \n    f = vec4(col, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dKGR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dKGWG", "name": "Spherical harmonics solver", "author": "Roninkoi", "description": "Spherical harmonics solved in real time from Legendre polynomials using the Clenshaw algorithm.\n\nOriginal version by iq: [url]https://www.shadertoy.com/view/lsfXWH[/url]", "tags": ["sphericalharmonics"], "likes": 2, "viewed": 377, "date": "1572371510", "time_retrieved": "2024-06-20T19:45:50.250691", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Four bands of Spherical Harmonics functions (or atomic orbitals if you want). For\n// reference and fun.\n\nprecision highp float;\n\n// azimuthal quantum number\n#define L 17\n\n// magnetic quantum number\n#define M 3\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // antialias level (try 1, 2, 3, ...)\n#endif\n\n//#define SHOW_SPHERES\n\n//---------------------------------------------------------------------------------\n\n#define PI 3.1415926535898\n\n// Clenshaw Legendre normalized\nfloat Pgn(int l, int m, float x)\n{\n    float p0 = 0.;\n    \n    float p1 = 0.;\n    \n    float p2 = 0.;\n    \n    for (int k = l; k >= 0; k--)\n\t{\n\t\tfloat k1 = float(k + 1);\n\t\tfloat m1 = float(2 * m) + k1;\n        float m2 = float(2 * (m + k) + 1);\n        \n\t\tp2 = p1;\n        p1 = p0;\n        \n\t\tp0 = 0.;\n        if (l == m + k)\n            p0 += 1.;\n        \n        float u0 = sqrt(\n\t\t\t(m2 * (m2 + 2.0)) /\n\t\t\t(k1 * m1)\n\t\t);\n        \n        float u1 = sqrt(\n            (k1 * m1 * (m2 + 4.0)) / \n\t\t\t((k1 + 1.0) * (m1 + 1.0) * m2)\n        );\n        \n        p0 += p1 * u0 * x;\n        p0 += -u1 * p2;\n\t}\n\n    for (int k = 1; k <= m; k++)\n\t{\n\t\tp0 *= sqrt(\n            (1.0 - 0.5/float(k)) * (1.0 - x) * (1.0 + x)\n        );\n\t}\n    \n    p0 *= sqrt((0.5 * float(m) + 0.25)/PI);\n    \n    return p0;\n}\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SH( in int l, in int m, in vec3 s ) \n{\n    vec3 ns = normalize(s);\n    \n    if (m < 0) {\n        float c = ns.x;\n        ns.x = ns.z;\n        ns.z = c;\n        m = -m;\n    }\n    \n    // spherical coordinates\n    float thetax = ns.y;\n    float phi = atan(ns.z, ns.x);\n    \n    float pl = Pgn(l, m, thetax);\n    \n    float r = pow(-1.0, float(m)) * cos(float(m) * phi) * pl;\n    \n    return r;\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 p00 = p;\n\t\n\tfloat r, d; vec3 n, s, res;\n\t\n    #ifdef SHOW_SPHERES\n\t#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))\n\t#else\n\t#define SHAPE (vec3(d-abs(r), sign(r),d))\n\t#endif\n    \n\td=length(p00); n=p00/d; r = SH(L, M, n ); s = SHAPE; res = s;\n\t\n\treturn vec3( res.x, 0.5+0.5*res.y, res.z );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec3 res = vec3(1e10,-1.0, 1.0);\n\n\tfloat maxd = 10.0;\n    float h = 1.0;\n    float t = 0.0;\n    vec2  m = vec2(-1.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( h<0.001||t>maxd ) break;\n\t    vec3 res = map( ro+rd*t );\n        h = res.x;\n\t\tm = res.yz;\n        t += h*0.1;\n    }\n\tif( t<maxd && t<res.x ) res=vec3(t,m);\n\t\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float an = 10.0*iMouse.x/iResolution.x + iTime;\n    float am = 2.*iMouse.y/iResolution.y - 1.;\n    vec3  ro = vec3(1.5*sin(an),1.5*sin(am),1.5*cos(an)) * 1.0;\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n\n    #define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {        \n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+vec2(float(m),float(n))/float(AA))) / iResolution.y;\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // background \n        vec3 col = vec3(0.3) * clamp(1.0-length(p)*0.5,0.0,1.0);\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n\n            // material\t\t\n            vec3 mate = 0.5*mix( vec3(1.0,0.6,0.15), vec3(0.2,0.4,0.5), tmat.y );\n\n            float occ = clamp( 2.0*tmat.z, 0.0, 1.0 );\n            float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 1.0 );\n\n            // lights\n            vec3 lin  = 2.5*occ*vec3(1.0,1.00,1.00)*(0.6+0.4*nor.y);\n                 lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n            // surface-light interacion\n            col = mate.xyz * lin;\n        }\n\n        // gamma\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dKGWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dtSRS", "name": "ShaderTober - Dizzy", "author": "Flopine", "description": "A small doodle with inktober's theme \"Dizzy\".\nif you can't stare at it in motion for too long, then the effect works :P ", "tags": ["raymarching", "fractal", "noise", "scanline"], "likes": 8, "viewed": 177, "date": "1572270346", "time_retrieved": "2024-06-20T19:45:50.856718", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.14192\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(11.1,25.4)))*1245.54);}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat cog (vec3 p, float in_r, float out_r)\n{   \n    float anim  = ((2.*PI)/3.) * (floor(iTime) + pow(fract(iTime),6.));\n    p.xy *= rot(anim);\n    float c1 = max(abs(cyl(p,in_r,0.25))-0.098, abs(p.z)-0.1);\n    moda(p.xy, 5.);\n    p.x -= in_r + out_r;\n    float c2 = cyl(p.yzx, 0.1-p.x*0.2, out_r);\n    return min(c1,c2);\n}\n\nfloat cogs (vec3 p)\n{\n    float i_r = 1.;\n    float o_r = 0.5;\n    float d = cog(p,i_r,o_r);\n    for (int i=0; i<3; i++)\n    {\n        p = abs(p)-3.;\n        i_r -= 0.2;\n        o_r -= 0.1;\n        p.xz *= rot(PI/4.);\n        moda(p.xy, 5.);\n        p.x -= (i_r + o_r)*2.;\n\n        d = min(d,cog(p, i_r, o_r));\n    }\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    p.xy *= rot(iTime*0.5);\n    p.x += mix(0.,texture(iChannel0, p.yz).r,clamp(exp(-fract(iTime)*8.)*6.,0.,1.));\n    float per = 20.;\n    p.xy *= rot(p.z*0.05);\n\tp.z = mod(p.z, per)-per*0.5;\n    return cogs(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float dither = hash21(uv); \n    \n    // scanline effect from superplek\n\tvec3 weight_G = vec3(1., 0.7, 1.);\n    vec3 weight_RB = vec3(0.7, 1., 0.7);\n    vec3 weight = mix(weight_G, weight_RB, mod(floor(fragCoord.y*iTime*5.), 2.));\n    \n    \n    vec3 ro = vec3(0.001,0.001,-10.+iTime),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        col = vec3(0.);\n    \n    float shad = 0.; \n    bool hit = false;\n    \n    for (float i=0.;i<64.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }        \n        d *= 0.6+dither*0.1;\n        p += d*rd;\n    }\n    \n\tif (hit)\n    {\n        col = vec3(1.-shad)*weight;\n    }\n  \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dtSRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dtSWH", "name": "GoldenCricularTrails", "author": "Wasserwecken", "description": "Simple example to answer a reddit post", "tags": ["test", "simple", "circular", "trails"], "likes": 4, "viewed": 261, "date": "1571904670", "time_retrieved": "2024-06-20T19:45:51.232558", "image_code": "float PI = 3.14159265359;\nfloat PI2 = 6.28318530717;\n\n\nfloat whiteNoise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvec2 toPolar(vec2 uv, vec2 origin)\n{\n    uv -= origin;\n    uv = vec2(\n        length(uv),\n        (atan(uv.y, uv.x) + PI) / PI2\n    );\n\n    return uv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y;\n\n    vec2 screenCenter = vec2(iResolution.x / iResolution.y / 2.0, .5);\n    uv = toPolar(uv, screenCenter);\n\n    // defines how many rings\n    uv.x *= 100.0;\n\n    // shifts each ring randomly\n    uv.y += whiteNoise(vec2(ceil(uv.x))) * iTime * .1;\n\n    // brings the shift into the 0 to 1 range again\n    uv.y = fract(uv.y);\n    \n    // defines how many trails are on one ring\n    uv.y *= 3.0;\n\n    // get a uniqe id for each trail\n    vec2 trailId = ceil(uv);\n    uv = fract(uv);\n\n    // the mask defines the inner and outer radius and also the trail thickness\n    float ringMask = step(20.0, trailId.x) * step(trailId.x, 50.0) * step(.8, uv.x);\n\n    // defines by probability wich trails are golden\n    float isGolden = step(.9, whiteNoise(trailId));\n\n    // finally coloring the trails\n    vec3 pixelColor = isGolden * vec3(0.83, 0.68, 0.21);\n    pixelColor += (1.0 - isGolden) * vec3(.5);\n    pixelColor *= ringMask;\n\n    // this is for a fading the ending of the trails\n    pixelColor *= 1. - pow(uv.y, 2.0);\n\n    \n    \n    fragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dtSWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dtSz2", "name": "Shadertober 28 - Ride", "author": "BackwardsCap", "description": "Strap in", "tags": ["ride", "inktober", "shadertober", "backwardscaptain"], "likes": 5, "viewed": 238, "date": "1572494086", "time_retrieved": "2024-06-20T19:45:51.238638", "image_code": "#define MAX_DIST 500.\n#define T iTime*20.\nmat2 rot(float x){return mat2(cos(x),-sin(x),sin(x),cos(x));}\n\nfloat box(vec3 p, vec3 d)\n{\n  vec3 q = abs(p) - d;\n  return min(max(q.x,max(q.y,q.z)),0.0)+length(max(q,0.0));\n}\n\nfloat g;\nfloat map(vec3 p)\n{\n    float r=0.;\n    \n    float hw = 4.;\n    float hh = 5.;\n    float cz = cos(p.z/15.);\n    p.xy*=rot(cos(p.z/100.)/5.);\n    float b = box(p-vec3(0,-3.75-cz,T+10.+cos(iTime)*.5),vec3(1.5,2.-(p.z-T)*.1,3));\n    b=max(b,-box(p-vec3(0,-1.75-cz,T+10.+cos(iTime)*.5),vec3(1.,2.8,2.)));\n    g+=0.01/(0.01+b*b);\n    float f = p.y+hh+cz+smoothstep(-1.,.5,cos(clamp(p.x*3.,-5.,5.))*3.);\n    float rw = dot(p+vec3(hw,0,0),normalize(vec3(1,0,0)));\n    float lw = dot(p-vec3(hw,0,0),normalize(vec3(-1,0,0)));\n    float tw = dot(p-vec3(0,hh-cos(p.z/20.),0),normalize(vec3(0,-1,0)));\n    b*=.9;\n    f*=.5;\n    r=min(f,rw);\n    r=min(r,lw);\n    r=min(r,tw);\n    r=min(r,b);\n    return r;\n}\nfloat ray(vec3 ro, vec3 rd)\n{\n    float t=0.;\n    for(int i=0;i<128;i++)\n    {\n        vec3 p = ro+rd*t;\n        float s = map(p);\n        if(s<0.01)break;\n        t+=s;\n        if(t>MAX_DIST){t=-1.;break;}\n    }\n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0001,0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n        ));\n}\n\nvec3 cam(vec3 ro, vec3 ta, vec2 uv)\n{\n    vec3 cf = normalize(ta-ro);\n    vec3 cu = normalize(cross(cf,vec3(0,1,0)));\n    vec3 cr = normalize(cross(cu,cf));\n    return normalize(uv.x*cu+uv.y*cr+2.*cf);\n}\n\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.y;\n\n    float h = -1.75;\n    vec3 ro = vec3(0,2.+h+cos(T/15.-10.),T-10.);\n    vec3 ta = vec3(0,h+cos(T/15.-9.),T);\n    vec3 rd = cam(ro,ta,uv);\n    \n    float r = ray(ro,rd);\n    \n    vec3 col = vec3(0);\n    \n    if(r>0.)\n    {\n        vec3 p = ro+rd*r;\n        vec3 n = normal(p);\n        vec3 sun = normalize(vec3(0.,0.1,.3));\n        float dif = clamp(dot(n,sun),0.,1.);\n        \n        col=vec3(1.)*dif+r/300.+g/100.;\n    }\n\tc.rgb=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dtSz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dtSzN", "name": "Kaleidoscopic Swirls", "author": "krakel", "description": "Noise, symmetry and lots of domain distortion.\n\nUncomment line 77 for a more dramatic version.", "tags": ["noise", "kaleidoscope"], "likes": 6, "viewed": 139, "date": "1571591594", "time_retrieved": "2024-06-20T19:45:51.238638", "image_code": "#define iTime .5*iTime\nfloat hash(in vec3 p)\n{\n\tivec3 q = ivec3(p*5000.);\n    int h = 15*q.x ^ q.y ^ q.z;\n    return fract(713.*sin(float(h)));\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 F = floor(p);\n    vec2 o = vec2(0,1);\n    vec3 f = smoothstep(0.,1.,fract(p));\n    float r1 = mix(hash(F), hash(F+o.yxx), f.x);\n    r1 = mix(r1,mix(hash(F+o.xyx),hash(F+o.yyx), f.x),f.y);\n    float r2 = mix(hash(F+o.xxy), hash(F+o.yxy), f.x);\n    r2 = mix(r2,mix(hash(F+o.xyy),hash(F+o.yyy), f.x),f.y);\n    return mix(r1,r2,f.z);\n}\n\nfloat fbm(in vec3 p)\n{\n    float s = 1.;\n    float a = 1.;\n    float g = 2.;\n    float A = 0.;\n    float r = 0.;\n    for(int i = 0; i<3; i++){\n        r += a*noise(1.2*float(i)+p*s);\n        A += a;\n        a /= g;\n        s *= g;\n    }\n    return r/A;\n}\n\nvec3 fbm3(in vec3 p)\n{\n    return vec3(fbm(p-10.3),fbm(p),fbm(p+10.3));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    vec3 col = vec3(0);\n    float t = iTime*.1;\n    \n    t *= (.5+.5*smoothstep(.0,1.,length(uv)));\n    \n    mat2 rot = mat2(cos(t),sin(t),-sin(t),cos(t));\n    \n    uv *=rot;\n    \n    vec2 rad = vec2(atan((uv.y/uv.x)), length(uv));\n    \n    int rf = int(abs(floor(6.*rad.x/3.16)));\n    rad.x = fract(6.*rad.x/3.16);\n    if(rf%2==0) rad.x = 1.-rad.x; \n    rad.x *= 3.16/6.;\n    \n    vec3 p =  vec3(rad.x,16.*rad.y-1.5*iTime,.5*iTime);\n    \n    t = -iTime*.001;\n    mat2 rot2 = mat2(cos(t),sin(t),-sin(t),cos(t));\n    \n    p.xy *= rot2;\n    \n    vec3 q = fbm3(vec3(p.xy,p.z));\n    vec3 r = .5*fbm3(2.*(p+q));\n    vec3 s = .2*fbm3(8.*(p+q+r));\n    \n    col += pow(fbm3(p+s)*fbm(r+.3*s)*3.5,vec3(.8,1.5,1.2));\n    \n    col *= fbm(p)*1.5;\n    \n    //col *= pow(fbm(p+s)*1.5,2.2);\n    \n    col *= 1.+smoothstep(.05,.0,rad.y);\n    \n    float vig = smoothstep(1.,.2,rad.y);\n    col = pow(col, vec3(vig));\n    col *= vig;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dtSzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dtXRH", "name": "Ascii art Heart - 138ch", "author": "iapafoto", "description": "Ascii art Heart", "tags": ["heart", "asciiart", "tweet", "golf"], "likes": 7, "viewed": 153, "date": "1571437352", "time_retrieved": "2024-06-20T19:45:51.723621", "image_code": "// FabriceNeyret2\n// mathmasterzach\n// coyote\n// iapafoto\n//---------------\n\n\n       /******\\    /******\\\n      /****/void  mainImage\\\n      (out vec4 O, vec2 U) {\n      vec2 R=iResolution.xy,\n      p=(.2*cos(8.*iTime)+4.\n       )*(U/R-.5),q=p.y*.7+\n         p*p-abs(p);O-=O;\n            O.ra=.1*R*(\n             .4-q*q-p\n               *p);}\n               \n               \n               \n// +3ch for antialisaing\n// -1ch \n\n// Variations\n//    no-antialisasing: O.ra=R*(.4-q*q-p*p)  \n//    antialisasing:    O.ra=.1*R*(.4-q*q-p*p)  \n//    3D shading:       O.ra=sqrt(.4-q*q-p*p)       \n//    pencil:           O.ra=.2*R*(abs(.4-q*q-p*p)-.04)   \n   \n// --- SMALEST -------------------------------------------------------\n// FabriceNeyret2 -1ch (U+U-R)/R ->  2.*(U/R-.5)\n/*\n#define mainImage(O,U) \\\n    vec2 R=iResolution.xy, \\\n         p=(.2*cos(8.*iTime)+4.)*(U/R-.5), \\\n         q=p.y*.7+p*p-abs(p); \\\n    O.ra=.1*R*(.4-q*q-p*p) /*\n\n\n// ----------------------------------------------------------\n// mathmasterzach -4ch changing O calculus!  117ch!\n\n#define mainImage(O,U) \\\n    vec2 R=iResolution.xy, \\\n         p=(.1*cos(8.*iTime)+2.)*(U+U-R)/R, \\\n         q=p.y*.7+p*p-abs(p); \\\n    O.ra=.1*R*(.4-q*q-p*p) /*\n\n// -------------------------------------------------------------------   \n// coyote -3ch -> 121ch (introducing q, avoid .y and .x and change O calculus)\n\n#define mainImage(O,U) \\\n    vec2 R=iResolution.xy, \\\n         p=(.1*cos(8.*iTime)+2.)*(U+U-R)/R, \\\n         q=p.y*.7+p*p-abs(p); \\\n    (q*q+p*p).x<.4?O.r++:0. /*\n\n\n// -------------------------------------------------------------------   \n// iapafoto -2ch => 124ch version (modify coefs)\n\n#define mainImage(O,U) \\\n    vec2 R=iResolution.xy, \\\n    p=(.1*cos(8.*iTime)+2.)*(U+U-R)/R; \\\n    p.y=p.y*.7-(abs(p)-p*p).x;  \\\n    O.ra=(.4-dot(p,p))*R /*\n\n\n// -------------------------------------------------------------------   \n// mathmasterzach version (-8ch) => 126ch version\n\n#define mainImage(O,U)\\\n\tvec2 R=iResolution.xy,\\\n\tp=(.04*cos(6.* iTime)+1.2)*(U+U-R)/R;\\\n\tp.y=p.y*.7-(abs(p)-p*p).x,\\\n\tO.ra=(dot(p,p)-.2)*R\n\n                    \n                 \n// -------------------------------------------------------------------   \n// original version iapafoto => 134ch version\n                   \n        \n/* \n\n// 96ch no anim\n\n#define mainImage(O,U)    \\\nvec2 R=iResolution.xy,    \\\n     p=(U+U-R)/R,         \\\nq=p.y*.7+p*p-abs(p);      \\\nO.ra=R*(.2-q*q-p*p)\n\n*/\n       \n\n// Shadertoy Moderators port of the shader:\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dtXRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dtXRj", "name": "ShaderTober - Dark", "author": "Flopine", "description": "A small doodle with inktober's theme \"Dark\". \nPlay the sound in iChannel0 and enjoy this awesome track from son lux :D All of their work are amazing > https://soundcloud.com/son-lux", "tags": ["raymarching", "audioreactive", "inktober", "sonlux"], "likes": 20, "viewed": 353, "date": "1572371620", "time_retrieved": "2024-06-20T19:45:52.311461", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// AN AUDIO REACTIVE SHADER, play the sound in iChannel0\n\n#define ITER 64.\n#define PI 3.141592\n#define megabass (texture(iChannel0, vec2(0.001,0.25)).x)\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,14.1)))*1245.4);}\n\nvec2 moda(vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat needles(vec3 p)\n{\n    vec3 pp = p;\n    float l_needle = 0.8 - clamp(megabass,0.,0.75);\n    \n    p.xz = moda(p.xz, 2.*PI/7.);\n    float n1 = cyl(p.yz,0.1-p.x*l_needle);\n    \n    p = pp;\n    p.y = abs(p.y);\n    p.y -= 0.1;\n    p.xz = moda(p.xz, 2.*PI/7.);\n    p.xy *= rot(PI/4.5);\n\n    float n2 = cyl(p.yz,0.1-p.x*l_needle);\n    \n    p = pp;\n    float n3 = cyl(p.xz, 0.1-abs(p.y)*l_needle);\n    \n    return min(n3,min(n2,n1));\n}\n\nfloat spikyball (vec3 p)\n{\n    p.y -= iTime;\n    p.xz *= rot(iTime);\n    p.yz *= rot(iTime*0.5);\n    float s = sphe(p,.9);\n    return smin(s, needles(p), 5.);\n}\n\n// provided by Shane, thank you :3\nfloat room(vec3 p)\n{\n    p += sin(p.yzx - cos(p.zxy));\n    p += sin(p.yzx/1.5 + cos(p.zxy)/2.)*.5;\n    return -length(p.xz) + 5.;\n}\n\nfloat SDF (vec3 p)\n{ \n    return min(spikyball(p),room(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.001,0.001+iTime,-3.); \n    vec3 p = ro;\n    vec3 dir = normalize(vec3(uv, 1.));\n    \n    float shad = 0.;\n    \n    for (float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if(d<0.001)\n        {\n        \tshad = i/ITER;\n            break;\n        }\n        d *= 0.9+dither*0.1;\n        p+=d*dir;\n    }    \n    \n    vec3 c = vec3 (shad);\n    \n    // Output to screen\n    fragColor = vec4(pow(c,vec3(1.5)),1.0);\n}", "image_inputs": [{"id": "Xll3Df", "previewfilepath": "https://soundcloud.com/dark_vibe/son-lux-dream-state-dark-day", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dark_vibe/son-lux-dream-state-dark-day", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dtXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dV3zm", "name": "cycling white vs blue noise", "author": "FabriceNeyret2", "description": "cycling noise with fract( noise + time ) \nLeft: using white noise. Right: using blue noise.\ncolor version: delete .xxxx\nuncomment last line to see effect on texture mixing ( BW or color blend)", "tags": ["bluenoise", "perception", "short", "whitenoise"], "likes": 8, "viewed": 408, "date": "1569930558", "time_retrieved": "2024-06-20T19:45:52.311461", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 P = U/iResolution.xy;\n    O = fract( ( P.x < .5 \n                   ? texelFetch( iChannel1, ivec2(U)%256,  0 )\n                   : texelFetch( iChannel0, ivec2(U)%1024, 0 )\n                ) + float(iFrame)/256. ).xxxx; // col: DEL .xxxx\n    \n  //O = mix( texture(iChannel2, P), texture(iChannel3, P), O ); // try mixing\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dV3zm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dVGWz", "name": "ShaderTober - Mindless", "author": "Flopine", "description": "A small doodle with inktober's theme \"mindless\"", "tags": ["raymarching", "inktober"], "likes": 7, "viewed": 252, "date": "1570019086", "time_retrieved": "2024-06-20T19:45:52.820527", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(16.4,34.5)))*1212.4);}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+ length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat well (vec3 p)\n{\n    p.y = abs(p.y)-2.;\n    p.xz = fract(p.xz)-0.5;\n    return max(abs(p.y)-0.25,abs(cyl(p.xzy, .45,1.))-0.05);\n}\n\nvec2 s_id;\nfloat g1 = 0.;\nfloat spheres (vec3 p)\n{ \n    s_id = floor(p.xz);\n    \n    float anim = (mod(s_id.x,2.) == 0.)? iTime*hash21(s_id)*0.5 : -iTime*hash21(s_id)*0.5;\n    p.y -= anim;\n   \tp.xz = fract(p.xz)-.5;\n    \n    p.y = fract(p.y)-.5;\n    \n   \tfloat d = length(p)-0.2;\n    g1 += 0.01/(0.01+d*d);\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    return min(-box(p,vec3(7.,2.5,5.)),min(spheres(p),well(p)));\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float dither = hash21(uv);\n    \n   \tvec3 ro = vec3(0.8,0.3,-3.5),\n        p = ro,\n        rd = getcam(ro, vec3(0.),uv),\n        col = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.9+dither*0.1;\n        p+=d*rd;\n    }\n    \n    col = vec3 (shad)*0.2;\n    vec3 c1 = clamp(vec3(hash21(s_id),hash21(s_id*0.2),1.),0.,1.);\n    vec3 c2 = clamp(vec3(1.,hash21(s_id),hash21(s_id)*0.1),0.,1.);\n    vec3 fc = mod(s_id.x, 2.) == 0. ? c1 : c2;\n\tcol += g1*fc*0.02*exp(-fract(iTime));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dVGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dy3Rt", "name": "ShaderTober - Enchanted", "author": "Flopine", "description": "A small doodle with inktober's theme \"Enchanted\".", "tags": ["raymarching", "voronoi", "inktober"], "likes": 8, "viewed": 278, "date": "1570710459", "time_retrieved": "2024-06-20T19:45:53.784394", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n\nvec2 rand (vec2 x)\n{return fract(sin(vec2(dot(x, vec2(1.2,5.5)), dot(x, vec2(4.54,2.41))))*4.45);}\n\nfloat hash11 (float x)\n{return fract(sin(x*45.15)*124.5);}\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.45,43.158)))*1245.5);}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a= atan(p.y,p.x);\n    float l = length(p);\n    float id = floor(a/per);\n    a = mod(a, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id) >= (rep/2.)) id = abs(id);\n    return id;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\n// voronoi function which is a mix between Book of Shaders : https://thebookofshaders.com/12/?lan=en\n// and iq article : http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\nvec3 voro (vec2 uv)\n{\n    vec2 uv_id = floor (uv);\n    vec2 uv_st = fract(uv);\n\n    vec2 m_diff;\n    vec2 m_point;\n    vec2 m_neighbor;\n    float m_dist = 10.;\n\n    for (int j = -1; j<=1; j++)\n    {\n        for (int i = -1; i<=1; i++)\n        {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 point = rand(uv_id + neighbor);\n            point = 0.5+0.5*sin(2.*PI*point+iTime);\n            vec2 diff = neighbor + point - uv_st;\n\n            float dist = length(diff);\n            if (dist < m_dist)\n            {\n                m_dist = dist;\n                m_point = point;\n                m_diff = diff;\n                m_neighbor = neighbor;\n            }\n        }\n    }\n\n    m_dist = 10.;\n    for (int j = -2; j<=2; j++)\n    {\n        for (int i = -2; i<=2; i++)\n        {\n            if (i==0 && j==0) continue;\n            vec2 neighbor = m_neighbor + vec2(float(i), float(j));\n            vec2 point = rand(uv_id + neighbor);\n            point = 0.5+0.5*sin(point*2.*PI+iTime);\n            vec2 diff = neighbor + point - uv_st;\n            float dist = dot(0.5*(m_diff+diff), normalize(diff-m_diff));\n            m_point = point;\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    return vec3(m_point, m_dist);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat od (vec3 p, float r)\n{return dot(p,normalize(sign(p)))-r;}\n\nfloat g1 = 0.;\nfloat room (vec3 p)\n{\n    p.y -= 5.;\n    p.y -= step(0.05,voro(p.xz).z)*0.05;\n    p.y += sin(length(p.xz*1.5)-iTime)*0.1;\n    \n    p.x -= step(0.05,voro(p.yz).z)*0.05;\n    p.x += sin(length(p.yz*1.5)-iTime)*0.1;\n    \n    float d = -box(p, vec3(10.,8.,15.));\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat t_id;\nfloat g2 = 0.;\nfloat tentacles (vec3 p)\n{\n    p.xz *= rot(sin(iTime+p.y*0.8)*0.5);\n    t_id = moda(p.xz, 7.);\n\n    p.x -= 2.;\n    float d = cyl(p.xzy, 0.15 - p.y*0.1,3.);\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\n\nfloat gem (vec3 p)\n{\n    p.y -= 1.5;\n    p.xz *= rot(iTime);\n    p.xy *= rot(iTime);\n    p.y += sin(iTime)*0.5+0.5;\n    return stmin(od(p, 1.),box(p,vec3(0.9)),0.5,3.);\n}\n\nfloat SDF (vec3 p)\n{\n    return min(gem(p),min(room(p),tentacles(p)));\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.001,2.,-5.5),\n        tar = vec3(0.,0.,0.),\n        rd = getcam(ro, tar, uv),\n        p = ro,\n        col = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<64.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.9+dither*0.1;\n        p += d*rd;\n    }\n\n    float t = length(ro-p);\n    \n    col = vec3(shad);\n    col += g1 * step(voro(p.xz+p.yz).z,0.05) * vec3(0.,0.3,0.4);\n    col += g2 * vec3(hash11(t_id)*0.1,1.,hash11(t_id))*0.2;\n    \n    col = mix(col, vec3(0.2,0.2,0.3), 1.-exp(-0.018*t*t));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dy3Rt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dy3WK", "name": "Looping-Test", "author": "Billy_T", "description": "Just testing how to make a looping effect (Always zooming out)", "tags": ["looping"], "likes": 6, "viewed": 86, "date": "1570910744", "time_retrieved": "2024-06-20T19:45:53.784394", "image_code": "#define PI 3.14159265359\n\nfloat insideTriangle(vec2 uv, float h) {\n    return step(max(-uv.y, dot(vec2(abs(uv.x), uv.y), vec2(sqrt(3.0)/2.0, .5))), h);\n}\n\nfloat deg2rad(float deg) {\n    return deg*PI/180.0;\n}\n\nmat2 rot(float rad) \n{\n    float s = sin(rad);\n    float c = cos(rad);\n    return mat2(c, s, -s, c);\n}\n\nfloat sn(float x) {\n    return sin(x) / 2. + .5;\n}\n\nvec4 getColor(vec2 uv, float time)\n{\n    float z = mod(time, 1.0) + 1.0;\n    uv *= pow(2.0, z);\n    float inside = 0.0;\n    float x = length(uv);\n    float i = -floor(log2(x + 0.001));\n    float c = pow(2.0, -i+1.0);\n    uv /= c;\n    float lvl = i;\n    i -= floor(time);\n\n    uv = rot(i*deg2rad(15.0) + time*.5) * uv;\n    //return vec4(vec3(inside), 1.0);\n    float iR = insideTriangle(uv, .3 + sn(time*.7) * .23);\n    float depth = min((-lvl + 6.0 - fract(time)) * .2, 1.0);\n    return vec4(depth * iR);\n}\n\nvec2 frag2uv(vec2 f) \n{\n    vec2 r = iResolution.xy;\n    return (f / r * 2.0 - 1.0) * vec2(max(r.x/r.y, 1.0), max(r.y/r.x, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = frag2uv(fragCoord);\n    fragColor = getColor(uv, iTime) + getColor(uv, iTime*.8 + 3.) + getColor(uv, iTime*1.2 + 6.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dy3WK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dy3zy", "name": "HSV Color progress bar", "author": "bolloxim", "description": "HSV Color fade through hue from red to green smoothly based on 0-100%", "tags": ["hsv", "progress", "ui"], "likes": 1, "viewed": 31, "date": "1570415842", "time_retrieved": "2024-06-20T19:45:54.281289", "image_code": "// Andi Smithers \n// button shader for smooth border edges\n// includes shadow both internal and drop shadow\n// 9 patch is basically preserving the edge with rectangle and doesnt stretch the image\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 0.6666666, 0.3333333, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = mod(iTime, 1.0);\n\n    vec4 backCol = vec4(1,1,1,1);\n    // uniforms\n    float borderSize = 0.05;\n    float antiAliasSize = 0.03;\n    vec4 borderColor = vec4(1.0,1.0,0.95, 1);\n    vec4 centreColor = vec4(0.1,0.5,0.9,1);\n    float wobbly = iTime;\n\tfloat rounding = sin(wobbly)*3.0+4.0;\n    vec2 shadowVec = vec2(-0.01, 0.05);\n    float scaleBox = 1.2;\n\n    // alias thickness\n    float aascalar = 1.0 / antiAliasSize;\n    float outerAlias = 1.0 - antiAliasSize;\n    \n    // convert UV into normalized coord\n    vec2 iuv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // compute 9patch centre - xaxis\n    float centre = (iResolution.x - iResolution.y)/iResolution.x * 0.5 ;\n    if (abs(iuv.x-0.5)<centre) uv.x=0.5;\n    if(iuv.x>centre+0.5) uv.x-=0.5 + (iResolution.y/iResolution.x) * centre*2.0;\n\n    vec2 uvUnit = (uv*2.0-1.0) * scaleBox;\n    vec2 shadowUnit = uvUnit + shadowVec;\n    \n    // rounded edge - have to abs the value incase shader doesnt support negative powers\n    uvUnit = pow(abs(uvUnit), vec2(rounding));\n    shadowUnit = pow(abs(shadowUnit), vec2(rounding));\n    \n    // compute border\n    float borderEdge = pow(1.0-borderSize, rounding);\n    float borderAlias = borderEdge - antiAliasSize;\n    \n    // edge\n    float edge = length(uvUnit);\n    float outer = 1.0-(clamp(edge, outerAlias, 1.0)-outerAlias) * aascalar;\n    float inner = 1.0-(clamp(edge, borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowInner = 1.0-(clamp(length(shadowUnit), borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowOuter = 1.0-(clamp(length(shadowUnit), outerAlias, 1.0)-outerAlias) * aascalar;\n    \n    // blow out outer then chose minimum this ensures a mask around the alpha output\n    float outermask = min(outer*1000.0, 1.0);\n    \n    // fetch image and poor mans chromakey alpha\n    vec4 barCol = vec4(hsv2rgb(vec3(progress*0.33333 - 0.1, 1.0, 1.0)), 1.0);\n    float blend = ((iuv.x - progress) <= 0.0 ? 1.0 : 0.0);\n    vec4 image = blend*barCol + backCol*(1.0-blend);\n    \n    \n    //image*= texture(iChannel0, iuv); if you want it textured\n    float alpha = length(image.rgb-vec3(0,1,0));\n    alpha = alpha> 0.5 ? 1.0 : 0.0;\n\n    // shadow\n    float shade = shadowInner<0.9 ? 0.8 + shadowInner*0.2: 1.0;\n    float shadeOut = shadowOuter>0.5 ? 0.0 + shadowOuter*0.2: 0.0;\t\n        \n    // blend inner/outer and image with image alpha\n    vec4 color = (centreColor*inner*(1.0-alpha)+image*alpha*inner)*shade + borderColor*(1.0-inner)*outermask;\n    color.a =  max(outer, shadeOut);\n    \n    // blend against a background texture - because shadertoy\n    vec4 background = texture(iChannel1, iuv);\n        \n    // and set the final color \n    fragColor = (color*color.a) + background*(1.0-color.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dy3zy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dyGW3", "name": "LinesZ8Q", "author": "foran", "description": "LinesZ8Q", "tags": ["linesz8q"], "likes": 10, "viewed": 129, "date": "1571032095", "time_retrieved": "2024-06-20T19:45:54.281289", "image_code": "#define MAXSTEPS 50\n#define HITTHRESHOLD .009\n#define FAR 25.\n#define AA 1\n#define NIFS 2\n#define SCALE 2.3\n#define TRANSLATE 3.5\n\nmat2x2 rot(float angle)\n{\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat2x2(c,-s,\n    s,c);\n}\n\nvec4 sd2d(vec2 p,float o)\n{\n    float time=.25*o+.6*iTime;\n    float s=.5;\n    p*=s;\n    float RADIUS=(1.5+sin(iTime));\n    int i;\n    vec3 col;\n    p=p*rot(-.4*time);// twist\n    \n    for(i=0;i<NIFS;i++)\n    {\n        if(p.x<0.){p.x=-p.x;col.g++;}\n        p=p*rot(.9*sin(time));\n        if(p.y<0.){p.y=-p.y;col.b++;}\n        if(p.x-p.y<0.){p.xy=p.yx;col.r++;}\n        p=p*SCALE-TRANSLATE;\n        p=p*rot(.3*(iTime));\n    }\n    \n    float d=.425*(length(p)-RADIUS)*pow(SCALE,float(-i))/s;\n    col/=float(NIFS);\n    vec3 oc=mix(vec3(.7,col.g,.2),vec3(.2,col.r,.7),col.b);\n    \n    return vec4(oc,d);\n}\n\nvec4 map(vec3 p)\n{\n    return sd2d(p.xz,p.y);\n}\n\nfloat shadow(vec3 ro,vec3 rd)\n{\n    float h=0.;\n    float k=3.;//shadowSmooth\n    float res=1.;\n    float t=.2;//bias\n    for(int i=0;t<15.;i++)// t < shadowMaxDist\n    {\n        h=map(ro+rd*t).w;\n        res=min(res,k*h/t);\n        if(h<HITTHRESHOLD)\n        {\n            break;\n        }\n        t=t+h;\n    }\n    return clamp(res+.05,0.,1.);\n}\n//---------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//-----------------\n//camera\nfloat height=-.4;\nfloat rot=iTime*.1;\nfloat dist=9.+1.*sin(.5*iTime);\nvec3 ro=dist*vec3(cos(rot),height,sin(rot));\nvec3 lookAt=vec3(0.,0.,0.);\nvec3 fw=normalize(lookAt-ro);\n\nvec3 right=normalize(cross(vec3(0.,1.,1.),fw));\nvec3 up=normalize(cross(fw,right));\nright=normalize(cross(up,fw));\n\n//light\nrot+=sin(iTime)*.2;\nvec3 lightPos=dist*vec3(cos(rot),height,sin(rot));\n\n//raymarch\nvec3 pos,closest;\nfloat t;\nfloat smallest;\nint i,iAtClosest;\nvec3 sdfCol;\nvec3 col;\n\nfor(int x=0;x<AA;x++)\nfor(int y=0;y<AA;y++)\n{\n    t=0.;smallest=500.;\n    vec2 o=vec2(float(x),float(y))/float(AA)-.5;\n    vec2 uv=(fragCoord+o)/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 rd=normalize(fw*.5+right*uv.x+up*uv.y);\n    \n    for(i=0;i<MAXSTEPS;i++)\n    {\n        pos=ro+rd*t;\n        vec4 mr=map(pos);\n        float d=mr.w;\n        if(d<smallest)smallest=d;closest=pos;iAtClosest=i;sdfCol=mr.rgb;\n        if(abs(d)<HITTHRESHOLD||t>FAR){break;}\n        t+=d;\n    }\n    pos=closest;\n    i=iAtClosest;\n    vec3 c;\n    if(t<FAR)\n    {\n        c=sdfCol;\n        vec3 toLight=normalize(lightPos-pos);\n        float s=shadow(pos,toLight);\n        c*=s;\n        c=mix(c,1.5*c,1.-s);\n    }\n    else\n    {\n        c=vec3(0.);\n    }\n    col+=c;\n}\ncol/=float(AA*AA);\n\n\n    fragColor = vec4 (col,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dyGW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dyGzy", "name": "testPlasmaHAHA", "author": "oneWisdom", "description": "Plasma In The DiE OCEAN", "tags": ["test", "plasma", "play", "cool"], "likes": 0, "viewed": 41, "date": "1570410472", "time_retrieved": "2024-06-20T19:45:54.554194", "image_code": "\n// Let's write a plasma!\n//\n// http://en.wikipedia.org/wiki/Plasma_effect\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +0.00178*t*t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(length(r) +1.7*t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\tif(p.x < 0.1/10.) { \n\t\tret = vec3(v1);\n\t} \n\telse if(p.x < 1./10.) { \n\t\tret = vec3(v2);\n\t} \n\telse if(p.x < 2./10.- 0.15*sin(iTime/3.)) { \n\t\tret = vec3(v);\n\t}\t\n\telse if(p.x < (6./10. + 0.35*cos(iTime/2.))) { \n\t\tret = vec3(sin(0.05*0.5*t*t*vec3(0.4,0.77,0.34)*v));\n\t}\n\telse if(p.x < 10./10.) { \n\t\tret = 2.*vec3(sin(v)+0.25, sin(v+0.25*3.14), sin(v+1.0*3.14));\n\t}\t\n\t\n\tret = 0.5 +0.5*ret;\n\t\n    vec3 pixel = ret;\n    fragColor = vec4(pixel, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dyGzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s3SRM", "name": "willster debug shader", "author": "willster", "description": "for testing, reference the other shader, will remove later.", "tags": ["willster"], "likes": 3, "viewed": 281, "date": "1571625365", "time_retrieved": "2024-06-20T19:45:54.554194", "image_code": "vec2 normz(vec2 x) {\n    return x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*1.0;\n\tvec2 uv = ( gl_FragCoord.xy / iResolution.xy )*4.0;\n\n\tfloat i0=1.2;\n\tfloat i1=0.95;\n\tfloat i2=1.5;\n\tvec2 i4=vec2(0.0,0.0);\n\tfor(int s=0;s<4;s++)\n\t{\n\t\tvec2 r;\n\t\tr=vec2(cos(uv.y*i0-i4.y+time/i1),sin(uv.x*i0+i4.x+time/i1))/i2;\n\t\tr+=vec2(-r.y,r.x)*0.2;\n\t\tuv.xy+=r;\n\n\t\ti0*=1.93;\n\t\ti1*=1.25;\n\t\ti2*=1.7;\n\t\ti4+=r.xy*1.0+0.5*time*i1;\n\t}\n\tfloat r=sin(uv.x-time)*0.7+0.5;\n\tfloat b=sin(uv.y+time)*0.5+0.5;\n\tfloat g=sin((sqrt(uv.x*uv.x+uv.y*uv.y)+time))*0.5+0.5;\n\tvec3 c=vec3(r,g,b);\n    if (iMouse.z > 0.0) {\n        vec2 d = gl_FragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) / 50.0);\n        c.xy += m * normz(d);\n    }\n\tfragColor = vec4(c,1.5);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s3SRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s3SWn", "name": "Interactive JuliaSet", "author": "adrenoide", "description": "Click and drag to see Julia sets computed in real time !\n\nClick near the bottom-left corner to come back to demo mode.", "tags": ["julia", "mandelbrot", "iteration"], "likes": 5, "viewed": 265, "date": "1571729151", "time_retrieved": "2024-06-20T19:45:55.063235", "image_code": "// Revisiting those objects with new tools is amazing to me !\n// In the 80's, I had to wait about 20' to get a single frame :)\n\n// Before clicking the mouse, what you see is the Julia set\n// transforming itself while the c parameter moves along roughly\n// the boundary of the Mandelbrot set.\n// After clicking the mouse, interactive mode is entered.\n// Coming back to demo mode is achieved by clicking near\n// the bottom-left corner.\n\nconst float pi = 4. * atan(1.);\n\n// map : z --> z**2 + c\nvec2 f(vec2 c, vec2 z) {\n    //return vec2(z.x * z.x - z.y * z.y + c.x, 2. * z.x * z.y + c.y);\n    return mat2(z, -z.y, z.x) * z + c;\n}\n\n\n// Computes the so-called \"escape-time\"\nint iter (vec2 c, vec2 z, int n, float threshold) {\n    vec2 zn = z;\n    int k = 0;\n    while ((k <= n) && (length(zn) < threshold)) {\n     \tzn = f(c, zn);\n        k++;\n    }\n    return k;\n}\n\n\n// Computes x**n\nfloat ipow(float x, int n) {\n    float y = 1.;\n    for (int k = 0; k < n; k++) {\n        y *= x;\n    }\n    return y;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    O = vec4(0.);\n    vec2 z = 5. * (U / iResolution.x - vec2(0.5,0.3));\n    \n    vec2 c;\n    float escape;\n    \n    // Computes the Mandelbrot set\n    escape = float(iter(z,vec2(0.),256, 2.)) / 256.;\n    vec4 MSet = vec4(vec3((1. - escape) / 4.), 1.);\n    \n    if (length (iMouse.xy) < 20. ) {\n        float t = iTime;\n        int n = int(floor(t / pi));\n        if (n % 6 == 0) { // upper half cardioid\n        \tc = 0.5 * vec2(cos(t), sin(t)) - 0.25 * vec2(cos(2.*t), sin(2.*t));\n        }\n        else if (n % 6 == 1) { // upper half disk\n            c = vec2(-1. + 0.25 * cos(t - pi), 0.25 * sin(t - pi));\n        }\n        else if (n % 6 == 2) { // segment -1.75 to -2\n            c = cos(t / 2.) * cos(t / 2.) * vec2(-1.25, 0.) +\n                sin(t / 2.) * sin(t / 2.) * vec2(-2., 0.) +\n                vec2 (0., 0.001);\n        }\n        else if (n % 6 == 3) { // segment -2 to -1.75\n            c = cos(t / 2.) * cos(t / 2.) * vec2(-1.25, 0.) +\n                sin(t / 2.) * sin(t / 2.) * vec2(-2., 0.) +\n                vec2 (0., -0.001);\n        }\n        else if (n % 6 == 4) { // lower half disk\n            c = vec2(-1. - 0.25 * cos(t), -0.25 * sin(t));\n        }\n        else { // lower half cardiod\n            c = 0.5 * vec2(cos(t), sin(t)) - 0.25 * vec2(cos(2.*t), sin(2.*t));\n        }\n        // shows c as a small red disk\n        float dist_to_c = smoothstep (0.1, 0., length(z - c));\n        vec4 red_spot = vec4(dist_to_c, 0., 0., 0.);\n        \n        // julia_set\n        escape = float(iter(c, z, 256, 2.)) / 256.;\n        vec4 jul = vec4 (mix (vec3(0.), vec3(.4,.6,1.), escape), 1.0);\n        \n        // alltogether\n    \tO = jul + MSet + red_spot;\n    }\n    else {\n        c = 5. * (iMouse.xy / iResolution.x - vec2(0.5,0.3));\n        escape = float(iter(c, z, 256, 2.)) / 256.;\n        vec4 jul = vec4 (mix (vec3(0.), vec3(.4,.6,1.), escape), 1.0);\n    \tO = jul + MSet;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s3SWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s3XRH", "name": "outrun", "author": "psedge", "description": "~a retro aesthetic concept NOW WITH MIC INPUT~", "tags": ["outrun", "vaporwave", "synthwave"], "likes": 3, "viewed": 274, "date": "1571597455", "time_retrieved": "2024-06-20T19:45:55.475345", "image_code": "vec3 fade(vec3 fg, vec3 bg, float alpha) {\n    return mix(bg, fg, alpha);\n    return bg*(1.0-alpha) + fg*(min(1.0,alpha));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = 0.0;\n    float h = iResolution.y;\n    float w = iResolution.x;\n    float distort = abs(sin(iTime/10.0));\n    float scale = h/450.0;\n\t\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat mic = texture( iChannel0, vec2(uv.x,1.0)).x;\n    vec3 col = vec3(0.15,0.0,0.15)*(uv.y+0.05)*distort;\n    \n    //sun drop\n    float distSun = distance(fragCoord, iResolution.xy*0.5-vec2(0.0,(-50.0)));\n    if (distSun < h*(2.5) && distSun > h*0.0) {\n        col = fade(col, vec3(0.4,0.24,0.4), distSun/h*(distort*6.0));\n    }\n    \n    //sun\n    if (distance(fragCoord, iResolution.xy*0.5-vec2(0.0,10.0)) < h*max(0.25+(distort/4.0), 0.1)) {\n        if (fragCoord.y < h/2.0 - 1.5*scale || fragCoord.y > h/2.0 + 3.0*scale) {\n            if (fragCoord.y < h/2.0 + 5.0*scale || fragCoord.y > h/2.0 + 22.0*scale) {\n                if (fragCoord.y < h/2.0 + 25.5*scale || fragCoord.y > h/2.0 + 35.5*scale) {\n                    if (fragCoord.y < h/2.0 + 42.0*scale || fragCoord.y > h/2.0 + 47.0*scale) {\n                        if (fragCoord.y < h/2.0 + 53.0*scale || fragCoord.y > h/2.0 + 55.5*scale) {\n                            if (fragCoord.y < h/2.0 + 62.0*scale || fragCoord.y > h/2.0 + 64.5*scale) {\n                                float maxSun = max(distort, 0.25);\n                                col = vec3(maxSun, maxSun, maxSun-0.2)*(uv[1]*5.0);\n                                \n                            }\n                        }\n                    }\n                }\n            }\n        }\n   \t}\n    \n    // waves\n    if (fragCoord.y*0.5 < cos(fragCoord.x*0.01)+h*(max(0.25, 0.225+mic/10.0))) {\n        col = vec3((1.0-distort)*0.3, 0.0, (1.0-distort)*0.3);\n\t\t//vec3 lineCol = 0.9-(uv.y*(min(0.6, max(0.5, distort)))*2.0)-vec3(distort, 0.85, 0.2);\n        vec3 lineCol = 0.7-(1.0*uv.y*(min(0.5, max(0.3, distort/2.0))))-vec3(distort/5.0, 0.65, 0.1);\n        float roadMod = 0.7 + (mic*2.0);\n        \n        // fg vert\n        //if (uv.x > (0.498+uv.y/250.0) && uv.x < (0.503-uv.y/250.0) && mod(uv.y+mod(iTime/5.0, 0.4), 0.15) > 0.1) {\n        if (uv.x > (0.498+uv.y/250.0) && uv.x < (0.503-uv.y/250.0)) {\n\t\t\tcol = lineCol * roadMod;\n        } else if (mod(fragCoord.x-w/2.0, h/1.89-fragCoord.y) < 2.25 && (uv.x < 0.25+uv.y/2.0 || uv.x > 0.79-uv.y/1.76)) {\n            col = lineCol;\n        }\n        \n\t\t// fg hoz\n        float c = 0.5*pow(0.5, (uv.y-0.1)*10.0);\n        float s = 0.625*pow(2.0, (uv.y-0.1)*10.0);\n        float d = min(0.02, c/8.0);\n        if (mod(uv.y+mod(iTime/s, c), c) < d && (uv.x < 0.2+uv.y/1.75 || uv.x > 0.8-uv.y/1.76)) {\n        \tcol = lineCol;\n        }\n        if (mod(uv.y+mod(iTime/s, c), c) < d && uv.x > 0.2+uv.y/1.75 && uv.x < 0.8-uv.y/1.76) {\n            col = lineCol * roadMod;\n        }\n        \n    }\n\n    fragColor = vec4(col,a);\n}\n", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s3XRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s3XRn", "name": "RectanglePractise", "author": "zrcoy", "description": "make a simple rect", "tags": ["rect"], "likes": 0, "viewed": 114, "date": "1571764062", "time_retrieved": "2024-06-20T19:45:55.475345", "image_code": "float makeBand(float d, float start, float end, float blur)\n{\n    float band1 = smoothstep(start - blur, start + blur, d);\n    float band2 = smoothstep(end + blur, end - blur, d);\n    return band1*band2;\n}\n\nfloat makeRect(vec2 uv, float left, float right, float top, float bottom, float blur)\n{\n    float verticalBand = makeBand(uv.x ,left,right,blur );\n    float horizontalBand = makeBand(uv.y, bottom, top, blur);\n    return verticalBand * horizontalBand;\n}\n\nfloat makeDiamond(vec2 uv, float left, float right, float top, float bottom, float blur)\n{\n    float verticalBand = makeBand(uv.x +uv.y ,left,right,blur );\n    float horizontalBand = makeBand(uv.y - uv.x, bottom, top, blur);\n    return verticalBand * horizontalBand;\n}\n\nfloat remap1(float a, float b, float t) //remap t to a - b in a range of 0-1 \n{\n \treturn ((t-a) / (b - a));\n}\n\nfloat remap2(float a , float b, float c, float d , float t)\n{\n    return remap1(a,b,t) * (d-c) + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5f;\n    uv.x *= iResolution.x / iResolution.y;\n    uv*=3.0f;\n    \n    float x = uv.x;\n    float y = uv.y;\n    float m = -(x-.5f)*(x+.5f);\n    m = 0.4f*sin(x*8.0f + iTime);\n    y -= m;\n    float blur;\n    blur += remap2(-.9f,.9f, 0.02f,0.2f,x);\n    float normalRect = makeRect(vec2(x,y),-.9f,.9f,.2f,-.2f,blur);\n    float rectMask = makeRect(vec2(x,y), -.2f * abs(sin(iTime)) , .2f* abs(sin(iTime)) ,.2f * abs(sin(iTime)),-.2f* abs(sin(iTime)), .002f);\n    \n    vec3 col =vec3( .0f);\n    \n    \n    col += normalRect;\n    \n    fragColor = vec4(col,1.f); \n\t\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s3XRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s3XWr", "name": "quasirandom r4 based hashing", "author": "public_int_i", "description": "r4 hash on left, sine based hash on right\n\nbased on http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/", "tags": ["random", "point", "r4", "hashing", "quasirandom", "r2", "r3", "quasi"], "likes": 2, "viewed": 257, "date": "1571749473", "time_retrieved": "2024-06-20T19:45:55.723856", "image_code": "\n//bad sin based hash\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\n\n/*javascript snippet for calculating plastic constant for ND-dimension\n\nvar ND = 4,\n\tITER = 10000,//higher iterations solves number to higher decimal places\n\tn = 1;\nND = 1.0/(1+ND);\nfor (var i = 0; i < ITER; i++) n = Math.pow(1+n,ND);\nconsole.log(n);\n*/\n#define R4P 1.1673039782614187\n\n//r4 based hash  http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec4 r4(float n) {\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash4(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\n\nvoid mainImage( out vec4 o, in vec2 u)\n{\n    vec4 seed = vec4(u.xyy,iTime);\n    if (u.x > iResolution.x*.5) {//sine hash right\n        o = vec4(hash(seed).xxxx);\n    } else {\n        o = vec4(hash4(seed).xxxx);//r4 hash left\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s3XWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3scSRN", "name": "A hyperspace travel 1", "author": "pik33", "description": "Smoothstep added to Logarithmic warping added to a shader by inigo quilez. \nThe smoothstp gave a nice effect resembling a hyperspace travel", "tags": ["warping", "flow"], "likes": 6, "viewed": 114, "date": "1571514895", "time_retrieved": "2024-06-20T19:45:56.499684", "image_code": "// Fork of \"Log warp\" by ciric50. https://shadertoy.com/view/tdt3z8\n// 2019-10-19 18:37:12\n// Added smoothstep to the color calculation created a nice effect.\n// ---------------------------------------------------------------\n\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// See here for a tutorial on how to make this:\n//\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n\n// Sep 6, 2019\n// Willard Maier\n// I added logarithmic warping to what inigo did.\n\n//====================================================================\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\n//====================================================================\n\nfloat func( vec2 q, out vec4 ron )\n{\n    q += 0.3*sin( vec2(0.27,0.23)*2.*iTime + length(q)*vec2(4.1,4.3));\n\n\tvec2 o = fbm4_2( 0.9*q );\n\n    o += 0.4*sin( vec2(0.12,0.14)*2.*iTime + length(o));\n\n    vec2 n = fbm6_2( 3.0*o );\n\n\tron = vec4( o, n );\n\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\n\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\n}\n\nvec2 warp(in vec2 p)\n{\n#define R1  0.1\n#define R2  4.0\n\n    // Logarithm\n    vec2 a = log(abs(p+0.01));\n\n    // Rotate\n    float alpha = atan(log(R2/R1)/6.283185307);\n    float f = cos(alpha);\n    float s = sin(alpha);\n    vec2 b = f*vec2(a.x*f - a.y*s, a.x*s+a.y*f);\n\n    // Exponential\n    return vec2(exp(b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p1 = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 p = warp(p1);\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    float f = func(p, on);\n\n\tvec3 col = vec3(0.0);\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\n    col = clamp( col*f*2.0, 0.0, 1.0 );\n    \n#if 0\n    // gpu derivatives - bad quality, but fast\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\n#else    \n    // manual derivatives - better quality, but slower\n    vec4 kk;\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \n                                2.0*e,\n                                func(p+vec2(0.0,e),kk)-f ) );\n#endif    \n\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    col=1.5*smoothstep(0.65,1., col);\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3scSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3scSRS", "name": "Double Simplex Truchet Weave Cap", "author": "ollj", "description": "simplified monochrome fork of \nhttps://www.shadertoy.com/view/3lB3Rc\nto print out for coloring with pens or as aquarell\n\nContinuing on from BigWIngs's double simplex Truchet weave pattern.", "tags": ["triangle", "simplex", "truchet", "pattern", "double", "weave", "zentangle"], "likes": 12, "viewed": 374, "date": "1572206946", "time_retrieved": "2024-06-20T19:45:58.432929", "image_code": "/*\n\n\n\tDouble Simplex Truchet Weave\n\t----------------------------\n\n\tAll too often, I'll be in the middle of coding something, then someone on \n    Shadertoy will post some interesting concept that sends me off on a tangent. \n\tBigWIngs puts up a lot of examples along those lines.\n\n    The other day, he posted a double quad Truchet that resulted in a really \n\tintense looking weave pattern -- The link is below. The basic premise was to \n\tdouble the usual amount of connecting points per side, then run\trandom \n\tsegments between them. It's such a simple idea, but opens up a heap of \n\tpossibilities.\n\n\tAnyway, BigWIngs also sketched up a very basic double sided simplex weave as \n\ta proof of concept, so this is just an extension on it.\n\n\tI was pleasantly surprised by how quickly it came together. Most of the time,\n\tthings that should take five minutes wind up taking much longer. The process\n\twas relatively quick because I was able to repurpose my quad version without\n\ttoo many incidents.\n\n\tIn regard to the lighting, I basically hacked away with a few samples to get \n\tthe look I wanted. There's very little science in there, so I wouldn't take \n\tany of it seriously... And I hope you like a monochrome palette -- It's the\n\tone I choose when I'm too lazy to make colors work. :D Either way, there's a\n\t\"CENTER_STRIPE\" define there for anyone who requires a splash of color.\n\n    Like the quad variation, if you wanted to produce a 3D extruded version,\n\tyou'd probably have to replace the Bezier curves with a mixture of arcs and \n\tlines, as it would be much faster.\n\n\tAt some point, I'd like to put together a proper 3D version, but I should \n\tprobably get back to what I'm supposed to be coding at the moment. :)\n\n\n\n\tBased On:\n\n    Double Triangle Truchet Doodle- BigWIngs\n\thttps://www.shadertoy.com/view/Ml2yzD\n\n\tCube-mapped Double Quad Truchet - BigWIngs\n\thttps://www.shadertoy.com/view/wlSGDD\n\n    Double Sided Quad Truchet - Shane\n\thttps://www.shadertoy.com/view/wl2GRG\n\n\n*/\n\n// I was undecided as to whether I wanted color, or not. Perhaps too busy?\n// Anyway, I've included it as an option.\n//#define CENTER_STRIPE\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.197)))*43758.5453); }\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n    \n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n     // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n   vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = length(b.xy - a.xy)*1.732/6.; // (1.4142 - 1.)/1.4142;\n \n    // Points on the same edge each have the same normal, and segments between them\n    // require a larger arc. There was no science behind the decision. It's just \n    // something I noticed and hacked a solution for. Comment the line out, and you'll \n    // see why it's necessary. By the way, replacing this with a standard semicircular \n    // arc would be even better, but this is easier.\n    if(abs(length(b.zw - a.zw))<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier curve from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\n\n// vec4 swap.\nvoid swap(inout vec4 a, inout vec4 b){ vec4 tmp = a; a = b; b = tmp; }\n \n\nvec4 triPattern(vec2 p){\n    \n\n    // Scaling constant.\n    const float gSc = 4.;\n    p *= gSc;\n    \n    // Keeping a copy of the orginal position.\n    vec2 oP = p;\n    \n    // Smoothing factor: This can do my head in, sometimes. If you don't take screen\n    // resolution into account, the fullscree image can look too blurry. If you do, the\n    // image can look too crisp and lose something in the translation... Then there's PPI\n    // to consider... Damned if you do, damned if you don't. :D\n    float sf = 4./450.*gSc;\n    sf*=.3;\n    //float sf = 4./min(750., iResolution.y)*gSc;\n    \n    \n     \n    // SIMPLEX GRID SETUP\n    \n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    //float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n    //vec2 ioffs = vec2(1. - i, i);\n    \n    // Amalgamating to the two lines above into this.\n    vec2 ioffs = p.x < p.y? vec2(0, 1) : vec2(1, 0);\n    \n    \n    // Vectors to the other two triangle vertices.\n    vec2 ip0 = vec2(0), ip1 = ioffs - .2113248654, ip2 = vec2(.577350269);\n    \n    // Make the vertices match up by swapping two of the vertices on alternate triangles. \n    // Actually, it's not really necessary here, but if you want to check neighboring\n    // properties, etc, it's a habit worth getting into.\n    if(ioffs.x<.5) { vec2 tmp = ip0; ip0 = ip2; ip2 = tmp; }\n    \n    \n    // Centralize everything, so that vec2(0) is in the center of the triangle.\n    vec2 ctr = (ip0 + ip1 + ip2)/3.; // Centroid.\n    //\n    ip0 -= ctr; ip1 -= ctr; ip2 -= ctr; p -= ctr;\n    \n   \n    \n    \n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges. There are faster ways to achieve this, but this will do.\n    float tri = min(min(distLine(p - ip0, p - ip1), distLine(p - ip1, p - ip2)), \n                  distLine(p - ip2, p - ip0));\n    \n    // Connecting points around the triangles. Two for each side. I should probably\n    // use a bit of trigonometry and hard code these, but I was feeling lazy. :)\n    const float offs = .204124; // Approx: length(ip0 - ip1)/4., or 1./sqrt(24.);\n    vec2 m01s = mix(ip0, ip1, .5 + offs);\n    vec2 m01t = mix(ip0, ip1, .5 - offs);\n    vec2 m12s = mix(ip1, ip2, .5 + offs);\n    vec2 m12t = mix(ip1, ip2, .5 - offs);\n    vec2 m20s = mix(ip2, ip0, .5 + offs);\n    vec2 m20t = mix(ip2, ip0, .5 - offs);\n    \n    // The boundary normals for each point. I should probably hardcode these as well.\n    vec2 n01 = -normalize(mix(ip0, ip1, .5));\n    vec2 n12 = -normalize(mix(ip1, ip2, .5));\n    vec2 n20 = -normalize(mix(ip2, ip0, .5));\n    \n    // Points, and their respective normals, to pass to the segment function.\n    vec4[6] pnt = vec4[6](vec4(m01s, n01), vec4(m01t, n01), \n                          vec4(m12s, n12), vec4(m12t, n12),\n                          vec4(m20s, n20), vec4(m20t, n20));\n    \n    \n    \n    // Shuffling the 6 array points and normals. I think this is the Fisher–Yates method, \n    // but don't quote me on it. It's been a while since I've used a shuffling algorithm, \n    // so if there are inconsistancies, etc, feel free to let me know.\n    //\n    // For various combinatorial reasons, some non overlapping tiles will probably be \n    // rendered more often, but generally speaking, the following should suffice.\n    //\n    for(int i = 5; i>0; i--){\n        \n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        \n        // Random number for each triangle: The figure \"s*3 + ioffs + 1\" is unique for\n        // each triangle... I can't remember why I felt it necessary to divide by 3,\n        // but I'll leave it in there. :)\n        float rs = hash21((s*3. + ioffs + 1.)/3. + fi/6.);\n        \n        // Other array point we're swapping with.\n        //int j = int(floor(mod(rs*6e6, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(pnt[i], pnt[j]);\n        \n    }    \n\n    \n    vec3 d; // Distances for all three triangle cell segments.\n    \n    float dPnt = 1e5; // Distance for the edge points.\n    \n    for(int i = 0; i<3; i++){\n        \n        // The Bezier segments for each layer.\n        d[i] =  doSeg(p,  pnt[i*2], pnt[i*2 + 1], offs);\n        \n        // The two edge points for each side.\n        dPnt = min(dPnt, length(p - pnt[2*i].xy));\n        dPnt = min(dPnt, length(p - pnt[2*i + 1].xy));\n    }\n    \n    \n    d -= .05; // Giving the segment some width.\n    dPnt -= .0125; // Edge point size.\n    \n  \n    // Overall cell color and bump value.\n    vec3 col = vec3(1.);\n    //float bump = -.5;\n    \n    // Concentric triangle background pattern.\n    float pat = 1.;//clamp(cos(tri*96.)*.5 + .5, 0., 1.);\n    \n    // Background triangle borders.\n    //col = mix(col, col*1.5, 1. - smoothstep(0., sf, tri - .01));\n    //col = mix(col, col*.5, 1. - smoothstep(0., sf, tri - .0));\n \t\n    // Extra base shadowing for the bump pass.\n    //bump = mix(bump, 0., (1. - smoothstep(0., sf*3., min(min(d.x, d.y), d.z) - .03))*.5);\n\n    \n    // Rendering the layers. The bump value is similar to the color value, but differs slightly,\n    // in places, so ultimately needs its own variable. Obviously, this means doubling up on \n    // calculations, but thankfully, this is a 2D... ish example.\n    for(int i = 0; i<3; i++){\n        \n        // Shadows, stroke, color, etc.\n        //col = mix(col, vec3(.0), (1. - smoothstep(0., sf*3., d[i] - .03))*.85);\n        col = mix(col, vec3(.0), 1. - smoothstep(0., sf, d[i] - .02));\n        col = mix(col, vec3(1), 1. - smoothstep(0., sf, d[i]));\n//        col = mix(col, vec3(.03), 1. - smoothstep(0., sf, d[i] + .01));\n\n        \n\n    }\n    \n    // Return the color and bump value.\n    return vec4(col, 1.);\n    \n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect correct pixel coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/min(750., iResolution.y);\n    \n    // Scaling and translation.\n\tuv = rot2(3.14159/12.)*(uv + vec2(.1, .05)*iTime);\n     \n    // Three color samples.\n    vec4 col = triPattern(uv);\n \n    fragColor = (max(col, 0.));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3scSRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3scXR7", "name": "Exoplanets", "author": "mhnewman", "description": "Tour a series of procedurally generated exoplanets.\nFast enough for FULLSCREEN!", "tags": ["procedural", "planets", "saturn", "jupiter", "uranus", "exoplanets", "moons"], "likes": 26, "viewed": 316, "date": "1571682630", "time_retrieved": "2024-06-20T19:45:59.784839", "image_code": "const bool GO_CRAZY = false;\n\nconst float tau = 6.283185;\n\nfloat hash1(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash1(float p, float q) {\n    vec3 p3  = fract(vec3(p, q, p) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(float p, float q) {\n    vec3 p3 = fract(vec3(p, q, p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash3(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash3(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hash4(float p) {\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);    \n}\n\nfloat noise1(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(hash1(i), hash1(i + 1.0), u);\n}\n\nvec3 noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(mix(hash3(i + vec3(0.0, 0.0, 0.0)), \n                                   hash3(i + vec3(1.0, 0.0, 0.0)), u.x),\n                               mix(hash3(i + vec3(0.0, 1.0, 0.0)), \n                                   hash3(i + vec3(1.0, 1.0, 0.0)), u.x), u.y),\n                           mix(mix(hash3(i + vec3(0.0, 0.0, 1.0)), \n                                   hash3(i + vec3(1.0, 0.0, 1.0)), u.x),\n                               mix(hash3(i + vec3(0.0, 1.0, 1.0)), \n                                   hash3(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\n}\n\nfloat fbm1(float p) {\n    float f = noise1(p); p = 2.0 * p;\n    f += 0.5 * noise1(p); p = 2.0 * p;\n    f += 0.25 * noise1(p); p = 2.0 * p;\n    f += 0.125 * noise1(p); p = 2.0 * p;\n    f += 0.0625 * noise1(p);\n    return f / 1.9375;\n}\n\nconst mat3 m = mat3( 0.51162, -1.54702,  1.15972,\n                    -1.70666, -0.92510, -0.48114,\n                     0.90858, -0.86654, -1.55678);\n\nvec3 fbm3(vec3 p) {\n    vec3 f = noise3(p); p = m * p;\n    f += 0.5 * noise3(p); p = m * p;\n    f += 0.25 * noise3(p); p = m * p;\n    f += 0.125 * noise3(p); p = m * p;\n    f += 0.0625 * noise3(p);\n    return f / 1.9375;\n}\n\nvec3 uniform3(float seed) {\n    vec2 hash = hash2(seed);\n    float x = 2.0 * hash.x - 1.0;\n    float r = sqrt(1.0 - x * x);\n    float t = tau * hash.y;\n    return vec3(x, r * sin(t), r * cos(t));\n}\n\nvec3 hsv(float hue, float sat, float val) {\n    return (val) * (vec3(1.0 - (sat)) + (sat) * (0.5 + 0.5 * cos(6.2831853 * (vec3(hue) + vec3(0.0, 0.33, 0.67)))));\n}\n\nvec4 newMoon(float moonCount, vec3 pole, float seed, float moon) {\n    vec3 pos = uniform3(seed);\n    pos -= 0.75 * pole * dot(pole, pos);\n    pos = normalize(pos);\n    pos *= 1.5 + 2.0 * hash1(seed + 0.001);\n    pos *= step(moon, moonCount);\n    float r = 0.02 + 0.1 * pow(hash1(seed + 0.002), 6.0);\n    return vec4(pos, r);\n}\n\n#define hitMoon(moon, seed) { \\\n    vec3 v = eye - moon.xyz; \\\n    float b = dot(v, ray); \\\n    float c = dot(v, v) - moon.w * moon.w; \\\n    float h = b * b - c; \\\n    float mHit = step(0.0, h); \\\n    h = max(h, 0.0); \\\n    float mDepth = -b - sqrt(h); \\\n    vec3 p = eye + mDepth * ray; \\\n    vec3 mNorm = normalize(p - moon.xyz); \\\n    mHit *= step(mDepth, moonDepth); \\\n    moonDepth = mix(moonDepth, mDepth, mHit); \\\n    moonNorm = mix(moonNorm, mNorm, mHit); \\\n    moonSeed = mix(moonSeed, seed, mHit); \\\n}\n\nfloat moonShadow(vec3 pos, vec4 moon, vec3 dir) {\n    vec3 p = pos - moon.xyz;\n\tfloat m = dot(p, dir);\n    float n = dot(p, p);\n    return step(step(m, 0.0) * moon.w * moon.w, n - m * m);\n}\n\nfloat ring(vec3 pos, vec3 dir, vec3 pole, float seed, out float d, out float r, out vec3 q) {\n    vec2 bounds = 1.4 * hash2(seed + 0.9) + vec2(1.1, 1.6);\n    \n    d = dot(-pos, pole) / dot(dir, pole);\n    q = pos + d * dir;\n    r = length(q);\n    \n    float a = smoothstep(bounds.x, bounds.x + 0.1, r) * smoothstep(bounds.y, bounds.y - 0.1, r);\n    a *= smoothstep(-0.5, 1.0, fbm1(6.0 * (r + 3.0 * seed)));\n    return clamp(a, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = 0.25 * iTime;\n    float seed = floor(t) + 1.0;\n    \n    vec3 center = vec3(0.0);\n    float s = tau * (0.4 * (fract(t) - 0.5));\n    center += s * pow(tan(s) / s - 1.0, 10.0) * vec3(1.0, 3.0, 0.0);\n    vec3 eye = center + vec3(0.0, -5.0, 0.0) + fract(t) * vec3(1.0, 1.0, 0.0);\n    float zoom = 3.0;\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward * iResolution.y);\n    \n    vec3 light = uniform3(seed);\n    vec3 pole = uniform3(seed + 0.1);\n    if (GO_CRAZY || iMouse.z > 0.0)\n        seed += 0.123 * floor(3.0 * iTime);\n    float dist = 1.0 + 1.2 * hash1(seed);\n    eye *= dist;\n\n    vec2 bandHash = hash2(seed + 0.2);\n    float bandScale = 1.0 + 6.0 * bandHash.x;\n    float bandTurbulence = 0.1 * pow(bandHash.y, 2.0);\n    \n    vec4 planetHash = hash4(seed + 0.3);\n    vec3 planetColor = hsv(planetHash.x, 0.5, 0.5 + 0.2 * planetHash.y);\n    vec3 planetMinorX = hsv(planetHash.x, 0.3, 0.5 + 0.2 * planetHash.y + 0.3 * planetHash.w) - planetColor;\n    vec3 planetMinorY = hsv(planetHash.x + 0.4 * planetHash.z, 0.5, 0.5 + 0.2 * planetHash.y) - planetColor;\n    vec3 planetMinorZ = hsv(planetHash.x + 0.4 * planetHash.z, 0.3, 0.5 + 0.2 * planetHash.y - 0.4 * planetHash.w) - planetColor;\n    \n    vec3 ringHash = hash3(seed + 0.4);\n    vec3 ringColor = hsv(ringHash.x, 0.2, 0.5 + 0.2 * ringHash.y);\n    vec3 ringMinor = hsv(ringHash.x + 0.3 * ringHash.z, 0.2, 0.7 + 0.2 * ringHash.y) - ringColor;\n    \n    float moonCount = hash1(seed + 0.5) * 8.0 - 2.0;    \n    \n    vec4 moon1 = newMoon(moonCount, pole, seed + 0.01, 0.0);\n    vec4 moon2 = newMoon(moonCount, pole, seed + 0.02, 1.0);\n    vec4 moon3 = newMoon(moonCount, pole, seed + 0.03, 2.0);\n    vec4 moon4 = newMoon(moonCount, pole, seed + 0.04, 3.0);\n    vec4 moon5 = newMoon(moonCount, pole, seed + 0.05, 4.0);\n    vec4 moon6 = newMoon(moonCount, pole, seed + 0.06, 5.0);\n    \n    float b = dot(eye, ray);\n    float c = dot(eye, eye) - 1.0;\n    float h = b * b - c;\n    float hit = step(0.0, h);\n    h = max(h, 0.0);\n    float depth = -b - sqrt(h);\n    vec3 pos = eye + depth * ray;\n    \n    vec3 poleX = normalize(cross(pole, vec3(0.0, 0.0, 1.0)));\n    vec3 poleY = cross(pole, poleX);\n    mat3 rot = inverse(mat3(pole, poleX, poleY));\n    \n    vec3 p = rot * pos;\n    //p.x = asin(p.x); // Latitude bands\n    p += bandTurbulence * fbm3(10.0 * p);\n    \n    vec3 bands = fbm3(bandScale * vec3(1.0, 0.05, 0.05) * p + seed);\n    vec3 color = planetColor;\n    color += planetMinorX * bands.x;\n    color += planetMinorY * bands.y;\n    color += planetMinorZ * bands.z;\n    \n    float moonDepth = 2.0 * depth;\n    vec3 moonNorm = vec3(0.0);\n    float moonSeed = 0.0;\n    hitMoon(moon1, 1.0);\n    hitMoon(moon2, 2.0);\n    hitMoon(moon3, 3.0);\n    hitMoon(moon4, 4.0);\n    hitMoon(moon5, 5.0);\n    hitMoon(moon6, 6.0);\n    float moonHit = 1.0 - step(depth, moonDepth) * hit;\n\n    vec3 moonPos = eye + moonDepth * ray;\n    \n    vec3 moonColor = fbm3(10.0 * moonPos);\n    float moonSat = 0.4 * hash1(seed + 0.123 * moonSeed) + 0.2 * moonColor.x;\n    moonColor = hsv(hash1(seed + 0.321 * moonSeed) + 0.2 * moonColor.y, moonSat, 0.4 + 0.7 * moonColor.z);\n    \n    pos = mix(pos, moonPos, moonHit);\n    color = mix(color, moonColor, moonHit);\n    depth = mix(depth, moonDepth, moonHit);\n    vec3 norm = mix(pos, moonNorm, moonHit);\n    hit = 1.0 - (1.0 - hit) * (1.0 - moonHit);\n    \n    float illumination = max(dot(norm, light), 0.0);\n\n    float m = dot(pos, light);\n    float n = dot(pos, pos);\n    illumination *= step(step(m, 0.0), n - m * m);\n    \n    illumination *= moonShadow(pos, moon1, light);\n    illumination *= moonShadow(pos, moon2, light);\n    illumination *= moonShadow(pos, moon3, light);\n    illumination *= moonShadow(pos, moon4, light);\n    illumination *= moonShadow(pos, moon5, light);\n    illumination *= moonShadow(pos, moon6, light);\n\n    float d, r;\n    vec3 q;\n    float ringShadow = ring(pos, light, pole, seed, d, r, q);\n    illumination *= 1.0 - ringShadow * step(0.0, d);\n\n    color *= hit * illumination;\n    \n    float ringAlpha = ring(eye, ray, pole, seed, d, r, q);\n    float ringLight = 0.5 + 0.5 * abs(dot(pole, light));\n    \n    m = dot(q, light);\n    n = dot(q, q);\n    ringLight *= step(step(m, 0.0), n - m * m);\n    \n    ringLight *= moonShadow(q, moon1, light);\n    ringLight *= moonShadow(q, moon2, light);\n    ringLight *= moonShadow(q, moon3, light);\n    ringLight *= moonShadow(q, moon4, light);\n    ringLight *= moonShadow(q, moon5, light);\n    ringLight *= moonShadow(q, moon6, light);\n    \n    ringColor += ringMinor * fbm1(15.0 * (r + 3.0 * seed));\n    ringColor *= ringLight;\n    \n    color = mix(color, ringColor, step(hit * d, depth) * ringAlpha);\n    \n    color *= 2.0;\n    float flare = max(0.0, dot(ray, light));\n    color += pow(flare, 10.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3scXR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3scXR8", "name": "shadetober #16 (wild)", "author": "percentcer", "description": "Inktober, but with shaders", "tags": ["inktober", "shadertober", "shadetober", "inktober2019"], "likes": 4, "viewed": 268, "date": "1571371841", "time_retrieved": "2024-06-20T19:46:00.160639", "image_code": "// should be a square for best results\n#define NUM 25\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y * .25;\n    // warm up the clock a bit\n    float dt = iTime + 10.;\n\n    // init points\n    vec2 points[NUM];\n    int stride = 5;\n    for(int i = 0; i < NUM; i++) {\n        float row = float(i / stride);\n        float col = float(i % stride);\n        points[i] = (-2. + vec2(col, row)) / float(stride);\n\n        // todo this could probably use some more interesting movement\n        points[i] += vec2(\n             sin(dt*.123*float(i)) * .1,\n             sin(19. + dt*.256*float(i)) * .1\n            );\n    }\n    \n    // debug origin draw\n    #if 0\n    if (uv.x > -.01 && uv.x < .01) { fragColor = vec4(1.,0.,0.,1.); return;}\n    if (uv.y > -.01 && uv.y < .01) { fragColor = vec4(1.,0.,0.,1.); return;}\n    #endif\n\n    // this loop calculates the closest and second closest distances\n    // it will be used for the classic f2-f1 voronoi border\n    vec2 dist = vec2(.5);\n    for(int i = 0; i < NUM; i++) {\n        float d = distance(uv, points[i]);\n        if (d < dist.x) {\n            // store the new closest value and record\n            // what the previous one was in dist.y\n            dist.y = dist.x;\n            dist.x = d;\n        } else if (d < dist.y) {\n            // sometimes the closest value doesn't \n            // change but the second closest does\n            dist.y = d;\n        }\n    }\n\n    // colors are based on leopard print patterns\n    vec3 base = vec3(1.,.8,.5);\n    vec3 outerspot = vec3(0.1, .05, .02);\n    vec3 innerspot = vec3(.81, .37, .01);\n\n    // easy f2-f1 voronoi. consider incorporating iq's perfect border\n    // if you want something more predictable\n    vec3 voro = vec3(dist.y - dist.x);\n    vec3 col = mix(base, outerspot, step(.02, voro));\n    col = mix(col, innerspot, step(.06, voro));\n\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3scXR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3scXzn", "name": "Spirals 15135 ", "author": "theepicsnail", "description": "Sprials", "tags": ["spirals"], "likes": 8, "viewed": 82, "date": "1571260439", "time_retrieved": "2024-06-20T19:46:00.160639", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n\tuv *= 5.;\n    float f = smoothstep(-.4,.4,sin(atan(uv.y, uv.x)*4.-length(uv)*5. +iTime) + sin(length(uv)+iTime));\n    f = 1.- abs(f-1.)*10.0;\n    fragColor = vec4(f,f,f,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3scXzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sd3Rs", "name": "Noise - Basic - 1D", "author": "iq", "description": "This is a 1D noise that uses a single random number/hash per invocation, instead of two like regular value and gradient noises do. This means no neighboring information is needed in order to preserve continuity.", "tags": ["noise", "1d"], "likes": 64, "viewed": 3989, "date": "1570422299", "time_retrieved": "2024-06-20T19:46:00.839494", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This is a 1D noise that uses a single random number/hash\n// per invocation, instead of two like regular value and gradient\n// noises do. This means no neighboring information is needed\n// in order to preserve continuity, and therefore it's much faster\n// than both Value and Gradient Noise.\n//\n// In fact, this is a hybrid between the two - it has zeros at\n// integer locations like Gradient noise, but the gradients/\n// derivatives are constant, +-1. That way each cycle's boundaries\n// are fixed and continuity is preserved always. Then, the single\n// per cycle random number K controls the value of the signal's\n// peak, a bit like in a Value Noise. A quartic function is used\n// to interpolate the whole curve inside the cycle.\n//\n// p(0)=0, p'(0)=1, p(1)=0, p'(1)=-1, p(1/2)=k, p'(1/2)=0\n//\n// results in\n//\n// p(x)=x·(x-1)·((16k-4)·x·(x-1)-1)\n//\n// The yellow curve shows this new Basic Noise, superimposed on\n// top of a regular Gradient Noise in dark grey.\n\nfloat hash( uint n );\n\n// Basic noise\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n  //float k = hash(uint(i));\n  //float k = 0.5+0.5*sin(i);\n    float k = fract(i*.1731);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    uint  i = uint(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n\n    float g0 = hash(i+0u)*2.0-1.0;\n    float g1 = hash(i+1u)*2.0-1.0;\n    return 2.4*mix( g0*(f-0.0), g1*(f-1.0), u);\n}\n\n////////////////////////////////////\n\nfloat fbm( in float x )\n{    \n    float n = 0.0;\n    float s = 1.0;\n    for( int i=0; i<9; i++ )\n    {\n        n += s*bnoise(x);\n        s *= 0.5;\n        x *= 2.0;\n        x += 0.131;\n    }\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px = 1.0/iResolution.y;\n    vec2 p = fragCoord*px;\n\t\n    vec3 col = vec3( 0.0 );\n    col = mix( col, vec3(0.7), 1.0 - smoothstep( 0.0, 2.0*px, abs( p.y - 0.75 ) ) );\n    col = mix( col, vec3(0.7), 1.0 - smoothstep( 0.0, 2.0*px, abs( p.y - 0.25 ) ) );\n    p.x += iTime*0.1;\n    \n    {\n    float y = 0.75+0.25*gnoise( 6.0*p.x );\n    col = mix( col, vec3(0.3,0.3,0.3), 1.0 - smoothstep( 0.0, 4.0*px, abs(p.y-y) ) );\n    }\n\n    {\n    float y = 0.75+0.25*bnoise( 6.0*p.x );\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0 - smoothstep( 0.0, 4.0*px, abs(p.y-y) ) );\n    }\n\n    {\n    float y = 0.25+0.15*fbm( 2.0*p.x );\n    col = mix( col, vec3(1.0,0.6,0.2), 1.0 - smoothstep( 0.0, 4.0*px, abs(p.y-y) ) );\n    }\n\n    fragColor = vec4( col, 1.0 );\n}\n\nfloat hash( uint n ) \n{   // integer hash copied from Hugo Elias\n\tn = (n<<13U)^n; \n    n = n*(n*n*15731U+789221U)+1376312589U;\n    return float(n&uvec3(0x0fffffffU))/float(0x0fffffff);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/3sd3Rs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sdSR4", "name": "cmy circles", "author": "novogrammer", "description": "cmy circles", "tags": ["cmyk", "cmy"], "likes": 6, "viewed": 100, "date": "1571595000", "time_retrieved": "2024-06-20T19:46:00.845534", "image_code": "#define noise(p)  texture( iChannel0, (p) / iChannelResolution[0].xy )\n#define MORE_SIMPLE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //from -1 to 1\n    vec2 pos=( 2.*fragCoord - iResolution.xy )/iResolution.y;\n    \n    float noiseCanvas=mix(.9,1.,noise(fragCoord).r);\n    vec3 col=noiseCanvas*vec3(1.,1.,.9);\n    \n    for(int i=0;i<9;i+=1){\n        float r=radians(float(i+1)*360.*iTime*.1);\n        vec2 circlePosition=vec2(cos(r),sin(r))*.5;\n        if(length(pos-circlePosition)<.5){\n#ifdef MORE_SIMPLE\n            col-=1./12.;\n            col[i%3]-=1./12.;\n#else\n            if(i%3==0){\n                //cyan\n                col-=vec3(2.,1.,1.)/12.;\n            }\n            if(i%3==1){\n                //magenta\n                col-=vec3(1.,2.,1.)/12.;\n            }\n            if(i%3==2){\n                //yellow\n                col-=vec3(1.,1.,2.)/12.;\n            }\n#endif\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sdSR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sdSWn", "name": "rayMarchv5-Camara", "author": "jorge2017a1", "description": "rayMarchv5 ,Camara--........iniciar en 0 para ver cambios de camara", "tags": ["raymarchv5camara"], "likes": 2, "viewed": 48, "date": "1571858904", "time_retrieved": "2024-06-20T19:46:01.639477", "image_code": "//Created by UltimateKimera in 2019-10-21\n//modificado por jorge2017a1 in 2019-10--22\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\n\n\n//Sphere function\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(c - p) - r;\n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(0,1,6,1);\n    vec4 sphere2 = vec4(0,0.5,3.0,0.25);\n    \n    //float dSphere = length(p-sphere.xyz)-sphere.w;\n    \n    \n    float dSphere, dSphere2;\n    //dSphere=sdSphere( sphere.xyz, p ,sphere.w );\n    //dSphere2=sdSphere( sphere2.xyz, p ,sphere2.w );\n    \n    float dPlane = p.y;\n    float d;\n    d=p.y;\n     //d= min(dSphere, dPlane);\n    //  d= min(d, dSphere2);\n    \n    \n    \n    float bx1, bx2, bx3, bx4, bx5, bx6;\n    float bxl1, bxl2, bxl3, bxl4, bxl5, bxl6;\n    \n    //bx1=sdBox( p-vec3(0.5,0.1,0), vec3(0.8,0.5,0.5) );\n    \n    \n    \n    bx1 = sdBox(p- vec3(0, 0, 16), vec3(5.5, 5.8, 0.5));\n    bx2 = sdBox(p- vec3(1.5, 0, 6), vec3(0.5, 1.8, 0.5));\n    bx3 = sdBox(p- vec3(3.5, 0, 6), vec3(0.15, 1.0, 1.5));\n    bx4 = sdBox(p- vec3(3.7, 1.5, 6), vec3(0.15, 0.5, 1.5));\n    bx5 = sdBox(p- vec3(3.9, 2.5, 6), vec3(0.15, 0.5, 1.5));\n    bx6 = sdBox(p- vec3(4.1, 3.5, 6), vec3(0.15, 0.5, 1.5));\n    \n    \n    bxl1 = sdBox(p- vec3(-0.1, 0,10), vec3(4.5, 2.8, 0.5));\n    bxl2 = sdBox(p- vec3(-1.5, 0, 6), vec3(0.5, 1.8, 0.5));\n    bxl3 = sdBox(p- vec3(-3.5, 0, 6), vec3(0.15, 1.0, 1.5));\n    bxl4 = sdBox(p- vec3(-3.7, 1.5, 6), vec3(0.15, 0.5, 1.5));\n    bxl5 = sdBox(p- vec3(-3.9, 2.5, 6), vec3(0.15, 0.5, 1.5));\n    bxl6 = sdBox(p- vec3(-4.1, 3.5, 6), vec3(0.15, 0.5, 1.5));\n    \n    \n    d= min(d, bx1); \t\n  \td= min(d, bx2);\n  \td= min(d, bx3);\n  \td= min(d, bx4);\n  \td= min(d, bx5);\n  \td= min(d, bx6);\n    \n    d= min(d, bxl1); \t\n  \td= min(d, bxl2);\n  \td= min(d, bxl3);\n  \td= min(d, bxl4);\n  \td= min(d, bxl5);\n  \td= min(d, bxl6);\n    \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + dO*rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dS<SURFACE_DIST || dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 e = vec2(.01, 0);\n    float d = GetDist(p);\n    vec3 n = vec3(\n    \td-GetDist(p-e.xyy),\n        d-GetDist(p-e.yxy),\n        d-GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n    if (d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n   \n    vec3 ro;\n    \n\n\n    \n    if (iTime <2.0 )  {ro=vec3(0.0,0.5,0.0);}\n    if (iTime >2.0 && iTime<6.1)  {ro=vec3(0.0,1.5,2.0);}\n    if (iTime >6.2 && iTime<10.1)  {ro=vec3(0.0,1.5,3.0);}\n    if (iTime >10.2 && iTime<13.1) {ro=vec3(0.0,3.0,0.0);}\n    \n    if (iTime >13.2 && iTime<17.0)\n    {\t\n        ro=vec3(0.0,4.5,1.0);\n    }\n    \n     else if (iTime >17.0)\n    {\t\n         ro=vec3(0.0,0.5,0.0);\n    }\n    \n    \n    \n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sdSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sdSzB", "name": "Sphere-Cube and Sun", "author": "TundrumMax", "description": "Its just a ray marcher program with a pulsating Sphere-Cube and a sun. Most of the code is from the \"LIVE Shader Deconstruction :: happy jumping\" video by Inigo, and I added the curved cube and sun into the program.", "tags": ["3d", "raymarcher"], "likes": 2, "viewed": 84, "date": "1572285367", "time_retrieved": "2024-06-20T19:46:01.639477", "image_code": "float sdBox( vec3 p, vec3 b , float r)\n{\n  r = min(r,max(b.x,max(b.y,b.z)));\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(in vec3 pos) {\n \tfloat d = length(pos) - 0.2; //Distance function for a sphere\n    float d2 = sdBox(pos - vec3(0,0,0),vec3(0.2,0.2,0.2),(sin(iTime)*0.5+0.5)*0.2);\n\td = d2;\n    d = min(pos.y + 0.2,d);\n    return d;\n}\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(0.0001,0.0);\n \treturn normalize( vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                           map(pos+e.yxy)-map(pos-e.yxy),\n                           map(pos+e.yyx)-map(pos-e.yyx)));   \n}\n\nfloat castRay(in vec3 ro, in vec3 rd, in float renderDistance) {\n \tfloat t = 0.0;\n    for(int i = 0; i < 100; i++) {\n     \tvec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        if(h < 0.001) break;\n        \n        t += h;\n        if(t > renderDistance) break;\n    }\n    if(t > renderDistance) t = -1.0;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an = iMouse.x / iResolution.x*6.245;\n    float en = -iMouse.y / iResolution.y + 3.1415 / 5.0;\n    //float an = iTime;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(cos(an),sin(en),sin(an));\n    vec3 ta = vec3(0.0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n\n    float renderDistance = 20.0;\n\tfloat t = 0.0;\n    t = castRay(ro,rd,renderDistance);\n    vec3 col = pow(vec3(0.6,0.8,0.9), vec3(rd.y*7.0));\n    \n    \n    vec3 sunVector = normalize(vec3(0.8,0.4,0.2));\n    col += vec3(pow(max(dot(sunVector,rd),0.0), 50.0)) * normalize(vec3(7,4.5,3));\n    \n    \n    \n    if(t > 0.0) {\n        vec3 pos = ro + t*rd;\n        vec3 norm = calcNormal(pos);\n        vec3 mat = vec3(0.18);\n        \n\n        vec3 skyVector = normalize(vec3(0.0,1.0,0.0));\n        \n        float sunDiffuse = clamp(dot(norm,sunVector),0.0,1.0);\n        float skyDiffuse = clamp(0.5 + 0.5*dot(norm,skyVector),0.0,1.0);\n        float bounceDiffuse = clamp(0.5 + 0.5*dot(norm,-skyVector),0.0,1.0);\n        \n        float sunShadow = step(castRay(pos + norm * 0.001,sunVector, renderDistance),0.0);\n        \n        \n        \n    \tcol = mat * vec3(7,4.5,3) * sunDiffuse * sunShadow;\n        col += mat * vec3(0.6,0.8,0.9) * skyDiffuse;\n        col += mat * vec3(0.7,0.3,0.2) * bounceDiffuse;\n    }\n\tcol = pow(col, vec3(0.4545));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sdSzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sdSzM", "name": "shadetober #19 (sling)", "author": "percentcer", "description": "Inktober, but with shaders\n\nWEW not my best thanks for bearing with me through this dark time", "tags": ["inktober", "shadertober", "shadetober", "inktober2019"], "likes": 2, "viewed": 251, "date": "1572248365", "time_retrieved": "2024-06-20T19:46:02.500153", "image_code": "#define TINY .0001\nmat3 roty(float a) { \n    return mat3(\n        cos(a), 0., -sin(a),\n        0., 1., 0.,\n        sin(a), 0., cos(a)\n        );\n}\n\n//---- http://www.flong.com/texts/code/shapers_circ/\nfloat doubleEllipticSigmoid (float x, float a, float b){\n\n  float epsilon = 0.00001;\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  float min_param_b = 0.0;\n  float max_param_b = 1.0;\n  a = max(min_param_a, min(max_param_a, a)); \n  b = max(min_param_b, min(max_param_b, b));\n \n  float y = 0.;\n  if (x<=a){\n    y = b * (1. - (sqrt(a*a - x*x)/a));\n  } else {\n    y = b + ((1.-b)/(1.-a))*sqrt(pow(1.-a,2.) - pow(x-1.,2.));\n  }\n  return y;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm of course\nvec3 opCheapBend( in vec3 p, in float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\n// this doesn't render correctly on my laptop and I have no idea why,\n// looks fine on desktop\n// float sdBox( vec3 p, vec3 b )\n// {\n//   vec3 q = abs(p) - b;\n//   return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n// }\n\nfloat otherSDBox (vec3 p, vec3 c, vec3 s)\n{\n    float x = max\n    (   p.x - c.x - s.x / 2.,\n        c.x - p.x - s.x / 2.\n    );\n \n    float y = max\n    (   p.y - c.y - s.y / 2.,\n        c.y - p.y - s.y / 2.\n    );\n    \n    float z = max\n    (   p.z - c.z - s.z / 2.,\n        c.z - p.z - s.z / 2.\n    );\n \n    float d = x;\n    d = max(d,y);\n    d = max(d,z);\n    return d;\n}\n\nfloat sdSphere(vec3 p) {\n    return length(p) - 1.;\n    //return length(p + vec3(0.,-clamp(sin(iTime)*10.,0.,10.),0.)) - 1.;\n}\n\nfloat sdGround(vec3 p, float k) {\n    return p.y - k;\n}\n\nfloat map(vec3 p) {\n    float fr = fract(iTime);\n    float sigx = (fr > .5 ? 1. - fr : fr) * 2.;\n    float jumpster = doubleEllipticSigmoid(sigx, .2, .51);\n    float sph = sdSphere(p + vec3(0.,-jumpster -.8,0.));\n    float wiggliwoo = (sin(iTime) + 1.) * .3 + .1;\n    float bx = otherSDBox(opCheapBend(p, -sin((4.*iTime + 2.1)) * wiggliwoo), vec3(0.,sin(iTime)*-.2,0.), vec3(5.,.1,3.));\n    //float bx = otherSDBox(opCheapBend(p, .4), vec3(0.), vec3(3.,.1,3.));\n    float d = min(bx, sph);\n    \n    return min(d, sdGround(p, -1.4));\n}\n\n// https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    // start the ray a little bit away from\n    // the surface to avoid self intersection\n    float t = .2;\n    float result = 1.;\n    for (int i = 0; i < 10; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        result = min(result, k * d / t);\n        if (result < 0.0001) {\n            return 0.0;\n        }\n        t += d;\n    }\n    return result;\n}\n\nvec3 grad(vec3 p) {\n    vec2 eps = vec2(TINY, 0.);\n    return normalize(map(p) - vec3(map(p - eps.xyy), map(p - eps.yxy), map(p - eps.yyx)));\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if (d < TINY) { return t; }\n        t += d;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv += texture(iChannel1, uv + iTime).rg * .04; // a touch of distortion\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).rgb * (1. - length(uv) * .5);//vec3(length(uv)*vec3(sin(iTime),1.-length(uv),.8));\n    \n    vec3 ro = vec3(0., 1., 3.);\n    // old style look straight ahead\n    // vec3 rd = normalize(vec3(uv.xy, -1.));\n    \n    // --- camera look-at ---\n    \n    // bad code ignore sleepy copied from other thing for lookat\n    float fr = fract(iTime);\n    float sigx = (fr > .5 ? 1. - fr : fr) * 2.;\n    float jumpster = doubleEllipticSigmoid(sigx, .2, .51);\n    vec3 sphc = vec3(0.,jumpster -.6 * 2.,-2.);\n    \n    vec3 look = normalize(vec3(.0,-.1,-1.));//normalize(sphc);\n    vec3 right = cross(vec3(0., 1., 0.), look);\n    vec3 up = cross(look, right);\n    vec3 rd = normalize(uv.x * right + uv.y * up + look);\n    \n    float dist = march(ro, rd);\n    if (dist < 10.) { \n        vec3 p = ro + rd * dist;\n        vec3 norm = grad(p);\n        vec3 ld = vec3(0.,1.,0.);\n        vec3 lc = vec3(1.,.97,.92);\n        float incd = dot(norm, ld);\n        float shad = shadow(p, ld, 12.);\n        col = incd * lc * shad;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sdSzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sdSzS", "name": "Color gridIDID", "author": "foran", "description": "Color gridIDID", "tags": ["colorgrididid"], "likes": 2, "viewed": 177, "date": "1572276227", "time_retrieved": "2024-06-20T19:46:02.506266", "image_code": "vec3 hsv(in float h,in float s,in float v){\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec3 px=vec3(fragCoord.xy/1.67/iResolution.y,.50)/1.;\n\tvec4 color=vec4(0);\n    float m=1.50;\n    float t=iTime*.1;\n    vec2 c=vec2(sin(t),cos(t));\n    float n=18.5;\n    const int iter=2;\n    for(int i=0;i<iter;i++)\n\t{\n    \tfloat id = 0.5 + 0.5*cos(iTime + sin(dot(floor(px+0.5),vec3(113.1,17.81,1.)))*43758.545);\n    \tvec3 co = 0.5 + 0.5*cos(iTime + 3.5*id + vec3(0.0,1.57,3.14) );\n    \tvec3 pa = smoothstep( 0.0, 0.2, id*(0.5 + 0.5*cos(6.2831*px)) );\n    \tfragColor = vec4( co*pa.x*pa.y, 1.0 );\n    \t//--------------\n      float l=max(abs(px.x-px.z),max(abs(px.y-px.z),abs(px.z-px.x)));\n      m*=smoothstep(0.,1.,l);\n      px/=l*l*.2;\n      px.xy=vec2(atan(c.x*c.y)*px.x-acos(c.x)*px.y,asin(c.x)*px.y-acos(c.x)*px.x);\n      px.xz=vec2(atan(c.x*c.y)*px.x-acos(c.y)*px.z,asin(c.y)*px.z-acos(c.y)*px.x);\n      px=abs(mod((px),n)-n/2.);\n      color+=vec4(.5+.5*sin(iTime*7./8.+l),.5+.5*cos(iTime*11./8.+l),.5+.5*cos(iTime*13./8.+l),1.);\n      color*=vec4(hsv(l,l,l),m);\n\t  //-----------------\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sdSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sdXRf", "name": "Mirror Crystal ", "author": "ankd", "description": "IFS and reflection", "tags": ["raymarching", "reflection"], "likes": 6, "viewed": 176, "date": "1572518778", "time_retrieved": "2024-06-20T19:46:02.506266", "image_code": "const float PI = acos(-1.);\n\nmat2 rotate(in float r) { float c=cos(r), s=sin(r); return mat2(c,-s,s,c); }\nvec2 rotate(in vec2 p, in float r) { return p * rotate(r); }\nvec3 rotate(in vec3 p, in vec3 r) { p.xy = rotate(p.xy, r.z); p.yz = rotate(p.yz, r.x); p.zx = rotate(p.zx, r.y); return p; }\nvec3 rotate(in vec3 p, in float r) { return rotate(p, vec3(r)); }\n\nfloat sphere(in vec3 p, in float r) { return length(p)-r; }\nfloat box(in vec3 p, in vec3 b) { vec3 d = abs(p)-b; return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.); }\nfloat box(in vec3 p, in float b) { return box(p, vec3(b));}\n\nfloat map(in vec3 p) {\n    float r = 1.5;\n    vec3 q = p;\n    vec3 c = vec3(4.0);\n    q = mod(q-0.5*c, c) - 0.5*c;\n    \n    float d = sphere(q, .5);\n\tfor(int i=0;i<6;i++) {\n    \tfloat fi = float(i);\n        q = abs(q) - r;\n        q.xyz = q.zxy;\n        q = rotate(q, PI/4.);\n        r *= mix(0.55, 0.6, 0.5+0.5*sin(iTime*0.04));\n    }\n    d = max(-d, box(q,r));\n\treturn d;\n}\n\n#define MARCH_THR 5e-4\nfloat trace(in vec3 ro, in vec3 rd, in vec2 tmm) {\n\tfloat t = tmm.x;\n    for(int i=0;i<100;i++) {\n    \tfloat tmp = map(ro + rd*t);\n        if(tmp<MARCH_THR || tmm.y<t) break;\n        t += tmp;\n    }\n    return t;\n}\n\n\nvec3 normal(in vec3 p) {\n\tvec2 e = vec2(1., -1.)*1e-4;\n    return normalize(\n    \te.xyy*map(p+e.xyy) +\n    \te.yxy*map(p+e.yxy) +\n    \te.yyx*map(p+e.yyx) +\n    \te.xxx*map(p+e.xxx)\n    );\n}\n\n\n#define MATERIAL_COLOR vec3(0.8,0.9,1.0)\n#define MATERIAL_BRIGHTNESS 2.0\n#define BACKGROUND_COLOR vec3(0.)\n#define REFLECTION 0.5+0.3*sin(iTime*0.25*PI)\nvec3 render(in vec3 ro, in vec3 rd, in vec2 tmm) {\n    vec3 res = vec3(0.);\n    \n\tfloat t = trace(ro, rd, tmm);\n    if(tmm.y<t) return BACKGROUND_COLOR;\n    \n\tvec3 pos = ro + rd*t;\n\tvec3 nor = normal(pos);\n    vec3 ref = reflect(rd, nor);\n    \n    vec3 lp = vec3(-1.);\n    //lp = ro;\n    vec3 ld = normalize(lp-pos);\n    \n    vec3 col = MATERIAL_COLOR * MATERIAL_BRIGHTNESS;\n    col *= clamp(dot(nor, ld)-exp(-1.*length(lp-pos)), 0., 1.);\n    col += pow(clamp(dot(ref, ld), 0., 1.), 30.);\n\n    res += col;\n\n    \n    float theta = 0.5*PI - acos(dot(ref, nor));\n    float tmmx = MARCH_THR / sin(theta);\n    \n    t = trace(pos, ref, vec2(tmmx, tmm.y));\n    if(tmm.y<t) {\n    \tcol = BACKGROUND_COLOR;\n    } else {\n        pos = pos + nor*t;\n        nor = normal(pos);\n        ref = reflect(rd, nor);\n\n        col =  MATERIAL_COLOR * MATERIAL_BRIGHTNESS;\n        col *= clamp(dot(nor, ld), 0., 1.);\n        col += pow(clamp(dot(ref, ld), 0., 1.), 50.);\n    }\n\n    res = mix(res, col, REFLECTION);\n    \n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord.xy*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfloat t = iTime + 50.;\n    //vec3 ro = 4.*vec3(cos(iTime*0.02), 0., sin(iTime*0.02));\n    //ro = vec3(0., 0., 4.*sin(iTime*0.05));\n    vec3 ro = .25*vec3(cos(t*0.4), 0., sin(t*0.4));\n    //vec3 ta = sin(iTime*vec3(0.43, 0.23, 0.33));\n    vec3 ta = 0.25*vec3(cos(-t*0.3), sin(t*0.1*PI), sin(-t*0.3));\n\n    float cr = (t*0.02);\n    vec3 cz = normalize(ta - ro);\n    vec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    vec3 rd = normalize(mat3(cx, cy, cz) * vec3(p, 2.));\n    \n    vec3 col = render(ro, rd, vec2(0., 10.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sdXRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sdXRH", "name": "sgdfgsdfgsdfg", "author": "lennyjpg", "description": "sdfsdfgsdfgsdfgsdfg", "tags": ["sdfgsdfgsdfgsdf"], "likes": 4, "viewed": 314, "date": "1571440172", "time_retrieved": "2024-06-20T19:46:02.506266", "image_code": "# define PI 3.141592653589793\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat r(vec2 uv, int f ){\n    float k = 2.;\n    float t = floor(iTime*.6);\n    return rand( floor( uv * pow(k, float(f))));\n}\n\nvec3 colors[8] = vec3[]( \n    vec3( 1.0, 0.2, 0.0 ),\n    vec3( 0.1, 0.2, 0.3 ),\n    vec3( 0.1, 0.1, 0.0 ),\n    vec3( 0.4, 0.9, 0.8 ),\n    vec3( 1.0, 1.0, 0.9 ),\n    vec3( 0.4, 0.2, 1.0 ),\n    vec3( 0.6, 1.0, 0.9 ),\n    vec3( 1.0, 0.1, 0.2 ));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    vec2 u = uv*2.0;\n    u += iMouse.xy / iResolution.xy * 10.0;\n    u.y+=iTime*0.5;\n    \n    if(iMouse.z > 0.0){\n     float angle = 0.0;\n     float rad = rand(uv*2.5)*0.9;\n      u.x += sin(angle)*rad;\n  \t  u.y += cos(angle)*rad;\n    }\n\n    float s  = r(u, 3);\n    float m = r(u, 2);\n    float l   = r(u, 1);\n    float xl = r(u, 0);\n    float f1 = round( r(u + 33., 1));\n    float f2 = round( r(u + 10., 2));\n    float f3 = round( r(u + 64., 0));\n    float g = mix(s, m, f2);\n    g = mix(g, l, f1);\n    g = mix(g, xl, f3);\n  //  g = fract(g * uv.y );\n   // float k = rand(u)*g*2.2;\n    vec3 col = colors[int(g*8.)];\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sdXRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sdXW8", "name": "(1-t)*x+ty - BIS", "author": "adrenoide", "description": "Homotopy between two funcs, one of them beeing translated forwards in time and the other one backwards.\nThe value of t (between 0 and 1) is given by mouse cursor's abscissa.", "tags": ["homotopy"], "likes": 2, "viewed": 214, "date": "1571889868", "time_retrieved": "2024-06-20T19:46:02.506266", "image_code": "// Click and move the mouse horizontally\n\nconst float pi = 4. * atan(1.);\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 p = U / iResolution.x;\n    p -= vec2(0.5, 0.25);\n    p *= 20.;\n    \n    vec2 mp = iMouse.xy / iResolution.x;\n    \n    float M = smoothstep (0.001, 0.,\n                   (1. - mp.x) * (p.y - 3. * sin(p.x + iTime)) +\n                          mp.x * (p.y - sin(3. * (p.x - iTime))));\n    \n    float grid_x = smoothstep (0., 0.2, abs(sin(pi * p.x)));\n    float grid_y = smoothstep (0., 0.2, abs(sin(pi * p.y)));\n    \n    O = M * (mp.x * vec4(1.,1.,0.5,1.) +\n             (1. - mp.x) * vec4(0.5,1.,1.,1.))\n         * grid_x * grid_y * vec4 (1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sdXW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sdXzr", "name": "Glass bricks", "author": "Simplyfire", "description": "I like glass bricks", "tags": ["noise", "fbm", "glass", "bricks"], "likes": 8, "viewed": 373, "date": "1571336589", "time_retrieved": "2024-06-20T19:46:03.324467", "image_code": "#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\n#define pi 3.14159265359\n\nvec4 permute(vec4 x){ return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat permute(float x){ return floor(mod(((x*34.0)+1.0)*x, 289.0)); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\nfloat taylorInvSqrt(float r){ return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 grad4(float j, vec4 ip){\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p, s;\n\n    p.xyz = floor(fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\nfloat snoise(vec4 v){\n    const vec2  C = vec2(0.138196601125010504, // (5 - sqrt(5))/20  G4\n    0.309016994374947451);// (sqrt(5) - 1)/4   F4\n    // First corner\n    vec4 i  = floor(v + dot(v, C.yyyy));\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n\n    vec3 isX = step(x0.yzw, x0.xxx);\n    vec3 isYZ = step(x0.zww, x0.yyz);\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp(i0, 0.0, 1.0);\n    vec4 i2 = clamp(i0-1.0, 0.0, 1.0);\n    vec4 i1 = clamp(i0-2.0, 0.0, 1.0);\n\n    //  x0 = x0 - 0.0 + 0.0 * C\n    vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n    vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n    vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n    vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n    // Permutations\n    i = mod(i, 289.0);\n    float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute(permute(permute(permute (\n    i.w + vec4(i1.w, i2.w, i3.w, 1.0))\n    + i.z + vec4(i1.z, i2.z, i3.z, 1.0))\n    + i.y + vec4(i1.y, i2.y, i3.y, 1.0))\n    + i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n    // Gradients\n    // ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0);\n\n    vec4 p0 = grad4(j0, ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4, p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * (dot(m0*m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2)))\n    + dot(m1*m1, vec2(dot(p3, x3), dot(p4, x4))));\n}\nconst int OCTAVES = 6;\nfloat fbm(float x, float y, float z, float w){\n    vec4 v = vec4(x, y, z, w);\n    float freq = 1.;\n    float amp = 1.0;\n    float sum = 0.;\n    for (int i = 0; i < OCTAVES; i++){\n        float n = snoise(vec4(v.x*freq, v.y*freq, v.z*freq, v.w*freq));\n        sum += n*amp;\n        amp *= .3;\n        freq *= 3.0;\n        v.xy += vec2(3.212, 12.312);\n    }\n    return sum;\n}\nfloat fbm(float x){\n    return fbm(x, 0., 0., 0.);\n}\nfloat fbm(float x, float y){\n    return fbm(x, y, 0., 0.);\n}\nfloat fbm(float x, float y, float z){\n    return fbm(x, y, z, 0.);\n}\nvec3 rgb(float h, float s, float b){\n    vec3 c = vec3(h, s, b);\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0, 4.0, 2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);  return c.z * mix(vec3(1.0), rgb, c.y);\n}\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\nfloat angularDiameter(float r, float size) {\n    return atan(2. * (size / (2. * r)));\n}\nfloat cubicPulse(float c, float w, float x){\n    x = abs(x - c);\n    if (x>w) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\nfloat map(float value, float start1, float stop1, float start2, float stop2){\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\nfloat norm(float value, float start, float stop){\n    return map(value, start, stop, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = iTime*.15;\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 ov = fragCoord.xy / iResolution.xy;\n    vec2 gv = fract(uv*3.02)-.5;\n    float grid = cubicPulse(.0, .25, min(abs(gv.x), abs(gv.y)));\n    uv *= vec2(1.0,0.5);\n    vec2 distortUv = vec2(fbm(uv.y,uv.x, grid), fbm(grid, uv.x, uv.y));\n    distortUv *= 0.5;\n    float n = fbm(distortUv.y+cos(t),distortUv.x+sin(t), grid);\n    n = pow(n, 1.5);\n    vec3 color = vec3(n);\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sdXzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sG3Dt", "name": "CodebaseAlpha4", "author": "codebasealpha", "description": "A ray-marching terrain shader created live on-stream at https://twitch.tv/codebasealpha. This is a work-in-progress; the intention is to add more features during the next episode of the stream - see CodebaseAlpha6 for those updates!", "tags": ["terrain"], "likes": 11, "viewed": 365, "date": "1571156633", "time_retrieved": "2024-06-20T19:46:03.330569", "image_code": "precision highp float;\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TOLERANCE       0.001\n#define MAX_ITER        100\n#define MIN_DISTANCE    0.1\n#define MAX_DISTANCE    30.0\n\nconst vec3 skyCol1 = vec3(0.35, 0.45, 0.6);\nconst vec3 skyCol2 = vec3(0.4, 0.7, 1.0);\nconst vec3 skyCol3 = pow(skyCol1, vec3(0.25));\nconst vec3 sunCol1 =  vec3(1.0,0.5,0.4);\nconst vec3 sunCol2 =  vec3(1.0,0.8,0.7);\n\nvoid rot(inout vec2 p, in float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  \n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nfloat rand(in vec2 co)\n{\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 hash(in vec2 p)\n{\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nvec4 voronoi(in vec2 x)\n{\n  vec2 n = floor(x);\n  vec2 f = fract(x);\n\n  vec4 m = vec4(8.0);\n  for(int j=-1; j<=1; j++)\n  for(int i=-1; i<=1; i++)\n  {\n    vec2  g = vec2(float(i), float(j));\n    vec2  o = hash(n + g);\n    vec2  r = g - f + o;\n    float d = dot(r, r);\n    if(d<m.x)\n    {\n      m = vec4(d, o.x + o.y, r);\n    }\n  }\n\n  return vec4(sqrt(m.x), m.yzw);\n}\n\nfloat globalHeight(float f, vec2 op)\n{\n    return (f *0.9 + (0.5 + 0.5 * cos(op.y *0.1)) * 0.4 - 0.3) * (0.7 + 0.3 *sin((0.5 + 0.25 * (1.0 + sin(op.y))) * op.x - 1.5));\n}\n\nfloat heightFunction(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n        \n    for (int i = 0; i < 7; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n    \n    return globalHeight(f, op);\n}\n\nfloat heightFunctionLo(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n        \n    for (int i = 0; i < 6; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n    \n    return globalHeight(f, op);\n}\n\nfloat heightFunctionHi(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n        \n    for (int i = 0; i < 11; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n    \n    return globalHeight(f, op);\n}\n\nvec3 getNormal(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunction(p - eps) - heightFunction(p + eps);\n  float dy = 2.0*eps.x;\n  float dz = heightFunction(p - eps.yx) - heightFunction(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nvec3 getNormalLo(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunctionLo(p - eps) - heightFunctionLo(p + eps);\n  float dy = 2.0*eps.x;\n  float dz = heightFunctionLo(p - eps.yx) - heightFunctionLo(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nvec3 getNormalHi(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunctionHi(p - eps) - heightFunctionHi(p + eps);\n  float dy = 2.0*eps.x;\n  float dz = heightFunctionHi(p - eps.yx) - heightFunctionHi(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nfloat march(in vec3 ro, in vec3 rd, out int max_iter)\n{\n  float dt = 0.1;\n  float d = MIN_DISTANCE;\n\n  for (int i = 0; i < MAX_ITER; ++i)\n  {\n    vec3 p = ro + d*rd;\n    float h = heightFunction(p.xz);\n    \n    if (d > MAX_DISTANCE) \n    {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < TOLERANCE)\n    {\n      return d;\n    }\n\n    dt = max(hd, TOLERANCE) + 0.001*d;\n    d += dt;\n  }\n  \n  max_iter = MAX_ITER;\n  return MAX_DISTANCE;\n}\n\nvec3 sunDirection()\n{\n  const vec3 sunDirection = normalize(vec3(-1.0, 0.2, -1.0));\n  vec3 sunDir = sunDirection;\n  rot(sunDir.xz, 2.0);\n  return sunDir;\n}\n\nvec3 skyColor(vec3 rd) {\n  vec3 sunDir = sunDirection();\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  vec3 final = vec3(0.0);\n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  final += mix(mix(skyCol1, skyCol2, max(0.0, angle)), skyCol3, clamp(-angle*2.0, 0.0, 1.0));\n  final += 0.5*sunCol1*pow(sunDot, 30.0);\n  final += 1.0*sunCol2*pow(sunDot, 600.0);\n    \n  return final;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float ll, in float mint)\n{\n  float t = mint;\n  \n  for (int i=0; i<24; ++i)\n  {\n    vec3 p = ro + t*rd;\n    float h = heightFunction(p.xz);\n    float d = (p.y - h);\n    if (d < TOLERANCE) return 0.0;\n    if (t > ll) return 1.0;\n    t += max(0.1, 0.25*h);\n  }\n  \n  return 1.0;\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    int max_iter;\n    float d = march(ro, rd, max_iter);\n    vec3 sandColor =  1.3 * vec3(0.68, 0.4, 0.3);\n    vec3 surfaceColor = vec3(0.0);\n    vec3 skyCol = skyColor(rd);\n    \n    if (d < MAX_DISTANCE)\n    {\n        vec3 p = ro + d * rd;\n        \n        // diffuse lighting\n        vec3 sunDir = sunDirection();\n        float seaHeight = 0.0;\n        float dsea = (seaHeight - ro.y)/rd.y; \n        //vec3 amb = ambient(sunf, sunDir, rd); \n        if (d > dsea && dsea > 0.0)\n        {\n            vec3 normal = vec3(0.0, 1.0, 0.0);\n            vec3 psea = ro + dsea * rd;\n            \n            // specular lighting\n            vec3 refRay = reflect(rd,normal);\n            vec3 refSkyColor = skyColor(refRay);\n            float shad = shadow(psea, sunDir, 4.0, 0.5);\n            \n            return refSkyColor * shad * 0.125 + vec3(0.1, 0.2, 0.4);\n        }\n        else\n        {\n            // Mountain strata\n            float bandings = mix(50.0, 100.0, 0.5 + 0.5*sin(length(p.y)*10.0));\n            float bandingo = sin(length(p.xz) * 3.0);\n            float bandingf = pow(0.5 + 0.5 * sin(p.y*bandings + bandingo), 0.25);\n            float banding = mix(0.6, 1.0, bandingf);\n        \n            float heightLo = heightFunctionLo(p.xz + vec2(0.2));\n            float heightHi = heightFunctionHi(p.xz);\n            float heightRatio = heightHi / heightLo;\n            \n            vec3 normalLo = getNormalLo(p.xz, d);\n            vec3 normal = getNormal(p.xz, d);\n            vec3 normalHi = getNormalHi(p.xz, d);\n            surfaceColor = sandColor * banding;\n            float refFactor = 0.0;\n                        \n            float flatness = max(dot(normal, vec3(0.0, 1.0, 0.0)), 0.0);\n            float flatnessFactor = pow(flatness, 7.0);\n            \n            // Fog\n            float fogHeight = 0.2 + 0.2 * flatnessFactor;\n            float dfog = (fogHeight - ro.y)/rd.y;\n            float fogDepth = d > dfog && dfog > 0.0 ? d - dfog : 0.0;\n            float fogFactor = exp(-fogDepth);\n            \n            vec4 treePattern = voronoi(p.xz * 50.0);\n            vec4 patchPattern = voronoi(p.xz * 10.0);\n        \n            // Snow\n            if (p.y > 0.7 + 0.1 * sin(p.x + p.z) - 0.3 * flatnessFactor)\n            {\n                surfaceColor = vec3(1.0);\n                refFactor = 0.5;\n                normal = normalLo;\n            }\n            else if (p.y < 0.3 + 0.1 * flatnessFactor)\n            {\n                // Trees\n                surfaceColor = mix(vec3(0.2, 0.5, 0.0), vec3(0.5, 0.5, 0.0), patchPattern.y) * 1.3;\n                surfaceColor *= 1.0 - treePattern.x * 0.75;\n                vec3 normalOffset = vec3(treePattern.z, 0.0, treePattern.w);\n                normal = normalize(normalLo - normalOffset);\n            }\n            else\n            {\n                normal = normalHi;\n            }\n        \n            // specular lighting\n            vec3 refRay = reflect(rd,normal);\n            vec3 refSkyColor = skyColor(refRay);\n        \n            // shadows\n            float shad = shadow(p, sunDir, 4.0, 0.25); // Look into this\n            float dl = max(0.0, dot(normal, sunDir));\n            float grad = mix(0.2, 1.0, shad * dl);   \n            vec3 col = vec3(grad * surfaceColor +  refFactor * refSkyColor) * pow(heightRatio, 3.0);\n            \n            col = mix(skyCol, col, fogFactor);\n            \n            col = mix(col, skyCol, d/MAX_DISTANCE);\n        \n            return col;\n        }\n    }\n    else\n    {\n        return skyCol;\n    }\n}\n\nvec3 eyePos(float t)\n{\n    return vec3(sin(t * 0.1), 1.4-0.0, -2.0 + t * 1.0);\n}\n\nvec3 getSample(in vec2 p, in float time)\n{\n  float off = 1.0*time;\n  vec3 ro  = eyePos(time);\n  vec3 la  = eyePos(time + 0.1) + vec3(0.0, -0.02,  0.0);\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 col = getColor(ro, rd);\n \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  vec2 p = fragCoord/iResolution.xy - vec2(0.5);\n  p.x *= iResolution.x/iResolution.y;\n    \n  vec3 col = getSample(p, iTime);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sG3Dt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sG3Rd", "name": "Metallic Paint Stir", "author": "104", "description": "cheap and pretty\nMouse = color", "tags": ["2d", "hypnosis"], "likes": 8, "viewed": 307, "date": "1571074511", "time_retrieved": "2024-06-20T19:46:03.573113", "image_code": "const float PI2 = atan(1.)*8.;\n\nconst float minPow = .6;\nconst float maxPow = 1.5;\nconst float speed = 0.2;\nconst float zoom = 3.0;\nconst float saturation = 0.2;\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord/R.xy-.5;\n    uv.x *= R.x/R.y;\n    uv *= zoom;\n    float t = iTime*speed;\n    \n    // get radius and angle\n    float l = length(uv);\n    l = sqrt(l);\n    float a = atan(uv.x,uv.y)+sin(l*PI2)*PI2;\n    \n    // distort uv by length, animated wave over time\n    float ex = mix(minPow, maxPow, sin(l*PI2+a+t*PI2)*.5+.5);\n    uv = sign(uv)*pow(abs(uv), vec2(ex));\n    \n    float d = abs(fract(length(uv)-t)-.5);// dist to ring centers\n    float c = 1./max(((2.-l)*6.)*d, .1);// dist to grayscale amt\n    o = vec4(c);\n    vec3 col = vec3(\n        clamp(l*l*l, 0.,1.), // generate correlated colorants 0-1 from length, angle, exponent\n        sin(a)*.5+.5,\n        (ex-minPow)/(maxPow-minPow));\n    col = 1.-mix(vec3(col.r+col.g+col.b)/3., col, saturation);\n\n    o.rgb *= col;\n    o *= 1.6-l;// fade edges (vignette)\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sG3Rd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sG3W1", "name": "Jake's Raytracer", "author": "JakeLockey", "description": "Very simple ray tracer", "tags": ["raytracer"], "likes": 0, "viewed": 104, "date": "1570943326", "time_retrieved": "2024-06-20T19:46:03.579135", "image_code": "vec3 CamPos = vec3(2.0,0.0,0.0);\nvec3 LookAt = vec3(0.0,0.0,0.0);\nvec3 CamAng = vec3(0.0,0.0,0.0);\nvec3 SpherePos = vec3(0.0,0.0,0.0);\nvec3 LightPos = vec3(0.0,5.0,0.0);\nfloat SphereRad = 1.0;\n\n\n\nfloat checkCollide(vec3 Origin, vec3 rayDir){\n    vec3 L = (SpherePos-Origin);\n    float tca = dot(L,rayDir);\n    \n    \n    if(tca<0.0){\n        return -1.0;\n    }\n    \n    float d = sqrt(dot(L,L)-(tca*tca));\n    \n    if(d>SphereRad){\n        return -1.0;\n    }\n    \n    float thc = sqrt((SphereRad*SphereRad)-(d*d));\n    float t0= tca-thc;\n    return t0;\n    \n}\n\nbool checkShadow(vec3 P){\n    vec3 ray = LightPos-P;\n    vec3 rayDir = ray/length(ray);\n    \n    \n    vec3 L = (SpherePos-P);\n    float tca = dot(L,rayDir);\n    \n    float d = sqrt(dot(L,L)-(tca*tca));\n    \n    if(d==SphereRad || tca<0.0){\n        return false;\n    }\n    return true;\n}\n\n\nint castRay(vec2 xy){\n    float ratio = CamAng.z/length(CamAng.xy);\n    vec3 VertPerp = vec3(-CamAng.x*ratio, -CamAng.y*ratio, length(CamAng.xy));\n    vec3 yComp = VertPerp * xy.y;\n    \n    vec3 HoriPerp = vec3(CamAng.y,-CamAng.x,0.0)/length(vec3(CamAng.y,-CamAng.x,0.0));\n    vec3 xComp = HoriPerp * xy.x;\n    \n    vec3 ray = (CamAng*3.0)+xComp+yComp;\n    vec3 rayDir = (ray/length(ray));\n    \n    float t1 = checkCollide(CamPos,rayDir);\n    if(t1>0.0){\n        vec3 P1 = CamPos + (rayDir*t1);\n       \tif(checkShadow(P1)){\n            return 2;\n        }\n        return 1;\n    }\n    return 0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    SpherePos = vec3(0.0,sin(2.0*iTime),0.0);\n    //LookAt= SpherePos;\n    LightPos = vec3(0.0,0.0,5.0);\n    CamPos = vec3(6,0.0,0.0);\n    CamAng = LookAt-CamPos;\n    //CamAng = vec3(0.0,-1.0,-1.0);\n    CamAng = CamAng/length(CamAng);\n    \n    \n    \n    \n    vec2 xy = vec2((2.0*(iResolution.x/iResolution.y)) * fragCoord.x/iResolution.x - (iResolution.x/iResolution.y), 2.0 * fragCoord.y/iResolution.y - 1.0);\n    //vec2 xy = 2.0 * fragCoord/iResolution.xy - 1.0;\n    vec3 col = vec3(0.5,0.5,0.5);\n    \n    int rayColor = castRay(xy);\n    \n    if(rayColor==1){\n        col = vec3(1.0,0.0,0.0);\n    }\n    else if(rayColor==2){\n        col = vec3(0.0,0.0,0.0);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sG3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sG3Wm", "name": "Shadertober 05 - Build", "author": "BackwardsCap", "description": "The pharohs would be jealous", "tags": ["build", "inktober", "shadertober", "backwardscaptain"], "likes": 4, "viewed": 290, "date": "1570288253", "time_retrieved": "2024-06-20T19:46:03.760798", "image_code": "//improved thanks to FabriceNeyret!\nfloat sq(vec2 p, float d)\n{\n    p=smoothstep(3./iResolution.y,.0,abs(p)-d-.1);\n    return  p.x*p.y;\n}\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2  p  = (2.*f-iResolution.xy)/iResolution.y;\n    float pr = fract(iTime/5.)*4.,\n    \t  z  = clamp(4.-(pr),0.0,1.0);\n    vec2  pp = vec2(0.,.4)+p+p*z/2.65-vec2(0.,-.27+z*.92);    \n    \n    float t1 = clamp(1.-(pr),0.0,1.0),\n    \t  t2 = clamp(2.-(pr),0.0,1.0),\n    \t  t3 = clamp(3.-(pr),0.0,1.0),\n    \t  d = .375,\n\t\t  t = sq(pp+vec2(0.,-2.)*t2,d) +\n        \t  sq(pp+vec2(.99,0.)+vec2(0.,-2.)*t1,d)+\n        \t  sq(pp+vec2(-.99,0.)+vec2(0.,-2.)*t3,d),    \n   \t\t  m = 1.479, v = 1.1723,h = 1.3636,\n\t \t  b = sq(pp+vec2(0.,v),d*m)+\n    \t  \t  sq(pp+vec2(h,v),d*m) +\n    \t  \t  sq(pp+vec2(-h,v),d*m);\n    \t  c = vec4(vec3(t+b),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sG3Wm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sGGDt", "name": "Zoomy Boxes", "author": "dalp", "description": "trying to recreate a trick I did in Flash back in the 1920s", "tags": ["boxes"], "likes": 3, "viewed": 131, "date": "1571265234", "time_retrieved": "2024-06-20T19:46:04.669807", "image_code": "// This is a combination of a semi-random noise gnerator \n// from Art of Code on Youtube - https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg/videos\n// a step/HSV effect I got from https://www.shadertoy.com/view/XdyXz3\n// and some stuff I did myself (constantly changing noise and the squares)\n// it was basically me learning how to work with masks\n// it's a mess, but it works\n\n#define S(a,b,t) smoothstep(a,b,t)\nconst float LEVELS = 12.;\n\nvec4 N14(float t) {\n    return fract(sin(t*vec4(123., 1024., 3456., 9564.))*vec4(6547., 345., 7799., 1564.));\n}\n\nvec4 NN14(float t) {\n    return fract(sin(t*vec4(1243., 10224., 13456., 69564.))*vec4(61547., 4345., 27799., 15564.));\n}\n\nfloat N11(float p) {\n    float a = fract(p*345.65);\n\ta += dot(a, a+34.45);\n    return fract(a);\n}\n\nfloat N21 (vec2 p) {\n    return fract(sin(p.x*122.+p.y*52453.)*244156.); // returns a single randomish number based on a coord input\n}\n\nvec3 hsv2rgb(vec3 c){  // taken from https://www.shadertoy.com/view/XdyXz3\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat SmoothNoise(vec2 uv) {\n \tvec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b,t,lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv,float d) {\n    float c;\n    float uvscale = 4.;\n    float detail = 1.;\n    for (float i=1.;i<=d;i++) {\n    \tc += SmoothNoise(uv*uvscale)*detail;\n        detail *= 0.5;\n        uvscale *= 2.;\n    }\n    return c/1.3;;\n}\n\nfloat GetClouds(vec2 uv, float t, float d) {\n    float speed = sin(t)*.5+.5;\n    float pi = 3.141592653;\n    // put a thing in here so that whenever the mix is fully one way or another, the 'hidden' one changes\n    float pitime = mod(floor((t - (pi*.5)) / (pi*2.)),100.); // Had to mod this, as after a while it starts drifting\n    float pitime2 = mod(floor((t - (pi*1.5)) / (pi*2.)),100.); // And at high numbers, the cloud function get a little janky\n    vec2 offs = vec2(-2.,-2.);\n    vec2 target1 = uv+(offs*pitime);\n    vec2 target2 = uv+vec2(11.,22.)+(offs*pitime2);\n    \n    // pull two noise maps\n    float c1 = SmoothNoise2(target1, d);\n    float c2 = SmoothNoise2(target2, d);\n    float c = mix(c1,c2,speed);                 \n\t\n    return floor(c*LEVELS)/LEVELS;\n}\n\nvec3 DoClouds (vec2 uv) {\n    uv *= .2;\n\tfloat t = iTime*1.;\n    //vec2 offset = vec2(sin(t)*0.006,cos(t)*0.006);  // rotating lightsource. doesn't look so good without a visual light cue.\n    vec2 offset = vec2(0.006,0.006);\n    \n    uv += iTime*0.02;  // slow diagonal move\n\tfloat detail = 4.; // 1-6 working range\n\n    float c = GetClouds(uv,t,detail);//\n    float edge = GetClouds(uv+offset,t,detail);\n    \n    //calc HSV color (taken from https://www.shadertoy.com/view/XdyXz3)\n    float h = c*.9 - .2; //rainbow hue\n    float s = 0.5;\n    float v = 1. - ( c*(detail*.05) ); //deeper is darker\n    \n    v -= c-edge;\n    \n    return hsv2rgb(vec3(-h,s,v));\n}\n\nvec4 RoundedBox( in vec2 p, in vec2 b, in float r, in vec4 rgba ) \n{\n    vec2 q = abs(p) - b;\n    float d = min(max(q.x,q.y),0.0) + length(max(q,0.0));\n    d *= 10.;\n    return S(.8,.6,d) * rgba;\n}\n\nfloat RoundedBoxInnerMask( in vec2 p, in vec2 b, in float r) \n{\n    vec2 q = abs(p) - b;\n    float d = min(max(q.x,q.y),0.0) + length(max(q,0.0));\n    d *= 10.;\n    return S(.8,.6,d);\n}\n\nvec4 RoundedBoxRing( in vec2 p, in vec2 b, in float r) \n{\n    vec2 q = abs(p) - b;\n    float d = (min(max(q.x,q.y),0.0) + length(max(q,0.0)))*4.;\n    return S(1.,0.85,d)-S(.4,.25,d)*vec4(0.,0.,0.,1.);\n}\n\nvec4 dots(vec2 uv,float t, vec4 rgba, float seed) {\n    vec4 b = vec4(0.); // Box\n    float bm = 0.; // Box Mask\n    vec4 br = vec4(0.); // Box Ring\n    float brm = 0.; // Box Ring Mask\n    vec2 p = vec2(0.); // Box coords\n    float nn = 20.; // Number of boxes\n    float pi = 3.141592653;\n\n    for (float n=1.;n<nn;n++) {\n        float ti = (t*2.2)+.22*n; // change move time offset for each box so they don't all move at the same time\n        // Put a thing in here to change the seed each cycle\n        float pitimes = floor((ti - (pi*.5)) / (pi*2.))*nn;\n        float pitimet = floor((ti - (pi*1.5)) / (pi*2.))*nn;\n        float s1 = seed*n+pitimes;\n        float s2 = seed*n+pitimet;\n        vec4 rands = (N14(s1)-.5)*5.;\n        vec4 randt = (NN14(s2)-.5)*5.;\n        float locx = rands.x+(S(0.,1.,sin(ti)*.5+.5)*(randt.x-rands.x));\n        float locy = rands.y+(S(0.,1.,sin(ti)*.5+.5)*(randt.y-rands.y));\n\n        p.x = uv.x+(locx*1.8); // Needs to be wider.  should fix to aspect ratio, but cba right now.\n        p.y = uv.y+locy;\n        \n        b += RoundedBox(vec2(p),vec2(0.5,0.5),0.1, rgba);\n        bm += RoundedBoxInnerMask(vec2(p.x,p.y),vec2(0.5,0.5),0.1);\n        br += RoundedBoxRing(vec2(p.x,p.y),vec2(0.5,0.5),0.1);\n    }\n\tfloat maskring = clamp(1.-bm,0.,1.);\n    return (b)-(maskring*br);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    float  t = iTime*.6+m.x+6.;\n\tuv *= 5.;\n\tvec4 col = vec4(.0);\n    \n    col += vec4(DoClouds(uv),1.);\n    \n    col += dots(uv,t,vec4(.1,.1,.35,.15),N11(54.)); // Add some boxes\n    \n    fragColor = vec4(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sGGDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sGGWD", "name": "Shadertober 03 Bait", "author": "GreenChicken", "description": "A mouse with its cheese surprised by a guy standing at the door.", "tags": ["raymarching", "mouse", "inktober"], "likes": 5, "viewed": 431, "date": "1570137213", "time_retrieved": "2024-06-20T19:46:04.670031", "image_code": "#define VOLUME 0.001\n#define PI 3.14159\n#define MAXSTEP 64\n\nfloat Vignette(vec2 uv, float force)\n{\n    return 1.0 - pow(length(uv), force);\n}\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdScaledSphere(vec3 p, vec3 s, float r)\n{\n    return float(length(p/s)*s)-r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCheese( vec3 p, vec2 h )\n{\n    p.zy *= rot(PI/2.0);\n    p.xy *= rot(PI/2.0);\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Scene setup\n\nfloat map(vec3 pos)\n{\n    float t = 0.0;\n    \n    t = sdPlane(pos);\n    \n    // mouse\n    vec3 mP = pos + vec3(-.3, 0.0, 2.0);\n    float body = sdScaledSphere(mP, vec3(.5, .5, 1.0), 0.2);\n    \n    vec3 hP = mP + vec3(0.0, -0.15, 0.3);\n    hP.zx *= rot(-PI/4.0+sin(iTime*10.)*.01);\n    float head = sdSphere(hP, .15);\n    vec3 eyeP = hP + vec3(0.05, -0.1, 0.1);\n    head = sSDF(sdSphere(eyeP, .01), head);\n    vec3 ore1P = hP + vec3(0.1, -0.1,  0.0);\n    float ore1 = sdSphere(ore1P, .05);\n    vec3 ore2P = hP + vec3(-0.1, -0.1,  0.0);\n    float ore2 = sdSphere(ore2P, .05);\n    vec3 musP = hP + vec3(0.0, -0.03, 0.15);\n    float mus = sdSphere(musP, .05);\n    vec3 stachP = hP + vec3(0.0, -0.05, 0.15);\n    float stch = sdBox(stachP, vec3(.1, 0.002, 0.002));\n    stachP = hP + vec3(0.0, -0.05, 0.15);\n    stachP.xy *= rot(PI/8.0);\n    stch = uSDF(stch, sdBox(stachP, vec3(.1, 0.002, 0.002)));\n    stachP.xy *= rot(PI/-4.0);\n    stch = uSDF(stch, sdBox(stachP, vec3(.1, 0.002, 0.002)));\n    vec3 tailP = mP + vec3(0.2, 0.09, -0.3);\n    tailP.zx *= rot(PI/16.0+sin(iTime)*0.1);\n    float tail = sdCappedCylinder(tailP, 0.2, 0.1);\n    tailP += vec3(0.03, 0.0, 0.1);\n    tail = sSDF(sdCappedCylinder(tailP, 0.2, 0.2), tail);\n    \n    float ores = uSDF(ore1, ore2);\n    float mouse = uSDF(body, head);\n    mouse = uSDF(mouse, ores);\n    mouse = uSDF(mouse, mus);\n    mouse = uSDF(mouse, stch);\n    mouse = uSDF(mouse, tail);\n    \n    // wall\n    vec3 wallP = pos + vec3(0.0, -1.0, -2.0);\n    float wallBase = sdBox(wallP, vec3(20.0, 30.0, 0.1));\n    vec3 doorP = pos + vec3(2.0, 0.0, -2.0);\n    float door = sdBox(doorP, vec3(1.0, 3.5, 1.0));\n    float wall = sSDF(door, wallBase);\n    \n    // legs\n    vec3 leg1P = pos + vec3(2.0, 1.0, -2.0);\n    float leg1 = sdBox(leg1P, vec3(.15, 3.0, 0.15));\n    vec3 leg2P = pos + vec3(2.6, 1.0, -2.0);\n    float leg2 = sdBox(leg2P, vec3(.15, 3.0, 0.15));\n    float legs = uSDF(leg1, leg2);\n    vec3 pat1p = pos + vec3(2.0, -0.1, -1.8);\n    float pat1 = sdBox(pat1p, vec3(.1, .1, .4));\n    vec3 pat2p = pos + vec3(2.6, -0.1, -1.8);\n    float pat2 = sdBox(pat2p, vec3(.1, .1, .4));\n    float pats = uSDF(pat1, pat2);\n    legs = uSDF(legs, pats);\n    \n    // cheese\n    vec3 cP = pos + vec3(0.05, 0.0, 2.3);\n    float cheese = sdCheese(cP, vec2(0.15, 0.1));\n    cheese = sSDF(sdSphere(cP+vec3(0.1, -0.1, 0.0), .05), cheese);\n    cheese = sSDF(sdSphere(cP+vec3(-0.1, -0.1, 0.0), .03), cheese);\n    cheese = sSDF(sdSphere(cP+vec3(0.0, -0.1, -0.1), .05), cheese);\n    cheese = sSDF(sdSphere(cP+vec3(0.0, -0.1, 0.1), .05), cheese);\n    \n    t = uSDF(t, mouse);\n    t = uSDF(t, cheese);\n    t = uSDF(t, wall);\n    t = uSDF(t, legs);\n    \n    return t;\n}\n\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<MAXSTEP ; i++)\n    {\n        float ray = map(ro + rd * t);\n        \n        if(ray < (0.0001*t))\n        {\n            float ao = float(i)/64.;\n            return t;\n        }\n        \n        t += ray;\n    }\n    \n    return -1.0;\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 10.0; i += .1) {\n        float dist = map(pos + dir * t);\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    float t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t == -1.0)\n    {\n        \n        col = vec3(1.0+rd.y)*(1.0-step(rd.y, -0.2));\n        col *= 1.0-step(uv.x, 0.5); // hide background color from left wall\n        \n    }\n    else\n    {\n        vec3 N = GetNormal(pos);\n        vec3 L = vec3(-4.0, 1.0, 8.0);\n        float light = dot(N,L);\n        float shade = GetShadow(pos, L, 8.0);\n        float rim = smoothstep(1. - .9, 1.0, 1.0-dot(N, rd));\n        \n        col = vec3(1.0);\n        col *= shade;\n        col *= light;\n        \n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 1.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cp = vec3(0.0, 0.6, -3.0);\n    vec3 ct = vec3(0.0, -0.8, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = Render(cp, vd, screenUV);\n    \n    // compo\n    \n    \n    col -= mix(vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), screenUV.y)*.2+sin(iTime)*.1;\n    col *= Vignette(uv, 1.0);\n   \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sGGWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sGGzy", "name": "gridthree", "author": "lennyjpg", "description": "kjlhkljhkjh", "tags": ["j", "k", "hlkjh"], "likes": 4, "viewed": 271, "date": "1570784078", "time_retrieved": "2024-06-20T19:46:04.670031", "image_code": "# define PI 3.141592653589793\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat r(vec2 uv, int f ){\n    float k = 2.;\n    float t = floor(iTime*.6);\n    return rand( floor( uv * pow(k, float(f))));\n}\n\nvec3 colors[8] = vec3[]( \n    vec3( 1.0, 0.2, 0.0 ),\n    vec3( 0.1, 0.2, 0.3 ),\n    vec3( 0.1, 0.1, 0.0 ),\n    vec3( 0.4, 0.9, 0.8 ),\n    vec3( 1.0, 1.0, 0.9 ),\n    vec3( 0.4, 0.2, 1.0 ),\n    vec3( 0.6, 1.0, 0.9 ),\n    vec3( 1.0, 0.1, 0.2 ));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    vec2 u = uv*2.0;\n    u += iMouse.xy / iResolution.xy * 10.0;\n    u.y+=iTime*0.5;\n    \n    if(iMouse.z > 0.0){\n     float angle = 0.0;\n     float rad = rand(u*1.5)*0.9;\n      u.x += sin(angle)*rad;\n  \t  u.y += cos(angle)*rad;\n    }\n\n    float s  = r(u, 3);\n    float m = r(u, 2);\n    float l   = r(u, 1);\n    float xl = r(u, 0);\n    float f1 = round( r(u + 33., 1));\n    float f2 = round( r(u + 10., 2));\n    float f3 = round( r(u + 64., 0));\n    float g = mix(s, m, f2);\n    g = mix(g, l, f1);\n    g = mix(g, xl, f3);\n  //  g = fract(g * uv.y );\n   // float k = rand(u)*g*2.2;\n    vec3 col = colors[int(g*8.)];\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sGGzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sK3Dd", "name": "Colored spiral", "author": "blueneosky", "description": "Don't look too long... or not, depend if you want your vision funny", "tags": ["spiral"], "likes": 0, "viewed": 68, "date": "1571230536", "time_retrieved": "2024-06-20T19:46:04.670031", "image_code": "const float PI = 2.*acos(0.);\nconst float doublePI = 2.*PI;\nconst float waveLength = 10.;\nconst float waveSpeed = 20.0;\n\nfloat waveAngleOffset() {\n    return iTime*waveSpeed; // loose precision arround 800sec\t(because of big number in sin/cos ???)\n    return mod(iTime*waveSpeed, doublePI);\t\n}    \n\nfloat psin(in float angle) { return .5 * (1. + sin(angle)); }\n\nvec2 polar(in vec2 p)\n{\n    float dist = length(p);\n    float teta = dist > .0 ? asin(p.y/dist) : .0;\t// -Pi/2 -> Pi/2\n    if(p.x < .0)\n    \tteta = PI - teta;\n    \n    return vec2(dist, teta);\n}    \n\nfloat spiralPol(in vec2 pol)\n{\n\treturn psin((pol.x*doublePI * waveLength) + pol.y - waveAngleOffset());\n}\n\nfloat spiralXY(in vec2 xy) { return spiralPol(polar(xy)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    vec2 pol = polar(uv);\n    \n    float spiral = spiralPol(pol);\n    // smooth a bit the center\n    spiral = min(1., (pol.x*waveLength*2.)) * spiral;\n    \n\tvec3 col = spiral * (.4+ .5*vec3(uv.xyy) * psin(pol.y - waveAngleOffset()));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sK3Dd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sK3WG", "name": "Creation by Silexars (Reboot)", "author": "Hotrhodium", "description": "Added more color channels. Yeah i know its bad but I love the original post from Danguafer https://www.shadertoy.com/user/Danguafer and something about red and green next each other without yellow makes me cringe.", "tags": ["roygbiv", "rygbv", "roygbv"], "likes": 6, "viewed": 137, "date": "1570855747", "time_retrieved": "2024-06-20T19:46:04.863983", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat c[6];\n    vec3 d;\n\tfloat l,z=t;\n\tfor(int i=0;i<6;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=0.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=0.05;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z*2.));\n        c[i]=.01/length(abs(mod(uv,1.)-.5));\n    }\n    //d = vec3(c[0]+c[1]+(c[4]*0.35),c[2]+c[1],c[3]+(c[4]*0.4));//RYGBV 6th channel is just lost\n    d = vec3(c[0]+c[1]+c[2]+(c[5]*0.35),c[3]+(c[1]*0.3)+c[2],(c[4]+(c[5]*0.4))*1.1);//With/orange ROYGBV\n\tfragColor=vec4(d/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sK3WG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sK3zy", "name": "Infinite House Plan", "author": "104", "description": "More partitioning goodness", "tags": ["2d"], "likes": 18, "viewed": 202, "date": "1571326126", "time_retrieved": "2024-06-20T19:46:04.863983", "image_code": "const float lineThickness = 2.5;\nconst float PARTITIONS = 13.;\n\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    float t = (iTime+1e2)*.4;\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    vec2 N = uv;\n    vec2 R = iResolution.xy;\n    uv.x *= R.x / R.y;\n    uv.x += t*.2;\n    uv.y += sin(t)*.3;\n    uv.y -= .5;\n    \n    vec2 cellUL = floor(uv);\n    vec2 cellBR = cellUL + 1.;\n    vec2 seed = cellUL;\n    o = vec4(1);\n    for(float i = 1.; i <= PARTITIONS; ++ i) {\n        vec4 h = hash42(seed+1e2*(vec2(cellBR.x, cellUL.y)+10.));\n        vec2 test = abs(cellUL - cellBR);\n        vec2 uv2 = uv;\n        float dl = abs(uv2.x - cellUL.x);\n        dl = min(dl, length(uv2.y - cellUL.y));\n        dl = min(dl, length(uv2.x - cellBR.x));\n        dl = min(dl, length(uv2.y - cellBR.y));\n\n        vec3 col = h.rgb;\n        o.rgb *= smoothstep(0.,lineThickness/max(R.x,R.y),dl);\n        if (h.w < .2)\n            o.rgb *= mix(col, vec3(col.r+col.g+col.b)/3.,.6);\n        vec2 pt = mix(cellUL, cellBR, h.y);\n\n        vec2 p2 = pt - uv;\n        float r = max(fract(p2.x-.5), fract(.5-p2.x));\n        r = max(r, fract(.5-p2.y));\n        r = max(r, fract(p2.y-.5));\n        r = 1.-r;\n        vec2 sz = cellBR - cellUL;\n        if (pow(sz.x * sz.y, .1) < r * 1.5) {\n            break;\n        }\n        vec2 thresh = sin(t*2.*h.xy)*.5+.5;\n        thresh *= h.zw*.3;\n        if (sz.x < thresh.x || sz.y < thresh.y)\n            break;\n        \n        if (uv2.x < pt.x) {// descend into quadrant.\n            if (uv2.y < pt.y) {\n                cellBR = pt.xy;\n            } else {\n              \tcellUL.y = pt.y;\n              \tcellBR.x = pt.x;\n            }\n        } else {\n            if (uv2.y > pt.y) {\n                cellUL = pt.xy;\n            } else {\n                cellUL.x = pt.x;\n                cellBR.y = pt.y;\n            }\n\t    }\n    }\n    \n    o = clamp(o,0.,1.);\n    o = pow(o,o-o+.3);\n    o *= 1.-dot(N,N);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sK3zy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sKGDV", "name": "Spiral - Baldwin Shape Extension", "author": "mujina", "description": "Spiraling shader, that can create arbitrary geometric shapes as particular case (just comment out the right parts).", "tags": ["spiral", "shape", "baldwin"], "likes": 7, "viewed": 82, "date": "1570993260", "time_retrieved": "2024-06-20T19:46:05.070251", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5; // -0.5 <> 0.5\n    uv.x *= iResolution.x / iResolution.y;\n\t\n    int N = 4; // SIDES OF SHAPE\n    \n    // angle\n    float a = atan(uv.y, uv.x); // radians(180.); // ROTATE SHAPE\n    \n    // extension of Baldwin's shape: transforming to a spiral\n    float spiral_step = 2.; // SET TO 0 FOR SIMPLE GEOMETRIC SHAPE (removes spiral)\n    a += spiral_step * iTime * length(uv);\n    \n    // slice of circle\n    float f = radians(360.)/float(N);\n    \n    // distance function\n    // float d = floor(0.5 + a/f) * f -a ; // UNCOMMENT TO UNDERSTAND CONSTRUCTION\n    float d = cos(floor(0.5 + a/f) * f - a) * length(uv);\n\n    // vec3 col = vec3(d); // UNCOMMENT TO SEE SMOTH VERSION AND UNDERSTAND CONSTRUCTION\n    vec3 col = vec3(1. - smoothstep(.24,.34,d)); // UNCOMMENT TO CUT\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sKGDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sKGWt", "name": "Spooky", "author": "theepicsnail", "description": "Spooky", "tags": ["spooky"], "likes": 1, "viewed": 257, "date": "1571204562", "time_retrieved": "2024-06-20T19:46:05.070251", "image_code": "mat2x2 rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2x2(c, -s, s, c);\n}\nvec3 yy(vec2 uv) {\n    float angle = iTime*.5;\n    vec3 color = vec3(.2,0,0);\n    \n    for(int i = 0 ; i < 4 ; i ++) {\n        float l = length(uv);\n        if( l > 1.) {\n            //color = mix(color, vec3(1,1,1), smoothstep(1.,2.1,length(uv)));\n            break;\n        }\n        \n        \n        uv *= rotate(sin(angle*float(i) + iTime)*float(i+1)*.11);\n        uv.x -=sign(uv.x)/2.; \n        uv*=2.5;\n        \n        float nl = length(uv);\n        color = vec3(smoothstep(uv.x*uv.x,uv.y,nl))*vec3(.2,0,0);\n        color.rg+=vec2(.3,.2)*max(0.,smoothstep(0.1,0.0,abs(nl-1.1))*smoothstep(.9,1.,abs(uv.x))*(uv.y*5./float(i+1)+.5));\n        //color = vec3(mix(vec3(sign(uv.y)*.5), color, smoothstep(.4, 0.1,abs(length(uv)-1.0))));\n        \n        //color = vec3(-(.2+uv.y)*.2*float(i+1),0,0);\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\tfragColor = vec4(yy(uv*.55+vec2(0,.3)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sKGWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sKGWw", "name": "MULTICOLOURED STARS", "author": "alro", "description": "Another iteration on [url]https://www.shadertoy.com/view/wls3Dl[/url]\n\nDespite the three nested loops, it's still technically loopless. Could use some optimisation at higher resolutions.", "tags": ["2d", "space", "particles", "glow", "stars", "infinite", "sparkle", "loopless"], "likes": 30, "viewed": 782, "date": "1570349280", "time_retrieved": "2024-06-20T19:46:05.645873", "image_code": "//Based on https://www.youtube.com/watch?v=3CycKKJiwis\n\nfloat random(vec2 par){\n   return fract(sin(dot(par.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 random2(vec2 par){\n\tfloat rand = random(par);\n\treturn vec2(rand, random(par+rand));\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float t = 1.0 + iTime * 0.06;\n    float layers = 10.0;\n    float scale = 32.0;\n    float depth;\n    float phase;\n    float rotationAngle = iTime * -0.1;\n    float size;\n    float glow;\n    //Iteration step size for outermost loop\n    float del = 1.0/layers;\n    \n   \tvec2 uv;\n    //Value of floor(uv)\n    vec2 fl;\n    vec2 local_uv;\n    vec2 index;\n    vec2 pos;\n    //Seed for random values\n    vec2 seed;\n    vec2 centre;    \n    //The indices of 3x3 cells surrounding the fragment\n    vec2 cell;\n    //To move the focus of the camera in a circle\n    vec2 rot = vec2(cos(t), sin(t));\n    \n    //To rotate layers\n    mat2 rotation = mat2(cos(rotationAngle), -sin(rotationAngle), \n                         sin(rotationAngle),  cos(rotationAngle));\n \tvec3 col = vec3(0);\n    vec3 tone;\n    \n    //For all layers\n    for(float i = 0.0; i <= 1.0; i+=del){\n        //Find depth from layer index and move it in time\n        depth = fract(i + t);\n        \n        //Move centre in a circle depending on the depth of the layer\n        centre = rot * 0.2 * depth + 0.5;\n        \n        //Get uv from the fragment coordinates, rotation and depth\n    \tuv = centre-fragCoord/iResolution.x;\n        uv *= rotation;\n    \tuv *= mix(scale, 0.0, depth);\n        fl = floor(uv);\n        //The local cell coordinates. uv-fl == frac(uv)\n        local_uv = uv - fl - 0.5;\n\n        \n        //For a 3x3 group of cells around the fragment, find the distance from the points \n        //of each to the current fragment and draw an accumulative glow accordingly\n        //The local cell is (0,0)\n       \tfor(float j = -1.0; j <= 1.0; j++){\n            for(float k = -1.0; k <= 1.0; k++){\n        \t\tcell = vec2(j,k);\n            \n                //Cell index\n        \t\tindex = fl + cell;\n        \n                //Cell seed\n        \t\tseed = 128.0 * i + index;\n                \n        \t\t//Get a random position in the considered cell\n        \t\tpos = cell + 0.9 * (random2(seed) - 0.5);\n        \n        \t\t//Get a random phase\n        \t\tphase = 128.0 * random(seed);\n                //Get colour from cell information\n        \t\ttone = vec3(random(seed), random(seed + 1.0), random(seed + 2.0));\n        \n        \t\t//Get distance to the generated point, fade distant points\n                //and make glow radius pulse in time\n        \t\tsize = (0.1 + 0.5 + 0.5 * sin(phase * t)) * depth;\n        \t\tglow = size * getGlow(length(local_uv-pos), 0.07, 2.5);\n                //Add white core and glow\n        \t\tcol += 5.0 * vec3(0.02 * glow) + tone * glow;\n        \t}\n        }\n    }\n    \n    //Tone mapping\n    col = 1.0 - exp(-col);\n    \n    //Gamma\n    col = pow(col, vec3(0.4545));\n    \n    //Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sKGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sKGzw", "name": "Single Animated Jellyfish", "author": "BradyInstead", "description": "Jellyfish movement shader", "tags": ["animation", "jellyfish", "movement"], "likes": 6, "viewed": 292, "date": "1569905573", "time_retrieved": "2024-06-20T19:46:07.058172", "image_code": "\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat noise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return ((2.2 * n_xyz)+1.)/2.;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat bump(vec3 pos)\n{\n    vec3 npos = abs(sin(pos.xyz))*8. + iTime*.5;\n    float n = noise(npos);\n    return sin(n*10.);\n}\n\nvoid contrast( inout vec3 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r , float nmod)\n{\n    p.x += sin(p.y*2. + iTime*3.)*.2;\n    p.z += cos(p.y*2. + iTime*3.)*.2;\n    \n    float shaping = .05*abs(sin(iTime*3. + p.x + p.z + p.y*4. + p.z))*nmod;\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r + shaping;\n}\n\nfloat sphere(vec3 p)\n{\n    //p.y *= 1.25;\n    float shaping = .1*abs(sin(3.36 + p.x + p.z + p.y*4.));\n    return length(p + bump(p)*.006) - .6+shaping;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n   \tp.y *= .4;\n  \tvec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\nfloat model(vec3 p)\n{\n    //p = opRep(p, vec3(10.));\n    p*=.45;\n    p.y -= 1.25;\n    \n    p.y += sin(iTime*3. + p.y*3.)*.075;\n    p.x += sin(iTime*3. + p.y*3.)*.05;\n    p.z += sin(iTime*3. + p.y*3.)*.05;\n    \n    // head\n    float head = sphere(p);\n    float torus = torus(p + vec3(0., .1 + sin(iTime*3.)*.05, 0.), vec2(.65, .05));\n    \n    head = opSmoothUnion(head, torus, .2);\n    \n    // tentacles\n    vec3 cp = p + vec3(0., -.0, 0.);\n    \n    float tent = capsule(cp + vec3(-.2, .15, .2), vec3(0.), vec3(0., -3., 0.), .2, 2.);\n    tent = min(tent, capsule(cp + vec3(.2, .15, .2), vec3(0.), vec3(0., -3., 0.), .2, 2.));\n    tent = min(tent, capsule(cp + vec3(.2, .15, -.2), vec3(0.), vec3(0., -3., 0.), .2, 2.));\n    \n    for(float i = 0.; i < 15.; i++)\n    {\n    \ttent = min(tent, capsule(cp, vec3(0.), vec3(sin(i + rand(i*10.)), -2., cos(i + rand(i))), .075, 1.));\n    }\n    \n    return opSmoothUnion(tent*.9, head, .1);\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 90; i++)\n    {\n\t\tfloat m = model(ro+rd*dist);\n        dist += m;\n        \n        if(m < .01) return dist;\n        else if(dist > 20.) break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(.01, -.01, 0.);\n    \n    return normalize(vec3(\n        model(pos + eps.xzz) - model(pos + eps.yzz),\n        model(pos + eps.zxz) - model(pos + eps.zyz),\n        model(pos + eps.zzx) - model(pos + eps.zzy)));\n}\n\nfloat shadow(in vec3 pos, in vec3 ld)\n{\n    float spread = 3.;\n    float res = 1.0;\n\tfor(float t = .2; t < .4;)\n    {\n        float dist = model(pos+ld*t);\n        if(dist<.001) return 0.;\n        res = min(res, spread*dist/t);\n        t += dist;\n    }\n    return res;\n}\n\nvec3 background()\n{\n    return vec3(.15, .05, .3);\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 rd, float dist, vec3 ro)\n{\n    if(dist < 0.) return background();\n    \n    //vec3 ld = .6 * vec3(sin(iTime*.5 + .75), 1., cos(iTime*.5 + .75));\n    vec3 ld = normalize(ro + vec3(1.));\n    \n    float dif = max(dot(nor,ld), 0.)*.6;\n    float sha = 0.;\n    if(dif > .01) sha = shadow(pos, ld);\n    vec3 lin = vec3(dif*sha);\n    \n    // add color\n    vec3 col1 = vec3(.2, .9, .8);\n    vec3 col2 = vec3(.0, 0.3, .6);\n    vec3 col = mix(col1, col2, lin)*.75;\n    \n    // bump & shift\n    //float bump = bump(pos);\n    //col = hueShift(col, bump*.25 + .75);\n    //col.bg *= 2. + pow(1., 2.0)*.2;\n    \n    //col = hueShift(col, 4.25);\n    //col = min(col*1.5, vec3(1.));\n    //col *= pow(exp(-.02*dist*dist), .2);\n    //col = pow(col, vec3(1.5));\n    //col.rgb = mix(background(), col, exp(-.003*dist*dist)*1.0).rgb;\n    \n    //col *= 1.2;\n    \n    contrast(col, 1.5);\n    \n    col*=1.5;\n    \n    //col.rb *= .9;\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    p += noise(vec3(p.x*5., p.y*5., iTime))*.05;\n    \n    //vec3 ro = vec3(sin(iTime*.5), 1., cos(iTime*.5))*7.;\n    //vec3 ro = vec3(6.);\n    vec3 ta = vec3(0., 0., 0.);\n    \n    vec3 ro = vec3(cos(iTime/2.), 1., sin(iTime/2.))*7.;\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,1.));\n    \n    float dist = raymarch(ro, rd);\n    vec3 pos = ro+rd*dist;\n    vec3 nor = normal(pos);\n    \n    vec3 col = shade(pos, nor, rd, dist, ro);\n    col = vec3(dot(col.rgb, vec3(0.299, 0.587, 0.114)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sKGzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stSR4", "name": "BinoBlob", "author": "NuSan", "description": "Simple shader to test stereoscopic rendering\nMade for the 3rd issue of Cookie Fanzine that will be released soon\nhttps://fanzine.cookie.paris/\nUse glasses with red on the left eye and cyan on the right eye", "tags": ["3d", "raymarch", "stereoscopic"], "likes": 9, "viewed": 196, "date": "1571567694", "time_retrieved": "2024-06-20T19:46:07.858325", "image_code": "/*\n\tSimple shader to test stereoscopic rendering\n\tMade for the 3rd issue of Cookie Fanzine that will be released soon\n\thttps://fanzine.cookie.paris/\n\t\n\tUse glasses with red on the left eye and cyan on the right eye\n*/\n\n// put to 2 or more to get antialiasing\n#define AA 1\n// put to 1 to get less artifacts but more noise\n#define DITHER 0\n\nfloat time = 16.06;\n// put to 0 to get a pretty fixed image\n#if 1\n\t#define time2 (iTime*0.2)\n\t#define factor 1.0\n#else\n\t#define time2 0.0\n\t#define factor 0.0\n#endif\n\n\nmat2 rot(float a) {\n    float ca=cos(a);\n    float sa=sin(a);\n    return mat2(ca,sa,-sa,ca);    \n}\n\nfloat box(vec3 p, float s) {\n    p=abs(p)-s;\n    return max(p.x, max(p.y,p.z));\n}\n\nfloat box(vec2 p, float s) {\n    p=abs(p)-s;\n    return max(p.x, p.y);\n}\n\n\nfloat map(vec3 p) {\n    \n    float t3=time*2.0;\n    t3=pow(smoothstep(0.0,1.0,fract(t3)),10.0)+floor(t3);\n    t3*=2.0;\n    t3 += sin(time2*0.5)+0.5*factor;\n    \n    vec3 bp=p;\n    \n    float m=10000.0;\n    for(int i=0;i<4; ++i) {\n        float t=0.7+float(i) + time*0.5;\n        p.xz*=rot(t + sin(p.y * 0.075 - t3)*0.2);\n        p.xy*=rot(t*0.7+sin(p.z*0.043 - t3)*0.3);\n        p=abs(p);\n        m=min(m, min(p.x,min(p.y,p.z)));\n        p-=0.7 + sin(p.yzx*0.8 - time2*2.0)*0.4;\n    }\n    \n    float d=m-0.0;\n    d=abs(d-0.2)-0.1;\n    \n    float f=abs(length(p)-5.0)-0.1;\n    f=min(f, abs(box(p.xz,0.5))-0.02);\n    f=min(f, abs(box(p.xy,0.5))-0.02);\n    f=min(f, abs(box(p.yz,0.5))-0.02);\n    f=min(f, abs(box(bp,4.0))-0.1);\n    d=max(d, f)-0.0;\n    \n \treturn d;   \n}\n\nfloat raymarch(vec3 s, vec3 r, float off) {\n    float val=0.0;\n    vec3 p=s;\n    for(int i=0; i<80; ++i) {\n     \tfloat d=abs(map(p))*off;\n        if(d<0.01) {\n            d=0.1;\n            break;\n        }\n        val+=0.01/(0.8+d);\n        p+=r*d;\n    }\n    return val;\n}\n\n#define ZERO (min(iFrame,0))\n\nfloat rnd(vec2 uv) {\n    return fract(dot(sin(uv*752.352+uv.yx*364.588), vec2(127.842)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sum=vec3(0);\n    \n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n\t\tvec2 uv = fragCoord-iResolution.xy*0.5 + o;\n#else    \n        vec2 uv = fragCoord-iResolution.xy*0.5;\n\n#endif\n        \n        float dither  =0.6;\n        #if DITHER\n            dither = 0.55+rnd(uv)*0.1;\n        #endif\n\n        //uv /= iResolution.y;\n        uv /= iResolution.x*0.56;\n\n        vec3 s=vec3(0,0,-25.0 + sin(time*0.8)*0.0);\n        vec3 t=vec3(0);\n\n        float t2=time*0.3;\n        s.xz *= rot(t2+sin(time2)*0.2+0.2*factor);\n        s.xy *= rot(-t2*1.2+sin(time2*0.7)*0.3);\n\n        vec3 cz=normalize(t-s);\n        vec3 cx=normalize(cross(cz, vec3(0,1,0)));\n        vec3 cy=normalize(cross(cz, cx));\n\n        float eyeoff=0.5; // distance between eyes\n\n        float fov = 1.0;\n        float dist = 20.0; // distance of focus\n        vec3 rbase = uv.x*cx+uv.y*cy+fov*cz;\n        vec3 r1=normalize(vec3(rbase + cx * eyeoff / dist));\n        vec3 r2=normalize(vec3(rbase - cx * eyeoff / dist));\n\n        vec3 col=vec3(0);\n        col.x=raymarch(s - eyeoff * cx, r1, dither);\n        col.y=raymarch(s + eyeoff * cx, r2, dither);\n        col.z=col.y;\n\n        //col *= pow(1.2-length(uv),1.0);\n\n        col = smoothstep(0.0,1.0,col);\n        col = pow(col, vec3(0.4545));\n\n        sum += col;\n#if AA>1\n    }\n    sum /= float(AA*AA);\n#endif\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(sum,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stSR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stSRB", "name": "Lava v1", "author": "Demuss", "description": "Having fun while learning shaders", "tags": ["lava"], "likes": 1, "viewed": 87, "date": "1572279553", "time_retrieved": "2024-06-20T19:46:07.858325", "image_code": "\nvec2 hash( vec2 x ) \n{\n    const vec2 k = vec2( 0.9183099, 0.2678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    float n =  mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    return 0.5 + 0.5*n;\n}\n\nfloat noise2(vec2 uv)\n{\n    float color;\n    color += smoothstep(.1,.5,noise(uv)); // Black splatter\n    color -= smoothstep(.1,.8,noise(uv)); // Holes on splatter\n    return color/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) + vec2(-iTime/200.,0);\n    \n    float time = iTime*5.;\n    vec2 uv1 = uv*8.;\n    float rand = noise(uv1+vec2(time));\n    rand += noise(uv1+vec2(-time));\n    rand += noise(uv1+vec2(time, -time));\n    rand += noise(uv1+vec2(-time, time));\n    rand += noise(uv1+vec2(time, 0.));\n    rand += noise(uv1+vec2(-time, 0.));\n    rand += noise(uv1+vec2(0., -time));\n    rand += noise(uv1+vec2(0., time));\n    \n    rand /= 16.;  \n    \n    float colR = smoothstep(clamp(0.25+rand,0.,1.), clamp(0.7, 0., 1.), noise(uv*32.)+noise2(uv*8.));\n    rand /= 4.;\n    float colG = smoothstep(clamp(0.5+rand,0.,1.), clamp(1., 0., 1.), noise(uv*32.)+noise2(uv*8.));\n    vec3 color = vec3(colR,colG,(colG+colR)/10.); \n    //vec3(noise2(uv*8.));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stSRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stSW7", "name": "(The Flash) vs (Sonic) vs (Goku)", "author": "rmmcal", "description": "Total: 164 seconds \n=> (The Flash) vs (Sonic) vs (Goku) vs (Wheel Star) - Animation Stick", "tags": ["2d", "animation"], "likes": 15, "viewed": 167, "date": "1572181805", "time_retrieved": "2024-06-20T19:46:08.937131", "image_code": "/////////////////////////////////////////////////////////////\n/////   ... (The Flash) vs (Sonic) vs (Goku) ...    ///////// \n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus                                       \n// (The Flash) vs (Sonic) vs (Goku)                              \n// Created by Rodrigo Cal (twitter: @rmmcal) - 2019/10\n// - https://www.shadertoy.com/view/3stSW7\n/////////////////////////////////////////////////////////////\n// -------------------------------------------------------\n//\n//  Speed run....\n//\n// Inspiration:\n// => https://en.wikipedia.org/wiki/Xiao_Xiao\n// => https://en.wikipedia.org/wiki/The_Flash_(2014_TV_series)\n// => https://en.wikipedia.org/wiki/Sonic_the_Hedgehog\n// => https://en.wikipedia.org/wiki/Goku\n// -------------------------------------------------------\n/////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159265359;\n\nmat2 rotate(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvec2 getPath(vec2 p)\n{\n    p.xy = rotate(cos(p.x+cos(p.x*0.4))*.0005)*p.xy;\n    p.xy = rotate((-cos((p.x+.8)*.3)*.0004))*p.xy;\n    p.xy = rotate((+cos((p.x+.5)*3.)*.00005))*p.xy;\n\treturn p;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mapArm(inout float d, vec2 pf, float ti ) {\n    float tt1 = abs(fract(pow(ti+.5,2.)*0.05)*2.-1.);\n    float t1 = (tt1*2.-1.);\n\n    float tt2 = abs(fract(pow(ti+.4,2.)*0.05)*2.-1.);\n    float t2 = (tt2*2.-1.);\n\n    vec2 pl = pf + vec2(.0,+.03 );\n    d = min(d, 1.-smoothstep(0.,.2, .2-sdLine(pl,vec2(-.0,-0.0),vec2(0.025*t1,-.05))));  // arm up  \n    d = min(d, 1.-smoothstep(0.,.2, .2-sdLine(pl,vec2(-.0,-0.0),vec2(-0.025*t2,-.05)))); // arm up\n\n    vec2 pl1 = pl + vec2(-.025*t1,+.05);\n    vec2 pl2 = pl + vec2( .025*t2,+.05);\n    d = min(d, 1.-smoothstep(0.,.2, .2-sdLine(pl1,vec2(-.0,-0.0),vec2(0.025,-.02)))); // arm down \n    d = min(d, 1.-smoothstep(0.,.2, .2-sdLine(pl2,vec2(-.0,-0.0),vec2(0.025,-.02)))); // arm down\n}\n\nvoid mapLeg(inout float d, vec2 pf, float ti ){\n    float tt1 = abs(fract(pow(ti*2.,2.)*0.05)*2.-1.);\n    float t1 = (tt1*2.-1.);\n\n    float tt2 = abs(fract(pow(ti*2.+.01,2.)*0.05)*2.-1.);\n    float t2 = (tt2*2.-1.);\n\n    vec2 pl = pf + vec2(.0,+.1 );\n    d = min(d, 1.-smoothstep(0.,.2, .2-sdLine(pl,vec2(-.0,-0.0),vec2(0.025*t1,-.05))));  // leg up  \n    d = min(d, 1.-smoothstep(0.,.2, .2-sdLine(pl,vec2(-.0,-0.0),vec2(-0.025*t2,-.05)))); // leg up\n\n    vec2 pl1 = pl + vec2(-.025*t1,+.05);\n    vec2 pl2 = pl + vec2( .025*t2,+.05);\n    d = min(d, 1.-smoothstep(0.,.2, .2-sdLine(pl1,vec2(-.0,-0.0),vec2(-0.025+t1*.03,-.06)))); // leg down \n    d = min(d, 1.-smoothstep(0.,.2, .2-sdLine(pl2,vec2(-.0,-0.0),vec2(-0.025-t2*.03,-.06)))); // leg down\n}\n\nvoid mapBody(inout float d, vec2 pf){\n    d = min(d, 1.-smoothstep(0.,.2, .2-sdLine(pf,vec2(0.),vec2(.0,-.1)))); // body\n}\n\nvoid mapHead(inout float d, vec2 pf, float ti){\n\td = min(d, 1.-smoothstep(0.,.2, .22-length(pf-vec2(0.,cos(pow(ti*1.+.01,2.))*.003)))); // head\n}\n\nvoid mapTheFlash(inout float d, vec2 pf, float ti){\n    mapHead(d, pf, ti); // head\n \tmapBody(d, pf);     // body\n   \tmapArm(d, pf, ti);  // arm\n    mapLeg(d, pf, ti);  // leg\n}\n\nvoid drawWind(inout vec3 c, vec2 ph, vec2 pb , float ti){\n    float ty = min( 0.01,  floor((pb.y+.05)*20.)/20.-.025) ;\n    float tx =  -ti*ti*0.001;\n    float d = min(1., 1.-smoothstep(0.,.2, .2-sdLine(pb+cos(vec2(0.,ti*ti*1.+pb.x*50.))*.01*pb.x,vec2(-0.01+ty,ty),vec2(tx+ty,ty)))); // wind\n    c = mix(c,vec3(0), clamp(ti*.01,0.,.5)*clamp(clamp(pb.x*.15, -0.2, 0.) + .2-smoothstep(0.,.03,d), 0., 1.));\n}\n\nvoid drawWheelStar(inout vec3 c, vec2 pb, float ti){\n        float timeStar = clamp(ti-3., 0., 1.);\n        vec2 pf = pb-vec2(0.+cos(ti*.3)*1.+.8,-0.25);\n        pf -= vec2(.5,0.1 +abs(cos(ti*2.))*.2);\n        float aStar = cos(atan(pf.x,pf.y)*5.-ti*ti)*.1;\n        c = mix(c,vec3(0), clamp(smoothstep(0.,.01, aStar*timeStar-length(pf)), 0., 1.) );\n        c = mix(c,vec3(0), clamp(smoothstep(0.,.01, .01-abs(.1-length(pf))), 0., 1.) );\n}\n\nvoid drawSonic(inout vec3 c, vec2 pb, float ti) {\n    float t1 = clamp(ti-37., 0., 1.); \n    float t2 = clamp(ti-63., 0., 1.); \n    float t3 = clamp(ti-62.5, 0., 1.); \n    float t1inv = 1.-t1; \n    float t2inv = 1.-t2; \n    vec2 pf = pb-vec2(t3/3.+cos(ti*.3)*1.-1.8-.3*(((((t1inv*t1inv*t1inv))))),-0.25 + 1.5*t1inv*cos(ti*1.3));\n    pf -= vec2(.5,0.1 +abs(cos(ti*2.))*.12);\n    float aStar = mod(atan(pf.x,pf.y)*5.-ti*ti,PI*1.)*.1;\n    float ts = sin(t3*t3*PI*10.);\n    c = mix(c,vec3(0),  clamp(smoothstep(0.,.01,  (1.-ts)*t2inv*t2inv*t1*.1- (.7+aStar)*length(pf)), 0., 1.) );\n    c = mix(c,vec3(1), ts);\n}\n\nvoid drawGoku(inout vec3 c, vec2 p, float ti) {\n    float t1 = clamp((ti-80.)/10., 0., 1.); \n    float t2= clamp((ti-90.)/1., 0., 1.); \n    vec2 pf = p;\n    vec2 pg = vec2(4.*t1-2.,.4);\n    float ft = mod(atan(pf.x,pf.y)*200.,1.)+.1;\n    float d = ( smoothstep(0.,.25, .015-sdLine(pf,vec2(-2.,0.4),pg)));\n    c = mix(c,vec3(0), (1.-t2)*clamp(smoothstep(0.,.01, d), 0., 1.) );\n    c = mix(c,vec3(0), (1.-t2)*clamp(smoothstep(0.,.01, ft*.03-length((pf-pg)*vec2(.5,1.))), 0., 1.) );\n}\n\nvoid drawBoom(inout vec3 c, vec2 ph,  vec2 pb,  vec2 pt, float ti) {\n    float t1 = clamp((ti-121.8)*5., 0., 1.);\n    float t2 = clamp((ti-121.98)*5., 0., 1.); \n\n    float tx1 = pow(abs((122.)-1.)*.2,2.)/1.; \n    c = mix(c,vec3(0), clamp(smoothstep(0.,.01, .1-length(ph-vec2(tx1,1.-t1))), 0., 1.) );\n    c = mix(c,vec3(0), clamp(smoothstep(0.,.01, t2-length(ph-vec2(tx1,1.-t1))), 0., 1.) );\n\n    float d = 1.;\n    d = min(d, 1.-smoothstep(0.,.2, .2-sdLine(ph,vec2(tx1,10.),vec2(tx1, 1.-t1))));\n    c = mix(c,vec3(0), (1.-pow(t1,8.))*clamp( 1.-smoothstep(0.,.15,d), 0., 1.));\n}\nvoid mapGrass(inout float d, vec2 ph, vec2 pt, float ti) {\n    vec2 rep = vec2(+floor(pt.x*.2)/.2+2.3,0.0);\n\tfloat tb = 0.;\n    vec2 pbuild = vec2(mod(ph.x/10., .01)*10.-0.05, ph.y);\n    d = min(d, 1.-smoothstep(0.,.1, .1-sdLine(pbuild,vec2(tb,0.),vec2(tb, abs(cos(ph.x*1.)+.5)*0.03)))); // bar grass\n}\n\nvoid mapStartBar(inout float d, vec2 ph, float ti) {\n\td = min(d, 1.-smoothstep(0.,.2, .22-sdLine(ph,vec2(0.,0.0),vec2(0.,.2)))); // bar start\n}\n\nvoid mapCloudsBar(inout float d,  vec2 ph, vec2 pt, float ti) {\n    d = min(d, 1.-smoothstep(0.,.2, .22-sdLine(ph,vec2(+floor(pt.x*.2)/.2+2.1,0.5),vec2(+floor(pt.x*.2)/.2+2.3,.5)))); // bar clouds\n}\n\nvoid drawTheFlash(inout vec3 c, vec2 pf, vec2 ph, vec2 pb, float ti) {\n    float d = 1.;\n    mapTheFlash(d, pf, ti);\n    c = mix(c,vec3(0), 1.-smoothstep(0.,.01,d));\n}\nvoid drawBgScene(inout vec3 c, vec2 ph, vec2 pt, float ti) {\n    float d = 1.;\n    d = min(d, ph.y); \t\t\t\t\t// floor\n \tmapStartBar( d,  ph, ti);\t\t\t// start bar\n    mapCloudsBar( d, ph, pt, ti);\t\t// \"cloud\"\n    mapGrass(d, ph, pt, ti);\t\t\t// grass\n    c = mix(c,vec3(0), 1.-smoothstep(0.,.01,d));\n}\nvoid drawFadeOutEnd(inout vec3 c, float tEnd, float tDuration, float ti){\n    c = mix(c,vec3(0), clamp((ti-161.)/2., 0., 1.)); // fade out\n}\n\nfloat getTime(float totalTime) {\n    return 1.*(fract((iTime+ 0.)/totalTime))*totalTime;\n}\n\nvoid setSlowMotion(inout vec2 p, inout float ti, float tStart, float tsDuration, float tEnd, float tsEnd){\n    float tspeed = clamp((ti-tStart)/tsDuration, 0., 1.);\n    float tspeed2 = 1.-clamp((ti-tEnd)/tsEnd, 0., 1.); // tsEnd... speed time to normal...\n    float tsp = abs(tspeed*2.-1.);\n    float speed = (max(.0,(pow( tsp *1.1, 3.)))*.5+.5);\n    ti = ti - tspeed2*tspeed*6.7 ; \n    float timeBounce = clamp(ti*.3, 0., 1.);\n    p*=.0+abs(cos(timeBounce*10.))*(1.-timeBounce)+sqrt(sqrt(sqrt(ti*2.)))*(tsp*.5+.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 a = vec2(iResolution.x/iResolution.y, 1.);\n\tvec2 p = (uv-.5)*a; \n  \n\tfloat ti = getTime(164.);  \n    vec2 ps = p;\n \tsetSlowMotion( ps,   ti,  121.8, 7.,  127.8, 5.); // slow motion [121.8 ... 127.8] sec. \n    \n    float tx = pow(abs((ti)-1.)*.2,2.)/1.;      \n    vec2 pc = getPath(vec2(tx+.5,0.5));    // center\n    vec2 ph = getPath(ps+vec2(tx,0.));     // path (inclination / mountain) \n    vec2 pt = vec2(tx+.15,0.2); \n    vec2 pb = ph-pt;\n    vec2 pf = pb * rotate(-.5 + .5/((ti*ti)*.01+1.)); // the flash speed inclination\n \n    vec3 c = vec3(1.);\n    drawBgScene( c, ph, pt, ti);      // backgound\n    drawTheFlash(c, pf, ph, pb,  ti); // the flash\n \tdrawWind(c, ph, pb, ti);          // wind / flash / sparkle\n    drawWheelStar(c, pb, ti);         // just a wheel... (wheel of the time) / (wheel of the life) / (wheel of the knowledge)   \n    drawSonic(c, pb, ti);             // sonic\n    drawGoku(c, p,  ti);              // fly goku\n    drawBoom(c, ph, pb, pt, ti);      // boom on slow motion\n    drawFadeOutEnd(c, 161., 2., ti);  // the end...\n  \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "4ts3DX", "previewfilepath": "https://soundcloud.com/lefathy/the-flash-theme-soundtrack", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lefathy/the-flash-theme-soundtrack", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stSW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stSWr", "name": "ShaderTober - Treasure", "author": "Flopine", "description": "A small doodle with inktober's theme \"Treasure\".\nI'm so tired, I don't have any creativity today... ><", "tags": ["raymarching", "glow", "morphing"], "likes": 3, "viewed": 106, "date": "1571781045", "time_retrieved": "2024-06-20T19:46:09.809798", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 100.\n#define PI 3.141592\n#define dt (iTime*0.3)\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\nfloat random (vec2 st)\n{return fract(sin(dot(st.xy, vec2(12.2544, 35.1571)))*2418.56);}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 *(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat od (vec3 p, float d)\n{return dot(p,normalize(sign(p)))-d;}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n        length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n        p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat g2 = 0.;\nfloat room (vec3 p)\n{\n    p.y -= 3.;\n    float d = -sdHexPrism(p.xzy, vec2(50.,20.));\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat column (vec3 p, float width)\n{\n    float c1 = length(p.xz)-width;\n\n    p.xz *= rot(p.y*0.2);\n    p.xz *= rot(iTime);\n    p.xz = moda(p.xz, PI);\n    p.x -= width;\n    float c2 = length(p.xz)-(width*0.5);\n\n    return min(c1, c2);\n}\n\nfloat columns (vec3 p)\n{\n    vec3 pp = p;\n    p.xz = moda(p.xz, PI/3.);\n    p.x -= 60.;\n    float d = column(p,5.);\n\n    return d;\n}\n\nfloat g1 = 0.;\nfloat gem (vec3 p)\n{\n    p.xz *= rot(iTime*5.);\n    float sp = 1.;\n    float steps = 3.;\n    float _od = od(vec3(p.x-sp,p.y,p.z),1.);\n    float _od1 = od(vec3(p.x+sp,p.y,p.z),1.);\n    float _od3 = od(vec3(p.x,p.y+sp,p.z),1.);\n    float _od2 = od(vec3(p.x,p.y-sp,p.z),1.);\n    float d = stmin(_od3,stmin(_od2,stmin(_od,_od1,0.5,steps),0.5,steps),0.5,steps);\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat pillars (vec3 p)\n{ \n    vec3 pp = p;\n    float c1 = mix(column(p,2.), gem(p), clamp(sin(iTime*0.5)*1.5+0.5,0.,1.));\n    float c = 1e10;\n    float aoffset = 0.;\n    float offset = 0.;\n    for (int i=0; i<2; i++)\n    {\n        p.xz *= rot(PI/(4.+aoffset));\n        p.xz =  moda(p.xz, 2.*PI/5.);\n        p.x -= 16.+offset;\n        c = min(c, column(p,1.5));\n\n        aoffset += 2.;\n        offset ++;\n    }\n    return min(c1,max(-column(pp,8.),c));\n}\n\nfloat SDF (vec3 p)\n{return stmin(room(p),min(columns(p),pillars(p)),3.,4.);}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.0*PI*(c*t+d));}\n\nvec3 get_cam (vec3 ro, vec3 target, vec2 uv, float fov)\n{\n    vec3 forward = normalize(target - ro);\n    vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n    vec3 up = normalize(cross (forward, left));\n    return normalize(forward*fov+ left*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float dither = random(uv); \n\n    vec3 ro = vec3(-21.*cos(-dt),1.,-21.*sin(-dt)),\n        p = ro,\n        tar = vec3(0.),\n        rd = get_cam(ro, tar, uv, 1.),\n        col = vec3(0.);\n\n    float shad = 0.;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.9+dither*0.1;\n        p += d*rd;\n    }\n\n    col = vec3(shad)*0.1;\n    vec3 g1_anim = mix(vec3(0.),\n                       palette(length(p), vec3(0.5), vec3(0.5),vec3(0.5), vec3(0.8,0.7,0.8)), \n                       clamp(sin(iTime*0.5),0.,1.)\n                      );\n    vec3 g2_anim = mix(vec3(0.),\n                       vec3(0.,length(uv)*0.5,0.7), \n                       clamp(sin(iTime*0.5),0.,1.)\n                      );\n    col += g1*g1_anim*0.3;\n    col += g2*g2_anim*0.1;\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stSzN", "name": "Shadertober 18 Misfit", "author": "GreenChicken", "description": "Misfit me", "tags": ["raymarching", "inktober"], "likes": 4, "viewed": 210, "date": "1571589238", "time_retrieved": "2024-06-20T19:46:10.573548", "image_code": "// SHADERTOBER 18 Misfit\n// Poulet vert 20-10-2019\n// thanks iq, leon, mercury\n\n#define PI 3.14159\n#define MAXSTEP 64\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, float s )\n{\n  vec3 q = abs(p) - vec3(s);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCross( vec3 p )\n{\n  float da = sdBox(p.xyz, vec3(3.,1.0,1.0));\n  float db = sdBox(p.yzx, vec3(1.0,3.,1.0));\n  float dc = sdBox(p.zxy, vec3(1.0,1.0,3.));\n  return min(da,min(db,dc));\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n// Scene setup\nvec2 map(vec3 pos)\n{\n    vec2 scene = vec2(0.0, 0.0);\n    \n    vec3 bp = pos + vec3(0.0);\n    bp = opRepLim(bp, 1.0, vec3(1.0));\n    float box = sdBox(bp, vec3(.3));\n    \n    vec3 hp = pos + vec3(0.0);\n    float heart = sdSphere(hp, 1.1+abs(sin(iTime*5.0)*.1));\n    \n    \n    // materials\n    scene = vec2(box, 0.0);\n    scene = opU2(scene, vec2(heart, 1.0));\n    \n    return scene;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(float(i)/128., ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(t.x+fract(iTime), vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(.1)*(length(uv)-.4);\n        \n    }\n    else\n    {\n        float depth = 1.0 - t.x;\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(depth)*.4;\n            col.r -= sin(rd.y*5.0+iTime)*.5;\n        }\n        else if(t.y == 1.0)\n        {\n            col = polyCol;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 cp = vec3(sin(iTime), 1.0, cos(iTime))*5.0;\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, uv);\n    \n    fragColor = vec4(sqrt(clamp(col, 0.0, 1.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stSzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stXW7", "name": "ray marching stuff", "author": "acnologia", "description": "i'm learning ray marching and this is something i saw on youtube", "tags": ["raymarching"], "likes": 4, "viewed": 44, "date": "1572160458", "time_retrieved": "2024-06-20T19:46:10.573548", "image_code": "#define MAX_MARCHING_STEPS 24\n\nfloat distScene(vec3 position){\n    position = fract(position)*2.-1.;\n    float sphere = length(position) - .15;\n    return sphere;\n}\nfloat trace(vec3 ro, vec3 rd){\n\tfloat depth = 0.;\n    for(int i = 0;i < MAX_MARCHING_STEPS;i++){\n    \tvec3 current = ro + depth * rd;\n        float t = distScene(current);\n        depth += t*.5;\n    }\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( iTime*.2, iTime*.2, iTime*0.1);\n    \n    float angle = iTime*.001;\n    ro.xz *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec3 rd = normalize(vec3(uv,1.));\n    float t = trace(ro, rd);\n    float fog = 1./(1.+t*t*.1);\n    fragColor = vec4((vec3(uv.x+1.5,uv.y-1.,1.)*fog),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stXW8", "name": "thinking about the universe", "author": "MapleSyrupCS6", "description": "thinking about the universe...", "tags": ["maplestudy"], "likes": 2, "viewed": 89, "date": "1571907980", "time_retrieved": "2024-06-20T19:46:10.573548", "image_code": "float rand(vec2 id)\n{\n    return fract(sin(dot(id, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat df1( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat df2( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat df3( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat map(vec3 p , float s){\n    \n    p.xy = mod(p.xy, 10.) - 1. * 5.;\n    return df3(p, s);\n}\n\nfloat dfm(vec3 p, float s){\n    \n    p.y -= 0.8;\n    vec3 q = rotate(p, radians(iTime * 5.0)*10., vec3(0.0, 1.0, 0.05));\n    //vec3 q2 = rotate(p, radians(5.0)*20., vec3(0.0, 1.0, 0.1));\n    float d3 = df3(q, 2.0);\n    float d4 = df2(q, vec2(3.5, 0.1));\n    float m2 = min(d3, d4);\n    p.y += 3.0;\n    float d1 = df1(p, vec3(2., 0., 2.), 0.3);\n    float d2 = df3(p, 2.0);\n    float m =  max(d1, d2);\n    return min(m, m2);\n    //return max(-d1, d2); // d1が重なっていないd2部分を描く\n    //return max(d1, -d2); // d2が重なっていないd1部分を描く\n    \n //   i.color = m < m2 ? kColor : cColor;\n}\n\nvec3 normal(vec3 p, float s){\n\n    vec2 e = vec2(0.0001, 0);\n    float d = dfm(p, s);\n    vec3 n = d - vec3(\n        dfm(p - e.xyy, s),\n        dfm(p - e. yxy, s),\n        dfm(p - e. yyx, s));\n    return normalize(n);\n}\n\nfloat image(vec2 uv){\n  \t//uv = fract(uv);\n    float d = distance(vec2(rand(uv), rand(uv))*5., uv);\n    d = step(2., d);\n    \n    \n    return d;\n}\n\nfloat image2(vec2 uv){\n  \t//uv = fract(uv);\n    float d = distance(vec2(rand(uv), rand(uv)), uv);\n    d = step(d, abs(0.9));\n    \n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 cameraPos = vec3(0, 0, -10);\n    float screenZ = 2.5;\n    vec3 rayDir = normalize(vec3(uv, screenZ));\n    vec3 lightDir = normalize(vec3(1.0, 1.0, -10.));\n    \n    float size = 1.0;\n    float depth = 0.0;\n    float dist = 0.0;\n    vec3 rayPos = vec3(0.0);\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 99; i++){\n        \n      \trayPos = cameraPos + (rayDir * depth);\n        dist = dfm(rayPos, size);\n        \n        if(dist < 0.0001) break;\n        \n        depth += dist;\n    }\n    \n    \n    if(dist < 0.0001){\n        \n      \tvec3 n = normal(rayPos, 1.0);\n        float diff = dot(n ,lightDir);\n        float im = image(uv);\n        vec3 c1 = vec3(0.5, 0.4, 0.9);\n        vec3 c2 = vec3(0.);\n        col = mix(c1, c2, diff); \n        col += image2(uv);\n        col /= image(uv);\n    }else{\n        float d = image(uv);\n        vec3 c1 = vec3(0.0, 0.2, 0.9);\n        c1 -= vec3(0.5);\n        vec3 c2 = vec3(0.9, 0.9, 0.2);\n        col = mix(c2, c1, d);  \n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stXW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stXzN", "name": "Shadertober 20 Tread", "author": "GreenChicken", "description": "it's repeated cubes, repeated cylinder substraction  in boolean and sin wave deformation for tunnel shape\n\nforget tu publish it in public", "tags": ["raymarching", "tunnel", "inktober"], "likes": 1, "viewed": 277, "date": "1571939164", "time_retrieved": "2024-06-20T19:46:11.597787", "image_code": "// SHADERTOBER 20 Tread\n// Poulet vert 20-10-2019\n// thanks iq, leon, and you because why not\n\n\n#define PI 3.14159\n#define MAXSTEP 64\n\nfloat ThirdRules(vec2 uv)\n{\n    float r = 0.; // final rule output\n    float rs = 0.005; // rule line size\n    float ds = 0.5; // dot size\n    \n    float hr = 0.0;\n    hr = step(fract(uv.x * 3.), rs);\n    hr *= 1. - step(uv.x, .1);\n    float d = step(fract(uv.y * 100.), ds);\n    hr = min(hr, d);\n    \n    float vr = 0.0;\n    d = step(fract(uv.x * 100.), ds);\n    vr = min(step(fract(uv.y * 3.), rs), d);\n    vr *= 1. - step(uv.y, .1);\n    \n    return max(hr, vr);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n// Scene setup\nvec2 map(vec3 pos)\n{\n    vec2 scene = vec2(0.0, 0.0);\n    \n    float time = iTime*4.0;\n    \n    pos.z += time;\n    pos.y += sin(pos.z)*.5;\n    \n    vec3 fwp = pos+vec3(0.0);\n    fwp = opRep(fwp, vec3(0.0, 0.0, 1.0));\n    float fw = sdBox(fwp, vec3(1.5));\n    \n    vec3 sfwp = pos+vec3(0.0);\n    sfwp.zy *= rot(PI/2.0);\n    sfwp.x += sin(pos.z*5.0)*.1;\n    sfwp = opRep(sfwp, vec3(0.0, 1.0, 0.0));\n    float sfw = sdCappedCylinder(sfwp, 1.0, 2.0);\n    \n    fw = max(fw, -sfw);\n    \n    // heart\n    vec3 hp = pos + vec3(0.0, 0.0, -time);\n    hp.xz *= rot(iTime*.9);\n    hp.yx *= rot(iTime*.74);\n    hp.x += sin(iTime)*.3;\n    hp.z += sin(iTime)*.4;\n    float heart = sdOctahedron(hp, .4+abs(sin(iTime*10.)*.1));\n    \n    \n    // materials\n    scene = vec2(fw, 0.0);\n    scene = opU2(scene, vec2(heart, 1.0));\n    \n    return scene;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(float(i)/128., ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(t.x+fract(iTime), vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(.1)*(length(uv)-.4);\n        \n    }\n    else\n    {\n        float depth = 1.0 - t.x;\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(depth)*.4;\n        }\n        else if(t.y == 1.0)\n        {\n            col = polyCol - depth*.5;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 cp = vec3(0.0, sin(iTime*2.0)*.25, -5.0);\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, uv);\n    \n    col.r -= uv.y*.5;\n    \n    col -= ThirdRules(screenUV)*.1;\n    \n    col -= clamp((length(uv))*.3, 0.0, 1.0);\n    \n    fragColor = vec4(sqrt(clamp(col, 0.0, 1.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sV3Dd", "name": "color flow 1", "author": "pik33", "description": "Another modification of https://www.shadertoy.com/view/ldX3Wn, this time symetric using abs", "tags": ["colors", "symetry"], "likes": 5, "viewed": 88, "date": "1571231711", "time_retrieved": "2024-06-20T19:46:11.597787", "image_code": "// modification of https://www.shadertoy.com/view/ldX3Wn\n\nconst float Pi = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=4.0*(abs(fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x,iResolution.y));\n\t\n\tfor(int i=1;i<45;i++)\n\t{\n\t\tvec2 newp=p;\n\t\tnewp.x+=(0.5/(1.5*float(i)))*cos(float(i)*p.y+iTime*11.0/37.0+0.03*float(i))+1.3;\t\t\n\t\tnewp.y+=(0.5/(1.5*float(i)))*cos(float(i)*p.x+iTime*17.0/41.0+0.03*float(i+10))+1.9;\n\t\tp=newp;\n\t}\n\n\tvec3 col=vec3(0.5*sin(3.0*p.x)+0.5,0.5*sin(3.0*p.y)+0.5,sin(1.3*p.x+1.7*p.y));\n\tfragColor=vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sV3Dd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sV3DW", "name": "ColourVision", "author": "lewdoo", "description": "playing with colour and metaballs", "tags": ["metaballs", "color"], "likes": 2, "viewed": 77, "date": "1570549944", "time_retrieved": "2024-06-20T19:46:11.792011", "image_code": "float rand(vec2 uv){\n\tfloat r = sin(fract(dot(uv, vec2(782.264234, 84.2384) + sin( uv.y * 942.))) * 111.4235);\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n\n    vec2 iPos = floor(uv);\n    \n    \n    for(float i =0.; i < 12.; i++){\n    \tvec2 pos = vec2(sin(sin(iTime * i * 0.2) + i + iTime * 0.5), rand(vec2(0.5 * i, i)) + sin(iTime + i) * 0.5) + vec2(0., 0.5);\n        float ball = 1.3 - distance(pos, uv);\n        \n        ball = smoothstep(1., .0, ball) * 0.05;\n        \n        //ball = floor(ball + 0.2);\n        col += vec3(ball * rand(vec2(i * 20., i * 2.)) * 20., \n                                ball * rand(vec2(sin(i) * 1281., i * 2.)), \n                                ball * rand(vec2((i + 0.5) * 100., i * 120.)) * 20.) * 3.;\n        \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sV3DW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sV3Rd", "name": "Interference Pattern With Color", "author": "Hotrhodium", "description": "Just some math", "tags": ["interferencepattern"], "likes": 2, "viewed": 116, "date": "1570769020", "time_retrieved": "2024-06-20T19:46:11.792011", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/vec2(iResolution.y);\n\tfloat freq = 30.0;\n    float Fade = 20.0;\n    float i = 0.07;\n    //float i = 0.0;\n    float AddBri = 1.0;\n    vec2 CirCen0 = vec2(0.9-(cos((iTime+5.0)*0.27)*0.9),0.5+(0.5*cos(iTime*.33)));\n    vec2 CirCen1 = vec2(0.9-(cos(iTime*0.59)*0.9),0.5+(0.5*cos((iTime+5.0)*.41)));\n    float MyDist0 = distance(CirCen0,uv);   \n    float MyDist1 = distance(CirCen1,uv);\n\n    float DarknessR = 0.0;\n    float DarknessY = 0.0;\n    float DarknessG = 0.0;\n    float DarknessB = 0.0;\n    float DarknessV = 0.0;\n    \n    DarknessR += cos(MyDist0*freq)/((MyDist0*MyDist0*Fade)+1.0);\n    MyDist0 += i;\n    DarknessY += cos(MyDist0*freq)/((MyDist0*MyDist0*Fade)+1.0);\n    MyDist0 += i;\n    DarknessG += cos(MyDist0*freq)/((MyDist0*MyDist0*Fade)+1.0);\n    MyDist0 += i;\n    DarknessB += cos(MyDist0*freq)/((MyDist0*MyDist0*Fade)+1.0);\n    MyDist0 += i;\n    DarknessV += cos(MyDist0*freq)/((MyDist0*MyDist0*Fade)+1.0);    \n    \n    DarknessR += cos(MyDist1*freq)/((MyDist1*MyDist1*Fade)+1.0);\n\tMyDist1 += i;\n    DarknessY += cos(MyDist1*freq)/((MyDist1*MyDist1*Fade)+1.0);\n    MyDist1 += i;\n    DarknessG += cos(MyDist1*freq)/((MyDist1*MyDist1*Fade)+1.0);\n    MyDist1 += i;\n    DarknessB += cos(MyDist1*freq)/((MyDist1*MyDist1*Fade)+1.0);\n    MyDist1 += i;\n    DarknessV += cos(MyDist1*freq)/((MyDist1*MyDist1*Fade)+1.0);    \n    \n    DarknessY *= 2.0;\n    DarknessB *= 2.0;\n    \n    DarknessR = DarknessR + DarknessY + DarknessV;\n    DarknessG = DarknessG + DarknessY;\n    DarknessB = DarknessB + DarknessV;\n    \n\tvec3 col = vec3(DarknessR,DarknessG,DarknessB);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sV3Rd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sV3Wm", "name": "curved progress bar with shade", "author": "bolloxim", "description": "Took the bevel edged code and generated a nice progress bar within it, includes drop shadows", "tags": ["progressbar", "ui", "curvedbox"], "likes": 2, "viewed": 321, "date": "1570327419", "time_retrieved": "2024-06-20T19:46:12.234276", "image_code": "// Andi Smithers \n// button shader for smooth border edges\n// includes shadow both internal and drop shadow\n// 9 patch is basically preserving the edge with rectangle and doesnt stretch the image\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = mod(iTime, 1.0);\n    vec4 barCol = vec4(1,1,0,1);\n    vec4 backCol = vec4(1,0,0,1);\n    // uniforms\n    float borderSize = 0.05;\n    float antiAliasSize = 0.03;\n    vec4 borderColor = vec4(1.0,1.0,0.95, 1);\n    vec4 centreColor = vec4(0.1,0.5,0.9,1);\n    float wobbly = iTime;\n\tfloat rounding = sin(wobbly)*3.0+4.0;\n    vec2 shadowVec = vec2(-0.01, 0.05);\n    float scaleBox = 1.2;\n\n    // alias thickness\n    float aascalar = 1.0 / antiAliasSize;\n    float outerAlias = 1.0 - antiAliasSize;\n    \n    // convert UV into normalized coord\n    vec2 iuv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // compute 9patch centre - xaxis\n    float centre = (iResolution.x - iResolution.y)/iResolution.x * 0.5 ;\n    if (abs(iuv.x-0.5)<centre) uv.x=0.5;\n    if(iuv.x>centre+0.5) uv.x-=0.5 + (iResolution.y/iResolution.x) * centre*2.0;\n\n    vec2 uvUnit = (uv*2.0-1.0) * scaleBox;\n    vec2 shadowUnit = uvUnit + shadowVec;\n    \n    // rounded edge - have to abs the value incase shader doesnt support negative powers\n    uvUnit = pow(abs(uvUnit), vec2(rounding));\n    shadowUnit = pow(abs(shadowUnit), vec2(rounding));\n    \n    // compute border\n    float borderEdge = pow(1.0-borderSize, rounding);\n    float borderAlias = borderEdge - antiAliasSize;\n    \n    // edge\n    float edge = length(uvUnit);\n    float outer = 1.0-(clamp(edge, outerAlias, 1.0)-outerAlias) * aascalar;\n    float inner = 1.0-(clamp(edge, borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowInner = 1.0-(clamp(length(shadowUnit), borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowOuter = 1.0-(clamp(length(shadowUnit), outerAlias, 1.0)-outerAlias) * aascalar;\n    \n    // blow out outer then chose minimum this ensures a mask around the alpha output\n    float outermask = min(outer*1000.0, 1.0);\n    \n    // fetch image and poor mans chromakey alpha\n    float blend = ((iuv.x - progress) <= 0.0 ? 1.0 : 0.0);\n    vec4 image = blend*barCol + backCol*(1.0-blend);\n    //image*= texture(iChannel0, iuv); if you want it textured\n    float alpha = length(image.rgb-vec3(0,1,0));\n    alpha = alpha> 0.5 ? 1.0 : 0.0;\n\n    // shadow\n    float shade = shadowInner<0.9 ? 0.8 + shadowInner*0.2: 1.0;\n    float shadeOut = shadowOuter>0.5 ? 0.0 + shadowOuter*0.2: 0.0;\t\n        \n    // blend inner/outer and image with image alpha\n    vec4 color = (centreColor*inner*(1.0-alpha)+image*alpha*inner)*shade + borderColor*(1.0-inner)*outermask;\n    color.a =  max(outer, shadeOut);\n    \n    // blend against a background texture - because shadertoy\n    vec4 background = texture(iChannel1, iuv);\n        \n    // and set the final color \n    fragColor = (color*color.a) + background*(1.0-color.a);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sV3Wm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sV3Wt", "name": "lighting study", "author": "ich", "description": "DONE: diffuse, reflection, refraction, fresnel\nTODO: internal reflection, beers law", "tags": ["lightingstudy"], "likes": 1, "viewed": 130, "date": "1571763923", "time_retrieved": "2024-06-20T19:46:13.393086", "image_code": "#define max_marches 100\n#define max_distance 100.\n#define surface_distance .001\n#define max_recursions 3\n#define light_pos vec3(cos(iTime * .125) * 3., 5, sin(iTime * -.241) * 2. - 1.)\n\nfloat sdf_sphere(vec3 p) {\n\treturn length(p);\n}\n\nfloat sdf_cube(vec3 p) {\n\tp = abs(p);\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat sdf_plane(vec3 p) {\n\treturn p.y;\n}\n\nfloat sdf_scene(vec3 p) {\n    float plane0 = sdf_plane(p - vec3(0, -.5, 0));\n\tfloat sphere0 = sdf_sphere(p - vec3(-1.5, .5, 0)) - 1.;\n    float sphere1 = sdf_sphere(p - vec3(-3.2, 2, -1)) - .5;\n    float cube0 = sdf_cube(p - vec3(1., 0, 0)) - .5;\n    float cube1 = sdf_cube(p - vec3(.8, 1, .3)) - .5;\n    float cube2 = sdf_cube(p - vec3(-1, .1, 3.)) - .6;\n    float cube3 = sdf_cube(p - vec3(-1, -.3, -2.)) - .2;\n    float cube4 = sdf_cube(p - vec3(-4, .5, -1)) - 1.;\n    float cube5 = sdf_cube(p - vec3(-3.5, -.3, -2.5)) - .2;\n    \n    return min(min(min(plane0, sphere0), sphere1), min(min(min(cube0, cube1), min(cube2, cube3)), min(cube4, cube5)));\n}\n\nstruct material_t {\n    vec3 diffuse;\n    float fresnelity;\n    float reflectivity;\n    float refractivity;\n    float refract_eta;\n    float density;\n};\n\nmaterial_t material(vec3 p) {\n    float plane0 = sdf_plane(p - vec3(0, -.5, 0));\n\tfloat sphere0 = sdf_sphere(p - vec3(-1.5, .5, 0)) - 1.;\n    float sphere1 = sdf_sphere(p - vec3(-3.2, 2, -1)) - .5;\n    float cube0 = sdf_cube(p - vec3(1., 0, 0)) - .5;\n    float cube1 = sdf_cube(p - vec3(.8, 1, .3)) - .5;\n    float cube2 = sdf_cube(p - vec3(-1, .1, 3.)) - .6;\n    float cube3 = sdf_cube(p - vec3(-1, -.3, -2.)) - .2;\n    float cube4 = sdf_cube(p - vec3(-4, .5, -1.)) - 1.;\n    float cube5 = sdf_cube(p - vec3(-3.5, -.3, -2.5)) - .2;\n    float d = min(min(min(plane0, sphere0), sphere1), min(min(min(cube0, cube1), min(cube2, cube3)), min(cube4, cube5)));\n   \tmaterial_t m;\n    \n    m.diffuse = vec3(1, 1, 1);\n    m.fresnelity = .2;\n    m.reflectivity = .3;\n    m.refractivity = .0;\n    m.refract_eta = .95;\n    m.density = 0.;\n    \n   \tif (sphere0 == d || cube3 == d || cube5 == d) {\n        m.diffuse = vec3(1, 1, 1);\n        m.fresnelity = .6;\n        m.reflectivity = .1;\n        m.refractivity = .8;\n    } else if (cube0 == d || cube1 == d || cube2 == d) {\n    \tm.diffuse = vec3(1, 0, 0);\n        m.fresnelity = .4;\n        m.reflectivity = .1;\n    } else if (cube4 == d || sphere1 == d) {\n    \tm.diffuse = vec3(1, 1, 1);\n        m.reflectivity = .8;\n        //m.refractivity = ;\n    }\n    \n    return m;\n}\n\nbool march(in vec3 ro, in vec3 rd, out vec3 p) {\n    p = ro;\n    float lO = 0.f;\n\n    for (int i = 0; i < max_marches; i++) {\n    \tfloat l = sdf_scene(p);\n        lO += l;\n        p += l * rd;\n        \n        if (l < surface_distance)\n            return true;\n        if (lO > max_distance)\n            return false;\n    }\n    \n\treturn false;\n}\n\nbool inner_march(in vec3 ro, in vec3 rd, out vec3 p) {\n    p = ro;\n    float lO = 0.f;\n\n    for (int i = 0; i < max_marches; i++) {\n    \tfloat l = -sdf_scene(p);\n        lO += l;\n        p += l * rd;\n        \n        if (l < surface_distance)\n            return true;\n        if (lO > max_distance)\n            return false;\n    }\n    \n\treturn false;\n}\n\n// internal_reflection with thickness\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(0, .001);\n    float l = sdf_scene(p);\n    \n    vec3 n = l - vec3(\n    \tsdf_scene(p - e.yxx),\n        sdf_scene(p - e.xyx),\n        sdf_scene(p - e.xxy)\n    );\n    \n    return normalize(n);\n}\n\nvec3 inner_normal(vec3 p) {\n\tvec2 e = vec2(0, .001);\n    float l = sdf_scene(p);\n    \n    vec3 n = l - vec3(\n    \tsdf_scene(p - e.yxx),\n        sdf_scene(p - e.xyx),\n        sdf_scene(p - e.xxy)\n    );\n    \n    return normalize(n);\n}\n\n    \nstruct ray_t {\n    vec3 ro;\n    vec3 rd;\n    float dist;\n    float lum;\n    int depth;\n};\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    vec2 uv = (frag_coord - iResolution.xy * .5) / iResolution.y;\n    vec2 m = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n    vec3 c = vec3(0.);\n    \n    vec3 ro = vec3(vec2(-1, 2) + m * 5., -5);\n    vec3 rd = normalize(vec3(uv - vec2(0, .2), 1));\n    \n    vec3 diff_r = .8 * vec3(1, 0, 0);\n    vec3 spec_r = .2 * vec3(0, 1, 0);\n\n    ray_t rays[int(pow(2., float(max_recursions)))]; // TOOD validate size\n    int rays_size = 0;\n    rays[0].ro = ro;\n    rays[0].rd = rd;\n    rays[0].dist = 1.;\n    rays[0].lum = 1.;\n    rays[0].depth = 0;\n    \n    while (rays_size > -1) {\n        vec3 ro = rays[rays_size].ro;\n        vec3 rd = rays[rays_size].rd;\n        float dist = rays[rays_size].dist;\n        float lum = rays[rays_size].lum;\n        int depth = rays[rays_size].depth;\n        --rays_size;\n        \n        vec3 p0;\n        if (march(ro, rd, p0)) {\n            material_t m0 = material(p0);\n        \tvec3 n0 = normal(p0);\n            \n            vec3 surface = n0 * surface_distance * 2.;\n            vec3 ro_outside = p0 + surface;\n            vec3 rd_light = normalize(light_pos - ro_outside);\n            float d0 = length(ro_outside - ro);\n            float dl = length(light_pos - ro_outside);\n            float da = dist + d0 + dl;\n            float attenuation = da * da * .001 + 1.;\n            float reflectivity = 1. - max(0., dot(rd, -n0)); // fresnel\n            reflectivity = min(1., min(1., pow(reflectivity, 8. - m0.fresnelity * 6.)) * m0.fresnelity + m0.reflectivity);\n            float refractivity = (1. - reflectivity) * m0.refractivity;\n            float diffusity = 1. - reflectivity - refractivity;\n            \n            vec3 p_light;\n            if (!march(ro_outside, rd_light, p_light) || dl < length(p_light - ro_outside) + .01) {\n            \tc += lum * diffusity * m0.diffuse * max(0., dot(n0, rd_light)) / attenuation;\n            }\n            \n            if (depth < max_recursions) {\n            \t++rays_size;\n                rays[rays_size].ro = ro_outside;\n                rays[rays_size].rd = reflect(rd, n0);\n                rays[rays_size].dist = dist + d0;\n                rays[rays_size].lum = lum * reflectivity;\n                rays[rays_size].depth = depth + 1;\n                \n                vec3 rd_refract = refract(rd, n0, m0.refract_eta);\n                vec3 ro_inside = p0 - surface;\n                \n                vec3 p_inside;\n                if (inner_march(ro_inside, rd_refract, p_inside)) {\n                    vec3 n_inside = normal(p_inside);\n                    vec3 surface_inside = n_inside * surface_distance * 2.;\n                    vec3 ro_refract_outside = p_inside + surface_inside;\n                    float di = length(p_inside - ro_inside);\n\n                    ++rays_size;\n                    rays[rays_size].ro = ro_refract_outside;\n                    rays[rays_size].rd = refract(rd_refract, -n_inside, 1. / m0.refract_eta);\n                    rays[rays_size].dist = dist + d0 + di;\n                    rays[rays_size].lum = lum * refractivity;\n                    rays[rays_size].depth = depth + 1;\n                }\n            }\n        }\n        \n        // follor ray -> color\n        // extra rays\n        // light, bears law, reflection, refraction, inner reflection\n    }\n    \n\n    frag_color = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sV3Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sVGWV", "name": "Jake's Better Raytracer", "author": "JakeLockey", "description": "Another simple ray tracer", "tags": ["raytracer"], "likes": 1, "viewed": 120, "date": "1570996738", "time_retrieved": "2024-06-20T19:46:14.476895", "image_code": "vec3 pixCol = vec3(0.5,0.5,0.5);\n\nstruct Light{\n    vec3 pos;\n};\nLight light = Light(vec3(-5.0,0.0,10.0));\n    \nstruct Camera{\n    vec3 pos;\n    vec3 dir;\n};\nCamera Cam = Camera(vec3(-1.0,7.0,6.0),vec3(0.0,-1.0,-0.9));\n\nstruct Sphere{\n    vec3 pos;\n    float r;\n    vec3 col;\n};\nSphere S1 = Sphere(vec3(0.0,0.0,0.0),1.0,vec3(1.0,1.0,1.0));\nSphere S2 = Sphere(vec3(0.0,0.0,1.5),0.7,vec3(1.0,1.0,1.0));\nSphere S3 = Sphere(vec3(0.0,0.0,2.5),0.5,vec3(1.0,1.0,1.0));\nSphere S4 = Sphere(vec3(-0.2,0.4,2.75),0.1,vec3(0.0,0.0,0.0));\nSphere S5 = Sphere(vec3(0.2,0.4,2.75),0.1,vec3(0.0,0.0,0.0));\n\nstruct Triangle{\n    vec3 Vert1;\n    vec3 Vert2;\n    vec3 Vert3;\n    vec3 col;\n};\nTriangle T1 = Triangle(vec3(5.0,5.0,-1.0), vec3(5.0,-5.0,-1.0), vec3(-5.0,5.0,1.0), vec3(0.7,0.7,0.7));\nTriangle T2 = Triangle(vec3(5.0,-5.0,-1.0), vec3(-5.0,-5.0,1.0), vec3(-5.0,5.0,1.0), vec3(0.8,0.8,0.8));\nTriangle T3 = Triangle(vec3(-5.0,5.0,1.0), vec3(5.0,-5.0,-1.0), vec3(5.0,5.0,-1.0), vec3(0.7,0.7,0.7));\nTriangle T4 = Triangle(vec3(-5.0,5.0,1.0), vec3(-5.0,-5.0,1.0), vec3(5.0,-5.0,-1.0), vec3(0.8,0.8,0.8));\n    \nstruct SceneObjects{\n    Sphere[5] spheres;\n    Triangle[4] triangles;\n};\nSceneObjects objects;\n\nvec3 checkCollide(vec3 Origin, vec3 rayDir){\n    float closestP = -1.0;\n    int objectNum = -1;\n    int SphereOrTriangle = -1;\n    for(int i = 0; i<objects.spheres.length(); i++){\n        Sphere tempS = objects.spheres[i];\n        \n        vec3 L = (tempS.pos-Origin);\n    \tfloat tca = dot(L,rayDir);\n    \n    \n    \tif(tca<=0.0){\n    \t   \tcontinue;\n    \t}\n    \n    \tfloat d = sqrt(dot(L,L)-(tca*tca));\n    \n    \tif(d>=tempS.r && d!=0.0){\n    \t    continue;\n    \t}\n    \n    \tfloat thc = sqrt((tempS.r*tempS.r)-(d*d));\n    \tfloat distToPoint= tca-thc;\n        \n        if(i==0||closestP==-1.0){\n            closestP = distToPoint;\n            SphereOrTriangle = 0;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphereOrTriangle = 0;\n        \tobjectNum = i;\n        }\n    \t\n    }\n    \n    for(int i = 0; i<objects.triangles.length(); i++){\n        Triangle tempT = objects.triangles[i];\n        \n        vec3 normal = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n        \n        //Test if ray is parallel to plane \n        if(dot(rayDir,normal)<0.001){\n            continue;\n        }\n        \n        vec3 p0l0 = tempT.Vert1 - Origin;\n        \n        //Dist to Intersection Point on plane\n        float distToPoint = dot(p0l0,normal) / dot(rayDir,normal);\n        if(distToPoint<0.0){\n            continue;\n        }\n        \n        vec3 P = Origin + rayDir*distToPoint; //Point of intersection\n        \n        //Check to see if ray is within the triangle\n        vec3 C;\n        //edge 1\n        vec3 edge1 = tempT.Vert2 - tempT.Vert1;\n\t\tvec3 vp1 = P - tempT.Vert1;\n        C = cross(edge1,vp1);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        //edge 2\n        vec3 edge2 = tempT.Vert3 - tempT.Vert2;\n\t\tvec3 vp2 = P - tempT.Vert2;\n        C = cross(edge2,vp2);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        //edge 3\n        vec3 edge3 = tempT.Vert1 - tempT.Vert3;\n\t\tvec3 vp3 = P - tempT.Vert3;\n        C = cross(edge3,vp3);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        \n        \n        \n        if(closestP==-1.0){\n            closestP = distToPoint;\n            SphereOrTriangle = 1;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphereOrTriangle = 1;\n        \tobjectNum = i;\n        }\n        \n    }\n    \n    return vec3(closestP,SphereOrTriangle,objectNum);\n    \n    \n}\n\nbool checkShadow(vec3 P){\n    vec3 ray = light.pos-P;\n    vec3 rayDir = ray/length(ray);\n    //P = P-(0.00001*rayDir);\n    \n    \n    float distToPoint = checkCollide(P,rayDir).x; //Checks collison to light\n    \n    //If the ray has collided, and it is closer than the light source\n    if(distToPoint!=-1.0 && length(ray)>distToPoint){ \n        return true;\n    }\n    return false;\n}\n\nvoid castRay(vec2 xy){\n    float ratio = Cam.dir.z/length(Cam.dir.xy);\n    vec3 VertPerp = vec3(-Cam.dir.x*ratio, -Cam.dir.y*ratio, length(Cam.dir.xy));\n    vec3 yComp = VertPerp * xy.y;\n    \n    vec3 HoriPerp = vec3(Cam.dir.y,-Cam.dir.x,0.0)/length(vec3(Cam.dir.y,-Cam.dir.x,0.0));\n    vec3 xComp = HoriPerp * xy.x;\n    \n    vec3 ray = (Cam.dir*3.0)+xComp+yComp;\n    vec3 rayDir = (ray/length(ray));\n    \n    vec3 Collision = checkCollide(Cam.pos,rayDir);\n    if(Collision.x>0.0){\n        if(int(Collision.y)==0){ //Sphere\n        \tpixCol = objects.spheres[int(Collision.z)].col;\n            vec3 P1 = Cam.pos + (rayDir*Collision.x);\n        \tif(checkShadow(P1)){ //Checks if in shadow\n            \tpixCol = objects.spheres[int(Collision.z)].col/3.0;\n        \t}\n        }\n        if(int(Collision.y)==1){ //Triangle\n            Triangle tempT = objects.triangles[int(Collision.z)];\n            pixCol = tempT.col;\n            vec3 P1 = Cam.pos + (rayDir*Collision.x);\n            vec3 normal = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n            P1 = P1 + normal*(-0.00001);\n        \tif(checkShadow(P1)){ //Checks if in shadow\n           \t\tpixCol = objects.triangles[int(Collision.z)].col/3.0;\n        \t}\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 LookAt = vec3(0.0,0.0,0.5);\n    Cam.dir = (LookAt-Cam.pos)/length(LookAt-Cam.pos);\n    \n    light.pos = vec3(75,0.0,75);\n    //light.pos = vec3(100.0*sin(iTime/5.0),0.0,100.0-abs(100.0*sin(iTime/5.0)));\n    //S2.pos = vec3(0.0,sin(iTime)+1.0,0.0);\n    \n    T1.Vert3.z = 10.0*sin(iTime)+5.0;\n    T2.Vert2.z = T1.Vert3.z;\n    T2.Vert3.z = T1.Vert3.z;\n    T4.Vert1.z = 10.0*sin(iTime)+5.0;\n    T4.Vert2.z = T4.Vert1.z;\n    T3.Vert1.z = T4.Vert1.z;\n    \n    Sphere[5] spheres = Sphere[](S1,S2,S3,S4,S5);\n\tTriangle[4] triangles = Triangle[](T1,T2,T3,T4);\n    \n    \n    objects = SceneObjects(spheres,triangles);\n    \n    \n    vec2 xy = vec2((2.0*(iResolution.x/iResolution.y)) * fragCoord.x/iResolution.x - (iResolution.x/iResolution.y), 2.0 * fragCoord.y/iResolution.y - 1.0);\n   \t\n    vec3 col = vec3(0.5,0.5,0.5);\n    \n    castRay(xy);\n    \n    col = pixCol;\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sVGWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sVGWz", "name": "waving bouncing balls", "author": "Jefferson", "description": "bouncing balls", "tags": ["demo"], "likes": 1, "viewed": 109, "date": "1570019368", "time_retrieved": "2024-06-20T19:46:14.476895", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.y;\n\tuv = uv * (iTime);\n    vec3 col = vec3(0);\n\tfloat t = iTime * 4.;;\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    float minradius = 0.05;\n    float maxradius = 0.5;\n    \n    col = vec3(maxradius - minradius);\n    col.x *= sin(t + id.x + id.y + 2.2);\n    col.y *= sin(t + id.x + id.y + 4.4);\n    col.z *= sin(t + id.x + id.y);\n    col += maxradius + minradius;\n    col /= 2.;\n    for(int i = 0; i < 3; ++i)\n    {\n    \tcol[i] = smoothstep(col[i], col[i]*.8, length(gv));\n    \tcol[i] *= (col[i] + 0.3 * maxradius)/maxradius/1.3;\n    }\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sVGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sVGzK", "name": "Beat01", "author": "legarcia", "description": "1", "tags": ["heart"], "likes": 1, "viewed": 61, "date": "1570560390", "time_retrieved": "2024-06-20T19:46:14.476895", "image_code": "\n\n\nfloat oneHz(){\n  \n   return(fract(iTime)*6.29);\n}\n\n\n\nvec4 tiler(vec2 i){\n    \n    \n    float modu = length(i);\n    \n    float z = cos(modu *oneHz())*.5 +.5;\n    \n\n    \n    vec3 o = vec3(z); \n        \n        \n    return vec4(o, 1.0);\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)*20./iResolution.y;\n\n    vec4 col = tiler(uv);\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sVGzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sy3Dt", "name": "Polar primes", "author": "badjano", "description": "Polar primes\ninspired by this: https://youtu.be/EK32jo7i5LQ", "tags": ["polar", "prime"], "likes": 4, "viewed": 124, "date": "1571158164", "time_retrieved": "2024-06-20T19:46:14.482980", "image_code": "#define pi 3.14159265359\nfloat truemod(float x,float y) { float v = mod(x,y); return (v==y)? 0. : v; }\n\n\n// isPrime:  Created by inigo quilez - iq/2013 https://www.shadertoy.com/view/4slGRH\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Info on prime hunting: http://www.iquilezles.org/blog/?p=1558\nfloat isPrime( float x )\n{\n\tif( x==1. ) return 0.;\n\tif( x==2. ) return 1.;\n\tif( x==3. ) return 1.;\n\tif( x==5. ) return 1.;\n\tif( x==7. ) return 1.;\n\t\n\tif( mod(x,2.)==0. ) return 0.;\n\tif( mod(x,3.)==0. ) return 0.;\n\tif( mod(x,5.)==0. ) return 0.;\n\n\tfloat y = 7.;\n\tbool flip =   true; // (mod(iTime*4.,1.)>.5);\n\tfloat xmax = (flip) ? sqrt(x)+1. : x;\n\t//int max =  (flip) ? 2000:200;\n\n\tfor( int i=0; i<200; i++ ) // count up to 6000\n\t{ \n\t    // if (i>max) {  return 1.; }\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 4.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 2.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 4.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 2.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 4.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 6.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 2.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 6.; if( y>=xmax ) return 1.;\n\t}\n\t\n\treturn 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    float t = iTime * .5;\n    \n    uv *= sin(t*.5)*.5+.5 + .1;\n    uv *= 3.;\n\n    float d = length(uv);\n    float angle = atan(uv.x,uv.y)*.5/pi +.5;\n    vec2 uv2 = vec2(angle,d-(angle-1.)*.01);\n    uv2 *= 100.;\n    float num = pow(uv2.x*.01+floor(uv2.y),2.);\n    float prime = isPrime(floor(num));\n    \n    fragColor = mix(vec4(prime),vec4(fract(uv2*.01)*fract(num), prime*fract(num),1.0),smoothstep(-1.,1.,sin(t*3.)));\n    //fragColor = vec4(prime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sy3Dt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sy3Dy", "name": "Equipotential charge lines", "author": "Zotho", "description": "Origin: https://www.shadertoy.com/view/XlfSRj\nThanks for: @stormoid (twitter)", "tags": ["2d", "vectorfield"], "likes": 12, "viewed": 162, "date": "1570820027", "time_retrieved": "2024-06-20T19:46:14.901315", "image_code": "//2D Vector field visualizer by nmz (twitter: @stormoid)\n//Added moving charges and equipotential lines (@allexev)\n#define u_time iTime\n#define pi 3.1415926535897932384626433832795\n\nconst float arrow_density = 1.7;\nconst float arrow_length = 0.5;\n\n//---------------Field to visualize defined here-----------------\nvec2 field(in vec2 p)\n{\n    return vec2(sin(p.x+sin(p.y)+u_time), sin(p.x+cos(p.y)));\n}\n\nvec3 fieldGrav(vec2 p) {\n    float time_coeff = 2.;\n    vec3 s = vec3(0.);\n    float r = 3.5+sin(u_time/10.*time_coeff);\n    float phi = -3.5+u_time/20.*time_coeff;\n    float mk = 1.4;\n    const int n_iter = 7;\n    for (int i = 0; i < n_iter; i++) {\n        float fi = float(i) / float(n_iter) * 2. * pi;\n        vec2 pos = vec2(r*cos(fi+phi+sin(u_time/10.*time_coeff)), r*sin(fi+phi));\n        float d = distance(pos, p);\n        float m = mk * sin(fi + pi / 10.);\n        vec2 a = m * (pos - p) / pow(d, 3.);\n        s += vec3(a, sign(m) * length(a));\n    }\n    return s;\n}\n//---------------------------------------------------------------\n\nfloat segm(in vec2 p, in vec2 a, in vec2 b) //from iq\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h)*30.;\n}\n\nfloat fieldviz(in vec2 p, vec2 t)\n{\n    vec2 ip = floor(p*arrow_density) / arrow_density + .5/arrow_density;   \n    float m = pow(length(t), .5) * (arrow_length/arrow_density);\n    vec2 b = normalize(t)*min(m, .3);\n    float rz = segm(p, ip, ip+b);\n    vec2 prp = (vec2(-b.y, b.x));\n    rz = min(rz,segm(p, ip+b, ip + b*.65 + prp*.3));\n    return clamp(min(rz,segm(p, ip+b, ip + b*.65 - prp*.3)), 0., 1.);\n}\n\nfloat equipotentialLines(float fld)\n{\n    float a = 0.;\n    const int n_lines = 29;\n    for (int i = 0; i < n_lines; i++) {\n        float f = float(i) - float(n_lines + 1) / 2.;\n        f *= 0.1;\n        float range = 111./(abs(f) + .4) - 11.;\n    \ta = max(a, 1. - clamp(abs(fld - f) * range, 0., 1.));\n    }\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = gl_FragCoord.xy / iResolution.xy - 0.5;\n\tp.x *= iResolution.x / iResolution.y;\n    p *= 10.;\n    vec3 fld = fieldGrav(p);\n    vec3 col = vec3(0.);\n    float fviz = fieldviz(p, fld.xy);\n    col = max(col, 1. - fviz*vec3(1.));\n    col = max(col , equipotentialLines(fld.z));\n    col.rb = max(col.rb, vec2(-fld.z, fld.z));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sy3Dy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sy3RV", "name": "cubes waves", "author": "Cewein", "description": "this is some wave of cube", "tags": ["procedural", "wave", "cube"], "likes": 3, "viewed": 157, "date": "1571227756", "time_retrieved": "2024-06-20T19:46:14.901315", "image_code": "float random (float v) {\n    return fract( sin( 12.9898 + v * 78.233 ) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5 * iResolution.xy)/iResolution.y;\n    vec2 coord = floor(uv * 7.);\n    float rand = random(coord.y);\n    vec3 col = vec3( rand + sin((coord.x + iTime*2.)/5.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sy3RV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syGRG", "name": "Anaglyphic cylinder", "author": "TheKing", "description": "This shader shows an anaglyphic cylinder using ray marching.", "tags": ["3d", "raymarching", "anaglyph"], "likes": 7, "viewed": 76, "date": "1570388099", "time_retrieved": "2024-06-20T19:46:14.901315", "image_code": "float cylinder(float r, float h, vec3 p) {\n    return max(length(p.xy)-r, abs(p.z)-h);\n}\n\nmat2 rot(float angle) {\n    return mat2(sin(angle), cos(angle), cos(angle), -sin(angle));\n}\n\nfloat sceneSDE(vec3 p) {\n    float h = p.y;\n    float angle1 = iTime;\n    float angle2 = iTime * 1.6;\n    p.yz *= rot(angle1);\n    p.xz *= rot(angle2);\n    return min(cylinder(1.,1.,p), h+2.);\n}\n\nvec3 rayMarch(vec3 origin, vec3 dir) {\n    vec3 p = origin;\n    while(true) {\n        float d = sceneSDE(p);\n        if (d < 0.01) { return p; }\n        if (length(p - origin) > 100.) { return p; }\n        p += dir * d;\n    }\n}\n\nfloat light(vec3 p, vec3 l) {\n    vec3 lvec = normalize(l-p);\n    if (length(rayMarch(p+0.1 * lvec, lvec)-p) < length(l-p)) { return 0.; }\n    vec2 helper = vec2(1e-5,0);\n    float d = sceneSDE(p);\n    vec3 norm = normalize(vec3(\n        sceneSDE(p + helper.xyy) - d,\n        sceneSDE(p + helper.yxy) - d,\n        sceneSDE(p + helper.yyx) - d\n        ));\n   return dot(norm, lvec);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 eye1 = vec3(-0.05,0,10);\n    vec3 eye2 = vec3(0.05,0,10);\n    vec3 l = vec3(3,10,5);\n    vec3 canvas = vec3(uv*3., 5);\n    \n    fragColor = vec4(0,0,0,1);\n\n    vec3 p = rayMarch(eye1, normalize(canvas-eye1));\n    if (length(eye1-p)>100.) { fragColor.x = 0.; }\n    else { fragColor.x = light(p, l); }\n    if (abs(p.y - -2.)<0.01) {fragColor.x *= sin(p.x+iTime)*0.4+0.5; }\n    \n    p = rayMarch(eye2, normalize(canvas-eye2));\n    if (length(eye2-p)>100.) { fragColor.y = 0.; }\n    else { fragColor.y = light(p, l); }\n    if (abs(p.y - -2.)<0.01) {fragColor.y *= sin(p.x+iTime)*0.4+0.5;}\n    fragColor.z = fragColor.y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syGRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syGRy", "name": "Fractal Box ", "author": "darkeclipz", "description": "A fractal box.", "tags": ["fractal", "box"], "likes": 4, "viewed": 154, "date": "1570401660", "time_retrieved": "2024-06-20T19:46:14.907417", "image_code": "// Raymarcher from https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n// Thanks iq!\n\n#define AA 1.\n#define R iResolution.xy\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 boxFold(vec3 z, vec3 r) {\n\treturn clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n// http://www.fractalforums.com/fragmentarium/fragmentarium-an-ide-for-exploring-3d-fractals-and-other-systems-on-the-gpu/15/\nvoid sphereFold(inout vec3 z, inout float dz) {\n    \n    float fixedRadius2 = 1.3;\n    float minRadius2 = 0.1;\n\tfloat r2 = dot(z,z);\n\tif (r2< minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t\tdz*=temp;\n\t} \n    else if (r2<fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t\tdz*=temp;\n\t}\n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 mengerFold(vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n    return z;\n}\n\nvec2 getOffset(float time) \n{\n    float frames = 5.;\n    time = mod(time, frames);\n\n    float it = floor(time),\n          ft = fract(time);\n    \n    vec2 p1 = vec2(-3.2, -2.4);\n    vec2 p2 = vec2(-3.4, -4.1); \n    vec2 p3 = vec2(-2.2, -3.3); \n    vec2 p4 = vec2(-3.8, -3.7); \n    vec2 pl = vec2(0.85, -2.3);\n \n    vec2 pos = p1;\n \n    if(it < 0.5)       pos = mix(pl, p1, smoothstep(0.0, 1.0, ft));\n    else if(it < 1.5)  pos = mix(p1, p2, smoothstep(0.0, 1.0, ft));\n    else if(it < 2.5)  pos = mix(p2, p3, smoothstep(0.0, 1.0, ft));\n    else if(it < 3.5)  pos = mix(p3, p4, smoothstep(0.0, 1.0, ft));\n    else if(it < 4.5)  pos = mix(p4, pl, smoothstep(0.0, 1.0, ft));\n\n    return pos;\n}\n\nvec2 DE(vec3 z, float time)\n{\n    float Iterations = 14.;\n    float Scale = 2.6;\n    vec2 of = getOffset(time);\n\n    vec3 offset = vec3(of.x, 0., of.y);\n\tfloat dr = 1.0;\n    float trap = 99.;\n\tfor (float n = 0.; n < Iterations; n++) {\n        \n        z = mengerFold(z);\n        z.xz = -z.zx;\n        z.yx = -z.xy;\n        z = boxFold(z, vec3(1));       \n        sphereFold(z, dr);\n        z=z*Scale + offset;\n        \n        dr = dr*abs(Scale)+1.0;\n        trap = min(trap, length(abs(z)));\n\t}\n\tfloat r = length(z);\n\treturn vec2(r/abs(dr), trap);\n}\n\nvec2 map( in vec3 pos, float time ) \n{\n    vec2 d1 = DE(pos, time);\n    return d1;\n}\n\nvec3 calcNormal( in vec3 pos, float t ) \n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize( vec3(map(pos+e.xyy,t).x-map(pos-e.xyy,t).x,\n                           map(pos+e.yxy,t).x-map(pos-e.yxy,t).x,\n                           map(pos+e.yyx,t).x-map(pos-e.yyx,t).x ) );\n}\n\nfloat castShadow( in vec3 ro, vec3 rd, float time )\n{\n    float res = 1.0;\n    float t = 0.00;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos, time ).x;\n        res = min( res, 16.0*h/t );\n        if ( res<0.01 ) break;\n        t += h;\n        if( t > 10.0 ) break;\n    }\n\n    return clamp(res,0.0,1.0);\n} \n\nvec2 castRay( in vec3 ro, vec3 rd, float time )\n{\n    float m = -1.0;\n    float t = 0.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        vec2 h = map( pos, time );\n        m = h.y;\n        if( h.x<0.00095 )\n            break;\n        t += h.x;\n        if( t>20.0 )\n            break;\n    } \n    if( t>20.0 ) m=-1.0;\n    return vec2(t,m);\n}\n\nvec3 camPos(float time) \n{\n    float frames = 5.;\n    time = mod(time, frames);\n\n    float it = floor(time),\n          ft = fract(time);\n    \n    vec3 p1 = vec3(-0.25, 0, 0.05);\n    vec3 p2 = vec3(0.2, 0, 0.2); \n    vec3 p3 = vec3(-.4, -0.3, 0.15); \n    vec3 p4 = vec3(-.1, 0.2, 0.25); \n    vec3 pl = vec3(-0.42, -0.05, 0.17);\n \n    vec3 pos = pl;\n\n    if(it < 0.5)       pos = mix(pl, p1, smoothstep(0.0, 1.0, ft));\n    else if(it < 1.5)  pos = mix(p1, p2, smoothstep(0.0, 1.0, ft));\n    else if(it < 2.5)  pos = mix(p2, p3, smoothstep(0.0, 1.0, ft));\n    else if(it < 3.5)  pos = mix(p3, p4, smoothstep(0.0, 1.0, ft));\n    else if(it < 4.5)  pos = mix(p4, pl, smoothstep(0.0, 1.0, ft));\n\n    return pos * 2.0;\n} \n\nmat3 camRotation(float time)\n{\n    float frames = 2.;\n    float it = floor(time),\n          ft = fract(time);\n \n    float angleY = 3.*cos(time);\n    float angleZ = sin(time);\n\n    mat3 ry = rotateY(angleY);\n    mat3 rz = rotateZ(angleZ);\n    return ry * rz;  \n}\n \nvoid mainImage( out vec4 O, in vec2 U )\n{\n\n    float time = iTime;\n    time /= 22.;\n\n    vec3 col = vec3(0);\n    vec3 res = vec3(0);\n    \n    for(float aax=0.; aax < AA; aax++)\n    for(float aay=0.; aay < AA; aay++)\n    {\n        vec2 p = (2.*((U + vec2(aax, aay) + vec2(0.5)) / AA)-R)/R.y;\n        \n        mat3 rot = camRotation(time);\n        vec3 ta = vec3(0,0,3) * rot;\n        vec3 ro = camPos(time);\n        \n        vec3 ww = normalize( ta-ro );\n        vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n        vec3 vv = normalize( cross(uu,ww) );\n\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n \n        vec3 col = vec3(0.0);\n\n        vec2 tm = castRay(ro, rd, time); \n\n        if( tm.x < 20. )\n        {\n            float t = tm.x;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, time);\n\n            vec3 mate = vec3(0.18); \n            mate = cos(vec3(0,1,1.5) + tm.y*1.2 - time*11.) *.5 + .5;\n\n            vec3 sun_dir = normalize( vec3(-1, -1, 0) );\n            float sun_dif = clamp( dot(nor,sun_dir),0.0,1.0); \n            float sun_sha = 0.75*castShadow( pos+nor*0.001, sun_dir, time );\n            float bou_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n\n            col  = mate*vec3(5.0,4.5,4.0)*sun_dif*sun_sha;\n            col += mate*vec3(0.5,0.6,0.6)*bou_dif;\n        }\n\n        res += clamp(col, 0.0, 1.0);\n    }\n\n    col = pow( res/(AA*AA), vec3(0.4545) );\n    \n    O = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syGRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syGWc", "name": "Flight Over Dunes", "author": "Delvar", "description": "Just a pretty flight over some sand dunes, Flight Over Dunes", "tags": ["3d", "terrain", "raymarch", "sun", "clouds", "fog", "mountains", "flare", "lensflare", "dust", "sand", "flightoverdunes"], "likes": 16, "viewed": 339, "date": "1571760774", "time_retrieved": "2024-06-20T19:46:19.138052", "image_code": "// =================================================================\n//  'Flight Over Dunes'\n//  https://www.shadertoy.com/view/3syGWc\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\tCredits: \n//\tThe bulk of the ray tracer and lighting was inspired by watching a video by Inigo Quilez https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\tand his related shadertoy iq: 'Happy Jumping' : https://www.shadertoy.com/view/3lsSzf\n//\n//\tParts of the lensFlare were copied or inspired from\n//\t\tmu6k : 'musk's lens flare' : https://www.shadertoy.com/view/4sX3Rs\n//\t\tnimitz : 'Cloud Ten' : https://www.shadertoy.com/view/XtS3DD\n//\n//\tClouds were copied and modified from\n//\t\tDave_Hoskins : 'Frozen wasteland' : https://www.shadertoy.com/view/Xls3D2\n//\n//\tMost of the other Math came from wikipedia https://www.wikipedia.org/\n// =================================================================\n\n#define RAY_MAX_STEPS 150\n#define RAY_MAX_DISTANCE 200.0\n#define OBJECT_MIN_SURFACE_DISTANCE 0.01\n#define RAY_MAX_STEPS_SHADOW RAY_MAX_STEPS\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW 0.04\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW_OFFSET (OBJECT_MIN_SURFACE_DISTANCE_SHADOW*1.1)\n\n#define PI\t3.1415926535897932384626433832795\n\n//Flags for debugging\n#define DEBUG_RAY_DITHER\n#define DEBUG_GRAIN_VIGNETTE\n#define DEBUG_DYNAMIC_EXPOSURE\n//#define DEBUG_OCCLUSION\n#define DEBUG_SAND_RIPPLES\n#define DEBUG_SAND_SHADING\n#define DEBUG_SAND_3POINT_NORMAL\n#define DEBUG_CAMERA_FLY\n#define DEBUG_SPECULAR\n#define DEBUG_SUN_RAYS_RENDER\n#define DEBUG_FOG_RENDER\n#define DEBUG_DUST_RENDER\n#define DEBUG_SAND_RENDER\n#define DEBUG_CLOUD_RENDER\n#define DEBUG_MOUNTAIN_RENDER\n\n// Flags to use texture lookups instead of noise functions, should be faster but introduces repetiton.\n//#define NOISE_TEXTURE_3D iChannel1\n//#define NOISE_TEXTURE_2D iChannel0\n\n// -- The Materials\n#define MAT_SKY 0\n#define MAT_GROUND 1\n#define MAT_SPHERE_1 2\n#define MAT_SPHERE_2 3\n\n// -- The Lights\n#define LIGHT_SUN 0\n#define LIGHT_SKY 1\n//#define LIGHT_GROUND 2\n\n// -- colours\n#define SAND_COLOUR vec3(0.98,0.82,0.68)\n\n// ========== Structs ==========\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance from screen\n};\n\nstruct ray {\n\tvec3 origin, direction;\n};\n\nstruct rayMarchHit {\n    vec3 origin, surfaceNormal;\n    float distance, dust;\n    int materialId;\n    int iteration;\n};\n\nstruct sphere {\n    vec3 origin;\n    float radius;\n};\n\nstruct light {\n    vec3 origin, colour;\n    float brightness;\n    float maxDistance;\n};\n\n// ========== ==========\n\n// ========== Globals ==========\n\nvec3 sunDir = normalize(vec3(5.0, 4.0, 5.0));\n\n// ========== ==========\n\n// ========== Rotation ==========\n\nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\n\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    //return rotateX(pitch) * rotateY(yaw) * rotateZ(roll);\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\n//Converts a unit vector into polar coordinates , vec2(Yaw, Pitch).\nvec2 toPolar(vec3 point) {\n    return vec2(atan(point.x,point.z),asin(point.y));\n}\n\n// ========== ==========\n\n// ========== Ray Constructor ==========\n\nray getRay(vec2 uv, camera camera) {\n    ray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\n// ========== ==========\n\n// ========== Hash Functions ==========\n\n#define HE 702.566665305\n#define HF 149.311292882\n#define HG 446.230257362\n#define HH 833.597411735\n\nfloat hash11(float st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(vec3(HF,HG,HH)*st)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(vec2(HF,HG)*st)&255,0).x;\n    # else\n    return fract(sin(st)*HE); \n    #endif\n}\n\nfloat hash21(vec2 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE,(st.x*st.y)*HE) &31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st*HE)&255,0).x;\n    # else\n    return fract(sin(dot(sin(st.xy),vec2(HE,HF)))*HG);\n    #endif\n}\n\nfloat hash31(vec3 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st.x*HE+st.z*HF,st.y*HG+st.z*HH)&255,0).x;\n    # else\n    return fract(sin(dot(sin(st),vec3(HE,HF,HG)))*HH);\n    #endif\n}\n\n\n//FIXME: find alternativs with texture lookup\nvec3 hash13(float st) {\n    return fract(sin(st*vec3(HE,HF,HG))*HH);\n}\n\nvec3 hash23(vec2 st) {\n    return fract(sin(st.xyx*vec3(HE,HF,HG))*HH);\n}\n\nvec3 hash33(vec3 st) {\n    return fract(sin(st*vec3(HE,HF,HG))*HH);\n}\n\n// ========== ==========\n\n// ========== Coherent Noise ==========\n\n//Quintic interpolation curve\nvec2 quinticInterpolation(vec2 x) {\n    return x*x*x*(x*(x*6.-15.)+10.);\n}\n\nfloat quinticInterpolation(float x) {\n    return x*x*x*(x*(x*6.-15.)+10.);\n}\n\n// - Value Noise, 2d, Unsigned\nfloat valueNoise2du(vec2 samplePoint) {\n    vec2 pointI = floor(samplePoint);\n    vec2 pointF = fract(samplePoint);\n    float bl = hash21(pointI + vec2(0.0,0.0) );\n    float br = hash21(pointI + vec2(1.0,0.0) );\n    float fl = hash21(pointI + vec2(0.0,1.0) );\n    float fr = hash21(pointI + vec2(1.0,1.0) );\n    //vec2 u = smoothstep(0.0,1.0,pointF);\n    vec2 u = quinticInterpolation(pointF);\n    float b = mix(bl,br,u.x);\n    float f = mix(fl,fr,u.x);\n\n    return mix(b,f,u.y);\n}\n\n// - Value Noise, 1d, Unsigned\nfloat valueNoise1du(float samplePoint) {\n    float pointI = floor(samplePoint);\n    float pointF = fract(samplePoint);\n    float b = hash11(pointI);\n    float f = hash11(pointI + 1.0 );\n    float u = quinticInterpolation(pointF);\n    return mix(b,f,pointF);\n}\n\n// - Value Noise, 1d, Unsigned, Wraped\nfloat valueNoise1duw(float samplePoint, float wrap) {\n    float pointI = floor(samplePoint);\n    float pointF = fract(samplePoint);\n    float b = hash11(mod(pointI, wrap));\n    float f = hash11(mod(pointI + 1.0 ,wrap));\n    float u = quinticInterpolation(pointF);\n    return mix(b,f,pointF);\n}\n\n// ========== ==========\n\n// ========== Distance Feilds ==========\n\nvec3 ClosestRayPoint(ray ray, vec3 point) {\n    return ray.origin + max(0.0,dot(point - ray.origin, ray.direction)) * ray.direction;\n}\n\nfloat DistanceRayPoint(ray ray, vec3 point) {\n    return (distance(point,ClosestRayPoint(ray, point) )) ;   \n}\n\nfloat DistancePointSphere(sphere sphere, vec3 point) {\n    float sphereDistance = distance(point, sphere.origin) - sphere.radius;\n    return sphereDistance; \n}\n\n// ========== ==========\n\n// ========== Clouds ==========\n\nfloat getCloudNoise(vec2 origin, float time) {\n    origin.x-= time*0.1;\n    origin.y-= time*0.5;\n\n    float r = valueNoise2du(origin*0.3);\n    r+= valueNoise2du(origin*1.3)*0.66;\n    r+= valueNoise2du(origin*2.3)*0.33;\n    r*= valueNoise2du(origin*0.2);\n    r*=0.5;\n    return clamp(r,0.0,1.0);\n}\n\nfloat getClouds(vec3 direction, float time) {\n    //Dont draw clouds very low on the horizon or ground.\n    if (direction.y<=0.04) {\n        return 0.0;\n    }\n\n    vec2 s = direction.xz;\n    s *= (1000.0)/direction.y;\n    s *= 0.001;\n    //slowly fade out the clouds at distance, to get rid of aliasing issues.\n    return getCloudNoise(s,time)*(clamp(0.0,0.1,(direction.y-0.04))*10.0);\n}\n\n// ========== ==========\n\n// ========== Terrain ==========\n\nfloat getTerrainHeight(vec2 point) {\n    const int octaves = 3;\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float amplitude = 1.5;\n    float frequency = 0.2;\n\n    float height = 0.0;\n\n    for (int i = 0; i < octaves; i++) {\n        height += amplitude * (sin(frequency*point.x*0.5)*cos(frequency*point.y+point.x)*0.5+0.5);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    //Add surface ripples in the dips, moved to shading to reduce overhead, adds errors at small scale but its not notisable\n    //height += ((sin(30.0*point.x)*sin(1.5*point.y+10.0*point.x)*0.5+0.5)*0.05)*(smoothstep(0.3,2.0,1.7-height));\n    return height;\n}\n\nvec3 getTerrainNormal(vec2 point, float hc) {\n\n    #if defined(DEBUG_SAND_3POINT_NORMAL)\n    float hl = getTerrainHeight(point + vec2(-0.01,0.0));\n    float hf = getTerrainHeight(point + vec2(0.0,-0.01));\n    return normalize(vec3(\n        hl - hc,\n        0.01,\n        hf - hc\n    ));\n    #else\n    float hl = getTerrainHeight(point + vec2(-0.01,0.0));\n    float hr = getTerrainHeight(point + vec2(0.01,0.00));\n    float hf = getTerrainHeight(point + vec2(0.0,-0.01));\n    float hb = getTerrainHeight(point + vec2(0.0,0.01));\n    return normalize(vec3(\n        hl - hr,\n        0.02,\n        hf - hb\n    ));\n    #endif    \n\n}\n\nvoid getTerrainHit(vec3 currentPoint, inout rayMarchHit hit, float minSurfaceDistance) {\n    float heightCenter = getTerrainHeight(currentPoint.xz);\n\n    float newDistance = (currentPoint.y - heightCenter);\n\n    if (newDistance < hit.distance) {\n        hit.distance = newDistance;        \n        //if (newDistance <= minSurfaceDistance) {\n        hit.origin = currentPoint;\n        hit.surfaceNormal = getTerrainNormal(currentPoint.xz, heightCenter);\n        hit.materialId = MAT_GROUND;\n        //}\n    }\n}\n\n// ========== ==========\n\n// ========== Ray Marcher ==========\n\nrayMarchHit GetRayMarchHit(vec3 currentPoint, float minSurfaceDistance, float time) {\n    rayMarchHit hit;\n    hit.distance = RAY_MAX_DISTANCE;\n    #if defined(DEBUG_SAND_RENDER)\n    getTerrainHit(currentPoint, hit, minSurfaceDistance);\n    #endif\n    return hit;\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\nrayMarchHit RayMarch(ray ray, float maxDistance, float minSurfaceDistance, int maxSteps, float time)\n{\n    float currentDistance = 0.0;\n    rayMarchHit hit;\n    float accumulatedDust = 0.0;\n    float lastDistance = 0.0;\n    float maxDustDistance = maxDistance/2.0;\n    float dustMaxHeight = 4.0;\n\n    for(int i=0; i<maxSteps; i++) {\n\n        vec3 currentPoint = ray.origin + ray.direction*currentDistance;\n        hit = GetRayMarchHit(currentPoint, minSurfaceDistance, time);\n\n        #if defined (DEBUG_DUST_RENDER)\n        float tHeight = getTerrainHeight(currentPoint.xz);\n        float dHeight = tHeight+dustMaxHeight;\n\n        if (currentDistance <= maxDustDistance && currentPoint.y < dustMaxHeight) {\n            float remapedY =  map(currentPoint.y, tHeight, dHeight, 0.0, 2.0*PI);\n            //we add the remapped y value ot the time for the lookup so the sand closer to the ground runs slower, not sure its that notisable.\n            float dust = lastDistance * (getCloudNoise(currentPoint.xz*3.0, time*(20.0-(remapedY*0.002))));\n            //we remap the ray height into the 0.0 to 2PI range, then pass it though sin to get a nice smooth falloff\n            dust *= sin(remapedY)*0.5+0.5;\t\t\t\n            dust *= 1.0-currentDistance/maxDustDistance;\n            accumulatedDust+= dust;\n        }\n        #endif\n\n        //had to add this to remove some of the dust artifacts., we jsut check if the ray is going into the dust and limit the distance\n        if (hit.distance > 1.0)\n        {\n            #if defined (DEBUG_DUST_RENDER)\n            if (currentPoint.y + (ray.direction.y * hit.distance) <= dHeight)\n            {\n                #endif\n                hit.distance = min(hit.distance,max((hit.distance*(currentDistance/maxDustDistance)),1.0));\n                #if defined (DEBUG_DUST_RENDER)\n            }\n            #endif\n        }\n        hit.iteration = i;\n        \n        #if defined (DEBUG_RAY_DITHER)\n\t        if(hit.distance > 0.0) {\n    \t        hit.distance *= mix(0.9,1.0, hash31(fract(currentPoint+time)));\n        \t}\n        #endif\n        \n        lastDistance = hit.distance;\n        currentDistance += hit.distance;\n\n        if(currentDistance >= maxDistance || (currentPoint.y > 5.0 && ray.direction.y > 0.0) || (currentPoint.y < 0.0 && ray.direction.y < 0.0)) {\n            hit.surfaceNormal = ray.direction;\n            hit.materialId=MAT_SKY;\n            break;\n        } \n        //terminate if we are very close or bounce back out if we end up within an object. \n        else if(hit.distance >= 0.0 && hit.distance <= minSurfaceDistance) {\n            break;\n        }\n    }\n    hit.distance = currentDistance;\n\t//This should match the calculation in the getLight function to ensure they line up.\n    hit.dust = clamp(0.2 * accumulatedDust * ((cos(time*0.5) + cos(time*0.3))*0.25+0.5),0.0,1.0);\n    return hit;\n}\n\n// ========== ==========\n\n// ========== Lighting ==========\n\nfloat getShadow(vec3 origin, vec3 destination, float soft, float time) {\n    float currentDistance = OBJECT_MIN_SURFACE_DISTANCE_SHADOW;\n    float maxDistance = distance(destination, origin);\n    vec3 direction = normalize(destination-origin);\n    rayMarchHit rayMarchHit;\n    float light = 1.0;\n\n    for(int i=0; i<RAY_MAX_STEPS_SHADOW; i++) {\n        vec3 currentPoint = origin + direction*currentDistance;\n        rayMarchHit = GetRayMarchHit(currentPoint, 99999.0, time);\n        //Soft Shadows!\n        light = min(light,soft * rayMarchHit.distance/currentDistance);\n        currentDistance += rayMarchHit.distance;\n        if(currentDistance > maxDistance) {\n            break;\n        } else if(rayMarchHit.distance < OBJECT_MIN_SURFACE_DISTANCE_SHADOW) {\n            light = 0.0;\n            break;\n        }\n    }\n\n    return light;\n}\n\nfloat getOcclusion( in vec3 origin, in vec3 normal, float time)\n{\n    float occlusion = 0.0;\n    float scale = 0.7;\n    rayMarchHit hit;\n\n    for( int i=0; i<6; i++ )\n    {\n        float distance = OBJECT_MIN_SURFACE_DISTANCE_SHADOW + 0.025*float(i);\n        vec3  currentPoint = origin + distance*normal;\n        hit = GetRayMarchHit(currentPoint, OBJECT_MIN_SURFACE_DISTANCE_SHADOW, time);\n        occlusion += (distance-hit.distance)*scale;\n        scale *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occlusion, 0.0, 1.0 );\n}\n\nvoid getLight(vec3 point, vec3 normal, vec3 rayDirection, out vec3 diffuseLight, out vec3 specularLight, float time) {\n\n    //FIXME: could bake the light brightness into the colour\n    //FIXME: get material shinynes for power\n\n    diffuseLight = vec3(0.0);\n    specularLight = vec3(0.0);\n\n    vec3 direction;\n    vec3 colour;\n    float brightness;\n    float shadow;\n    vec3 specDirection;\n    float dotProduct;\n    float maxDustDistance = RAY_MAX_DISTANCE/6.0;\n\n    #if defined (DEBUG_DUST_RENDER)\n    float dust = (getCloudNoise(point.xz*3.0, time*20.0))*0.25;\n    //This should match the calculation in the RayMarch function to ensure they line up.\n    dust = 1.0-clamp(1.2*dust * ((cos(time*0.5) + cos(time*0.3))*0.25+0.5),0.0,1.0);\n    #endif\n\n    #if defined(LIGHT_SUN)\n    colour=vec3(0.8,0.6,0.4);\n    direction = sunDir;\n    brightness = clamp(dot(direction,normal),0.0,1.0);\n    shadow = getShadow(point +  normal*OBJECT_MIN_SURFACE_DISTANCE_SHADOW_OFFSET, point+direction*RAY_MAX_DISTANCE*0.5, 10.0, time);\n    #if defined (DEBUG_CLOUD_RENDER)\n    float cloudCover = (1.0-getCloudNoise(point.xz*0.2, time));\n    brightness *= cloudCover;\n    #endif\n    #if defined (DEBUG_DUST_RENDER)\n    brightness *= dust;\n    #endif\n    brightness *= shadow;\n\n    #if defined(DEBUG_SPECULAR)\n    \n    float spec = hash21(floor(point.xz*100.0)/100.0);\n    \n    if(spec > 0.98) {\n        spec = (spec-0.98) * 50.0;\n        specDirection = reflect(direction, normal);\n        dotProduct = dot(specDirection, rayDirection);\n        specularLight += colour * 5.0 * spec * pow(max(dotProduct,0.0), 5.0) * shadow;\n    }\n        #endif\n        diffuseLight += colour * 5.0 * brightness;\n    #endif\n\n    #if defined(LIGHT_SKY)\n    colour=vec3(0.4, 0.85, 1.0);\n    direction = normalize(vec3(0.0, 1.0, 0.0));\n    brightness = clamp(dot(direction,normal),0.0,1.0);\n    #if defined (DEBUG_DUST_RENDER)\n    \tbrightness *= dust;\n    #endif\n    \n        #if defined(DEBUG_SPECULAR)\n        spec = hash21(floor(point.xz*150.0)/150.0);\n\n        if(spec > 0.99) {\n            spec = (spec-0.99) * 100.0;\n            specDirection = normalize(reflect(direction, normal));\n            dotProduct = dot(specDirection, rayDirection);\n            specularLight += colour * 2.0 * pow(max(dotProduct,0.0), 5.0);\n        }\n        #endif\n    \n    diffuseLight += colour * 2.0 * brightness;\n    #endif\n\n    //#if defined(LIGHT_GROUND)\n    //colour=SAND_COLOUR;\n    //direction = normalize(vec3(0.0, -1.0, 0.0));\n    //brightness = clamp(dot(direction,normal),0.0,1.0);\n    //#if defined(DEBUG_SPECULAR)\n    //specDirection = normalize(reflect(direction, normal));\n    //dotProduct = dot(specDirection, rayDirection);\n    //specularLight += pow(max(dotProduct,0.0), 2.0) * colour;\n    //#endif\n    //diffuseLight += colour * 1.0 * brightness;\n    //#endif\n}\n\n// ========== ==========\n\n// ========== Camera Motion ==========\n\nvec3 getCameraPath(float time) {\n    //Force a loop in time .. large values of time cuase judder\n    //FIXME: need to figure out a way to make the loop smooth, remove the glitch jump.\n    //time=mod(time,300.0);\n\n    vec3 r;\n    //r.y = 6.0;\n    //r.x=sin(time/10.0)*40.0;\n    //r.z=cos(time/10.0)*40.0;\n    r.y = (sin(time/2.0)*0.5+0.5) + (sin(time/6.0)+1.0) + (sin(time/15.0)+1.0) + 3.0;\n    r.x = ( sin(time/10.0) * 40.0 ) + sin(time/6.0) * 5.0 + sin(time/2.0) * 3.0;\n   r.z = ( cos(time/10.0) * 40.0 ) + sin(time/5.0) * 9.0 + sin(time/3.0) * 2.0;\n    return r;\n\n}\n\ncamera getCamera(vec3 origin, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n    camera.origin = origin;\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw);\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec3 origin, vec3 forward, float roll, float zoom) {\n    float yaw = atan(forward.x,forward.z);\n    float pitch = asin(forward.y);\n    return getCamera(origin, roll, pitch, yaw, zoom);\n}\n\ncamera getCamera(vec2 mouse, float time) {\n    #if defined(DEBUG_CAMERA_FLY)\n    vec3 cameraPos1 = getCameraPath(time);\n    if (iMouse.z<0.5) {\n\t\tvec3 cameraPos2 = getCameraPath(time+0.5);\n        vec3 cameraPos3 = getCameraPath(time-0.5);\n\n        vec3 cameraForward = normalize(cameraPos2 - cameraPos1);\n        \n        vec3 cameraForward2 = normalize(cameraPos1 - cameraPos3);\n\n        //Take atan and nivt to -1 to +1 range\n        float yaw1 = atan(cameraForward.x,cameraForward.z)/PI;\n        float yaw2 = atan(cameraForward2.x,cameraForward2.z)/PI;\n\n        // get the differance and renormalize using fract.\n        float roll = -(fract((yaw1-yaw2)*0.5+0.5)*2.0-1.0)*5.0;\n        roll = clamp(roll,-0.5,0.5);\n        return getCamera(cameraPos1, cameraForward, roll,  0.5);\n    } else  {\n        return getCamera(cameraPos1, 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    }\n    #else\n    return getCamera(vec3(0.0,5.0,0.0), 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);    \n    #endif\n}\n\n// ========== ==========\n\n// ========== Screen Space Effects ==========\n\nvec3 getLensFlare(vec2 uv, vec2 sunUv)\n{\n    // Render the 'godray'?\n    vec2 delta = uv-sunUv;\n    float distance = clamp(dot(delta,delta),0.0,1.0);\n    float angle = atan(delta.x,delta.y);\n    float ray =sin(valueNoise1du(sin(angle*3.0+sunUv.x*2.0)*7.0-cos(angle*5.0+sunUv.y*2.0)))*0.2;\n    ray*=1.0-distance;\n    ray+=pow(1.0-distance,10.0);\n\n    //Render the 'circles'\n\n    //further away from the center the bigger they gets\n    vec2 uvSpread =  uv * length(uv) ;\n    //Offset the RGB to fake Chromatic Aberration\n    vec3 circles = vec3(0.0);\n    if (sunUv.x > -1.5 && sunUv.y > -1.0 && sunUv.x < 1.5 && sunUv.y < 1.0) {\n        for (float i=0.0;i<5.0;i++) {\n            vec2 circlePosition = sunUv * (0.5 - 0.4*i);\n            float size = 40.0/(i+1.0);\n            float blur = 2.0*(5.0-i);\n            circles += vec3(\tmax(\t0.0,\t1.0-pow(length(\t\t\tcirclePosition-delta)*size,blur)),\n                            max(\t0.0,\t1.0-pow(length(1.05*\tcirclePosition-delta)*size,blur)),\n                            max(\t0.0,\t1.0-pow(length(1.1*\t\tcirclePosition-delta)*size,blur)));    \n        }\n    }\n    // Odd edge glows ...\n    circles += vec3(\n        max(0.0, 5.0/(1.0+25.0*pow(length(uvSpread-0.7*-sunUv),1.5))),\n        max(0.0, 5.0/(1.0+30.0*pow(length(uvSpread-0.8*-sunUv),1.4))),\n        max(0.0, 5.0/(1.0+35.0*pow(length(uvSpread-0.9*-sunUv),1.3)))\n    );\n\n    circles += vec3(\n        max(0.0, 1.0-(1.0*pow(length(uvSpread-0.7*-sunUv)*5.5,2.5))),\n        max(0.0, 1.0-(2.0*pow(length(uvSpread-0.8*-sunUv)*5.5,2.4))),\n        max(0.0, 1.0-(2.0*pow(length(uvSpread-0.9*-sunUv)*5.5,2.3)))\n    );\n\n    return circles*0.1*length(uv-sunUv) + ray;\n}\n\n// ========== ==========\n\n// ========== Entry Point ==========\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = iTime;\n    //vec3 debugOverlay = vec3(0.0);\n\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n    \n    //Snap to center on startup.\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    camera camera = getCamera(mouse, time);\n\n    // --\n    ray ray = getRay(uv, camera);\n    rayMarchHit hit = RayMarch(ray, RAY_MAX_DISTANCE, OBJECT_MIN_SURFACE_DISTANCE, RAY_MAX_STEPS, time);\n\n    //float yaw3 = atan(ray.direction.x,ray.direction.z)/PI;\n    //debugOverlay = vec3(abs(fract( (yaw3-yaw1)*0.5+0.5)*2.0-1.0));\n\n    vec3 colour;\n\n    // ---- Render Sky Box\n\n    //Get the distance from the sun so we can tint the sky, This is also used for the fog colour later.\n    float distanceFromSun = 1.0-(dot(sunDir,ray.direction)*0.5+0.5);\n\n    vec3 skyColour;    \n\n    if(ray.direction.y < 0.0) {\n        // Floor (not the sand!)\n        skyColour = mix(SAND_COLOUR*0.75,SAND_COLOUR*0.5,distanceFromSun);\n    } else {\n        // Sky\n        skyColour = mix(vec3(0.4, 0.85, 1.0),vec3(0.1, 0.2, 0.25),distanceFromSun) - max(ray.direction.y,0.0)*0.3;\n    }\n\n    skyColour *= 5.0; //Make it very bright!\n\n    // ---- Render Mountains\n    #if defined(DEBUG_MOUNTAIN_RENDER)\n    if (ray.direction.y > 0.0 && ray.direction.y < 0.1875) {\n        float rayYaw = atan(ray.direction.x,ray.direction.z)/PI*0.5+0.5;\n        float mountainDepth = 0.0;\n        float maxMountainHeight = 1.0;\n        vec3 mountainColour;\n        for (float i=0.0;i<6.0;i++) {\n            float \tmountainHeight =\tvalueNoise1duw( i*1234.543 + rayYaw*(30.0),\t\t30.0) * 2.0;\n            mountainHeight+= \t\t\tvalueNoise1duw( i*7832.856 + rayYaw*(60.0),\t\t60.0) * 1.0;\n            mountainHeight+= \t\t\tvalueNoise1duw( i*5892.473 + rayYaw*(120.0),\t120.0) * 0.5;\n            mountainHeight+= \t\t\tvalueNoise1duw( i*2857.673 + rayYaw*(180.0),\t180.0) * 0.25;\n            mountainHeight*= 0.07-i*0.01;\n\n            if(ray.direction.y < mountainHeight) {\n                mountainDepth=(i+1.0)/7.0;\n                //FIXME: should move this out somwhere or remap the mountain height to 0.0 to 1.0\n                //add a fade from the top to the bottom of this mountain\n                float maxHeight = (2.0+1.0+0.5+0.25)*(0.07-i*0.01);\n                float ratio = mountainHeight/maxHeight;\n                mountainDepth*= 1.0-pow(1.0-ratio,3.6);\n                mountainColour = mix(vec3(1.0),SAND_COLOUR*2.0,(i+1.0)/5.0);\n            }\n        }\n\n        float pointHeight = map(ray.direction.y,0.0,0.1875,0.0,1.0);\n        skyColour = mix(skyColour, mountainColour, mountainDepth);\n    }\n    #endif\n    //Haze\n    skyColour = mix(skyColour,mix(SAND_COLOUR*1.5,SAND_COLOUR,distanceFromSun)*3.0,pow(1.0-abs(ray.direction.y),20.0));\n\n    // ---- Render Clouds and Sun\n    if(hit.materialId == MAT_SKY) {\n        vec3 samplePoint = ray.direction;\n        float clouds = 0.0;\n        #if defined(DEBUG_CLOUD_RENDER)\n        clouds = getClouds(ray.direction, time);\n        #endif\n        vec3 suncolour = vec3(0.8,0.6,0.6);\n        float sunBright = 1.0-distanceFromSun;\n\n        sunBright = pow(smoothstep(0.99,1.0,sunBright),20.0) * 10.0; //blow it right out\n\n        skyColour += suncolour * sunBright;\n\n        skyColour = mix(skyColour, vec3(3.0), clouds );        \n\n        colour = skyColour;\n\n        // ---- Render Ground/Sand\n    } else if(hit.materialId == MAT_GROUND) {\n\n        //base sand colour\n        vec3 sandColour = SAND_COLOUR;//vec3(0.98,0.82,0.68);\n\n        #if defined(DEBUG_SAND_RIPPLES)\n        //Add riples by distorting the normal\n        float offset = ((sin(35.0*hit.origin.x)*sin(2.0*hit.origin.y+5.0*hit.origin.x)*2.0-1.0)*0.4)*(smoothstep(0.3,2.0,1.7-hit.origin.y));\n        hit.surfaceNormal.xy = normalize(hit.surfaceNormal.xy - offset);\n        #endif\n\n        #if defined(DEBUG_SAND_SHADING)\n        //give the sand some interesting variations\n        sandColour = mix(sandColour,vec3(1.0),smoothstep(0.0,1.0,dot(vec3(-1.0,0.0,0.0),hit.surfaceNormal)));\n        sandColour = mix(sandColour, vec3(0.8,0.6,0.6),smoothstep(0.0,2.0,(sin((hit.origin.x+hit.origin.z)*0.2)*cos((hit.origin.z+hit.origin.y)*0.2)*cos(hit.origin.y*0.1)*0.5+0.5)));\n        sandColour = mix(sandColour,vec3(0.6,0.4,0.3),smoothstep(0.0,1.0,1.5-hit.origin.y));\n        #endif\n        colour = sandColour;\n\n        // ---- Render Other Objects\n    } else if(hit.materialId == MAT_SPHERE_1) {\n        colour = vec3(1.0,0.1,0.1);\n    } else if(hit.materialId == MAT_SPHERE_2) {\n        colour = vec3(hit.surfaceNormal)*0.5+0.5;\n    } else {\n        colour = vec3(1.0,0.0,1.0);//vec3(1.0-hit.distance/RAY_MAX_DISTANCE);    \n    }\n\n    // ---- Render Lighting, Occlusion and Fog for everything but the skybox\n    if(hit.materialId != MAT_SKY) {\n        // Apply diffuse and specular Light\n        vec3 diffuseLight, specularLight;\n        getLight(hit.origin, hit.surfaceNormal, ray.direction, diffuseLight, specularLight, time);\n\n        colour = colour * diffuseLight + specularLight;\n\n        #if defined(DEBUG_OCCLUSION)\n        //Simple fake Occlusion\n        float occlusion = getOcclusion(hit.origin, hit.surfaceNormal, time);\n        colour *= occlusion;\n        #endif\n\n        #if defined(DEBUG_DUST_RENDER)\n        colour = mix(colour,SAND_COLOUR*2.0,hit.dust);\n        #endif\n\n        #if defined(DEBUG_FOG_RENDER)\n        //Fog - fade to sky colour in the distance\n        colour = mix(colour,skyColour,pow((hit.distance/RAY_MAX_DISTANCE),3.0));\n        #endif\n    }\n\n    // ---- Lense Flare\n    #if defined(DEBUG_SUN_RAYS_RENDER)\n    float sunDot = dot(camera.forward, sunDir);\n    if (sunDot > 0.0) {\n        //Project the sun to the screen to get its UV position\n        mat3 invMat = rotateY(-camera.yaw) * rotateX(-camera.pitch) * rotateZ(-camera.roll);\n        vec3 sunProjection = (sunDir*invMat);\n        vec2 sunUv = sunProjection.xy/sunProjection.z*camera.zoom;\n        colour += getLensFlare(uv, sunUv)*5.0;//*pow(clamp(dot(camera.forward, sunDir),0.0,1.0),1.5);\n    }\n    #endif\n\n    // ---- Colour correction and Vignette\n    float exposure = 0.35;\n\n    #if defined(DEBUG_DYNAMIC_EXPOSURE)\n    exposure *= smoothstep(-0.7,1.0,( 1.0-pow(clamp(dot(camera.forward, sunDir),0.0,1.0),4.0)));\n    #endif\n\n    // Gamma\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n\n    //Clamp\n    colour = clamp(colour,0.0,1.0); \n\n    #if defined(DEBUG_GRAIN_VIGNETTE) \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv; \n    float vignette = clamp(pow( uv.x*uv.y*5.0,0.5)+0.4,0.0,1.0);\n    // Grain\n    //vignette *= (1.0-hash31( (vec3(ray.direction)+(5.0+mod(vec3(time),vec3(10.0,137.0,75.3))  )) * 50.00 ) * 0.1);\n    //Burn it in\n    colour=vec3(1.0)-((vec3(1.0)-colour)/vignette);\n    #endif\n\n    //Clamp\n    colour = clamp(colour,0.0,1.0); \n    // colour grading\n    //colour = colour*vec3(1.0,0.8,1.0);\n    // compress        \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n\n    fragColour = vec4(colour,1.0);\n    //ragColour = vec4(mix(colour,debugOverlay,0.5),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4sfGRr", "previewfilepath": "/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syGWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syGWW", "name": "Chaolotus", "author": "singularity23", "description": "toying around with my 1st shader toy. I love Moiré :)\n", "tags": ["n00b"], "likes": 5, "viewed": 237, "date": "1572333835", "time_retrieved": "2024-06-20T19:46:19.138052", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = uv - vec2 (0.5,0.5);\n    vec2 a = uv + mod(0.5,0.5);     \n    vec3 col = vec3 ( 0.5, .7, 1. );\n    float r = 0.02 + 0.9 * sin(atan(q.y,q.x)* iTime * 5.0 ); \n    float d = 0.2 * 6.0 * fract(atan(a.y,a.x) * iTime * a.x * 2.0 );\n    col *= mix (r, r*0.0001, length( q / d*3.23) ); \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syGWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tsXR8", "name": "tuto-4", "author": "Clemm_ence", "description": "tuto4", "tags": ["tuto4"], "likes": 1, "viewed": 104, "date": "1570823963", "time_retrieved": "2024-06-20T19:46:19.956056", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define sat(x) clamp(x,0.,1.) \n//make sure that x is between 0 and 1\n\nfloat remap01(float a, float b, float t){\n\treturn sat((t-a) / (b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n\treturn sat(((t-a) / (b-a)) * (d-c) +c);\n}\n\nvec2 within(vec2 uv, vec4 rect){//Same as remap 01\n\treturn (uv - rect.xy) / (rect.zw-rect.xy);\n}\n\n\nvec4 Brow(vec2 uv){\n\tfloat y = uv.y;\n    uv.y +=uv.x *.8-.3; // play with the place & form\n    uv.x -= .1;\n    \n    uv -=.5;\n    \n    vec4 col = vec4(0.);\n    \n    float blur = .1;\n    \n    float d1 = length(uv); \n    float s1 = S(.45, .45-blur, d1);//first circle\n    float d2 = length(uv-vec2(.1, -.2)*.7); \n    float s2 = S(.5, .5-blur, d2); //2nd circle\n    \n\tfloat browMask = sat(s1-s2); //substract first circle to second & don't go negative\n    \n     float colMask = remap01(.7, .8, y)*.75;\n     colMask *= S(.6, .9, browMask);\n    \n    vec4 browCol = mix(vec4(.4,.2 ,.2, 1.),vec4(1., .75, .5, 1.), colMask);\n    \n    uv.y += .15;\n    blur +=.1;\n    \n    d1 = length(uv);\n    s1 = S(.45, .45-blur, d1);\n    d2 = length(uv-vec2(.1, -.2)*.7);\n    s2 = S(.5, .5-blur, d2);\n    float shadowMask = sat(s1-s2);\n    \n    \n    col = mix(col, vec4(0.,0.,0.,1.), S(.0, 1., shadowMask)*.5);\n    \n    col = mix(col, browCol, S(.2, .4, browMask));\n    \n    return col;\n}\n\nvec4 Eye(vec2 uv, float side, vec2 m, float smile) {\n    uv -=.5;\n    uv.x *= side;\n    \n    float d= length(uv);\n    vec4 irisCol = vec4(.3,.5,1.,1.);\n    vec4 col = mix(vec4(1.), irisCol, S(.1,.7,d)* .5);\n    col.a = S(.5,.48,d);\n    \n    col.rgb *= 1. - S(.45, .5 , d) *.5 * sat(-uv.y - uv.x*side);\n    d = length(uv-m*.5);\n    irisCol.rgb *= 1. + S(.3,.05,d);\n    \n    col.rgb = mix(col.rgb, vec3(0.), S(.3,.28,d)); // iris outline\n    \n    d = length(uv-m*.6); \n    col.rgb = mix(col.rgb, irisCol.rgb, S(.28,.25,d));\n    \n    float pupilSize = mix(.2,.16, smile);\n    col.rgb = mix(col.rgb, vec3(0.), S(pupilSize,pupilSize*.85,d)); //pupile\n    \n    float highlight = S(.1, .09, length(uv-vec2(-.15,.15)));\n    highlight += S(.07, .05, length(uv+vec2(-.08,.08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    \n    return col;\n}\n\nvec4 Mouth(vec2 uv) {\n    uv -= .5;\n\tvec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5;\n    uv.y -= uv.x * uv.x*2.;\n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    float td = length(uv-vec2(0., .6));\n    vec3 toothCol = vec3(1.) * S(.6,.35 ,d);\n    col.rgb = mix(col.rgb, toothCol, S(.4,.37, td));\n    \n    td = length(uv + vec2(0., .5)); //thong distance\n    col.rgb = mix(col.rgb, vec3(1., .5 ,.5) , S(.5 , .2 ,td));\n    return col;\n}\n\nvec4 Head(vec2 uv) {\n\tvec4 col = vec4(0.9,.65,0.1,1.);\n    float d = length(uv);\n    col.a = S(0.5,.49,d);\n    float edgeShade = remap01(.35,.5,d);\n    edgeShade *= edgeShade;\n    col.rgb *= 1. - edgeShade *.5;\n    col.rgb = mix(col.rgb, vec3(.6,.3,.1), S(.47,.48,d));\n        \n    float highlight = S(.41, .405,d);\n    highlight *= remap(.41 , -.1, 0.75, 0.,uv.y);\n    highlight *= S(.18, .19, length(uv - vec2(.21,.08)));\n    col.rgb = mix(col.rgb , vec3(1.), highlight);\n    \n     d = length(uv - vec2(.25,-.2));\n    float cheek = S(.2,.01,d)*.4; //edge\n    cheek *= S(.18 ,  .16, d) ;\n    \n    col.rgb = mix(col.rgb, vec3(1., .1 , .1), cheek);\n    \n    return col;\n}\n\n\nvec4 Smiley(vec2 uv, vec2 m, float smile) {\n\tvec4 col = vec4(0.);\n    \n    float side = sign(uv.x); //+1 for right side -1 for the left side\n    \n    uv.x = abs(uv.x); //symetrie\n    vec4 head = Head(uv);\n    vec4 eye = Eye(within(uv, vec4(.03,-.1,.37, .25)),side, m, smile);\n    vec4 mouth = Mouth(within(uv, vec4(-.3,-.43,.3, -.13)));\n    vec4 brow = Brow(within(uv, vec4(.03,.2, .4,.45)));\n    \n    col = mix(col,head, head.a); //mix the color between col and head. if head.a = 0 return col/ if =1 return head\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    col = mix(col, brow, brow.a);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    uv -=0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec2 m = iMouse.xy /iResolution.xy;\n  \tm -= .5;\n\n    float smile = cos(iTime)*.5+.5;\n    // Output to screen\n    fragColor = Smiley(uv, m, smile);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tsXR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sK3Rc", "name": "Color Separation Spin Cycle", "author": "jaburns", "description": "Shaking the colors out of white", "tags": ["simple"], "likes": 3, "viewed": 264, "date": "1571538454", "time_retrieved": "2024-06-20T19:46:19.956056", "image_code": "#define PI 3.14159265358979\n#define BLACK vec4(0,0,0,1)\n#define WHITE vec4(1,1,1,1)\n#define RADIUS .8\n#define BASE_THICKNESS .05\n#define VAR_THICKNESS .08\n#define INNER_THICKNESS_SCALE .2\n\nfloat bell(float x)\n{\n    return exp(-((x-PI)*(x-PI)) * .5);\n}\n\nfloat go(vec2 pos, float time)\n{\n    time *= time;\n    \n    float lp = length(pos);\n    float theta = mod(atan(pos.y, pos.x) + time, 2.*PI) ;\n    float thickness = BASE_THICKNESS + VAR_THICKNESS*bell(theta);\n    \n    if (lp < RADIUS + thickness && lp > RADIUS - INNER_THICKNESS_SCALE*thickness) {\n        return 1.;\n    }\n    return 0.;\n}\n\nvec3 samp(vec2 pos, vec2 o)\n{\n    pos += o / iResolution.xy;\n    float a = go(pos, iTime-.02);\n    float b = go(pos, iTime-.01);\n    float c = go(pos, iTime);\n    return vec3(a, b, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = 2. * fragCoord.xy / iResolution.xy - 1.;\n    pos.x *= iResolution.x / iResolution.y;\n    float time = iTime * iTime;\n    \n    vec3 sampleA = samp(pos, vec2(-.75, .25));\n    vec3 sampleB = samp(pos, vec2(-.25,-.75));\n    vec3 sampleC = samp(pos, vec2( .25, .75));\n    vec3 sampleD = samp(pos, vec2( .75,-.25));\n    \n    fragColor = vec4((sampleA + sampleB + sampleC + sampleD) / 4., 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sK3Rc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sVfD3", "name": "transparent", "author": "pequalsnp", "description": "a simple transparent shader", "tags": ["colors", "shading", "transparent"], "likes": 6, "viewed": 105, "date": "1569954382", "time_retrieved": "2024-06-20T19:46:19.956056", "image_code": "float Angle(vec3 v,vec3 u)\n{\n    return dot(v,u)/(length(v)*length(u));\n}\n\nfloat Delta(vec3 pos,vec3 spos)\n{\n    float a = Angle(pos,vec3(sin(iTime*0.15),cos(iTime*0.1),sin(iTime*0.1)));\n    \n\treturn  abs(length(pos-spos)\n               - 1.0\n               + 0.05*sin(8.0*pos.y + iTime)\n               - 0.05*sin(16.0*pos.x*pos.y + iTime)\n        \t   + 0.05*sin(20.0*a));\n}\n\nvec3 Normal(vec3 pos,vec3 spos) {\n    return normalize(pos-spos);\n}\n\nvec3 Col(vec3 pos,vec3 spos)\n{\n    vec3 norm = Normal(pos,spos);\n    return norm*Angle(norm,vec3(1.0,0.5,0.5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    \n\tvec3 pos = vec3(uv,0.0);\n    vec3 dir = pos - vec3(0.0,0.0,-1.5);\n    \n    vec3 spos = vec3(sin(iTime)*0.1,cos(iTime)*0.1,1.0);\n    \n\tvec3 color  = vec3(0.0);\n    \n    int steps = 150;\n    for(int i = 0; i < steps; i++)\n    {\n        if(Delta(pos,spos) < 0.015)\n        {\n            color += Col(pos,spos)*(float(i)/float(steps));\n        }\n        pos += 0.01*dir;\n    }\n    \n\tcolor *= 0.35;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sVfD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldcfDH", "name": "hash-based high-pass dither test", "author": "mystran", "description": "Dithers using a small 5-tap high-pass kernel sampling a hash-based RPDF.\n\nDrag mouse to adjust comparison.", "tags": ["dither"], "likes": 3, "viewed": 118, "date": "1572276287", "time_retrieved": "2024-06-20T19:46:20.368356", "image_code": "\nconst float levels = 6.; // number of quantisation levels, must be at least 2\nconst float animFPS = 120.; // max framerate for temporal dither, set 0 to disable\nbool separateRGB = false; // use different random values for different channels?\n\nuint hash(uint x)\n{\n    x ^= x >> 16; x *= 0x7feb352du; \n    x ^= x >> 15; x *= 0x846ca68bu; \n    x ^= x >> 16;\n    return x;\n}\n\n// fetch random values for RGB channels\nvec3 hash2v(uint x, uint y)\n{\n    // take a hash, split it into components\n    uint h = hash(uint(x)+(uint(y)<<16));\n    vec3 v;\n    v.x = float(h&0xffu); if(separateRGB) h >>= 8;\n    v.y = float(h&0xffu); if(separateRGB) h >>= 8;\n    v.z = float(h&0xffu);\n    \n    return v / float(0xffu);\n}\n\nvec3 triCDF(vec3 x)\n{\n    vec3 y = min(x, 1.-x);\n    y = .5 * sqrt(2.*y);\n    return mix(y, 1.-y, round(x));\n}\n\nvec3 dither(vec3 c, uvec2 xy)\n{\n    \n    // temporal dither\n    xy.x += uint(floor(animFPS*iTime)*12345.);\n    \n    // compute noise\n    vec3 h = hash2v(xy.x, xy.y);\n    h -= .25 * hash2v(xy.x-1u, xy.y);\n    h -= .25 * hash2v(xy.x+1u, xy.y);\n    h -= .25 * hash2v(xy.x, xy.y-1u);\n    h -= .25 * hash2v(xy.x, xy.y+1u);\n\n    // scale, about 2 is enough to deal \n    h *= 2.;\n    \n    float g = levels-1.;\n    \n    // expand near black to counter compression\n    vec3 f0 = max(.5-c*g, 0.); c -= .5*f0*f0;\n    // expand near white to counter compression\n    vec3 f1 = max(.5-(1.-c)*g, 0.); c += .5*f1*f1;    \n    \n    return round(c*g + h) / g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 c = texture(iChannel0,uv.xy).xyz;\n    \n    if(abs(iMouse.x - fragCoord.x) < iResolution.x*.25) \n    {\n        c = dither(c, uvec2(fragCoord.xy));\n    }\n\telse if(iMouse.y < .5*iResolution.y) c = round(c*(levels-1.)) / (levels-1.);\n    \n    \n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldcfDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2yzG", "name": "tv noise", "author": "tamasaur", "description": "tv noise shader with chromatic aberration\n\n\n\n", "tags": ["noise", "tv", "shader"], "likes": 4, "viewed": 174, "date": "1571167818", "time_retrieved": "2024-06-20T19:46:20.368356", "image_code": "\n#define noiselevel 0.4\n#define rgbshiftlevel 0.01\n#define ghostreflectionlevel 0.03\n#define bypass false\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float randomValue = rand(vec2(uv.x+sin(iTime), uv.y+cos(iTime)));\n    float rgbShift = sin(iTime+randomValue)*rgbshiftlevel;\n    \n    if(randomValue > 0.95-ghostreflectionlevel)\n    \tuv.x+=sin(iTime/5.0)*0.5;\n   \n    uv.y += (cos(iTime*randomValue)+0.5) * (randomValue*0.01);\n    \n    float colorr = texture(iChannel0, vec2(uv.x+rgbShift, uv.y)).r;\n    float colorg = texture(iChannel0, vec2(uv.x, uv.y)).g;\n    float colorb = texture(iChannel0, vec2(uv.x-rgbShift, uv.y)).b;\n    \n  \tvec4 movieColor = vec4(colorr,colorg,colorb, 1.0);\n    vec4 noiseColor = vec4(randomValue,randomValue,randomValue,1.0);\n \n    if(randomValue > 0.55-ghostreflectionlevel)\n    \tnoiseColor = abs(noiseColor - 0.2);\n \n    if(bypass)\n        fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy); \n    else\n      \tfragColor = mix(movieColor, noiseColor, noiselevel);  \n    \n\t\n}\n", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2yzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3SD7", "name": "Rainbow Voronoi", "author": "copperTones", "description": "a simple Moroni shader. colors based on center of cell. credit to the art of code for the voronoi tutorial", "tags": ["2d", "voronoi", "worley"], "likes": 3, "viewed": 133, "date": "1572110909", "time_retrieved": "2024-06-20T19:46:20.556219", "image_code": "vec2 point(float i) {//random point maker\n    vec3 a = fract(i*vec3(123.45, 456.78, 321.98));\n    a += dot(a, a+35.79);\n    return fract(a.xy + a.zz);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragCoord -= iResolution.xy/2.;//centered, normalized, uv\n    vec2 uv = fragCoord/iResolution.y;\n    uv += .5;\n\t\n    vec2 p = vec2(-10.);\n    for(float i = 0.; i < 50.; i++) {//voronoi\n        vec2 v = .5 + .5*sin(6.2831*point(i) + .1*iTime);\n        if (length(uv-p) > length(uv-v)) {\n        \tp = v;\n        }\n    }\n\t\n    vec3 color = vec3(p.x+p.y);//based on og rainbow effect\n    color += vec3(0, 2, 4) + iTime;\n    color = .5 + .5*sin(color);\n    \n    fragColor = vec4(color, 1.);\n    fragColor *= 1. - 2.*length(uv-p);//times voronoi\n    \n    fragColor.w = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3SD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3SDH", "name": "Anaglyph Decoration", "author": "leon", "description": "Anaglyph Decoration. Framed for https://fanzine.cookie.paris/", "tags": ["anaglyph", "cookiezine", "cookieparty"], "likes": 5, "viewed": 294, "date": "1571874693", "time_retrieved": "2024-06-20T19:46:20.562267", "image_code": "// Anaglyph Decoration\n// Framed for https://fanzine.cookie.paris/\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.10.24\n// Using code from Inigo Quilez\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat random (in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\n\nvec3 look (vec3 eye, vec3 target, vec2 anchor) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * .75 + right * anchor.x + up * anchor.y);\n}\n\nfloat map (vec3 pos) {\n    vec3 p = pos;\n    float scene = 10.0;\n    float r = 1.0;\n    const float count = 9.0;\n    for (float index = count; index > 0.0; --index) {\n        pos.xz = abs(pos.xz)-1.4*r;\n        pos.yx *= rot(3.9/r + iTime * 0.3);\n        pos.yz *= rot(0.5/r + iTime * 0.2);\n        pos.xz *= rot(0.2/r + iTime * 0.1);\n        scene = min(scene, abs(max(pos.x, max(pos.y, pos.z))));\n        r /= 1.8;\n    }\n    scene = max(abs(p.z)-1., scene);\n    scene = max(-length(p.xy)-p.z*.5, scene);\n    return scene;\n}\n\nvec4 raymarch (vec3 eye, vec3 ray) {\n    float dither = random(ray.xy+fract(iTime));\n    vec4 result = vec4(eye, 0);\n    float total = 0.1 * dither;\n    float maxt = 20.0;\n    const float count = 30.;\n    for (float index = count; index > 0.0; --index) {\n        result.xyz = eye + ray * total;\n        float dist = map(result.xyz);\n        if (dist < 0.001 + total * .001 || total > maxt) {\n            result.w = index / count;\n            break;\n        }\n        dist *= 0.7 + 0.1 * dither;\n        total += dist;\n    }\n    result.w *= step(total, maxt);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(.2,.1,-2.);\n    vec3 at = vec3(0);\n    vec3 ray = look(eye, at, uv);\n    vec3 eyeoffset = 0.02*normalize(cross(normalize(at-eye), vec3(0,1,0)));\n    vec4 resultLeft = raymarch(eye-eyeoffset, ray);\n    vec4 resultRight = raymarch(eye+eyeoffset, ray);\n    fragColor = vec4(resultLeft.w,vec2(resultRight.w),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "unknown-license-reference", "thumbnail": "https://www.shadertoy.com/media/shaders/td3SDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3SDn", "name": "Shadertober 22 Ghost", "author": "GreenChicken", "description": "a cute one", "tags": ["raymarching", "ghost", "inktober"], "likes": 2, "viewed": 245, "date": "1571759063", "time_retrieved": "2024-06-20T19:46:21.550201", "image_code": "// SHADERTOBER 22 Ghost\n// Poulet vert 22-10-2019\n// thanks iq, leon\n\n#define VOLUME 0.001\n#define PI 3.14159\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n// Scene setup\nvec2 map(vec3 pos)\n{\n    vec2 scene = vec2(0.0, 0.0);\n    \n    pos.y -= iTime*2.0;\n    pos = opRep(pos, vec3(0.0, 8., 0.0));\n    \n    \n    pos.y += sin(iTime)*.5;\n    pos.x += sin(pos.y+iTime)*.5;\n    pos.xy *= rot(sin(iTime)*.1);\n    \n    vec3 bodyP = pos + vec3(0.0);\n    float body = sdVerticalCapsule(bodyP, 2.0, 1.0);\n    float low = sdSphere(pos+vec3(0.0, 1.0, 0.0), .8);\n    \n    body = opSmoothUnion(body, low, 2.0);\n    \n    vec3 subP = pos + vec3(0.0, 1.8, 0.0);\n    subP.y += sin(pos.x*10.+iTime)*.1;\n    \n    float sub1 = sdBox(subP, vec3(2.0, 1.0, 2.0));\n    \n    body = max(body, -sub1);\n    \n    vec3 eyeP = pos + vec3(0.15, -2.0, 1.0);\n    float eyes = sdSphere(eyeP, .1);\n    eyeP = pos + vec3(-0.15, -2.0, 1.0);\n    eyes = min(eyes, sdSphere(eyeP, .1));\n    \n    // materials\n    scene = vec2(body, 0.0);\n    scene = opU2(scene, vec2(eyes, 1.0));\n    \n    return scene;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 10.0; i += .1) {\n        float dist = map(pos + dir * t).x;\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec3 GetNormal (vec3 p)\n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy).x - map(p-e.xyy).x,\n        map(p+e.yxy).x - map(p-e.yxy).x,\n        map(p+e.yyx).x - map(p-e.yyx).x\n        ));\n}\n\nfloat GetLight(vec3 N, vec3 lightPos)\n{\n    return max(dot(N, normalize(lightPos)), 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(t.x+fract(iTime), vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(0.0);\n        \n    }\n    else\n    {    \n        vec3 N = GetNormal(pos);\n        vec3 rimL = vec3(0.5, 0.5, .5);\n        float rimlight = GetLight(N, rimL);\n        vec3 mainL = vec3(1.0, 1.0, -2.0);\n        float mainlight = GetLight(N, mainL);\n        \n        \n        if(t.y == 0.0)\n        {\n            col = vec3(.0);\n            col += vec3(1.0) * mainlight;\n            col += vec3(1.0, 0.5, 0.0) * vec3(rimlight) * 2.0;\n        }\n        else if(t.y == 1.0)\n        {\n            col = polyCol;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(sin(iTime)*.5, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 cp = vec3(0.0, 4.0, -8.0);\n    vec3 ct = vec3(0.0, 4.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, uv);\n    \n    col.b -= (length(uv)-1.0)*.2;\n    \n    col *= clamp(3.0-length(uv), 0.0, 1.0);\n    \n    col = sqrt(clamp(col, 0.0, 1.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3SDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3SRH", "name": "ShaderTober - Ornament", "author": "Flopine", "description": "A small doodle with inktober's theme \"Ornament\"", "tags": ["raymarching", "glow", "inktober"], "likes": 4, "viewed": 112, "date": "1571402422", "time_retrieved": "2024-06-20T19:46:22.307851", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 100.\n#define PI 3.141592\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat necklace (vec3 p)\n{\n    vec3 pp = p;\n    p.y += 1.5;\n    p.x = abs(p.x)-0.5;\n    p.y += sin(p.x);\n    p.xy *= rot(-PI/4.);\n    p.xz *= rot(p.y*2.-iTime);\n    moda(p.xz, 5.);\n    p.x -= 0.2;\n    float n = cyl(p.xz,0.1);\n    \n    p = pp;\n    p.y -= 0.5;\n    float r = max(abs(cyl(p.xy,1.7))-0.2,abs(p.z)-0.12);\n    \n    return stmin(r,n,0.2,3.) ;\n}\n\nfloat g1 = 0.;\nfloat gem (vec3 p)\n{\n    p.y -= 0.5;\n    p.xz *= rot(iTime);\n   \tfloat d = dot(p, normalize(sign(p)))-0.85;\n    g1 += 0.1/(0.1+d*d);\n\treturn d ;\n}\n\nint mat_id;\nfloat SDF (vec3 p)\n{\n    p.y += 0.4;\n    float g = gem(p);\n    float n = necklace(p);\n    float d = min(g,n);\n    \n    if (d == n) mat_id =1;\n    if (d == g) mat_id = 2;\n    \n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),\n                                 SDF(p-eps.yxy),\n                                 SDF(p-eps.yyx)));\n}\n\nvoid gold (inout vec3 color, vec3 n, vec3 l, vec3 rd)\n{\n    // fresnel\n    float fre = pow(clamp(1.-dot(-rd,n),0.,1.), 2.);\n    color += fre*vec3(0.8,0.5,0.2);\n    \n    // specular\n    vec3 h = normalize(l-rd);\n    float spe = pow(max(0.,dot(h,n)),10.);\n    color += spe*vec3(0.8,0.5,0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.001,0.001,-3.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        l = vec3(1.,-3.,-5.),\n        col = vec3(1.);\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd;\n    }\n    \n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        if (mat_id == 1)\n        {\n            col = vec3(0.7,0.5,0.1);\n            gold(col,n,l,rd);\n        }\n        if (mat_id == 2)\n        {\n            col = vec3(shad);\n        }\t\n    }\n    \n    col -= g1*0.1;\n\tcol = clamp(col,0.,1.);\n    \n    // vignetting (from iq)\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.15);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3SRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3SWr", "name": "CodebaseAlpha6", "author": "codebasealpha", "description": "Version of CodebaseAlpha4, but with clouds and water added; created live on-stream during Ep. 69 of Codebase Alpha (https://twitch.tv/codebasealpha)", "tags": ["terrain"], "likes": 16, "viewed": 401, "date": "1571764065", "time_retrieved": "2024-06-20T19:46:22.307851", "image_code": "#define PI  3.141592654\n#define TAU (2.0*PI)\n#define TOLERANCE       0.001\n#define MAX_ITER        100\n#define MIN_DISTANCE    0.1\n#define MAX_DISTANCE    30.0\n\nconst vec3 skyCol1 = vec3(0.35, 0.45, 0.6);\nconst vec3 skyCol2 = vec3(0.4, 0.7, 1.0);\nconst vec3 skyCol3 = pow(skyCol1, vec3(0.25));\nconst vec3 sunCol1 =  vec3(1.0,0.5,0.4);\nconst vec3 sunCol2 =  vec3(1.0,0.8,0.7);\nconst float gravity = 1.0;\n\nfloat noise(vec2 p)\n{\n    return 2.0 * (texture(iChannel1, 0.01 *p + 0.5).x - 0.5);\n}\n\nvec4 cloudCol(vec2 p, float off)\n{\n    float n = 0.0;\n    p += 3.0;\n    float amp = 1.0;\n    float freq = 1.0;\n\n    for (int i = 0; i < 5; i++)\n    {\n        n += amp * noise(freq * p);\n        const float df = 0.1;\n        p += 0.0051 * iTime; // + 1.0 * vec2(cos(df * i*p.x), sin(df * i*p.y));\n        amp *= 0.4;\n        freq *= 3.0;\n    }\n\n    vec4 col = vec4(1.0, 1.0, 1.0, max(n-off, 0.0));\n    return col;\n}\n\nvoid rot(inout vec2 p, in float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nfloat rand(in vec2 co)\n{\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 hash(in vec2 p)\n{\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nvec4 voronoi(in vec2 x)\n{\n  vec2 n = floor(x);\n  vec2 f = fract(x);\n  vec4 m = vec4(8.0);\n  for(int j=-1; j<=1; j++)\n  for(int i=-1; i<=1; i++)\n  {\n    vec2  g = vec2(float(i), float(j));\n    vec2  o = hash(n + g);\n    vec2  r = g - f + o;\n    float d = dot(r, r);\n\n    if(d<m.x)\n    {\n      m = vec4(d, o.x + o.y, r);\n    }\n  }\n\n  return vec4(sqrt(m.x), m.yzw);\n}\n\nfloat globalHeight(float f, vec2 op)\n{\n    return (f *0.9 + (0.5 + 0.5 * cos(op.y *0.1)) * 0.4 - 0.3) * (0.7 + 0.3 *sin((0.5 + 0.25 * (1.0 + sin(op.y))) * op.x - 1.5));\n}\n\nfloat heightFunction(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n\n    for (int i = 0; i < 7; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n\n    return globalHeight(f, op);\n}\n\nfloat heightFunctionLo(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n       \n    for (int i = 0; i < 6; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n    \n    return globalHeight(f, op);\n}\n\nfloat heightFunctionHi(vec2 p)\n{\n    vec2 op = p;\n    p += 0.02;\n    p *= 0.0025;\n    float f = 0.0;\n    float amplitude = 1.0;\n    float period = 1.0;\n       \n    for (int i = 0; i < 11; i++)\n    {\n        f += amplitude * texture(iChannel0, period * p).x;\n        rot(p, 1.0);\n        amplitude *= 0.5;\n        period *= 2.0;\n    }\n   \n    return globalHeight(f, op);\n}\n\nvec3 getNormal(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunction(p - eps) - heightFunction(p + eps);\n  float dy = 2.0f*eps.x;\n  float dz = heightFunction(p - eps.yx) - heightFunction(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nvec3 getNormalLo(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunctionLo(p - eps) - heightFunctionLo(p + eps);\n  float dy = 2.0f*eps.x;\n  float dz = heightFunctionLo(p - eps.yx) - heightFunctionLo(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nvec3 getNormalHi(in vec2 p, in float d)\n{\n  vec2 eps = vec2(0.004*d, 0);\n  float dx = heightFunctionHi(p - eps) - heightFunctionHi(p + eps);\n  float dy = 2.0f*eps.x;\n  float dz = heightFunctionHi(p - eps.yx) - heightFunctionHi(p + eps.yx);\n  return normalize(vec3(dx, dy, dz));\n}\n\nfloat march(in vec3 ro, in vec3 rd, out int max_iter)\n{\n  float dt = 0.1;\n  float d = MIN_DISTANCE;\n  float lh = 0.0;\n  float ly = 0.0;\n \n  for (int i = 0; i < MAX_ITER; ++i)\n  {\n    vec3 p = ro + d*rd;\n    float h = heightFunction(p.xz);\n   \n    if (d > MAX_DISTANCE) \n    {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < 0.0)\n    {\n      return d - dt + dt*(lh-ly)/(p.y-ly-h+lh);\n    }\n\n    lh = h;\n    ly = p.y;\n    dt = max(hd, TOLERANCE) + 0.001*d;\n    d += dt;\n  }\n \n  max_iter = MAX_ITER;\n  return MAX_DISTANCE;\n}\n\nvec3 sunDirection()\n{\n  const vec3 sunDirection = normalize(vec3(-1.0, 0.2, -1.0));\n  vec3 sunDir = sunDirection;\n  rot(sunDir.xz, 2.0);\n  return sunDir;\n}\n\nvec3 skyColor(vec3 rd) {\n  vec3 sunDir = sunDirection();\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  vec3 final = vec3(0.0);\n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n  final += mix(mix(skyCol1, skyCol2, max(0.0, angle)), skyCol3, clamp(-angle*2.0, 0.0, 1.0));\n  final += 0.5*sunCol1*pow(sunDot, 30.0);\n  final += 1.0*sunCol2*pow(sunDot, 600.0);\n   \n  return final;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float ll, in float mint)\n{\n  float t = mint;\n \n  for (int i=0; i<24; ++i)\n  {\n    vec3 p = ro + t*rd;\n    float h = heightFunction(p.xz);\n    float d = (p.y - h);\n    if (d < TOLERANCE) return 0.1;\n    if (t > ll) return 1.0;\n    t += max(0.1, 0.25*h);\n  }\n \n  return 1.0;\n}\n\nfloat gravityWave(in vec2 p, float k, float h) \n{\n  float w = sqrt(gravity*k*tanh(k*h));\n  return sin(p.y*k + w* iTime);\n}\n\nfloat seaHeight(vec2 p)\n{\n  float height = 0.0;\n  float amplitude = 0.17;\n  float freq = 0.3;\n\n  for (int i = 0; i < 7; i++)\n  {  \n    height += amplitude * gravityWave(p, freq, 10.0);\n    amplitude *= 0.80;\n    freq *= 1.1;\n//    p += 10.0;\n    rot(p, 1.2);\n  }\n\n  return height;\n}\n\nvec3 seaNormal(in vec2 p, in float h) \n{\n  vec2 eps = vec2(0.001, 0.0);\n  vec3 n = vec3(\n    h*seaHeight(p + eps) - h*seaHeight(p - eps), 2.0*eps.x,\n    h*seaHeight(p + eps.yx) - h*seaHeight(p - eps.yx)\n  );\n \n  return normalize(n);\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    int max_iter;\n    float d = march(ro, rd, max_iter);\n    vec3 sandColor =  1.3 * vec3(0.68, 0.4, 0.3);\n    vec3 surfaceColor = vec3(0.0);\n    vec3 skyCol = skyColor(rd);\n   \n    if (d < MAX_DISTANCE)\n    {\n        vec3 p = ro + d * rd;\n       \n        // diffuse lighting\n        vec3 sunDir = sunDirection();\n        float seaHeight = 0.225;\n        float dsea = (seaHeight - ro.y)/rd.y;\n\n        if (d > dsea && dsea > 0.0)\n        {\n            vec3 psea = ro + dsea * rd;\n            float seaDepth = seaHeight - heightFunctionLo(psea.xz);\n            vec3 normal = seaNormal(psea.xz * 500.0, tanh(20.0*seaDepth)*(0.5 + 0.5*sin(5.0*(psea.x + psea.y))));\n            float dotProduct = max(dot(-normal, rd), 0.0);\n           \n            // specular lighting\n            vec3 refRay = reflect(rd,normal);\n            vec3 refSkyColor = skyColor(refRay);\n            float seaDist = d - dsea;\n            float seaFactor = exp(-seaDist * 50.0);\n            float shoreFactor = exp(-seaDist * 200.0);\n           \n            // Fog\n            float fogHeight = 0.3 - seaDepth;\n            float dfog = (fogHeight - ro.y)/rd.y;\n            float fogDepth = d > dfog && dfog > 0.0 ? d - dfog : 0.0;\n            float fogFactor = exp(-fogDepth);\n            float shad = shadow(psea, sunDir, 4.0, 0.04);\n            vec3 seaAmb = 0.4*mix(vec3(0.4, 1.0, 0.9), vec3(0.0), tanh(30.0*seaDepth));\n            vec3 seaFloor = mix(seaAmb, shad * 0.5*vec3(0.8, 1.0, 0.6), seaFactor);\n            vec3 breakingWaves = mix(seaFloor, vec3(0.9), shoreFactor);\n            vec3 col = mix(refSkyColor, breakingWaves, pow(dotProduct, 0.75));\n            col = mix(skyCol, col, fogFactor);\n           \n            return col;\n        }\n        else\n        {\n            // Mountain strata\n            float bandings = mix(50.0, 100.0, 0.5 + 0.5*sin(length(p.y)*10.0));\n            float bandingo = sin(length(p.xz) * 3.0);\n            float bandingf = pow(0.5 + 0.5 * sin(p.y*bandings + bandingo), 0.25);\n            float banding = mix(0.6, 1.0, bandingf);\n      \n            float heightLo = heightFunctionLo(p.xz + vec2(0.2));\n            float heightHi = heightFunctionHi(p.xz);\n            float heightRatio = heightHi / heightLo;\n           \n            vec3 normalLo = getNormalLo(p.xz, d);\n            vec3 normal = getNormal(p.xz, d);\n            vec3 normalHi = getNormalHi(p.xz, d);\n            surfaceColor = sandColor * banding;\n            float refFactor = 0.0;\n                       \n            float flatness = max(dot(normal, vec3(0.0, 1.0, 0.0)), 0.0);\n            float flatnessFactor = pow(flatness, 7.0);\n           \n            // Fog\n            float fogHeight = 0.2 + 0.2 * flatnessFactor;\n            float dfog = (fogHeight - ro.y)/rd.y;\n            float fogDepth = d > dfog && dfog > 0.0 ? d - dfog : 0.0;\n            float fogFactor = exp(-fogDepth);\n          \n            vec4 treePattern = voronoi(p.xz * 50.0);\n            vec4 patchPattern = voronoi(p.xz * 10.0);\n       \n            // Snow\n            if (p.y > 0.7 + 0.1 * sin(p.x + p.z) - 0.3 * flatnessFactor)\n            {\n                surfaceColor = vec3(1.0);\n                refFactor = 0.5;\n                normal = normalLo;\n            }\n            else if (p.y > seaHeight + 0.01 && p.y < 0.3 + 0.1 * flatnessFactor)\n            {\n                // Trees\n                surfaceColor = mix(vec3(0.2, 0.5, 0.0), vec3(0.5, 0.5, 0.0), patchPattern.y) * 1.3;\n                surfaceColor *= 1.0 - treePattern.x * 0.75;\n                vec3 normalOffset = vec3(treePattern.z, 0.0, treePattern.w);\n                normal = normalize(normalLo - normalOffset);\n            }\n            else\n            {\n                normal = normalHi;\n            }\n       \n            // specular lighting\n            vec3 refRay = reflect(rd,normal);\n            vec3 refSkyColor = skyColor(refRay);\n       \n            // shadows\n            float shad = shadow(p, sunDir, 4.0, 0.01); // Look into this\n            float dl = max(0.0, dot(normal, sunDir));\n            float grad = mix(0.2, 1.0, shad * dl);   \n            vec3 col = vec3(grad * surfaceColor +  refFactor * refSkyColor) * pow(heightRatio, 3.0);\n            col = mix(skyCol, col, fogFactor);\n            col = mix(col, skyCol, d/MAX_DISTANCE);\n       \n            return col;\n        }\n    }\n    else\n    {\n        vec3 col = skyCol;\n        float dsky = (10.0 - ro.y)/rd.y;\n       \n        if (dsky > 0.0)\n        {     \n            vec3 p = ro + dsky * rd;\n            vec4 clouds = cloudCol(p.xz * 0.003, 1.0 - 0.75 * tanh(p.z));\n            col = mix(skyCol, clouds.xyz, clouds.w * (1.0 - 1.0 * tanh(0.001 * p.z)));\n        }\n       \n        return col;\n    }\n}\n\nvec3 eyePos(float t)\n{\n    return vec3(sin(t * 0.1), 1.4-0.0, -2.0 + t * 1.0);\n}\n\nvec3 getSample(in vec2 p, in float time)\n{\n  float off = 1.0*time;\n  vec3 ro  = eyePos(time);\n  vec3 la  = eyePos(time + 0.1) + vec3(0.0, -0.02,  0.0);\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 col = getColor(ro, rd);\n \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  vec2 p = fragCoord/iResolution.xy - vec2(0.6,0.3);\n  p.x *= iResolution.x/iResolution.y;\n    \n  vec3 col = getSample(p, iTime);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3SWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3Szj", "name": "Undersea Life", "author": "dr2", "description": "Polyps living quietly (mouseable)", "tags": ["water", "hexagon", "bubble", "godray", "polyp"], "likes": 16, "viewed": 420, "date": "1572340407", "time_retrieved": "2024-06-20T19:46:22.325550", "image_code": "// \"Undersea Life\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrSphAnDf (vec3 p, float r, float w);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HsvToRgb (vec3 c);\nfloat Minv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 gPhs;\nvec3 ltDir;\nvec2 gId;\nfloat tCur, dstFar, hgSize, obHt, bbHt;\nint idObj;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvoid SetGrObjConf ()\n{\n  float g, r;\n  r = Hashfv2 (37.3 * gId + 11.1);\n  obHt = 0.5 * r;\n  bbHt = 0.1 + mod (3. * tCur + 0.5 * r * dstFar, 0.5 * dstFar);\n  g = dot (gId, vec2 (1.));\n  gPhs = vec4 (12. + floor (8. * r),\n     -0.1 * sin (2. * pi * (0.1 * tCur + 0.2 * g)),\n     sin (2. * pi * (-0.5 * tCur + 0.3 * g) + vec2 (0., 0.5 * pi)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, s, a, r, rs, l, w;\n  dMin = dstFar;\n  r = 2.;\n  l = 0.5;\n  w = 0.05;\n  p.xz -= HexToPix (gId * hgSize);\n  p.y -= obHt;\n  q = p;\n  a = (length (q.xz) > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  s = smoothstep (0.05, 0.8, q.y / r);\n  q.xy -= vec2 (gPhs.y * s, r);\n  rs = r * (1. + (0.02 * cos (gPhs.x * 2. * pi * a) + \n     0.1 * cos (4. * pi * (a + 0.1 * tCur)) * gPhs.w) * s) * (1. +\n     0.002 * dot (gPhs.zw, sin (3. * pi * q.y + vec2 (0.5 * pi, 0.))));\n  d = max (PrSphAnDf (q, rs, 0.1 * (0.2 - 0.8 * q.y / r)), q.y - 0.1 * r);\n  DMIN (1);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (gPhs.x * a + 0.5) / gPhs.x));\n  d = max (PrTorusDf (q, w, rs), q.y);\n  DMIN (1);\n  q.xy -= vec2 (- rs, l);\n  d = PrCylDf (q.xzy, w, l);\n  DMIN (1);\n  q.y -= l;\n  d = PrSphDf (q, 3. * w);\n  DMIN (2);\n  q = p;\n  q.y -= bbHt;\n  d = PrSphDf (q, 0.05);\n  DMIN (3);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  if (rd.y == 0.) rd.y = 0.0001;\n  p = 20. * rd.xz / rd.y;\n  t = 2. * tCur;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nfloat TurbLt (vec3 p, vec3 vn, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, vn), dot (p.zxy, vn)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (float j = 1.; j <= 7.; j ++) {\n    tt = t * (1. + 1. / j);\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.zw;\n    c += 1. / length (q / sin (qq));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 2. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.1, 0.7, 0.6), vec3 (0.3, 0.5, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.1 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj;\n  rd = VaryNf (32. * rd, rd, 0.02 * (1. - rd.y * rd.y));\n  bgCol = BgCol (rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj < 3) {\n      vn = VaryNf (ro, vn, 0.2);\n      col = HsvToRgb (vec3 (0.05 + 0.4 * Hashfv2 (gId), 0.9, 1.));\n      if (idObj == 2) col *= 1.5;\n    } else {\n      col = mix (vec3 (1.2), BgCol (reflect (rd, vn)), 0.5);\n    }\n    col = col * (0.1 + 0.2 * bgCol + 0.7 * max (dot (vn, ltDir), 0.));\n    col *= 1. + 0.2 * TurbLt (0.05 * ro, abs (vn), 0.25 * tCur) * smoothstep (-0.3, -0.1, vn.y);\n    col = mix (col, bgCol, smoothstep (0.3, 1., dstObj / dstFar));\n  } else col = (bgCol + WatShd (rd)) * (0.7 + 0.3 * smoothstep (-0.9, -0.5, rd.y));\n  col = pow (clamp (col, 0., 1.), vec3 (1.1, 1.1, 0.9));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  hgSize = 2.8;\n  az = 0.;\n  el = -0.12 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    az += 0.4 * pi * (2. * mod (floor (0.015 * tCur), 2.) - 1.) *\n       SmoothBump (0.3, 0.7, 0.15, mod (0.015 * tCur, 1.));\n    el -= 0.05 * pi * sin (0.017 * pi * tCur);\n  }\n  el = clamp (el, -0.45 * pi, 0.2 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vec3 (0., 20., 5. + 0.5 * tCur);\n  zmFac = 3.;\n  dstFar = 90.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrSphAnDf (vec3 p, float r, float w)\n{\n  return abs (length (p) - r) - w;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3Szj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3XWM", "name": "smoothstep graph", "author": "mat44", "description": "simple graph to show what smoothstep does", "tags": ["graph"], "likes": 3, "viewed": 474, "date": "1572097084", "time_retrieved": "2024-06-20T19:46:22.326132", "image_code": "float func(float x) {\n    return smoothstep(iTime/5., 1.0, x);\n}\n\nfloat funcGrad(float x) {\n    float o = 0.01;\n    return (func(x-o) - func(x+o)) / (2.0 * o);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    uv -= (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 2.0;\n    uv -= 0.1;\n    \n    vec3 col = vec3(1);\n    \n    float gridW = 0.1;\n    vec2 gridUv = fract(uv*10.);\n    float grid = smoothstep(1.0-gridW, 1.0, gridUv.x);\n    grid += smoothstep(gridW, 0.0, gridUv.x);\n    grid += smoothstep(1.0-gridW, 1.0, gridUv.y);\n    grid += smoothstep(gridW, 0.0, gridUv.y);\n    \n    col -= 0.1*grid;\n    \n    if (abs(uv.x) < 0.01 || abs(uv.y) < 0.01) col = vec3(1.0, 0.0, 0.0);\n    \n    float y = func(uv.x);\n    // old method, uneven thickness\n    //col -= 1.0 - smoothstep(0.01, 0.02, abs(uv.y - y));\n    // new method based off http://www.iquilezles.org/www/articles/distance/distance.htm\n    col -= smoothstep(0.02, 0.019, abs(uv.y - y) / sqrt(1.0 + pow(funcGrad(uv.x), 2.0)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3XWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3XWn", "name": "Combining Shapes", "author": "lilieming", "description": "Combining Shapes", "tags": ["mathdrawraymarch"], "likes": 4, "viewed": 137, "date": "1571757159", "time_retrieved": "2024-06-20T19:46:23.011009", "image_code": "\nprecision highp float;\n\nfloat getDistanceFromPoint(vec3 point);\nvec3 draw_line(float d);\nfloat draw_solid(float d);\nvec3 draw_distance(float d, vec2 p);\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\nvec3 calcNormal(vec3 pos, float eps) {\n    const vec3 v1 = vec3( 1.0, -1.0, -1.0);\n    const vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n    return normalize( v1 * getDistanceFromPoint( pos + v1*eps ) +\n    v2 * getDistanceFromPoint( pos + v2*eps ) +\n    v3 * getDistanceFromPoint( pos + v3*eps ) +\n    v4 * getDistanceFromPoint( pos + v4*eps ) );\n}\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n    mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n    return normalize(camMat * vec3(screenPos, lensLength));\n}\nfloat intersectPlane(vec3 ro, vec3 rd, vec3 nor, float dist) {\n    float denom = dot(rd, nor);\n    float t = -(dot(ro, nor) + dist) / denom;\n    return t;\n}\nfloat getDistanceFromPoint(vec3 point) {\n    vec3 offset = vec3(0.25, 0, 0);\n    float radius = 0.3;\n    float d1 = length(point - offset) - radius;\n    float d2 = length(point + offset) - radius;\n    float d3 = length(point - offset.zyx) - radius;\n    float d4 = length(point + offset.zyx) - radius;\n    return min(max(d1, d2), max(d3, d4));\n}\nfloat beckmannDistribution(float x, float roughness) {\n    float NdotH = max(x, 0.0001);\n    float cos2Alpha = NdotH * NdotH;\n    float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n    float roughness2 = roughness * roughness;\n    float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n    return exp(tan2Alpha / roughness2) / denom;\n}\nfloat cookTorranceSpecular(\nvec3 lightDirection, vec3 viewDirection, vec3 surfaceNormal, float roughness, float fresnel) {\n    float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n    float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n    \n    //Half angle vector\n    \n    vec3 H = normalize(lightDirection + viewDirection);\n    \n    //Geometric term\n    \n    float NdotH = max(dot(surfaceNormal, H), 0.0);\n    float VdotH = max(dot(viewDirection, H), 0.000001);\n    float x = 2.0 * NdotH / VdotH;\n    float G = min(1.0, min(x * VdotN, x * LdotN));\n    \n    //Distribution term\n    \n    float D = beckmannDistribution(NdotH, roughness);\n    \n    //Fresnel term\n    \n    float F = pow(1.0 - VdotN, fresnel);\n    \n    //Multiply terms and done\n    \n    return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime * 0.025;\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    vec3 ro = vec3(sin(time), 1.0, cos(time));\n    vec3 ta = vec3(0);\n    vec3 rd = getRay(ro, ta, uv, 2.0);\n    float t = -1.0;\n    float mind = 0.01;\n    float maxd = 10.0;\n    float latest = 1.0;\n    for (int i = 0; i < 30; i++) {\n        if (latest < mind || t > maxd) break;\n        t += (latest = getDistanceFromPoint(ro + rd * t));\n    }\n    float tPlane = intersectPlane(ro, rd, vec3(0, 1, 0), 0.0);\n    if (tPlane > -0.5 && tPlane < t) {\n        vec3 pos = ro + rd * tPlane;\n        fragColor = vec4(draw_distance(getDistanceFromPoint(pos) - 0.0125, pos.xz), 1);\n    }\n    else\n    if (t > maxd) {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n    else {\n        vec3 pos = ro + rd * t;\n        vec3 normal = calcNormal(pos, 0.002);\n        vec3 ldir = normalize(vec3(0, 1, 0.2));\n        float mag = max(0.2, dot(normal, ldir));\n        mag = pow(mag, 0.3545);\n        mag *= 1.75;\n        //mag = 0.0;\n        \n        \n        fragColor = vec4(mag * vec3(0.95, 0.45, 0.15), 1);\n        fragColor.rgb += cookTorranceSpecular(ldir, -rd, normal, 1.0, 3.25) * 1.5;\n    }\n\n}\nvec3 draw_line(float d) {\n    const float aa = 1.0;\n    const float thickness = 0.0025;\n    return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\nfloat draw_solid(float d) {\n    return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\nvec3 draw_distance(float d, vec2 p) {\n    float t = clamp(d * 0.85, 0.0, 1.0);\n    vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n    float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n    float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n    float d2 = abs(1.0 - draw_line(d).x);\n    vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n    grad -= rim * clamp(1.25 - d, 0.0, 1.0);\n    grad -= 1.0 - clamp(1.25 - d * 0.25, 0.0, 1.0);\n    grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n    return grad;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3XWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3Xzr", "name": "Eye of Ezbhan", "author": "ozeg", "description": "Reaction diffusion like pattern inspired by diviaki's fingerprint.\nRadial gradients distributed by the golden angle along a spiral gives lifelike LSD like sensations.\nSpecial thanks to FabriceNeyret2 for his valuable feedback and beautiful shaders.", "tags": ["trippy", "organic", "diffuse", "reaction", "fingerprint"], "likes": 38, "viewed": 861, "date": "1571305903", "time_retrieved": "2024-06-20T19:46:23.011009", "image_code": "#define THETA 2.399963229728653 //THETA is the golden angle in radians: 2 * PI * ( 1 - 1 / PHI )\nvec2 spiralPosition(float t)\n{\n    float angle = t * THETA - iTime * .001; \n    float radius = ( t + .5 ) * .5;\n    return vec2( radius * cos( angle ) + .5, radius * sin( angle ) + .5 );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y * 1024.;\n    float a = 0.;\n    float d = 50.;\n    for(int i = 0; i < 256; i++)\n    {\n        vec2 pointDist = uv - spiralPosition( float(i) ) * 6.66;\n        a += atan( pointDist.x, pointDist.y );\n        d = min( dot( pointDist, pointDist ), d );\n    }\n    d = sqrt( d ) * .02;\n    d = 1. - pow( 1. - d, 32. );\n    a += sin( length( uv ) * .01 + iTime * .5 ) * 2.75;\n    vec3 col  = d * (.5 + .5 * sin( a + iTime + vec3( 2.9, 1.7, 0 ) ) );\n    //col   = d * smoothstep( .75, 1.0, vec3( .5 + .5 * sin( a + iTime * -1. ) ) );\n    fragColor = vec4( col, 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3Xzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3XzX", "name": "GlobalRemix", "author": "Del", "description": "Global Snow Remix", "tags": ["2d", "remix", "snow"], "likes": 16, "viewed": 438, "date": "1572479414", "time_retrieved": "2024-06-20T19:46:23.265428", "image_code": "// global remix - Del 30/10/2019\n\n\nfloat snow(vec2 uv,float scale)\n{\n    \n\tfloat _t = (iTime)*2.3;\n\tuv*=scale;    \n\tuv.x+=_t; \n\tvec2 s=floor(uv);\n    vec2 f=fract(uv);\n\tvec2 p=.5+.35*sin(11.*fract(sin((s+scale)*mat2(7,3,6,5))*5.))-f;\n    float d=length(p);\n\tfloat k=smoothstep(0.,d,sin(f.x+f.y)*0.003);\n\treturn k;\n}\n\n\nvec3 _globalmix(vec2 uv)\n{\n\t//vec2 uv=(fragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y); \n\tfloat dd = 0.5-length(uv);\n\tuv.x += sin(iTime*0.08);\n\tuv.y += sin(uv.x*1.4)*0.2;\n\tuv.x *= 0.1;\n\tfloat c=snow(uv,30.)*.3;\n\tc+=snow(uv,20.)*.5;\n\tc+=snow(uv,15.)*.8;\n\tc+=snow(uv,10.);\n\tc+=snow(uv,8.);\n\tc+=snow(uv,6.);\n\tc+=snow(uv,5.);\n\tc*=0.2/dd;\n\tvec3 finalColor=(vec3(0.7,0.35,0.9))*c*30.0;\n    finalColor += vec3(1.1,0.55,0.9)*0.02/dd;\n    return finalColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    fragColor = vec4(_globalmix(uv),1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3XzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcSD4", "name": "Jacintos", "author": "OcarinhaOfTime", "description": "An abstract shader representing my theater experience.", "tags": ["voronoi", "fbm", "pattern"], "likes": 4, "viewed": 92, "date": "1572063757", "time_retrieved": "2024-06-20T19:46:24.507823", "image_code": "vec3 _Color0 = vec3(0.8773585, 0.1983112, 0.06207722);\nvec3 _Color1 = vec3(0.9150943, 0.7658796, 0.07338018);\nvec3 _Color2 = vec3(0.3417617, 0.06608219, 0.9339623);\n\nvec2 scale_center(vec2 st, float a){\n    st -= .5;\n    st = mat2(a, 0, 0, a) * st;\n    st += .5;\n    return st;\n}\n\nvec2 rotate(vec2 st, float a){\n    return mat2(cos(a), -sin(a), sin(a), cos(a)) * st;\n}\n\nfloat poli_field(vec2 st, float n){\n    float a = atan(st.x, st.y)+3.141592;\n    float r = (3.141592 * 2.)/n;\n\n    return cos(floor(.5+a/r)*r-a) * length(st);\n}\n\nvec2 hash22(vec2 p){\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n    return -1.0 + 2.0*fract(sin(p) * 43758.5453123);\n}\n\nfloat hash21(vec2 st){\n    return fract(sin(dot(st, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise(vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 st){\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(st);\n        st = rot * st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec2 fbm2(vec2 uv, float freq, float amp){\n    float rx = (fbm(uv * freq) - .5);\n    float ry = (fbm(uv * freq + 313.666999) - .5);\n    return normalize(vec2(rx, ry)) * amp;\n}\n\nfloat voronoi(vec2 x ) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    float md = 8.0;\n    float val;\n    for (int j= -1; j <= 1; j++) {\n        for (int i= -1; i <= 1; i++) {\n            vec2 g = vec2(float(i),float(j));\n            vec2 o = hash22( n + g );\n            o = 0.5 + 0.5*sin( 6.2831*o );\n\n            vec2 r = g + o - f;\n            float d = dot(r,r);\n\n            if( d<md ) {\n                md = d;\n                val = clamp(dot(o,vec2(.3,.6)), 0., 1.);\n            }\n        }\n    }\n\n    return val;\n}\n\nfloat voronoise(vec2 uv, float rfreq, float ramp, float vfreq){\n    float rx = (fbm(uv* rfreq) - .5);\n    float ry = (fbm(uv * rfreq + 313.15843) - .5);\n    vec2 dir = normalize(vec2(rx, ry)) * ramp;\n\n    return voronoi(uv * vfreq + dir);\n}\n\nvec3 DiscreteLerp(float t){\n    return _Color0 * step(t, .33) +\n        _Color1 * step(.33, t) * step(t, .66) +\n        _Color2 * step(.66, t);\n}\n\nfloat triang(vec2 uv, float a){\n    vec2 d = rotate(vec2(0., .25), a);\n    vec2 _uv = rotate(uv - d, -a);\n    float f = poli_field(_uv * vec2(12., 6.), 3.);\n    return smoothstep(.2, .19, f);\n}\n\nvec2 rand_dir(vec2 uv, float freq){\n    float rx = (fbm(uv* freq) - .5);\n    float ry = (fbm(uv * freq + 313.15843) - .5);\n    return normalize(vec2(rx, ry));\n}\n\nfloat tooth(float x, float y){\n    float yr = fract(y * 4.);\n    y = abs(yr * 2. - 1.);\n    y = fract(y);\n    x += y * .15 + .005;\n    return step(.5, x);\n}\n\nvec3 background(vec2 uv, vec2 f0, vec2 f1, vec2 f2){\n    uv = (uv - .5) * 2.;\n\n    float f0d = length(uv - f0);\n    float ford = (1. - smoothstep(0., .4, f0d));\n\n    f0d = length(uv - f1);\n    ford += (1. - smoothstep(0., .4, f0d));\n\n    f0d = length(uv - f2);\n    ford += (1. - smoothstep(0., .4, f0d));                \n\n    uv = rotate(uv, 3.14 * ford);\n    //scroll\n    uv.y += iTime * .1;\n\n    vec3 col = vec3(0.);\n    float rs = noise(uv * 6.28) * 0.098125;\n\n    uv.x += sin((uv.y + rs) * 6.28) * 0.098125;\n    uv *= vec2(12, 1.76);\n\n    float rx = (fbm(uv* 64.) - .5);\n    float ry = (fbm(uv * 64. + 696.666999) - .5);\n    vec2 dir = normalize(vec2(rx, ry)) * 0.1;\n    col.rgb = DiscreteLerp(voronoi(uv + dir));\n    col.rgb *= pow(DiscreteLerp(voronoi(uv * 4. + dir + 313.313)), vec3(.2));\n\n    return col;\n}\n\nvec4 rage(vec2 uv, vec2 c){\n    vec2 dir = rand_dir(uv, 16.) * .0015;\n    vec2 suv = scale_center(uv, .8);\n    uv = (suv - .5 + dir) * 2. - c * 2.;\n\n    float cir = smoothstep(.2, .19, length(uv));\n\n    float tf1s = 0.;\n    float a = 0.;\n\n    for(int k=0; k<4; k++){\n        tf1s += triang(uv, a);\n        tf1s += triang(uv, a + 3.14 * .25) * 1.5;\n        a += 3.14 * .5;\n    }\n\n    float v = voronoise(uv, 64., .5, 64.);\n    v = mix(.4, .9, v);\n\n    vec4 col = vec4((cir + tf1s) * v);\n    col.rgb *= _Color0;\n    col.a = step(.1, col.r);\n    return col;\n}            \n\nvec4 sorrow(vec2 uv, vec2 c){\n    vec2 dir = rand_dir(uv, 16.) * .0015;\n\n    vec2 suv = scale_center(uv + dir, 3.14);\n    uv = (suv - .5) * 2. - c * 3.14 * 2.;\n    float cir = smoothstep(.9, .89, length(uv));\n\n    uv = suv - c * 3.14;\n\n    float t1 = tooth(uv.x, uv.y+ 0.125);\n    float t2 = tooth(1.-uv.x, uv.y);\n    float brk = 1. - t1 * t2;\n\n    float v = voronoise(uv, 64., .5, 64.);\n    v = mix(.4, .9, v);\n\n    vec4 col = vec4(cir * brk * v);\n    col.rgb *= _Color2;\n    col.a = step(.01, col.r);\n    return col;\n}\n\nvec4 reason(vec2 uv, vec2 c){\n    vec2 dir = rand_dir(uv, 16.) * .0015;\n    uv = scale_center(uv + dir- c, 3.5);\n    uv = uv * 2. - 1.;\n    float cir = smoothstep(.99, .98, length(uv));          \n    float cir2 = smoothstep(.1, .09, length(uv - vec2(0, .5)));\n    float cir3 = smoothstep(.1, .09, length(uv + vec2(0, .5)));\n\n    uv *= 1.02;\n    float x = uv.x + .5;\n    float s = sin(uv.y * 3.14);\n    float sig = sign(s);\n    float cur = abs(s) * sig;\n\n    x += cur * .33;\n    float a = clamp(step(.5, x) + .5, 0., 1.);\n\n    float re = cir * a + cir3 - cir2 * .5;\n\n    float v = voronoise(uv, 32., .5, 32.);\n    v = mix(.66, .9, v);\n\n    vec4 col = vec4(re * v);\n    col.rgb *= _Color1;\n    col.a = step(.01, re);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    uv *= 1.5;\n    uv = uv * .5 + .5;\n    \n    vec2 c = vec2(0, -.1);\n    \n    vec2 pn = vec2(.0, .25);\n    float t = iTime * -.2;\n    \n    vec2 p0 = rotate(pn, t)+c;\n    vec2 p1 = rotate(pn,  t + 4.71238898038)+c;\n    vec2 p2 = rotate(pn,  t + 4.71238898038 * 3.)+c;\n    \n    vec4 ra = rage(uv, p0);\n    vec4 re = reason(uv, p1);\n    vec4 so = sorrow(uv, p2);\n    \n    vec4 fo = ra + re + so;\n    fo.a = clamp(fo.a, .0, 1.);\n    \n    vec3 bg = background(uv, p0 * 2., p1 * 2., p2 * 2.);\n\t\n    vec4 col = fo;\n    col.rgb += bg * (1.-fo.a) * .66;\n    \n    fragColor.rgb = col.rgb;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcSD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcSRX", "name": "Shadertober 28 ride", "author": "GreenChicken", "description": "I wanted to create some basic synthwave visual and added some julia friends riding together", "tags": ["raymarching", "julia", "inktober"], "likes": 7, "viewed": 303, "date": "1572472274", "time_retrieved": "2024-06-20T19:46:25.641464", "image_code": "// SHADERTOBER 28 Ride\n// Poulet vert 30-10-2019\n// second shader based on Julia function by iq\n// thanks leon <3\n\n#define VOLUME 0.001\n#define PI 3.14159\n\n\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nvec4 qsqr( in vec4 a ) // square a quaterion\n{\n    return vec4( a.x*a.x - a.y*a.y - a.z*a.z - a.w*a.w,\n                 2.0*a.x*a.y,\n                 2.0*a.x*a.z,\n                 2.0*a.x*a.w );\n}\n\nvec4 qmul( in vec4 a, in vec4 b)\n{\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.y * b.x + a.x * b.y + a.z * b.w - a.w * b.z, \n        a.z * b.x + a.x * b.z + a.w * b.y - a.y * b.w,\n        a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y );\n\n}\n\nvec4 qconj( in vec4 a )\n{\n    return vec4( a.x, -a.yzw );\n}\n\n// iq Julia src : https://www.shadertoy.com/view/MsfGRr\nconst int numIterations = 11;\nfloat julia(vec3 p, vec4 c)\n{\n    vec4 z = vec4(p,0.0);\n    \n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n\n    float n = 1.0;\n    for( int i=0; i<numIterations; i++ )\n    {\n        md2 *= mz2;\n        z = qsqr(z) + c;  \n        mz2 = dot(z,z);\n        if(mz2>4.0) break;\n        n += 1.0;\n    }\n    \n    return 0.1*sqrt(mz2/md2)*exp2(-n)*log(mz2);\n}\n\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n\n// Scene setup\nvec2 map(vec3 p)\n{\n    // ground\n    vec3 gp = p + vec3(0.0);\n    gp.y += sin(p.z+iTime*5.)*sin(p.x*5.)*.1;\n    float d = gp.y;\n    \n    // sun\n    vec3 cp = p + vec3(0.0, -2.0, -30.0);\n    float c = sdSphere(cp,  5.);\n    \n    // moutain\n    vec3 mp = p + vec3(0.0, -0.5, -20.0);\n    mp = opRep(mp, vec3(1.0, 0.0, 0.0));\n    mp.y += sin(p.x*4.)*.2;\n    mp.y += abs(p.x)*.2;\n    float m = sdSphere(mp, 1.5);\n    \n    // julia\n    vec3 jp = p + vec3(sin(iTime), -2.0, cos(iTime)*2.0);\n    float j = julia(jp, vec4(.5+abs(sin(p.z+iTime)), p.y, .5, p.z));\n    \n    // julia 2\n    jp = p + vec3(sin(iTime+2.0), -2.0, cos(iTime)*2.0+1.0);\n    j = min(j, julia(jp, vec4(.5+abs(sin(p.z+iTime)), p.y, .5, p.x)));\n    \n    \n    // materials\n    vec2 scene = vec2(d, 0.0);\n    scene = opU2(scene, vec2(c, 1.0));\n    scene = opU2(scene, vec2(m, 2.0));\n    scene = opU2(scene, vec2(j, 3.0));\n    \n    return scene; \n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\n\nvec3 GetNormal (vec3 p)\n{\n    float c = map(p).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p+e.xyy).x, map(p+e.yxy).x, map(p+e.yyx).x) - c);\n}\n\n\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv, float time)\n{\n    \n    \n    // map stuffs\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(fract(iTime), vec3(.5), vec3(1.0), vec3(1.0), vec3(0.67, 0.33, 0.0));\n    \n    vec3 nor = GetNormal(pos);\n    vec3 light = vec3(0.0, 1.0, -5.0);\n    float l = clamp(dot(nor, light), 0.0, 1.0);\n    \n    if(t.x == -1.0)\n    {\n        vec3 ramp = mix(vec3(1.0, 0.0, 0.5), vec3(0.0,  0.0, 1.0), max(uv.y, 0.0));\n        ramp *= ramp;\n        ramp *= uv.y;\n        ramp = clamp(ramp, 0.0, 1.0);\n        ramp *= abs(uv.y)*-1.+.5;\n        \n        col = ramp;\n    }\n    else\n    {   \n        if(t.y==0.0) // ground grid\n        {\n            vec2 groundPos = pos.xz;\n            groundPos.y += time;\n            \n            // first version\n            //float grid = clamp(step(fract(groundPos.x*1.), .05) + step(fract(groundPos.y*1.), .05), 0.0, 1.0);\n            \n            // edit thanks to ocb\n            float grid = max(.1/(abs(fract(groundPos.x)-.5)+.1) + .1/(abs(fract(groundPos.y)-.5)+.1)-.5,0.);\n            \n            col = vec3(0.0, 0.0, 1.0) * grid;\n            col *= clamp(-pos.z*.01+.1, 0.0, 1.0)*10.;\n        }\n        else if(t.y==1.0) // sun\n        {\n            col = mix(vec3(1.0, .0, .3), vec3(0.0, .5, 1.0), uv.y*3.0-.3);\n        }\n        else if(t.y==2.0) // black\n        {\n            col = vec3(0.0);\n        }\n        else if(t.y==3.0) // shape\n        {\n            col = vec3(1.0, .0, .3) * l + fract(iTime*5.0);\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(sin(iTime)*.2, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    float time = iTime * 5.0;\n    \n    \n    vec3 cp = vec3(sin(iTime)*.1, 1.0+sin(iTime)*.2, -5.0);\n    vec3 ct = vec3(0.0, 1.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, uv, time);\n    \n    col.b -= uv.y*.2;\n    col *= clamp(1.0-length(uv*.75), 0.0, 1.0);\n    \n    \n    \n    col = sqrt(clamp(col, 0.0, 1.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcSRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcSWN", "name": "FVM - Smooth Union", "author": "dfactor", "description": "Another try of Functional Voxel Modeling with MSAA", "tags": ["sdf", "csg", "normal", "fvm", "mdi"], "likes": 4, "viewed": 153, "date": "1571968759", "time_retrieved": "2024-06-20T19:46:26.247644", "image_code": "// Old variant\n/*float circle(vec2 uv, vec2 center, float radius) {\n    return (uv.x-center.x)*(uv.x-center.x) + (uv.y-center.y)*(uv.y-center.y) - radius*radius;\n}*/\n\nfloat circle(vec2 uv, vec2 center, float radius) {\n    return length(uv-center)*length(uv-center) - radius*radius;\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b) {\n    return ((b.y-a.y)*uv.x + (a.x-b.x)*uv.y + (b.x*a.y-a.x*b.y))/sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));\n}\n\nfloat sum(float a, float b, float alpha) {\n    return (a+b+sqrt(a*a + b*b - 2.0*alpha*a*b))*(1.0/(1.0+alpha));\n}\n\nfloat mul(float a, float b, float alpha) {\n    return (a+b-sqrt(a*a + b*b - 2.0*alpha*a*b))*(1.0/(1.0+alpha));\n}\n\n// Smooth multiply\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat sminCubic( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// Our FV model\nfloat map(vec2 uv, float alpha) {\n    vec2 pos1 = vec2(-cos(iTime*1.5)/1.5, -sin(iTime*1.5)/1.5);\n    vec2 pos2 = vec2(sin(iTime)/3.0, cos(iTime)/3.0);\n    vec2 pos3 = vec2(0.0, -sin(iTime*2.0)/6.0);\n    \n    /*return mul(\n        circle(uv, vec2(0.,0.), 0.3),\n        mul(\n            circle(uv, pos1, 0.3),\n            circle(uv, pos2, 0.3),\n            alpha),\n        alpha\n    );*/\n    \n    return sminCubic(\n    \tcircle(uv, vec2(0.,0.), 0.3),\n        sminCubic(\n            circle(uv, pos1, 0.3),\n            circle(uv, pos2, 0.3),\n            0.2\n        ),\n        0.2\n    );\n}\n\n// Faster MDI\nvec4 mdi_v2(vec2 uv1, vec2 uv2, vec2 uv3, float value1, float value2, float value3) {\n    vec2 a2 = uv3 - uv1;\n    vec2 b2 = uv2 - uv1;\n    \n    vec3 a3 = vec3(a2.x, a2.y, value1-value3);\n    vec3 b3 = vec3(b2.x, b2.y, value2-value1);\n    \n    vec3 Nxyz = cross(a3, b3);\n    \n    float D = uv1.x*(uv2.y*value3-uv3.y*value2)-uv2.x*(uv1.y*value3-uv3.y*value1)+uv3.x*(uv1.y*value2-uv2.y*value1);\n    \n    vec4 N = normalize(vec4(Nxyz, D));\n    \n    int flag1 = 0;\n    int flag2 = 0;\n    int flag3 = 0;\n    if (value1>=0.0) flag1 = 1;\n    if (value2>=0.0) flag2 = 1;\n    if (value3>=0.0) flag3 = 1;\n    \n    int flag_sum = flag1 + flag2 + flag3;\n    if (flag_sum < 2) return (N + vec4(1.,1.,1.,1.)) / 2.; //fit to [0;1]\n    return vec4(0.5, 0.5, 1.0, 0.0); //+Z normal\n}\n\nvec4 calcImage(vec2 uv, float alpha) {\n    vec2 uv1 = uv;\n    vec2 uv2 = vec2(uv.x, uv.y+0.005);\n    vec2 uv3 = vec2(uv.x+0.005, uv.y);\n    \n    float value1 = map(uv1, alpha);\n    float value2 = map(uv2, alpha);\n    float value3 = map(uv3, alpha);\n    \n    return mdi_v2(uv1, uv2, uv3, value1, value2, value3);\n}\n\nvec4 render(vec2 uv, float alpha) {\n    float offset = iResolution.x / iResolution.y / 512.0;\n    \n    return (\n        calcImage(uv-offset*vec2(-0.5,-0.5), alpha) +\n        calcImage(uv-offset*vec2(-0.5,0.5), alpha) +\n        calcImage(uv-offset*vec2(0.5,-0.5), alpha) +\n        calcImage(uv-offset*vec2(0.5,0.5), alpha)\n    )/4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 vUV = fragCoord.xy / iResolution.xy;\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n    vec4 value = render(vWindow, 0.0);\n    vec3 col = vec3(value.x, value.y, value.z);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcXR7", "name": "Bones tracing", "author": "levonchic", "description": "Falling bones in distance tracing", "tags": ["tracing", "bones", "distancetracing"], "likes": 0, "viewed": 35, "date": "1571665311", "time_retrieved": "2024-06-20T19:46:26.896167", "image_code": "#define PI  3.14159265359\n#define PI0 6.28318530718\n#define PI2 1.57079632679\n#define PI4 0.78539816339\n\n// #define FAST\n#define ROTATION\n#define SCALE 6.0\n\n// SQRT\nfloat circle(vec2 v, vec2 center, float radius) {\n    return distance(v, center) - radius;\n}\n\nfloat circle_check(vec2 v, vec2 center, float radius, float a, float b, float far) {\n    vec2 dir = v - center;\n    float angle = PI + atan(dir.x, dir.y);\n    \n    if (a < 0.0) {\n        if (b < 0.0) {\n            if (angle < a + 2.0 * PI || angle > b + 2.0 * PI)\n                return far;\n        } else {\n            if (angle < a + 2.0 * PI && angle > b)\n                return far;\n        }\n    } else if (angle < a || angle > b)\n        return far;\n    \n    return length(dir) - radius;\n}\n\nfloat round_segment_check(vec2 v, vec2 A, vec2 B, float far) {\n    vec2 b = B - A;\n    vec2 a = v - A;\n    float frac = dot(a, b) / dot(b, b);\n    if (frac < 0.0)\n        return distance(v, A);\n    if (frac > 1.0)\n        return distance(v, B);\n    \n    vec2 n  = B - A;\n    vec2 va = A - v;\n    vec2 c  = n * dot(va, n) / dot(n, n);\n    return length(va - c);\n}\n\nvec4 color(float dist) {\n   vec4 c;\n    c.a = 1.0;\n    c.r = c.g = c.b = 1. / pow(2.0 + 0.2 * sin(mod(iTime, PI) * 4.0), dist * 60.);\n    c.r *= 0.962745098;\n    c.g *= 0.939215686;\n    c.b *= 0.903921569;\n    \n    return c;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {    \n    fragCoord.xy = SCALE * fragCoord.xy + vec2(iTime * 500., iTime * 1000.);\n    vec2 quarantOffset = round((fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xy);\n    \n    fragCoord += cos(quarantOffset.yx * PI + mod(iTime, PI) * 4.) * iResolution.yx * 0.04;\n    fragCoord.xy = mod(fragCoord.xy, iResolution.xy);\n    \n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    // Scale to fit light\n    uv *= 1.5;\n    uv.y -= 0.017;\n    \n    bool qX = (int(quarantOffset.x) & 1) == 0;\n    bool qY = (int(quarantOffset.y) & 1) == 0;\n    \n    // Invert coords\n    if (qX) \n        uv.y = -uv.y;\n    \n    if (qY) \n        uv.x = -uv.x;\n\n#ifdef ROTATION\n    // Rotation\n    float s = cos((qX && qY ? 1.0 : -1.0) * mod(iTime, PI) * 4.);\n    float c = sin((qX && qY ? 1.0 : -1.0) * mod(iTime, PI) * 4.);\n    mat2 m = mat2(c, -s, s, c);\n    uv = m * uv;\n#endif\n\n#ifdef FAST\n    float d0 = round_segment_check(uv, vec2(0.0, 0.1), vec2(0.1,  0.0), 10.0);\n    float d1 = round_segment_check(uv, vec2(-0.1, 0.0), vec2(0.0, -0.1), 10.0);\n\t\n    float d2 = abs(circle(uv, vec2(0.1 * sqrt(2.0) / 2.0 + 0.1, -0.1 * sqrt(2.0) / 2.0), 0.1)); \n    float d3 = abs(circle(uv, vec2(0.1 * sqrt(2.0) / 2.0, -0.1 * sqrt(2.0) / 2.0 - 0.1), 0.1));\n    \n    float d22 = abs(circle(uv, -vec2(0.1 * sqrt(2.0) / 2.0 + 0.1, -0.1 * sqrt(2.0) / 2.0), 0.1)); \n    float d32 = abs(circle(uv, -vec2(0.1 * sqrt(2.0) / 2.0, -0.1 * sqrt(2.0) / 2.0 - 0.1), 0.1));\n#else\n    float d0 = round_segment_check(uv, vec2(0.0, 0.1), vec2(0.1,  0.0), 10.0);\n    float d1 = round_segment_check(uv, vec2(-0.1, 0.0), vec2(0.0, -0.1), 10.0);\n    \n    float d2 = abs(circle_check(uv, vec2(0.1 * sqrt(2.0) / 2.0 + 0.1, -0.1 * sqrt(2.0) / 2.0), 0.1, -5.0 * PI4, 0.0, 10.0)); \n    float d3 = abs(circle_check(uv, vec2(0.1 * sqrt(2.0) / 2.0, -0.1 * sqrt(2.0) / 2.0 - 0.1), 0.1, -PI2, 3.0 * PI4, 10.0));\n    float d23 = abs(circle(uv, vec2(0.1 + 0.1 * sqrt(2.0) / 2.0, -0.1 - 0.1 * sqrt(2.0) / 2.0), 0.0));\n    \n    float d22 = abs(circle_check(uv, -vec2(0.1 * sqrt(2.0) / 2.0 + 0.1, -0.1 * sqrt(2.0) / 2.0), 0.1, -PI4, PI, 10.0)); \n    float d32 = abs(circle_check(uv, -vec2(0.1 * sqrt(2.0) / 2.0, -0.1 * sqrt(2.0) / 2.0 - 0.1), 0.1, PI2, 7.0 * PI4, 10.0));\n    float d232 = abs(circle(uv, -vec2(0.1 + 0.1 * sqrt(2.0) / 2.0, -0.1 - 0.1 * sqrt(2.0) / 2.0), 0.0));\n#endif\n    \n    //float d5 = segment_check(uv, vec2(-0.5, -0.28), vec2( 0.5, -0.28), 10.0);\n    //float d6 = segment_check(uv, vec2( 0.5, -0.28), vec2( 0.5,  0.28), 10.0);\n    //float d7 = segment_check(uv, vec2( 0.5,  0.28), vec2(-0.5,  0.28), 10.0);\n    //float d8 = segment_check(uv, vec2(-0.5,  0.28), vec2(-0.5, -0.28), 10.0);\n    \n    float mn = min(d0, d1);\n          mn = min(mn, d2);\n          mn = min(mn, d3);\n          mn = min(mn, d22);\n          mn = min(mn, d32);\n#ifndef FAST\n          mn = min(mn, d23);\n          mn = min(mn, d232);\n#endif\n\t\t  \n    //      mn = min(mn, d5);\n    //      mn = min(mn, d6);\n    //      mn = min(mn, d7);\n    //      mn = min(mn, d8);\n    \n    fragColor = color(mn);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcXR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcXRj", "name": "2019-10-29 waves", "author": "sinclav", "description": "study: waves by sines", "tags": ["2d"], "likes": 0, "viewed": 104, "date": "1572357773", "time_retrieved": "2024-06-20T19:46:27.072028", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvc = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float t = iTime;\n    uvc *= 9.678;\n\n    float c = 0.0;\n    float v1 = cos(uvc.x+sin(t*1.231234))+sin(1.4239234*uvc.y+t);\n    float v2 = sin(sin(uvc.x)+t)+sin(sin(2.4239234*uvc.y)+t);\n    float v3 = sin(3.3238*sin(distance(uv, uvc)+t/0.3));\n    c = sin(v1 + v2 + v3) * 0.8 + 0.5;\n    \n    float res = 0.0;\n    for (int i=1; i<=3; i++) {\n        float l = float(i);\n        float w = 0.02;\n    \tres += l < c && c < l + w ? 1.0 : 0.0;\n    }\n\n    fragColor = vec4(vec3(res), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcXz4", "name": "Phillips spectrum(correct versio", "author": "mgjunior", "description": "Phillips spectrum(correct version)", "tags": ["spectrum"], "likes": 0, "viewed": 25, "date": "1571538088", "time_retrieved": "2024-06-20T19:46:27.726420", "image_code": "#define Gently_flapping_the_wings 1\n\n//I go formula from here\n//https://zhuanlan.zhihu.com/p/64414956\n\nconst float two_Pi =6.28;\nconst float A=2.;\nvec2 wind= vec2(1.,0.);\nconst float V=1000.;\nconst float g=9.8;\nfloat L=V*V/g;\n\nvec2 complex_multiply(vec2 c1,vec2 c2){\n    float x = c1.x;\n    float y = c1.y;\n    float a = c2.x;\n    float b = c2.y;\n    return vec2(a * x - b * y,a * y + b * x);\n}\n\nfloat random(vec2 v)\n{\n    float seed_x=1113.;\n    float seed_y=11.5;\n    return fract(sin(dot(v,vec2(seed_x,seed_y)))*43758.54534 );\n}\n\nfloat random_clamp(vec2 v){\n    // need clamp beacuse \n    // https://www.geogebra.org/m/dpvqeczu\n\treturn clamp(random(v),0.001,1.);\n}\n\n// https://www.geogebra.org/m/dpvqeczu\nvec2 gaussian_distribution(vec2 u){\n    float u1=u.x;\n    float u2=u.y;\n    \n    // Box-Muller\n    // https://zhuanlan.zhihu.com/p/67776340\n    float r =sqrt(-2.*log(u1));\n    return vec2(r*cos(two_Pi*u2),r*sin(two_Pi*u2));\n}\n\n// https://zhuanlan.zhihu.com/p/64414956\nfloat Pn(vec2 k,float K){\n    float K2 =K*K;\n    float KL =K*L;\n    float dot_k_wind=abs(dot(k,wind));\n    return  A/(K2*K2) * exp(-1./(KL*KL)) * dot_k_wind * dot_k_wind;\n}\n\nvec2 h0(vec2 k,vec2 E,float K){\n    float S =sqrt(Pn(k,K)/2.);\n    //return vec2(S);\n\treturn S*E;\n}\n\nvec2 h0_conjugate(vec2 k,vec2 E,float K){\n    vec2 c_h0=h0(k,E,K);\n    return vec2(c_h0.x,-c_h0.y);\n}\n\nfloat w(float k){\n\treturn sqrt(g*k);\n}\n\nvec2 e_i(float x){\n\treturn vec2(cos(x),sin(x));\n}\n\n// n 0.~1.\nvec2 h(vec2 n,vec2 k,float t){\n \n    \n#if Gently_flapping_the_wings\n    //static,now this butterfly is Gently flapping her wings\n\tvec2 t1=k;\n#else\n    \n    // dynamic,this butterfly is powerfully flapping her wing\n    // use this version to do inverse of FFT, will get interesting result\n    vec2 t1=k+t;\n#endif\n    \n    float range =10.;\n    vec2 offset1 =mod(t1,range);\n    vec2 offset2 =mod(t1+vec2(0.45,0.99),range);\n    vec2 offset3 =mod(t1+vec2(0.15,-0.6),range);\n    vec2 offset4 =mod(t1+vec2(-0.9,0.01),range);\n    \n    \n    vec2 E1=gaussian_distribution(vec2(random_clamp(offset1),random_clamp(offset2)));\n    vec2 E2=gaussian_distribution(vec2(random_clamp(offset3),random_clamp(offset4)));\n    \n    //return offset1;\n    //return vec2(random(offset1));\n    //return E2;    \n    \n    float K=length(k);\n    K=(K>0.0001)?K:0.0001;\n    //return e_i(-w(K)*t);\n    //return complex_multiply(h0(k,E1,K) , e_i(w(K)*t));\n    //return complex_multiply(h0_conjugate(-k,E2,K) , e_i(-w(K)*t));\n    return complex_multiply(h0(k,E1,K) , e_i(w(K)*t))\n\t+complex_multiply(h0_conjugate(-k,E2,K) , e_i(-w(K)*t));     \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;// maybe (ratio,1.);\n   \tvec2 offset =iResolution.xy/iResolution.yy;\n    \n    // Output to screen\n    float t=(two_Pi*iTime);\n    vec2 k = uv*2.-offset;// y to -1~1, x to -ratio~ratio\n    k*=0.5;\n    \n    \n    if(k.x>1. || k.x<-1.)\n        fragColor=vec4(0.,0.,0.,1.);\n    else    \n    \tfragColor = vec4(h(uv.xy,k,t),0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcXz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcXzS", "name": "simple 2d circle waves", "author": "jt", "description": "Simple waves generated by combining rotating circles.", "tags": ["2d", "waves", "water", "circle"], "likes": 5, "viewed": 151, "date": "1572257875", "time_retrieved": "2024-06-20T19:46:27.726618", "image_code": "//  Noise - value - 3D by iq (https://www.shadertoy.com/view/4sfGzS)\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n//  Noise - value - 3D by iq (https://www.shadertoy.com/view/4sfGzS)\nfloat noise(in vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n#define pi 3.1415926\n#define tau (2.0 * pi)\n\n#define N 5.0\n\nfloat STEP(float x, float y)\n{\n    float o = 1.0 / iResolution.y;\n    return smoothstep(x - o, x + o, y);\n}\n\nfloat water(in vec2 v)\n{\n    float r = 1.5 / N;\n    float s = 1.0;\n\n    for(float i = 0.0; i < N; i++)\n    {\n        vec2 c = vec2(iResolution.x / iResolution.y * (i + 0.5) / N, 0.5);\n        float phase = tau * noise(vec3(i, 0.0, 0.0));\n        float amp = 1.0;\n        vec2 o = vec2(cos(iTime + phase), sin(iTime + phase)) / N;\n        c += 0.1 * o;\n\n        s = min(s, STEP(r, length(v - c)));\n        s = min(s, max(STEP(r, abs(v.x - c.x)), STEP(v.y, c.y)));\n    }\n    \n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v = fragCoord/iResolution.y;\n    vec2 v1 = (fragCoord + vec2(0.0, 2.0))/iResolution.y;\n\n    float s = water(v);\n    float s1 = water(v1);\n    float l = s - s1;\n\n    //fragColor = vec4(l);\n    //fragColor = vec4(s);\n    //vec4 sky = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.0, 0.0, 1.0, 1.0), v.y);\n    //vec4 sky = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.0, 0.0, 0.5, 1.0), v.y);\n    vec4 sky = mix(vec4(1.0, 1.0, 0.5, 1.0), vec4(1.0, 0.25, 0.0, 1.0), v.y);\n    float sun = STEP(length(v - vec2(0.5, 0.3)), 0.05);\n    sky += sun; //  * vec4(1.0, 0.8, 0.5, 1.0);\n    vec4 water = mix(vec4(0.0, 0.0, 0.5, 1.0), vec4(0.5, 1.0, 1.0, 1.0), 2.0 * v.y);\n    fragColor = mix(sky, water, s) + l * 0.5;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcXzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdd3Rl", "name": "Dancing circles", "author": "nurof3n", "description": "Sum circles fuckening", "tags": ["circles", "fx", "boom"], "likes": 10, "viewed": 155, "date": "1571130728", "time_retrieved": "2024-06-20T19:46:27.726618", "image_code": "const float nrcircles = 7.;\nconst float pi = 3.141592;\nconst vec3 color = vec3(236.0 / 255.0, 71.0 / 255.0, 140.0 / 255.0);\nconst float innerradius = 0.5;\nconst float outerradius = 0.02;\n\nvec2 shake(vec2 uv) {\n\treturn vec2(uv.x + .1*sin(1. * pow(3., pi - mod(iTime, pi))), uv.y - .1*sin(1. * pow(2.5, pi - mod(iTime, pi))));\n}\n\nfloat edge(vec2 pixel, vec2 offset, float outerradius, float innerradius) {\n    return clamp(outerradius / abs(length(pixel + offset) - innerradius), 0.0, 3.0);\n}\n\nfloat fade(float radius) {\n    return 2. - radius;\n}\n\nfloat sonicboom(vec2 uv, float radius) {\n    return edge(uv, vec2(.0), outerradius + (1. - .5*radius), radius) * fade(radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\t//centered, unstretched pixel coordinates: (0; 0) is the center of the viewport\n    pixel = shake(pixel);\n    float s;\n    float c;\n    float f;\n    for(float i = 0.0; i < nrcircles; i++){\n        s = cos(iTime + i * 2.0 * pi / nrcircles) * abs(sin(iTime)) * 0.4;\n        c = sin(iTime + i * 2.0 * pi / nrcircles) * abs(sin(iTime)) * 0.4;\n        f += edge(pixel, vec2(c, s), outerradius, innerradius);\n    }\n\n    //if(f < 1.0)\t//Clamp the color so that it stays the same value, not brightened up\n    vec3 destColor = color * f;\n    float radius = 1.*mod(iTime + .01, pi) + innerradius;\n    destColor += color * sonicboom(pixel, radius);\n    \n    // Output to screen\n    fragColor = vec4(destColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdd3Rl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tddSR8", "name": "PIÑERA_QL", "author": "bitnenfer", "description": "piñera culiao! :3", "tags": ["pineraql"], "likes": 4, "viewed": 102, "date": "1571461074", "time_retrieved": "2024-06-20T19:46:27.726618", "image_code": "float box(vec2 p, vec2 b){vec2 q = abs(p) - b;return length(max(q,0.0)) + min(max(q.x,q.y),0.0);}\nmat2 rot(float r){float c = cos(r), s = sin(r);return mat2(c,s,-s,c);}\n\nfloat pinera_ql(vec2 uv)\n{\n    const float w = 0.01;\n    const float h = 0.3;\n    float d = 100.0;    \n    vec2 pinera_ql_centro = vec2(0.15, 0.0);\n    vec2 p = pinera_ql_centro + vec2(1.0, 0.0);\n    d = min(d, box(uv + p - vec2(0.0, 0.0), vec2(w, h)));\n    d = min(d, box(uv + p - vec2(0.1, 0.29), vec2(h / 3.0, w)));\n    d = min(d, box(uv + p - vec2(0.1, -0.0), vec2(h / 3.0, w)));\n    d = min(d, box(uv + p - vec2(0.2, 0.15), vec2(w, h / 2.0)));    \n    vec2 i = pinera_ql_centro + vec2(0.7, 0.0);\n    d = min(d, box(uv + i - vec2(0.0, 0.0), vec2(w, h)));    \n    vec2 n = pinera_ql_centro + vec2(0.6, 0.0);\n    d = min(d, box(uv + n - vec2(0.0, 0.0), vec2(w, h)));\n    d = min(d, box((uv + n - vec2(0.09, 0.0)) * rot(0.3), vec2(w, h)));\n    d = min(d, box(uv + n - vec2(0.18, 0.0), vec2(w, h)));\n    d = max(d, -box(uv + n - vec2(0.1, 0.29), vec2(0.17, w*10.0)));\n    d = min(d, box(uv + n - vec2(0.09, 0.29), vec2(h/3., w)));    \n    vec2 e = pinera_ql_centro + vec2(0.32, 0.0);\n    d = min(d, box(uv + e - vec2(0.0, 0.0), vec2(w, h)));\n    d = min(d, box(uv + e - vec2(0.1, 0.29), vec2(h / 3.0, w)));\n    d = min(d, box(uv + e - vec2(0.1, -0.0), vec2(h / 3.0, w)));\n    d = min(d, box(uv + e - vec2(0.1, -0.29), vec2(h / 3.0, w)));    \n    vec2 r = pinera_ql_centro + vec2(0.03, 0.0);\n    d = min(d, box(uv + r - vec2(0.0, 0.0), vec2(w, h)));\n    d = min(d, box(uv + r - vec2(0.1, 0.29), vec2(h / 3.0, w)));\n    d = min(d, box(uv + r - vec2(0.1, -0.0), vec2(h / 3.0, w)));\n    d = min(d, box(uv + r - vec2(0.2, 0.15), vec2(w, h / 2.0)));\n\td = min(d, box((uv + r - vec2(0.155, -0.145)) * rot(0.3), vec2(w, h / 1.9)));    \n    vec2 a = pinera_ql_centro + vec2(-0.27, 0.0);\n    d = min(d, box(uv + a - vec2(0.0, 0.0), vec2(w, h)));\n    d = min(d, box(uv + a - vec2(0.1, 0.29), vec2(h / 3.0, w)));\n    d = min(d, box(uv + a - vec2(0.1, -0.0), vec2(h / 3.0, w)));\n    d = min(d, box(uv + a - vec2(0.2, 0.0), vec2(w, h)));    \n    vec2 _ = pinera_ql_centro + vec2(-0.55, 0.29);\n    d = min(d, box(uv + _ - vec2(0.1, -0.0), vec2(h / 4.0, w)));    \n    vec2 q = pinera_ql_centro + vec2(-0.83, 0.0);\n    d = min(d, box(uv + q - vec2(0.0, 0.0), vec2(w, h)));\n    d = min(d, box(uv + q - vec2(0.1, 0.29), vec2(h / 3.0, w)));\n    d = min(d, box(uv + q - vec2(0.1, -0.29), vec2(h / 3.0, w)));\n    d = min(d, box(uv + q - vec2(0.2, 0.0), vec2(w, h)));\n    d = min(d, box((uv + q - vec2(0.18, -0.26)) * rot(0.6), vec2(w, h / 4.0)));    \n    vec2 l = pinera_ql_centro + vec2(-1.134, 0.0);\n    d = min(d, box(uv + l - vec2(0.0, 0.0), vec2(w, h)));\n    d = min(d, box(uv + l - vec2(0.1, -0.29), vec2(h / 3.0, w)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float s = 0.01;\n    const float x = 2.69;\n    vec2 uv = (fragCoord *2. - iResolution.xy )  /iResolution.y;\n    vec2 rep = vec2(0.0, 0.35);\n    uv *= rot(sin(iTime*0.2)*0.5);\n    uv *= 0.5+abs(sin(iTime*0.3)*0.4);\n    uv = mod(uv, rep) - rep * 0.5; \n\tuv.x += iTime;\n    uv *= 2.0;\n    uv.x = mod(uv.x-x,2.7)-1.5;\n    float b = pinera_ql(uv);\n    float st = smoothstep(0.,4./iResolution.y,b-s);\n    fragColor = vec4(mix(vec3(1.0, 1.0, 0.85), vec3(0.76,0.121,0.121), st),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tddSR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tddSzH", "name": "Rift 2", "author": "peterszerzo", "description": "Second rift experiment with eerie bright colors and a cold passive background", "tags": ["gradient", "rift"], "likes": 0, "viewed": 54, "date": "1571651808", "time_retrieved": "2024-06-20T19:46:27.726618", "image_code": "vec3 hsvToRgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float pi = 3.1415926535897932384;\n\nmat2 rotation ( in float _angle ) {\n    return mat2(\n        cos(_angle), sin(_angle),\n    \t-sin(_angle), cos(_angle)\n    );\n}\n\nfloat angle(in vec2 pos) {\n    if (abs(pos.x) < 0.0001) {\n        if (pos.y >= 0.0) {\n            return pi / 2.0;\n        }\n        if (pos.y < 0.0) {\n            return -pi / 2.0;\n        }\n    }\n    return atan(pos.y, pos.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.75;\n    \n    vec2 uv0 = (fragCoord  - 0.5* iResolution.xy ) / iResolution.y;\n    \n    vec2 uv = rotation(pi * 0.75) * uv0;\n    \n    float theta = angle(uv) * 5.2 / pi;\n    \n    float uvrX = 19.0 * pow(\n        length(uv),\n        0.8\n    );\n    \n    vec2 uvr = vec2(\n        uvrX,\n        theta * 5.0 + 3.2 * sin(uvrX + 4.0 + time)\n    );\n    \n    vec3 color1 = hsvToRgb(vec3(\n        0.79,\n        0.70,\n        0.65\n    ));\n    \n    vec3 color2 = hsvToRgb(vec3(\n        0.9,\n        0.85,\n        0.35\n    ));\n  \n    // Inside gradient\n    if (uvr.x < 7.0) {\n        fragColor = vec4(mix(\n            color1,\n            color2,\n            0.5 + 0.5 * sin(uvr.x * 0.5 + uvr.y * 0.2)\n        ), 1.0);\n        return;\n    }\n\n    fragColor = vec4(mix(\n        vec3(0.12, 0.1, 0.15) * 1.05,\n        vec3(0.05) * 1.5,\n        0.5 + 0.5 * sin(\n            -uv0.x * 10.0 +\n            -uv0.y * 10.0 +\n            -15.0 * uv0.x * uv0.y +\n            -time * 0.5\n        )\n    ), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tddSzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tddXD7", "name": "puzzleZZLE", "author": "foran", "description": "puzzleZZLE", "tags": ["puzzlezzle"], "likes": 9, "viewed": 112, "date": "1572203939", "time_retrieved": "2024-06-20T19:46:27.726618", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nvec3 hsv(in float h, in float s, in float v) {\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    vec3 p=vec3(fragCoord.xy/1.67/iResolution.y,.50)/1.;\n\tvec4 color = vec4(0);\n\tfloat m = 1.50;\n\tfloat t = iTime*0.1;\n\tvec2 c = vec2(sin(t), cos(t));\n\tfloat n = 18.5;\n\tconst int iter = 2;\n\tfor (int i = 0; i < iter; i++) {\n\t\tfloat l=max(abs(p.x-p.z), max(abs(p.y-p.z), abs(p.z-p.x)));\n\t\tm *= smoothstep(0.0, 1.0, l);\n\t\tp /= l*0.2;\n\t\tp.xy = vec2(atan(c.x*c.y)*p.x - acos(c.x)*p.y, asin(c.x)*p.y-acos(c.x)*p.x);\n\t\tp.xz = vec2(atan(c.x*c.y)*p.x - acos(c.y)*p.z, asin(c.y)*p.z-acos(c.y)*p.x);\n\t\tp = abs(mod((p), n)-n/2.0);\n\t    color+=vec4(.5+.5*sin(iTime*7./8.+l), .5+.5*cos(iTime*11./8.+l), .5+.5*cos(iTime*13./8.+l),1.);\t\n\t\tcolor *= vec4(hsv(l, l, l), 1.);\n\t}\n\n\tfragColor = vec4( color/float(iter) )*m;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tddXD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tddXR4", "name": "Voodoo", "author": "lsdlive", "description": "Volumetric raymarching for Cookie fanzine #003 with theme \"anaglyph\".\nUse your red/blue glass to see this in 3D!", "tags": ["raymarching", "volumetric", "stereoscopic"], "likes": 17, "viewed": 591, "date": "1571599357", "time_retrieved": "2024-06-20T19:46:28.605494", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nVoodoo.\n\nVolumetric raymarching for Cookie fanzine #003 with theme \"anaglyph\".\nUse your red/blue glass to see this in 3D!\n\nMore about volumetric raymarching: https://www.shadertoy.com/view/wd3GWM\n\nSome notation:\np: position (usually in world space)\nrd: ray direction (eye or view vector)\n*/\n\n// Enable/disable animation & anaglyph (3D effect)\n#define ANIMATE\n#define ANAGLYPH\n\n#define PI 3.14159\n#define TAU 6.28318\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// iq's noise\nfloat noise(in vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3. - 2. * f);\n\tvec2 uv = (p.xy + vec2(37., 17.) * p.z) + f.xy;\n\tvec2 rg = textureLod(iChannel0, (uv + .5) / 256., 0.).yx;\n\treturn -1. + 2.4 * mix(rg.x, rg.y, f.z);\n}\n\n// Fbm\nfloat fbm(vec3 p) {\n\treturn noise(p * .06125) * .5 + noise(p * .125) * .25 + noise(p * .25) * .125;\n}\n\n// Dodecahedron folding\n// checkout: https://www.shadertoy.com/view/wtsGzl\nvec3 fold(vec3 p) {\n\tvec3 nc = vec3(-.5, -.809017, .309017);\n\tfor (int i = 0; i < 5; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2. * min(0., dot(p, nc))*nc;\n\t}\n\treturn p - vec3(0, 0, 1.275);\n}\n\nfloat sdf_crystal(vec3 p, float scale) {\n\tvec3 fp = fold(p * scale);\n\tfloat cryst = dot(fp, normalize(sign(fp))) - .1 - sin(fp.y*.2)*2. - sin(fp.y*.7)*1.;\n\tcryst += min(fp.x*1., sin(fp.y*.3));\n\n\tfp = fold(fp) - vec3(.2, .57, -.2);\n\tfp = fold(fp) - vec3(-.14, .99, -2.4);\n\tfp = fold(fp) - vec3(-.03, 1., -.3);\n\tfp = fold(fp) - vec3(0, .26, 0);\n\tcryst += sin(fp.y*.18)*5.;\n\tcryst *= .6;\n\n\treturn cryst / scale;\n}\n\nfloat sdf_mask(vec3 p) {\n\tp.x = abs(p.x) - .28;\n\n\tp.xz *= r2d(.56);\n\tp.xy *= r2d(-.01);\n\n\treturn sdf_crystal(p, 3.);\n}\n\nfloat de(vec3 p) {\n\n#ifdef ANIMATE\n\tp.xy *= r2d(sin(iTime)*.3);\n\tp.xz *= r2d(sin(iTime*2.)*.12);\n\tp.xy *= r2d(sin(sin(iTime * 2.) * 2.) * .2);\n\tp.x += sin(iTime*2.)*.9;\n#endif\n\n\treturn sdf_mask(p * .1) / .1 + fbm(p * 35.) * .1;\n}\n\nvec3 camera(vec3 ro, vec3 ta, vec2 uv) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = normalize(cross(vec3(0, 1, 0), fwd));\n\tvec3 up = normalize(cross(fwd, left));\n\treturn normalize(fwd + uv.x * left + up * uv.y);\n}\n\nfloat raymarch(vec3 ray_ori, vec2 uv) {\n\tvec3 target = vec3(0);\n\tvec3 ray_dir = camera(ray_ori, target, uv);\n\tvec3 pos = ray_ori;\n\n\t// local density/distance\n\tfloat ldensity = 0.;\n\n\t// accumulation color & density\n\tvec4 sum = vec4(0.);\n\n\tfloat tmax = 25.;\n\tfloat tdist = 0., dist = 0.;\n\n\tfor (float i = 0.; (i < 1.); i += 1. / 64.) {\n\n\t\tif (dist < tdist * .001 || tdist > tmax || sum.a > .95)\n\t\t\tbreak;\n\n\t\t// evaluate distance function\n\t\tdist = de(pos) * .59;\n\n\t\t// check whether we are close enough (step)\n\t\t// compute local density and weighting factor \n\t\tconst float h = .05;\n\t\tldensity = (h - dist) * step(dist, h);\n\n\t\tvec4 col = vec4(1);\n\t\tcol.a = ldensity;\n\n\t\t// pre-multiply alpha\n\t\t// checkout: https://www.shadertoy.com/view/XdfGz8\n\t\t// http://developer.download.nvidia.com/assets/gamedev/files/gdc12/GDC2012_Mastering_DirectX11_with_Unity.pdf\n\t\tcol.rgb *= col.a;\n\t\tsum += (1. - sum.a) * col;\n\n\t\t// from duke/las\n\t\tsum.a += .004;\n\n\t\t// enforce minimum stepsize\n\t\tdist = max(dist, .03);\n\n\t\t// step forward\n\t\tpos += dist * ray_dir; // sphere-tracing\n\t\ttdist += dist;\n\t}\n\n\t// from duke/las\n\t// simple scattering approximation\n\tsum *= 1. / exp(ldensity * 3.) * 1.25;\n\n\tsum.r = pow(sum.r, 2.15);\n\tsum.r -= texture(iChannel0, uv * 6.).r * .18;\n\n\treturn sum.r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tfloat rotation_delta = 1.57;\n\tfloat z_dst = -19.5;\n\n#ifdef ANAGLYPH\n\trotation_delta -= .02;\n#endif\n\n\tvec3 ro1 = vec3(z_dst * cos(rotation_delta), 0, z_dst * sin(rotation_delta));\n\n#ifdef ANAGLYPH\n\trotation_delta += .04;\n#endif\n\n\tvec3 ro2 = vec3(z_dst * cos(rotation_delta), 0, z_dst * sin(rotation_delta));\n\n\tfloat red = raymarch(ro1, uv);\n\tfloat cyan = raymarch(ro2, uv);\n\n\tfragColor = vec4(vec3(red, vec2(cyan)), 1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tddXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdG3Dc", "name": "NeonBars(SST)", "author": "Del", "description": "neon bars for SST", "tags": ["bars", "neon", "seamless", "sst"], "likes": 7, "viewed": 304, "date": "1571085752", "time_retrieved": "2024-06-20T19:46:28.902475", "image_code": "// Generic (sexy, seamless & slightly wibbly) neonbars with extraglow etc. for SST - Del 14/10/2019\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 SSTLines(vec2 duv, vec3 col2, float nl, float grad,float thickness, float wibblesize, float wibblespeed, float glowintensity, float glowclamp, float extraglow)\n{\n    if (iMouse.z>0.5)\n    \tcol2 = hsv2rgb(vec3(duv.y*0.1+duv.x*0.1+iTime*0.025,0.5,0.5));\n    \n    \n    duv.y -= (floor(duv.x)*grad) + (duv.x*grad);\n    duv = fract(duv);\n    float l1 = abs(fract((duv.x*grad-duv.y)*nl) -0.5);\n    float dd = sin(iTime*wibblespeed+duv.x*6.28)*wibblesize;\n    l1 = min(glowclamp, (thickness+dd)/l1);\n    vec3 col = col2*l1*glowintensity+(dd*extraglow);\n    return mix(col2,col,l1);\n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 1.0+sin(iTime)*0.25;\t// zoom\n    uv.y += iTime*0.1;\t\t\t// vscroll\n    \n    // lots of silly parameters, have fun :)\n    float grad = sin(iTime*0.35)*0.2;\n    float nlines = 5.0;\n    float thickness = 0.15;\n    float wibblesize = 0.015;\n    float glowintensity = 3.25;\n    float wibblespeed = 6.5;\n    float glowclamp = 1.0;\n    float extraglow = 9.0;\n    vec3 col = hsv2rgb(vec3(iTime*0.025,0.5,0.5));\n\tcol = SSTLines(uv, col, nlines, grad, thickness, wibblesize, wibblespeed, glowintensity, glowclamp, extraglow);\n    \n\t// vignette\n   \tvec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.35 );\n    \n    \n    O = vec4(col.xyz,1.0);\n}\n\n  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdG3Dc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdG3Dd", "name": "Fractal Yin Yang", "author": "theepicsnail", "description": "Fractal Yin Yang", "tags": ["fractal"], "likes": 8, "viewed": 290, "date": "1571197244", "time_retrieved": "2024-06-20T19:46:28.902475", "image_code": "mat2x2 rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2x2(c, -s, s, c);\n}\nvec3 yy(vec2 uv) {\n    float angle = iTime*.5;\n    vec3 color = vec3(.2,0,0);\n    \n    for(int i = 0 ; i < 10 ; i ++) {\n        if( length(uv) > 1.) {\n            break;\n        }\n        \n        uv *= rotate(angle+float(i)*.5);\n        uv*=2.;\n        uv.x -=sign(uv.x); \n        \n        color = vec3(sign(uv.y));\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\tfragColor = vec4(yy(uv),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdG3Dd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdG3Dm", "name": "Shadertober 06 - Husky", "author": "BackwardsCap", "description": "Corn or pineapple?", "tags": ["inktober", "shadertober", "husky", "backwardscaptain"], "likes": 2, "viewed": 236, "date": "1570420383", "time_retrieved": "2024-06-20T19:46:28.902475", "image_code": "#define MAX_DIST 30.0\n#define PI 3.1415927\n#define T mod((iTime*2.),12.55)\n\nvec2 rotate(vec2 a, float d){\n    float s  = sin(d);\n    float c = cos(d);\n    \n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0));\n}\n\nfloat husk(vec3 bp, vec3 p)\n{\n    \n    return box(bp-vec3(0.,-2.,-4),vec3(10,3.+cos(p.x+p.z+p.y)/4.+bp.x/2.,.1));\n}\n\n\nvec2 map(vec3 p)\n{\n    \n    \n\tvec3 pp = p+vec3(0.,8.,0.);\n    pp.yz = rotate(pp.yz,0.);\n    vec3 bp = pp+vec3(-T-1.,3.,0.);\n    vec3 lp = p;\n    lp.x-=T;\n    float o =30.;\n    float b = 1000000000.;\n    \n    float mx = 10.;\n    for(float i=0.;i<mx;i++)\n    {\n        pp.yz = rotate(pp.yz,.6+i*.0001);\n        bp = pp+vec3(-T-12.,0.,-1.-cos(T-i)/10.);\n        bp.z+=((lp.x-o)*(lp.x-o))/25.;\n        b=min(b,husk(bp,p));\n    }\n    \n    p.y=p.y+abs(p.z*p.z)/25.;\n    p.y+=(lp.x*lp.x)/400.;\n    float c = p.y+.5*(1.-smoothstep(-1.,1.,abs(cos(abs(p.z)))*3.))+smoothstep(0.2,2.,(1.-abs(sin(p.x*2.))/1.5));\n\t\n    float r=min(c,b);\n    \n    float m=0.0;\n\n    if(r==c)m=1.;\n    else if(r==b)m=2.;\n    \n    return vec2(r,m);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0001,0.);\n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n    ));\n    \n}\n\nvec2 ray(vec3 ro, vec3 rd)\n{\n    float t =0.0;\n    float m = 0.0;\n    \n    for(int i=0;i<128;i++)\n    {\n        \n        vec3 p=ro+rd*t;\n        vec2 h=map(p);\n        m=h.y;\n        if(h.x<0.00001)break;\n        t+=h.x/2.;\n        if(t>MAX_DIST)break;\n    }\n    \n    if(t>MAX_DIST)t=-1.;\n    \n    return vec2(t,m);\n}\n \nvec3 color(vec3 p, vec3 n, vec2 t)\n{\n    vec3 c = vec3(0.);\n    vec3 mate = vec3(1.32,1,0);\n    if(t.y>1.5)\n    {\n        mate=vec3(0.,.5,0.)/4.*(.5+(1.+cos(p.x/2.)));\n        mate+=(mate*texture(iChannel0,vec2(p.x,(p.z/p.y))).rgb)/2.;\n    }\n    vec3 sun=normalize(vec3(0.2,0.5,-0.5));\n    float dif=clamp(dot(n,sun),0.0,1.0);\n    float sha = step(ray(p+n*.001,sun).x,0.0);\n    float sky = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.,1.);\n    float bou = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.,1.);\n    \n    c=mate*vec3(0.5,0.6,0.5)*dif*sha;\n    c+=mate*vec3(0.2,0.3,.8)*sky;\n    c+=mate*vec3(0.2,0.1,0.1)*bou;\n    \n    return c;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{    \n    \n    vec2 st = vec2(atan(rd.y,rd.z), length(ro));\n        \n\tvec3 c = vec3(0.,.1,0.)*(.5+smoothstep(-0.,1.,cos(st.x*40.+iTime*3.)));\n\n    \n    vec2 t = ray(ro,rd);\n\n    \n    if(t.x>0.)\n    {\n        vec3 p = ro+rd*t.x;\n        vec3 n=normal(p);\n        \n        c=color(p,n,t);\n        \n    }\n   \tc=pow(c,vec3(0.454));\n    \n    return c;\n}\n    \n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(T,2,0.);\n    vec3 ta = vec3(T+10.,0,0.);\n    vec3 camF =\tnormalize(ta-ro);\n    vec3 camU = normalize(cross(camF,vec3(0,1,0)));\n    vec3 camR = normalize(cross(camU,camF));\n    \n    vec3 rd = normalize(uv.x*camU+uv.y*camR+2.*camF);\n    \n    c.rgb=render(ro,rd);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdG3Dm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdG3DW", "name": "shadetober #03 (bait)", "author": "percentcer", "description": "Inktober, but with shaders", "tags": ["inktober", "shadertober", "shadetober", "inktober2019"], "likes": 2, "viewed": 311, "date": "1570176613", "time_retrieved": "2024-06-20T19:46:29.120601", "image_code": "float expStep( float x, float k, float n )\n{\n    return exp( -k*pow(x,n) );\n}\n\nfloat parabola( float x, float k )\n{\n    x = fract(x);\n    return pow( 4.0*x*(1.0-x), k );\n}\n#define PI 3.141\nfloat sinc( float x, float k )\n{\n    float a = PI*(k*x-1.0);\n    return sin(a)/a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 distort = texture(iChannel0, uv + iTime * .3) / 32.;\n    uv += distort.xy;\n\n    vec3 col = vec3(1.,.2,.6);\n    col.r = 0.5 + 0.5*cos(uv.x * 197.);\n    col.r *= 1. - parabola(uv.y + (sin(uv.x*32.) + cos(uv.x*10.))*.7 + iTime * .3, 6.);\n    // col.g = 0.5 + 0.5*cos(iTime+uv.y * 12.);\n    \n    //col = vec3(1.,1.,0.);\n    //col *= parabola(uv.y + iTime * .3, 128.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdG3DW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdG3Rd", "name": "Base warp fBM", "author": "trinketMage", "description": "Base for warp fBM (Fractional Brownian Motion) implemented from articles from @iq http://www.iquilezles.org/www/articles/warp/warp.htm\nWith transform_rose colormap from colormap-shaders", "tags": ["noise", "fbm", "warp", "cineshader"], "likes": 94, "viewed": 97221, "date": "1570737186", "time_retrieved": "2024-06-20T19:46:29.659987", "image_code": "float colormap_red(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 20049.0 / 82979.0) {\n        return 0.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\n    } else if (x <= 1.0) {\n        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 7249.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return 127.0 / 255.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nvec4 colormap(float x) {\n    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\n}\n\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n/*float noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}*/\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p + iTime  ); p = mtx*p*2.02;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.015625*noise( p + sin(iTime) );\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\tfloat shade = pattern(uv);\n    fragColor = vec4(colormap(shade).rgb, shade);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Base warp fBM\",\n\t\"description\": \"Noise but Pink\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdG3Rd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdG3Rw", "name": "Raining Blood", "author": "piyushslayer", "description": "My attempt at how blood rain on a glass window would look like. ", "tags": ["refraction", "fog", "glass", "rain", "blood", "refract", "raindrops"], "likes": 27, "viewed": 1390, "date": "1571261730", "time_retrieved": "2024-06-20T19:46:30.314575", "image_code": "/**\n\"Raining Blood, From a lacerated sky. Bleeding its horror, creating my\nstructure now I shall reign in blood.\" - Slayer\n\nThis is inspired by bigwings' heartfelt (https://www.shadertoy.com/view/ltffzl)\n*/\n\n#define PI 3.141592653589793\n\nfloat hash21(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) / float(0xffffffffU);\n}\n\nvec3 hash13(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat rainDrops(vec2 st, float time, float size)\n{\n    vec2 uv = st * size;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 gridUv = fract(uv) - .5; // grid\n   \tvec2 id = floor(uv);\n    vec3 h = (hash13(id.x * 467.983 + id.y * 1294.387) - .5) * .8;\n    vec2 dropUv = gridUv - h.xy;\n    vec4 noise = textureLod(iChannel1, id * .05, 0.);\n    float drop = smoothstep(.25, 0., length(dropUv)) *\n        max(0., 1. - fract(time * (noise.b + .1) * .2 + noise.g) * 2.);\n    return drop;\n}\n\nvec2 wigglyDrops(vec2 st, float time, float size)\n{\n    vec2 wigglyDropAspect = vec2(2., 1.);\n    vec2 uv = st * size * wigglyDropAspect;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y += time * .23;\n\n    vec2 gridUv = fract(uv) - .5; // rectangular grid\n    vec2 id = floor(uv);\n    \n    float h = hash21(id);\n    time += h * 2. * PI;\n    float w = st.y * 10.;\n    float dx = (h - .5) * .8;\n    dx += (.3 - abs(dx)) * pow(sin(w), 2.) * sin(2. * w) *\n        pow(cos(w), 3.) * 1.05; // wiggle\n    float dy = -sin(time + sin(time + sin(time) * .5)) * .45; // slow down drop before continuing falling\n    dy -= (gridUv.x - dx) * (gridUv.x - dx);\n    \n    vec2 dropUv = (gridUv - vec2(dx, dy)) / wigglyDropAspect;\n    float drop = smoothstep(.06, .0, length(dropUv));\n    \n    vec2 trailUv = (gridUv - vec2(dx, time * .23)) / wigglyDropAspect;\n    trailUv.y = (fract((trailUv.y) * 8.) - .5) / 8.;\n    float trailDrop = smoothstep(.03, .0, length(trailUv));\n    trailDrop *= smoothstep(-.05, .05, dropUv.y) * smoothstep(.4, dy, gridUv.y) *\n        \t(1.-step(.4, gridUv.y));\n    \n    float fogTrail = smoothstep(-.05, .05, dropUv.y) * smoothstep(.4, dy, gridUv.y) *\n\t\t\tsmoothstep(.05, .01, abs(dropUv.x)) * (1.-step(.4, gridUv.y));\n    \n    return vec2(drop + trailDrop, fogTrail);\n}\n\nvec2 getDrops(vec2 st, float time)\n{\n    vec2 largeDrops = wigglyDrops(st, time * 2., 1.6);\n    vec2 mediumDrops = wigglyDrops(st + 2.65, (time + 1296.675) * 1.4, 2.5);\n    vec2 smallDrops = wigglyDrops(st - 1.67, time - 896.431, 3.6);\n    float rain = rainDrops(st, time, 20.);\n    \n    vec2 drops;\n    drops.y = max(largeDrops.y, max(mediumDrops.y, smallDrops.y));\n    drops.x = smoothstep(.4, 2., (1. - drops.y) * rain + largeDrops.x +\n                          mediumDrops.x + smallDrops.x); // drops kinda blend together\n\n    return drops;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord / iResolution.xy;\n    float time = mod(iTime + 100., 7200.);\n    \n    vec2 drops = getDrops(st, time);\n    vec2 offset = drops.xy;\n    float lod = (1. - drops.y) * 4.8;\n    \n    // This is kinda expensive, would love to use a cheaper method here.\n    vec2 dropsX = getDrops(st + vec2(.001, 0.), time);\n    vec2 dropsY = getDrops(st + vec2(0., .001), time);\n    vec3 normal = vec3(dropsX.x - drops.x, dropsY.x - drops.x, 0.);\n    normal.z = sqrt(1. - normal.x * normal.x - normal.y * normal.y);\n    normal = normalize(normal);\n    \n    float lightning = sin(time * sin(time * 30.)); // screen flicker\n    float lightningTime = mod(time, 10.) / 9.9;\n   \tlightning *= 1. - smoothstep(.0, .1, lightningTime)\n        + smoothstep(.9, 1., lightningTime); // lightning flash mask\n    \n\tvec3 col = textureLod(iChannel0, st+normal.xy * 3., lod).rgb;\n    col *= (1. + lightning);\n    \n    col *= vec3(1., .8, .7); // slight red-ish tint\n    col += (drops.y > 0. ? vec3(.5, -.1, -.15)*drops.y : vec3(0.)); // bloody trails\n    col *= (drops.x > 0. ? vec3(.8, .2, .1) * (1.-drops.x) : vec3(1.)); // blood colored drops\n    \n    col = mix(col, col*smoothstep(.8, .35, length(st - .5)), .6); // vignette\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdG3Rw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdG3WR", "name": "Disco Raymarch", "author": "jmdeejay", "description": "Test de raymarching.", "tags": ["raymarch"], "likes": 1, "viewed": 101, "date": "1569972943", "time_retrieved": "2024-06-20T19:46:30.314575", "image_code": "float map(vec3 p)\n{\n\tvec3 q = fract(p) * 2.0 - 1.0;\n    return length(q) - 0.4;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for(int i; i < 32; i++){\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n    float time = iTime * 0.25;\n    \n    vec3 o = vec3(0.0, time, time);\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    r.xz *= mat2(cos(time), -sin(time), sin(time), cos(time));\n    \n    float t = trace(o, r);\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = vec3(fog);\n    \n    vec3 col = 0.5 + 0.5 * cos(time + uv.xyx + vec3(0, 2, 4));\n    \n    // Output to screen\n    fragColor = vec4(fc * col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdG3WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdG3Wz", "name": "Grid of Stars", "author": "specialsaucewc", "description": "Tutorial done", "tags": ["grid", "space", "learning"], "likes": 2, "viewed": 141, "date": "1570059028", "time_retrieved": "2024-06-20T19:46:30.314575", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define STAR_SPEED .5\n#define TWINKLE_INT 12.\n#define TWINKLE_SPEED 0.5\n#define TWINKLE_MIN 0.1\n#define GRID_MAX_SIZE 15.\n#define GRID_MIN_SIZE .5\n#define LAYER_SPEED .07\n#define LAYER_COUNT 5.\n#define SOUND_BOOST 1.2\n\nfloat N21(vec2 p) {\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p) {\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nfloat DistLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n    return length(pa - ba*t);\n}\n\nvec2 GetPos(vec2 id, vec2 offs) {\n    vec2 r = N22(id + offs)*iTime;\n    return offs + sin(r)*STAR_SPEED;\n}\n\nfloat DrawLine(vec2 p, vec2 a, vec2 b) {\n    float d = DistLine(p, a, b);\n    float m = S(.03, .01, d);\n    float d2 = length(a-b);\n    m *= S(1.2, .5, d2) + S(.05, .03, abs(d2-.75));\n    return m;\n}\n\nfloat Layer(vec2 uv) {\n    float m = 0.;\n    //make 5x5 grid centered\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    \n    vec2 p[9];\n    int i = 0;\n    //get random point in each 3x3 grid cell\n    for (float y=-1.; y <= 1.; y++) {\n        for (float x=-1.; x <= 1.; x++) {\n            p[i] = GetPos(id, vec2(x,y));\n            i++;\n        }\n    }\n    \n    float t = iTime * TWINKLE_SPEED;\n    \n    for (int i=0; i<9; i++) {\n        m += DrawLine(gv, p[4], p[i]);\n        \n        //point twinkle\n        vec2 dFromP = (p[i] - gv) * TWINKLE_INT;\n        //inverse square approximation\n        float sparkle = 1. / length(dot(dFromP, dFromP));\n        \n        //animate\n        m += sparkle*(sin(t+fract(p[i].x)*10.)*(.5-TWINKLE_MIN/2.) + (.5+TWINKLE_MIN/2.));\n    }\n    m += DrawLine(gv, p[1], p[3]);\n    m += DrawLine(gv, p[1], p[5]);\n    m += DrawLine(gv, p[5], p[7]);\n    m += DrawLine(gv, p[3], p[7]);\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    //Normalized mouse coord from -.5 to .5\n    vec2 mouse = (iMouse.xy / iResolution.xy)-.5;\n    vec3 col = vec3(0);\n    float gradient = uv.y;\n    \n    float m = 0.;\n    float t = iTime*LAYER_SPEED;\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    uv *= rot;\n    mouse *= rot;\n    \n    for (float i=0.; i <= 1.; i+=1./LAYER_COUNT) {\n        float z = fract(i+t);\n        float size = mix(GRID_MAX_SIZE, GRID_MIN_SIZE, z);\n        float fade = S(0., .5, z) * S(1., .8, z);\n        m += Layer(uv*size + i*20. + mouse) * fade;\n    }\n    \n    \n    vec3 base = sin(t*5.*vec3(.345, .456, .678))*.4 + .6;\n    col = m*base;\n    \n    float fft = texelFetch( iChannel0, ivec2(.7, 0), 0).x;\n    gradient *= fft*SOUND_BOOST;\n    col -= gradient * base;\n    \n    //if (gv.x > .48 || gv.y > .48) col = vec3(1,0,0);    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "MtXSDM", "previewfilepath": "https://soundcloud.com/eberstark/fading", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/eberstark/fading", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdG3Wz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdG3zV", "name": "Wavy Blocks", "author": "ParaBellum", "description": "Playing around with random and ray marching\nYou can move the camera with the mouse left click and moving it", "tags": ["3d", "raymarching", "random", "blocks"], "likes": 6, "viewed": 155, "date": "1571076568", "time_retrieved": "2024-06-20T19:46:30.314575", "image_code": "#define MAX_STEPS 700\n#define MIN_DIS .01\n#define STEP_SIZE .075\n\n#define PI 3.141592\n\n#define DISP 1.\n\n#define MIN_SHADOW .1\n#define MAX_SHADOW .2\n\n#define AO_SAMPLES 1.\n#define AO_INTENSITY 1.\n\n#define T iTime*.5\n#define L_P vec3(0., 10., 100.)\n#define SHININNESS 16.\n\n#define B vec3(.1)\n#define W vec3(1.)\n#define C1 vec3(.0, .1, .0)\n#define C2 vec3(.0, .6, .0)\n\nfloat hash21(in vec2 p)\n{\n    return fract(sin(dot(p, vec2(23.1, 98.3))) * 65192.8);\n}\n\nfloat plane(in vec3 p)\n{\n    float h21 = hash21(floor(p.xz))*DISP;\n    h21 += (sin((p.x*.1)+T)*cos((p.z*.1)+T))*2.5;\n    return p.y-h21;\n}\n\nfloat scene(in vec3 p)\n{\n    return plane(p);\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, 0.);\n    float d = scene(p);\n    vec3 n = d - vec3(scene(p-e.xyy), scene(p-e.yxy), scene(p-e.yyx));\n    return normalize(n);\n}\n\nfloat phong(in vec3 p, in vec3 n, in vec3 o)\n{\n    vec3 ld = normalize(L_P - p);\n    vec3 vd = normalize(o - p);\n    vec3 hv = normalize(ld + vd);\n    \n    float Kd = max(dot(n, ld), 0.);\n    float Ks = pow(max(dot(n, hv), 0.), SHININNESS);\n    \n    return Kd+Ks;\n}\n\nfloat hShadow(in vec3 o)\n{\n    vec3 d = normalize(L_P - o);\n    float t = MIN_SHADOW;\n    for (int i = 0; i < 1; i+=0)\n    {\n        float s = scene(o + d * t);\n        if (s < .01)\n            return 0.5;\n        if (t > MAX_SHADOW)\n            break;\n        t += s;\n    }\n   \treturn 1.;\n}\n\nfloat ambientOcclusion(in vec3 p, in vec3 n)\n{\n    float s = 1. / AO_SAMPLES;\n    float ao = clamp((s-scene(p + n * s))*AO_INTENSITY, 0., 1.);\n    return 1. - ao / AO_SAMPLES;\n}\n\nfloat shade(in vec3 p, in vec3 o)\n{\n    vec3 n = normal(p);\n    float ph = phong(p, n, o);\n    float a = .25;\n    float s = hShadow(p);\n    s = pow(s, 2.);\n    float ao = ambientOcclusion(p, n);\n    return clamp(ph*s + a*ao, 0., 1.);\n}\n\nfloat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float s = scene(o + d * t);\n        if (s < MIN_DIS)\n            return t;\n        t += s*STEP_SIZE;\n    }\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 ms = iMouse.xy/iResolution.xy*2.-1.;\n    ms.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.);\n    float h = 12.;\n    vec3 o = vec3(ms.x*5., h, 0.);\n    vec3 t = vec3(0., h-2.+ms.y*5., h/2.);\n    vec3 f = normalize(o-t);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n\tvec3 d = uv.x*r + uv.y*u - f;\n\n    float m = marcher(o, d);\n    if ( m > -1.)\n    {\n        vec3 p = o + d * m;\n\n        float h21 = hash21(floor(p.xz));\n        col += shade(p, o);\n        vec3 C = abs(vec3(sin(T), 0., cos(T)));\n        if (h21 < .94)\n          \tcol *= B;\n        else if (h21 >= .94 && h21 < .96)\n            col *= C1+C;\n        else if (h21 >= .96 && h21 < .98)\n            col *= C2+C;\n        else if (h21 >= .98)\n            col *= W;\n    }\n    \n    fragColor = vec4(sqrt(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdG3zV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdGGRt", "name": "metaball3d", "author": "lewdoo", "description": "Ray-marched metaballs", "tags": ["metaball"], "likes": 0, "viewed": 126, "date": "1570805919", "time_retrieved": "2024-06-20T19:46:31.060079", "image_code": "float _Gloss = 400.;\nfloat _BallCount = 6.;\n\n//controls ball positioning\nvec3 getSource(float i) {\n    i = (sin(i + .2) * 6.) + 2.;\n    return vec3(4., -2.,22.) \n           \t\t + vec3(dot(i,0.1)*sin(iTime*mod(i,5.0)*0.6)*4.0,\n                        dot(i,0.4)*sin(iTime*mod(i,3.)*0.4)*4.0, dot(i,0.2)*sin(iTime*mod(i,3.)*.5)*0.1);    \n}\n\n//controls the merging\nfloat metaField(in vec3 m, out vec3 normal) {\n    \n    normal = vec3(0,0,0);\n    float fieldi = 0.0;\n    \n    //mouse control of ball\n    \n    vec3 so = vec3((iMouse.xy / iResolution.xy - vec2(0.35, 0.55)) * 15., 22.);\n    float dis = length(m - so);\n    float s = 1. / (dis*dis);\n    vec3 l = normalize(m - so);\n    normal += l * s;\n    fieldi += s;\n    \n    for(float i=0.; i<_BallCount; i++) {\n        \n        vec3 source = getSource(i); //source is the ball position\n        float d = length(m - source); //d is the distance from the position to the current draw dist\n        \n        float size = 1. / (d*d); //how big i want that layer to draw\n        vec3 localNormal = normalize(m - source); //the normal of the blobs\n        \n        normal += localNormal * size;\n        fieldi += size;\n    }\n    \n    normal = normalize(normal);\n    return fieldi;\n}\n\n\nfloat rayMarching(in vec3 origin, in vec3 ray, out vec3 m, out vec3 normal) {\n    \n    float\tmDist = 0.0;\n\n \tm = origin;   \n    \n    \n    \n    \n    for(int i=0; i<140; i++) {\n    \tfloat fieldIntensity = metaField(m, normal);\n        \n        if(fieldIntensity > 0.5) {\n            //return 1.;\n        }\n        //else if(fieldIntensity > 0.475 && fieldIntensity < 0.5){\n        //\treturn 0.8;\n        //}\n        else {\n            mDist += 0.2;\n        \tm = origin + ray * mDist;    \n        }\n    }\n    \n    float fieldIntensity = metaField(m, normal);\n    if(fieldIntensity > 0.5){\n    \treturn 1.;\n    }//returns the glow\n    else if(fieldIntensity > 0.01){\n    \treturn pow(fieldIntensity * 2.6, 2.);\n    }\n\treturn 0.;    \n}\n\nvec4 getCol(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light) {\n    \n    vec3 lightRay = normalize(m - light);\n    float diffuse = dot(normal, -lightRay);\n\n    vec3 reflectedL  = reflect(lightRay, normal);\n    float hLight \t\t = pow(max(dot(reflectedL, -ray),0.0), _Gloss);\n\n    vec3 baseColor = vec3(0.2,0.5,0.8)*1.5 + normal * .4;\n\n    vec3 diff = baseColor * 0.5 * diffuse;\n    vec3 shine = vec3(1.0, 1.0, 1.0) * hLight;    \n    vec3 ambiant = baseColor * 0.7;        \n\n    return vec4(diff + shine + ambiant, 1.0);\n}\n\n\nmat3 rotXY(const in vec2 angle ) \n{\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\t\n\treturn mat3(c.y, 0.0, -s.y,\n\t\t\t\ts.y * s.x, c.x, c.y * s.x,\n\t\t\t\ts.y * c.x, -s.x, c.y * c.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    vec2 mo = vec2(0.5);\n\tmo = iMouse.xy/iResolution.xy;\n    \n    uv -= vec2(0.5);\n    \n    vec3 ro = vec3(1.,.0,0.);\n\tro *= rotXY(vec2(-mo.x,-mo.y*1.5));\n    \n    vec3 cam = vec3(-.7, -.45, -0.4);\n    //cam.x += sin(iTime) * 0.5;\n    //cam.z += cos(iTime) * 0.5;\n    vec3 ray = normalize(vec3(uv, 1.) - cam);\n    vec3 light = vec3(-15.0, 5.0, 5.0);\n    \n    vec3 m;\n    vec3 normal;\n    \n    float r = rayMarching(cam, ray, m, normal);\n    if(r == 1.) {\n        fragColor = getCol(ray, m, normal, light);\n    }\n    else if(r != 0.){\n        vec4 outCol = vec4(vec3(r* 8.) * vec3(0.2,0.5,0.8)*1.1, 1.);\n    \tfragColor = outCol;\n    }\n    \n    vec2 st = uv;\n    st.y -= iTime * 0.002;\n    vec3 n = vec3(fract(sin(uv.x * 49.4758 + st.y *742.923) + uv.x * 253.5235 + sin(st.y * 238.432))) * 0.045;\n    vec3 cn = n + vec3(0.4, 0.4, 0.4) * 0.56;\n    float rim = 1. - pow(length(uv + vec2(0.6, 0.5)), 1.4) * 1.5;\n    //cn *= vec3(rim);\n    \n    fragColor += vec4(cn, 1.);\n    fragColor *= rim * 0.7;\n}\n\n\n//to lava lamp it just make fake groups and scroll them up with sin\n//then make a tier for on click that drags them all to the centre by different speeds- would look sick\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdGGRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdGGWV", "name": "Abstract Orchard", "author": "Dave_Hoskins", "description": "An abstract orchard, with some strange fruit. Thanks goes to 'fizzer' for the excellent tree folding idea, and 'iapafoto' for the splendid particle code. This shader creates a rendering stack of alpha positions to help with the anti-aliasing. ", "tags": ["raymarch", "grass", "abstract", "tree", "trees", "summer", "orchard", "abstractorchard"], "likes": 56, "viewed": 1102, "date": "1571776546", "time_retrieved": "2024-06-20T19:46:33.720918", "image_code": "// Abstract Orchard\n// by Dave Hoskins. October 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nint spointer;\nvec3 sunLight;\n#define SUN_COLOUR vec3(1., .9, .8)\n#define FOG_COLOUR vec3(1., .7, .7)\n\nstruct Stack\n{\n    vec3 pos;\n    float alpha;\n    float dist;\n    int mat;\n\n};\n\n#define STACK_SIZE 8\nStack stack[STACK_SIZE];\n\n//==============================================================================\n//--------------------------------------------------------------------------\nfloat getGroundHeight(vec2 p)\n{\n    float y =(sin(p.y*.23)+cos(p.x*.18))*.8;\n    return y;\n}\n//--------------------------------------------------------------------------\nmat3 getCamMat( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//--------------------------------------------------------------------------\n// Loop the camposition around a uneven sine and cosine, and default the time 0\n// to be steep at a loop point by adding 140...\nvec3 getCamPos(float t)\n{\n    //t = sin(t*.01)*200.;\n    t+=140.;\n    vec3 p = vec3(3.0+50.0*sin(t*.03),\n                  1.5,\n                  4.0 + 50.0*cos(t*.044));\n    p.y-=getGroundHeight(p.xz);\n    return p;\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n//------------------------------------------------------------------------------\nfloat randomTint(vec3 pos)\n{\n    float r = texture(iChannel1, pos.xz*.0027).x;\n    return r+.5;\n}\n\n//----------------------------------------------------------------------------------------\nvec3 texCube(sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture(sam, p.yz).xyz;\n\tvec3 y = texture(sam, p.zx).xyz;\n\tvec3 z = texture(sam, p.xy).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//------------------------------------------------------------------------------\nvec4 grassTexture(vec3 pos, vec3 nor)\n{\n    \n    float g = texture(iChannel1, pos.xz*.5).x;\n    float s = texture(iChannel1, pos.xz*.015).x*.2;\n    \n    \n    vec3 flower = texture(iChannel2, pos.xz*.15).xyz;\n    float rand = texture(iChannel1, pos.xz*.003).x;\n    rand *= rand*rand;\n    \n    flower =pow(flower,vec3(8, 15, 5)) *10. * rand;\n    vec4 mat = vec4(g*.05+s, g*.65, 0, g*.1);\n    mat.xyz += flower;\n    \n\treturn min(mat, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec4 barkTexture(vec3 p, vec3 nor)\n{\n    vec2 r = floor(p.xz / 5.0) * 0.02;\n    \n    float br = texture(iChannel1, r).x;\n\tvec3 mat = texCube(iChannel3, p, nor) * vec3(.35, .25, .25);\n    mat += texCube(iChannel3, p*1.73, nor)*smoothstep(0.0,.2, mat.y)*br * vec3(1,.9,.8);\n    //mat*=mat*2.5;\n   \treturn vec4(mat, .1);\n}\n\n//------------------------------------------------------------------------------\nvec4 leavesTexture(vec3 p, vec3 nor)\n{\n    \n    vec3 rand = texCube(iChannel2, p*.15,nor);\n\tvec3 mat = vec3(0.4,1.2,0) *rand;\n    if (nor.y < 0.0) mat += vec3(1., 0.5,.5);\n    \n   \treturn vec4(mat, .0);\n}\n\n//------------------------------------------------------------------------------\nvec4 fruitTexture(vec3 p, vec3 nor, float i)\n{\n    \n    \n    float rand = texCube(iChannel2, p*.1 ,nor).x;\n    float t = dot(nor, normalize(vec3(.8, .1, .1)));\n\tvec3 mat = vec3(1.,abs(t)*rand,0);\n    mat = mix(vec3(0,1,0), mat, i/10.);\n\n   \treturn vec4(mat, .5);\n}\n\n\n\n//------------------------------------------------------------------------------\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h)\n{\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n}\n\n//------------------------------------------------------------------------------\nconst int   SEEDS = 8 ;\nconst float STEP_SIZE = 2.;\n#define SIZE .03\n\n\n// This seed code is the starfield stuff from iapafoto\n// I've just removed the alpha part...\n// https://www.shadertoy.com/view/Xl2BRR\nmat2 rotMat2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(si, co, -co, si);\n}\n\nvec3 floatingSeeds(in vec3 ro, in vec3 rd, in float tmax)\n{ \n \n    float d =  0.;\n    ro /= STEP_SIZE;\n\tvec3 pos = floor(ro),\n\t     ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ro + .5 + rs*0.5) * ri;\n\t\n    float dint;\n\tvec3 offset, id;\n    vec3 col = vec3(0);\n    vec3 sum = vec3(0);\n    //float size = .04;\n    \n\tfor( int i=0; i< SEEDS; i++ )\n    {\n        id = hash33(pos);\n\n        offset = clamp(id+.2*cos(id*iTime),SIZE, 1.-SIZE);\n        d = distanceRayPoint(ro, rd, pos+offset, dint);\n        \n        if (dint > 0. && dint * STEP_SIZE < tmax)\n        {\n            col = vec3(.4)*smoothstep(SIZE, 0.0,d);\n            sum += col;\n        }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n  \n\treturn sum * .7;\n}\n\n//--------------------------------------------------------------------------\nfloat findClouds2D(in vec2 p)\n{\n\tfloat a = 1.5, r = 0.0;\n    p*= .000001;\n    for (int i = 0; i < 5; i++)\n    {\n        r+= texture(iChannel1,p*=2.2).x*a;\n        a*=.5;\n    }\n\treturn max(r-1.5, 0.0);\n}\n//------------------------------------------------------------------------------\n// Use the difference between two cloud densities to light clouds in the direction of the sun.\nvec4 getClouds(vec3 pos, vec3 dir)\n{\n    if (dir.y < 0.0) return vec4(0.0);\n    float d = (4000. / dir.y);\n    vec2 p = pos.xz+dir.xz*d;\n    float r = findClouds2D(p);\n    float t = findClouds2D(p+normalize(sunLight.xz)*30.);    \n    t = sqrt(max((r-t)*20., .2))*2.;\n    vec3 col = vec3(t) * SUN_COLOUR;\n    // returns colour and alpha...\n    return vec4(col, r);\n} \n\n\n//------------------------------------------------------------------------------\n// Thanks to Fizzer for the space-folded tree idea...\n/// https://www.shadertoy.com/view/4tVcWR\nvec2 map(vec3 p, float t)\n{\n \n    float matID, f;\n    p.y += getGroundHeight(p.xz);\n\tfloat num = (floor(p.z/5.))*5.+(floor(p.x/5.0))*19.;\n\tp.xz = mod(p.xz, 5.0)-2.5;\n    //p.xz *= rotMat2D(p.y*num/300.); // ... No, just too expensive. :)\n    \n    float d = p.y;\n    matID = 0.0;\n\n    float s=1.,ss=1.6;\n    \n    // Tangent vectors for the branch local coordinate system.\n    vec3 w=normalize(vec3(-1.5+abs(hash11(num*4.)*.8),1,-1.));\n    vec3 u=normalize(cross(w,vec3(0,1.,0.)));\n\n    float scale=3.5;\n    p/=scale;\n    vec3 q = p;\n    // Make the iterations lessen over distance for speed up...\n    int it = 10-int(min(t*.03, 9.0));\n\n\tfloat h  = hash11(num*7.)*.3+.3;\n    vec3 uwc = normalize(cross(u,w));\n    int dontFold = int(hash11(num*23.0) * 9.0)+3;\n    \n    float thick = .4/h;\n    for (int i = 0; i < it; i++)\n    {\n\t\tf = scale*max(p.y-h,max(-p.y,length(p.xz)-.04/(p.y+thick)))/s;\n        if (f <= d)\n        {\n            d = f;\n            matID = 1.0;\n        }\n\n        // Randomly don't fold the space to give more branch types...\n        if (i != dontFold)\n        \tp.xz = abs(p.xz);\n\n        p.y-=h;\n        p*=mat3(u,uwc,w);\n        p*=ss;\n\t\ts*=ss;\n    }\n\n    float fr = .2;\n    f = (length(p)-fr)/s;\n    if (f <= d)\n    {\n        d = f;\n        matID = 2.0;\n    }\n    \n    q.y -= h*1.84;\n    h *= 1.1;\n    for (int i = 0; i < it; i++)\n    {\n      \tp = (normalize(hash31(num+float(i+19))-.5))*vec3(h, 0.1, h);\n     \tp+=q;\n        float ds =length(p)-.015;\n     \tif (ds <= d)\n        {\n            matID = 3.0+float(i);\n         \td = ds;\n        }\n    }\n\n\treturn vec2(d, matID);\n}\n\n//------------------------------------------------------------------------------\nfloat sphereRadius(float t)\n{\n\tt = abs(t-.0);\n\tt *= 0.002;\n\treturn clamp(t, 1./iResolution.y, 3000.0/iResolution.y);\n}\n\n//------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd, float dis)\n{\n\tfloat res = 1.0;\n    float t = hash11(dis)*.5+.2;\n\tfloat h;\n\t\n    for (int i = 0; i < 10; i++)\n\t{\n        vec3 p =  ro + rd*t;\n\n\t\th = map(p,dis).x;\n\t\tres = min(10.*h / t*t, res);\n\t\tt += h*2.5;\n\t}\n    //res += t*t*.02; // Dim over distance\n    return clamp(res, .3, 1.0);\n}\n\n//-------------------------------------------------------------------------------------------\n// Taken almost straight from Inigo's shaders, thanks man!\n// But I've changed a few things like the for-loop is now a float,\n// which removes the need for the extra multiply and divide in GL2\nfloat calcOcc( in vec3 pos, in vec3 nor, float d )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(float h= 0.07; h < .25; h+= .07)\n    {\n\t\tvec3 opos = pos + h*nor;\n        float d = map( opos, d ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n//-------------------------------------------------------------------------------------------\nfloat marchScene(in vec3 rO, in vec3 rD, vec2 co)\n{\n\tfloat t = hash12(co)*.5;\n\tvec4 normal = vec4(0.0);\n\tvec3 p;\n    float alphaAcc = 0.0;\n\n    spointer = 0;\n\tfor( int j=min(0,iFrame); j < 140; j++ )\n\t{\n        // Check if it's full or too far...\n\t\tif (spointer == STACK_SIZE || alphaAcc >= 1.) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = sphereRadius(t);\n\t\tvec2 h = map(p, t);\n\t\tif( h.x <= sphereR)\n\t\t{\n            //h = max(h,0.0);\n            float alpha = (1.0 - alphaAcc) * min(((sphereR-h.x+.01) / sphereR), 1.0);\n\t\t\tstack[spointer].pos = p;\n            stack[spointer].alpha = alpha;\n            stack[spointer].dist = t;\n            stack[spointer].mat = int(h.y);\n            alphaAcc += alpha;\n\t        spointer++;\n        }\n\t\tt +=  h.x+t*0.007;\n\t}\n    return alphaAcc;\n}\t\n\n//-------------------------------------------------------------------------------------------\nvec3 lighting(in int id, in vec4 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n\n    // Shadow and local occlusion...\n\tfloat sh = shadow(pos+sunLight*.01,  sunLight, d);\n    float occ = calcOcc(pos, normal, d);\n    \n    // Light surface with 'sun'...\n\tvec3 col = mat.xyz * SUN_COLOUR*(max(dot(sunLight,normal), 0.0))*sh;\n    if (id == 2 && normal.y < -0.5)\n    {\n       \tcol.y += .15;\n    }\n\n\n    // Ambient...\n\t\n    float fre = clamp(1.0+dot(normal,eyeDir),0.0,1.0);\n    \n    float bac = clamp(dot( normal, normalize(vec3(-sunLight.x,0.0,-sunLight.z))), 0.0, 1.0 );\n    normal = reflect(eyeDir, normal); // Specular...\n\tcol += pow(max(dot(sunLight, normal), 0.0), 16.0)  * SUN_COLOUR * sh * mat.w * occ * fre;\n    col += bac*mat.xyz* .3 * occ;\n    col += mat.xyz * max(normal.y, 0.0) * occ * .5;\n\t//col += SUN_COLOUR * fre *.2*occ;\n\n\treturn min(col, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec3 getNormal2(vec3 p, float e)\n{\n    return normalize( vec3( map(p+vec3(e,0.0,0.0), 0.).x - map(p-vec3(e,0.0,0.0), 0.).x,\n                            map(p+vec3(0.0,e,0.0), 0.).x - map(p-vec3(0.0,e,0.0), 0.).x,\n                            map(p+vec3(0.0,0.0,e), 0.).x - map(p-vec3(0.0,0.0,e), 0.).x));\n}\n\nvec3 getNormal(vec3 pos, float ds)\n{\n\n    float c = map(pos, 0.).x;\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(ds, 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy, 0.0).x, map(pos + eps_zero.yxy, 0.0).x,\n                          map(pos + eps_zero.yyx, 0.0).x) - c);\n}\n\n\n//------------------------------------------------------------------------------\nvec3 getSky(vec3 dir)\n{\n\tvec3 col = mix(vec3(FOG_COLOUR), vec3(.0, 0.2,0.4),(abs(dir.y)));\n    return col;\n}\n\n\n//==============================================================================\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 mouseXY = iMouse.xy / iResolution.xy;\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    sunLight = normalize(vec3(-.8,1.8,-1.5));\n    \n    // Camera stuff...\n    float time = iTime+mouseXY.x*100.0;\n    vec3 camera = getCamPos(time);\n\tvec3 lookat = getCamPos(time+10.);\n    float ride = sin(iTime*.3)+.3;\n    camera.y += ride;\n \tlookat.y += ride;\n    \n    mat3 camMat = getCamMat(camera, lookat, 0.0);\n    vec3 seedDir = normalize( vec3(uv, cos((length(uv*.4)))));\n\tvec3 rd = camMat * seedDir;\n\n\tvec3 col = vec3(0);\n\n\tvec3 sky  = getSky(rd);\n  \n\n    // Build the stack returning the final alpha value...\n    float alpha = marchScene(camera, rd, fragCoord);\n    vec4 mat;\n    // Render the stack...\n    if (alpha > .0)\n    {\n        for (int i = 0; i < spointer; i++)\n        {\n            vec3  pos = stack[i].pos; \n            float d = stack[i].dist;\n            \n            vec3 nor =  getNormal(pos, sphereRadius(d));\n            int matID = stack[i].mat;\n            if (matID == 0) mat =  grassTexture(pos, nor);\n            else\n\t\t\t\tif (matID == 1) mat = barkTexture(pos, nor);\n            else\n            if (matID == 2)\n            {\n\t\t\t\tmat = leavesTexture(pos, nor);\n                \n                \n            }\n            else\n                mat = fruitTexture(pos, nor, float(matID - 3));\n\n            mat *= randomTint(pos);\n \n            vec3  temp = lighting(matID,mat, pos, nor, rd, d);\n            if (matID == 3) temp=temp*.4+vec3(.15, .01,0);\n            \n            temp = mix(sky, temp , exp(-d*.01));\n            col += temp * stack[i].alpha;\n        }\n    }\n    vec4 cc = getClouds(camera, rd);\n    sky+= pow(max(dot(sunLight, rd), 0.0), 300.0)*SUN_COLOUR*2.;\n\tsky = mix(sky, cc.xyz, cc.w);\n\tcol += sky *  (1.0-alpha);\n    \n    float d = stack[0].dist;\n    col+= floatingSeeds(camera, rd, d);\n    \n   \n    // Sun glow effect...\n    col+=pow(max(dot(sunLight, rd), 0.0), 6.0)*SUN_COLOUR*.2;\n    \n    // Clamp and contrast...\n    col = col * vec3(1., .7,.5);\n    col = clamp(col,0.,1.);\n    col = col*col*(3.0-2.0*col);\n\n    \n    // The usual vignette...which manages to add more vibrancy...\n    vec2 q = fragCoord / iResolution.xy;\n    col *= pow(90.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.5);\n\t// A nice fade in start...\n    \n    \n    col *= smoothstep(0.0, 5.0, time);\n    fragColour = vec4(sqrt(col), 1.0);\n    \n}\n\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "MlfXW2", "previewfilepath": "https://soundcloud.com/maddecent/unlike-pluto-kickraux-palace-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/maddecent/unlike-pluto-kickraux-palace-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdGGWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdK3Dh", "name": "Another KIFS Fractal ", "author": "darkeclipz", "description": "Yet another fractal from the tutorial of The Art of Code.\n\nhttps://www.youtube.com/watch?v=il_Qg9AqQkE", "tags": ["fractal", "kifs"], "likes": 13, "viewed": 252, "date": "1570116111", "time_retrieved": "2024-06-20T19:46:33.720918", "image_code": "#define R iResolution.xy\n#define pi 3.1415\n\nvec2 N(float angle) {\n\treturn vec2(sin(angle), cos(angle));    \n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*U-R)/R.y;\n    vec2 mouse = iMouse.xy/R;\n    vec3 col = vec3(0);\n    \n \n    uv /= 1.5;\n    uv.x = abs(uv.x);\n    float angle = (5. / 6.) * pi;\n    uv.y += tan(angle) * 0.5;\n\t\n    vec2 n = N(angle);\n    uv -= 2.* n * max(0., dot(uv - vec2(0.5, 0), n));\n\n    n = N((0.5*sin(iTime/8.)+0.5)*(2. / 3.) * pi);\n    uv.x += 1.5 / 3.;\n    float scale = 1.;\n    for(int i=0; i < 7; i++) {\n        \n\t\tuv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n        \n        uv.x = abs(uv.x);\n        uv.x -= 0.5;    \n        uv -= 2.0 * n * min(dot(uv, n), 0.0);\n    }\n    \n    \n    float d = length(uv - vec2(clamp(uv.x, -1., 1.), 0));\n    col += smoothstep(1./iResolution.y, .0, d / scale);\n  \tuv /= scale;\n    col += texture(iChannel0, 3. * uv - 0.03 * iTime).rgb;\n\n    // Output to screen\n    O = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdK3Dh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdK3Dw", "name": " Test of \"bleeding\" color v2", "author": "jorge2017a1", "description": " Test of \"bleeding\" color\nhttps://www.shadertoy.com/view/XdSXWR", "tags": ["testofbleedingcolor"], "likes": 8, "viewed": 203, "date": "1570368402", "time_retrieved": "2024-06-20T19:46:36.466581", "image_code": "//Created by predatiti in 2015-01-06\n///https://www.shadertoy.com/view/XdSXWR\n//mnodificado por jorge2017a1--5--oct-2019\n//mover con el mouse!!!\n\nconst float t = 16.0;//nr. sample per pixel\n\n#define pi acos(-1.0)\n#define pi2 pi/2.0\n\nstruct Sphere\n{\n\tvec4 center_radius;\n\tint idmaterial;\n};\n\nstruct Box\n{\n    vec3 min, max;\n   int idmaterial;\n};\n    \nstruct Cylinder \n{\n    vec3 c;\n    float r,h;\n    int idmaterial;\n};\n\nBox box0;\nSphere sfere[4];\nBox boxe[15];\nCylinder cylinder[4];\n//Material material[6];\n\nvec3 light = vec3(0.0, 0.0, 0.0);\nvec3 cub, lcub;\nvec2 uvCoord;\nvec2 p,rv2;\nvec2 randv2;\nfloat side = 1.0;\nfloat time ;\nfloat f0, f1,f2,f3;\nvec2 cw = vec2(-0.4,0.1);\n\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t   fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 cosPowDir(vec3  dir, float power) \n{//creates a biased random sample\n   vec2 r=rand2()*vec2(6.2831853,1.0);\n   vec3 sdir=cross(dir,((abs(dir.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)));\n   vec3 tdir=cross(dir,sdir); \n   r.y=pow(r.y,0.01/power);\n   float oneminus = sqrt(1.0-r.y*r.y);\n   return cos(r.x)*oneminus*sdir + sin(r.x)*oneminus*tdir + r.y*dir;\n}\n\nvec2 intersectCube(vec3 origin, vec3 ray, Box cube) {      \n   vec3   tMin = (cube.min - origin) / ray;      \n   vec3   tMax = (cube.max - origin) / ray;      \n   vec3     t1 = min(tMin, tMax);      \n   vec3     t2 = max(tMin, tMax);\n   float tNear = max(max(t1.x, t1.y), t1.z);\n   float  tFar = min(min(t2.x, t2.y), t2.z);\n   return vec2(tNear, tFar);   \n}\n\nvec3 normalForCube(vec3 hit, Box cube)\n{  \n   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   \n   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   \n   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   \n   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      \n   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   \n   else return vec3(0.0, 0.0, 1.0);   \n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, Sphere s) {   \n   vec3 toSphere = origin - s.center_radius.xyz;      \n   float sphereRadius = s.center_radius.w;\n   float a = dot(ray, ray);      \n   float b = dot(toSphere, ray);   \n   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   \n   float discriminant = b*b - a*c;      \n   if(discriminant > 0.0) {      \n      float t = (-b - sqrt(discriminant)) ;   \n      if(t > 0.0) return t;      \n   }   \n   return 10000.0;   \n}  \n\nvec3 normalForSphere(vec3 hit, Sphere s) {   \n   return (hit - s.center_radius.xyz) / s.center_radius.w;   \n} \n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)\n{\n\tvec3  rc = ro - cylinder.c;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( rc.xz, rd.xz );\n\tfloat c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;\n\tfloat d = b*b - a*c;\n\tif( d>=0.0 )\n\t{\n\t\t// cylinder\t\t\t\n\t\tfloat s = (-b - sqrt( d ))/a;\n        float hy = ro.y-cylinder.c.y+s*rd.y;\n\t\tif( s>0.0 && hy<cylinder.h && hy>-cylinder.h )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t\t// cap\t\t\t\n\t\t/*s = (cylinder.h - ro.y+cylinder.c.y)/rd.y;\n\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t{\n\t\t\treturn s;\n\t\t}*/\n\t}\n    return 100000.0;\n}\n\nvec3 normalforCylinder(vec3 hit,Cylinder cylinder)\n{\n    vec3 nor;\n\tnor.xz = hit.xz - cylinder.c.xz;\n    nor.y = 0.0;\n    nor = nor/cylinder.r;\n    //nor.y = 1.0*sign(hit.y-cylinder.c.y);\n    return nor;\n}\n\nvoid initscene()\n{\n    box0.min = vec3(-2.0, -1.2, -2.0);//room\n   \tbox0.max = vec3( 2.0,  1.2,  2.0);\n    \n    light = vec3(cos(time *0.0)*1.65-0.5, sin(time*0.0)*0.65+0.7, sin(time*0.5)*1.65);\n\n    float h = sin(time*3.0)*0.03;\n    float sinr = sin(time)*0.5; float cosr = cos(time)*0.5;\n    sfere[0].center_radius = vec4( 0.0, h-0.3, 0.0,    0.523);//rosu\n   \tsfere[1].center_radius = vec4( 0.0, h-0.29, 0.0,    0.520);//verde\n   \tsfere[2].center_radius = vec4(sinr, h+0.1,cosr,    0.123);//albastru\n    \n    vec3 center = vec3(0.8,-0.8,-1.6); \n    cylinder[0].c = vec3( 0.55,0.0, 0.25) + center;\n    cylinder[0].r = 0.04;\n    cylinder[0].h = 0.4;\n    \n    cylinder[1].c = vec3( 0.55,0.0,-0.25) + center;\n    cylinder[1].r = 0.04;\n    cylinder[1].h = 0.4;\n    \n    cylinder[2].c = vec3(-0.55,0.0, 0.25) + center;\n    cylinder[2].r = 0.04;\n    cylinder[2].h = 0.4;\n    \n    cylinder[3].c = vec3(-0.55,0.0,-0.25) + center;\n    cylinder[3].r = 0.04;\n    cylinder[3].h = 0.4;\n\n   \tcenter = vec3(-1.55,-0.2, 0.5);\n    cub = vec3(0.0, 0.0, 0.0) + center;//corp dulap\n    lcub = vec3(0.4, 1.0, 0.8);    \n   \tboxe[0].min = cub - lcub;\n   \tboxe[0].max = cub + lcub;\n    \n   \tcub = vec3(0.5, 0.0, +0.0) + center;//fanta\n   \tlcub = vec3(0.12, 0.98, 0.01);\n   \tboxe[1].min = cub - lcub;\n   \tboxe[1].max = cub + lcub;\n    \n   \tcub = vec3(0.02, 0.99, 0.0) + center;//plafon\n   \tlcub = vec3(0.43, 0.015, 0.85);\n   \tboxe[2].min = cub - lcub;\n   \tboxe[2].max = cub + lcub;   \n    \n   \tcub = vec3( 0.380, 0.0, 0.385) + center;//oglinda dreapta\n   \tlcub = vec3(0.03, 0.77, 0.18);    \n   \tboxe[3].min = cub - lcub;\n   \tboxe[3].max = cub + lcub;\n    \n   \tcub = vec3(0.385, 0.0, -0.385) + center;//oglinda stanga\n   \tlcub = vec3(0.03, 0.77, 0.18);\n   \tboxe[4].min = cub - lcub;\n   \tboxe[4].max = cub + lcub;\n\n   \tcub = vec3(0.41, 0.0, 0.06) + center;//maner dreapta\n   \tlcub = vec3(0.021, 0.1, 0.01);\n   \tboxe[5].min = cub - lcub;\n   \tboxe[5].max = cub + lcub;\n\n   \tcub = vec3(0.41, 0.0, -0.06) + center;//maner stanga\n   \tlcub = vec3(0.021, 0.1, 0.01);\n   \tboxe[6].min = cub - lcub;\n   \tboxe[6].max = cub + lcub;\n\n   /*\tcub = vec3(0.0, 0.0, 0.0) + center;//bbox\n   \tlcub = vec3(0.47, 1.2, 0.87);\n   \tboxe[7].min = cub - lcub;\n   \tboxe[7].max = cub + lcub;*/\n//dulap\n\n//birou\n\tcenter = vec3(0.8,-0.8,-1.6);\n   \tcub = vec3( 0.0, 0.4, 0.0) + center;//tablie\n   \tlcub = vec3(0.65, 0.015, 0.35);\n   \tboxe[7].min = cub - lcub;\n   \tboxe[7].max = cub + lcub;\n\n//scaun\n   \tcub = vec3(-0.0, 0.1, 0.5) + center;//tablie\n   \tlcub = vec3(0.25, 0.015, 0.25);\n   \tboxe[8].min = cub - lcub;\n   \tboxe[8].max = cub + lcub;\n\n   \tcub = vec3(-0.22, -0.15, 0.28) + center;//picior stanga fata\n   \tlcub = vec3(0.03, 0.25, 0.03);\n   \tboxe[9].min = cub - lcub;\n   \tboxe[9].max = cub + lcub;\n\n   \tcub = vec3( 0.22, -0.15, 0.28) + center;//picior dreapta fata\n   \tlcub = vec3(0.03, 0.25, 0.03);\n   \tboxe[10].min = cub - lcub;\n   \tboxe[10].max = cub + lcub;\n\n   \tcub = vec3( 0.22, 0.2,  0.72) + center;//picior dreapta spate\n   \tlcub = vec3(0.03, 0.60, 0.03);\n   \tboxe[11].min = cub - lcub;\n   \tboxe[11].max = cub + lcub;\n\n   \tcub = vec3(-0.22, 0.2,  0.72) + center;//picior stanga spate\n   \tlcub = vec3(0.03, 0.60, 0.03);\n   \tboxe[12].min = cub - lcub;\n   \tboxe[12].max = cub + lcub;\n\n   \tcub = vec3(-0.0, 0.6,  0.74) + center;//spatar\n   \tlcub = vec3(0.25, 0.10, 0.01);\n   \tboxe[13].min = cub - lcub;\n   \tboxe[13].max = cub + lcub;\n    \n    cub = vec3(-0.4,-0.87,  1.9) ;//calorifer\n   \tlcub = vec3(0.55, 0.3, 0.06);\n   \tboxe[14].min = cub - lcub;\n   \tboxe[14].max = cub + lcub;\n}\n\nvoid intersectscene(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)\n{\n    float tSphere6 = intersectSphere(ro, rd, sfere[3]);\n    if(tSphere6 < t && bl) { t = tSphere6;i=6;}\n\n   \t/*float tSphere = intersectSphere(ro, rd, sfere[0]);\n    if(tSphere < t) { t = tSphere;i=0;}\n   \ttSphere = intersectSphere(ro, rd, sfere[1]);\n    if(tSphere < t) { t = tSphere;i=1;}\n   \ttSphere = intersectSphere(ro, rd, sfere[2]);\n    if(tSphere < t) { t = tSphere;i=2;}\n\t*/\n    \n    \n\tfloat tcyl = iCylinder(ro, rd, cylinder[0]);\n    if(tcyl<t) {t = tcyl; i = 10;}\n    tcyl = iCylinder(ro, rd, cylinder[1]);\n    if(tcyl<t) {t = tcyl; i = 11;}\n    tcyl = iCylinder(ro, rd, cylinder[2]);\n    if(tcyl<t) {t = tcyl; i = 12;}\n    tcyl = iCylinder(ro, rd, cylinder[3]);\n\tif(tcyl<t) {t = tcyl; i = 13;}\n    \n\tvec2 tboxc = intersectCube(ro, rd, boxe[0]); \n    if(tboxc.x>0.0 && tboxc.x<tboxc.y && tboxc.x < t) {t = tboxc.x; i = 20;}\n    vec2 tboxf = intersectCube(ro, rd, boxe[1]); \n    //if(tboxf.x>0.0 && tboxf.x<tboxf.y && tboxf.x < t) {t = tboxf.x; i = 21;}\n    vec2 tbox = intersectCube(ro, rd, boxe[2]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 22;}\n    tbox = intersectCube(ro, rd, boxe[3]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 23;}\n    tbox = intersectCube(ro, rd, boxe[4]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 24;}\n    tbox = intersectCube(ro, rd, boxe[5]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 25;}    \n    tbox = intersectCube(ro, rd, boxe[6]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 26;} \n\n    float t1 = 200000.0;\n    float t2 = 200000.0;  \n    if(tboxf.x>0.0 && tboxf.x<tboxf.y) {t1 = tboxf.y; t2=tboxf.x;}\n    if(t1>t && t2<t && i==20) {t=t1; i=21;}\n\n    tbox = intersectCube(ro, rd, boxe[7]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 27;}\n    tbox = intersectCube(ro, rd, boxe[8]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 28;}\n    tbox = intersectCube(ro, rd, boxe[9]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 29;}\n    tbox = intersectCube(ro, rd, boxe[10]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 30;}\n    tbox = intersectCube(ro, rd, boxe[11]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 31;}\n    tbox = intersectCube(ro, rd, boxe[12]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 32;}\n    tbox = intersectCube(ro, rd, boxe[13]); \n\tif(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 33;}\n    \n    tbox = intersectCube(ro, rd, boxe[14]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 34;}\n}\n\nvoid ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)\n{\n\tif(t == tRoom.y)\n\t{            \n\t\tmref = vec2(0.0,0.0);\n        normal =-normalForCube(hit, box0);   \n        if(abs(normal.x)>0.0)\n        { \n            mcol.xyz = vec3(0.95,0.95,0.95);\n            mref = vec2(0.0,1.0);\n        } \n         else if(normal.y>0.0)\n        {\n            vec3 tcol = texture(iChannel1,1.0-(hit.xz-vec2(1.5,1.5))/3.5).xyz;\n            float s = tcol.y+0.1;//-d\n            s = pow(s,3.0)*0.75+0.01;\n            mref = vec2((s*0.5+0.1),pow(1.0-s,2.0));\n            mcol.xyz = vec3(0.9);//tcol+0.4;\n        } \n        else if(abs(normal.z)>0.0)\n        {\n            mcol.xyz = vec3(0.95,0.15,0.19);\n            mref = vec2(0.0,1.0);\n            \n            if(normal.z<0.0)\n\t\t\t{\n            \t//cw = vec2(-0.4,0.1);\n            \tif(\tall(lessThanEqual(hit.xy,vec2(-0.05,0.6)+cw)) &&\n               \t\tall(greaterThanEqual(hit.xy,vec2(-0.7,-0.6)+cw)) ||\n               \t\tall(lessThanEqual(hit.xy,vec2(0.7,0.6)+cw)) &&\n               \t\tall(greaterThanEqual(hit.xy,vec2(0.05,-0.6)+cw)))\n               \t\tmcol = vec4(vec3(1.1),2.0);\n\t\t\t}\n        }\n\t}     \n\telse   \n\t{\n        \t if(id==0) {normal = normalForSphere(hit, sfere[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==1) {normal = normalForSphere(hit, sfere[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==2) {normal = normalForSphere(hit, sfere[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==6) {normal = normalForSphere(hit, sfere[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n    \telse if(id==10) {normal = normalforCylinder(hit, cylinder[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==11) {normal = normalforCylinder(hit, cylinder[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==12) {normal = normalforCylinder(hit, cylinder[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==13) {normal = normalforCylinder(hit, cylinder[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==20) {normal = normalForCube(hit, boxe[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==21) {normal = normalForCube(hit, boxe[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==22) {normal = normalForCube(hit, boxe[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==23) {normal = normalForCube(hit, boxe[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,9000.0);}\n        else if(id==24) {normal = normalForCube(hit, boxe[4]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,9000.0);}\n        else if(id==25) {normal = normalForCube(hit, boxe[5]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,10.0);}\n        else if(id==26) {normal = normalForCube(hit, boxe[6]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,10.0);}\n        else if(id==27) {normal = normalForCube(hit, boxe[7]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.8,0.8);}\n        else if(id==28) {normal = normalForCube(hit, boxe[8]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==29) {normal = normalForCube(hit, boxe[9]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==30) {normal = normalForCube(hit, boxe[10]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==31) {normal = normalForCube(hit, boxe[11]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==32) {normal = normalForCube(hit, boxe[12]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==33) {normal = normalForCube(hit, boxe[13]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==34) {normal = normalForCube(hit, boxe[14]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.05,3.8);}\n        \n        if(id>19 && id<23)//material for dulap\n        {\n            vec2 uv = hit.yz;\n            uv = abs(normal.y) > 0.0 ? hit.zx : uv;\n            uv = abs(normal.z) > 0.0 ? hit.yx : uv; \n            mcol.xyz = texture(iChannel1,1.0-(uv - vec2(1.5,-1.0))/vec2(5.5,0.5)).xyz - vec3(0.35,0.2,0.2);\n            mref = vec2(0.0,0.2);// transparent, glossines\n            mcol.xyz = vec3(0.1,0.99,0.1);// color\n            \n            if(id==21)\tnormal = -normal;\n        }\n        \n        if(id>26 && id<34)//masa scaun\n        {\n            mcol.xyz = vec3(0.9);\n            mref = vec2(0.0,0.7);// transparent, glossines\n            //if(id==27) mcol.xyz = vec3(0.9,0.9,0.9);// color\n            \n            if(id==21)\tnormal = -normal;\n        }\n        \n        if(id==34)//calorifer\n        {\n            mcol.xyz = vec3(sin(hit.x*59.0)+2.0-0.2);\n            mref = vec2(0.0,0.0);\n        }\n    }  \n}\n\nvec3 directLight(vec3 hit, vec3 normal, vec3 lightf, vec3 cl, inout bool i)\n{\n   vec3 color = vec3(0.0);\n   int id = -1;\n   i = false;\n   //vec3 toLight = (lightf-hit);\n   //float sqdist = dot(toLight,toLight);\n   vec3 L = normalize(lightf-hit);;//(toLight*rsqrt(sqdist);\n   float diffuse = clamp(dot(normal,L),0.0,0.7)+0.3;\n \n   if(diffuse>0.0)\n   {\n      float ldist =distance(lightf,hit);// sqrt(sqdist);\n      float sh = 1000.0;//distance(lightf,hit);\n      intersectscene(hit + normal * 0.0001, L, sh, id, false);           \n      if(sh>ldist)\n         {color += cl * (diffuse/(ldist))*0.32; i = true;}\n   }\n   return color;\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 col = vec3(1.0);\n    int id=-1;\n    int tm = -1;\n    \n    for(int i=0; i<6; i++)\n    {\n    \tfloat t = 10000.0; //seed++;\n\t\t\n   \t\tvec2 tRoom = intersectCube(ro, rd, box0);          \n   \t\tif(tRoom.x < tRoom.y)   t = tRoom.y; \n    \n    \tintersectscene(ro, rd, t, id, true);\n    \n    \tvec3 hit = ro + rd * t;        \n\t\tvec4 mcol = vec4(vec3(0.99),0.0);\n    \tvec3 normal; \n    \tvec2 mref = vec2(0);\n      \n    \tColorAndNormal(hit, mcol, normal, tRoom, mref, t, id);\n    \thit = hit + normal * 0.00001;\n         \n        vec2 rnd = rand2();\n        rnd = vec2(0.3,0.6);\n        \n        \n        \n        //rnd.x = 1.0/6.0 * ( float(i) + rnd.x );\n        col *= mcol.xyz;\n     \n        \n        \n        if(mcol.w>0.0) \n        {\n            if(i==0) {color = mcol.xyz; break;}\n            float df=max(dot(rd,-normal),0.0)*2.0; //if(tm==1) df *= 19.0;\n            color += col*mcol.xyz*mcol.w * df ;\n            //if(tm==1) color += col * 1.5;\n            break;\n        }\n        \n        \n        \n        \n\t\ttm = -1;\n        if(rnd.x>abs(mref.x))//diffuse\n        {\n            \n            rnd=vec2(0.5,0.6);\n        \trd = CosineWeightedSampleHemisphere ( normal, rnd);      \n        \ttm = 0;   \n        \n        \tcol *= clamp(dot(normal,rd),0.0,1.0);\n           // color += col * 0.1;\n            \n            bool isLight = false;\n         \t//vec3 rnd3 = vec3(rand2(),rand2().x) *2.0 -1.0;\n            rnd = rand2()*2.0-1.0;\n            \n            rnd=vec2(1.0,1.0);\n            \n            //cw = vec2(-0.4,0.1);\n         \tvec3 lightf = vec3(cw,2.2) + vec3(rnd.x*0.65,rnd.y * 0.6,0.0);\n         \tvec3 dl = directLight(hit, normal, lightf, vec3(0.9,0.9,0.9), isLight);\n            float nd = max(0.0,dot(lightf,vec3(0.0,0.0,1.0)))+max(0.0,dot(lightf,normal));\n         \tcolor += col * dl*5.0 *nd;\n\n\t\t\n         \tif(isLight) break;\n            \n          \n            \n        }       \n        else \n        {\n            vec3 nrd = reflect(rd,normal); tm = 1;//reflect\n       \t\t/*if(mref.x<0.0)//refract\n            {\n                //if(id==30)\n                    //if(dot(rd,normal)>0.0) normal = -normal;\n            \tvec3 ior=vec3(1.0,1.52,1.0/1.12); tm = 2;\n           \t \tvec3 refr=refract(rd,normal,(side>=0.0)?ior.z:ior.y);//calc the probabilty of reflecting instead\n           \t \tvec2 ca=vec2(dot(normal,rd),dot(normal,refr)),n=(side>=0.0)?ior.xy:ior.yx,nn=vec2(n.x,-n.y);\n            \tif(rand2().y>0.5*(pow(dot(nn,ca)/dot(n,ca),2.0)+pow(dot(nn,ca.yx)/dot(n,ca.yx),2.0)))\n               \t\tnrd=refr;\n            }*/\n            rd = cosPowDir(nrd, mref.y*1.0);\n            col *= 1.2;\n        }\n        \n        ro = hit + rd * 0.0001; \n        \n        if(dot(col,col) < 0.1 && i>3) break;\n    }\n    \n \treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    p = -1.0+2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n    float seed = iTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime))*10000.0);\n\t\n    //move camera with mouse\n\tvec3 ro = vec3( 3.0*cos(8.0*mo.x), -0.9 + 2.5*(mo.y), 0.0 + 3.0*sin(8.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n    //camera path\n    time = 0.2 * iTime;\n    vec3 path = vec3(sin(time*0.5)*2.0, sin(time)*0.7, cos(time*0.5)*2.0);    \n    //ro = path; ta = path + vec3(-sin(time*0.5)*0.5+0.0, -cos(time)*0.2, -cos(time*0.5)*0.5+0.0);\n    \n    //view of raymarch\n    //ro = vec3(-0.4,-0.8, 1.0); ta = vec3(-0.4,-0.8, 1.5);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    initscene();\n\t\n\tvec3 col = vec3(0.0);\n\n//    for(float i=0.0; i<t; i++)\n//    {\n//        p += (rand2() * 2.0 - 1.0) * 0.7 / iResolution.x;\n//        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n//    \tcol += getColor( ro, rd );\n//    }\n    \n    \n    for(float i=0.0; i<1.0; i++)\n    {\n        p += (rand2() * 2.0 - 1.0) * 0.7 / iResolution.x;\n        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \tcol += getColor( ro, rd );\n    }\n\n    \n\n    //col = pow( clamp( col/t, 0.0, 1.0 ), vec3(0.65) );\n    col = pow( clamp( col/1.0, 0.0, 1.0 ), vec3(0.65) );\n    \n    //col.g += tc;\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdK3Dw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdK3Wt", "name": "Tyre Icon", "author": "coposuke", "description": "Tyre Desu.", "tags": ["2d", "tyre"], "likes": 5, "viewed": 115, "date": "1571234939", "time_retrieved": "2024-06-20T19:46:36.472675", "image_code": "#define PI 3.14159265356989\n#define PI_2 6.28318530713978\n#define TYRE_COLOR         vec4(0.1, 0.1, 0.1, 1.0)\n#define WHEEL_BG_COLOR     vec4(0.3, 0.3, 0.3, 1.0)\n#define WHEEL_COLOR        vec4(0.7, 0.7, 0.7, 1.0)\n#define WHEEL_COLOR_SHADOW vec4(0.6, 0.6, 0.6, 1.0)\n#define BOLT_COLOR         vec4(0.2, 0.2, 0.2, 1.0)\nconst mat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\nmat2 rotate2d(float _angle)\n{\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec3 hsv(float h, float s, float v)\n{\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n\nvec4 tyre(vec2 uv, float time)\n{\n    vec4 color = vec4(0,0,0,0);\n\n    // tyre & wheel\n    float dist = distance(vec2(0,0), uv);\n    float angle = atan(uv.y, -uv.x);\n    float angleSpeed = -time;\n    angle = 1.0 - (angle + PI) / (PI * 2.0);\n    angle = fract(angle + angleSpeed);\n    \n    // tyre\n    color.rgb += step(0.4, dist) * step(dist, 0.6) * TYRE_COLOR.rgb * ((dist - 0.4) / 0.3);\n\n    // wheel\n    color.rgb = mix(color.rgb, WHEEL_COLOR.rgb * (dist / 0.4), step(dist, 0.4));\n    float shadowDist = distance(vec2(0.0025, 0.0), uv);\n    color.rgb = mix(color.rgb, WHEEL_COLOR_SHADOW.rgb, step(shadowDist, 0.35));\n    color.rgb = mix(color.rgb, WHEEL_BG_COLOR.rgb, step(dist, 0.335));\n\n    float wheelDistance = 0.0;\n    wheelDistance = abs(clamp(sin(angle * PI_2 * 8.0) + 0.0, 0.0, 1.0)) - 0.6;\n    color.rgb = mix(color.rgb, WHEEL_COLOR.rgb, step(dist, wheelDistance));\n    wheelDistance = abs(clamp(sin((angle + 0.05) * PI_2 * 8.0) + 0.0, 0.0, 1.0)) - 0.6;\n    color.rgb = mix(color.rgb, WHEEL_COLOR.rgb, step(dist, wheelDistance));\n    wheelDistance = abs(clamp(sin((angle + 0.05) * PI_2 * 36.0 * 2.0) + 0.0, 0.0, 1.0)) - 0.3;\n    color.rgb = mix(color.rgb, hsv(0.2 + iTime * 0.25, 0.2, 0.2), step(dist, wheelDistance) * step(0.56, dist) * step(dist, 0.59));\n    wheelDistance = abs(clamp(sin((angle + 0.005) * PI_2 * 36.0 * 1.0) + 0.0, 0.0, 1.0)) - 0.3;\n    color.rgb = mix(color.rgb, hsv(0.2 + iTime * 0.25, 0.2, 0.2), step(dist, wheelDistance) * step(0.54, dist) * step(dist, 0.59));\n\n    color.rgb = mix(color.rgb, WHEEL_COLOR.rgb, step(dist, 0.1));\n    color.rgb = mix(color.rgb, WHEEL_BG_COLOR.rgb, step(dist, 0.03));\n    color.rgb = mix(color.rgb, WHEEL_COLOR_SHADOW.rgb, step(0.075, dist) * step(dist, 0.09));\n    \n    // bolt\n    const int BOLT_NUM = 5;\n    for(int i=0 ; i<BOLT_NUM ; ++i)\n    {\n        wheelDistance = distance(vec2(0.0, 0.0 + 0.06) * rotate2d(PI_2 / float(BOLT_NUM) * float(i) - angleSpeed * PI_2), uv);\n        color.rgb = mix(color.rgb, BOLT_COLOR.rgb, step(wheelDistance, 0.025));\n        color.rgb = mix(color.rgb, WHEEL_COLOR.rgb, step(wheelDistance, 0.015));\n    }\n\n    // fade\n    vec3 fade = vec3(1,1,1) * (distance(vec2(1, -1) * 0.75, uv));\n    color.rgb *= fade.rgb;\n\n    // draw enable\n    color.a = step(dist, 0.6);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // bg\n    vec2 gbUV = uv * 2.0;\n\n    // wave\n    vec2 wave = uv;\n    wave.x += iTime * 0.5;\n    wave = vec2(1,0) * fbm(vec3((wave) * 0.05, 0.0)) * 2.0;\n    wave.y += sin(uv.x * 2.0 + iTime * 3.0) * 0.15;\n    wave.x += sin(uv.y * 2.0 + iTime * 3.0) * 0.025 + wave.y;\n    gbUV += wave;\n    gbUV.x += iTime * 0.125;\n    float f = mod(step(0.5, fract(gbUV.x)) + step(0.5, fract(gbUV.y)), 2.0);\n    vec3 bg = mix(vec3(1.0, 1.0, 1.0), hsv(0.2 + iTime * 0.25, 0.2, 0.2), f);\n    fragColor.rgb += bg * (uv.y * 0.75 + 1.0);\n\n    const int TIRE_NUM = 10;\n    const int TIRE_TYPE = 3;\n    for(int y=0 ; y<TIRE_TYPE ; y++)\n    {\n        for(int x=0 ; x<TIRE_NUM ; x++)\n        {\n            vec2 tireUV = uv;\n            tireUV.x += 2.0 / float(TIRE_NUM) * float(x) - (1.0 + 1.0 / float(TIRE_NUM)); // 横に整列\n\n            float tireSpeed = mix( 0.1, 1.0, rand(vec2(x,y))) * iTime;\n            float tireScale = float(TIRE_TYPE) - float(y) * 7.0 + 5.5;\n            int tireRap = int(floor(tireUV.x + 0.5 + tireSpeed));\n            tireUV.x += tireSpeed;\n            tireUV.y += mix(-1.0, 1.0, rand(vec2(x+1+tireRap,y+1)));\n            tireUV.x = mod(tireUV.x, 2.0) - 1.0;\n            \n            vec4 tireColor = tyre(tireUV * tireScale, tireSpeed);\n            vec3 tireFade = vec3(1,1,1) * (uv.y + 1.5) * (float(y) + 1.0) / float(TIRE_TYPE);\n            tireColor.rgb *= tireFade.rgb;\n            fragColor = mix(fragColor, tireColor, tireColor.a);\n        }\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdK3Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdK3zV", "name": "Sphere Outer line 1", "author": "Leasel", "description": "It uses math to calculate the Outer Line of the sphere.", "tags": ["sin", "spheres", "orthographic", "mathematica"], "likes": 0, "viewed": 218, "date": "1570603518", "time_retrieved": "2024-06-20T19:46:36.472675", "image_code": "const float scale = 25.;\nconst float r = 6.;\nvec3 posCircle= vec3(2,2,3);\nconst float degreeError = 15.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    uv -= 0.5;\n    uv.x*= (iResolution.x/iResolution.y);\n    uv *= scale;\n    \n    posCircle.z = sin(iTime)*5. + 5.;\n    posCircle.x = cos(iTime)*(iResolution.x -r)*0.5/scale;\n    \n    float rad = atan(r/posCircle.z);\n    \n    float d = length(-vec3(uv.xy,0.)+posCircle);\n    float radUv = asin(r/d);\n    \n    float radDeg = degreeError/6.298;\n    \n    vec3 col = vec3(0.);\n    \n    if(abs(rad-radUv) < radDeg)\n        {\n            col = vec3((1.-abs(rad-radUv))/d);\n        }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdK3zV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKGDK", "name": "Avg RGB Together", "author": "FelixTheWolfrick", "description": "Average the RGB together and change the colors to the average.", "tags": ["rgb", "average"], "likes": 1, "viewed": 49, "date": "1571002081", "time_retrieved": "2024-06-20T19:46:36.599923", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float avg = (col.r + col.g + col.b) / 3.0;\n    col =  0.5 + 0.5*cos(iTime+uv.xyx+vec3(avg,avg,avg));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKGDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKGDW", "name": "Toony fire", "author": "tecanec", "description": "Based on the tech of my other fire shader", "tags": ["fire"], "likes": 4, "viewed": 89, "date": "1570208567", "time_retrieved": "2024-06-20T19:46:36.599923", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord/iResolution.y) - vec2(iResolution.x / iResolution.y, 1.0);\n    uv *= 1.4;\n    \n    float pro = 0.0;\n    \n    const int particleCount = 20;\n    \n    for (int i = 0; i < particleCount; i++)\n    {    \n        float fI = float(i);\n        float age = mod(iTime + fI / float(particleCount), 1.0);\n        \n        vec2 params = texture(iChannel1, vec2(\n            (iTime - age) / iChannelResolution[1].x, \n            fI / iChannelResolution[1].y\n        )).xy;\n        \n        vec2 pos = vec2(\n        \t(1.0 / (age + 1.0) - 1.0) * (params.x - .5) * 1.3,\n            age / (2.0 - age) * 1.3 / (params.y * .5 + .5) - 1.0\n        );\n        \n        float size = (1.0 - age) * .5;\n        float sizeSqr = size * size;\n        \n        vec2 relativePos = uv - pos;\n        float distSqr = relativePos.x * relativePos.x + relativePos.y * relativePos.y;\n    \t\n        float add = (sizeSqr / distSqr + size * 1.4) * (1.0 - age * age) * .5;\n        pro += (add - mod(add, .5));\n    }\n\t\n    vec3 col = vec3((pro > 3.5) ? pro / 8.0 : 0.0, pro > 9.0, pro > 30.0);\n    fragColor = vec4(col, max(col.x, col.y));\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKGDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKGRw", "name": "ShaderTober - Ring", "author": "Flopine", "description": "A small doodle with inktober's theme \"ring\". I'll try to do that for each day in October :) ", "tags": ["raymarching", "blackandwhite", "inktober"], "likes": 8, "viewed": 326, "date": "1569931843", "time_retrieved": "2024-06-20T19:46:37.115259", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\n// Idea of doing a shadertober came from GreenChicken, thank you ^^ \n\nfloat hash21 (vec2 c)\n{return fract(sin(dot(c,vec2(21.45,40.49)))*1245.5);}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat g1 = 0.;\nfloat sun (vec3 p)\n{\n    p.yz -= vec2(0.6, 0.4);\n    float d = sphe (p,0.8+sin(iTime)*0.1+0.15);\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat g2 = 0.;\nfloat moon (vec3 p)\n{\n    p.z += 0.4;\n    p.y -= 0.5;\n    p.y += clamp(sin(iTime*0.1)*3.,0.,3.);\n    float d = sphe (p, 0.6);\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat water (vec3 p)\n{\n    p.y += 1.5;\n    p.y += sin(length(p.xz*3.)-iTime)*0.1;\n    return abs(p.y) -0.2;\n}\n\nfloat SDF (vec3 p)\n{\n    return min(water(p),min(sun(p), moon(p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.001,0.001,-3.), \n        p = ro, \n        col = vec3(0.),\n        rd = normalize(vec3(uv,1.));\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if(d<0.001)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.9+dither*0.1;\n        p+=d*rd;\n    }\n    float t = length(ro-p);\n\n    col = vec3(shad)*0.2;\n\n    col += g1*0.15;\n    col -= g2*0.05;\n    \n    col = mix(col, vec3(0.,0.,0.03),1.-exp(-0.01*t*t));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKGRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKGW1", "name": "Shadertober 03 - Bait", "author": "BackwardsCap", "description": "I'm hooked", "tags": ["raymarching", "worm", "inktober", "shadertober", "bait", "backwardscaptain", "cineshader"], "likes": 8, "viewed": 15792, "date": "1570125859", "time_retrieved": "2024-06-20T19:46:38.048524", "image_code": "#define AA 2\n\n//gotta love iq and his wonderful website of knowledge\nfloat sub(float d1, float d2){return max(-d1,d2);}\n\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp(0.5+0.5*(d2-d1)/k,0.0,1.0);\n    return mix(d2,d1,h)-k*h*(1.0-h);\n}\n\nfloat elipsoid(vec3 pos, vec3 rad)\n{\n    float k0=length(pos/rad);\n    float k1 = length(pos/rad/rad);\n    \n    return k0*(k0-1.0)/k1;\n}\n\nfloat capsule(vec3 p, float h, float r)\n{\n    p.y-=clamp(p.y,0.0,h);\n    return length(p)-r;\n}\n\n\nvec2 map(vec3 pos)   \n{\n    float mat = -1.;\n    vec3 wormPos = pos+vec3(0.,1.5+sin(iTime/2.)*.2,0.);\n    vec3 hookPos = wormPos-vec3(-0.3,.55,0);\n    float w = elipsoid(wormPos+vec3(wormPos.z*.3,abs(wormPos.z)*.1,0.)*sin(iTime-wormPos.z),vec3(.3,.3+fract(wormPos.z*5.)/20.,4.25));\n    float hb = elipsoid(hookPos+vec3(-0.3,-.4,0.),vec3(.7,.8,10.));\n    float ht = elipsoid(hookPos+vec3(-.3,-.15,0.),vec3(.8,0.9,0.1));\n    float base = sub(hb,ht);\n    float top = capsule(hookPos+vec3(.35,.0,0.),3.,.1+.05*hookPos.y/2.);\n    float hook = smin(base,top,.2);\n    \n    float line = capsule(hookPos+vec3(0.35,-3.0,0.),10.,.02);\n    \n    vec3 mp = mod(pos+vec3(-5.,-iTime,0.),vec3(30.,4,30.))-.5;\n    \n    float bubble = min(length(pos+vec3(-3,-30.+mod(-iTime*5.,220.),0))-.25,\n                    length(pos+vec3(0,-90.+mod(-iTime*3.,130.),8))-.15);\n    bubble=min(bubble,length(pos+vec3(5.,-90.+mod(-iTime*4.,180.),-8))-.2);\n    float d = min(min(w,hook),line);\n    d=min(d,bubble);\n    \n    if(d==w)mat=1.;\n    else if(d==hook)mat=2.;\n    else if(d==line)mat=3.;\n    else if(d==bubble)mat=4.;\n    \n    return vec2(d,mat);\n}\n\nvec3 normal(vec3 p)\n{\n    float eps = 0.005;\n    return normalize(vec3(\n        map(vec3(p.x+eps,p.y,p.z)).x-map(vec3(p.x-eps,p.y,p.z)).x,\n        map(vec3(p.x,p.y+eps,p.z)).x-map(vec3(p.x,p.y-eps,p.z)).x,\n        map(vec3(p.x,p.y,p.z+eps)).x-map(vec3(p.x,p.y,p.z-eps)).x\n    ));\n}\n\nfloat castShadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0001;\n    for(int i=0;i<128;i++)\n    {\n        \n        vec3 pos = ro+t*rd;\n        vec2 h = map(pos);\n        \n        res= min(res, 18.0*h.x/t);\n        if(h.x<0.0001)break;\n        t+=h.x;\n        if(t>20.0)break;\n        \n    }\n    \n    return clamp(res,0.,1.);\n}\n\nvec2 ray(vec3 ro, vec3 rd)\n{\n    \n    float t = 0.0;\n    float m =0.0;\n    int bounces = 128;\n    float max_dist = 30.0;\n    for(int i=0;i<bounces;i++)\n    {\n        vec3 pos = ro+t*rd;\n        vec2 h = map(pos);\n        m=h.y;\n        if(h.x<0.0001)\n        {\n            break;\n        }\n        t+=h.x/2.;\n        if(t>max_dist)break;\n    }\n    \n    if(t>max_dist)t=-1.;\n    \n    return vec2(t,m);\n    \n}\n\nvec3 color(vec3 p, vec3 n, vec2 r)\n{\n    vec3 col = vec3(0.);\n    vec3 mate=vec3(0.);\n    if(r.y<1.5)mate=vec3(0.7,.1,.3)*.6;\n    else if(r.y<2.5)\n    {\n        mate=vec3(1.,1.,2.);\n    }\n    else if(r.y<3.5)mate=vec3(.1);\n    else if(r.y<4.5)mate=vec3(0.3,0.3,4.5);\n    vec3 sun_dir = normalize(vec3(.5,2.,0.2));\n    float sun_dif = clamp(dot(n,sun_dir),0.0,1.0);\n    float sun_sha = castShadow(p+n*0.001,sun_dir);\n    float sky_dif = clamp(0.5+0.5*dot(n,vec3(0.,1.,0.)),0.,1.);\n    \n    col=mate*vec3(1.0,3.0,2.0)*sun_dif*sun_sha;\n    col+=mate*vec3(0.1,0.1,0.3)*sky_dif;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = 0.0;\n    vec3 tot=vec3(0.0);\n    for(int ii=0;ii<AA;ii++)\n    {\n        for(int jj=0;jj<AA;jj++)\n        {\n            vec2 offset = vec2(float(ii),float(jj))/float(AA);\n            \n            vec2 uv = (2.*(fragCoord+offset)-iResolution.xy)/iResolution.y;\n            \n            float time = iTime/10.;\n            vec3 ro = vec3(sin(time)*-10.,1.,cos(time)*-9.);\n            vec3 ta = vec3(0.,-.5,0.);\n\n            vec3 ww = normalize(ta-ro);\n\n            vec3 uu = normalize(cross(ww,vec3(0,1,0)));\n            vec3 vv = normalize(cross(uu,ww));\n\n            vec3 rd = normalize(uv.x*uu+uv.y*vv+2.*ww);\n\n            vec2 r = ray(ro,rd);\n            d=r.x;\n\n            vec3 p = ro+rd*r.x;\n\n            vec3 n =normal(p);\n\n            vec3 col = vec3(0.0,0,1.6-p.y)*(.8+sin(sin(p.x)+cos(p.y*20.+iTime-uv.x*5.))*vec3(.1));\n\n            if(r.x>0.0)\n            {\n                col=color(p,n,r);\n\n                if(r.y==2.||r.y==4.)\n                {\n                    rd = reflect(rd,n);\n                    ro=p+n*.001;\n                    r = ray(ro,rd);\n                    p=ro+r.x*rd;\n                    vec3 c = color(p,normal(p),r);\n                    if(r.x>0.)col+=c;\n                    else col+=c/4.;\n                }\n\n            }\n\n\t\t    col=pow(col,vec3(.454545));\n            tot+=col;\n        }\n    }\n\n    tot/=float(AA*AA);\n    fragColor = vec4(tot,normalize(d));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKGW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdtSR8", "name": "Dancing Polar Coordinates", "author": "adrenoide", "description": "Linear interpolation between three polar curves", "tags": ["polarcoordinates"], "likes": 1, "viewed": 236, "date": "1571782718", "time_retrieved": "2024-06-20T19:46:38.291017", "image_code": "const float pi = 4. * atan(1.);\n\nfloat phi(float x) {\n\tfloat s = sin(pi * x);\n    return s*s;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 p = U / iResolution.x;\n    \n    p -= vec2 (0.5, 0.3);\n    p *= 5.;\n    \n    // Polar coordinates with rotating\n    // polar axis\n    float r = length (p);\n    float t = atan(p.y, p.x) - iTime / 2.;\n\n    // coefft in [0,1], smoothly varying in time\n    float w = phi(iTime / 6.);\n    \n    // 3 polar curves\n    float c0 = 1. + cos(t) * cos(3.*t);\n    float c1 = 1. + cos(t) - cos(2.*t);\n    float c2 = cos(t) * cos(t) * cos(3.*t);\n    \n    // linear interpolation between the 3 curves\n    float c = (2.*w-1.)*(w-1.)*c0 +\n        \t  4.*w*(1.-w)*c1 +\n        \t  w*(2.*w-1.)*c2;\n    \n    float e = smoothstep (-.1, .1, abs(r - c));\n    \n    vec4 tex = texture(iChannel0, p / 5.);\n    \n\tO = tex * vec4(vec3(e), 1.) *\n        vec4(mix(vec3(phi(iTime/2.), phi(iTime/3.), phi(iTime/5.)),\n                 vec3(phi(iTime/5.), phi(iTime/2.), phi(iTime/3.)), phi(iTime / 10.)), 1.)\n        + vec4(vec3(1. - e), 1.);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdtSR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdtSWN", "name": "Platform 3-0", "author": "pik33", "description": "Start your spiritual journey on Platform 3-0, board your space ship and fly into beautiful colors of KT-95", "tags": ["plasma", "flow", "spirit"], "likes": 6, "viewed": 211, "date": "1572028489", "time_retrieved": "2024-06-20T19:46:38.297154", "image_code": "// Fork of \"A flow of 33\" by pik33. https://shadertoy.com/view/td3Sz8\n// 2019-10-25 17:33:00\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p=(3.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n  float f = cos(iTime/30.);\n  float s = sin(iTime/30.);\n  p = vec2(p.x*f-p.y*s, p.x*s+p.y*f);\t\n    \n  for(float i=3.0;i<30.;i++)\n\t{\n        p+= .30/i * sqrt(abs(cos(i*p.yx+iTime*vec2(.30,.30)  + vec2(.30,3.0)))); \n\t}\n\tvec3 col=vec3(.30*sin(3.0*p.x)+.30,.30*sin(3.0*p.y)+.30,sin(3.0*p.x+3.0*p.y));\n\tfragColor=(3.0/(3.0-(3.0/3.0)))*vec4(col, 3.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdtSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdtXD8", "name": "ShaderTober - Ghost", "author": "Flopine", "description": "A small doodle with inktober's theme \"ghost\".\nIt's also one of the visual I used during the Fantômes à Rayures concert at kawaii cafe. Check out his music!  > https://fantome-a-rayures.bandcamp.com/ ", "tags": ["raymarching", "jellyfish", "inktober"], "likes": 18, "viewed": 485, "date": "1571921238", "time_retrieved": "2024-06-20T19:46:39.036627", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define time iTime\n\nfloat BPM = 170./60.;\nfloat PI = acos(-1.);\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat hash1d (vec2 x)\n{return fract(sin(dot(x,vec2(1.45,8.151)))*45485.489);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    float id = floor(a/per);\n    a = mod(a, per) - per*.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id) >= rep/2.)id = abs(id);\n    return id;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat od (vec3 p, float r)\n{return dot(p, normalize(sign(p)))-r;}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat tunnel (vec3 p)\n{\n    p.x += texNoise(vec2(p.y, p.z+time*BPM*2.)*0.05).x;\n    p.y += texNoise(vec2(p.x, p.z+time*BPM*2.)*0.05).x;\n    return -cyl(p.xyz, 8., 1e10);\n}\n\nfloat g2 =0.;\nfloat jellyfish (vec3 p)\n{   \n    moda (p.xy, 3.);\n    p.x -= 4.;\n    p.xy *= rot(sin(p.z*0.5+time));\n    moda(p.xy, 3.);\n    p.x -= 2.;\n    p.yz *= rot(PI/2.);\n    \n    vec3 pp = p;\n    p.y -= 2.;\n    float o = min(sphe(p,.5),max(-sphe(p,1.2),od (p,0.8)));\n    \n    p = pp;\n    p.xz *= rot(sin(p.y+time));\n    moda(p.xz, 8.);\n    p.x -= 0.5;\n    float c = cyl(p.xzy, 0.1+p.y*0.05, 2.);\n    float d = stmin(c, o, 0.5,3.);\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat g1 = 0.;\nfloat strings (vec3 p)\n{\n    p.xy *= rot(p.z*0.3+time);\n    moda(p.xy, 5.);\n    p.x -= 6.;\n    float d = cyl(p, 0.3, 1e10);\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    float anim = exp(-fract(PI*time*BPM/2.)*6.)*8.;\n    p.x += texNoise(p.yz*anim).r*0.5;\n    return min(tunnel(p), min(strings(p),jellyfish(p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float dither = hash1d(uv);\n    \n    vec3 ro = vec3(0.001,0.001,-4.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = vec3(0.);\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i=0.; i<100.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/100.;\n            hit = true;\n            break;\n        }\n        d *= 0.9+dither*0.1;\n        p += d*rd;\n    }\n    float t = length(ro-p);    \n    if (hit)\n    {\n        col = vec3(shad);\n    }\n    col += g2*vec3(0.5,0.3,0.)*0.2;\n    col += g1*0.2;\n\n    col = mix(col, vec3(0.,0.,0.08), 1.-exp(-0.005*t*t));\n    \n    fragColor = vec4(pow(col, vec3(1.)), 1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdtXD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdtXRN", "name": "Mozaic Patern", "author": "Numero7", "description": "Well my atempt at smoothnoise that did not turn well but I tried to give a fun/glitchyness of it.", "tags": ["colors", "patern"], "likes": 4, "viewed": 88, "date": "1571616516", "time_retrieved": "2024-06-20T19:46:39.036627", "image_code": "#define pi 2.0*asin(1.0)\n\nvec2 rotate(vec2 p, float angle)\n{\n    return vec2(p.x * cos(angle) - p.y * sin(angle), p.x * sin(angle) + p.y * cos(angle));\n}\n\nfloat noise(vec2 p)\n{\n    return fract(sin(p.x * 31536.0656341 - p.y * 14503.056430) * 35014.0);\n}\n\nfloat smoothNoise(vec2 p)\n{\n    vec2 sq = (fract(p) - 0.5) * 2.0;\n    float c = 0.0;\n    float s = 0.0;\n    for (float x = -1.0; x <= 1.0; x++)\n    {\n        for (float y = -1.0; y <= 1.0; y++)\n        {\n            vec2 id = floor(p + vec2(x, y)) - 0.5;\n            float ne = length(abs(vec2(x,y)) - abs(sq));\n            \n            c += noise(id) * ne;\n            s += ne;\n        }\n    }\n    \n    return c / s;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 16.0;\n    uv += iTime * 3.0;\n    uv += rotate(uv, smoothNoise(vec2(sin(iTime * 0.91), cos(iTime * 0.23))));\n    float n = smoothNoise(uv);\n    vec3 col = vec3(sin(1.6 * pi * n), sin(6.3 * pi * n), sin(11.6 * pi * n));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdtXRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdV3Wm", "name": "Shadertober 06 Husky", "author": "GreenChicken", "description": "Creating a husky is quite hard, so i made a doggo. Many doggos. Many many dogogogogosgod ododgogosdogogogo", "tags": ["inktober", "husky", "rarymarching", "doggo"], "likes": 3, "viewed": 288, "date": "1570379344", "time_retrieved": "2024-06-20T19:46:39.042731", "image_code": "// SHADERTOBER 06 Husky\n// Poulet vert 06-10-2019\n// many thanks to iq, flafla2, leon\n\n#define PI 3.14159\n#define MAXSTEP 64\n\nfloat Vignette(vec2 uv, float force)\n{\n    float f = clamp(force, 0.001, 1.0);\n    return f + (1.0 - length(uv)) * f;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// Scene setup\n\nvec2 map(vec3 pos)\n{\n    vec2 t = vec2(0.0);\n    float x = 0.0;\n    float y = 0.0;\n    \n    t = vec2(pos.y, 0.0);\n    \n    // doggo\n    \n    vec3 dP = pos + vec3(0.0, -0.1, 1.7);\n    \n    dP.xz *= rot(PI/6.0);\n    dP.x -= iTime;\n    dP.y -= abs(sin(iTime*10.)*.1);\n    dP = opRep(dP, vec3(1.0, 0.0, 1.0));\n    vec2 dog = vec2(sdBox(dP, vec3(.1, .05, .05)), 0.0);\n    \n    vec3 oreP = dP + vec3(-0.08, -0.07, 0.04);\n    float or = sdBox(oreP, vec3(0.02, 0.03, 0.01));\n    oreP = dP + vec3(-0.08, -0.07, -0.04);\n    or = uSDF(or, sdBox(oreP, vec3(0.02, 0.03, 0.01)));\n    vec2 orm = vec2(or, 0.0);\n    \n    vec3 patP = dP + vec3(-0.09, 0.06, 0.04);\n    float pat = sdBox(patP, vec3(0.01));\n    patP = dP + vec3(0.09, 0.06, 0.04);\n    pat = uSDF(pat, sdBox(patP, vec3(0.01)));\n    patP = dP + vec3(0.09, 0.06, -0.04);\n    pat = uSDF(pat, sdBox(patP, vec3(0.01)));\n    patP = dP + vec3(-0.09, 0.06, -0.04);\n    pat = uSDF(pat, sdBox(patP, vec3(0.01)));\n    vec2 patm = vec2(pat, 0.0);\n    \n    vec3 faceP = dP + vec3(-0.1, -0.02, 0.02);\n    vec2 face = vec2(sdBox(faceP, vec3(.005)), 2.0);\n    faceP = dP + vec3(-0.1, -0.02, -0.02);\n    face = opU(face, vec2(sdBox(faceP, vec3(.005)), 2.0));\n    faceP = dP + vec3(-0.1, -0.0, 0.0);\n    face = opU(face, vec2(sdBox(faceP, vec3(.04, .02, .015)), 0.0));\n    faceP = dP + vec3(-0.13, 0.02, 0.0);\n    face = opU(face, vec2(sdBox(faceP, vec3(.002, .01, .005)), 1.0));\n    faceP = dP + vec3(-0.14, -0.02, 0.0);\n    face = opU(face, vec2(sdBox(faceP, vec3(.01)), 2.0));\n    \n    t = opU(t, dog);\n    t = opU(t, orm);\n    t = opU(t, patm);\n    t = opU(t, face);\n    \n    return t;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(float(i)/64., ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(.0); \n        \n    }\n    else\n    {\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(1.0 - t.x);\n        }\n        else if(t.y == 1.0)\n        {\n            col = vec3(1.0, 0.3, 0.7);\n        }\n        else if(t.y == 2.0)\n        {\n            col = vec3(0.0, 0.0, 0.0);\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 1.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime * 0.5;\n    \n    vec3 cp = vec3(0.0, .25, -2.0);\n    vec3 ct = vec3(cos(iTime), 0.1, sin(iTime));\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = Render(cp, vd, screenUV);\n    \n    // compo\n    col -= mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), screenUV.y)*.3;\n    \n    col *= vec3(Vignette(uv, 0.45));\n    \n    col *= 1.1;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdV3Wm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdV3Ww", "name": "Inktober2019 03: bait", "author": "s23b", "description": "Catching up with the challenge is not going as well as I planned, but I'll take being happy with the results over finishing it all this October.", "tags": ["cell", "bacteria", "predator", "inktober", "shadertober", "bait", "inktober2019", "microorganism"], "likes": 13, "viewed": 315, "date": "1570597396", "time_retrieved": "2024-06-20T19:46:39.042731", "image_code": "#define PERIOD 5.\n#define COLOR vec3(.7, .85, .8)\n\n#define PI 3.14159265359\n\nvoid tRotate(inout vec2 p, float angle) {\n    float s = sin(angle), c = cos(angle);\n\tp *= mat2(c, -s, s, c);\n}\n\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\nfloat opSU(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdCell(vec2 p, float size, vec2 dir) {\n    return opSU(length(p) - size, distance(p, dir * size) - size * .75, size / 2.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float color = 0.;\n    \n    float res = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / res;\n    \n    if (abs(uv.x) < .45 && abs(uv.y) < .45) {\n        float t = fract(iTime / PERIOD);\n        vec2 p = ((fragCoord - iResolution.xy / 2.) / res) * 2.5;\n        \n        // add some distortion\n        p+= sin(p.yx * 5. + t * PI * 2.) * .01;\n        p.x-= sin(p.y * 20. - t * PI * 4.) * .005;\n        p.y-= sin(p.y * 50. - t * PI * 6.) * .002;\n        \n        // add camera movement\n        float camera = smoothstep(.7, .9, t);\n        tRotate(p, camera * PI / 2.);\n        p += mix(vec2(.5), vec2(1, 0), camera);\n        p *= mix(1., 2., camera);\n        \n        // entity positions\n        vec2 bait = vec2(1);\n        vec2 fool = vec2(.2);\n        fool = mix(fool, bait, smoothstep(.2, .3, t));\n        vec2 predator = vec2(2.6, -.6);\n        vec2 bystander1 = mix(vec2(.25, 1), vec2(-.4, 1.4), t);\n        vec2 bystander2 = mix(vec2(2, .5), vec2(1, -.5), t);\n        vec2 bystander3 = mix(vec2(1.8, 0), vec2(-.5, -.5), t);\n        \n        // add cells\n        float d = sdCell(p - bait, mix(.2, .0, smoothstep(.4, .8, t)), vec2(0, 1));\n        d = opSU(d, sdCell(p - fool, .4, mix(vec2(0, -1), vec2(-1, 0), smoothstep(.0, .8, t)) * (1. + .5 * smoothstep(.05, .0, abs(t - .25)))), .25);\n        d = opU(d, sdCell(p - predator, .8, vec2(1, 0)));\n        \n        // apply edges\n        float edge = mix(.025, .05, smoothstep(.7, .9, t));\n        d = abs(abs(d) - edge * 1.6) - edge;\n        \n        // add bystanders\n        float crowd = distance(p, bystander1) - .1;\n        crowd = opU(crowd, distance(p, bystander2) - .2);\n        crowd = opU(crowd, distance(p, bystander3) - .1);\n        d = opU(d, abs(crowd) - edge);\n        \n        // render\n        float w = fwidth(d);\n        color = min(1.,1. + d / w);\n    }\n\n\tfragColor = vec4(mix(vec3(0), COLOR, color), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdV3Ww.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdV3z3", "name": "Olympian Nights Visualizer", "author": "AnnoidJohnny", "description": "Music visualizer for Olympian Nights by Neb: https://soundcloud.com/drurylain/olympian-nights", "tags": ["music", "visualizer"], "likes": 2, "viewed": 140, "date": "1570696503", "time_retrieved": "2024-06-20T19:46:39.042731", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float audio = texture(iChannel0, vec2(0.0,0.0)).r;\n    \n    \n    vec2 transformedUV = (uv - vec2(0.5,0.5)) * mat2(cos(iTime * sin(iTime*0.01)), sin(iTime * sin(iTime*0.01)), -sin(iTime * sin(iTime*0.01)), cos(iTime * sin(iTime*0.01)));\n    \n    vec2 transformedUV2 = (uv - vec2(0.5 + cos(iTime*1.5)*0.25,0.5 + sin(iTime*1.5) * 0.25)) * mat2(cos((-iTime + distance(uv, vec2(0.5,0.5))*5.) * sin(iTime*0.01)), sin((-iTime + distance(uv, vec2(0.5,0.5))*5.) * sin(iTime*0.01)), -sin((-iTime + distance(uv, vec2(0.5,0.5))*5.) * sin(iTime*0.01)), cos((-iTime + distance(uv, vec2(0.5,0.5))*5.) * sin(iTime*0.01)));\n    \n    vec3 col = 0.5 + 0.5*cos(iTime + audio+uv.xyx+vec3(0,2,4)) + (texture(iChannel1, transformedUV).rgb) + texture(iChannel2, uv + vec2(cos(iTime + uv.y*5.), 0.0)).b*audio;\n\n    bool checka = distance(fragCoord.xy, (iResolution.xy/2.0) + vec2(cos(iTime*5.0)*12.0,sin(iTime*5.0)*cos(iTime*5.0)*5.0)*10.0) < ((75.0 * iResolution.y/300.0) + audio*70.0* iResolution.y/300.0);\n    bool checkb = distance(fragCoord.xy, (iResolution.xy/2.0) + vec2(cos(iTime*5.0)*12.0,sin(iTime*5.0)*cos(iTime*5.0)*5.0)*10.0) > ((50.0 * iResolution.y/300.0) + audio*80.0* iResolution.y/300.0);\n   \tbool checkc = distance(fragCoord.xy, (iResolution.xy/2.0) + vec2(cos(iTime*5.0)*12.0,sin(iTime*5.0)*cos(iTime*5.0)*5.0)*10.0) < ((25.0 * iResolution.y/300.0) + audio*90.0* iResolution.y/300.0);\n    \n    if(checka && (checkb || checkc))\n        col =  0.5 + 0.5*cos(-iTime+uv.xyx+vec3(0,6,8)+audio) + texture(iChannel1,transformedUV2).rgb;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4tj3zK", "previewfilepath": "https://soundcloud.com/drurylain/olympian-nights", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/drurylain/olympian-nights", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdV3z3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdVGDD", "name": "progress bar - simple", "author": "bolloxim", "description": "bordersimple combine shader to show progress between two textures", "tags": ["progressbar", "ui"], "likes": 1, "viewed": 134, "date": "1570327659", "time_retrieved": "2024-06-20T19:46:39.042731", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 0.6666666, 0.3333333, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 border = vec2(0.05, 0.1);\n    vec4 backCol = vec4(1,1,1,1);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // generate border mask\n\tvec2 mask2 = step(border, uv) * step(uv, 1.0-border);\n    float mask = mask2.x*mask2.y;\n    \n    float progress = mod(iTime, 1.0);  \n    float blend = ((uv.x - progress) <= 0.0 ? 1.0 : 0.0) * mask;\n    vec4 foreCol = vec4(hsv2rgb(vec3(progress*0.33333 - 0.1, 1.0, 1.0)), 1.0);\n    fragColor = foreCol*blend + backCol*(1.0-blend);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdVGDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdVGDW", "name": "Hex Hypnotic v2", "author": "lukaszk159", "description": "First shader version B", "tags": ["hex"], "likes": 2, "viewed": 65, "date": "1570210749", "time_retrieved": "2024-06-20T19:46:39.212404", "image_code": "float HexDist(vec2 p)\n{\n    p = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    col += cos(HexDist(uv)*10.0 + iTime);\n\t\n    col = col * vec3( 0.8, 1, 0.3); col.g = sqrt(col.g);\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdVGDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdVGDy", "name": "Ray marching in the Kaliset", "author": "janiorca", "description": "First ray marching shader. The kaliset provides something fast and easy to compute ray collisions against. \n\nI was trying to keep this reasonably performant on my laptop so I kepth escape count very low. ", "tags": ["raymarch", "kaliset"], "likes": 8, "viewed": 178, "date": "1570899432", "time_retrieved": "2024-06-20T19:46:39.212404", "image_code": "#define steps 850.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = vec3( fragCoord/iResolution.x - vec2( 0.5, 0.5 ), 0.0 );\n\n    vec3 origin = vec3( 0.0, 0.0, 1.0 );\n    vec3 ray_dir = pos - origin ;\n    vec3 c = vec3( -1.05241, -.8134335, -.95455);\n\n    vec3 col;\n    float pitch = iTime / 5.0;\n    float cos_a = cos(pitch);\n    float sin_a = sin(pitch);\n    float yaw = 0.6+sin(iTime/2.0)/3.0;\n    float sin_b = sin( yaw );\n    float cos_b = cos( yaw );\n    mat3 rot_m = mat3( cos_a, 0.0, -sin_a,\n                    sin_a*-sin_b, cos_b, cos_a*-sin_b,\n                    sin_a*cos_b, sin_b, cos_a*cos_b );                        \n\n    origin = rot_m*vec3( 0,0,1.0  + sin(iTime*0.9 ) * .55 ) ;\n    origin.y = .9;\n    ray_dir = rot_m*ray_dir;\n\n    for( float depth = 60.0; depth < steps; depth ++ ) {\n        pos = origin +  depth * ray_dir * 0.003;\n        ray_dir = ray_dir * 1.003;\n        vec3 prev  = vec3( 1,1,1), prev_prev;\n        for( int idx=0; idx< 7;idx++ ) \n        {\n            prev_prev = prev;\n            prev = pos;\n            pos = abs(pos);\n            pos =  pos / dot( pos, pos ) + c;\n            if( dot( pos,pos  )  > 6.89 ) \n            {\n                if( idx  >3  ) \n                {\n                    col = normalize( prev - prev_prev ) / 2.0 + vec3( 0.5, 0.5, 0.5 );\n                } else  \n                {\n\n                  col = normalize( -prev-prev_prev ) / 2.0 + vec3( 0.5, 0.5, 0.5 );\n                } \n                depth = 100000.0;\n                break;\n            }\n        }\n    }    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdVGDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdVGWw", "name": "Moon Flight", "author": "dr2", "description": "No longer a tranquil landscape... (mouseable)", "tags": ["terrain", "lunar", "moonscape"], "likes": 11, "viewed": 381, "date": "1570349498", "time_retrieved": "2024-06-20T19:46:39.235339", "image_code": "// \"Moon Flight\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA    0  // optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCapsAnDf (vec3 p, float r, float w, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HexGrid (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 sunDir, flPos, crMid, qHit;\nvec2 gId, scrMid;\nfloat dstFar, tCur, crFac, hgSize, rScrn;\nint idObj;\nbool isOcc;\nconst int idGrnd = 1, idRkt = 2, idEng = 3, idCage = 4, idScrn = 5;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjCDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r;\n  dMin = dstFar;\n  d = p.y - 0.8;\n  if (d < 0.1) {\n    q = p;\n    d = q.y - 0.5 * Fbm2 (0.3 * q.xz);\n    if (crFac > 0.) {\n      q.xz -= crMid.xz;\n      r = length (q.xz) / crFac;\n      d -= crFac * (0.03 * (1. - smoothstep (0.9, 1., r)) -\n         0.3 * (1. - smoothstep (0.5, 0.9, r)));\n    }\n    DMIN (idGrnd);\n    if (isOcc) {\n      q = p - crMid;\n      d = PrCapsDf (q.xzy, 0.1, 0.14);\n      DMIN (idRkt);\n      q.xz = abs (q.xz) - 0.08;\n      q.y -= -0.08;\n      d = PrCapsDf (q.xzy, 0.03, 0.06);\n      DMIN (idEng);\n    }\n  } else dMin = d;\n  return dMin;\n}\n\nvoid SetGrndConf ()\n{\n  vec2 fRand;\n  float crFrac;\n  crFrac = 0.6;\n  fRand = Hashv2v2 (gId * vec2 (37.3, 43.1) + 27.1);\n  if (fRand.x < crFrac) crFac = 0.;\n  else {\n    fRand.x = (fRand.x - crFrac) / (1. - crFrac);\n    crFac = hgSize * 0.5 * sqrt3 * (0.55 - 0.4 * clamp (2.2 * (fRand.x - 0.5), -1., 1.));\n    crMid.xz = HexToPix (gId * hgSize) + hgSize * max (0., 0.5 * sqrt3 - crFac) * fRand.x *\n       sin (2. * pi * fRand.y + vec2 (0.5 * pi, 0.));\n    crMid.y = 0.5 * Fbm2 (0.3 * crMid.xz) - 0.3 * crFac + 0.15;\n  }\n  isOcc = (crFac > 0.5 && fRand.y > 0.8);\n}\n\nfloat ObjCRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 350; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrndConf ();\n    }\n    d = ObjCDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjCNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjCDf (p + e.xxx), ObjCDf (p + e.xyy), ObjCDf (p + e.yxy), ObjCDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjCSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrndConf ();\n    }\n    h = ObjCDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, len, rad, s, b;\n  dMin = dstFar;\n  len = 1.;\n  rad = 1.;\n  p = flMat * (p - flPos);\n  q = p;\n  q.yz -= vec2 (-0.1 * rad, 0.3 * len);\n  b = length (q.xy);\n  s = (q.z > len) ? 16. * (atan (q.z - len, b) / (2. * pi) + 0.5) : 2. * q.z / len;\n  s = min (abs (fract (s) - 0.5), abs (fract (12. * atan (q.y, - q.x) / (2. * pi)) - 0.5));\n  d = 0.7 * max (max (PrCapsAnDf (q, rad, 0.01 * (1.5 - clamp (20. * s, 0.5, 1.75)), len),\n     -1.25 * len - 0.03 - q.z), 0.2 * rad - b);\n  DMINQ (idCage);\n  q = p;\n  q.yz -= vec2 (-0.14, 0.5);\n  scrMid = q.xy;\n  q.xy = Rot2D (q.xy, pi / 4.);\n  q.xy -= 1.02 * rScrn * sign (q.xy);\n  d = PrCylDf (q, rScrn, 0.003);\n  DMINQ (idScrn);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ErCol (vec3 rd)\n{\n  vec3 erDir, col, vn;\n  float erRad, bs, ts;\n  erDir = normalize (vec3 (0.02, -0.04, 1.));\n  erRad = 0.017;\n  col = vec3 (0.);\n  bs = dot (rd, erDir);\n  ts = bs * bs - 1. + erRad * erRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - erDir) / erRad);\n      col = mix (vec3 (0.3, 0.4, 0.8), vec3 (1., 1., 0.95),\n         smoothstep (0.2, 0.8, Fbm2 (6. * vn.xy + 7.1))) * (0.5 + 0.5 * max (- dot (vn, rd), 0.));\n    }\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf, g;\n  float dstObj, nDotS, sh, s;\n  int idObjS;\n  bool isScrn, showBg;\n  rScrn = 0.03;\n  isScrn = false;\n  showBg = true;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idCage) {\n      col = mix (vec3 (0.45, 0.5, 0.5), vec3 (0.5, 0.5, 0.6), smoothstep (0.4, 0.6,\n         Fbm3 (64. * qHit)));\n      vn = VaryNf (128. * qHit, vn, 0.2);\n    } else if (idObj == idScrn) {\n      if (length (qHit.xy) < 0.95 * rScrn) {\n        ro = flPos;\n        qHit.xy = Rot2D (qHit.xy, - pi / 4.);\n        rd = normalize (vec3 (qHit.xy, - rScrn)).xzy;\n        if (abs (scrMid.y) > abs (scrMid.x)) rd.yz = Rot2D (rd.yz, -0.25 * pi * sign (scrMid.y));\n        else rd.xy = Rot2D (rd.xy, 0.25 * pi * sign (scrMid.x));\n        isScrn = true;\n      } else {\n        col = vec3 (0.6, 0.5, 0.5) * (0.7 + 0.3 * sin (256. * atan (qHit.y, qHit.x)));\n      }\n    }\n    if (! isScrn) {\n      nDotS = max (dot (vn, sunDir), 0.);\n      nDotS *= nDotS;\n      col = col * (0.2 + 0.1 * abs (vn.y) + 0.6 * nDotS * nDotS) +\n         0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      showBg = false;\n    }\n  }\n  if (dstObj >= dstFar || isScrn) {\n    dstObj = (rd.y < 0.) ? ObjCRay (ro, rd) : dstFar;\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ObjCNf (ro);\n      idObjS = idObj;\n      if (idObj == idGrnd) {\n        col4 = vec4 (0.7, 0.6, 0.4, 0.01) * (0.7 + 0.3 * Fbm2 (0.2 * ro.zx));\n        if (crFac > 0.) {\n          g = ro.xz - crMid.xz;\n          s = smoothstep (0.5, 0.9, length (g) / crFac);\n          col4 = mix (col4, vec4 (0.6, 0.5, 0.3, 0.01) * (0.7 + 0.3 * sin (64. * atan (g.y, g.x)) *\n             (0.6 + 0.4 * sin (32. * pi * ro.y)) * s), 1. - s);\n          vf = vec2 (4., 2. + s);\n        } else vf = vec2 (4., 3.);\n        vf.y *= 1. - smoothstep (0.2, 0.6, dstObj / dstFar);\n        if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n        sh = ObjCSShadow (ro, sunDir);\n        col = col4.rgb * (0.2 + 0.1 * max (vn.y, 0.) +\n           0.7 * sh * max (dot (vn, sunDir), 0.)) + col4.a * smoothstep (0.8, 1., sh) *\n           pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      } else {\n        if (idObj == idRkt) {\n          g = Rot2D (ro.xz - crMid.xz, pi / 8.);\n          col4 = mix (vec4 (0.5, 0.5, 1., 0.2), vec4 (1., 1., 1., 0.2),\n             smoothstep (0.45, 0.55, mod (4. * (((length (g) > 0.) ? atan (g.y, g.x) : 0.) /\n             (2. * pi) + 0.5), 1.)));\n        } else if (idObj == idEng) {\n          col4 = vec4 (1., 0.7, 0.4, 0.2);\n        }\n        col = col4.rgb * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) + col4.a * \n           pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      }\n      col *= 1. - smoothstep (0.8, 0.95, dstObj / dstFar);\n      if (isScrn) col *= (dstObj < dstFar && (idObjS == idRkt || idObjS == idEng)) ?\n         vec3 (1.3, 0.3, 0.3) : vec3 (0.4, 0.9, 0.7);\n      showBg = false;\n    } else {\n      col = vec3 (0.);\n      if (! isScrn) col += ErCol (rd);\n    }\n  }\n  if (showBg || idObj == idGrnd && length (col) < 0.03) col += StarPat (rd, 8.);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return t * vec3 (0.1, 0., sqrt (0.99)) + vec3 (2. * cos (0.1 * t), 0., 0.);\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 1.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, 5. * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, c;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.) + 11.1;\n  hgSize = 1.;\n  VuPM (2. * tCur);\n  az = 0.;\n  el = -0.03 * pi;\n  if (mPtr.z > 0.) {\n    az += 1.5 * pi * mPtr.x;\n    el += 1.5 * pi * mPtr.y;\n    az = clamp (az, -0.5 * pi, 0.5 * pi);\n    el = clamp (el, -0.4 * pi, 0.4 * pi);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  flPos.y += 5.;\n  ro = flPos;\n  dstFar = 50.;\n  sunDir = normalize (vec3 (1., 0.5, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.3 * pi * sin (0.1 * tCur));\n  zmFac = 2.6;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  if (abs (uv.y) < 0.85) {\n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = 0.; a < naa; a ++) {\n      rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      rd = vuMat * rd;\n      rd = rd * flMat;\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  } else col = vec3 (0.05);\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCapsAnDf (vec3 p, float r, float w, float h)\n{\n  p.z = abs (p.z);\n  return max (length (p - vec3 (0., 0., min (p.z, h + w))) - r,\n     - length (p - vec3 (0., 0., min (p.z, h - w))) + r) - w;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdVGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdy3DD", "name": "On The Alien Operating Table", "author": "104", "description": "Mouse click = color", "tags": ["2d"], "likes": 10, "viewed": 148, "date": "1570720604", "time_retrieved": "2024-06-20T19:46:39.236369", "image_code": "const float RINGS = 15.;\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord/R.xy-.5;\n    uv.x *= R.x/R.y;\n    vec2 N = uv;\n    uv *= .3;\n    float t = iTime*.2;\n\n    o = vec4(1);\n    for (float i = 1.;i <= RINGS; ++ i) {\n        vec4 h = hash42(vec2(i)+3e2);\n        vec4 h2 = hash42(h.zw*2e2+4e2);\n        h.y -= t * (h.z-.5);\n        h.x += h.y*(h2.w-.5)*2.;\n        h.xy = fract(h.xy-.5)-.5;// repetition\n\n        float sd = 1e3;\n        \n        // cheap variations\n        for (int s = 0; s < 4; ++ s) {\n            vec2 p = fract(h.xy+h2[s]-.5)-.5;\n            float sdextra = length(uv - p) - h2.w*h2[(s+1)%4]*.2;\n            sd = min(sd, sdextra);\n        }\n        \n        float a = .5/clamp(sd*sd*500.*h2.w, .1,1e3);\n        o = mix(o, h2, a);\n\t}\n    float sd = abs(length(uv)-.12)-.01;// center ring\n    o /= max(sd, 1e-3)*80.;\n    o += (hash42(N*1e3+t)-.5)*.2;\n    if (iMouse.z <= 0.)\n\t    o.rgb = mix(o.rgb,(o.rrr+o.g+o.b)/3.,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdy3DD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdy3DR", "name": "Wave interference-ish.", "author": "izo", "description": "Multiple \"objects\" adding to pixel value. Reminiscent of wave interference. ", "tags": ["circle", "smoothing"], "likes": 1, "viewed": 257, "date": "1569986174", "time_retrieved": "2024-06-20T19:46:39.236797", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -=.5;\n    \n    float d = 0.;\n\td += smoothstep(.25,.05,length(uv));\n    d += smoothstep(.24,.05,length(uv+sin(iTime/2.)/2. ));\n\n    // Output to screen\n    fragColor = vec4(vec3(d),1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdy3DR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdy3Rd", "name": "ShaderDojo 040", "author": "antonOTI", "description": "some raymarching experiment.", "tags": ["training"], "likes": 4, "viewed": 266, "date": "1571043040", "time_retrieved": "2024-06-20T19:46:39.237411", "image_code": "mat2 rot(float a)\n{\n    float sa = sin(a); float ca = cos(a);\n    return mat2(ca,-sa,sa,ca);\n}\n\nfloat map(vec3 p)\n{\n    \n    vec3 cp = p;\n    p.xy *= 2.;\n    float r = iTime * .75;\n    for(float i = 0.; i < 5.; ++i)\n    {\n        p = abs(p);\n        p.x -= 1.;\n        p.xy *= rot(r);\n        p.xz *= rot(r * .75);\n        p.yz *= rot(r * .5);\n        r *= .9;   \n    }\n    \n    float dist = max(p.x,max(p.y,p.z)) - 1.;\n    \n    p = abs(cp);\n    \n    float tunnel = max(p.x, p.y) - 15.;\n    \n//    dist = min(dist, -tunnel);\n    \n    return dist;\n}\n\nconst float far = 40.;\nconst float sp = 32.;\n\nfloat ray(vec3 cp, vec3 rd)\n{\n    cp += rd * far;\n    for(float st =0.; st < 1.; st += 1./sp)\n    {\n    \tfloat cd = map(cp);\n        if(cd < .01)\n        {\n            return st;\n        }\n        \n        cp -= rd * cd;\n    }\n    return 1.;\n}\n\nvec3 lookAt(vec3 ro, vec3 rt, vec2 uv)\n{\n    vec3 fd = normalize(rt - ro);\n    vec3 ri = cross(fd, vec3(0.,1.,1.));\n    vec3 up = cross(ri, fd);\n    return fd + ri * uv.x + up * uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) /iResolution.y;\n\n    vec3 ro = vec3(0.,0.,-10.);\n    vec3 rs = vec3(0.,0.,0.);\n    vec3 rd = lookAt(ro,rs,uv);\n    \n    float st = ray(ro, rd);\n    st = 1.-st;\n    \n    fragColor = vec4(st);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdy3Rd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdy3Ww", "name": "Unsymmetrical Dancy Tree Doodle", "author": "machmuel", "description": "Forked from https://www.shadertoy.com/view/wslGz7 from wyatt and added a partial solution to the problem mentioned by him/her: \"I wanted to make a more natural looking tree, but I realized you're  limited to really symetrical trees for this setup.\" \n", "tags": ["fractal", "tree", "kifs"], "likes": 12, "viewed": 510, "date": "1570277284", "time_retrieved": "2024-06-20T19:46:39.237411", "image_code": "// Forked from https://www.shadertoy.com/view/wslGz7\n// Unfortunately, the forking menu is missing in my Chrome browser :-(\n\n// Included partial solution for unsymmetrical trees - but was not able \n// to get rid of some clipping or floating wigs.\n\nvec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n}\n\nvec2 po (vec2 v) {\n\treturn vec2(length(v),atan(v.y,v.x));\n}\nvec2 ca (vec2 u) {\n\treturn u.x*vec2(cos(u.y),sin(u.y));\n}\nfloat ln (vec2 p, vec2 a, vec2 b) { \n    float r = dot(p-a,b-a)/dot(b-a,b-a);\n    r = clamp(r,0.,1.);\n    p.x+=(0.7+0.5*sin(0.1*iTime))*0.2*smoothstep(1.,0.,abs(r*2.-1.))*sin(3.14159*(r-4.*iTime));\n    return (1.+0.5*r)*length(p-a-(b-a)*r);\n}\nvoid mainImage( out vec4 Q, in vec2 U )\n{   vec2 R = iResolution.xy;\n \tfloat r = 1e9;\n \tvec2 mouse = 2.*iMouse.xy/iResolution.xy-1.; // -1 1 \n \tU = 4.*(U-0.5*R)/R.y;\n \tU.y += 1.5;\n \tQ = vec4(0);\n \tfor (int i = 1; i < 16; i++) {\n        U = ca(po(U)+0.3*(sin(2.*iTime)+0.5*sin(4.53*iTime)+0.1*cos(12.2*iTime))*vec2(0,1));\n        r = min(r,ln(U,vec2(0),vec2(0,1.)));\n        U.y-=1.;\n        \n        vec2 n = N(2.2);\n        float d = dot(U, n);\n        U -= min(0.,d)*n*2.;\n        \n        U.x=abs(U.x);\n        U*=1.4+0.1*sin(iTime)+0.05*sin(0.2455*iTime)*(float(i));\n        U = po(U);\n        U.y += 1.+0.5*sin(0.553*iTime)*sin(sin(iTime)*float(i))+0.1*sin(0.4*iTime)+0.05*sin(0.554*iTime);\n        U = ca(U);\n        \n        \n        Q+=sin(1.5*exp(-1e2*r*r)*1.4*vec4(1,-1.8,1.9,4)+iTime);\n        \n \t\t\n \t}\n \tQ/=18.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdy3Ww.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdy3zK", "name": "Shadertober 08 - Frail", "author": "BackwardsCap", "description": "Fractals are frail, right?", "tags": ["fractal", "mandelbulb", "inktober", "shadertober", "frail", "backwardscaptain"], "likes": 13, "viewed": 508, "date": "1570564736", "time_retrieved": "2024-06-20T19:46:39.239141", "image_code": "#define MAX_DIST 20.0\nfloat g;\nfloat bulb(vec3 p)\n{\n    \n    vec3 z = p;\n    \n    {\n        const float exBR = 1.5;\n        float r = length(p)-exBR;\n        if(r>1.0){return r;}\n    }\n    \n    float dr =1., r=0., pw = 8., fr=.0, theta, phi, zr;\n    for(int i=0;i<10;i++)\n    {\n        \n        r=length(z);\n        if(r>2.)\n        {\n            fr = min(0.5*log(r)*r/dr, length(p)-.72);\n            break;\n        }\n        theta=acos(z.z/r)+iTime/10.;\n        phi = atan(z.y,z.x);\n        dr = pow(r,7.)*7.*dr+1.;\n        \n        zr = pow(r,pw);\n        theta = theta*pw;\n        phi = phi*pw;\n        \n        z=zr*vec3(sin(theta)*cos(phi),\n                  sin(phi)*sin(theta),\n                  cos(theta))+p;\n    }\n    \n    return fr;\n    \n}\n\nfloat map(vec3 p)\n{\n    float s = bulb(p);\n    \n    g+=0.1/(0.1+s*s);\n    \n    return s;\n}\n\nfloat ray(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0;i<100;i++)\n    {\n        \n        vec3 p = ro+rd*t;\n        float s = map(p);\n\n        if(s<0.00001)break;\n        t+=s;\n        if(t>MAX_DIST)break;\n        \n    }\n    if(t>MAX_DIST)t=-1.;\n    \n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e= vec2(0.005,0.);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n        ));\n}\n\nvec3 color(vec3 ro, vec3 rd, float r)\n{\n    vec3 c = vec3(0.);\n    vec3 cs = 0.5 + 0.5*cos(iTime+rd.xyx+vec3(0,2,4));\n    \n    if(r>0.)\n    {\n        vec3 p = ro+rd*r;\n        vec3 n = normal(p);\n        vec3 sun = normalize(vec3(0.2,0.5,0.3));\n        float dif = clamp(dot(sun,n),0.0,1.0);\n        float sky = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.,1.);\n        \n        c=vec3(r)*-.1;\n        c+=cs*r*dif;\n        c+=r*sky*vec3(0.9,0.5,0.5);\n        \n    }\n    \n    \n    return c+(g/75.*cs);\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.y;\n\n    \n    float d = 1.2, t=3.1415927/2.;\n    vec3 ro = vec3(cos(t)*d,0,sin(t)*d);\n    \n    vec3 ta = vec3(0);\n    \n    vec3 cf = normalize(ta-ro);\n    vec3 cu = normalize(cross(cf,vec3(0,1,0)));\n    vec3 cr = normalize(cross(cf,cu));\n    \n    float dst =( min((1.+cos(iTime/5.))/2.+.1,1.)*.5)/2.+.3;\n    vec3 rd = normalize(uv.x*cu+uv.y*cr+dst*cf);\n    \n    float r = ray(ro,rd);\n\n    c = vec4(color(ro,rd,r),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdy3zK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdy3zV", "name": "Distortion spheres ;)", "author": "MeleeCampz", "description": "Lots of distorting spheres ;)\nStill a bit buggy in terms of distrubution and a lot of headroom for performance", "tags": ["refraction", "spheres"], "likes": 2, "viewed": 140, "date": "1570574563", "time_retrieved": "2024-06-20T19:46:40.060967", "image_code": "struct CircleData\n{\n    vec2 uv;\n    float number;\n    float cr;\n    float distScale;\n    float offsetScale;\n    float time;\n    float speed;\n    vec2 idOff;\n};\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//rotate incoming vector\nvec2 rot(vec2 inVec, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(\n        inVec.x * c - inVec.y * s,\n        inVec.x * s + inVec.y * c);\n}\n\n\n//Vec3 x,y = offset; z = mask\nvec3 circleUV(vec2 uv, vec2 offset, float radius)\n{\n    vec2 off = (uv - offset);\n  \tfloat mask = step(-radius, -length(off));\n    vec2 cv =  off/radius;\n    vec2 maskedOff = cv * mask;\n    \n    return vec3(maskedOff, mask);\n}\n\n//smooth 2dnoise based on textures that moves with time\nvec2 smNoiseOff(vec2 uv, vec2 scale, float str)\n{\n    return texture(iChannel2, uv * scale + iTime * 0.1).xy * str;\n}\n\n//Return uv offset + mask of circle\nvec3 GetCircleOffset(vec2 uv, vec2 center, float radius)\n{\n    vec3 circle = circleUV(uv, center, radius);\n    vec2 cv = circle.xy;\n    float cm =circle.z;\n    \n    vec2 cvOff = pow(cv,vec2(3.)) * 2.;\n    cvOff += smNoiseOff(uv, vec2(2.), .5) * cm;\n    \n    return vec3(cvOff, cm);\n}\n\n//Generates a custer of circles\nvec3 multiCircleOffset(CircleData data)\n{\n    vec3 off = vec3(0);\n    \n    for(float y=-data.number; y<= data.number; y++)    \n    {\n     \tfor(float x=-data.number; x<= data.number; x++)    \n    \t{            \n            vec2 pos = vec2(x,y);\n          \tpos += data.idOff;// <----- id randomizer\n            \n            vec2 offCenter = vec2(hash21(pos.xy)-1.,hash21(pos.yx)-1.)* data.offsetScale;\n            offCenter += .5;\n            \n            vec2 offTime = vec2(data.time * data.speed + sin(data.time * data.speed * .5) * 0.2) * (offCenter*0.5);\n            float crOff = (sin(offTime.x)*.5+.5) * data.cr;\n            \n            vec2 cc = vec2(sin(offTime.x), cos(offTime.y)) * data.distScale + offCenter;\n            off += GetCircleOffset(data.uv, cc, data.cr + crOff);\n        }\n    } \n    \n    return off;\n}\n\n//Samples neighbour cells to allow for overlaps\n//Expensive but easy to implement\nvec3 multiCircleOffsetMultiCell(CircleData data, int range)\n{\n    CircleData cpy = data;\n    vec3 avg = vec3(0);\n    for(int y = -range; y <= range; y++)\n    {\n        for(int x = -range; x <= range; x++)\n        {\n            vec2 idlocal = vec2(1);\n            idlocal *= vec2(x,y);\n            \n            cpy.uv = data.uv + idlocal * 2.;\n            cpy.idOff = data.idOff - idlocal;\n            \n            avg += multiCircleOffset(cpy);\n        }\n    }\n    return avg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5*iResolution.xy)/ iResolution.y;\n    vec3 col = vec3(0.);    \n        \n    //Dynamic zoom\n    vec2 uvm = uv * 3.;\n    uvm *=  sin(iTime * 0.25) * 0.3 + 1.;\n    \n    //Rotate bg\n    uv = rot(uv, iTime * 0.1);\n    \n    //Dynamic pan\n    float panTime = iTime * 0.1;\n    float panScale = 0.1;\n    uv += vec2(sin(panTime),cos(panTime)* panScale);\n        \n    //Gridify cells\n    float gridCells = 2.; //Bug here!! why is only two working for this O_o?\n    vec2 gv = fract(uvm )* gridCells - vec2(gridCells * 0.5);\n    vec2 id = floor(uvm);\n   \n    \n    //Modulate circle radius with time and music\n    float musicMod = texture(iChannel1, vec2(0.,-.5)).x * 0.1;\n    float cr = sin(iTime) * 0.01 + (0.3 +  musicMod);    \n    cr *= 0.3;\n    \n    //Circle params <----- Circle Cluster Config!\n    float speed = 2.6;\n    float time = iTime + 1000.;\n    float number = 2.;\n    float distScale = 1.8 + sin(iTime * 0.3)*.5-.5;\n    float offsetScale = 1.5;\n    int range = 1;\n    CircleData data = CircleData(gv, number, cr, distScale, offsetScale,time, speed, id); \n    \n    //Get circle uv distortion\n    vec3 circleOff = multiCircleOffsetMultiCell(data, range) * 0.05;\n    vec2 uvRef = uv +circleOff.xy;\n    \n    //Sample bg with offset\n  \tcol += texture(iChannel0, uvRef).xxx;\n    //Enhance circle to background contrast\n    col *= 0.3 + circleOff.z * 3.0;\n    //USe mask to color only bubbles\n    col += vec3(circleOff.z,0,sin(iTime*0.1) * circleOff.z) * 0.5;\n    \n    //Debug grid\n    float gridWidth = 0.01;\n  \t//col += vec3(1.,.0,.0) * max(step(1.- gridWidth, gv.x), step(1.- gridWidth, gv.y));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdy3zV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyGDK", "name": "ShaderTober - Pattern", "author": "Flopine", "description": "A small doodle with inktober's theme \"Pattern\".  \nThis one is mostly inspired by this tutorial from The Art of Code : https://www.youtube.com/watch?v=cQXAbndD5CQ but with hexagonal grid ;) ", "tags": ["2d", "grid", "wor", "hexagone"], "likes": 5, "viewed": 174, "date": "1570957569", "time_retrieved": "2024-06-20T19:46:40.479036", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// This one is mostly inspired by this tutorial from The Art of Code : \n// https://www.youtube.com/watch?v=cQXAbndD5CQ\n// But with hexagonal grid ;) \n\n#define hr vec2(1.,sqrt(3.))\n#define PI 3.141592\n\nfloat xor (float a, float b)\n{return (1.-a)*b + (1.-b)*a;}\n\nfloat hdist (vec2 uv)\n{\n    uv = abs(uv);\n    return max(uv.x, dot(uv, normalize(hr)));\n}\n\n\nvec3 hgrid (vec2 uv)\n{\n    uv *= 4.;\n    \n    vec2 ga = mod(uv,hr)-hr*0.5;\n    vec2 gb = mod(uv-hr*0.5,hr)-hr*0.5;\n    vec2 guv = (dot(ga,ga) < dot(gb,gb)) ? ga : gb;\n    \n    float m = 0.;\n    vec2 id = guv - uv;\n    \n    float dist = length(id)*5.;\n    for(float i = -1.; i<=1.;i++)\n    {\n     \tfor(float j = -1.; j<=1.;j++)\n    \t{\n        \tvec2 offset = vec2(i,j);\n            float r = mix(0.5,1.8,sin(iTime-dist)*0.5+0.5);\n            float d = hdist(guv-offset);\n            m = xor(m,smoothstep(r,r*0.95, d));\n    \t}   \n    }\n    return vec3(m,id);\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b * cos(2.*PI*(c*t+d));}\n\nvec3 frame (vec2 uv)\n{\n\tvec3 hg = hgrid(uv);\n    return palette(length(uv*2.),\n                   vec3(0.5), \n                   vec3(0.5), \n                   vec3(hg.x*0.3), \n                   vec3(0.2,0.,0.7));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = frame(uv);\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyGDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyGDm", "name": "Fiery bobs", "author": "janiorca", "description": "A long time ago amiga demos had bobs in them (blitter  objects) This is creating the same movement with a fire color effect", "tags": ["fire", "sin", "bob"], "likes": 4, "viewed": 114, "date": "1570298943", "time_retrieved": "2024-06-20T19:46:40.727588", "image_code": "#define num_dots 50\n#define step_size 400.0\n#define step_width 1000.0\n\nconst vec3 colors[3] = vec3[3] (\n    vec3( 1.0, 0.0, 0.0  ),\n    vec3( 0, 1.0, 0.0 ),\n    vec3( 0, 0.0, 1.0 )\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sc = vec2( 0.5, 0.5*iResolution.y/iResolution.x );\n    vec2 pos = fragCoord/iResolution.x - sc;\n    \n    vec2 dots[ num_dots ];\n\n    float charge = 0.0;\n    float g = iTime*0.012 + 0.89;\n    float f = iTime*0.0452 + 0.389;\n    for( int idx=0; idx<num_dots;idx++ ) \n    {\n        vec2 charge_pos  = vec2(sin( iTime*0.823+float(idx)*g )*0.417,\n                            sin( iTime*0.5125+float(idx)*f)*0.25);\n        float chr = 2.0+sin( iTime*1.4231 + float(idx)*0.9232)*2.0;                            \n        charge = charge + chr / dot( pos-charge_pos, pos-charge_pos);\n    }    \n\n    vec3 final_color = vec3( 0.0, 0.0, 0.0 );\n    for( int c=0; c<3; c ++ ) \n    {\n        float intensity = smoothstep( 1000.0 + float(c)*step_size, \n                1000.0 + float(c)*step_size + step_width, charge);\n\n        final_color = final_color + colors[ c ]*intensity;\n    }\n    fragColor = vec4(final_color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyGDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyGWK", "name": "Hallomeowy", "author": "zxxuan1001", "description": "Be spooky.", "tags": ["glow", "spooky"], "likes": 18, "viewed": 538, "date": "1572507740", "time_retrieved": "2024-06-20T19:46:40.733608", "image_code": "#define PI 3.1416\n#define TERRAIN_PATTERN 4.0*sin(12.0*pos.x)+sin(20.0*pos.y)+sin(15.0*pos.z)\n#define SPEED aTime*0.2\n#define MAX_DIST 40.0\n#define MAX_STEP 60\n#define LIGHT_DIRECTION vec3(0.8,0.2,1.0)\n#define LIGHT_INTENSITY vec3(0.5,1.0,2.0)*2.0\n#define SKY_COLOR vec3(0.01, 0.01, 0.02)\n#define TERRAIN_COLOR vec3(0.01,0.02,0.03)\n#define GLOW_COLOR vec3(0.1,0.85,1.2)\n#define RIM_POWER 0.25\n#define AA_SIZE 1\n\nvec3 rotateY(vec3 p, float rad) {\n    p.x = cos(rad)*p.x + sin(rad)*p.z;\n    p.z = -sin(rad)*p.x + cos(rad)*p.z;\n    return p;\n}\n\nvec3 rotateZ(vec3 p, float rad) {\n    p.x = cos(rad)*p.x - sin(rad)*p.y;\n    p.y = sin(rad)*p.x + cos(rad)*p.y;\n    return p;\n}\n\nfloat sdSphere(in vec3 pos, in float r)\n{\n    return length(pos)-r;\n}\n\n//http://iquilezles.org/www/articles/ellipsoids/ellipsoids.htm\nfloat sdElipsoid(in vec3 pos, in vec3 r)\n{\n    float k0 = length(pos/r);\n    float k1 = length(pos/r/r);\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\n//http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(in float a, in float b, in float k)\n{\n    float h = max( k - abs(a-b), 0.0);\n    return min(a,b) - h*h*0.25/k;\n}\n\nfloat smax(in float a, in float b, in float k)\n{\n    float h = max( k - abs(a-b), 0.0);\n    return max(a,b) + h*h*0.25/k;\n}\n\nvec4 sdUnion(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x)? d1:d2;\n}\n\nvec3 opRepLim( in vec3 p, in float s, in vec3 lim )\n{\n    return p-s*clamp(round(p/s),-lim,lim);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat tombStone(vec3 p) {\n    float b = 4.0;\n    vec3 rep = vec3(mod(abs(p.x),b)-2.5, p.y, mod(abs(p.z+1.5), b)-2.5);\n    vec2 id = vec2(floor(abs(p.x)/b),floor((p.z+1.5)/b));\n    float fid = id.x*133.3 + id.y*311.7;\n    float wr = 0.5+0.3*sin(fid);\n        \n    vec3 newP = rotateY(rep, wr);\n    newP = rotateZ(newP, 0.2*wr);\n    float d = sdRoundBox( newP, vec3(wr*0.5, wr, 0.04), 0.03);\n    return d;\n}\nfloat streetlight(vec3 p) {\n    p -= vec3(0.0,0.5,-2.0);\n    \n    //vec3 rep = opRepLim(p, 8.0, vec3(2.0, 0.0, 2.0));\n    vec3 rep = opRep(p, vec3(12.0, 0.0, 12.0));  \n    float t = iTime*0.5;\n    float d = sdCappedCone(rep, 5.0+2.0*sin(p.x*0.2+p.z*0.5+t), 0.01, 1.8 ) + 0.1*sin(p.z*3.0+p.y*2.0+iTime);\n    d *= 0.6;\n    return d;\n}\n\nvec4 map(in vec3 pos, float aTime)\n{\n    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n    float t = fract(aTime);\n    float y = 3.0*t*(1.0-t); \n    float sinT = sin(aTime);\n    vec3 cen = vec3(0.0,0.55,SPEED);\n    float sy = 0.8 + 0.2*y;\n    float sz = 1.0/sy;\n    vec3 r = vec3(0.35,0.32+0.05*sy,0.25+0.05*sz);\n    vec3 q = pos-cen;\n    vec3 h = q;\n    \n    //body \n    float ta0 = step(fract(aTime*10.0),0.99);\n    h.z -= 3.0;\n    h.z += ta0*9.0;\n    float d = sdElipsoid(h-vec3(0.0, 0.03, -0.09), r);\n    {\n    \n    //head \n    float d1 = sdElipsoid(h - vec3(0.0, 0.32, 0.01), vec3(0.28, 0.2, 0.18));\n    float d2 = sdElipsoid(h - vec3(0.0, 0.30, -0.07), vec3(0.2));\n    d2 = smin(d1, d2, 0.08);\n    d = smin(d, d2, 0.08);\n    \n    vec3 sh = vec3(abs(h.x), h.yz);//symmetric along x\n    \n    //ears\n    d2 = sdElipsoid(sh - vec3(0.15, 0.47, -0.05), vec3(0.06, 0.09, 0.04));\n    d = smin(d, d2, 0.08);\n    res = vec4(d,2.0,0.0,0.0);  \n     \n    //eyes\n    float d3 = sdSphere(sh - vec3(0.068,0.4,0.108), 0.07);\n    res = sdUnion(res, vec4(d3,3.0,0.0,0.0));\n    \n    //terrain\n    float fh = -0.05+0.05*(sin(2.5*pos.x) + sin(1.5*pos.z));\n    float d4 = pos.y - fh;\n    d4 -= .01*texture(iChannel0, pos.xz).x;\n    res = sdUnion(res, vec4(d4,0.0,0.0,0.0));\n    \n    //tombstone\n    float d5 = tombStone(pos);\n    res = sdUnion(res, vec4(d5,1.0,0.0,0.0));\n    \n    //light\n    float d6 = streetlight(pos);\n    res = sdUnion(res, vec4(d6,4.0,0.0,0.0));\n    \n    float glow = d6;\n    res.w = glow;\n        \n    float shadow = min(d4, d5); \n    res.z = shadow;\n    }\n    \n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float aTime)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float h = 0.01 + 0.32*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, aTime ).x;\n        occ += (h-d)*sca;\n        sca *= 0.85;\n        \n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 calcNormal(in vec3 pos, in float aTime)\n{\n    vec2 e = vec2(0.001,0.0);\n    return normalize( vec3(map(pos + e.xyy,aTime).x - map(pos - e.xyy,aTime).x,\n                          map(pos + e.yxy,aTime).x - map(pos - e.yxy,aTime).x,\n                          map(pos + e.yyx,aTime).x - map(pos - e.yyx,aTime).x) );\n}\n\nfloat castShadow(in vec3 ro, in vec3 rd, in float aTime)\n{\n    float res = 1.0;\n    float t = 0.01;\n    float tMax = MAX_DIST;\n    \n    for (int i=0; i<MAX_STEP;++i)\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos,aTime).z;\n        res = min( res, 16.0*h/t );\n        if (res<0.01 || t > tMax) break;\n        t += h;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd, in float aTime)\n{\n   float t = 0.01;\n   vec4 m = vec4(0.0);\n   float tMax = MAX_DIST;\n   float minDist = MAX_DIST;\n   for ( int i = 0; i < MAX_STEP; ++i )\n   {\n       vec3 pos = ro + t*rd;\n       vec4 h = map( pos,aTime );\n       minDist = min(minDist, h.w/t);\n       m.x = t;\n       m.y = h.y;\n       m.z = minDist;\n       m.w = h.w;\n       \n       if ( abs(h.x)<(0.001*t) || t>tMax ) break;\n       t += h.x;\n   } \n    \n   if ( t>tMax )\n   {\n       m.x = MAX_DIST;\n       m.y = -1.0;\n       m.w = MAX_DIST;\n   }\n   \n   return m;\n}\n\nvec3 render(in vec2 fragCoord, in float aTime)\n{\n    vec2 p = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 mouse = 2.0*iMouse.xy/iResolution.xy-1.0;\n    float angle = 10.0*iMouse.x/iResolution.x;\n    \n    vec3 ta = vec3(0.0,0.85,3.0+SPEED);\n    vec3 ro = ta+vec3( 1.0*sin(angle), 0.0, 1.0*cos(angle) );;\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross( ww, vec3(0.0, 1.0, 0.0) ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n    \n    \n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0*ww);\n    vec3 mDir = LIGHT_DIRECTION;\n    vec3 bg = SKY_COLOR;\n    vec3 col = bg;\n    \n    vec2 uv = rd.xz/rd.y; //sky dome( intersect the top )\n    \n    vec4 tm = castRay(ro, rd, aTime);\n    float t = tm.x;\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal(pos, aTime);\n    vec3 mate = vec3(0.0);\n    float occ = calcOcclusion( pos, nor, aTime );\n    float fresnel = clamp(1.0+dot(nor,rd),0.0,1.0);\n    float mDiff = clamp( dot(nor, mDir),0.0,1.0 );\n    float mShadow = castShadow(pos+nor*0.01, mDir, aTime);\n    if ( tm.x < MAX_DIST )\n    {  \n        if (tm.y == 0.0) {\n            mate = TERRAIN_COLOR;//terrain\n        } \n        else if (tm.y == 1.0){\n           mate = vec3(0.1);\n           mate += RIM_POWER*GLOW_COLOR*fresnel;    \n        }\n        else if (tm.y==2.0)\n        {\n            mate = vec3(0.5); //body\n            mDiff = 0.0;\n        } \n        else if (tm.y==3.0)\n        {\n            mate = vec3(1.0); //eyes\n            mDiff = 1.0;\n        }\n        else if (tm.y==4.0)\n        {\n            mate = vec3(0.0,0.5,0.5); //light\n            mate += step(fract(pos.y*3.0),0.25)*vec3(2.0,0.0,2.0);\n    \t\tmate += step(fract(pos.y*1.5),0.15)*vec3(0.0,2.0,2.0);\n            mDiff = 1.0;\n            mShadow = 1.0;\n            occ = 1.0;\n        }  \n       \n        col = mate*LIGHT_INTENSITY*mDiff*mShadow;\n        col *= occ*occ; \n        \n    } \n    \n    // fog\n    col = mix( col, vec3(0.0,0.05,0.05), 1.0-exp( -0.003*t*t ) );\n    \n    float glow = 0.1*exp(-64.0*tm.z); \n    col += GLOW_COLOR*glow;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    vec2 off = vec2(0.0);\n    \n#if AA_SIZE>1\n    //anti aliasing & motion blur\n    for (float aaY = 0.0; aaY < float(AA_SIZE); ++aaY)\n    {\n        for (float aaX = 0.0; aaX < float(AA_SIZE); ++aaX)\n        {\n            off = -0.5+vec2(aaY,aaX)/float(AA_SIZE);\n            \n            float md = texelFetch(iChannel0, ivec2(fragCoord)&255, 0).x;\n            float mb = (aaY*float(AA_SIZE)+aaX)/(float(AA_SIZE*AA_SIZE-1));\n            mb += (md-0.5)/float(AA_SIZE*AA_SIZE);\n            float aTime = iTime - mb*0.5*(1.0/24.0); //1 frame in 24fps for film\n#else\n            float aTime = iTime;\n#endif\n            col += render(fragCoord+off, aTime);\n             \n            \n#if AA_SIZE>1\n        }\n    }\n    col /= float(AA_SIZE*AA_SIZE);\n#endif\n    \n    //gamma\n    col = pow( col, vec3(0.4546));\n   \n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyGWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyGzK", "name": "Flight through a nebula", "author": "Delvar", "description": "Simple fly though of a 3d voronoi via ray marching added lightning, mouse to look around.", "tags": ["voronoi", "noise", "raymarch", "cloud", "nebula"], "likes": 9, "viewed": 306, "date": "1570631309", "time_retrieved": "2024-06-20T19:46:41.515483", "image_code": "// also see \n// voronoi  version, https://www.shadertoy.com/view/tdyGzK\n// simplex version, https://www.shadertoy.com/view/WsG3zd\n// box version, https://www.shadertoy.com/view/tsK3Rd\n\n#define RAY_MAX_STEPS 30\n#define RAY_MAX_DISTANCE 10.0\n#define RAY_CAMERA_FADE_START_DISTANCE 0.5\n#define RAY_CAMERA_FADE_END_DISTANCE 2.0\n#define RAY_MAX_STEPS_SHADOW 15\n\n#define K\t0.1428571428571429\t// 1/7\n#define Ko\t0.3571428571428571\t// 1/2-(K/2)\n#define K2\t0.0204081632653061\t// 1/(7*7)\n#define Kz\t0.1666666666666667\t// 1/6\n#define Kzo\t0.4166666666666667\t// 1/2-(1/(6*2))\n#define Km\t0.0034602076124567\t// 1/289\n#define PI\t3.1415926535897932384626433832795\n    \n\nstruct camera {\n   vec3 origin, forward, right, up;\n   float zoom; // Distance from screen\n};\n\nstruct ray {\n   vec3 origin, direction;\n};\n       \ncamera getCameraDirection(vec3 origin, vec3 direction, float zoom) {\n   camera camera;\n   camera.origin = origin;\n   camera.forward = normalize(direction);\n   camera.right = cross(vec3(0.0,1.0,0.0), camera.forward);\n   camera.up = cross(camera.forward, camera.right);\n   camera.zoom = zoom;\n   return camera;\n}\n\nray getRay(vec2 uv, camera camera) {\n\tray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n\treturn ray;   \n}\n\nfloat mod289(float x) {\n\treturn x - floor(x * Km) * 289.0;\n}\n\nfloat mod7(float x) {\n\t//return x;\n\treturn x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n//Wrap around for id generation\nfloat wrap(float x) {\n\t//return mod((34.0 * x + 1.0) * x, 289.0);\n    return mod289((34.0 * x + 1.0) * x);\n}\n\nvec3 idToPoint(vec3 id) {\n    vec3 point;\n    point.x = fract(id.z * K) - Ko;\n\t//point.y = mod(floor(id.z * K),7.0) * K - Ko;\n    point.y = floor(id.z * K) * K - Ko;\n\tpoint.z = floor(id.z * K2) * Kz - Kzo;\n    return point;\n}\n\nfloat voronoiNoiseDistance(vec3 samplePoint){\n    vec3 pointI = mod(floor(samplePoint),289.0);\n    vec3 pointF = fract(samplePoint);\n\n    float minDistance= 9999.0;\n    vec3 id;\n    vec3 offset;\n    \n    for(float i=-1.0;i<=1.0;i++) {\n        offset.x = i;\n        id.x= wrap(pointI.x + i);\n\t\tfor(float j=-1.0;j<=1.0;j++) {\n            offset.y=j;\n            id.y = wrap(id.x + pointI.y + j);\n            for(float k=-1.0;k<=1.0;k++) {\n                offset.z=k;\n            \tid.z = wrap(id.y + pointI.z + k);\n                vec3 pointFract = fract(idToPoint(id));\n                vec3 pointPos = pointFract + offset;\n                vec3 dPosition = pointF - pointPos;\n                float squareDistance = dot(dPosition,dPosition);\n    \t\t\tminDistance = min(minDistance, squareDistance);\n\t\t\t}\n\t\t}\n\t}\n\treturn  clamp(minDistance,0.0,1.0);\n}\n\nvec3 RayMarch(ray ray, float maxDistance, int maxSteps)\n{\n    float maxStepsf = float(maxSteps);\n    float stepSize = maxDistance/maxStepsf;\n    vec3 total = vec3(0.0);\n    \n    // Stop the shimmering??\n    float currentDistance = stepSize-(ray.origin.z-(floor(ray.origin.z/stepSize)*stepSize));\n    \n    float strike = 1.0+smoothstep(0.5,1.0,sin(ray.direction.z+iTime*20.0)*sin(ray.direction.x +iTime*30.0)*cos(ray.direction.y +iTime*40.0)*(wrap(iTime)/289.0));\n    \n    for(float i=0.0; i<maxStepsf; i++) {\n\t\tvec3 currentPoint = ray.origin + ray.direction * currentDistance;\n        float s = voronoiNoiseDistance(currentPoint);\n        s=smoothstep(0.1,1.0,s);\n        float stepf = ((maxStepsf - i)/maxStepsf);\n        s *= stepf;\n        vec3 light = sin((currentPoint+vec3(iTime/10.0,iTime/13.0,iTime/15.0))/4.0)*0.5+1.0; //Yes we blow out the colour a little.\n        total += light*s;\n        currentDistance += stepSize;\n    }\n    return (total*(3.0/maxStepsf))*strike;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n    //Snap to center on startup.\n    if(iMouse.x <= 1.0 && iMouse.y <= 1.0) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    // -- 1st person cammera\n    vec3 forward = vec3(\n        sin(mouse.x*PI),\n    \tsin(mouse.y*PI),\n    \tcos(mouse.x*PI)\n    );\n    camera camera = getCameraDirection(vec3(0.0,0.0,iTime), forward, 0.5);\n    \n    ray ray = getRay(uv, camera);\n\tvec3 colour = RayMarch(ray, RAY_MAX_DISTANCE, RAY_MAX_STEPS);\n    float gamma = 0.8;\n    colour = pow(colour, vec3(1.0/gamma));\n    \n    fragColor = vec4(colour,1.0);\n\n   \n  /*  \n    vec3 samplePosition = vec3(uv.xy*4.0,iTime*0.1);\n    vec3 samplePositionf = fract(samplePosition);\n    float s = 0.0*voronoiNoiseDistance(samplePosition);\n    vec3 s3= smoothstep(vec3(0.95),vec3(1.0),samplePositionf) + smoothstep(vec3(0.05),vec3(0.0),samplePositionf);\n\tfragColor = vec4(max(s3,vec3(s)),1.0); \n*/\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyGzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlf3RX", "name": "大龙猫 - 中国", "author": "totetmatt", "description": "Releasing as it's national day. \nWanted to see how hard it would be to build chinese characters. Just asking for patience :-D\nMost of functions from https://iquilezles.org/ :)", "tags": ["china", "hanzi", "shadertober", "octshader"], "likes": 1, "viewed": 249, "date": "1569951120", "time_retrieved": "2024-06-20T19:46:41.521588", "image_code": "#define pi 3.141592\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sphere(vec3 p, float radius)\n{\n    return length(p)- radius;\n}\n// 中\nfloat zhong(vec3 p){\n \n    vec3 pLeft = p+vec3(2.1,-0.5,0.);\n    float left = sdCappedCylinder(pLeft,vec2(.1,.7));\n    \n    \n    vec3 pRight = p+vec3(.4,-0.5,0.);\n    float right = sdCappedCylinder(pRight,vec2(.1,0.7));\n    \n    vec3 pTop = (p+vec3(1.25,-1.15,0.)).yxz;\n    float top = sdCappedCylinder(pTop,vec2(.1,1.));\n     \n    \n    vec3 pDown = (p+vec3(1.25,0.,0.)).yxz;\n    float down = sdCappedCylinder(pDown,vec2(.1,1.));\n    \n    \n    vec3 pMiddle = p+vec3(1.25,0.,0.);\n    float middle = sdCappedCylinder(pMiddle,vec2(.1,1.5));\n    \n    \n    return fOpUnionStairs(\n                            fOpUnionStairs(\n                  \t\t\t\tfOpUnionStairs(right,left,.1,3.),\n                   \t\t\t\tfOpUnionStairs(top,down,0.1,3.),\n                                .1,\n                                3.),\n                             middle,\n                               .1,\n                               3.);\n\n}\n//国\nfloat guo(vec3 p) {\n\n    vec3 pLeft = p+vec3(2.,0.0,0.);\n    float left = sdCappedCylinder(pLeft,vec2(.1,1.5));\n    \n    \n    vec3 pRight = p+vec3(-.5,0.,0.);\n    float right = sdCappedCylinder(pRight,vec2(.1,1.5));\n    \n    vec3 pTop = (p+vec3(0.9,-1.30,0.)).yxz;\n    float top = sdCappedCylinder(pTop,vec2(.1,1.3));\n     \n    \n    vec3 pDown = (p+vec3(0.9,1.30,0.)).yxz;\n    float down = sdCappedCylinder(pDown,vec2(.1,1.3));\n    \n    \n    \n    \n    vec3 pMiddle = p+vec3(.70,0.,0.);\n    float middle = sdCappedCylinder(pMiddle,vec2(.1,1.));\n    \n    vec3 pMiddleTop = (p+vec3(0.7,-1.,0.)).yxz;\n    float middleTop = sdCappedCylinder(pMiddleTop,vec2(.1,0.9));\n    \n    \n    vec3 pMiddleMiddle = (p+vec3(0.7,.0,0.)).yxz;\n    float middleMiddle = sdCappedCylinder(pMiddleMiddle,vec2(.1,0.7));\n    \n    vec3 pMiddleDown = (p+vec3(0.7,1.,0.)).yxz;\n    float middleDown = sdCappedCylinder(pMiddleDown,vec2(.1,0.9));\n    \n    vec3 pMiddleDot = (p+vec3(-.1,.8,0.)).yxz;\n    pMiddleDot.xy *= rotate2d(-45.);\n    float middleDot= sdCappedCylinder(pMiddleDot,vec2(.1,0.3));\n    \n    float st = 3.;\n    float l = 0.05;\n    float kou = fOpUnionStairs(\n        \t\t\t\t\t\tfOpUnionStairs(\n                                    fOpUnionStairs(right,left,.1,st),\n                                    fOpUnionStairs(top,down,.1,st),\n                                    .1,\n                                    st),\n        \t\t\t\t\t\tmiddleDot,\n    \t\t\t\t\t\t\t.1,\n    \t\t\t\t\t\t\tst);\n    float sheng = fOpUnionStairs(middleDown,fOpUnionStairs(middleMiddle,\n                                     fOpUnionStairs(middleTop,middle,l,st),\n                                     l,\n                      \t\t\t\t st),\n                                 l,\n                                 st);\n    return fOpUnionStairs(kou,sheng,l,st);\n}\nfloat SDF(vec3 p){\n    \n     p *= .5;\n    float s = sphere(p+vec3(0.+sin(iTime+3.)/1.,0.+cos(iTime+3.)/1.,-2.),sin(iTime)/5.+p.z+3.);\n    float zhongguo =  min(zhong(p+vec3(1.,0.,0.)),guo(p+vec3(-3.,0.,0.)));\n    return min(max(s,zhongguo),mix(s,zhongguo,1.+sin(iTime)/5.));\n    \n}\n\n\nvec3 get_normal(vec3 p){\n  vec2 eps = vec2(0.1,0.);\n    return normalize(\n             vec3(\n                  SDF(p+eps.xyy) - SDF(p-eps.xyy), // Diff in X\n                  SDF(p+eps.yxy) - SDF(p-eps.yxy), // Diff in Y\n                  SDF(p+eps.yyx) - SDF(p-eps.yyx)  // Diff in Z\n             )\n            );  // Math Vector\n}\n\nfloat diffuse_directional(vec3 n,vec3 l){\n   float a = dot(n,normalize(l))*.5+.5 ;\n    return a;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n     \n    vec3 ro = vec3(0.01,0.01,-10.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1. ));\n    float offset = 0.;\n    if (uv.x < 0.) {\n        offset =pi/2.;\n    }\n\n    p += vec3(0.,0.,tan(offset+iTime*2.));\n    \n\tp.y += sin(p.y+iTime) +cos(p.y+iTime);\n  \n    bool hit = false;\n    float shading = 0.;\n    for(float i=0.;i<1000.;i++){\n   \n          \n        float d = SDF(p);  \n            if(d < 0.001) {  \n                hit = true;\n                shading = i/100.;\n                break;\n\n            }\n            p += d * rd;  \n       \n    }\n    float t = length(ro-p);  \n    vec3 col =  vec3(1.0,0.,0.);\n    if(hit){\n         vec3 n = get_normal(p) ; \n         vec3 l = vec3(0.001+cos(iTime*0.1)*4.,1.,-1.+sin(iTime*0.1)*4.); \n        l = vec3(0.911,.1,-10.);\n        col = vec3(diffuse_directional(n,l));\n      \n         col = mix(vec3(0.1,0.1,0.),vec3(1.,1.,0.), col)*(1.-shading); \n      \n    } else {\n           \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlf3RX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts3SD8", "name": "2.3 Arbitrary tetrahedron", "author": "JHL", "description": "Generate an arbitrary tetrahedron given its vertices.", "tags": ["3d", "sdf"], "likes": 0, "viewed": 79, "date": "1571858261", "time_retrieved": "2024-06-20T19:46:42.309645", "image_code": "#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n        \n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations, twisting and merging\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nfloat smin(float a, float b){\n    float k = 0.2;\n    float h = clamp((0.5 + 0.5 * (b - a) / k), 0.0, 1.0);\n    return mix(b,a,h) - k * h * (1.0-h);\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat scene(vec3 p) {\n    return (max(\n\t    abs(p.x+p.z)-p.y,\n\t    abs(p.x-p.z)+p.y\n\t)-3.0)/sqrt(10.);\n}\n//Found this code online, can't figure out what it's doing...\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts3SD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts3SzS", "name": "Shader4-Delgado-Midterms4", "author": "Sachiemon", "description": "BOMB", "tags": ["academic"], "likes": 2, "viewed": 81, "date": "1572313921", "time_retrieved": "2024-06-20T19:46:42.309645", "image_code": "vec3 Blue = vec3(0.0,0.0,.9);\nvec3 Red = vec3(.9,0.0,0.0);\nvec3 White = vec3(1.0, 1.0, 1.0);\nvec3 Black = vec3(0.0,0.0,0.0);\nvec3 Grey=vec3(.3,.4,.5);\nvec3 BombAnimation(vec2 uv,float sides, float y, float z,float posx,float posy)\n{\t\n    float ratio=iResolution.x/iResolution.y;\n    uv.x*=ratio;\n \n    vec2 shapePos=(vec2(posx*ratio,posy));\n    float dist=distance(shapePos,uv)*2.;\n   \tuv -= shapePos;\n    float angle=atan(uv.y,uv.x);\n    float radius = clamp(cos(z*angle)*sin(angle*y),-y,-z);\n    radius = abs(cos(angle*sides));\n    radius = abs(cos(angle*12.)*sin(angle*3.))*.8+.1;\n    radius = smoothstep(-.5,1., cos(angle*10.))*0.2+0.5;\n \tfloat value = smoothstep(dist-.10, dist*1.5+sin(iTime), radius/2.);\n   \tvec3 color = vec3(value);\n    color += value * vec3(0.4, 0., 0.) * vec3(0.4,0.1,0.0);\n    color += mix(vec3(.5,.2,.0),vec3(0.4,.1,.0),color);\n    return color; \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 image=BombAnimation(uv,12.,3.,8.,.5,.5);\n   \t//image=mix(Blue,Red,image);\n    // Output to screen\n    fragColor = vec4(image, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts3SzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts3XD8", "name": "2.4 The spiral of a cockscrew", "author": "JHL", "description": "spiral", "tags": ["3d", "sdf"], "likes": 1, "viewed": 60, "date": "1571861356", "time_retrieved": "2024-06-20T19:46:43.152111", "image_code": "#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n        \n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations, twisting and merging\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nfloat smin(float a, float b){\n    float k = 0.2;\n    float h = clamp((0.5 + 0.5 * (b - a) / k), 0.0, 1.0);\n    return mix(b,a,h) - k * h * (1.0-h);\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat box(vec3 pt, vec3 dim){\n  vec3 d = abs(pt) - dim; // dimensions\n  float val = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n  return val;\n}\n\nfloat twistedBox(vec3 pt,vec3 dim) {\n    float t = pt.y * PI * 0.1;\n    float m = length(dim);\n    vec3 temp = vec3( pt.x*cos(t) + pt.z*sin(t),\n                      pt.y,\n                      -pt.x*sin(t)+ pt.z*cos(t));\n    return box(temp, dim);\n}\n\n\n\nfloat scene(vec3 pt) {\n\treturn twistedBox(pt,vec3(0.5,4,0.5));\n}\n\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts3XD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts3XR7", "name": "Ray Marching 1(From Art of Code)", "author": "UltimateKimera", "description": "Followed Art of Code's Ray Marching for Dummies here: https://www.youtube.com/watch?v=PGtv-dBi2wE", "tags": ["raymarching", "raycasting"], "likes": 2, "viewed": 364, "date": "1571663983", "time_retrieved": "2024-06-20T19:46:43.152111", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\n\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(0,1,6,1);\n    float dSphere = length(p-sphere.xyz)-sphere.w;\n    float dPlane = p.y;\n    float d = min(dSphere, dPlane);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + dO*rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dS<SURFACE_DIST || dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 e = vec2(.01, 0);\n    float d = GetDist(p);\n    vec3 n = vec3(\n    \td-GetDist(p-e.xyy),\n        d-GetDist(p-e.yxy),\n        d-GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n    if (d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts3XR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts3XRM", "name": "atan spirals", "author": "bitless", "description": "Spirals", "tags": ["spiral", "atan"], "likes": 4, "viewed": 140, "date": "1571655900", "time_retrieved": "2024-06-20T19:46:43.291473", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    \n    uv.y *= iResolution.y/iResolution.x;\n\n\n    // Time varying pixel color\n    float f1 = sin(atan(uv.y,uv.x)*25.+sin(length(uv)*10.-iTime*1.5)*40. + sin(length(uv)*250.-iTime*1.5)*0.25 + iTime*5. + sin(iTime));\n    float f2 = sin(atan(uv.y,uv.x)*25.+sin(length(uv)*10.-iTime*1.5)*40. + sin(length(uv)*250.-iTime*1.5+5.)*0.25 + iTime*5. + sin(iTime+1.));\n    float f3 = sin(atan(uv.y,uv.x)*25.+sin(length(uv)*10.-iTime*1.5)*40. + sin(length(uv)*250.-iTime*1.5+10.)*0.25 + iTime*5. + sin(iTime+2.));\n    \n    vec3 col = vec3(f1,f2,f3);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts3XRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscSDH", "name": "Crazy morphing glitch cube", "author": "jarble", "description": "I edited a single line of code from a raymarching tutorial example. The result was unexpectedly impressive.", "tags": ["raymarching", "fractal"], "likes": 4, "viewed": 314, "date": "1571874721", "time_retrieved": "2024-06-20T19:46:44.479292", "image_code": "//This shader is based on https://www.shadertoy.com/view/Xtd3z7\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    \n    //I edited this line to make this animation\n    vec3 d = abs(p+sin((sin(p+iTime)*10.0))) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return cubeSDF(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscSDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscSR2", "name": "ShaderTober - Tasty", "author": "Flopine", "description": "A small doodle with inktober's theme \"Tasty\"", "tags": ["raymarching", "chocolate", "inktober"], "likes": 6, "viewed": 166, "date": "1572356439", "time_retrieved": "2024-06-20T19:46:45.097594", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI 3.141592\n#define ITER 100.\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat pour (vec3 p, float rythm, float width)\n{\n    p.xz *= rot(sin(-p.y*rythm+iTime));\n    moda(p.xz, 3.);\n    p.x -= width;\n    return cyl(p.xzy, width*0.5, 10.);\n}\n\nfloat SDF (vec3 p)\n{\n    p.xz *= rot(p.y*0.5+iTime);\n    float ry = 0.5,wi = 0.5;\n    float d = pour(p, ry, wi);\n    for (int i=-2; i<=2; i+=2)\n    {\n        ry += 0.2;\n        wi -= 0.1;\n        for (int j=-2; j<=2; j+=2)\n    \t{\n            vec3 offset = vec3(float(i),0.,float(j));\n            d = smin(d, pour(p+offset, ry, wi), 2.);\n    \t}\n    }\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(vec3( SDF(p+eps.xyy)-SDF(p-eps.xyy),\n                         SDF(p+eps.yxy)-SDF(p-eps.yxy),\n                         SDF(p+eps.yyx)-SDF(p-eps.yyx)\n                         )\n                    );\n}\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\n// courtesy of Alkama\nvec3 pales (vec2 uv)\n{\n  uv *= rot(-iTime*.2);\n  return floor(smoothstep(0.1, 0.2,cos(atan(uv.y, uv.x)*5.)))*vec3(0.4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(0.001,0.001,-7.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        l = vec3(0.,5.,-2.),\n        col = mix(vec3(0.),\n              mix(vec3(0.3,0.25,0.15), vec3(0.8,0.7,0.4), pales(uv)),\n              smoothstep(0.35,1.,abs(uv.x)));\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd*0.5;\n    }\n    float t = length(ro-p);\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = mix(vec3(0.01,0.005,0.005), vec3(0.05,0.01,0.01), lighting(n,l));\n        col += vec3(0.,0.02,0.05)*(1.-pow(clamp(dot(n,-rd),0.,1.),.2));\n        vec3 h = normalize(l-rd);\n        col += pow(max(dot(h,n) ,0.), 25.)*vec3(0.2,0.25,0.25);\n        col *= vec3(1.-shad);\n    }\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(0.4545)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscSR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscSR7", "name": "my_one", "author": "kabom", "description": "study1", "tags": ["sin"], "likes": 1, "viewed": 37, "date": "1571713857", "time_retrieved": "2024-06-20T19:46:45.418757", "image_code": "vec3 cicle(vec2 pt, vec2 center, float r)\n{\n    vec3 ret = vec3(0.0, 0.0, 0.0);\n\tfloat dis = distance(pt, center);\n    if (dis < r) {\n    \tret = vec3(1.0, 1.0, 1.0);\n    }\n    return ret;\n}\n\nvec3 rect(vec2 pt, vec2 center, float r)\n{\n    vec3 ret = vec3(0.0, 0.0, 0.0);\n\tfloat disx = abs(pt.x - center.x);\n    float disy = abs(pt.y - center.y);\n    if (disx * 2.0f < r && disy * 2.0f < r) {\n       ret = vec3(1.0, 1.0, 0.0);   \n    }\n    \n    return ret;       \n\t\n}\n\nvec3 drawSin(vec2 pt)\n{\n    vec3 ret = vec3(0.0, 0.0, 0.0);\n    float si = sin((pt.x + iTime / 10.0f) * 3.14f * 4.0f) * 0.5f;\n    if (pt.y - 0.5 < si) {\n         ret = vec3(1.0, 1.0, 1.0);\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 tcol = texture(iChannel0, uv).rgb;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    vec2 center = vec2(0.5, 0.5);\n    vec3 c = cicle(uv, center, 0.2f);\n    vec3 r = rect(uv, center, 0.3f); \n    vec3 s = drawSin(uv);\n    vec3 ns = vec3(1.0, 1.0, 1.0) - s;\n    \n    vec3 col = c * 0.4 + r *0.6;\n    \n    \n    // Output to screen\n    fragColor = vec4(s * tcol + ns * vec3(1.0, 1.0, 0.0) ,1.0);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscSWn", "name": "anticipation", "author": "freder", "description": ".", "tags": ["bw"], "likes": 1, "viewed": 55, "date": "1571769622", "time_retrieved": "2024-06-20T19:46:45.418757", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// normalize coordinates and move origin to center\n\tvec2 st = (fragCoord.xy / iResolution.xy) - vec2(0.5);\n    \n\t// animate global scale: zoom in and out\n\tst *= cos(iTime * 0.5);\n\n\t// animate point distance from center\n\tvec2 offset = (0.03 + pow(sin(iTime * 0.5), 4.5)) * vec2(0.5, 0.0);\n\n\t// calculate gradient colors for two diametrically opposite points\n\tfloat c1 = distance(st, offset); float c2 = 0.95 - distance(st, -offset);\n\n\t// set output color as combination of both colors\n\tfragColor = vec4(vec3(pow(c1 + c2, 20.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscSz7", "name": "Now loading...", "author": "ducklett", "description": "inspired by slow computers", "tags": ["animated", "loading", "gif"], "likes": 15, "viewed": 651, "date": "1571668733", "time_retrieved": "2024-06-20T19:46:45.418757", "image_code": "#define DOTS 14\n#define DOTOFFSET 0.04\n#define SPEED 0.2\n#define POWER 3.\n#define COLTOP vec3(.3,0.6,1.)\n#define COLBTM vec3(1.,.4,.3)\n\n#define lerp mix\n#define pi 3.1415\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    float d = 9999.;\n    vec3 col;\n    for (int i=0;i<DOTS;i++) {\n    \tfloat t = pow(fract(iTime*SPEED+(float(i)*DOTOFFSET)),POWER);\n    \tfloat s = pi*2.;\n    \tvec2 o = vec2(sin(t*s), cos(t*s))*.2;\n        float dist = length(uv+o)-.01;\n        if (dist<d){\n        \tcol=lerp(COLTOP,COLBTM, cos(t*s)*.5+.5);\n        }\n    \td = smin(d,dist, 0.04);\n        \n        \n    }\n    \n    \n    \n    col = lerp(col, vec3(1.,1.,.9), smoothstep(0., 0.005, d));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscSz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscSzj", "name": "Snowmannnnnnn", "author": "TundrumMax", "description": "is it too early for christmas\nadded some ground variance", "tags": ["3d", "raymarcher", "snow", "snowman"], "likes": 2, "viewed": 126, "date": "1572347025", "time_retrieved": "2024-06-20T19:46:46.140109", "image_code": "float sdBox( vec3 p, vec3 b , float r)\n{\n  r = min(r,0.15);\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdSphere(vec3 p, float r) {\n \treturn length(p) - r;\n}\nfloat sdCone( in vec3 p, in vec2 c , in vec3 size)\n{\n    // c is the sin/cos of the angle\n    float q = length(p.xy);\n    float dotProduct = dot(c,vec2(q,p.z));\n    float d = max(dotProduct,sdBox(p,size,0.0));\n    return d;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r ) //This, the cone and the box are -s-t-o-l-e-n- borrowed from Inigo's SDF page\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec2 getSnowman(in vec3 pos) {\n\tfloat lowerBody = sdSphere((pos), 0.2);\n\tfloat middleBody  = sdSphere(pos-vec3(0,0.2,0),0.16);\n    float upperBody = sdSphere(pos-vec3(0,0.36,0), 0.13);\n    \n    float coneAngle = 1.4;\n    float nose = sdCone(pos-vec3(0,0.36,0.2),vec2(sin(coneAngle),cos(coneAngle)),vec3(0.1));\n    \n    float rightEye = sdSphere(pos-vec3(0.05,.4,0.12),0.01);\n    float leftEye = sdSphere(pos-vec3(-0.05,.4,0.12),0.01);\n    float lowerHat = sdCappedCylinder(pos-vec3(0,0.47,0),0.13,0.01);\n    float upperHat = sdCappedCylinder(pos-vec3(0,0.47,0),0.1,0.1);\n    \n    \n    \n    float d = min(lowerBody,min(middleBody,min(upperBody,min(nose,min(rightEye,min(leftEye,min(lowerHat,upperHat)))))));\n    float identifier = 0.0;\n    if(d == nose) identifier = 5.0;\n    if(d == leftEye || d == rightEye || d == lowerHat || d == upperHat) identifier = 6.0;\n    return vec2(d, identifier);\n}\nvec2 map(in vec3 pos) {\n    float identifier = 0.0;\n    float animationSpeed = 1.5;\n\tvec3 animation = vec3(sin(iTime*5.0*animationSpeed)/20.0*max(pos.y,0.0),sin(iTime*10.0*animationSpeed)/20.0*max(pos.y,0.0),0.0);\n    float ground = pos.y + 0.2 - length(sin(pos/1.0))/20.0-length(sin(pos/11.0))/1.0;\n\tvec2 snowman = getSnowman(pos-animation);\n    float d = min(ground,snowman.x);\n    //OH LAWD THIS IS A MESS\n    //are arrays a thing in glsl\n    //if so, it would make things a lot easier\n    \n\n\tif(d == ground) identifier = 4.0;\n    if(d == snowman.x) identifier = snowman.y;\n    return vec2(d,identifier);\n}\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(0.0001,0.0);\n \treturn normalize( vec3(map(pos+e.xyy).x-map(pos-e.xyy).x,\n                           map(pos+e.yxy).x-map(pos-e.yxy).x,\n                           map(pos+e.yyx).x-map(pos-e.yyx).x));   \n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float renderDistance) {\n \tvec2 t = vec2(0.0);\n    for(int i = 0; i < 100; i++) {\n     \tvec3 pos = ro + t.x*rd;\n        \n        vec2 h = map(pos);\n        if(h.x < 0.001) break;\n        \n        t.x += h.x;\n        t.y = h.y;\n        if(t.x > renderDistance) break;\n    }\n    if(t.x > renderDistance) t.x = -1.0;\n    return t;\n}\nfloat random (vec2 rndpos) {\n    return fract(sin(dot(rndpos.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an = iMouse.x / iResolution.x*6.245;\n    float en = -iMouse.y / iResolution.y + 3.1415 / 5.0;\n    //float an = iTime;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(sin(an),sin(en),-cos(an));\n    vec3 ta = vec3(0,0.2,0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n\n    float renderDistance = 20.0;\n\tvec2 t = vec2(0.0);\n    t = castRay(ro,rd,renderDistance);\n    vec3 sunVector = normalize(vec3(0.8,0.4,0.2));\n    vec3 col = pow(vec3(0.6,0.8,0.9), vec3(rd.y*7.0)) * ((dot(sunVector,rd)*normalize(vec3(7.0,3.0,0.0))+ 1.0)*normalize(vec3(7,4,3)));\n    \n    \n\n\t\n    col += vec3(pow(max(dot(sunVector,rd),0.0), 100.0)) * normalize(vec3(7,5.5,4));\n    \n    \n    \n    if(t.x > 0.0) {\n        vec3 pos = ro + t.x*rd;\n        vec3 norm = calcNormal(pos);\n        vec3 mat = vec3(0.2,0.3,0.4);\n        if(t.y == 5.0) mat = vec3(0.5,0.3,0.0);\n\t\tif(t.y == 6.0) mat = vec3(0.01);\n        if(t.y == 4.0) mat -= length(sin(pos/2.0))/20.0;\n        vec3 skyVector = normalize(vec3(0.0,1.0,0.0));\n        \n        float sunDiffuse = clamp(dot(norm,sunVector),0.0,1.0);\n        float skyDiffuse = clamp(0.5 + 0.5*dot(norm,skyVector),0.0,1.0);\n        float bounceDiffuse = clamp(0.5 + 0.5*dot(norm,-skyVector),0.0,1.0);\n        \n        float sunShadow = step(castRay(pos + norm * 0.001,sunVector, renderDistance).x,0.0);\n        \n        \n        \n    \tcol = mat * vec3(15,7,3) * sunDiffuse * sunShadow;\n        col += mat * vec3(0.6,0.8,0.9) * skyDiffuse;\n        col += mat * vec3(0.7,0.3,0.2) * bounceDiffuse;\n    }\n\tcol = pow(col, vec3(0.4545));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscXWM", "name": "raymarch--8-camino", "author": "jorge2017a1", "description": "raymarch--8-camino", "tags": ["raymarch8camino"], "likes": 1, "viewed": 90, "date": "1572098971", "time_retrieved": "2024-06-20T19:46:46.146195", "image_code": "//Created by UltimateKimera in 2019-10-21\n//modificado por jorge2017a1-  -26-oct-2019\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\n\n//----------------------------\n\n// Maximum/minumum elements of a vector    \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n//---------------------\n\n\n\n// ============================\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n\n\nfloat repeat(float v, float r )  {   \n    return (mod(v, r)-r/2.);\n}    \n    \n   \n\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(0,1,6,1);\n    float dSphere = length(p-sphere.xyz)-sphere.w;\n    float dPlane = p.y;\n    \n  vec3 c;\n    c=p;\n    \n    vec4 color = vec4(1., 1., 1., 1.);\n  \n  c.z = repeat(c.z, 2.);\n    \n  c.x = abs(c.x)-0.5; //Mirror\n    \n  vec3 boxSize = vec3(.5, 1., .5);\n  vec3 boxOffset = vec3(1., -1.2, 0.);\n  float b1 = fBox(c+ boxOffset, vec3(3.0, .2, .2)); //c- vec3(x, y, z) how much to move the object\n  float b2 = fBox(c- boxOffset, vec3(3.0, .2, .2)); //c- vec3(x, y, z) how much to move the object\n  float b3 = fBox(c- vec3(.8, 0., 0.), vec3(.07, 1., .05)); //left box on column\n  float b4 = fBox(c- vec3(1., 0., -0.17), vec3(.07, 1., .05)); //front box on column\n  float b5 = fBox(c- vec3(1., 0., 0.17), vec3(.07, 1., .05)); //back box on column\n  float b6 = fBox(c- vec3(-.8, 0., 0.), vec3(.07, 1., .05)); //right box on column\n  float b7 = fBox(c- vec3(.0, -1.5, 0.), vec3(.5, .2, 2.));//small box on bottom\n  \n  float col1 = fCylinder(c- vec3(1., 0., 0.), .2, .9);\n  float col2 = fCylinder(c- vec3(1.9, 0., 0.), .2, .9);\n    \n    \n    \n  \n    \n    \n    //float d = min(dSphere, dPlane);\n    float d;\n    \n    d=min(dPlane, b1);\n    d=min(d, b2);\n    d=min(d, b3);\n    d=min(d, b4);\n    d=min(d, b5);\n    d=min(d, b6);\n    d=min(d, b7);\n    \n    d=min(d, col1);\n    d=min(d, col2);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + dO*rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dS<SURFACE_DIST || dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 e = vec2(.01, 0);\n    float d = GetDist(p);\n    vec3 n = vec3(\n    \td-GetDist(p-e.xyy),\n        d-GetDist(p-e.yxy),\n        d-GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    /*vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n    if (d<length(lightPos-p)) dif *= .1;\n    return dif;*/\n    \n    \n    vec3 lightPos1 = vec3(0, 5, 6);\n    lightPos1.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURFACE_DIST*2., l1);\n    if (d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    \n    \n    vec3 lightPos2 = vec3(-41.0, 25.0, -1.5);\n    lightPos2.xz += vec2(0.0, 5.0)*2.0;\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURFACE_DIST*2., l2);\n    if (d2<length(lightPos2-p)) dif2 *= .1;\n    return dif1+dif2;\n    \n}\n\nfloat GetLight2(vec3 p ,  vec3 luz){\n    /*vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n    if (d<length(lightPos-p)) dif *= .1;\n    return dif;*/\n    \n    \n    vec3 lightPos1 = vec3(-0.5, 15, -10);\n    //lightPos1.xz += vec2(sn(iTime), cos(iTime))*2.;\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURFACE_DIST*2., l1);\n    if (d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    float dif2;\n    \n    //vec3 lightPos2 = vec3(-41.0, 25.0, -1.5);\n    vec3 lightPos2 = luz;\n    \n    //lightPos2.xz += vec2(0.0, 5.0)*2.0;\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    \n\t dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURFACE_DIST*2., l2);\n    if (d2<length(lightPos2-p)) dif2 *= .1;\n    \n    return dif1+dif2;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //vec3 ro = vec3(0,1,0);\n    vec3 ro = vec3(0.0,0.5,iTime);\n    vec3 luz= vec3(5.0,6.0,iTime*0.05+10.0);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    \n    //float dif = GetLight(p);\n    float dif = GetLight2(p, luz);\n    \n    col = vec3(dif);\n    \n    \n    col = pow(col, vec3(1.0/2.2)); \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscXz2", "name": "change sphere", "author": "zrcoy", "description": "Sphere changes", "tags": ["sphere"], "likes": 2, "viewed": 493, "date": "1572381460", "time_retrieved": "2024-06-20T19:46:46.146195", "image_code": "#define DIST_SURFACE .001f\n#define DIST_MAX 1000.f\n#define MAX_STEPS 100\n\nfloat remap(float a, float b, float t)//ramap t from a-b to 0-1\n{\n \treturn (t-a) / (b-a);   \n}\n\nfloat dsSphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat dsWholeMap(vec3 p)\n{\n    float displacement = sin(5.0 * p.x + iTime *5.f) * sin(5.0 * p.y + iTime * 5.f) * sin(5.0 * p.z + iTime * 5.f) * .15f;\n \tfloat dSphere = dsSphere(p, vec3(0), 2.f);\n    \n    return dSphere + displacement;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 swizzle = vec2(.001f, 0);\n \tfloat gradient_x = dsWholeMap(p + swizzle.xyy) - dsWholeMap(p - swizzle.xyy);\n    float gradient_y = dsWholeMap(p + swizzle.yxy) - dsWholeMap(p - swizzle.yxy);\n    float gradient_z = dsWholeMap(p + swizzle.yyx) - dsWholeMap(p - swizzle.yyx);\n    \n    return normalize(vec3(gradient_x, gradient_y, gradient_z));\n}\n\nfloat GetLightDifuse(vec3 p, vec3 lightP)\n{\n    vec3 normal = GetNormal(p);\n    vec3 dirToL = normalize(lightP - p);\n    float f = remap(-1.f, 1.f, dot(normal, dirToL));\n    return f;\n}\n\nvec3 RayMarching(vec3 ro, vec3 rd)\n{\n \tfloat totalDist = 0.f;\n    for(int i=0; i<MAX_STEPS;i++)\n    {\n     \tvec3 currentPos = ro + rd * totalDist;\n        vec3 center = vec3(0);\n        float dS = dsWholeMap(currentPos);\n        if(dS < DIST_SURFACE)\n        {\n            vec3 lightPos = vec3(4.f * sin(iTime) ,4.f ,4.f * cos(iTime));\n            float difuse = GetLightDifuse(currentPos, lightPos);\n            //vec3 col = vec3(1.f,0,0);\n            vec3 col = 0.5 + 0.5*cos(iTime+currentPos.xyx+vec3(0,2,4));\n         \treturn  difuse * col;   \n        }\n        if(dS > DIST_MAX)\n            break;\n        \n        totalDist += dS;\n    }\n    \n    return vec3(0);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.f - 1.f;// make it -1 - 1\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //primitive camera\n    vec3 ro = vec3(0,0.f,-5.f);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.f));\n    \n    vec3 col_sphere = RayMarching(ro, rd);\n    \n    fragColor = vec4(col_sphere, 1.f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscXz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscXz7", "name": "Shadertober 21 Cheese -jaburns", "author": "jaburns", "description": "Ray marched endless zoom on the Menger sponge", "tags": ["fractal", "raymarch", "menger"], "likes": 7, "viewed": 379, "date": "1571684782", "time_retrieved": "2024-06-20T19:46:46.146195", "image_code": "#define ITERATIONS  100\n#define EPSILON      0.0001\n#define MAX_DIST    100.\n#define PI 3.14159265358979\n\nmat2 rot(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox2d(vec2 p, float r)\n{\n    vec2 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdBox( vec3 p, float b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCross(vec3 p, float r)\n{\n    return min(sdBox2d(p.yz, r), min(sdBox2d(p.xy, r), sdBox2d(p.xz, r)));\n}\n\nfloat opSubtract(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat map(vec3 p, float scale)\n{\n    p /= scale;\n    \n    p = mod(p + 3., 6.) - 3.;\n    \n    float d = sdBox(p, 3.);        \n    d = opSubtract(d, sdCross(p, 1.));\n\n    float s = 1.;\n    for (int i = 0; i < 6; ++i) {\n        vec3 p1 = mod(s*p + 1., 2.) - 1.;\n        float cutDist = sdCross(p1, 1. / 3.) / s;\n        d = opSubtract(d, cutDist);\n        s *= 3.;\n    }\n\n    return d * scale;\n}\n\nstruct MarchResult\n{\n    vec3 pos;\n    float dist;\n    float ao;\n};\n\nMarchResult march(vec3 ro, vec3 rd, float scale)\n{\n    float dist, totalDist = 0.0;\n    \n    int i;\n    for (i = 0; i < ITERATIONS; ++i) {\n    \tdist = map(ro, scale);\n        if (dist < EPSILON || totalDist > MAX_DIST) break;        \n        totalDist += dist;\n        ro += rd * dist;\n    }\n    \n    return MarchResult(ro, dist < EPSILON ? totalDist : -1., 1. - float(i)/100.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy - vec2(.5*iResolution.x/iResolution.y, .5);\n\n    // ===== Camera =====\n\n    float T = 20.;\n    float t = mod(iTime / T, 1.);\n    float zoom = mix(1., 3., t);\n\tvec3 rd;\n    const float x0 = 2.;\n    const float xx = 6.;\n    const float yy = 8. - (.666);\n  \n    vec3 ro;\n    if (t < .5) {\n        t *= 2.;\n        ro = zoom*vec3(x0,0, -yy * (  2.*t-t*t ));\n        float angle = -PI / 2. * (.5-.5*cos(PI*t));\n        rd = normalize(vec3(uv, -1));\n        rd.xz *= rot(angle);\n        rd.yz *= rot(2.*PI* (.5-.5*cos(PI*t)) );\n    } else {\n        t = 2.*(t - .5);\n        vec3 roA = zoom*vec3(x0,0,-yy);\n        vec3 roB = zoom*vec3(x0+xx*t,0,-yy);\n        ro = mix(roA, roB, smoothstep(0.,1.,clamp(4.*t, 0., 1.)));\n        float look = (1.-(2.*t-1.)*(2.*t-1.)) * sin(2.*PI*t);                \n        rd = normalize(vec3(uv + .5*look, -1));\n        rd.xz *= rot(-PI / 2.);\n        rd.zy *= rot(.25*look);\n    }\n    \n    // ==================\n    \n    MarchResult m = march(ro, rd, zoom);\n    \n    float vis = 0.;\n    if (m.dist >= 0.) {\n    \tvis = exp(-.2 * m.dist) * m.ao;\n    }\n    \n    const vec3 DARK = mix(vec3(97., 8., 52.) / 255., vec3(0), .2);\n    const vec3 LIGHT = vec3(255., 165., 0.) / 255.;\n    \n    fragColor = vec4(mix(DARK, LIGHT, vis), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscXz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscXzX", "name": "Global Remix 2", "author": "Del", "description": "snow", "tags": ["remix", "snow"], "likes": 10, "viewed": 331, "date": "1572480941", "time_retrieved": "2024-06-20T19:46:46.146195", "image_code": "// global remix 2 - Del 30/10/2019\n\n\n// Tidied up by Fabrice (thankyou!)\n\nfloat snow(vec2 uv,float scale)\n{\n\tfloat _t = iTime*2.3;\n\tuv*=scale;    \n\tuv.x+=_t; \n\tvec2 s=floor(uv);\n    vec2 f=fract(uv);\n\tvec2 p=.5+.35*sin(11.*fract(sin((s+scale)*mat2(7,3,6,5))*5.))-f;\n    float d=length(p);\n\tfloat k=smoothstep(0.,d,sin(f.x+f.y)*0.003);\n\treturn k;\n}\n\n\n\nvec3 _globalmix(vec2 uv)\n{\n\tfloat dd = 0.5-length(uv);\n\tuv.x += sin(iTime*0.08);\n\tuv.y += sin(uv.x*1.4)*0.2;\n\tuv.x *= 0.1;\n\tfloat c=snow(uv,30.)*.3;\n\tc+=snow(uv,20.)*.5;\n\tc+=snow(uv,15.)*.8;\n\tc+=snow(uv,10.);\n\tc+=snow(uv,8.);\n\tc+=snow(uv,6.);\n\tc+=snow(uv,5.);\n\tc*=0.2/dd;\n\tvec3 finalColor=(vec3(0.77,0.435,0.29))*c*30.0;\n    finalColor += vec3(.75,0.35,0.15)*0.02/dd;\n    return finalColor;\n}\n\nmat2 rot(float a)\n{\n    float sa = sin(a), ca = cos(a);\n\treturn mat2(ca, -sa, sa, ca);\n}    \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tuv *= rot(iTime);\n    vec2 uv2 = uv;\n    uv2.y += sin(iTime*0.35+uv2.x*2.0);\n    uv2.y = abs(uv2.y);\n    uv2.y -= dot(uv2,uv2);\n    fragColor = vec4(_globalmix(uv)*length(0.25/uv2),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscXzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsdSRf", "name": "Shadertober 30 Catch", "author": "GreenChicken", "description": "a tunnel inspired by hexeosis psy loop visuals", "tags": ["raymarching", "inktober"], "likes": 8, "viewed": 324, "date": "1572542139", "time_retrieved": "2024-06-20T19:46:47.303968", "image_code": "// SHADERTOBER 30 Catch\n// Poulet vert 31-10-2019\n// thanks iq for sdf functions\n// inspired by hexeosis psy loop visuals\n\n#define VOLUME 0.001\n#define PI 3.14159\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Scene setup\nvec2 map(vec3 p)\n{\n    // base full world\n    vec3 bp = p + vec3(0.0);\n    bp = opRep(bp, vec3(1.0));\n    float b = sdBox(bp, vec3(1.0));\n    \n    // tunnels\n    vec3 tp = p + vec3(0.0);\n    tp = opRep(tp, vec3(0.0, 0.0, 1.0));\n    float t = sdBox(tp, vec3(1.0));\n    \n    tp = p + vec3(1.0, 0.0, 0.0);\n    tp = opRep(tp, vec3(0.0, 0.0, .5));\n    t = min(t, sdBox(tp, vec3(.5)));\n    \n    tp = p + vec3(-1.0, 0.0, 0.0);\n    tp = opRep(tp, vec3(0.0, 0.0, .5));\n    t = min(t, sdBox(tp, vec3(.5)));\n    \n    tp = p + vec3(0.0, 1.0, 0.0);\n    tp.xy *= rot(PI/4.0);\n    tp = opRep(tp, vec3(0.0, 0.0, .5));\n    t = min(t, sdBox(tp, vec3(.5)));\n    \n    tp = p + vec3(0.0, -1.0, 0.0);\n    tp.xy *= rot(PI/4.0);\n    tp = opRep(tp, vec3(0.0, 0.0, .5));\n    t = min(t, sdBox(tp, vec3(.5)));\n    \n    b = max(b, -t);\n    \n    // lines\n    vec3 lp = p + vec3(1.5, 0.0, 0.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 2.0));\n    float l = sdBox(lp, vec3(0.1, .5, 1.0));\n    \n    lp = p + vec3(-1.5, 0.0, 0.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 2.0));\n    l = min(l, sdBox(lp, vec3(0.1, .5, 1.0)));\n    \n    lp = p + vec3(0.0, 1.0, 0.0);\n    lp.xy *= rot(PI/4.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 2.0));\n    l = min(l, sdBox(lp, vec3(0.5, .5, 1.0)));\n    \n    lp = p + vec3(0.0, 0.9, 0.0);\n    lp.xy *= rot(PI/4.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 1.0));\n    l = max(l, -sdBox(lp, vec3(0.5, .5, 1.0)));\n    \n    lp = p + vec3(0.0, -1.0, 0.0);\n    lp.xy *= rot(PI/4.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 2.0));\n    l = min(l, sdBox(lp, vec3(0.5, .5, 1.0)));\n    \n    lp = p + vec3(0.0, -0.9, 0.0);\n    lp.xy *= rot(PI/4.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 1.0));\n    l = max(l, -sdBox(lp, vec3(0.5, .5, 1.0)));\n    \n    // torus\n    vec3 ap = p + vec3(0.0);\n    ap.yz *= rot(PI/2.0);\n    ap = opRep(ap, vec3(0.0, 1.0, 0.0));\n    float a = sdTorus(ap, vec2(3.0, .1));\n    \n    // rooms\n    vec3 rp = p + vec3(0.0);\n    rp = opRep(rp, vec3(0.0, 0.0, 10.0));\n    float r = sdBox(rp, vec3(5.0, 5.0, 2.0));\n    \n    b = max(b, -r);\n    l = max(l, -r);\n    \n    \n    // Materials\n    vec2 scene = vec2(b, 0.0);\n    scene = opU2(scene, vec2(l, 1.0));\n    scene = opU2(scene, vec2(a, 2.0));\n    \n    return scene;\n}\n\nvec3 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec3(t, ray.y, float(i)/128.);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec3(-1.0, 0.0, 0.0);\n}\n\n\nvec3 GetNormal (vec3 p)\n{\n    float c = map(p).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p+e.xyy).x, map(p+e.yxy).x, map(p+e.yyx).x) - c);\n}\n\nfloat GetLight(vec3 N, vec3 lightPos)\n{\n    return max(dot(N, normalize(lightPos)), 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(fract(floor(pos.z)*.05), vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    polyCol *= step(fract(pos.z+.1), .8);\n    \n    if(t.x == -1.0)\n    {\n        col = vec3(0.0);\n    }\n    else\n    {    \n        vec3 N = GetNormal(pos);\n        \n        vec3 mainL = vec3(1.0, 1.0, 0.0);\n        float mainlight = GetLight(N, mainL);\n        \n        vec2 ledFreq = vec2(.15, .17);\n        vec2 ledUV =  vec2(-pos.x+5.08, -pos.y-.5);\n        \n        float depth = t.z;\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(1.0)*mainlight*.5+.5;\n            col.y -= uv.y;\n            col *= .1;\n        }\n        else if(t.y == 1.0) // effect\n        {\n            col = polyCol;\n            \n        }\n        else if(t.y == 2.0) // effect\n        {\n            col = vec3(1.0);\n            col.x = uv.y;\n            \n        }\n        \n        col *= 1.0-t.z;\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 1.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    float time = iTime * 10.0;\n    \n    \n    vec3 cp = vec3(0.0, 0.0, time-5.0);\n    vec3 ct = vec3(0.0, 0.0, time);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, screenUV);\n    \n    vec3 gradient = mix(vec3(1.0, 0.25, 0.3), vec3(0.3, 0.1, 1.0), -uv.y);\n    \n    col *= gradient;\n    \n    col = sqrt(clamp(col, 0.0, 1.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsdSRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsdSzj", "name": "Sub voxel rm test", "author": "NLIBS", "description": "This world is created with voxels based on IQ's integer hash function. ", "tags": ["raymarching", "voxels"], "likes": 7, "viewed": 213, "date": "1572417068", "time_retrieved": "2024-06-20T19:46:47.303968", "image_code": "// IQ's integer hash function ---------------------------\nconst uint k = 1234543210U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//-------------------------------------------------------\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat shrub(vec3 p)\n{  \n    return length(vec3(mod(p.xz,1.)-.5,p.y+12.).xyz)-.5;\n}\n\nfloat cube(vec3 p)\n{\n    float h = length(p)-14.;\n    return min(max(-h,0.),max(abs(p.y-11.99)-.01,0.));    \n}\n\nfloat ray_box(vec3 ro, vec3 rd, float mint, float maxt)\n{\n\tfloat t = 0.;\n    for (int i = 0; (i<150 && t<maxt); i++) {\n    \tvec3 p = ro + rd * t;\n        float h = cube(p);\n        t += h;\n        if (h*1e5<mint+t) return t;\n    }\n    return -1.;\n}\n\nfloat ray_veg(vec3 ro, vec3 rd, float mint, float maxt) {\n\tfloat t = 0.;\n    for (int i = 0; (i<150 && t<maxt); i++) {\n        float h = shrub(ro + rd * t);\n        t += h;\n        if (h*1e5<mint+t) return t;\n    }\n    return -1.;\n}\n\nvec2 ray(vec3 ro, vec3 rd) {\n    float t = 0.;\n    float grid = 24.;\n    vec3 pr_stp = step(0., rd)*grid;\n    float dec = .3;\n    while(t<300.) {\n        vec3  p   = ro + rd*t,\n              ip  = floor((ro + rd*t)/grid)*grid,\n              dt  = (pr_stp + ip-p) / rd;\n    \tfloat dlt = max(min(min(dt.x,dt.y),dt.z),1e-3),\n              pr_hash = hash(uvec3(ip/grid+1e4)).x;\n        if (pr_hash<dec && ip.y<0.) {\n\t\t\tfloat t2 = ray_box(p-ip-grid*.5,rd,t,dlt);  \n            if (t2!=-1.) {\n\t\t\t\treturn vec2(t+t2,2); \n            }\n        } else if (ip.y<1.) {\n\t\t\tpr_hash = hash(uvec3((ip-vec3(0,1,0))/grid+1e4)).x;\n\t\t\tif (pr_hash<dec) {\n                float t2 = ray_veg(p-ip-grid*.5,rd,t,dlt);\n                if (t2!=-1.) {\n\t\t\t\t\treturn vec2(t+t2,3); \n                }\n            }\n\t\t\t\n        }\n    \tt += dlt;\n    }\n    return vec2(0);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 U ) \n{\n    vec2 uv = (U-iResolution.xy*.5)/iResolution.y*2.;\n    \n    vec3 viewPos = vec3(0,36,iTime*20.),\n         rd = normalize(vec3(uv,-1.6)).xzy;\n    \n    vec2 hit = ray(viewPos,rd);\n    vec3 p = viewPos + rd*hit.x;\n    \n    vec3 col = vec3(0.);\n    if (hit.y>0.) {  \n        float grid = (3.-hit.y)*24.;    \n        vec3 ip = floor(p/grid)*grid;\n        vec3 fp = p-ip-grid*.5;\n        col = hash(uvec3(ip+1e4))*0.2+vec3(0,.3,0.);\n\n        col = 1.- exp(-col*exp((36.-hit.x)*.06));\n        col = pow(col.rgb, vec3(1./2.2));\n        vec3 noise = pow(texelFetch(iChannel0, ivec2(U)%1024, 0).rgb,vec3(1./2.2));\n        noise = (noise*2.-1.)*0.499*2.;\n        col += noise/256.;\n    }\n    O = col.xyzx;\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsdSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsG3Dw", "name": "Raymarch experiment by Petronous", "author": "petronous", "description": "A small experiment\n\nTry changing the #define values", "tags": ["raymarching"], "likes": 0, "viewed": 87, "date": "1570283389", "time_retrieved": "2024-06-20T19:46:47.825142", "image_code": "#define CAM_ZOOM  2.\n#define MAX_STEPS 200\n#define MAX_DIST  1000.\n#define SURF_DIST .03\n#define PI 3.1415926\n#define CAM_TO_CENTER false\n#define LIGHT true\n#define BALL_SPACING 5.\n\n\nvec3 VecMod(vec3 v, float m) {\n  vec3 ret = v;\n  for(int i = 0; i < 3; i++){\n    float rem = v[i];\n    if (rem > 0.){\n      while (rem > m) {\n        rem -= m;\n      }\n      ret[i] = rem-m/2.;\n    } else {\n      while (rem < -m) {\n        rem += m;\n      }\n      ret[i] = rem+m/2.;\n    }\n  }\n\n  return ret;\n}\n\n\nfloat Distance(vec3 rn){\n  return length(VecMod(rn, BALL_SPACING)) - .5;\n}\n\nfloat Light(vec3 rn){\n  \tfloat dist = Distance(rn);\n    if (dist < SURF_DIST) {\n        vec3 relpos = VecMod(rn, BALL_SPACING);\n        vec3 normal = normalize(relpos);\n        return dot(normal, normalize(vec3(.5, 1, -.1)));\n    } else {\n    \treturn 2.;\n    }\n}\n\nfloat March(vec3 ro, vec3 rd) {\n    float ditr = 0.;\n    for(int i = 0; i < MAX_STEPS; i++){\n    float dist = Distance(ro + rd*ditr);\n        ditr += dist;\n        if(dist < SURF_DIST || ditr > MAX_DIST) break;\n    }\n    return ditr;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx - vec2(.5, .5*iResolution.y/iResolution.x);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.yxx+vec3(1));\n\n    vec3 ro = vec3(100.*sin(iTime/10.),0,100.*cos(iTime/10.));\n    //vec3 ro = vec3(0.,1.5,-10.);\n    vec3 camd = normalize(ro);\n    float xzCAngle;\n    if (CAM_TO_CENTER){\n    \txzCAngle= atan(camd.x/camd.z);\n        if (ro.z>0.) {\n            xzCAngle += PI;\n        }\n    } else {\n    \tro = vec3(0, 0, iTime/.5);\n        xzCAngle = 0.;\n    }\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1./CAM_ZOOM));\n    float xzAngle = atan(rd.x/rd.z) + xzCAngle;\n    rd.x = sin(xzAngle);\n    rd.z = cos(xzAngle);\n\t\n    vec3 col;\n    float dist = March(ro,rd);\n    if(LIGHT){\n    \tfloat light = Light(dist*rd + ro);\n        if (light <= 1.) {\n        \tcol = vec3(light);\n        } else {\n        \tcol = vec3(dist/MAX_DIST);\n        }\n    } else {\n    \tcol = vec3(dist/MAX_DIST);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsG3Dw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsG3Rd", "name": "Shadertober 10 Pattern", "author": "GreenChicken", "description": "I wanted to try the sdLine function and create this happy shape. I added a little noise in posteffect to create something strange.", "tags": ["raymarching", "line", "colors", "inktober"], "likes": 3, "viewed": 237, "date": "1570738211", "time_retrieved": "2024-06-20T19:46:48.703861", "image_code": "// SHADERTOBER 10 Pattern\n// Poulet Vert 10-10-2019\n// Thanks to iq, leon, patricio&jen\n\n#define VOLUME 0.001\n#define PI 3.14159\n\n\n\n////////////////////////////////////////////////////////////////////////////////\nfloat opU(float s1, float s2) { return min(s1, s2);}\n\nvec2 opU2(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nfloat sat(float a) {return clamp(a, .0, 1.); }\n\n\nvec2 sdLine( vec3 p, vec3 a, vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length( pa - ba*h ), h );\n}\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat sdChronoLine(vec3 p, float o, float s, float le)\n{\n    float time = iTime + o;\n    vec3 pa = vec3(.0);\n    vec3 pb = vec3(sin(time), cos(time), 0.0) * le;\n    vec2 b = sdLine( p, pa, pb );\n\n    float tr = s;\n    float l = b.x - tr;\n    \n    return l;\n}\n\n// -------------------------------------------------------------------------\n\nvec2 map(vec3 pos)\n{\n    vec2 t = vec2(0.0, -1.0);\n    \n    // ground\n    t.x = pos.y;\n    \n    vec3 p = pos + vec3(0.0, -1.5, 0.0);\n    \n    vec2 l = vec2(1.0, 0.0);\n    float anim = abs(sin(iTime));\n    for(int i=0; i<16 ; i++)\n    {\n        l = opU2(l, vec2(sdChronoLine(p, float(i)*PI/8.0, anim, 1.0), float(i)*.1));\n    }\n    \n    \n    t = opU2(t, l);\n    \n    return t;\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 1.; i += 1./15.) {\n        vec2 dist = map(pos + dir * t);\n        if (dist.x < VOLUME) return 0.;\n        f = min(f, k * dist.x / t);\n        t += dist.x;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = ro+rd*t.x;\n    vec3 col = vec3(0.0);\n    float depth = clamp(pos.z, 0.0, 1.0);\n    depth = 1.0 - sat(pos.z*.1);\n            \n    if(t.x == -1.0)\n    {        \n        col = vec3(rd.y);\n        \n    }\n    else\n    {\n        float glp = clamp(length(pos)*.1, 0.0, 1.0);\n        vec3 N = GetNormal(ro+rd*t.x);\n        vec3 L = vec3(0.0, 1.0, 1.0);\n        float light = dot(N,L);\n        float shade = GetShadow(pos, L, 4.);\n        \n        if(t.y == -1.0) \n        {\n            col = vec3(.3+pos.z*.1);\n            col *= shade;\n        }\n        else\n        {\n            col = vec3(1.0, 0.2+t.y, 1.0-t.y);\n            col *= vec3(light)*.7;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime*.25;\n    \n    vec3 cp = vec3(0.0, 1.0, 5.0);\n    vec3 ct = vec3(0.0, 1.5, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    col = Render(cp, vd, uv);\n    col.z += screenUV.y*.2;\n    col -= random(screenUV) * .1;\n    col *= 1.0-length(uv)*.8;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsG3Rd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsG3RV", "name": "interpolating angles / phases", "author": "FabriceNeyret2", "description": "interpolating or averaging or doing stats on angles (white) or phases is an issue because they warp on [0, 2.Pi].\nBlue: angle average.\nGreen: angle % 2Pi average.\nRed:  complex  (or vector) average: best.", "tags": ["rotation", "angle", "interpolation", "complexes"], "likes": 8, "viewed": 318, "date": "1570548582", "time_retrieved": "2024-06-20T19:46:48.704493", "image_code": "#define CS(a)       vec2( cos(a), sin(a) )           // complex operators\n#define Arg(z)      atan( (z).y,(z).x )\n#define expZ(z)   ( length(z) * CS(z) )\n#define logZ(z)     vec2( length(z), Arg(z) )\n#define mulZ(a,b) ( mat2(a, -(a).y,(a).x) * (b) )\n\nvec2 R;\n\n#define S(d,r,pix) smoothstep( .75, -.75, (d)/(pix)-(r))   // antialiased draw. r >= 1.\n#define F(p,f)     S( abs(f-3.*(p).y-2.), 1., fwidth(f-3.*(p).y) ) // draw curve\n\n// segment with disc ends: seamless distance to segment\nfloat line(vec2 p, vec2 a,vec2 b, float pix, float d) {  // draw line\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);      // proj coord on line\n    if ( d >= 0. && mod(h*10.-d, 3.) < 2.) return 0.;    // dashs\n    d = length(p - b * h);                               // dist to segment \n    return S( d ,1., 2.*pix/R.y );                       // draw line\n}\n\n#define blend0(a0,a1) ( a0 + a1 ) / 2.\n#define blend1(a0,a1) ( mod(a0,TAU) + mod(a1,TAU) ) / 2.\n#define blend2(a0,a1)   Arg( CS(a0) + CS(a1) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n          R = iResolution.xy;      \n    vec2  U = ( 2.*u - R ) / R.y,\n         C0 = vec2(0);\n\n    float r = .8,\n         TAU = 6.2831853,\n          w0 = -1., w1 = 2.713,\n          a0 = w0* iTime, a1 = w1* iTime,\n          x0 = 2.*w0*U.x, x1 = 2.*w1*U.x;\n    \n#define draw(a,e,d) line(U, C0, r* CS(a), e, d)\n    O.b  = draw( blend0(a0,a1), 1., 0. );//  +  F( U, sin( blend0(x0,x1)) );\n    O.g  = draw( blend1(a0,a1), 1., 1. );//  +  F( U, sin( blend1(x0,x1)) );\n    O.r  = draw( blend2(a0,a1), 1., 2. );//  +  F( U, sin( blend2(x0,x1)) );\n    O   += draw(        a0    , 2.,-1. );//  +  F( U, sin( x0 ) );\n    O   += draw(           a1 , 2.,-1. );//  +  F( U, sin( x1 ) )*.5;\n    O   += draw(       0.     , 1.,-1. ) * .3;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsG3RV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsGGDh", "name": "Julia bad", "author": "minecire", "description": "I want to make my vec2s more precise so I can zoom in farther but I'm afraid it's impossible, at least without implementing some things I don't understand very well.\nI made the colors nicer and implemented some other changes FabriceNeyret2 suggested.", "tags": ["juliasets"], "likes": 1, "viewed": 66, "date": "1570066861", "time_retrieved": "2024-06-20T19:46:48.704493", "image_code": "\nvec2 pos = vec2(0,0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = pow(0.999,float(iFrame));\n    vec2 normCoord = vec2((fragCoord.x/iResolution.x*4.-2.)*zoom + pos.x, (fragCoord.y/iResolution.y*2.25-1.125)*zoom + pos.y);\n    vec2 z = normCoord;\n    float zsize;\n    int i;\n    for(i = 0; i < 150000; i++){\n        zsize = dot(z,z);\n        z = mat2( z, -z.y,z.x) * z + iMouse.xy / iResolution.xy*4.-2.;\n        if(zsize > 4.){\n            break;\n        }\n    }\n    if(i == 150000){\n    \tfragColor = vec4(0,0,0, 0);\n    }\n    else{\n        \n        fragColor = vec4(float(i%137)/137.,float(i%298)/298.,1.-float(i%255)/64.,0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsGGDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsGGDR", "name": "abstract lines bootleg", "author": "thefox231", "description": "a bootleg of https://www.shadertoy.com/view/wsGGWR", "tags": ["2d", "simple", "abstract"], "likes": 5, "viewed": 369, "date": "1569980438", "time_retrieved": "2024-06-20T19:46:48.704493", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    uv.y += sin(uv.x*3.0)/((uv.x+4.0+sin(iTime))/0.1);\n    \n    uv.x += round(uv.y*49.3) * (5.347*round(uv.y*49.3+iTime+uv.x*(sin(iTime/10.0)*10.0)*sin(uv.x*3.14)));\n    \n    fragColor = vec4(col,1.0)*mod(uv.x-iTime/5.0,0.4);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsGGDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsK3Rd", "name": "Flight through a nebula v3", "author": "Delvar", "description": "Simple fly though of a 3d box noise via ray marching.\nAdded some stars, a sun and lightning!\nhad to do some shufting around to hide the errors in the box noise, but its very fast.\nstill suffers from repetition though.", "tags": ["noise", "raymarch", "cloud", "nebula", "box"], "likes": 1, "viewed": 209, "date": "1570805862", "time_retrieved": "2024-06-20T19:46:49.807032", "image_code": "// also see \n// voronoi  version, https://www.shadertoy.com/view/tdyGzK\n// simplex version, https://www.shadertoy.com/view/WsG3zd\n// box version, https://www.shadertoy.com/view/tsK3Rd\n\n#define RAY_MAX_STEPS 100\n#define RAY_MAX_DISTANCE 30.0\n\n#define PI\t3.1415926535897932384626433832795\n    \n\n// Flags to use tecture lookups instead of noise functions, should be faster but introduces repetiton.\n//#define noiseTecture3d\n#define noiseTecture2d\n\nstruct camera {\n   vec3 origin, forward, right, up;\n   float zoom; // Distance from screen\n};\n\nstruct ray {\n   vec3 origin, direction;\n};\n\nmat3x3 eulerToMatrix(float roll, float pitch, float yaw){\n  float\n      cPitch = cos(pitch),\n      sPitch = sin(pitch),\n      cYaw = cos(yaw),\n      sYaw = sin(yaw),\n      cRoll = cos(roll),\n      sRoll = sin(roll);\n    \n\tmat3x3 mPitch = mat3x3(\t1.0,\t0.0,\t0.0,\n\t\t\t\t\t\t\t0.0,\tcPitch,\tsPitch,\n\t\t\t\t\t\t\t0.0,\t-sPitch,\tcPitch);\n    \n    mat3x3 mYaw = mat3x3(\tcYaw,\t0.0,\tsYaw,\n\t\t\t\t\t\t\t0.0,\t1.0,\t0.0,\n\t\t\t\t\t\t\t-sYaw,\t0.0,\tcYaw);\n    \n    mat3x3 mRoll = mat3x3(\tcRoll,\t-sRoll,\t0.0,\n\t\t\t\t\t\t\tsRoll,\tcRoll,\t0.0,\n\t\t\t\t\t\t\t0.0,\t0.0,\t1.0);\n\n    return mPitch * mYaw * mRoll;\n}\n\ncamera getCamera(vec3 origin, float roll, float pitch, float yaw, float zoom) {\n\tcamera camera;\n\tcamera.origin = origin;\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw);\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n\tcamera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n\tcamera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n\tcamera.zoom = zoom;\n\treturn camera;\n}\n\nray getRay(vec2 uv, camera camera) {\n\tray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n\treturn ray;   \n}\n\nfloat random(in float st) {\n#if defined(noiseTecture3d)\n\treturn float(texelFetch( iChannel0, ivec3(vec3(139.181,151.199,229.211)*st)&31,0));\n#elif defined(noiseTecture2d)\n\treturn float(texelFetch( iChannel1, ivec2(vec2(139.181,151.199)*st)&255,0));\n# else\n\treturn fract(sin(st*139.181))* 437.5453123);\n#endif\n}\n\nfloat random3(in vec3 st) {\n#if defined(noiseTecture3d)\n\treturn float(texelFetch( iChannel0, ivec3(st)&31,0));\n#elif defined(noiseTecture2d)\n\treturn float(texelFetch( iChannel1, ivec2(st.xy*st.z)&255,0));\n# else\n\treturn fract(sin(dot(st,vec3(12.9898,79.233,96.9723)))* 437.5453123);\n#endif\n}\n\nfloat boxNoise(vec3 samplePoint) {\n    vec3 pointI =floor(samplePoint);\n    vec3 pointF = fract(samplePoint);\n    \n   \n    float bbl = random3(pointI + vec3(0.0,0.0,0.0) );\n    float bbr = random3(pointI + vec3(1.0,0.0,0.0) );\n    float btl = random3(pointI + vec3(0.0,1.0,0.0) );\n    float btr = random3(pointI + vec3(1.0,1.0,0.0) );\n    \n    float fbl = random3(pointI + vec3(0.0,0.0,1.0) );\n    float fbr = random3(pointI + vec3(1.0,0.0,1.0) );\n    float ftl = random3(pointI + vec3(0.0,1.0,1.0) );\n    float ftr = random3(pointI + vec3(1.0,1.0,1.0) );\n    \n    vec3 u =pointF;\n    \n    float bb = mix(bbl,bbr,u.x);\n    float bt = mix(btl,btr,u.x);\n    \n    float b = mix(bb,bt,u.y);\n    \n    float fb = mix(fbl,fbr,u.x);\n    float ft = mix(ftl,ftr,u.x);\n    \n    float f = mix(fb,ft,u.y);\n    \n    return mix(b,f,u.z);\n}\n\nvec3 RayMarch(ray ray, float maxDistance, int maxSteps)\n{\n    float maxStepsf = float(maxSteps);\n    float stepSize = maxDistance/maxStepsf;\n    vec3 total = vec3(0.0);\n    float currentDistance = 1.0;\n    \n    for(float i=0.0; i<maxStepsf; i++) {\n        vec3 project = (ray.direction* currentDistance);\n        //Add some offsets to hide the aligned features in the box noise.\n        project.x +=sin(project.y*0.5);\n        project.y +=sin(project.z*0.2);\n        project.z +=sin(project.x*0.3);\n\t\tvec3 currentPoint = ray.origin + project  ;\n        \n        float stepf = ((maxStepsf - i)/maxStepsf);\n        float s = 1.0-(abs(boxNoise(currentPoint)-0.5)*2.0);\n        s=smoothstep(0.7,1.1, s);\n\n        s *= stepf;\n        vec3 light = sin((currentPoint+vec3(iTime/10.0,iTime/13.0,iTime/15.0))/4.0)*0.5+1.0; //Yes we blow out the colour a little.\n        total += light*s;\n        currentDistance += stepSize;\n    }\n    return (total*(3.0/maxStepsf));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n    //Snap to center on startup.\n    if(iMouse.x <= 1.0 && iMouse.y <= 1.0) {\n        mouse = vec2(0.0,0.0);\n    }\n    \n\tcamera camera = getCamera(vec3(0.0,0.0,iTime), iTime*0.1, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    ray ray = getRay(uv, camera);\n\n    vec3 cloudColour = RayMarch(ray, RAY_MAX_DISTANCE, RAY_MAX_STEPS);\n    \n    //Stars\n    float starBase = random3(floor(ray.direction*iResolution.x*0.5));\n    float stars = starBase>0.05?0.0:starBase*20.0;\n    stars *= stars * stars * stars;\n    float cloudColourLength = length(cloudColour);\n   \tstars *= clamp(pow(clamp(1.0-smoothstep(0.1,1.0,length(cloudColourLength)),0.01,1.0),1.0),0.0,1.0)*0.6;\n    vec3 starColour = vec3(stars);\n    \n    //Sun\n    vec2 facing = vec2(iTime*0.01+1.2,iTime*0.03+0.3);\n    vec3 sunDir = normalize(vec3(\n        sin(facing.x),\n    \tsin(facing.y),\n    \tcos(facing.x)\n     ));\n    \n    float sunBright = clamp(dot(sunDir,ray.direction),0.0,1.0);\n    sunBright = pow(smoothstep(0.8,1.0,sunBright),2.0)* 10.0; //blow it right out\n    sunBright*=(clamp(1.0-cloudColourLength*0.5,0.1,1.0)); //obscure by nebula\n    vec3 suncolour = vec3(0.9, 0.7, 0.6); //nice orange/yellow\n   \n    //Lightning\n    float strikeBright = pow(clamp(sin(ray.direction.x+iTime*10.0)*sin(ray.direction.y+iTime*15.0)*cos(ray.direction.z+iTime*20.0),0.0,1.0),15.0+sin(iTime*2.0)*10.0);\n    strikeBright *= 8.0*clamp(1.0-cloudColourLength,0.1,1.0)*smoothstep(0.7,1.0,random(floor(iTime*5.0)));\n    vec3 strikeColour = vec3(0.7,0.9,1.0);\n    \n    //\n    vec3 colour = max(starColour,suncolour*sunBright*(clamp(1.0-cloudColourLength*0.5,0.1,1.0)) + cloudColour); \n\tcolour+=strikeBright*strikeColour;\n\n    //modualte expose, so the screen darkens when looking at the sun,\n    //rewrite the UV to remove aspect ratio but still in 0 > 1 range\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv; \n    float exposure = smoothstep(-0.7,1.0,( 1.0-pow(clamp(dot(camera.forward, sunDir),0.0,1.0),4.0)));\n    colour *= exposure;\n \n    //Harsh gamma gives it a nicer look.\n    colour = pow(colour, vec3(1.0/0.8));\n    //flatten the colours\n    //colour = 1.35*colour/(1.0+colour);\n    colour = clamp(colour,0.0,1.0);\n  \tcolour = colour*colour*(3.0-2.0*colour);\n    \n    float vignette = clamp(pow( uv.x*uv.y*5.0,0.2)+0.3,0.0,1.0);\n    colour*=vignette;\n    fragColor = vec4(colour,1.0);\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4sfGRr", "previewfilepath": "/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsK3Rd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsK3RK", "name": "Raymarch for practice ", "author": "specialsaucewc", "description": "Learning how to raymarch in shaders.", "tags": ["raymarch", "learning"], "likes": 0, "viewed": 55, "date": "1570580533", "time_retrieved": "2024-06-20T19:46:49.807032", "image_code": "#define MAX_STEPS 100\n#define SURFACE_DIST .06\n#define MAX_DIST 100.\n#define CAMERA_POS vec3(0, 1, 0)\n\n#define SPHERE_POS vec4(0, 1.2, 6, 1)\n#define MATERIAL vec3(.12, .5, .99)\n\n#define LIGHT_COLOR vec3(1, 0, 0)\n#define LIGHT_RAD .01\n#define LIGHT_POS vec3(0, 3, 5)\n#define LIGHT_SPEED 1.5\n\nvec4 GetLightPos() {\n    vec3 lightPos = LIGHT_POS;\n    float speed = iTime * LIGHT_SPEED;\n    lightPos.xz += vec2(sin(speed), cos(speed))*3.;\n    lightPos.y += sin(speed/4.)*2.;\n    return vec4(lightPos, LIGHT_RAD);\n}\n\nvec3 GetLightColor() {\n    return 0.5 + 0.5*cos(iTime+LIGHT_COLOR.xyz+vec3(0,2,4));\n}\n\nfloat GetDist (vec3 p, bool shadow) {\n    vec4 sphere = SPHERE_POS;\n    sphere.y += sin(iTime)*.5 + .5;\n    vec4 light = GetLightPos();\n    float dS = length(p - sphere.xyz)-sphere.w;\n    float dL = length(p - light.xyz)-light.w;\n    float dP = p.y;\n    float d = min(dS, shadow ? dP : min(dP, dL));\n    return d;\n}\n\nfloat RayMarch (vec3 ro, vec3 rd, bool shadow) {\n    float dO = 0.;\n    for (int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro+dO*rd;\n        float ds = GetDist(p, shadow);\n        dO += ds;\n        if (ds < SURFACE_DIST || dO > MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p, false);\n    vec2 e = vec2(SURFACE_DIST, 0.);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy, false),\n        GetDist(p - e.yxy, false),\n        GetDist(p - e.yyx, false));\n    return normalize(n);\n}\n\nvec3 GetLight(vec3 o, vec3 p) {\n    vec3 lightPos = vec3(GetLightPos().xyz);\n    vec3 l = normalize(lightPos - p);\n    vec3 v = normalize(p - o);\n    vec3 n = GetNormal(p);\n    vec3 r = reflect(l, n);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float spec = pow(max(dot(v, r), 0.), 32.);\n    vec3 wVal = vec3(1., dif, spec) * MATERIAL;\n    float s = wVal.y + wVal.z;\n    \n    float d = RayMarch(p+n*SURFACE_DIST*2., l, true);\n    if (d < length(lightPos-p)) {\n        s *= .1;\n    }\n    vec3 lCol = GetLightColor();\n    \n    return (wVal.x + s) * lCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = CAMERA_POS;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    float d = RayMarch(ro, rd, false);\n    \n    if (d < MAX_DIST) {\n    \tvec3 p = ro + d * rd;\n        vec3 l = GetLightPos().xyz;\n        if (length(p - l) < 2.*SURFACE_DIST) {\n            col = GetLightColor();\n        }\n        else {\n    \t\tcol = GetLight(ro, p);\n        }\n    }\n    else {\n        col = vec3(0.);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsK3RK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsKGWG", "name": "Red Pulse", "author": "mujina", "description": "First shader. Red glowing light", "tags": ["glowing"], "likes": 3, "viewed": 77, "date": "1570882493", "time_retrieved": "2024-06-20T19:46:49.807032", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.y;\n    float xy_ratio = iResolution.x / iResolution.y;\n\t\n    vec2 center = vec2(0.5 * xy_ratio, 0.5);\n    float r = 0.6;\n    float omega = 5.;\n    \n    vec3 col = vec3(r * (cos(omega * iTime) + 2.) / 2. - length(uv - center), 0., 0.);\n        \n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsKGWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsKGzh", "name": "Framed Geometric Pattern", "author": "Shane", "description": "The picture-framed image is a bit of a computer graphics cliche, but an effective way to display an otherwise simple geometric pattern.", "tags": ["2d", "truchet", "wood", "pattern", "maze", "frame", "herringbone"], "likes": 39, "viewed": 684, "date": "1572438423", "time_retrieved": "2024-06-20T19:46:52.673994", "image_code": "/*\n\n\n\tFramed Geometric Pattern\n\t------------------------\n\n\tI made this a while ago. It's not that exciting, but I thought I'd put\n\tit up anyway. :)\n\n    The picture-framed image is a bit of a computer graphics cliche, but an \n\teffective way to display an otherwise simple geometric pattern. Like a \n\tlot of grid-based patterns out there, this one is Truchet based. The \n\tpicture frame itself was applied using standard distance field and \n\tlayering techniques.\n\n\tThe background image is just some offset circles and is based on an\n\tunderlying herringbone grid pattern. The timber is just an application of \n\tan old layered noise technique, which I'd imagine was first oulined by \n\tKen Perlin, back in the day.\n\n\t\n\tOther Examples:\n\n    // BigWIngs's popular Youtube channel. It's always informative seeing how \n\t// others approach various graphics topics.\n    Shader Coding: Truchet Tiling Explained! -  The Art of Code\n\thttps://www.youtube.com/watch?v=2R7h76GoIJM\n\n\n\t// Flipped Truchet pattern basics. Fabrice does it in a few of his \n\t// examples too, if anyone wants to track them down.\n    TruchetFlip - JT\n    https://www.shadertoy.com/view/4st3R7\n\n\n*/\n\n// Originally, this was a plain pattern I put together, just for something to do.\n// I thought it looked a little too plain, so got a bit carried away. Anyway, if\n// you're more of a \"less is more\" person, like me, here's the original.\n//#define PATTERN_ONLY\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// IQ's animated vec2 to float hash.\nfloat hash21A(vec2 p){  \n    float x = fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n    return sin(x*6.2831 + iTime/3.)*.5 + .5;\n}\n\n// IQ's rounded box formula -- slightly modified.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// Textureless 3D Value Noise:\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement. I have no idea whether it's faster or not. It could be slower,\n// for all I know, but it doesn't really matter, because in its current state, \n// it's still no match for IQ's texture-based, smooth 3D value noise.\n//\n// By the way, a few people have managed to reduce the original down to this state, \n// but I haven't come across any who have taken it further. If you know of any, I'd\n// love to hear about it.\n//\n// I've tried to come up with some clever way to improve the randomization line\n// (h = mix(fract...), but so far, nothing's come to mind.\n\nfloat n3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(27, 113, 57);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*p*(p*(p * 6. - 15.) + 10.);\n    \n    // Even smoother, but this would have to be slower, surely?\n\t//vec3 p3 = p*p*p; p = ( 7. + ( p3 - 7. ) * p ) * p3;\t\n\t\n    // Cosinusoidal smoothing. OK, but I prefer other methods.\n    //p = .5 - .5*cos(p*3.14159);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    //return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n);\n    return sin(p*6.2831853 + iTime*1.57); \n    \n}\n\n\n// The Truchet distance field. Truchet patterns, in their various forms, are \n// pretty easy to put together; Render some rotationally symmetric tiles, then\n// randomly rotate them. If you know how to render simple 2D objects like \n// squares, circles, arcs, etc, you should be good to go. As you can see from\n// the imagery, these tiles consist of a line of circles and some chopped\n// out circles.\nfloat distField(vec2 p){\n    \n    // Saving the original position.\n    vec2 oP = p;\n \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Random value for the tile. This one is time based.\n    float rnd = hash21A(ip);\n    \n    // If the random number generated by the unique ID for the\n    // tile is above a certain threshold, flip it upside down.\n    if(rnd<.5) p.y = -p.y;\n  \n    \n    // Distance field.\n    float d = 1e5;\n    \n    // Radius.\n    float r = .09;\n    \n    // Two circles on diagonally opposite corners.\n    d = min(d, length((p) - vec2(-.5, .5)) - .5);\n    d = min(d, length((p) - vec2(.5, -.5)) - .5);\n\n    // Some small circles down the center.\n    float d2 = length(p - .3) - r*.9;\n    d2 = min(d2, length(p - .1) - r*.7); \n    d2 = min(d2, length(p + .1) - r*.7); \n    d2 = min(d2, length(p + .3) - r*.9);  \n    \n    // Flip checkered tiles. It's a necessary operation to perform\n    // for this style of Truchet tile.\n    if(mod(ip.x + ip.y, 2.)<.5) d = -d;\n    if(rnd>=.5) d = -d;\n    \n    // Put in some decorative borders. I like them, but you can take\n    // them out if you feel it's too much.\n    d = max((d - r*1.25), -(abs(abs(d ) - .05) - r/3.));\n    \n    // Combining the dotted lines and circles, whilst allowing for\n    // the checkerboard flipping.\n    if(mod(ip.x + ip.y, 2.)<.5){\n        if(rnd<.5) d = max(d, -d2);\n        else d = min(d, d2);\n    }\n    else {\n       if(rnd<.5) d = min(d, d2);\n        else d = max(d, -d2); \n    }\n    \n    // Adding a grid. Not necessary, but I like it.\n    p = abs(p);\n    float grid = abs(max(p.x, p.y) - .5) - .015;\n    d = min(d, grid);\n    \n   \n    // Rendering circles at the grid vertices, whilst accounting\n    // for checkerboard flipping.\n    vec2  q = oP - .5;\n    vec2 iq = floor(q);\n    q -= iq + .5;\n\n    if(mod(iq.x + iq.y, 2.)<.5){\n        d = min(d, length(q) - r*1.4);\n    }\n    else {\n       d = max(d, -(length(q) - r*1.4));\n    }\n    \n\n    // Return the distance field value.\n    return d;\n}\n\n// Skewing and unskewing.\nvec2 skewXY(vec2 p, vec2 v){ return mat2(1, -v.y, v.x, 1)*p; }\nvec2 unskewXY(vec2 p, vec2 v){ return inverse(mat2(1, -v.y, v.x, 1))*p; }\n\n\n// The background pattern.\nvec4 bgField(vec2 q2){\n    \n    // Helper variables: Scale, skewing vector, \n    // individual cell dimension, and block dimension.\n    const float scale = 1./1.25;\n\tconst vec2 sk = vec2(1, -1)/5.; // 12 x .2\n\tvec2 dim = vec2(1.5, 1)*scale;\n\tvec2 s = (vec2(2.5, 2.5) - abs(sk)/2.)*scale; // 12 x .2\n\n    \n    \n    float d = 1e5;\n    vec2 cntr, p, ip;\n    \n    vec2 id = vec2(0);\n    vec2 l = dim;\n    cntr = vec2(0);\n    float boxID = 0.;\n    vec2 offs = vec2(1, 0);\n    \n    for(int i = 0; i<4; i++){\n         \n        // With herringbone arrangements, the rectangular tile needs to\n        // be intermittently rotated by 90 degrees, which means flipping\n        // dimensions, etc.\n        if(i==2) {\n            cntr = vec2((dim.x + dim.y)/2., -dim.y/4.);\n            l = l.yx;\n            offs = offs.yx;\n        }\n        \n    \tp = q2 - cntr; // Local coordinates, based on a square grid.\n    \tp = skewXY(p, sk); // Skewing by the X and Y skewing values.\n        ip = floor(p/s); // Local tile ID.\n        p -= (ip + .5)*s; // New local position.\n        p = unskewXY(p, sk); // Unskewing.\n\n        \n        // Individual positional tile ID.\n        vec2 idi = ip*s + cntr + l/2.;\n        // Don't forget to unskew the ID... Yeah, skewing is confusing. :)\n        idi = unskewXY(idi, sk);\n        \n        // The brick dimension itself. Not used here.\n        //float di2D = sBoxS(p, l/2., .04);\n       \n \n        // We're rendering a large circle and two smaller circles in each \n        // rectangular tile, which are randomly flipped in accordance with\n        // the tile ID.\n        if(hash21(idi)<.5) p = -p;\n        \n        float lw = dim.y/4.; // Offset.\n        float sz = dim.y/2.; // Size.\n        float ew = .04*scale; // Empty border width, or margin, to CSS folk.\n        \n        vec3 df;\n        \n        // Large circle, and two smaller circles.\n        df.x = length(p - offs*lw) - (sz - ew);\n        df.y = length(p + offs*lw*2. + offs.yx*lw) - (sz/2. - ew);\n        df.z = length(p + offs*lw*2. - offs.yx*lw) - (sz/2. - ew);\n\n        // A little offset circle inside the large circle.\n        vec2 rnd22 = hash22(idi);\n        df.x = max(df.x, -(length(p - offs*lw - rnd22*(lw/2. + .05*scale)) - lw/2.5));          \n \n        // Obtain the smallest of the three circles for this particular tile.\n        vec3 dfi = df.x<df.y && df.x<df.z? vec3(df.x, offs*lw) :\n        \t\t   df.y<df.z? vec3(df.y, offs*lw*2. + offs.yx*lw) :\n        \t\t   vec3(df.z, offs*lw*2. - offs.yx*lw);\n        \n        // If one of the circle objects in this particular tile is smaller than the\n        // overall smallest object, update the distance field, object ID, and make\n        // a note of the rectangular tile ID.\n        if(dfi.x<d){\n            \n            d = dfi.x;\n            id = idi + dfi.yz;\n            boxID = float(i);\n            \n        }\n        \n        // Move the position down by the longest length.\n        cntr -= -dim.y;\n        \n    }\n    \n    // Return the distance, ID and rectangular tile ID.\n    return vec4(d, id, boxID);\n}\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n    // Return the hatch value.\n    return hatch;\n    \n}\n\n \n// One of many simple wood grain formulas. Not much thought was put into it.\n// This one has accentuated grain marks for a more cartoonish look, but more\n// realistic grains can be created in a simpilar fashion.\nvec4 woodGrain(in vec3 p){\n\n   \n    // Noise.\n    float ns = (n3D(p*96.)*.67 + n3D(p*192.)*.33);\n    \n    // Slight perturbation.\n    //p += (n3D(2.5*p)*.66 + n3D(5.*p)*.34)*.5;\n    p += (n3D(2.*p)*.57 + n3D(4.*p)*.28 + n3D(8.*p)*.15)*.5;\n    \n    // Stretching things out along one of the axes -- In this case the Y axis.\n    p *= vec3(1, 80, 1)*4.;\n    \n    // Cheap fract lines.\n    float v = fract(-p.y*.1);\n    //float v = fract(dot(p, vec3(-.1)));\n    v *= v;\n    v = min(v, v*(1. - v)*5.); // Smoothing the fract lines.\n\n    // Using the value above to produce the timber color. I did this a while\n    // ago, but I'm sure I knew what I was doing at the time. :D\n    vec3 rWood = pow(min(vec3(1.5, 1, 1)*mix(.3, .9, v), 1.), vec3(1, 3, 12));\n    vec3 wood = mix(vec3(.6, .4, .2), vec3(1.2, .8, .4), v);\n    //vec3 wood = mix(vec3(.5, .125, .025)/1.25, vec3(.75, .27, .05)*1.5, v);\n    //vec3 wood = mix(vec3(1, .8, .6)/3., vec3(1.2, 1, .8), v);\n    \n    wood = mix(wood, rWood, .25 - v*.25);\n    \n    // Adding in a sprinking of noise.\n    vec3 rNoise = pow(min(vec3(1, 1, 1)*mix(.8, 1., ns), 1.), vec3(1, 2, 3));\n    wood = min(wood*rNoise*1.1, 1.);\n    \n    // Toning things down, just a touch.\n    //wood = pow(wood, vec3(.95));\n    \n    // Returning the timber color value, and the distance value -- which in this\n    // case, is just the red channel, but it could be something more sophisticated.\n    return vec4(wood, wood.x);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Scaling only.\n    float gSc = 10.;\n    vec2 p = uv*gSc;\n    \n    // Saving a copy of the original.\n    vec2 oP = p;\n    \n    // Resolution based scaling.\n    float sf = gSc/iResolution.y;\n\n    // The framed distance field.\n    float d = distField(p);\n    \n    // The background pattern.\n    vec4 dBg = bgField(rot2(-3.14159/4.)*oP);\n    \n    // Frame width, rounding factors and frame dimensions.\n    const float frW = .45;\n    const float rF = .05, rF2 = .01;\n    vec2 fDim = vec2(14, 6);\n    \n    #ifdef PATTERN_ONLY\n    // A quick hack to display the Truchet pattern only.\n    fDim *= 2.;\n    #endif\n    \n    \n    \n    // The square frame.\n    vec2 q = p;\n    float sqr = sBoxS(q, fDim/2. + frW*2., rF);\n    float fr = max(sqr, -sBoxS(q,fDim/2., rF2)); \n  \n    // The frame shadow.\n    q = (p - vec2(frW/2., -frW/2.));\n    float sqr2 = sBoxS(q, fDim/2. + frW*2., rF);\n    float fr2 = max(sqr2, -sBoxS(q, fDim/2., rF2));\n    \n    \n    // Using a standard distance filed operation to cut down the size of \n    // the cavas to the frame.\n    d = max(d, sqr + frW*2.);\n\n    \n    // A hatch value, just to add a little extra texture here and there.\n    float hatch = doHatch(oP/gSc, iRes);\n    \n    \n    // The timber color.\n    float frSh = clamp(.25 - fr/frW*2., 0., 1.);\n    vec4 wGrain = woodGrain(vec3(oP/4., 1. + frSh*.1));\n    // Last minute adjustment: Toning the wood grain down a bit, if desired.\n    //wGrain.xyz = mix(wGrain.xyz, wGrain.w*wGrain.w*vec3(.85, .8, .75), .25);\n \n    \n    // Applying some cheap hatching.\n    wGrain.xyz *= hatch*.3 + .8;\n\n    \n    // The scene color. Initialized to zero.\n    vec3 col = vec3(0);\n     \n    \n    // Applying the background circle pattern.\n    vec4 wGrainBg = woodGrain(vec3(oP/3. + .5, 1.));\n    col = vec3(.95, .8, .7)*(wGrainBg.w*.3 + .85);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*1.5, dBg.x))*.35);\n    col = mix(col, vec3(.95, .8, .7)*(hatch*.2 + .9), (1. - smoothstep(0., sf, dBg.x + .05))*.7);\n\n    // A cleaner background.\n    //col = vec3(.95, .8, .7);\n    //col *= wGrainBg.w*.5 + .7;     \n    \n    // Applying some subtle hatching.\n    col *= hatch*.35 + .75;\n         \n    \n    // Putting the frame shadow down first.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*15., fr2 - .05))*.65);\n    \n    // The frame.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., fr))*.5);\n    col = mix(col, wGrain.xyz*frSh, (1. - smoothstep(0., sf, fr)));\n   \n   \n    // The frame content: In this case, the dot-like Truchet pattern.\n    col = mix(col, vec3(.8) + hatch*.3, (1. - smoothstep(0., sf, sqr + frW*2.)));\n    col = mix(col, vec3(.01, .005, 0) + hatch*.05, (1. - smoothstep(0., sf, d)));\n    \n    // Outer edging.\n    col = mix(col, vec3(.1, .05, 0), (1. - smoothstep(0., sf*1.5, abs(fr + .01) - .01))*.85);\n    \n    // Inner edging... or something like that -- Like everyone else, I make this stuff \n    // up as I go along. :)\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*1.5, abs(fr + .15) - .01))*.75);\n    \n    // Subtle highlighting.\n    col = mix(col, col*1.35, (1. - smoothstep(0., sf*4., max((fr + .02), -(fr2 + .02)))));\n\n  \n    // Cheap paper grain.\n    oP = floor(oP/gSc*1024.);\n    vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    col *= .9 + .1*rn3.xyz  + .1*rn3.xxx;    \n\n     \n     \n    // Applying a subtle silhouette, for art's sake.\n\tuv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./32.); \n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsKGzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tstSWn", "name": "\"The Universe Within\" - Pt. 1", "author": "voxel", "description": "This is my take on the shader that YouTube channel The Art of Code creates in the first video of their series \"The Universe Within\" (https://www.youtube.com/watch?v=3CycKKJiwis).", "tags": ["test"], "likes": 4, "viewed": 216, "date": "1571795786", "time_retrieved": "2024-06-20T19:46:52.673994", "image_code": "float lineDist(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba*t);\n}\n\nfloat H21(vec2 p) {\n    return fract(sin(p.x * 123.456 + p.y * 7654.321) * 314.159);\n}\n\nvec2 getCirc(vec2 id) {\n    float f1 = 0.3 + H21(id);\n    float f2 = 0.3 + H21(id + 50.);\n    float p1 = H21(id + 100.) * 100.;\n    float p2 = H21(id + 150.) * 100.;\n    float r = 0.35;\n    float x = sin(f1 * iTime + p1);\n    float y = sin(f2 * iTime + p2);\n    return 0.5 + r * vec2(x, y);\n}\n\nfloat distScale(float dist) {\n    return smoothstep(1.5, .6, dist);\n}\n\nfloat connectVal(vec2 p, vec2 circ1, vec2 circ2) {\n    float ds = distScale(distance(circ1, circ2));\n    return smoothstep(ds*.08+0.04, .0, lineDist(p, circ1, circ2)) * ds;\n}\n\nfloat combineGrad(float grad, float cv) {\n    return grad + cv;\n}\n\n#define UPDATE_GRAD(n1, n2) \\\n  grad = combineGrad(grad, connectVal(sp, neighbors[n1], neighbors[n2]))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 id = floor(fragCoord / 40.);\n    vec2 sp = fract(fragCoord / 40.);\n\n    vec2 neighbors[9];\n    for (int i = 0, dx = -1; dx < 2; dx++) {\n        for (int dy = -1; dy < 2; dy++) {\n            neighbors[i++] = getCirc(id + vec2(dx, dy)) + vec2(dx, dy);\n        }\n    }\n    float grad = 0.;\n    for (int i = 0; i < 9; i++) {\n        if (i != 4) {\n            UPDATE_GRAD(i, 4);\n        }\n    }\n    \n    UPDATE_GRAD(1, 5);\n    UPDATE_GRAD(5, 7);\n    UPDATE_GRAD(7, 3);\n    // UPDATE_GRAD(3, 1);\n    \n    vec3 col = vec3(grad);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tstSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tstXDr", "name": "refraction concept", "author": "Txoka", "description": "refraction", "tags": ["refraction", "concept"], "likes": 5, "viewed": 403, "date": "1571828746", "time_retrieved": "2024-06-20T19:46:52.673994", "image_code": "float sphere(vec2 ray, vec2 dir, vec2 center, float radius, float n)\n{\n\tvec2 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - n*sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1., t, st);\n}\nfloat line(vec2 uv, vec2 p, vec2 p2){\n\tvec2 n=uv-p;\n\tvec2 w=p2-p;\n\tfloat r=clamp(dot(n,w)/dot(w,w),0.,1.);\n\tr=length(n-w*r);\n\n    return clamp(smoothstep(0.01,0.004,r)*(smoothstep(0.6,1.,1.)),0.,1.);\n}\nfloat point(vec2 uv, vec2 p){\n    p-=uv;\n\treturn 0.0001/dot(p,p);\n}\nconst float n_air=1.;\nconst float n_glass=1.2;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y*1.+vec2(0.7,0);\n    \n    vec2 ro=vec2(-1,0);\n    vec2 rd=normalize(vec2(-0.5,sin(iTime)*0.125)-ro);\n    vec2 c=vec2(1,0);\n    float r=0.5;\n    \n\n    float dist=sphere(ro,rd,c,r,1.);\n    vec2 surf=ro+rd*dist;\n    \n    vec2 norm=normalize(surf-c);\n    vec2 rd_refle=reflect(rd,norm);\n    vec2 rd_refra_1=refract(rd,norm,n_air/n_glass);\n    \n    float dist2=sphere(surf,rd_refra_1,c,r,-1.);\n    vec2 surf2=surf+rd_refra_1*dist2;\n    \n    vec2 norm2=normalize(c-surf2);\n    \n    vec2 rd_refra_2=refract(rd_refra_1,norm2,n_glass/n_air);\n    \n    \n    \n    float k=distance(c,uv)-r;\n    vec3 col = smoothstep(0.0001,0.,k*k)*vec3(0,0,1);\n    \n    \n\tcol+=point(uv,ro);\n    col+=point(uv,c);\n    col+=point(uv,rd*0.2+ro);\n    col+=point(uv,surf2);\n    col+=point(uv,surf);\n    col+=point(uv,surf+0.2*rd_refle);\n    col+=point(uv,surf+0.2*rd_refra_1);\n    col+=point(uv,surf2+0.2*rd_refra_2);\n    \n    col+=line(uv,ro,surf)*vec3(1,0,0);\n    col+=line(uv,surf,surf2)*vec3(1,0,0);\n    col+=line(uv,surf,surf+rd_refle)*vec3(1,0,0);\n    col+=line(uv,c,(surf-c)*2.+c)*vec3(0,1,0);\n\tcol+=line(uv,c,(surf2-c)*2.+c)*vec3(0,1,0);\n    col+=line(uv,surf2,surf2+rd_refra_2)*vec3(1,0,0);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tstXDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tstXR7", "name": "Affine Space / Automorphism", "author": "cmarangu", "description": "[url]https://twitter.com/c010011012/status/1270521006235377666[/url]\n[url]https://www.reddit.com/r/perfectloops/comments/h01vcj/aoc_impossible_cube_wave/[/url]", "tags": ["voxel", "penrose", "swirledseries"], "likes": 4, "viewed": 187, "date": "1571713684", "time_retrieved": "2024-06-20T19:46:55.043939", "image_code": "\n\n\n///*\n// Current code for: Affine Space / Automorphism\n// Date: 2020 5/28 (idea/started before then around 5/7)\n// Description: [url]https://twitter.com/c010011012/status/1270521006235377666[/url]\n// [url]https://www.reddit.com/r/perfectloops/comments/h01vcj/aoc_impossible_cube_wave/[/url]\n// Tags: voxel, penrose, swirledseries\n\n\n//\n// TODO:\n// - wave start slow from left come faster\n// - distributed/sharp shadows\n// - interpolate cubes' normals slightly to that of spheres w/same center\n// - to help w shading specular maps look nicer\n\n\n// ↓ i know more\n#define PI 3.14159265358979323846264338327950288419716939937510582097494459\n#define TAU (2.*PI)\n\n#define arg mod(float(iFrame)/60./4., 1.)\n\n\n\n// sky box\n// #define sund vec3(cos(TAU*arg), 1., -sin(TAU*arg))\n#define sund normalize(vec3(.4, .5, -1.))\n\nvec3 sky_map (vec3 p, vec3 d) {\n    // return vec3(1.);\n    // return vec3(0., 0., 100./255.);\n    // return vec3(.5, .8, .9);\n    float cloudamt2 = 0.;\n    vec2 g = vec2(p.x-p.y, -p.z-p.y);\n    g *= .08;\n    cloudamt2 += .7*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/43.).r;\n    cloudamt2 += .3*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/15.).r;\n    cloudamt2 = pow(cloudamt2, 1.);\n    return clamp(vec3(.5, .8, .9)*.2+cloudamt2, 0., 1.);\n    // return vec3(.3, .5, .9)+vec3(1.)*cloudamt2;\n    // return texture(iChannel2, d).rgb;\n    float dimness = .5+.5*cos(d.y*PI);\n    \n    \n    float a = 2.;\n    float ah = dot(vec3(d.x, -abs(d.y), d.z), normalize(vec3(0., -a, 0.)) );\n    float h = a/ah;\n    float o = sqrt(h*h-a*a);\n    float th = atan(d.z, d.x);\n    // g is where it hits the ground/sky\n    //vec2 g = vec2(cos(th)*o, sin(th)*o);\n    \n    // get ths sky color\n    float cloudamt = 0.;\n    cloudamt += .7*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/43.).r;\n    cloudamt += .3*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/15.).r;\n    cloudamt = pow(cloudamt, 2.);\n    // cloudamt *= .4;\n    // cloudamt += .0*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/90.).r;\n    float sunamt = clamp(dot(d, sund), 0., 1.);\n    float sunglow = pow(sunamt, 1.)*.2;\n    \n    vec3 SKY_COLOR = vec3(.0, .5, 1.);\n    SKY_COLOR += cloudamt;\n    // SKY_COLOR *= 1.-sunhalo;\n    // SKY_COLOR += vec3(1., .9, .6)*sunhalo;\n    SKY_COLOR += vec3(1., 1., 1.)*sunglow*2.;\n    \tdimness = mix(dimness, 1., sunglow);\n    \t// dimness = mix(dimness, 1., sunhalo);//sunamt*sunamt);\n    if (d.y > .2) {\n        return SKY_COLOR*pow(dimness, .05);\n    }\n    else {\n        // return vec3(1.)*mod(floor(g.x)+floor(g.y), 2.);\n        vec3 GROUND_COLOR = vec3(.3, .5, .3)*(.0+.8*texture(iChannel0, g/5.).r);\n        \n        GROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n        GROUND_COLOR *= 4.;\n        GROUND_COLOR = clamp(GROUND_COLOR, 0., 1.);\n        \n        float puddleamt = .5+.5*sin(g.x*o*.05);\n        puddleamt = .5*puddleamt+.5*texture(iChannel0, vec2(g.x, g.y)/20.).r;\n        puddleamt = pow(puddleamt, .3);\n        dimness = mix(dimness, 1., puddleamt)*.5;\n        \n        if (puddleamt > .8) {\n            float amt = (puddleamt-.3)/.6;\n            amt = clamp(amt, 0., 1.);\n            amt = pow(amt, 2.);\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR+vec3(.4), amt);\n        }\n        if (-.2 <= d.y && d.y <= .2) {\n            float amt = (d.y+.2)/.4;\n            dimness = mix(\n                dimness,\n                mix(\n                    dimness*2.,\n                    1.,\n                    -puddleamt\n                ),\n                amt\n            );\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR, amt);\n        }\n        return GROUND_COLOR*dimness*mix(0., 1., clamp(abs(d.y)*12., 0., 1.));\n    \n    }\n\n}\n\n\n\n\n\n\n// intersections have a normal and then a distance\n#define inter_sky vec4(vec3(0.), 1e9)\n\n\n// intersect plane\n#define inter_plane_short(p, d, c, n) ( dot(-n, d) > 1e-6 ? vec4(n, dot(c-p, -n)/dot(-n, d)) : inter_sky )\n// #define inter_plane_dist(p, d, c, n) ( dot(n, d) > 1e-6 ? dot(c-p, n)/dot(n, d) : inter_sky )\nvec4 inter_plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n    vec4 inter_plane1;\n    inter_plane1 = inter_plane_short(p, d, c, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    //inter_plane1 = inter_plane_short(p, d, c, -n);\n    //if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n    //    return inter_plane1;\n    //}\n    return inter_sky;\n}\n\n\nfloat h (vec2 p) {\n    float amt = clamp(arg*10.-max(p.x+9., 0.)*0.4, 0., 1.);\n    //float amt = clamp(arg*10.-max(\n    //    length(vec2(p.x-1., -p.y-1.0))*3./2.,\n    //    0.\n    //)*0.5, 0., 1.);\n    amt = -amt*(amt-1.)*1.0+amt;\n    return -amt*2.;\n}\n\n// intersect custom SDF\n// #define SDF(p) (length(p)-2.)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-.3, 0.))-.18)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-.4, 0.))-.07)\n#define SDF(p) (length(vec3(\\\n    max(abs((p).x-.5)-.4, 0.),\\\n    max(((p).y-.5)-.4, 0.),\\\n    max(abs((p).z-.5)-.4, 0.)\\\n))-.07)\n\n#define inf vec2(1e-3, 0.)\nvec4 inter_SDF (vec3 p, vec3 d) {\n    vec3 camp = p;\n    float SDFp;\n    for (int i=0; i<200; ++i) {\n        SDFp = SDF(p);\n        if (abs(p.x-.5) > 1. || abs(p.z-.5) > 1. || SDFp > 4.) {\n            break;\n        }\n        else if (abs(SDFp) < 1e-3) {\n            return vec4(\n                normalize(-SDFp+vec3(\n                    SDF(p+inf.xyy),\n                    SDF(p+inf.yxy),\n                    SDF(p+inf.yyx)\n                )),\n                length(p-camp)\n            );\n        }\n        p += d*abs(SDFp)*.9;\n    }\n    return inter_sky;\n}\n\n\n\n\nvec4 inter_pillars (vec3 p, vec3 d) {\n    vec4 inter_closest;\n    vec4 inter_current;\n    vec3 camp = p;\n    for (int jumps=0; jumps<10; ++jumps) {\n        vec4 inter_solid1 = inter_SDF(vec3(fract(p.x), p.y+h(floor(p.xz)), fract(p.z)), d);\n        //vec4 inter_solid1 = inter_SDF(p, d);\n        if (inter_solid1.w < inter_sky.w) {\n            // hits sdf - portals will not be hit\n            inter_solid1.w += length(p-camp);\n            return inter_solid1;\n        }\n        // check 4 \"panes\" / portals\n        inter_closest = inter_sky;\n        inter_current = inter_plane(p, d, floor(p)+vec3(1., 0., 0.), normalize(vec3(-1., 0., 0.)) );\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n        }\n        inter_current = inter_plane(p, d, floor(p)+vec3(0., 0., 1.), normalize(vec3(0., 0., -1.)) );\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n        }\n        inter_current = inter_plane(p, d, floor(p)+vec3(0., 0., 0.), normalize(vec3(1., 0., 0.)) );\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n        }\n        inter_current = inter_plane(p, d, floor(p)+vec3(0., 0., 0.), normalize(vec3(0., 0., 1.)) );\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n        }\n        p += d*inter_closest.w;\n        p += d*1e-3;\n    }\n    return inter_sky;\n}\n\n\n\n\n// main image - camera/initial raycast, setting pixel color\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec3 retina = vec3(0.);\n    #define numsamples 1.\n    vec4 randy;\n    for (float samplei=0.; samplei<numsamples; ++samplei) {\n        randy = texture(iChannel1, vec2(\n            samplei/256.+fragCoord.x/256., float(iFrame)/256.+fragCoord.y/256.\n        )).rgba;\n        // -1 to 1 in y, proportional in x\n        vec2 screen = (\n            -iResolution.xy/2.\n            +fragCoord+randy.rg\n        )/iResolution.y*2.;\n        \n        // camera\n        vec3 camp = vec3(screen.xy*4., -20.);\n        vec3 camd = normalize(vec3(0., 0., 1.));\n        \n        // float ph = (iMouse.y/iResolution.y*2.-1.)*4.;\n        #define ph atan(1./sqrt(2.))\n        mat2 zenith = mat2(\n            cos(ph), cos(PI*.5+ph),\n            sin(ph), sin(PI*.5+ph)\n        );\n        camp.yz *= zenith;\n        camd.yz *= zenith;\n        \n        // float th = (iMouse.x/iResolution.x*2.-1.)*TAU;\n        #define th (PI*.25)\n        mat2 azimuth = mat2(\n            cos(th), cos(PI*.5+th),\n            sin(th), sin(PI*.5+th)\n        );\n        camp.xz *= azimuth;\n        camd.xz *= azimuth;\n        \n        camd = normalize(camd);\n        \n        \n        // space skipping\n        vec4 skp = inter_plane(camp, camd, vec3(0., 4., 0.), normalize(vec3(0., 1., 0.)) );\n        if (skp.w < inter_sky.w && skp.w > 0.) {\n            camp += camd*skp.w;\n        }\n        \n        \n        \n        // raytracing\n        vec3 finalCol = vec3(0.);\n        float shiny = 1.;\n        vec3 p = camp;\n        vec3 d = camd;\n        \n        for (int bounces=0; bounces<32; ++bounces) {\n            \n            if (shiny < .1) {\n                break;\n            }\n            \n            vec4 inter_closest = inter_sky;\n            // for (var i in scene... inter_current = scene[i]) {\n                vec4 inter_current = inter_pillars(p, d);\n                if (inter_current.w < inter_closest.w) {\n                    inter_closest = inter_current;\n                }\n            //}\n            \n            if (dot(d, normalize(vec3(0., 1., 0.))) > 0. && p.y > 5.) {\n                // far enough from floor and angled away from such that\n                // ray will garunteed hit sky\n                // finalCol += vec3(1., 0., 0.)*shiny;\n                // shiny *= 0.;\n                break;\n            }\n            if (inter_closest.w >= inter_sky.w) {\n                // hits sky - stop reflection/refraction loop\n                break;\n            }\n            else {\n                // hits object\n                p += d*inter_closest.w;\n                \n                float czk = mod(floor(p.x)+floor(p.z), 2.);\n                \n                // shadows\n                vec4 shado = inter_pillars(p+sund*2e-3, sund);\n                //vec4 shado = inter_sky;\n                if (shado.w < inter_sky.w) {\n                    #define shininess .6\n                    finalCol += shiny*shininess*vec3(0.);\n                    shiny *= 1.-shininess;\n                    #undef shininess\n                }\n                \n                if (czk < .5){\n                    // have normal and distance to closest itnersection\n                    // reflect, refract, texture, etc.\n                    #define shininess .5\n                    vec3 TEXp = vec3(1.)*mod(floor(p.x*7.)+floor(p.z*7.), 2.);\n                    TEXp = vec3(0.);\n                    //TEXp.rg = vec2(\n                    //    mod((p.x-p.y)*.025, 1.),\n                    //    mod((-p.z-p.y)*.025, 1.)\n                    //)*4.;\n                    finalCol += TEXp*shiny*shininess;\n                    shiny *= 1.-shininess;\n                    d = reflect(d, inter_closest.xyz);\n                    p += d*1e-3;\n                    #undef shininess\n                }\n                else {\n                    \n                    #define shininess .5\n                    // also .2\n                    vec3 TEXp = abs(inter_closest.xyz);\n                    TEXp.rgb  = vec3(\n                        min(min(TEXp.r, TEXp.g), TEXp.b),\n                        TEXp.r,\n                        max(max(TEXp.r, TEXp.g), TEXp.b)\n                    );\n                    //TEXp = vec3(.0, .2, .6);\n                    TEXp = vec3(0., .7, .7);\n                    finalCol += TEXp*shiny*shininess;\n                    shiny *= 1.-shininess;\n                    d = reflect(d, inter_closest.xyz);\n                    p += d*1e-3;\n                    #undef shininess\n                }\n                \n            }\n        }\n        \n        if (shiny == 1.) {\n            // never hit object - real sky color\n            finalCol += shiny*vec3(0., 1., 100./255.);\n            shiny *= 0.;\n        }\n        // add sky color to final reflection/refraction\n        // finalCol += (vec3(0., 0., 100./255.))*shiny;\n        finalCol += sky_map(p, d)*shiny;\n        retina += finalCol;\n    }\n    fragColor = vec4(retina/numsamples, 1.);\n}\n\n/**/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n\n// Old Code for: raymarched reflections!\n// Date: 2019 10/22 (around then)\n// Tags: raymarching\n// Description: Coded by me from scratch, with refrence and\n// inspiration from Shanes shader and CodeParade's video, as well as\n// TheArtOfCode's raymarching tutorial\n\n\n// MADE ENTIRELY FROM ME BY SCRATCH FROM TJE START\n// I ONLY COPIED THE FOV USED IN TheArtOfCodes Ray/Sphere intersection tutorial\n// and technique described in this super awesome video by\n// CodeParade https://www.youtube.com/watch?v=svLzmFuSBhk\n\n// \"i swear im trying so hard but my raytracers reflections were\n//  glitching and i couldnt figure out the phong lighting model ;(\"\n// - me before i made THIS\n\n// some help from\n// https://www.shadertoy.com/view/4dt3zn\n// https://www.youtube.com/watch?v=svLzmFuSBhk\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n\nconst int LightSourceT_point = 0;\nconst int LightSourceT_ray = 1;\n\nstruct LightSource {\n    int type; \n    vec3 p;\n    vec3 col;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nfloat SDF(vec3 p) {\n    float boxrad = 3.;\n    p = mod(p, boxrad)-boxrad/2.;\n    return sqrt(p.x*p.x/8.+p.y*p.y*2.+p.z*p.z/8.)-.5;\n    // return length(p)-1.5;\n    // return length(p-vec3(1, 1, 2))-1.;\n}\n\nvec3 reflekt(vec3 p) {\n    float inf = 1e-3;\n    return normalize(\n        vec3(\n            SDF(vec3(p.x+inf, p.y, p.z)),\n            SDF(vec3(p.x, p.y+inf, p.z)),\n            SDF(vec3(p.x, p.y, p.z+inf))\n        )-\n        vec3(SDF(p))\n    );\n}\n\nvec3 colour(vec3 p, LightSource[3] lights) {\n    vec3 light = vec3(0., 0., 0.);\n    for (int i=0; i<lights.length(); ++i) {\n        vec3 dir = vec3(0.);\n        if (lights[i].type == LightSourceT_point) {\n            dir = normalize(lights[i].p-p);\n        }\n        else if (lights[i].type == LightSourceT_ray) {\n        \tdir = normalize(lights[i].p);\n        }\n        light.x += dot(dir, reflekt(p))*lights[i].col.x;\n        light.y += dot(dir, reflekt(p))*lights[i].col.y;\n        light.z += dot(dir, reflekt(p))*lights[i].col.z;\n    }\n    light = clamp(light, 0., 1.);\n    return vec3(light);\n}\n\nvec3 march(Ray ray) {\n    LightSource[3] lights;\n    lights[0] = LightSource(LightSourceT_ray, normalize(vec3(1, 2, 0)), vec3(1., 0., 0.));\n    lights[1] = LightSource(LightSourceT_ray, normalize(vec3(2, 0, 0)), vec3(0., 1., 1.));\n    vec3 col = vec3(0.);\n    float rcount = 0.;\n    float rindex = .35;\n    float rmax = 6.;\n    int dmax = 108;\n    for (int i=0; i<dmax && rcount<rmax; ++i) {\n        float DE = SDF(ray.origin);\n        if (DE <= 1e-2) {\n            vec3 col2 = colour(ray.origin, lights);\n            if (rcount == rmax-1.) {\n                col2 = vec3(0., 0., 100./255.);\n            }\n            ray.direction = reflect(ray.direction, reflekt(ray.origin));\n        \tray.origin = ray.origin + ray.direction*1e-2;\n            if (true) {\n                float rindex2 = pow(rindex, rcount);\n                // col2 = vec3(0);\n                col = col*(1.-rindex2)+col2*rindex2;\n                // col = col2;\n\t\t\t}\n            ++rcount;\n        }\n        // if it diverges to far return te background color\n        if (i == dmax-1 && rcount > 0.) {\n            float rindex2 = pow(rindex, rcount);\n            vec3 col2 = vec3(0., 0., 100./255.);\n            col = col*(1.-rindex2)+col2*rindex2;\n        }\n        ray.origin = ray.origin + ray.direction*DE;\n    }\n    if (rcount > 0.) {\n        return col;\n    }\n    return vec3(0., 0., 100./255.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.x*2.;\n    vec3 dir = vec3(uv.x, uv.y, 1.);\n    float mag = sqrt(dir.z*dir.z+dir.x*dir.x);\n    float ang = atan(dir.z, dir.x)+(iMouse.x+150.-iResolution.x/2.)/90.;\n    dir = vec3(cos(ang)*mag, dir.y, sin(ang)*mag);\n    float pi = 3.1415926535897;\n    Ray ray = Ray(vec3(0.-(iTime+sin(iTime))/pi*2.*2., 0., 0.), normalize(dir));\n    \n    vec3 retina = march(ray);\n\n    // Output to screen\n    fragColor = vec4(retina, 1.0);\n}\n/**/", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tstXR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tstXRr", "name": "ShaderTober - Wild", "author": "Flopine", "description": "A small doodle with inktober's theme \"Wild\"", "tags": ["raymarching", "water", "inktober", "uvdistorsion"], "likes": 14, "viewed": 418, "date": "1571352859", "time_retrieved": "2024-06-20T19:46:55.680312", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 100.\n#define PI 3.141592\n#define t (iTime*2.*PI)\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.45,46.5)))*124.5);}\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat prim (vec3 p)\n{\n    p.xz *= rot(sin(p.y*2.)+iTime);\n  \tmoda(p.xz, 5.);\n    p.x -= .18;\n   \treturn cyl(p.xzy, 0.1, 1e10);\n}\n\nfloat g1 = 0.;\nfloat eel (vec3 p)\n{\n    p.x = abs(p.x)-2.;\n    p.z -= t;\n    p.x -= sin(p.z+t);\n    p.y += cos(p.z+t);\n    float d = cyl(p, 0.2+sin(p.z*5.)*0.1, 1.);\n    g1 += 0.1/(0.1+d*d);\n    return d; \n}\n\nfloat grid (vec3 p)\n{\n    float per = 4.;\n    p = mod(p,per)-per*0.5;\n    \n    float p1 = prim(p);\n    p.xy*=rot(PI/2.);  \n    float p2 = prim(p);\n    p.yz *= rot(PI/2.);\n    return min(min(p1,p2),prim (p));\n}\n\nfloat SDF (vec3 p)\n{return min(grid(p),eel(p));}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    uv += texNoise(texNoise(uv*0.5+iTime*0.2).rg*0.2).rg*0.7;\n    \n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(4.,1.4,-4.+t),\n        p = ro,\n        tar = vec3(0.,-.5,t ),\n        rd = getcam(ro, tar,uv),\n        col = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i =0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.5+dither*0.2;\n        p += d*rd;\n    }\n\n    float ad = length(ro-p);\n    \n    col = vec3(shad)*0.8;\n\tcol += g1 * vec3(0.2,0.7,0.8+p.x*0.5)*0.4;\n    \n    col = mix(col, vec3(0.,0.15,0.35), 1.-exp(-0.008*ad*ad));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tstXRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsV3Dc", "name": "Sierpinski zoom", "author": "id523", "description": "A constant zoom into a Sierpinski triangle, with trilinear filtering.", "tags": ["fractal", "triangle", "zoom", "sierpinski"], "likes": 3, "viewed": 352, "date": "1571141738", "time_retrieved": "2024-06-20T19:46:55.680312", "image_code": "float texXY(int x, int y) {\n    return x >= 0 && y >= 0 && (x & y) == 0 ? 1.0 : 0.0;\n}\n\nfloat texY(float x, int y) {\n    x -= 0.5 * float(y);\n    float texX1 = texXY(int(floor(x)), y);\n    float texX2 = texXY(int(floor(x)) + 1, y);\n    return mix(texX1, texX2, fract(x));\n}\n\nfloat tex(vec2 pos) {\n    float texY1 = texY(pos.x, int(pos.y));\n    float texY2 = texY(pos.x, int(pos.y) + 1);\n    return mix(texY1, texY2, fract(pos.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime * 0.35);\n    \n    float zoom = pow(2.0, t);\n    \n    fragCoord *= 0.8 / zoom;\n    fragCoord.x *= 0.8660254;\n    \n    float texM = mix(tex(fragCoord), tex(fragCoord * 2.0), zoom - 1.0);\n    fragColor = vec4(texM, texM, texM, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsV3Dc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsV3Dh", "name": "Sky Formations", "author": "ailanthus", "description": "Clouds generated with noise distorted by more noise and raymarched with a very basic lighting  approximation with two light sources.", "tags": ["raymarching", "clouds", "cloud", "sky", "formations"], "likes": 4, "viewed": 131, "date": "1570220694", "time_retrieved": "2024-06-20T19:46:57.044173", "image_code": "// derivative noise by iq. https://www.shadertoy.com/view/4dffRH\n\nvec3 hash( vec3 p ) // i'm supposed to replace this with something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns 3D value noise (in .x)  and its derivatives (in .yzw)\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    float v = va + \n              u.x*(vb-va) + \n              u.y*(vc-va) + \n              u.z*(ve-va) + \n              u.x*u.y*(va-vb-vc+vd) + \n              u.y*u.z*(va-vc-ve+vg) + \n              u.z*u.x*(va-vb-ve+vf) + \n              u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n              \n    vec3 d = ga + \n             u.x*(gb-ga) + \n             u.y*(gc-ga) + \n             u.z*(ge-ga) + \n             u.x*u.y*(ga-gb-gc+gd) + \n             u.y*u.z*(ga-gc-ge+gg) + \n             u.z*u.x*(ga-gb-ge+gf) + \n             u.x*u.y*u.z*(-ga+gb+gc-gd+ge-gf-gg+gh) +   \n             \n             du * (vec3(vb-va,vc-va,ve-va) + \n                   u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + \n                   u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + \n                   u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) );\n                   \n    return vec4( v, d );                   \n}\n\nvec4 recursive_noise(vec3 p, float octaves){\n    vec4 n = vec4(0.);\n    for (float i = 0.; i < octaves; i += 1.){\n        float e = pow(2., i);\n        vec3 mini_pos = p*e;\n        //mini_pos.w *= e; // Smaller is noisier\n        n += noised(mini_pos)/e;\n    }\n    return n/2.;\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 2.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.2; // cutoff for clouds\n\nconst vec3 LIGHT_1 = vec3(0, 1, 0);\nconst vec3 LIGHT_2 = normalize(vec3(10, 3, -10)); // backlight\n\n//const vec3 LIGHT_1 = LIGHT_2;\n\n\nfloat sphere(vec3 samplePoint, float radius) {\n    return clamp(-length(samplePoint) + radius, 0., 1.);\n}\n\n\nfloat spheres(vec3 p){\n\tvec3 side = vec3(3, 0, 1);\n    //samplePoint.z += 1.;\n    return sphere(p, 2.) + sphere(p+side, 1.) + sphere(p-side, 1.);\n}\n\n\nvec4 sceneDeriv(vec3 voxel) {\n    //return spheres(voxel);\n    float scale = 3.; // larger noise\n    float p_scale = .5;\n    //vec4 p_noise = noised(voxel/8.-iTime); // perterbation noise, using derivative\n    \n    // Recursive displacement on normal noise\n    //vec4 p_noise = recursive_noise(voxel/p_scale-iTime/32., 8.);\n    \n    // move\n    voxel.xyz -= iTime/8.;\n    // change\n    float change = iTime/1.;\n    vec4 p_noise = noised(voxel*vec3(.5, 1, 1)-change/16.)/4.;\n    p_noise += noised(voxel*vec3(1, 2, 2) -change/4.)/4.;\n    p_noise += noised(-voxel*vec3(6, 6, 6)+change)/16.;\n    //vec4 noise = recursive_noise(voxel/scale + p_noise.yzw/4.1, 8.);\n    vec4 noise = noised(voxel/scale + p_noise.yzw);\n    \n\t//vec4 noise = recursive_noise(voxel*scale, 8.);\n    //vec4 noise = recursive_noise(vec3(voxel.x, voxel.y, voxel.z-iTime/(scale)), 8.);\n    noise.x = (0., (noise.x - EPSILON)/(1.-noise.x)); // cut off below epsilon and respread\n    return noise;\n    // we have no use for negative noise values, unless we want them as bad distance estimates\n}\n\nfloat scene(vec3 voxel){\n    //return spheres(voxel);\n\treturn sceneDeriv(voxel).x;\n}\n\n// Returns the extent to which a cloud bit is in \"shadow\"\n// Assuming a relative to the normalized light direction\nfloat getShadow(vec3 point, vec3 lightDirection, float end){\n    float step_length = .05;\n    float dist = 0.; // distance to edge of cloud in light direction\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        dist += step_length;\n        float new_point = scene(point + dist * lightDirection);\n        if (new_point < EPSILON) {\n            return dist;\n        }\n        dist += step_length;\n        if (dist >= end) {\n            return dist;\n        }\n    }\n    return dist;\n}\n\n// Check one point, shadow is relative change\n// Pick an arbitrary lightward neighbor\n// Shadow is density of neighbor + difference in densities\nfloat fastShadow(vec3 point, vec3 lightDirection){\n    float dist = .2; // distance to edge of cloud in light direction\n    float density = scene(point);\n    float neighbor = scene(point + dist * lightDirection);\n    //float volume_difference = scene(point + dist * lightDirection) - density;\n    // If volume_difference is negative (lighter), no shadow\n    float shadow = clamp((neighbor*4.-density*1.)*1.+.1, 0., 1.);\n    // effectively mixing difference (rough approximation of derivative)\n    // with neighbor density\n    return shadow;\n}\n    \nfloat sampleShadow(vec3 point, vec3 lightDirection){\n    float dist = 0.0; // distance to edge of cloud in light direction\n    float density = scene(point);\n    float shadow = 0.;\n    for (int i = 0; i < 3; i++) {\n        dist += 0.1;\n        float neighbor = scene(point + dist * lightDirection);\n        shadow += neighbor;\n        shadow -= density/2.; // this makes trends matter.\n        // in liight density, it will still be dark if neighbors are darker.\n    }\n    //float volume_difference = scene(point + dist * lightDirection) - density;\n    // If volume_difference is negative (lighter), no shadow\n    shadow = clamp(shadow, 0., 1.);\n\n    return shadow;\n}\n\n// Blends colors moving forward using alpha channels.\nvec4 composite(vec4 foreground, vec4 background){\n    float f_alpha = foreground.w;\n    float b_alpha = background.w * (1.-f_alpha);\n    vec3 color = foreground.xyz + background.xyz * b_alpha;\n\t//alpha = 1.-(1.-alpha)*(1.-background.w);\n\tfloat new_alpha = f_alpha + b_alpha;\n\treturn vec4(color, new_alpha);\n}\n\nvec4 shootRay(vec3 eye, vec3 marchingDirection, float start, float end) {\n    vec4 color = vec4(0); // start transparent\n    float depth = start;\n    float volume = 0.;\n    float max_shaded = 2.;\n    float step_length = .05;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        // Distance according to SDF\n        vec3 point = eye + depth * marchingDirection;\n        float density = scene(point);\n        // float travel = dist;\n        float travel = step_length;\n        if (density > 0.) {\n            float max_density = .5;\n            // put a cap on density variance. \n            // clouds can still have irregular translucent edges, but no weird opaque cores.\n            density = min(density, max_density)/(1.-max_density);\n            float skyFade = 1.-(depth/end); // further away becomes fainter\n            //float light = (max_shaded-getShadow(point, vec3(0, 1, 0), max_shaded))/max_shaded;\n\t\t\tfloat opacity = density * .1 + .0;\n            //float opacity = .1;\n            vec3 light = vec3((1.-fastShadow(point, LIGHT_1)));\n            vec3 light2 = vec3((1.-fastShadow(point, LIGHT_2)));\n            //vec3 light = vec3((1.-sampleShadow(point, LIGHT_1)));\n            //vec3 light2 = vec3((1.-sampleShadow(point, LIGHT_2)));\n            light *= vec3(.2, .3, .6)* 2.;\n            light2 *= vec3(.4, .2, .1)* 2.;\n            vec4 backColor = vec4(light+light2, opacity);\n\t\t\t//backColor.b = skyFade;\n            color = composite(color, backColor);\n            //color = composite(backColor, color);\n            //volume += .1 * step_length;\n            //volume += step_length * density * light;\n            //volume += ()\n            //volume += step_length * density;\n           \t//travel = .05;\n        }\n        //else{ travel = dist;}\n        depth += travel;\n        if (depth >= end) {\n            return color;\n        }\n    }\n    return color;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(85.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    vec4 color = shootRay(eye, dir, MIN_DIST, MAX_DIST);\n    //volume = clamp(volume, 0., 1.);\n    // volume *= .2;\n    float height = fragCoord.y/iResolution.y;\n    vec4 skyColor = vec4(.9-height*.6, .86-height*.4, .75-height*.15, 1);\n    skyColor = composite(color, skyColor);\n    \n    // gama correction. i.e. converting from light amount to screen/eye colorspace.\n    skyColor.rgb = pow( skyColor.rgb, vec3(1.0/2.2) );\n    fragColor = skyColor;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsV3Dh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsV3DV", "name": "Raytracer (WIP)", "author": "cmarangu", "description": "idk what multipass is exactly but i think this is a multipass for me? anywast since glsl doesnt freaking support recursion so i may develop my first raytracer on another platform instead", "tags": ["raytracing", "reflections"], "likes": 3, "viewed": 104, "date": "1571026877", "time_retrieved": "2024-06-20T19:46:58.080638", "image_code": "// /*\n// Old code for: \"Raytracer (WIP)\"\n// Created: 2019 10/14 (before then)\n// Tags: raytracing, reflections\n// Description: idk what multipass is exactly but i think this is a multipass for me?\n// anywast since glsl doesnt freaking support recursion so i may develop my first raytracer on\n// another platform instead\n\n// C010011012 (@cmarangu)'s 1st raytracer :D\n// Started 2019 9/26\n// Original attempt 2019 7/21\n// or was it 7/3\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray2 {\n    bool exists;\n    vec3 color;\n    Ray ray;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nstruct Plane {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material {\n\tfloat lighting;\n    float reflectionIndex;\n};\n\nconst Ray noRay = Ray(vec3(0), vec3(0));\nconst vec3 noColor = vec3(0);\n\nconst vec3 sun = vec3(0, 2, 0);\n\n// vec3 plan2(Ray ray, Plane plan\n\nRay2 inter_ray_plane(Ray ray, Plane plan) {\n    // https://www.scratchapixel.com/\n    float denom = dot(plan.direction, ray.direction);\n    if (denom > 1e-6) {\n        vec3 p010 = normalize(plan.origin-ray.origin);\n    \tfloat t = dot(p010, plan.direction)/denom;\n    \tvec3 p = ray.origin+ray.direction*t;\n        // if (t < 0.) {\n        \t// float a = mod(p.x, 1.);\n        \t// float b = mod(p.z, 1.);\n        \t// vec3 col = vec3(min(a, b), a, max(a, b));\n        \t// checkerboard texture knowledge from\n        \t// http://web.cse.ohio-state.edu/~shen.94/681/Site/Slides_files/texture.pdf\n        \tvec3 col = vec3(mod(\n                floor(p.x*2.)+\n                floor(p.z*2.),\n            2.));\n            return Ray2(\n                true,\n                col,\n                Ray(p, reflect(ray.direction, plan.direction))\n            );\n        // }\n\t}\n    return Ray2(false, noColor, noRay);\n}\n\nRay2 inter_ray_sph(Ray ray, Sphere sph) {\n    // Much help from TheArtOfCode\n    // https://www.youtube.com/watch?v=HFPlKQGChpE\n    // t is the closest point on the ray to the center\n    // of the sphere (unless im mistaken)\n    float t = dot(sph.center-ray.origin, ray.direction);\n    // no t is the coefficient of rd to get that point\n    // p is the point on the ray closest to the center\n    // of the sphere\n    vec3 p = ray.origin+ray.direction*t;\n    // pi_0 and pi_1 have nothing to do with any circle\n    // constant. they are the initial point of intersection\n    // and secondary point of intersection of the ray with\n    // the sphere respectively\n    float y = length(p-sph.center);\n    if (t > 0.) {\n        if (y < sph.radius) {\n            float x = sqrt(sph.radius*sph.radius-y*y);\n            vec3 pi_0 = ray.origin+ray.direction*(t-x);\n            vec3 pi_1 = ray.origin+ray.direction*(t+x);\n            Plane plan_r = Plane(pi_0, normalize(pi_0-sph.center) );\n            vec3 col = vec3(.2, 0., 0.);\n            // col = vec3(0., 1., 200./255.);\n            vec3 r = reflect(ray.direction, plan_r.direction);\n            float spec = abs(dot(r, r))/5.;\n            col = (col+vec3(spec))/2.;\n            return Ray2(\n                true,\n                col,\n                Ray(pi_0, reflect(ray.direction, plan_r.direction))\n            );\n    \t}\n    }\n    return Ray2(false, noColor, noRay);\n}\n\nint closer(Ray ray, Ray2 obj1, Ray2 obj2) {\n    if (obj1.exists) {\n        if (obj2.exists) {\n            if (length(obj2.ray.origin-ray.origin) < length(obj1.ray.origin-ray.origin)) {\n                return 2;\n            }\n            else {\n                return 1;\n            }\n        }\n        else {\n            return 1;\n        }\n    }\n    else if (obj2.exists) {\n        return 2;\n    }\n    else {\n        return 0;\n    }\n}\n\nvec3 CAST2(Ray ray) {\n    Sphere sph = Sphere(vec3(0., -.0, 2.+2.+2.*sin(iTime)), 1.);\n    Plane plan = Plane(vec3(0., 1., 0.), normalize(vec3(0., -1., 0.)) );\n    \n    Ray2 r2s = inter_ray_sph(ray, sph);\n    Ray2 r2p = inter_ray_plane(ray, plan);\n    \n    int r2_ = closer(ray, r2p, r2s);\n    \n    if (r2_ == 2) {\n        // return (r2s.color*3.+CAST2(r2s.ray)*2.)/5.;\n        return r2s.color;\n    }\n    else if (r2_ == 1) {\n        // return (r2p.color*3.+CAST2(r2p.ray)*2.)/5.;\n        return r2p.color;\n    }\n    else {\n    \treturn vec3(0., 0., 100./255.);\n    }\n    \n    \n}\n\nvec3 CAST(Ray ray) {\n    Sphere sph = Sphere(vec3(0., -.0, 2.+2.+2.*sin(iTime)), 1.);\n    Plane plan = Plane(vec3(0., 1., 0.), normalize(vec3(0., -1., 0.)) );\n    \n    Ray2 r2s = inter_ray_sph(ray, sph);\n    Ray2 r2p = inter_ray_plane(ray, plan);\n    \n    int r2_ = closer(ray, r2p, r2s);\n    \n    if (r2_ == 2) {\n        return (r2s.color*3.+CAST2(r2s.ray)*2.)/5.;\n        // return r2s.color;\n    }\n    else if (r2_ == 1) {\n        return (r2p.color*3.+CAST2(r2p.ray)*2.)/5.;\n        // return r2p.color;\n    }\n    else {\n    \treturn vec3(0., 0., 100./255.);\n    }\n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.x*2.*1.2;\n    vec3 dir = vec3(uv.x, uv.y, 1.);\n    float mag = sqrt(dir.x*dir.x+dir.z*dir.z);\n    float ang = atan(dir.z, dir.x)+(iMouse.x-iResolution.x/2.)/180.;\n    dir = vec3(cos(ang)*mag, dir.y, sin(ang)*mag);\n    Ray RAY = Ray(vec3(0., 0., 0.), normalize(dir));\n    \n    /// OH MI GOSH I CASTED A RAY I DID IT THE\n     // / /// WORLD OF 3D GRAPHICS IS MIIIINE!!!!!\n    // and then theres recursive ray casts :D\n    vec3 retina = CAST(RAY);\n\n    // Output to screen\n    fragColor = vec4(retina, 1.0);\n}\n/**/\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4sfGRr", "previewfilepath": "/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsV3DV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsV3Dz", "name": "Function plot (dist estimation)", "author": "nurof3n", "description": "A dumb function plotter that uses shaders and has no purpose whatsoever.\nAnd also some built in noise functions.", "tags": ["noise", "graph", "function", "plotting"], "likes": 6, "viewed": 165, "date": "1571231597", "time_retrieved": "2024-06-20T19:46:58.571582", "image_code": "/*\n\tDistance estimation algorithm\n\thttp://iquilezles.org/www/articles/distance/distance.htm\n*/\n#define PI 3.14159265359\n#define random(x) (fract(sin(x) * 43758.545))\n#define smoothsaw(x) (smoothstep(0.0, 1.0, fract(x)))\n#define steprandom(x) (random(floor(x)))\n#define randomsaw(x) (smoothsaw(x) * steprandom(x))\n#define noise(x) (randomsaw(x) - randomsaw(x - 1.) + steprandom(x - 1.))\n#define fractalnoise(x) (noise((x)) + .5*noise((x)/.5) + .25*noise((x)/.25) + .125*noise((x)/.125) + .0625*noise((x)/.0625))\nvec2 c;\n#define rectangle(center, size, uv) (c = 1.-step(size, abs(uv - center)), c.x * c.y)\n\n#define f(x) (sin( (x) * cos(x) ) * cos(iTime + (x)))\n#define g(x) (sin( ((x) * 3.) * cos(iTime) * sin(x) ))\nfloat f2(vec2 x) {\n    float r = length(x);\n    float a = atan(x.y,x.x);\n    return r - 1.0 + 0.5*sin(3.0*a+2.0*r*r);\n}     \n\nconst vec2 h = vec2(0.001, 0.0);\t//set this with less precision if lines are weird\n//analytical gradient, needs to be written for any particular function\n#define grad1(x) (vec2(1.0, cos(x)*sin(x*x) + 2.0*x*cos(x*x)*sin(x)))\n#define grad2(x, func) (vec2(1.0, (func(x+h) - func(x-h)) / (2.0*h)))\n#define grad2d(uv, func) (vec2( func(uv+h.xy) - func(uv-h.xy), func(uv+h.yx) - func(uv-h.yx) ) / (2.0*h.x))\n#define sdf(uv, g, func) ((func(uv.x) - uv.y) / length(g))\n#define sdf2d(uv, g, func) ((func(uv)) / length(g))\n\nfloat scale = 6.;\nfloat eps;\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nvec2 shake(vec2 uv) {\n\treturn vec2(uv.x + (fractalnoise(iTime * 10.) - 1.) * 2., uv.y + (fractalnoise(iTime*10. + 1.) - 1.) * 2.);\n}                           \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //https://www.shadertoy.com/view/lsXGzf\n    //scale += 5.0*texelFetch( iChannel0, ivec2(KEY_UP,2),0 ).x;\n    //scale -= 4.0*texelFetch( iChannel0, ivec2(KEY_DOWN,2),0 ).x;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.y;\n    mouse = (mouse == vec2(.0) ? vec2(aspect, 1.) / 2. : mouse);\t//for initialization\n    vec2 uv = fragCoord/iResolution.y;\n    eps = scale / iResolution.y; \t//pixel size, for constant thickness independent of resolution\n    \n    mouse -= vec2(aspect/2., .5);\n    uv -= vec2(aspect/2., .5);\n    uv *= scale;\n    mouse *= scale;\n    uv -= mouse;\n    \n    //dont uncomment this\n    //uv = shake(uv);\n    \n    vec2 rotuv = rotate2d(5.*sin(iTime / 2.) * PI) * uv;\n    \n    vec2 g1 = grad2(uv, f);\n    vec2 g2 = grad2(uv.x, g);\n    float de = sdf(uv, g1, f);\n    float de2 = sdf(uv, g2, g);\n    \n    vec3 color, color2;\n    color = mix(vec3(175.0,238.0,238.0)/255.0, \n                mix(vec3(.0), vec3(.9, .97, .8), (1. - smoothstep(-2.*eps, .0, de)) ),\n                1. - smoothstep(.0, 2.*eps, de));\n    color2 = mix(vec3(175.0,238.0,238.0)/255.0, \n                mix(vec3(.0), vec3(.9, .97, .8), (1. - smoothstep(-2.*eps, .0, de2)) ),\n                1. - smoothstep(.0, 2.*eps, de2));\n    color = min(color, color2);  \n    \n    //axes\n    color = mix(color, color * vec3(.1, .5, .6), smoothstep(-eps, 0., uv.x) - smoothstep(0., eps, uv.x));\t\n    color = mix(color, color * vec3(.1, .5, .6), smoothstep(-eps, 0., uv.y) - smoothstep(0., eps, uv.y));\n    \n    //ruler\n    if(abs(uv.x) > 8. * eps || abs(uv.y) > 8. * eps) {    //dont draw in the origin\n        color = mix(color, color * vec3(.1, .5, .6), rectangle(vec2(.0, round(uv.y)), vec2(5.*eps, eps), uv));\n        color = mix(color, color * vec3(.1, .5, .6), rectangle(vec2(round(uv.x), .0), vec2(eps, 5.*eps), uv));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsV3Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsV3Wd", "name": "Shadertober 14 - Overgrown", "author": "BackwardsCap", "description": "Growing vines", "tags": ["inktober", "shadertober", "overgrown", "backwardscaptain"], "likes": 3, "viewed": 257, "date": "1571262606", "time_retrieved": "2024-06-20T19:46:59.026163", "image_code": "#define MAX_DIST 100.\n#define T iTime/5.\n#define PI 3.1415927\n\nfloat cyl(vec3 p, vec3 d)\n{\n    return length(p.xz-d.xy)-d.z;\n}\n\nfloat vine(vec3 p, float r)\n{\n    return cyl(p+vec3(cos(p.y+r),0.,sin(p.y+r)),vec3(1.,1.,.5*cos(clamp(T-p.y/5.+1.,-2.,0.))));\n}\n\nvec2 map(vec3 p)\n{\n    vec3 cell = vec3(18.);\n    p.xz = mod(p.xz,cell.xz)-cell.xz/2.;\n    \n    float m=0.;\n    float c = cyl(p,vec3(1,1,1));\n    \n    float v1 = vine(p,0.);\n    float v2 = vine(p,PI*.5);\n    float v3 = vine(p,PI);\n    float v4 = vine(p,PI*1.5);\n        \n    float r=min(c,v1);\n    r=min(r,v2);\n    r=min(r,v3);\n    r=min(r,v4);\n    if(r==c)m=2.;\n    else m=1.;\n    return vec2(r,m);\n    \n}\n\nvec2 ray(vec3 ro, vec3 rd)\n{\n    float m=0.,t=0.;\n    for(int i=0;i<128;i++)\n    {\n        vec3 p = ro+rd*t;\n        vec2 s = map(p);\n        m=s.y;\n        if(s.x<0.00001)break;\n        t+=s.x/3.;\n        if(t>MAX_DIST){t=-1.; break;}\n    }\n    return vec2(t,m);\n}\n\n\nvec3 normal(vec3 p)\n{\n    vec2 e=vec2(0.0005,0.);\n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        ));\n}\n\nvoid mainImage( out vec4 c, in vec2 f)\n{\n    vec2 p = (2.*f-iResolution.xy)/iResolution.y;\n\n    float h = T*5.+6.;\n    vec3 ro = vec3(0.1,h-1.9,0);\n    vec3 ta = vec3(0,h-1.83,0);\n    vec3 cf = normalize(ta-ro);\n    vec3 cu = normalize(cross(cf,vec3(0,1,0)));\n    vec3 cr = normalize(cross(cu,cf));\n    vec3 rd = vec3(p.x*cu+p.y*cr+1.*cf);\n\n    vec2 r = ray(ro,rd);\n    \n    vec3 col =vec3(0.);\n    if(r.x>0.)\n    {\n        vec3 p = ro+rd*r.x;\n        vec3 n = normal(p);\n        \n        vec3 mate = vec3(1.0);\n        vec2 az=vec2(atan(p.y,p.x),length(p));\n        if(r.y<1.5)mate=vec3(0,1,0)+texture(iChannel1,vec2(az.y,p.x)).rgb/3.;\n        else if (r.y<2.5)mate=vec3(1,0.5,.4)+texture(iChannel0,vec2(abs(az.y),(-.6+p.x))).rgb;\n        \n        vec3 sun = normalize(vec3(3.,0.3,1.));\n        float dif = clamp(dot(sun,n),0.0,1.0);        \n        col = mate*vec3(0.2,0.4,0.5)*dif*(1.-r.x/MAX_DIST);\n    }\n    \n    c.rgb=col;\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsV3Wd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsVGD3", "name": "PLOTus", "author": "foran", "description": "PLOTus", "tags": ["plotus"], "likes": 2, "viewed": 67, "date": "1571119287", "time_retrieved": "2024-06-20T19:46:59.026163", "image_code": "\n#define PI 3.141592654\nvec3 draw_center(vec2 coord)\n{\n    float l = length(coord);\n    float i_l = smoothstep(max(0.0, 0.101), 0.0, l);\n    vec3 baseColor = vec3(1.0,1.0,0.0);\n    baseColor=mix(baseColor,baseColor.zxy,smoothstep(-0.4,0.94,sin(iTime*0.4)));\n    baseColor*=i_l * i_l;\n    return baseColor;\n}\nvec3 noise(vec2 uv)\n{\n    // float pTime = floor(2.0*iTime);\n    float fre=.520*PI;\n    float pTime = iTime;\n    float n_1 = sin(uv.x + pTime) * fre;\n    float n_2 = sin(n_1 + uv.y + pTime) * fre;\n    float n_3 = sin(n_1*uv.x+n_2*uv.y+n_2+n_1)*fre;\n    float n_4 = sin(n_2*uv.x+n_3*uv.y+n_2+n_3)*fre;\n    return vec3(sin(n_4), cos(n_4),sin(n_3+n_4));\n}\nvec3 draw_particles(vec2 uv, vec2 coord)\n{\n    float r=sign(coord.x)*atan(coord.y/coord.x);\n    float dis=length(coord);\n    float mag= max(0.0,1.0+coord.y*80.5)*pow(max(1.0*sin((r-dis*PI*1.0)*20.0),0.0),3.0);\n    vec3 noi=noise(coord);\n    vec2 dir=normalize(coord)*mag+(1.-mag)*noi.xz;\n    \n    vec3 baseColor=vec3(0.);\n    if(dis>0.003)\n    {\n        float stride=0.1006;\n        baseColor+=texture(iChannel0,uv-stride*dir).xyz;\n        baseColor*=0.9975;\n    }\n    return baseColor;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float f = iResolution.x / iResolution.y;\n    vec2 coord = uv - vec2(0.5,0.3);\n    coord.x *= f;\n    vec3 color1 = draw_center(coord);\n    vec3 color2 = draw_particles(uv, coord);\n\n    vec3 t_color = color1 + color2;\n    // t_color=texture2D(iChannel0,uv).xyz;\n    vec3 preColor = texture(iChannel0, uv).xyz;\n    t_color=mix(t_color,preColor.xyz,0.1);\n    fragColor = vec4(t_color, 1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsVGD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsVGzt", "name": "Tiled Distance Pattern", "author": "Simplyfire", "description": "distance from center of tile plugged into fbm", "tags": ["noise", "fbm", "distance", "pattern", "tiles"], "likes": 12, "viewed": 388, "date": "1570788789", "time_retrieved": "2024-06-20T19:46:59.911055", "image_code": "\nuniform sampler2D texture;\nuniform vec2 resolution;\nuniform float time;\n\n#define pi 3.14159265359\n\nvec3 rgb(float h, float s, float b){\n    vec3 c = vec3(h, s, b);\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0, 4.0, 2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat map(float value, float start1, float stop1, float start2, float stop2){\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat norm(float value, float start, float stop){\n    return map(value, start, stop, 0., 1.);\n}\n\n//\tSimplex 4D Noise\n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 grad4(float j, vec4 ip){\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\nfloat snoise(vec4 v){\n    const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n    0.309016994374947451); // (sqrt(5) - 1)/4   F4\n    // First corner\n    vec4 i  = floor(v + dot(v, C.yyyy) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C\n    vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n    vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n    vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n    vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n    // Permutations\n    i = mod(i, 289.0);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n    i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n    + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n    + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n    + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n    // Gradients\n    // ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n    + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nfloat fbm(vec4 p){\n    float amp = 1.;\n    float frq = 1.;\n    float sum = 0.;\n\n    for (int i = 0; i < 5; i++){\n        sum += amp*snoise(p*frq);\n        amp *= .5;\n        frq *= 2.;\n    }\n    return sum;\n}\n\nfloat fbm(float x){\n    return fbm(vec4(x, 0., 0., 0.));\n}\n\nfloat fbm(float x, float y){\n    return fbm(vec4(x, y, 0., 0.));\n}\n\nfloat fbm(float x, float y, float z){\n    return fbm(vec4(x, y, z, 0.));\n}\n\nfloat fbm(float x, float y, float z, float w){\n    return fbm(vec4(x, y, z, w));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    float timeRadius = 0.15;\n    vec2 timeOrigin = vec2(5, 1);\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 originalUV = uv.xy;\n//    uv = fract(uv*5.)-.5;\n    uv = fract(uv*5.)-.5;\n    uv *= 30.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv)+.5;\n    float distanceFromTileCenter = length(id*30.);\n    float distanceFromOriginalCenter = length(originalUV*.2);\n    float rawNoise = fbm(\n        distanceFromTileCenter, distanceFromOriginalCenter,\n        timeOrigin.x+timeRadius*cos(t), timeOrigin.y+timeRadius*sin(t)\n    );\n    float smoothNoise = smoothstep(-0.5,1.5,rawNoise);\n    float fadeToBlack = smoothstep(0.0, 1.1, length(originalUV));\n    float hueStart = .5;\n    float hueRange = 0.75;\n    vec3 color = rgb(\n        hueStart+hueRange*smoothNoise,\n        1.-smoothNoise,\n        clamp(pow(smoothNoise, 0.4), 0., 1.)\n    );\n    fragColor = vec4(color-fadeToBlack, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsVGzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsXSWS", "name": "Field of Diamonds", "author": "jrkirby", "description": "An exploration of figure and ground on a hexagonal tiled plane", "tags": ["hexagon", "loop", "tiling"], "likes": 4, "viewed": 343, "date": "1571087423", "time_retrieved": "2024-06-20T19:46:59.917546", "image_code": "\nvec2 rotate(vec2 v, float angle) {\n    angle = angle * 3.1415;\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat invert(float inUV) {\n    inUV = min(1., max(0., inUV));\n\treturn 1.-inUV;\n}\n\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1,1.73205080757)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\nvec4 HexCoords(vec2 uv) {\n\tvec2 r = vec2(1, 1.73205080757);\n    vec2 h = r*.5;\n    \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    \n    vec2 gv = dot(a, a) <= dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = floor(uv-gv + vec2(.00001, .00001));\n    return vec4(x, y, id.x,id.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat stepTime = floor(iTime);\n    float sawTime = mod(stepTime, 2.0);\n    float halfSawTime = mod(floor(iTime/2.), 2.);\n    float sawTimeInv = 1.- sawTime;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv = rotate(uv, 4. *floor(stepTime/2.)/6.);\n\n    vec3 col = vec3(0);\n    \n    uv *= 4.;\n    \n    vec2 motionDir = vec2(-1./2.,1.73205080757/2.);\n    \n    float hexmotion = iTime;\n    vec2 uvSten = uv;\n    uvSten = rotate(uvSten, 2./3.);\n    uvSten = mod(floor(uvSten/.86602540378), 2.0);\n    \n    \n    vec4 hc1 = HexCoords(uv);\n    vec4 hc2 = HexCoords(uv+(motionDir * hexmotion));\n    vec4 hc3 = HexCoords(uv+(motionDir * -hexmotion));\n    vec4 hc4 = mix(hc2, hc3, uvSten.y);\n    \n    vec4 hc = mix(hc1, hc4, sawTimeInv);\n    \n    float rotUV = ((hc.x/3.1415) + 1.) /2.;\n    float rotTime = (mod(iTime, 1.0) /3.) + 1./3.;\n    \n    float c1 = step(rotUV, 1./3.);\n    float c2 = step(rotUV, rotTime);\n    float c = mix(c1, c2, sawTime);\n    float r = invert(c);\n    c = mix(c, r, halfSawTime);\n    \n    col = vec3(c);\n    \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsXSWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsy3Wh", "name": "Ghost sphere", "author": "izo", "description": "Another go on the old sphere raytrace, this time distorting the sphere \"surface\" with some sine waves.", "tags": ["sphere", "raytrace", "sine", "spheredistortion"], "likes": 1, "viewed": 313, "date": "1570061645", "time_retrieved": "2024-06-20T19:47:00.153444", "image_code": "#define radius_static .06 \n#define BGB true\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy; //Center on screen (-.5 to .5)\n\tuv.x = uv.x * (iResolution.x/iResolution.y); //Adjust x cord for aspect ratio\n\n\t\n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec3 s = vec3(sin(iTime)/6.,0, .3 - cos(iTime)/8.);\n    \n    float t = dot(s-ro, rd);\n    \n    vec3 p = ro + rd*t;\n    \n    float y = length(p-s);\n    \n    float radius_distort = (sin((fragCoord.y)/6.+iTime)+cos((fragCoord.x)/6.+iTime))/600.; \n    // float radius_distort = sin((fragCoord.x*fragCoord.y)/4000.+iTime)/500.; // Liner\n    \n    float radius = radius_static + radius_distort;\n    \n    float x = sqrt(radius*radius - y*y);\n    \n    float t1 = x + t;\n    \n    float t2 = x - t;\n    \n    float dist = length(ro +rd*t1);\n    \n    float blink_bg = BGB ? abs(sin(iTime)) : 1.;\n   \n    //vec3 ballcolor = vec3(1, 0, 0);\n    vec3 ballcolor = vec3(float((int(fragCoord.x)*2)^(int(fragCoord.y)*2))/((iResolution.x*iResolution.y)/300.),.2,0); // Transparent\n    \n  \tvec3 col = y > radius ? vec3(0,0,float(int(fragCoord.x)^int(fragCoord.y))/((iResolution.x*iResolution.y)/300./blink_bg) ) : //Generate background\n    \tmix(vec3(x*20. - dist), ballcolor, .4);//\"Raytraced\" ball\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsy3Wh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsy3zc", "name": "ShaderTober - Husky", "author": "Flopine", "description": "A small doodle with inktober's theme \"Husky\". He can follow your mouse, try it! :) ", "tags": ["2d", "mouse", "interaction", "inktober", "husky"], "likes": 8, "viewed": 124, "date": "1570643488", "time_retrieved": "2024-06-20T19:47:00.723124", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n#define anim (2.*(iMouse.xy/iResolution.xy)-1.)\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat xor (float a, float b)\n{return (1.-a)*b + (1.-b)*a;}\n\nfloat head (vec2 uv)\n{\n    uv.y +=0.2;\n    float c = step(length(uv), 1.8);\n    float uux = abs(uv.x)-0.5, uuy = uv.y;\n    uuy -= .5+sin(uux*PI)*0.5;\n    vec2 uu = vec2(uux,uuy);\n    \n    return xor(step(uu.y, -0.2),c)*c;\n}\n\nfloat ear (vec2 uv)\n{\t\n    uv.x = abs(uv.x)-0.2;\n    uv.x += sin(uv.y*1.5+PI);\n    return step(uv.x + uv.y,0.2) * step(-0.4,uv.y);\n}\n\nfloat ears (vec2 uv)\n{\n    uv.y -= 0.75;\n    uv.x = abs(uv.x) -1.7;\n    uv *= rot(-PI/4.);\n    uv *= rot(sin(iTime)*0.2);\n    return ear(uv);\n}\n\nfloat face (vec2 uv)\n{\n\n   \tuv -= clamp(anim,vec2(-0.4,-0.53),vec2(0.4,0.15));\n    uv.x = abs(uv.x);\n    vec2 uu = uv;\n    \n    uv += vec2(-0.9,0.3);\n    float c = step(length(uv), 0.2);\n    \n    uv = uu;\n    uv.y += 0.6;\n    float n = step(uv.x - uv.y,0.2)*step(uv.y,0.05);\n    \n    uv = uu;\n    uv.y += .8;\n    uv.y -= uv.x * uv.x ;\n    float m = step(abs(uv.x*0.9 + uv.y), 0.05)*step(-0.5,uv.y);\n    return c+n+m;\n}\n\nfloat outline (vec2 uv)\n{\n    uv.y += 0.1;\n    return step(length(uv),1.8) * step(1.7,length(uv));\n}\n\nfloat background (vec2 uv)\n{\n    float per = .9;\n    uv *= rot(iTime);\n    uv *= sin(iTime*0.3)*0.5+0.8;\n    uv = mod(uv,per)-per*0.5;\n    uv.x = abs(uv.x)-0.05;\n    uv *= rot(-PI/4.);\n    return step(length(uv*vec2(1.,0.5)),0.1);\n}\n\nvec3 husky (vec2 uv)\n{\n    uv *= 2.;\n    vec3 col = vec3(1.);\n    col -= vec3(0.4,0.3,0.3)*clamp(ears(uv)+head(uv),0.,1.);\n    col -= vec3(1.)*face(uv);\n    col -= vec3(1.)*outline(uv);\n\tcol -= vec3(0.,1.,1.)*clamp(background(uv)-(step(length(uv), 1.8)+ears(uv)),0.,1.);\n    return clamp(col,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\n    uv.x *= iResolution.x/iResolution.y;\n   \n    vec3 col = husky(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsy3zc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsyGDm", "name": "sensorgrid", "author": "lennyjpg", "description": "sdsdsdsdsdsD", "tags": ["sddssdsdsd"], "likes": 5, "viewed": 300, "date": "1570395694", "time_retrieved": "2024-06-20T19:47:00.723124", "image_code": "# define PI 3.141592653589793\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    vec2 u = fract(uv.xy*5.)-0.5;\n    float z = 5.;\n    vec2 g = iTime*.02 + floor(uv * z);\n    float b =  rand(floor(g + 3.321))*3.;\n    float r =.7;\n    float angle = PI*0.25+floor(rand(floor(g))*4.)*PI*0.5;      \n    u.x+=sin(angle)*r;\n    u.y+=cos(angle)*r;\n    float d = length(u*.3);\n //\tfloat k = smoothstep(d,d*1.01,0.5);\n    float k = fract(d*2.0-iTime*(b-0.5)*0.2);\n    vec3 cc = mix( vec3(.1, 0.1, 0.2), vec3(1.0, 0.14, 0), k);\n    fragColor = vec4(cc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsyGDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsyGRc", "name": "Shadertober 09 - Swing", "author": "BackwardsCap", "description": "Swing dancing dots", "tags": ["swing", "inktober", "shadertober", "backwardscaptain"], "likes": 4, "viewed": 271, "date": "1570640842", "time_retrieved": "2024-06-20T19:47:00.723124", "image_code": "#define PI 3.1415927\n\nfloat cir(vec2 p, float r)\n{\n    return smoothstep(9./iResolution.y,0.,length(p)-r);\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 p = 2.*((2.*f-iResolution.xy)/iResolution.y), c1, c2;\n    float t = iTime*2.+atan(p.x,p.y)-atan(p.y,p.x), r = .5, o = .25, b=cos(t)*r, z= sin(t)*r;\n    for(float x=-1.; x<=1.; x++)\n        for(float y=-1.;y<=1.;y++)\n        {\n            c1 = (p-vec2(x+o,y+o))+vec2(z,b);\n            c2 = (p-vec2(x-o,y-o))-vec2(z,b);\n            c.rgb += vec3(cir(c2,.1)+cir(c1,.1));\n         }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsyGRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsyGW3", "name": "Solar wind around planet", "author": "dyuri", "description": "solar wind distortion", "tags": ["planet", "solarwind"], "likes": 1, "viewed": 53, "date": "1571755701", "time_retrieved": "2024-06-20T19:47:00.723124", "image_code": "#define R .4\n#define PI 3.1415927\n#define SPEED 1.2\n#define DIST .25\n#define GLOW 1.9\n#define ROTSPEED .02\n#define LAYERS 20.\n#define PHI - PI / 9.\n#define BARS 32.\n#define SS(a,b,t) smoothstep(a,b,t)\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat speed(float x) {\n    x *= BARS;\n    x = fract(floor(abs(x)) / BARS);\n\treturn SPEED + (pow(texture(iChannel0, vec2(x, .25)).r, 3.) - .5);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat windTexture(vec3 uvw, float speed) {\n\t/*\n    return texture(iChannel0,\n        uvw.xy /\n            (1. + uvw.z) + // the nearer the less dense\n        vec2(uvw.z + iTime * SPEED * .5 * uvw.z, // the nearer the quicker\n            uvw.z)).r;\n\t*/\n    vec2 st = vec2(\n        uvw.xy /\n        \t(1. + uvw.z) +\n        vec2(uvw.z + iTime * speed * .5 * (uvw.z + .1),\n             uvw.z)) * 72.;\n    \n    return pow(noise(st) * 3.2, 2.);\n}\n\nfloat wind(vec3 uvw) {\n    float col = 0.;\n    float dist = length(uvw);\n    float circle = SS(-.02, .01, 1. - dist);\n\n    // rotate\n    uvw.xy = uvw.xy * rotate2d(PHI);\n    \n    // glow\n    float d = max(0., DIST - max(0., dist - 1.)) / DIST;\n    float gx = max(0.2, uvw.x);\n    float glowspeed = speed(uvw.y);\n    \n    // \"around\" planet\n    uvw -= d * normalize(uvw) * .5;\n    uvw.y *= 1. + \n        SS(0., 1. + abs(uvw.z) / R, max(0., -uvw.x * dist)) + // after\n        SS(0., .3 + abs(uvw.z) / R, max(0., uvw.x * dist)); // before\n    \n    col = SS(.1, 1., windTexture(uvw, SPEED)) *\n        (1. - circle); // don't draw into the planet\n\t\n    return (1. + d * gx * GLOW * glowspeed) * col + d * gx * gx * GLOW * glowspeed;\n}\n\nvec3 planet(vec2 uv, float wcol, float speed) {\n    vec3 uvw = vec3(uv, sqrt(1. - dot(uv, uv)));\n\n    // \"hot air\"\n    vec2 hot = vec2(-cos(PHI), sin(PHI)) * (wcol - .5) * speed * .1;\n\t\n    vec2 longLat = vec2(\n        (atan(uvw.x, uvw.z) / PI + 1.0) * 0.5,\n        (asin(uvw.y) / PI + 0.5)\n    );\n    \n    vec4 surface = \n        sqrt(uvw.z) * // sphere\n        texture(iChannel1, longLat - hot + ROTSPEED * vec2(iTime, 0.)) * // sphere mapped texture\n\t\tmax(.2, ((cos(-PHI) * uvw.x + .5) + (sin(-PHI) * uvw.y + .5) + uvw.z) / 2.); // sun direction\n        \n   \treturn surface.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (0, 0 in the center)\n    vec2 uv = fragCoord.xy / iResolution.xy -.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    uv = uv / R;\n    \n    vec3 uvw = vec3(0.);\n    float wcol = 0.;\n    \n    for (float w = 0.01; w < 1.5; w += 1.5 / LAYERS) {\n    \tuvw = vec3(uv, w);\n    \twcol += wind(uvw) / LAYERS;\n    }\n    \n    // TODO\n    // - wind color\n    \n    vec3 col = vec3(wcol * 1.2, wcol * wcol, wcol * wcol * wcol * .8) + max(vec3(0.), .5 * planet(uv, wcol, SPEED));\n    \n    float vignette = min(.4 * (3.2 - length(uv)), 1.);\n        \n    fragColor = vec4(vignette * col, 1.);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "ltXGDf", "previewfilepath": "https://soundcloud.com/fullspectrum/black-sun-empire-dawn", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/fullspectrum/black-sun-empire-dawn", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsyGW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsyGWD", "name": "IQ Engine Re-composition", "author": "Dirk", "description": "This Shader is a reconstruction and documentation of IQ's Happy Jumping Ray marching Tutorial.\nhttps://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=7560s\nI hope it may server as a helpful reference for IQ's student body.\n", "tags": ["tutorial", "iq", "learning", "render", "process"], "likes": 7, "viewed": 154, "date": "1570291786", "time_retrieved": "2024-06-20T19:47:01.850596", "image_code": "/*\n\n\tIQ RENDER ENGINE\n\n\tDocumented and Composed by Dirk Stockton\n\n\tThis Shader is a reconstruction and documentation of IQ's Happy Jumping Ray marching Tutorial.\n\t\n\tSHADERTOY ~ https://www.shadertoy.com/view/3lsSzf\n\tYOUTUBE ~ https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=7560s\n\n\tI hope it is as helpful to you as it was to me :)\n\n*/\n\n\n//SDF( Signed Distance Functions )\n\n//SPHERE\nfloat sdSphere( in vec3 pos, float rad )\n{\n \treturn length(pos) - rad;   \n}\n\n//ELIPSOID\nfloat sdEllipsoid( in vec3 pos, vec3 rad )\n{\n \tfloat k0 = length(pos/rad);\n \tfloat k1 = length(pos/rad/rad);\n    return k0*(k0-1.0)/k1;\n}\n\n//STICK\nfloat sdStick( in vec3 p, vec3 a, vec3 b, float ra, float rb )\n{\n\tvec3 ba = b-a;\n    vec3 pa = p-a;\n    \n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    \n    float r = mix( ra, rb, h );\n    return length(pa-h*ba) - r;\n}\n\n//SMOOTH MIN\nfloat smin( in float a, in float b, float k )\n{\n    float h = max( k - abs(a-b), 0.0 );\n \treturn min(a,b) - h*h/(k*4.0);   \n}\n\n//MODEL( Bat )\nvec2 sdBat( in vec3 pos )\n{\n    float t = fract(iTime/2.0);  \t\t\t\t//Loop time with FRACT\n    \n \tfloat y = 2.0*t*(1.0-t);\t\t\t\t//Motion Function\n    float dy = 4.0*(1.0-2.0*t);\t\t\t\t//Motion Derivitive( to find tangent )\n        \n    vec2 u = vec2(1.0,dy);\t\t\t\t\t//U axis of UV system\n    vec2 v = vec2( -dy,1.0);\t\t\t\t//V axis of UV system\n    \n    vec3 cen = vec3(0.0,y,0.0);\t\t\t\t//Move center\n    \n    float sy = 0.5 + 0.5*y;\t\t\t\t\t//Horizontal stretch\n    float sz = 0.5 + 0.2/sy;\t\t\t\t\t\t//Vertical Stretch\n    \n    vec3 rad = vec3(0.25,0.25*sy,0.25*sz);\t//Radius of Stretched Sphere\n    \n    vec3 q = pos - cen;\t\t\t\t\t\t//Coordinate System Refence to Origin\n    \n    float d = sdEllipsoid(q,rad);\t\t\t//Body Sphere\n    \n    vec3 h = q;\t\t\t\t\t\t\t\t//Head Location\n    \n    vec3 sh = vec3( abs(h.x), h.yz );\t\t//Reflection about X\n    \n    //Head\n    float d2 = sdEllipsoid(h-vec3(0.0,0.28,0.0),vec3(0.2));  //Head Shape\n    \n    d = smin(d,d2,0.1);\t\t\t\t\t\t\t\t\t\t//Add Head to Body\n    \n    //Horns\n    vec3 ho = sh-vec3(0.15,0.35,0.15);\t\t\t\t\t\t//Horn Position with refletion\n    ho.xy = (mat2(3,-4,4,3)/5.0)*ho.xy;\t\t\t\t\t\t//Horn Rotation( Pythagrian Triples )\n    \n    d2 = sdEllipsoid(ho,vec3(0.06,0.015,0.015));\t\t\t//Horn Shape\n    d = smin(d,d2,0.04);\t\t\t\t\t\t\t\t\t//Add Horns to Body\n    \n    //Stick\n    d2 = sdStick( sh, vec3(0.2,0.01,0.1),vec3(0.3,0.4*t-0.2,0.1), 0.01, 0.03 );\t//Arm Shape with Reflection about X\n    d = smin(d,d2,0.04);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Add Arms to Body\t\t\t\n    \n    vec2 res = vec2(d,2.0);\t//Material\n    \n    float d4 = sdSphere( sh - vec3(0.1,0.25,0.15), 0.05 );\t//EYES\n    if( d4<d )\t\t\t\t\t\t\t\t\t\t\t\t//Surface Eye material\n    {\n     \tres = vec2(d4,3.0 );   \n    }\n    \n    return res;\t//Return Model Distance field\n}\n\n//MAP - Returns Distance field based on SDF( Signed Distance Functions ) combined using min.\nvec2 map(in vec3 pos )\t\t\t\t\n{\n\tvec2 d1 = sdBat(pos); \t\t\t\t\t//Sphere Distance\n    \n    float fh = -0.1 + 0.05*(sin(2.0*pos.x) + sin(2.0*pos.z));\n    float d2 = pos.y - fh;\t   \t\t\t//Floor Distance\n    \n    return (d2<d1.x) ? vec2(d2,1.0) : d1;\t//Total Scene Depth\n}\n  \n//CALCULATE NORMAL - Returns surface angle of passed point\nvec3 calcNormal( in vec3 pos ) \t\t\t\t\n{\n    \n\tvec2 e = vec2(0.0001,0.0);\t\t\t\t//Perspective Precision\n \treturn normalize( \n    \tvec3(map(pos+e.xyy).x-map(pos-e.xyy).x,   \t//Perspective Math\n             map(pos+e.yxy).x-map(pos-e.yxy).x,\t\t//...\n             map(pos+e.yyx).x-map(pos-e.yyx).x ) );\t//...\n}\n\n//CAST RAY - from Ray Origin( ro ) about the Ray Direction( rd )\nvec2 castRay( in vec3 ro, vec3 rd )\n{\n    float m = -1.0;\n    float t = 0.0;\t\t\t\t\t//Ray Length\n    \n    for( int i=0; i<100; i++ ){\t\t//Ray Steps about Z into the horizon\n        \n    \tvec3 pos = ro + t*rd;\t\t//Ray position formula\t\n        \n        vec2 h = map(pos);\t\t\t//Map position( returns depth of point )\n        \n        m = h.y;\t\t\t\t\t//Assign Material ID to 'm'\n        \n        if( h.x<0.001 ) break;\t\t//Near Clipping Plane( too close to render )\n            \n        t+= h.x;\t\t\t\t\t//Progress the ray\n        \n        if( t>20.0 ) break;\t\t\t//Far clipping plane( render the sky )\n    }\n    if( t>20.0) m=-1.0;\t\t\t\t//Disguard overshot rays\n    \n    return vec2(t,m);\t\t\t\t//Return Ray Distance\n}\n\n\n//MAIN IMAGE composes the camera, lights, distances, and textures into a final pixar \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\t//Center Screen Coordinates\n    \n    float an = 10.0*iMouse.x/iResolution.x;\t\t\t\t\t//User Input Facing Angle;\n    \n   \tvec3 ta = vec3(0.0,0.55,0.0);\t\t\t\t\t\t\t//Target Angle\n    vec3  ro = ta + vec3(1.5*sin(an),0.0,1.5*cos(an)); \t\t\t//Camera Position\n    \n    vec3 ww = normalize( ta - ro );\t\t\t\t\t\t\t//Rotation Math\n    vec3 uu = normalize( cross(ww,vec3(0,1,0)));\t\t\t//Rotation Math\n    vec3 vv = normalize( cross(uu,ww) );\t\t\t\t\t//Rotation Math\n    \n    float len = 1.5;\t\t\t\t\t\t\t\t\t\t//Lens Aperture\n    vec3  rd = normalize( p.x*uu + p.y*vv + len*ww );\t\t//Camara Direction( NORMALIZED )\n    \n    vec3  col = vec3(0.8,0.4,0.3) - 0.7*rd.y;\t\t\t\t//Sky Color\n    col = mix( col,vec3(0.8,0.8,0.7), exp(-10.0*rd.y));\t\t//Sky Color 2 + Gradient Mixture\n    \n\t//TRACE SCENE\n    vec2 tm = castRay( ro, rd );\t\t\t\t\t\t\t\n    if( tm.y>0.0 )\t\t\t\t\t\t\t//If( Beyond Near Clipping Plane )\n    {\n        float t = tm.x;\t\t\t\t\t\t//Distance\n        vec3 pos = ro + t*rd;\t\t\t\t//Depth Map\n        vec3 nor = calcNormal(pos);\t\t\t//Normal Map\n        \n        vec3 mate = vec3(0.18);\t\t\t\t//Base Material\n        \n        if( tm.y<1.5 )\t\t\t\t\t\t//Grass Material\n        {\n         \tmate = vec3(0.02,0.04,0.04);\n            float f = -1.0+2.0*smoothstep( -0.1,0.1,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));\n            mate += f*0.05*vec3(0.5,0.8,0.8);\n        }\n        else\n        if( tm.y<2.5 )\t\t\t\t\t\t//Skin Material\n        {\n         \tmate = vec3(0.4,0.4,0.5);      \t//Cream\n        }\n        else\t\t\t\t\t\t\t\t//Eye Material\n        {\n         \tmate = vec3(0.01,0.01,0.01);    //Black\n        }\n    \t\n        //Build Lights\n        vec3  sun_dir = normalize( vec3(0.8,0.4,0.2) );\t\t\t\t\t\t\t//Sun Direction\n        float sun_dif = clamp( dot(nor,sun_dir),0.0,1.0);\t\t\t\t\t\t//Sun Difuse\n        float sun_sha = step(castRay( pos+nor*0.001,sun_dir ).y,0.0);\t\t\t//Sun Shadow\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\t//Sky Difuse\n        float bou_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\t//Bounce Difuse\n        \n        //Apply Lights\n        col =  mate*vec3(7.0,4.5,3.0)*sun_dif*sun_sha;\t//Sun Color\n        col += mate*vec3(0.5,0.8,0.9)*sky_dif;\t\t\t//Sky Color\n        col += mate*vec3(0.7,0.3,0.2)*bou_dif;\t\t\t//Earth Color\n        \n        col *= 0.9; //Gamma Correction\n    }\n    \n    col = pow( col, vec3(0.4545) ); //Alpha Correction\n    \n    //RENDER\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsyGWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsyGWR", "name": "Inktober #1: Rings", "author": "Wraithan", "description": "Playing with stuff for inktober", "tags": ["rings", "inktober"], "likes": 4, "viewed": 151, "date": "1569971724", "time_retrieved": "2024-06-20T19:47:01.850596", "image_code": "float H21(vec2 p) {\n    vec3 h = fract(p.xyx * vec3(141.212, 373.184, 107.63));\n    h *= dot(h, vec3(p, 1848.177));\n    return fract(h.x + (h.y * h.z));\n}\n\nvec2 rotate2d(vec2 p, float theta) {\n    return p * mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\n\n// https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // -1.0 <> 1.0\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    float gridScalar = 30.0;\n    \n    uv *= gridScalar;\n    \n    uv += gridScalar * 3.0;\n    \n    uv = rotate2d(uv, 3.14159 * -0.25);\n\n    \n    vec2 id = floor(uv);\n    vec2 st = fract(uv) - 0.5;\n    \n    \n    float d = length(st);\n    \n    vec3 col = hsv2rgb(vec3(H21(id) * d, 0.5, 1.0));\n    \n    float radius = sin(iTime * H21(id) * 5.0) * 0.22 + 0.22;\n    float border = 0.09;\n    \n    \n    float inner = smoothstep(radius - border, radius, d);\n    float outer = smoothstep(radius, radius + border, d);\n\n    \n  \tfloat mask = inner - outer;\n    col *= mask;\n    \n    //col.b = smoothstep(0.09, 0.07, d);\n    //col = vec3(H21(uv));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsyGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd3SDH", "name": "Noise sculptor shape", "author": "Nicolas2", "description": "Used in my websynth : www.noisesculptor.com.", "tags": ["waves", "outrun", "blue", "sines"], "likes": 10, "viewed": 240, "date": "1571873578", "time_retrieved": "2024-06-20T19:47:01.850596", "image_code": "\n\n  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r,g,b;\n    \n    r=0.2;\n    g=0.2;\n    b=0.57;\n\t\n    float time=iTime*4.0;\n \tfloat ot1=5.0;\n    float ot3=2.0;\n    float ot5=0.1;\n    float ot7=0.01;\n    float ot9=0.025;\n \tfloat Q=5000.;\n\tvec2 uv = fragCoord/iResolution.xy;\n    float amnt;\n\tfloat nd;\n\tfloat ip;\n\tfloat alpha;\n\tvec4 cbuff = vec4(0.0);\n\tfor(float i=0.0; i<10.0;i++){\n\t\t\n\tip=i-2.0;\n\t  nd = 1.0/4.0*ot1*sin(uv.x*2.0*3.14+ip*0.4+time*0.05)/2.0;\n\n\t  nd += 1.0/4.0*ot3*sin(3.0*uv.x*2.0*3.14+ip*0.4)/2.0;\n\n\t  nd += 1.0/4.0*ot5*sin(5.0*uv.x*2.0*3.14+ip*0.4)/2.0;\n\n\t  nd += 1.0/4.0*ot7*sin(7.0*uv.x*2.0*3.14+ip*0.4)/2.0;\n\n\t  nd/=5.0;\n\t  nd+=0.5;\n\t  amnt = 1.0/abs(nd-uv.y)*0.01;\n      amnt= smoothstep(0.01, 0.5+10.0*uv.y, amnt)*5.5;\n\t  alpha=(10.0-i)/5.0;\n\t  cbuff += vec4(amnt*alpha*0.3, amnt*0.3*alpha , amnt*uv.y*alpha,0) ;\n\t}\n\n\n\tfragColor = vec4(cbuff[0]*r,cbuff[1]*g,cbuff[2]*b,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd3SDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd3SW7", "name": "Chill landscape", "author": "z0rg", "description": "A little landcape I made inspired from a few things I saw on pinterest", "tags": ["2d", "landscape", "chill"], "likes": 21, "viewed": 273, "date": "1572186314", "time_retrieved": "2024-06-20T19:47:02.492998", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 green = vec3(0.42,0.55,0.33).xxx;\nvec3 blue = vec3(0.12,0.33,0.45);\n\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nfloat sat(float a)\n{\n    return clamp(a, 0., 1.);\n}\nbool inRange(float a, float mi, float ma)\n{\n  return a> mi &&a<ma;\n}\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat lenny(vec3 v)\n{\n  return abs(v.x)+abs(v.y)+abs(v.z);\n}\n\nfloat inC(vec2 uv, vec2 pos, float r)\n{\n  return 1.0-sat((length(uv-pos) - r)*550.);\n}\n\nfloat cloud(vec2 uv, vec2 pos)\n{\n  uv.x*=0.8;\n  uv*=2.;\n  float cr = inC(uv,pos+vec2(0.1,0.),0.05);\n  float cl = inC(uv,pos-vec2(0.1,0.),0.05);\n  float base = float(abs(uv.x-pos.x)<0.1&&(abs(uv.y-pos.y)<0.051));\n  float cm = inC(uv,pos+vec2(0.05,0.05),0.07);\n  float cb = inC(uv,pos+vec2(-0.05,0.02),0.07);\n\n  return float(sat(cr+cl+cm+cb+base));\n}\n\nfloat rdrMask(vec2 uv)\n{\n  float c = cloud(uv, vec2(sin(iTime*0.5)*0.5,0.3));\n  float c2=cloud(uv*vec2(-1.,1.)*0.5, vec2(0.3*sin(iTime*0.1),0.2));\n    \n  float inCircle = 1.0-sat((length(uv) - 0.4)*500.);\n  return inCircle * float((1.-c)*(1.-c2));\n}\n\n\nvec3 rdrWater(vec2 uv)\n{\n  float shape = sin(uv.y*20.)*0.1;\n  float thick =0.4*(0.1-uv.y);\n  float f =float(inRange(uv.x,shape-thick, shape+thick));\n\n  vec3 col =mix(green, blue, sin(iTime+uv.y*50.)*0.2+rand(uv.yx));\n  float light =dot(normalize(uv+vec2(0.+0.1*sin(iTime+pow(1.0+uv.y*3., 2.)*103.),0.)),vec2(0.,-1.));\n  return col*f*pow(light,5.);\n}\nvec3 rdr(vec2 uv)\n{\n\n  float isUp = float(sat((0.1*sin(uv.x*10.-4.)*250.+uv.y*450.)));\n  vec2 uvo = uv;\n  vec3 col;\n  uvo+= vec2(sin(-iTime)*0.1,cos(-iTime)*0.1);\n  for(int i= 0;i<10;++i)\n  {\n    col += vec3(0.02*float(10-i))*float(length(uvo)<(0.05*float(i)));\n  }\n  vec3 water = rdrWater(uv)*(1.-isUp);\n  return water+mix(green,blue,uv.y*4.+0.3)*isUp+col*(0.8*isUp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n    vec2 ouv = uv;\n  vec2 center = vec2(0.5)*iResolution.xy/iResolution.xx;\n  uv = uv - center;\n\n  uv*=1.6;\n  vec3 col =0.7* (1.-length(uv+vec2(0.,-0.3)))*vec3(0.21,0.12,0.657);\n  \n  col = col/pow(lenny(col),0.1);\n  col = mix(col, rdr(uv), rdrMask(uv));\n  col += vec3(0.3,uv.y,0.56)*(rand(uv)*0.1+0.5)*lenny(uv);\n  col +=( 1.-length(2.*uv+vec2(0.,-0.3)))*0.5;\n  col *= vec3(0.7,0.6,0.55)*1.7;\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd3SW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd3Sz4", "name": "Shadertober 19 Bronze -jaburns", "author": "jaburns", "description": "Raymarched tetrahedrons. Messing around with march step count AO and glow.", "tags": ["raymarch", "ao", "practice"], "likes": 7, "viewed": 322, "date": "1571526134", "time_retrieved": "2024-06-20T19:47:03.602155", "image_code": "//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n// =======================================================================================\n\n\n#define PI           3.14159265358979\n#define EPSILON      0.001\n#define MAX_DIST    30.0\n#define ITERATIONS  50.\n\n#define tt          (iTime * .2)\n\n#define POINTS_MATERIAL 1\n#define GEM_MATERIAL    2\n\nmat2 rot(float t)\n{\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, s, -s, c);\n}\n\n\nstruct DistMat\n{\n    float dist;\n    int mat;\n};\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat floatyPoints(vec3 p)\n{\n    float pointsT = tt * 10.;\n    float pointsR = .5 + .5*sin(pointsT);\n    \n    float octo = sdOctahedron(p, 2. + pointsR);\n    float sphere = length(p) - 1.6 - pointsR;\n    \n    return max(-sphere, octo);\n}\n\nfloat middleGem(vec3 p)\n{\n    p.yz *= rot(tt *7.);\n    p.xz *= rot(tt *5.);\n    p.xy *= rot(tt *3.);\n    \n    vec3 q = p;\n    q.xz *= rot(PI / 4.);\n    q.xy *= rot(PI / 4.);\n    \n    return min(\n        sdOctahedron(p, 1.3),\n        sdOctahedron(q, 1.3)\n    );\n}\n\nDistMat dmMin(DistMat a, DistMat b)\n{\n    if (a.dist < b.dist) {\n\t\treturn a;\n    }\n    return b;\n}\n\nDistMat DE(vec3 p)\n{   \n    p.xz *= rot(3.*tt);\n    p.yz *= rot(.5*tt);\n    \n    float a = floatyPoints(p);\n    float b = middleGem(p);\n    \n    return dmMin(\n        DistMat(a, POINTS_MATERIAL),\n        DistMat(b, GEM_MATERIAL)\n    );\n}\n\n\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(EPSILON, 0);\n    return normalize(vec3(\n        DE(p + e.xyy).dist - DE(p - e.xyy).dist,\n        DE(p + e.yxy).dist - DE(p - e.yxy).dist,\n        DE(p + e.yyx).dist - DE(p - e.yyx).dist));\n}\n\nstruct MarchResult\n{\n    vec3 pos;\n    float totalDist;\n    float ao;\n    int material;\n};\n    \nMarchResult march(vec3 ro, vec3 rd)\n{\n    DistMat dist;\n    float totalDist = 0.;\n    \n    ro += rd*.01;\n    \n    float i = 0.;\n    for (; i < ITERATIONS; ++i) {\n        dist = DE(ro);\n        totalDist += dist.dist;\n        if (dist.dist < EPSILON || totalDist > MAX_DIST) break;\n        ro += rd * dist.dist;\n    } \n    \n    return MarchResult(\n        ro,\n        dist.dist < EPSILON ? totalDist : -1.0,\n        (.8+0.2*snoise(300.*ro)) * i / 100.,\n        dist.mat\n    );\n}\n\nfloat traceLight(vec3 ro, vec3 rd)\n{\n    return 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy - vec2(.5*iResolution.x/iResolution.y,.5);\n    \n    vec3 ro = vec3(0,0,7);\n    vec3 rd = normalize(vec3(uv, -1));\n    \n    MarchResult m = march(ro, rd);\n    \n    if (m.totalDist > 0.0) {\n        vec3 norm = getNormal(m.pos);\n        \n        float la = .1+.4*clamp(dot(norm,normalize(vec3(1,1,1))),0.,1.);\n        float lb = .1+.4*clamp(dot(norm,normalize(vec3(-1,1,1))),0.,1.);\n        \n    \tfragColor = la*vec4(1,.9,.8,0);\n        fragColor += lb*vec4(1,.8,.9,0);\n        fragColor -= vec4(3.*m.ao);\n    }\n    else {\n        float r = 1./length(uv);\n        float t = atan(uv.y, uv.x);\n        float n = sin(r + 10.*tt + 3.) + sin(3.*t);\n        \n        fragColor = .3*n*vec4(.1);\n    }\n    \n    fragColor += .8*m.ao*vec4(1,.9,.8,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3Sz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd3Szn", "name": "x0008 - lines and dots", "author": "xigh", "description": "Still learning how to draw lines and dot, trying to have \"blurry solutions\" ... ", "tags": ["lines", "dots", "rotation"], "likes": 8, "viewed": 168, "date": "1571255848", "time_retrieved": "2024-06-20T19:47:03.602155", "image_code": "float segment(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n    float u = dot(ap, ab); // |ap|.|ab|.cos<pab>\n    float v = dot(ab, ab); // |ab|^2\n    float z = u / v;\n\tfloat h = clamp(z, 0., 1.);\n\treturn smoothstep(.9, .7, 100.*length(ap - ab*h));\n}\n\nconst float count = 30.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec2 p0 = vec2(0);\n    float r = 0.0;\n    float g = 0.0;\n\tfloat b = smoothstep(1.0, 0.9, length(uv-p0)*25.);\n\n    for (float i = 0.0; i < count; i++) {\n    \tfloat s1 = sin(iTime*(1.0+i)/4.0);\n    \tfloat c1 = cos(iTime*(1.0+i)/4.0);\n    \tmat2 r1 = mat2(\n        \t+c1, -s1,\n        \t+s1, +c1);\n    \tvec2 p1 = r1 * vec2(0., (count-i)/(count+1.0));\n    \n\t\tr += segment(uv, p0, p1);\n        float t = smoothstep(1.0, 0.9, length(uv-p1)*25.);\n    \tg += t;\n        b += mix(0.3, 1.0, i / count) * t;\n    }\n    \n\tfragColor = vec4(r, g, b, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3Szn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd3SzS", "name": "MetaBalls Tutorial", "author": "positivepig", "description": "my first shader in shadertoy -- metaballs, hope you like it！", "tags": ["2d", "sdf", "metaballs", "tutorials"], "likes": 10, "viewed": 1752, "date": "1572251628", "time_retrieved": "2024-06-20T19:47:03.602155", "image_code": "#define AA 2.\n\nstruct MetaBall{\n\tfloat r;\n    vec2 pos;\n    vec3 col;\n};\n\nvec4 BallSDF(MetaBall ball, vec2 uv){\n    float dst = ball.r / length(uv - ball.pos);\n    return vec4(ball.col * dst, dst);\n}\n\nvec3 renderMetaBall(vec2 uv){\n\tMetaBall  mbr, mbg, mbb;\n    mbr.pos = 0.7 * sin(iTime*.5 + vec2(4.0, 0.5) + 6.0); mbr.r = 0.6; mbr.col = vec3(1., 0., 0.);\n    mbg.pos = 0.7 * sin(iTime*.8 + vec2(1.0, 25) + 2.0); mbg.r = 0.9; mbg.col = vec3(0., 1., 0.);\n    mbb.pos = 0.7 * sin(iTime*1.2 + vec2(3.0, 2.5) + 4.0); mbb.r = 0.75; mbb.col = vec3(0., 0., 1.);\n\t\n    vec4 ballr = BallSDF(mbr, uv);\n    vec4 ballg = BallSDF(mbg, uv);\n    vec4 ballb = BallSDF(mbb, uv);\n    \n    float total = ballr.a + ballg.a + ballb.a;\n    float threshold = total > 4.5 ? 1. : 0.;\n    vec3 color = (ballr.rgb + ballg.rgb + ballb.rgb) / total;\n    color *= threshold;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n#ifdef AA \n    // Antialiasing via supersampling\n    float uvs = 1. / max(iResolution.x, iResolution.y);\n   \n    for(float i = -AA; i < AA; ++i){\n        for(float j = -AA; j < AA; ++j){\n        \tcol += renderMetaBall(uv + vec2(i, j) * (uvs / AA)) / (4.* AA * AA);\n        }\n    }\n#else       \n    col = renderMetaBall(uv);\n#endif /* AA */\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd3SzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd3XR4", "name": "Bouncy bounce!", "author": "msiddeek", "description": "Bouncing lights and balls around.", "tags": ["raymarching", "reflection", "raycasting", "baking"], "likes": 5, "viewed": 195, "date": "1571611236", "time_retrieved": "2024-06-20T19:47:04.796198", "image_code": "#define BOUNCES 3\n#define SAMPLES 3.\n#define RM_SIZE 4.\n\n#define MAX_DIST 50.\n#define PREC .01\n#define CR 400.\n#define CP 1200.\n\nfloat plane(vec3 p, vec4 n) {\n    return dot(p, normalize(n.xyz)) - n.w;\n}\nfloat planeX(vec3 p, float d) {\n    return plane(p, vec4(1., 0., 0., d));\n}\nfloat planeY(vec3 p, float d) {\n    return plane(p, vec4(0., 1., 0., d));\n}\nfloat planeZ(vec3 p, float d) {\n    return plane(p, vec4(0., 0., 1., d));\n}\nfloat cyl(vec3 p, vec3 cd, float r) {\n    return length(cross(p, normalize(cd))) - r;\n}\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat box(vec3 p, vec3 b)  {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n          \nfloat tramp(vec2 p, float s) {\n    vec2 ap = abs(p);\n    float a = clamp(-MAX_DIST, 0., abs(max(ap.x, ap.y) * .5) - s);    \n    return -a * .4;\n}\nfloat pCol(vec3 c) {\n    float f = 0.;\n    f = f * CP + floor(c.r * CR);\n    f = f * CP + floor(c.g * CR);\n    f = f * CP + floor(c.b * CR);\n    return f;\n}\n\nvec3 upCol(float f) {\n    vec3 c;\n    f = (f - fract(f)) / CP;\n    c.b = fract(f);\n    f = (f - fract(f)) / CP;\n    c.g = fract(f);\n    f = (f - fract(f)) / CP;\n    c.r = fract(f);\n    return c * CP / CR;\n}\n\nvec4 map(vec3 p) {\n    float d = MAX_DIST;\n    float c = .0;\n    float nor = 0.;\n    float dif = 0.;\n\n    // walls\n    float w =\n            min(\n                min(planeX(p, -RM_SIZE), -planeX(p, RM_SIZE)),\n                min(-planeZ(p, RM_SIZE), planeZ(p, - RM_SIZE))\n            );\n    if (d > w) {\n        d = w;\n        c = pCol(vec3(1.1, .9, .7));\n        dif = .0;\n        nor = .5;\n    }\n\n    // sky\n    float pl1 = plane(p, vec4(-.0, -1., -.0, -3.5));\n    if (d > pl1) {\n        d = pl1;\n        c = pCol(vec3(1.25, 1.25, 1.25));\n        dif = .00;\n        nor = .00;\n    }\n    \n    // ball\n    float phf = fract(iTime / 8.);\n    float ph = cos(phf * 3.14 * 2. * 8.);\n    float j = 3.;\n\n    vec3 sp = p - vec3(0., 1. + ph, 0.);\n    sp.x += (clamp(abs(8. * phf - 3.) - 1.5, 0.1, 0.9) - .5) * j;\n    sp.z += (clamp(abs(8. * phf - 5.) - 1.5, 0.1, 0.9) - .5) * j;\n    float s = sphere(sp, .5);\n    if (s < d) {\n        d = s;\n        c = pCol(vec3(1.));\n        nor = .00;\n        dif = .999;\n    }\n    \n    // mirror\n    float m = box(p - vec3(0., 1.75, RM_SIZE), vec3(3., 1.65, .01));\n    if (d > m) {\n\t\td = m;\n        float fr = smoothstep(1.5, 1.499999, abs(p.y - 1.75)) * smoothstep(2.9, 2.899999, abs(p.x));\n        c = fr * pCol(vec3(1.)) + (1. - fr) * pCol(vec3(.1, .3, .5));\n        nor = .01;\n        dif = .94 + .05 * fr;\n    }\n    \n    \n    // floor\n    float f = p.y - clamp(-1., -.1, ph) * tramp(sp.xz, .8);\n    if (d > f) {\n        d = f;\n        float bt = (mod(floor(p.x - .5), 2.) * mod(floor(p.z - .5), 2.));\n        c = pCol(vec3(.1 + 1.1 * bt, .2 + .9 * bt, .1));\n        dif = 0.;\n        nor = 0.4;\n    }\n    \n    return vec4(d, c, dif, nor);\n}\n\nvec3 normal(vec3 p) {\n    vec2 t = vec2(1., -1.) * PREC * .001;\n    return normalize(\n    \tt.xyy * map(p + t.xyy).x +\n    \tt.yxy * map(p + t.yxy).x +\n    \tt.yyx * map(p + t.yyx).x +\n    \tt.xxx * map(p + t.xxx).x);\n}\nvec4 march(vec3 ro, vec3 rd, float maxD) {\n    vec4 res;\n    float d = 0.;\n    float newD = PREC;\n    while (newD >= PREC && d < maxD) {\n        res = map(ro + rd * d);\n        newD = res.x;\n        d = min(maxD, d + newD);\n    }\n \treturn vec4(d, res.yzw);\n}\n\n\nfloat R11(float i) {\n    return fract(i * 12312.234 + 89.1);\n}\nfloat R31(vec3 p, float s) {\n    return fract(\n        s * (p.x * p.y * p.z + .567) * 100.654 +\n        p.x * 123.458 +\n        p.y * 789.012 +\n        p.z * 345.678);\n}\nvec3 R33(vec3 p, float s) {\n    return vec3(\n        fract(R31(p, s) * 567.890),\n        fract(R31(p, s) * 123.456),\n        fract(R31(p, s) * 789.012));\n}\n\nvec3 bounce(vec3 h, vec3 n, vec3 r, vec2 m, float s) {\n    vec3 ref = r - 2. * dot(r, n) * n;\n    return m.x * ref + m.y * n + (1. - m.x - m.y) * normalize(R33(h, fract((s + 1.) * iTime)) - .5);\n}\n\n\n\nvec3 ray(vec3 ro, vec3 rd) {\n    vec3 ac = vec3(0);\n    vec3 c[BOUNCES + 1];\n\n    for (float s = 0.; s < SAMPLES; s++) {\n        vec3 h = ro;\n        vec3 n = rd;\n        vec3 r = rd;\n        vec4 m = march(h + n * PREC, r, MAX_DIST);\n        c[0] = upCol(m.y);\n        h = h + m.x * r;\n        n = normal(h);\n        r = normalize(bounce(h, n, r, m.zw, R11(s)));\n\n        int b = 1;\n        while (b <= BOUNCES) {\n            m = march(h + n * PREC, r, MAX_DIST);\n            c[b] = upCol(m.y);\n            if (length(c[b]) <= 0.2) {\n                break;\n            }\n\n            h = h + m.x * r;\n            n = normal(h);\n            r = normalize(bounce(h, n, r, m.zw, R11(s)));\n            b++;\n        }\n\n\t   vec3 rc = vec3(0);\n       while (b >= 0) {\n           rc *= c[b];\n           rc += smoothstep(1., 3., c[b]);\n           b--;\n        }\n        ac += rc;\n    }\n\n\n    return ac / SAMPLES;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    col += ray(ro, rd);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float y = 0.1;\n    float a = - .25 * 3.14; //;\n    if (iMouse.x != 0.) {\n        y = (.5 - iMouse.y / iResolution.y) * 3.14 * .75;\n        a += (.5 - iMouse.x / iResolution.x) * 3.14 * .5;\n    }\n    float cp = 1.;\n    vec3 ro = vec3(-RM_SIZE + .3, 2., -RM_SIZE + .3);\n    float phf = fract(iTime / 8.);\n    float ph = cos(phf * 3.14 * 2. * 8.);\n    ro.y += smoothstep(-.8, -1., ph) * (ph + .8) * .5;\n    vec3 rd = normalize(vec3(uv.x, uv.y, cp));\n\n    rd.yz = mat2(cos(y), sin(y), -sin(y), cos(y)) * rd.yz;\n    rd.xz = mat2(cos(a), sin(a), -sin(a), cos(a)) * rd.xz;\n\n    vec3 col = render(ro, rd);\n    col = pow(col * 4., vec3(0.4545));\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd3XR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd3XRj", "name": "Impossible Geometric Lattice", "author": "Shane", "description": "Using a triangular grid to construct a randomly connected impossible geometric lattice.", "tags": ["grid", "triangle", "cube", "transparent", "geometry", "lattice", "impossible", "layer"], "likes": 30, "viewed": 651, "date": "1572530108", "time_retrieved": "2024-06-20T19:47:08.305708", "image_code": "/*\n\n\tImpossible Geometric Lattice\n\t----------------------------\n\n\tUsing a triangular grid to construct an impossible geometric lattice,\n\tconnected together with random, semi-transparent tubes. \n\n\tOne of my favorite pastimes is looking at a standard repeat pattern on \n\tthe net, then trying to figure out how to reconstruct it -- We all need \n\tour hobbies, right? :D Sometimes, I'll get lucky and figure it out \n\timmediately. Other times, I'll try for ages getting nowhere, then have \n\tto quit. However, if I'm patient enough, someone on Shadertoy will \n\teventually do it. :D\n\n\tThankfully, the trick behind the impossible geometric lattice pattern \n    came to me quickly. On the down side, I'd already produced it on a \n    diamond grid before realizing that a triangle grid version would allow \n\tfor a much more elegant construction. Whilst on the subject, I should\n\talso point out that a Wang tile approach would be even better, but this\n\tis another thing I only figured out at the end. :)\n\n\tAs mentioned above, this is an example of impossible geometry -- The \n    connections you're seeing wouldn't be possible in the real world, which \n    can mess with your sense of perception, but that's half the appeal.\n\n\tThe imagery was rendered in a psuedo pencil drawing style using 2D \n\ttechniques. Like the geometry itself, the lighting, shadows, etc, are a \n\tmixture of real world calculations and ones that don't really add up, \n\tso as when watching movies, a certain suspension of belief is necessary.\n\n\tIf you just wanted a simple connecting lattice, you could set up a\n\ttriangle grid, then render one cube face and connecting tube at each of\n\tthe three triangle vertex points, and you'd be done. Essentially, that's \n\tall I've done here. However, I got a little carried away prettying it\n\tup, adding shadows, extra settings, etc, so this is a little longer. \n\tHaving said that, it's still not what I'd describe as a long example.\n\n\n\n\tOther Impossible Geometry Examples:\n\n\t// Fabrice has covered everything at one point or another. :)\n\timpossible triangle (224 ch) -  FabriceNeyret2\n\thttps://www.shadertoy.com/view/XtyfDc\n\n\t// Beatiful example: There are some things you can't really achieve\n\t// with 2D overlays.\n\tPenrose Pathtraced - yx\n\thttps://www.shadertoy.com/view/ttXGWr\n\n*/\n\n\n// A regular equilateral scaling, which is just a special form of isosceles.\n// With an example like this, equilateral triangles are the way to go, but\n// I wanted to show that isosceles triangles are possible also. By the way,\n// on a diamond grid, playing with the stretch settings make more sense.\n#define EQUILATERAL\n\n\n// Adding in some noise. Comment it out for a smoother, cleaner look.\n#define NOISE_TEX\n\n// Turn the hatching on or off. I prefer it, but others might like a cleaner, \n// smoother, look.\n#define DO_HATCH\n\n// Flat shading. It looks cleaner, and probably looks a little more natural, \n// but I wanted vibrancy, for this particular example.\n//#define FLAT_SHADING\n\n// A hacky glass tube effect. Putting in more effect to render glass cubes\n// would be cool, but that would require more writing. :D\n//#define GLASS\t\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.687, 57.583)))*43758.5453); }\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n    \n}\n\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n    \n   vec2 l = vec2(length(b - a), ew);\n   return sBox(p, (l + ew)/2.) ;\n}\n\n// Entirely based on IQ's signed distance to a 2D triangle -- Very handy.\n// I have a generalized version somewhere that's a little more succinct,\n// so I'll track that down and drop it in later.\nfloat quad(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3){\n\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p3 - p2;\n\tvec2 e3 = p0 - p3;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\tvec2 v3 = p - p3;\n\n\tvec2 pq0 = v0 - e0*clamp(dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp(dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp(dot(v2, e2)/dot(e2, e2), 0., 1.);\n\tvec2 pq3 = v3 - e3*clamp(dot(v3, e3)/dot(e3, e3), 0., 1.);\n    \n    float s = sign(e0.x*e3.y - e0.y*e3.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n    \n    d = min(d, vec2(dot(pq3, pq3), s*(v3.x*e3.y-v3.y*e3.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// Signed distance to a regular hexagon -- using IQ's more exact method.\nfloat sdHex(in vec2 p, in float r){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.\n  p = abs(p);\n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n    \n}\n\n// \nfloat shade(vec2 p, float shd){\n    \n    #ifdef FLAT_SHADING\n    return pow(shd, 4.) + .25;\n    #else\n    \n    //float lgt = max(1.3 - length(p), 0.);\n    //return pow(lgt, 4.)*shd*shd + .2;\n   \n    shd *= max(1.3 - length(p), 0.);\n    return pow(shd, 4.) + .15;\n    #endif\n}\n\nfloat shade2(vec2 p, float shd){\n    \n    #ifdef FLAT_SHADING\n    return pow(shd, 4.) + .25;\n    #else\n    //float lgt = max(1.35 - length(p), 0.);\n    //return pow(lgt, 4.)*shd*shd + .25;\n   \n    shd *= max(1.35 - length(p), 0.);\n    return pow(shd, 4.) + .15;\n    #endif\n}\n\n\n\n// The scaling vector. Basically, it determines the height to width ratio.\n//\n#ifdef EQUILATERAL\n// An equilateral scaling, which is just a special kind of isosceles.\nconst vec2 s = vec2(1, .8660254); //1./.8660254\n#else\n// I wanted to show that this example would work with other scales too, even \n// if they don't look particularly great. :)\nconst vec2 s = vec2(1.3, 1)*.84; \n// One to one scaling -- which would effectively make the scaling redundant.\n//const vec2 s = vec2(1); \n#endif\n\n\nvec4 getTri(vec2 p, inout float itri){\n    \n    // Scaling the cordinates down, which makes them easier to work with. You scale \n    // them back up, after the calculations are done.\n    p /= s;\n    \n    // Triangles pack a grid nicely, but unfortunately, if you want vertices to \n    // match up, each alternate row needs to be shifted along by half the base \n    // width. The following vector will help effect that.\n    float ys = mod(floor(p.y), 2.)*.5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    \n    // Two triangles pack into each square cell, and each triangle uses the bottom \n    // left point as it's unique identifier. The two points are stored here.\n    vec4 ip4 = floor(p.xyxy + ipY) - ipY + .5; \n    \n    // The local coordinates of the two triangles are stored here.\n    vec4 p4 = fract(p.xyxy - ipY) - .5;\n    \n    // Which isoso... I always struggle to spell it... isosceles triangle\n    // are we in? Right way up, or upside down. By the way, if you're wondering\n    // where the following arises from, \"A*abs(x) + B*abs(y) - C\" partitions \n    // a quad and \"A*abs(x) +  B*y - C\" partitions a triangle.\n    float i = (abs(p4.x)*2. + p4.y<.5)? 1. : -1.;\n    \n    itri = i;\n    \n    // Depending on which triangle we're in, return a vector containing the local \n    // coordinates in the first two spots, and the unique position-based identifying \n    // number in the latter two spots. These two positions would be all you'd need\n    // to render a colored triangle grid. However, when combined with the triangle \n    // orientation and vertices (above), you can render more interesting things.\n    p4 = i>0.? vec4(p4.xy*s, ip4.xy) : vec4(p4.zw*s, ip4.zw);  \n    \n    return p4;\n    \n}\n\n\nvec3 triLattice(vec2 q, float sf, vec2 uv, float iRes){    \n \n    // The relative vertice positions. You could hardcode these into the formulae \n\t// below, but if you're performing various edge arithmetic, etc, they're handy \n\t// to keep around.\n\tvec2 v0 = vec2(-.5), v1 = vec2(0, .5), v2 = vec2(.5, -.5);\n\tvec2 v0Sh = v0, v1Sh = v1, v2Sh = v2;\n\n    // Keeping a copy of the original coordinate.\n    vec2 oP = q;\n    \n    // Rotating the entire grid, according to the grid dimensions. Basically, this\n    // just orients the camera to an isometric view that's easier on the eyes.\n    // // \"q *= r(a)\"works too, but apparently not all cards like it. Typical. :)\n    q = rot2(-atan(s.x/s.y/2.))*q; \n\n    \n    // The shadowed triangle grid, IDs, physical positions, etc.\n    float itriSh;\n    vec4 p4Sh = getTri(q - vec2(.12, -.12), itriSh);\n    vec2 pSh = p4Sh.xy; // Local coordinates.\n    vec2 ipSh = p4Sh.zw; // Triangle ID.\n    if(itriSh>0.) { vec2 tmp = v0Sh; v0Sh = v2Sh; v2Sh = tmp; }\n\n    vec2[3] vIDSh = vec2[3](v0Sh*itriSh, v1Sh*itriSh, v2Sh*itriSh);\n    vec2[3] vVSh = vec2[3](vIDSh[0]*s, vIDSh[1]*s, vIDSh[2]*s);\n    vec2[3] eIDSh = vec2[3](mix(vIDSh[0], vIDSh[1], .5), mix(vIDSh[1], vIDSh[2], .5), mix(vIDSh[2], vIDSh[0], .5));\n    \n    // The main triangle grid, IDs, physical positions, etc. All this is explained in my\n    // triangle jigsaw example on this site, if you feel like looking for it.\n    float itri;\n    vec4 p4 = getTri(q, itri);\n     // Making a copy of the triangle's local coordinates and ID. It's not particularly\n    // necessary, but saves a bit of extra writing and confusion.\n    vec2 p = p4.xy; // Local coordinates.\n    vec2 ip = p4.zw; // Triangle ID.\n    // Arranging for the vertices of complimentary triangle set to line up.\n    if(itri>0.) { vec2 tmp = v0; v0 = v2; v2 = tmp; }\n    \n    \n    // The unscaled triangle vertices, which double as an ID: Note that the vertices of\n    // alternate triangles are flipped in a such a way that edge neighboring edge vertices\n    // match up.\n    vec2[3] vID = vec2[3](v0*itri, v1*itri, v2*itri);\n    // Edge IDs, based on the vertex IDs above. The mid points of neighboring triangles\n    // occur in the same position, which means both triangles will generate the same\n    // unique random number at that position. This is handy for all kinds of things.\n    vec2[3] eID = vec2[3](mix(vID[0], vID[1], .5), mix(vID[1], vID[2], .5), mix(vID[2], vID[0], .5));\n    // Scaled vertices -- It's not absolutely necessary to have these, but when doing more\n    // complicated things, I like to switch between the unscaled IDs and the physically scaled\n    // vertices themselves.\n    vec2[3] vV = vec2[3](vID[0]*s, vID[1]*s, vID[2]*s);\n    // Scaled mid-edge vertices.\n    vec2[3] vE = vec2[3](eID[0]*s, eID[1]*s, eID[2]*s);\n\n\n    \n    const float cw = .45; // The cube face dimension. \".5\" would be the maximum.\n    const float lw = .175; // The connecting tube face dimension.\n    float spc = (cw - lw)/1.732; // The diagonal distance to center the tube.\n    const float ew = .01; // Edge width.\n    \n    const float thresh = .57; // Join threshold.\n    const float thresh2 = .57; // Threshold for cubes without holes.\n    \n    \n    \n    // Individual cube face and connecting tube face shades. These have been tailored\n    // to suit the example.\n    vec3 sh = vec3(1, .65, .25);\n    vec3 sh2 = vec3(.5, .15, 1.2);\n   \n    // Triangles can be tricky. Alternating triangles need the shades shifted around.\n    // I was feeling lazy, so I got these through trial and error. The top cube face\n    // needed to be lighter, and so forth.\n    if(itri<0.) { sh = sh.yxz; sh2 = sh2.zyx; }\n    \n    \n    // The scene color, initialized to a simple background gradient.\n    vec3 col = mix(vec3(.7, .85, 1)/1.25, vec3(1, .7, .4)*.8, -uv.y + .5);\n\n    #ifdef GLASS\n    // Darken the background for the glass setting. Yeah, it needs more effort. :)\n    col *= .75;\n    #endif    \n    \n    #ifdef NOISE_TEX\n    // The subtle noise texture.\n    float ns = fbm(oP*32.*max(iRes/450., 1.));\n    vec3 tx = mix(vec3(1, .8, .7), vec3(.05, .1, .15), ns);\n    tx = smoothstep(-.25, .55, tx);    \n    col *= tx;\n    #endif\n    \n    // Render connecting tube links and there shadows, or not.\n    vec3 drawLink = vec3(0);\n    vec3 drawLinkSh = vec3(0.);\n\n    \n    // An impossible geometric lattice with all the links in tact looks interesting,\n    // but I don't feel it looks as interesting as the one with random links. Rendering\n    // links randomly is simple enough (just compare the random shared edge value \n    // against a threshold), but you wind up with floating cubes. If you're OK with that,\n    // then the following isn't necessary. If it bothers you, like it did me, then you\n    // have to check for empty neighboring links, and either, omit the cube, or put a\n    // link in, which is what is happening here. By the way, using a Wang tile approach\n    // would be a more effective solution, but the following hack will do for now.\n  \n    for(int i = 0; i<3; i++){\n    \n        // Random number from the shared edge ID.\n        float rndI = hash21(ip + eID[i]);\n        // If it's below the threshold, flag the index of the link drawing vector.\n        if(rndI<thresh) drawLink[i]++;\n      \n        // Check for floating cubes:\n        //\n        // At the end of the final iteration, if no links have been rendered\n        // to the cube, add one in. I'm not happy with this logic, but it\n        // seems to work, so I'll leave it as is, for now.\n        if(i == 2){\n            int lCnt2 = 0;\n            if(hash21(ip + eID[(i + 0)%3])<thresh) lCnt2++;\n            if(hash21(ip + eID[(i + 2)%3])<thresh) lCnt2++;\n            if(hash21(ip + eID[(i + 0)%3]*2. + eID[(i + 2)%3])<thresh) lCnt2++;\n            if(hash21(ip + eID[(i + 2)%3]*2. + eID[(i + 4)%3])<thresh) lCnt2++;\n            if(lCnt2==0) drawLink[i]++;\n        }\n        \n        // Do the same with the shadow links. I'd hoped to use the variables above.\n        // Unfortunately, however, shadows need to be calculated seperately.\n        rndI = hash21(ipSh + eIDSh[i]);\n        if(rndI<thresh){\n            drawLinkSh[i]++;\n        }\n        \n        // Check for floating shadow cubes.\n        if(i == 2){\n            int lCnt2 = 0;\n            if(hash21(ipSh + eIDSh[(i + 0)%3])<thresh) lCnt2++;\n            if(hash21(ipSh + eIDSh[(i + 2)%3])<thresh) lCnt2++;\n            if(hash21(ipSh + eIDSh[(i + 0)%3]*2. + eIDSh[(i + 2)%3])<thresh) lCnt2++;\n            if(hash21(ipSh + eIDSh[(i + 2)%3]*2. + eIDSh[(i + 4)%3])<thresh) lCnt2++;\n           if(i==2 && lCnt2==0) drawLinkSh[i]++;\n        }\n\n    }\n   \n\n    // Render the shadows first. Something I get wrong all the time is trying to\n    // render the shadows layer upon layer. You have to take the overal minimum then\n    // render the entier shadow to the background... or on top of objects that are\n    // between the light and the background... And that's why I find it easier just\n    // to render things in 3D. :)\n    float dSh = 1e5;\n    for(int i = 0; i<3; i++){\n    \n        // Cube shadows. Just hexigons at each vertice. Quadrilateral cube faces\n        // would also work, but this does the same thing, and is easier.\n        dSh = min(dSh, sdHex(pSh - vVSh[i], cw));\n        \n        // If applicable, render the link shadow, which is just a box \n        // between vertices.\n        if(drawLinkSh[i]>.5){\n        \tdSh = min(dSh, lBox(pSh, vVSh[i], vVSh[(i + 1)%3], lw));\n        }\n     \t\n    }\n    \n\n    // Apply the background shadow.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dSh + .08))*.7);\n    \n    \n    // With the shadow done, it's time to render the boxes (with or without holes),\n    // and the connecting tubes.\n     \n    for(int i = 0; i<3; i++){\n\n        // Normal vectors. There are used to obtain the vertices of the\n        // quadrilateral cube faces.\n        vec2 n0 = normalize(vV[i] - vV[(i + 1)%3]);\n    \tvec2 n1 = normalize(vV[(i + 1)%3] - vV[(i + 2)%3]);\n    \tvec2 n2 = normalize(vV[(i + 2)%3] - vV[i]);\n\n        // Cube face distance field.\n        //\n        // Clockwise.\n        vec2 v0 = vV[i];\n\t\tvec2 v1 = v0 + n1*cw;\n\t\tvec2 v2 = v1 + n2*cw;\n\t\tvec2 v3 = v2 - n1*cw;\n        float d = quad(p, v0, v1, v2, v3);\n\n        \n        // Connecting tube distance field.\n        float side2 = length(vV[i] - vV[(i + 1)%3]);\n        v0 = vV[i] - n0*spc;\n\t\tv1 = v0 + n2*lw;\n\t\tv2 = v1 - n0*(side2 - spc - cw);\n\t\tv3 = v2 - n2*lw;\n        float d2 = quad(p, v0, v1, v2, v3);\n        \n        // The cube hole.\n        float dH = max(d2, d);\n        \n        \n        // Make a hole in the cube, or not. You could put holes on\n        // all cubes, if you wanted, but I thought this added a bit\n        // more visual interest.\n        float cbRnd = hash21(ip + vID[i] + .1);\n        if(drawLink[i]>.5 || cbRnd<thresh2) {\n            // Cube hole, on all link faces, and on\n            // random cubes as well.\n            v0 = vV[i] - n0*spc;\n\t\t\tv1 = v0 + n2*lw;\n\t\t\tv2 = v1 + n1*lw;\n\t\t\tv3 = v2 - n2*lw;\n            d = max(d, -quad(p, v0, v1, v2, v3));\n        }\n        \n        \n        \n        // The shading formula. Fake, of course. Basically, we're just manipulating the\n        // distance field itself, and hoping it looks kind of right. :) The more correct\n        // part of the lighting simply comes from giving the top cube face a light shade,\n        // the left a middle range shade, and the right a dark one.\n        float vSh = shade(p.xy - (vV[i] + s.yx*vec2(-1, 1)*.05), sh[i]);\n        \n        \n  \n        // Using the random vertex ID to give the cubes (which share a common triangle\n        // vertex) a random color.\n        float rnd = hash21((ip + vID[i])*s);\n        // Tweaking IQ's elegant underutilized one line palette formula to produce some subtle \n        // reddish earth tones. By the way, it's worth knowing the formula by heart, because it's\n        // so useful. In fact, if there's a cleverer more versatile formula than this, then I'm \n        // yet to see it. A close second would be the following: \n        // c = pow(vec3(a, b, c)*grey, vec3(d, e, f));\n        vec3 tCol = .5 + .45*cos(6.2831*mix(0., .3, rnd) + vec3(0, 1, 2)/1.5);\n        tCol = mix(vec3(1, .4, .25), tCol, .5);\n\n\n        #ifdef NOISE_TEX\n        tCol *= tx;\n        #endif\n\n        vec3 svCol = col;\n  \t\t\t\n        // If applicable, render an inner box.\n        if(drawLink[i]>.5 ||  cbRnd<thresh2){\n\n            float vSh2 = shade(p.xy - (vV[i] + s.yx*vec2(-1, 1)*.05), sh[(i + 2)%3]);\n            // Fake AO.\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., dH))*.5);\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, dH)));\n        \tcol = mix(col, mix((tCol + vec3(.6, .8, 1)*.5)*vSh2*vSh2, svCol, .5), \n                      \t\t   (1. - smoothstep(0., sf, dH + ew)));\n           \n            // Shadow cast on object.\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., max(dSh + .08, dH)))*.35);\n         }   \n   \t\t\t\n        \n        // Boxes --  We're actually rendering a diamond quadrilateral cube face at \n        // each vertex, but when joined together on a triangle grid, it looks like a \n        // repetitive cubes.\n        //\n        // Fake AO, border, color and shading.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., d))*.5);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, d)));\n   \t\tcol = mix(col, mix(tCol*vSh, svCol, 0.), (1. - smoothstep(0., sf, d + ew)));\n        // Shadow cast on the object -- The physics are nonsensical, but no one will check. :)\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., max(dSh + .08, d)))*.35);\n       \n        \n        // Connecting tube links.\n        \n        // Brightening up the left verticle tube link a bit. There's no science behind this --\n        // I just thought it looked a little better.\n        //if(itri>0.) vSh[0] *= 2.;\n        if(itri>0.) sh2[0] = mix(sh2[0], sh2[2], .55);\n        \n        if(drawLink[i]>.5){\n          \n            // The science behind the lighting here is pretty simple. Basically, I shifted\n            // the position around to various places until it looked like it might be scientifically\n            // correct... Then, when I didn't like how that looked, I moved it around until I\n            // thought it looked pretty. :D\n            //vSh = doShade(p.xy - mix(vE[(i + 1)%3], vV[i], .8), vSh);\n            vSh = shade2(p.xy - (mix(vE[(i + 1)%3], vV[i], .25) - s.yx*vec2(-1, 1)*.15), sh2[i]);\n            \n            vec3 lCol = vec3(.6, .8, 1);\n            #ifdef NOISE_TEX\n            // Add a little noise to the tubes.\n            lCol *= tx*.75 + .25;\n            #endif\n            \n            // The tubes are slightly transparent, to I've saved the background to mix\n            // with it. Normally, I wouldn't have to, but the dark edges are just a slightly\n            // larger black tube, with the colored tube over the top. I could use the \"abs\"\n            // trick, but sometimes, it doesn't quite work.\n            svCol = col;\n         \n            // Fake AO -- Technically, this encroaches a little onto the sides of the\n            // cube, but it's barely noticeable... to most, but there's always one :D\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., d2 + ew))*.5); \n            // Edges.\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, d2)));\n            #ifdef GLASS\n            // Glowing glass tubes.\n   \t\t\tcol = mix(col, mix(lCol*vSh, svCol, .9)*vec3(1.5, 2.3, 3.4), \n                     (1. - smoothstep(0., sf, d2 + ew)));\n            #else\n            // Transparent... hard plastic tubes? Either way, they'll do.\n   \t\t\tcol = mix(col, mix(lCol*vSh, svCol, .5), (1. - smoothstep(0., sf, d2 + ew)));\n            #endif\n          \n            // Shadow object cast. Again, not realistic, but I doubt anyone will care. :)\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., max(dSh + .08, d2)))*.35);\n            \n \n        }\n \n    }\n    \n\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Restricting the fullscreen resolution.\n    float iRes = min(iResolution.y, 800.);\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    \n    // Scaling and translation.\n    float gSc = 4.5;\n    // Depending on perspective; Moving the scene toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    //\n    // Warped version.\n    //vec2 p = uv*(.95 + length(uv*vec2(iResolution.y/iResolution.x, 1))*.05)*gSc - vec2(-1, -.5)*iTime;\n    vec2 p = (uv*gSc - vec2(-.6, -.3)*iTime);\n    \n    // A nonwarped copy, for postprocessing purposes.\n    vec2 oP = uv*gSc - vec2(-.6, -.3)*iTime;\n    \n    \n    // The smoothing factor.\n    float sf = gSc/iRes;\n    \n    \n    // The isosceles grid lattice object.\n    vec3 col = triLattice(p, sf, uv, iRes);\n    //vec3 col = triLattice(rot2(-3.14159/6.)*p, sf, uv, iRes);\n     \n\n    #ifdef DO_HATCH\n    // A cheap hatch-like pattern, just to give it that extra oldschool look.\n    float hatch = doHatch(oP/gSc, iRes);\n    col *= hatch*.45 + .75;\n    #endif\n  \n    \n    // Spotlight color mixing.\n    //col = mix(col, col.xzy, pow(dot(uv, uv), 1.5)*.35);\n \n  \n    \n    // Applying a subtle silhouette, for art's sake.\n\tuv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05; \n    \n    // Rough gamma correction, then output to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd3XRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd3XW8", "name": "2.2 Igloo", "author": "JHL", "description": "A lovely igloo", "tags": ["3d", "sdf"], "likes": 1, "viewed": 73, "date": "1571855685", "time_retrieved": "2024-06-20T19:47:09.196555", "image_code": "#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n        \n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations, twisting and merging\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nfloat smin(float a, float b){\n    float k = 0.2;\n    float h = clamp((0.5 + 0.5 * (b - a) / k), 0.0, 1.0);\n    return mix(b,a,h) - k * h * (1.0-h);\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat sphere(vec3 pt, float r) {\n    return length(pt) - r;\n}\n\nfloat semisphere(vec3 pt, float r){\n    if (pt.y < 0.0) return 1.0;\n    else return length(pt) - r;\n}\n\nfloat box(vec3 pt, vec3 dim){\n  vec3 d = abs(pt) - dim; // dimensions\n  float val = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n  return val;\n}\n\nfloat cylinder(vec3 pt, float r, float h){\n    if(pt.y < 0.0 || pt.y > h) return 1.0;\n    else return length(pt.xz) - r;\n}\n\nfloat scene(vec3 pt) {\n    return max(smin(smin(\n        \t\tsemisphere(pt - vec3(0,-1,0), 5.0),\n               \tcylinder(pt - vec3(4.5,-1.0,0), 1.0, 2.0)),\n                semisphere(pt - vec3(4.5,1,0), 1.0)),\n               \t-box(pt - vec3(5,0,0), vec3(5,1,0.7))\n              );\n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd3XW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd3Xz8", "name": "大龙猫 - Quicky#018", "author": "totetmatt", "description": "Practicing atan function, then derived to this :D ", "tags": ["quicky"], "likes": 3, "viewed": 242, "date": "1571400172", "time_retrieved": "2024-06-20T19:47:09.196555", "image_code": "mat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat circle(vec2 uv,float r) {\n \n    return smoothstep(r,r+.01,length(uv)-r-.70);\n}\nfloat ring(vec2 uv,float r) {\n    return abs(circle(uv,r)-r);\n}\n\n#define PI 3.141592\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    uv+=vec2(cos(-iTime)/50. ,sin(iTime)/50.);\n    uv*=rot(iTime/20.*(1.+floor(5.* length(uv) * sign(cos(length(uv*4.*PI)))  )));\n      uv+=vec2(cos(iTime)/66. ,sin(-iTime)/66.);\n     vec2 q = vec2(1.0,0.);\n     float d = ring(uv,.25- (fract(6.*PI*smoothstep(2.*-PI,2.*PI, atan(uv.x,uv.y)  ))));\n     vec3 col = mix(vec3(.1),vec3(.9,.5,.2),vec3(d));\n     col.b -=mod(-iTime/50.+smoothstep(2.*-PI,2.*PI, atan(uv.x,uv.y)),.1)*10. ; \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd3Xz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd3XzS", "name": "Audio-Visualizer", "author": "CoolerZ", "description": "A simple shader to visualize audio.", "tags": ["musicaudiovisualizer"], "likes": 3, "viewed": 336, "date": "1572254789", "time_retrieved": "2024-06-20T19:47:09.196555", "image_code": "float sigmoid(float x)\n{\n    return 1. / (1. + exp(x));\n}\n\nvec3 sigmoid(vec3 xyz)\n{\n    return vec3(sigmoid(xyz.x), sigmoid(xyz.y), sigmoid(xyz.z));\n}\n\nfloat sample_at(float f)\n{\n    return texture(iChannel0, vec2(f / 16.0, 0.)).x;\n}\n\nfloat sample_multiple(float f)\n{\n    float delta = .1;\n    return 0.2 * (sample_at(f - 2. * delta) + sample_at(f - delta) + sample_at(f) + sample_at(f + delta) + sample_at(f + 2. * delta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5) / iResolution.xy;\n    uv = 2. * uv - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec2 center = vec2(0.);// 0.5 * vec2(cos(iTime), sin(iTime));\n    float d = length(uv - center);\n\n    float amplitude = sample_multiple(d * d);\n    d -= amplitude;\n    float weird = sigmoid(abs(uv.x) * abs(uv.y));\n    float speed = 6. * amplitude * sin(iTime * weird * 0.005) * 0.001;\n    float dist_diagonal = abs(abs(uv.x) - abs(uv.y));\n    dist_diagonal += d * amplitude;\n    dist_diagonal *= dist_diagonal;\n    amplitude += .1 / (.1 + smoothstep(1., 0.1, dist_diagonal));\n    float brightness = 3. * amplitude * sigmoid(sin(d * d * 16. - speed * iTime + 2. * speed * amplitude));\n\n    vec3 col = sigmoid(vec3(uv, sin(iTime)));\n\n    fragColor = vec4(col * brightness,1.0);\n}", "image_inputs": [{"id": "lts3Wf", "previewfilepath": "https://soundcloud.com/top_knot/feel-the-bass", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/top_knot/feel-the-bass", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd3XzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcGRS", "name": "Snake and sphere", "author": "rgbGuy", "description": "practicing", "tags": ["snakeandsphere"], "likes": 1, "viewed": 66, "date": "1570788793", "time_retrieved": "2024-06-20T19:47:09.560216", "image_code": "#define RADIUS 0.05\n#define RADIUS1 0.3\n\n\nbool InsideSquare(vec2 uv, float radius, vec2 origin)\n{\n    \n    if(uv.y > radius + origin.y || uv.y < -radius + origin.y || uv.x > radius + origin.x || uv.x < -radius + origin.x)\n        return false;\n    else\n        return true; \n}\n\nbool InsideCircle(vec2 uv, float radius, vec2 origin)\n{\n    \n    if(dot(uv,uv) < (radius)*(radius))\n        return true;\n    else\n        return false; \n}\n\nbool InsideCircle1(vec2 uv, float radius, vec2 origin)\n{\n    \n    if(dot(uv,uv) < radius*radius)\n        return true;\n    else\n        return false; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates //shifting the origin to centre\n    //vec2 uv = fragCoord/iResolution.xy + vec2(-0.5,-0.5);\n\tvec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    //uv = vec2(uv.x*1.77, uv.y);\n    fragColor = vec4(uv.y + 0.1 ,0.0,uv.y + 0.2,1.0);\n    \n    \n    vec2 origin = vec2(0.0,0.0);\n    if(InsideCircle(uv, RADIUS1, origin))\n    {\n        //uv = uv - vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y);\n        float pointDistanceFromOrigin = dot(uv,uv);\n        pointDistanceFromOrigin = pointDistanceFromOrigin/RADIUS1;\n        \n        //fragColor = vec4((uv.y)*1.50 + 0.70, 0.0, 0.0 ,0.50); //sunset\n        fragColor = vec4(1.0-dot(uv,uv)/(RADIUS1*RADIUS1),\n            0.0, 0.0, 1.0); //gradient effect\n\n    }\n    \n    for(int i = 0; i < 15; i ++)\n    {\n    \tvec2 origin = vec2(sin(iTime + float(i))/10.0, cos(iTime)/8.0) + vec2(float(i)/40.0,float(i)/20.0); //centre of the square\n    \t\n    \torigin = origin - vec2(0.5,0.5);\n    \tif(InsideSquare(uv, RADIUS, origin))\n    \t{\n       \t\tfragColor = vec4(float(i)/20.0, float(i)/20.0, 0.0 ,1.0);\n\t\n    \t}\n\n    \t    \n    }\n    \n\n\n\n    \n    \n    // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcGRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdcSDH", "name": "A wobbler", "author": "tiggerbiggo", "description": "description", "tags": ["2d"], "likes": 1, "viewed": 160, "date": "1571848294", "time_retrieved": "2024-06-20T19:47:09.560216", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= 5.;\n    uv.x += sin(iTime*0.1)*5.;\n    uv.y += cos(iTime*0.2332)*5.;\n    \n    uv *= cos(uv+(0.3*iTime))+sin(iTime+uv)+2.;\n    \n    \n    vec2 grid = floor(uv*4.);\n    grid *= .1;\n    \n    \n    float dist = length(uv+(grid.x*grid.y));//length(mod(uv, 1.)-.5)+sin(grid.x*iTime*3.)+cos(grid.y*iTime);\n    \n    // Output to screen\n    fragColor = vec4(sin(iTime),cos(sin(dist*6.)*fract(iTime+dist))-.3,sin(dist*fract(dist+iTime*.3)*.3),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdcSDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcSDn", "name": "tomcilo GOD LIKE DOMINATION", "author": "tomcilo", "description": "Some desc", "tags": ["sdf", "supervision"], "likes": 0, "viewed": 59, "date": "1571760294", "time_retrieved": "2024-06-20T19:47:10.954338", "image_code": "#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\n/* sphere centred at 0, with radius r */\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/* cube centred at 0, parallel to xyz axis, with side length 2a */\nfloat cube(vec3 p, float a) {\n    return max(abs(p.x), max(abs(p.y), abs(p.z))) - a;\n}\n\n/* cylinder along x axis, with radius r */\nfloat cylinder_x(vec3 p, float r) {\n\treturn length(vec2(p.y, p.z)) - r;\n}\n\n/* cylinder along x axis, with radius r, x coordinate [0, l] */\nfloat bounded_cylinder_x(vec3 p, float r, float l) {\n\treturn max(cylinder_x(p, r), cube(vec3(p.x - l / 2.0, 0, 0), l / 2.0));\n}\n\n/* vertical cone, with peak at 0 pointing upwards, with radius r at depth 1 and with height h*/\nfloat one_bounded_cone_y(vec3 p, float r, float h) {\n\tfloat dist = length(vec2(p.x, p.z));\n\n    return max(\n        (r * p.y + dist) / (r * r + 1.0),\n        cube(vec3(0.0, p.y + h / 2.0, 0.0), h / 2.0)\n    );\n}\n\n/*\n * R  - radius of outer sphere\n * r  - radius of inner sphere\n *\n * l  - lenght of entry (measured from the center, assumed to be greater than R\n * Re - outer radius of entry\n * re - inner radius of entry\n */\nfloat igloo(vec3 p, float R, float r, float l, float Re, float re) {\n    return\n        max(\n        \tmax(\n                max(\n                \tmin(\n               \t    \tsphere(p, R),\n                    \tbounded_cylinder_x(p, Re, l)\n                \t),\n\t\t\t\t\t-bounded_cylinder_x(p, re, l + 0.1)\n                ),\n                -sphere(p, r)\n            ),\n            -cube(vec3(p.x, p.y + l, p.z), l + 0.1)\n        );\n}\n\nvec3 cross_prod(vec3 a, vec3 b) {\n\treturn vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}\n\nfloat scalar_prod(vec3 a, vec3 b) {\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\n/* returns halfspace determined by the plane abc, that contains d*/\nfloat halfspace(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d) {\n\tvec3 n = cross_prod(b - a, c - a);\n    if (scalar_prod(n, d - a) > 0.0)\n        n = -1.0 * n;\n    return scalar_prod(n, p - a) / length(n);\n\n}\n\n/* r - inner radius\n * w - offset\n * h - height\n * t - twisting factor\n */\nfloat corkscrew(vec3 p, float r, float w, float h, float t) {\n    float theta = t * p.y;\n//    float _x = (p.x) * cos(p.y) + p.z * sin(p.y);\n//    float _y =-(p.x) * sin(p.y) + p.z * cos(p.y);\n    float _x = p.x + sin(t * p.y);\n    float _y = p.z + cos(t * p.y);\n\treturn bounded_cylinder_x(vec3(p.y + h, _x, _y), r, 2.0 * h) / 1.2;\n}\n\n/* returns tetrahedron determined by its 4 vertices */\nfloat tetrahedron(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d) {\n\treturn\n        max(\n        \tmax(\n\t\t\t\thalfspace(p, a, b, c, d),\n\t\t\t\thalfspace(p, b, c, d, a)\n            ),\n            max(\n\t\t\t\thalfspace(p, c, d, a, b),\n\t\t\t\thalfspace(p, d, a, b, c)\n            )\n        );\n}\n\nfloat scene1(vec3 p) {\n    return one_bounded_cone_y(vec3(p.x, p.y - 1.0, p.z), 0.7, 3.0);\n}\nfloat scene2(vec3 p) {\n\treturn igloo(vec3(p.x, p.y - 1.0, p.z),\n    \t2.0,  // R\n        1.75, // r\n        2.5,  // l\n        1.0,  // Re\n        0.75);// re\n}\nfloat scene3(vec3 p) {\n\treturn tetrahedron(p,\n    \tvec3(-1.0, -1.0, -1.0),\n    \tvec3(-1.0, 1.0, 1.0),\n    \tvec3(1.0, 1.0, -1.0),\n    \tvec3(1.0, -1.0, 1.0));\n}\n\nfloat scene4(vec3 p) {\n\treturn corkscrew(p,\n                     1.1,  // r\n                     1.0,  // w\n                     3.0,  // h\n                     3.0); // t\n}\n\nfloat scene(vec3 p) {\n    // Change this to sceneN for N <- {1, 2, 3, 4}\n    return scene4(p);\n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt);\n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n\n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n\n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n\n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n\n\n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n\n    vec3 color = castRay(origin, direction);\n\n    fragColor = vec4(color, 0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcSDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcSW7", "name": "Multiple SineLines", "author": "dalp", "description": "I can't get out of the 90s, send help.", "tags": ["sinewaves"], "likes": 11, "viewed": 175, "date": "1572124670", "time_retrieved": "2024-06-20T19:47:10.954338", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nvec3 getline (in vec2 uv, in float offs, in float t) {\n    float ti = t*.5;\n    uv.y = uv.y + sin(ti+uv.x+(offs*0.32)*cos(ti*1.3+sin(uv.y-uv.x*.85)))*2.;\n    return S(0.08,0.001, distance(uv.y, 0.))*vec3(.4,.7,.9)*S(0.8,0.1,mod((uv.x*.1+(offs*.1))+t,2.)-1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 ms = iMouse.xy/iResolution.xy;\n    float  t = iTime+(2.*ms.x)+(.5*ms.y);\n\tuv *= 5.;\n    \n    vec3 col = vec3 (0.);\n    for (float i=0.;i<=16.;i++) {\n        col += getline(uv,i+3.2,t);\n    }    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcSW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcSWM", "name": "/\\_/\\/\\_/\\/\\/\\_/\\_/\\/\\/\\/\\", "author": "ChrisFeline", "description": "Just testing... :)", "tags": ["noise"], "likes": 3, "viewed": 71, "date": "1572094640", "time_retrieved": "2024-06-20T19:47:10.954338", "image_code": "// RANDOM 2D\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    return mix(hash(i), hash(i + 1.0), f);\n}\n\n#define COLOR1 vec3(41.0, 53.0, 58.0)\n#define COLOR2 vec3(30.0, 38.0, 43.0)\n#define COLOR3 vec3(23.0, 31.0, 34.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    uv.y *= 2.;\n    uv.y -= 0.5;\n    \n    col = mix(COLOR1 / 255.0, col, step(noise((uv.x + iTime * 0.1) * 10.) * 0.2,uv.y - 0.7));\n    col = mix(COLOR2 / 255.0, col, step(noise((uv.x + iTime * 0.05) * 13.) * 0.2,uv.y - 0.5));\n    col = mix(COLOR3 / 255.0, col, step(noise((uv.x + iTime * -0.05) * 15.) * 0.2,uv.y - 0.3));\n    col = mix(vec3(0.0), col, step(noise((uv.x + iTime * -0.1) * 18.) * 0.2,uv.y - 0.1));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcSWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcSzn", "name": "pixelatedcircle", "author": "scry", "description": "variable resolution can be fun but I didn't expect a 3d effect! ", "tags": ["2d"], "likes": 11, "viewed": 298, "date": "1571350563", "time_retrieved": "2024-06-20T19:47:10.954338", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0.);\n    vec2 p = vec2(0.);\n    //uv = floor(uv*120.)/120.;\n    //float steps = abs(sin(iTime*0.1)*16.)+4.;\n    float steps = 32. + sin(iTime*0.1)*31.;\n    //float steps = 64.;\n    float s = iTime*01.25;\n    for (float i;i<steps;i++) {\n        float ii = i*02.102/steps;\n        p = vec2(sin(s+ii),cos(s+ii))*(0.3+sin((s+ii)*8.)*0.1);\n        ii = ii*ii*15.;\n        //ii += 40.;\n        //ii = ii*20.;\n        //ii = (steps*3.)-ii;\n        vec2 pv = floor(uv*ii)/ii;\n    \tif (length(pv+p) < 0.1*(i/steps)) {\n            col = vec3(i/(steps-1.));\n            col = col*col*col;\n        \t//col = vec3((i/steps)+(.025));\n        }\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcSzr", "name": "Golden flow 3", "author": "pik33", "description": "A friend asked me to make a golden shader avoiding black. This time using float loop with multiply instead of add", "tags": ["plasma", "flow"], "likes": 15, "viewed": 371, "date": "1571305517", "time_retrieved": "2024-06-20T19:47:10.954338", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=7.0*(fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x,iResolution.y);\n\t\n\tfor(float i=1.0;i<40.0;i*=1.1)\n\t{\n\t\tvec2 o=q;\n\t\to.x+=(0.5/i)*cos(i*q.y+iTime*0.297+0.03*i)+1.3;\t\t\n\t\to.y+=(0.5/i)*cos(i*q.x+iTime*0.414+0.03*(i+10.0))+1.9;\n\t\tq=o;\n\t}\n\n\tvec3 col=vec3(0.5*sin(3.0*q.x)+0.5,0.5*sin(3.0*q.y)+0.5,sin(1.3*q.x+1.7*q.y));\n    float f=0.43*(col.x+col.y+col.z);\n\n\tfragColor=vec4(f+0.6,0.2+0.75*f,0.2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcSzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdcXDH", "name": "2.1 Cone", "author": "JHL", "description": "A cone centered at the origin, with radius r and height h, pointing towards the positive y-axis.", "tags": ["2d"], "likes": 1, "viewed": 59, "date": "1571851729", "time_retrieved": "2024-06-20T19:47:11.717994", "image_code": "#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat sphere(vec3 pt, float r) {\n    return length(pt) - r;\n}\n\nfloat cone(vec3 pt, float r, float h){\n    float dist = length(pt.xz);\n    float r_dash = r - r * pt.y / h; \n\tif (pt.y < 0.0) return 1.0;\n    else if (pt.y > h) return length(pt - vec3(0,h,0));\n    else return dist - r_dash;\n}\n\nfloat scene(vec3 pt) {\n    return cone(pt - vec3(0,-2,0), 2.0, 4.0);\n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdcXDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdcXDN", "name": "igloo", "author": "roberthoenig", "description": "igloo", "tags": ["igloo"], "likes": 0, "viewed": 66, "date": "1571946514", "time_retrieved": "2024-06-20T19:47:12.578669", "image_code": "#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cone(vec3 p, float angle) {\n \treturn length(p.xz) * cos(angle) - p.y * sin(angle);\n}\n\nfloat cube(vec3 p, float r) {\n    p = abs(p);\n \treturn max(p.x, max(p.y, p.z)) - r;\n}\n\nfloat cylinder(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat igloo_dense(vec3 p) {\n    return max(\n        min(sphere(p, 2.0),\n            max(\n                cube(p - vec3(2.5, 0, 0), 1.0),\n                cylinder(p.yxz, 1.0)\n            )\n           ),\n        cube(p - vec3(0, 10, 0), 10.0)\n    );\n}\n\nfloat scene(vec3 p) {\n    return igloo_dense(p);\n\n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdcXDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcXR4", "name": "Cloudy day", "author": "DustinTeWind", "description": "Just playing with perlin noise while learning shaders and I happened upon something that looked like clouds. \n\ncloudscape is moveable with mouse position", "tags": ["2d", "noise", "clouds", "perlin"], "likes": 2, "viewed": 112, "date": "1571532238", "time_retrieved": "2024-06-20T19:47:13.021102", "image_code": "// FORKED perlin algorithm from user 'madweedfall'\n\nconst int firstOctave = 3;\nconst int octaves = 8;\nconst float persistence = 0.6;\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo - 'madweedfall'\n//\n//https://www.shadertoy.com/view/Mls3RS - 'madweedfall'\n//\n//And it is a better realization I think - 'madweedfall'\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency + iTime * 0.1,y*frequency + iTime * 0.25)*amplitude;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float x = uv.x * 4.0 + iMouse.x/60.0 + iTime*0.05;\n    float y = uv.y * 4.0  + iMouse.y/60.0;\n    \n    float x2 = uv.x * 2.0 + iMouse.x/120.0  + iTime*0.05 + 0.5;\n    float y2 = uv.y * 2.0  + iMouse.y/120.0 + 0.5;\n    \n    \n    float noise = 0.6+1.5*PerlinNoise2D(x,y);\n    float secNoise = 0.6+2.0*PerlinNoise2D(x2,y2);\n    \n    noise = smoothstep(0.2,0.7, noise);\n    secNoise = smoothstep(0.2,0.7, secNoise);\n    \n    vec3 col = mix(vec3(1,1,1), vec3(0.2,0.54,0.95), noise*secNoise);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcXR8", "name": "Supervision 1 Work", "author": "gcorso", "description": "SDF exercise", "tags": ["sdf"], "likes": 1, "viewed": 54, "date": "1571575969", "time_retrieved": "2024-06-20T19:47:14.142484", "image_code": "#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat cone(vec3 p, vec3 o, float r, float h) {\n    if(dot(o, p)<0.0){\n    \tfloat v_d = -dot(o,p);\n        float h_d = max(length(p + v_d*o)-r, 0.0);\n        return sqrt(h_d*h_d+v_d*v_d);\n    } else {\n    \tvec3 H = o*h;\n        vec3 R = normalize(p - dot(p,o)*o)*r;\n        if(dot(H-R, p-R) < 0.0) return length(p-R);\n        if(dot(R-H, p-H) < 0.0) return length(p-H);\n        return length(cross(H-p, R-p))/length(R-H);\n    }\n}\n\nfloat hemisphere(vec3 p, vec3 up, float r){\n\tif(dot(up, p)<0.0){\n    \tfloat v_d = -dot(up,p);\n        float h_d = max(length(p + v_d*up)-r, 0.0);\n        return sqrt(h_d*h_d+v_d*v_d);\n    } else {\n    \treturn length(p)-r;\n    }\n}\n\nfloat semicylinder(vec3 p, vec3 axis, vec3 up, float radius, float height){\n    if(dot(up, p)<0.0){\n        float vertical = -dot(up, p);\n        vec3 rem = p +vertical*up;\n        float horizontal = max(max(-dot(rem, axis), dot(rem, axis)-height), \n                               abs(dot(cross(up,axis), rem))-radius);\n        return sqrt(vertical*vertical+horizontal*horizontal);\n\t} else {\n        if(dot(axis, p)<0.0){\n        \treturn max(-dot(axis, p), length(p-dot(axis, p)*axis)-radius);\n        } else if(dot(axis, p)>height){\n            return max(dot(axis, p)-height, length(p-dot(axis, p)*axis)-radius);\n        } else {\n            return length(p-dot(axis, p)*axis)-radius;\n        }\n    }\n}\n\nfloat igloo(vec3 p, vec3 up, vec3 front, float R, float r, float door_R, float door_r){\n    return max(min(hemisphere(p,up,R), semicylinder(p-2.0*front, front, up, door_R, 2.5*(R-r))), \n               -min(hemisphere(p,up,r), semicylinder(p-2.0*front, front, up, door_r, 2.5*(R-r))));\n}\n\n\nfloat tetrahedron(vec3 p, vec3 v[4]){\n   \tfloat min_signed_dist = 1e10;\n    \n    for(int i = 0; i<4; i++){\n        vec3 perp = normalize(cross(v[(i+1)%4]-v[i], v[(i+2)%4]-v[i]));\n        if(dot(perp, v[(i+3)%4]-v[i])<0.0) perp = -perp;\n        \n        float dist = dot(perp, p-v[i]);\n        min_signed_dist = min(min_signed_dist, dist);\n    }\n    return min_signed_dist;\n}\n\n\nfloat cylinderY(vec3 p, vec3 c, float r){\n   \tp = p-c;\n    return length(p.xz)-r;\n}\n\nfloat spiralY(vec3 p, vec3 c, float r){\n    //p.x = p.x-2.0;\n    return cylinderY(vec3(p.x*cos(p.y*2.0)-p.z*sin(p.y*2.0), \n                          p.y, p.x*sin(p.y*2.0)+p.z*cos(p.y*2.0)), \n                     vec3(1.0,0.0,0.0), r);\n}\n    \n\n\n\nfloat scene(vec3 p) {\n    \n    //return cone(p, vec3(1.0,0.0,0.0), 2.0, 3.0);\n    /*vec3 t[4];\n    t[0] = 2.5*vec3(1.0,0.0,0.0);\n    t[1] = 2.5*vec3(1.0,1.5,0.0);\n    t[2] = 2.5*vec3(-1.0,1.0,0.0);\n    t[3] = 2.5*vec3(1.0,1.0,1.0);\n    return tetrahedron(p, t);*/\n    //return igloo(p, vec3(0.0,1.0,0.0), vec3(1.0,0.0,0.0), 3.0, 2.5, 1.5, 1.0);\n    //return semicylinder(p, vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), 2.0, 3.0);\n    \n    return spiralY(p, vec3(1.0,0.0,0.0), 0.4);\n    \n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcXR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcXRj", "name": "DVD screensaver", "author": "z0rg", "description": "An idea I had in mind for a long time :)", "tags": ["2d", "retro", "sdf"], "likes": 8, "viewed": 374, "date": "1572341123", "time_retrieved": "2024-06-20T19:47:14.985565", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec2 rot2D(vec2 v, float a)\n{\n  float cosa=cos(a);float sina=sin(a);\n  mat2 rot = mat2(cosa,-sina,sina,cosa);\n  return v*rot;\n}\n\nfloat sat(float a)\n{\n  return clamp(a,0.0,1.0);\n}\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nint imod(int a, int b)\n{\n  int res = a/b;\n  return a-(res*b);\n}\n\n// SDF operations\nfloat _union(float a, float b)\n{\n  return min(a, b);\n}\nfloat _sub(float a, float b)\n{\n  return max(-a,b);\n}\n\n// SDF functions\nfloat sdf_rect(vec2 uv, vec2 sz)\n{\n  vec2 r = abs(uv)-sz;\n  return max(r.x,r.y);\n}\n\nfloat sdf_cir(vec2 uv, float r, float thick)\n{\n  float li = length(uv)-r;\n  float lo = li-thick;\n  return _sub(li,lo);\n}\n\nfloat sdf_plaind(vec2 uv)\n{\n  float left = uv.x;\n  return _sub(left, sdf_cir(uv*vec2(.6,1.), -1.,1.075));\n}\n\nfloat sdf_v(vec2 uv)\n{\n  float res;\n  float widthUp = 0.085;\n  float pxu = 0.15;\n  res = sdf_rect(uv-vec2(-pxu,0.089), vec2(widthUp,0.018));\n  res = _union(res, sdf_rect(uv-vec2(pxu-0.02,0.089), vec2(widthUp-0.02,0.018)));\n  res = _union(res, sdf_rect(rot2D(uv-vec2(-0.04,0.0005),1.1), vec2(0.1,0.025)));\n  res = _union(res, sdf_rect(rot2D(uv-vec2(0.04,0.0005),-1.1), vec2(0.1,0.025)));\n  return res;\n}\n\nfloat sdf_d(vec2 uv)\n{\n  float res = _sub(sdf_plaind(vec2(0.9,1.)*uv+vec2(0.05,0.)),sdf_plaind(uv*vec2(0.9,0.7)));\n\n  res = _union(res, sdf_rect(uv-vec2(-0.015,0.089), vec2(0.03,0.018)));\n  res = _union(res, sdf_rect(uv-vec2(-0.015,-0.089), vec2(0.03,0.018)));\n  res = _union(res, sdf_rect(uv-vec2(-0.025,-0.02), vec2(0.02,0.07)));\n  return res;\n}\n\nvec2 myPixel(vec2 uv, vec2 sz)\n{\n  vec2 tmp = uv / sz;\n\n  uv.x = float(int(tmp.x));\n  uv.y = float(int(tmp.y));\n  return uv*sz;\n}\n\nfloat rdrDVDtxt(vec2 uv)\n{\n  float blurMax = 200.;\n  float blur = 0.02;\n  float realBlur = mix(blurMax,0.,blur);\n\n  float res=sdf_v(uv);\n  res = _union(sdf_d(uv-vec2(-0.25,0.)),sdf_v(uv));\n  res = _union(res, sdf_d(uv-vec2(0.17,0.)));\n\n  if (res<0.)\n    return 0.;\n  return sat(1.-(res/blur));\n}\n\n\nvec3 rdrDvd(vec2 uv)\n{\n  float inC = float(length(uv*vec2(1.,1.5))<0.2);\n  float lVid = length(uv*vec2(.9,4.5)*2.+vec2(0.,0.49));\n  float cVid = (1.-sat((lVid-0.2)*5.));\n  float DVDtxt = rdrDVDtxt(uv*2.-vec2(0.,0.02));\n  return (vec3(1.)*inC-cVid*.5)-vec3(DVDtxt);\n}\nconst float PI = 3.141592653927;\nvec3 rdr(vec2 uv)\n{\n  vec2 pos;\n  vec3 col[4];\n\n  col[0] = vec3(0.897,0.31,0.21);\n  col[1] = vec3(0.897,0.31,0.21).xzy;\n  col[2] = vec3(0.897,0.31,0.21).yzx;\n  col[3] = vec3(0.1,0.897,0.21);\n\n  pos.x = asin(sin(iTime))*0.5;\n  bool isUpX = pos.x > asin(sin(iTime+0.01))*0.5;\n  pos.y = asin(sin(2.*iTime+PI))*0.25;\n  bool isUpY = pos.y < asin(sin(2.*iTime+PI+0.01))*0.25;\n  int colIdx = int(isUpX)+(isUpY ? 1 : 2);\n  return rdrDvd(uv-pos)*col[imod(colIdx,4)];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  vec2 center = vec2(0.5)*iResolution.xy/iResolution.xx;\n  uv = uv - center;\n  uv = uv *2.;\n  vec3 col;\n  uv = myPixel(uv-vec2(2.), vec2(0.01))+vec2(2.); // minus then plus offset to avoid mod fail around 0\n  col = rdr(uv);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcXRn", "name": "Blinn Phong Shading Model", "author": "rishipandey125", "description": "First GLSL project. Implemented a basic Blinn Phong Shading Model. Building my skills in GLSL and Shaders to further understand CG in Film/Animation.", "tags": ["phong"], "likes": 3, "viewed": 1022, "date": "1571285864", "time_retrieved": "2024-06-20T19:47:14.986570", "image_code": "vec3 background(vec3 rd) {\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));//sky gradient\n\tvec3 sky_color = vec3(0.5,0.8,1.0);//sky color\n\treturn pow(sky, 1.0)*sky_color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(.6);\n    vec2 cord = fragCoord/iResolution.xy;\n    vec3 center = vec3(0.5,0.5,5.0);\n    float radius = 0.3;\n    float aspect_ratio = iResolution.x/iResolution.y;\n    cord.x *= aspect_ratio;\n    center.x *= aspect_ratio;\n    if (length(cord-vec2(center.x,center.y)) <= radius) {\n      color = vec3(0.8,0.3,1);\n      vec3 camera = vec3(0.5,0.5,0);\n      vec3 point_light = vec3(10.0*sin(iTime*0.5),5.0,-1);\n      float z = center.z - sqrt(pow(radius,2.0)-pow(cord.y-center.y,2.0));\n      vec3 curr = vec3(cord,z);\n      vec3 normal = normalize(curr-center);\n      vec3 light = normalize(point_light-curr);\n      vec3 view = normalize(camera-curr);\n      vec3 h = normalize(light+view);\n      vec3 ambient = .1*color;\n      vec3 diffuse = vec3(max(dot(normal,light),0.0));\n      vec3 specular = vec3(max(0.2*pow(dot(normal,h),200.0),0.0));\n      color *= ambient+diffuse+specular;\n    } else {\n      color = background(vec3(cord,0));\n    }\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcXRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdcXRr", "name": "ShaderTober - Overgrown", "author": "Flopine", "description": "A small doodle with inktober's theme \"Overgrown\"", "tags": ["raymarching", "plant", "vines", "inktober"], "likes": 15, "viewed": 233, "date": "1571263289", "time_retrieved": "2024-06-20T19:47:15.754392", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 64.\n#define PI 3.141592\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat hash11 (float x)\n{return fract(sin(x)*124.5);}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    float id = floor(a/per);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id)>= rep/2.) id = abs(id);\n    return id;\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat leaf (vec3 p)\n{\n    p.xz *= rot(PI);\n    p.y += sin((p.x+3.5)*1.5)*0.5;\n    return box(p, vec3(1.5,0.01+p.x*0.02,0.28+sin(p.x*2.)*0.3));\n}\n\nfloat vine (vec3 p)\n{\n    float c = cyl(p.xz,0.5);\n   \n    p.y = mod(p.y, 3.)-3.*0.5;\n    moda(p.xz, 3.);\n    p.x -= 2.;\n    \n    return stmin(c,leaf(p),0.3, 3.);\n}\n\nfloat s_id;\nfloat sprout (vec3 p)\n{\n\tp.xz *= rot(iTime*0.2);\n    p.xz *= rot(p.y*0.5);\n    s_id = moda(p.xz, 7.);\n    p.x -= .8+sin(p.y+iTime)*0.3;\n    return vine(p);\n}\n\nfloat SDF (vec3 p)\n{\n    p.y += iTime*0.5; \n    return sprout(p);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(SDF(p)- vec3(SDF(p-eps.xyy), SDF(p-eps.yxy), SDF(p-eps.yyx)));\n}\n\nfloat dir_light (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.001,-1.5,-4.),\n        p = ro,\n        rd = getcam(ro, vec3(0.,0.8,0.), uv),\n        l = vec3(2.,0.,.5),\n        col = vec3(0.,0.3-uv.y*0.2,0.5);\n    \n    bool hit = false;\n    float shad = 0.;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        \n        p+=d*rd*0.5;\n    }\n    \n    float t = length(ro-p);\n    \n   \tif (hit)\n    {\n        vec3 n = getnorm(p);\n        vec3 v_col = vec3(hash11(s_id)*0.8,1.,hash11(s_id+0.5));\n        col = mix(vec3(0.,0.1,0.3), v_col, clamp(dir_light(n,l),0.,1.));\n        col *= 1.-shad;\n    }\n   \tvec3 back_col = mix(vec3(0.,0.3-uv.y*0.2,0.5), \n                        vec3(0.8,0.8,0.9), \n                        texNoise(uv*0.03+vec2(0.,iTime*0.004)).g*0.8);\n    col = mix(col,back_col, 1.-exp(-0.03*t*t));\n    \n    // vignetting (from iq)\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.7);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdcXRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdcXzl", "name": "neuro_test", "author": "neur0sys", "description": "test", "tags": ["test"], "likes": 1, "viewed": 50, "date": "1572561895", "time_retrieved": "2024-06-20T19:47:16.209242", "image_code": "#define NUM 500\n#define SPRITE_SIZ 1.0f\n#define W 640.0f\n#define H 400.0f\n\nvec2 virt_scale(vec2 p)\n{\n\tp.x = float(int(p.x * W)) / W;\n    p.y = float(int(p.y * H)) / H;   \n    \n    return p;\n}\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Scale to nearest multiple virtual-screen resolution\n    uv = virt_scale(uv);\n    \n\tvec2 ps = SPRITE_SIZ / vec2(W, H);\n    vec4 c = texture(iChannel1, uv) * 0.3f;\n    \n    vec2 pb1 = vec2(iTime * 1.2f, iTime * -1.2f);\n    vec2 pb2 = vec2(iTime * 1.4f, iTime * 1.4f);\n    \n    for (int i = 0; i < NUM; i++) {\n        float x1 = cos(pb1.x) + sin(pb1.y);\n        float y1 = cos(pb2.x) + sin(pb2.y);\n        \n        vec2 pt = vec2(x1 / 6.0f + 0.5f, y1 / 6.0f + 0.5f);\n\n        pt = virt_scale(pt);\n        \n        if (uv.x >= pt.x && uv.x <= pt.x + ps.x &&\n            uv.y >= pt.y && uv.y <= pt.y + ps.y) {\n            vec2 uv1 = (pt - uv) / -ps;\n            //c = texture(iChannel0, uv1);\n            c = vec4(hsl2rgb(vec3(float(i) / float(NUM), 1.0f, 0.5f)), 1.0f);\n        }\n\n        pb1 += vec2(0.7f, 0.6f);\n        pb2 -= vec2(0.4f, 0.3f);\n    }\n\n    fragColor = c;\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdcXzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdd3DX", "name": "Geometric Grid Pattern", "author": "Shane", "description": "An ordered geometric grid pattern.", "tags": ["2d", "grid", "box", "geometry", "pattern", "cell", "art"], "likes": 23, "viewed": 584, "date": "1570977767", "time_retrieved": "2024-06-20T19:47:17.421520", "image_code": "/*\n\t\n\tGeometric Grid Pattern\n\t----------------------\n\n\tI have a lot of grid pattern examples lying around. They're not exactly cutting edge, \n    but I find them quick to construct and visually interesting, which makes them suitable \n    texture add-ins for 3D scenes, or to provide the basis for the geometry itself.\n\n  \tI see patterns that follow this particular rectangular strip concept all the time, but \n    usually in the form of randomly rotated cell segments. This version consists of 4 by 4 \n    cell blocks that have been rotated in a specific predetermined order, in accordance with \n    array pattern entries. I'd imagine people could code this up without too much hassle, \n    and probably in more efficient ways, but for anyone interested, the workings and \n    explanation are below. I've kept the code reasonably short.\n\n\n\tOther Examples:\n\n    // Using simple square geometry to great effect.\n\tTruchet variation - XT95\n    https://www.shadertoy.com/view/llfBWB\n\n    // Flyguy has a lot of clean but interestig exapmles.\n\tMaterial Design Pattern  - FlyGuy\n\thttps://www.shadertoy.com/view/XsySWc\n\n\t// Clever.\n    Escher-like tiling (255 chars) - FabriceNeyret2  \n    https://www.shadertoy.com/view/4dVGzd\n\n*/\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// This renders a horizontal or vertical box-line from point \"a\" to point \"b,\" with a line \n// width of \"w.\" It's different to the the usual line formula because it doesn't render the \n// rounded caps on the end -- Sometimes, you don't want those. It utilizes IQ's box formula \n// and was put together in a hurry, so I'd imagine there are more efficient ways to do the \n// same, but it gets the job done. I put together a more generalized angular line formula as \n// well.\nfloat lBoxHV(vec2 p, vec2 a, vec2 b, float w){\n    \n   vec2 l = abs(b - a); // Box-line length.\n   p -= vec2(mix(a.x, b.x, .5), mix(a.y, b.y, .5)); // Positioning the box center.\n   \n   // Applying the above to IQ's box distance formula.\n   vec2 d = abs(p) - (l + w)/2.; \n   return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\n// Number of bar lines. As you can see from the imagery, there are five. Different numbers are\n// interesting, but numbers in this range obviously visualize better.\n#define N 5\nconst float Nf = float(N);\n\nvec3 distField(vec2 p){\n    \n    vec2 ip = floor(p); // Cell ID.\n    p -= ip + .5; // Centered local coordinates.\n   \n    // A lot of grid patterns are formed by rendering specific patterns in cells, then\n    // randomly rotating them -- Truchets are a good example. Others can be formed by rotating\n    // patterns according to a simple formula, like rotating alternate checkered cells. Others, \n    // however, need to be rotated according to specific sequence that might not be as easy to\n    // define with a simple formula, in which case it makes more sense to simply hardcode them,\n    // so that's what is happening here. Each 4x4 cell block is rotated according to the 4x4\n    // cell block sequence below.\n    // \n    // In this case, you could use a mat4, if you wanted, but the following is a little more \n    // readable, and can be extended to include any \"N x M\" arrangement.\n    float ad[16] = float[16](3., 0., 1., 0.,\n                             0., 3., 0., 1.,\n                             3., 2., 1., 2.,\n                             2., 3., 2., 1.);\n    \n    // Rotate the local grid coordinates according to the 4x4 sequence above. For instance, the\n    // second cell on the third row has a value of \"2,\" which results in 2 90-degree rotations.\n    // The cell to the right of it has a value of \"1,\" so will result in 1 90-degree rotation.\n    int index = int(floor(mod(ip.x, 4.) + mod(4. - ip.y, 4.)*4.));\n    float cID = ad[index];\n    \n    // Rotate the cell by multiples of 90 degrees, according to the 4x4 cell block array above.\n    p = rot2(cID*3.14159/2.)*p;\n     \n    // Line width, cell object (box-line) ID, and box-line distance value.\n    float w = 1./Nf, bID = -1., d = 1e5;\n    \n    // Render a series of bar-graph vertical lines that shorten with increasing X-value across\n    // the cell, then fill in the rest of the space with the equivalent horizontal lines. Refer to \n    // the imagery to get a better idea. By the way, I've been doing this for years, and nothing \n    // below require math skills beyond grade school, yet I never get it right the first time. Sigh. :)\n    for(int i = 0; i<N; i++){\n        \n        float fi = float(i);\n        \n        // Vertical and horizontal bar-graph like boxs of width \"w.\" \n        float vBox = lBoxHV(p, vec2(-.5 + w/2. + fi*w, -.5 + w/2.), vec2(-.5 + w/2. + fi*w, .5 - w/2. - fi*w), w);\n        float hBox = lBoxHV(p, vec2(-.5 + w/2. + (fi + 1.)*w, .5 - w/2. - fi*w), vec2(.5 - w/2., .5 - w/2. - fi*w), w);\n       \n        // Give the individual vertical and horizontal boxes their own unique ID (not to be confused\n        // with the overall individual cell ID). These will be used later to shade and color the \n        // box lines. Again, refer to the imagery.\n        if(vBox<d){ d = vBox; bID = fi; }\n        if(hBox<d && i<N - 1){ d = hBox; bID = fi + Nf; }\n         \n    } \n     \n    // Return the object distance, cell ID and individual cell object ID.\n    return vec3(d, cID, bID);\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Scaling and translation.\n    float gSc = 6.;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = uv*gSc - vec2(-.5, -.25)*iTime;\n    \n    // Smoothing factor -- based on the resolution and global scaling factor.\n    float sf = gSc/iRes;\n\n\n    // The distance field. It returns the block \n    vec3 d = distField(p);\n    \n    // Record the individual cell ID and the ID of the individual object \n    // within the cell.\n    float cID = d.y;\n    float bID = d.z;\n    \n    \n    // Shade and color the cell contents, according to the cell object ID.\n    //\n    // Shade: Outer horizontal and vertical bars are lighter.\n    float idSh = (Nf - 1. - mod(bID, Nf))/(Nf - 1.); \n    // Color, which is reliant on shade, meaning uter horizontal and vertical bars will\n    // have lighter palette (a fiery variation) colors.\n    vec3 dCol = pow(min(vec3(1.35, 1.02, 1)*mix(.3, .925, idSh), 1.), vec3(1, 2.25, 8.));\n    \n    // A blue-flame shaded complimentary color to the above.\n    vec3 shCol = mix(dCol, dCol.zyx, .9); // Mixing in just a touch of the original color\n\n    // Use the cell ID and cell object ID to apply the blue shaded color.\n    //\n    // Top left, X, sans frame.\n    if(bID>.5 && bID<(Nf - .5) && mod(cID, 4.)==2.) dCol = shCol;\n    // Top right, X and Y, sans frame.\n    if(bID!=0. && bID!=Nf && mod(cID, 4.)==3.) dCol = shCol;\n    // Bottom right, Y, sans frame.\n    if(bID>(Nf + .5) && mod(cID, 0.)==0.) dCol = shCol;\n    \n    \n    /*\n    // The palette color provides the depth, but you can apply extra depth, if desired.\n    vec2 q = rot2(svID*3.14159/2.)*p;\n    q = fract(q) - .5;\n    float lDist = max(1. - length(q - vec2(-.5, .5).yx), 0.);\n    float sh = 1./(1. + lDist*lDist*4.);\n    dCol = min(dCol*sh*1.25, 1.);\n    */\n    \n    \n    // Render the cell contents: I.e. The individually colored and shaded bar-graph lines. The \n    // \"sqrt(450./iRes)\" term is just a hack to give the dark lines around the borders some \n    // consistency with resolution changes. Catering to canvas size changes is almost futile. :)\n    vec3 col = mix(vec3(0), dCol, 1. - smoothstep(0., sf, d.x + .02*sqrt(450./iRes)));// + .42/(Nf + 1.)\n \n    // Run a bit of a texturized layer over the top. Comment it out, if you prefer\n    // a cleaner version.\n    vec3 tx = texture(iChannel0, p/gSc*2.).xyz; tx *= tx;\n    tx = min(smoothstep(-.1, .3, tx)*1.1, 1.);\n    col *= tx;\n    \n\n    // Apply some subtle line overlays.\n    vec2 pt = rot2(6.2831/3.)*p;\n    float pat2 = clamp(cos(pt.x*6.2831*28.*iRes/450.)*2. + 1.5, 0., 1.);\n    col *= pat2*.4 + .7;\n    \n    \n    // Applying a subtle silhouette, for art's sake.\n\tuv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.); \n\n    \n    // Rough gamma correction, then output to the screen..\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdd3DX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdd3R2", "name": "Razer RGB Cooler", "author": "nurof3n", "description": "guys loek at dis coler from my pc master race", "tags": ["rgb", "razer"], "likes": 6, "viewed": 94, "date": "1571130940", "time_retrieved": "2024-06-20T19:47:17.421520", "image_code": "#define TWO_PI 6.28318530718\n\nvec3 hsv2rgb( vec3 c )\n{    \n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\t//smoothed\n    \n\tvec3 color = mix( vec3(1.0), rgb, c.y);\n    color = color * (1. - smoothstep(1., 1.2, c.y));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= aspect;\n  \tfloat xmid = aspect/2.;\n    \n    vec2 toCenter;\n    toCenter.x = uv.x - xmid;\n    toCenter.y = uv.y - .5;\n    float angle = atan(toCenter.y,toCenter.x) + 2.*iTime;// + 1.*iTime;\n    float radius = length(toCenter) * 2.;\n    \n    float f;\n    //f = abs(cos(angle * 2.5)) * .5 + .4;\n    //f = abs(cos(angle * 6.) * sin(angle * 3.)) * .7 + .3;\n    f = smoothstep(.0, .5, cos(angle * 5.)) * 0.1 + 0.6;\n    \n    vec3 color = hsv2rgb(vec3((angle - 1.*iTime)/TWO_PI, radius, 1.0)) * (1. - smoothstep(f, f+.03, radius))\n        * smoothstep(f/1.1, f/1.1+.03, radius);\n    color += hsv2rgb(vec3((angle - 1.*iTime)/TWO_PI, radius * 2., 1.0)) * (1. - smoothstep(.1, .12, length(toCenter)));\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdd3R2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WddSD8", "name": "My_gears", "author": "adrenoide", "description": "coupled gears", "tags": ["gears", "polarcoordinates"], "likes": 3, "viewed": 219, "date": "1571901497", "time_retrieved": "2024-06-20T19:47:17.421520", "image_code": "const float pi = 4. * atan(1.);\n\n// Pour s = fract(x/2*pi) ...\n// entre 0 et a : s ** e\n// entre a et 1/2 : 1\n// symétriquement entre 1/2 et 1\nfloat phi(float x, float a, float e) {\n\tfloat s = fract(x / (2. * pi));\n    if (s < a) {\n        return pow(s/a, e);\n    }\n    else if (s > 1. - a) {\n        return pow((1. - s) / a, e);\n    }\n    else {\n    \treturn 1.;\n    }\n}\n\nfloat gear(vec2 p, vec2 ctr, float rMin, float rMax,\n           int nbTeeth, float param, float expos, float theta) {\n    float r = length(p - ctr);\n    float t = atan(p.y - ctr.y, p.x - ctr.x);\n    \n    float n = float (nbTeeth);\n    float f = rMin + (rMax - rMin) * phi(n * (t - theta), param, expos);\n    \n    return\n        smoothstep (0.01,\n                    0.,\n                    r - f)\n        ;\n}\n\nvec3 radialColor (vec2 p, vec2 ctr,\n                  float rOmega, float rPhi,\n                  float gOmega, float gPhi,\n                  float bOmega, float bPhi) {\n \treturn vec3 (\n        abs(sin(rOmega * length(p - ctr) + rPhi)),\n        abs(sin(gOmega * length(p - ctr) + gPhi)),\n        abs(sin(bOmega * length(p - ctr) + bPhi))\n    );   \n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 p = U / iResolution.x;\n    \n    p -= vec2 (0.5, 0.3);\n    p *= 5.;\n    \n    vec4 gearsColor = vec4(\n        \tvec3 (gear(p, vec2(0.,0.), .4, .6, 10, 0.4, 4., iTime)) *\n        \t\tradialColor (p, vec2(0.,0.), 2., 0., 1., 0., 3., 1.) +\n        \tvec3 (gear(p, vec2(1.1,0.), .4, .6, 10, 0.4, 4., -iTime - 0.8)) *\n        \t\tradialColor (p, vec2(1.1,0.), 3., 0., 1., 1., 2., 2.) +\n        \tvec3 (gear(p, vec2(1.05, -2.3), 1.3, 1.8, 30, 0.4, 12., iTime / 3. + 0.8)) *\n        \t\tradialColor (p, vec2(1.05,-2.3), 2., 0., 1., 0., 3., 1.) +\n        \tvec3(gear(p, vec2(-.8, 0.3), 0.15, 0.3, 5, 0.4, 4., -2. * iTime - 0.15) *\n                radialColor (p, vec2(-.8,.3), 3., 0., 1., 0.5, 3., 1.))\n        , 1.);\n    \n    vec4 gearsBlack = vec4(1.) - vec4(\n        \tvec3 (gear(p, vec2(0.,0.), .4, .6, 10, 0.4, 4., iTime)) +\n        \tvec3 (gear(p, vec2(1.1,0.), .4, .6, 10, 0.4, 4., -iTime - 0.8))+\n        \tvec3 (gear(p, vec2(1.05, -2.3), 1.3, 1.8, 30, 0.4, 12., iTime / 3. + 0.8)) +\n        \tvec3(gear(p, vec2(-.8, 0.3), 0.15, 0.3, 5, 0.4, 4., -2. * iTime - 0.15))\n        , 1.);\n    \n    O = gearsBlack * vec4(1.) + gearsColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WddSD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wddSDM", "name": "simpleHalftone", "author": "Venay", "description": "use mouse", "tags": ["halftone"], "likes": 7, "viewed": 301, "date": "1572185832", "time_retrieved": "2024-06-20T19:47:17.421520", "image_code": "float remap(float low1,float high1,float low2,float high2,float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\nfloat rand(vec2 st) {return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 st = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    float md = distance(uv,M);\n    float scale = 30.;\n    uv *= scale;\n    //uv = vec2(length(uv), atan(uv.y,uv.x)/(2.*3.1415)*2.);\n        \n    vec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    vec2 off = vec2(.5);\n    \n    float rid = rand(id);\n    float tt = sin(iTime*2.+uv.y*.2+rid*3.);\n    \n    \n    float tch = tt*md*3.;\n    tch = clamp(tch, 0., 1.);\n    \n    float d = distance(uv,id+off)*2.; \n    \n\tfloat c = smoothstep(tch, tch*.5, d);\n\n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wddSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WddSRj", "name": "reflective surfaces", "author": "acnologia", "description": "trying to create reflective surfaces through ray marching", "tags": ["raymarching"], "likes": 1, "viewed": 43, "date": "1572372442", "time_retrieved": "2024-06-20T19:47:17.421520", "image_code": "#define MAX_STEPS 100\n#define MAX_DEPTH 50.\nfloat sphereSDF(vec3 position){\n    vec4 sphere1 = vec4(-.8, .5, 1, .5);\n    vec4 sphere2 = vec4(.8, .5, 1, .5);\n\treturn min(length(position - sphere1.xyz) - sphere1.w,length(position - sphere2.xyz) - sphere2.w);\n}\nfloat cubeSDF(vec3 position){\n    float s = .2;\n \tvec3 d = abs(position-vec3(0,sin(iTime),cos(iTime))) - vec3(s);\n  \treturn min(max(d.x, max(d.y,d.z)), 0.0)\n      + length(max(d,0.0));\n}\n\nvec3 getSphereNormal(vec3 p){\n    vec2 eps = vec2(0.01,0);\n    return normalize(vec3(\n    \tsphereSDF(p+eps.xyy) - sphereSDF(p-eps.xyy),\n    \tsphereSDF(p+eps.yxy) - sphereSDF(p-eps.yxy),\n    \tsphereSDF(p+eps.yyx) - sphereSDF(p-eps.yyx)\n    ));\n}\n\nvec3 getCubeNormal(vec3 p){\n    vec2 eps = vec2(0.01,0);\n    return normalize(vec3(\n    \tcubeSDF(p+eps.xyy) - cubeSDF(p-eps.xyy),\n    \tcubeSDF(p+eps.yxy) - cubeSDF(p-eps.yxy),\n    \tcubeSDF(p+eps.yyx) - cubeSDF(p-eps.yyx)\n    ));\n}\n\n\nvec4 rayCast(vec3 ro, vec3 rd){\n\tfloat depth = 0.;\n    vec3 outColor = vec3(.52, .80, .92); //sky color - default\n    for(int i = 0;i < MAX_STEPS;++i){\n        vec3 position = ro + rd * depth;\n        float dist1 = sphereSDF( position );\n        float dist2 = cubeSDF( position );\n        float minDist;\n        if ( dist1 < dist2 ){\n            outColor = vec3(1); // color of sphere - white\n          \tminDist = dist1;\n        }else{\n            outColor = vec3(0, 0, 1); // color of cube - blue\n            minDist = dist2;\n        }\n        if(minDist < 0.01) break;\n        if(depth > MAX_DEPTH){\n            outColor = vec3(.52, .80, .92); //sky color - default\n            break;\n        }\n        depth += minDist;\n    }\n    return vec4(outColor, depth);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv *2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0, .5, -2);\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 lightSource = vec3(0, 1, -1);\n    vec4 res = rayCast(ro, rd);\n    vec3 col = res.xyz;\n    vec3 normal = lightSource;\n    if(res.xyz == vec3(1)){\n        vec3 refro = ro + rd*res.w;\n        vec3 refn = getSphereNormal(refro);\n    \tres = rayCast(refro+refn*.01, refn);\n        float d= 1./(1.+res.w*res.w);\n        col=mix(col,res.xyz,.4);\n        normal = refn;\n    }else if(res.xyz == vec3(0, 0, 1)){\n        vec3 refro = ro + rd*res.w;\n        normal = getCubeNormal(refro);\n    }\n    \n    fragColor = vec4(col,1);// * dot(normalize(lightSource),normal),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WddSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wddSW8", "name": "Animated additive mixing", "author": "egnawake", "description": "Animated visualization of the additive color model.", "tags": ["color", "additive", "model", "mixing"], "likes": 1, "viewed": 77, "date": "1571916067", "time_retrieved": "2024-06-20T19:47:17.421520", "image_code": "float circle(vec2 uv, vec2 center, float radius) {\n\treturn smoothstep(radius, radius-0.01, length(uv - center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 RES = iResolution.xy;\n    float RATIO = RES.x / RES.y;\n    \n    vec2 uv = fragCoord/RES; // [0, 1]\n    uv = uv - 0.5; // [-0.5, 0.5]\n    uv.x = uv.x * RATIO;\n    \n    vec3 col1 = vec3(1.0, 0.0, 0.0);\n    vec3 col2 = vec3(0.0, 1.0, 0.0);\n    vec3 col3 = vec3(0.0, 0.0, 1.0);\n    \n    vec3 mask = vec3(0.0);\n    float radius = 0.2;\n    float spread = sin(iTime) + 2.0 * 0.5;\n\n    mask = vec3(0.15);\n    mask += vec3(circle(uv, vec2(0.0, 0.05) * spread, radius)) * col1;\n    mask += vec3(circle(uv, vec2(0.0577, -0.05) * spread, radius)) * col2;\n    mask += vec3(circle(uv, vec2(-0.0577, -0.05) * spread, radius)) * col3;\n\n    fragColor = vec4(mask,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wddSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wddSzH", "name": "probabilist rect. billiard  3", "author": "FabriceNeyret2", "description": "let follows the trajectory of N*N balls starting from the same location.\n\nvariant: delete normalize for varying speed.  Or try vec2(iMouse.xy/R)  instead of vec(.5).\n[ wow, twice faster *with* the normalize ! same for with/without - float(N-1)/2.  WTF ? ]", "tags": ["simulation", "random", "billiard"], "likes": 8, "viewed": 297, "date": "1571490633", "time_retrieved": "2024-06-20T19:47:17.664225", "image_code": "// variant of  https://shadertoy.com/view/wstXz8\n\n\n#define N 17 // 12 for 60fps\n\n#define shash(p) ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n\nfloat h;\nfloat line(vec2 p, vec2 a,vec2 b) { // segment with disc ends: seamless distance to segment\n\n    p -= a, b -= a;\n    h = clamp(dot(p, b) / dot(b, b), 0., 1.);         // proj coord on line\n    p -= b * h;\n    return dot(p,p);                                  // dist² to segment\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, \n          U = u / R.y,\n          S = R / R.y, P, _P, K;\n    \n    float t = (R.y<250.) ? iTime - 9. : iTime,\n        l = 1e9, d,L;\n    for ( int k=0; k < N*N; k++) {\n        K = shash( vec2(k%N,k/N) - float(N-1)/2. );\n        for ( float dt = 0.; dt <= 1.; dt++ )  {\n            _P = P;\n         // P = vec2(.5+ .1*K) + (t+dt*.1)*vec2(1);  // random start position\n            P = vec2(.5) + (t+dt*.1) * normalize(K); // random start direction\n            P = mod( P/S, 2.); P = min( P, 2.-P )*S; // wrap virtual P(t) in recursive border \"mirrors\"\n        }\n      //l = min(l, dot(P-=U,P));                     // min distance\n        d = line(U,_P,P); if (d<l) l=d, L=h;         // min distance to trajectory\n    }\n    \n    O = vec4( L* smoothstep( 4.*L/R.y,0., sqrt(l) )); // draw tranjectory segment\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wddSzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wddXWM", "name": "Fixed Pattern Golden Noise Demo", "author": "Bapho", "description": "This is a fixed pattern golden noise/grain shader created for demonstration purposes.\nIt obviously has a major disadvantage: the noise pattern never changes.", "tags": ["noise", "goldenratio", "grain", "golden", "goldennoise"], "likes": 1, "viewed": 220, "date": "1572182414", "time_retrieved": "2024-06-20T19:47:18.088201", "image_code": "//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Fixed Pattern Golden Noise Demo by Bapho\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nfloat noise = 2.0;\n\n//----------------------------------------------------------------------\nprecision lowp float;\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\n\nfloat gold_noise(in vec2 coordinate, in float seed){\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouse;\n    if (iMouse.x <= 0.0 || iMouse.x >= iResolution.x){\n\t\tmouse = iResolution.x / 2.0;\n    } else {\n        mouse = iMouse.x;\n    }\n                             \n    if (mouse > fragCoord.x - 4.0 && mouse < fragCoord.x + 4.0){\n        fragColor = vec4(0.4, 0.0, 0.0, 1.0);\n    } else {\n\n        vec2 uv = fragCoord/iResolution.xy;\n\n        vec3 color;\n        if (fragCoord.x < iResolution.x * 0.05\n            || fragCoord.x > iResolution.x * 0.95){\n            color = vec3(0.0);\n            \n        } else if (fragCoord.y < iResolution.y * 0.15){\n        \tcolor = texture(iChannel1, uv).rgb;\n            \n        } else if (fragCoord.y < iResolution.y * 0.85){\n            color = texture(iChannel0, uv).rgb;\n            \n        } else {\n            color = 0.5 + 0.25*cos(iTime*0.5+uv.xyx+vec3(0,4,8));\n            //color = vec3(0.0, 0.8, 0.2);\n        }\n\n        if ((mouse <= 0.0 && fragCoord.x < iResolution.x / 2.0) \n\t\t\t\t|| mouse > fragCoord.x){\n            \n            float uniquePos = (fragCoord.x * uv.y) + fragCoord.x;\n            float amount = noise * 0.08;\n            \n            // using a fictive coordinate as a workaround to fix a pattern bug\n\t\t\tvec2 coordinate = vec2(fragCoord.x, fragCoord.y * 1.001253543);\n            \n            // a very low unique seed will lead to slow noise\n            // pattern changes on slow moving color gradients\n            float uniqueSeed = uniquePos * 0.000000001;\n            \n            // average noise luminance to subtract\n            float sub = (0.5 * amount);\n\n            // calculating and adding/subtracting the golden noise\n            float ran = gold_noise(coordinate, uniqueSeed);\n            float add = clamp(ran * amount, 0.0, 1.0);\n            color += (add - sub);\n        }\n\n        fragColor = vec4(color, 1.0);\n    }\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wddXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WddXWr", "name": "Ray marching algorithm", "author": "bf319", "description": "Ray marching algorithm", "tags": ["ray", "marching"], "likes": 0, "viewed": 57, "date": "1571785630", "time_retrieved": "2024-06-20T19:47:18.827651", "image_code": "#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat scene(vec3 p) {\n    return sphere(p, 2.0);\n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WddXWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdGGDc", "name": "LEX Trippy", "author": "legarcia", "description": "1", "tags": ["logatansin"], "likes": 2, "viewed": 94, "date": "1571081013", "time_retrieved": "2024-06-20T19:47:18.827651", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n\t\n\tfloat a = atan(uv.y, uv.x);\n\tfloat l = log(length(uv)) * 10.0 - iTime * 5.0;\n\t//float c = sin(l + cos(a * 6.0) * 0.5 + a) * 0.5 + 0.5;\n\tfloat c = fract(a*l)*(sin(iTime*2.)*.2+.8);\n   \n    fragColor = vec4(smoothstep(.4999,.5,c));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdGGDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdGGDG", "name": "Shadertober 11 - Snow", "author": "BackwardsCap", "description": "A snowman in a snowglobe", "tags": ["snow", "inktober", "shadertober", "backwardscaptain"], "likes": 3, "viewed": 291, "date": "1570938787", "time_retrieved": "2024-06-20T19:47:19.518534", "image_code": "#define MAX_DIST 50.0\nfloat g;\n\nmat2 rot(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat2(c, -s, s, c);\n}\n\n//thanks to iq for sharing this knowledge!\nfloat cyl(vec3 p, float ra, float rb, float h)\n{\n    vec2 d=vec2(length(p.xz)-2.0*ra+rb,abs(p.y)-h);\n    return min(max(d.x,d.y),0.0)+length(max(d,0.0))-rb;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0)/k;\n    return min(a,b)-h*h*k*(1.0/4.0);\n}\n\nfloat h21(vec2 p)\n{\n    return abs(fract(sin(dot(p,vec2(12.84,13.1523)))*21.129));\n}\n\nfloat snow(vec3 p)\n{\n    vec3 cell = vec3(4.);\n    vec3 mp = p+vec3(cos(iTime/2.-p.z/cell.z)*1.5,iTime,iTime/4.+cos(iTime/3.-p.x/cell.x)*1.5);\n    float id = floor(h21(floor(mp.xy/cell.xy))*100.);\n    float t = (100.+iTime)*2.*h21(floor(mp.xz/cell.xz));\n\n    float sn= length(mod(mp+vec3(0.,t,0),cell)-cell/2.)-.001;\n    \n    if(p.z<2.5) //clip snowflakes that are too close\n    g+=0.001/(0.01+sn*sn);\n\treturn sn;\n}\n\nvec2 map(vec3 p)\n{\n    float m = 0.;\n    float r =p.y+4.+(p.x*p.x+p.z*p.z)/200.;\n    float sn = snow(p);\n    vec3 smp = p+vec3(0,2.5,9);\n    vec3 smhp = smp+vec3(0,-4.4,0);\n    float sm = smin(smin(length(smp)-2.,length(smp+vec3(0,-2.5,0.))-1.4,.4),length(smhp)-.9,.4);\n    float smh = min(cyl(smhp+vec3(0,-.6,0),.65,.1,.05),cyl(smhp+vec3(0,-1.4,0),.4,.1,.5));\n    float sme = min(length(smhp-vec3(0.4,.24,.9))-.1,length(smhp-vec3(-0.4,.24,.9))-.1);\n    vec3 rp = smhp-vec3(0.2,0.0,0.2);\n    float hp = 3.1415927/2.;\n    rp.xy*=rot(hp);\n    rp.yz*=rot(hp*.8);\n    float n = cyl(rp,.1,4.,.1);\n    smh=min(smh,sme);\n    r=smin(r,sm,.9);\n    r=min(r,sn);\n    r=min(r,smh);\n    r=min(r,n);\n    if(r==smh)m=1.;\n    if(r==n)m=2.;\n    return vec2(r,m);\n}\n\nvec2 ray(vec3 ro, vec3 rd)\n{\n    float m = 0.0;\n    float t = 0.0;\n    for(int i=0;i<128;i++)\n    {\n        vec3 p=ro+rd*t;\n        vec2 s = map(p);\n        m=s.y;\n        if(s.x<0.00001)break;\n        t+=s.x*.8;\n        if(t>MAX_DIST)\n        {\n            t=-1.;\n            break;\n        }\n    }\n    return vec2(t,m);\n}\n\nvec3 normal(vec3 p )\n{\n    vec2 e = vec2(0.0005,0.);\n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        ));\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 p = (2.*f-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.,.6,2.5);\n    vec3 ta = vec3(0,0.5,2.2);\n    vec3 cf = normalize(ta-ro);\n    vec3 cu = normalize(cross(cf,vec3(0,1,0)));\n    vec3 cr = normalize(cross(cu,cf));\n    \n    vec3 rd = vec3(p.x*cu+p.y*cr+.4*cf);\n    vec2 r = ray(ro,rd);\n    \n    vec3 pos = ro+rd*r.x;\n    vec3 n = normal(pos);\n    vec3 sun = normalize(vec3(0.2,0.5,0.6));\n    float dif = clamp(dot(sun,n),0.,1.);\n    float sky = clamp(dot(n,vec3(0,1,0)),0.,1.);\n    float bou = clamp(dot(n,vec3(0,-1,0)),0.,1.);\n    float sha = step(ray(pos+n*0.001,sun).x,0.);\n    \n    vec3 col = vec3(0.5,0.5,1.)-(p.y+.3)/5.;\n    vec3 mate = vec3(1.);\n    if(r.y>.5&&r.y<1.5)mate=vec3(0.1);\n    else if(r.y>1.5){mate=vec3(0.89,0.3,0.);}\n    if(r.x>0.)\n    {\n        col=mate*vec3(1.,1.,1.8)*dif+g/2.*(abs(p.y+1.))*sha;\n        col+=mate*vec3(0.2,0.25,0.25)*sky;\n        col+=mate*vec3(0.1,0.1,0.1)*bou;\n    }\n    else col+=(g/2.)*(abs(p.y+1.));\n    float cp = length(p)-.9;\n    if(cp>0.)col=vec3(smoothstep(0.,3./iResolution.y,length(p)-.9)+.6);\n    else{\n        col+=smoothstep(1.,0.,length(p-.75)+.1)/1.1;\n\t\tcol-=smoothstep(-.2,4.,length(p)-.95)*100.;\n    }\n    c.rgb = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdGGDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdGGWc", "name": "Shadertober 14 Overgrown", "author": "GreenChicken", "description": "I wanted to try functions Leon use sometime to create theses rotating shapes. Love u <3", "tags": ["raymarching", "repeat", "inktober"], "likes": 3, "viewed": 329, "date": "1571075917", "time_retrieved": "2024-06-20T19:47:19.518761", "image_code": "// SHADERTOBER 14 Overgrown\n// Poulet vert 14-10-2019\n// Thanks to iq, Leon\n\n#define VOLUME 0.001\n#define PI 3.14159\n#define MAXSTEP 64\n#define sdist(p,r) (length(p)-r)\n#define TAU (2.*PI)\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, float s )\n{\n  vec3 q = abs(p) - vec3(s);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// leon ftw\nfloat amod (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an/2.;\n    float c = floor(a/an);\n    a = mod(abs(a),an)-an/2.;\n    p = vec2(cos(a),sin(a))*length(p);\n    return c;\n}\n\nfloat polarModulo (vec3 p) {\n    amod(p.xz, 5.);\n    p.x -= 1.;\n    return sdist(p, .5);\n}\n\nfloat tubeTwist (vec3 p, float s, float o) {\n    p.xz *= rot(p.y*2.0-iTime-o);\n    amod(p.xz, 8.);\n    p.x -= .5;\n    return sdist(p.xz, s);\n}\n\n// Scene setup\n\nvec2 map(vec3 pos)\n{\n\n    vec2 t = vec2(pos.y, 0.0);\n    \n    float anim = (.25 + abs(sin(iTime))*.25) * (1.0-pos.y*.2);\n    \n    vec3 sp = pos + vec3(0.0, 0.0, iTime*5.0);\n    sp = opRep(sp, vec3(4.0, 0.0, 4.0));\n    float grow = tubeTwist(sp, anim, 0.0);\n    grow = opU(grow, tubeTwist(sp, anim, 3.0));\n    \n    vec2 g = vec2(grow, 1.0);\n    \n    vec3 shp = pos + vec3(-2.0, -1.0, -4.0+sin(iTime)*2.0);\n    shp.xy *= rot(iTime);\n    float sh = sdSphere(shp, .5);\n    float ch = sdBox(shp, .25);\n    \n    vec2 s = vec2(mix(sh, ch, (1.0+sin(iTime*5.0))*.5), 2.0);\n    \n    t = opU2(t, g);\n    t = opU2(t, s);\n    \n    return t;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(float(i)/64., ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(.0); \n        \n    }\n    else\n    {\n        float depth = 1.0 - t.x;\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(depth*.25);\n        }\n        else if(t.y == 1.0)\n        {\n            col = vec3(0.0, 1.0, 1.0) * depth*.5;\n        }\n        else if(t.y == 2.0)\n        {\n            col = vec3(1.0, 0.0, 0.0) + depth * .8;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(sin(iTime), -1.0, cos(iTime)), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 1.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float forwardTime = 0.0;// iTime*5.0;\n    float offsetTime = 2.0+sin(iTime);\n    float up = 1.0+sin(iTime*.3)*.9;\n    \n    vec3 cp = vec3(offsetTime, up, forwardTime-1.0);\n    vec3 ct = vec3(offsetTime, up, forwardTime);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = Render(cp, vd, screenUV);\n    \n    // compo\n    col.g -= screenUV.y * .2;\n    col.r += (1.0-length(uv)*2.0)-.5;\n    \n    \n    col += random(uv)*.1* length(uv) * 2.0;\n    \n    col = clamp(col, 0.0, 1.0);\n    col *= 1.0-length(uv)*.75;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdGGWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdGGWK", "name": "ShaderTober - Swing", "author": "Flopine", "description": "A small doodle with inktober's theme \"Swing\"", "tags": ["raymarching", "animation"], "likes": 11, "viewed": 172, "date": "1570903104", "time_retrieved": "2024-06-20T19:47:19.918673", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n\nmat2 rot(float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat ring (vec3 p, float r, float w)\n{return max(abs(cyl(p, r,1.))-w,abs(p.z)-0.08);}\n\nfloat SDF (vec3 p)\n{\n    float r = 5.;\n    float w = 0.01;\n    float d = 1e10;\n\tfor (int i = 0; i<=6; i++)\n    {\n        float ratio = float(i)/5.;\n        r-=ratio;\n        w += ratio*0.1;\n        p.xz *= rot(iTime*0.5);\n        p.yz *= rot(iTime*0.2);\n        d = min(d, ring (p,r,w));\n    }  \n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.001,0.001,-6.),\n        rd = normalize(vec3(uv,1.)),\n        col = vec3(0.),\n        p = ro;\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i = 0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/64.;\n            hit = true;\n            break;\n        }\n        \n        p+=d*rd;\n    }\n    \n    if (hit)\n    {\n        col = vec3(1.-shad);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdGGWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdGGWR", "name": "Sierpinski carpet steps", "author": "nurof3n", "description": "A multicolored carpet!", "tags": ["fractal", "sierpinski"], "likes": 2, "viewed": 75, "date": "1571130793", "time_retrieved": "2024-06-20T19:47:19.924721", "image_code": "#define PI 3.14159265359\nconst float iter = 6.0;\n\nvec2 tile(vec2 uv) {\n\tuv *= 3.;\n    uv = fract(uv);  \n    return uv;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec3 hsv2rgb( vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 tiling = vec2(aspect, 1.);\n    uv.x *= aspect;\n    uv.x -= (aspect - 1.) / 2.;\n    \n \n    vec3 color = vec3(0.0);\n    vec3 colorr = vec3(0.0);\n    vec3 green = vec3(.3, .5, .1);\n    \n    if(uv.x > 1. || uv.x < .0) {     \n        color = vec3(1.0);\n        colorr = green;\n    }\n    else {\n        uv = rotate2d(PI / 4.) * uv;\n        vec3 hsl = vec3( uv.x / 2. + iTime * .5, 1.0, uv.y );\n\t\tcolorr = hsv2rgb(hsl);\n        uv = rotate2d(-PI / 4.) * uv;\n    \n        \n        for(float i = 0.; i < iter; ++i) {\n\n            vec3 color1 = vec3(step(1./3., uv.x) - step(2./3., uv.x));\n            vec3 color2 = vec3(step(1./3., uv.y) - step(2./3., uv.y));\n\n            color = color1 * color2;\n\n            if(color == vec3(1.))\n                break;\n\n            float pas = floor((fract(iTime*.2) * iter));\n            if(i == pas)\n                break;\n\n            uv = tile(uv);\n        }\n    }\n    \n    color *= colorr;\n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdGGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdGGzc", "name": "circle Edge", "author": "Venay", "description": "circle Edge", "tags": ["circleedge"], "likes": 1, "viewed": 228, "date": "1570641234", "time_retrieved": "2024-06-20T19:47:19.924721", "image_code": "\nvec2 circleClose(vec2 uv,vec2 C,float r){\n    return C + r*(uv-C)/length(uv-C);\n}\nfloat T(float s){\n\treturn sin(iTime*s)/2.+.5;\n}\n//----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat radius = .2;\n    vec2 C = vec2(cos(iTime*2.),sin(iTime*2.))*.2;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec2 i = circleClose(uv,C,radius);\n    float d = distance(uv,i);\n    vec3 col = vec3(smoothstep(radius*.1,radius*.1-.01,d));\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdGGzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdK3Dd", "name": "A golden flow 1", "author": "pik33", "description": "Derived form \"sine puke\", monochromatic flow of golden patterns", "tags": ["flow"], "likes": 6, "viewed": 117, "date": "1571249665", "time_retrieved": "2024-06-20T19:47:19.924721", "image_code": "const float Pi = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    \n    vec2 q=7.0*(fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x,iResolution.y);\n    vec2 p=vec2(abs(q.x),q.y);\n\t\n\tfor(int i=1;i<40;i++)\n\t{\n\t\tvec2 newp=p;\n\t\tnewp.x+=(0.5/(1.0*float(i)))*cos(float(i)*p.y+iTime*11.0/37.0+0.03*float(i))+1.3;\t\t\n\t\tnewp.y+=(0.5/(1.0*float(i)))*cos(float(i)*p.x+iTime*17.0/41.0+0.03*float(i+10))+1.9;\n\t\tp=newp;\n\t}\n\n\tvec3 col=vec3(0.5*sin(3.0*p.x)+0.5,0.5*sin(3.0*p.y)+0.5,sin(1.3*p.x+1.7*p.y));\n    col.x=smoothstep(0.90,1.0,col.x);   \n    col.y=smoothstep(0.90,1.0,col.y);\n    col.z=smoothstep(0.90,1.0,col.z);\n    float f=col.x;\n    f=max(f,col.y);\n    f=max(f,col.z);\n    f=(f*20.)-19.;       \n    \n\tfragColor=vec4(f,0.75*f,0.1,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdK3Dd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdK3Dz", "name": "NEON LOVE", "author": "alro", "description": "Quadratic Bezier curve SDF with glow. Using distance function from [url]https://www.shadertoy.com/view/MlKcDD[/url]\n\nAt sharp turns, the SDF has creases in the far field. Smooth minimum functions seem to distort low values. Is there a fix for this?", "tags": ["2d", "sdf", "bezier", "heart", "glow", "curve", "neon"], "likes": 97, "viewed": 3887, "date": "1570055254", "time_retrieved": "2024-06-20T19:47:20.640056", "image_code": "// gelami has created a nice fix for the creases: https://www.shadertoy.com/view/7l3GDS\n\n#define POINT_COUNT 8\n\nvec2 points[POINT_COUNT];\nconst float speed = -0.5;\nconst float len = 0.25;\nconst float scale = 0.012;\nfloat intensity = 1.3;\nfloat radius = 0.015;\n\n//https://www.shadertoy.com/view/MlKcDD\n//Signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0){ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n\n//http://mathworld.wolfram.com/HeartCurve.html\nvec2 getHeartPosition(float t){\n    return vec2(16.0 * sin(t) * sin(t) * sin(t),\n                -(13.0 * cos(t) - 5.0 * cos(2.0*t)\n                - 2.0 * cos(3.0*t) - cos(4.0*t)));\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nfloat getSegment(float t, vec2 pos, float offset){\n\tfor(int i = 0; i < POINT_COUNT; i++){\n        points[i] = getHeartPosition(offset + float(i)*len + fract(speed * t) * 6.28);\n    }\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n\tfloat dist = 10000.0;\n    \n    for(int i = 0; i < POINT_COUNT-1; i++){\n        //https://tinyurl.com/y2htbwkm\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, scale * c_prev, scale * points[i], scale * c));\n    }\n    return max(0.0, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre = vec2(0.5, 0.5);\n    vec2 pos = centre - uv;\n    pos.y /= widthHeightRatio;\n    //Shift upwards to centre heart\n    pos.y += 0.03;\n\t\n    float t = iTime;\n    \n    //Get first segment\n    float dist = getSegment(t, pos, 0.0);\n    float glow = getGlow(dist, radius, intensity);\n    \n    vec3 col = vec3(0.0);\n    \n    //White core\n    col += 10.0*vec3(smoothstep(0.006, 0.003, dist));\n    //Pink glow\n    col += glow * vec3(1.0,0.05,0.3);\n    \n    //Get second segment\n    dist = getSegment(t, pos, 3.4);\n    glow = getGlow(dist, radius, intensity);\n    \n    //White core\n    col += 10.0*vec3(smoothstep(0.006, 0.003, dist));\n    //Blue glow\n    col += glow * vec3(0.1,0.4,1.0);\n        \n    //Tone mapping\n    col = 1.0 - exp(-col);\n    \n    //Gamma\n    col = pow(col, vec3(0.4545));\n\n    //Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdK3Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdK3Rt", "name": "conic sections from spotlight", "author": "matthen", "description": "circles, ellipses, parabolas and hyperbolas are created by shining a light on a plane", "tags": ["geometry"], "likes": 4, "viewed": 216, "date": "1570780933", "time_retrieved": "2024-06-20T19:47:20.640056", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 col;\n\n \n\tvec3 camera = vec3(0., 0, -1.);\n    vec3 screen = vec3(uv.x, uv.y, 0.);\n    vec3 ray = normalize(screen - camera);\n    \n    float numSteps = 5. / (ray.z);\n    vec3 planePoint = screen + ray * numSteps;\n\n    \n    // move a torch around in some swirly way.\n    vec3 torch = vec3(\n        2. * sin(iTime), \n        0.2 * cos(iTime),\n        4.+.99 * sin(iTime)\n    );\n    vec3 torchDir = normalize(\n        vec3(-7. * sin(iTime),\n             cos(.618 * iTime),\n             .5 + .49 * cos(2. * iTime)\n            )\n    );\n    \n    col +=  smoothstep(0.9, 1.0, dot(normalize(planePoint - torch), torchDir));\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdK3Rt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdK3W1", "name": "ShaderTober - Bait", "author": "Flopine", "description": "A small doodle with inktober's theme \"bait\"... ;D ", "tags": ["raymarching", "inktober", "bait"], "likes": 10, "viewed": 288, "date": "1570123217", "time_retrieved": "2024-06-20T19:47:21.385496", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n#define nt iTime*4.\n\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\n// polynomial smooth min from iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\n\nfloat sp (vec3 p)\n{   \n    p.z -= nt;\n    p.xz *= rot(-PI/2.);\n    \n    p.y -= sin(p.x*2.+iTime*2.)*p.x*0.2;\n    float s =  sphe(p,0.5);\n    p.x -= 1.8;\n    float c = cyl(p.yzx,-p.x*0.2,1.5);\n    return smin(s,c,0.2);\n}\n\nfloat sps (vec3 p)\n{\n    p.xy *= rot(iTime*0.5);\n    float s1 = sp(p+vec3(3.,2.,0.));\n    float s2 = sp(p+vec3(0.,-2.,0.));\n   \tfloat s3 = sp(p + vec3(-3.,0.,0.));\n    return min(s1,min(s2,s3));\n}\n\nfloat g2 = 0.;\nfloat ov (vec3 p)\n{\n    p.z -= 3.+nt;\n    \n    p.x += sin(p.y*5.+.5)*0.2;\n    p.y -= sin(p.z*5.+0.1)*0.1;\n    p.z += cos(p.x*4.)*0.3;\n    float d = sphe(p, 0.8+exp(-fract(iTime)));\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat g1 = 0.;\nfloat tunnel(vec3 p)\n{\n    p.x += texNoise(p.yz*0.05).r;\n    p.y += texNoise(p.xz*0.02).r;\n    float d =  cyl(p, 5.+sin(nt)*0.15, 1e10);\n    g1 += 0.01/(0.01+d*d);\n    return d;\n}\n\nvec2 path(float t) \n{\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(a, a*b);\n}\n\nfloat SDF (vec3 p)\n{\n    p.xy -= path(p.z);\n    \n    return min(-tunnel(p),min(sps(p), ov(p)));\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.), f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.001,0.001,-5.+nt),\n        tar = vec3(0.,0.,nt),\n        p = ro,\n        col = vec3(0.);\n    \n    ro.xy += path(ro.z);\n\ttar.xy += path(tar.z);\n    \n    vec3 rd = getcam(ro, tar, uv);\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i =0.; i<64.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/64.;\n            hit = true;\n            break;\n        }\n        p+=d*rd*0.7;\n    }\n    if (hit) \n    {\n        col = vec3(1.-shad);\n    }\n    col += g1 * vec3(1.,0.7,0.7)*0.02;\n    col += g2 * vec3(0.8,0.1,length(uv))*0.05;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdK3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdK3Wz", "name": "Noise cube", "author": "Anskiere", "description": "drag to change isosurface offset", "tags": ["raymarching", "noise"], "likes": 9, "viewed": 174, "date": "1570019967", "time_retrieved": "2024-06-20T19:47:21.391677", "image_code": "#define fr float(iFrame)\n\nconst float maxDist = 200.;\nconst float planeDist = 2.;\n\nfloat rand31(vec3 co)\n{\n\treturn fract(sin(dot(co,vec3(65.9898,\n\t \t78.233, 29.3471))) * 1537.5497);\n}\n\nfloat n(vec3 uv)\n{\n\tvec3 i = floor(uv);\n\tvec3 luv = fract(uv);\n\tluv.xyz = smoothstep(0., 1., luv.xyz);\n\tvec3 d = vec3(1,-1,0);\n\tvec3 p[8];\n\tfloat r[8];\n\n\tp[0] = i;\n\tp[1] = i + d.zzx;\n\tp[2] = i + d.zxz;\n\tp[3] = i + d.zxx;\n\tp[4] = i + d.xzz;\n\tp[5] = i + d.xzx;\n\tp[6] = i + d.xxz;\n\tp[7] = i + d.xxx;\n\n\tfor(int k = 0; k < 8; k++)\n\t\tr[k] = rand31(p[k]);\n\n\tfloat rx[4];\n\n\tfor(int k = 0; k < 4; k++)\n\t    rx[k] = mix(r[k], r[k+4], luv.x);\n\n\tfloat rxy[2];\n\n\tfor(int k = 0; k < 2; k++)\n\t    rxy[k] = mix(rx[k], rx[k+2], luv.y);\n\n\tfloat rxyz = mix(rxy[0], rxy[1], luv.z);\n\n\treturn rxyz;\n}\n\nfloat noise(vec3 uv)\n{\n\tfloat r = 0.;\n\tfloat p = 1.;\n\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t    float cr = n(uv * p) / p;\n        r += cr;\n\t    p *= 2.;\n\t}\n\n\tr -= .5;\n\n\treturn r;\n}\n\nfloat sin01(float x)\n{\n\treturn sin(x) * 0.5 + 0.5;\n}\n\nfloat cos01(float x)\n{\n\treturn cos(x) * 0.5 + 0.5;\n}\n\nvec3 lightPos()\n{\n\treturn vec3(1,1,1);\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp((a - b)/k + 0.5, 0., 1.);\n\tfloat m = h * (1. - h) * 0.5 * k;\n\tfloat r = mix(a, b, h) - m;\n\treturn r;\n}\n\nvec3 cameraPos()\n{\n\treturn vec3(6,8,-6);\n\tfloat t = (fr/30.) * 0.05;\n\n\tvec3 res = vec3(\n\t\tsin(t) * 9.,\n\t\t9.,\n\t\t-cos(t) * 9.);\n\n\treturn res;\n}\n\nvec3 getRay(vec2 uv)\n{\n\tvec3 cam = cameraPos();\n\tvec3 origin = vec3(0, 0, 0);\n\tvec3 look = normalize(origin - cam);\n\tvec3 upGlob = vec3(0,1,0);\n\tvec3 right = normalize(cross(upGlob, look));\n\tvec3 camUp = normalize(-cross(right, look));\n\n\tvec3 p = cam + camUp * uv.y + right * uv.x;\n\tp += look * planeDist;\n\n\tvec3 res = p - cam;\n\treturn normalize(res);\n}\n\nfloat getSphere(vec3 p, float size, vec3 origin)\n{\n\treturn length(p - origin) - size;\n}\n\nfloat getSphere(vec3 p, float size)\n{\n\treturn getSphere(p, size, vec3(0,0,0));\n}\n\nfloat getCube(vec3 p, float size)\n{\n\tp = abs(p);\n\treturn max(max(p.x, p.y), p.z) - size;\n}\n\nfloat getInfCylinder(vec3 p, float size)\n{\n\tfloat l = length(vec3(p.x, p.y, 0)) - size;\n\treturn l;\n}\n\nfloat getPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nfloat inter(float a, float b)\n{\n\treturn max(a, b);\n}\n\nfloat un(float a, float b)\n{\n\treturn min(a, b);\n}\n\nfloat diff(float a, float b)\n{\n\treturn max(a, -b);\n}\n\nfloat getCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nvec2 skew(vec2 p, float a)\n{\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\n\tmat2 m = mat2(ca, sa, -sa, ca);\n\n\tp = p * m;\n\n\treturn p;\n}\n\nfloat getSd(vec3 p)\n{\n\tvec3 po = p;\n\n    float time = fr / 30.;\n    float n = noise(p - vec3(0,time*.5,0));\n\n\tfloat res = n;\n\n\tres = inter(res, getCube(po, 1.7));\n    \n    if (iMouse.z > 0.)\n    {\n        float x = smoothstep(0., 1., iMouse.y / iResolution.y)*2.-1.;\n        x *= 0.5;\n        res -= x;\n    }\n\n    return res;\n}\n\nvec3 calcNormal(vec3 p )\n{\n\tconst float h = 0.03; // or some other value const\n\tvec2 k = vec2(1,-1);\n\n\treturn\n\tnormalize(\n\t\tk.xyy*getSd( p + k.xyy*h ) +\n\t\t k.yyx*getSd( p + k.yyx*h ) +\n\t\t \tk.yxy*getSd( p + k.yxy*h ) +\n\t\t \t\tk.xxx*getSd( p + k.xxx*h ) );\n}\n\nfloat raymarch(vec3 sp, vec3 ray)\n{\n\tfloat depth = 0.;\n\n\tfor(int i = 0; i < 150; i++)\n\t{\n\t\tvec3 p = sp + ray * depth;\n\t\tfloat dist = getSd(p);\n\n\t\tif (dist <= 0.001)\n\t\t  return depth;\n\n\t\tdepth += dist;\n\n\t\tif (depth >= maxDist)\n\t\t  return maxDist;\n\t}\n\n\treturn maxDist;\n}\n\nfloat getShadow(vec3 p)\n{\n\tvec3 lp = lightPos();\n\tfloat ld = length(lp - p);\n\tvec3 ray = normalize(lp - p);\n\tfloat d = raymarch(p + ray*0.2, ray);\n\tfloat res = smoothstep(0.1,1., d);\n\tres = res * 0.3 + 0.7;\n\treturn res;\n}\n\nfloat getSpec(vec3 refRay, vec3 l)\n{\n\tfloat x = dot(refRay, l);\n\n\tx = clamp(x,0.,1.);\n\tx = pow(x, 7.);\n\n\treturn x;\n}\n\nfloat getHatch(vec3 l, vec3 p)\n{\n\tfloat time = fr / 30.;\n\tp -= vec3(0,time*.5,0);\n\tvec3 right = normalize(cross(l, vec3(0,1,0)));\n\tvec3 up = (cross(l, right));\n\n\tfloat u = dot(p, right);\n\tfloat v = dot(p, up);\n\tvec2 uv = vec2(u,v)*0.3;\n\n\tfloat h = texture(iChannel0, uv).r;\n\n\treturn 1.-h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n\tuv.y /= iResolution.x / iResolution.y;\n    uv *= 2.;\n    \n    vec3 ray = getRay(uv);\n    vec3 camPos = cameraPos();\n\tfloat d = raymarch(camPos, ray);\n\tfloat inf = step(1., maxDist - d);\n\n\tvec3 col = vec3(1.);\n\n\tif (d > 30.)\n\t{\n\t    fragColor = vec4(0);\n\t\treturn;\n\t}\n\n\tvec3 intP = cameraPos() + d*ray;\n\tvec3 n = calcNormal(intP);\n\tvec3 lightDir = normalize(vec3(1));\n\n    float dd = dot(n, lightDir);\n    dd = dd *.5 + .5;\n    \n    vec3 cuv = (intP - vec3(-1.7))/3.4;\n\n\tvec3 res = col * dd * inf * cuv;\n\n\tvec3 refRay = reflect(ray, n);\n\n\tfloat spec = getSpec(refRay, lightDir);\n\tfloat h = getHatch(lightDir, intP);\n    \n\tspec *= h;\n\tres += spec;\n\n    fragColor = vec4(res, 1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdK3Wz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdK3zK", "name": "First Ray Marching Experiment", "author": "msiddeek", "description": "First experiment", "tags": ["ray"], "likes": 3, "viewed": 123, "date": "1571155079", "time_retrieved": "2024-06-20T19:47:21.391677", "image_code": "#define MAX_DIST 100.\n#define PREC .01\n#define PREC1 .03\n#define SHADOW_QUAL 100.\n\n#define LIGHT_POS vec3(2., 2.8, 2.)\n#define LIGHT_DIR vec3(-sin(iTime * .81) * .25, -1., +sin(iTime * 4.12) * .125)\n\n\nfloat plane(vec3 p, vec4 n) {\n    return dot(p, normalize(n.xyz)) - n.w;\n}\nfloat planeX(vec3 p, float d) {\n    return plane(p, vec4(1., 0., 0., d));\n}\nfloat planeY(vec3 p, float d) {\n    return plane(p, vec4(0., 1., 0., d));\n}\nfloat planeZ(vec3 p, float d) {\n    return plane(p, vec4(0., 0., 1., d));\n}\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec4 map(vec3 p) {\n    float d = MAX_DIST;\n    float m = .0;\n\n    float px1 = planeX(p, -3.);\n    float px2 = -planeX(p, 3.);\n    float pz1 = -planeZ(p, 3.);\n    float pz2 = planeZ(p, -3.);\n    float py1 = planeY(p, 0.);\n    float py2 = -planeY(p, 4.);\n    if (d > px1) {\n        d = px1;\n        m = 1.;\n    }\n    if (d > px2) {\n        d = px2;\n        m = 5.;\n    }\n    if (d > pz1) {\n        d = pz1;\n        m = 2.;\n    }\n    if (d > pz2) {\n        d = pz2;\n        m = 3.;\n    }\n    if (d > py1) {\n        d = py1;\n        m = 0.;\n    }\n    if (d > py2) {\n        d = py2;\n        m = 4.;\n    }\n    float pl = plane(p, vec4(-1., -1., -1., -4.8));\n    if (d > pl) {\n        d = pl;\n        m = 6.;\n    }\n\n    float s = sphere(p - vec3(0., 1.25 - pow(fract(iTime * 1.) - .5, 2.) * 3., 0.), .5);\n    if (s < d) {\n        m = 7.;\n        d = s;\n    }\n\treturn vec4(d, m, 0., 0.);\n}\nvec3 normal(vec3 p) {\n    vec2 t = vec2(PREC, -PREC) * .001;\n    return normalize(\n    \tt.xyy * map(p + t.xyy).x +\n    \tt.yxy * map(p + t.yxy).x +\n    \tt.yyx * map(p + t.yyx).x +\n    \tt.xxx * map(p + t.xxx).x);\n}\nvec4 march(vec3 ro, vec3 rd, float maxD) {\n    vec4 res;\n    float d = 0.;\n    float newD = PREC;\n    while (newD >= PREC && d < maxD) {\n        res = map(ro + rd * d);\n        newD = res.x;\n        d = min(maxD, d + newD);\n    }\n \treturn vec4(d, res.yzw);\n}\nfloat shadow(vec3 ro, vec3 rd, float maxD) {\n    float soft = 1.;\n    float d = PREC;\n    float newD = PREC;\n    while (newD >= PREC && d < maxD) {\n        newD = map(ro + rd * d).x;\n        soft = min(soft, 4. * max(0., newD - PREC) / d);\n        d += min(newD, maxD / SHADOW_QUAL);\n    }\n \treturn soft;\n}\nvec3 color(float c) {\n    if (c < 1.) {\n    \treturn vec3(1., 1., 0.) * .8;\n    } else if (c < 2.) {\n    \treturn vec3(1., 0., 1.) * .8;\n    } else if (c < 3.) {\n    \treturn vec3(.0, 1., .0) * .8;\n    } else if (c < 4.) {\n    \treturn vec3(0., 1., 1.) * .8;\n    } else if (c < 5.) {\n    \treturn vec3(1., 0., 0.) * .8;\n    } else if (c < 6.) {\n    \treturn vec3(0., .0, 1.) * .8;\n    } else if (c < 7.) {\n    \treturn vec3(2., 2., 2.);\n    } else if (c < 8.) {\n    \treturn vec3(1., 1., 1.) * .1;\n    }\n}\nfloat reflection(float c) {\n    if (c < 6.) {\n    \treturn 0.;\n    } else if (c < 8.) {\n    \treturn 1.;\n    }\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n\n    vec4 m = march(ro, rd, MAX_DIST); \n    float hd = m.x;\n    vec3 h = ro + rd * (hd - PREC1);\n    vec3 n = normal(h);\n    vec3 lh = h - LIGHT_POS;\n    vec3 diff = dot(n, -normalize(lh)) * color(m.y);\n    if (color(m.y).x <= 1.) {\n        float shad = clamp(0., 1., shadow(h, normalize(-lh), length(lh)) + .25);\n        diff *= shad;\n    }\n\n    if (reflection(m.y) > .1 && color(m.y).x <= 1.) {\n        vec3 r = rd - 2. * dot(normalize(rd), n) * n;\n        vec4 mr = march(h, r, MAX_DIST);\n        float hdr = mr.x;\n        vec3 hr = h + r * (hdr - PREC1);\n        vec3 nr = normal(hr);\n        vec3 lhr = hr - LIGHT_POS;\n        diff = color(mr.y) * dot(nr, -normalize(lhr)) * (1.8 + dot(rd, n));\n\t    float shadr = clamp(0., 1., shadow(hr, normalize(-lhr), length(lhr)) + .25);\n        diff *= shadr;\n    }\n\n    col += diff;\n\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0., 1.25, -2.9);\n    float a = iTime * .5;\n    ro.xz = mat2(cos(a), sin(a), -sin(a), cos(a)) * ro.xz;\n    float cp = 1.;\n    vec3 rd = normalize(vec3(uv.x, uv.y, cp));\n    rd.xz = mat2(cos(a), sin(a), -sin(a), cos(a)) * rd.xz;\n\n    vec3 col = render(ro, rd);\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdK3zK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdK3zt", "name": "Distortion Breath", "author": "shadeThrower", "description": "Distorted breathing kaleidoscopic plane", "tags": ["kaleidoscope", "trig"], "likes": 4, "viewed": 273, "date": "1570758177", "time_retrieved": "2024-06-20T19:47:21.591648", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tme = iTime*.5;\n    float scale = 0.125;\n   \n    vec2 adjVec = vec2((sin(tme)*.5), (cos(tme)*.5));\n    vec2 uv = fragCoord/iResolution.xy;    \n    vec2 uvM;\n    float posMod;\n\n    uvM = mod(uv + normalize(uv-0.5)*adjVec, scale);\n    uv = normalize(uvM-vec2(scale/2.))*(adjVec+vec2(.5));\n\n    if(mod(floor((uv.x)/scale),2.) == 0.)\n            uvM.x = scale - uvM.x;\n    if(mod(floor((uv.y)/scale),2.) == 0.)\n            uvM.y = scale - uvM.y;\n\n    uvM += adjVec*length(uvM + adjVec - vec2(0.5));\n\n    // Time varying pixel color\n    vec3 col = vec3(0.5 + 0.5*tan((cos(tme)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.)))),\n                    0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.)))),\n                    0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*(uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdK3zt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdKGDV", "name": "Truchet Knitting Snakes", "author": "azirafail", "description": "truchet experiments", "tags": ["truchet"], "likes": 3, "viewed": 109, "date": "1570993224", "time_retrieved": "2024-06-20T19:47:21.591648", "image_code": "float noise2(vec2 uv)\n{\n    return fract(sin(uv.x * 8989.) * 52423. + cos(uv.y * 4917.) * 68159.);\n}\n\nfloat mh(vec2 v)\n{\n    return abs(v.x) + abs(v.y);\n}\n\nfloat PI = 3.142;\n\nstruct snakeUvs {\n    vec2 stuv, cuv, suv, tuv, flipper;\n    bool flipped;\n};\n\nsnakeUvs getSnakeUvs(vec2 wuv, float offset)\n{\n    // truchet\n    \n    vec2 otuv = fract(wuv);\n    vec2 tuv = otuv;\n    vec2 c = floor(wuv);\n    \n    float n = noise2(c);\n\n    bool flip = n < 0.5;\n    \n    if (flip) \n    {\n        tuv.x = 1. - tuv.x;\n        otuv.x = -otuv.x;\n    }\n    \n    if (mh(tuv) > 1.) \n    {\n       tuv -= 1.;\n       otuv -= 1.;\n    }\n    \n    if (flip)\n    {\n        otuv = vec2(-1. - otuv.x, otuv.y);\n    }\n    \n    float d = length(tuv);\n    \n    vec2 suv;\n    suv.y = 2.*atan(tuv.y/tuv.x)/PI - .5;\n    suv.x = -(d * 3. - 1.5);\n    \n    \n    vec2 flipper = vec2(1.,1.);\n    if (mod(c.x+c.y,2.) == 0.) \n    {\n        flipper.y = - 1.;\n    }\n    if ((mod(mh(c),2.) == 0.) ^^ flip )\n    {\n        flipper.x = - 1.;\n    }\n    \n    suv *= flipper;\n    \n    \n    vec2 stuv = vec2(suv.x, fract(suv.y * 2. + offset)-.5);\n    \n    snakeUvs uvs;\n    uvs.stuv = stuv;\n    uvs.cuv = otuv;\n    uvs.suv = suv;\n    uvs.tuv = tuv;\n    uvs.flipper = flipper;\n    uvs.flipped = flip;\n    \n    return uvs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   \n    vec2 wuv1 = uv * (6. + 2. * sin(iTime / 5.)) + vec2(0.6,0.5) * iTime;\n    vec2 wuv2 = wuv1 + vec2(- 76.5,39.5);\n    \n    vec2 ctuv = fract((wuv1 + .25) * 2.);\n    vec2 cti = floor((wuv1 + .25) * 2.);\n    \n    bool over = mod(mh(cti), 4.) > 2.;\n    \n    \n    snakeUvs uvs1 = getSnakeUvs(wuv1, iTime * 3.);\n    snakeUvs uvs2 = getSnakeUvs(wuv2, iTime * 1.);\n    \n    vec2 stuv1 = uvs1.stuv;\n    vec2 stuv2 = uvs2.stuv;\n    \n    vec2 stxy1 = uvs1.cuv;\n    vec2 stxy2 = uvs2.cuv;\n    \n    stuv1.x *= -1.5-uv.y;\n    stuv2.x *= 1.5-uv.y;\n    stuv1.x *= 2.+sin(wuv1.x / (4.5 + sin(wuv1.y / 30.)));\n    stuv2.x *= 2.+sin(wuv2.x / (3.8 + sin(wuv2.y / 70.)));\n    \n    //col.rg = stuv1 + stuv2;\n    float mask1 = smoothstep(.5,0.45,abs(stuv1.x));\n    float mask2 = smoothstep(.5,0.45,abs(stuv2.x));\n    \n    if (over)\n    {\n      mask2 *= 1. - mask1;\n    }\n    else {\n      mask1 *= 1. - mask2;\n    }\n    \n    vec2 luv = mask1 * stuv1 + mask2 * stuv2;\n    \n    float rope = cos(luv.x * 2. * PI / 2.) * sin(fract((luv.x - luv.y) * 2.) * PI);\n    col += vec3(.7,.1,.2) * mask1 * rope;\n    col += vec3(.4,.1,.6) * mask2 * rope;\n    \n    col.rgb += vec3(luv.x);\n\n    vec2 norm = (stxy1 * 5.*(uvs1.stuv.x*sign(uvs1.stuv.x * (length(stxy1) - 0.5))) *  mask1 + stxy2 * 5.*(uvs2.stuv.x*sign(uvs2.stuv.x * (length(stxy2) - 0.5))) * mask2);\n    \n    vec2 fwd = normalize(vec2(luv.y, -luv.x));\n \n    norm -= 0.8 * fwd * (fract((luv.x - luv.y) * 3.) - 0.5);\n    \n    \n   \tfloat illum1 = clamp(dot(norm, vec2(1. * sin(iTime / 3.),1. * cos(iTime / 3.))), 0.,1.);\n   \tfloat illum2 = clamp(dot(norm, vec2(1. * sin(iTime / 5.),1. * cos(iTime / 3.))), 0.,1.);\n    \n    col.rgb = col.rgb * 0.4 \n        + (col.rgb * 0.7 * illum1 +  illum1 * illum1) * vec3(1.,.5,0.)\n        + (col.rgb * 0.7 * illum2 +  illum2 * illum2) * vec3(0.,.5,.8);\n    \n    //col.rg = norm;\n    //col.b = illum;\n    \n    \n    //col.g = length(tuv);\n  \t//col.rg = suv;\n    \n    fragColor.rgb = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdKGDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdKGRc", "name": "Beat03", "author": "legarcia", "description": "3 ", "tags": ["heart"], "likes": 1, "viewed": 89, "date": "1570654559", "time_retrieved": "2024-06-20T19:47:21.591648", "image_code": "\n\nfloat oneHz(){\n  \n   return(fract(iTime)*6.29);\n}\n\nfloat osc( float scale){\n    \n  scale *= .5;\n\n  return sin(oneHz()) * scale + scale;\n}\n\n\n\nvec4 tiler(vec2 i){\n    vec3 o = vec3(1.);\n    \n    \n    vec2 grid = vec2(fract(i.x),fract(i.y));\n    \n    grid -=.5;\n    \n    grid.y = fract(length(grid)*(osc(length(i)*2.) +6.) );\n    \n    grid.y = smoothstep(.1, .8, grid.y);\n    \n    \n\n    float sawtooth =  fract(length(i));\n    // grid += vec2(triangle,triangle);;\n\n    \n    return vec4(grid, sawtooth, 1.0);\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)*8./iResolution.y;\n\n    vec4 col = tiler(uv);\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdKGRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdKGRK", "name": "shadetober #08 (frail)", "author": "percentcer", "description": "Inktober, but with shaders", "tags": ["inktober", "shadertober", "shadetober", "inktober2019"], "likes": 1, "viewed": 202, "date": "1570599464", "time_retrieved": "2024-06-20T19:47:21.791557", "image_code": "mat2 rot(float a) {\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a)\n               );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    uv -= vec2(aspect * .5, 0.5);\n\n    // Time varying pixel color\n    vec3 col = vec3(.8,0.,.1);\n    \n    float wiggliness = 10.;\n    uv.x += sin((uv.y + iTime) * wiggliness) * .2;\n    \n    uv = rot(iTime) * uv;\n    \n    float p = length(uv);\n    p = smoothstep(.2, .22, p);\n    \n    col *= fract(uv * 2.).xyx;\n\n    // Output to screen\n    fragColor = vec4(col,1.0) + p * .5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdKGRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdKGWz", "name": "Inktober2019 01: ring", "author": "s23b", "description": "Mouseable, #define tinkerable.\n\nI know I'm late to the party, but I will try to catch up with the calendar. My goal for this challenge is to keep the style consistent (simple, monochrome, instagram-friendly, loopable, antialiased) throughout the shaders.", "tags": ["torus", "ring", "inktober", "shadertober", "inktober2019"], "likes": 32, "viewed": 543, "date": "1570288782", "time_retrieved": "2024-06-20T19:47:21.791557", "image_code": "#define AA 4.\n#define NUM_STRIPES 10.\n#define PERIOD 10.\n#define COLOR vec3(1., .9, .75)\n\n#define MAX_STEPS 100\n#define NEAR .001\n#define FAR 5.\n#define PI 3.14159265359\n\nvec3 hash(float p) {\n    return fract(cos(p) * vec3(12345.6, 23456.7, 34567.8));\n}\n\nvoid tRotate(inout vec2 p, float angle) {\n    float s = sin(angle), c = cos(angle);\n\tp *= mat2(c, -s, s, c);\n}\n\nfloat sdTorus(vec3 p, float r1, float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat map(vec3 p) {\n    return sdTorus(p.xzy, 1., .2);\n}\n\nfloat trace(vec3 o, vec3 r) {\n\n    float t = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        float d = map(o + r * t);\n        t += d;\n        if (d < NEAR || t > FAR) break;\n    }\n    \n    return t;\n}\n\nfloat render(vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    vec3 r = normalize(vec3(uv, 1.5));\n    vec3 o = vec3(.1, -.1, -3);\n    \n    vec2 rot = iMouse.z > 0. ? iMouse.xy / iResolution.xy * 2. : vec2(-.2, .2);\n    rot *= PI;\n    tRotate(r.yz, -rot.y);\n    tRotate(r.xz, -rot.x);\n    tRotate(o.yz, -rot.y);\n    tRotate(o.xz, -rot.x);\n    \n    float f = trace(o, r);\n    \n    if (f > FAR) return 1.;\n    \n    vec3 p = o + f * r;\n    \n    vec2 tp = atan(vec2(p.x, length(p.xy)-1.), p.yz) / PI / 2. + .5;\n    tp.y = fract(tp.y + tp.x + iTime / PERIOD);\n    vec3 h = hash(floor(tp.y * NUM_STRIPES));\n    float offset = h.x,\n          speed = ceil(h.y * PERIOD) / PERIOD,\n          size = h.z * .25 + .125;\n    \n    tp.y = mod(tp.y, 1. / NUM_STRIPES) - .5 / NUM_STRIPES;\n    tp.x = fract(tp.x + offset + speed * iTime) - .5;\n    tp = abs(tp);\n    \n   \treturn step(smoothstep(size, 0., tp.x), tp.y / .4 * NUM_STRIPES);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float color = 0.;\n    \n    vec2 uv = abs(fragCoord - iResolution.xy / 2.) / min(iResolution.y, iResolution.x);\n    \n    if (uv.x > .45 || uv.y > .45) {\n        color = 0.;\n    } else {\n        for (float x = 0.; x < AA; ++x) {\n            for (float y = 0.; y < AA; ++y) {\n                color += render(fragCoord + vec2(x, y) / AA);\n            }\n        }\n    \tcolor /= AA * AA;\n    }\n    \n        \n\tfragColor = vec4(mix(vec3(0), COLOR, color), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdKGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdKGzt", "name": "Raymarching a height map", "author": "TheKing", "description": "This shader ray marches a height map. You can be adapt it to any height map if you know an upper bound on the slope of the secant lines. Using this information, a signed distance estimate can be generated. Smaller upper bounds make it faster.", "tags": ["3d", "raymarching", "heightmap"], "likes": 8, "viewed": 1255, "date": "1570754958", "time_retrieved": "2024-06-20T19:47:21.791557", "image_code": "const float angle = 1.;\nconst mat2 m1 = mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n\nvec3 transform(vec3 p) {\n    mat2 m2 = mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime));\n    p.yz *= m1;\n    p.xy *= m2;\n    return p;\n}\n\nconst float slopeUB= 2.;\nconst float g = sin(atan(1.,slopeUB));\n\nfloat sde(vec3 p) {\n    float h = (sin(p.x) + sin(p.y));\n    return (p.z-h)*g;\n    \n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    vec3 p = ro + rd*0.001;\n    while(true) {\n        float d = sde(p);\n        if (d < 0.0001) {break;}\n        p += rd*d;\n        if (length(p-ro) > 200.) {break;}\n    }\n    return p;\n}\n\nconst vec2 helper = vec2(1e-5,0);\n\nfloat light(vec3 l, vec3 p) {\n    float d = sde(p);\n    vec3 norm = normalize(vec3(\n        sde(p + helper.xyy) - d,\n        sde(p + helper.yxy) - d,\n        sde(p + helper.yyx) - d\n        ));\n    vec3 ld = normalize(l-p);\n    float s = max(0.,dot(ld, norm));\n    if (s > 0.) {\n        if (length(rayMarch(p,ld)-p) < length(l-p)) {\n            return 0.;\n        }\n    }\n    return s;\n}\n\nconst vec3 l = vec3(0,10,5);\nconst vec3 ro = vec3(0,0,15);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 c = vec3(15.*uv,3);\n    vec3 ro_ = ro;\n    c = transform(c);\n    ro_ = transform(ro_);\n    \n    vec3 p = rayMarch(ro_, normalize(c - ro_));\n\n    vec3 col = vec3(light(l, p));\n    \n    float d = length(p-ro_);\n    col -= vec3(smoothstep(0.,200.,d));\n    col = min(vec3(1),col);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdKGzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdKGzw", "name": "Mandelbrot with Antialiasing", "author": "HAL9000", "description": "Simple mandelbrot shader with basic antialias", "tags": ["mandelbrot"], "likes": 2, "viewed": 60, "date": "1569936273", "time_retrieved": "2024-06-20T19:47:21.791557", "image_code": "#define SAMPLES 2 //samples are quadratic!\n#define max_iter 512\n\nfloat lerp (float a, float b, float fac)\n{\n    return a * (1. - fac) + b * fac;\n}\n\n\nfloat brot_iter(vec2 uv)\n{\n    vec2 n = vec2(uv);\n    for(int i = 1; i < min(int(iTime*30.),512); i++){\n        n = vec2(n.x * n.x - n.y * n.y, 2. * n.x * n.y)+uv;\n        if(dot(n,n) >= 4.){\n            return float(i);\n\t    }\n    }\n    return 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cntr = vec2(-0.50052, 0.52);\n    float yside = mix(.00005, 2., pow(2., (cos(iTime/3.) - 1.) * 20.));\n    float xside = yside * float(iResolution.x) / iResolution.y;\n    vec2 topl = cntr - vec2(xside, yside) / 2.;\n\tvec2 botr = cntr + vec2(xside, yside) / 2.;\n   \tfloat col = 0.;\n    float half_samples = float(SAMPLES) / 2.;\n    float spacing = 1./float(SAMPLES);\n    for (int i = 0; i < SAMPLES; i++){\n        for (int j = 0; j < SAMPLES; j++){\n        \tvec2 uv = (fragCoord + vec2(i, j) * spacing)/iResolution.xy;\n    \t\tuv =  mix(topl, botr, uv);\n            col += float(brot_iter(uv));\n            //col += pow(float(brot_iter(uv)) / float(max_iter), 0.1);\n        }\n    }\n    col /= float(SAMPLES*SAMPLES) * float(max_iter);\n    col = pow(col, 0.5);\n    // Output to screen\n    fragColor = vec4(col, col, pow(1000., col) - 1.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdKGzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtSD4", "name": "Shadertober 24 - Dizzy", "author": "BackwardsCap", "description": "@_@", "tags": ["dizzy", "inktober", "shadertober", "backwardscaptain"], "likes": 6, "viewed": 362, "date": "1572022454", "time_retrieved": "2024-06-20T19:47:21.791557", "image_code": "void mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.y;\n    vec2 ap = vec2(atan(uv.y,uv.x),length(uv));\n    c.rgb=(0.5 + 0.5*cos(iTime+ap.xyx+vec3(0,2,4))*2.)*\n        (cos(ap.y*cos(iTime)*(100.+ap.y*50.*cos(iTime)*2.)+ap.x-iTime*7.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtSD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtSD7", "name": "Raymarched shadows", "author": "JentGent", "description": "Testing out shadows.", "tags": ["3d", "raymarching"], "likes": 2, "viewed": 65, "date": "1572197768", "time_retrieved": "2024-06-20T19:47:22.579531", "image_code": "// Set float precision\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Output color\nvec3 c = vec3(1.0, 1.0, 1.0);\n\n// Distance estimators\nfloat deSphere(vec3 from, vec3 center, float radius) {\n\treturn length(center - from) - radius;\n} // Sphere\nfloat deTorus(vec3 from, vec3 center, float radius, float thickness) {\n    return length(vec2(length(center.xz - from.xz) - radius, center.y - from.y)) - thickness;\n} // Torus\nfloat deCuboid(vec3 from, vec3 center, vec3 dimensions) {\n\treturn length(clamp(abs(center - from) - dimensions / 2.0, 0.0, 100000.0));\n} // Cuboid\nfloat deUncappedCylinder(vec3 from, vec3 center, float radius) {\n    return length(center.yz - from.yz) - radius;\n} // Uncapped cylinder\nfloat deCappedCylinder(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2.0, center.x + capAt / 2.0), from.yz)) - radius;\n} // Capped cylinder\nfloat deCapsule(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2.0, center.x + capAt / 2.0), from.yz)) - radius;\n} // Capsule\n\n// Find normal of a sphere\nvec3 normalSphere(vec3 v, vec3 center) {\n    return normalize(center - v);\n}\n\n// Rounded objects (WARNING: also increases object size!)\nfloat deRound(float pd, float radius) {\n\tfloat de = pd;\n\treturn de - radius;\n}\n\n// Booleans (union, subtraction, intersection)\nfloat boolUnion(float pd, float pd2) {\n\treturn min(pd, pd2);\n}\nfloat boolSubtraction(float pd, float pd2) {\n\treturn max(-pd, pd2);\n}\nfloat boolIntersection(float pd, float pd2) {\n\treturn max(pd, pd2);\n}\n\n// Smooth Booleans\nfloat smoothBoolUnion(float pd, float pd2, float smoothness) {\n\tfloat level = clamp(0.5 + (pd - pd2) / smoothness / 2.0, 0.0, 1.0);\n\treturn mix(pd, pd2, level) - smoothness * level * (1.0 - level);\n}\nfloat smoothBoolSubtraction(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd + pd2) / smoothness / 2.0, 0.0, 1.0 );\n    return mix(pd2, -pd, level) + smoothness * level * (1.0 - level);\n}\nfloat smoothBoolIntersection(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd - pd2) / smoothness / 2.0, 0.0, 1.0);\n    return mix(pd, pd2, level) + smoothness * level * (1.0 - level);\n}\n\nfloat displace(float pd, vec3 from, vec3 dir, float size, float strength) {\n    vec3 p = from + dir * pd;\n    float d2 = sin(size * p.x) * sin(size * p.y) * sin(size * p.z) * strength;\n    return pd + d2;\n}\n\nvec3 rotate(vec3 inp, float xRot, float yRot, float zRot, vec3 anchor) {\n    inp -= anchor;\n    mat2 rot = mat2(\n        cos(xRot), -sin(xRot),\n        sin(xRot), cos(xRot)\n    );\n    inp.yz *= rot; // X rotation\n    rot = mat2(\n        cos(yRot), -sin(yRot),\n        sin(yRot), cos(yRot)\n    );\n    inp.xz *= rot; // Y rotation\n    rot = mat2(\n        cos(zRot), -sin(zRot),\n        sin(zRot), cos(zRot)\n    );\n    inp.xy *= rot; // Z rotation\n    inp += anchor;\n    return inp;\n}\n\n// Lights\nvec3 sun = vec3(-2.0, 1.0, -1.0);\n\n// Camera\nvec3 cam = vec3(0.0, 0.0, -100.0);\nfloat FOV = 0.25;\n\n// Glow settings\nvec3 glow_color = vec3(1.0, 1.0, 1.0);\nfloat glow_strength = 0.0;\n\nuniform vec2 cursor;\n\nfloat PI = 3.14159265358979323;\n\n// Scene (creating the scene)\nfloat scene(vec3 from) {\n    float speed = 1.0;\n    float rotation = iTime;\n    mat2 rot = mat2(\n        cos(rotation * speed), -sin(rotation * speed),\n        sin(rotation * speed), cos(rotation * speed)\n    );\n    from.xz *= rot; // Y rotation\n    \n    float de = deRound(deCuboid(rotate(from, 0.5, -1.0, 0.25, vec3(0.0)), vec3(0.0, 0.0, -10.0), vec3(130.0, 130.0, 20.0)), 10.0);\n    de = smoothBoolSubtraction(deSphere(rotate(from, 0.5, -1.0, 0.25, vec3(0.0)), vec3(cos(iTime * 2.0) * 45.0, 0.0, -10.0), 50.0), de, 5.0);\n    de = smoothBoolUnion(de, from.y + 25.0 - floor(cos(from.x / 12.0) + sin(from.z / 12.0) + 0.5) * 2.0, 20.0);\n    de = boolUnion(de, deCuboid(from, vec3(0.0, -5.0, 30.0), vec3(45.0)));\n    return de;\n    \n}\n\n// March the rays!\nvec3 render(vec3 from, vec3 dir) {\n    vec3 at = from;\n    float closest = 10000.0;\n    for(float totalDE = 0.0; totalDE < 100.0; totalDE += 1.0) {\n        float de = scene(at);\n        at += dir * de;\n        if(de < closest) {\n            closest = de;\n        }\n        if(de < 0.00001) {\n            float closestShadow = 10000.0;\n            float shade = 1.0;\n            float bias = 1.0;\n            vec3 atShadow = at + bias * sun;\n            float totalShadowDE = bias;\n            for(float shadowDE = 0.0; shadowDE < 100.0; shadowDE += 1.0) {\n                float deShadow = clamp(scene(atShadow), 0.0, 1.0);\n                atShadow += sun * deShadow;\n                if(deShadow < closestShadow) {\n                    closestShadow = deShadow;\n                    shade = min(shade, deShadow / totalShadowDE);\n                }\n                totalShadowDE += deShadow;\n            }\n            return vec3(0.75) * clamp(shade, 0.2, 1.0) - totalDE / 500.0;\n        }\n    }\n    return glow_color * glow_strength - closest / 10.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    c = render(cam, normalize(vec3(gl_FragCoord.x / iResolution.x - 0.5, gl_FragCoord.y / iResolution.y - 0.5, FOV)));\n    fragColor = vec4(c, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtSD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtSR4", "name": "Anaglyph Temple", "author": "Koltes", "description": "Code based on https://www.shadertoy.com/view/wdc3zX and uses trad code from iq and all\nTemple based on Temple of Concordia, Agrigento https://sketchfab.com/3d-models/temple-of-concordia-agrigento-b28\nMade for the 3rd issue of https://fanzine.cookie.paris/", "tags": ["anaglyph"], "likes": 4, "viewed": 298, "date": "1571602185", "time_retrieved": "2024-06-20T19:47:23.531225", "image_code": "// Code based on https://www.shadertoy.com/view/wdc3zX and uses trad code from iq and all\n// Temple based on Temple of Concordia, Agrigento https://sketchfab.com/3d-models/temple-of-concordia-agrigento-b28946ad96af42b29f248a4d89050d16\n// Made for the 3rd issue of https://fanzine.cookie.paris/\n\nconst float divergence = 1.0;\nconst float fieldOfView = 1.5;\n\nfloat random(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nvec3 look (vec3 eye, vec3 target, vec2 anchor, float fov) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * fov + right * anchor.x + up * anchor.y);\n}\n\nfloat hash1( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat hash2(vec2 co) {\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash3(vec3 p) {\n\tp  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n\treturn fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 oi = vec2(0,1);\n\treturn mix(mix(mix( hash3(p),\n\t\t\t\t\t\thash3(p+oi.yxx),f.x),\n\t\t\t\tmix( hash3(p+oi.xyx),\n\t\t\t\t\t\thash3(p+oi.yyx),f.x),f.y),\n\t\t\tmix(mix( hash3(p+oi.xxy),\n\t\t\t\t\t\thash3(p+oi.yxy),f.x),\n\t\t\t\tmix( hash3(p+oi.xyy),\n\t\t\t\t\t\thash3(p+oi.yyy),f.x),f.y),f.z);\n}\n\nfloat fbm (vec3 p, float s) {\n\tfloat value = 0.0;\n\tfloat amplitude = 1.;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tvalue += amplitude * noise(p);\n\t\tp *= 2.;\n\t\tp.yx *= rot(iTime*s*.5);\n\t\tp.yz *= rot(iTime*s*.3);\n\t\tp.xz *= rot(iTime*s*.6);\n\t\tamplitude *= .5;\n\t}\n\treturn value;\n}\n\nvec3 camera (vec3 eye) {\n    vec2 mouse = iMouse.xy/iResolution.xy*2.-1.;\n    if (iMouse.z > 0.5) {\n        eye.yz *= rot(mouse.y*3.1415);\n        eye.xz *= rot(mouse.x*3.1415);\n    }\n    return eye;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCone( in vec3 p, in float a )\n{\n    float q = length(p.xy);\n    return dot(vec2(sin(a),cos(a)),vec2(q,p.z));\n}\n\nfloat sdColumn(vec3 p) {\n    float a = atan(p.z, p.x);\n    float d = length(p.xz) - (1. - p.y * 0.02 + sin(a * 20.) * .1);\n    d = max(d, -p.y);\n    d = max(d, p.y - 10.);\n    \n    float dCone = sdCone(p.xzy*vec3(1,1,-1)+vec3(0,0,2.), 1.45);\n    dCone = max(dCone, -p.y + 9.8);\n    dCone = max(dCone, p.y - 10.2);\n    \n    d = smoothmin(d, dCone, 0.2);\n    d = smoothmin(d, sdBox(p - vec3(0, 10.5, 0), vec3(1.1, 0.3, 1.1)), 0.2);\n    \n    return d;\n}\n\nfloat sdTemple(vec3 p) {\n    p.xz = abs(p.xz);\n    const float sep = 6.;\n    float d = sdColumn(p - vec3(sep*0.5, 0, sep*5.5));\n    d = min(d, sdColumn(p - vec3(sep*1.5, 0, sep*5.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*5.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*4.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*3.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*2.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*1.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*0.5)));\n    const float minisep = 5.;\n    d = min(d, sdColumn(p - vec3(minisep*0.5, 0, minisep*4.5)));\n    d = min(d, sdColumn(p - vec3(minisep*1.5, 0, minisep*4.5)));\n    d = min(d, sdColumn(p - vec3(minisep*1.5, 0, minisep*3.5)));\n    d = min(d, sdColumn(p - vec3(minisep*1.5, 0, minisep*2.5)));\n    d = min(d, sdColumn(p - vec3(minisep*1.5, 0, minisep*1.5)));\n    d = min(d, sdColumn(p - vec3(minisep*1.5, 0, minisep*0.5)));\n    \n    float dTop = sdBox(p - vec3(0,11.5,0), vec3(sep*2.5+1.1, 1., sep*5.5+1.1));\n    dTop = min(dTop, sdBox(p - vec3(0, 13.5, sep*5.5-3.5), vec3(sep*2.5+1.1, 1., 4.6)));\n    dTop = max(dTop, -sdBox(p, vec3(sep*2.5-1.1, 20., sep*5.5-1.1)));    \n    dTop += fbm(p, 0.)*.1;\n    d = min(d, dTop);\n    \n    vec3 q = p;\n    q.x -= (sep*2.5+3.);\n    q.y -= 14.5;\n    q.xy *= rot(.2);\n    float dTri = q.y;\n    dTri = max(dTri, -(p.y - 14.5));\n    dTri = max(dTri, p.x - (sep*2.5+1.));\n    dTri = max(dTri, abs(p.z - sep*5.5 - .7) - 1.);\n    dTri += fbm(p, 0.)*.1;\n    d = min(d, dTri);\n    \n    const float stepsep = 1.;\n    float dSteps = sdBox(p - vec3(0, -0.3, 0), vec3(sep*3.+0.*stepsep, .6, sep*6.+0.*stepsep)) + smoothstep(0.05, 0., abs(fract(p.x*.4)-.5))*.1;\n    dSteps = min(dSteps, sdBox(p - vec3(0, -0.9, 0), vec3(sep*3.+1.*stepsep, .6, sep*6.+1.*stepsep)) + smoothstep(0.05, 0., abs(fract(p.x*.4+.5)-.5))*.1);\n    dSteps = min(dSteps, sdBox(p - vec3(0, -1.5, 0), vec3(sep*3.+2.*stepsep, .6, sep*6.+2.*stepsep)) + smoothstep(0.05, 0., abs(fract(p.x*.4)-.5))*.1);\n    dSteps = min(dSteps, sdBox(p - vec3(0, -2.1, 0), vec3(sep*3.+3.*stepsep, .6, sep*6.+3.*stepsep)) + smoothstep(0.05, 0., abs(fract(p.x*.4+.5)-.5))*.1);\n    dSteps += fbm(p, 0.)*.2;\n    d = min(d, dSteps);\n    \n    float dGround = p.y + 2.4;\n    dGround += fbm(p, 0.)*.1;\n    d = min(d, dGround);\n    \n    return d;\n}\n\nfloat sdCloud (vec3 p) {\n\tp.y -= 40.-20.*sin(6.283/8.*clamp(length(p.xz)/200.,0.,1.));\n\tfloat shape = abs(p.y+5.*fbm(p*.2, .01))-5.*(noise(p*.1+iTime*.1)-.4);\n\tshape = mix(1.,shape, clamp(length(p.xz),0.,1.));\n\treturn shape;\n}\n\nfloat geometry (vec3 pos) {\n    pos = camera(pos);\n    float scene = sdTemple(pos);\n    scene = min(scene, sdCloud(pos));\n    return scene;\n}\n\nfloat raymarch ( vec3 eye, vec3 ray ) {\n    float dither = random(ray.xy+fract(iTime));\n    float total = dither;\n    const int count = 50;\n    for (int index = count; index > 0; --index) {\n        float dist = geometry(eye+ray*total);\n        dist *= 0.9+.1*dither;\n        total += dist;\n        if (dist < 0.001 * total)\n            return float(index)/float(count);\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 diverg = vec2(divergence, 0.);\n    vec3 eye = vec3(10,1,50);\n    vec3 target = vec3(-10,15,0);\n    \n    vec2 uv = 2.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 eyeLeft = eye - diverg.xyy;;\n    vec3 eyeRight = eye + diverg.xyy;\n    vec3 rayLeft = look(eyeLeft, target, uv, fieldOfView);\n    vec3 rayRight = look(eyeRight, target, uv, fieldOfView);\n    float red = raymarch(eyeLeft, rayLeft);\n    float cyan = raymarch(eyeRight, rayRight);\n    fragColor = vec4(red,vec2(cyan),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtSR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtSRH", "name": "probabilist rect. billiard  2", "author": "FabriceNeyret2", "description": "let follows the trajectory of N*N balls starting from the same location.\nContinuous front variant.\n\nNB:  try vec2(iMouse.xy/R)  instead of vec2(.5)\n        try dashed variant", "tags": ["simulation", "random", "billiard"], "likes": 5, "viewed": 286, "date": "1571484520", "time_retrieved": "2024-06-20T19:47:23.864618", "image_code": "// variant of https://shadertoy.com/view/wstXz8\n\n/* // code golfed version: 263 chars ( from 412)\n\n#define mainImage(O,u)                                            \\\n    vec2  R = iResolution.xy,                                     \\\n          U = u / R.y,                                            \\\n          S = 2.* R / R.y, P, _P, A,B;                            \\\n    float l = 1e9, h, a=0.;                                       \\\n    for ( ; a <= 6.29; a += .01461 )                              \\\n        _P = P,                                                   \\\n        P = .5 + iTime * cos(a+vec2(0,11)),                       \\\n        P = min( P = mod( P, S), S-P ),                           \\\n        h = clamp(dot(A= U-_P, B= P-_P) / dot(B,B), 0., 1.),      \\\n        a>0. ? l = min( l, dot(A -= B*h , A ) ) :l;               \\\n    O += 1.-R.y/2.*sqrt(l)  /*\n*/\n\n\n#define N 430. // 17*17 = 289\n\nfloat line(vec2 p, vec2 a,vec2 b) { // segment with disc ends: seamless distance to segment\n\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    p -= b * h;\n    return dot(p,p);                                  // dist² to segment\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, \n          U = u / R.y,\n          S = R / R.y, P, _P;\n    \n    float t = (R.y<250.) ? iTime - 9. : iTime, s=0.,\n        l = 1e9;\n    \n    for ( float a = 0.; a <= 6.284; a += 6.283/N, s=1.-s ) {\n        _P = P;\n        P = vec2(.5) + t * vec2(cos(a),sin(a));  // all directions around start position\n        P = mod( P/S, 2.); P = min( P, 2.-P )*S; // wrap virtual P(t) in recursive border \"mirrors\"\n\n      //l = min(l, dot(P-=U,P));                 // min distance to point\n        if (a>0.) l = min(l, line(U,_P,P));      // min distance to line between points\n      //if (s>0.) l = min(l, line(U,_P,P));      // dashed variant\n    }\n    \n    O = vec4( smoothstep( 2./R.y,0., sqrt(l) )); // draw dot or line\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtSRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtSW8", "name": "borrowed from leon", "author": "Crackhausen", "description": "test", "tags": ["glitch"], "likes": 6, "viewed": 325, "date": "1571884736", "time_retrieved": "2024-06-20T19:47:23.864618", "image_code": "// Anaglyph Structure\n// Framed for https://fanzine.cookie.paris/\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.10.24\n// Using code from Inigo Quilez\n\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat random (in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\n\nvec3 look (vec3 eye, vec3 target, vec2 anchor) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * .5 + right * anchor.x + up * anchor.y);\n}\n\n\nfloat map (vec3 pos) {\n    float scene = 10.0;\n    float r = 1.50;\n    const float count = 7.0;\n    for (float index = count; index > 0.0; --index)\n    {\n        pos.xz = abs(pos.xz)-1.5*r;\n        pos.xz *= rot(0.4/r + iTime * 0.1);\n        pos.yz *= rot(1.5/r + iTime * 0.05);\n        pos.yx *= rot(.2/r + iTime * 0.05);\n        scene = min(scene, length(pos.xy)-0.001);\n        scene = min(scene, length(pos)-0.3*r);\n        r /= 1.8;\n    }\n    return scene;\n}\n\nvec4 raymarch (vec3 eye, vec3 ray) {\n    float dither = random(ray.xy+fract(iTime));\n    vec4 result = vec4(eye, 0);\n    float total = 0.0;\n    float maxt = 20.0;\n    const float count = 30.;\n    for (float index = count; index > 0.0; --index) {\n        result.xyz = eye + ray * total;\n        float dist = map(result.xyz);\n        if (dist < 0.001 + total * .002 || total > maxt) {\n            result.w = index / count;\n            break;\n        }\n        dist *= 0.9 + 0.1 * dither;\n        total += dist;\n    }\n    result.w *= step(total, maxt);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(1.,0.5,-4.);\n    vec3 at = vec3(0);\n    vec3 ray = look(eye, at, uv);\n    vec3 eyeoffset = 0.02*normalize(cross(normalize(at-eye), vec3(0,1,0)));\n\n    vec4 resultLeft = raymarch(eye-eyeoffset, ray);\n    vec4 resultRight = raymarch(eye+eyeoffset, ray);\n    fragColor = vec4(resultLeft.w,vec2(resultRight.w),1);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "unknown-license-reference", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtSWM", "name": "PI", "author": "96logda", "description": "Right now I am trying to learn how to make text, so my idea was to start with combining pipes to make a simple text.", "tags": ["text", "antialiasing", "pi", "distance", "field", "aa", "3", "shape", "pipe", "14"], "likes": 2, "viewed": 200, "date": "1572180619", "time_retrieved": "2024-06-20T19:47:24.264371", "image_code": "//Copyright (c) 2019-10-26 - 2019-10-27 by Angelo Logahd\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat pipe1(float r, vec2 p, float l)\n{\n\tfloat v = max(abs(p.x) - r, abs(p.y) - l);\n\treturn min(v, max(abs(p.x) - 0.07, abs(abs(p.y) - (l - 0.04))));\n}\n\nfloat pipe2(float r, vec2 p, float rad, vec2 d)\n{\n\treturn max(max(abs(length(p) - rad) - r, p.x * d.x), p.y * d.y);\n}\n\n// Based on https://thebookofshaders.com/07/ with some small changes to get the effect I wanted.\nfloat backgroundDE(in vec2 st)\n{\n    int N = 4;\n\n    // Angle and radius from the current pixel\n    float a = atan(st.x, st.y) + PI;\n    float r = TWO_PI / float(N);\n\n    // Shaping function that modulate the distance\n    float d = cos(floor(1.0 + a / r) * r - a) * length(st);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    \n    // Move the space\n    st.x += 0.25 + sin(iTime * 0.5) * 0.15;\n    \n    // Remap the space to -1.0 to 1.0\n    st = st * 2.0 - 1.0;\n    \n    float d = backgroundDE(st - vec2(0.03, 0.0));\n    \n    // PI text\n    d = min(d, pipe1(0.03, st, 0.4));\n    d = min(d, pipe2(0.03, st - vec2(0.1, 0.15), 0.2, vec2(-0.5, 0.1)));\n    d = min(d, pipe1(0.03, st - vec2(0.65, 0.0), 0.4));\n    \n    //3.14 text\n    //3\n    d = min(d, pipe2(0.01, st - vec2(1.1, 0.11), 0.25, vec2(-0.5, 0.1)));\n    d = min(d, pipe2(0.01, st - vec2(1.1, -0.4), 0.25, vec2(-0.5, 0.1)));\n    //.\n\td = min(d, pipe2(0.00, st - vec2(1.55, -0.51), 0.0, vec2(-0.5, 0.1)));\n    //1\n    d = min(d, pipe1(0.03, st - vec2(1.85, -0.1), 0.45));\n    //4\n    d = min(d, pipe1(0.03, st - vec2(2.2, 0.1), 0.25));\n    d = min(d, pipe1(0.13, st - vec2(2.5, -0.1), 0.01));\n    d = min(d, pipe1(0.03, st - vec2(2.6, -0.1), 0.45));\n    \n    // The smoothstep with the small interval is used to achive a simple anti aliasing.\n    vec3 color = vec3(1.0 - smoothstep(0.05, 0.06, d) * 1.0 - vec3(1.0, 0.0, 0.0));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtSWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtSzS", "name": "Z-buffer showcase", "author": "dfactor", "description": "Simple linear z-buffer realization.", "tags": ["3d", "raymarching", "sdf", "depth", "zbuffer"], "likes": 3, "viewed": 182, "date": "1572274954", "time_retrieved": "2024-06-20T19:47:24.264595", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 5.0;\nconst float MAX_DIST = 25.0;\nconst float EPSILON = 0.0001;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat boxSDF(vec3 p, vec3 b) {\n  \tvec3 q = abs(p) - b;\n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sceneSDF(vec3 p) {\n    p = rotateY(iTime / 2.0) * p;\n    return unionSDF(\n        differenceSDF(\n            boxSDF(p, vec3(1.0, 1.0, 1.0)),\n            unionSDF(\n                sphereSDF(p + vec3(1.0, -1.0, 1.0), 1.66),\n                sphereSDF(p + vec3(-1.0, 1.0, -1.0), 1.66)\n            )\n        ),\n        sphereSDF(p, 0.5)\n    );\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t\treturn;\n    }\n\n    vec3 p = eye + dist * worldDir;\n    \n    float depth = (2.0 * dist) / (MAX_DIST + MIN_DIST);\n    \n    vec3 color = vec3(depth);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtXDM", "name": "g_circles", "author": "guanguan", "description": "number of circles", "tags": ["newbie"], "likes": 0, "viewed": 48, "date": "1572188102", "time_retrieved": "2024-06-20T19:47:24.264595", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n\tst=st*2.0-1.0;\n    float len = length(abs(st)-vec2(sin(iTime)));\n    fragColor.xyz=vec3(fract(len*10.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtXDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtXRM", "name": "Shadertober 21 Treasure", "author": "GreenChicken", "description": "Didn't have time to do something closest to my references", "tags": ["raymarching", "inktober"], "likes": 4, "viewed": 316, "date": "1571678720", "time_retrieved": "2024-06-20T19:47:25.203924", "image_code": "// SHADERTOBER 21 Treasure\n// Poulet vert 21-10-2019\n// Thanks iq, leon, everybody yeah yeah\n\n#define PI 3.14159\n#define MAXSTEP 64\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat ThirdRules(vec2 uv)\n{\n    float r = 0.; // final rule output\n    float rs = 0.005; // rule line size\n    float ds = 0.5; // dot size\n    \n    float hr = 0.0;\n    hr = step(fract(uv.x * 3.), rs);\n    hr *= 1. - step(uv.x, .1);\n    float d = step(fract(uv.y * 100.), ds);\n    hr = min(hr, d);\n    \n    float vr = 0.0;\n    d = step(fract(uv.x * 100.), ds);\n    vr = min(step(fract(uv.y * 3.), rs), d);\n    vr *= 1. - step(uv.y, .1);\n    \n    return max(hr, vr);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n// Scene setup\nvec2 map(vec3 pos)\n{\n    vec2 scene = vec2(0.0, 0.0);\n    \n    float time = iTime*4.0;\n    \n    pos.z += time;\n    \n    vec3 cubP = pos + vec3(0.0);\n    cubP = opRep(cubP, vec3(0.0, 0.0, 1.0));\n    float world = sdBox(cubP, vec3(1.0));\n    \n    vec3 triP = pos + vec3(0.0);\n    triP = opRep(triP, vec3(0.0, 0.0, 1.0));\n    float tri = sdTriPrism(triP, vec2(1.0, 2.0));\n    \n    world = max(world, -tri);\n    \n    triP = pos + vec3(0.0, 0.0, 0.0);\n    triP.xz *= rot(PI/2.0);\n    triP = opRep(triP, vec3(5.0, 0.0, 0.0));\n    tri = sdTriPrism(triP, vec2(1.0, 2.0));\n    \n    world = max(world, -tri);\n    \n    // glogofkdgkdfjgkj\n    vec3 fckP = pos + vec3(0.0, 0.0, time*2.0);\n    fckP = opRep(fckP, vec3(0.0, 0.0, 10.0));\n    float fck = sdTriPrism(fckP, vec2(.5, .01));\n    fckP = pos + vec3(0.0, 0.0, time*2.0);\n    fckP = opRep(fckP, vec3(0.0, 0.0, 10.0));\n    fck = max(fck, -sdTriPrism(fckP, vec2(.4, .6)));\n    \n    // materials\n    scene = vec2(world, 0.0);\n    scene = opU2(scene,vec2(fck, 1.0));\n    \n    return scene;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(float(i)/128., ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(t.x+fract(iTime), vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(0.0);\n        \n    }\n    else\n    {\n        float depth = 1.0 - t.x;\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(depth)*.4;\n        }\n        else if(t.y == 1.0)\n        {\n            col = polyCol;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(sin(iTime)*.5, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + (2.0+sin(iTime)) * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 cp = vec3(0.0, 0.0, -5.0);\n    vec3 ct = vec3(0.0, sin(iTime)*.2, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, uv);\n    \n    col.x -= length(uv)-.5;\n    \n    col += ThirdRules(screenUV)*.1;\n    \n    col -= clamp((length(uv))*.2, 0.0, 1.0);\n    \n    fragColor = vec4(sqrt(clamp(col, 0.0, 1.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtXRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtXRn", "name": "FVM - Test", "author": "dfactor", "description": "First test of FVM by A. V. Tolok.", "tags": ["sdf", "voxel", "rfunc", "fvm", "functionalvoxelmodeling"], "likes": 2, "viewed": 112, "date": "1571338858", "time_retrieved": "2024-06-20T19:47:25.658649", "image_code": "// Old variant\n/*float circle(vec2 uv, vec2 center, float radius) {\n    return (uv.x-center.x)*(uv.x-center.x) + (uv.y-center.y)*(uv.y-center.y) - radius*radius;\n}*/\n\nfloat circle(vec2 uv, vec2 center, float radius) {\n    return length(uv-center)*length(uv-center) - radius*radius;\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b) {\n    return ((b.y-a.y)*uv.x + (a.x-b.x)*uv.y + (b.x*a.y-a.x*b.y))/sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));\n}\n\nfloat sum(float a, float b, float alpha) {\n    return (a+b+sqrt(a*a + b*b - 2.0*alpha*a*b))*(1.0/(1.0+alpha));\n}\n\nfloat mul(float a, float b, float alpha) {\n    return (a+b-sqrt(a*a + b*b - 2.0*alpha*a*b))*(1.0/(1.0+alpha));\n}\n\n// Our FV model\nfloat map(vec2 uv, float alpha) {\n    //vec2 pos1 = vec2(-cos(iTime)/2.0, 0.0);\n    //vec2 pos2 = vec2(0.0, sin(iTime)/2.0);\n    \n    //return mul(circle(uv, pos1, 0.5), circle(uv, pos2, 0.5), alpha);\n    \n    vec2 a = vec2(-0.5, mix(0.0,-0.5,0.5+cos(iTime)/2.0));\n    vec2 b = vec2(0.0, 0.0);\n    vec2 c = vec2(mix(-0.5,0.5,0.5+cos(iTime)/2.0), -0.5);\n    \n    float r = 0.75 + cos(iTime)/4.0;\n    \n    return sum(mul(line(uv, a, b), line(uv, b, c), alpha), circle(uv, b, r), alpha);\n}\n\n// Calculating the Multi-Dimennsional Image\nvec4 mdi(vec2 uv1, vec2 uv2, vec2 uv3, float value1, float value2, float value3) {\n    float Ai = uv1.y*(value2-value3)-uv2.y*(value1-value3)+uv3.y*(value1-value2);\n    float Bi = -(uv1.x*(value2-value3)-uv2.x*(value1-value3)+uv3.x*(value1-value2));\n    float Ci = uv1.x*(uv2.y-uv3.y)-uv2.x*(uv1.y-uv3.y)+uv3.x*(uv1.y-uv2.y);\n    float Di = uv1.x*(uv2.y*value3-uv3.y*value2)-uv2.x*(uv1.y*value3-uv3.y*value1)+uv3.x*(uv1.y*value2-uv2.y*value1);\n\n    float Nx = Ai / sqrt(Ai*Ai + Bi*Bi + Ci*Ci + Di*Di);\n    float Ny = -Bi / sqrt(Ai*Ai + Bi*Bi + Ci*Ci + Di*Di);\n    float Nz = -Ci / sqrt(Ai*Ai + Bi*Bi + Ci*Ci);\n    float Nt = Di / sqrt(Ai*Ai + Bi*Bi + Ci*Ci + Di*Di);\n    \n    int flag1 = 0;\n    int flag2 = 0;\n    int flag3 = 0;\n    if (value1>=0.0) flag1 = 1;\n    if (value2>=0.0) flag2 = 1;\n    if (value3>=0.0) flag3 = 1;\n    \n    int flag_sum = flag1 + flag2 + flag3;\n    if (flag_sum < 2) return vec4((Nx+1.0)/2.0, (Ny+1.0)/2.0, (Nz+1.0)/2.0, (Nt+1.0)/2.0); //xyz representation\n    return vec4(0.5, 0.5, 1.0, 0.0); //+Z normal\n}\n\nvec4 calcImage(vec2 uv, float alpha) {\n    vec2 uv1 = uv;\n    vec2 uv2 = vec2(uv.x, uv.y+0.005);\n    vec2 uv3 = vec2(uv.x+0.005, uv.y);\n    \n    float value1 = map(uv1, alpha);\n    float value2 = map(uv2, alpha);\n    float value3 = map(uv3, alpha);\n    \n    return mdi(uv1, uv2, uv3, value1, value2, value3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 vUV = fragCoord.xy / iResolution.xy;\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n    \n    //vec4 value = circle_mdi(vWindow, vec2(sin(iTime)*0.5, cos(iTime)*0.5), 0.5);\n    //vec4 value = line_mdi(vWindow, vec2(sin(iTime),1), vec2(cos(iTime),-1));\n    vec4 value = calcImage(vWindow, 0.0);\n    vec3 col = vec3(value.x, value.y, value.z);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtXRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtXW8", "name": "Flying Neon Balls Test", "author": "Delvar", "description": "Just a test of neon lights with basic black fog. \nUses the ray march process to accumulate the neon glow.\nAlso uses a dither function to modify the distance travelled to reduce banding.\n", "tags": ["test", "balls", "neon"], "likes": 1, "viewed": 156, "date": "1571922099", "time_retrieved": "2024-06-20T19:47:27.943777", "image_code": "// =================================================================\n//  'Flying Neon Balls Test'\n//  https://www.shadertoy.com/view/wdtXW8\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\tCredits: \n//\tThe bulk of the ray tracer and lighting was inspired by watching a video by Inigo Quilez https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\tand his related shadertoy iq: 'Happy Jumping' : https://www.shadertoy.com/view/3lsSzf\n//\n//\tDistance functions from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//\t\tand implementation iq : 'Raymarching - Primitives' : https://www.shadertoy.com/view/Xds3zN\n//\n//\tMost of the other Math came from wikipedia https://www.wikipedia.org/\n// =================================================================\n#define RAY_MAX_STEPS 100\n#define RAY_MAX_DISTANCE 20.0\n#define OBJECT_MIN_SURFACE_DISTANCE 0.001\n\n#define PI\t3.1415926535897932384626433832795\n\n#define DEBUG_RAY_DITHER\n#define DEBUG_CAMERA_FLY\n#define DEBUG_WHITE_NEON\n#define DEBUG_FLICKER\n//#define DEBUG_MORE_SHAPES\n\n// Flags to use texture lookups instead of noise functions, should be faster but introduces repetiton.\n//#define NOISE_TEXTURE_3D iChannel0\n//#define NOISE_TEXTURE_2D iChannel1\n\n// -- The Materials\n#define MAT_SKY 0\n//#define MAT_GROUND 1\n#define MAT_NEON 2\n\n// ========== Structs ==========\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance from screen\n};\n\nstruct ray {\n\tvec3 origin, direction;\n};\n\nstruct rayMarchHit {\n    vec3 origin, surfaceNormal;\n    float distance, fog;\n    vec3 neon;\n    int materialId;\n    int iteration;\n};\n\nstruct sphere {\n    vec3 origin;\n    float radius;\n};\n// ========== ==========\n    \n// ========== Rotation ==========\n\nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\n\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    //return rotateX(pitch) * rotateY(yaw) * rotateZ(roll);\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\n//Converts a unit vector into polar coordinates , vec2(Yaw, Pitch).\nvec2 toPolar(vec3 point) {\n    return vec2(atan(point.x,point.z),asin(point.y));\n}\n\n// ========== ==========\n\n// ========== Ray Constructor ==========\n\nray getRay(vec2 uv, camera camera) {\n    ray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\n// ========== ==========\n\n// ========== Hash Functions ==========\n\n#define HD 43758.5453123\n#define HE 12.989824344\n#define HF 78.233235235\n#define HG 44.230257362\n#define HH 83.597411735\n\nfloat hash11(float st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(vec3(HF,HG,HH)*st)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(vec2(HF,HG)*st)&255,0).x;\n    # else\n    return fract(sin(st*HE)*HD); \n    #endif\n}\n\nfloat hash21(vec2 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE,(st.x*st.y)*HE) &31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st*HE)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec2(HE,HF)))*HD);\n    #endif\n}\n\nfloat hash31(vec3 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st.x*HE+st.z*HF,st.y*HG+st.z*HH)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec3(HE,HF,HG)))*HD);\n    #endif\n}\n\n\n//FIXME: find alternativs with texture lookup\nvec3 hash13(float st) {\n    return fract(sin(st*vec3(HE,HH,HG))*HD);\n}\n\nvec3 hash23(vec2 st) {\n    return fract(sin(st.xyx*vec3(HE,HF,HH))*HD);\n}\n\nvec3 hash33(vec3 st) {\n    return fract(sin((st+vec3(HD,HH,HE))*vec3(HH,HE,HG))*HD);\n}\n\n// ========== ==========\n\n// ========== Helper Functions ==========\n\n//Simple remap of value and range to new value in new range\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\n//Quintic interpolation curve\nvec2 quinticInterpolation(vec2 x) {\n    return x*x*x*(x*(x*6.-15.)+10.);\n}\n\nfloat quinticInterpolation(float x) {\n    return x*x*x*(x*(x*6.-15.)+10.);\n}\n\n// ========== ==========\n\n// ========== Coherent Noise ==========\n\n\n// - Value Noise, 2d, Unsigned\nfloat valueNoise2du(vec2 samplePoint) {\n    vec2 pointI = floor(samplePoint);\n    vec2 pointF = fract(samplePoint);\n    float bl = hash21(pointI + vec2(0.0,0.0) );\n    float br = hash21(pointI + vec2(1.0,0.0) );\n    float fl = hash21(pointI + vec2(0.0,1.0) );\n    float fr = hash21(pointI + vec2(1.0,1.0) );\n    //vec2 u = smoothstep(0.0,1.0,pointF);\n    vec2 u = quinticInterpolation(pointF);\n    float b = mix(bl,br,u.x);\n    float f = mix(fl,fr,u.x);\n\n    return mix(b,f,u.y);\n}\n\n// - Value Noise, 1d, Unsigned\nfloat valueNoise1du(float samplePoint) {\n    float pointI = floor(samplePoint);\n    float pointF = fract(samplePoint);\n    float b = hash11(pointI);\n    float f = hash11(pointI + 1.0 );\n    float u = quinticInterpolation(pointF);\n    return mix(b,f,pointF);\n}\n\n// - Value Noise, 1d, Unsigned, Wraped\nfloat valueNoise1duw(float samplePoint, float wrap) {\n    float pointI = floor(samplePoint);\n    float pointF = fract(samplePoint);\n    float a = hash11(mod(pointI, wrap));\n    float b = hash11(mod(pointI + 1.0 ,wrap));\n    float u = quinticInterpolation(pointF);\n    return mix(a,b,u);\n}\n\n// ========== ==========\n\n// ========== Distance Feilds ==========\n\n// All primitives are centered at the origin.\n\n//Sphere - exact\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\n//Box - exact\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// ========== ==========\n\n// ========== Ray Marcher ==========\n\nrayMarchHit GetRayMarchHit(vec3 position, float minSurfaceDistance, float time) {\n    rayMarchHit hit;\n    hit.distance = RAY_MAX_DISTANCE;\n    \n    float s1 = 5.0;\n    \n    vec3 id = hash33( floor((position+0.5*s1)/s1) );\n    vec3 positionRepeat = mod(position+0.5*s1,s1)-0.5*s1;\n\t\n    float s2 = (s1/10.0);\n    \n    float newDistance;\n    \n    #if defined(DEBUG_MORE_SHAPES)\n\tif (hash31(id) < 0.25) {\n    \tnewDistance= sdSphere(positionRepeat,s2);\n    } else if (hash31(id) < 0.5) {\n    \tnewDistance = sdBox(positionRepeat, vec3(s2));\n    } else if (hash31(id) < 0.75) {\n    \tnewDistance = sdTorus( positionRepeat, vec2(s2,s2*0.2) );\n    } else {\n        newDistance = sdCapsule( positionRepeat, vec3(0.0,-s2*0.5,0.0), vec3(0.0,s2*0.5,0.0) ,s2*0.25 );\n    }\n    #else\n    \tnewDistance= sdSphere(positionRepeat,s2);\n    #endif\n    \n    if (newDistance < hit.distance) {\n        hit.origin = position;\n    \thit.distance = newDistance;\n        hit.materialId = MAT_NEON;\n        #if defined(DEBUG_FLICKER)\n        \thit.neon = normalize(id+ vec3(0.001)) * ( 1.0-valueNoise1duw((time+hash31(id)*10.0)*100.0,200.0)*0.5); //add here to remove artifacts with 0 length Ids\n        #else\n        \thit.neon = normalize(id+ vec3(0.001));\n        #endif\n\t}\n\n    return hit;\n}\n\nrayMarchHit RayMarch(ray ray, float maxDistance, float minSurfaceDistance, int maxSteps, float time)\n{\n    rayMarchHit hit;\n    float lastDistance = 0.0;\n    float accumilatedDistance = 0.0;\n\tvec3 accumilatedNeon = vec3(0.0);\n    \n    for(int i=0; i<maxSteps; i++) {\n\n        vec3 currentPoint = ray.origin + ray.direction*accumilatedDistance;\n        hit = GetRayMarchHit(currentPoint, minSurfaceDistance, time);\n        if (hit.distance > minSurfaceDistance) {\n            accumilatedNeon += (1.0-accumilatedDistance/maxDistance) * (hit.neon) * max(1.0-hit.distance/2.0,0.0) * 0.02;\n        } else {\n            #if defined (DEBUG_WHITE_NEON)\n            \taccumilatedNeon += vec3((1.0-accumilatedDistance/maxDistance));\n            #else\n            \taccumilatedNeon = abs(accumilatedNeon-vec3(0.005));\n            #endif\n        }\n\n\t\thit.iteration = i;\n\t\tlastDistance = hit.distance;\n        \n        #if defined (DEBUG_RAY_DITHER)\n        \taccumilatedDistance += mix(hit.distance*0.5,hit.distance*0.9, hash31(fract(currentPoint)));\n        #else \n        \taccumilatedDistance += hit.distance;\n        #endif\n        \n        if(accumilatedDistance >= maxDistance) {\n            hit.surfaceNormal = ray.direction;\n            hit.materialId=MAT_SKY;\n            break;\n        }\n        //terminate if we are very close or bounce back out if we end up within an object. \n        else if(hit.distance >= 0.0 && hit.distance < minSurfaceDistance) {\n            break;\n        }\n    }\n    hit.distance = accumilatedDistance;\n    hit.neon = accumilatedNeon;\n    return hit;\n}\n\n// ========== ==========\n\n// ========== Camera Motion ==========\n\nvec3 getCameraPath(float time) {\n    vec3 r;\n    r.y = (sin(time/2.0)*0.5+0.5) + (sin(time/6.0)+1.0) + (sin(time/15.0)+1.0) + 3.0;\n    r.x = ( sin(time/15.0) * 20.0 ) + sin(time/6.0) * 5.0 + sin(time/2.0) * 3.0;\n\tr.z = ( cos(time/10.0) * 30.0 ) + sin(time/5.0) * 9.0 + sin(time/3.0) * 2.0;\n    return r;\n}\n\ncamera getCamera(vec3 origin, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n    camera.origin = origin;\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw);\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec3 origin, vec3 forward, float roll, float zoom) {\n    float yaw = atan(forward.x,forward.z);\n    float pitch = asin(forward.y);\n    return getCamera(origin, roll, pitch, yaw, zoom);\n}\n\ncamera getCamera(vec2 mouse, float time) {\n    #if defined(DEBUG_CAMERA_FLY)\n    vec3 cameraPos1 = getCameraPath(time);\n    if (iMouse.z<0.5) {\n\t\tvec3 cameraPos2 = getCameraPath(time+1.5);\n        vec3 cameraPos3 = getCameraPath(time-1.5);\n\n        vec3 cameraForward = normalize(cameraPos2 - cameraPos1);\n        \n        vec3 cameraForward2 = normalize(cameraPos1 - cameraPos3);\n\n        //Take atan and nivt to -1 to +1 range\n        float yaw1 = atan(cameraForward.x,cameraForward.z)/PI;\n        float yaw2 = atan(cameraForward2.x,cameraForward2.z)/PI;\n\n        // get the differance and renormalize using fract.\n        float roll = -(fract((yaw1-yaw2)*0.5+0.5)*2.0-1.0)*5.0;\n        roll = clamp(roll,-0.5,0.5);\n        return getCamera(cameraPos1, cameraForward, roll,  0.5);\n    } else  {\n        return getCamera(cameraPos1, 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    }\n    #else\n    return getCamera(vec3(1.0,1.0,0.0), 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);    \n    #endif\n}\n\n// ========== ==========\n\n// ========== Entry Point ==========\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = iTime;\n    //vec3 debugOverlay = vec3(0.0);\n\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n    \n    //Snap to center on startup.\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    camera camera = getCamera(mouse, time);\n\n    // --\n    ray ray = getRay(uv, camera);\n    rayMarchHit hit = RayMarch(ray, RAY_MAX_DISTANCE, OBJECT_MIN_SURFACE_DISTANCE, RAY_MAX_STEPS, time);\n\n    //float yaw3 = atan(ray.direction.x,ray.direction.z)/PI;\n    //debugOverlay = vec3(abs(fract( (yaw3-yaw1)*0.5+0.5)*2.0-1.0));\n\n    vec3 colour;\n\n    // ---- Render\n\t//Distance\n    colour = vec3(hit.distance/RAY_MAX_DISTANCE);\n    colour = vec3(hit.neon);\n    //colour = vec3(camera.yaw);\n\n    // ---- \n    float exposure = 1.0;\n    \n    // Gamma\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n\n    //Clamp\n    colour = clamp(colour,0.0,1.0); \n\n    // colour grading\n    //colour = colour*vec3(1.0,0.8,1.0);\n    // compress        \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n\n    fragColour = vec4(colour,1.0);\n    //ragColour = vec4(mix(colour,debugOverlay,0.5),1.0);\n        \n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4sfGRr", "previewfilepath": "/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtXW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtXWn", "name": "mod_motionblur_rotate", "author": "Fogrex", "description": "mod motionblur rotation matrix", "tags": ["art"], "likes": 1, "viewed": 78, "date": "1571806620", "time_retrieved": "2024-06-20T19:47:27.943777", "image_code": "\nvec2 rotate(vec2 uv,float rot)\n{\n    // rotation matrix\n    float s = sin(-rot);\n    float c = cos(-rot);\n    return mat2x2(c,s,-s,c)*uv;\n}\n\nvec3 calcColor(vec2 uv, float t)\n{\n    vec2 uv2 = rotate(uv, sin(t*0.2)*6.28);\n    float d;\n    // mod\n    vec2 uv3 = mod(uv2, 0.3) / 0.3;\n    // lattice\n    if(uv3.x < 0.1 || uv3.y < 0.1)\n    {\n        return vec3(1.0,1.0,1.0);\n    }\n    return vec3(abs(uv3.x),abs(uv3.y),sin(t)*0.5+0.5);\n}\n\nvec4 motionBlur(vec2 uv, float Freq)\n{\n    float doubleFreq = Freq * Freq;\n    vec3 col = vec3(.0,.0,.0);\n    for(float i=0.0;i<Freq;i++)\n    {\n        // ∫x dx = (1/2)x^2 + C\n        col += calcColor(uv, iTime - i / Freq * 0.1 )*((Freq - i) * 2.0 / doubleFreq);\n    }\n    \n    return vec4(col,1.0);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n     vec2 uv = (2.0*fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // Output to screen\n    fragColor = motionBlur(uv,20.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtXWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtXWr", "name": "test remi displace", "author": "vankeisb", "description": "ddd", "tags": ["ddd"], "likes": 1, "viewed": 86, "date": "1571818760", "time_retrieved": "2024-06-20T19:47:27.949763", "image_code": "#define MAX_STEPS 10\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat GetDist(vec3 p) {\n    p = rotateZ((iTime + 1000.) / 6.) * rotateY((iTime + 500.) / 3.) * rotateX(iTime / 2.) * p;\n    \n    float d1 = sdSphere(p, 6.);\n    float c = sin(iTime / 2.);\n    float d2 = (sin(2. * p.x * c)*cos(2.*p.y * c)*sin(2.*p.z * c));\n    return d1 + d2;\n}\n\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(SURF_DIST, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}   \n\nfloat RayMarch(vec3 ro, vec3 rd) {    \n    float dO = 0.;\n    \n    for (int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(10, 10, -20);\n    vec3 lightV = normalize(lightPos - p);\n    vec3 normal = GetNormal(p);\n    \n    float dif = clamp(dot(normal, lightV), 0., 1.);    \n    \n\tfloat d = RayMarch(p+normal*SURF_DIST*10000., lightV);\n    if (d < length(lightPos - p)) dif *= .5;\n    return dif;\n}\n\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0, -20);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    if (d < 26.)\n    \tcol = vec3(GetLight(p));\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtXWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdV3DW", "name": "NEON TUNNEL", "author": "alro", "description": "Tunnel with 2D shapes and SDF glow on multiple layers. Distance functions from [url]https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm[/url]", "tags": ["2d", "tunnel", "sdf", "glow", "shapes", "neon"], "likes": 38, "viewed": 811, "date": "1570275554", "time_retrieved": "2024-06-20T19:47:28.640703", "image_code": "//Base values modified with depth later\nfloat intensity = 1.0;\nfloat radius = 0.05;\n\n//Distance functions from \n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triangleDist(vec2 p){ \n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat boxDist(vec2 p){\n    vec2 d = abs(p)-1.0;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat circleDist( vec2 p){\n  return length(p) - 1.0;\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = fragCoord/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre;\n    vec2 pos;\n\t\n    float t = iTime * 0.05;\n    \n    float dist;\n    float glow;\n    vec3 col = vec3(0);\n    \n    //The spacing between shapes\n    float scale = 500.0;\n    //Number of shapes\n    float layers = 15.0;\n    \n    float depth;\n    vec2 bend;\n    \n    vec3 purple = vec3(0.611, 0.129, 0.909);\n    vec3 green = vec3(0.133, 0.62, 0.698);\n    \n    float angle;\n    float rotationAngle;\n    mat2 rotation;\n    \n    //For movement of the anchor point in time\n    float d = 2.5*(sin(t) + sin(3.0*t));\n\n    //Create an out of frame anchor point where all shapes converge to    \n    vec2 anchor = vec2(0.5 + cos(d), 0.5 + sin(d));\n    \n    //Create light purple glow at the anchor loaction\n    pos = anchor - uv;\n    pos.y /= widthHeightRatio;\n    dist = length(pos);\n    glow = getGlow(dist, 0.25, 3.5);\n    col += glow * vec3(0.6,0.4,1.0);\n    \n\tfor(float i = 0.0; i < layers; i++){\n        \n        //Time varying depth information depending on layer\n        depth = fract(i/layers + t);\n\n        //Move the focus of the camera in a circle\n        centre = vec2(0.5 + 0.2 * sin(t), 0.5 + 0.2 * cos(t));\n        \n        //Position shapes between the anchor and the camera focus based on depth\n        bend = mix(anchor, centre, depth);\n     \t\n        pos = bend - uv;\n    \tpos.y /= widthHeightRatio;\n\n        //Rotate shapes\n       \trotationAngle = 3.14 * sin(depth + fract(t) * 6.28) + i;\n        rotation = mat2(cos(rotationAngle), -sin(rotationAngle), \n                        sin(rotationAngle),  cos(rotationAngle));\n        \n        pos *= rotation;\n        \n        //Position shapes according to depth\n    \tpos *= mix(scale, 0.0, depth);\n    \t\n        float m = mod(i, 3.0);\n        if(m == 0.0){\n        \tdist = abs(boxDist(pos));\n        }else if(m == 1.0){\n        \tdist = abs(triangleDist(pos));\n        }else{\n        \tdist = abs(circleDist(pos));\n        }\n       \n        //Get glow from base radius and intensity modified by depth\n    \tglow = getGlow(dist, radius+(1.0-depth)*2.0, intensity + depth);\n        \n        //Find angle along shape and map from [-PI; PI] to [0; 1]\n        angle = (atan(pos.y, pos.x)+3.14)/6.28;\n        //Shift angle depending on layer and map to [1...0...1]\n\t\tangle = abs((2.0*fract(angle + i/layers)) - 1.0);\n        \n        //White core\n    \t//col += 10.0*vec3(smoothstep(0.03, 0.02, dist));\n        \n        //Glow according to angle value\n     \tcol += glow * mix(green, purple, angle);\n\t}\n    \n    //Tone mapping\n    col = 1.0 - exp(-col);\n    \n    //Gamma\n    col = pow(col, vec3(0.4545));\n    \n    //Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdV3DW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdV3R1", "name": "Ray-Marching : Inflating", "author": "klemek", "description": "My attempt at ray-marching with scene definition, reflection and colors.\nIt's far from optimized and I'm open to any helping tips.", "tags": ["raymarching"], "likes": 1, "viewed": 192, "date": "1570796692", "time_retrieved": "2024-06-20T19:47:29.980193", "image_code": "/* \n\tPARTS :\n\t* CONSTANTS\n\t* UTILS\n\t* OBJECT DEFINITION\n\t* SCENE\n\t* RAY MARCHING\n\t* MAIN\n*/\n\n/*\n\tCONSTANTS\n*/\n\n#define MAX_STEPS 100\n#define SURFACE_DIST 1.5 / iResolution.y\n#define MAX_DIST 100.\n#define PI 3.14159\n\n#define TYPE_LIGHT 0\n#define TYPE_SPHERE 1\n#define TYPE_PLANE 2\n#define TYPE_CAPS 3\n#define TYPE_TORUS 4\n#define TYPE_BOX 5\n#define TYPE_CYL 6\n\n#define MAX_OBJECTS 10\n#define MAX_REFLECT 5\n\n/*\n\tUTILS\n*/\n\nmat3 rotY(float t)\n{\n    return mat3(\n        cos(t), 0, sin(t),\n        0, 1, 0,\n        -sin(t), 0, cos(t));\n}\n\n/*\n\tOBJECT DEFINITION\n*/\n\nstruct obj {\n    int type;\n    vec4 v;\n    vec4 w;\n    vec3 color;\n    float ref;\n};\n\nobj light(vec3 pos, vec3 color)\n{\n    return obj(TYPE_LIGHT, vec4(pos, 0), vec4(0), color, 0.);\n}\n\nobj sphere(vec3 pos, float r, vec3 color, float ref)\n{\n    return obj(TYPE_SPHERE, vec4(pos, r), vec4(0), color, ref);\n}\n\nobj plane(vec3 dir, float offset, vec3 color, float ref)\n{\n    return obj(TYPE_PLANE, vec4(dir, offset), vec4(0), color, ref);\n}\n\nobj capsule(vec3 pos1, vec3 pos2, float r, vec3 color, float ref)\n{\n    return obj(TYPE_CAPS, vec4(pos1, r), vec4(pos2, 0), color, ref);\n}\n\nobj torus(vec3 pos, float r1, float r2, vec3 color, float ref)\n{\n    return obj(TYPE_TORUS, vec4(pos, 0), vec4(r1, r2, 0, 0), color, ref);\n}\n\nobj box(vec3 pos, vec3 size, vec3 color, float ref)\n{\n    return obj(TYPE_BOX, vec4(pos, 0), vec4(size, 0), color, ref);\n}\n\nobj cylinder(vec3 pos1, vec3 pos2, float r, vec3 color, float ref)\n{\n    return obj(TYPE_CYL, vec4(pos1, r), vec4(pos2, 0), color, ref);\n}\n\n//get distance from an object by its type\nfloat getObjDist(vec3 p, obj o)\n{\n    switch (o.type) {\n    case TYPE_SPHERE:\n        return length(p - o.v.xyz) - o.v.w;\n    case TYPE_PLANE:\n        return dot(o.v.xyz, p) + o.v.w;\n    case TYPE_TORUS:\n        p -= o.v.xyz;\n        float x = length(p.xz) - o.w.x;\n        return length(vec2(x, p.y)) - o.w.y;\n    case TYPE_BOX:\n        p -= o.v.xyz;\n        return length(max(abs(p) - o.w.xyz, 0.));\n    case TYPE_CAPS:\n        vec3 ab1 = o.w.xyz - o.v.xyz;\n        vec3 ap1 = p - o.v.xyz;\n        float t1 = dot(ap1, ab1) / dot(ab1, ab1);\n        t1 = clamp(t1, 0., 1.);\n        vec3 c1 = o.v.xyz + t1 * ab1;\n        return length(p - c1) - o.v.w;\n    case TYPE_CYL:\n        vec3 ab2 = o.w.xyz - o.v.xyz;\n        vec3 ap2 = p - o.v.xyz;\n        float t2 = dot(ap2, ab2) / dot(ab2, ab2);\n        vec3 c2 = o.v.xyz + t2 * ab2;\n        float d = length(p - c2) - o.v.w;\n        float y = (abs(t2 - .5) - .5) * length(ab2);\n        float e = length(max(vec2(d, y), 0.));\n        float i = min(max(d, y), 0.);\n        return e + i;\n    }\n    return MAX_DIST;\n}\n\n/*\n\tSCENE\n*/\n\nobj scene[MAX_OBJECTS];\nint obj_count;\n\n/* \n\tRAY MARCHING\n*/\n\n//get distance from closest object in scene\nfloat getDist(vec3 p)\n{\n    float d = MAX_DIST;\n    for (int i = 0; i < obj_count; i++) {\n        d = min(d, getObjDist(p, scene[i]));\n    }\n    return d;\n}\n\n//get the normal vector of a point relative to the scene\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    vec2 e = vec2(.01, 0);\n\n    vec3 n = d - vec3(\n                     getDist(p - e.xyy),\n                     getDist(p - e.yxy),\n                     getDist(p - e.yyx));\n\n    return normalize(n);\n}\n\nstruct hit {\n    float dO;\n    float dS;\n    int index;\n};\n\n//return the closest object in scene and its distance\nhit getDist2(vec3 p)\n{\n    float d = MAX_DIST;\n    float t;\n    int hit_index = -1;\n    for (int i = 0; i < obj_count; i++) {\n        t = getObjDist(p, scene[i]);\n        if (t < d) {\n            hit_index = i;\n            d = t;\n        }\n    }\n    return hit(0., d, hit_index);\n}\n\n//ray march in a direction until an object is hit\nhit rayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    hit last;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + dO * rd;\n        last = getDist2(p);\n        dO += last.dS;\n        if (last.dS < SURFACE_DIST || dO > MAX_DIST)\n            break;\n    }\n    last.dO = dO;\n    return last;\n}\n\n//calculate the light influence on a point\nvec3 getLight(vec3 p, obj light)\n{\n    vec3 l = normalize(light.v.xyz - p);\n    vec3 n = getNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n\n    hit h = rayMarch(p + n * SURFACE_DIST * 2., l);\n    float ld = length(light.v.xyz - p);\n\n    if (h.dO < ld) {\n        dif *= .1;\n    }\n    return dif * light.color;\n}\n\n/*\n\tMAIN\n*/\n\n//add light from every sources\nvec3 getPointColor(vec3 p, vec3 hitColor)\n{\n    vec3 col = vec3(0);\n    for (int i = 0; i < obj_count; i++) {\n        if (scene[i].type == TYPE_LIGHT) {\n            col += getLight(p, scene[i]);\n        }\n    }\n    return col * hitColor;\n}\n\n//main calculation : hit and bounce over objects\nvec4 getColor(vec2 uv, vec3 ro, mat3 dir)\n{\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.)) * dir;\n\n    hit h = rayMarch(ro, rd);\n    vec3 p = ro + rd * h.dO;\n    vec3 col = vec3(0);\n    float ref = 1.;\n    int i = 0;\n    vec3 n;\n    while (h.index >= 0 && i++ < MAX_REFLECT) {\n        col += ref * getPointColor(p, scene[h.index].color) * (1. - scene[h.index].ref);\n        ref *= scene[h.index].ref;\n        if (ref > .01) {\n            n = getNormal(p);\n            rd -= 2. * dot(rd, n) * n;\n            h = rayMarch(p + rd * SURFACE_DIST * 2., rd);\n            p += (h.dO + SURFACE_DIST * 2.) * rd;\n        }\n        else {\n            break;\n        }\n    }\n\n    return vec4(col, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //normalize uv\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    //build scene\n    int i = 0;\n    scene[i++] = plane(vec3(0, 1, 0), 0., vec3(1.), .2);\n    scene[i++] = sphere(vec3(0, .5 + cos(iTime) * .2, -2), .5 + cos(iTime) * .2, vec3(0., 1., 0.), .5);\n    scene[i++] = box(vec3(0, .3, 0), vec3(.6, .3, .6), vec3(1., 0., 0.), .2);\n    scene[i++] = torus(vec3(0, 1. + sin(iTime) * .2, 0), .5, .1, vec3(1., 0., 0.), .2);\n    scene[i++] = capsule(vec3(0, .3, 0), vec3(0, .5 + cos(iTime) * .2, -2), .08 + cos(iTime) * .03, vec3(1., 1., 1.), 0.);\n    scene[i++] = cylinder(vec3(0, 0, 0), vec3(0, 1. + sin(iTime) * .2, 0), .2, vec3(1., 1., 1.), .2);\n    scene[i++] = light(vec3(2, 4, 0), vec3(.7, .3, .3));\n    scene[i++] = light(vec3(2, 4, .5), vec3(.3, .7, .3));\n\n    obj_count = i;\n\n    //specify camera\n    vec3 pos = vec3(cos(iTime - PI / 2.) * 3., 1. + cos(iTime * .3) * .5, sin(iTime - PI / 2.) * 3.);\n    mat3 dir = rotY(-iTime);\n\n    fragColor = getColor(uv, pos, dir);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdV3R1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdV3WD", "name": "Shadertober 04 - Freeze", "author": "BackwardsCap", "description": "It's chilly in here", "tags": ["freeze", "inktober", "shadertober", "backwardscaptain"], "likes": 3, "viewed": 285, "date": "1570244774", "time_retrieved": "2024-06-20T19:47:29.986335", "image_code": "#define MAX_DIST 20.0\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0)/k;\n    return min(a,b)-h*h*k*(1.0/4.0);\n}\n\n\nfloat elipsoid(vec3 p, vec3 r)\n{\n    float k=length(p/r);\n    float k1 = length(p/(r*r));\n    return k*(k-1.)/k1;\n}\n\nfloat box(vec3 p, vec3 b, float r)\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0))-r + min(max(d.x,max(d.y,d.z)),0.0);\n    \n}\n\nfloat cyl (vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y))-vec2(h,r);\n    return min(max(d.x,d.y),0.0)+length(max(d,0.0));\n    \n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nvec2 map(vec3 p)\n{\n    float f=clamp((1.+cos(iTime/3.)),0.0,1.0);\n    float r = 0.0;\n    \n    float id = mod(floor((9.5+iTime)/18.85),2.);\n    \n    float s = elipsoid(p+vec3(0,1.1,0.),vec3(3.+cos(length(p+p.x))/2.+sin(length(p+p.z))/2.,.3+f*2.,3));\n    float b=box(p,vec3(1.,1.,1.),.05);\n    float c = cyl(p+vec3(0,3.05,0),5.+p.y,2.);\n    \n    \n    vec3 sp=p+vec3(0.,2.36-f*2.,0.);\n    float snowman  =smin(sphere(sp,1.),\n                        smin(sphere(sp+vec3(0.,-.3-f,0),.7),\n                           sphere(sp+vec3(0.,.7-f*3.,0.),.5),.2),.2);\n    \n    \n    float ta = snowman;\n    if(id==1.)ta=b;\n    \n   \tfloat i=mix(s,ta,f);\n    r=min(i,c);\n    \n    float m=0.0;\n    \n    if(r==i)\n    {\n        m=2.+f;\n    }\n    else if(r==c)m=1.;\n    \n    return vec2(r,m);\n}\n\nvec3 normal(vec3 p)\n{\n    float eps = 0.0005;\n    return normalize(vec3(\n        map(vec3(p.x+eps,p.y,p.z)).x-map(vec3(p.x-eps,p.y,p.z)).x,\n        map(vec3(p.x,p.y+eps,p.z)).x-map(vec3(p.x,p.y-eps,p.z)).x,\n        map(vec3(p.x,p.y,p.z+eps)).x-map(vec3(p.x,p.y,p.z-eps)).x\n        \n    ));\n    \n}\n\nvec2 ray(vec3 ro, vec3 rd)\n{\n    float m = 0.0;\n    float t = 0.0;\n    for(int i=0;i<128;i++)\n    {\n        vec3 p = ro+rd*t;\n        vec2 h = map(p);\n        m=h.y;\n        if(h.x<0.0001)break;\n        t+=h.x;\n        if(t>MAX_DIST)break;\n    }\n    \n    if(t>MAX_DIST)t=-1.;\n    \n    return vec2(t,m);\n}\n\nvec3 color(vec3 ro, vec3 rd, vec2 r)\n{\n    vec3 col =vec3(-0.1-rd.y,0.3,1.4);\n\n    if(r.x>0.0)\n    {\n        vec3 p = ro+rd*r.x;\n        vec3 n=normal(p);\n        vec3 mate = vec3(0.2);\n        if(r.y<.5)\n        {\n            mate=vec3(.1,.1,0.1);\n        }\n        else if(r.y<1.5){\n            \n            mate=vec3(0.1,0.1,0.2);\n        }\n        else if(r.y<3.5)\n        {\n            vec3 wc = vec3(.0,.2,1.+(1.+cos(iTime-p.x*2.)*.2+sin(iTime-p.z*4.)/2.));\n            vec3 sc = vec3(.6,1.,3.)*(1.5);\n            mate=mix(wc, sc, r.y-2.);\n            \n        }\n        \n        vec3 sun = normalize(vec3(-0.2,.25,0.2));\n        float dif = clamp(dot(sun,n),0.0,1.0);\n        float sha = step(ray(p+n*.001,sun).x,0.0);\n        float sky = clamp(0.5+0.5*dot(n,vec3(0.,1.,0.)),0.,1.);\n        float bou = clamp(0.5+0.5*dot(n,vec3(0.,-1.,0.)),0.,1.);\n        \n        col = mate*dif*sha;\n        col+= mate*vec3(0.5,0.2,0.1)*sky;\n        col+= mate*vec3(0.3,0.2,0.1)*bou*.5;\n    }\n\t\n    return col;\n    \n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 r)\n{\n    \n    vec3 col =  color(ro,rd,r);\n    vec3 p = ro+rd*r.x;\n    vec3 n = normal(p);\n\n    if(r.x>0.0)\n    {\n\n\t\tvec3 nc = col;\n        if(r.y>=2.)\n        {\n            nc=color(p,n,r);\n            rd = reflect(rd,n);\n            ro=p+n*.001;\n            r = ray(ro,rd);\n            p=ro+r.x*rd;\n            vec3 c = color(p,normal(p),r);\n            nc+=c/10.;\n        }\n        col=mix(col,mix(col,nc,(1.+(2.-r.y))),1.-((2.-r.y)));\n\n    }\n    \n    col=pow(col,vec3(.454545));\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float dist = -8.+(1.+sin(iTime/10.))/2.;\n    vec3 ro = vec3(dist*cos(iTime/5.),2.5,dist*sin(iTime/5.));\n    vec3 ta = vec3(0.,0.,0.);\n    \n    vec3 camForward = normalize(ta-ro);\n    vec3 camUp = normalize(cross(camForward,vec3(0,1,0)));\n    vec3 camRight = normalize(cross(camUp,camForward));\n    \n    vec3 rd = normalize(uv.x*camUp+uv.y*camRight+2.*camForward);\n    \n    vec2 r = ray(ro,rd);\n    \n\tvec3 col = render(ro,rd,r); \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdV3WD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdV3WG", "name": "milkdrop tutorial thing", "author": "BagelOrb", "description": "https://youtu.be/cQXAbndD5CQ\n\nFollowed this tutorial and added some fun stuff.", "tags": ["waves", "modulo", "droplet"], "likes": 3, "viewed": 218, "date": "1570969625", "time_retrieved": "2024-06-20T19:47:29.986335", "image_code": "#define zoom 10.\n\nfloat len(vec2 v, vec2 id)\n{\n    float d1 =  abs(v.x) + abs(v.y);\n    float d2 = length(v);\n    return mix(d1, d2, length(id / zoom) + sin(iTime*1.3));\n}\n\nfloat xor(float a, float b)\n{\n    //return 1. - abs(1. - (a + b));\n    //return a * (1.-b) + b*(1.-a);\n    return a + b;\n}\n\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    float angle = .7853981634;\n    float sa = sin(angle);\n    float ca = cos(angle);\n    uv *= mat2(ca, sa, -sa, ca);\n    \n    vec2 guv = uv * zoom;\n    vec2 p = fract( guv ) -.5;\n    vec2 id = floor(guv);\n    \n    float d = 0.;\n    \n    for (float x = -1.; x <= 1.; x++) {\n    for (float y = -1.; y <= 1.; y++) {\n    \tvec2 offset = vec2(x,y);\n        float time_delay = length(id + offset);\n        float cutoff = .5 + .5*(sin(time_delay - iTime) * .5 + .5);\n    \td = xor(d, smoothstep(cutoff, cutoff*.99, len( p - offset , id + offset)) );\n    }}\n    col.g = mod(d, 3.) - 1.;\n    col.b = 1. - mod(d + 1., 3.);\n    col.r = 1. - mod(d + 2., 3.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdV3WG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdV3WK", "name": "Add Brightness", "author": "FelixTheWolfrick", "description": "Change the image brightness by 10&", "tags": ["brightness"], "likes": 1, "viewed": 51, "date": "1571001826", "time_retrieved": "2024-06-20T19:47:30.137710", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Brightness Variable\n    float brightness = 0.10;\n    \n    // Time varying pixel color + add brightness by 10%\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)) + brightness;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdV3WK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdV3Wz", "name": "Shadertober 02 - Mindless", "author": "BackwardsCap", "description": "Gaze into the empty mind", "tags": ["inktober", "shadertober", "mindless", "backwardscaptain"], "likes": 6, "viewed": 366, "date": "1570047867", "time_retrieved": "2024-06-20T19:47:30.137710", "image_code": "float rand (vec2 p)\n{\n    return fract(sin(dot(p.xy,vec2(12389.1283,8941.1283)))*12893.128933);\n}\n\nfloat noise(in vec2 v)\n{\n    vec2 i=floor(v);\n    vec2 f = fract(v);\n    \n    float a = rand(i);\n    float b = rand(i+vec2(1,0));\n    float c = rand(i+vec2(0,1));\n    float d = rand(i+vec2(1,1));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a,b,u.x)+(c-a)*u.y*(1.0-u.x)+(d-b)*u.x*u.y;\n}\n\nfloat fbm(vec2 p)\n{\n    float ret = 0.;\n    float amp = .4;\n    int oct = 8;\n    for(int i=0;i<oct;i++)\n    {\n        ret+=amp*noise(iTime+20.*p);\n        p*=2.;\n        amp*=.5;\n    }\n    \n    return ret+.15;\n}\n\nfloat map(in vec3 p)\n{    \n    return length(p)-1.+cos(sin(iTime-p.y*20.)/5.+sin(iTime-p.z*20.)/5.+sin(iTime-p.x*20.)/5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n   \n    float time = iTime/4.;\n\tvec3 ro = vec3(sin(time)*2.,1.,cos(time));\n    vec3 ta = vec3(0.0,0.,0.);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu =normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n        \n   \tvec3 rd = normalize(p.x*uu+p.y*vv+2.*ww);\n\tvec3 pos = ro;\n    float m = 1000.0;\n    float t = 0.0;\n    for(int i=0;i<128;i++)\n    {\n        pos = ro+rd*t;\n        \n       \tfloat h = map(pos);\n        m= min(m,h);\n        if(h<.00001)break;\n        \n        t+=h/30.;\n    }\n    \n    \n    float d = 400.;\n    vec3 col =vec3(m)*vec3(fbm(pos.xy/d),fbm(pos.yz/d),fbm(pos.zx/d))*(2.5-(length(p)-.1));\n    fragColor = vec4(pow(col,vec3(1.5)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdV3Wz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdVGD3", "name": "Abandoned Construction", "author": "Shane", "description": "Flying through an extruded structure produced via an underlying herringbone block pattern.", "tags": ["raymarching", "grid", "pattern", "block", "sand", "herringbone"], "likes": 120, "viewed": 4678, "date": "1572267912", "time_retrieved": "2024-06-20T19:47:35.768569", "image_code": "/*\n\n\tAbandoned Construction\n\t----------------------\n\n\tHave you ever wondered what a herringbone tiling of 3 by 2 rectangles would look like\n\tin extruded heightmap form? Neither have I, but I began coding a brick pattern on a \n\t2D plane, and this is where I ended up. :D\n\n    A lot of repetitive tiling examples utilize a square grid. I prefer them for the\n\tobvious reason that they're simpler to use. Of course, a lot of interesting scenes \n\trequire triangles and hexagons, so on occasion, I'll make use of those too. Like \n\teveryone else, these single regular polygons are the ones I stick to. However, there \n\tare countless other tiling arrangements that remain underutilized, like this one.\n\n\tAs previously mentioned, this is based on a herringbone arrangement and consists of a \n    single 3 by 2 rectangle. I like this particular arrangement and tile size because it \n\thas a kind of ordered randomness feel to it that more common sizes -- like 2 by 1 -- \n\tlack. The downside is the added complexity due to the fact that grid skewing and \n\tunskewing is required to minimize the number of taps (four, all up, which is pretty\n\tgood) needed to cover the plane. I can't speak for everyone else, but I get a little\n\tconfused with logic that doesn't stay in a straight line. :)\n\n\tIn regard to the code, it's all been patched together from my other examples. It's \n\treasonably efficient, but probably not organized as much as I'd like. I've employed\n\ta lot of standard prioritization techniques, like raymarching the main objects and\n\tadding smaller details via bump mapping, etc. I've also used cheaper functions where\n\tpossible. By the way, I have a 2D example featuring the same herringbone pattern that \n\tI'll put up later, which will be a little easier to decipher.\n\n\tWhenever putting something relatively simple, like this, together, I always appreciate \n\tthe amount of work that goes into virtually all of Dr2's examples. I have a couple of \n\tinteresting 3D examples coming up, but for now, I'm going back to simpler 2D stuff. :)\n    \n\t\n\n\n\tRelated examples:\n\n\t// This was the only herringbone pattern example I could find on Shadertoy, and from\n\t// what I can see, Fabrice has covered Nx1 (Whole integer multiples), which don't \n    // require skewing. I have an extruded example that cover this range and half integer\n    // multiples as well, but I need to think of an interesting scene first. Perhaps,\n\t// I'll leave that to Fabrice. :)\n\tHerringbone pattern - FabriceNeyret2 \n    https://www.shadertoy.com/view/4dVyDw\n\n\t// One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https://www.shadertoy.com/view/XtfSWX\n    Based on one of my all time favorites:\n    Xyptonjtroz - Nimitz\n\thttps://www.shadertoy.com/view/4ts3z2\n\n*/\n\n// Cheap, and very lazy, night time postprocessing. Kind of effective though. :)\n//#define NIGHT\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 60.\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// 3x1 hash function.\nfloat hash( vec3 p ){ return fract(sin(dot(p, vec3(21.71, 157.97, 113.43)))*45758.5453); }\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n    \n    n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n\n#define RIGID\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) {\n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(113, 1)));\n    p = fract(vec2(2097152, 262144)*n)*2. - 1.;\n    #ifdef RIGID\n    return p;\n    #else\n    return cos(p*6.283 + iGlobalTime);\n    //return abs(fract(p+ iGlobalTime*.25)-.5)*2. - .5; // Snooker.\n    //return abs(cos(p*6.283 + iGlobalTime))*.5; // Bounce.\n    #endif\n\n}\n\n\n// Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into squares, \n// attach random 2D vectors to each of the square's four vertices, then smoothly \n// interpolate the space between them.\nfloat gradN2D(in vec2 f){\n    \n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec2 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    //vec2 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec2 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec2 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec2 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    // grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    // operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22(p + e.xx), f - e.xx), dot(hash22(p + e.yx), f - e.yx), w.x),\n                  mix(dot(hash22(p + e.xy), f - e.xy), dot(hash22(p + e.yy), f - e.yy), w.x), w.y);\n    \n    // Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n// Gradient noise fBm.\nfloat fBm(in vec2 p){\n    \n    return gradN2D(p)*.57 + gradN2D(p*2.)*.28 + gradN2D(p*4.)*.15;\n    \n}\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function - based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values. I'll swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n// Like above, but with no smoothing. Uses for the extruded brick height, so the smoothing\n// isn't noticeable, so we may as well cut the line out and save the GPU some work.\nfloat n2DS(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    //p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    \n    return vec2(6.*sin(z * .1), 0);\n}\n\n// A very cheap surface function. Used for the underlying sand surface.\nfloat surfFunc( in vec3 p){\n    \n    // More expensive, but not noticeable enough to use.\n    //p /= 3.;\n    //return n2D(p.xz)*.57 + n2D(p.xz*2.)*.28 + n2D(p.xz*4.)*.15;\n    \n    // Just two layers.\n    p /= 2.5;\n    return n2D(p.xz)*.67 + n2D(p.xz*2.)*.33;\n    \n\n}\n\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + iTime); \n    \n}\n \n// Based on IQ's gradient noise formula.\nfloat n2D3G(in vec2 p){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    //return v.x + p.x*(v.y - v.x) + p.y*(v.z - v.x) + p.x*p.y*(v.x - v.y - v.z + v.w);\n}\n\n\n// Height map values. Just some noise, with a path cut out for the camera to go through.\nfloat hm(in vec2 p){\n    \n    // Camera path. \n    vec2 pth = p.xy - path(p.y);\n    float camPath = abs(pth.x);\n    \n    // Scaling.\n    p = p/2.5;// + iTime/4.;\n    \n    // Noise, for the terrain, or block heights\n    float n = n2DS(p.xy + 7.5);//*.67 + n2D(p.xy*2.)*.33;\n    \n    // Cutting a camera path out of the noisy terrain.\n    n = smoothstep(.2, 1., n)*clamp(camPath - .6, 0., 1.);\n \n    \n    return n; // Range [0, 1]... hopefully. :)\n\n}\n\n\n\nfloat sBox(in vec3 p, in vec3 b){\n   \n\n  vec3 d = abs(p) - b;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.));\n}\n\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n/*\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n   \n\n  vec3 d = abs(p) - b + sf;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but I want to save every operation\n    // I can.\n    const float sf = .005;\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n \n// Skewing and unskewing.\nvec2 skewXY(vec2 p, vec2 v){ return mat2(1, -v.y, v.x, 1)*p; }\nvec2 unskewXY(vec2 p, vec2 v){ return inverse(mat2(1, -v.y, v.x, 1))*p; }\n\n \n// Extruded 3 by 2 bricks, laid out in a herringbone formation with heights\n// derived from a simple height function. It was a little fiddly to code,\n// but anyone could figure it out.\nvec4 herringbone3D(vec3 q3){\n    \n    // Scale.\n    const float scale = 1./3.;\n    // Skewing vector. Each brick staggers down by this amount... for some\n    // reason that made sense to me at the time... I should probably write \n    // these things down. :D\n\tconst vec2 sk = vec2(1, -1)/5.; // 12 x .2\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = vec2(1.5, 1)*scale;\n    // A helper vector, but basically, it's the size of the repeat cell.\n    // Again, the little correction factor made sence to me at the time.\n    // When the reasoning comes to me, I'll update the comments. :)\n\tvec2 s = (vec2(2.5, 2.5) - abs(sk)/2.)*scale; // 12 x .2\n\n    // A hacky Z-scaling factor to help avoid artifacts. In case it isn't \n    // obvious, I didn't enjoy coding this. :D\n    q3.y *= scale/2.;\n    \n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 cntr, p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 l = dim;\n    cntr = vec2(0);\n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    for(int i = 0; i<4; i++){\n         \n        if(i==2) {\n            cntr = vec2((dim.x + dim.y)/2., -dim.y/4.);\n            l = l.yx;\n        }\n\n        // Working with skewed grids can be a bit confusing, but it's not\n        // so bad. However, following someone elses logic is always confusing,\n        // so for now, just trust that this particular process works. If you're\n        // like me, and you need to do things for yourself, create a pattern\n        // that involves a skewed grid, and the following should make more sense.\n        // \n        // Local coordinates, based on a square grid.\n        p = q3.xz - cntr;\n        p = skewXY(p, sk); // Skewing by the X and Y skewing values.\n        ip = floor(p/s) + .5; // Local tile ID.\n        p -= (ip)*s; // New local position.\n        p = unskewXY(p, sk); // Unskewing.\n\n\n        // At the this point, you render whatever object you wish to render, just\n        // like with any other grid. In this case it's an extruded pylon that \n        // takes its height from a height map function.\n        \n        // Rounded box.\n        float di2D = sBoxS(p, l/2., .04);\n        // Correct positional individual tile ID.\n        vec2 idi = ip*s + cntr;\n        // Don't forget to unskew the ID... Yeah, skewing is confusing. :)\n        idi = unskewXY(idi, sk);\n        // The extruded block height. See the height map function, above. I've\n        // Also used to the floor function to snap the heights to specific\n        // quantized values.\n        float h = max(floor(hm(idi)*24.999)/24., 0.)*.5 + .002;\n        \n        // The extruded distance function value.\n        float di = opExtrusion(di2D + .01, q3.y - h, h);\n\n        // For all tiles above a certain height, bore out the center to give it\n        // a Besser block feel.\n        if(h>.0025){\n\n            di = max(di, -(di2D + .1));\n        }\n\n\n        // If necessary, update the minimum tile value, position-based ID, and block ID.\n        if(di<d){\n            d = di;\n            id = idi;\n            boxID = float(i);\n\n        }\n\n        // Move the grid center to the new position. From the pattern, you can see that\n        // each tile is rendered down by factor equivalent to the longest length.\n        cntr -= -dim.y;\n        \n    }\n    \n    // Return the distance, unskewed position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n// Brick ID and scene object ID.\nvec2 bID;\nvec3 objID;\n\n// The flat shaded terrain and the mesh.\nfloat map(vec3 p){\n    \n    \n    // Terrain function. Essentially, the sand, in this case. \n    float ter = p.y + (.5 - surfFunc(p))*.8 - .05;\n\n    // The extruded herringbone heightmap.\n    vec4 her = herringbone3D(p); \n\n    // The individual brick pylon ID.\n    bID = her.yz;\n    \n \n    // Placing the individual object IDs in a container. This will\n    // be sorted outside the loop. It's also necessary to compare\n    // values, to mix materials. Like, for instance, where the sand\n    // meets the brick surface.\n    objID = vec3(ter, her.x, 1e5);\n    \n    \n    // Combining the blocks with the terrain. I've combined them with \n    // a touch of smoothing to make it look a little more organic.\n    return smin(ter, her.x, .005);\n \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., d;\n    \n    // Hack to force loop unrolling. I can't say I'm happy with it, but it is what it is. :)\n    // If someone has a better idea, feel free to let me know.\n    //int zer = int(min(iTime, 0.)); \n    for(int i = 0; i<128; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(t*.05 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        // I concocted this mess in a desperate attempt to get more mileage out of the ray, and \n        // amazingly, it worked. Having said that, you probably shouldn't try this at home. :D\n        t += i<32? d*.75 : d*(1. + t*.05); \n    }\n\n    return min(t, FAR);\n}\n\n\n/*\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n// a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n// same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 normal(in vec3 p, float ef)\n{  \n    vec2 e = vec2(-1, 1)*.001*ef;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*/\n\n \n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p, float ef) {\n\tvec2 e = vec2(.001*ef, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, fract(p.zx)).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n\n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(113, 157, 1);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n\n\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the sand height values that are further away. If you don't do this, really bad\n// Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n// I didn't want to pass an extra variable through a bunch of different functions.\nfloat gT;\n\n// Surface bump function..\nfloat bumpSurf3D( in vec3 p){\n    \n    \n    \n    p *= vec3(1.65, 2.2, 3.85);\n    //float ns = n2D(p.xz)*.57 + n2D(p.xz*2.)*.28 + n2D(p.xz*4.)*.15;\n    float ns = n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n    \n    // vec2 q = rot2(-3.14159/5.)*p.xz;\n    // float ns1 = grad(p.z*32., 0.);//*clamp(p.y*5., 0., 1.);//smoothstep(0., .1, p.y);//\n    // float ns2 = grad(q.y*32., 0.);//*clamp(p.y*5., 0., 1.);//smoothstep(0., .1, p.y);//\n    // ns = mix(ns1, ns2, ns);\n    \n    ns = (1. - abs(smoothstep(0., 1., ns) - .5)*2.);\n    ns = mix(ns, smoothstep(0., 1., ns), .65);\n    \n    // Use the height to taper off the sand edges, before returning.\n    ns = ns*smoothstep(0., .2, p.y - .075);\n    \n    \n    // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    // formed in the distance. Simply lessen the value when it's further away. Most people would\n    // figure this out pretty quickly, but it took far too long before it hit me. :)\n    return ns/(1. + gT*gT*.015);\n    \n\n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(0.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p);\n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    */\n       \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    //int zer = int(min(iTime, 0.)); // Hack to force loop unrolling.\n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d*.75, .05, .35); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\n// Standard sky routine: Gradient with sun and overhead cloud plane. I debated over whether to put more \n// effort in, but the dust is there and I'm saving cycles. I originally included sun flares, but wasn't \n// feeling it, so took them out. I might tweak them later, and see if I can make them work with the scene.\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld){ \n    \n    // Sky color gradients.\n    vec3 col = vec3(.8, .7, .5), col2 = vec3(.4, .6, .9);\n    \n    // Probably a little too simplistic. :)\n    //return mix(col, col2, pow(max(rd.y*.5 + .9, 0.), 5.))*vec3(1.2, .95, .7); \n    \n    // Mix the gradients using the Y value of the unit direction ray. \n    vec3 sky = mix(col, col2, pow(max(rd.y + .15, 0.), .5));\n    //sky *= vec3(.84, 1, 1.17); // Adding some extra vibrancy.\n    \n     \n    float sun = clamp(dot(ld, rd), 0., 1.);\n    sky += vec3(1, .7, .4)*vec3(pow(sun, 16.))*.2; // Sun flare, of sorts.\n    sun = pow(sun, 32.); // Not sure how well GPUs handle really high powers, so I'm doing it in two steps.\n    sky += vec3(1, .9, .7)*vec3(pow(sun, 32.))*.35/vec3(1.2, 1, .8); // Sun.\n    \n     // Subtle, fake sky curvature.\n    rd.z *= 1. + length(rd.xy)*.15;\n    rd = normalize(rd);\n   \n    // A simple way to place some clouds on a distant plane above the terrain -- Based on something IQ uses.\n    const float SC = 1e5;\n    float t = (SC - ro.y - .15)/(rd.y + .15); // Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; // UV coordinates.\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\tif(t>0.) sky =  mix(sky, vec3(2), smoothstep(.45, 1., fBm(1.5*uv/SC))*\n                        smoothstep(.45, .55, rd.y*.5 + .5)*.4);\n    \n    // Return the sky color.\n    return sky*vec3(1.2, 1, .8);\n     \n}\n\n\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n/////\n// Code block to produce some layers of smokey haze. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n// Several layers of cheap noise to produce some subtle smokey haze.\n// Start at the ray origin, then take some samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    \n    //ro -= vec3(0, 0, iTime*3.);\n    \n    float t0 = 0.;\n    \n    for (int i = 0; i<24; i++){\n        \n        // If we reach the surface, don't accumulate any more values.\n        if (t0>t) break; \n        \n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = 1./(1. + sDi*.25);\n\t    \n        // Noise layer.\n        vec3 ro2 = (ro + rd*t0)*2.5;\n        float c = noise3D(ro2)*.65 + noise3D(ro2*3.)*.25 + noise3D(ro2*9.)*.1;\n        //float c = noise3D(ro2)*.65 + noise3D(ro2*4.)*.35; \n\n        float n = c;//max(.65-abs(c - .5)*2., 0.);//smoothstep(0., 1., abs(c - .5)*2.);\n        mist += n*sAtt;\n        \n        // Advance the starting point towards the hit point. You can \n        // do this with constant jumps (FAR/8., etc), but I'm using\n        // a variable jump here, because it gave me the aesthetic \n        // results I was after.\n        t0 += clamp(c*.25, .1, 1.);\n        \n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return max(mist/48., 0.);\n    \n    // A different variation (float n = (c. + 0.);)\n    //return smoothstep(.05, 1., mist/32.);\n\n}\n\n//////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\n\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.     \n\tvec3 ro = vec3(0, 1.5, iTime*2.); // Camera position, doubling as the ray origin.\n    vec3 lk = ro + vec3(0, -.1, .5);  // \"Look At\" position.\n    \n\t\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\n \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/2.5; // FOV - Field of view.\n    vec3 fw = normalize(lk - ro);\n    vec3 rt = normalize(vec3(fw.z, 0, -fw.x )); \n    vec3 up = cross(fw, rt);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(fw + (u.x*rt + u.y*up)*FOV);\n    // Warping the ray to give that curved lens effect.\n    rd = normalize(vec3(rd.xy, rd.z*(1. - length(rd.xy)*.25)));\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lk.z).x/48.)*rd.xy;\n    \n\t\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(FAR*.25, FAR*.35, FAR) + vec3(0, 0, ro.z);\n \n\n\t// Raymarching.\n    float t = trace(ro, rd);\n    \n    // Saving objects.\n    vec2 svBID = bID;\n    vec3 oSvObjID = objID; // Saving the list of object IDs for blending purposes.\n    // Closest object ID.\n    float svObjID = objID.x < objID.y? 0. : 1.;\n\n    // Global distance. Used to mitigate Moire pattern effects.\n    gT = t;\n   \n    // Sky. Only retrieving a single color this time.\n    //vec3 sky = getSky(rd);\n    \n    // The passage color.\n    vec3 col = vec3(0);\n    \n    // Surface point. \"t\" is clamped to the maximum distance, and I'm reusing it to render\n    // the mist, so that's why it's declared in an untidy position outside the block below...\n    // It seemed like a good idea at the time. :)\n    vec3 sp = ro + t*rd; \n    \n    float pathHeight = sp.y;//surfFunc(sp);// - path(sp.z).y; // Path height line, of sorts.\n    \n    // If we've hit the ground, color it up.\n    if (t < FAR){\n    \n        \n        vec3 sn = normal(sp, 1.); // Surface normal. //*(1. + t*.125)\n        \n        // Light direction vector. From the sun to the surface point. We're not performing\n        // light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp - sp;\n        float lDist = max(length(ld), 0.001);\n        ld /= lDist; // Normalize the light direct vector.\n        \n        lDist /= FAR; // Scaling down the distance to something workable for calculations.\n        float atten = 1./(1. + lDist*lDist*.05);\n\n        \n        // Texture scale factor.        \n        const float tSize = 1./8.;\n        \n        \n        // Function based bump mapping.\n        if(svObjID==0.) sn = doBumpMap(sp, sn, .1);///(1. + t*t/FAR/FAR*.25)\n        \n        // Texture bump mapping.\n        float bf = .01;//(pathHeight + 5. < 0.)?  .05: .025;\n        //sn = doBumpMap(iChannel0, sp*tSize, sn, bf/(1. + t/FAR));\n        \n        \n        // Soft shadows and occlusion.\n        float sh = softShadow(sp, lp, sn, 8.);\n        float ao = calcAO(sp, sn); // Ambient occlusion.\n        \n        // Add AO to the shadow. No science, but adding AO to things sometimes gives a bounced light look.\n        sh = min(sh + .25, 1.); \n        \n        float dif = max( dot( ld, sn ), 0.); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 5.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n \n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n       \n        // Overal global ambience. It's made up, but I figured a little occlusion (less ambient light\n        // in the corners, etc) and reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = ao*.35;// + fre*fre2*.2;\n        \n\n        \n        \n        \n\t\t// Surface texel.\n        vec3 tx = tex3D(iChannel0, sp/2., sn);\n \n        tx = smoothstep(-.2, .4, tx);\n    \t//tx = mix(tx, vec3(1)*dot(tx, vec3(.299, .587, .114)), .5); // Toning down a little.\n        \n        vec3 sndTx = mix(vec3(1, .95, .7), vec3(.9, .6, .4), fBm(sp.xz*16.));\n        \n        vec3 col0 = col;\n        vec3 col1 = col;\n        \n        float bordCol0Col1 = oSvObjID.x - oSvObjID.y;\n        const float bordW = .1;\n        \n        \n        // Blocks.\n        if(svObjID==1. || abs(bordCol0Col1)<bordW){\n            col1 = tx*mix(vec3(1), sndTx*2., .6);///vec3(1, .9, .8)*1.5; \n            \n            col1 *= 1./(1. + t*t*.005);\n            \n            vec3 bTx = texture(iChannel0, svBID).xyz; bTx *= bTx;\n            bTx =  smoothstep(0., .5, bTx);\n            \n            col1 = mix(col1, col1*bTx*2.4, .35);\n        }\n       \n        // Sand.\n        if(svObjID==0. || abs(bordCol0Col1)<bordW){\n        \n            // Give the sand a bit of a sandstone texture.\n        \tcol0 = sndTx;//mix(vec3(1, .95, .7), vec3(.9, .6, .4), fBm(sp.xz*16.));\n        \tcol0 = mix(col0*1.4, col0*.6, fBm(sp.xz*32. - .5));///(1. + t*t*.001)\n     \n             // Extra shading in the sand crevices.\n            float bSurf = bumpSurf3D(sp);\n            col0 *= bSurf*.75 + .5;\n            col0 *= vec3(1.5, 1.45, 1.3)/2.;\n \n        }\n        \n        \n        \n        \n        // Return the color, which is either the sandy terrain color, the object color,\n    \t// or if we're in the vicinity of both, make it a mixture of the two.\n    \tcol = mix(col0, col1, smoothstep(-bordW, bordW, bordCol0Col1));\n       \n        // Lamest sand sprinkles ever. :)\n        col = mix(col*.7 + (hash(floor(sp*96.))*.7 + hash(floor(sp*192.))*.3)*.3, col, min(t*t/FAR, 1.));\n        col *= vec3(1.2, 1, .9); // Extra color -- Part of last minute adjustments.\n    \n        \n        // Combining all the terms from above. Some diffuse, some specular - both of which are\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        // good enough for the purposes of this demonstation.        \n        col = col*(dif + amb + vec3(1, .97, .92)*fre2*spe*2.)*atten;\n        \n        \n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        vec3 refSky = getSky(sp, reflect(rd, sn), ld);\n        col += col*refSky*.05 + refSky*fre*fre2*atten*.15; \n        \n \n        // Applying the shadows and ambient occlusion.\n        col *= sh*ao;\n\n        \n    }\n    \n  \n    // Combine the scene with the sky using some cheap volumetric substance.\n\tfloat dust = getMist(ro, rd, lp, t)*(1. - smoothstep(0., 1., pathHeight*.05));//(-rd.y + 1.);\n    vec3 gLD = normalize(lp - vec3(0, 0, ro.z));\n    vec3 sky = getSky(ro, rd, gLD);//*mix(1., .75, dust);\n    //col = mix(col, sky, min(t*t*1.5/FAR/FAR, 1.)); // Quadratic fade off. More subtle.\n    col = mix(col, sky, smoothstep(0., .95, t/FAR)); // Linear fade. Much dustier. I kind of like it.\n    \n    \n    // Mild dusty haze... Not really sure how it fits into the physical situation, but I thought it'd\n    // add an extra level of depth... or something. At this point I'm reminded of the \"dog in a tie \n    // sitting at the computer\" meme with the caption, \"I have no idea what I'm doing.\" :D\n    vec3 mistCol = vec3(1, .95, .9); // Probably, more realistic, but less interesting.\n    col += (mix(col, mistCol, .66)*.66 + col*mistCol*1.)*dust;\n    \n    \n    // Simulating sun scatter over the sky and terrain: IQ uses it in his Elevated example.\n    col += vec3(1., .7, .4)*pow( max(dot(rd, gLD), 0.), 16.)*.4;\n    \n    \n    // Applying the mild dusty haze.\n    col = col*.75 + (col + .25*vec3(1.2, 1, .9))*mistCol*dust*1.5;\n    \n    \n    // Really artificial. Kind of cool, but probably a little too much.    \n    //col *= vec3(1.2, 1, .9);\n\n    #ifdef NIGHT\n    // Cheapest, laziest night time postprocessing ever. :D\n    col *= vec3(.4, .6, 1);\n    #endif\n    \n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    // term to give it more subtlety.\n    u = fragCoord/iResolution.xy;\n    col = min(col, 1.)*pow( 16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n \n    // Rough gamma correction, and present to screen.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdVGD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdVGRm", "name": "Thorny Partitions", "author": "104", "description": "Creating chaos by dividing space recursively-ish", "tags": ["2d", "fractal", "partition"], "likes": 7, "viewed": 111, "date": "1569943981", "time_retrieved": "2024-06-20T19:47:35.768569", "image_code": "#define POINTS 3\n#define PARTITIONS 12\n\nconst float PI2 = 6.28;\n\nvec2 min2(vec2 lhs, vec2 rhs) {\n    if (lhs.x < rhs.x)\n        return lhs;\n    return rhs;\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 o, vec2 C)\n{\n    vec2 R = iResolution.xy;\n    vec2 N = C/R-.5;\n    vec2 uv = N;\n    uv.x *= R.x/R.y;\n    float t = iTime  *.5;\n    vec3 pts[POINTS];// x,y,seed\n\n    // x = dist, y = pts index\n    vec2 tileFinder = vec2(0);\n    float seed = 1.;\n    for (int ip = 0; ip < PARTITIONS; ++ ip) {\n\n        for (int i = 0; i < POINTS; ++ i) {\n            vec4 h = hash41(seed+float(i));\n            pts[i] = vec3(\n                sin(h.x*PI2+t*h.y),\n                sin(h.y*PI2-t*h.z),\n                h.x\n            )*.3;\n        }\n\n       \t// find the closest pt\n        tileFinder = vec2(length(uv - pts[0].xy), 0);\n        for (int i = 1; i < POINTS; ++ i) {\n            float d = length(uv - pts[i].xy);\n            tileFinder = min2(tileFinder, vec2(d, i));\n        }\n        \n        // center around that point and re-partition\n        uv -= pts[int(tileFinder.y)].xy;\n        uv *= 1.4;\n        seed = pts[int(tileFinder.y)].z;\n    }\n    \n    o = hash41(pts[int(tileFinder.y)].z *1e3)+.02;\n    o *= tileFinder.x;\n    o = clamp(o,0.,1.);\n    o = pow(o,o-o+.4);\n    o *= 1.-dot(N,N);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdVGRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdVGWK", "name": "Shadertober 11 Snow", "author": "GreenChicken", "description": "wanted to try some smooth snow flake. But it became  an electric raining shit. And it's not so bad in my opinion.", "tags": ["snow", "inktober"], "likes": 2, "viewed": 328, "date": "1570978355", "time_retrieved": "2024-06-20T19:47:36.925991", "image_code": "\n#define VOLUME 0.001\n#define PI 3.14159\n\n\n////////////////////////////////////////////////////////////////////////////////\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sat(float a) {return clamp(a, .0, 1.); }\n\nfloat opU(float s1, float s2) { return min(s1, s2);}\n\nvec2 opU2(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// -------------------------------------------------------------------------\n\nvec2 map(vec3 pos)\n{\n    vec2 t = vec2(0.0, -1.0);\n    \n    // ground\n    t.x = pos.y;\n    \n    // sphere\n    vec3 sp = pos + vec3(0.0, -1.0, 0.0);\n    vec2 sphere = vec2(sdSphere(sp,0.7), 0.0);\n    \n    // snow\n    vec3 np = sp + vec3(0.0, -.15, 0.0);\n    np.x += sin(pos.x*10.)*.01;\n    np.z += sin(pos.z*12.)*.01;\n    np.y += fract(iTime)*.1;\n    float nf = opS(sphere.x, sdSphere(np,0.72));\n    vec2 ne = vec2(nf, 1.0);\n    \n    // cloud\n    vec3 gnp = pos;\n    gnp.x += sin(pos.y*10.+iTime)*.1;\n    gnp.xy -= sin(pos.xy)*.1;\n    vec3 cp = gnp + vec3(0.0, -3.0, 0.0);\n    float cl = sdSphere(cp, .5);\n    cp = gnp + vec3(0.5, -3.0, 0.0);\n    cl = opU(cl, sdSphere(cp, .5));\n    cp = gnp + vec3(-0.6, -3.0, 0.0);\n    cl = opU(cl, sdSphere(cp, .5));\n    cp = gnp + vec3(-0.2, -3.3, 0.0);\n    cl = opU(cl, sdSphere(cp, .5));\n    cp = gnp + vec3(0.3, -2.8, 0.0);\n    cl = opU(cl, sdSphere(cp, .5));\n    \n    vec2 cloud = vec2(cl, 2.0);\n    \n    // rain\n    vec3 pp = pos + vec3(sin(iTime)*.2, -2.0+iTime*.5, sin(iTime)*.1);\n    pp = opRep(pp, vec3(.1+fract(iTime*pos.y), .5+sin(iTime*pos.y), .01));\n    float ps = sdSphere(pp, .025*pos.y);\n    float sbox = sdBox(pos+vec3(0.0, -2.0, 0.0), vec3(1.0, 1.0, .3));;\n    ps = opI(ps, sbox);\n    \n    vec2 rain = vec2(ps, 3.0);\n    \n    \n    t = opU2(t, sphere);\n    t = opU2(t, ne);\n    t = opU2(t, cloud);\n    t = opU2(t, rain);\n    \n    return t;\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 1.; i += 1./15.) {\n        vec2 dist = map(pos + dir * t);\n        if (dist.x < VOLUME) return 0.;\n        f = min(f, k * dist.x / t);\n        t += dist.x;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = ro+rd*t.x;\n    vec3 col = vec3(0.0);\n    float depth = clamp(pos.z, 0.0, 1.0);\n            \n    if(t.x == -1.0)\n    {   \n        // background\n        col = vec3(rd.y)+.2;\n        \n    }\n    else\n    {\n        float glp = clamp(length(pos)*.1, 0.0, 1.0);\n        vec3 N = GetNormal(ro+rd*t.x);\n        vec3 L = vec3(0.0, 1.0, 1.0);\n        float light = dot(N,L);\n        float shade = GetShadow(pos, L, 4.);\n        \n        vec3 bgColor = vec3(.4+pos.z*.1) * shade;\n        \n        if(t.y == -1.0) \n        {\n            // ground\n            col = bgColor;\n        }\n        else if(t.y == 0.0)\n        {\n            // sphere\n            col = vec3(.5);\n            col *= light;\n        }\n        else if(t.y == 1.0)\n        {\n            // some sort of snow\n            col = vec3(.0, .5, 1.0) * abs(pos.y) * (1.0+sin(iTime*50.)*.5);\n            col *= light;\n        }\n        else if(t.y == 2.0)\n        {\n            col = vec3(rd.y);\n            \n            col += depth;\n        }\n        else if(t.y == 3.0)\n        {\n            col = vec3(0.0, 0.5, 1.0);\n            \n            col += depth;\n            \n            col = mix(bgColor, col, vec3(pow(1.0-abs(uv.x), 8.0)));\n            \n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime*.25;\n    \n    vec3 cp = vec3(0.0, 2.0, 5.0);\n    vec3 ct = vec3(0.0, 2.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    col = Render(cp, vd, uv);\n    col.z += screenUV.y*.2;\n    col -= random(screenUV) * .1;\n    col *= 1.0-length(uv)*.8;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdVGWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdVGWR", "name": "Rotating checkers", "author": "kamihaze", "description": "Rotating overlapping checkers with miscalculated rotation matrix.", "tags": ["checker", "rotation"], "likes": 2, "viewed": 72, "date": "1570015772", "time_retrieved": "2024-06-20T19:47:36.926245", "image_code": "const float shades = 4.5;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = vec2(sin(iTime),cos(0.8*iTime));\n    vec2 uv =2.0*(\n        (fragCoord/iResolution.xy)-vec2(0.5))\n    \t*vec2(iResolution.x/iResolution.y,1.0) + pos;\n\n    mat4 m4= transpose(mat4( \n         \t 0.0, 0.0, 0.0, 0.0,\n    \t\t 0.0, 0.0, 0.0, 0.0,\n             0.0, 0.0, 0.0, 0.0,\n             0.0, 0.0, 0.0, 0.0 ));\n    \n    // Rotation matrix\n    mat2 m = transpose( mat2(\n        \t1.2*cos(1.2 * iTime), -sin(1.3 * iTime),\n        \t    sin(0.9 * iTime),  cos(1.0 * iTime)\n        )\n\t);\n        \n\tvec2 res = (uv * m);\n\n    \n    float y=abs(res.y);\n    float x=abs(res.x);\n    \n    float r,g,b;\n    \n    //Have it rounding errors to create stepping\n    r=y;\n    r *= shades;\n    r  = ceil(r);\n    r /= shades;\n    \n    b=x;\n    b *= shades;\n    b  = ceil(b);\n    b /= shades;\n    \n\tg=max(r,b)*b*r; //r*b*0.9;\n   \n   \n    vec3 outcol=vec3( r, g, b );\n    // Output to screen\n    fragColor = vec4(outcol,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdVGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdVGzc", "name": "Shadertober 09 Swing", "author": "GreenChicken", "description": "I wanted to create this strange shape on the center", "tags": ["raymarching", "inktober"], "likes": 1, "viewed": 256, "date": "1570663080", "time_retrieved": "2024-06-20T19:47:37.835259", "image_code": "// SHADERTOBER 09 Swing\n// Poulet Vert 09-10-2019\n// Thanks to iq, leon, patricio&jen\n\n#define VOLUME 0.001\n#define PI 3.14159\n\n\n////////////////////////////////////////////////////////////////////////////////\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sat(float a) {return clamp(a, .0, 1.); }\n\nfloat opU(float s1, float s2) { return min(s1, s2);}\n\nvec2 opU2(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat random (float s) {return fract(sin(dot(s,1.9898))*1.5453123);}\n\nvec2 map(vec3 pos)\n{\n    vec2 t = vec2(0.0, 0.0);\n    \n    // ground\n    t.x = pos.y;\n    \n    // strange shape\n    vec3 sp = pos + vec3(1.0, -1.0, 2.0);\n    sp.xy *= rot(PI/2.0);\n    \n    float s = 1.0;\n    \n    for(int i=0;i<35;i++)\n    {\n        float rs = random(float(i)*.0005);\n        sp.y -= rs*2.0;\n        s = opU(s, sdCappedCylinder(\n            sp, \n            1.0+sin(float(i)+iTime)*.2, \n            rs));\n    }\n    \n    vec2 strange = vec2(s, 1.0);\n    \n    // walls\n    vec3 wap = pos + vec3(3.0, 0.0, 2.0);\n    float wa = sdBox(wap, vec3(1.7, 5.0, 1.0));\n    wap = pos + vec3(-3.0, 0.0, 2.0);\n    wa = opU(wa, sdBox(wap, vec3(1.7, 5.0, 1.0)));\n    \n    vec2 walls = vec2(wa, 2.0);\n    \n    t = opU2(t, strange);\n    t = opU2(t, walls);\n    \n    return t;\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 1.; i += 1./15.) {\n        vec2 dist = map(pos + dir * t);\n        if (dist.x < VOLUME) return 0.;\n        f = min(f, k * dist.x / t);\n        t += dist.x;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = ro+rd*t.x;\n    vec3 col = vec3(0.0);\n    float depth = clamp(pos.z, 0.0, 1.0);\n    depth = 1.0 - sat(pos.z*.1);\n            \n    if(t.x == -1.0)\n    {        \n        col = vec3(rd.y);\n        \n    }\n    else\n    {\n        float glp = clamp(length(pos)*.1, 0.0, 1.0);\n        vec3 N = GetNormal(ro+rd*t.x);\n        vec3 L = vec3(0.0, 1.0, 1.0);\n        float light = dot(N,L);\n        float shade = GetShadow(pos, L, 4.);\n        \n        if(t.y == 0.0) \n        {\n            col = vec3(.2+pos.z*.1);\n            col *= shade;\n        }\n        if(t.y == 1.0) \n        {\n            col = vec3(sin(pos.x+iTime*1.), 0.2, 0.2);\n            col *= vec3(light)*.7;\n        }\n        if(t.y == 2.0) \n        {\n            col = vec3(light*.2);\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime*.25;\n    \n    vec3 cp = vec3(0.0, 1.0, 5.);\n    vec3 ct = vec3(0.0, 1.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    col = Render(cp, vd, uv);\n    col.z += screenUV.y*.2;\n    col *= 1.0-length(uv)*.8;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdVGzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdVGzt", "name": "Options", "author": "shadeThrower", "description": "Different visualization presets can be selected by changing the `option` variable at the top.", "tags": ["kaleidoscope", "trig", "switch"], "likes": 3, "viewed": 308, "date": "1570756640", "time_retrieved": "2024-06-20T19:47:38.386764", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //OPTIONS: (0) NONE, (1) BREATHE, (2) DISTORT, (3) BREATHE-MOVE,\n    //(4) MOVE, (5) XSIN, (6) SCAPE, (7) 2001, (8) CONVEX-ZOOM, (9) CONCAVE-ZOOM\n    //(10) CONCAVE-INTERACT\n    int option = 9;\n    float tme = iTime*.5;\n    float scale = 0.125;\n   \n    vec2 adjVec = vec2((sin(tme)*.5), (cos(tme)*.5));\n    vec2 uv = fragCoord/iResolution.xy;    \n    vec2 uvM;\n    float posMod;\n    switch(option){\n        case 1:\n\t    \tuvM = mod(uv + normalize(uv-0.5)*adjVec, scale);\n        \tbreak;\n    \tcase 2:\n\t    \tuvM = mod(uv + normalize(uv*uv-2.*scale)*adjVec, scale);\n        \tbreak;\n        case 3:\n        \tuvM = mod(uv*(uv.y) + normalize((uv-.5) + adjVec*.667)*adjVec, scale);\n        \tbreak;\n        case 4:\n        \tuvM = mod(uv + adjVec, scale);\n        \tbreak;\n        case 5:\n        \tuvM = mod(uv*sin((uv.x)*3.1416), scale);\n        \tbreak;\n        case 6:\n        \tuvM = mod(uv + uv*tan(pow(length(uv),abs(sin(adjVec.x)*30.*uv.x))), scale);\n        \tbreak;\n        case 7:\n        \tscale *= 2.;\n        \tposMod = fract(tme/5.);\n        \tif(uv.x>0.5){\n                uv.x=1.-uv.x;\n    \t\t}\n        \t//uv.x -= sin(uv.x)/8.-(pow(0.5-uv.x,-1.));\n        \n        \tuv.x += (pow(0.525,-1.))/2500.; //+ .14*(0.5-uv.x);\n        \tuv.x -=(pow(0.525-uv.x,-1.))/2500.;\n        \t//uv.x -= sin(uv.y*30.+sin(tme)*20.)*2.*(.5-uv.x)*(pow(0.5-uv.x,1.4))/14.;\n        \n        \tuv.y = uv.y-.5 - sin(tme/2.)*.65;\n\t\t\t\n        \n\t        uvM = mod(uv*tan((mod((sin(uv.x)),0.5))*3.1416)+vec2(posMod*5.,(1.-sin(tme/2.+4.7124)/2.+.5)*uv.y), scale);\n\t        //uvM = mod(uv*tan((mod((sin(uv.x)),0.5))*3.1416)+vec2(1.,uv.y), scale);\n        \tbreak;\n        case 8:\n        \tuv = (uv-.5)*length(uv-0.5)*adjVec.x*5.;\n        \tuvM = mod(uv, scale);\n        \tbreak;\n        case 9:\n        \tposMod = (cos(tme/2.+3.1416)*.95 + .05)/2.+.5;\n        \t//uv = vec2(pow((uv.x-.5)*length(normalize(uv-0.5))*5., -.05)*posMod, pow((uv.y-.5)*length(normalize(uv-0.5))*5., -.05)*posMod);\n        \t//uv = vec2(pow((uv.x-.5)*length(uv-0.5)*5., -.07)*posMod*2., pow((uv.y-.5)*length(uv-0.5)*5., -.07)*posMod*2.);\n        \tuv = vec2(pow(abs(uv.x-.5)+length(uv-.5), -.07)*posMod*3., pow(abs(uv.y-.5)+length(uv-.5), -.07)*posMod*3.);\n        \tuvM = mod(uv, scale);\n        \tbreak;\n        case 10:\n            //INTERACTIVE: Mouse X controls flight speed, Mouse Y controls depth\n            float normX;\n            float normY;\n        \tif(iMouse.y>0. || iMouse.x>0.){\n                normX = ((iMouse.x)-1.)/iResolution.x;\n                normY = ((iMouse.y)-1.)/iResolution.y;\n            }\n            else{\n                normX = 0.3;\n                normY = 0.3;\n            }\n            float zoomMult = pow(max(normY,0.001)*5., .5);\n            //uv = vec2(pow((uv.x-.5)*length(normalize(uv-0.5))*5., -.05)*posMod, pow((uv.y-.5)*length(normalize(uv-0.5))*5., -.05)*posMod);\n            //uv = vec2(pow((uv.x-.5)*length(uv-0.5)*5., -.07)*posMod*2., pow((uv.y-.5)*length(uv-0.5)*5., -.07)*posMod*2.);\n            uv = vec2(pow(abs(uv.x-.5)+length(uv-.5), -.07)*zoomMult*2., pow(abs(uv.y-.5)+length(uv-.5), -.07)*zoomMult*2.);\n            uvM = mod(uv+fract((tme)*normX)*5.*(normY*.75+.25), scale);\n        \tbreak;\n    \tdefault:\n\t        uvM = mod(uv, scale);\n    }\n    uv = normalize(uvM-vec2(scale/2.))*(adjVec+vec2(.5));\n\n    if(mod(floor((uv.x)/scale),2.) == 0.)\n            uvM.x = scale - uvM.x;\n    if(mod(floor((uv.y)/scale),2.) == 0.)\n            uvM.y = scale - uvM.y;\n\n    uvM += adjVec*length(uvM + adjVec - vec2(0.5));\n\n    // Time varying pixel color\n    vec3 col = vec3(0.5 + 0.5*tan((cos(tme)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.)))),\n                    0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.)))),\n                    0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*(uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdVGzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdy3W1", "name": "Shadertober 02 Mindless", "author": "GreenChicken", "description": "Inktober day 2 with theme \"mindless\". I wanted to create something close to human with primitives and a simple dot of waving colors for hair to catch the eye.", "tags": ["raymarching", "human", "inktober"], "likes": 4, "viewed": 367, "date": "1570050333", "time_retrieved": "2024-06-20T19:47:38.386764", "image_code": "// SHADERTOBER 02 MINDLESS\n// Poulet Vert, 02/10/2019\n// thanks to iq, ajweeks, Leon, Flopine\n\n#define PI 3.14159\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n\nfloat SuitUp(vec3 p)\n{\n    float t = 0.0;\n    \n    p.zx *= rot(PI/4.0);\n    \n    p.x += sin(p.y*10.)*0.03; // primitive to cloth\n    \n    vec3 bodyP = p + vec3(0.0, 1.6, 0.0);\n    float body = sdBox(bodyP, vec3(1.0, 1.0, .2));\n    \n    vec3 LarmP = p + vec3(1.35, 2.8, 0.0);\n    LarmP.xy *= rot(PI/5.);\n    float Larm = sdBox(LarmP, vec3(1.0, 2.0, .2));\n    \n    vec3 RarmP = p + vec3(-1.2, 2.85, 0.0);\n    RarmP.xy *= rot(PI/3.0);\n    float Rarm = sdBox(RarmP, vec3(2.0, 1.0, .2));\n    \n    vec3 neckP = p + vec3(0.0, 0.8, 0.0);\n    neckP.xy *= rot(PI/3.0);\n    float neck = sdTriPrism(neckP, vec2(.5, 1.0));\n    \n    vec3 topNeckP = p + vec3(0.0, .8, 0.0);\n    vec3 topNeckPsub = topNeckP + vec3(0.0, 0.0, 0.1);\n    float topNeck = sdCappedCylinder(topNeckP, .5, .5);\n    topNeck = sSDF(sdCappedCylinder(topNeckPsub, .5, .6), topNeck);\n    \n    t = uSDF(body, Larm);\n    t = uSDF(t, Rarm);\n    t = sSDF(neck, t);\n    t = uSDF(t, topNeck);\n    \n    return t;\n}\n\nfloat head(vec3 p)\n{\n    float t = 0.0;\n    \n    p.zx *= rot(PI/4.0); \n    float yMask = max(p.y*4.0-1.0, 0.0);\n    p.z -= sin(iTime+dot(p.x, p.y)*10.)*0.1*yMask; // magic hair\n    \n    vec3 sP = p + vec3(0.0, -0.3, 0.0);\n    float s = sdVerticalCapsule(sP, 1.0, .5);\n    \n    vec3 jawP = sP + vec3(0.0, .35, 0.0);\n    float j = sdCappedCylinder(jawP, .5, .4);\n    \n    vec3 jawMaskP = jawP + vec3(0.0, 0.0, 0.5);\n    float jm = sdSphere(jawMaskP, .4);\n    j = opIntersection(j, jm);\n    \n    vec3 neckP = sP + vec3(0.0, 1.0, 0.0);\n    float n = sdCappedCylinder(neckP, .3, .8);\n    \n    t = uSDF(s, j);\n    t = uSDF(t, n);\n    \n    return t;\n}\n\nfloat map(vec3 pos)\n{\n    float t = 0.0;\n    \n    t = SuitUp(pos);\n    t = min(t, head(pos));\n    \n    return t;\n}\n\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        float ray = map(ro + rd * t);\n        \n        if(ray < (0.0001*t))\n        {\n            return t;\n        }\n        \n        t += ray;\n    }\n    \n    return -1.0;\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    float t = CastRay(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t == -1.0)\n    {\n        vec2 vignetteUV = uv;\n        vignetteUV.y -= 0.2;\n        col = vec3(2.0 - length(vignetteUV))*.15;\n        \n        \n    }\n    else\n    {\n        float maskY = rd.y*4.0+.5;\n        vec3 N = GetNormal(ro+rd*t);\n        vec3 L = vec3(1.0, 0.0, 0.0);\n        float light = dot(N,L);\n        \n        col = mix(vec3(0.0), vec3(N+1.0), max(rd.y*4.0-0.2, 0.0));\n        \n        \n        \n        //col += N*max(rd.y*4.0-.5, 0.0)+ .2 * maskY;\n        \n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(sin(iTime*.5)*.03, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cp = vec3(0.0, 0.0, -4.5);\n    vec3 ct = vec3(sin(iTime)*.1, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    col = Render(cp, vd, uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Mlf3W2", "previewfilepath": "https://soundcloud.com/cryo-chamber/dark-ambient", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/cryo-chamber/dark-ambient", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdy3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdy3zy", "name": "basic01", "author": "legarcia", "description": "The bottomless weaved basket.\n\nFor my fellow rookies: read through  https://www.khronos.org/opengles/sdk/docs/manglsl/docbook4/", "tags": ["selftraining"], "likes": 2, "viewed": 87, "date": "1570416811", "time_retrieved": "2024-06-20T19:47:38.393078", "image_code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)*200./iResolution.y;\n\n    \n    vec3 o = vec3(0.,0.,.0);\n\n    vec2 left = uv;\n    left.x +=30.;\n    \n    vec2 right = uv;\n    right.x -=30.;\n    \n    \n    float lft_module = length(left);\n    float rgt_module = length(right);\n    \n    vec3 unit = vec3(.6,.2,-.3);\n    \n    o = unit*sin(lft_module-iTime*12.)*3.+ \n        unit*sin(rgt_module-iTime*12.)*3.+1.;\n    \n\n\n    // Output to screen\n    fragColor = vec4(o,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdy3zy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdyGDV", "name": "Rightpoint Logo", "author": "ssartell", "description": "Rightpoint Logo", "tags": ["raymarching"], "likes": 0, "viewed": 90, "date": "1570934825", "time_retrieved": "2024-06-20T19:47:38.393078", "image_code": "float farClip = 20.0;\nfloat pi = 3.14159;\nvec3 black = vec3(0.02);\nvec3 red = vec3(0.4, 0.0, 0.0);\n\nfloat join( float d1, float d2 ) {\n\treturn min(d1,d2);\n}\n\nfloat subtraction( float d1, float d2 ) {\n\treturn max(-d1,d2);\n}\n\nfloat intersection( float d1, float d2 ) {\n\treturn max(d1,d2);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinder( vec3 p, vec3 c ) {\n\treturn length(p.xz-c.xy)-c.z;\n}\n\nfloat bigP(vec3 p) {\n\tvec3 p1 = p + vec3(0.2, 0.1, 0.0);\n\tfloat d = box(p1, vec3(0.1, 0.5, 0.1));\n\n\tp1 = p + vec3(-0.1, -0.1, 0.0);\n\td = join(\n\t\td,\n\t\tsubtraction(\n\t\t\tcylinder(p1.xzy, vec3(0.0, 0.0, 0.1)),\n\t\t\tintersection (\n\t\t\t\tcylinder(p1.xzy, vec3(0.0, 0.0, 0.3)),\n\t\t\t\tbox(p1 + vec3(-0.3, 0.0, 0.0), vec3(0.3, 0.3, 0.1))\n\t\t\t)\n\t\t)\n\t);\n\n\td = join(\n\t\td,\n\t\tjoin(\n\t\t\tbox(p + vec3(0.0, -0.3, 0.0), vec3(0.1)),\n\t\t\tbox(p + vec3(0.0, 0.1, 0.0), vec3(0.1))\n\t\t)\n\t);\n\n\treturn d;\n}\n\nfloat bigR(vec3 p) {\n\tfloat d = bigP(p);\n\n\tvec3 p1 = vec3(p.x + p.y / 2.3, p.y, p.z);\n\n\td = join(\n\t\td,\n\t\tbox(p1 + vec3(-0.05, 0.3, 0.0), vec3(0.105, 0.3, 0.1))\n\t);\n\n\treturn d;\n}\n\nvec2 map(vec3 p) {\n\tp = vec3(-p.z, p.y - 0.2, p.x);\n\n\tfloat d = box(p + vec3(0.0, 0.25, 0.0), vec3(0.85, 0.65, 0.1));\n\tif (d > 0.1) {\n\t\treturn vec2(d, 0.0);\n\t}\n\n\tfloat d1 = join(\n\t\tbigR(p + vec3(0.45, 0.0, 0.0)),\n\t\tbigP(p + vec3(-0.45, 0.0, 0.0))\n\t);\n\n\tfloat d2 = box(p + vec3(0.4, 0.85, 0.0), vec3(0.35, 0.1, 0.1));\n\n\tif (d1 < d2) {\n\t\treturn vec2(d1, 1.0);\n\t} else {\n\t\treturn vec2(d2, 2.0);\n\t}\n}\n\nvec3 calcNormal(vec3 p) {\n\tvec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).x - map(p - e.xyy).x,\n\t\tmap(p + e.yxy).x - map(p - e.yxy).x,\n\t\tmap(p + e.yyx).x - map(p - e.yyx).x));\n}\n\nvec2 marchRay(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\tfloat g = 0.0;\n\tfor(int i = 0; i < 100; i++) {\n\t\tvec3 p = ro + t * rd;\n\t\tvec2 res = map(p);\n\t\tfloat h = res.x;\n\t\tg = res.y;\n\t\tif (h < 0.0001) return vec2(t, g);\n\t\tt += h;\n\t\tif (t > farClip) return vec2(0.0, 0.0);\n\t}\n\treturn vec2(t, g);\n}\n\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\tfloat angle1 = gain(fract(iTime / 5.0), 5.0) * 2.0 * pi;\n\tvec2 rot = vec2(angle1, 0.0);\n\tif (iMouse.z > 0.0) {\n\t\trot = 8.0 * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.xy;\n\t}\n\n\tfloat r = 3.4;\n\n\tvec3 ro = vec3(r * cos(rot.x), rot.y, r * sin(rot.x));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\n\t// camera axes\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww, vec3(0,1,0)));\n\tvec3 vv = normalize(cross(uu, ww));\n\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww);\n\n\tvec2 res = marchRay(ro, rd);\n\tfloat t = res.x;\n\tfloat g = res.y;\t\n\t\n\tvec3 col = vec3(1.0);\n\n\tif (t > 0.0) {\n\t\tcol = vec3(0.0);\n\t\tvec3 p = ro + t * rd;\n\n\t\tvec3 n = calcNormal(p);\n        vec3 l = normalize(vec3(1.0, 0.1, -0.2));\n\t\tvec3 r = reflect(-l, n);\n\n\t\tfloat ndotl = max(dot(n,l), 0.0);\n\t\tfloat rdotv = max(dot(-rd, r), 0.0);\n\n\t\tvec3 alb = black;\n\t\tif (g == 2.0) {\n\t\t\talb = red;\n\t\t}\n\n\t\tcol = alb * (ndotl * 0.7 + 0.3) + vec3(1.0) * pow(rdotv, 1000.0);\n\t}\n\n\tcol = pow(col, vec3(1.0 / 2.2));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdyGDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdyGWD", "name": "vector field coloring", "author": "Cewein", "description": "2D vector field in glsl, you can change the vector field as you like.\n\nPlease post it in the comment if you have something cool as a result.", "tags": ["color", "polar", "vectorfield"], "likes": 1, "viewed": 240, "date": "1570141678", "time_retrieved": "2024-06-20T19:47:38.938407", "image_code": "/*\n\n\tShader writtend by Maximilien 'cewein' nowak\n\t\n\tYou can modify the Vector field function under\n\tthis commentto change the look of the vector field\n\n\tfor the coloring, I use polar coordinate and the \n\ttransation form hsv color to rgb color. \n\n\t\n*/\n\nconst float PI = 3.14159265359;\n\n/*************************************************/\n/*                                               */\n/*            Vector field function              */\n/*                                               */\n/*************************************************/\n\nvec2 f(vec2 uv)\n{ \n    vec2 v = vec2(0.,5.);\n    \n    v.x =cos(uv.y) / tan(uv.y);\n    v.y =sin(uv.y * uv.x + iTime+length(uv)*5.);\n\n    return v;\n}\n\n\n/*************************************************/\n/*                                               */\n/*             Maths and coloring                */\n/*                                               */\n/*************************************************/\n\n//cartesian to poloar coordinate\nfloat xy2polar(vec2 xy)\n{\n    return atan(xy.x, xy.y);\n}\n\n//self explnatory function\nfloat rad2deg(float rad)\n{\n    return ((rad + PI)/(2.*PI)) * 360.;\n}\n\n//for the math being it : https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB\nvec3 hsv2rgb(float hue)\n{\n    float hue1 = hue/60.;\n    float x = 1. * (1.-abs((mod(hue1,2.))-1.));\n    vec3 col = vec3(0.);\n\n    if (hue1 >= 0. && hue1 <= 1.) {\n        col.x = 1.;\n        col.y = x;\n    } else if (hue1 >= 1. && hue1 <= 2.) {\n        col.x = x;\n        col.y = 1.;\n    } else if (hue1 >= 2. && hue1 <= 3.) {\n        col.y = 1.;\n        col.z = x;\n    } else if (hue1 >= 3. && hue1 <= 4.) {\n        col.y = x;\n        col.z = 1.;\n    } else if (hue1 >= 4. && hue1 <= 5.) {\n        col.x = x;\n        col.z = 1.;\n    } else if (hue1 >= 5. && hue1 <= 6.) {\n        col.x = 1.;\n        col.z = x;\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    //image zoom\n    uv *= 10.;\n    \n    //applying vector function\n    vec2 v = f(uv);\n    \n    //coloring\n    float phi = xy2polar(v);\n    float deg = rad2deg(phi);\n    vec3 polarColor = hsv2rgb(deg);\n    vec3 col = vec3(polarColor);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdyGWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws3SRn", "name": "AD - Connecting dots", "author": "arnedecant", "description": "Tutorial: https://www.youtube.com/watch?v=3CycKKJiwis", "tags": ["dots"], "likes": 9, "viewed": 176, "date": "1571312199", "time_retrieved": "2024-06-20T19:47:38.944463", "image_code": "float DistLine(vec2 p, vec2 a, vec2 b) {\n    \n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    \n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n    \n    return length(ap - ab * t);\n        \n}\n\nfloat N21(vec2 p) {\n    \n \tp = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    \n    return fract(p.x * p.y);\n    \n}\n\nvec2 N22(vec2 p) {\n    \n\tfloat n = N21(p);\n    \n    return vec2(n, N21(p + n));\n    \n}\n\nvec2 GetPos(vec2 id, vec2 offset) {\n    \n    vec2 n = N22(id + offset) * iTime;\n    \n    return offset + sin(n) * 0.4;\n\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b) {\n\t\n    float d = DistLine(p, a, b);\n    float m = smoothstep(0.03, 0.01, d);\n    \n    m *= smoothstep(1.2, 0.8, length(a - b));\n    \n    return m;\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    float m = 0.0;\n    \n    uv *= 5.0;\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    \n    int i = 0;\n    for (float y = -1.0; y <= 1.0; y++) {\n    \tfor (float x = -1.0; x <= 1.0; x++) {\n            vec2 offset = vec2(x, y);\n    \t\tp[i++] = GetPos(id, offset);\n    \t}\n    }\n    \n    float t = iTime * 10.0;\n    for (int i = 0; i < 9; i++) {\n    \tm += Line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i] - gv) * 20.0;\n        float sparkle = 0.5 / dot(j, j);\n        \n        m += sparkle * (sin(t + p[i].x * 5.0) * 0.5 + 0.5);\n    }\n    \n    m += Line(gv, p[1], p[3]);\n    m += Line(gv, p[1], p[5]);\n    m += Line(gv, p[7], p[3]);\n    m += Line(gv, p[7], p[5]);\n    \n    vec3 col = vec3(m);\n    \n    // if (gv.x > 0.48 || gv.y > 0.48) col = vec3(1, 0, 0);\n\n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3SRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws3SW8", "name": "ch819 Cone", "author": "KangarooChief", "description": "shader", "tags": ["shader"], "likes": 0, "viewed": 36, "date": "1571831302", "time_retrieved": "2024-06-20T19:47:39.702223", "image_code": "#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cone(vec3 p, float alpha)\n{\n \treturn (sin(alpha)*length(p.xy) + cos(alpha)*p.z);   \n}\n\nfloat scene(vec3 p) {\n    return cone(p, 2.0);\n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3SW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws3XD8", "name": "Shadertober 23 Mandelbrot -jb", "author": "jaburns", "description": "Simple Mandelbrot zoom until you run out of floating point accuracy.", "tags": ["mandelbrot", "zoom"], "likes": 0, "viewed": 250, "date": "1571861713", "time_retrieved": "2024-06-20T19:47:39.702223", "image_code": "float mandelbrot( vec2 c, vec2 offset )\n{\n    // Camera\n    c += offset / iResolution.xy;\n    c.x -= .65;\n    c /= exp( .3*iTime );\n    c += vec2( .34848, .510404 );\n    \n    // Iteration of z = z^2 + c\n    vec2 z = vec2( 0 );\n    float i = 0.;\n    for( ; i < 150.; ++i ) {\n        z = vec2(\n            z.r*z.r - z.g*z.g + c.r,\n            2.*z.r*z.g + c.g\n        );  \n        if (length(z) > 40.) break;\n    }\n    \n    if (i == 150.) return 0.;\n    \n    i = i - log(length(z)) / log(40.);\n    \n    return i / 150.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 3.*( fragCoord/iResolution.yy - vec2(.5 * iResolution.x/iResolution.y, .5) );\n    \n    // MSAA\n    float a = mandelbrot(uv, vec2(-.75, .25));\n    float b = mandelbrot(uv, vec2(-.25,-.75));\n    float c = mandelbrot(uv, vec2( .25, .75));\n    float d = mandelbrot(uv, vec2( .75,-.25));\n\n    fragColor = 0.25 * vec4(a + b + c + d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws3XD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws3XDr", "name": "Raymarching wobbley spheres", "author": "tiggerbiggo", "description": "dasfasdf", "tags": ["raymarching"], "likes": 5, "viewed": 303, "date": "1571769711", "time_retrieved": "2024-06-20T19:47:40.393196", "image_code": "/**\n * Part 1 Challenges\n * - Make the circle yellow\n * - Make the circle smaller by decreasing its radius\n * - Make the circle smaller by moving the camera back\n * - Make the size of the circle oscillate using the sin() function and the iTime\n *   uniform provided by shadertoy\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 s) {\n    \n    vec2 gridLocation = s.xy;\n    \n   \tgridLocation = floor(gridLocation);\n    \n    \n    \n    \n    s = vec3(fract(s.x)-0.5, fract(s.y)-0.5, s.z-sin(iTime+gridLocation.x*0.7)-cos(iTime+gridLocation.y*0.8));\n    return length(s) - 0.4;\n}\n\nfloat wallSDF(vec3 samplePoint) {\n    return samplePoint.z;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 s) {\n    return \n        //min(\n            sphereSDF(s);\n            //wallSDF(s));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(130.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(sin(iTime*0.1)*10.0, iTime*2.0, 5.0);\n   \n    mat4 viewToWorld = viewMatrix(eye, eye+vec3(0.0, 1, -1.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    fragColor = vec4(sin(fract(dist)*dist*0.4), fract((dist)+iTime), sin(dist+fract(-iTime)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws3XDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws3XR4", "name": "FunPipes", "author": "nolibab", "description": "Port intro 'FunPipes' release for Xenium party 2019 coded by mikael.", "tags": ["3d", "raymarching", "truchet", "pipes"], "likes": 10, "viewed": 159, "date": "1571500139", "time_retrieved": "2024-06-20T19:47:40.393196", "image_code": "//  FunPipes\tby mikael [code]  \n//  release party : Xenium 2019\n\nfloat l(vec3 f)\n{\nfloat l=fract(cos(dot(floor(abs(f)),vec3(13,78,35)))*43759.);\nif(l<.8)f=f.gbr;\nif(l<.4)f=f.gbr;\nf=fract(f);\nl=length(vec2(length(f.rg),f.b)-.5);\nf=f.gbr-vec3(1,1,0);\nl=min(l,length(vec2(length(f.rg),f.b)-.5));\nf=f.gbr-vec3(-1,1,-1);\nreturn min(l,length(vec2(length(f.rg),f.b)-.5))-.1;\n}\n\nfloat l(vec3 f,vec3 g,float m)\n{\nfloat r,b=0.;\nfor(r=.001;r<=m;r+=b)\n {\n b=l(f+g*r);\n if(b<.001*r)\n   break;\n }\nreturn r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\nvec3 g=vec3(0.,0.,iTime*.5), b=g+vec3(0,0,1), m=normalize(vec3(fragCoord.rg / iResolution.y - 1., 1.));\nvec2 i=sin(vec2(0,1.571)+iTime*.1);\nm.rg*=mat2(i.g,-i.r,i);    \nm.rb*=mat2(i.g,-i.r,i);    \nfloat k=min(l(g,m,6.),6.);\ng+=m*k;\nvec3 s=normalize(b-g);\nfloat n=length(b-g);\ni.r=.001;\ni.g=0.;\nb=normalize(vec3(l(g+i.rgg),l(g+i.grg),l(g+i.ggr))-l(g));\nvec3 a=vec3(0.);\nfor(float p=0.; p<.5; p+=.1)\n a+=l(g+b*p)/(1.+p);\nif(l(g,s,n)>=n)\n a+=dot(b,s)+pow(max(dot(reflect(-s,b),-m),0.),4.);\nfragColor = vec4( mix(a*(b+8.)/20.+l(g,reflect(m,b),2.)/8., vec3(.1,.2,.3), k/6.), 1. );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3XR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws3Xz2", "name": "Shadertober 27 - Coat", "author": "BackwardsCap", "description": "A fresh coat of paint", "tags": ["inktober", "shadertober", "backwardscaptain", "coat"], "likes": 2, "viewed": 234, "date": "1572379872", "time_retrieved": "2024-06-20T19:47:40.393196", "image_code": "float k(float w, float o)\n{\n    return clamp((o+cos(iTime/2.)+cos(w*20.)/200.)*2.,-.1,1.1);\n}\n\nvec3 s(vec3 c, float t, float x, float w)\n{\n    float  p = 3./iResolution.y,\n           f = smoothstep(0.+p,0.,x-t),\n           l = smoothstep(0.+p,0.,x-t+w)-f;\n    \t   c=mix(c,1.-c,f)-l;\n    return c;\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2  u = f/iResolution.xy;\n    float d = mod(floor(iTime/6.28),2.),\n          x = d==0.?u.x:u.y,\n       \t  l = d==0.?u.y:u.x*2.,\n\t      o = d==0.?(u.y>.5?.6:0.):(u.x>.66?.9:(u.x<=.33?-.3:.3)),\n          w = d==0.?.01:.02,\n          t = k(l,o);\n    bool  b = d==0.?u.y>.5:u.x<=.66&&u.x>.33;\n    vec3  p = 0.5 + 0.5*cos(iTime+u.xyx+vec3(0,2,4));\n\t\t  c.rgb=s(p,b?x:t,b?(1.-t):x,w);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws3Xz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws3Xz8", "name": "ray marching remi 2", "author": "vankeisb", "description": "lksqjslkqjqsdkljdskl", "tags": ["blah"], "likes": 2, "viewed": 61, "date": "1571401892", "time_retrieved": "2024-06-20T19:47:40.393196", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n    float y = abs(sin(iTime * 5.)) + 1.;\n    float x = sin(iTime);\n    float z = cos(iTime) + 6.;\n    vec4 sphere = vec4(x, y, z, 1);\n    float dS = length(p - sphere.xyz)-sphere.w;\n    float dP = p.y;\n    float d = min(dS,dP);\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}   \n\nfloat RayMarch(vec3 ro, vec3 rd) {    \n    float dO = 0.;\n    \n    for (int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(2, 4, 0);\n    lightPos.x += sin(iTime);\n//    vec3 lightPos = vec3(0, 10, 6);\n//    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 lightV = normalize(lightPos - p);\n    vec3 normal = GetNormal(p);\n    \n    float dif = clamp(dot(normal, lightV), 0., 1.);\n\n    float d = RayMarch(p+normal*SURF_DIST*2., lightV);\n    if (d < length(lightPos - p)) dif *= .1;\n    \n    return dif;\n   \n}\n\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) /iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    float diffuseL = GetLight(p);\n    \n    col = vec3(diffuseL);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws3Xz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws3XzH", "name": "Shadertober 16 - Wild", "author": "BackwardsCap", "description": "The inside of an egg", "tags": ["wild", "inktober", "shadertober", "backwardscaptain"], "likes": 3, "viewed": 224, "date": "1571455407", "time_retrieved": "2024-06-20T19:47:40.393196", "image_code": "#define MAX_DIST 100.\nfloat g;\n\nmat2 rot(float x)\n{\n    float s = sin(x);\n    float c = cos(x);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp(0.5+0.5*(d2-d1)/k,0.0,1.0);\n    return mix(d2,d1,h)-k*h*(1.0-h);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return min(max(q.x,max(q.y,q.z)),0.0)+length(max(q,0.0));\n}\n\nvec2 map(vec3 p)\n{\n    float m=0.;\n    float d = 3.;\n    float r = 1000.;\n    float pr = .3;\n    for(float i=0.;i<6.;i++)\n    {\n        p.yz*=rot(iTime/2.*pr+.1);\n        pr+=.15;\n        p.z+=1.5;\n        p.x-=1.5;\n        p.y+=1.;\n        p=abs(p);\n        r=smin(r,length(p)-d,.7);\n        \n        bool ev = mod(i,2.)==0.;\n        \n        if(ev)\n        r=smin(r,length(p-abs(vec3(1.5+cos(iTime)*pr)))-d/3.,.7);\n        p.xy *=rot(.5);\n        \n        \n        if(mod(i,2.)!=0.)\n        r=smin(r,box(p,vec3(1,2.+cos(iTime/4.)*11.,1)),.6);\n    }\n    g+=0.01/(0.01+r*r);\n    return vec2(r,m);\n}\n\nvec2 ray(vec3 ro, vec3 rd)\n{\n    float t =0., m=0.;\n    \n    for(int i=0;i<100;i++)\n    {\n        \n        vec3 p = ro+rd*t;\n        vec2 s = map(p);\n        m=s.y;\n        if(s.x<0.00001)break;\n        t+=s.x;\n        if(t>MAX_DIST){t=-1.;break;}\n        \n    }\n    \n    return vec2(t,m);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0005,0.);\n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        ));\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.y+vec2(.1,0);\n\tfloat d = 22.5;\n    vec3 ro = vec3(d,0,d);\n    vec3 ta = vec3(0,0.,0);\n    vec3 cf = normalize(ta-ro);\n    vec3 cu = normalize(cross(cf,vec3(0,1,0)));\n    vec3 cr = normalize(cross(cu,cf));\n    vec3 rd = normalize(uv.x*cu+uv.y*cr+2.*cf);\n    \n    vec2 r = ray(ro,rd);\n    vec3 p = ro+rd*r.x;\n    vec3 col = vec3(1.);\n    \n    vec3 sun = normalize(ro);\n    float dif = clamp(dot(normal(p),sun),0.0,1.0);\n\n    if(r.x>0.)col=vec3(1.0)*dif;\n    else col/=g;\n    c.rgb=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws3XzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WscSR4", "name": "Flower Wave by Joyer", "author": "Joyer", "description": "Simple Flower by Joyer", "tags": ["flower"], "likes": 0, "viewed": 62, "date": "1571499057", "time_retrieved": "2024-06-20T19:47:40.393196", "image_code": "// Flower Wave by Joyer 2019\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    vec2 pos = vec2(0.5)-st;\n\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n\tfloat boosted = iTime + 50.;\n    float f = cos(a*boosted/10.) * 1./7.*sin(r*a*12.) + abs(1. - fract(boosted / 10.0) * 2.0);\n\n    color = vec3((1.-smoothstep(f,f+(0.04*1./r),r)) * smoothstep(f-(0.05*1./r),f,r), 0.2, 0.3 );\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WscSR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wscSRj", "name": "Simple Domain Warping ", "author": "hahnzhu", "description": "simply edited from https://thebookofshaders.com/13/\nCredit to iq for this article: http://www.iquilezles.org/www/articles/warp/warp.htm", "tags": ["noise", "fbm"], "likes": 7, "viewed": 367, "date": "1572333688", "time_retrieved": "2024-06-20T19:47:40.399039", "image_code": "float random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat value_noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// Domain Warping from Inigo Quiles\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n#define NUM_OCTAVES 2\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * value_noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n\t\n    vec3 color = vec3(0.0);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 0.50*iTime);\n    q.y = fbm( st + vec2(1.0));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );\n    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\n    float f = fbm(st+r);\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n    \n    // Output to screen\n    fragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wscSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wscSRr", "name": "rolling shutter propeller ", "author": "matthen", "description": "demo of rolling shutter effect on a rotating propeller", "tags": ["rotation", "rollingshutter"], "likes": 2, "viewed": 110, "date": "1571299627", "time_retrieved": "2024-06-20T19:47:40.399244", "image_code": "#define kNumBlades 5.\n#define kAntiAlias 1.\n\n// from https://www.shadertoy.com/view/ll2GD3\nvec3 gradient(in float t) {\t\n    vec3 a = vec3(.5, .5, .5);\n    vec3 b = vec3(.5, .5, .5);\n    vec3 c = vec3(1., 1., .5);\n    vec3 d = vec3(.8, .9, .3);\n    return a + b * cos(6.28318 * ( c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    \n    for (float i = -kAntiAlias; i <= kAntiAlias; i += 1.) {\n\t    for (float j = -kAntiAlias; j <= kAntiAlias; j += 1.) {\n           \n            vec2 sampleCoord = fragCoord + 0.5 * vec2(i, j);\n   \n            vec2 uv = (sampleCoord - .5 *iResolution.xy) / iResolution.y;\n            float time = 2. * iTime;\n            float delay = 2000.*(10. * (.5 + uv.x) + 100. * (.5 + uv.y));\n            time -= 0.0001 * (.5 - .5 * cos(.1 * iTime)) * delay;\n            float theta = atan(uv.x, uv.y);\n            theta += time;\n            float r = length(uv);\n            vec3 rgb = gradient(1. -  3. * r);\n            rgb *= (0.5 + .5 * sin(kNumBlades * theta));\n            float inProp = step(-.6, r - cos(kNumBlades * theta)) * step(0.05, r);\n            col += rgb * (1. - inProp);\n            col += inProp;\n       \t}\n    }\n    \n    col /= pow((2. * kAntiAlias + 1.), 2.);\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wscSRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WscSzj", "name": "Atom_gooch", "author": "zxxuan1001", "description": "sdf functions from iq: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nshading formula from original paper: https://users.cs.northwestern.edu/~ago820/SIG98/gooch98.pdf\n", "tags": ["goochshading"], "likes": 2, "viewed": 287, "date": "1572310532", "time_retrieved": "2024-06-20T19:47:40.399244", "image_code": "const float EPSILON = 0.0001;\nconst float PI = 3.1415926;\nconst float MAX_DIST = 100.0;\nconst int MAX_STEPS = 60;\nconst vec3 GREEN = vec3(125.0, 245.0, 217.0)/255.0;\nconst vec3 YELLOW = vec3(0.2, 0.2, 0.0);\nconst vec3 PINK = vec3(255.0, 94.0, 186.0)/255.0;\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shiness;\n};\n\n#define AA 1\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nvec2 intersectSDF(vec2 dist0, vec2 dist1) {\n    return dist0.x > dist1.x? dist0 : dist1;\n}\n\nvec2 unionSDF(vec2 dist0, vec2 dist1) {\n    return dist0.x < dist1.x? dist0 : dist1;\n}\n\nvec2 diffSDF(vec2 dist0, vec2 dist1) {\n    return dist0.x > -dist1.x? dist0 : vec2(-dist1.x, dist1.y);\n}\n\nvec3 rotX(vec3 p, float d) {\n    mat4 rotM= mat4(1.0, 0.0, 0.0, 0.0, \n                    0.0, cos(d), -sin(d), 0.0, \n                    0.0, sin(d), cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\nvec3 rotY(vec3 p, float d) {\n    mat4 rotM= mat4(cos(d), 0.0, sin(d), 0.0, \n                    0.0, 1.0, 0.0, 0.0,\n                    -sin(d), 0.0, cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nvec3 rotZ(vec3 p, float d) {\n    mat4 rotM= mat4(cos(d), -sin(d), 0.0, 0.0, \n                    sin(d), cos(d), 0.0, 0.0, \n                    0.0, 0.0, 1.0, 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nvec3 doTranslate(vec3 p, vec3 t) {\n    return p - t;\n}\n\nvec2 sceneSDF(vec3 p) {\n    float deg = 90.0;\n    float sr = 2.0;\n    float lr = 2.0;\n    float SR = 1.8;\n    float LR = 1.5;\n    float spheres[12];\n    float vTime = iTime;\n    \n    float id = 1.0;\n    for (int i = 0; i < 4; i ++) {\n        float dx = SR * cos(90.0 * id * PI / 180.0);\n        float dz = SR * sin(90.0 * id * PI / 180.0);\n        vec3 v = vec3(p.x + dx, p.y, p.z + dz);\n        spheres[i] = sphereSDF(v, sr);\n        id += 1.0;\n    }\n    spheres[4] = sphereSDF(vec3(p.x, p.y + LR, p.z), lr);\n    spheres[5] = sphereSDF(vec3(p.x, p.y - LR, p.z), lr);\n    \n    \n    \n    float torus[3];\n    float t_ry = 0.1;\n    float t_rxl = 16.0;\n    float t_rxs = 12.0;\n    float alpha0 = vTime;\n    float alpha1 = vTime + 90.0 * PI / 180.0;\n    torus[0] = sdTorus( rotX(p, alpha0), vec2(t_rxl, t_ry) );\n    torus[1] = sdTorus( rotZ(p, alpha0), vec2(t_rxs, t_ry) );\n    torus[2] = sdTorus( rotZ(p, alpha1), vec2(t_rxs, t_ry) );\n    \n    float ssr = 0.3;\n    spheres[6] = sphereSDF(vec3(p.x, p.y - t_rxl * sin(alpha0), p.z + t_rxl * cos(alpha0)), ssr);\n    spheres[7] = sphereSDF(vec3(p.x, p.y + t_rxl * sin(alpha0), p.z - t_rxl * cos(alpha0)), ssr);\n    spheres[8] = sphereSDF(vec3(p.x - t_rxl, p.y, p.z), ssr);\n    spheres[9] = sphereSDF(vec3(p.x + t_rxl, p.y, p.z), ssr);\n    \n    spheres[10] = sphereSDF(vec3(p.x - t_rxs * cos(alpha0), p.y - t_rxs* sin(alpha0), p.z), ssr);\n    spheres[11] = sphereSDF(vec3(p.x - t_rxs * cos(alpha1), p.y - t_rxs* sin(alpha1), p.z), ssr);\n    \n    float objId = 0.0;\n    //horizontal spheres\n    vec2 combined = unionSDF(vec2(spheres[0], objId), vec2(spheres[1], objId));\n    combined = unionSDF(combined, vec2(spheres[2], objId));\n    combined = unionSDF(combined, vec2(spheres[3], objId));\n    \n    //lower sphere\n    objId++;\n    combined = unionSDF(combined, vec2(spheres[4], objId));\n    \n    //upper sphere\n    objId++;\n    combined = unionSDF(combined, vec2(spheres[5], objId));\n    \n    //small spheres\n    objId++;\n    combined = unionSDF(combined, vec2(spheres[6], objId));\n    combined = unionSDF(combined, vec2(spheres[7], objId));\n    combined = unionSDF(combined, vec2(spheres[8], objId));\n    combined = unionSDF(combined, vec2(spheres[9], objId));\n    combined = unionSDF(combined, vec2(spheres[10], objId));\n    combined = unionSDF(combined, vec2(spheres[11], objId));\n    \n    //large tortus\n    objId++;\n    combined = unionSDF(combined, vec2(torus[0], objId));\n    \n    //small tortus\n    objId++;\n    combined = unionSDF(combined, vec2(torus[1], objId));\n    combined = unionSDF(combined, vec2(torus[2], objId));\n    \n  \n    \n   return combined;\n}\n\nvec2 rayMarching(vec3 ro, vec3 rd) {\n    float tmax = MAX_DIST;\n    float t = 0.0;\n    vec2 result = vec2(-1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 res = sceneSDF(p);\n        if (res.x < EPSILON || t > tmax) break;\n       \n        t += res.x;\n        result.x = t;\n        result.y = res.y;\n    }\n    \n    if (t > tmax) result.x = tmax;\n    return result;\n}\n\nvec3 getNormal(vec3 p) {\n    float x = sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x;\n    float y = sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x;\n    float z = sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x;\n    return normalize(vec3(x, y, z));\n}\n\nvec3 shading(vec3 p, vec3 ro, vec3 rd, Material mat) {\n    vec3 col = vec3(0.0);\n    vec3 nor = getNormal(p);\n    //light needs to be perpendicular to gaze direction\n    vec3 lightDir = -vec3(0.2, 0.8, 0.6); \n    vec3 viewDir = normalize(rd);\n    vec3 ref = normalize(reflect(-lightDir, nor));\n    vec3 surf = mat.diffuse;//vec3(0.8, 0.5, 0.4);\n    vec3 warm = vec3(0.3, 0.3, 0.0) + 0.25 * surf;\n    vec3 cool = vec3(0.0, 0.0, 0.55) + 0.25 * surf;\n    float dotLN =dot(lightDir, nor);\n    float k = (1.0 + dotLN) / 2.0;\n    vec3 gc = k * cool + (1.0 - k) * warm;\n    float spe = pow(max( dot( viewDir, ref ), 0.0 ), mat.shiness);\n    \n    col = spe + (1.0-spe)*gc;\n    return col;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 background(vec2 p) {\n    return 0.8*mix(vec3(0.0,0.3,0.4), vec3(0.4,0.5,0.6), p.y + 0.5);\n}\n\nvec3 render(in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  uv -= 0.5;\n    \n  uv.x *= iResolution.x/iResolution.y;\n  vec2 mo = iMouse.xy/iResolution.xy - 0.5;\n  \n  vec3 ro = vec3 (cos(iTime) * 10.0 + 10.0, 3.0, sin(iTime) * 10.0 + 20.0);\n  vec3 ta = vec3 (0.0, 0.0, -1.0);\n  mat3 cam = getCamera(ro, ta, 0.0);\n  \n  vec3 rd = normalize(cam * vec3(uv, 1.0));\n  vec2 h = rayMarching(ro, rd);\n \n  vec3 col = vec3(0.0);\n  \n  if (h.x < MAX_DIST) {\n    \n    vec3 p = ro + rd * h.x;\n        \n    Material mat;\n    //chrome\n    mat.ambient = vec3(0.1);\n    mat.diffuse = vec3(0.4);\n    mat.specular = vec3(0.674597);\n    mat.shiness = 32.0;\n    \n    if (h.y == 1.0 || h.y == 2.0) {\n      //pink\n      mat.ambient = PINK;\n      mat.diffuse = PINK;\n      mat.specular = PINK;\n    } else if (h.y == 0.0) {\n      //gold\n      mat.ambient = vec3(0.24725, 0.1995, 0.0745);\n      mat.diffuse = vec3(0.75164, 0.60648, 0.12648);\n      mat.specular = vec3(0.628281, 0.555802, 0.366065);\n      mat.shiness = 8.0;\n    } \n    col += shading(p, ro, rd, mat); \n    \n  } else {\n      col = background(uv);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0.0);\n#if AA > 1\n    float count = 0.0;\n    for (float aaY = 0.0; aaY < float(AA); aaY++)\n    {\n        for (float aaX = 0.0; aaX < float(AA); aaX++)\n        {\n            col += render(fragCoord + vec2(aaX, aaY) / float(AA));\n            count += 1.0;\n        }\n    }\n    col /= count;\n#else\n    col += render(fragCoord);\n#endif\n    \n    col = pow( col, vec3(1.0/2.2) );\n     \n    vec2 p = fragCoord/iResolution.xy ;\n    col *= 0.2 + 0.8 * pow(32.0 * p.x * p.y * (1.0 - p.x) * (1.0 - p.y), 0.2);\n    \n    fragColor = vec4 (col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WscSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wscXRr", "name": "Golden flow 2", "author": "pik33", "description": "Avoiding black :)", "tags": ["plasma"], "likes": 6, "viewed": 136, "date": "1571303270", "time_retrieved": "2024-06-20T19:47:40.399244", "image_code": "const float Pi = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=7.0*(fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x,iResolution.y);\n    vec2 p=vec2(abs(q.x),q.y);\n\t\n\tfor(int i=1;i<40;i++)\n\t{\n\t\tvec2 newp=p;\n\t\tnewp.x+=(0.5/(1.0*float(i)))*cos(float(i)*p.y+iTime*11.0/37.0+0.03*float(i))+1.3;\t\t\n\t\tnewp.y+=(0.5/(1.0*float(i)))*cos(float(i)*p.x+iTime*17.0/41.0+0.03*float(i+10))+1.9;\n\t\tp=newp;\n\t}\n\n\tvec3 col=vec3(0.5*sin(3.0*p.x)+0.5,0.5*sin(3.0*p.y)+0.5,sin(1.3*p.x+1.7*p.y));\n    float f=0.43*(col.x+col.y+col.z);\n\n\tfragColor=vec4(f+0.6,0.2+0.75*f,0.2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wscXRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wscXWM", "name": "burning ship", "author": "finalpatch", "description": "Burning Ship fractal", "tags": ["fractal"], "likes": 6, "viewed": 138, "date": "1572099890", "time_retrieved": "2024-06-20T19:47:40.399244", "image_code": "const float esc = 20.0;\nconst int depth = 420;\nconst float p = 30.0;\n\nvec3 mandel(vec2 z0)\n{\n    float k = 0.0;\n    vec2 z = vec2(0.0);\n    for(int i = 0; i < depth; ++i)\n    {\n        vec2 z1 = vec2(abs(z.x), abs(z.y));\n        z = vec2(z1.x*z1.x-z1.y*z1.y, z1.x*z1.y*2.0) + z0;\n        if (length(z) > esc)\n            break;\n        k += 1.0;\n    }\n    float mu = k + 1.0 - log2(log(length(z)));\n    return sin(mu*0.1 + vec3(0.0,0.5,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n\tvec2 uv = gl_FragCoord.xy / iResolution.yy;\n    float t = mod(iTime, p);\n    if (t > p/2.0)\n        t = p - t;\n    uv *= vec2(1.0, -1.0) * 3.0;\n    uv += vec2(-1.0, 1);\n    float scale = 0.5 + pow(2.0, t);\n    vec2 offset = vec2(-1.76, -0.025);\n    uv += offset*scale;\n    uv /= scale;\n    fragColor = vec4(mandel(uv), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wscXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wscXWN", "name": "the World in the picture book", "author": "MapleSyrupCS6", "description": "the World in the picture book", "tags": ["maplestudy"], "likes": 6, "viewed": 96, "date": "1571982629", "time_retrieved": "2024-06-20T19:47:40.399244", "image_code": "float rand(vec2 id)\n{\n    return fract(sin(dot(id, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat cloth(vec2 id, float value)\n{\n    return sin(dot(id*value, vec2(12.9898, 78.233)) * 43758.5453);\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat df1( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat df2( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat df3( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat map(vec3 p , float s){\n    \n    p.xy = mod(p.xy, 10.) - 1. * 5.;\n    return df3(p, s);\n}\n\nfloat dfm(vec3 p, float s){\n    \n    p.y -= 0.8;\n    vec3 q = rotate(p, radians(iTime * 5.0)*10., vec3(0.0, 1.0, 0.05));\n    //vec3 q2 = rotate(p, radians(5.0)*20., vec3(0.0, 1.0, 0.1));\n    float d3 = df3(q, 2.0);\n    float d4 = df2(q, vec2(3.5, 0.07));\n    float m2 = min(d3, d4);\n    p.y += 3.0;\n    float d1 = df1(p, vec3(2., 0., 2.), 0.3);\n    float d2 = df3(p, 2.0);\n    float m =  max(d1, d2);\n    return min(m, m2);\n    //return max(-d1, d2); // d1が重なっていないd2部分を描く\n    //return max(d1, -d2); // d2が重なっていないd1部分を描く\n    \n    \n}\n\n\nint dfc(vec3 p, float s){\n    \n    p.y -= 0.8;\n    vec3 q = rotate(p, radians(iTime * 5.0)*10., vec3(0.0, 1.0, 0.05));\n    //vec3 q2 = rotate(p, radians(5.0)*20., vec3(0.0, 1.0, 0.1));\n    float d3 = df3(q, 2.0);\n    float d4 = df2(q, vec2(3.5, 0.1));\n    float m2 = min(d3, d4);\n    p.y += 3.0;\n    float d1 = df1(p, vec3(2., 0., 2.), 0.3);\n    float d2 = df3(p, 2.0);\n    float m =  max(d1, d2);\n   float mm =  min(m, m2);\n\n    \n    int color = d4 < d3 ? 0 : \n    \t\t\t\t   mm < d3 ? 1 : 2;\n    return color;\n}\n\nvec3 normal(vec3 p, float s){\n\n    vec2 e = vec2(0.0001, 0);\n    float d = dfm(p, s);\n    vec3 n = d - vec3(\n        dfm(p - e.xyy, s),\n        dfm(p - e. yxy, s),\n        dfm(p - e. yyx, s));\n    return normalize(n);\n}\n\nfloat image(vec2 uv){\n  \t//uv = fract(uv);\n    float d = distance(vec2(rand(uv), rand(uv))*5., uv);\n    d = step(2., d);\n    \n    \n    return d;\n}\n\nfloat image2(vec2 uv){\n  \t//uv = fract(uv);\n    float d = distance(vec2(rand(uv), rand(uv)), uv);\n    d = step(d, abs(0.9));\n    \n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 cameraPos = vec3(0, 0, -10);\n    float screenZ = 2.5;\n    vec3 rayDir = normalize(vec3(uv, screenZ));\n    vec3 lightDir = normalize(vec3(1.0, 1.0, -10.));\n    \n    float size = 1.0;\n    float depth = 0.0;\n    float dist = 0.0;\n    int color = 0;\n    vec3 rayPos = vec3(0.0);\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 99; i++){\n        \n      \trayPos = cameraPos + (rayDir * depth);\n        dist = dfm(rayPos, size);\n        color = dfc(rayPos, size);\n        \n        if(dist < 0.0001) break;\n        \n        depth += dist;\n    }\n    \n    \n    if(dist < 0.0001){\n        \n      \tvec3 n = normal(rayPos, 1.0);\n        float diff = dot(n ,lightDir);        \n        float im = image(uv);\n        vec3 c1 = vec3(0.5, 0.4, 0.9);\n        vec3 c2 = vec3(0.);\n        \n        if(color == 0){\n            float clo = cloth(uv, 9.);\n            //col = mix(vec3(0.9, 0.9, 0.4), vec3(0.9, 0.7, 0.4), diff);\n            col = vec3(0.9, 0.9, 0.4);\n            col = mix(col, vec3(0.3), clo);\n           // col = mix(c1, c2, diff); \n        }else if(color == 1){\n            float clo = cloth(uv, 0.2);\n            vec3 c1 = vec3(0.8, 0.6, 0.1);\n            c1 -= (0.3);\n            col = mix(c1, vec3(0.2), diff);\n            col /= clo;\n        }else{\n            float im = image2(uv);\n            float clo = cloth(uv, 9.);\n            vec3 c1 = vec3(0.2, 0.3, 0.9);\n            c1 += (0.4);\n            col = mix(c1, vec3(0.2), im);\n            //col /= clo;\n        }\n        //col = mix(c1, c2, diff); \n        //col += image2(uv);\n       // col /= image(uv);\n    }else{\n        float clo = cloth(uv, 1.);\n        float d = image(uv);\n        vec3 c1 = vec3(0.0, 0.2, 0.9);\n        c1 -= vec3(0.5);\n        vec3 c2 = vec3(0.9, 0.9, 0.2);\n        //col = mix(c2, c1, d);  \n        col = vec3(0.3, 0.3, 0.6);\n        col += (0.4);\n        col = mix(col, c2, clo);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wscXWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdGRl", "name": "Julia set dynamics", "author": "nurof3n", "description": "Some fractal fuckening", "tags": ["mandelbrot", "distanceestimation"], "likes": 6, "viewed": 146, "date": "1571128963", "time_retrieved": "2024-06-20T19:47:40.817399", "image_code": "const vec3 colorf = vec3(.0);\nconst vec3 colorf2 = vec3(.8, .3, .2);\nconst vec2 zoompoint = vec2(-0.77568377, 0.13646737);\n\nvec3 hsv2rgb( float c )\n{\n    vec3 rgb = clamp( abs(mod(c*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y; \n    highp float zoom = 1.0;\n    \n    //highp float tz = 0.5 * (1. - cos(iTime * 0.5));\n    //zoom = pow(2.2, 15.0 * tz);\n    highp float real = position.x * 2.7 / zoom;\n    highp float imag = position.y * 2.7 / zoom;    \n    //real += zoompoint.x;\n\t//imag += zoompoint.y;\n    \n    //mandelbrot set\n    highp vec2 z = vec2(0.0);\n    highp vec2 dz = vec2(0.0);\n    highp vec2 c = vec2(real, imag);// + vec2(sin(iTime), cos(iTime));\n    highp float rz = 0.0;\n    highp float rdz = 0.0;\n    int nri = 0;\n    \n    //julia set\n\tz = vec2(real, imag);\n\tc = vec2(-.4, -.6) + vec2(sin(iTime * fract(position.x * 10000.)), 2.56 * cos(iTime * .5));\n\t\n\n    //int nri;\n    for (int i = 0; i < 500; i++)\n    {\n        if(rz > 1024.0)\n            break;\n\n        // Z' -> 2*Z*Z' + 1\n        dz = 2.0 * vec2(z.x * dz.x - z.y * dz.y, z.x * dz.y + z.y * dz.x) + vec2(1.0, 0.0);\n\n        // Z -> Z^2 + c\t\t\t\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n\n        nri = i;\n\n        rz = dot(z, z);\t//is the modulo squared\t\n    }\n\n    //https://www.mi.sanu.ac.rs/vismath/javier/b3.htm (COLORING ALGORITHMS)\n    rdz = dot(dz, dz);\n    highp float d = sqrt(rz / rdz) * log(rz);\n    highp vec3 color;\n    if (rz < 4.0)\n        color = colorf;\n    else {\n        float nic = float(nri) + 1. - log2(log2(rz));\t\t\t\t\t//normalized iteration count\n        //color = hsv2rgb((nic * .015));\t\t\t\t\t\t\t\t//multicolored\n        color = .5 + .5 * cos(3.0 + nic * .2 + vec3(0.0,0.6,1.0));\t//like on wiki?\n        //color = 0.2 + mix(colorf, colorf2, fract(float(nri) * .02));\t//(discrete) escape time coloring: Base the color on the number of iterations\n       // d = clamp(pow(4.0 * d, 0.3), 0.0, 10.0);\t\t\t\t\t\t//(~continuous: if the bailout is larger then it is smoother) dem based on the Hubbard-Douady potential\n        //color = 0.5 + 0.5 * cos(colorf2 + hsv2rgb(d) * 2.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdGRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsdSDM", "name": "Psychedelic Worley", "author": "piyushslayer", "description": "I was working on a bigger shader that required worley noise, and ended up coding\na quick psychedelic disco mock up.", "tags": ["voronoi", "noise", "color", "random", "worley", "psychedelic", "disco", "cell"], "likes": 3, "viewed": 312, "date": "1572136643", "time_retrieved": "2024-06-20T19:47:40.817399", "image_code": "// Thank you Dave_Hoskins for the hash! <3\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*uvec2(1597334673U, 3812015801U);\n\tq = (q.x ^ q.y) * uvec2(1597334673U, 3812015801U);\n\treturn vec2(q) * (1.0 / float(0xffffffffU));\n}\n\nfloat worley(vec2 uv)\n{\n    uv *= 5.;\n    uv += iTime*.25;\n    \n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    \n    float minDist = 100.;\n    for (float y = -1.; y <= 1.; ++y)\n    {\n        for(float x = -1.; x <= 1.; ++x)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 h = hash22(id + offset) * .8 + .1; // .1 - .9\n    \t\th = (((sin(h*iTime)+1.)*.5)*.8+.1) + offset;\n            float p = length(gv - h);\n            if (p < minDist)\n            {\n                minDist=p;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= aspectRatio;\n    \n    vec3 col = vec3(0.);\n    float w = worley(uv);\n    col += 1.-w;\n    col.r *= smoothstep(1.7, .0, length(uv-(sin(vec2(.7, .5)+iTime)+1.)*.5));\n    uv.x = 1.2-uv.x;\n    col.g *= smoothstep(1.7, .0, length(uv-(cos(.5+iTime)+1.)*.5));\n    col.b *= 1.-sin(col.r+col.g);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsdSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsdSR8", "name": "Heart function", "author": "nurof3n", "description": "A nice little heart ", "tags": ["heart"], "likes": 4, "viewed": 92, "date": "1571424654", "time_retrieved": "2024-06-20T19:47:41.114322", "image_code": "float f(vec2 uv) {\n    float t = atan(uv.y, uv.x);\n    float r = length(uv);\n    if(t > .0)\n    \tt = -t;\n \treturn r - (.6 + sin(t) * sin(t + .75) + fract(sin(t*.8)) + cos(t) - .6*(pow(abs(cos(t)), 4.)));       \n}\n\nvec2 grad2(vec2 uv) {\n \tvec2 h = vec2( 0.001, 0.0 );\n    return vec2(f(uv+h.xy) - f(uv-h.xy),\n                f(uv+h.yx) - f(uv-h.yx)) / (2.0*h.x);\n}\nfloat sdf(vec2 uv, vec2 g) {\n \tfloat v = f(uv);\n    float de = v/length(g);\n    return de; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 3.;\n    uv = vec2(-uv.y, uv.x);\t//90 rotation\n    uv.x += .75;\n    uv *= (abs(sin(3.*iTime)) / 15. + 1.);\n    vec3 color;\n    //color = mix( vec3(.8, .33, .3), vec3(1.), smoothstep(.0, .05, length(uv) - f(uv)) );\t//edges not properly drawn\n    \n    vec2 g = grad2(uv);\n    float de = sdf(uv, g);\n    float eps = 20. / iResolution.y;\n    color = mix(vec3(.8, .33, .3), vec3(1.), smoothstep(.0, eps, de));\t//for isosurface do smoothstep with abs(de)\n    \n    //Uncomment for many hearts!\n    /*\n    vec2 uv2 = mod(uv * 18. + vec2(.8, 1.5), vec2(3.)) - vec2(3.);\n    uv2.x += 2.;\n    uv2.y += 1.5;\n    \n    vec2 g2 = grad2(uv2);\n    float de2 = sdf(uv2, g2);\n    if(color == vec3(.8, .33, .3))\n    \tcolor = mix(vec3(.8, .33, .3), vec3(1.), smoothstep(.0, 2.*eps, de2));\n\t*/\n\t\n    \n   \tuv.x -= .75;\n    color *= (7. - pow(length(uv), .7)) * vec3(.3, .1, .2);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsdSR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdSRr", "name": "Isometric Grid w/ Mouse Interact", "author": "r3eckon", "description": "Simple isometric grid rendering with correct UV space for each cell.", "tags": ["grid", "isometric", "tilemap"], "likes": 4, "viewed": 226, "date": "1571367073", "time_retrieved": "2024-06-20T19:47:41.641628", "image_code": "#define CCOUNT 4.0\n#define CELL_FILL .95  \n\nvec2 AgridID(vec2 uv)\n{\n    uv.y /=0.5;\n    \n    return vec2(floor(uv));\n}\n\nvec2 BgridID(vec2 uv)\n{\n    uv.y /= 0.5;\n    \n    return vec2(floor((uv-0.5)));\n}\n\nvec2 AgridUV(vec2 uv, float cells)\n{\n\treturn vec2(mod(uv.x, 1.0), mod(uv.y*2.0, 1.0));\n}\n\nvec2 BgridUV(vec2 uv, float cells)\n{\n\treturn vec2(mod(uv.x-0.5, 1.0), mod((uv.y*2.0)-0.5, 1.0));\n}\n\nfloat los( vec2 pos, vec2 s ) \n{\n    vec2 abspos = abs(pos - vec2(0.5,0.5));\n\n    return sign( abspos.x*s.y + abspos.y*s.x - s.x*s.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n    vec2 ar = vec2(1.0, iResolution.y/iResolution.x);\n    \n    float CELLS = iTime*CCOUNT + CCOUNT;\n\n    mouseUV *= ar;\n    mouseUV *= CELLS;\n    \n    uv *= ar;\n    uv *= CELLS;\n    \n    vec2 aguv = AgridUV(uv,CELLS);\n    vec2 bguv = BgridUV(uv,CELLS);\n    \n    //Just to make circles render within cells instead of ovals\n    //aguv.y *= ar.y;\n    //aguv.y += 0.5 * ar.y;\n    \n    //bguv.y *= ar.y;\n    //bguv.y += 0.5 * ar.y;\n    \n    \n    //vec3 acol = vec3(floor(1.335 - distance(aguv - 0.5, vec2(.0,.0))));\n    //vec3 bcol = vec3(floor(1.335 - distance(bguv - 0.5, vec2(.0,.0))));\n    \n    //vec3 acol = vec3(aguv.x, aguv.y, 0.0);\n    //vec3 bcol = vec3(bguv.x, bguv.y, 0.0);\n    \n    float alos = 1.0-los(aguv, vec2(0.5*CELL_FILL));\n    float blos = 1.0-los(bguv, vec2(0.5*CELL_FILL));\n    \n    vec2 agid = AgridID(uv);\n    vec2 bgid = BgridID(uv);\n    \n    vec2 amgid = floor(AgridID(mouseUV));\n    vec2 bmgid = floor(BgridID(mouseUV));\n    \n    vec3 acol = vec3(alos);\n    vec3 bcol = vec3(blos);\n    \n    vec3 col = max(acol,bcol);\n    //vec3 col = acol;\n    \n    vec3 overlay = vec3(1.0,0.0,0.0);\n    vec3 overlay2 = vec3(0.0,1.0,0.0);\n    \n    if(agid == amgid)\n    {\n        if(alos >= 1.0)\n        \tcol*=overlay;\n    }\n    \n    if(bgid == bmgid)\n    {\n        if(blos >= 1.0)\n        \tcol*=overlay2;\n    }\n    \n    if(bgid.x < 0.0 || bgid.y < 0.0)\n    {\n        col *= 1.0-blos;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdSRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdSW4", "name": "Prueba niebla ", "author": "rueton", "description": "Probando shaders haciendo niebla y alguna cosa más.\n\nAdded (as comment) a variation which moves the colored parts  (in vec3 col)\nCommented the effect that step does in  fragColor. Now it behaves normally.", "tags": ["nieblaroja"], "likes": 2, "viewed": 83, "date": "1572017214", "time_retrieved": "2024-06-20T19:47:41.981076", "image_code": "#define time -iTime\n\nfloat random(vec2 coord){\n     float aux_a = (coord.x * .25 + coord.y * 0.4);\n \treturn fract(sin(aux_a*4541522.6591 + 5415528.969 )*5157.15121);\n}   \n\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(mix(a, b, u.x) , mix(c,d, u.x), u.y) ;\n}\n\nfloat fbm(vec2 coord){\n    int iter = 4;\n\tfloat value = 0.;\n    float scale = 0.5;\n        \n        for(int  i= 0; i<iter; i++){\n           value +=  noise(coord) * scale;\n           coord*=2.;\n           scale*=0.5 ;\n               }\n    return value;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 10.*fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    \n    \n   vec2 motion = vec2(fbm(uv+iTime*0.4));\n    //vec3 col = vec3 (fbm(uv+motion -iTime*step(0.2 , noise(vec2(random(uv))))));\n\tvec3 col = vec3 (fbm(uv+motion));\n    \n    //add base color\n    vec3 base = vec3(0.70,0.3,0);\n    \n    \n    // Output to screen\n    //fragColor = vec4((col)*(-1.)*step(0.1,abs(sin(iTime + fbm(uv))))+base,1.);\n    fragColor = vec4((col)*(-1.)+base,1.);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdSW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsdSzr", "name": "Morph circle to square", "author": "Sophotec", "description": "Morph circle to square with simple formula sin(x)*cos(y) \nClick Mouse and move left and right", "tags": ["circle", "pattern"], "likes": 4, "viewed": 163, "date": "1571421664", "time_retrieved": "2024-06-20T19:47:42.181159", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) /iResolution.y;\n    vec4 m = iMouse / iResolution.x;\n    uv *= 16.;\n\n    float t=mod(iTime *.4,2.)-1.;\n    \n    float c = sin(uv.x) * cos(uv.y);  //Basis of effect\n\t\n\tvec3 col = vec3(0.0);\n\n\tif( m.z>0.0 ) {\n        c= smoothstep(0.,16./iResolution.y, c - (m.x -.5)*2. );\n\t} \n    else  {\n        c= smoothstep(0.,16./iResolution.y, c - t );\n    }\n    fragColor = vec4(c,c*.6,c*.3,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsdSzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsdXR4", "name": "Autumn leaves 1", "author": "pik33", "description": "Using more complex iteration function gave  a nice leaves pattern", "tags": ["plasma", "colors"], "likes": 1, "viewed": 97, "date": "1571589239", "time_retrieved": "2024-06-20T19:47:42.181159", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\t\n\tfor(float i=1.;i<9.;i+=1.)\n\t{\n       p+= 0.5/i * sqrt(abs(cos(i*p.yx+0.3*iTime+vec2(.03*i,.03*i))));\n\t}\n\tfragColor=vec4(1.5*fract(1.5*p.x)-0.5,1.5*fract(1.5*p.y)-0.5,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsdXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdXR8", "name": "ray marching Cube", "author": "kass", "description": "Simple TestCode", "tags": ["raymarching"], "likes": 1, "viewed": 335, "date": "1571474572", "time_retrieved": "2024-06-20T19:47:42.617479", "image_code": "const vec3 lightDir = vec3(-0.577, 0.577, 0.577);\nconst int accuracy = 16;\n\nvec3 trans(vec3 p){\n    // return p;\n    return mod(p, 4.0) - 2.0;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat distanceCube(vec3 p){\n    // p = rotate(p,iTime,vec3(0.0,0.0,1.0));\n\tvec3 e = trans(p);\n    // e = rotate(e,iTime,vec3(0.0,0.0,1.0));\n    \n    vec3 q = abs(e);\n    vec3 cube = vec3(1.5,1.2,0.5);\n    \n    return length(max(q - cube, 0.0));\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        distanceCube(p + vec3(  d, 0.0, 0.0)) - distanceCube(p + vec3( -d, 0.0, 0.0)),\n        distanceCube(p + vec3(0.0,   d, 0.0)) - distanceCube(p + vec3(0.0,  -d, 0.0)),\n        distanceCube(p + vec3(0.0, 0.0,   d)) - distanceCube(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy) / min(iResolution.x,iResolution.y);\n\n    // camera\n    vec3 cPos = vec3(0.0,  0.0,  2.0);\n    vec3 cDir = vec3(0.0,  0.0, -1.0);\n    vec3 cUp  = vec3(0.0,  1.0,  0.0);\n    vec3 cSide = cross(cDir, cUp);\n\tfloat targetDepth = 1.2;     \n    \n    cPos.z = cPos.z - iTime;\n    \n    vec3 ray = normalize(cSide * uv.x + cUp * uv.y + cDir * targetDepth);\n    \n    // marching loop\n    float distance = 0.0;\n    float rLen = 0.0;\n    vec3  rPos = cPos;\n    for(int i = 0; i < accuracy; i++){\n        distance = distanceCube(rPos);\n        rLen += distance;\n        rPos = cPos + ray * rLen;\n    }\n    \n    // Output to screen\n    if(abs(distance) < 0.001){\n        vec3 normal = getNormal(rPos);\n        float diff = clamp(dot(lightDir, normal), 0.5, 1.0);\n        fragColor = vec4(vec3(diff), 1.0);\n    }else{\n        fragColor = vec4(vec3(0.2),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdXR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsdXRM", "name": "Lollipop Patterns", "author": "96logda", "description": "I made the borders by using techniques from the shapes chapter in \"The Book of Shaders\".\nWhen I had the borders in place I got the idea to make something interesting inside the borders.", "tags": ["2d", "colors", "pattern", "borders", "lollipop"], "likes": 0, "viewed": 70, "date": "1571684221", "time_retrieved": "2024-06-20T19:47:42.617479", "image_code": "//Based on code and formulas from The Book of Shaders:\n//https://thebookofshaders.com/07/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    vec2 borders1   = step(vec2(0.1), st);\n    vec2 borders2   = step(vec2(0.1), 1.0 - st);\n    float pct = borders1.x * borders1.y * borders2.x * borders2.y;\n    \n    if (pct == 1.0)\n    {\n        vec2 st2 = st * 2.0 - 1.0;\n        float d = length(max(abs(st2) - 0.7, 0.0) );\n        color += vec3(fract(d * 15.0));\n\n        vec2 pos = vec2(0.5) - st;\n        float a = atan(pos.y, pos.x) * 2.0;\n\n        color += vec3(cos(a), sin(a * iTime * 0.1), sin(iTime * 0.1));\n    }\n    else\n    {\n    \tcolor = vec3(pct);\n    }\n    \n    fragColor = vec4(pow(color, vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsdXRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsdXRS", "name": "raymarching / sphere tracing tut", "author": "littlemilk", "description": "raymarching tutorial", "tags": ["raymarching"], "likes": 1, "viewed": 105, "date": "1572357679", "time_retrieved": "2024-06-20T19:47:42.617479", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 100.0\n#define SURF_DIST 0.0001\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0.0, 1.0, 6.0, 1.0);\n\ts.y += sin(iTime);\n    \n    float sphereDist = length(p - s.xyz) - s.w;\n    float planeDist = p.y;\n    \n    float d = smin(sphereDist, planeDist, 0.8);\n    return d;\n\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        \n        if (dO > MAX_DIST || dS < SURF_DIST) {\n            break;\n        }\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n    \tGetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p) {\n\tvec3 lightPos = vec3(0.0, 5.0, 6.0);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n        \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0.0, 1.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n\n    fragColor.rgb = col;\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsdXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsdXW7", "name": "Pulsing heart", "author": "adrenoide", "description": "Parametric coordinates provide an elegant way to draw a heart-shaped 2d curve", "tags": ["heart", "curve", "polar", "coordinates"], "likes": 1, "viewed": 249, "date": "1572171838", "time_retrieved": "2024-06-20T19:47:42.617479", "image_code": "const float pi = 4. * atan(1.);\n\nfloat phi(float x) {\n\tfloat s = sin(pi * x);\n    return s*s;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 p = U / iResolution.x;\n    \n    p -= vec2 (0.5, 0.3);\n    p *= 8.;\n    \n    vec2 pm = iMouse.xy / iResolution.x;\n    \n    // heart-shaped polar curve :\n    // x = sin^3(t)\n    // y = cos(t) - cos^4(t)\n\n    float sc = 2.;\n    int nb_pts = 50;\n    float dt = 2. * pi / float (nb_pts);\n    \n    O = vec4(0.);\n    \n    for (int k=0; k < nb_pts; k++) {\n        float t = sc * (iTime + float(k) * dt);\n        float c = cos(t), s = sin(t);\n        vec2 m = (1. + phi(0.7 * iTime) / 2.) * vec2(1.5 * s*s*s, 0.5 + c - c*c*c*c);\n        float e = smoothstep (.1, .0, length(p-m));\n\n        // blending between red and blue suggests that\n        // blood's color depends on whether it enters or\n        // exits the heart.\n        \n        O += vec4(mix (vec3(e, 0., 0.), vec3(0., 0., e), (1. + s) / 2.), 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsdXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdXWM", "name": "Temporal Golden Noise Demo", "author": "Bapho", "description": "This is a temporal golden noise/grain shader created for demonstration purposes.\nIt obviously has a disadvantage: the noise pattern is always changing, even when the color of the position is not changing.", "tags": ["noise", "goldenratio", "grain", "golden", "goldennoise"], "likes": 2, "viewed": 248, "date": "1572182804", "time_retrieved": "2024-06-20T19:47:43.023582", "image_code": "//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Temporal Golden Noise Demo by Bapho\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nfloat noise = 2.0;\n\n//----------------------------------------------------------------------\nprecision lowp float;\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\n\nfloat gold_noise(in vec2 coordinate, in float seed){\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouse;\n    if (iMouse.x <= 0.0 || iMouse.x >= iResolution.x){\n\t\tmouse = iResolution.x / 2.0;\n    } else {\n        mouse = iMouse.x;\n    }\n                             \n    if (mouse > fragCoord.x - 4.0 && mouse < fragCoord.x + 4.0){\n        fragColor = vec4(0.4, 0.0, 0.0, 1.0);\n    } else {\n\n        vec2 uv = fragCoord/iResolution.xy;\n\n        vec3 color;\n        if (fragCoord.x < iResolution.x * 0.05\n            || fragCoord.x > iResolution.x * 0.95){\n            color = vec3(0.0);\n            \n        } else if (fragCoord.y < iResolution.y * 0.15){\n        \tcolor = texture(iChannel1, uv).rgb;\n            \n        } else if (fragCoord.y < iResolution.y * 0.85){\n            color = texture(iChannel0, uv).rgb;\n            \n        } else {\n            color = 0.5 + 0.25*cos(iTime*0.5+uv.xyx+vec3(0,4,8));\n            //color = vec3(0.0, 0.8, 0.2);\n        }\n\n        if ((mouse <= 0.0 && fragCoord.x < iResolution.x / 2.0) \n\t\t\t\t|| mouse > fragCoord.x){\n            \n            float uniquePos = (iResolution.x * fragCoord.y) + fragCoord.x;\n            float amount = noise * 0.08;\n            \n            // a very low unique seed will lead to slow noise\n            // pattern changes on slow moving color gradients\n            float uniqueSeed = uniquePos * 0.000000001 * iTime;\n            \n            // using a fictive coordinate as a workaround to fix a pattern bug\n\t\t\tvec2 coordinate = vec2(fragCoord.x, fragCoord.y * 1.001253543);\n            \n            // average noise luminance to subtract\n            float sub = (0.5 * amount);\n\n            // calculating and adding/subtracting the golden noise\n            float ran = gold_noise(coordinate, uniqueSeed);\n            float add = clamp(ran * amount, 0.0, 1.0);\n            color += (add - sub);\n        }\n\n        fragColor = vec4(color, 1.0);\n    }\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdXWn", "name": "fold color", "author": "novogrammer", "description": "fold color", "tags": ["fold"], "likes": 1, "viewed": 61, "date": "1571809517", "time_retrieved": "2024-06-20T19:47:43.029646", "image_code": "\nfloat circle(vec2 positionFragment,vec2 positionObject,float radius){\n    return length(positionFragment-positionObject) - radius;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //from -1 to 1\n    vec2 pos=( 2.*fragCoord - iResolution.xy )/iResolution.y;\n    vec3 col=vec3(0.);\n    for(int i=0;i<9;i+=1){\n        float r=radians(float(i+1)*360.*iTime*.1);\n        vec2 circlePosition=vec2(cos(r),sin(r))*.5;\n        //red or green or blue\n        col[i%3]+=step(0.,-circle(pos,circlePosition,0.5));\n    }\n    \n    //repeat\n    col=mod(col,2.0);\n    //fold\n    col=1.0-abs(1.0-col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdXWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsdXzr", "name": "Vortex in a wave function", "author": "michael0884", "description": "Explaining wyatt why you can have vortices even though the velocity is the gradient of the phase\nAt the discontinuities the gradient is infinite, but we take the 2*pi periodicity into account, so we can make the gradient continuous - and it is a vortex!\n\n", "tags": ["schrodinger"], "likes": 1, "viewed": 151, "date": "1571336832", "time_retrieved": "2024-06-20T19:47:43.296372", "image_code": "float phase(vec2 pos)\n{\n    //number of windings, essentially the velocity\n    float n = 5.; //necessarily integer for the wave function to be continuous, thus vorticity is quantized\n\treturn n*( 0.5*iTime + atan(pos.x, pos.y));\n}\n\nvec2 vortex_psi(vec2 pos)\n{   \n    //it is zero at pos = 0, so it is continuos, even if atan(pos.x, pos.y) aka the phase is not\n    return 0.5*length(pos)*vec2(sin(phase(pos)), cos(phase(pos)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(mod(iTime,4.) < 2.)\n    {\n        //the wave function\n        vec2 psi = vortex_psi(4.*(uv - vec2(0.5)));\n\n        vec2 red = vec2(1,0), green = vec2(-0.5,sqrt(3.)*0.5), blue = vec2(-0.5,-sqrt(3.)*0.5);\n\n        vec3 RGB =  (0.5 + vec3(dot(psi, red),dot(psi, green),dot(psi, blue)))/1.5;\n        // Output to screen\n        fragColor = vec4(RGB*pow(abs(RGB),vec3(0.2)),1.0);\n    }\n    else\n    {\n         //the phase\n         float phase = mod(phase(4.*(uv - vec2(0.5))),2.*3.14159); //it is periodic\n          // Output to screen\n         fragColor = vec4(vec3(phase)/(2.*3.14159),1.0);\n    }\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsdXzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsG3Dt", "name": "Shadertober 15 Legend", "author": "GreenChicken", "description": "I played to much Zelda Botw", "tags": ["raymarching", "zelda", "inktober"], "likes": 6, "viewed": 281, "date": "1571156792", "time_retrieved": "2024-06-20T19:47:43.296372", "image_code": "// SHADERTOBER 15 Legend\n// Poulet vert 15-10-2019\n// used iq menger spone code for fractal crap in the background\n\n#define PI 3.14159\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, float s )\n{\n  vec3 q = abs(p) - vec3(s);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCross( vec3 p )\n{\n  float da = sdBox(p.xyz, vec3(3.,1.0,1.0));\n  float db = sdBox(p.yzx, vec3(1.0,3.,1.0));\n  float dc = sdBox(p.zxy, vec3(1.0,1.0,3.));\n  return min(da,min(db,dc));\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n// Scene setup\n\nvec2 map(vec3 pos)\n{\n\n    vec2 t = vec2(pos.y, 0.0);\n    \n    vec3 cp = pos + vec3(0.0, -1.0, 0.0);\n    cp = opRep(cp, vec3(1.0));\n    float c = sdBox(cp, vec3(1.0));\n    \n    float s = 1.0;\n    for(int m=0; m<3; m++)\n    {\n        vec3 p = pos + vec3(0.0, iTime, 0.0);\n        vec3 a = mod(p*s, 2.0)-1.0;\n        s*= 3.1;\n        vec3 r = 1.0 - 3.0 * abs(a);\n        \n        float cro = sdCross(r)/s;\n        \n        c = max(c, -cro);\n    }\n    \n    float subBox = sdBox(pos+vec3(0.0, -1.2, 0.0), .5);\n    c = max(c, -subBox);\n    \n    vec2 shape = vec2(c, 1.0);\n    \n    vec3 trip = pos + vec3(0.21, -1.0, 0.0);\n    float tri = sdTriPrism(trip, vec2(.25, .1));\n    trip = pos + vec3(-0.21, -1.0, 0.0);\n    tri = opU(tri, sdTriPrism(trip, vec2(.25, .1)));\n    trip = pos + vec3(-0.0, -1.37, 0.0);\n    tri = opU(tri, sdTriPrism(trip, vec2(.25, .1)));\n    \n    t = shape;\n    t = opU2(t, vec2(tri, 2.0));\n    \n    return t;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(float(i)/128., ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(.0); \n        \n    }\n    else\n    {\n        float depth = 1.0 - t.x;\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(depth*.2);\n        }\n        else if(t.y == 1.0)\n        {\n            col = vec3(1.0, 1.0, 1.0) * depth * .5;\n        }\n        else if(t.y == 2.0)\n        {\n            col = vec3(1.0, .8, 0.0) * depth;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 1.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime * .5;\n    \n    vec3 cp = vec3(sin(time), 1.5, cos(time));\n    vec3 ct = vec3(0.0, 1.2, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = Render(cp, vd, screenUV);\n    \n    // compo\n    \n    col.rg -= screenUV.y * .5 * length(uv);\n    col -= random(uv)*.1* length(uv) * .4;\n    \n    col = clamp(col, 0.0, 1.0);\n    col *= 1.0-length(uv)*.5;\n    \n    col = sqrt(clamp(col, 0.0, 1.0)) * 1.2;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4tf3WX", "previewfilepath": "https://soundcloud.com/zelda-soundtracks/sets/legend-of-zelda-nes", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/zelda-soundtracks/sets/legend-of-zelda-nes", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsG3Dt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsG3RV", "name": "int tunnel", "author": "ddl_blue", "description": "MI-SOC", "tags": ["tunnel"], "likes": 0, "viewed": 36, "date": "1570553481", "time_retrieved": "2024-06-20T19:47:43.296372", "image_code": "#define MUL 2048.0\n#define iMUL 2048\n\n#define DETAIL 2\n\nint intSin(int x){\n\treturn int(sin(float(x)/MUL)*MUL); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n    // Output to screen\n    fragColor = vec4(0.0, 0.0, 0.0 ,1.0);\n    /***************************************************************************/\n    int posX  = 0;\n    int posY  = 0;\n    int posZ  = int(iTime*3000.0);\n    \n    int dirX = int(uv.x*MUL)/(2*DETAIL);\n    int dirY = int(uv.y*MUL)/(2*DETAIL);\n    int dirZ = iMUL/(2*DETAIL);\n    \n    bool ignore = false;\n\n    for (int i=0; i<25*DETAIL; ++i){\n        if (!ignore){\n            int rawDist = posX*posX + posY*posY;\n            int dist = rawDist + intSin(posX*posY/256 + posZ)*512;\n            \n            if (dist > iMUL*iMUL){\n            \tignore = true;\n\t\t\t\tint div = (posZ-int(iTime*3000.0))/25; \n                \n                int cg = (dist-rawDist)/iMUL*2;\n                int cb = abs(intSin(posZ));\n                int cr = (cb+cg)/2;\n                \n                fragColor = vec4(float(cr-div)/MUL,float(cg-div)/MUL,float(cb-div)/MUL, 1.0);\n            }\n            posX += dirX;\n            posY += dirY;\n            posZ += dirZ;\n        }\t\n    }  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsG3RV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsG3Ry", "name": "Shadertober 06b - Husky", "author": "BackwardsCap", "description": "Now I am craving some corn", "tags": ["corn", "inktober", "shadertober", "husky", "backwardscaptain", "cineshader"], "likes": 9, "viewed": 9116, "date": "1570421433", "time_retrieved": "2024-06-20T19:47:44.048063", "image_code": "#define MAX_DIST 50.0\n#define PI 3.1415927\n\n//as always, thanks to IQ for sharing this knowledge :)\n\nvec2 rotate(vec2 a, float d){\n    float s  = sin(d);\n    float c = cos(d);\n    \n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c);\n}\n\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0));\n}\n\nfloat husk(vec3 bp, vec3 p)\n{\n    \n    return box(bp-vec3(0.,-2.,-4),vec3(10,3.+cos(p.x+p.z+p.y)/4.+bp.x/2.,.1));\n}\n\n\nvec2 map(vec3 p)\n{\n    p.x-=.5;\n    vec3 bp = p+vec3(-4.,0.,0);\n    \n    bp.yz=rotate(bp.yz,PI*iTime/2.);\n    \n    bp.x+=((bp.y*bp.y)+(bp.z*bp.z))/8.;\n    float b = box(bp,vec3(.1,2,2));\n    \n    bp.yz=rotate(bp.yz,PI/4.);\n    \n    b = min(b,box(bp,vec3(.1,2,2)));\n    \n    \n    float stem = box(bp+vec3(.5,0,0),vec3(1.,.5,.5));\n    \n    vec2 st = vec2(atan(p.z,p.y), length(p));\n    \n    float x = clamp(.5+(p.x+4.5)/10.,0.0,1.0);\n    float c=length(p/vec3(2.5-p.x/10.,1.,1.))-2.+(smoothstep(1.,-1.,abs(cos(iTime*10.+p.x*10.+.6)))/10.*x)+\n        (smoothstep(1.,-1.,abs(cos(st.x*10.)))/10.)*x;\n    \n    float r=min(c,b);\n    r=min(r,stem);\n    \n    float m=0.0;\n\n    if(r==c)m=1.;\n    else if(r==b||r==stem)m=2.;\n    \n    \n    return vec2(r,m);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0001,0.);\n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n    ));\n    \n}\n\nvec2 ray(vec3 ro, vec3 rd)\n{\n    float t =0.0;\n    float m = 0.0;\n    \n    for(int i=0;i<128;i++)\n    {\n        \n        vec3 p=ro+rd*t;\n        vec2 h=map(p);\n        m=h.y;\n        if(h.x<0.00001)break;\n        t+=h.x;\n        if(t>MAX_DIST)break;\n    }\n    \n    if(t>MAX_DIST)t=-1.;\n    \n    return vec2(t,m);\n}\n \nvec3 color(vec3 p, vec3 n, vec2 t)\n{\n    vec3 c = vec3(0.);\n    vec3 mate = vec3(1.32,1,0);\n    if(t.y>1.5)\n    {\n        mate=vec3(0.,.125,0.);\n    }\n    vec3 sun=normalize(vec3(0.2,0.5,-0.5));\n    float dif=clamp(dot(n,sun),0.0,1.0);\n    float sha = step(ray(p+n*.001,sun).x,0.0);\n    float sky = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.,1.);\n    float bou = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.,1.);\n    \n    c=mate*vec3(0.5,0.6,0.5)*dif*sha;\n    c+=mate*vec3(0.2,0.3,.8)*sky;\n    c+=mate*vec3(0.2,0.1,0.1)*bou;\n    \n    return c;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{    \n    vec2 st = vec2(atan(rd.y,rd.x), length(ro));\n        \n\tvec3 c = vec3(0.,.1,0.)*(.5+smoothstep(-0.,1.,cos(st.x*40.+iTime*3.)));\n    \n    vec2 t = ray(ro,rd);\n\n    if(t.x>0.)\n    {\n        vec3 p = ro+rd*t.x;\n        vec3 n=normal(p);\n        \n        c=color(p,n,t);\n        \n    }\n   \tc=pow(c,vec3(0.454545));\n    \n    return c;\n}\n    \n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.y;\n\n    float d = 10.;\n    vec3 ro = vec3(sin(PI)*d,0,cos(PI)*d);\n    vec3 ta = vec3(0.,0,0.);\n    vec3 camF =\tnormalize(ta-ro);\n    vec3 camU = normalize(cross(camF,vec3(0,1,0)));\n    vec3 camR = normalize(cross(camU,camF));\n    \n    vec3 rd = normalize(uv.x*camU+uv.y*camR+2.*camF);\n    \n    c.rgb=render(ro,rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsG3Ry.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsG3W1", "name": "大龙猫 - Quicky#014", "author": "totetmatt", "description": " 大龙猫 - Quicky#014", "tags": ["quicky", "shadertober"], "likes": 2, "viewed": 296, "date": "1570050195", "time_retrieved": "2024-06-20T19:47:44.054129", "image_code": "float hash(vec2 p) {\n    p = fract(p*vec2(222.910,317.54));\n    p += dot(p.yx,p+325.21);\n    return fract(p.x * p.y);\n}\nmat2 r(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat shape(vec2 uv,float factor) {\n    return smoothstep(0.551,0.5,sin(floor(factor*iTime*8.)+length(log(1.+abs(uv)*100.))));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if( .5+abs(uv.y ) > .8 ) uv = fract(uv*10.+vec2(sign(uv.y)*iTime,0.))-.5;\n    uv*=r(floor(iTime*4.));\n   float d = mix(shape(uv,1.),shape(uv,-1.1),0.5);\n    vec3 col =  vec3(d*vec3(.5+cos(floor(iTime)*2.)/2.,hash(floor(uv))*.3+sin(floor(-iTime)*4.)/2.,.4+sin(floor(iTime)*8.)/2.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsG3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsG3z3", "name": "draw triangle 2", "author": "FabriceNeyret2", "description": "note that the full SDF distance would be more complicated.", "tags": ["triangle", "distance"], "likes": 3, "viewed": 467, "date": "1570635350", "time_retrieved": "2024-06-20T19:47:44.290261", "image_code": "vec2 R;\n\n#define S(d) smoothstep( 1., -1., d*R.y)                   // antialiased draw\nfloat cross2(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }  // 2D cross product (so stupid built-in is only for vec3 )\n\n#if 0 // variant 1\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c) {           // --- draw triangle \n    if ( cross2(c-a,b-a) < 0. ) { vec2 t=b; b=a; a=t; }    // make triangle direct\n    float d  = cross2(p-a,b-a)/length(b-a);\n    d = min(d, cross2(p-b,c-b)/length(c-b) );\n    d = min(d, cross2(p-c,a-c)/length(a-c) );              // inside distance to closest border\n    return S(-d);                                          // draw \n}\n\n#else // variant 2\n\n#define B(p,a,b) S(-cross2( p-a, normalize(b-a) ) )\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c) {           // --- draw triangle \n    if ( cross2(c-a,b-a) < 0. ) { vec2 t=b; b=a; a=t; }    // make triangle direct\n    return   B(p,a,b) * B(p,b,c) * B(p,c,a);               // combines 3 half-planes\n}\n\n#endif\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    R = iResolution.xy;\n    vec2 U = u/R.y;\n    float t = iTime+5.;\n    O += triangle(U, vec2(.1),vec2(.8,.6)+.4*vec2(cos(t),sin(t)), vec2(1.3,.9));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsG3z3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsG3zd", "name": "Flight through a nebula v2", "author": "Delvar", "description": "Simple fly though of a 3d simplex via ray marching.", "tags": ["noise", "raymarch", "cloud", "simplex", "nebula"], "likes": 2, "viewed": 160, "date": "1570797293", "time_retrieved": "2024-06-20T19:47:45.199508", "image_code": "// also see \n// voronoi  version, https://www.shadertoy.com/view/tdyGzK\n// simplex version, https://www.shadertoy.com/view/WsG3zd\n// box version, https://www.shadertoy.com/view/tsK3Rd\n// simplex function taken from https://www.shadertoy.com/view/XsX3zB\n\n\n#define RAY_MAX_STEPS 100\n#define RAY_MAX_DISTANCE 10.0\n#define RAY_CAMERA_FADE_START_DISTANCE 0.5\n#define RAY_CAMERA_FADE_END_DISTANCE 2.0\n#define RAY_MAX_STEPS_SHADOW 15\n\n#define K\t0.1428571428571429\t// 1/7\n#define Ko\t0.3571428571428571\t// 1/2-(K/2)\n#define K2\t0.0204081632653061\t// 1/(7*7)\n#define Kz\t0.1666666666666667\t// 1/6\n#define Kzo\t0.4166666666666667\t// 1/2-(1/(6*2))\n#define Km\t0.0034602076124567\t// 1/289\n#define PI\t3.1415926535897932384626433832795\n    \nstruct camera {\n   vec3 origin, forward, right, up;\n   float zoom; // Distance from screen\n};\n\nstruct ray {\n   vec3 origin, direction;\n};\n       \ncamera getCameraDirection(vec3 origin, vec3 direction, float zoom) {\n   camera camera;\n   camera.origin = origin;\n   camera.forward = normalize(direction);\n   camera.right = cross(vec3(0.0,1.0,0.0), camera.forward);\n   camera.up = cross(camera.forward, camera.right);\n   camera.zoom = zoom;\n   return camera;\n}\n\nray getRay(vec2 uv, camera camera) {\n\tray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n\treturn ray;   \n}\n\nfloat mod289(float x) {\n\treturn x - floor(x * Km) * 289.0;\n}\n\nfloat mod7(float x) {\n\t//return x;\n\treturn x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n//Wrap around for id generation\nfloat wrap(float x) {\n\t//return mod((34.0 * x + 1.0) * x, 289.0);\n    return mod289((34.0 * x + 1.0) * x);\n}\n\n// --------------------------------------------------\n//from https://www.shadertoy.com/view/XsX3zB\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\n#define F3 0.333333\n#define G3 0.1666667\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n// --------------------------------------------------\n\nvec3 RayMarch(ray ray, float maxDistance, int maxSteps)\n{\n    float maxStepsf = float(maxSteps);\n    float stepSize = maxDistance/maxStepsf;\n    vec3 total = vec3(0.0);\n    \n    // Stop the shimmering??\n    //float currentDistance = stepSize-(ray.origin.z-(floor(ray.origin.z/stepSize)*stepSize));\n    float currentDistance = 1.0;\n    \n    float strike = 1.0+smoothstep(0.5,1.0,sin(ray.direction.z+iTime*20.0)*sin(ray.direction.x +iTime*30.0)*cos(ray.direction.y +iTime*40.0)*(wrap(iTime)/289.0));\n    \n    for(float i=0.0; i<maxStepsf; i++) {\n\t\tvec3 currentPoint = ray.origin + ray.direction * currentDistance;\n        \n        float s = (1.0-abs(simplex3d(currentPoint)));\n        s=s*s*s;\n        s=smoothstep(0.1,2.0, s);\n        \n        float stepf = ((maxStepsf - i)/maxStepsf);\n        s *= stepf;\n        vec3 light = sin((currentPoint+vec3(iTime/10.0,iTime/13.0,iTime/15.0))/4.0)*0.5+1.0; //Yes we blow out the colour a little.\n        total += light*s;\n        currentDistance += stepSize;\n    }\n    return (total*(3.0/maxStepsf))*strike;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n    //Snap to center on startup.\n    if(iMouse.x <= 1.0 && iMouse.y <= 1.0) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    // -- 1st person cammera\n    vec3 forward = vec3(\n        sin(mouse.x*PI),\n    \tsin(mouse.y*PI),\n    \tcos(mouse.x*PI)\n    );\n    camera camera = getCameraDirection(vec3(0.0,0.0,iTime), forward, 0.5);\n    \n    ray ray = getRay(uv, camera);\n\tvec3 colour = RayMarch(ray, RAY_MAX_DISTANCE, RAY_MAX_STEPS);\n    float gamma = 0.8;\n    colour = pow(colour, vec3(1.0/gamma));\n    \n    fragColor = vec4(colour,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsG3zd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGGDd", "name": "fractal ying yang", "author": "Jarazz", "description": "Saw something like this on reddit that was 2 ying yangs stacked, abstracted it for n layers of ying yang \nif you want to control how many iterations to see: https://www.shadertoy.com/view/wsG3Dt", "tags": ["yingyangfractalkifs"], "likes": 7, "viewed": 418, "date": "1571169830", "time_retrieved": "2024-06-20T19:47:45.545130", "image_code": "#define PI 3.14159\n#define t iTime*PI/4.\n \nvec2 cartesian2polar(vec2 cartesian){\n\treturn vec2(atan(cartesian.x,cartesian.y),length(cartesian.xy));\n}\n\nvec2 polar2cartesian(vec2 polar){\n\treturn polar.y*vec2(cos(polar.x),sin(polar.x));\n}\n\nvec2 rotate2D(vec2 coords, float amount){\n\treturn polar2cartesian(cartesian2polar(coords)+vec2(amount,0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv = rotate2D(uv, t);\n \n    vec3 col = vec3(.3);\n    \n    int iterationID = 0; \n    float iterations =  max(2. + (-4.*cos(t/2.)-PI/2.),0.);\t\t//how many layers, you can manually just enter 5.0 or 20.0 and see what happens\n   \tfloat circleRadius = .25;\n    \n    for(int i = 0; i< int(iterations); i++){               //loop for KIFS fractal, keep transforming the uvs inside the inner circles into the uv of the whole circle\n \tfloat distToInner = length(abs(uv)-vec2(0,circleRadius));\n    \tif(distToInner<circleRadius){\t\t\t//inner circle\n       \tuv.y = (uv.y>=0.)?(uv.y-circleRadius):(uv.y+circleRadius);\n        uv*=2.;\n        iterationID++;\n    \tuv = rotate2D(uv,-PI/2. + t * float(iterationID)  );\n       \t}\n   \t\n    }\n     \n \tfloat distToInner = length(abs(uv)-vec2(0,circleRadius));\n    \tif(distToInner<circleRadius*fract(iterations) ){\t\t\t//inner circle\n       \tuv.y = (uv.y>=0.)?(uv.y-circleRadius):(uv.y+circleRadius);\n        uv*=2.;\n        iterationID++;\n    \tuv = rotate2D(uv,-PI/2. +  t * float(iterationID)  );\n       \t}\n    \n    if(length(uv)<.5){\n    col = vec3(step(0.,uv.x));\n        \n        float distToInner = length(abs(uv)-vec2(0,.25));\n    \tif(distToInner<circleRadius){\t\t\t//inner circle\n        \tcol = vec3(step(0.,uv.y) ); \n           \n            if(distToInner>circleRadius/2.){ \t//final most inner circle/iris\n        \t\t col = vec3( -col.x +1.); \n            }\n    \t} \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGGDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsGGDm", "name": "grass generator", "author": "gorilla", "description": "草をフラクタル構造とみなせることに気づいたので。", "tags": ["practice"], "likes": 5, "viewed": 357, "date": "1570297961", "time_retrieved": "2024-06-20T19:47:45.545130", "image_code": "vec4 grass = vec4(0.464f,0.683f,0.601f,1.0f);\n\nvoid drawSquare(in vec2 amin, in vec2 amax, in vec2 fragCoord, inout vec4 fragColor)\n{\n    if (amin.x <= fragCoord.x && fragCoord.x <= amax.x) {\n    \tif (amin.y <= fragCoord.y && fragCoord.y <= amax.y) {\n        \tfragColor = grass;  \n    \t}\n    }\n}\n\nvoid drawGrass(in vec2 offset, in float scale, inout vec4 fragColor, in vec2 fragCoord)\n{\n    offset.y += iResolution.y - 228.0f;\n    vec2 min1 = (vec2(0.0f,50.0f))*scale + offset;\n    vec2 max1 = (vec2(130.0f,60.0f))*scale + offset;\n\tdrawSquare(min1, max1, fragCoord, fragColor);\n\n    vec2 min2 = (vec2(65.0f,10.0f))*scale + offset;\n    vec2 max2 = (vec2(75.0f,80.0f))*scale + offset;\n\tdrawSquare(min2, max2, fragCoord, fragColor);\n\n    vec2 min3 = (vec2(20.0f,80.0f))*scale + offset;\n    vec2 max3 = (vec2(120.0f,90.0f))*scale + offset;\n\tdrawSquare(min3, max3, fragCoord, fragColor);\n\n    vec2 min4 = (vec2(20.0f,100.0f))*scale + offset;\n    vec2 max4 = (vec2(120.0f,110.0f))*scale + offset;\n\tdrawSquare(min4, max4, fragCoord, fragColor);\n\n    vec2 min5 = (vec2(20.0f,120.0f))*scale + offset;\n    vec2 max5 = (vec2(120.0f,130.0f))*scale + offset;\n\tdrawSquare(min5, max5, fragCoord, fragColor);\n\n    vec2 min6 = (vec2(20.0f,80.0f))*scale + offset;\n    vec2 max6 = (vec2(30.0f,130.0f))*scale + offset;\n\tdrawSquare(min6, max6, fragCoord, fragColor);\n\n    vec2 min7 = (vec2(110.0f,80.0f))*scale + offset;\n    vec2 max7 = (vec2(120.0f,130.0f))*scale + offset;\n\tdrawSquare(min7, max7, fragCoord, fragColor);\n\n    vec2 min8 = (vec2(110.0f,80.0f))*scale + offset;\n    vec2 max8 = (vec2(120.0f,130.0f))*scale + offset;\n\tdrawSquare(min8, max8, fragCoord, fragColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.772f, 0.913f, 0.607f,1.0f);\n    float loop = mod(float(iFrame),29.0f)/30.0f; // 0.0167f ~ 1.0f\n    //loop += 0.0167f;\n\n    loop = pow(loop, 1.216f);\n    loop = 1.0f - loop;\n    for (int i = 0; i < 3; ++i) {\n\t    drawGrass(vec2(1920.0f*float(i)-(1920.0f*loop/2.0f)*float(i), -1920.0f*(1.0f-loop)-1680.0f),\n                  16.0f-loop*8.0f, fragColor, fragCoord);\n    }\n    for (int i = 0; i < 5; ++i) {\n\t    drawGrass(vec2(960.0f*float(i)-(960.0f*loop/2.0f)*float(i), -960.0f*(1.0f-loop)-720.0f),\n                  8.0f-loop*4.0f, fragColor, fragCoord);\n    }\n    for (int i = 0; i < 10; ++i) {\n\t    drawGrass(vec2(480.0f*float(i)-(480.0f*loop/2.0f)*float(i), -480.0f*(1.0f-loop)-240.0f),\n                  4.0f-loop*2.0f, fragColor, fragCoord);\n    }\n    for (int i = 0; i < 20; ++i) {\n\t    drawGrass(vec2(240.0f*float(i)-(240.0f*loop/2.0f)*float(i), -240.0f*(1.0f-loop)),\n                  2.0f-loop, fragColor, fragCoord);\n    }\n    for (int i = 0; i < 40; ++i) {\n\t    drawGrass(vec2(120.0f*float(i)-(120.0f*loop/2.0f)*float(i), 120.0f*loop),\n                  1.0f-loop/2.0f, fragColor, fragCoord);\n    }\n    for (int i = 0; i < 80; ++i) {\n\t    drawGrass(vec2(60.0f*float(i)-(60.0f*loop/2.0f)*float(i), 120.0f+120.0f*loop/2.0f),\n                  (1.0f-loop/2.0f)/2.0f, fragColor, fragCoord);\n    }\n    \n    if (fragCoord.y < iResolution.y-50.0f)\n        return;\n    for (int i = 0; i < 160; ++i) {\n        \n\t    drawGrass(vec2(30.0f*float(i)-(30.0f*loop/2.0f)*float(i), 180.0f+60.0f*loop/2.0f),\n                  (1.0f-loop/2.0f)/4.0f, fragColor, fragCoord);\n    }\n    for (int i = 0; i < 320; ++i) {\n        \n\t    drawGrass(vec2(15.0f*float(i)-(15.0f*loop/2.0f)*float(i), 210.0f+30.0f*loop/2.0f),\n                  (1.0f-loop/2.0f)/8.0f, fragColor, fragCoord);\n    }\n}    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsGGDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsGGDz", "name": "wrainbow", "author": "lucastakejame", "description": "i should be sleeping", "tags": ["2d", "lightdispersion"], "likes": 5, "viewed": 146, "date": "1569993433", "time_retrieved": "2024-06-20T19:47:45.733027", "image_code": "#define SIN(a) smoothstep(-4., 2.5, sin(a))\n#define SIN2(a) (SIN(a)*SIN(a))\n\nvec2 rot(vec2 p, float a)\n{\n    vec2 i = vec2(cos(a), sin(a));\n    return vec2(p.x*i.x - p.y*i.y, p.x*i.y + p.y*i.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    uv.x += .1*sin(uv.y*uv.x*40.);\n    \n    uv += rot(uv, length(uv+iTime));\n    \n    vec2 tuv = abs(log(-uv*.005 + 0.909));\n    \n    \n    float v = 1.01 -.0005;\n    // Time varying pixel color\n    vec3 col = vec3(\n    \tSIN2(20./pow(tuv.x,v*v*v)),\n    \tSIN2(20./pow(tuv.x,v*v)),\n    \tSIN2(20./pow(tuv.x,v))\n    )/length(tuv*7.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsGGDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsGGRt", "name": "some shapes", "author": "zrcoy", "description": "study making couple palm trees \nadd a ground\nadd a smile face to the sun\nadd jumping stars \nadd glowworm", "tags": ["image"], "likes": 1, "viewed": 538, "date": "1570724991", "time_retrieved": "2024-06-20T19:47:45.738965", "image_code": "float makeBand(float d, float start, float end, float blur)\n{\n    float band1 = smoothstep(start - blur, start + blur, d);\n    float band2 = smoothstep(end + blur, end - blur, d);\n    return band1*band2;\n}\n\nfloat makeRect(vec2 uv, float left, float right, float top, float bottom, float blur)\n{\n    float verticalBand = makeBand(uv.x ,left,right,blur );\n    float horizontalBand = makeBand(uv.y, bottom, top, blur);\n    return verticalBand * horizontalBand;\n}\n\nfloat makeDiamond(vec2 uv, float left, float right, float top, float bottom, float blur)\n{\n    float verticalBand = makeBand(uv.x +uv.y ,left,right,blur );\n    float horizontalBand = makeBand(uv.y - uv.x, bottom, top, blur);\n    return verticalBand * horizontalBand;\n}\n\nfloat makeCircle(vec2 xy, float r, vec2 p, float blur)\n{   \n\n    return (1.0f-smoothstep(r,  r*blur,length(p-xy)));\n    \n}\n \nfloat makeSmileMask(vec2 xy, vec2 p, float r, float blur)\n{\n    float mask = 0.0f,mask_mouth=0.0f,mask_leftEye=0.0f,mask_rightEye=0.0f;\n    //mask = makeCircle(xy,0.2f,vec2(0,0),1.1f);       \n    mask = makeCircle(xy,r,p,blur);\n    mask_leftEye = makeCircle(xy,0.12f*r,vec2(p.x - 1.0f/3.0f*r,p.y + 1.0f/3.0f*r),1.5f*blur);\n    mask_rightEye = makeCircle(xy,0.12f*r,vec2(p.x + 1.0f/3.0f*r,p.y + 1.0f/3.0f*r),1.5f*blur);\n    mask_mouth = makeCircle( xy , 0.8f * r , p , blur) - makeCircle(xy,0.75f*r,vec2(p.x,0.2f * r+p.y),blur);\n    mask -= (mask_leftEye + mask_rightEye + mask_mouth);\n    return mask;\n}\n\n\n\nvoid makePalmTreeWithGround(inout vec3 col, in vec2 xy,in vec2 dToTreeOrigin,in float leafNum,in float originCircleRadius, in float palmTreeLengthOffset, in float bendLeafOffset)\n{\n    \n \t//tree\n    float r = originCircleRadius + palmTreeLengthOffset * cos(atan(dToTreeOrigin.y,dToTreeOrigin.x) * leafNum + bendLeafOffset * dToTreeOrigin.x + 2.0f * sin(iTime));    \n    col *= smoothstep(r - 0.02f, r, length(dToTreeOrigin));\n    float branchEdgeWidth =  0.03f;\n    //wave edge on the branch\n    branchEdgeWidth += 0.01f + 0.0055f * cos(10.0f * dToTreeOrigin.y * 10.0f);\n    //the ground\n    branchEdgeWidth += 0.000001f * exp(-12.0f * dToTreeOrigin.y);\n    //cut down upper part of the branch\n    col *= 1.0f - (1.0f - smoothstep(branchEdgeWidth,branchEdgeWidth+0.02f,abs(dToTreeOrigin.x + 0.2f * sin(2.0f * dToTreeOrigin.y)))) * (1.0f - smoothstep(0.0f,0.1f,dToTreeOrigin.y));   \n}\n\nfloat remap1(float a, float b, float t) //remap t to a - b in a range of 0-1 \n{\n \treturn ((t-a) / (b - a));\n}\n\nfloat remap2(float a , float b, float c, float d , float t)\n{\n    return remap1(a,b,t) * (d-c) + c;\n}\n\nfloat DistToLine(vec3 ro, vec3 rd, vec3 p)\n{\n \treturn length(cross(p-ro,rd))/ length(rd);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //make center of screen (0,0) and not affect by screen ratio\n    vec2 xy = fragCoord / iResolution.xy;\n    xy-=.5f;\n    xy.x *= iResolution.x/ iResolution.y;\n    vec3 ro = vec3(0,0,-2.0f);\n    vec3 rd = vec3(xy.x,xy.y,0)- ro;\n    float t =iTime;\n    \n    //first tree\n    vec2 treeOrigin = vec2(0.3f,0.01f);\n    vec2 dToTreeOrigin = xy - treeOrigin; \n    dToTreeOrigin *=3.5f;   \n    \n    //glowworm \n    vec3 col_w = vec3(0.2,1.0f,0.0f);\n    vec3 p = vec3(0.5f * sin(t),0.8f,2.0f + 3.0f * cos(t));\n    p -= vec3(dToTreeOrigin.x - 0.8f , dToTreeOrigin.y+1.3f , 0);\n    float dist_p = smoothstep(0.2f,0.1f,DistToLine(ro,rd,p));\n    col_w *= dist_p;\n    \n    //Sun\n    vec3 col = mix(vec3(0.2f, .6f, 1.0f), vec3(1.0f,0.7f,0.9f),5.0f*sin(2.0f*t+(-xy.x+xy.y)));\n    vec2 rSunOrigin = vec2(-0.5,0.4f); \n    vec2 vToSun = xy - rSunOrigin; \n    vToSun *=5.5f;\n    float dToSun = length(vToSun);\n    \n    //Second Tree\n    vec2 secondTreeOrigin = vec2(0.6f,.8f);\n    vec2 dToSTreeOrigin = xy - secondTreeOrigin;\n   \n       \n    \n    makePalmTreeWithGround(col, xy, dToTreeOrigin,10.0f,0.3f,0.2f,20.0f);\n    \n    makePalmTreeWithGround(col, xy, dToSTreeOrigin,5.0f,0.4f,0.2f,20.0f);\n    \n    //Sun\n   \tfloat r_Sun = 0.6f + 0.2f * cos(atan(vToSun.y,vToSun.x) * 10.0f + 20.0f * sin(t)); \n    col *= smoothstep(r_Sun - 0.02f, r_Sun, dToSun);\n      \n    //smile face\n    float mask=0.0f;\n    vec3 col_SmileFace = mix(vec3(1.0f,0.5f,0.2f),vec3(0.5f,1.0f,0.2f), sin(0.4f*t + xy.x));\n    mask = makeSmileMask(xy,rSunOrigin,0.05f,1.1f);\n\tcol_SmileFace*=mask;\n    \n    //jumping star\n    float starMask = makeDiamond(xy-vec2(1.0f * sin(t),0.2f * abs(cos(t * 2.0f))) - vec2(0,-0.3f), -.03f * abs(sin(iTime)) , .03f* abs(sin(iTime)) ,.03f * abs(sin(iTime)),-.03f* abs(sin(iTime)), .002f);\n    float star2Mask = makeRect(xy-vec2(1.0f * sin(t *1.5f),0.2f * abs(cos(t * 4.0f))) - vec2(0,-0.3f), -.04f * abs(sin(iTime)) , .04f* abs(sin(iTime)) ,.04f * abs(sin(iTime)),-.04f* abs(sin(iTime)), .002f);\n    \n    //river\n    float riverX = xy.x;\n    float riverY = xy.y;\n    riverY +=0.42f;\n    float m = 0.03f*sin(t+riverX*8.0f);\n    riverY +=m;\n    float blur = remap2(-.9f,.9f, 0.002f,0.05f,riverX);\n    float riverMask = makeRect(vec2(riverX,riverY),-.9f,.9f, .01f,-.01f,blur);\n    \n\n    col += col_SmileFace+ starMask + star2Mask + riverMask +col_w ;\n    \n    fragColor = vec4(col,1.0f);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsGGRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGGW1", "name": "Polar Play", "author": "carmandale", "description": "playing with polar coordinates and motion", "tags": ["polarwarping"], "likes": 0, "viewed": 54, "date": "1570047813", "time_retrieved": "2024-06-20T19:47:45.738965", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy -.5*iResolution.xy)/iResolution.y;\n    vec2 st = vec2(atan(uv.x, uv.y), length (uv));\n    \n    float t = iTime;\n    float d = 5.*cos(uv.x*t);\n    uv = vec2(st.x/6.2831+.5, st.y);\n    \n    float x = uv.x*d;\n    float m = min(fract(x), fract(1.-x));\n    float c = smoothstep(0.,.1, m*.5+.2-uv.y);\n    \n\n    \n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGGW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGGW3", "name": "TorusBlackHole", "author": "JohnShadow", "description": "Torus Black Hole algorithm, can make any shape of black hole, go ahead try it", "tags": ["raymarch", "torus", "blackhole"], "likes": 1, "viewed": 78, "date": "1571030520", "time_retrieved": "2024-06-20T19:47:46.272326", "image_code": "const float G = 6.67408e-11;\nconst float mass = 1.0e9;\nconst vec3 bhpos = vec3(0, 0, 0); \n\nfloat map(vec3 p)\n{\n    p = min(max(p, -256.0), 256.0);\n    p = mod(p, 32.0) - 16.0;\n\tfloat s = distance(p, vec3(0, 0, 0.0))-4.0;\n    return s;\n}\nfloat blackhole(vec3 p)\n{\n    vec3 p1 = p;\n    p.x = p1.y;\n    p.y = p1.x;\n\tvec2 t = vec2(5.0, 0.25);\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nvec3 getnormal (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( map(p + vec3(eps, 0, 0) ) - map(p - vec3(eps, 0, 0)),\n \t  map(p + vec3(0, eps, 0) ) - map(p - vec3(0, eps, 0)),\n\t  map(p + vec3(0, 0, eps) ) - map(p - vec3(0, 0, eps))\n \t)\n );\n}\nvec3 holefeild (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( blackhole(p + vec3(eps, 0, 0) ) - blackhole(p - vec3(eps, 0, 0)),\n \t  blackhole(p + vec3(0, eps, 0) ) - blackhole(p - vec3(0, eps, 0)),\n\t  blackhole(p + vec3(0, 0, eps) ) - blackhole(p - vec3(0, 0, eps))\n \t)\n );\n}\nfloat calcGrav(float r, float m)\n{\n\treturn G * m/(r * r);\n}\nvec4 march(vec3 ori, vec3 dir)\n{\n    vec3 pos = ori + dir;\n    float bhrad = 1.0;\n\tfor(int i = 0; i < 400; ++i)\n    {\n        float bh = blackhole(pos);\n        if(bh < bhrad)\n            return vec4(0.0);\n\t\tvec3 bhdir = holefeild(pos);\n        float grav = calcGrav(bh, mass);\n        float cs = map(pos);\n       \tdir = normalize(dir - bhdir * grav);\n        pos += dir * min((bh - bhrad), cs);\n\n        if(cs < 0.001)\n            return vec4(pos, cs);\n    }\n    return vec4(0.0);\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 eye = vec3(30.0 * sin(iTime * 0.5), 10.0, 30.0 * cos(iTime * 0.5));\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    vec3 normal, color;\n    \n    // Time varying pixel color\n    vec4 hit = march(eye, worldDir);\n    normal = getnormal(hit.xyz);\n    if(hit.w != 0.0)\n        color = vec3(0.2, 0.7, 0.8) * max(dot(normal, normalize(vec3(0, 0.5, -0.5))), 0.1);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGGW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGGWd", "name": "Anyone Remember?", "author": "rmmcal", "description": "Remembering the past.... (Johnny Castaway Screensaver) dedicated to my favorite screensaver...", "tags": ["johnnycastaway"], "likes": 6, "viewed": 132, "date": "1571243308", "time_retrieved": "2024-06-20T19:47:47.508853", "image_code": "/////////////////////////////////////////////////////////////\n/////      ........ Johnny Castaway ..........     ////////// \n/////      .... My favorite screensaver ......     ////////// \n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus            \n// Anyone Remember?  \n// Created by Rodrigo Cal (twitter: @rmmcal) - 2019/10\n// - https://www.shadertoy.com/view/WsGGWd\n/////////////////////////////////////////////////////////////\n// -----------------------------------------------------------\n// The past is alive for time travelers....\n//\n//      - Reflection of the day... @rmmcal 2019/10\n//\n// Inspiration:\n//  => https://en.wikipedia.org/wiki/Johnny_Castaway\n//  => Johnny Castaway Screensaver\n//// -----------------------------------------------------------\n/////////////////////////////////////////////////////////////\n\nvec2 uv ;\n\n/////////////////////////////////////////////////////////////\n//  => https://www.shadertoy.com/view/tsKGDc @onak\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283);\n}\nfloat perlin_noise(vec2 p) {\n\tvec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\nfloat perlin_noise1(vec2 p) {\n    vec2 count ;\n    for (float i = 0.; i < 9.; i++){\n        count += hash22 ( floor(p*10.)/10. +vec2(mod(i,3.)-1., i/3.-1.) );\n    }\n    count /= 9.;\n    return count.x;\n}\nfloat noise_fBM(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    for (int i = 1; i <= octaves; i++) {\n        c += perlin_noise(coord * size) * p;\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    c /= n;\n    return c;\n}\n/////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////\n\nfloat clouds(vec2 p) {\n    float c = 2.5 * noise_fBM(2.0, 6, 0.5, 2.0, p*vec2(1.,2.1/(pow(p.y,2.))) + vec2(iTime * ( 0.01), 0.0));\n \treturn c;\n}\n\nfloat water(vec2 p) {\n    float c = 4.5 * noise_fBM(2.0, 6, 0.5, 2.0, p*vec2(1.,4.) )*.4+ +1.-p.y*3.2;\n \treturn c;\n}\n\nfloat bit(float b){\n    return floor(b*2.+.4)/2.;\n}\n\nvec3 bit(vec3 b){\n    return floor(b*2.+.4)/2.;\n}\n\nfloat stepin(float a, float b, float x){\n    return a < x && x < b ? 1. : 0.;\n}\n\nvoid wood(inout vec3 canvas, vec2 p)\n{\n    float cf = (abs(mod(p.y+cos(p.x*10.),.03)*20.-1.));\n    cf = (cf*=cf)*(cf*=cf);\n    cf = bit(1.-cf*.5);\n    p -=  vec2(-0.12,+0.04);\n    canvas = mix(canvas, bit(vec3(p.x*2.))+(vec3(.4,.1,0.))*cf, (stepin(0.5,2., -atan(-p.x,p.y))) * step( 0.002, (.01-p.y)*.15+.08-abs(length((p-vec2(0.,0.))*vec2(4.,1.0))-.5)  ));\n}\n\nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvoid foliage(inout vec3 canvas, vec2 p)\n{\n\tp*= 2.0;\n    p -=  vec2(-0.0,-0.18);\n    vec3 c1 = vec3(.0,.9,0.0);\n    vec3 c2 = vec3(.23,.56,0.23);\n    vec3 c = p.x>0.0?c1:c2;\n    float cf = abs(mod(p.y,.1)*20.-1.);\n    p.x *= 1.+pow(cf,8.);\n    float f = .2-length(p*vec2(8.*(0.5-p.y),1.));\n    canvas = mix(canvas, c,  step( 0.002, f));\n    canvas = mix(canvas, vec3(1.),  step( 0.002, min(f, .004-abs(p.x))));\n}\n\nvoid coconutTree(inout vec3 canvas, vec2 p)\n{\n    for (int i = 0; i < 5; i++)\n\t\tfoliage(canvas, rotate(float(5-i)*.56-1.75)*(p-vec2(.0,0.25))+vec2(0.,abs(p.y*.1)));\n    wood(canvas, p-vec2(.0,-.07));\n}\n\nvoid johnny(inout vec3 canvas, vec2 p)\n{\n    p *= vec2(.5,1.);\n    p *= vec2(1.5);\n    \n\tp *= vec2(2.- clamp(iTime*.2-.1,0.,1.));\n    p += vec2(0.7,-.4)* vec2(1.- clamp(iTime*.2-.1,0.,1.));\n\n    float t = abs(fract(iTime*.1)*2.-1.);\n    float t2 = abs(fract(iTime*.7)*2.-1.);\n\tfloat y = cos(t*5.);\n    p -=  vec2(t*.2-.1,-0.05);\n    p *= 2.;\n    float f;\n    \n    //head\n    vec3 skin = vec3(1.0,0.7,0.5);\n    float f0 = .06-length(p*vec2(2.,1.1)-vec2(0.,.05));\n    canvas = mix(canvas, skin,  step( 0.002, f0));\n\n    // beard\n    float f1 = .05-length(p*vec2(8.*(0.2-p.y),1.));\n    canvas = mix(canvas, vec3(0.),  step( 0.002, f1));\n\n    //hair\n    f = .05-length(p*vec2(8.*(0.3-p.y),1.)+vec2(0.,-.04));\n    f =  .01-abs(f);\n    f =  -max(-f,f1);\n    canvas = mix(canvas, vec3(0.0),  step( 0.002, f));\n\n    // mouth\n    f = .02-length(p*vec2(1.,4.1));\n    canvas = mix(canvas, skin+.1,  step( 0.002, f));\n\n    // nose\n    f = .03-length(p*vec2(2.,2.1)+vec2(0.,-.06));\n    canvas = mix(canvas, skin+.1,  step( 0.002, f));\n\n    // hat\n    f =        .03-length(p*vec2(1.0,2.1)+vec2(0.,-.22));\n    f = max(f, .03-length(p*vec2(1.5,2.1)+vec2(0.,-.25)));\n    canvas = mix(canvas, vec3(1.),  step( 0.002, f));\n\n    // eye white\n    f = .01-length(p*vec2(1.,2.1)+vec2((p.x>0.)?-0.01:0.01,-.13));\n    canvas = mix(canvas, vec3(1.),  step( 0.002, f));\n\n    // eye black\n    f = .007-length(p*vec2(1.,1.1)+vec2((p.x>0.)?-0.01:0.01,-.07));\n    canvas = mix(canvas, vec3(0.),  step( 0.002, f));\n\n    ////////////////\n    p *= vec2(1.5);\n\t\n    float side = (p.x>0.)?-1.:1.;\n    //arms\n    f = .07-length(rotate((t2-0.5+side)*.1)*p*vec2(3.,-0.9)+vec2( side*0.1,-.13));\n    canvas = mix(canvas, skin,  step( 0.002, f));\n\tcanvas = mix(canvas, vec3(0.),  step( 0.002, 0.008-abs(f)));\n  \t\n \t//legs\n    f = .07-length(rotate((t2-0.5+side)*.03)*p*vec2(3.,-0.9)+vec2((p.x>0.)?-0.05:0.05,-.26));\n    canvas = mix(canvas, skin,  step( 0.002, f));\n    canvas = mix(canvas, vec3(0.),  step( 0.002, 0.008-abs(f)));\n\n    // body\n    f = .07-length(p*vec2(3.,-0.9)+vec2((p.x>0.)?-0.01:0.01,-.13+0.02));\n    canvas = mix(canvas, skin,  step( 0.002, f));\n \tcanvas = mix(canvas, vec3(0.),  step( 0.002, 0.008-abs(f)));\n  \n    // pants\n    f = .07-length((p)*vec2(3.,-1.7)+vec2((p.x>0.)?-0.01:0.01,-.35));\n    canvas = mix(canvas, vec3(1.),  step( 0.002, f));\n    canvas = mix(canvas, vec3(0.),  step( 0.002, 0.008-abs(f)));\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float re = 400.;\n    \n    vec2 r= iResolution.xy;\n    uv = fragCoord/iResolution.xy;\n    uv = floor(uv*re)/re;\n    vec2 cp = vec2(0.,1.)+uv*vec2(1.,-1.);\n\t\n    vec2 aspectRatio  = vec2( iResolution.x/iResolution.y,1.);\n    vec2 p = (uv-.5)*aspectRatio;\n\tvec2 pt = (uv-.5)*aspectRatio;\n\t\n    vec3 canvas ;\n    canvas = vec3(0.,0.97,0.97);\n  \n    float c = clouds(uv);\n    vec3 cloud = bit(canvas+ abs(vec3(c))+.5);\n    \n    float cb1 = step(.3,clouds(uv))-step(.3,clouds(uv-vec2(1./r)));\n    float cb2 = step(.5,clouds(uv))-step(.5,clouds(uv-vec2(1./r)));\n    float cb3 = step(.8,clouds(uv))-step(.8,clouds(uv-vec2(1./r)));\n    cloud = mix(cloud, vec3(0.8), step( 0.5, cb1 ));\n    cloud = mix(cloud, vec3(0.8), step( 0.5, cb2 ));\n    cloud = mix(cloud, vec3(0.8), step( 0.5, cb3 ));\n\n    canvas = mix(canvas, cloud, 1.-step( 0.4, cp.y ));\n    \n    float w2 = water(uv+vec2(0.,-0.7));\n    float w = water(uv);\n    canvas = mix(canvas, vec3(0.,0.5,0.97), step( 0.4, cp.y )*bit(w2));\n    canvas = mix(canvas, vec3(0.,0.0,0.97), step( 0.45, cp.y ));\n    canvas = mix(canvas, vec3(0.,0.0,0.48), step( 0.5, cp.y )*bit(w) );\n    \n    \n    float down = step(.63, cp.y);\n    float up = 1.-down;\n    \n    float pn = bit(perlin_noise(p*20.*vec2(1.,2.))*.4+.35)+.95;\n    \n    canvas = mix(canvas, vec3(0.9,.9,0.48), down*step( 0.0, .2-length((cp-vec2(0.,(1.,.5)))*vec2(1.,4.)-.5) ) );\n    canvas = mix(canvas, vec3(1.,1.0,0.48)*pn, up *step( 0.0, .2-length((cp-vec2(0.,(1.,.4)))*vec2(1.,2.)-.5) ) );\n    \n    coconutTree(canvas, p);\n    johnny(canvas, p);\n   \n    canvas = mix(canvas, vec3(0.),          step( 0.01, (length(p)-iTime+.3)  ));\n \n    fragColor = vec4(canvas,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGGWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGGWy", "name": "Move in circle ( tutorial )", "author": "Kiltun", "description": "A simple shader of a circle moving on a ring.\nI really tried to be understandable but if you need precision or just if you have ideas of optimization, you can write it in the comment section ^^.", "tags": ["tutorial", "circle", "ring", "move", "moveincircle"], "likes": 1, "viewed": 172, "date": "1570811436", "time_retrieved": "2024-06-20T19:47:48.393700", "image_code": "/*\nby Kilian Allaire (SLEEPN'T STUDIO). 11/10/2019\n\nHello, this is the first shader I made for shadertoy and \nI will try to explain you how I did. I am clearly not an expert\nand maybe this script is not optimal but I just want to have \nthe possibility to help other devs ^^.\n\nThis script is heavily based on this tutorial made by Uğur Güney : https://www.shadertoy.com/view/Md23DV\n(Go check his work, seriously)\n*/\n\n\n// choose one of the two options and compile the shader again\n// PART 1 = with aliasing\n// PART 2 = with anti-aliasing\n#define PART 1\n\n\n#if PART == 1\n\n// Function for making a disk :\n// \tr = screen resolution\n// \tcenter = position of the disk in the screen\n// \tradius = size of the disk\n// \tcolor = color of the disk\n// \tpixel = color output (what will be returned by the function)\n// \tWe will assign all this parameters when calling the function\n\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n    \n    // \"length(r-center)\" give us the distance between \"r\" and \"center\"\n    //  It will only change the color when it's inferior to the radius which will create a disk\n\tif( length(r-center) < radius) {\n\t\tpixel = color; \n\t}\n}\n\nvoid ring(vec2 r, vec2 center, float radius, vec3 lineColor, float lineThickness, inout vec3 pixel){\n    \n    // For making a ring, we will need to create two disk\n    // and then adding color between them\n    // 1st disk = \"length(r-center) < radius\"\n    // 2nd disk = \"length(r-center) > (radius - lineThickness)\"\n    if(length(r-center) < radius && length(r-center) > (radius - lineThickness)){        \n\t\tpixel = lineColor;        \n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; // Screen resolution in [-1.0, 1.0] scale\n    \n    vec3 pixel = vec3(0.1); // Base color\n    vec3 col1 = vec3(0.85,0.2,0.25); // red\n    vec3 col2 = vec3(0.95,0.92,0.95); // white\n    \n    float ringRadius = 0.7; \n    \n    // The math function to have a object moving in circle : \n    // X = originX + cos(angle)*radius;\n\t// Y = originY + sin(angle)*radius;\n    \n    // In this example the origin of the ring is the center \n    // of the screen ([0.0, 0.0]) so it's not important. \n    // I also wanted to have a moving object so I replace\n    // \"angle\" \n    // (the object has a specific position on the ring depending on the angle)\n    // by \"iTime\". \n    // (the object position depend on the time value which is always increasing)\n    vec2 mouvCircle = vec2((cos(iTime)*ringRadius),(sin(iTime)*ringRadius));\n\n    \n\t// calling functions\n    ring(r, vec2(0.0), ringRadius, col2, 0.05, pixel);\n    disk(r, mouvCircle, 0.2, col1, pixel);\n\n\n    // Output to screen\n    fragColor = vec4(pixel,1.0);\n}\n\n\n#elif PART == 2\n\n\t// In PART 1, we were able to see the pixel around \n\t// the disk and the ring, this is aliasing.\n\t// Here, we will reduce this effect by making the edges\n\t// fade which will give a nicer look to our objects.\n\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tif( length(r-center) < radius) {\n        \n        // We will use the \"smoothstep\" function.\n        // This function act like a \"lerp\" function but \n        // will start slow and end slow (giving a better look) \n        \n        // exemple : ValueA = smoothstep( 0, 1, ValueB)\n        // \"ValueB\" will interpolate the \"ValueA\" between 0 and 1.\n        \n        // Thank to that, we can fade the edges of the disk by \n        // adjusting the brightness of it. \n        vec3 brightness = vec3(smoothstep(radius, radius - 0.06, length(r-center)));\n\t\tpixel = vec3(brightness * color); // adding color\n        \n\t}\n}\n\nvoid ring(vec2 r, vec2 center, float radius, vec3 lineColor, float lineThickness, inout vec3 pixel){\n    if(length(r-center) < radius && length(r-center) > (radius - lineThickness)){ \n        \n        // For the ring, we need to put the \"smoothstep\" function on the two edges.\n        // We start by taking the middle of the ring :\n        // ((radius - lineThickness) + (radius - (radius - lineThickness))*0.5)\n        // and then we use \"smoothstep\" from the middle of the ring to the two edges.\n        \n        // (edge1 to middle) * (middle to edge2) * Intensity\n        \n        lineColor = vec3(smoothstep(radius, (radius - lineThickness) + (radius - (radius - lineThickness))*0.5, length(r-center)))\n            \t* vec3(smoothstep( (radius - lineThickness) + (radius - (radius - lineThickness))*0.5, radius, length(r-center))) * 4.0;\n        \n\t\tpixel = vec3(lineColor);        \n        \n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 pixel = vec3(0.0);\n    vec3 col1 = vec3(0.15, 0.2, 0.95);\n    vec3 col2 = vec3(0.95, 0.92, 0.95);\n    \n    float ringRadius = 0.7;\n    \n    vec2 mouvCircle = vec2((cos(iTime)*ringRadius),(sin(iTime)*ringRadius));\n    \n\n    ring(r, vec2(0.0), ringRadius, col2, 0.09, pixel);\n    disk(r, mouvCircle, 0.2, col1, pixel);\n\n\n    // Output to screen\n    fragColor = vec4(vec3(pixel), 1.0);\n}\n\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGGWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGGWz", "name": "ecLipse", "author": "foran", "description": "ecLipse", "tags": ["eclipse"], "likes": 2, "viewed": 85, "date": "1569959277", "time_retrieved": "2024-06-20T19:47:49.230208", "image_code": "#define PI 3.14159265359\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D \n//               noise functions.\n//      Author : People\n//  Maintainer : Anyone\n//     Lastmod : 20120109 (Trisomie21)\n//     License : No Copyright No rights reserved.\n//               Freely distributed\n//\n/*\nfloat snoise(vec3 uv)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\tvec3 f = fract(uv);\n\tf = f*f*(3.0-2.0*f);\n\tuv = floor(uv);\n\tvec4 v = vec4(dot(uv, s)) + vec4(0., s.x, s.y, s.x+s.y);\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\tr = fract(sin((v+s.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n*/\n//--------------\n/*\n//float Cellular3D(vec3 P)\nfloat snoise(vec3 uv)\n{\n\t//\testablish our grid cell and unit position\n\tvec3 Pi=floor(uv);\n\tvec3 Pf=uv-Pi;\n\t\n\t// clamp the domain\n\tPi.xyz=Pi.xyz-floor(Pi.xyz*(1./69.))*69.;\n\tvec3 Pi_inc1=step(Pi,vec3(69.-1.5))*(Pi+1.);\n\t\n\t// calculate the hash ( over -1.0->1.0 range )\n\tvec4 Pt=vec4(Pi.xy,Pi_inc1.xy)+vec2(50.,161.).xyxy;\n\tPt*=Pt;\n\tPt=Pt.xzxz*Pt.yyww;\n\tconst vec3 SOMELARGEFLOATS=vec3(635.298681,682.357502,668.926525);\n\tconst vec3 ZINC=vec3(48.500388,65.294118,63.934599);\n\tvec3 lowz_mod=vec3(1./(SOMELARGEFLOATS+Pi.zzz*ZINC));\n\tvec3 highz_mod=vec3(1./(SOMELARGEFLOATS+Pi_inc1.zzz*ZINC));\n\tvec4 hash_x0=fract(Pt*lowz_mod.xxxx)*2.-1.;\n\tvec4 hash_x1=fract(Pt*highz_mod.xxxx)*2.-1.;\n\tvec4 hash_y0=fract(Pt*lowz_mod.yyyy)*2.-1.;\n\tvec4 hash_y1=fract(Pt*highz_mod.yyyy)*2.-1.;\n\tvec4 hash_z0=fract(Pt*lowz_mod.zzzz)*2.-1.;\n\tvec4 hash_z1=fract(Pt*highz_mod.zzzz)*2.-1.;\n\t\n\t//  generate the 8 point positions\n\tconst float JITTER_WINDOW=.166666666;// 0.166666666 will guarentee no artifacts.\n\thash_x0=((hash_x0*hash_x0*hash_x0)-sign(hash_x0))*JITTER_WINDOW+vec4(0.,1.,0.,1.);\n\thash_y0=((hash_y0*hash_y0*hash_y0)-sign(hash_y0))*JITTER_WINDOW+vec4(0.,0.,1.,1.);\n\thash_x1=((hash_x1*hash_x1*hash_x1)-sign(hash_x1))*JITTER_WINDOW+vec4(0.,1.,0.,1.);\n\thash_y1=((hash_y1*hash_y1*hash_y1)-sign(hash_y1))*JITTER_WINDOW+vec4(0.,0.,1.,1.);\n\thash_z0=((hash_z0*hash_z0*hash_z0)-sign(hash_z0))*JITTER_WINDOW+vec4(0.,0.,0.,0.);\n\thash_z1=((hash_z1*hash_z1*hash_z1)-sign(hash_z1))*JITTER_WINDOW+vec4(1.,1.,1.,1.);\n\t\n\t//\treturn the closest squared distance\n\tvec4 dx1=Pf.xxxx-hash_x0;\n\tvec4 dy1=Pf.yyyy-hash_y0;\n\tvec4 dz1=Pf.zzzz-hash_z0;\n\tvec4 dx2=Pf.xxxx-hash_x1;\n\tvec4 dy2=Pf.yyyy-hash_y1;\n\tvec4 dz2=Pf.zzzz-hash_z1;\n\tvec4 d1=dx1*dx1+dy1*dy1+dz1*dz1;\n\tvec4 d2=dx2*dx2+dy2*dy2+dz2*dz2;\n\td1=min(d1,d2);\n\td1.xy=min(d1.xy,d1.wz);\n\treturn min(d1.x,d1.y)*(9./12.);// return a value scaled to 0.0->1.0\n}\n*/\n//-----------\n//float Perlin3D(vec3 P)\nfloat snoise(vec3 uv)\n{\n\t//  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\n\t\n\t// establish our grid cell and unit position\n\tvec3 Pi=floor(uv);\n\tvec3 Pf=uv-Pi;\n\tvec3 Pf_min1=Pf-1.;\n\t\n\t// clamp the domain\n\tPi.xyz=Pi.xyz-floor(Pi.xyz*(1./69.))*69.;\n\tvec3 Pi_inc1=step(Pi,vec3(69.-1.5))*(Pi+1.);\n\t\n\t// calculate the hash\n\tvec4 Pt=vec4(Pi.xy,Pi_inc1.xy)+vec2(50.,161.).xyxy;\n\tPt*=Pt;\n\tPt=Pt.xzxz*Pt.yyww;\n\tconst vec3 SOMELARGEFLOATS=vec3(635.298681,682.357502,668.926525);\n\tconst vec3 ZINC=vec3(48.500388,65.294118,63.934599);\n\tvec3 lowz_mod=vec3(1./(SOMELARGEFLOATS+Pi.zzz*ZINC));\n\tvec3 highz_mod=vec3(1./(SOMELARGEFLOATS+Pi_inc1.zzz*ZINC));\n\tvec4 hashx0=fract(Pt*lowz_mod.xxxx);\n\tvec4 hashx1=fract(Pt*highz_mod.xxxx);\n\tvec4 hashy0=fract(Pt*lowz_mod.yyyy);\n\tvec4 hashy1=fract(Pt*highz_mod.yyyy);\n\tvec4 hashz0=fract(Pt*lowz_mod.zzzz);\n\tvec4 hashz1=fract(Pt*highz_mod.zzzz);\n\t\n\t// calculate the gradients\n\tvec4 grad_x0=hashx0-.49999;\n\tvec4 grad_y0=hashy0-.49999;\n\tvec4 grad_z0=hashz0-.49999;\n\tvec4 grad_x1=hashx1-.49999;\n\tvec4 grad_y1=hashy1-.49999;\n\tvec4 grad_z1=hashz1-.49999;\n\tvec4 grad_results_0=inversesqrt(grad_x0*grad_x0+grad_y0*grad_y0+grad_z0*grad_z0)*(vec2(Pf.x,Pf_min1.x).xyxy*grad_x0+vec2(Pf.y,Pf_min1.y).xxyy*grad_y0+Pf.zzzz*grad_z0);\n\tvec4 grad_results_1=inversesqrt(grad_x1*grad_x1+grad_y1*grad_y1+grad_z1*grad_z1)*(vec2(Pf.x,Pf_min1.x).xyxy*grad_x1+vec2(Pf.y,Pf_min1.y).xxyy*grad_y1+Pf_min1.zzzz*grad_z1);\n\t\n\t// Classic Perlin Interpolation\n\tvec3 blend=Pf*Pf*Pf*(Pf*(Pf*6.-15.)+10.);\n\tvec4 res0=mix(grad_results_0,grad_results_1,blend.z);\n\tvec4 blend2=vec4(blend.xy,vec2(1.-blend.xy));\n\tfloat final=dot(res0,blend2.zxzx*blend2.wwyy);\n\treturn(final*1.1547005383792515290182975610039);// scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}\n//----------\n//rob dot dunn at gmail \n//Inspired by Ken Perlin's slides: http://www.noisemachine.com/talk1/24a.html\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\tvec2 p = ( fragCoord.xy / iResolution.xy ) - vec2(0.5);\n\tp.x *= iResolution.x/iResolution.y;\t\t\n\tfloat color1 = 3.0 - (3.*length(2.*p));\n\tfloat color2 = 3.0 - (3.*length(2.*p));\n\tfor(int i = 1; i <= 8; i++)\n\t{\n\t\tfloat power = pow(2.0,float(i));\n\t\tcolor1 -= ( (1.5 / power) * snoise( 2.*vec3( (atan(p.y,p.x))*power, (2.*length(p)-(iTime/16.))*power,  (iTime/8.) ) ) );\n\t\tcolor2 -= ( (1.5 / power) * snoise( 2.*vec3( (atan(p.y,-p.x)+2.*PI)*power, (2.*length(p)-(iTime/16.))*power,  (iTime/8.) ) ) );\n\t}\n\tcolor1 *= smoothstep(PI,0.,(abs(atan(p.y,p.x))));\n\tcolor2 *= smoothstep(PI,0.,(abs(atan(p.y,-p.x))));\n\tfloat color = color1+color2;\n\n\tfragColor = vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15 , 1.0 );\n\tif(length(p)<0.12) fragColor = vec4(0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsK3D3", "name": "NeonBars(BENDY)", "author": "Del", "description": "bars", "tags": ["neon"], "likes": 8, "viewed": 399, "date": "1571096580", "time_retrieved": "2024-06-20T19:47:49.539255", "image_code": "// Generic (sexy, seamless & slightly wibbly) neonbars with extraglow etc. for SST - Del 14/10/2019\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 SSTLines(vec2 duv, vec3 col2, float nl, float grad,float thickness, float wibblesize, float wibblespeed, float glowintensity, float glowclamp, float extraglow)\n{\n    if (iMouse.z<0.5)\n    \tcol2 = hsv2rgb(vec3(duv.y*0.1+duv.x*0.1+iTime*0.025,0.5,0.5));\n    \n    \n    duv.y -= (floor(duv.x)*grad) + (duv.x*grad);\n    duv = fract(duv);\n    float l1 = abs(fract((duv.x*grad-duv.y)*nl) -0.5);\n    float dd = sin(iTime*wibblespeed+duv.x*6.28)*wibblesize;\n    l1 = min(glowclamp, (thickness+dd)/l1);\n    vec3 col = col2*l1*glowintensity+(dd*extraglow);\n    return mix(col2,col,l1);\n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv.x -= 1.0;\n    uv.x = dot(uv,uv);\n    uv *= 1.0+sin(iTime)*0.25;\t// zoom\n    uv.y += iTime*0.1;\t\t\t// vscroll\n    \n    // lots of silly parameters, have fun :)\n    float grad = sin(iTime*0.35)*0.2;\n    float nlines = 5.0;\n    float thickness = 0.15;\n    float wibblesize = 0.015;\n    float glowintensity = 3.25;\n    float wibblespeed = 6.5;\n    float glowclamp = 1.0;\n    float extraglow = 9.0;\n    vec3 col = hsv2rgb(vec3(iTime*0.025,0.5,0.5));\n\tcol = SSTLines(uv, col, nlines, grad, thickness, wibblesize, wibblespeed, glowintensity, glowclamp, extraglow);\n    \n\t// vignette\n   \tvec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.35 );\n    \n    \n    O = vec4(col.xyz,1.0);\n}\n\n  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsK3D3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsK3DK", "name": "Shadertober 12 Dragon", "author": "GreenChicken", "description": "A flying dragon in the sky with people looking at it", "tags": ["raymarching", "dragon", "inktober"], "likes": 1, "viewed": 264, "date": "1570985419", "time_retrieved": "2024-06-20T19:47:50.799967", "image_code": "\n#define VOLUME 0.001\n#define PI 3.14159\n\n////////////////////////////////////////////////////////////////////////////////\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sat(float a) {return clamp(a, .0, 1.); }\n\nfloat opU(float s1, float s2) { return min(s1, s2);}\n\nvec2 opU2(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdGuy(vec3 p, float h)\n{\n    p.y -= h*.5;\n    float t = sdBox(p, vec3(.05, h*.5, .025));\n    t = opU(t, sdBox(p+vec3(0.0, -h*.5-.025, 0.0), vec3(.025, .025, .025)));\n    return t;\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\n\n\n\nvec2 sdLine( vec3 p, vec3 a, vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length( pa - ba*h ), h );\n}\n\nfloat sdSphere(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n\n// -------------------------------------------------------------------------\n\nvec2 map(vec3 pos)\n{\n    vec2 t = vec2(0.0, -1.0);\n    \n    // ground\n    t.x = pos.y;\n    \n    vec3 gp = pos + vec3(0.0, 0.0, 0.0);\n    float ground = udTriangle(gp,\n        vec3(-1.4, 0.0, 3.3),\n        vec3(0.0, 0.0, 5.0),\n        vec3(2.2, 0.0, 5.0));\n    \n    // guys\n    vec3 g1p = pos + vec3(0.0, 0.0, -4.1);\n    g1p.xz *= rot(PI/6.0);\n    float g1 = sdGuy(g1p, .2);\n    float g2 = sdGuy(g1p+vec3(-0.4, 0.0, -.9), .2);\n    float g3 = sdGuy(g1p+vec3(0.2, 0.0, -.5), .2);\n    \n    float guys = opU(g1, g2);\n    guys = opU(guys, g3);\n    \n    // dragon\n    vec3 d = pos + vec3(4.0, -1.0, 0.0);\n    d.y += sin(pos.x+iTime)*.5;\n    float dragonLine = sdLine(d, vec3(0.0), d + vec3(1.0, 0.0, 0.0)).x;\n    float dragon = dragonLine - .2;\n    \n    // legs\n    vec3 ep = pos + vec3(0.0, sin(iTime)*.5-.7, -1.0);\n    float leg = sdLine(ep, vec3(0.0), ep + vec3(0.2, -.2, 0.0)).x - .05;\n    ep = pos + vec3(2.0, sin(pos.x+iTime)*.5-1.0, -1.0);\n    leg = opU(leg, sdLine(ep, vec3(0.0), ep + vec3(-0.15, -.15, 0.0)).x - .02);\n    \n    // head\n    vec3 hp = pos + vec3(-1.4, sin(pos.x+iTime)*.5-1.0, -2.0);\n    float head = sdLine(hp, vec3(0.0), hp + vec3(0.2, -.2, 0.0)).x - .02;\n    \n    t = vec2(ground, 0.0);\n    t = opU2(t, vec2(guys, 1.0));\n    t = opU2(t, vec2(dragon, 2.0));\n    t = opU2(t, vec2(leg, 2.0));\n    //t = opU2(t, vec2(head, 3.0));\n    \n    return t;\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 1.; i += 1./15.) {\n        vec2 dist = map(pos + dir * t);\n        if (dist.x < VOLUME) return 0.;\n        f = min(f, k * dist.x / t);\n        t += dist.x;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = ro+rd*t.x;\n    vec3 col = vec3(0.0);\n    float depth = clamp(pos.z, 0.0, 1.0);\n    depth = 1.0 - sat(pos.z*.1);\n            \n    if(t.x == -1.0)\n    {        \n        col = vec3(0.0);\n        \n    }\n    else\n    {\n        float glp = clamp(length(pos)*.1, 0.0, 1.0);\n        vec3 N = GetNormal(ro+rd*t.x);\n        vec3 L = vec3(3.0, 10.0, 0.0);\n        float light = dot(N,normalize(L));\n        float shade = GetShadow(pos, L, 4.);\n        \n        if(t.y == -1.0) \n        {\n            col = vec3(.2+pos.z*.1);\n            col *= shade;\n        }\n        else if(t.y == 0.0) // ground\n        {\n            col = vec3(.5);\n            col *= light;\n            col += shade*.5;\n        }\n        else if(t.y == 1.0) // guys\n        {\n            col = vec3(0.0);\n            col += light*.3;\n        }\n        else if(t.y == 2.0) // dragon\n        {\n            col = vec3(1.0);\n        }\n        else if(t.y == 3.0) // tongue\n        {\n            col = vec3(1.0, 0.0, 0.0);\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 1.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime*.25;\n    \n    vec3 cp = vec3(0.0, 2.0, 6.0);\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    col = Render(cp, vd, uv);\n    col.z += screenUV.y*.5;\n    col -= random(screenUV) * .1;\n    col *= 1.0-length(uv)*.4;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsK3DK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsK3W1", "name": "Jazzy Partitions", "author": "104", "description": "90's inspired?", "tags": ["2d"], "likes": 10, "viewed": 267, "date": "1571671180", "time_retrieved": "2024-06-20T19:47:50.799967", "image_code": "const float PARTITIONS = 9.;\nconst float SHADETHRESH = .9;\n\nvec3 dtoa(float d, vec3 amount){\n    return vec3(1. / clamp(d*amount, vec3(1), amount));\n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n#define nsin(x) (sin(x)*.5+.5)\n#define q(x,p) (floor((x)/(p))*(p))\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    vec2 R = iResolution.xy;\n    uv.x *= R.x / R.y;\n    uv *= 2.;\n\n    vec2 cellUL = vec2(-.5);\n    vec2 cellBR = vec2(.5);\n    float seed = 1e3;\n    o = vec4(0);\n    vec3 lineColor;\n    vec3 a, a2;\n    \n    for(float i = 0.; i < PARTITIONS; ++ i) {\n        vec4 h = hash42(1e3*cellUL+seed); // xy = pos to divide between cellUL / cellBR.\n        vec4 h2 = hash42(1e2*cellUL+seed);\n        h.xy = mix(cellUL, cellBR, h.xy);\n        seed = h2.z+i;\n        vec2 uv2 = uv;\n        uv2 += q(sin(iTime*(h.z-.5)+(h.w*6.28))*.5, h2.w+.01);\n        uv2.x += uv2.y * (h2.x-.5);\n      \tuv2.y += uv2.x * (h2.y-.5);\n        float dl = min(length(uv2.x - h.x), length(uv2.y - h.y));\n        if (h2.x > SHADETHRESH) {\n            o.rgb = mix(h2.ywx, lineColor, a2 * nsin(150.*(uv.x+uv.y)));\n        }\n        dl = fract(dl);// cheap way to add more angles.\n        a = dtoa(dl, vec3(800));\n        a2 = dtoa(dl-.05, vec3(40));\n        lineColor = hash42(h2.xz*1e3).rgb;\n        o.rgb = max(o.rgb, lineColor * a);\n        \n        if (uv2.x < h.x) {\n            if (uv2.y < h.y) {\n                cellBR = h.xy;\n            } else {\n              \tcellUL.y = h.y;\n              \tcellBR.x = h.x;\n            }\n        } else {\n            if (uv2.y > h.y) {\n                cellUL = h.xy;\n            } else {\n                cellUL.x = h.x;\n                cellBR.y = h.y;\n            }\n\t    }\n        uv *= 1.05;\n    }\n    \n    vec2 N = fragCoord / iResolution.xy-.5;\n    o = clamp(o,0.,1.);\n    o = pow(o,o-o+.8);\n    o.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsK3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsK3Wd", "name": "laplace- & sobel filter", "author": "ich", "description": "laplace- & sobel filter", "tags": ["laplacesobelfilter"], "likes": 2, "viewed": 177, "date": "1571232083", "time_retrieved": "2024-06-20T19:47:50.799967", "image_code": "float grey(vec2 uv)\n{\n    vec3 c = texture(iChannel0, uv).rgb;\n    return (c.r + c.g + c.b) / 3.;\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 aspect2 = vec2(aspect, 1.);\n\treturn smoothstep(.5, .4, length(uv * aspect2 + - .5));\n}\n\nfloat laplace(vec2 uv)\n{\n    vec2 pixel = 1. / iResolution.yy;\n    \n\tfloat center = grey(uv);\n    float left = grey(uv - vec2(pixel.x, 0));\n    float right = grey(uv + vec2(pixel.x, 0));\n    float up = grey(uv - vec2(0, pixel.y));\n    float down = grey(uv + vec2(0, pixel.y));\n    \n    float c = left + right + up + down - 4. * center;\n    return c * .5 + .5;\n}\n\nfloat sobel_vertical(vec2 uv)\n{\n    vec2 p = 1. / iResolution.yy;\n    \n    float top = grey(uv - vec2(0, p.y));\n    float topleft = grey(uv - vec2(-p.x, p.y));\n    float topright = grey(uv + p);\n    float bottom = grey(uv + vec2(0, p.y));\n    float bottomleft = grey(uv + vec2(-p.x, -p.y));\n    float bottomright = grey(uv + vec2(p.x, -p.y));\n    \n    float c = bottomleft + bottomright + 2. * bottom - topleft - topright - 2. * top;\n    return c * .5 + .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0);\n    \n    float t = sin(iTime) * .2 + .5;\n    float tl = t - .2;\n    float tr = t + .2;\n    \n    float l = smoothstep(tl - .005, tl + .005, uv.x);\n    float r = smoothstep(tr + .005, tr - .005, uv.x);\n    \n    col += l * r * grey(uv);\n    col += (1. - l) * laplace(uv);\n    col += (1. - r) * sobel_vertical(uv);\n        \n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsK3Wd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsK3WG", "name": "Rift", "author": "peterszerzo", "description": "A little play with rifts, gradients and magnetism", "tags": ["gradient", "orthographic", "streamline"], "likes": 1, "viewed": 79, "date": "1571054954", "time_retrieved": "2024-06-20T19:47:50.799967", "image_code": "vec3 hsvToRgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float pi = 3.1415926535897932384;\n\nmat2 rotation ( in float _angle ) {\n    return mat2(\n        cos(_angle), sin(_angle),\n    \t-sin(_angle), cos(_angle)\n    );\n}\n\nfloat angle(in vec2 pos) {\n    if (abs(pos.x) < 0.0001) {\n        if (pos.y >= 0.0) {\n            return pi / 2.0;\n        }\n        if (pos.y < 0.0) {\n            return -pi / 2.0;\n        }\n    }\n    return atan(pos.y, pos.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.75;\n    \n    vec2 uv = rotation(pi * 1.25) *\n        (fragCoord / iResolution.xy - 0.5);\n    \n    uv.x = uv.x * iResolution.x / iResolution.y;\n    \n    float theta = angle(uv) * 5.2 / pi;\n    \n    float uvrX = 19.0 * pow(\n        length(uv),\n        0.8\n    );\n    \n    vec2 uvr = vec2(\n        uvrX,\n        theta * 5.0 + 1.6 * sin(uvrX + 4.0 + time)\n    );\n    \n    vec3 color1 = hsvToRgb(vec3(\n        0.56,\n        0.7,\n        0.75\n    ));\n    \n    vec3 color2 = hsvToRgb(vec3(\n        0.68,\n        0.8,\n        0.60\n    ));\n    \n    vec2 uvrMacro = floor(uvr);\n    vec2 uvrMicro = fract(uvr);\n  \n    // Inside gradient\n    if (uvrMacro.x < 7.0) {\n        fragColor = vec4(mix(\n            color1,\n            color2,\n            0.5 + 0.5 * sin(uvr.x * 0.5 + uvr.y * 0.2)\n        ), 1.0);\n        return;\n    }\n\n    fragColor = vec4(\n        vec3(0.08 + 0.04 * sin(\n            (uv.y + 0.1 * (0.5 + 0.5 * sin(time)) +\n             (1.0 + 0.12 * sin(time)) * uv.y * uv.x) *\n            21.0 * (1.5 + 0.02 * sin(time + pi * 0.5))\n        )),\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsK3WG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsK3z3", "name": "MitoDip", "author": "ompuco", "description": "Dip mitosis. He does this kind of often.", "tags": ["dipmitosissdfcharacteranimation"], "likes": 0, "viewed": 112, "date": "1570695366", "time_retrieved": "2024-06-20T19:47:52.454671", "image_code": "\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec3 Zigzag(vec3 pos, float freq, float offset){\n    float i = (pow(offset+abs(pos.x),.8));\n    float x = freq-abs(mod(i,2.0*freq)-freq);\n    pos.y+=(x);\n    return pos;\n}\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n#define PI 3.14159\n\n\nvec2 kaleido(vec2 z, float axis ){\n                float angleFrac = (2.0 * PI) / (2.0 * axis);\n\n                    float phi = abs(atan(z.y, z.x)); \n                    float r = length(z.xy);\n\n                    int count = int(phi / angleFrac);\n\n                    phi = mod(phi, angleFrac);\n                    if ( int(mod(float(count),2.0)) == 1) {\n                    phi = angleFrac - phi;\n                    }\n\n                    float x = r * cos(phi);\n                    float y = r * sin(phi);\n\n                    \n                    \n                    return (vec2(x,y));\n            }\n\n\nfloat dip(vec3 p) {\n    //p.x+=sin(p.y*2.0+iTime*4.0)/8.0;\n    \n    float head=sdRoundedCylinder(p+vec3(.0,.05,-.050),.375,.6,.01);\n\n    vec3 p2 = p;p2.x=abs(p2.x);p2.y/=1.4;\n\n    vec3 p3 = p;p3.z*=1.12;\n    //p3.x-=sin(iTime*2.0)/4.0;\n    //p3.x-=sin(p3.y+iTime*2.0)/8.0;\n    //p3.z+=step(p.z,.0)*sin(p3.y)/8.0;\n    p3.z-=smoothstep(.0,1.0,p3.y)/8.0;\n\t\n    \n    float body = sdRoundedCylinder(p3+vec3(.0,1.7,.350+sin(p3.y)/8.0),.3,1.7,.103);\n\t    p3.yz=rotate(p3.yz,.105);\n\n    body = opSmoothUnion(body, sdRoundedCylinder(p3+vec3(.0,.9,.150),.25,1.7,.103),.1);\n    \n    float d=opSmoothUnion(body,head,.15);\n     \n    float horns = sdOctahedron(p2-vec3(.5,.44,.1),.5);\n    horns = max(horns,-sdBox(p2-vec3(.0,.5,.0),vec3(.2,1.0,1.0)));\n    d=min(d,horns);\n    \n    \n    //d=min(d,body);\n    \n\n\n    \n    return d;\n}\n\n\nfloat map(vec3 p){\n    float t = float(iFrame)/60.0;\n    float x = smoothstep(.0,1.0,sin(t)/2.0+.5);\n        vec2 pos = vec2(x,.0)/2.25;\n\tfloat m = length(pos)*5.0;\n    float m2 = length(p);\n    //m+=abs(1.-m)*(.5+.5*sin(p.y*32.))/8.0;\n    \n    vec3 p2 = p;\n    \n    p2.z+=m/3.;\n        p.z+=m/3.;   \n    \n       \n    p2.xz=rotate(p.xz,-m/3.);\n    p.xz=rotate(p.xz,m/3.);\np2.x-=m/3.;\n        p.x+=m/3.;\n\n    float d = dip(p-6.2*vec3(pos.xy,.0));\n    float d2 = dip(p2+6.2*vec3(pos.xy,.0));\n    float b = m*max(.0,1.1-m2*1.)*sin(p.y*32.+sin(p.y*3.3)*4.)/16.0;\n\t//b*=(.75+b*.5);\n    d = opSmoothUnion(d,d2,.5*m+b*4.1);\n    //d -= (d*(b/2.+.5)*1.9)/1.0;\n    return d;\n}\n\nvec4 colorMap(vec3 pos){\n    \n        float t = float(iFrame)/60.0;\n\n    vec2 rotor = vec2(sin(t*2.0)/2.0,cos(t));\n\n    float eyeLook = mod(rotor.x+3.14*9.0,3.14*2.0)-3.14;\n    //eyeLook=clamp(eyeLook*12.5,-2.7,2.7)/2.7;\n    eyeLook=clamp(eyeLook*2.0,-1.0,1.0);\n\n    eyeLook=smoothstep(0.0,1.0,eyeLook/2.0+.5)*2.0-1.0;\n    eyeLook*=.85;\n        //eyeLook=clamp(eyeLook,-1.,1.)*.6;\n    \n    \n    vec3 p = pos;\n    p.x=abs(p.x);\n    \n    \n    \n    \n    vec4 fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    \n    float eyes=step(length(p+vec3(-.4,-.1,-.6)),.25);\n    float blink = clamp(1.0-abs(sin(t*0.45))*16.0,.0,1.0);\n    \n    \n    //blink rate for second blink set\n    float blinkRate = .4;\n    \n    //second set of blinks for more dynamic blinking lol\n    blink = max(blink,clamp(1.0-abs(cos(t*0.45*blinkRate))*16.0/blinkRate,.0,1.0));\n    \n    //squint occasionally\n    blink = max(blink,clamp(.35-abs(cos(t/4.0+.15)),.0,.10));\n\n    eyes*=step(p.y+p.x/8.0,.2-blink);\n    \n    //horizontal pupils follow camera\n    float pupils =step(.0,sdBox(p+vec3(-.4-eyeLook*sign(pos.x)/6.0,-.1+p.x/8.0,-.6),vec3(.01,.1,.5)));\n    \n    \n    //fragColor.g+=step(.0,n.y)*.25*step(-.5,r.pos.y);\n    //fragColor.g+=step(.0,n.y)*.05*step(n.y,.01);\n    \n    //fragColor.rgb=n.rgb;\n\n    fragColor.g=clamp(fragColor.g+eyes*pupils,.0,1.0);\n\n    \n    \n    \n    vec3 pm = Zigzag(pos,.11,.15);\n    \n    \n    pm.y=mix(pos.y,pm.y*2.0+.35,clamp(1.0-abs(pm.x),.0,1.0));\n\n\n    \n    float talkFreq = mix(sin(t*16.0),sin(t*13.0)-.8,clamp((cos(t*2.0+.15)+.5)*4.0,0.0,1.0));\n    float talkH=clamp(talkFreq/16.0+.1,.015,.25);\n    //float talkW=smoothstep(-1.0,1.0,clamp(-cos(iTime*2.0+.15)*8.0+.5,.0,1.0)*.24)*1.15-.34;\n    float talkW=smoothstep(-1.0,1.0,clamp(-cos(t*2.0+.15)*8.0+.5,.0,1.0)*.24)*.65;\n\n    //\ttalkW=.42;\n    float mouth = (sdEllipsoid(pm+vec3(.0,.425-pow(abs(pm).x,2.0)/1.0,-.5),vec3(talkW,talkH,.5)));\n\n    \n    \n    fragColor.g+=1.0-step(-.01,mouth);\n    return fragColor;\n    \n}\n\n\nvec4 dipCol(vec3 p){\n        float t = float(iFrame)/60.0;\n\n    \n    float x = smoothstep(.0,1.0,sin(t)/2.0+.5);\n        vec2 pos = vec2(x,.0)/2.25;\n\tfloat m = length(pos)*5.0;\n    \n    vec3 p2 = p;\n    \n    p2.z+=m/3.;\n        p.z+=m/3.;   \n    \n       \n    p2.xz=rotate(p.xz,-m/3.);\n    p.xz=rotate(p.xz,m/3.);\np2.x-=m/3.;\n        p.x+=m/3.; \n    \n    \n    vec4 d = colorMap(p-6.2*vec3(pos.xy,.0));\n    vec4 d2 = colorMap(p2+6.2*vec3(pos.xy,.0));\n    d.g = max(d.g,d2.g);\n\treturn d;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nstruct rmData{\n    vec4 color;//TODO @SAM: just do the colors at end of rm() function, u dummy\n    vec3 pos;\n    float depth;\n};\n\n    \nrmData rm(vec3 eye, vec3 dir, float start, float end) {\n    float depth = start;\n    rmData raym;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + depth * dir;\n        //pos=round(pos*16.0)/16.0;\n        //pos.x+=2.5;\n        //pos.z+=2.4;\n        //pos.xy=kaleido(pos.xy,16.0);\n        //        pos.y-=.85;\n\n        //pos.zx=kaleido(pos.zx,16.0);\n\n        //        pos.z-=1.5;\n        //pos.z-=2.5;        \n        \n\nfloat dist = map(pos);\n        if (dist < EPSILON) {\n            raym.depth=depth;\n            raym.pos=pos;\n            raym.color=dipCol(raym.pos);\n\t\t\treturn raym;\n        }\n        depth += dist;\n        if (depth >= end) {\n            raym.depth=end;\n            return raym;\n        }\n    }\n    raym.depth=end;\n    return raym;\n}\n            \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float t = float(iFrame)/60.0;\n\n    vec3 lDir = (vec3(.65,.5,.85))*2.0;\n\n    vec2 rotor = vec2(sin(t*2.0)/2.0,cos(t)/4.0);\n    rotor.y+=.2;\n \tif(iMouse.z>.0)\n    rotor=-vec2((iMouse.x/128.),(iMouse.y/64.-3.14))*2.0;\n\n    float eyeLook = mod(rotor.x+3.14*9.0,3.14*2.0)-3.14;\n    //eyeLook=clamp(eyeLook*12.5,-2.7,2.7)/2.7;\n    eyeLook=clamp(eyeLook*2.0,-1.0,1.0);\n\n    eyeLook=smoothstep(0.0,1.0,eyeLook/2.0+.5)*2.0-1.0;\n    eyeLook*=.85;\n        //eyeLook=clamp(eyeLook,-1.,1.)*.6;\n\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    dir.xz=rotate(dir.xz,rotor.x);\n    dir.yz=rotate(dir.yz,rotor.y/4.0-.15);\n\n    vec3 eye = vec3(0.0, 0.2, 5.25);\n    eye.z+=(sin(t)/2.0+.5)*2.0;\n \teye.z+=.5;\n    eye.xz=rotate(eye.xz,rotor.x);\n    eye.yz=rotate(eye.yz,rotor.y/4.0-.15);\n    \n\n\n    rmData r = rm(eye, dir, MIN_DIST, MAX_DIST);\n    float dist = r.depth;\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    fragColor=r.color;\n    vec3 n = estimateNormal(r.pos);\n    \n    \n    \n    //cel shading\n    fragColor*=mix(.5,1.0,clamp(fragColor.g+round(dot(n,lDir)+.5),.0,1.0));\n\n    \n\n\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsK3z3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsKGD1", "name": "Palillos", "author": "mago314", "description": "A zooming fractal. I should improve the zooming motion to be more continuous, probably.", "tags": ["fractal"], "likes": 9, "viewed": 107, "date": "1570178144", "time_retrieved": "2024-06-20T19:47:52.454671", "image_code": "float SIZE = 2.;\n\nvec2 foldUVs(vec2 uvs) {\n    if (uvs.x < 0.) uvs *= -1.;\n    uvs.x -= .5;\n    //mat2 m = mat2(0,1,-1,0);\n    //float ang = 6.28*iMouse.x/iResolution.x;\n    float ang = 3.141592*1./2.;\n    mat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n    uvs *= m;\n    uvs *= SIZE;\n    return uvs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= 1.;\n    float scale = 1.;\n    \n    float ang = 0.;\n    mat2 m = mat2(0.);\n    float s = 0.;\n    float t = 1.;\n\n    uv.y -= mix(.0, -1., t);//.5;\n    ang = mix(.0, -3.141592/2., t);//3.141592*1./2.;\n    m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n    uv *= m;\n    s = mix(1., 1./SIZE, t);\n    uv *= s; //SIZE;\n    scale *= s;\n    \n    //t = iMouse.x / iResolution.x;\n    t = fract(iTime);\n    //float t = 0.1;\n    \n    //uv.y -= mix(.0, -1., t);//.5;\n    //float a = mix(.5, -.5, t) * 3.141592;\n    //vec2 disp = vec2(cos(a),sin(a))*.5 - vec2(.0, .5);\n    vec2 disp = vec2(0., mix(.0, -1., t));\n    uv -= disp;\n    ang = mix(.0, -3.141592/2., t);//3.141592*1./2.;\n    m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n    uv *= m;\n    s = mix(1., 1./SIZE, t);\n    uv *= s; //SIZE;\n    scale *= s;\n    \n    vec3 col = vec3(0);    \n    float d = 1000.;\n    for (float i=0.; i<16.; i++) {\n        d = min(d, length(uv - vec2(clamp(uv.x,-.5,.5), 0.))/scale);\n        //if (abs(uv.y)<.002*scale && uv.x>0. && uv.x<.5) col = vec3(1,0,0);\n  \t    //if (abs(uv.x)<.002*scale && uv.y>0. && uv.y<.5) col = vec3(0,1,0);\n        uv = foldUVs(uv);\n        scale *= SIZE;\n    }\n    //col.x = d*10.;\n    col.x = smoothstep(2./iResolution.y,0.0,d);\n    //col.y = uv.y;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsKGD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsKGDV", "name": "Color pulse", "author": "mosaic", "description": "Modified from https://www.shadertoy.com/view/wsVGzy", "tags": ["2d"], "likes": 6, "viewed": 122, "date": "1571195233", "time_retrieved": "2024-06-20T19:47:52.624377", "image_code": "vec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n\n\tfloat len = length(uv);\n    float len2= length(uv)+.5;\n   \n float ring =smoothstep(80.0*(sin(iTime*4.)+1.1)/3./iResolution.y, 0.0, abs(len-(tan((iTime))+1.)/3.-.5));\n    ring+= smoothstep(80.0*(cos(iTime*4.)+1.1)/3./iResolution.y, 0.0, abs(len2-(sin((iTime))+1.)/3.-.5));\n    \n    \n    fragColor = vec4(ring) + 0.20*cos(iTime/2.-uv.yxyx+vec4(0,2,4,0)); // add color \n\tfragColor+=(hash42(uv*1e3+iTime*.2)-.5)*.2;  // optional film grain effect from https://www.shadertoy.com/view/tdy3DD\n    //fragColor=vec4(fragColor.x);//monochrome option\n    //fragColor = vec4(smoothstep(4.0/iResolution.y, 0.0, abs(length(uv)-.6))); //original non-moving ring\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsKGDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsKGRm", "name": "nNoise", "author": "nuzly", "description": "experimenting with noise. ", "tags": ["noise"], "likes": 0, "viewed": 71, "date": "1569919998", "time_retrieved": "2024-06-20T19:47:53.030518", "image_code": "\n//adapted from https://www.shadertoy.com/view/XdXGW8\n\n\nfloat nTime(){\n\nreturn iTime*3.123;\n}\n\nvec2 hash( vec2 v )  \n{\n    vec2 n = vec2( 0.1141592, 0.31812123 );    \n    v = v * n + n.yx;    \n\n    vec2 h =  -1.0 + 2.0 * fract(((6.0 * nTime()) / 6.66) * n * fract( v.x * v.y * (v.x + v.y)) );  \n   \n    if(h.x>0.1){  h =  -1.0 + 2.0 * fract(((12.0 * nTime()) / 122.33) * n * fract( v.x * v.y * (v.x + v.y)) );    }\n  \n    return abs(h);\n}\n\n\nfloat noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 j = fract(p);\n    \n    vec2 k = j * j * (3.0-2.0 * j);\n                  \n    float A = mix(\n        dot( hash( i + vec2(0.0,0.0) ), j - vec2(0.0,0.0) ), \n        dot( hash( i + vec2(1.0,0.0) ), j - vec2(1.0,0.0) ),\n        k.x);\n   \n    \n    float B = mix( \n        dot( hash( i + vec2(0.0,1.0) ), j - vec2(0.0,1.0) ), \n        dot( hash( i + vec2(1.0,1.0) ), j - vec2(1.0,1.0) ), \n        k.x);\n     \n    \n    float r = mix(A, B, k.y);\n   \n    return r;\n}\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 4.;\n\tfloat brightness =5.;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    float f;\n    \n\n     mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\n    f =  0.2500*noise( scale*uv ); uv = m*uv;\n\tf += 0.1250*noise( scale*uv ); uv = m*uv;\n    f += 0.0625*noise( scale*uv ); uv = m*uv;\n    \n\n   f*=brightness;\n   \n\tfloat r = f;\n    float g = f;\n    float b = f;\n\n   r = sin((uv.x/1.1)*f);\n\n \n\n    \n    vec3 col = vec3(r,g,b);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsKGRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsKGRt", "name": "shadetober #10 (pattern)", "author": "percentcer", "description": "Inktober, but with shaders", "tags": ["inktober", "shadertober", "shadetober", "inktober2019"], "likes": 3, "viewed": 269, "date": "1570782177", "time_retrieved": "2024-06-20T19:47:53.527576", "image_code": "#define MAX_MARCHING_STEPS 256\n#define PI 3.14159\n#define MAX_DEPTH 40.0\n\nconst float EPSILON = .001;\n\n// copied from iq's page on shapes\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// copied from iq's page on shapes\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// this could be cleaned up. can we use functors?\nvec3 gradient(vec3 p) {\n    return normalize(vec3(\n    \tsdOctahedron(vec3(p.x + EPSILON, p.yz), 1.) - sdOctahedron(vec3(p.x - EPSILON, p.yz), 1.),\n    \tsdOctahedron(vec3(p.x, p.y + EPSILON, p.z), 1.) - sdOctahedron(vec3(p.x, p.y - EPSILON, p.z), 1.),\n    \tsdOctahedron(vec3(p.xy, p.z + EPSILON), 1.) - sdOctahedron(vec3(p.xy, p.z - EPSILON), 1.)\n    ));\n}\n\n// copied from the internet\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t0.0,                                0.0,                                0.0,                                1.0\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5, .5);\n    uv.x *= iResolution.x / iResolution.y;\n    float cdist = 1. - length(uv);\n\n    // background light\n    vec3 col = vec3(cdist * .3, cdist * .4, cdist * .5) * 3.;\n    \n    // pos out of screen neg into screen\n    vec4 eye4 = rotation3d(vec3(0.,.2,.4), iTime) * vec4(vec3(0., 0., 5.), 1.);\n    vec3 eye = eye4.xyz;\n    vec2 pix = fragCoord - iResolution.xy * .5;\n    // not sure what this is doing. divide the height by the tan of half of the FOV. confusing.\n    float unsure_z = iResolution.y / tan((PI * .5) * .5);\n    vec3 ray = normalize(vec3(pix, -unsure_z));\n    \n    float depth = 0.0f;\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i) {\n        vec3 hPoint = eye + depth * ray;\n        vec3 point = opRep(hPoint, vec3(3., 3., 3.));\n        float dist = sdOctahedron(point, 1.);\n        if (dist < EPSILON && depth > 1.) {\n            col = mix(gradient(point) * 1.25 * (20. / float(i)),\n                      col,\n                      depth / MAX_DEPTH);\n            break;\n        }\n        depth += dist;\n        if (depth > MAX_DEPTH) {\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsKGRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsKGWV", "name": "shadetober #13 (ash)", "author": "percentcer", "description": "Inktober, but with shaders", "tags": ["inktober", "shadertober", "shadetober", "inktober2019"], "likes": 2, "viewed": 276, "date": "1571033113", "time_retrieved": "2024-06-20T19:47:53.527576", "image_code": "#define PI2 6.282\n\nfloat map(vec3 p) {\n    float angle = atan(p.z, p.x) / PI2;\n    vec2 lookup = vec2(p.x, p.z) + vec2(angle, -iTime);\n    float rad = \n        (1. + p.y) - cos(p.y) * p.y\n        + texture(iChannel0, (lookup * .2)).r\n        * smoothstep(0., 1., p.y * .75);\n    \n    return length(p) - rad * .7;\n}\n\nvec3 grad(vec3 p) { \n    vec2 ep = vec2(.0001, 0.);\n    return normalize(vec3(\n        map(p + ep.xyy) - map(p - ep.xyy),\n        map(p + ep.yxy) - map(p - ep.yxy),\n        map(p + ep.yyx) - map(p - ep.yyx)\n        ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(0., .4, 9.);\n    vec3 ray = normalize(vec3(uv, -1.5));\n    \n    vec2 spot = uv;\n    spot.y *= 8.;\n    spot.x *= 2.;\n    spot.y += 1.3;\n    float d = length(spot);\n    \n    float rBase = (sin(iTime) + 1.) * .03 + .7;\n    float gBase = (sin(iTime * 1.2) + 1.2) * .06 + .4;\n    vec3 col = vec3(rBase - d, gBase-d, 0.);\n\n    float t = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = eye + ray * t;\n        float depth = map(p);\n        if (depth < .001) {\n            vec3 lightpos = vec3(0., -1., 0.);\n            vec3 lightcol = vec3(1.);\n            \n            vec3 norm = grad(p);\n            \n            float alignment = dot(lightpos, norm);\n            vec3 addcol = lightcol * alignment;\n            col = clamp(vec3(1. - p.y, .5 - p.y, 0.), 0., 1.) \n                + addcol * .35;\n            col *= col;\n        }\n        t += depth;\n        if (depth > 20.) {\n            break; }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsKGWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsKGzV", "name": "Beat00", "author": "legarcia", "description": "1 Hz ", "tags": ["heart"], "likes": 2, "viewed": 89, "date": "1570651744", "time_retrieved": "2024-06-20T19:47:53.527576", "image_code": "\nfloat oneHz(){\n  \n   return(fract(iTime)*6.29);\n}\n\nfloat osc( float scale){\n    \n  scale *= .5;\n\n  return sin(oneHz()) * scale + scale;\n}\n\n\n\nvec4 tiler(vec2 i){\n    vec3 o = vec3(1.);\n    \n    \n    vec2 grid = vec2(fract(i.x),fract(i.y));\n    \n    grid -=.5;\n    \n    if ( length(grid)<(osc(.8) - length( i ) / 50.)  ){\n       grid.x = length(i);\n       grid.y =1.; //oneHz();\n    } else {\n       grid = vec2(0.);         \n    }\n    \n    \n    o = vec3(grid.yx, 00.);\n    \n    \n    \n    o.x = oneHz()/length(i);\n    \n    \n    \n    return vec4(o, 1.0);\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)*25./iResolution.y;\n\n    vec4 col = tiler(uv);\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsKGzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wst3zX", "name": "Voronoi Shader with max 8 player", "author": "wouter140", "description": "Voronoi Shader with max 8 player, easily set by changing the N_PLAYERS define.\n\nExpanded from https://www.shadertoy.com/view/4sVXR1 ", "tags": ["voronoi"], "likes": 6, "viewed": 104, "date": "1571322728", "time_retrieved": "2024-06-20T19:47:55.739766", "image_code": "// Screen coords:\n//   vec2 in \"screen units\" relative to the center of viewport\n//   y axis pointing up, x axis pointing to the right\n//   screen units are chosen so that a square [-1, 1] x [-1, 1] fits into the screen\n// World coords: vec2 in units.\n// Cameras: vec3, .xy is world coords of the center of the camera, .z is \"zoom\" (in screen units per world unit)\n\n\n#define PI 3.1415926535897932384626433832795\n\n#define CAMERA_ZOOM_MIN 0.6\n#define CAMERA_ZOOM_MAX 1.0\n\n#define N_PLAYERS 8\n\nvec3 playersColor[N_PLAYERS];\nvec3 playersBgColor[N_PLAYERS];\n\n\n// Inputs of the shader.\nvec2 playersPos[N_PLAYERS];  // player positions in world coordinates\nvec3 globalCam;             // global camera (zoomed out camera that sees all players)\nvec3 playersCam[N_PLAYERS];  // positions of cameras for each player\n\n\n// *****************************************************\n//  Utility functions\n// *****************************************************\n\nfloat atan2(float y, float x) {\n\t// For some reason GLSL's atan doesn't work as atan2\n    // and only returns angles [0, PI).\n    if (y > 0.0) {\n        return atan(y, x);\n    } else {\n        return PI + atan(-y, -x);\n    }\n}\n\nvec2 camScreen2World(vec3 cam, vec2 screenCoord) {\n    return cam.xy + screenCoord / cam.z;\n}\n\nfloat camScreen2World(vec3 cam, float screenLength) {\n    return screenLength / cam.z;\n}\n\nvec2 camWorld2Screen(vec3 cam, vec2 worldCoord) {\n    return (worldCoord - cam.xy) * cam.z;\n}\n\nfloat camWorld2Screen(vec3 cam, float worldLength) {\n    return worldLength * cam.z;\n}\n\nfloat screen2px(float x) {\n    return x * 0.5 * min(iResolution.x, iResolution.y);\n}\n\nfloat camWorld2Px(vec3 cam, float worldLength) {\n    return screen2px(camWorld2Screen(cam, worldLength));\n}\n\n// Weighted aggregation of the color information for overlapping objects on the same layer.\n// The resulting color is a weighted average of all aggreageted colors.\nvoid aggregateColorSiblings(inout vec4 aggColor, inout float aggWeight, vec4 addedColor) {\n    if (addedColor.w > 0.0001) {\n        float opacity = max(aggColor.w, addedColor.w);        \n        aggWeight += addedColor.w;\n        aggColor = vec4(mix(aggColor.xyz, addedColor.xyz, addedColor.w / aggWeight), opacity);\n    }    \n}\n\n// *****************************************************\n//  Scene rendering (demo vesion)\n// *****************************************************\n\nvec3 renderBackgroundRadialChecker(vec3 cam, vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(cam, screenCoord);\n    \n    float radius = length(worldCoord.xy);\n    float angularD = atan2(worldCoord.y, worldCoord.x) * radius;\n    \n    const float rowWidthGrowthPow = 2.5;    \n    const float rowRadiusScale = 100.0;\n    // index of a radial checker row.\n    float row = ceil(pow(radius * rowRadiusScale, 1.0 / rowWidthGrowthPow));\n    \n    float rowOuterRadius = pow(row, rowWidthGrowthPow) / rowRadiusScale;    \n    float radialBorderD = abs(radius - rowOuterRadius);\n    float columns = 10.0;\n    const float minRow = 2.0;\n    if (row < minRow + 0.1) {\n        row = minRow;\n        columns = 4.0;\n    } else {\n  \t\tfloat rowInnerRadius = pow(row - 1.0, rowWidthGrowthPow) / rowRadiusScale;\n        radialBorderD = min(radialBorderD, abs(radius - rowInnerRadius));\n        \n        columns = 10.0;        \n    }\n    \n    // index of a concentric checker column.\n    float columnWidth = (radius * 2.0 * PI) / columns;\n    float col = ceil(angularD / columnWidth);\n    \n    float concentricBorderD = abs(mod(angularD / columnWidth + 0.5, 1.0) - 0.5) * columnWidth;\n    \n    \n    const vec3 white = vec3(1.0);\n    const vec3 black = vec3(0.0);\n    vec3 midColor = 0.5 * (black + white);\n    \n    vec3 color;\n    if (mod(row + col, 2.0) > 0.5) {\n        color = white;\n    } else {\n        color = black;\n    }\n    \n    float borderDPx = camWorld2Px(cam, min(radialBorderD, concentricBorderD));\n    float aaColorWeight = smoothstep(0.0, 0.6, borderDPx);\n    \n    return mix(midColor, color, aaColorWeight);\n}\n\nvec4 renderPlayers(vec3 cam, vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(cam, screenCoord);\n    \n    // Player is a 10px at furthest possible zoom and gets bigger when gets closer.\n    float radiusPx = 10.0 * max(cam.z, CAMERA_ZOOM_MIN) / CAMERA_ZOOM_MIN;\n    const float radiusAaPx = 1.0;\n    \n    vec4 color = vec4(0.0);\n    float weight = 0.0;\n    for(int i = 0; i < N_PLAYERS; i++) {\n    \tfloat distPx = camWorld2Px(cam, length(worldCoord - playersPos[i]));\n        \n        float playerWeight = 1.0 - smoothstep(radiusPx, radiusPx + radiusAaPx, distPx);\n        vec4 playerColor = vec4(playersColor[i], playerWeight);\n        aggregateColorSiblings(color, weight, playerColor);\n  \t}    \n    return color;\n}\n\nvec3 renderScene(vec3 cam, vec2 screenCoord) {\n    vec3 color = renderBackgroundRadialChecker(cam, screenCoord);\n    vec4 playersColor = renderPlayers(cam, screenCoord);\n    color = mix(color, playersColor.xyz, playersColor.w);\n    \n    return color;\n}\n\n// *****************************************************\n//  Screen partitioning\n// *****************************************************\n\n// Returns a number that is guaranteed to be higher than any\n// of the distances within Global Camera.\nfloat maxGlobalDist() {\n    return camScreen2World(globalCam, 100.0);\n}\n\nint closestPlayer(vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(globalCam, screenCoord);\n\n    int minPlayer = 0;\n    float minDist = maxGlobalDist();\n    for(int i = 0; i < N_PLAYERS; i++) {\n    \tfloat dist = length(worldCoord - playersPos[i]);\n        \n        if (dist < minDist) {\n            minDist = dist;\n            minPlayer = i;\n        }\n  \t}\n    \n    return minPlayer;\n}\n\n\n// *****************************************************\n//  Faking inputs\n// *****************************************************\n\nvec2 initPlayerPos(vec2 basePos, float radius, float basePhase, float timeC) {\n    vec2 center = basePos - radius * vec2(cos(basePhase), sin(basePhase));\n    float phase = basePhase + iTime * timeC;\n    return center + radius * vec2(cos(phase), sin(phase));\n}\n\nvoid fakePlayers() {\n    const float timeScale = 0.2;\n    \n    for(int i = 0; i < N_PLAYERS; i++) {\n        switch(i) {\n            case 0:\n            playersColor[i] = vec3(0.957, 0.263, 0.212);  // red\n            playersPos[i] = initPlayerPos(vec2(0.2, 0.1), 2.0, PI, 1.0 * timeScale);\n            break;\n            \n            case 1:\n            playersColor[i] = vec3(0.129, 0.588, 0.953);  // blue\n            playersPos[i] = initPlayerPos(vec2(-0.2, 0.1), 1.0, 3.0 * PI * 0.5, 3.0 * timeScale);\n            break;\n            \n            case 2:\n            playersColor[i] = vec3(0.298, 0.686, 0.314);  // green\n            playersPos[i] = initPlayerPos(vec2(-0.2, -0.1), 3.0, 0.0, 0.5 * timeScale);\n            break;\n            \n            case 3:\n            playersColor[i] = vec3(0.612, 0.153, 0.69);   // purple\n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 2.0, 3.0 * PI / 4.0, 1.0 * timeScale);\n            break;\n            \n            \n            case 4:\n            playersColor[i] = vec3(1, 0.153, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 2.0, 3.0 * PI / 5.0, 1.0 * timeScale);\n            break;\n            \n            case 5:\n            playersColor[i] = vec3(0.612, 1, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 1.0, 3.0 * PI / 10.0, 1.0 * timeScale);\n            break;\n            \n            case 6:\n            playersColor[i] = vec3(0.612, 0.153, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 3.0, 3.0 * PI / 14.0, 1.0 * timeScale);\n            break;\n            \n            case 7:\n            playersColor[i] = vec3(0.612, 0.553, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 2.0, 3.0 * PI / 34.0, 1.0 * timeScale);\n            break;\n            \n            \n            case 8:\n            playersColor[i] = vec3(0.957, 0.263, 0.212);  // red\n            playersPos[i] = initPlayerPos(vec2(0.8, 0.5), 2.0, PI, 1.0 * timeScale);\n            break;\n            \n            case 9:\n            playersColor[i] = vec3(0.129, 0.588, 0.953);  // blue\n            playersPos[i] = initPlayerPos(vec2(-0.8, -0.1), 1.0, -3.0 * PI * 0.5, 3.0 * timeScale);\n            break;\n            \n            case 10:\n            playersColor[i] = vec3(0.298, 0.686, 0.314);  // green\n            playersPos[i] = initPlayerPos(vec2(-0.3, 0.1), 3.0, 0.0, 0.5 * timeScale);\n            break;\n            \n            case 11:\n            playersColor[i] = vec3(0.612, 0.153, 0.69);   // purple\n            playersPos[i] = initPlayerPos(vec2(-0.4, 0.1), 2.0, 3.0 * PI / -4.0, 1.0 * timeScale);\n            break;\n            \n            case 12:\n            playersColor[i] = vec3(1, 0.153, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(0.3, -0.7), 2.0, -3.0 * PI / 5.0, 1.0 * timeScale);\n            break;\n            \n            case 13:\n            playersColor[i] = vec3(0.612, 1, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(-0.92, -0.1), 1.0, -3.0 * PI / -10.0, 1.0 * timeScale);\n            break;\n            \n            case 14:\n            playersColor[i] = vec3(0.612, 0.153, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.29, 0.1), 3.0, 3.0 * PI / -4.0, 1.0 * timeScale);\n            break;\n            \n            case 15:\n            playersColor[i] = vec3(0.612, 0.553, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.62, -0.31), 2.0, 3.0 * PI / 44.0, 1.0 * timeScale);\n            break;\n        }\n    }\n}\n\n\nvoid fakeGlobalCamera() {\n    vec2 minPlayerCoord = playersPos[0];\n    vec2 maxPlayerCoord = playersPos[0];\n    for(int i = 1; i < N_PLAYERS; i++) {\n        minPlayerCoord = min(minPlayerCoord, playersPos[i]);\n        maxPlayerCoord = max(maxPlayerCoord, playersPos[i]);\n  \t}\n    const float cameraMarginScreen = 0.4;\n    // (maxPlayerCoord.x - minPlayerCoord.x) * zoom + 2.0 * cameraMarginScreen = iResolution.x / screen2px(1.0);\n    vec2 zoom = (iResolution.xy / screen2px(1.0) - 2.0 * cameraMarginScreen) / (maxPlayerCoord - minPlayerCoord);\n\tglobalCam = vec3((minPlayerCoord + maxPlayerCoord) * 0.5, min(min(zoom.x, zoom.y), CAMERA_ZOOM_MAX));\n}\n\nvoid fakePlayerCameras() {\n    if (globalCam.z > CAMERA_ZOOM_MIN) {\n        for(int i = 0; i < N_PLAYERS; i++) {\n            playersCam[i] = globalCam;\n        }\n    } else {\n        for(int i = 0; i < N_PLAYERS; i++) {\n            vec2 playerPosScreen = camWorld2Screen(globalCam, playersPos[i]);\n            playersCam[i] = vec3(playersPos[i] - playerPosScreen / CAMERA_ZOOM_MIN, CAMERA_ZOOM_MIN);\n        }\n    }\n}\n\nvoid adjustPlayerCameras(float uniformCamZoom) {\n    \n    for(int i = 0; i < N_PLAYERS; i++) {\n        playersBgColor[i] = playersColor[i];\n    }\n    float mergeDistMin = 0.6 * CAMERA_ZOOM_MIN;\n    float mergeDistMax = 0.8 * CAMERA_ZOOM_MIN;\n    for (int k = 0; k < 2; k++) {\n        // Moving cameras closer to each other.\n        for(int i = 0; i < N_PLAYERS; i++) {\n            for(int j = 0; j < N_PLAYERS; j++) {\n                if (i < j) {\n                    vec2 camPosI = playersCam[i].xy;\n                    vec2 camPosJ = playersCam[j].xy;\n                    float camDistScreen = length(camPosI - camPosJ) * uniformCamZoom;\n                    float mergeWeight = 0.5 * (1.0 - pow(smoothstep(mergeDistMin, mergeDistMax, camDistScreen), 4.0));\n                    playersCam[i].xy = mix(camPosI, camPosJ, mergeWeight);\n                    playersCam[j].xy = mix(camPosJ, camPosI, mergeWeight);\n\n                    vec3 bgColorI = playersBgColor[i];\n                    vec3 bgColorJ = playersBgColor[j];\n                    playersBgColor[i] = mix(bgColorI, bgColorJ, mergeWeight);\n                    playersBgColor[j] = mix(bgColorJ, bgColorI, mergeWeight);\n                }            \n            }\n        }\n        mergeDistMin *= 0.5;\n        mergeDistMax *= 0.5;\n    }\n}\n\n// *****************************************************\n//  Demos\n// *****************************************************\n\nvec4 mainSimpleDemo(vec2 screenCoord) {\n    fakePlayers();    \n    \n    float zoom = (CAMERA_ZOOM_MAX + CAMERA_ZOOM_MIN) * 0.5; // x axis spans [-10, 10]\n    zoom = zoom - (CAMERA_ZOOM_MAX - CAMERA_ZOOM_MIN) * 0.5 * cos(iTime * 0.3);  // animate zoom\n    const float camRadius = 0.2;\n\tvec3 camera = vec3(camRadius * cos(iTime), camRadius * sin(iTime), zoom);\n    \n    return vec4(renderScene(camera, screenCoord), 1.0);\n}\n\nvec4 mainGlobalCameraDemo(vec2 screenCoord) {\n    fakePlayers();    \n    fakeGlobalCamera();\n    \n    vec3 color = renderScene(globalCam, screenCoord);\n    int player = closestPlayer(screenCoord);\n    for(int i = 0; i < N_PLAYERS; i++) {\n        if (player == i) {\n        \tcolor = mix(color, playersColor[i], 0.4);\n        }\n    }\n    \n    return vec4(color, 1.0);\n}\n\nvec4 mainSplitScreenDemo(vec2 screenCoord) {\n    fakePlayers();    \n    fakeGlobalCamera();\n    fakePlayerCameras();\n\n    // We assume that all player cams have the same zoom.\n    float uniformCamZoom = playersCam[0].z;\n    adjustPlayerCameras(uniformCamZoom);\n    \n    int player = closestPlayer(screenCoord);\n    vec3 color;\n    for(int i = 0; i < N_PLAYERS; i++) {\n        if (player == i) {\n        \tcolor = renderScene(playersCam[i], screenCoord);\n        \tcolor = mix(color, playersBgColor[i], 0.4);\n        }\n    }\n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCoord = (fragCoord.xy - 0.5 * iResolution.xy) / screen2px(1.0);\n    // vec4 color = mainSimpleDemo(screenCoord);\n    // vec4 color = mainGlobalCameraDemo(screenCoord);\n    vec4 color = mainSplitScreenDemo(screenCoord);\n\tfragColor = vec4(color.xyz, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wst3zX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstSDM", "name": "Voronoi testing / Modularity", "author": "tiggerbiggo", "description": "woah", "tags": ["voronoi"], "likes": 0, "viewed": 168, "date": "1572184731", "time_retrieved": "2024-06-20T19:47:56.054981", "image_code": "#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n#define DBL_MAX 1.7976931348623158e+308\n#define DBL_MIN 2.2250738585072014e-308\n\nvec3 steppyColour(vec2 uv, float t);\nvec2 voronoiPoints(vec2 uv, float t, int n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= 1.3;\n\n    \n    uv = voronoiPoints(uv, float(iTime), 100);\n    \n    vec3 col = steppyColour(uv, iTime);\n    \n    //col = vec3(sin(uv.x*10.), cos(uv.y*5.), 0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvec3 steppyColour(vec2 uv, float t){\n    float len = length(uv);\n    return vec3(sin(len*5.0), sin(fract(len+t)*3.141*5.), .5*sin(len+cos(-t)));\n}\n\nvec3 uvReferenceColour(vec2 uv, float scale){\n    return vec3(sin(uv.x*scale), cos(uv.y*scale), 0);\n}\n\nvec2 voronoiPoints(vec2 uv, float t, int n){\n    float minn = FLT_MAX;\n    vec2 ret = vec2(0);\n    \n    for(float i = 0.; i<float(n); i++){\n        vec2 p = vec2(sin(t+(i*0.06)), sin(i+cos(t)));\n        \n        float tmp = minn;//hold last min value\n        minn = min(distance(uv,p),minn); //perform next calculation\n        tmp = tmp - minn; //get difference in values\n        \n        \n        ret = mix(ret,uv-p,step(0.00001, tmp));//mix between old and new values\n    }\n    return ret;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstSDn", "name": "metaball with lookup texture", "author": "novogrammer", "description": "metaball with lookup texture", "tags": ["metaball", "lookup"], "likes": 2, "viewed": 86, "date": "1571812164", "time_retrieved": "2024-06-20T19:47:56.054981", "image_code": "\nfloat circle(vec2 positionFragment,vec2 positionObject,float radius){\n    return length(positionFragment-positionObject) - radius;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //from -1 to 1\n    vec2 pos=( 2.*fragCoord - iResolution.xy )/iResolution.y;\n    \n    //smooth factor\n    float e=0.5;\n    \n    float value=0.;\n    for(int i=0;i<3;i+=1){\n        float r=radians(float(i+1)*360.*iTime*.1);\n        vec2 circlePosition=vec2(cos(r),sin(r))*.5;\n        value+=smoothstep(-e,e,-circle(pos,circlePosition,0.25));\n    }\n    \n    //lookup\n    vec3 col=texture(iChannel0,vec2(value,mod(iTime,.5)+.25)).rgb;\n    \n    //isolate\n    if(value<0.5){\n        col=1.-col;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstSDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WstSRM", "name": "ripple_learning", "author": "hyunxi", "description": " https://www.shadertoy.com/view/XsXXDn\ntry to understand this shader step by step", "tags": ["learningripple"], "likes": 2, "viewed": 66, "date": "1571757980", "time_retrieved": "2024-06-20T19:47:56.327689", "image_code": "#define t iTime\n#define r iResolution.xy\n\nvec2 ripple(vec2 p)\n{\n    float l = length(p);//length of all point to center of screen\n    //ripple shape\n    //sin(l) : along the l increase direction create wave pattern using sin\n    //this create Concentric circles\n    //-t*2 create animation\n    \n    float density = 9.;\n    float speed = -2.;\n    p = vec2(abs(sin(l*density+speed*t)));\n    return p;\n}\n\nvec2 beam(vec2 p)\n{\n    \n    float l = length(p);//length of all point to center of screen\n    //more center, more align to x axis , larger value\n    p = p/l;\n    //animate the brightness using lifted sin\n    p*=(sin(t)+1.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/r;// uv [(0 ,0)~(1,1)]\n    \n    vec2 p =uv;\n    p -=0.5;// [(-0.5 ,-0.5)~(0.5,0.5)]\n    p.x *= r.x/r.y; // proportion to 1:1 [(-0.5*r.x/r.y , -0.5)~(0.5*r.x/r.y , 0.5)]\n    \n    float c = (ripple(p)*beam(p)).y;\n    \n\t\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WstSRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WstSzS", "name": "2019-10-29 particles?", "author": "sinclav", "description": "I want very particles but it's not...", "tags": ["particles"], "likes": 1, "viewed": 67, "date": "1572275735", "time_retrieved": "2024-06-20T19:47:56.327689", "image_code": "float disk(vec2 pos, vec2 center, float r) {\n    return 1.0-smoothstep(r, r+0.14, distance(pos, center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 p = fragCoord / iResolution.xy;\n    vec2 pc = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    pc *= 9.21838192;\n    \n    float v = sin(pc.x*sin(t*0.2)+t*3.12)+sin(pc.y-sin(2.102*t))+sin(sin(length(pc))+t);\n    for (int i=0; i<20; i++) {\n        for (int j=0; j<20; j++) {\n          \tfloat d = disk(pc, vec2(v+10.1233*sin(float(i)/1.23+t*0.981),\n                                    v+8.912381*sin(float(j)/0.991+t*0.914)), 0.0);\n        \tvec2 res = vec2(pow(d, 1.0), pow(d, 1.0));\n        \tcol += vec3(res.x, res.y, length(p*d));\n        }\n    }\n    \n    //col.x += disk(pc, vec2(0.0), 0.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WstSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstXDM", "name": "Shadertober 26 Dark", "author": "GreenChicken", "description": "Japanese gate over a dark chess texture", "tags": ["raymarching", "inktober"], "likes": 3, "viewed": 222, "date": "1572189049", "time_retrieved": "2024-06-20T19:47:57.242970", "image_code": "// SHADERTOBER 26 Dark\n// Poulet Vert 27-10-2019\n// thanks iq, leon, flopine\n\n#define VOLUME 0.001\n#define PI 3.14159\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\n// Scene setup\nvec2 map(vec3 pos)\n{\n    vec2 scene = vec2(0.0, 0.0);\n    \n    scene.x = pos.y;\n    \n    float doorP = iTime * 3.;\n    \n    vec3 dp = pos + vec3(0.0, -3.0, doorP);\n    dp = opRep(dp, vec3(0.0, 0.0, 5.0));\n    float door = sdBox(dp, vec3(2., .2, .3));\n    \n    dp = pos + vec3(1.5 - pos.y*.1, -1.5, doorP);\n    dp = opRep(dp, vec3(0.0, 0.0, 5.0));\n    door = min(door,sdBox(dp, vec3(.2, 2.0, .2)));\n    \n    dp = pos + vec3(-1.5 + pos.y*.1, -1.5, doorP);\n    dp = opRep(dp, vec3(0.0, 0.0, 5.0));\n    door = min(door,sdBox(dp, vec3(.2, 2.0, .2)));\n    \n    // Materials\n    scene = opU2(scene, vec2(door, 1.0));\n    \n    return scene;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 10.0; i += .1) {\n        float dist = map(pos + dir * t).x;\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\n\nvec3 GetNormal (vec3 p)\n{\n    float c = map(p).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p+e.xyy).x, map(p+e.yxy).x, map(p+e.yyx).x) - c);\n}\n\nfloat GetLight(vec3 N, vec3 lightPos)\n{\n    return max(dot(N, normalize(lightPos)), 0.0);\n}\n\n\n\nfloat GroundTexture(vec2 uv)\n{   \n    return sign(sin(uv.x))*sign(sin(uv.y));\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(iTime*.5, vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    \n    if(t.x == -1.0)\n    {\n        col = vec3(0.0);\n    }\n    else\n    {    \n        vec3 N = GetNormal(pos);\n        \n        vec3 mainL = vec3(2.0, 5.0, 0.0);\n        float mainlight = GetLight(N, mainL);\n        \n        vec2 ledFreq = vec2(.15, .17);\n        vec2 ledUV =  vec2(-pos.x+5.08, -pos.y-.5);\n        \n        float shade = GetShadow(pos, mainL, 4.0);\n        \n        \n        if(t.y == 0.0) // ground\n        {\n            col = clamp(vec3(1.0-length(pos*.1))*.3, 0.0, 1.0);\n            vec2 groundUV = pos.xz * 10.;\n            groundUV.y += iTime*30.;\n            col *= GroundTexture(groundUV);\n            col *= shade;\n            \n        }\n        else if(t.y == 1.0) // door\n        {\n            col = polyCol;\n            col *= clamp(vec3(1.0-length(pos*.1))*.3, 0.0, 1.0);\n            col *= shade;\n            \n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(sin(iTime)*.3, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;    \n    \n    vec3 cp = vec3(sin(iTime)*.5, 1.0, 0.0);\n    vec3 ct = vec3(0.0, 1.0, 5.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, screenUV);\n    \n    col = sqrt(clamp(col, 0.0, 1.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstXDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstXR4", "name": "Cookie 19 fanzine submission", "author": "macbooktall", "description": "for cookie demoparty zine", "tags": ["kifs"], "likes": 10, "viewed": 383, "date": "1571599252", "time_retrieved": "2024-06-20T19:47:57.697697", "image_code": "// Submission to Cookie demo party fan zine -- by @connrbell\n#define ANIMATE 1\nfloat time;\n\n// pR from mercury.sexy/hg_sdf\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// smin and sdBox by iq - https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sdBox( vec3 p, vec3 b ) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n// --\n\nfloat hollowBox(vec3 p, vec3 b, float edge) {\n\tfloat res = sdBox(p,b);\n\tfloat edgeLow = (1.0 - edge * 0.5);\n    float edgeHigh = (1.0 + edge * 0.5);\n    vec3 size = vec3(b.x*edgeLow, b.y*edgeLow, b.z*edgeHigh);\n\n    res = max(res, -sdBox(p, size));\n    res = max(res, -sdBox(p, size.xzy));\n    res = max(res, -sdBox(p, size.zyx));\n\treturn res;\n}\n\nfloat map(vec3 p) {\n    float scale = .55, distFromCam = length(p)*3., res = 1e20;\n\tvec3 boxPos = p + vec3(0.,1.,-3.);\n\n    p.xyz = mod(p.xyz, vec3(2.)) - vec3(1.);\n\n    for (int i = 0; i < 7; i++) {\n        p = abs(p) + vec3(-.5, -.5, -.5) * scale;\n\n        pR(p.xz, 3.4 + 6.*iMouse.x/iResolution.x + cos( time + distFromCam + float(i)*0.333)*0.15);\n        pR(p.xy, .35 + 6.*iMouse.y/iResolution.y + sin( time + distFromCam + float(i)*0.333)*0.15); \n   \n\t\tscale *= 0.6;\n        \n        res = min(res,sdBox(p,vec3(scale)));    \n    }\n    pR(boxPos.xz,1.570795*0.65+time);\n    pR(boxPos.xy,1.570795*0.5+sin(time)*0.35);\n    res = smin(res, hollowBox(boxPos,vec3(.2), 0.075), 0.125);\n\treturn min(res, sdBox(boxPos,vec3(.1)));\n}\n\nvoid getColor (out vec4 fragColor, in vec2 fragCoord, vec3 ro) {\n    \n    time = 4.65 + iTime * float(ANIMATE);\n    vec2 p = -1.0+2.0*fragCoord.xy/iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    vec3 rd = normalize(vec3(p.x, p.y-0.5, 4.));\n \tfloat dist = 0.;   \n    \n    for (int i = 0; i < 65; i++) {\n   \t\tdist += map(ro + rd * dist);\n   \t}\n\n    vec3 pos = ro + rd * dist;\n\tvec3 col = vec3(map(pos + normalize(vec3(0., .1, -3.)) * 0.0025 )) / 0.0015;\n    \n    col = mix(col, vec3(0.), clamp((dist)/5., 0., 1.));\n    \n    fragColor = mix(vec4(.0), vec4(pow(col,vec3(0.5)), 1.), 1.-smoothstep(0.,1.,length(p)*0.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    float divergence = 0.01;\n    vec4 red = vec4(0);\n    vec3 ro = vec3(0.-divergence, -.75, 0.75);\n    getColor(red, fragCoord, ro);\n    vec4 cyan = vec4(0);\n    ro = vec3(0.+divergence, -.75, 0.75);\n    getColor(cyan, fragCoord, ro);\n    fragColor = vec4(red.r, cyan.gb, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstXz7", "name": "Spheres pooping spheres", "author": "theepicsnail", "description": "Me learning lighting things and screwing around with normals. ", "tags": ["abstract"], "likes": 5, "viewed": 75, "date": "1571724341", "time_retrieved": "2024-06-20T19:47:57.703735", "image_code": "#define max_steps 100\n#define eps 0.001\n\nmat2x2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2x2(c,-s,s,c);\n}\nvec3 rotX(vec3 ro, float a) { ro.yz = rot(a)*ro.yz; return ro;}\nvec3 rotY(vec3 ro, float a) { ro.xz = rot(a)*ro.xz; return ro;}\nvec3 rotZ(vec3 ro, float a) { ro.xy = rot(a)*ro.xy; return ro;}\n\n\nfloat sphere(vec3 p, float r) {\n    \n    return length(p) - r;\n}\n\nfloat sub(float a, float b) {\n    return max(a,-b);\n}\n\nfloat add(float a, float b) {\n    return min(a,b);\n}\n\nvec3 recenter(vec3 p, vec3 nc) {\n    return p-nc;\n}\n\nfloat plane(vec3 p) {\n    return p.y;\n}\nfloat sdf(vec3 ro) {\n    float d = 100000.0;\n    \n    float x = sin(iTime);\n    \n    float main = sphere(recenter(ro, vec3(0,1.5,0)), .5);\n    \n    vec3 sc = vec3(0, 1.5-fract(iTime*.25)*1.,0);\n    d= add(d,sub(main, sphere(recenter(ro, sc), .30)));\n    d= add(d,sphere(recenter(ro, sc-vec3(0,1,0)), .25));\n        \n    float sec = sphere(recenter(ro, sc), .25);\n    \n    d = add(d, sec);\n    \n    d = add(d, plane(ro));\n    \n    d = add(d,\n            plane(\n                rotX(recenter(ro, vec3(0,0,1)), -1.5)\n            )\n            );\n    d = add(d,\n            plane(\n                rotZ(recenter(ro, vec3(1,0,0)), 1.5)\n            )\n            );\n    d = add(d,\n            plane(\n                rotZ(recenter(ro, vec3(-1,0,0)), -1.5)\n            )\n            );\n    return d;\n}\n\nvec2 render(vec3 ro, vec3 rd) {\n    float total_distance = 0.;\n    for(int i = 0 ; i < max_steps ; i++) {\n        float d = sdf(ro + total_distance*rd);\n        \n        if(d<eps)\n            return vec2(1, total_distance);\n        \n       \ttotal_distance += d;\n    }\n    \n    return vec2(0, total_distance);\n}\n\nfloat rand(vec2 co){\n    co = floor(co*10.);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453)*2.-1.;\n}\n\nvec3 est_normal(vec3 p) {\n    return normalize(vec3(\n       sdf(p+vec3(eps,0,0))-sdf(p-vec3(eps,0,0)),\n       sdf(p+vec3(0,eps,0))-sdf(p-vec3(0,eps,0)),\n       sdf(p+vec3(0,0,eps))-sdf(p-vec3(0,0,eps))\n    )) + vec3(rand(p.yz), rand(p.xz), rand(p.yz))*.1;\n}\n\n\nfloat lighting(vec3 ro, vec3 lightPos) {\n    vec3 n = est_normal(ro);\n    vec3 rd = normalize(lightPos-ro);\n    \n    vec2 r = render(ro+n*eps*2., rd);\n    float brightness = .5;\n    if(r.y > length(lightPos - ro))\n        brightness = 1.;\n    return dot(n,rd) * brightness;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n \n \n    vec3 cam = vec3(0,.5,-1.5);\n    //cam.x += muv.x*.5;\n    //cam.y += muv.y;\n    //cam.xz *= rot;\n    \n    vec3 lookat = vec3(0,1,0);\n    \n    vec3 f = normalize(lookat-cam);\n    vec3 r = cross(f,vec3(0,1,0));\n    vec3 u = cross(r,f);\n    \t\n    vec3 i = cam + uv.x*r + uv.y*u + f*.7;\n        \n    vec3 ro = cam;\n    vec3 rd = normalize(i-cam);\n    \n    //fragColor.rgb = fract(abs(i-cam)*10.);\n    //return;\n    \n    vec2 result = render(ro, rd);\n    \n    vec3 hitpos = ro+rd*result.y;\n    //if(result.x<1.) return;\n\n    float l = 0.;\n    \n    vec3 lpos = vec3(.5,.6,0);\n    lpos.xz *= rot(iTime*.7);\n    fragColor = vec4(0,0,0,1);\n\tfragColor.rgb += lighting(hitpos, lpos) * vec3(1,0,0);\n    lpos.xz *= rot(2.);\n\tfragColor.rgb += lighting(hitpos, lpos) * vec3(0,1,0);\n    lpos.xz *= rot(2.);\n\tfragColor.rgb += lighting(hitpos, lpos) * vec3(0,0,1);\n    \n    \n    \n\t//fragColor.rg =uv;\n    //fragColor.b=0.;\n    // Output to screen\n    // * est_normal(hitpos)\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstXz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstXz8", "name": "probabilist rect. billiard ", "author": "FabriceNeyret2", "description": "let follows the trajectory of N*N balls starting from the same location.\n\nvariant: delete normalize for varying speed.  Or try vec2(iMouse.xy/R)  instead of vec(.5).\n[ wow, twice faster *with* the normalize ! same for with/without - float(N-1)/2.  WTF ? ]", "tags": ["simulation", "random", "billiard"], "likes": 2, "viewed": 254, "date": "1571483315", "time_retrieved": "2024-06-20T19:47:57.703735", "image_code": "#define N 17\n\n#define shash(p) ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, \n          U = u / R.y,\n          S = R / R.y, P, K;\n    \n    float t = (R.y<250.) ? iTime - 9. : iTime,\n        l = 1e9;\n    for ( int k=0; k < N*N; k++) {\n        K = shash( vec2(k%N,k/N) - float(N-1)/2. );\n     // P = vec2(.5+ .1*K) + t*vec2(1);          // random start position\n        P = vec2(.5) + t * normalize(K);         // random start direction\n        P = mod( P/S, 2.); P = min( P, 2.-P )*S; // wrap virtual P(t) in recursive border \"mirrors\"\n\n        l = min(l, dot(P-=U,P));                 // min distance\n    }\n    \n    O = vec4( smoothstep( 2./R.y,0., sqrt(l) )); // draw dot\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstXz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstXzj", "name": "Training 01 (Copo)", "author": "coposuke", "description": "Training", "tags": ["training"], "likes": 3, "viewed": 88, "date": "1572424227", "time_retrieved": "2024-06-20T19:47:57.703735", "image_code": "#define PI   3.14159265357989\n#define PI_2 6.28318530715978\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 opMin(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 map(in vec3 rayPos)\n{\n    float time = fract(iTime);\n    vec3 grid = floor(rayPos);\n    vec3 sphRayPos = fract(rayPos + vec3(time * mix(-1.0, 1.0, step(fract(grid.z / 2.0), 0.0)), 0.5, 0));\n    vec3 boxRayPos = fract(rayPos + vec3(0.0, time * mix(-1.0, 1.0, step(fract(grid.x / 2.0), 0.0)), 0));\n    \n    vec2 ret = vec2(1e+4, 0);\n    ret = opMin(ret, vec2(length(sphRayPos - 0.5) - 0.2, 1));\n    ret = opMin(ret, vec2(sdBox(boxRayPos - 0.5, vec3(0.15)), 2));\n    return ret;\n}\n\nvec4 march(in vec3 camPos, in vec3 camRay)\n{\n    const int ITERATE = 128;\n    vec3 rayPos = camPos;\n    vec4 ret = vec4(0);\n    \n    for(int i=0 ; i<ITERATE ; ++i)\n    {\n        vec2 result = map(rayPos);\n        rayPos += camRay * result.x;\n        \n        if(result.x < 1.0e-3)\n        {\n            ret.xyz = rayPos;\n            ret.w = result.y;\n        }\n    }\n    \n    return ret;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    const float EPSILON = 1.0e-4;\n    return normalize(vec3(\n        map(vec3(pos.x + EPSILON, pos.y, pos.z)).x - map(vec3(pos.x - EPSILON, pos.y, pos.z)).x,\n        map(vec3(pos.x, pos.y + EPSILON, pos.z)).x - map(vec3(pos.x, pos.y - EPSILON, pos.z)).x,\n        map(vec3(pos.x, pos.y, pos.z + EPSILON)).x - map(vec3(pos.x, pos.y, pos.z - EPSILON)).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 camPos = vec3(0.5 + cos(fract(iTime * 0.25) * PI_2) * 0.1, sin(fract(iTime * 0.5) * PI_2) * 0.5 + 0.1, iTime);\n    vec3 camDir = vec3(0, 0, 1);\n    vec3 camUp  = normalize(vec3(cos(fract(iTime * 0.05) * PI_2), sin(fract(iTime * 0.05) * PI_2), 0));\n    vec3 camSide= cross(camDir, camUp);\n    mat3 camMat = mat3(camSide, camUp, camDir);\n    float camLength = 2.0;\n    vec3 camRay = camMat * normalize(vec3(uv, camLength));\n    \n    vec4 result = march(camPos, camRay);\n    float resDist  = distance(camPos, result.xyz);\n    vec3 resPos    = vec3(result.xyz);\n    vec3 resNormal = computeNormal(resPos);\n    \n    vec3 diffuse = vec3(0);\n    diffuse = mix(diffuse, vec3(0.7, 0.7, 0.5), step(result.w, 2.0));\n    diffuse = mix(diffuse, vec3(0.8, 0.7, 0.3), step(result.w, 1.0));\n    diffuse = mix(diffuse, vec3(0.9), step(result.w, 0.0));\n    \n    vec3 lightDir = normalize(vec3(1,1.5,-1));\n    vec3 light = clamp(dot(lightDir, resNormal), 0.3, 1.0) * vec3(1);\n    light = mix(light, vec3(1), step(result.w, 0.0));\n\n    fragColor = vec4(diffuse * light,1.0);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.9), clamp(resDist * 0.075, 0.0, 1.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsV3D1", "name": "Raaaainbowwww", "author": "atzmael", "description": "My first shader created with the help of book of shader", "tags": ["rainbow", "firstshader", "cineshader"], "likes": 9, "viewed": 5161, "date": "1570110645", "time_retrieved": "2024-06-20T19:47:57.703735", "image_code": "// return a value between -1 & 1;\nfloat borderCircle(vec2 st, float pct, float minLimit, float maxLimit){\n  return  smoothstep( pct - minLimit, pct, distance(st,vec2(0.5,0.47))) -\n          smoothstep( pct, pct + maxLimit, distance(st,vec2(0.5, 0.499)));\n}\n\nfloat fillCircle(vec2 st, float pct){\n  return  step(0., distance(st,vec2(0.5))) -\n          step( pct, distance(st,vec2(0.5)));\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Centered thanks to Mosaic\n    vec2 st = (fragCoord-.5*iResolution.xy)/iResolution.y+.5;\n    \n    float drawCircle1 = map(sin(iTime * 1.), -1., 1., 0.40, 0.45);\n    float drawCircle2 = map(sin(iTime * 1.2), -1., 1., 0.35, 0.39);\n    float drawCircle3 = map(sin(iTime * 1.4), -1., 1., 0.30, 0.34);\n    float drawCircle4 = map(sin(iTime * 1.6), -1., 1., 0.25, 0.29);\n    float drawCircle5 = map(sin(iTime * 1.8), -1., 1., 0.20, 0.24);\n    float drawCircle6 = map(sin(iTime * 2.), -1., 1., 0.15, 0.19);\n    float drawCircle7 = map(sin(iTime * 2.2), -1., 1., 0.10, 0.14);\n    \n    vec3 circle1 = vec3(borderCircle(st, drawCircle1, 0.01, 0.01));\n    vec3 circle2 = vec3(borderCircle(st, drawCircle2, 0.01, 0.01));\n    vec3 circle3 = vec3(borderCircle(st, drawCircle3, 0.01, 0.01));\n    vec3 circle4 = vec3(borderCircle(st, drawCircle4, 0.01, 0.01));\n    vec3 circle5 = vec3(borderCircle(st, drawCircle5, 0.01, 0.01));\n    vec3 circle6 = vec3(borderCircle(st, drawCircle6, 0.01, 0.01));\n    vec3 circle7 = vec3(borderCircle(st, drawCircle7, 0.01, 0.01));\n\n    vec3 color = \n        circle1*vec3(0.975,0.000,0.000) +\n        circle2*vec3(0.990,0.493,0.000) +\n        circle3*vec3(0.955,0.955,0.000) +\n        circle4*vec3(0.000,0.985,0.000) +\n        circle5*vec3(0.000,0.000,0.965) +\n        circle6*vec3(0.694,0.000,0.990) + \n        circle7*vec3(0.571,0.000,0.990);\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsV3D1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsV3Dc", "name": "Kurosuke wall", "author": "blueneosky", "description": "Tiling with kurosuke creature", "tags": ["tiling", "makkuro", "kurosuke", "susuwatari"], "likes": 4, "viewed": 83, "date": "1571141088", "time_retrieved": "2024-06-20T19:47:57.703735", "image_code": "const vec3 ConstBackGroundCol = vec3(.25);\nconst float ConstBodyBorderSize = .2;\nconst float ConstEyesBodyRatio = .3;\nconst vec2 ConstEyeLoc = vec2(.35, .25);\nconst float ConstIrisEyeRatio = .4;\n\nconst vec3 ConstBodyColor = vec3(0.);\nconst vec3 ConstEyesColor = vec3(1.);\nconst vec3 ConstIrisColor = vec3(0.);\nconst vec3 ConstAngryEyesColor = vec3(1., 0., 0.);\nconst vec3 ConstAngryIrisColor = vec3(.5, .0, 1.);\n\nconst float PI = 2.*asin(1.);\n\nvec2 polar(in vec2 p) {\n    float dist = length(p);\n    float teta = dist > .0 ? asin(p.y/dist) : .0;\t// -Pi/2 -> Pi/2\n    if(p.x < .0)\n    \tteta = 3.14 - teta;\n    \n    return vec2(dist, teta);\n}    \n\nfloat smoothPeriodicEvent(in float period, in float duration, in float timeOffset) {\n    float val = fract((iTime + timeOffset) / period);\n    val = smoothstep(.0, duration/period, val);\t// _.-°¨¨¨¨¨¨|_.-°¨¨¨¨¨¨|_ [...]\n    val = 2.*abs(val-.5);\t\t\t\t\t\t// ¨\\_/¨¨¨¨¨¨¨¨\\_/¨¨¨¨¨¨¨¨ [...]\n    val = 1.-val;\t\t\t\t\t\t\t\t// _/¨\\________/¨\\________ [...]\n    \n    return val;\n}             \n\nfloat hcos(float v) {\n    // Note: approximation of bad/cool rendering cos of too high value on some chip CG\n    float d = sign(mod(v, 2.*PI)/PI - 1.)\n        \t* max(0., fract(mod(v, PI)/PI/0.65 - 7./13.)-.3)/.7;\n    return cos(PI/2. * (1.- d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = 4.*(2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    float hashedTime = 10000.+iTime;\n    \n    // tiling\n    float idY = floor(uv.y/2. + .5);\n    uv.x -= .5*idY;\n    vec2 id = vec2(floor(uv/2. + .5));\n    uv -= 2.*id ;\n    \n    vec3 col = ConstBackGroundCol;\n    \n    // angry one - sometime\n    float angry = smoothPeriodicEvent(30., 3., id.x*id.y + 2. * 5.*id.x - 7.*id.y);\n    if(angry >.0) {\n        vec2 rumble = .05*angry*vec2(cos((1000.*iTime)), sin(1200.*iTime));\n        uv+=rumble;\n    }\n    \n    // body size ~= 1. (+-cos +-sin)\n    {\n\t\tvec2 pol = polar(uv);\n        float bsize = pol.x\n            + ConstBodyBorderSize / 10.0 *\n            \t(   hcos(pol.y * 10. + 2. * iTime)\n                  - hcos(pol.y * 7. - 1.5 * iTime));\n        float b = smoothstep(1.-ConstBodyBorderSize, 1., bsize);\n        if(b < 1.) col = mix(ConstBodyColor, ConstBackGroundCol, b);\n    }\n    \n    // eyes\n    {\n        vec2 eyeMove = vec2(.0);\n        vec2 eyeLoc = ConstEyeLoc + eyeMove;\n        \n        vec2 rightLeftCorrection = vec2(1.);\n        if(uv.x < .0) rightLeftCorrection.x = -1.;\n        vec2 correctedEyeLoc = eyeLoc * rightLeftCorrection;\n        \n        vec2 normalizedEyeUv = (uv - correctedEyeLoc) / ConstEyesBodyRatio;\n        vec2 pol = polar(normalizedEyeUv);\n\n        float e = smoothstep(.7, 1., pol.x);\n        if(e < 1.)\n        {\n            // in the eye\n            vec3 eyesColor = ConstEyesColor;\n            if(angry>.0) eyesColor = mix(eyesColor, ConstAngryEyesColor, angry);\n            col = mix(eyesColor, col, e);\n            \n            // iris\n            {\n            \tvec2 irisLoc = eyeLoc;//+ 0.5*vec2(.03 * cos(iTime), .02 * sin(iTime));\n                vec2 normalizedIrisUv = (uv - irisLoc * rightLeftCorrection) / (ConstIrisEyeRatio*ConstEyesBodyRatio);\n                pol = polar(normalizedIrisUv);\n            \te = smoothstep(.6, 1.2, pol.x);\n                vec3 irisColor = ConstIrisColor;\n                if(angry>.0) irisColor = mix(irisColor, ConstAngryIrisColor, angry);\n                if(e < 1.) col = mix(irisColor, col, e);\n            }\n            \n            // eyelid\n            {\n                float closing = 1.-smoothPeriodicEvent(10., .2, 10.*(sin(30.* id.x) + .5*cos(10.*id.y)));\n                \n                vec2 lidLoc = eyeLoc;\n        \t\tvec2 correctedLidLoc = lidLoc * rightLeftCorrection;\n        \t\tvec2 normalizedLidUv = (uv - correctedLidLoc) / ConstEyesBodyRatio;\n                vec2 ellipsoidLidUv = normalizedLidUv * vec2(1., 1./closing);\n                float b = 1.-smoothstep(1., 1.05, length(ellipsoidLidUv));\n\t\t\t\tif(b<1.) col*=b;\n            }\n        }\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsV3Dc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsV3DG", "name": "Shader Showdown EVOKE-19 Final", "author": "evvvvil", "description": "Winning shader made at EVOKE 2019 Shader Showdown.\nLive coded on stage in 25 minutes. It ended up looking quite different on stage, but I got away with it.", "tags": ["time", "clouds", "demoscene", "volumetric", "abstract", "glow", "vortex", "laser", "limit", "live", "battle", "lazer", "shadershowdown", "gloss", "industrial"], "likes": 13, "viewed": 666, "date": "1570899762", "time_retrieved": "2024-06-20T19:47:58.279374", "image_code": "// Winning shader made at EVOKE 2019 Shader Showdown,\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader on stage. No google, no cheat sheets.\n// The audience votes for the winner by making noise or by voting on their phone.\n\n// \"Love is somebody who will do boring things with you and not later claim to be traumatised by the experience.\" Christian Fitness - \"The brain is not a lever\"\n\nvec2 s,v,e=vec2(.00035,-.00035);float t,tt,g,de,cr,f,ff,at,g2;vec3 np,cp,pp,rp,po,no,ld,al;vec4 su=vec4(0);\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec2 fb( vec3 p)\n{\n    p.xz*=r2(0.2-at*0.1);\n    vec2 h,t=vec2(bo(abs(p)-vec3(0,0,6),vec3(1,1,2)),5);  \n    h=vec2(bo(p,vec3(0.5,0.5,6)),3);  \n    h.x=min(bo(abs(p)-vec3(0,0.03,3.56),vec3(10,0.1,0.1)),h.x);  \n    t=t.x<h.x?t:h;\n    h=vec2(bo(abs(p)-vec3(0,0,9),vec3(0.7,0.7,6)),6);  \n    t=t.x<h.x?t:h;\n    h=vec2(bo(abs(p)-vec3(0,0.03,3.56),vec3(10,0.1,0.0)),6);\n    h.x=min(bo(p,vec3(0.1,0.55,2.5)),h.x);  \n    g2+=0.1/(0.1+h.x*h.x*400.);\n    t=t.x<h.x?t:h;\n    t.x*=0.7;\n    return t;\n}\nvec2 mp( vec3 p)\n{\n    np=p;\n    at=20.-min(length(p-vec3(0,sin(tt)*40.,0))-20.,20.);  \n    for(int i=0;i<8;i++){        \n        np=abs(np)-vec3(3,0,3);\n        if(i>5) np.x=sin(np.x*-.7);\n        np.xz*=r2(.785);\n        np.xy*=r2(.785);\n        np.yz-=2.-at*0.06;\n    }\n    vec2 h,t=fb(np);    \n    h=vec2(2.5*bo(abs(np*.2-vec3(sin(tt)-0.5,0,0.5))-.9,vec3(0.01,10,0.01)),6);\n    g+=0.1/(0.1+h.x*h.x*100.);\n    t=t.x<h.x?t:h;    \n    return t;\n}\nvec2 tr( vec3 ro,vec3 rd)\n{\n    vec2 h,t=vec2(.1);\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x);\n        if(h.x<.0001||t.x>80.)break;\n        t.x+=h.x;t.y=h.y;    \n    }\n    if(t.x>80.)t.y=0.;  \n    return t;\n}\nfloat noi(vec3 p){\n    vec3 f=floor(p),s=vec3(7,157,113);\n    p-=f;vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n    p=p*p*(3.-2.*p);\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\nfloat cno(vec3 p,float k){\n    float f=0.; p.z+=tt*k;\n    f+=0.5*noi(p);p=2.1*p;\n    f+=0.25*noi(p+1.);p=2.2*p;\n    f+=0.125*noi(p+2.);p=2.3*p;\n    return f;\n}\nfloat cmp( vec3 p)\n{  \n    float t=0.8*length(abs(p)-vec3(0,abs(sin(tt+1.59))*30.,0))-(8.-sin(p.y*.2-sin(tt)*2.+1.59)*6.);  \n    return t;\n}\n#define a(D) clamp(mp(po+no*D).x/D,0.,1.)\n#define s(D) smoothstep(0.,1.,mp(po+ld*D).x/D)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime*.8,62.83);\n    vec3 ro=vec3(cos(tt*.5)*33.,4.+sin(tt*.5)*30.,sin(tt*.5)*33.),\n        cw=normalize(vec3(0)-ro),\n        cu=normalize(cross(cw,vec3(cos(tt*0.2-0.5),1,0))),\n        cv=normalize(cross(cu,cw)),\n        rd=mat3(cu,cv,cw)*normalize(vec3(uv,.4)),co,fo;\n    ld=normalize(vec3(0.3,0.5,-0.5));\n    co=fo=vec3(0,.2,.3)+rd.y*0.3+0.5*(1.-(length(uv)-0.2));\n    s=tr(ro,rd);t=s.x;  \n    if(s.y>0.){    \n        po=ro+rd*t;no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n        al=vec3(1,.5,0);\n        if(s.y<5.) al=vec3(0);\n        if(s.y>5.) al=vec3(1);\n        float dif=max(0.,dot(no,ld)),fr=pow(1.+dot(no,rd),4.),\n            spo=exp2(10.*cno(np.zyx,0.)),sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo);\n        co=mix(sp+al*(a(.2)*a(.4)+.1)*(dif+s(.4)+s(2.)),fo,min(fr,.5));\n        co=mix(co,fo,1.-exp(-.00001*t*t*t));\n    }\n    cr=cmp(ro)-10.+fract(dot(sin(uv*476.567+uv.yx*785.951),vec2(984.156)));\n    for(int i=0;i<70;i++){\n        cp=ro+rd*(cr+=1./3.);\n        if(su.a>.99||cr>t) break;\n        de=clamp(-.5-cmp(cp)+2.*cno(cp,10.),0.,1.);\n        su+=vec4(vec3(mix(1.,0.,de)*de),de)*(1.-su.a);\n    }    \n    co=mix(co,su.xyz*1.5,su.a*.9); //co=mix(co,mix(su.xyz*1.5,fo,1.-exp(-.00001*cr*cr*cr)),su.a*.9);\n    fragColor = vec4(pow(co+g*.05+vec3(1,0.5,0)*g2*.3,vec3(.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsV3DG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsV3Dt", "name": "Another Triangular Voronoi", "author": "bitless", "description": "Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration \nThanks to aiekick and iq for some code from https://www.shadertoy.com/view/ltK3WD and https://www.shadertoy.com/view/MdSGRc", "tags": ["2d", "voronoi", "triangular"], "likes": 40, "viewed": 392, "date": "1571217992", "time_retrieved": "2024-06-20T19:47:58.818882", "image_code": "// Author: bitless\n// Title: another triangular voronoi \n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration\n// Thanks to aiekick and iq for some code from https://www.shadertoy.com/view/ltK3WD and https://www.shadertoy.com/view/MdSGRc\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.1415926\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 rotate2D(vec2 _st, float _angle,vec2 m){\n   \n    _st -= m;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += m;\n    return _st;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec2 m = vec2(0.5,0.5); \n    \n    if (iResolution.y > iResolution.x ) {\n        st.y *= iResolution.y/iResolution.x;\n        m.y *= iResolution.y/iResolution.x;\n    }       \n    else {\n        st.x *= iResolution.x/iResolution.y;\n        m.x *= iResolution.x/iResolution.y;\n    }\n    vec3 color = vec3(.0);\n\n\n\tst = rotate2D(st,PI*0.666666*((floor(mod(iTime,15.0)/5.0)-1.0)),m);  //rotation on 120 degrees\n    st = rotate2D(st,PI*0.666666*pow(smoothstep(0.0,1.0,mod(iTime+1.0,5.0))*(1.0-step(1.0,mod(iTime+1.0,5.0))),2.5),m);  //animate rotation cicle\n    // Scale\n    st -= m;\n    st *= sin(iTime*0.2)*1.0+3.0+cos(smoothstep(0.0,1.0,mod(iTime+1.0,5.0))*(1.0-step(1.0,mod(iTime+1.0,5.0)))*PI*2.0)*0.5; \n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    \n    float m_dist = 9.;  // minimun distance\n\n    vec2 p; \n    vec4 f;\n    f.x = 9.;\n    \n    for(int x=-2;x<=2;x++)\n    for(int y=-2;y<=2;y++)\n    {\t\n        p = vec2(x,y); //neightbour\n        p += 0.5*sin(iTime*0.2+6.2831*random2(i_st+p)); //animate\n\t\tp += .5  - f_st;\n\n        f.y = max(abs(p.x)*.866 - p.y*.5, p.y); \n        if (f.y < f.x)\n        {\n            m_dist = f.x;\n            f.x = f.y;\n            f.zw = p;\n        }\n        else if( f.y < m_dist )\n\t\t{\n\t\t\tm_dist = f.y;\n\t\t}\n    }\n\t\n    m_dist -= f.x;\n    \n    vec3 n = vec3(0);\n    \n    if ( (f.x - (-f.z*.866 - f.w*.5)) \t<.0001) \tn = vec3(0.940,0.860,0.907); \n\tif ( (f.x - (f.z*.866 - f.w*.5))\t<.0001) \tn = vec3(0.970,0.949,0.888);\n\tif ( (f.x - f.w)\t\t\t\t\t<.0001) \tn = vec3(0.871,0.900,0.960);\n\t\n    color =  n*(0.6+length(f.x)); //base color + distance field shadow\n    color -= 0.45*pow(clamp(m_dist*4.0,0.0,1.0),0.2); //edges\n    color *= 1.0-smoothstep(0.0,10.0,mod(length(f.x)*100.0,15.0))*0.06; //gradient stripes\n    color *= 1.0-step(2.0,mod(length(f.x)*100.0,15.0))*0.05; //thin light stripes\n\n    fragColor = vec4(color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsV3Dt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsV3RV", "name": "Shadertober 08 Frail", "author": "GreenChicken", "description": "was trying stuffs with matrix and... well it didn't work so i made legs with a lot of sphere instead of a cylinder looking at the creature.", "tags": ["raymarching", "monster", "inktober"], "likes": 4, "viewed": 260, "date": "1570570515", "time_retrieved": "2024-06-20T19:47:59.758325", "image_code": "// SHADERTOBER 08 Frail\n// Poulet Vert 08-10-2019\n// thanks to iq, leon\n\n////////////////////////////////////////////////////////////////////////////////\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sat(float a) {return clamp(a, .0, 1.); }\n\nfloat opU(float s1, float s2) { return min(s1, s2);}\n\nvec2 opU2(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p+0.5*c, c)-0.5*c;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdLeg(vec3 p, vec3 t, int legnum, float legsize, float smoothsize)\n{\n    float leg = sdSphere(p, legsize);\n    for(int i=0;i<legnum;i++)\n    {\n        vec3 dist = (t - p)*float(i)/float(legnum);\n        leg = opSmoothUnion(leg, sdSphere(p+dist, legsize), smoothsize);\n    }\n    return leg;\n}\n\nvec2 map(vec3 pos)\n{\n    vec2 t = vec2(0.0,0.0);\n    \n    // ground\n    t.x = pos.y;\n    \n    // poto\n    vec3 potop = pos + vec3(2., -0.5, 3.0);\n    potop = opRep(potop, vec3(4.0, 0.0, 6.0));\n    float prep = sdCappedCylinder(potop, .5, .3);\n    float pp = opI(prep, sdBox(pos+vec3(0.0), vec3(7.0, 5.0, 10.0)));\n    vec2 poto = vec2(pp, 1.0);\n    \n    // *****\n    // monster\n    // head\n    vec3 headp = pos + vec3(sin(iTime), -3., -5.0);\n    float randShape = sin(pos.y*10.+iTime)*.05;\n    vec3 headpFX = headp;\n    headpFX.xz += randShape;\n    float head = sdSphere(headpFX, 1.0);\n    // eyes\n    vec3 eyep = headp + vec3(0.5, -0.05, -1.0);\n    eyep.y *= .5;\n    float eye = sdSphere(eyep, .05);\n    eyep = headp + vec3(-0.5, -0.05, -1.0);\n    eyep.y *= .5;\n    eye = opU(eye, sdSphere(eyep, .05));\n    // legs\n    int legpartnumber = 10;\n    float legSize = .1;\n    float legsmoothsize = .55;\n    float leg1 = sdLeg(pos + vec3(2.0, -1.0, -9.0), headp+vec3(.5, .5,-.5), legpartnumber, legSize, legsmoothsize);\n    float leg2 = sdLeg(pos + vec3(-2.0, -1.0, -9.0), headp+vec3(-.5,.5,-.5), legpartnumber, legSize, legsmoothsize);\n    float leg3 = sdLeg(pos + vec3(2.0, -1.0, -3.0), headp+vec3(.5, .5,-.5), legpartnumber, legSize, legsmoothsize);\n    float leg4 = sdLeg(pos + vec3(-2.0, -1.0, -3.0), headp+vec3(-.5,.5,-.5), legpartnumber, legSize, legsmoothsize);\n    \n    vec2 monster = vec2(head, 2.0);\n    vec2 eyes = vec2(eye, 3.0);\n    vec2 legs1 = vec2(leg1, 2.0);\n    vec2 legs2 = vec2(leg2, 2.0);\n    vec2 legs3 = vec2(leg3, 2.0);\n    vec2 legs4 = vec2(leg4, 2.0);\n    \n    // merge\n    t = opU2(t, poto);\n    t = opU2(t, monster);\n    t = opU2(t, eyes);\n    t = opU2(t, legs1);\n    t = opU2(t, legs2);\n    t = opU2(t, legs3);\n    t = opU2(t, legs4);\n    \n    return t;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(float(i)/64., ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = ro+rd*t.x;\n    vec3 col = vec3(0.0);\n    float depth = clamp(pos.z, 0.0, 1.0);\n    depth = 1.0 - sat(pos.z*.1);\n            \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(pos.z);\n        \n    }\n    else\n    {\n        float glp = clamp(length(pos)*.1, 0.0, 1.0);\n        vec3 N = GetNormal(ro+rd*t.x);\n        vec3 L = vec3(1.0, 1.0, 0.0);\n        float light = dot(N,L);\n        \n        if(t.y == 0.0) col = vec3(t.x*1.0);\n        if(t.y == 1.0) col = vec3(t.x*1.4);\n        if(t.y == 2.0) col = vec3(0.0);\n        if(t.y == 3.0) col = vec3(1.0, .25, 0.5);\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cp = vec3(0.0, 2.0, 14.);\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    \n    col = Render(cp, vd, uv);\n    col.x -= (1.0-length(uv))*.5;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsV3RV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsV3Wm", "name": "Fractal Fragments (Julia Set)", "author": "zerovolts", "description": "Mandelbrot + Voronoi + Noise", "tags": ["voronoi", "mandelbrot"], "likes": 2, "viewed": 90, "date": "1570328530", "time_retrieved": "2024-06-20T19:48:00.594707", "image_code": "precision highp float;\n\n#define MAX_ITER 2000\n#define VORONOI_CELL_COUNT 128\n#define PI 3.141592\n#define TAU 6.28318\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Source: https://www.shadertoy.com/view/Ms2SD1\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// Source: https://www.shadertoy.com/view/Ms2SD1\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec2 complex_mul(vec2 c1, vec2 c2) {\n    return vec2(\n        (c1.x * c2.x) - (c1.y * c2.y),\n        (c1.x * c2.y) + (c1.y * c2.x)\n    );\n}\n\n// Returns the number of iterations before escaping above 2, or max_iter.\nint mandelbrot(vec2 coord, int max_iter) {\n    // vec2 z = vec2(0);\n    vec2 z = coord;\n    vec2 c = vec2(.355, .355);\n    for (int i = 0; i < max_iter; i++) {\n        z = complex_mul(z, z) + c;\n        if (length(z) > 2.0) return i;\n    }\n    return max_iter;\n}\n\n// Returns the Voronoi cell index that the point falls in\nint voronoi(vec2 position) {\n    vec2 points[VORONOI_CELL_COUNT];\n    float minDist = 100000.0;\n    int nearestIndex = -1;\n    for (int i = 0; i < VORONOI_CELL_COUNT; i++) {\n        points[i] = random2(vec2(float(i), float(i)));\n        points[i] = 0.5 + 1.0 * sin((iTime / 8.0) + TAU * points[i]);\n        float dist = distance(position, points[i]);\n        if (dist < minDist) {\n            minDist = dist;\n            nearestIndex = i;\n        }\n    }\n    return nearestIndex;\n}\n\nvec2 rotate(vec2 coord, float angle) {\n    float sinFactor = sin(angle);\n    float cosFactor = cos(angle);\n    mat2 rotation = mat2(cosFactor, sinFactor, -sinFactor, cosFactor);\n    return coord * rotation;\n}\n\n// Takes a fragCoord and transforms it into a usable coordinate\nvec2 camera(vec2 fragCoord, vec2 center, float zoom, float angle) {\n    float min_dimension = min(iResolution.x, iResolution.y);\n    vec2 normalized_coord = (fragCoord - 0.5 * iResolution.xy) / min_dimension;\n    return rotate(normalized_coord * zoom, angle) + center;\n}\n\nvec3 subsample(vec2 mandelbrot_coord, vec2 voronoi_coord) {\n    int max_iter = min(int(iTime * 8.0), MAX_ITER);\n    int mandel = mandelbrot(mandelbrot_coord, max_iter);\n    float mandel_norm = float(mandel) / float(max_iter);\n\n    int voronoi_index = voronoi(voronoi_coord);\n    float voronoi_norm = (float(voronoi_index) / float(VORONOI_CELL_COUNT));\n\n    vec3 color;\n    if (mandel < max_iter) {\n        float variance = sin(mandel_norm * TAU * 16.0) / 8.0 + 0.4;\n        color = hsv2rgb(vec3(\n            sin((mandel_norm * TAU / 8.0) + (iTime * TAU / 32.0) + (voronoi_norm * TAU / 16.0)) / 2.0 + 0.5,\n            variance,\n            variance\n        ));\n    } else {\n        float height = 0.0;\n        for (int i = 1; i < 16; i++) {\n            vec2 right_movement = vec2(-iTime / 32.0, 0);\n            height += noise((voronoi_coord + vec2(1, 0) + rotate(right_movement, 0.0)) * float(i) * 32.0) / float(i);\n            height += noise((voronoi_coord + vec2(0, 1) + rotate(right_movement, TAU / 3.0)) * float(i) * 32.0) / float(i);\n            height += noise((voronoi_coord + rotate(right_movement, TAU / 3.0 * 2.0)) * float(i) * 32.0) / float(i);\n        }\n        height /= 2.0;\n        height += 0.5;\n        color = hsv2rgb(vec3(\n            iTime / 16.0 + height / 8.,\n            height / 4.0 + 0.4,\n            height / 4.0 + 0.4\n        ));\n    }\n\n    return color;\n}\n\nmat4x2 split_fragment(vec2 fragCoord) {\n    float distToCenter = 0.25;\n    return mat4x2(\n        vec2(fragCoord.x - distToCenter, fragCoord.y - distToCenter),\n        vec2(fragCoord.x + distToCenter, fragCoord.y + distToCenter),\n        vec2(fragCoord.x + distToCenter, fragCoord.y - distToCenter),\n        vec2(fragCoord.x - distToCenter, fragCoord.y + distToCenter)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    mat4x2 subsamples = split_fragment(fragCoord);\n\n    // vec2 mandelbrot_center = vec2(-1.483, 0);\n    // vec2 mandelbrot_center = vec2(-0.09, 0.650004);\n    vec2 mandelbrot_center = vec2(-0.091069, 0.65899);\n    float mandelbrot_zoom = (8.0 / float(pow(1.5, iTime / 2.0)));\n    float mandelbrot_angle = 0.;//iTime / 8.0;\n    mat4x2 mandelbrot_coords = mat4x2(\n        camera(subsamples[0], mandelbrot_center, mandelbrot_zoom, mandelbrot_angle),\n        camera(subsamples[1], mandelbrot_center, mandelbrot_zoom, mandelbrot_angle),\n        camera(subsamples[2], mandelbrot_center, mandelbrot_zoom, mandelbrot_angle),\n        camera(subsamples[3], mandelbrot_center, mandelbrot_zoom, mandelbrot_angle)\n    );\n\n    vec2 voronoi_center = vec2(0.5);\n    float voronoi_zoom = 1.0;\n    float voronoi_angle = iTime / -16.0;\n    mat4x2 voronoi_coords = mat4x2(\n        camera(subsamples[0], voronoi_center, voronoi_zoom, voronoi_angle),\n        camera(subsamples[1], voronoi_center, voronoi_zoom, voronoi_angle),\n        camera(subsamples[2], voronoi_center, voronoi_zoom, voronoi_angle),\n        camera(subsamples[3], voronoi_center, voronoi_zoom, voronoi_angle)\n    );\n\n    // Uncomment to apply anti-aliasing\n    vec3 col = vec3(0);\n    col += subsample(mandelbrot_coords[0], voronoi_coords[0]);\n    //col += subsample(mandelbrot_coords[1], voronoi_coords[1]);\n    //col += subsample(mandelbrot_coords[2], voronoi_coords[2]);\n    //col += subsample(mandelbrot_coords[3], voronoi_coords[3]);\n    //col /= 4.;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsV3Wm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsV3Wt", "name": "Dancing pixels 2", "author": "pik33", "description": "Experiment with coefficients of \"Dancing pixel\" shader https://www.shadertoy.com/view/ldX3Wn ", "tags": ["plasma", "sinepuke"], "likes": 15, "viewed": 287, "date": "1571213121", "time_retrieved": "2024-06-20T19:48:00.594707", "image_code": "// modification of https://www.shadertoy.com/view/ldX3Wn\n\nconst float Pi = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\t\n\tfor(int i=1;i<45;i++)\n\t{\n\t\tvec2 newp=p;\n\t\tnewp.x+=(0.5/float(i))*cos(float(i)*p.y+iTime*11.0/37.0+0.03*float(i))+1.3;\t\t\n\t\tnewp.y+=(0.5/float(i))*cos(float(i)*p.x+iTime*17.0/41.0+0.03*float(i+10))+1.9;\n\t\tp=newp;\n\t}\n\n\tvec3 col=vec3(0.5*sin(3.0*p.x)+0.5,0.5*sin(3.0*p.y)+0.5,sin(1.3*p.x+1.7*p.y));\n\tfragColor=vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsV3Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsV3zz", "name": "FBM Scaling", "author": "iq", "description": "Shows the anisotropic self-similarity of Brownian Motion on the left and the isotropic self-similarity of Fractional Brownian Motion with gain=0.5. More info: [url]http://iquilezles.org/www/articles/fbm/fbm.htm[/url]", "tags": ["2d", "fbm", "selfsimilarity", "hurst"], "likes": 23, "viewed": 1652, "date": "1569889264", "time_retrieved": "2024-06-20T19:48:01.461462", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime + 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA);\n\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/WsV3zz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVGD1", "name": "Rotating flowers", "author": "Sophotec", "description": "Use key 1 2 3 to stack the color layers\nIt looks like the blue flower is at the back. (optical illusion ?)\n", "tags": ["flower", "polar"], "likes": 8, "viewed": 118, "date": "1571421391", "time_retrieved": "2024-06-20T19:48:01.746460", "image_code": "// --- key toggles -----------------------------------------------------\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n// Modifiers: SHIFT: 16 CTRL: 17 ALT: 18  \n// Advice:  Mode: keyToggle(key)  Action: keydown(key)+keyclick(modifier)\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n \n#define lim .3\n \nfloat flower(vec2 uv ,float petals, float speed , float size ) {\n    vec2 st= vec2(atan(uv.x, uv.y), length(uv));\n    uv= vec2(st.x/6.2831 +.5 + iTime * speed, st.y);\n    float x=uv.x * petals;\n    float m= min(fract(x), fract(1.-x));\n                return smoothstep(0., .15,m*size + .2 - uv.y);                 \n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) /iResolution.y;\n \n    float cr=flower(uv, 8., .05, .50);\n    float cg=flower(uv, 7., .1, .60);\n    float cb=flower(uv, 6., .15, .8);\n \n    if (keyClick(49)) {\n        if (cr>lim) { cg=0.; cb=0.; }\n        else {\n            if(cg>lim) cb=0.; \n        }\n                    fragColor = vec4(cr,cg,cb,0.);\n    }\n    else if (keyClick(50)) {\n        if (cg>lim) { cr=0.; cb=0.; }\n        else {\n            if(cr>lim) cb=0.; \n        }\n                    fragColor = vec4(cr,cg,cb,0.);\n    }\n    else if (keyClick(51)) {\n        if (cb>lim) { cr=0.; cg=0.; }\n        else {\n            if(cg>lim) cr=0.; \n        }\n                    fragColor = vec4(cr,cg,cb,0.);\n    }\n    else {\n                    fragColor = vec4(cr,cg,cb,0.);\n    }\n    \n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVGD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVGDc", "name": "Blurred SDF AO", "author": "TekF", "description": "Following on from my [url=https://www.shadertoy.com/view/Wdd3Rl]cone-traced AO[/url], I wanted a cheaper AO solution for using in general scenes. This one samples the SDF at points distributed on a hemisphere and at a logarithmic range of distances.", "tags": ["sdf", "lighting", "ao", "ambientocclusion"], "likes": 19, "viewed": 659, "date": "1571266966", "time_retrieved": "2024-06-20T19:48:02.976863", "image_code": "#define AO_SAMPLES 50\n\n// comment/uncomment these to turn different effects on/off\n//#define LIGHTS\n#define AMBIENT_LIGHT\n//#define COLOURISE_AMBIENT\n\n// hide the errors of low sample counts by varying them per-pixel\n//#define DITHER\n\nconst float phi = 1.6180339887498948;\nconst float tau = 6.2831853071795865;\n\nuvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\nuvec3 quasi3 = uvec3( 3518319155, 2882110345, 2360945575 );\n\nfloat sdf( vec3 p )\n{\n    return\n        min(min(min(min(min(\n        \tmax(max(max(\n                length(p)-1.,\n                .3 - length((p-vec3(.5,0,0)).xz)),\n                .3 - length((p-vec3(-.25,0,-.5)).xz)),\n                dot(p,normalize(vec3(-1,0,-2)))-.4 + .003*sin(p.y*100.)\n            ),\n            max(max(\n                length(p-vec3(0,-.5,1.2))-.5,\n                .45-length(p-vec3(0,-.5,1.2))),\n                dot(p-vec3(0,-.5,1.2),normalize(vec3(1,2,-3)))\n            )),\n            length(p-vec3(0,-.5,1.2))-.3),\n\t\t\tmax(\n                length(p.xz)-.5,\n                p.y+.9\n            )),\n            max(\n                length((p-vec3(-.25,0,-.5)).xz) - .22,\n                dot(p,normalize(vec3(-1,4,-2)))-.95\n            )),\n            p.y + 1.\n        );\n}\n\n\nfloat OcclusionTrace( vec3 pos, vec3 target, float rpert )\n{\n    // higher quality setting, better for direct lights\n    const int maxSteps = 150; const float stepSize = .5;\n    \n    vec3 toTarget = target-pos;\n    float end = length(toTarget);\n    vec3 ray = toTarget/end;\n    float t = .05;\n    float visibility = 1.;\n    for ( int i=0; i < maxSteps; i++ )\n    {\n        float h = sdf( ray*t+pos );\n        if ( t >= end ) break;\n        float r = rpert*t;\n        visibility = min( visibility, smoothstep( -r, r, h ) );\n        if ( visibility <= 0. ) break;\n        t += (h+r) * stepSize;\n    }\n\treturn visibility;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 _fragCoord )\n{\n    uint seed = uint(_fragCoord.x)*quasi2.x\n        \t\t+ uint(_fragCoord.y)*quasi2.y;\n#ifndef DITHER\n    seed = 0x80000000u;\n#endif\n    vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n    vec2 fragCoord = _fragCoord + jitter;\n    \n    vec3 ray = vec3( (fragCoord-iResolution.xy*.5)/sqrt(iResolution.x*iResolution.y), 2 );\n    \n    vec3 camPos = vec3( 0, 0, -8. );\n    vec2 a = vec2(.3,iTime*.3);//-1.5);//\n    vec2 d = vec2(-1,1);\n    camPos.yz = camPos.yz*cos(a.x) + camPos.zy*d.xy*sin(a.x);\n    camPos.zx = camPos.zx*cos(a.y) + camPos.xz*d.xy*sin(a.y);\n    \n    vec3 camTarget = vec3(0);\n    \n    vec3 camK = normalize(camTarget - camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    ray = normalize( ray );\n    \n    float t = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n        float h = sdf(ray*t + camPos);\n        t += h;\n        if ( h < .001 )\n        {\n            break;\n        }\n    }\n    \n    vec3 pos = ray*t+camPos;\n    \n    d *= .001;\n    vec3 normal =\n        normalize(\n            sdf(pos+d.xxx)*d.xxx +\n            sdf(pos+d.yyx)*d.yyx +\n            sdf(pos+d.yxy)*d.yxy +\n            sdf(pos+d.xyy)*d.xyy\n        );\n    \n    struct Light\n    {\n        vec3 pos;\n        vec3 col;\n    };\n    \n    Light lights[] = Light[]\n        (\n            //Light( vec3(4,8,-6), vec3(50) ),\n            //Light( vec3(.7,-.7,0), vec3(5,0,0) ) // shows multiple bugs with the shadow tech - all fixed by increasing loop limit on shadow test!\n            /*Light( vec3(4,8,-6), vec3(50,0,0) ),\n            Light( vec3(4,8,-5), vec3(0,50,0) ),\n            Light( vec3(4,8,-4), vec3(0,0,50) )*/\n            Light( vec3(.5,0,2), vec3(0,1,0) ),\n            Light( vec3(2,-.5,.5), vec3(1,.3,0) ),\n            Light( vec3(1,.5,-1.2), vec3(1,0,0) ),\n            Light( vec3(-.25,-.5,-1), vec3(1,0,.7)*.2 ),\n            Light( vec3(-1,1,.5), vec3(0,.2,1)*2. )\n        );\n    \n    fragColour.rgb = vec3(0);\n    \n    for ( int i=0; i < lights.length(); i++ )\n    {\n        vec3 toLight = lights[i].pos - pos;\n        float lightStrength = max(0.,dot(normal,normalize(toLight)));\n        lightStrength /= dot(toLight,toLight);\n        lightStrength *= OcclusionTrace( pos, lights[i].pos, .05 );\n#ifdef LIGHTS\n    \tfragColour.rgb += lights[i].col*lightStrength;\n#endif\n    }\n    \n    \n    \n    // sample SDF at various points to give a blurred version of scene, and divide by expected value if we're flat\n    // i.e. it's both a blur and a bunch of actual samples\n//    float ao = min(0.,sdf( pos+normal*.3 )/.3)+1.;\n    \n    vec3 ambient = vec3(0);\n    float weightSum = 0.;\n    for ( int i=0; i < AO_SAMPLES; i++ )\n    {\n        vec3 rand = vec3(quasi3*(uint(i)+seed))/exp2(32.);\n        \n        // distribute randomly on hemisphere\n        // n.b. I adapted this technique from somewhere but can't recall where\n        // uniformly distribute on unit cylinder about z\n        vec3 tap = vec3( cos(rand.x*tau), sin(rand.x*tau), rand.y*2.-1. );\n        // project radially inward onto sphere - this gives uniform distribution of samples\n        tap.xy *= sqrt(1.-tap.z*tap.z);\n        // project perpendicular to normal onto a curved-cone pointing along normal\n        float sdn = dot(tap,normal);\n        float l = .5+.5*sdn;\n        // ignore the height along the cone - so we get a disc (perpendicular to normal)\n        // curve the cone (sqrt) so distribution is uniform on disc\n        tap = normalize(tap-sdn*normal)*sqrt(l); // there's a faster way to do that normalize\n        // project along normal onto hemisphere\n        tap += normal*sqrt(1.-l);\n        \n        // randomize the distance of the sample\n        float dist = rand.z;//(float(i)+float(seed)/exp2(32.))/float(AO_SAMPLES);//\n        tap *= exp2( mix( -5., 3., dist ) ); // interesting how this trades big vs small details\n        \n//I want this to be a min AND an average, hmm...\n/*yeah, I want it to approximate occlusion in this direction, and min with other samples that approximate in this direction\nbut add to ones in other directions\nand I want to do that without paying attention to direction\n=> ignore the direction and just average the samples\nor, have a factor for how much to treat the samples as exclusive\nwhat about something logarithmic, so it sort of works like a min and an add?\n\npreferably fading confidence of samples with distance, so close ones definitely occlude, more distant ones nudge the average by less\nn.b. could do 2D rand and start close\n*/\n//        float aotap = clamp( sdf( pos+tap )/dot(tap,normal) + 1., .001, 1. );\n        //ao = min( ao, aotap );\n//        ao += log2(aotap) * 2.*(1.-dist);\n        \n\t\t// take full occlusion as the norm, then add on points which defy that\n\n        float weight = 1.;\n        float ao = clamp( sdf( pos+tap )/dot(tap,normal),\n                        0., // pushing this below 0 darkens shadows\n                        1.3 // amp them up if they're very positive! - this gives a fake drybrushing effect that I quite like\n                       );\n\n#ifdef COLOURISE_AMBIENT\n\t    vec3 ambientColour = mix( vec3(1,.3,0), vec3(0,.3,1), normalize(tap).x*.5+.5 );\n#else\n    \tvec3 ambientColour = vec3(.7);\n#endif\n        \n        ambient += ao*ambientColour;\n\n        weightSum += weight;\n    }\n    ambient /= weightSum;\n    \n    \n    \n#ifdef AMBIENT_LIGHT\n    fragColour.rgb += ambient;\n#endif\n\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    \n//    fragColour.rgb = sin(fragColour.rgb*6.-1.+iTime*.3)*.5+.5; // AWESOME\n    \n    fragColour.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVGDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVGDV", "name": "Barycentric vs. Quad", "author": "hanfling", "description": "Showcases artifacts for vertex colors on triangles versus linear interpolation on quad.", "tags": ["barycentric", "interpolation"], "likes": 1, "viewed": 129, "date": "1570995660", "time_retrieved": "2024-06-20T19:48:02.976863", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 Colors[4];\n    \n    Colors[0] = vec4(1.0,0.0,0.0,1.0);\n    Colors[1] = vec4(0.0,1.0,0.0,1.0);\n    Colors[2] = vec4(0.0,0.0,1.0,1.0);\n    Colors[3] = vec4(1.0,0.5,0.0,1.0);\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 UV = fragCoord/iResolution.xy;\n    UV.t = 1.0-UV.t;\n    \n    vec4 LinearResult = mix(mix(Colors[0],Colors[1],UV.s),mix(Colors[2],Colors[3],UV.s),UV.t);\n    vec4 BarycentricResult;\n    \n    if ( (1.0-UV.s)>UV.t )\n    {\n        float Areas[3];\n        Areas[0] = 0.5*length(cross(vec3(1.0,0.0,0.0),vec3(UV,0.0)));\n        Areas[1] = 0.5*length(cross(vec3(0.0,1.0,0.0),vec3(UV,0.0)));\n        Areas[2] = 0.5-Areas[0]-Areas[1];\n\n        float Weights[3];       \n        Weights[0] = Areas[0]/0.5;\n        Weights[1] = Areas[1]/0.5;\n        Weights[2] = Areas[2]/0.5;\n\n    \tBarycentricResult = Weights[0]*Colors[2]+Weights[1]*Colors[1]+Weights[2]*Colors[0];\n    }\n    else\n    {\n        float Areas[3];\n        Areas[0] = 0.5*length(cross(vec3(1.0,0.0,0.0),vec3(vec2(1.0)-UV,0.0)));\n        Areas[1] = 0.5*length(cross(vec3(0.0,1.0,0.0),vec3(vec2(1.0)-UV,0.0)));\n        Areas[2] = 0.5-Areas[0]-Areas[1];\n\n        float Weights[3];       \n        Weights[0] = Areas[0]/0.5;\n        Weights[1] = Areas[1]/0.5;\n        Weights[2] = Areas[2]/0.5;\n\n    \tBarycentricResult = Weights[0]*Colors[1]+Weights[1]*Colors[2]+Weights[2]*Colors[3];\n    }\n\n    fragColor = mix(LinearResult,BarycentricResult,pow(0.5+0.5*cos(2.0*iTime),4.0));\n    //fragColor = BarycentricResult;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVGDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVGWm", "name": "Abstract moving blobs", "author": "papad", "description": "Bunch of moving blobs in space to try out ray marching.", "tags": ["raymarch", "infinity"], "likes": 3, "viewed": 106, "date": "1570377790", "time_retrieved": "2024-06-20T19:48:02.976863", "image_code": "#define MAX_MARCH_STEPS 100\n#define MAX_MARCH_DIST 120.\n#define D_SURF_DIST 0.001\n\nfloat df_movingBlob(vec3 point, vec4 sphere)\n{\n    float m = 3.0;\n    point = mod(point, m) - 0.5*m;\n\treturn 0.06*sin((point.x+iTime*0.51)*15.)+length(point - sphere.xyz) - sphere.w;\n}\n\nfloat getDist(vec3 point)\n{\n    vec4 sphere = vec4(0.,0.,1.5,.5); // w component is the radius.\n    float sphereDist = df_movingBlob(point,sphere);\n    return sphereDist;\n}\n\nvec3 getNormalAtPoint( in vec3 p )\n{\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(getDist(p+h.xyy) - getDist(p-h.xyy),\n                           getDist(p+h.yxy) - getDist(p-h.yxy),\n                           getDist(p+h.yyx) - getDist(p-h.yyx) ) );\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection, out int steps)\n{\n    float d0=0.;\n    steps = MAX_MARCH_STEPS;\n\tfor(int i=0; i < MAX_MARCH_STEPS; ++i)\n    {\n        vec3 currPos = rayOrigin + rayDirection*d0;\n        float dist = getDist(currPos);\n        d0+=dist;\n        if(d0 > 10. + abs(120.*sin(iTime*.5)) || dist < D_SURF_DIST)\n        {\n            steps = i;\n            break;\n        }\n    }\n    return d0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.x)/iResolution.y;\n\n    vec3 camPos = vec3(sin(iTime*2.5),cos(iTime*1.5),iTime*4.4);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1));\n    \n    int steps;\n    float distanceToScene = rayMarch(camPos, rayDir, steps);\n    \n    vec3 p = camPos + rayDir * distanceToScene;\n    float dli = float(steps)/float(MAX_MARCH_STEPS);\n    vec3 col = vec3(0,dli,dli);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVGWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVGWw", "name": "Pepelatz warping", "author": "StrangerintheQ", "description": "https://www.youtube.com/watch?v=4d34j56ERU8\n\nhttps://codepen.io/strangerintheq/pen/YzzzpOy", "tags": ["raymarching"], "likes": 10, "viewed": 188, "date": "1570353383", "time_retrieved": "2024-06-20T19:48:02.982724", "image_code": "\nconst vec3 lightPos  = vec3(0.,4.,-4.);\n\n\nvec3 palette(float i) {\n    float time = iTime;\n    float T = 1400. + 1300.*i; \n    vec3 L = vec3(4.4, 5.6 + sin(time)/2., 6.4 + sin(time/2.)); \n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L); \n}    \n\nvec3 hash33(vec3 p) { \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat voronoi(vec3 p) {\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); \n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\t\n\t    }\n\t}\n\treturn d;\n}\n\nfloat noiseLayers(in vec3 p) {\n        float time = iTime;\n    vec3 t = vec3(0., 0., p.z+time*1.7); \n    float tot = 0., sum = 0., amp = 1.; \n    for (int i = 0; i < 11; i++) {\n        tot += voronoi(p + t) * amp; \n        p *= 2.0; \n        t *= 1.5; \n        sum += amp; \n        amp *= 0.5; \n    }\n    return tot/sum; \n}\n  \n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat dot2( in vec2 v ) { \n  return dot(v,v); \n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 ){\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 repeatAng(vec2 p, float n) {\n    float ang = 2.0*3.14/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    return rotate(p, sector*ang);\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat spikes(vec3 p, float r, float count) {\n    p.xz = repeatAng(p.xz, count);\n    return sdCappedCone(p - vec3(0., 1.27, r), .07, .06, .01);\n}\n\nfloat legs(vec3 p) {\n    p.xz = repeatAng(p.xz, 3.);\n    return sdBox(p+vec3(0., 1.03, -1.05), vec3(.16,.2,.15));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h ) {\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec2 map(vec3 p) {\n     float time = iTime;\n // pepelatz body\n    float d = sdCappedCone(p, 1.2, 1.2, 1.);\n    d = smin(d, legs(p), 0.01);\n    d = smin(d, sdCappedCone(p+vec3(0.,-1.35,0.), .16, .2, .187), 0.01);\n    \n    // door\n    vec3 pd = vec3(p.x,rotate(p.yz, -0.08));\n    d = smin(d, sdBox(pd+vec3(.0, 0.2, 1.), vec3(0.34,.7,.08)), 0.03);\n    vec3 pd1 = vec3(p.x,rotate(p.yz, 1.57));\n    d = smin(d, sdCappedCone(pd1 + vec3(0.,-1.,-0.3), .09, .15, .15), 0.1);\n    d = max(d, -sdCappedCone(pd1 + vec3(0.,-1.,-0.3), .12, .13, .13));\n    d = smin(d, sdCappedCone(pd+vec3(-0.1,0.9,1.1), .16, .02, .02), 0.02);\n    d = smin(d, sdCappedCone(pd+vec3( 0.0,0.9,1.1), .16, .02, .02), 0.02);\n    d = smin(d, sdCappedCone(pd+vec3( 0.1,0.9,1.1), .16, .02, .02), 0.02);\n      \n    // roof spikes\n    d = smin(d, spikes(p,0.94,50.), 0.01);\n    d = smin(d, spikes(p,0.80,45.), 0.01);\n    d = smin(d, spikes(p,0.65,35.), 0.01);\n    d = smin(d, spikes(p,0.45,25.), 0.01);\n\n    // antenna\n    vec2 r = rotate(p.xz, time*3.);\n    vec3 pa = vec3(r.x, p.y-1.55, r.y);\n    vec3 pa1 = vec3(pa.x,rotate(pa.yz, 1.57));\n    pa1.z -= 0.2;\n    d = smin(d, sdBox(pa, vec3(0.01,.1,.1)), 0.01);\n    d = smin(d, sdBox(pa, vec3(0.1,.01,.7)), 0.01);\n    d = smin(d, sdCappedCone(pa1-vec3(0.,0.05,0.), .2, .1, .1), 0.1);\n    d = max(d, -sdCappedCone(pa1, .30, .09, .09));\n    d = max(d, -sdBox(pa1-vec3(-0.08,0.,-0.1), vec3(0.08,.3,.09)));  \n\n\n\n    return vec2(d, 2.5);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size) {\n    vec2 xy = gl_FragCoord.xy - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvec2 castRay( vec3 ro, vec3 rd ) {\n    float tmin = 1.0;\n    float tmax = 32.0;\n    float t = tmin;\n    float m = -1.0;\n    for ( int i=0; i<64; i++ ) {\n\t    float precis = 0.0001*t;\n\t    vec2 res = map( ro+rd*t );\n        if ( res.x<precis || t>tmax )\n            break;\n        t += res.x;\n\t    m = res.y;\n    }\n    if ( t>tmax )\n        m=-1.0;\n    return vec2( t, m );\n}\n\nconst float NORMAL_EPSILON = 0.0005;\n\nvec3 estimateNormal(vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*NORMAL_EPSILON;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nconst vec3 K_a = vec3(.5, .5, .5);\nconst vec3 K_d = vec3(.5, .5, .5);\nconst vec3 K_s = vec3(.0, .0, .0);\n\nconst float shininess = 3.5;\nconst vec3 lightIntensity = vec3(1., 1., 1.);\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, \n                          vec3 p, vec3 N, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    if (dotLN < 0.0) \n        return vec3(0.0, 0.0, 0.0);\n    if (dotRV < 0.0) \n        return lightIntensity * (k_d * dotLN);\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, \n                       float alpha, vec3 p, vec3 nor, \n                       vec3 eye, vec3 materialColor) {\n    vec3 color = materialColor * k_a;\n    color += phongContribForLight(k_d, k_s, alpha, p, nor, eye, \n                                  lightPos, lightIntensity);\n    return color;\n}\n\nvec3 decodeMaterial(float m) {\n    return vec3(1.-m/3.);\n}\n\nvec3 phong(vec3 p, vec3 nor, vec3 eye, float material) {\n    vec3 materialColor = decodeMaterial(material);\n    return phongIllumination(K_a, K_d, K_s, shininess, p, nor, eye, materialColor);\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ){\n\t  float res = 1.0;\n    float t = mint;\n    for( int i=0; i!=16; i++ ) {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat ao( vec3 pos, vec3 nor ){\n\t  float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i!=5; i++ ){\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat fbm( vec3 p, vec3 n )\n{\n\tp *= 0.25;\n\tfloat x = noise(  p.yz );\n\tfloat y = noise(  p.zx );\n\tfloat z = noise(  p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor ){\n    float e = 0.0015;\n    float b = 0.01;\n    \n\tfloat ref = fbm( 28.0*pos, nor );\n    vec3 gra = -b*vec3( fbm(28.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,\n                        fbm(28.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,\n                        fbm(28.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize ( nor - tgrad );\n}\n\n\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float time = iTime;\n    float r = sin(time)*7. + 15.;\n    vec3 eye = vec3(sin(time)*r,5.,cos(time)*r);\n\tvec3 lookAt = vec3(0.,2.,0.);\n\n\tvec3 direction = rayDirection(60.0, iResolution.xy);\n    mat4 viewToWorld = viewMatrix(eye, lookAt, vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(direction, 0.0)).xyz;\n    vec2 dist = castRay(eye, worldDir);\n    if (dist.x > 32.) {\n        vec2 uv = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n        uv += vec2(sin(time/7.)*0.1,cos(time/3.)*0.15);\n    float cs = cos(time/5.0), \n        si = sin(time/2.0);\n    uv.xy *= mat2(cs, -si, si, cs); \n        vec3 rd = normalize(vec3(uv.x, uv.y, 3.1415/(75.+sin(time)*32. + cos(time*10.)*3.)));\n        float d = noiseLayers(rd*2.);\n        fragColor = vec4(sqrt(palette(d)), 1.); \n        fragColor /= sqrt(sqrt(dot(uv, uv)));\n    } else {\n        vec3 pt = eye + dist.x * worldDir;\n        vec3 nor = estimateNormal( pt );\n          nor = doBumpMap(pt, nor);\n        float occ = ao( pt, nor );\n        float shadow = softShadow( pt, normalize(lightPos-pt), 0.1, 22.2);\n        vec3 color = phong(pt, nor, eye, dist.y)*sqrt(occ);\n        color += color * shadow;\n        fragColor = vec4(color, 1.0);\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVGWy", "name": "Hexagon Grid Pattern", "author": "Shane", "description": "A simple hexagonal grid pattern.", "tags": ["2d", "grid", "hexagon", "pattern", "art"], "likes": 20, "viewed": 1073, "date": "1570977852", "time_retrieved": "2024-06-20T19:48:03.995127", "image_code": "/*\n\n\tHexagon Grid Pattern\n\t--------------------\n\n    I see variations on this particular pattern all over the place, and it's pretty\n\teasy to make, so I figured I'd recreate one. If it's not obvious, the idea is to\n\tpartition space into hexagonal cells, then render six smaller overlapping hexagons \n\tin each of the cell's six corners. Commenting in the \"SHOW_GRID\" define should \n    make it more clear. \n\n\tOn a side note, there are countless other interesting hexagonal stock imagery \n    patterns on the internet that I'd love to see on Shadertoy, if anyone feels like \n\tmaking any. :)\n\n\t\n    Other Hexagonal Pattern Examples:\n\n\n\tShadertober Day 10 - Pattern -- BackwardsCap\n\thttps://www.shadertoy.com/view/tsV3Rd\n\n    Hexagon Pattern -- plabatut \n\thttps://www.shadertoy.com/view/Wdt3WN\n\n    Impossible Chainmail -- BigWIngs \n    https://www.shadertoy.com/view/td23zV\n\n*/\n\n//#define SHOW_GRID\n\n#define FLAT_TOP\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.617, 57.743)))*43758.5453); }\n\n\n// Flat top hexagon, or pointed top.\n#ifdef FLAT_TOP\nconst vec2 s = vec2(1.732, 1);\n#else\nconst vec2 s = vec2(1, 1.732);\n#endif\n\n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n    \n    // Flat top and pointed top hexagons.\n    #ifdef FLAT_TOP\n    return max(dot(abs(p.xy), s/2.), abs(p.y*s.y));\n    #else   \n    return max(dot(abs(p.xy), s/2.), abs(p.x*s.x));\n    #endif\n}\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n    \n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n    //return getHex(q.xy)<getHex(q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float res = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/res;\n    \n    // Scaling and translation.\n    const float sc = 3.;\n    vec2 p = uv*sc - vec2(-1, -.5)*iTime/2.;\n    \n    // Smoothing factor.\n    float sf = 1./res*sc;\n    \n    \n    // Hexagonal grid coordinates.\n    vec4 p4 = getGrid(p);\n    \n    \n    // Hexagon vertex IDs. They're useful for neighboring edge comparisons, etc.\n    // Multiplying them by \"s\" gives the actual vertex postion.\n    #ifdef FLAT_TOP\n    // Vertices: Clockwise from the left.\n\n\tvec2[6] vID = vec2[6](vec2(-1./3., 0), vec2(-1./6., .5), vec2(1./6., .5), \n                          vec2(1./3., 0), vec2(1./6., -.5), vec2(-1./6., -.5)); \n    \n    //vec2[6] eID = vec2[6](vec2(-.25, .25), vec2(0, .5), vec2(.25, .25), \n                         // vec2(.25, -.25), vec2(0, -.5), vec2(-.25, -.25));\n    \n    #else\n    // Vertices: Clockwise from the bottom left. -- Basically, the ones \n    // above rotated anticlockwise. :)\n    vec2[6] vID = vec2[6](vec2(-.5, -1./6.), vec2(-.5, 1./6.), vec2(0, 1./3.), \n                          vec2(.5, 1./6.), vec2(.5, -1./6.), vec2(0, -1./3.));\n     \n    //vec2[6] eID = vec2[6](vec2(-.5, 0), vec2(-.25, .25), vec2(.25, .25), vec2(.5, 0), \n                          //vec2(.25, -.25), vec2(-.25, -.25));\n \n    #endif\n\n   \n    // The scene color.\n    vec3 col = vec3(1);\n\n    \n    // Rendering the six overlapping hexagons within each cell.\n    for(int i = 0; i<6; i++){\n        \n  \n        // Corner hexagon.\n        vec2 q = abs(p4.xy - vID[5-i]*s*.5);\n        float hx = getHex(q) - .265;\n        float oHx = hx;\n\n        // Using the neighboring hexagon to chop out one third. This way, the final\n        // hexagon will look like it's tucked in behind the previous one... Comment\n        // out the third (hx) line to see what I mean. By the way, you don't have to\n        // do this, but I prefer this particular look.\n        q = abs(p4.xy - vID[(5-i + 5)%6]*s/2.);\n        float hx2 = getHex(q) - .27;\n        hx = max(hx, -hx2);\n\n        // Using the triangle wave formula to render some concentric lines on each\n        // hexagon.\n        float pat = (1. - abs(fract(oHx*16. + .2) - .5)*2.) - .55;\n        pat = smoothstep(0., .2, pat);\n        \n        // Rendering the chopped out hexagon and a smaller white center.\n        col = mix(col, vec3(1)*pat, 1. - smoothstep(0., sf, hx));  \n        col = mix(col, vec3(1), 1. - smoothstep(0., sf, max(oHx + .22, -hx2)));\n        // A colorful center, if preferred.\n        //col = mix(col, vec3(1, .05, .1), 1. - smoothstep(0., sf, max(oHx + .22, -hx2))); \n        \n        // Applying a shadow behind the hexagon. I thought it added more visual interest, \n        // but for something like wallpaper, or whatever, you could comment it out.\n        vec3 sh = mix(col, vec3(0), (1. - smoothstep(0., sf, hx)));\n        col = mix(col, sh, (1. - smoothstep(0., sf*8., max(max(hx, hx2), - hx2)))*.5);\n\n    }\n    \n        \n    // Rendering the grid boundaries, or just some black hexagons in the center.\n    float gHx = getHex(p4.xy);\n    \n    #ifdef SHOW_GRID \n    // Grid lines.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(gHx - .5) - .035));  \n    col = mix(col, vec3(1, .05, .1)*1.5, 1. - smoothstep(0., sf, abs(gHx - .5) - .0075));  \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., gHx - .02 - .025))*.5);\n    // Colored center hexagon.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, gHx - .02 - .025));   \n    col = mix(col, vec3(1, .05, .2), 1. - smoothstep(0., sf, gHx - .015));   \n    #else\n    // Small shadowed center hexagon.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., gHx - .02))*.5);   \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, gHx - .02));  \n    #endif\n    \n    // Vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVGWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVGz3", "name": "Not what I was trying to make", "author": "wutzhuhn", "description": "Made this while checking my coordinates and it looked neat, so I guess I'll keep it", "tags": ["2d", "color"], "likes": 5, "viewed": 82, "date": "1570692782", "time_retrieved": "2024-06-20T19:48:03.995127", "image_code": "float lengthSq(vec2 v)\n{\n    return dot(v, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / vec2(min(iResolution.x, iResolution.y)) * 2.;\n\n    vec2 a = vec2(-.5, sin(iTime * .3));\n    vec2 b = vec2(0. , sin(iTime * .5));\n    vec2 c = vec2( .5, sin(iTime * .7));\n    \n    vec3 col = vec3(lengthSq(a - uv),\n                    lengthSq(b - uv),\n                    lengthSq(c - uv));\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVGz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVGzt", "name": "Interactive Wormhole", "author": "shadeThrower", "description": "Interactive, click and drag mouse horizontally to adjust flight speed, vertically to adjust tunnel complexity. (Just tap and don't drag if on mobile)", "tags": ["mouse", "interactive", "infinity"], "likes": 2, "viewed": 363, "date": "1570757333", "time_retrieved": "2024-06-20T19:48:04.316167", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tme = iTime*.3;\n    float scale = 0.125;\n   \n    vec2 adjVec = vec2((sin(tme)*.5), (cos(tme)*.5));\n    vec2 uv = fragCoord/iResolution.xy;    \n    vec2 uvM;\n    float posMod;\n    float normX;\n    float normY;\n\n    //INTERACTIVE: Mouse X controls flight speed, Mouse Y controls depth\n    if(iMouse.y>0. || iMouse.x>0.){\n    \tnormX = ((iMouse.x)-1.)/iResolution.x;\n    \tnormY = ((iMouse.y)-1.)/iResolution.y;\n    }\n    else{\n        normX = 0.2;\n        normY = 0.2;\n    }\n    float zoomMult = pow(max(normY,0.001)*5., .5);\n    float posModGradA;\n    float posModGradB;\n    posModGradA = (cos(tme*1.1)*.9 + .1)/2.+.5;\n    posModGradB = (cos(tme*.9)*.9 + .1)/2.+.5;\n    //uv = vec2(pow((uv.x-.5)*length(normalize(uv-0.5))*5., -.05)*posMod, pow((uv.y-.5)*length(normalize(uv-0.5))*5., -.05)*posMod);\n    //uv = vec2(pow((uv.x-.5)*length(uv-0.5)*5., -.07)*posMod*2., pow((uv.y-.5)*length(uv-0.5)*5., -.07)*posMod*2.);\n    uv = vec2(pow(abs(uv.x-.5)+length(uv-.5), -.07)*zoomMult*2., pow(abs(uv.y-.5)+length(uv-.5), -.07)*zoomMult*2.);\n    uvM = mod(uv+fract((tme)*normX)*5.*(normY*.75+.25), scale);\n\n    uv = normalize(uvM-vec2(scale/2.))*(adjVec+vec2(.5));\n\n    if(mod(floor((uv.x)/scale),2.) == 0.)\n            uvM.x = scale - uvM.x;\n    if(mod(floor((uv.y)/scale),2.) == 0.)\n            uvM.y = scale - uvM.y;\n\n    uvM += adjVec*length(uvM + adjVec - vec2(0.5));\n\n    // Time varying pixel color\n    /*vec3 col = vec3(0.5 + 0.5*tan((cos(tme)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.)))),\n                    0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.)))),\n                    0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*(uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))));*/\n\n    // With uvM and uv gradients\n    vec3 col = vec3(0.5 + 0.5*tan((cos(tme)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(((cos(length(uv*posModGradA*100.))*.4+.6)+(cos(length(uvM*posModGradB*100.))*.4+.6))/2.),\n                    0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(((cos(length(uv*posModGradA*100.))*.4+.6)+(cos(length(uvM*posModGradB*100.))*.4+.6))/2.),\n                    0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*(uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))))*(((cos(length(uv*posModGradA*100.))*.4+.6)+(cos(length(uvM*posModGradB*100.))*.4+.6))/2.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVGzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVGzV", "name": "Colormixing metaballs", "author": "bitless", "description": "Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration ", "tags": ["2d", "voronoi", "metaballs"], "likes": 4, "viewed": 176, "date": "1570601111", "time_retrieved": "2024-06-20T19:48:04.934573", "image_code": "// Author: bitless\n// Title: Colormixing Metaballs\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration \n\n// translate color from HSB space to RGB space\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat rand (vec2 st) {\n    float f = fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n    return max(f,0.2);\n}\n\nvec3 random_color (vec2 p){\n    return hsb2rgb(vec3(rand(p),0.6,1.0));\n // blood cells bellow\n // return hsb2rgb(vec3(0.02,clamp(rand(p),0.7,0.8),clamp(rand(p),0.4,1.0)));\n\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    st -= 0.5;\n    if (iResolution.y > iResolution.x ) \n        st.y *= iResolution.y/iResolution.x;\n    else \n        st.x *= iResolution.x/iResolution.y;\n   \n    vec3 color = vec3(.0);\n\n    // Scale\n    float scale = sin(iTime*0.2)*2.0 + 5.0;\n   \tst *= scale;\n\n    //st += noise(st*.005*scale)*100.05/scale;\n    //st += random2(st)*0.02;\n\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    \n    vec3 c = vec3(0.0);\n    vec3 c1;\n\n    float m_dist = 10.;  // minimun distance\n    float meta_dist = 10.;  // minimun distance\n    vec2 cl_point;\n    vec2 cl_dist;\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n            \n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n            \n            if (m_dist>dist) {\n                cl_point = neighbor +i_st;\n                cl_dist = diff;\n            }\n            \n            // mix color with neighbors\n            c = mix (c,random_color(neighbor+i_st),1.0-smoothstep(.0,1.0,dist*0.90));\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n            meta_dist = min(meta_dist, meta_dist*dist*1.0);\n            \n        }\n    }\n    \n\n    // Draw the min distance (distance field)\n\t// base color\n    color = mix(random_color(cl_point),c,1.0);\n    // inner borders of cells\n    color -= smoothstep(-0.1,1.0,m_dist)*0.24;\n    // borders of metaballs\n    color = (color)*abs(1.0-smoothstep(0.7,1.0,meta_dist*0.4)*0.3-smoothstep(0.95,1.0,meta_dist*0.4));\n\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVGzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsy3RG", "name": "materials 1", "author": "elenzil", "description": "first shader w/ materials.\nknown issues:\n  * no AA\n  * very limited reflection\n  * shading model not so great\n  * scintillating edges\n  * hard shadows\n", "tags": ["materials", "grimoire"], "likes": 5, "viewed": 277, "date": "1570393072", "time_retrieved": "2024-06-20T19:48:06.358842", "image_code": "/*\nfirst shader w/ materials.\nknown issues:\n  * no AA\n  * very limited reflection\n  * shading model not so great\n  * scintillating edges\n*/\n\n// common stuff\nconst vec3  fv3_1   = vec3(1.0, 1.0, 1.0);\nconst vec3  fv3_0   = vec3(0.0, 0.0, 0.0);\nconst vec3  fv3_x   = vec3(1.0, 0.0, 0.0);\nconst vec3  fv3_y   = vec3(0.0, 1.0, 0.0);\nconst vec3  fv3_z   = vec3(0.0, 0.0, 1.0);\nconst vec2  fv2_1   = vec2(1.0, 1.0);\nconst vec2  fv2_0   = vec2(0.0, 0.0);\nconst vec2  fv2_x   = vec2(1.0, 0.0);\nconst vec2  fv2_y   = vec2(0.0, 1.0);\nconst float PI      = 3.14159265359;\nconst float TAU     = PI * 2.0;\nconst float MAX_FLOAT = intBitsToFloat(0x7f7fffff);\n\n\n// less common\nconst float rmMaxSteps = 350.0;\nconst float rmMaxDist  = 150.0;\nconst float rmEpsilon  =   0.01;\nconst float grEpsilon  =   0.001;\nconst float nrmBackoff =   grEpsilon * 1.0;\n\nconst float shadowFac  = 0.2;           // 1.0 for no shadows, 0.0 for black.\nconst vec3  clr_fog   = vec3(0.0, 0.03, 0.05);\n\n#define SHOW_PIXEL_COST 0\n\nfloat gT = 0.0;\n\n#define mat_no_hit -1\n#define mat_0       0\n#define mat_1       1\n#define mat_2       2\n#define mat_3       3\n#define mat_4       4\n\n#define clr_cyn vec3(0.5, 0.8, 0.8)\n#define clr_er1 vec3(1e3, 0e0, 0e0)\n#define clr_er2 vec3(1e3, 0e0, 1e3)\n#define clr_er3 vec3(0e0, 0e0, 1e3)\n#define clr_grn vec3(0.1, 0.9, 0.3)\n#define clr_mag vec3(0.7, 0.0, 0.1)\n#define clr_pnk vec3(1.0, 0.5, 0.7)\n#define clr_red vec3(0.4, 0.2, 0.2)\n#define clr_wht vec3(0.8, 0.8, 0.8)\n#define clr_yel vec3(1.0, 1.0, 0.0)\n\nstruct SurfaceHit {\n    int  material;\n    vec3 position;\n};\n\n// from IQ's https://www.shadertoy.com/view/XlcSz2\nfloat checkers2D(vec2 p)\n{\n    vec2 ddx = dFdx(p); \n    vec2 ddy = dFdy(p); \n\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 albedo(in SurfaceHit sh) {\n    if (false) {\n        // noop\n    }\n    else if (sh.material == mat_no_hit) {\n        return clr_fog;\n    }\n    else if (sh.material == mat_0) {\n        return clr_pnk * (0.7 + 0.3 * checkers2D(vec2(sh.position.y - gT * 3.0, 0.1) * 1.0));\n    }\n    else if (sh.material == mat_1) {\n        return clr_grn * (0.7 + 0.3 * checkers2D(vec2(sh.position.y - gT * 3.0, 0.1) * 1.0));\n    }\n    else if (sh.material == mat_2) {\n        float ch = checkers2D(sh.position.xz * 0.1);\n        float w = 1.0/(2.0 + dot(sh.position.xz, sh.position.xz));\n        vec3 c1 = mix(clr_yel, clr_wht, smoothstep(0.5 - w, 0.5 + w, 2.0 * abs(-0.5 + fract(-gT * (ch - 0.5) * 2.0 + 16.0 * (atan(sh.position.x, sh.position.z) / TAU)))));\n        vec3 c2 = mix(clr_red, clr_cyn, ch);\n        return mix(c1, c2, clamp(length(sh.position.xz) / (rmMaxDist * 0.5) + 0.2, 0.0, 1.0));\n    }\n    else if (sh.material == mat_3) {\n        return clr_mag * (0.7 + 0.3 * checkers2D(vec2(sh.position.y + gT * 3.0, 0.1) * 1.0));\n    }\n    else if (sh.material == mat_4) {\n        return clr_wht;\n    }\n    else {\n        return clr_er1;\n    }\n}\n\n\n// based on https://www.shadertoy.com/view/Wtf3Df\nvec3 getRayDirection(in vec3 ro, in vec3 lookAt, in vec2 uv, float zoom) {\n  vec3 ol       = normalize(lookAt - ro);\n  vec3 screenRt = cross(ol      , fv3_y); // world Up\n  vec3 screenUp = cross(screenRt, ol   );\n  vec3 rd       = normalize(uv.x * screenRt + uv.y * screenUp + ol * zoom);\n  return rd;\n}\n\nfloat sdfSphere(in vec3 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat sdfCylinderX(in vec3 p, float radius) {\n  return length(p.yz) - radius;\n}\n\nfloat sdfFloor(in vec3 p, float height) {\n  float lxz = length(p.xz);\n  float floorRipple = sin(sqrt(lxz) * 2.0 + mod(gT, 25.0) * -25.0) * 0.4;\n  floorRipple *= 7.0 * smoothstep(0.0, 20.0, lxz) / (1.0 + lxz * 0.05);\n  return p.y - height + floorRipple;\n}\n\n// todo: how to get the material without all this ternaries ?\n//       we only care about material during shading, not when marching or getting normal.\n//       idea: two SDF fn's, only one of which has the material logic.\n//             this could be made even uglier by using #def's.\n//             #def SDF_FULL(all the things) {\\...\\...\\}\n//             #def INCLUDE_MATERIAL false\n//             #def SDF_NO_MAT(p) SDF_FULL\n//             #def INCLUDE_MATERIAL true\n//             etc. ugh.\nfloat sdf(in vec3 p, out int material) {\n  const float sphRad = 5.0;\n\n  float d = MAX_FLOAT;\n  float D;\n  int   m = mat_no_hit;\n\n  D = sdfSphere(p,  sphRad);\n  d = min(d, D);\n  m = d == D ? mat_0 : m;\n\n  const float offset = 1.1;\n  vec3 pax = vec3(abs(p.x) -offset * sphRad, p.y, p.z);\n  D = sdfSphere(pax,  sphRad);\n  d = max(d, -D);\n  m = d == -D ? mat_1 : m;\n\n  pax.x += sphRad * 0.65;\n  pax.x *= -1.0;\n  D = pax.x;\n  d = max(d, -D);\n\n  D = sdfCylinderX(p, sphRad * 0.5);\n  d = max(d, -D);\n  m = d == -D ? mat_3 : m;\n\n  D = sdfSphere(p,  sphRad * 0.2  );\n  d = min(d, D);\n  m = d == D ? mat_4 : m;\n\n  // lower the floor slightly to avoid some shadow tearing.\n  D = sdfFloor (vec3(p.xz, p.y + 0.2).xzy, -sphRad);\n  d = min(d, D);\n  m = d == D ? mat_2 : m;\n\n  material = m;\n\n  return d;\n}\n\n// from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions\nvec3 estimateNormal(vec3 p) {\n  const float e = grEpsilon;\n  int unused;\n  return normalize(vec3(\n    sdf(vec3(p.x + e, p.y    , p.z    ), unused) - sdf(vec3(p.x - e, p.y    , p.z    ), unused),\n    sdf(vec3(p.x    , p.y + e, p.z    ), unused) - sdf(vec3(p.x    , p.y - e, p.z    ), unused),\n    sdf(vec3(p.x    , p.y    , p.z + e), unused) - sdf(vec3(p.x    , p.y    , p.z - e), unused)\n  ));\n}\n\n\nSurfaceHit march(in vec3 p, in vec3 rd, out float numSteps) {\n  SurfaceHit sh; // = SurfaceHit(mat_no_hit, vec3(0.0));\n\n  float distTotal = 0.0;\n  for (numSteps = 0.0; (numSteps < rmMaxSteps) && (distTotal <= rmMaxDist); ++numSteps) {\n    int mat;\n    float d = sdf(p, mat);\n    if (d < rmEpsilon) {\n      sh.material = mat;          \n      sh.position = p;\n      return sh;\n    }\n    p += rd * d;\n    distTotal += d;\n  }\n  sh.material = mat_no_hit;\n  sh.position = p;\n  return sh;\n}\n\nfloat AO(in vec3 p, in vec3 n) {\n    int _;\n    float ret = min(1.0, (sdf(p + n * 0.6, _) * 2.0 + 2.0) / 3.0);\n    return ret;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    RGBA.a   = 1.0;\n\n    float smallWay = min(iResolution.x, iResolution.y);\n    vec2  uv = (XY * 2.0 - fv2_1 * iResolution.xy)/smallWay;\n    gT  = iTime * TAU * 0.01;\n    vec3  ro = vec3( vec2(cos(gT), sin(gT)) * 30.0, mix(0.0, 20.0, sin(gT * 0.21) * 0.5 + 0.5)).xzy;\n    vec3  la = vec3( 0.0, 0.0, 0.0);\n    float zoom = 4.0;\n    vec3  rd = getRayDirection(ro, la, uv, zoom);\n\n    vec3  rgb = clr_fog;\n\n    vec3  ld = normalize(vec3(sin(gT * -3.0), 2.0 * (sin(gT * 5.0) * 0.4 + 0.6), cos(gT * -3.0)));\n\n    float numSteps;\n    SurfaceHit sh = march(ro, rd, numSteps);\n    rgb = albedo(sh);\n\n    vec3 nrm = estimateNormal(sh.position - rd * nrmBackoff);\n\n    float numSubSteps;\n\n    if (sh.material == mat_2) {\n      SurfaceHit shrf = march(sh.position + nrm * 0.01, reflect(rd, nrm), numSubSteps);\n      rgb = mix(rgb, albedo(shrf), 0.2);\n      numSteps += numSubSteps;\n    }\n    if (sh.material == mat_4) {\n      SurfaceHit shrf = march(sh.position + nrm * 0.01, reflect(rd, nrm), numSubSteps);\n      rgb = mix(rgb, albedo(shrf), 0.2);\n      numSteps += numSubSteps;\n    }\n\n    if (sh.material != mat_no_hit) {\n      // shading\n      float shadeFac = max(shadowFac, dot(ld, nrm));\n\n      // shadow\n      SurfaceHit shsh = march(sh.position + nrm * 0.01, ld, numSubSteps);\n      numSteps += numSubSteps;\n      if (shsh.material != mat_no_hit) {\n          shadeFac = shadowFac;\n      }\n\n      rgb *= shadeFac;\n      \n      rgb *= AO(sh.position, nrm);\n    }\n\n    // fog\n    float dist = length(ro - sh.position);\n    rgb = mix(rgb, clr_fog, clamp(dist/rmMaxDist - 0.1, 0.0, 1.0));\n\n    // gamma\n    // rgb = pow(rgb, vec3(0.4545));\n    rgb = pow(rgb, vec3(0.6));\n  \n    #if SHOW_PIXEL_COST\n    rgb.r += numSteps / rmMaxSteps;\n    #endif\n\n    RGBA.rgb = rgb;\n}\n\n\n// grimoire bindings\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsy3RG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsy3Ry", "name": "combination", "author": "sobriquet", "description": "exercise to combine two existing shaders", "tags": ["combination"], "likes": 3, "viewed": 93, "date": "1570407289", "time_retrieved": "2024-06-20T19:48:07.801556", "image_code": "\n/*\nA combination of these shaders as an exercise.\n\nhttps://www.shadertoy.com/view/WsSXWm\nhttps://www.shadertoy.com/view/ll2SW3\n\n*/\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 300;\nconst float EPS_NORMAL = 0.001;\nconst float SCALE_DIST = 0.2;\n\nconst float PI = 3.14159265359;\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdUnion( float d0, float d1 ) {\n    return min( d0, d1 );\n}\n\nfloat sdInter( float d0, float d1 ) {\n    return max( d0, d1 );\n}\n\nfloat sdSub( float d0, float d1 ) {\n    return max( d0, -d1 );\n}\n\nfloat sdUnion_s( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sfDisp( vec3 p ) {\n    return sin(p.x)*sin(p.y)*sin(p.z) ;\n}\n\nvec3 sdTwist( vec3 p, float a ) {\n    float c = cos(a*p.y);\n    float s = sin(a*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 sdRep( vec3 p, vec3 c ) {\n    return mod(p,c)-0.5*c;\n}\n\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nvec3 carToPol(vec3 p) {\n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    vec3 pol = carToPol(pos);\n\n    \n    float d1 = opOnion(sdSphere( pos, 1.1 ), 0.0001);\n    float wave = -0.1+0.5*sin(8.*(pol.y+0.2*iTime))*sin(8.*(pol.z));\n    float d2 = d1 + wave;\n\n    float d = sdSub(d1,d2);\n\n\tvec2 res = vec2(d, 1.0);\n    \n \t//vec2 res = vec2( sdSphere( pos - vec3( .0 , .0 , .0 ) , 1.1 ) , 1. ); \n    //res = opU( res , vec2( sdBox( pos- vec3( -.8 , -.4 , 0.2 ), vec3( .4 , .3 , .2 )) , 2. ));\n    \n    return res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h*SCALE_DIST;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( EPS_NORMAL, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = vec3( 0.5 );\n    \n  vec3 lightPos = vec3( 1. , 4. , 3. );\n    \n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n      \n    vec3 lightDir = normalize( lightPos - pos );\n    \n    float match = max( 0. , dot( lightDir , norm ));\n      \n   \tcolor = vec3( 1. , 1., 1.) * match * 0.3 ;\n    \n    vec3 pol = carToPol(pos);\n    vec3 selfColor = spectrum(1.0*pol.z/PI/2.0+0.5*pol.y/PI);\n\n    color += selfColor * 01.0;\n  }\n   \n  return color;\n    \n    \n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 p1 = fragCoord; \n    p1 /= iResolution.xy;\n    vec4 o4 = vec4(0);\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    o4 += step(( ( (sin(iTime)+1.)/2.)*.5+.25 ), fract(exp2(ceil(-log2(p1.y))) * p1.x / 2.));\n    \n    vec3 ro = vec3( 3.0*cos(0.5*iTime), 0.0, 3.0*sin(0.5*iTime));\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.5*sin(iTime) );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n        \t// rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\trd = rot * rd;\n\tro = rot * ro;\n\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\t\n    vec3 color = o4.rgb;\n    vec3 color1 = render( res , ro , rd );\n\n    if (!(color1 == vec3(.5)))\n        color = color1;\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsy3Ry.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsy3Wm", "name": "Inktober2019 02: mindless", "author": "s23b", "description": "The \"distance functions\" here are a mess, don't look at them. Good thing we have fwidth to cover for us in times like these.\n\nI don't know how I'll be able to put one of these out each day, let alone catch up with the calendar. It was fun making it tho.", "tags": ["mountain", "wind", "desert", "inktober", "shadertober", "mindless", "inktober2019", "tumbleweed"], "likes": 23, "viewed": 426, "date": "1570355333", "time_retrieved": "2024-06-20T19:48:07.801556", "image_code": "#define AA 4.\n#define PERIOD 5.\n#define COLOR vec3(1., .8, .5)\n#define SOLID 0\n\n#define PI 3.14159265359\n\nvec4 hash(float p) {\n    return fract(cos(p) * vec4(12345.6, 23456.7, 34567.8, 45678.9));\n}\n\nvoid tRotate(inout vec2 p, float angle) {\n    float s = sin(angle), c = cos(angle);\n\tp *= mat2(c, -s, s, c);\n}\n\nvoid tTwirl(inout vec2 p, float size) {\n    const float r1 = .5;\n    const float r2 = .3;\n    const float r3 = .2;\n    if (p.x < 0.) {\n        vec2 p2 = p - vec2(0, size * (2. * r1 - r2));\n        float y2 = length(p2) - size * r2;\n        if (abs(p.y) > abs(y2)) {\n            p = vec2(((atan(-p2.x, p2.y) / PI) * r2 + r1) * PI * size, y2);\n        }\n    } else {\n        vec2 p1 = p - vec2(0, size * r1);\n        vec2 p2 = p - vec2(0, size * (2. * (r1 - r2) + r3));\n        float y1 = length(p1) - size * r1;\n        float y2 = length(p2) - size * r3;\n        \n        p = abs(y1) < abs(y2)\n            ? vec2((atan(-p1.x, p1.y) / PI + 1.) * PI * r1 * size, y1)\n            : vec2(((atan(-p2.x, p2.y) / PI + 1.) * r3 + r1 + r2) * PI * size,\n                   y2 + sign(y2) * smoothstep(-PI, 0., atan(-p2.x, p2.y)) * size / 10.);\n    }\n}\n\n// not exact, but we're on a deadline here\nfloat sdStroke(vec2 p, vec2 dim) {\n    p = abs(p);\n    return p.x > dim.x ? distance(p, vec2(dim.x, 0.)) : p.y - smoothstep(dim.x, 0., p.x) * dim.y;\n}\n\nfloat sdLine(vec2 p, vec2 direction, float amount) {\n    float s = dot(p, direction);\n    return abs(s) - amount;\n}\n\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\nfloat ground(float x) {\n    return sin(x * 5.) / 15.;\n}\n\nfloat sdBackground(vec2 p) {\n    p.y += ground(p.x);\n\t#if ! SOLID\n    p.y = abs(p.y);\n    #endif\n    return p.y - .015 - (sin(p.x * 5. + 4.5) + 1.) * .005;\n}\n\nfloat sdBall(vec2 p, float pos) {\n    p += vec2(-pos, ground(pos));\n    p.y -= .12;\n    tRotate(p, pos * PI * 2.);\n    \n    float a = atan(p.x, p.y);\n    float l = length(p);\n    \n    float d = l - .12 + sin(a * 3.) * .006;\n    \n    #if ! SOLID\n    d = opS(d, l - .08 + sin(a * 3. + 2.) * .004);\n    #endif\n    \n    for (float i = 0.; i < 25.; ++i) {\n        vec4 h = hash(i) - vec4(.5, .5, .5, -.5);\n        d = opU(d, sdLine(p + vec2(h.x * .2, 0), normalize(h.yz), h.w * .01));\n    }\n    return d + abs(l - .10) * .3;\n}\n\nfloat sdWind(vec2 p, float t) {\n    t -= .5;\n    tTwirl(p, .1);\n    return sdStroke(p - vec2(t, 0), vec2(.3, .01));\n}\n\nfloat sdWinds(vec2 p, float t) {\n    t -= .65;\n    t = t * 6.;\n    tRotate(p, -.15);\n    float w1 = sdWind(vec2(p.x, p.y - .02), t),\n          w2 = sdWind(vec2(p.x + .12, - p.y - .04), t),\n          w3 = sdWind(vec2(p.x - .06, - p.y - .02), t - .4),\n          w4 = sdWind(vec2(p.x - .16, p.y), t - .6);\n    return opU(opU(w1, w2), opU(w3, w4));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float color = 0.;\n    \n    float res = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / res;\n    \n    if (abs(uv.x) > .45 || abs(uv.y) > .45) {\n        color = 0.;\n    } else {\n        float t = fract(iTime / PERIOD);\n        vec2 p = uv;\n        tRotate(p, -PI / 4.);\n        p.x -= .1 - smoothstep(.1, .4, abs(.5 - abs(t - .25))) * .25;\n        p.y += .15;\n        \n        float pos = .1 + sin((t + .1 * cos(t * PI * 2.)) * PI * 2.) * .35;\n        \n        float d = sdBackground(p);\n        d = opU(d, sdBall(p, pos));\n        d = opU(d, sdWinds(p - vec2(-.5, .21), t));\n        float w = fwidth(d);\n        color = smoothstep(-w, 0., d);\n    }\n        \n\tfragColor = vec4(mix(vec3(0), COLOR, color), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsy3Wm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsy3z3", "name": "Factory Windows", "author": "104", "description": "Stay out kids", "tags": ["2d", "kowloon"], "likes": 14, "viewed": 300, "date": "1570614649", "time_retrieved": "2024-06-20T19:48:08.347002", "image_code": "// fork of https://www.shadertoy.com/view/3dVGDW\n\nconst float PARTITIONS = 10.;\n\nfloat dtoa(float d, float amount){\n    return 1. / clamp(d*amount, 1., amount);\n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat sdroundedthing(vec2 uv, float size) {\n    float ret = length(uv)-size;\n    if (uv.y < 0.) {\n        ret = min(ret, max(uv.x-size, -uv.x-size));\n    }\n    return ret;\n}\n// helps movement of ghosts. probably a cheaper way to accomplish this.\nfloat smoothsquare(float t, float f)\n{\n    const float pi = atan(1.)*4.;\n    const float delta = .03;// smoothness\n    const float A = 1.;// amp\n    float y = (A/atan(1./delta))*atan(sin(2.*pi*t*f)/delta);\n    return y;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    float t = (iTime+1e2)*.2;\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    vec2 N = uv;\n    uv.x *= R.x / R.y;\n    uv.x += .5;\n    vec2 uvghost = uv;\n\n    uv.y += t*.3;\n    \n    // behind the glass...\n    float sdghost = 1e6;\n    const float ghosts = 9.;\n    for (float i = 0.;i < ghosts; ++ i) {\n        vec4 h = hash42(vec2(i+2e2));\n        vec2 uvg2 = uvghost;\n    \tuvg2.x -= (fract(t*h.x+smoothsquare(t+h.z*2., .5)*.2)-.5)*3.;\n        uvg2.y *= sign(h.w-.5);// ceiling\n        uvg2.y += h.y*.5;\n        sdghost = min(sdghost, sdroundedthing(uvg2, .0));\n    }\n    \n    o = vec4(mix(1.,smoothstep(.0,.4,sdghost), .9));\n    //return;\n\n    N *= .98;// oob artifact quickfix\n\n    vec2 cellUL = floor(uv);\n    vec2 cellBR = cellUL + 1.5;\n    vec2 seed = cellUL;// top-level cell ID\n\n    for(float i = 1.; i <= PARTITIONS; ++ i) {\n        vec4 h = hash42(seed+(vec2(cellBR.x, cellUL.y)+10.));\n        float dl = abs(uv.x - cellUL.x);// distance to edge of cell, left edge\n        dl = min(dl, length(uv.y - cellUL.y));// bottom (inv y)\n        dl = min(dl, length(uv.x - cellBR.x));// right\n        dl = min(dl, length(uv.y - cellBR.y));// top\n\n        float r = max(fract(N.x-.5), fract(.5-N.x));\n        r = max(r, fract(.5-N.y));\n        r = max(r, fract(N.y-.5));\n        r = 1.-r;\n        float col2 = 1.5-dtoa(dl, (h.z+.05)*6000.*pow(r, 1.5));\n        vec3 col = h.xyz;\n        o.rgb *= col2;\n        if (h.w < .1)// sometimes color a window\n        \to.rgb *= mix(col, vec3(col.r+col.g+col.b)/3.,.8);\n        \n        h.y = mix(.5, h.y, .2);// favor dividing evenly\n        vec2 pt = mix(cellUL, cellBR, h.y);\n\n        if (uv.x < pt.x) {// descend into quadrant\n            if (uv.y < pt.y) {\n                cellBR = pt.xy;\n            } else {\n              \tcellUL.y = pt.y;\n              \tcellBR.x = pt.x;\n            }\n        } else {\n            if (uv.y > pt.y) {\n                cellUL = pt.xy;\n            } else {\n                cellUL.x = pt.x;\n                cellBR.y = pt.y;\n            }\n\t    }\n    }\n    \n    o = clamp(o,0.,1.);\n    o = pow(o,o-o+.7);\n    o.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsy3z3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsyGDV", "name": "Monitor Hill Random", "author": "mmichal", "description": "Random check board", "tags": ["random"], "likes": 1, "viewed": 230, "date": "1571048727", "time_retrieved": "2024-06-20T19:48:08.777337", "image_code": "const int DIRECTION = 1; // 1, 2, 3, 4;\nconst bool COLOR = true;\n\n\n\n// Random Generators:\nfloat nrand( vec2 n ){\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat N21_1( vec2 n ){\n\tfloat t = fract( n.y*n.x*0.322001 );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\n\nfloat N21_2( vec2 n ){\n\tfloat t = fract( n.y*0.24023 );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\n\nfloat N21_3( vec2 n ){\n\tfloat t = fract( tan(n.x*.0321) );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\treturn (nrnd0+nrnd1+nrnd2) / 3.0;\n}\n\nfloat N21_4(vec2 p){\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float scale = 200.0;   // 10 \"pix\" blocks in x axis in respect to screen resolution\n    float speed = 10.0;   // 10 s to pass screen x resolution\n    \n    speed = 1.0/speed;\n    vec2 uv = (fragCoord -0.5*iResolution.xy)/iResolution.x; // iResolution.y makes uv*scale fit y coord\n    vec3 col = vec3(1.0, 0.0, 0.0);\n\n\n    uv *= scale; //repeat uv\n    float move = iTime*(speed*scale);\n\n    // Direction:\n    if(DIRECTION == 1){ uv.x += move;}\n    else if(DIRECTION == 2){ uv.x -= move; }\n    else if(DIRECTION == 3){ uv.y += move; }\n    else if(DIRECTION == 4){ uv.y -= move; }\n    else{ fragColor = vec4(col, 1.);}\n\n    // Grid and id:\n    vec2 gv = fract(uv) - 0.5; // grid uv - center in the middle\n    vec2 id = floor(uv); // identifier for each cell\n\n    // Color:\n    if(COLOR){\n        float n_r = N21_1(id*0.17); // return \"random\" number for each cell (0-1)\n        float n_g = N21_4(id*.042);\n        float n_b = N21_2(id*.0342);\n    \tcol = vec3(n_r, n_g, n_b);\n    } else {\n        float n_r = N21_1(id);\n        col = vec3(n_r, n_r, n_r);\n    }\n\n    // if (gv.x >.40 || gv.y >.40) {col = vec3(1.0, 0, 0);} // draw the outline of the box\n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsyGDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsyGR3", "name": "Spiral test foobarasdadsasd", "author": "pbsds", "description": "a description", "tags": ["spiraleulerspiral"], "likes": 5, "viewed": 235, "date": "1570626767", "time_retrieved": "2024-06-20T19:48:08.777337", "image_code": "#define PI   3.1415926535\n#define TAU  (2.0*PI)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = (fragCoord - iResolution.xy/2.0) / iResolution.y * 2.0;\n    \n    float theta = atan(uv.y,uv.x); // from -pi to pi\n    float dist = distance(uv, vec2(0.0)); // distance from center, 1 is the top edge\n    \n    vec3 col = vec3(1.0);\n    if (mod(theta - pow(dist + 1.0, 1.7)*11.0 + iTime*4.0, TAU) < 0.3)\n        col *= 0.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsyGR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsyGWd", "name": "sdf_FG_practice", "author": "zfc946", "description": "sdf_practice", "tags": ["sdf"], "likes": 0, "viewed": 68, "date": "1571188683", "time_retrieved": "2024-06-20T19:48:09.528802", "image_code": "#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat scene(vec3 p) {\n    return sphere(p, 2.0);\n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsyGWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsyGWz", "name": "Endless Cartoon Droplets", "author": "thomasderoo4", "description": "Looking to improve speed, now runs at about 26 frames/second on my machine. Maybe add soft shadows instead of hard. Get rid of artifacts around light.", "tags": ["cartoon", "raytrace"], "likes": 5, "viewed": 168, "date": "1570027601", "time_retrieved": "2024-06-20T19:48:09.528802", "image_code": "#define MAX_STEPS 100\n#define SURFACE_DIST .01\n#define FOG_START 4.\n#define FOG_END 10.\n#define MAX_DIST FOG_END + 1.\n#define PI 3.14159265359\n#define LIGHT vec4(0., 5.+sin(iTime*4.3)*.2, -2. + iTime, .03)\n\n// Noise 3 to 1\nfloat N31(vec3 id) {\n id = fract(id * vec3(244.224, 441.211, 521.198));\n id += dot(id, vec3(63.6, 9.1, 55.3))/6.6;\n return fract(id.x * id.y * id.z);\n}\n\n// Noise 3 to 3\nvec3 N33(vec3 id) {\n id = fract(id * vec3(266.234, 881.211, 572.598));\n id += dot(id, vec3(67.6, 981.1, 5.3));\n return vec3(fract(id.x * id.y), fract(id.y * id.z), fract(id.z * id.x));\n}\n\n// Gets distance from point p to capsule a to b with radius r.\nfloat d_capsule(vec3 p, vec3 a, vec3 b, float r, float pinch) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + ab*t;\n    \n    // Make capsule thinner at center\n    float mx = 1.-(cos(t*2.*PI)*.5+.5);\n    \n    return length(p-c)-mix(r, r*.2, mx*pinch);\n}\n\n// Gets a random corner for the cube.\nvec3 RandomCorner(vec3 id) {\n    float s = .65;\n    float r = N31(id);\n    if (r < .25) {\n        return vec3(-s, -s, -s);\n    } else if (r < .5) {\n        return vec3(-s, s, -s);\n    } else if (r < .75) {\n        return vec3(-s, s, s);\n    } else {\n        return vec3(s, s, -s);\n    }\n}\n\n// Get distance to scene\nfloat GetDist(vec3 p, vec3 rd, out float lightdist) {\n    // Get direction so that we don't search in wrong direction\n    float ox = (rd.x > 0.) ? 1. : 0.;\n    float oy = (rd.y > 0.) ? 1. : 0.;\n    float oz = (rd.z > 0.) ? 1. : 0.;\n    \n    float sphere_d = length(p-LIGHT.xyz)-LIGHT.w;\n    \n   \t\n    // square id\n    vec3 id = floor(p / 2.);\n    \n    // Domain repetition\n    p = vec3(mod(p.x, 2.)-1.,mod(p.y, 2.)-1., mod(p.z, 2.)-1.);//, );\n\n    float capsule_d = MAX_DIST;\n    // Search in xyz offset by direction.\n    for(float x = -1.+ox;x<=ox;x++) {\n        for(float y = -1.+oy;y<=oy;y++) {\n            for(float z = -1.+oz;z<=oz;z++) {\n                // Get random corner for this square\n                vec3 v = RandomCorner(id + vec3(x, y, z));\n                \n                // Get capsule distance\n                float d = d_capsule(p, v + vec3(x, y, z) * 2., -v + vec3(x, y, z) * 2., .3, 1.);//mh_length(p-sphere.xyz)-sphere.w;\n                \n                // Calc min\n                capsule_d = min(capsule_d, d);\n            }\n        }\n    }\n    lightdist = sphere_d;\n    return min(capsule_d, sphere_d);\n}\n\n\n\n\n\n// March ray, returns distance and iterations\nfloat RayMarch(vec3 ro, vec3 rd, out int its, out float minlightdist) {\n\tfloat d_o = 0.;  \n    its = 0;\n    minlightdist = MAX_DIST;\n    \n    for(int i=0;i<MAX_STEPS;i++) {\n     \tvec3 c_p = ro + (rd * d_o);\n        float lightdist = 0.;\n        float d_s = GetDist(c_p, rd, lightdist);\n        minlightdist = min(minlightdist, lightdist);\n        d_o+= d_s;\n        its++;\n        if ((d_s < SURFACE_DIST) || (d_o > MAX_DIST)) break;\n    }\n            \n    return d_o;\n}\n\n\n// Guess normal at position p\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(SURFACE_DIST, 0.);\n    float lightdist = 0.;\n    float d = GetDist(p, vec3(0.), lightdist);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, vec3(-1., 0., 0.), lightdist),\n        GetDist(p-e.yxy, vec3(0., -1., 0.), lightdist),\n        GetDist(p-e.yyx, vec3(0., 0., -1.), lightdist)\n    );\n    return normalize(n);\n}\n\n// Get light level at position p\nfloat GetLight(vec3 p) {\n    // light position\n    vec3 lv = normalize(LIGHT.xyz-p);//lightvector\n    vec3 nv = GetNormal(p);//normalvector\n    int its = 0;\n    float lightdist = 0.;\n    // light cutoff\n    float lightlevel = smoothstep(.3,.7,clamp(dot(lv, nv), 0., 1.));\n    float shadow = (RayMarch(p+(nv*SURFACE_DIST*2.), lv, its, lightdist) < (length(LIGHT.xyz-p)-(LIGHT.w*2.))) ? 0. : 1.;\n    return 0.3 + ((lightlevel * shadow) * .7);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0.);\n    // Ray origin, Ray direction\n    vec3 ro = vec3(cos(iTime*0.8)*.4, 5.+sin(iTime*0.8)*.4, -6. + iTime);\n    vec3 rd = normalize(vec3(uv.x-cos(iTime*0.8)*.1, uv.y-sin(iTime*0.8)*.1, 1.));\n\t\n    // get iterations and distance to scene\n\tint its = 0;\n    float lightdist = 0.;\n    float d = RayMarch(ro, rd, its, lightdist);\n    \n    // Get the minimum distance a ray came to a light and create add var.\n    float light_add = pow(smoothstep(LIGHT.w*100., 0., lightdist), 20.);// * (0.7 + ((sin(atan(uv.x, uv.y)*16.)*.5+.5)*0.3));\n   \t\n    // Dont bother if beyond fog reach\n    if(d<FOG_END) {\n        \n        // Make more iterations darker\n        float outline = smoothstep(.75, .65, float(its)/40.);\n        \n        // Get hit position\n        vec3 pos = ro + (rd * d);\n\t\t\n        bool at_light = (length(pos-LIGHT.xyz) < LIGHT.w*2.);\n        \n        // Get random color at position\n   \t\tvec3 posid = floor(pos / 2.);\n    \tvec3 col_at_pos = at_light ? vec3(1.) :  (.2+N33(posid)*.8);\n        \n        // Calculate final pixel color\n        col = col_at_pos * (at_light ? 1. : GetLight(pos)) * smoothstep(FOG_END, FOG_START, d) * outline;\n    }\n\n    fragColor = vec4(mix(col+light_add, vec3(1.), light_add),1.0);\n}", "image_inputs": [{"id": "llfGD2", "previewfilepath": "https://soundcloud.com/alexei-lyutarevich/session-add", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/alexei-lyutarevich/session-add", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsyGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsyGz1", "name": "spiky torus knot", "author": "arifr123", "description": "spiky torus knot using a torus knot estimated signed distance function.\n", "tags": ["raymarching", "torusknot"], "likes": 5, "viewed": 103, "date": "1569963095", "time_retrieved": "2024-06-20T19:48:10.607654", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat fOverDerF(float t, vec3 p)\n{\n    \n\tfloat sint = sin(t);\n    float cost = cos(t);\n    \n    float sin2t = 2.0*sint*cost;//sin(2.0*t);\n    float cos2t = cost*cost - sint*sint;//cos(2.0*t);\n    \n    float sin4t = 2.0*sin2t*cos2t;//sin(4.0*t);\n    \n    float sin3t = sin(3.0*t);\n    float cos2tSq = cos2t*cos2t;\n    float cos3t = cos(3.0*t);\n    \n    return (2.0*p.x*sint + p.x*sin2t + 2.0*p.x*sin4t - 3.0*p.y*cos3t - 2.0*p.z*cost - 4.0*p.z*cos2tSq + p.z*cos2t + 2.0*p.z - 6.0*sin3t)/(2.0*p.x*cost + 16.0*p.x*cos2tSq + 2.0*p.x*cos2t - 8.0*p.x + 9.0*p.y*sin3t + 2.0*p.z*sint - 2.0*p.z*sin2t + 8.0*p.z*sin4t - 16.0*cos2tSq*cos2t + 12.0*cos2t - 18.0*cos3t + 4.0*cos(6.0*t));\n\t\n    \n    //return (2.0*p.x*sin(t) + p.x*sin(2.0*t) + 2.0*p.x*sin(4.0*t) - 3.0*p.y*cos(3.0*t) - 2.0*p.z*cos(t) - 4.0*p.z*pow(cos(2.0*t), 2.0) + p.z*cos(2.0*t) + 2.0*p.z - 6.0*sin(3.0*t))/(2.0*p.x*cos(t) + 16.0*p.x*pow(cos(2.0*t), 2.0) + 2.0*p.x*cos(2.0*t) - 8.0*p.x + 9.0*p.y*sin(3.0*t) + 2.0*p.z*sin(t) - 2.0*p.z*sin(2.0*t) + 8.0*p.z*sin(4.0*t) - 16.0*pow(cos(2.0*t), 3.0) + 12.0*cos(2.0*t) - 18.0*cos(3.0*t) + 4.0*cos(6.0*t));\n}\n\nvec3 torusKnot(float t)\n{\n    return vec3((cos(3.0*t) + 2.0)*cos(t), sin(3.0*t), (cos(3.0*t) + 2.0)*sin(t));\n}\nvec3 torusKnotDer(float t)\n{\n    return vec3(sin(t)*(-(cos(3.*t) + 2.)) - 3.*sin(3.*t)*cos(t), 3.*cos(3.*t), cos(t)*(cos(3.*t) + 2.) - 3.*sin(t)*sin(3.*t));\n}\n\nfloat lengthSq(vec3 p)\n{\n    return dot(p, p);\n}\n\nfloat oldTorusKnotDist(vec3 p, out vec3 closestPoint)\n{\n    int samplePointsNum = 12;\n    \n    float jump = 2.0 * PI / float(samplePointsNum);\n    \n    float minDistSq = -1.0;\n    float minT;\n    \n    for(int i = 0; i < samplePointsNum; i++)\n    {\n        float cT = jump * float(i);\n        \n        cT -= fOverDerF(cT, p);\n        \n        float cDistSq = lengthSq(torusKnot(cT) - p);\n        \n        if(minDistSq == -1.0 || cDistSq < minDistSq)\n        {\n            minDistSq = cDistSq;\n            minT = cT;\n        }\n    }\n\n    minT -= fOverDerF(minT, p);\n    \n    \n    closestPoint = torusKnot(minT);\n    \n    return distance(closestPoint, p);\n}\n\n\nvec2 cMult(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\nvec2 cPow(vec2 a, int n)\n{\n    vec2 r = vec2(1, 0);\n    for(int i = 0; i < n; i++)\n    {\n        r = cMult(r, a);\n    }\n    \n    return r;\n}\n\nfloat torusDist(vec3 p, out vec3 closestPoint, float r1, float r2)\n{\n    float d = sqrt(pow(p.y, 2.0) + pow(length(p.xz) - r1, 2.0));\n    \n    closestPoint = p;\n    closestPoint.xz -= p.xz * r1 / length(p.xz);\n    closestPoint *= r2 / d;\n    closestPoint.xz += p.xz * r1 / length(p.xz);\n    \n    return d - r2;\n}\nfloat fastTorusKnotDist(vec3 p, out vec3 closestPoint, int n, float r1)\n{\n    vec2 pa = normalize(p.xz);\n    vec2 rot = cPow(pa, n);\n    p.xz -= pa * rot.x;\n    p.y -= rot.y;\n    \n    float d = torusDist(p, closestPoint, r1, 0.);\n    \n    closestPoint.xz += pa * rot.x;\n    closestPoint.y += rot.y;\n    \n    return d;\n}\n\nfloat pulse(float x, float a, float b)\n{\n    return pow(1./(pow(abs(x), a) + 1.), b);\n}\n\nfloat getT(vec3 closestPoint)\n{\n    return atan(closestPoint.z, closestPoint.x);\n}\nfloat getS(float t, vec3 p, vec3 closestPoint)\n{\n    vec3 normal = vec3(cos(3.0*t)*cos(t), sin(3.0*t), cos(3.0*t)*sin(t));\n    vec3 cpToP = normalize(p - closestPoint);\n    \n    float angle = acos(clamp(dot(normal, cpToP), -1., 1.));\n    \n    \n    float angSign = sign(dot(cross(normal, cpToP), torusKnotDer(t)));\n    \n    return angle * angSign;\n}\n\nfloat getBumps(vec3 p, vec3 lastClosestCurvePoint)\n{\n    float t = getT(lastClosestCurvePoint);\n    float s = getS(t, p, lastClosestCurvePoint);\n\n    float time = -2.*0.3*iTime;\n\n\n    float bump = PI / 24.;\n\n    float modT = t + bump + time;\n\n    modT = mod(modT, 2.*bump);\n\n    modT -= bump;\n\n\n    modT *= 10.;\n    s *= 2.;\n\n\n    return 0.5 * (cos(3.*t)+1.) * exp(-modT*modT -s*s);\n}\n\nfloat spikyTorusKnotDist(vec3 p, out vec3 closestPoint)\n{\n    float tnd = oldTorusKnotDist(p, closestPoint) - 0.5;\n    //float tnd = fastTorusKnotDist(p, closestPoint, 3, 2.) - 0.75;\n    \n    return tnd - getBumps(p, closestPoint);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx - (iResolution.xy/iResolution.xx)/2.0;\n    \n    float time = 0.1 * iTime;\n    \n    \n    float az = (2.*PI*time);\n    float po = PI/2. * sin(2.*PI*time);\n    \n    \n    vec3 camera = vec3(cos(po) * cos(az), sin(po), cos(po) * sin(az));\n    vec3 cz = -camera;\n    vec3 cy = vec3(sin(-po) * cos(az), cos(-po), sin(-po) * sin(az));\n    vec3 cx = cross(cy, cz);\n    camera *= 14.;\n\n    float zoom = 1.;\n    \n    \n    \n    \n    vec3 sp = normalize(uv.x * cx + uv.y * cy + zoom * cz);\n    \n    vec3 p = camera;\n    \n    float hitDistance = 0.2;\n    \n    \n    vec3 lastClosestCurvePoint;\n    float totalDist = 0.0;\n    float lastDist = -1.0;\n    for(int i = 0; i < 30; i++)//30\n    {\n        p += sp * lastDist;\n        \n        lastDist = spikyTorusKnotDist(p, lastClosestCurvePoint);\n        \n        //lastDist *= 0.35;\n        \n        \n        totalDist += lastDist;\n        \n        //if(lastDist < 0.2)break;\n    }\n    \n    totalDist -= 9.;\n    \n    vec3 col = (4./(totalDist*totalDist) + 0.2) * mix(hsv2rgb(vec3(time + 0.5, 1, 1)), hsv2rgb(vec3(time, 1, 1)), getBumps(p, lastClosestCurvePoint));\n\n    col *= smoothstep(0.2, 0., lastDist);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsyGz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsyGzd", "name": "A small lattice twist (tweak)", "author": "tribeteknofolle", "description": "https://www.shadertoy.com/view/3dK3Rc", "tags": ["boh"], "likes": 2, "viewed": 55, "date": "1570743761", "time_retrieved": "2024-06-20T19:48:10.874346", "image_code": "//i'm newbie for shader i try to edit every parameters with PHI and FIBO sequence. \n// this shader was made from ( https://www.shadertoy.com/view/3dK3Rc ) \n// ( ENYOY ) \n\n\n// 280 chars\n#define r(a) mat2(cos(vec4(0, 11, 33, 0) + a))\nvoid mainImage(out vec4 o, in vec2 u) {\n\tvec2 R = iResolution.xy;\n    vec3 p;\n\tfloat t = .0;\n    for (int i = 0; i < 32; i++) {\n        p = mod(p, 4.) - 3.14;\n        p = vec3((u + u - R) / R.y, 1) * (t += .5 * min(min(length(p.xz) - .5, length(p.xy) - .5), length(p.yz) - .5));\n\t\tp.xy *= r((p.z += iTime * 3.) * .3);  \n        \n    }\n    o += 1. / t;\n}\n\n\n// 296 chars\n/*\n#define r(a) mat2(cos(vec4(0, 11, 33, 0) + a))\nvoid mainImage(out vec4 o, in vec2 u) {\n\t\n\tvec2 R = iResolution.xy;\n\tu = (u + u - R) / R.y;\n\t\t\n    vec3 p;\n\tfloat t = 0., k = iTime * 314.;\n    \n    for (int i = 0; i < 32; i++) {\n        p = mod(p, 4.) - 2.;\n        p = vec3(0, 0, k) + vec3(u, 1) * (t += .5 * min(min(length(p.xz) - .3, length(p.xy) - .3), length(p.yz) - .3));\n\t\tp.xy *= r(p.z * .1);  \n        \n    }\n    o += 1. / t;\n    \n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsyGzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtsGzB", "name": "Alien Voxel Landscape", "author": "BradyInstead", "description": "Procedurally generated alien voxel landscape, based on iq's voxel rendering. Uses Brian Sharpe's fast Value3D noise algorithm.\n\nWEBSITE: bradyinstead.com\nTWITTER: twitter.com/BradyInstead\nINSTA: instagram.com/bradyinstead/", "tags": ["voxel"], "likes": 72, "viewed": 3658, "date": "1571749923", "time_retrieved": "2024-06-20T19:48:12.504884", "image_code": "//------------------------------------------------------------------------\n// Alien Voxel Landscape\n// by @BradyInstead\n//------------------------------------------------------------------------\n\n// based on https://iquilezles.org/www/articles/voxellines/voxellines.htm\n\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time)\n{\n    float zoom = 50.;\n    vec3 initPos = vec3(zoom);\n\tcamPos = initPos;\n    camPos.z += iTime*16.; // movement\n    camTar = camPos-initPos;\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//------------------------------------------------------------------------\n\nvec3 doBackground( void )\n{\n    return vec3( 0.);\n}\n\n\n//------------------------------------------------------------------------\n// Shaping \n//------------------------------------------------------------------------\n\n// p = positions\n// h = dimensions of elongation\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\n//------------------------------------------------------------------------\n// Modelling \n//------------------------------------------------------------------------\n\nfloat noise( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nfloat mapTerrain( vec3 p )\n{\n    p*=.35;\n    p.y /= 2.;\n\treturn noise(p);\n}\n\nfloat map(in vec3 p)\n{\n\tfloat terrain = mapTerrain( p ) + 0.12*p.y;\n\treturn step( terrain, 0.95 );\n}\n\n\n//------------------------------------------------------------------------\n// Material\n//------------------------------------------------------------------------\n\nvec3 doMaterial( vec3 pos, vec3 vos )\n{\n    float h = vos.y/8.;\n    \n    vec3 primary = vec3(.9, .1, .2) ;\n    vec3 secondary = vec3(.1, .5, 1.);\n    \n    return mix(primary, secondary, h)*h;\n}\n\nvec3 saturation(vec3 rgb, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n\nfloat maxcomp( in vec4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wb = smoothstep( 0.7, 0.99, vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y) ) * ( 1.0 - va + va*vc );\n    // corners\n    vec4 wc = smoothstep( 0.7, 0.99, vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\n    return 1.0 - maxcomp( max(wb,wc) );\n}\n\nfloat calcOcc( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n\n    // corners\n    vec4 wb = vec4(uv.x*uv.y,\n                   st.x*uv.y,\n                   st.x*st.y,\n                   uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n    \n    return wa.x + wa.y + wa.z + wa.w +\n           wb.x + wb.y + wb.z + wb.w;\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal , vec3 vos, vec3 dir)\n{\n    vec3 uvw = pos - vos;\n    \n    vec3 v1  = vos + nor + dir.yzx;\n\tvec3 v2  = vos + nor - dir.yzx;\n\tvec3 v3  = vos + nor + dir.zxy;\n\tvec3 v4  = vos + nor - dir.zxy;\n\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n    vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\tvec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\tvec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\tvec3 v9  = vos + dir.yzx;\n\tvec3 v10 = vos - dir.yzx;\n\tvec3 v11 = vos + dir.zxy;\n\tvec3 v12 = vos - dir.zxy;\n \tvec3 v13 = vos + dir.yzx + dir.zxy; \n\tvec3 v14 = vos - dir.yzx + dir.zxy;\n\tvec3 v15 = vos - dir.yzx - dir.zxy;\n\tvec3 v16 = vos + dir.yzx - dir.zxy;\n\n\tvec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\tvec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\tvec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\tvec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n    \n    // ambient occlusion\n    float occ = 1.0;\n    occ = calcOcc( uv, va, vb, vc, vd );\n    float ocAm = 3.0;\n    occ = 1.0 - occ/ocAm;\n    occ = pow(occ, 5.);\n    \n    // fake lighting\n    vec3 norC = abs(nor);\n    float sum = min(1.0, norC.g + norC.r*.35 + norC.b*.2 + .05);\n    vec3 col = mal*sum*isEdge(uv, va, vb, vc, vd);\n    \n    col = mix(col.rgb*occ, vec3(col.rg*occ, col.b), .2);\n    \n    return col;\n}\n\n\n//------------------------------------------------------------------------\n// Raymarching\n//------------------------------------------------------------------------\n\nfloat calcIntersection( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir, out int mat )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<200; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 getColor(int r)\n{\n    switch(r)\n    {\n        // METAL\n        case 0:\n        \treturn vec3(86., 48., 107.) \t/256.;\n        case 1:\n        \treturn vec3(98., 67., 198.) \t/256.;\n        case 2:\n        \treturn vec3(102., 165., 250.)\t/256.;\n        case 3:\n        \treturn vec3(186., 250., 236.)\t/256.;\n        \n        // LAVA\n        /*\n        case 0:\n        \treturn vec3(45., 19., 44.) \t/256.;\n        case 1:\n        \treturn vec3(128., 19., 54.) \t/256.;\n        case 2:\n        \treturn vec3(199., 44., 65.)\t/256.;\n        case 3:\n        \treturn vec3(238., 69., 64.)\t/256.;*/\n        \n        /*\n        // CHROME\n        case 0:\n        \treturn vec3(80., 38., 167.) \t/256.;\n        case 1:\n        \treturn vec3(141., 68., 139.) \t/256.;\n        case 2:\n        \treturn vec3(204., 106., 135.)\t/256.;\n        case 3:\n        \treturn vec3(236., 205., 143.)\t/256.;*/\n    }\n    \n    return vec3(0.);\n}\n\n//------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    p.x /= 1.25;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( vec3(p.xy,1.0) ); // lens length\n    rd.y -= 1.0;\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    vec3 vos, dir;\n    int mat;\n    float t = calcIntersection( ro, rd, vos, dir, mat );\n    if( t>0.0 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = -dir*sign(rd);\n\n        // materials\n        vec3 mal = doMaterial( pos, vos );\n\n        col = doLighting( pos, nor, rd, t, mal, vos, dir);\n\t}\n\n    \n    col *= 1.5;\n    col -= .03;\n    \n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.5) );\n    \n    // saturation\n\t//col = saturation(col, 2.0);   \n    //col *= exp(-.01*t*t);\n    \n    // toon\n    col *= vec3(6.);\n    float colFract = abs(sin(fract(col.r) * 3.14 * 1.0));\n    col = floor(col);\n    \n    \n    // pallete\n    col = mix(getColor(int(col.r-1.)), getColor(int(col.r)), colFract);\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtsGzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtSSDy", "name": "Smoky Planet", "author": "peterszerzo", "description": "Experiments with fBm noise and a blurry planet", "tags": ["noise", "blur", "smoke", "planets"], "likes": 1, "viewed": 197, "date": "1570276252", "time_retrieved": "2024-06-20T19:48:12.510851", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n  vec2 i = floor(_st);\n  vec2 f = fract(_st);\n\n  // Four corners in 2D of a tile\n  float a = random(i);\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  return mix(a, b, u.x) +\n    (c - a)* u.y * (1.0 - u.x) +\n    (d - b) * u.x * u.y;\n}\n\nmat2 rotation ( in float _angle ) {\n    return mat2(\n        cos(_angle), sin(_angle),\n    \t-sin(_angle), cos(_angle)\n    );\n}\n\n#define NUM_OCTAVES 4\n\n#define PI 3.14159\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = rotation(0.5);\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n      v += a * noise(_st);\n      _st = rot * _st * 2.0 + shift;\n      a *= 0.5;\n    }\n    return v;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    float time = iTime * 1.0;\n    \n    float minwh = min(iResolution.x, iResolution.y);\n    float aspect = iResolution.x / iResolution.y;\n    \n\tvec2 st = rotation(PI * 1.75) * vec2(\n        fragCoord.x / minwh - 0.5 * aspect,\n        fragCoord.y / minwh - 0.5\n    );\n    \n    vec3 yellow = vec3(191.0 / 255.0, 191.0 / 255.0, 0.0);\n    \n    vec4 planetColor;\n    \n    float mixRatio;\n    \n    float blur = 1.0 - smoothstep(0.2, 0.24, length(st));\n    \n    if (length(st) < 0.24) {\n        mixRatio = 0.85;\n        planetColor = mix(vec4(0.1, 0.1, 0.1, 1.0), vec4(\n            yellow * (\n                0.7 +\n                0.3 *\n                sin(\n                    2.2 +\n                    10.0 *\n                    distance(st, vec2(0.1, 0.1)) *\n                    distance(st, vec2(0.03, -0.16)) *\n                    distance(st, vec2(-0.03, 0.16)) *\n                    (1.0 + 0.1 * sin(time * 1.0)) * 30.0\n                )\n            ),\n            1.0\n        ), blur);\n    } else {\n        mixRatio = 0.0;\n        planetColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    \n    // Smoke\n    vec2 st1 = st * 6.0;\n    vec3 color = vec3(0.0);\n\n    vec2 q = vec2(0.0);\n    q.x = fbm(st1 + 0.00 * time);\n    q.y = fbm(st1 + vec2(1.0));\n\n    vec2 r = vec2(0.0);\n    \n    r.x = fbm( st1 + 1.0 * q + vec2(1.7, 9.2) + 0.6 * sin(0.2 * time) );\n    r.y = fbm( st1 + 1.0 * q + vec2(8.3, 2.8) + 0.6 * cos(0.2 * time) );\n\n    float f = fbm(0.5 * st1 + 2.0 * r);\n    \n    vec3 color1 = vec3(0.1, 0.6, 0.6);\n    vec3 color2 = vec3(0.6, 0.6, 0.5);\n    \n    color = mix(\n        color1,\n        color2,\n        clamp((f*f)*4.0,0.0,1.0)\n    );\n\n    color = mix(\n        color,\n        vec3(0.3, 0.3, 0.3),\n        clamp(length(q),0.0,1.0)\n    );\n\n    color = mix(\n        color,\n        vec3(0.2, 0.2, 0.2),\n        clamp(length(r.x), 0.0, 1.0)\n    );\n    \n    vec4 smokeColor = vec4(\n      (f * f * f + 0.6 * f * f + 0.5 * f) * color,\n      1.0\n    );\n\n    fragColor = mix(smokeColor, planetColor, mixRatio);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtSSDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
