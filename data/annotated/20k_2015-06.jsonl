{"id": "4d2Gzt", "name": "4d soap bubble", "author": "Antonalog", "description": "travelling through a 4d soap bubble", "tags": ["noise"], "likes": 35, "viewed": 935, "date": "1434381661", "time_retrieved": "2024-06-20T18:21:19.924753", "image_code": "//various noises borrowed from iq\n\n#define FULL_PROCEDURAL\n\n\n#ifdef FULL_PROCEDURAL\n\n// hash based 3d value noise\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n#else\n\n// LUT based 3d value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\n\n//x3\nvec3 noise3( in vec3 x)\n{\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\n\t\t\t\tnoise(x+vec3(.11,47.43,19.17)),\n\t\t\t\tnoise(x) );\n}\n\n//http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz\nfloat bias(float x, float b) {\n\treturn  x/((1./b-2.)*(1.-x)+1.);\n}\n\nfloat gain(float x, float g) {\n\tfloat t = (1./g-2.)*(1.-(2.*x));\t\n\treturn x<0.5 ? (x/(t+1.)) : (t-x)/(t-1.);\n}\n\n\nmat3 rotation(float angle, vec3 axis)\n{\n    float s = sin(-angle);\n    float c = cos(-angle);\n    float oc = 1.0 - c;\n\tvec3 sa = axis * s;\n\tvec3 oca = axis * oc;\n    return mat3(\t\n\t\toca.x * axis + vec3(\tc,\t-sa.z,\tsa.y),\n\t\toca.y * axis + vec3( sa.z,\tc,\t\t-sa.x),\t\t\n\t\toca.z * axis + vec3(-sa.y,\tsa.x,\tc));\t\n}\n\nvec3 fbm(vec3 x, float H, float L, int oc)\n{\n\tvec3 v = vec3(0);\n\tfloat f = 1.;\n\tfor (int i=0; i<10; i++)\n\t{\n\t\tif (i >= oc) break;\n\t\tfloat w = pow(f,-H);\n\t\tv += noise3(x)*w;\n\t\tx *= L;\n\t\tf *= L;\n\t}\n\treturn v;\n}\n\nvec3 smf(vec3 x, float H, float L, int oc, float off)\n{\n\tvec3 v = vec3(1);\n\tfloat f = 1.;\n\tfor (int i=0; i<10; i++)\n\t{\n\t\tif (i >= oc) break;\n\t\tv *= off + f*(noise3(x)*2.-1.);\n\t\tf *= H;\n\t\tx *= L;\n\t}\n\treturn v;\t\n}\n\n\nvec4 map( in vec3 p )\n{\n\tfloat d = 0.2 - p.y;\n\n\tvec3 q = p - vec3(1.0,0.1,0.0)*iTime;\n\t\n#if 0\t\n\tfloat f;\n    f  = 0.5000*noise( q ); q = q*2.02;\n    f += 0.2500*noise( q ); q = q*2.03;\n    f += 0.1250*noise( q ); q = q*2.01;\n    f += 0.0625*noise( q );\n\n\td += 3.0 * f;\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.7,0.7,0.7), res.x );\n#endif\n\t\n//\tvec3 p = vec3(uv*.2,slow+change);\t\t\t\t\t//coordinate + slight change over time\n\tp -= vec3(1.0,0.1,0.0)*iTime*.01;\n\tp *= 4.;\n\t\n\tvec3 axis = 4. * fbm(p, 0.5, 2., 8);\t\t\t\t//random fbm axis of rotation\n\t\n\tvec3 colorVec = 0.5 * 5. * fbm(p*0.3,0.5,2.,7);\t\t//random base color\n\tp += colorVec;\n\t\n//\tfloat mag = 4e5;\t//published, rather garish?\n\tfloat mag = 0.75e5; //still clips a bit\n//\tmag = mag * (1.+sin(2.*3.1415927*ts)*0.75);\n\tvec3 colorMod = mag * smf(p,0.7,2.,8,.2);\t\t\t//multifractal saturation\n\tcolorVec += colorMod;\n\t\n\tcolorVec = rotation(3.*length(axis),normalize(axis))*colorVec;\n\n\tcolorVec *= 0.1;\n\t\n\tvec4 res;\n\tres.xyz = colorVec;\n\tres.w = length(colorVec)*8.;\n//\tres.xyz = vec3(pow(res.w,100.));\n//\tres.w = pow(res.w,100.);\n\tres = clamp(res, vec4(0),vec4(1));\n//#endif\t\n\treturn res;\n}\n\n\nvec3 sundir = vec3(-1.0,0.0,0.0);\n\n\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n\tfloat t = 0.1;\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( sum.a > 0.99 ) continue;\n\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = map( pos );\n\t\t\n\t\t#if 0\n\t\tfloat dif =  clamp((col.w - map(pos+0.3*sundir).w)/0.6, 0.0, 1.0 );\n\n        vec3 lin = vec3(0.65,0.68,0.7)*1.35 + 0.45*vec3(0.7, 0.5, 0.3)*dif;\n\t\tcol.xyz *= lin;\n\t\t#endif\n\t\t\n\t\tcol.a *= 0.35 * (t*8.);\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n        #if 0\n\t\tt += 0.1;\n\t\t#else\n\t\tt += max(0.1,0.025*t);\n\t\t#endif\n\t}\n\n\tsum.xyz /= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = vec2(0);//-1.0 + 2.0*iMouse.xy / iResolution.xy;\n    mo.x = sin(iTime*0.0125);\n    // camera\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t\n    vec4 res = raymarch( ro, rd );\n#if 0\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\tcol = mix( col, res.xyz, res.w );\n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n#else\n\tvec3 col = res.xyz;\n#endif\t\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2Gzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d2XD3", "name": "My First SDF Marcher! :)", "author": "ddoodm", "description": "I finished this a good while ago, and figured that I ought to make it public. Thanks for visiting!\n(Just a learning experiment :) )\nI borrowed a good chunk of code from Joates and iq.", "tags": ["raymarcherraymarcherdistancefieldfunction"], "likes": 7, "viewed": 1293, "date": "1433584725", "time_retrieved": "2024-06-20T18:21:19.924753", "image_code": "// DDOODM's first raymarched distance field!\n// Derived from:\n// \"monkey saddle by joates (Nov-2014)\"\n//\n// Deinyon Davies & Joates, November 2014\n\n// Thank you, IQ!\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\n//#define IS_BOXED\nconst float size = 0.45;\n\n// iq's Smooth Minimum\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat map( in vec3 p )\n{\n    float plane = p.y + 0.5 + 0.025*(sin(p.x*10.0+sin(p.z*14.0))+cos(p.z*10.0+sin(p.x*20.0)));\n    plane = max(plane, length(p + vec3(0.0,0.5,0.0)) - 3.0);\n    \n    float d1 = length(p) - size;\n    \n    float d2 = max(p.y + p.x/2.0, p.y - p.x/2.0);\n    \n    float d3 = length(p) - size * 0.85;\n    \n    float d4 = length(p - vec3(0.0, 0.25*cos(iTime)-0.25, 0.0)) - size * 0.25*cos(iTime*1.2);\n\n    float hem = max(d1,d2);\n    \n    float bow = max(hem, -d3);\n    \n    float metabowl = smin(d4, bow, 8.0);\n    metabowl *= 0.5;\n    \n    return min(metabowl, plane);\n}\n\nvec3 calcNormal( in vec3 p ) {\n    vec2 e = vec2( 0.01, 0.0 );\n    return normalize( vec3( map( p + e.xyy ) - map( p - e.xyy ),\n                            map( p + e.yxy ) - map( p - e.yxy ),\n                            map( p + e.yyx ) - map( p - e.yyx ) ) );\n}\n\n// Thank you, mu6k!\nfloat amb_occ(vec3 p)\n{\n\tfloat acc=0.0;\n\t#define ambocce 0.1\n\n\tacc+=map(p+vec3(-ambocce,-ambocce,-ambocce));\n\tacc+=map(p+vec3(-ambocce,-ambocce,+ambocce));\n\tacc+=map(p+vec3(-ambocce,+ambocce,-ambocce));\n\tacc+=map(p+vec3(-ambocce,+ambocce,+ambocce));\n\tacc+=map(p+vec3(+ambocce,-ambocce,-ambocce));\n\tacc+=map(p+vec3(+ambocce,-ambocce,+ambocce));\n\tacc+=map(p+vec3(+ambocce,+ambocce,-ambocce));\n\tacc+=map(p+vec3(+ambocce,+ambocce,+ambocce));\n\treturn 0.5+acc;\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\n\n\tfloat time = iTime*0.1;\n\n    // view origin & direction\n\tvec3 ro = vec3( size );\n\tvec3 tp = vec3( 0.0 );\n    tp.y = -0.25*size;\n\n    // camera orbit\n    float m = iMouse.x/iResolution.x * 6.0;\n    ro.x = cos(time+m)*length(ro);\n    ro.z = sin(time+m)*length(ro);\n    ro.y = iMouse.y/iResolution.y;\n\n    vec3 lit = vec3( 200.0, 75.0, 200.0 );\n    vec3 ldir = normalize(lit);\n    vec3 col = vec3( 0.0 );\n    \n    // camera view\n\tvec3 cw = normalize( tp-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw, cp) );\n\tvec3 cv = normalize( cross(cu, cw) );\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\n\n    float tmax = 200.0;\n    float h = 1.0;\n    float t = 0.0;\n    float iterations = 0.0;\n    for( int i = 0; i < 100; i++ ) {\n        if( h < 0.0001 || t > tmax ) break;\n        h = map( ro + t*rd );\n        t += h;\n        iterations = float(i);\n    }\n\n    if ( t < tmax ) {\n        vec3 pos = ro + t*rd;\n       \tvec3 nor = calcNormal( pos );\n        vec3 viw = normalize(-pos);\n        \n        // Ambient\n       \tcol = vec3( 0.45, 0.23, 0.2 );\n\n        // Diffuse\n       \tcol += vec3( 1.3, 0.5, 0.2 ) * clamp( dot( nor, ldir ), 0.0, 1.0 );\n        if(pos.y > -0.4)\n        {\n        \tcol *= texture(iChannel0, pos.xz * 4.0).xyz;\n            \n            // Reflection\n        \t//col += 0.2 * texture(iChannel2, -cw-viw).xyz;\n            \n        \t// Specular\n        \tcol += vec3( 0.5 ) * pow( clamp( dot( -reflect(nor, rd), ldir), 0.0, 1.0 ), 255.0);\n        }\n        else\n        {\n            col *= texture(iChannel1, pos.xz).xyz;\n            \n            // Fog?\n            col *= clamp(2.5 - length(pos), 0.0, 1.0);\n        }\n        \n        // Sky light\n       \tcol += vec3( 0.0, 0.1, 0.18 ) * clamp( nor.y, 0.0, 1.0 );\n        \n        // AO\n        col *= amb_occ(ro + (t-0.1)*rd);\n    }\n    else {\n        // Hit the sky\n        col = vec3( 0.30, 0.15, 0.1 ) * 0.7;\n        col += clamp(vec3( 0.9, 0.4, 0.3 ) * dot(rd, ldir), 0.0, 1.0);\n        col += clamp(vec3( 0.0, 0.1, 0.18 ) * dot(rd, -ldir), 0.0, 1.0);\n    }\n    \n    // Contrast\n    col = smoothstep( 0.0, 1.0, col );\n    \n    // Vigneting\n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n    \n    col += vec3(0.1,0.15,0.2) * iterations/150.0;\n        \n    col = ACESFilm(col);\n    \n    // Gamma\n    col = pow(col, vec3(0.8));\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsfGzn", "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2XD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l23Dd", "name": "dsalume_sphere", "author": "dsalume", "description": "Basic sphere as a test\n", "tags": ["sphere"], "likes": 0, "viewed": 96, "date": "1433715901", "time_retrieved": "2024-06-20T18:21:19.930851", "image_code": "#define CHECKERED_SQUARE_SIZE 0.25\n#define MAX_DEPTH 2\n#define EPSILON 0.001\n\nstruct Ray\n{\n\tvec3 pos;\n    vec3 dir;\n};\n\nstruct Triangle\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n    \nstruct Sphere\n{\n \tvec3 pos;\n    float radius;\n    vec4 color;\n};\n    \nstruct Camera\n{\n\tvec3 pos;\n    vec3 forward;\n    vec3 up;\n    vec3 right;\n};\n    \nstruct DirectionalLight\n{\n  \tvec3 dir;\n    vec4 color;\n};\n    \nstruct IntersectionInfo\n{\n\tvec3 point;\n    vec3 normal;\n    vec4 color;\n};\n\nTriangle triangles[2];\nSphere sphere = Sphere(vec3(0,0,2), 0.7, vec4(1,0,0,0));\nCamera camera = Camera(vec3(0,2,-1), normalize(vec3(0,-1,1)), normalize(vec3(0,1,1)), vec3(1,0,0));\nvec4 background = vec4(0);\nDirectionalLight dirLight = DirectionalLight(vec3(0,0,1.0), vec4(1));\nvec4 ambientLight = vec4(0.2,0.2,0.2, 1.0);\n\nvoid InitTriangles()\n{\n    vec3 verts[4];\n    verts[0] = vec3(-2,-2,0);\n    verts[1] = vec3(2,-2,0);\n    verts[2] = vec3(-2,-2,4);\n    verts[3] = vec3(2,-2,4);\n    \n    triangles[0] = Triangle(verts[0], verts[1], verts[2]);\n    triangles[1] = Triangle(verts[3], verts[2], verts[1]);    \n}\n\nmat4 GetCameraTransform(Camera camera)\n{\n\tmat4 ret = mat4(\n        vec4(normalize(camera.right), 0),\n        vec4(normalize(camera.up), 0),\n        vec4(normalize(camera.forward), 0),\n        vec4(camera.pos, 1));\n    return ret;\n}\n\nvoid Lookat(in vec3 point)\n{\n    camera.forward = normalize(point - camera.pos);\n    \n    // TODO; subtract component along forward\n    //vec3\n    \n    camera.up = normalize(cross(camera.right, camera.forward));\n\tcamera.right = normalize(cross(camera.forward, camera.up));\n}\n\nfloat AngleBetween(vec3 a, vec3 b)\n{\n\tfloat angle = acos(dot(normalize(a), normalize(b)));\n    \n    return angle;\n}\n\nvoid SolveQuadratic(float a, float b, float c, out float sol1, out float sol2)\n{\n   \tfloat discriminant = pow(b,2.0) - 4.0 * a * c;\n    \n    if (discriminant < 0.0)\n    {\n    \tsol1 = sol2 = -1.0;\n        return;\n    }\n    \n \tsol1 = (-b + sqrt(discriminant))/(2.0*a);\n    sol2 = (-b + sqrt(discriminant))/(2.0*a);\n}\n\nvec4 GetSphereColor(vec3 intersectionPoint)\n{\n    vec3 distFromCenter = intersectionPoint - sphere.pos;\n \treturn\n        vec4(normalize(intersectionPoint.xy) /\n             (min(intersectionPoint.x, min(intersectionPoint.y, intersectionPoint.z))/1.0),\n             0.5+sin(intersectionPoint.x + intersectionPoint.y + intersectionPoint.z)    \n             , 1.0);\n\n/*\t\tvec4(\n             0.5+sin(distFromCenter.x + distFromCenter.y), \n             0.5+sin(distFromCenter.y * 2.0),   \n             0.8+sin(distFromCenter.x + distFromCenter.y + distFromCenter.z)    \n             , 1.0); \n*/\n}\n\nvoid RaycastBackground(Ray ray, out vec4 color)\n{\n    color = vec4(0);\n}\n\n// https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld018.htm\nfloat RaycastTriangle(Ray ray, Triangle triangle, out IntersectionInfo intersection)\n{\n    vec3 ap = triangle.a - ray.pos;\n    vec3 bp = triangle.b - ray.pos;\n    vec3 cp = triangle.c - ray.pos;\n    vec3 normal = normalize(cross(triangle.b - triangle.a, triangle.c - triangle.a));\n    float d = -dot(triangle.a, normal);\n    float dist = -(dot(ray.pos, normal) + d) / dot(normal, ray.dir);\n        \n    if (dot(ray.dir, -normalize(cross(bp, ap))) < 0.0 ||\n        dot(ray.dir, -normalize(cross(cp, bp))) < 0.0 ||\n        dot(ray.dir, -normalize(cross(ap, cp))) < 0.0)\n    {\n        return -1.0;  \n    }\n    \n    intersection.normal = normal;\n    intersection.point = ray.pos + dist * ray.dir;\n    vec3 pa = intersection.point - triangle.a;\n    vec3 pc = intersection.point - triangle.c;\n    \n    float distab = dot(pa, normalize(triangle.b - triangle.a));\n    float distac = dot(pc, normalize(triangle.c - triangle.a));\n    \n    if ((mod(distab, CHECKERED_SQUARE_SIZE * 2.0) > CHECKERED_SQUARE_SIZE &&\n         mod(distac, CHECKERED_SQUARE_SIZE * 2.0) > CHECKERED_SQUARE_SIZE)\n        ||\n\t\t(mod(distab, CHECKERED_SQUARE_SIZE * 2.0) < CHECKERED_SQUARE_SIZE &&\n         mod(distac, CHECKERED_SQUARE_SIZE * 2.0) < CHECKERED_SQUARE_SIZE))\n    {\n    \tintersection.color = vec4(1);   \n    }\n    else\n    {\n    \tintersection.color = vec4(0);   \n    }\n    \n    return dist;\n}\n\nRay GetReflectedRay(Ray inRay, IntersectionInfo intersection)\n{\n\tvec3 reflectedDir = reflect(inRay.dir, intersection.normal);\n    return Ray(intersection.point + EPSILON * reflectedDir, reflectedDir);\n}\n\nfloat RaycastSphere(Ray ray, Sphere sphere, out IntersectionInfo intersection)\n{\n    vec3 sphereCenterToRayOrigin = ray.pos - sphere.pos;\n    float a = 1.0;\n    float b = 2.0*dot(sphereCenterToRayOrigin, ray.dir);\n    float c = dot(sphereCenterToRayOrigin,sphereCenterToRayOrigin) - pow(sphere.radius,2.0);\n    \n    float sol1, sol2, closeIntersection;\n    SolveQuadratic(a,b,c, sol1, sol2);\n    \n    closeIntersection = min(sol1, sol2);\n    \n    if (closeIntersection < 0.0)\n    {\n     \treturn -1.0;   \n    }\n    \n    intersection.point = ray.pos + closeIntersection * normalize(ray.dir);\n    sphere.color = GetSphereColor(intersection.point);\n    \n    intersection.normal = normalize(intersection.point-sphere.pos);\n    \n    float diffuse = clamp(dot(intersection.normal, normalize(dirLight.dir)), 0.0, 1.0);\n    float specular = pow(clamp(dot(reflect(dirLight.dir, intersection.normal), -ray.dir), 0.0, 1.0), 25.0);\n    vec4 result = sphere.color * diffuse + specular;\n    intersection.color = result + ambientLight * sphere.color;\n        \n    return closeIntersection;\n}\n\nbool RaycastSingle(Ray ray, out IntersectionInfo intersection)\n{\n    float dist = 0.0;\n    float minDist = 100.0;\n    IntersectionInfo currIntersection;\n    \n    dist = RaycastSphere(ray, sphere, currIntersection);\n    if (dist > 0.0)\n    {\n        minDist = dist;\n        intersection = currIntersection;\n    }\n   \n    for (int i = 0; i < 2; i++)\n    {\n        dist = RaycastTriangle(ray, triangles[i], currIntersection);\n        if (dist >= 0.0 && dist < minDist)\n        {\n            minDist = dist;\n            intersection = currIntersection;\n        }\n    }\n    \n    if (minDist == 100.0)\n    {\n    \treturn false;\n    }\n    \n\treturn true;\n}\n\nvec4 Raycast(Ray ray)\n{\n    Ray currentRay = ray;\n    IntersectionInfo intersection;\n    vec4 color;\n    if (RaycastSingle(ray, intersection))\n    {\n        color = intersection.color;\n    \tcurrentRay = GetReflectedRay(currentRay, intersection);\n\t\n    \tif (RaycastSingle(currentRay, intersection))\n        {\n    \t\tcolor = color + 0.1 * intersection.color;\n        }\n    }\n    else\n    {\n    \tRaycastBackground(ray, color);    \n    }\n    \n        vec4 reflectedColor;\n\tfor (int i = 0; i < MAX_DEPTH; i++)\n    {\n        //color = color + ;   \n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitTriangles();\n        \n    float animationDuration = 10.0;\n    float timeMod = mod(iTime,animationDuration);\n    float timeModPercent = timeMod / animationDuration;\n    //dirLight = DirectionalLight(normalize(vec3(timeMod-2.0, 1.0, 1.0)), vec4(1.0));\n    \n    float angleAroundSphere = timeModPercent * 2.0 * 3.14159;\n    camera.pos.x = sphere.pos.x + 4.0 * cos(angleAroundSphere);\n    camera.pos.z = sphere.pos.z + 4.0 * sin(angleAroundSphere);\n    \n//    Lookat(sphere.pos);\n    Lookat(vec3(0));\n    \n    float minResolution = min(iResolution.x, iResolution.y);\n    vec2 normalizedResolution = iResolution.xy/minResolution;\n    vec2 pixelSizeCamSpace = normalizedResolution / iResolution.xy;\n    vec3 imageCoordCamSpace = vec3(fragCoord/minResolution - (normalizedResolution / 2.0) + (pixelSizeCamSpace / 2.0), 1.0);\n\tvec3 imageCoordWorldSpace = (GetCameraTransform(camera) * vec4(imageCoordCamSpace, 1)).xyz;\n    Ray ray = Ray(camera.pos, normalize(imageCoordWorldSpace - camera.pos));\n    \n    //sphere.color = vec4(imageCoord.xy + 0.5,0.5+sin(imageCoord.x + imageCoord.y),1.0);    \n    \n    fragColor = Raycast(ray);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l23Dd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l2GDd", "name": "City Test", "author": "rammoskar", "description": "city", "tags": ["3d"], "likes": 1, "viewed": 161, "date": "1433704430", "time_retrieved": "2024-06-20T18:21:21.688601", "image_code": "// Based on IQ code\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n#if 0\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n#else\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif    \n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\n//----------------------------------------------------------------------\n\nfloat houses(vec3 p) {\n    vec3 po = p;\n   \n    float h = 2.0;\n    \n    vec3 b = vec3(0.15, h, 0.15);\n    \n    vec3 c = vec3(0.3, 100.0, 0.3);\n    p = mod(p,c);//-0.5*c;\n    p.y += h * 0.5;\n    vec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    \n\t/*vec3 po = p;\n    vec3 cyl = vec3(0.2,0.2,0.2);\n    vec3 c = vec3(3.0, 100.0, 3.0);\n    vec3 q = mod(p,c)-0.5*c;\n    p = q;\n\treturn length(p.xz-cyl.xy)-cyl.z - (0.05 * sin(p.y*20.0 - iTime*2.0)) + po.y * 0.12 + sin(po.x*0.1) + sin(po.z*0.1);*/\n}\n\n//----------------------------------------------------------------------\nvec2 map( in vec3 pos , vec2 uv)\n{\n    vec2 res = vec2(houses(pos), 1337.0);\n    res = opU(res, vec2(sdPlane(pos), 1));\n    return res;\n}\n\nvec2 map(in vec3 pos) {\n\treturn map(pos, vec2(0.0, 0.0));\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, vec2 uv)\n{\n    float tmin = 0.0;//1.0;\n    float tmax = 50.0;//20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;//0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<100; i++ ) //50\n    {\n\t    vec2 res = map( ro+rd*t, uv);\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd, vec2 uv)\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd,uv);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n        \n        if (m < 1.5) {\n            float w = 0.205;\n            pos.x += 0.225;\n            pos.z += 0.225;\n            if ((mod(pos.x, 0.3) > w || mod(pos.x, 0.3) < 0.3 - w) && \n                (mod(pos.z, 0.3) > w || mod(pos.z, 0.3) < 0.3 - w)) {\n           \t \tcol = vec3(0.2, 0.2, 0.2);\n            } else {\n                col = vec3(0.1, 0.1, 0.1);  \n            }\n        \tcol *= brdf;\n        }\n        \n        if (m == 1337.0) {\n            if (mod(pos.y, 0.01) > 0.005) {\n            \tcol = vec3(0.3, 0.3, 0.9);\n            } else {\n            \tcol = vec3(0.3, 0.3, 1.0);\n            }\n            \n            col *= brdf;\n        }\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\t//vec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n\t//vec3 ta = vec3(0.0, 1.0, 0.0); //vec3( -0.5, -0.4, 0.5 );\n    float t = 3.0;\n    float x = mod(time, t) > t * 0.5 ? \n        \t\ttime - t  + mod(time, t): \n    \t\t\ttime - mod(time, t);\n    \n    float z = mod(time, t) <= t * 0.5 ? \n        \t\ttime - t  + mod(time, t): \n    \t\t\ttime - mod(time, t);\n    \n    float d = 0.5;\n    time -= d;\n     float x2 = mod(time, t) > t * 0.5 ? \n        \t\ttime - t  + mod(time, t): \n    \t\t\ttime - mod(time, t);\n    \n    float z2 = mod(time, t) <= t * 0.5 ? \n        \t\ttime - t  + mod(time, t): \n    \t\t\ttime - mod(time, t);\n    x = 0.5 * x + 0.5 * x2;\n    z = 0.5 * z + 0.5 * z2;\n    time += d;\n    \n    vec3 ro = vec3(5.0 - x*0.1, 0.1, 5.0 - z*0.1);\n    vec3 ta = ro + vec3(-0.5  + 0.2*sin(time), -0.0, -0.5   + 0.2*sin(time*0.5));\n    \n    \n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    // render\t\n    vec3 col = render( ro, rd, q );\n\n    // gamma correction ?\n\t//col = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 ) /** 0.5*/;\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l2GDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lB3Wd", "name": "Shade a day 6 / 5 / 2015", "author": "cabbibo", "description": "weird mistake with cones, but looks super nice!", "tags": ["raytrace"], "likes": 4, "viewed": 143, "date": "1433451707", "time_retrieved": "2024-06-20T18:21:21.688601", "image_code": "\n#define time iTime\n\nconst float INTERSECTION_PRECISION = .01;\nconst float MAX_TRACE_DISTANCE     = 10.;\nconst int NUM_TRACE_STEPS          = 100;\n\n\nconst vec3 lightPos = vec3( 3. , 0.  , 0. );\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\n// By NIMITZ  (twitter: @stormoid)\n// good god that dudes a genius...\n\nfloat tri_1_0( float x ){ \n  return abs( fract(x) - .5 );\n}\n\nvec3 tri3_1_1( vec3 p ){\n \n  return vec3( \n      tri_1_0( p.z + tri_1_0( p.y * 1. ) ), \n      tri_1_0( p.z + tri_1_0( p.x * 1. ) ), \n      tri_1_0( p.y + tri_1_0( p.x * 1. ) )\n  );\n\n}\n                                 \n\nfloat triNoise3D_1_2( vec3 p, float spd , float time){\n  \n  float z  = 1.4;\n\tfloat rz =  0.;\n  vec3  bp =   p;\n\n\tfor( float i = 0.; i <= 3.; i++ ){\n   \n    vec3 dg = tri3_1_1( bp * 2. );\n    p += ( dg + time * .1 * spd );\n\n    bp *= 1.8;\n\t\tz  *= 1.5;\n\t\tp  *= 1.2; \n      \n    float t = tri_1_0( p.z + tri_1_0( p.x + tri_1_0( p.y )));\n    rz += t / z;\n    bp += 0.14;\n\n\t}\n\n\treturn rz;\n\n}\n\n\n\nfloat smin_2_3(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\n\n\n// exponential smooth min (k = 32);\n/*float smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}*/\n\n\nfloat sdSphere( vec3 p, float s ){\n  \n    return length( p ) - s*( (triNoise3D_1_2( p , .02 , time) + triNoise3D_1_2( p * .1 , .02 , time) * 4.) * .3 + .7);\n\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\nvoid doCamera( out vec3 camPos , out vec3 camTar , in float time ){\n\n  camPos = vec3( 0. , 0. , 2.5 );\n  camTar = vec3( 0. );\n\n}\n\nmat3 calcLookAtMatrix( vec3 camPos , vec3 camTar , float roll ){\n\n  vec3 up = vec3( sin( roll ) ,cos( roll ) , 0. );\n  vec3 ww = normalize( camTar - camPos );\n  vec3 uu = normalize( cross( ww , up ) );\n  vec3 vv = normalize( cross( uu , ww ) );\n\n  return mat3( uu , vv , ww );\n\n}\n\n\nvec2 map( vec3 pos ){\n\n\n  vec2 res = vec2(10000000. ,1. );\n\n  float fRes = res.x;\n  for( int i = 0; i < 10; i ++ ){\n   \n    vec3 p  = vec3( \n      .8 * sin( ( float( i +1)+ time* .1 ) * 2. ) ,\n      .8 * sin( ( float( i +1)+ time* .1 ) * 5. ) ,\n      .8 * sin( ( float( i +1)+ time* .1 ) * 9. ) \n    );   \n    vec2 res2 = vec2(sdCone( pos - p , vec2( 1. , .1 )  ) , 2. ); \n\n    fRes = smin_2_3( fRes , res2.x , .8);\n\n  }  \n  \n  //float fRes = -1.;\n  \n  //float fRes = smin( res.x , res2.x , 8.);\n\n  return vec2( fRes , 1.);\n\n\n\n}\n\n\n// res = result;\nvec2 calcIntersection( in vec3 ro , in vec3 rd ){\n\n  float h     = INTERSECTION_PRECISION * 2.;\n  float t     = 0.;\n  float res   = -1.;\n  float id    = -1.;\n\n  for( int i = 0; i < NUM_TRACE_STEPS; i++ ){\n      \n    if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n    \n    vec2 m = map( ro + rd * t );\n  \n    h  = m.x;\n    t += h;\n    id = m.y;\n\n  }\n\n  if( t < MAX_TRACE_DISTANCE ) res = t;\n  if( t > MAX_TRACE_DISTANCE ) id = -1.;\n\n  return vec2( res , id ); \n\n}\n\nvec3 calcNormal( vec3 pos ){\n\n  vec3 eps = vec3( 0.01 , 0. , 0. );\n  \n  vec3 nor = vec3(  \n    map( pos + eps.xyy ).x - map( pos - eps.xyy ).x,\n    map( pos + eps.yxy ).x - map( pos - eps.yxy ).x,\n    map( pos + eps.yyx ).x - map( pos - eps.yyx ).x\n  );\n\n  return normalize( nor );\n  \n\n}\n\n\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord){\n\n  vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n  \n  // Getting mouse position!\n  vec2 m = iMouse.xy/iResolution.xy;\n    \n  vec3 ro , ta;\n  \n  doCamera( ro , ta , time  );\n\n  mat3 camMat = calcLookAtMatrix( ro , ta , 0. ); \n \n  // z = lens length \n  vec3 rd = normalize( camMat * vec3( p.xy , 2. ) ); \n    \n  // Getting our mouse ray direction\n  vec3 md = normalize( camMat * vec3( m.xy , 2. ) ); \n \n  vec2 res = calcIntersection( ro , rd );\n  vec3 col = vec3( 0. );\n\n  if( res.x > 0. ){\n\n    vec3 pos = ro + rd * res.x;\n\n    vec3 lightDir = normalize( pos - lightPos );\n    vec3 nor = calcNormal( pos );\n\n    float lightMatch = max( 0. , dot( nor , lightDir ) );\n\n    vec3 refl = reflect( lightDir , nor );\n    float reflMatch = max( 0. , dot( refl , rd ) );\n\n    float rimMatch =  1. - max( 0. , dot( nor , -rd ) );\n\n\n    vec3 norCol = (nor * .5 + .5);\n\n    vec3 lambCol = ((nor * .5 + .5)* lightMatch);\n    vec3 ambiCol = ( vec3( 1. ) -norCol )*.1;\n    vec3 specCol = vec3( 1. , .8 , 0. ) * pow( reflMatch , 20. );\n    vec3 rimCol  = vec3( .4 , 1. , .8 ) * pow( rimMatch, 4. );\n    \n    col = lambCol + ambiCol + specCol + rimCol;\n\n  }\n\n  fragColor = vec4( col , 1. );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lB3Wd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lB3Wt", "name": "Study iQ's Synth - FM", "author": "tyleeer", "description": "Well, there seems to be no way to remember the time when mouse is released...", "tags": ["study"], "likes": 0, "viewed": 146, "date": "1433386730", "time_retrieved": "2024-06-20T18:21:22.009769", "image_code": "// Created by inigo quilez - iq\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Modified by Tyler\n\nvec2 pixelSpaceToUVSpace(vec2 p, vec2 resolution) {\n  vec2 uv = 2.0*p/resolution-1.0;\n  if (resolution.x > resolution.y)\n      uv[0] *= resolution.x/resolution.y;\n  else\n      uv[1] *= resolution.y/resolution.x;\n  return uv;\n}\n\nfloat signedDistanceToLine(vec2 p, vec2 n,float d) {\n \t// the line passes point d*n and has n as its normal\n    return dot(p-d*n,n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = pixelSpaceToUVSpace(fragCoord.xy,iResolution.xy); // get pixel position\n    vec2 m_uv = pixelSpaceToUVSpace(iMouse.xy,iResolution.xy); // get mouse position\n    \n    vec2 n = normalize(m_uv); // define the normal of the line\n    \n    // Calculate the scanning range required to cover the whole screen\n    float D = max(abs(signedDistanceToLine(vec2(iResolution.x/iResolution.y,-1.0),n,0.0)),\n                  abs(signedDistanceToLine(vec2(iResolution.x/iResolution.y,1.0),n,0.0)));\n    \n    float d;\n    if (iMouse.z < 0.01) {\n    \td = D*sin(iTime); // if mouse is released, let the line scan\n    }\n    else {\n        d = length(m_uv); // if mouse is clicked, let the line pass the mouse's position\n    }\n   \n    float a = smoothstep(0.0,0.001,signedDistanceToLine(uv,n,d)); // define region\n    float c = mix(0.0,0.4,a); // color the region\n    fragColor = vec4(c,c,c,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lB3Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lfSDn", "name": "crowded pillars 3", "author": "FabriceNeyret2", "description": "a variant of https://www.shadertoy.com/view/XtfSDn\nBe sure to wait long enough ;-)", "tags": ["3d", "raymarching", "short", "spheremarching"], "likes": 70, "viewed": 2740, "date": "1435667788", "time_retrieved": "2024-06-20T18:21:22.300866", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define T iTime\n#define r(v,t) { float a = (t)*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n#define SQRT3_2  1.26\n#define SQRT2_3  1.732\n#define smin(a,b) (1./(1./(a)+1./(b)))\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d,c; p.x-=.4; // init ray \n    r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);   // camera rotations\n    d = p;                                 // ray dir = ray0-vec3(0)\n    p.z += 5. *T;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float closest = 999.0;\n    f = vec4(0);\n    \n    for (float i=1.; i>0.; i-=.01)  {\n        \n        vec4 u = floor(p/8.), t = mod(p, 8.)-4., ta; // objects id + local frame\n        // vec4 u=floor(p/18.+3.5), t = p, ta,v;\n        // r(t.xy,u.x); r(t.xz,u.y); r(t.yz,1.);    // objects rotations\n        u = sin(78.*(u+u.yzxw));                    // randomize ids\n        // t -= u;                                  // jitter positions\n        c = p/p*1.2; // *vec4(1,0,0,0);\n \n        float x1,x2,x3,x=1e9, t4 = clamp(cos(T/4.),0.,1.), t8 = clamp(cos(T/8.),0.,1.);\n        // r(t.xy,u.x); r(t.xz,u.y); r(t.yz,u.z);\n        // t -= 2.*u;  \n        ta = abs(t);\n        x2 = smin(length(t.xy),smin(length(t.yz),length(t.xz))) -.7;   \n        // ta = abs(mod(p, .25)); x1 = min(ta.x,min(ta.y,ta.z))-.05; x = sqrt(x1*x1+x*x)-.0; // max(-x1,x);\n        // ta = abs(mod(p, 1.)); x1 = min(ta.x,min(ta.y,ta.z))-.4; x = sqrt(x1*x1+x2*x2)-.0; // x = max(-x1,x);\n        ta = abs(mod(p, 1.)-.2); x1 = min(ta.x,min(ta.y,ta.z)); x1 = sqrt(x1*x1+x2*x2)-.0; // x = max(-x1,x);\n        ta = abs(mod(p, 1.)+.2); x3 = min(ta.x,min(ta.y,ta.z)); x3 = sqrt(x3*x3+x2*x2)-.0; // x = max(-x1,x);\n     \tx = min(x1,x3);\n        x3 = min(length(t.xy),min(length(t.yz),length(t.xz))) -.0; //x = min(x,x3);\n        f += .7*vec4(1,1,0,0) * exp(-10.*x3)*clamp(dot(.3+.7*sin(3.*(p+8.*T+u)),vec4(1,1,1,0)),0.,1.)*t8*t4;\n        // x3 = min(x3, closest);\n        // if (x==x3) c=vec4(1,1,0,0);\n\n        if(x2<.01) f += .01*vec4(1.5,.3,.3,0)*t4; //*texture(iChannel0, t.xyz-3.)*2.;\n            \n        if(x<.01) // hit !\n            { f += i*c*1.; break;  }  // color texture + black fog \n        \n        p -= d*x;           // march ray\n     }\n    //f += vec4(1,1,0,0) * exp(-closest); // *(.5+.5*cos(T/2.)); // thanks kuvkar ! \n}\n", "image_inputs": [{"id": "4sfGzn", "previewfilepath": "/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfSDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lfSz7", "name": "My 90Hz Heart", "author": "834144373", "description": "Yean!90Hz!\nSo happy today.", "tags": ["heart"], "likes": 4, "viewed": 296, "date": "1435141270", "time_retrieved": "2024-06-20T18:21:22.306848", "image_code": "//The 90Hz heart made by 834144373zhu/2015\n//https://www.shadertoy.com/view/4lfSz7\n////////////////////////////////////////\n//Today is last of my \"First Year College life\".\n//Come on,let me have a good relax.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = -((fragCoord.xy/iResolution.xy)-vec2(0.5,0.45))*vec2(1.12,1.58);\n    \n    //here the first version,you can try it\n    float d = length(pos+vec2(pos.x,pow(abs(pos.x),0.9)));\n    \n    //here the second version,but i like the first version.....\n\t//float d = length(pos+vec2(pos.x,abs(pos.x)));\n   \n    vec3 c;\n\t\n    c.rg += smoothstep(.0,1.,.85-d);\n\t\n    //here another version is c.g/=50.2,but i like the 5.2 color\n    c.g /=5.2;\n\t\n    //My heart rate is 1.5*60 = 90Hz/m,becase one jump spend 1/1.5 s......\n\tc += pow(c.r,1.+.2*fract(iTime*1.5));\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfSz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lfSzn", "name": "iterated square 2", "author": "FabriceNeyret2", "description": ".", "tags": ["ifs", "short"], "likes": 2, "viewed": 1192, "date": "1433881128", "time_retrieved": "2024-06-20T18:21:22.525109", "image_code": "// variant from https://www.shadertoy.com/view/XtfSRn\n\nfloat n = 120.; \nfloat a = 32.*2.*3.1416;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5)); \n    float luv = length(uv)/sqrt(2.);\n\n      \n    float t = cos(.5*iTime);\n    a = a/n*pow(t,3.);   float  c=cos(a),s=sin(a);  \n    float l=1.; \n    float k = 2.+(.5+.5*cos(.1*iTime));\n    mat2 m=mat2(c,-s,s,c)*k;\n    vec4 paint = vec4(pow(.4,1.),pow(.15,1.),pow(.06,1.),1.), col=vec4(1.), p=vec4(1.);\n    \n    for (float i=0.; i<5.; i++) {\n        //if (l<luv) break;\n        float w = l/n;\n        p *= pow(paint,vec4(w,w,w,1.));\n        float d = max(abs(uv.x),abs(uv.y));\n        vec4 col0 = smoothstep(.9+.008*l,.9-.008*l,d)*p; \n           col0.a = smoothstep(.9+.008*l,.9-.008*l*(1.-abs(t)),d);\n        col = col0 + (1.-col0.a)*col;\n        l *= k;\n        uv *= m; uv -= sign(uv);\n    }\n    \n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ljGDd", "name": "Magic Fractal", "author": "dgreensp", "description": "Experiment with this beautiful, cheap-to-compute fractal.  Inspired by Kali's \"Star Nest\".", "tags": ["fractal"], "likes": 55, "viewed": 3394, "date": "1433703045", "time_retrieved": "2024-06-20T18:21:22.918931", "image_code": "const int MAGIC_BOX_ITERS = 13;\nconst float MAGIC_BOX_MAGIC = 0.55;\n\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    // scroll a certain number of screenfuls/second\n    uv.x += iTime*0.4;\n\n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    \n    float result = magicBox(p);\n    // Scale to taste.  Also consider non-linear mappings.\n    result *= 0.03;\n    \n\tfragColor = vec4(vec3(result),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ljGDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ljGWt", "name": "Power Coils", "author": "fizzer", "description": "Playing with inversion and volumetric light.", "tags": ["procedural", "inversion", "eletric"], "likes": 26, "viewed": 491, "date": "1433596911", "time_retrieved": "2024-06-20T18:21:22.918931", "image_code": "void mainImage(out vec4 c, vec2 q)\n{\n    float a=iTime*.1+1.,b=.5,g,e,t=0.,s;\n    vec3 r=vec3(0.,0.,3.),w=normalize(vec3((q-iResolution.xy/2.)/iResolution.y,-.5)),p;\n\n    mat2 x=mat2(cos(a),sin(a),sin(a),-cos(a)),y=mat2(cos(b),sin(b),sin(b),-cos(b));\n\n    w.xz=y*w.xz;\n    r.xz=y*r.xz;\n\n    w.yz=x*w.yz;\n    r.yz=x*r.yz;\n\n    c.rgb=vec3(0.,0.,.02);\n\n    for(int i=0;i<150;++i)\n    {\n        p=r+w*t;\n\n        float f=.25,d=1e4;\n        for(int j=0;j<2;++j)\n        {\n            s=.2*dot(p,p);\n            p=p/s;\n            f*=s;\n            g=p.z;\n            e=atan(p.y,p.x);\n            p=(mod(p,2.)-1.)*1.25;\n        }\n\n        d=min((length(abs(p.xy)-1.3)-.1)*f,1e2);\n\n        if(d<1e-3)\n            break;\n\n        c.rgb+=vec3(.3,.4,.8)*(pow(.5+.5*cos(g*.5+a*77.+cos(e*10.)),16.))*\n            (1.-smoothstep(0.,1.,70.*d))*.25;\n\n        t+=d;\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ljGWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4llSzN", "name": "CrossStructure", "author": "dila", "description": "Flying around some fractal structure. I think it kinda looks like bones :)", "tags": ["fractal", "camera", "path"], "likes": 15, "viewed": 316, "date": "1435000802", "time_retrieved": "2024-06-20T18:21:22.918931", "image_code": "const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n\tvec3 q = clamp(p, -s, s);\n    return length(p - q);\n}\n\nfloat wscl = 6.0;\n\nfloat map(vec3 p)\n{\n    float h = wscl * 2.0;\n\tvec3 g = (fract((p+vec3(h*0.5))/h) * 2.0 - 1.0) * h;\n    vec3 q = g;\n    for (int i = 0; i < 4; ++i) {\n        vec3 r = sign(q);\n        q = r + reflect(q - r, normalize(r));\n        vec3 aq = abs(q);\n        q -= sign(q) * min(aq.x, min(aq.y, aq.z)) * 0.5;\n    }\n    float d = box(q, vec3(1.0));\n    float tr = 0.5 + 0.5 * sin(p.z*0.5);\n    tr = mix(2.5, 6.0, tr);\n    float c = length(g.xy) - tr;\n    float e = length(g.xz) - tr;\n    float f = length(g.yz) - tr;\n    float cv = min(min(c, e), f);\n    return max(d,-cv);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 42; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.35;\n    }\n    return t;\n}\n\nvec3 textex(vec3 p)\n{\n\tvec3 ta = texture(iChannel0, vec2(p.y,p.z)).xyz;\n    vec3 tb = texture(iChannel0, vec2(p.x,p.z)).xyz;\n    vec3 tc = texture(iChannel0, vec2(p.x,p.y)).xyz;\n    return (ta + tb + tc) / 3.0;\n}\n\nvec3 shade(vec3 o, vec3 r, vec3 w, vec3 sn, float t)\n{\n    float fd = map(w);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.01 + fd * 100.0);\n    vec3 diff = textex(w);\n    \n    vec3 lit = vec3(0.5);\n    vec3 spec = vec3(0.0);\n    \n    for (int i = -1; i <= 1; i+=2) {\n        float j = float(i) * 0.5 + 0.5;\n\n        vec3 loff = vec3(0.0, 0.0, 4.0) * sign(float(i));\n\n        vec3 ldir = normalize(o + loff - w);\n\n        vec3 lcol = mix(vec3(1.0,1.0,0.5), vec3(0.5,1.0,1.0), j);\n        \n        lit += max(dot(sn,ldir), 0.0) * lcol;\n\n        vec3 refl = reflect(ldir, -sn);\n        float spr = clamp(dot(refl, r), 0.0, 1.0);\n        spr = pow(spr, 4.0);\n        \n        spec += lcol * spr;\n    }\n\n    diff *= lit;\n    diff += spec * 0.5;\n    return diff * fog;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, iTime*2.0);\n    vec3 r = normalize(vec3(uv, 1.2));\n    r *= zrot(iTime*0.25);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n\tvec3 sc = shade(o, r, w, sn, t);\n    \n\tfragColor = vec4(sqrt(sc), 1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4llSzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lSGDd", "name": "Looking Face", "author": "cabbibo", "description": "trying to make faces", "tags": ["raytrace"], "likes": 5, "viewed": 155, "date": "1433455765", "time_retrieved": "2024-06-20T18:21:24.525263", "image_code": "\n#define time iTime\n\nconst float INTERSECTION_PRECISION = .001;\nconst float MAX_TRACE_DISTANCE     = 10.;\nconst int NUM_TRACE_STEPS          = 130;\n\nconst vec3 lightPos = vec3( 3. , 0.  , 0. );\n\nvec3 lookPos;\n\n\nfloat smin_2_3(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n\nvoid doCamera( out vec3 camPos , out vec3 camTar , in float time ){\n\n  camPos = vec3( 0. , 0. , 1.5 );\n  camTar = vec3( 0. );\n\n}\n\nmat3 calcLookAtMatrix( vec3 camPos , vec3 camTar , float roll ){\n\n  vec3 up = vec3( sin( roll ) ,cos( roll ) , 0. );\n  vec3 ww = normalize( camTar - camPos );\n  vec3 uu = normalize( cross( ww , up ) );\n  vec3 vv = normalize( cross( uu , ww ) );\n\n  return mat3( uu , vv , ww );\n\n}\nfloat sdPlane( vec3 pos ){\n return pos.y;   \n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xy), -p.z - c.z );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n\n    vec2 w = v - q;\n\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n\n    vec2 d = max(qv,0.0)*qv/vv;\n\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nmat3 matInverse( mat3 m ){\n    \n  \n    vec3 a = vec3(\n      \n        m[1][1] * m[2][2] - m[2][1] * m[1][2],\n        m[0][2] * m[2][1] - m[2][2] * m[0][1],\n        m[0][1] * m[1][2] - m[1][1] * m[0][2]\n        \n    );\n    \n    vec3 b = vec3(\n      \n        m[1][2] * m[2][0] - m[2][2] * m[1][0],\n        m[0][0] * m[2][2] - m[2][0] * m[0][2],\n        m[0][2] * m[1][0] - m[1][2] * m[0][0]\n        \n    );\n    \n     vec3 c = vec3(\n      \n        m[1][0] * m[2][1] - m[2][0] * m[1][1],\n        m[0][1] * m[2][0] - m[2][1] * m[0][0],\n        m[0][0] * m[1][1] - m[1][0] * m[0][1]\n        \n    );\n    \n    \n    return mat3( \n        \n       a.x , a.y , a.z ,\n       b.x , b.y , b.z ,\n       c.x , c.y , c.z\n        \n    );\n    \n \n  \n    \n}\n\nfloat face( vec3 pos , vec3 p , mat3 rot ){\n    \n    mat3 iRot = matInverse( rot );\n    \n    vec3 headPos  = iRot * ( pos - p );\n    vec3 nosePos  = iRot * ( pos - p );\n    vec3 lePos    = iRot * ( pos - p + rot * vec3( -.1 , -.1 , 0.));\n    vec3 rePos    = iRot * ( pos - p + rot * vec3( .1 , -.1 , 0.));\n    vec3 mouthPos = iRot * ( pos - p + rot * vec3( 0. , .12 , 0.));\n\n    \n   \tfloat nose = sdCappedCone( nosePos , vec3( .1 , .04 , .1 ) );\n    float head = udBox( headPos , vec3( .2 , .2 , .01 ));\n    \n    float re = sdSphere( rePos , .03 );\n    float le = sdSphere( lePos , .03 );\n    \n    float mouth = sdTorus( mouthPos , vec2( .04 , .02 ));\n\n    float f = head;\n    \n    f = smin_2_3( f , nose  , .04 );\n    f = smin_2_3( f , le    , .04 );\n    f = smin_2_3( f , re    , .04 );\n    f = smin_2_3( f , mouth , .04 );\n                       \n    return f;\n    \n}\n\nfloat fire( vec3 pos ){\n\n    vec3 p = vec3( 0. , -.3 , 0.5 );\n    float f = sdSphere( pos - p  , .1 ); \n    \n    \n    for( int i  = 0; i < 10; i++ ){\n        \n       float h = mod( time * (abs( sin( float( i + 5 ))) +.3) * .05 , .3 );\n       p  = vec3( \n         sin( ( h + .2) * float( i + 5 ) ) * .8 * h,\n         h * 2. - .3,\n         cos(( h +.3) * float( i + 5 ) ) * .8 * h + .5\n       );   \n       \n       float r = abs( sin( p.x * time * .01 )  + sin( p.y * float( i +4 ) * time * .001 ));\n       float v = sdSphere( pos - p  , (.3 - h ) * .2 ); \n       f = smin_2_3( f , v  , .04 );\n       \n        \n\t}\n    \n    \n    return f;\n    \n}\n\n\n\nvec2 map( vec3 pos ){\n\n\n  vec2 res = vec2( sdSphere( pos - lookPos , .01 ) ,1. );\n  vec2 res2;\n  for( int i = 0; i < 4; i ++ ){\n   \n  \n    vec3 p = vec3( (((float( i )+.5) / 4. ) - .5 ) * 2., 0.,0.);\n      \n    mat3 rot = calcLookAtMatrix( p , lookPos , 0. );\n      \n    res2 = vec2(face( pos , p , rot) , float( i ) ); \n\n    res = opU( res , res2 );\n\n  }  \n    \n  res2 = vec2( fire( pos ) , 10. );\n    \n  res = opU( res , res2 );\n    \n  res2 = vec2( sdPlane( pos  - vec3( 0. , -.5 , 0. ) ), 100. );\n  res = opU( res , res2 );\n    \n\n  return res;\n\n\n\n}\n\n\n// res = result;\nvec2 calcIntersection( in vec3 ro , in vec3 rd ){\n\n  float h     = INTERSECTION_PRECISION * 2.;\n  float t     = 0.;\n  float res   = -1.;\n  float id    = -1.;\n\n  for( int i = 0; i < NUM_TRACE_STEPS; i++ ){\n      \n    if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n    \n    vec2 m = map( ro + rd * t );\n  \n    h  = m.x;\n    t += h;\n    id = m.y;\n\n  }\n\n  if( t < MAX_TRACE_DISTANCE ) res = t;\n  if( t > MAX_TRACE_DISTANCE ) id = -1.;\n\n  return vec2( res , id ); \n\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 render( vec3 ro , vec3 rd ){\n   \n  vec2 res = calcIntersection( ro , rd );\n  vec3 col = vec3( 1. );\n\n  if( res.x > 0. ){\n\n\tvec3 pos = ro + rd * res.x;\n      vec3 nor = calcNormal( pos );\n\n      float AO = calcAO( pos , nor );\n\n      float fix = pow( AO , .4 );\n      \n      vec3 coloa = vec3( .6 , .2 , .1 );\n      \n      // fire\n      if( res.y > 9.9 ){\n          coloa = vec3( .6 , .4 , .2 ); \n      }\n      \n      if( res.y > 99.9 ){\n      \tcoloa = vec3( .2 , .2 , .5 );    \n      }\n      \n      coloa *= nor * .5 + .5;\n      col = mix( vec3( 1. ) , coloa , 1. - fix );\n\n  }\n    \n  return col;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord){\n\n  vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n  \n  // Getting mouse position!\n  vec2 m =  ( -iResolution.xy + 2.0 * iMouse.xy ) / iResolution.y;;\n    \n  vec3 ro , ta;\n  \n  doCamera( ro , ta , time  );\n\n  mat3 camMat = calcLookAtMatrix( ro , ta , 0. ); \n \n  // z = lens length \n  vec3 rd = normalize( camMat * vec3( p.xy , 2. ) ); \n    \n  // Getting our mouse ray direction\n  vec3 md = normalize( camMat * vec3( m.xy , 2. ) ); \n    \n  lookPos = ro + md * 1.;\n    \n  //lookPos = vec3( 0. , -.3 , .5 );\n \n  vec3 col = render( ro , rd );\n\n  fragColor = vec4( col , 1. );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lSGDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lsXzM", "name": "crowded psychedelic place", "author": "FabriceNeyret2", "description": "a psychedelic variant of https://www.shadertoy.com/view/ltfXRM :-)", "tags": ["3d", "raymarching", "short", "spheremarching"], "likes": 2, "viewed": 1235, "date": "1435336692", "time_retrieved": "2024-06-20T18:21:24.779827", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define T iTime\n#define r(v,t) { float a = t*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d,c; p.x-=.4; // init ray \n     r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);   // camera rotations\n    d = p;                                 // ray dir = ray0-vec3(0)\n    p.z += 5.*T;\n    \n    for (float i=1.; i>0.; i-=.01)  \n    {\n        vec4 u = floor(p/8.), t = mod(p, 8.)-4.; // objects id + local frame\n         r(t.xy,u.x); r(t.xz,u.y); r(t.yz,1.);    // objects rotations\n        u = sin(78.*(u+u.yzxw));                 // randomize ids\n        t -= u;                                  // jitter positions\n        u = .5+.5*u;\n        \n        t = abs(t);     // here for relief X symmetry\n        //c = texture(iChannel0, t.zxy-3.);  // c for color, c.x for displacement\n        c = p/p;                            // just the canonical shape           \n        // c = mix(p/p,c,.5+.5*sin(T)); \n\n        // t = abs(t);  // here for no relief symmetry\n        // float x = min(t.y, length(t.xz) -1.5 + 1.*c.x); // pilars\n        float x1 = length(t.xyz) -3.6 + c.x;           // spheres\n        float x2 = max(t.x,max(t.y,t.z)) -3. + c.x;      // bricks\n        float x = max(-x1,x2);\n        // float x = ( u.x>.6? length(t.xyz)-.5 :max(t.x,max(t.y,t.z)) ) -2. + c.x; // sphs+bricks\n \n        // f = p/p*p.w*.01;                // show depth\n        // f = p/p*x*100.;                 // show dist\n        f = c*mix(1.,i*i*4.,.5+.5*sin(T));      // color texture + black fog (try c alone !)\n        // f *= (.5+.5*u)*vec4(1,1,.005,1);     // gradient block coloring (set off random id)\n        f *= u*.5;                              // random block coloring\n\n        if(x<.01) break;    // hit !\n        p -= d*x;           // march ray\n     }\n}\n", "image_inputs": [{"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lsXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lXSDr", "name": "raymarch'd ball + plane", "author": "kaminate", "description": "positions are in world-space", "tags": ["raymarching"], "likes": 3, "viewed": 223, "date": "1435689356", "time_retrieved": "2024-06-20T18:21:25.597928", "image_code": "const float degreesToRadians = 3.14159 / 180.0;\nconst float rayEpsilon = 0.01;\nconst int rayIterations = 50;\nconst float exposure = 1.5;\nconst float tau = 6.2831853071;\n\n// http://filmicgames.com/archives/75\nvec3 TonemapAndGammaCorrection( vec3 color )\n{\n  color *= exposure;\n\n  vec3 x = max(vec3( 0 ),color- vec3( 0.004 ) );\n  vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n  return retColor;\n}\n\nfloat Sphere( vec3 position, vec3 spherePosition, float sphereRadius )\n{\n  return length(  position - spherePosition ) - sphereRadius;\n}\n\nfloat Plane( vec3 position, vec4 plane ) // ax + by + cz + d = 0\n{\n  return dot(  position, plane.xyz ) + plane.w;\n}\n\n\nfloat map( vec3 position )\n{   \n\n  float sphereRadius = 0.5;\n  vec3 spherePosition = vec3( \n      0,\n      0,\n      sphereRadius + abs(sin(iTime*5.0)) );\n  float sphereDist = Sphere( position, spherePosition, sphereRadius );\n  float dist = min( \n      sphereDist,\n      Plane( position, vec4( 0, 0, 1, 0 ) ) );\n  return dist;\n}\n\nvec3 GetNormal( vec3  position )\n{\n  float epsilon= 0.1;\n  vec3 dx = vec3(epsilon,0,0);\n  vec3 dy = vec3(0,epsilon,0);\n  vec3 dz = vec3(0,0,epsilon);\n\n  return normalize( vec3(\n        map( position + dx )- map( position - dx ),\n        map( position + dy )- map( position - dy ),\n        map( position + dz )- map( position - dz ) ) );\n}\n\n// https://www.shadertoy.com/view/lsf3zr\n// stolen shamelessly from iq catacombs.\n// TODO: look at how this works\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float ao = 0.0;\n  float sca = 15.0;\n  for( int i=0; i<5; i++ )\n  {\n    float hr = 15.0*(0.01 + 0.015*float(i*i));\n    float dd = map( pos + hr*nor );\n    ao += (hr-dd)*sca/15.0;\n    sca *= 0.5;\n  }\n  return 1.0 - clamp( ao, 0.0, 1.0 );\n}\n\nvoid Raymarch(\n    vec3 rayPosition,\n    vec3 rayDirection,\n    out float rayDepth,\n    out int iteration )\n{\n  rayDepth = 0.0;\n  iteration = 0;\n  for( int i = 0; i < rayIterations; ++i )\n  {\n    vec3 rayPoint = rayPosition + rayDirection * rayDepth;\n    float rayDist = map( rayPoint );\n    rayDepth += rayDist;\n    if( rayDist < rayEpsilon )\n    {\n      iteration = i;\n      break;\n    }\n\n    ++iteration;\n  }\n}\n\nvec3 AddLight(\n    vec3 lightPosition,\n    vec3 lightColor,\n    float lightIntensity,\n    vec3 geometryNormal,\n    vec3 geometryPosition )\n{\n  vec3 lightToGeometry = geometryPosition - lightPosition;\n  float distLightToGeometry = length( lightToGeometry );\n\n  float attenuation = 1.0 / ( distLightToGeometry * distLightToGeometry );\n\n  vec3 lightDirection = lightToGeometry / distLightToGeometry;\n  float ndotl = max( 0.0, dot( geometryNormal, -lightDirection ) );\n\n  return ndotl * lightColor * attenuation * lightIntensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 ndcPixel = ( fragCoord.xy / iResolution.xy * 2.0 ) - 1.0;   \n  float aspectRatio = iResolution.x / iResolution.y;\n  vec3 wsUp = vec3( 0, 0, 1 );\n\n  // camera parameters\n  vec3 wsCamPos = vec3( 0, -6 , 1 );\n  vec3 wsCamDirection = vec3( 0, 1, 0 );\n  vec3 wsCamRight = -normalize( cross( wsUp, wsCamDirection ) );\n  vec3 wsCamUp = cross( wsCamRight, wsCamDirection );\n  float camNear = 0.1;\n  float camFar = 100.0;\n  float camFovY = degreesToRadians * 60.0;\n\n  float wsHalfProjH = camNear * tan( camFovY / 2.0 );\n  float wsHalfProjW = wsHalfProjH * aspectRatio;\n\n  vec3 wsCenterPixel = wsCamPos + wsCamDirection * camNear;\n  vec3 wsCurrentPixel = \n    wsCenterPixel + \n    wsCamRight * wsHalfProjW * ndcPixel.x +\n    wsCamUp * wsHalfProjH * ndcPixel.y;\n\n  vec3 rayPosition = wsCurrentPixel;\n  vec3 rayDirection = normalize( wsCurrentPixel - wsCamPos );\n\n  float rayDepth;\n  int iteration;\n  Raymarch( rayPosition, rayDirection, rayDepth, iteration );\n\n  vec3 wsHitPoint = rayPosition + rayDirection * rayDepth;\n  vec3 wsHitNormal = GetNormal( wsHitPoint );\n\n\n  vec3 color = vec3( 0, 0, 0 );\n\n  for( int i = 0; i < 3; ++i )\n  {\n    float offset = float( i ) * tau / 3.0;\n    vec3 lightPosition = vec3(\n        2.0 * sin( iTime + offset ), \n        2.0 * cos( iTime + offset ), \n        2.0 );\n    vec3 lightColor = vec3(0,0,0);\n    lightColor[ i ] = 1.0;\n    float lightIntensity = 1.0;\n\n    color += AddLight(\n        lightPosition,\n        lightColor,\n        lightIntensity,\n        wsHitNormal,\n        wsHitPoint );\n  }\n\n\n  color *= calcAO( wsHitPoint, wsHitNormal );\n  color = TonemapAndGammaCorrection( color );\n  fragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lXSDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t2GDd", "name": "Splattered Sphere", "author": "dgreensp", "description": "An application of https://www.shadertoy.com/view/4ljGDd", "tags": ["procedural", "fractal", "sphere"], "likes": 5, "viewed": 1368, "date": "1433775891", "time_retrieved": "2024-06-20T18:21:25.973859", "image_code": "const float MAGIC_BOX_MAGIC = 0.56;\n\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float tot = 0.0;\n    float L = length(p), L2;\n    \n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n\n    \n    return tot;\n}\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * (fragCoord.xy - 0.5*iResolution.xy) / iResolution.yy;\n        \n    vec3 sph = vec3(uv.x, uv.y, sqrt(1.-dot(uv,uv)));\n    float ang = iTime*1.0;\n    mat3 rot = mat3(-sin(ang),0.0,cos(ang),0.,1.,0.,cos(ang),0.,sin(ang));\n    mat3 M2 = M*rot;\n    float q = magicBox(vec3(0.6,0.3,0.4)+0.2*M2*sph);\n    \n    float a = 1. - smoothstep(14., 16., q);\n    \n\tfragColor = vec4(vec3(a),1.0) * (vec4(0.3,1.0,0.3,1.0) * (0.3+0.7*dot(sph,normalize(vec3(-1.,1.,1.)))));\n    \n    if (dot(uv,uv) > 1.) fragColor=vec4(vec3(0.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t2GDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t2GW3", "name": "Arabesque #2", "author": "mplanck", "description": "Second draft of a series that began with [url]https://www.shadertoy.com/view/4lBGWW[/url]. ", "tags": ["raytrace", "arabesque"], "likes": 52, "viewed": 3306, "date": "1433622932", "time_retrieved": "2024-06-20T18:21:26.773951", "image_code": "#define REALLY_SMALL_NUMBER 0.0001\n#define BIG_NUMBER 1000000.\n#define PI 3.14159\n#define TWO_PI 6.28318\n\nfloat g_time = 0.;\n    \n// Reference: http://geomalgorithms.com/a05-_intersect-1.html. Does an\n// intersection test against a plane that is assumed to be double sided and\n// passes through the plane_origin and has the specified normal.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that ray_origin + t*ray_direction = intersection point\nvec2 intersect_plane(vec3 ray_origin,\n                     vec3 ray_direction,\n                     vec3 plane_origin,                     \n                     vec3 plane_normal)\n{\n    float ray_direction_dot_normal = dot(ray_direction, plane_normal);\n\n    float denominator = ray_direction_dot_normal;\n    \n    float intersected = 0.;\n    float t = BIG_NUMBER;\n    if (abs(denominator) > REALLY_SMALL_NUMBER) {\n        t = -dot(plane_normal, (ray_origin - plane_origin)) / denominator;    \n        if (t > REALLY_SMALL_NUMBER) {\n            intersected = 1.;\n        }\n    }\n    return vec2(intersected, t);\n\n}\n\nfloat grayscale(vec3 c)\n{\n    return dot(c, vec3(.21, .72, .07));\n}\n\nvoid mirror_test(vec3 o, vec3 r, vec3 po, vec3 pn,\n                 inout vec3 rn,\n                 inout float t)\n{\n    \n    vec2 hr = intersect_plane(o, r, po, pn);\n    if (hr.x > .5 && t > hr.y)\n    {\n        rn = pn;\n        t = hr.y;\n    }\n}\n\nfloat dist_to_line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 l = normalize(b-a);\n    return length((a-p) - dot((a - p), l) * l);    \n}\n\nvec3 shade_end(vec3 hp, float reflect_depth)\n{\n\n    float sr = .02 * mod(reflect_depth - 160. * g_time, 50.);\n\n    float sm = texture(iChannel0, vec2(.0, .5)).r;\n    \n    //vec3 c = mix(vec3(1.2, .8, .1), vec3(1., .0, .0), sr);\n    //vec3 c = mix(vec3(.8), vec3(0.05), sr);\n    vec3 c = mix(vec3(1.2, .8, .1), vec3(1., -.1, .0), sr);\n    \n    c += .5 * pow((1. - sr), 4.);\n    float sp = BIG_NUMBER;\n    \n    vec2 p1 = vec2(0., sin(10. * g_time));\n    vec2 p2 = vec2(-.866, -.5 * sin(5. * g_time));\n    vec2 p3 = vec2(.866, -.5 * sin(10. * g_time + 3.14));\n    \n    sp = min(dist_to_line(hp.xz, p1, p2), sp);\n    sp = min(dist_to_line(hp.xz, p2, p3), sp);\n    sp = min(dist_to_line(hp.xz, p3, p1), sp);    \n\n    c = (.4 + .6 * smoothstep(0., .6, sp)) * (.5 + .5 * smoothstep(0., .08, sp)) * c;\n\n    float sb = BIG_NUMBER;\n    vec2 b1 = vec2(0., 1.732);\n    vec2 b2 = vec2(-1.6, -1.);\n    vec2 b3 = vec2(1.732, -1.);\n    \n    sb = min(dist_to_line(hp.xz, b1, b2), sb);\n    sb = min(dist_to_line(hp.xz, b2, b3), sb);\n    sb = min(dist_to_line(hp.xz, b3, b1), sb);    \n\n    \n    c = (.8 + .2 * smoothstep(0., .5, sb)) * (.2 + .8 * smoothstep(0., .08, sb)) * c;\n    \n    return c;\n}\n\nvec3 trace_arabesque(vec3 rd, \n                     vec3 ro)\n{\n \n    vec3 r = rd;\n    vec3 o = ro;  \n    vec3 c = vec3(0.);\n    for (float i = 0.; i < 35.; i += 1.)\n    {\n        float t = BIG_NUMBER;\n        vec3 hn = vec3(0.);\n\n        // Test intersection with the mirrors of the arabesque\n        mirror_test(o, r, vec3(.5, 0., .866),  vec3(.866, 0., .5),  hn, t);\n        mirror_test(o, r, vec3(0., 0., -1.),   vec3(0., 0., 1.),    hn, t);\n        mirror_test(o, r, vec3(-.5, 0., .866), vec3(-.866, 0., .5), hn, t);        \n\n        // Now test the shaded plane at the bottom of the arabesque\n        vec2 pt = intersect_plane(o, r, vec3(0., -10., 0.), vec3(0., 1., 0.));\n        if (pt.x > .5 && t > pt.y)\n        {\n            t = pt.y;\n            vec3 hp = o + r * t;\n            c += shade_end(hp, i);\n            break;\n        }\n\n        // If loop isn't broken, reflect the mirrors of the arabesque \n        // and repeat\n        o = o + r * t;\n        r = reflect(r, hn);\n\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    g_time = .1 * iTime;\n    \n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.y *= invar;\n    \n    vec3 iz = vec3(0., -1., 0.);\n    vec3 ix = vec3(cos(1. * g_time), 0., sin(1. * g_time));\n    vec3 iy = normalize(cross(ix, iz));\n    \n    vec3 o = vec3(0., 5. * sin(2. * g_time + PI * iMouse.x/iResolution.x) + 8., 0.);\n    vec3 r = normalize(ix * uv.x + iy * uv.y + .3 * iz);\n        \n    vec3 c = trace_arabesque(r, o);\n    \n    // gamma correct\n    c = pow(c, vec3(.45));\n    \n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t2GW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tB3Wt", "name": "lotus flower", "author": "tabularasa1992", "description": "lotus flower test", "tags": ["color", "polar"], "likes": 2, "viewed": 144, "date": "1433391463", "time_retrieved": "2024-06-20T18:21:26.773951", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = vec2( fragCoord.xy - 0.*iResolution.xy );\n    st = st.xy/iResolution.y;\n    st.x -= .5;\n    vec3 color = vec3(0.0);\n\n    vec2 pos = vec2(0.5)-st;\n\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n\n    float f;\n    f=2.+(((abs(cos(a*3.)))+(0.35-(abs(cos(a*3.+3.14/2.))))*2.)/(2.+abs(cos(a*6.+3.14/2.))*8.));\n    //f/=0.5;\n    \n    f = pow(f,(sin((iTime + 47.)/10.) + 1.) * 15.);\n    \n  \tvec3 ring1 = vec3(1.-smoothstep(f,f+0.2,r) - (1.-smoothstep(f-0.2,f,r)));\n    color = ring1;\n \n    for (int i = 0; i < 30; i++){\n        f/=1.3;\n        vec3 ring = vec3(1.-smoothstep(f,f+0.2,r) - (1.-smoothstep(f-0.2,f,r)));\n            color += ring;\n    }\n    \n    color *= vec3(abs(sin(iTime * 2. + r)), abs(cos(iTime/2. + r)), abs(sin(iTime + r)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tB3Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tBGDt", "name": "Ray marching cube minus sphere", "author": "kjfung", "description": "I'm a scrub at this", "tags": ["march"], "likes": 1, "viewed": 191, "date": "1433390559", "time_retrieved": "2024-06-20T18:21:26.773951", "image_code": "float distToBox(vec3 p, float side) {\n    vec3 d = abs(p) - side;\n    float box = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    float sphere = -(-length(p) + side + 15.0);\n    return max(-sphere, box);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Setup properties of the eye along with its orientation\n\tvec3 eye   = vec3(200.0 * sin(iTime), 0.0, 200.0 * cos(iTime));\n    float focal = 200.0;\n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 focus = vec3(0.0, 0.0, 0.0);\n    \n    //Calculate eye directions\n    vec3 look  = focus - eye;\n    vec3 right = cross(look, up);\n    \n    //Calculate this particular pixel's normalized coordinates\n    //on the virtual screen\n    float screenX = (2.0 * fragCoord.x)/(1.0 * iResolution.x) - 1.0;\n    float screenY = (2.0 * fragCoord.y)/(1.0 * iResolution.y) - 1.0;\n\n    //Calculate the direction that the ray through this pixel goes\n    vec3 dir = normalize(focal * normalize(look) \n               + screenX * normalize(right) * iResolution.x/2.0\n               + screenY * normalize(up) * iResolution.y/2.0);\n\n    //Ray march\n    vec3  p = eye + dir;\n    float d = distToBox(p, 50.0);\n    vec3  e = vec3(0.0005, 0.0, 0.0);\n    \n    for(int i = 0; i < 256; i++)\n    {\n        if(d <= e.x)\n        {\n            vec3 normal = normalize(vec3(distToBox(p + e.xyy, 50.0) - d,\n                \t\t\t\t\t     distToBox(p + e.yxy, 50.0) - d,\n                \t\t\t\t\t     distToBox(p + e.yyx, 50.0) - d));\n            float lighting = dot(normalize(vec3(0.5, 1.0, 1.0)), normal);\n            fragColor = vec4(1.0, 1.0, 1.0, 1.0) * lighting;\n            return;\n        }\n        p = p + d * normalize(dir);\n        d = distToBox(p, 50.0);\n    }\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tBGDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tfSzn", "name": "maelstrom 70ties", "author": "FabriceNeyret2", "description": ".", "tags": ["noise"], "likes": 24, "viewed": 1480, "date": "1433879678", "time_retrieved": "2024-06-20T18:21:26.773951", "image_code": "#define PI 3.1415927\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\nvec2 sfbm2( vec3 p ) {\n    return 2.*vec2(fbm(p),fbm(p-327.67))-1.;\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (iMouse.z<0.) \n         mouse = vec2(.9,.5)*vec2(cos(1.*t)+.5*sin(2.2*t),sin(1.1*t)+.5*cos(1.9*t))/1.5;   \n    else \n            mouse = 2.*mouse-1.;\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.9,.5));\n    float a = .1*iTime, c=cos(a), s=sin(a); mat2 m = mat2(c,-s,s,c);\n    \n    vec4 col=vec4(0.);\n    //vec3 paint = vec3(.7,.5,.4);\n    vec3 paint = vec3(.3,.9,.7);\n    \n    for(float z=0.; z<1.; z+= 1./30.) {\n        paint = .5+.5*cos(4.*2.*PI*z+vec3(0.,2.*PI/3.,-2.*PI/3.));\n        uv *= m;\n        vec2 duv = vec2(.8,.5)*sfbm2(vec3(1.2*uv,3.*z+iTime)) - 3.*z*mouse;\n    \tfloat d = length(uv+duv)-1.2*(1.-z),\n              a = smoothstep(.1,.09,abs(d)); \n        d = .5*a+.5*smoothstep(.09,.08,abs(d));\n        col += (1.-col.a)*vec4(d*paint*exp(-0.*z),a);\n        if (col.a>=.9) break;\n    }\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tlSzr", "name": "RoundRect", "author": "mlepage", "description": "Simple rounded rectangle.", "tags": ["procedural", "2d"], "likes": 9, "viewed": 1030, "date": "1434120027", "time_retrieved": "2024-06-20T18:21:26.780640", "image_code": "// Created by Marc Lepage - mlepage/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Rect radius\nfloat radius = 32.0;\n\n// Background color\nvec4 bgColor = vec4(0, 0, 0, 1);\n\n// Rounded rect distance function\nfloat udRoundRect(vec2 p, vec2 b, float r)\n{\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Rect center and half size\n    vec2 center = iResolution.xy / 2.0;\n    vec2 hsize = iResolution.xy / 2.0;\n\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec4 contentColor = vec4(uv, 0.5 + 0.5*sin(iTime), 1.0);\n\n    // Simple animation (comment out to fill viewport)\n    center += iResolution.xy * 0.25*sin(iTime/3.0);\n    hsize *= (0.5 + 0.25*cos(iTime/5.0));\n    radius = max(abs(radius*cos(iTime/7.0)), 8.0);\n    \n    // Mix content with background using rounded rectangle\n\tfloat a = clamp(udRoundRect(fragCoord - center, hsize - radius, radius), 0.0, 1.0);\n    fragColor = mix(contentColor, bgColor, a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlSzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tlXR4", "name": "matrix - 255 char", "author": "FabriceNeyret2", "description": "compacting to 2-tweets  patriciogv's Matrix shader https://www.shadertoy.com/view/MlfXzN \n( 819 -> 255 chars )\nBut first go see patriciogv's comments and readable sources :-D", "tags": ["font", "2tweets", "short", "pseudofont"], "likes": 45, "viewed": 3196, "date": "1434898356", "time_retrieved": "2024-06-20T18:21:27.095048", "image_code": "// the 2-tweets version of patriciogv's Matrix  https://www.shadertoy.com/view/MlfXzN \n\n// 255   ( -21 with the slight look-changing suggestions in comments )\n\n\n\n#define r(s) fract(43.*sin(s.x*13.+s.y*78.))\n\nvoid mainImage(out vec4 o, vec2 i){\n    vec2 j = fract(i*=50./iResolution.x), \n         p = i-j+ vec2(2,floor(iTime*20.*fract(sin(i-j).x)));   // iDate.w: -4 chars\n    i = abs(j-.5);\n    o =  vec4(r(floor(p*23.+5.*j))>.5&&i.x<.3&&i.y<.45 ?   1. - r(p)*(2.-dot(i,i)*6.)  :  1.);\n // o +=  r(floor(p*23.+5.*j))>.5&&i.x<.3&&i.y<.45 ?   1. - r(p):  1.;  // -17 chars\n}\n\n\n\n\n\n\n\n\n/* // 258\n#define r(s) fract(43.*sin(s.x*13.+s.y*78.))\n\nvoid mainImage(inout vec4 o, vec2 i){\n    vec2 p = floor(i*= 50./iResolution.x), j=i-p; i=abs(j-.5);\n    p += vec2(2,floor(iTime*20.*fract(sin(p.x)))); \n    o +=  r(floor(p*23.+5.*j))>.5 && i.x<.3&&i.y<.45 ? 1. - r(p)*(2.-dot(i,i)*6.)  :  1.;\n}\n*/\n\n\n/* // 270\n#define r(s) fract(43.*sin(s.x*13.+s.y*78.))\n\nvoid mainImage(inout vec4 o, vec2 i){\n\ti *= 50./iResolution.x;\n    vec2 p = floor(i); i -= p; \n    p += vec2(2,floor(iTime*20.*fract(sin(p.x)))); \n\to +=  r((p*23.+floor(5.*i)))>.5 ? r(p) : 0.;\n    i=abs(i-.5); \n    o = 1.- o *  (2.-dot(i,i)*6.) * (i.x<.3&&i.y<.45?1.:0.);\n}\n*/\n\n\n/*  // 273\n#define r(s) fract(43.*sin(s.x*13.+s.y*78.))\n\nvoid mainImage(inout vec4 o, vec2 i){\n\ti *= 50./iResolution.x;\n    vec2 p = floor(i); i -= p; \n    p += vec2(2,floor(iTime*20.*fract(sin(p.x)))); \n\to +=  r(p) * step(.5,r((p*23.+floor(5.*i))));\n    i=abs(i-.5); \n    o = 1.- o *  (2.-dot(i,i)*6.) * (i.x<.3&&i.y<.45?1.:0.);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tlXRN", "name": "My First Ugly Shader", "author": "834144373", "description": "...", "tags": ["uglyshader"], "likes": 1, "viewed": 203, "date": "1434959996", "time_retrieved": "2024-06-20T18:21:27.646653", "image_code": "//thanks inigo quilez's articles and other people's codes.\n//\"My First Ugly Shader\" by 834144373zhu/2015\n//https://www.shadertoy.com/view/4tlXRN\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define time iTime*0.1\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat theTorus(vec3 p){\n\tvec2 t = vec2(.3,0.2);\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 P2CameraSpace(in vec3 camPos,in vec3 p){\n\tvec3 dian = vec3(0,0,0);\n\tvec3 ArixY = vec3(0,1,0);\n\tvec3 z = normalize(dian - camPos);\n\tvec3 x = normalize(cross(z,ArixY));\n\tvec3 y = normalize(cross(z,x));\n\n\tvec3 theCameraSpaceP = vec3(\n\t//dot(p,x),dot(p,y),dot(p,z)\n\tp.x*x + p.y*y + p.z*z\n\t//mul(mat(x,y,z),p)\n\t//mul(p,mat(x,y,z))\n\t\t\t\t\n\t);\n\n\treturn theCameraSpaceP;\n}\n\nfloat map(in vec3 pos){\n\tpos.xyz = mod(pos.xyz,4.4)-2.2;\n\tfloat d;// = sdSphere(pos,1.);\n\t//d = opU(d,udBox(pos,vec3(0.3,1.,1.2)));\n    d = theTorus(pos);\n    d = max(d,udBox(pos,vec3(0.2,.3,.2)));\n\treturn d;\n}\n\nvec3 normal(in vec3 pos){\n\tvec2 offset = vec2(0.001,0);\n\tvec3 nDir = normalize(\n\t\tvec3(\n\t\t\tmap(pos+offset.xyy)-map(pos-offset.xyy),\n\t\t\tmap(pos+offset.yxy)-map(pos-offset.yxy),\n\t\t\tmap(pos+offset.yyx)-map(pos-offset.yyx)\n\t\t)\n\t);\n\treturn nDir;\n}\n\nfloat marching(in vec3 orgin,in vec3 p){\n\tfloat t = 1.;\n\t//int i;\n\tfor(int i=0;i<64;++i){\n\t\tvec3 sphere = orgin + t*p;\n\t\tfloat d = map(sphere);\n\t\tif(d<0.02)break;\n\t\tt += d;\n\t}\n\treturn t;\n}\n\nvec3 render(in vec3 pos,in vec3 p){\n\tfloat d = marching(pos,p);\n\tvec3 nDir = normal(pos + p*d);\n\t\n\tvec3 c = vec3(0.);\n\tif(d<85.){\n\t\tvec3 lDir = normalize(vec3(sin(time),cos(time),0.));\n\t\tfloat diff = max(0.,dot(lDir,nDir));\n\t\t\n\t\tc = nDir;//vec3(diff,diff,diff);\n\t}\n    \n    //Ugly Fog\n    c = mix(c-0.06,vec3(0.,0.,0.),d/75.);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = ( fragCoord.xy / iResolution.xy )*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\n\tvec3 p = normalize(vec3(uv,2));\n\n\t// the Camera pos and move the Camera\n\tvec3 camPos = vec3(4.,12.,5.)+vec3(1.,8.*sin(time),8.*cos(time));\n\t// the new p direction\n\tvec3 theNewP = P2CameraSpace(camPos,p); \n\n\t//render the models and light them\n\tvec3 col = render(camPos,theNewP);\n\n\tfragColor = vec4( col, 1.0 );\n;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlXRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tlXzN", "name": "2D Flame", "author": "834144373", "description": "i wrote it for many days ago\ni want to keep it,\nand i also put it on http://www.glslsandbox.com/e#24095.1", "tags": ["2dflame"], "likes": 12, "viewed": 766, "date": "1434980240", "time_retrieved": "2024-06-20T18:21:27.646653", "image_code": "//the 2D Flame made by 834144373zhu\n\n//https://www.shadertoy.com/view/4tlXzN\n//http://www.glslsandbox.com/e#24095.1\n///////////////////////////////////////\n#define time iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 pos = ( fragCoord.xy / iResolution.xy )*8.-vec2(4.,4.);// + mouse / 4.0;\n    \n    if(pos.y>-6.){\n\t\t//pos.y += 0.1*sin(time*3.)+0.13*cos(time*2.+0.6)+.1*sin(time*3.+0.4)+0.2*fract(sin(time*400.));\n        pos.y += 0.2*fract(sin(time*400.)+cos(time));\n\t}\n\n\tvec3 color = vec3(0.,0.,0.0);\n\t\n\tfloat p =.004;\n    \n\t\n\tfloat y = pow(abs(pos.x),3.2)/(2.*p)*3.3;\n\t\n\t\n\tfloat dir = length(pos+vec2(pos.x,y))*sin(0.26);//*(0.01*sin(time)+0.07);\n\t\n\tif(dir < 0.7){\n\t\tcolor.rg += smoothstep(0.0,1.,.75-dir);\n\t\tcolor.g /=2.4;\n\t}\n\tcolor += pow(color.r,1.1);\n    //new vertion\n    /*\n        float p1 = .015;\n        float y1 = pow(abs(pos.x),3.2)/(2.*p1)*3.3;\n        float d = length(pos+vec2(pos.x,y1+2.3))*sin(0.28);\n        color.b += smoothstep(-0.2,.9,0.47-d);\n        color.g += smoothstep(-0.3,.9,0.17-d);\n    */\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tS3Dt", "name": "Shadeaday 6 / 4 / 2015", "author": "cabbibo", "description": "a bunch of rods", "tags": ["rods"], "likes": 3, "viewed": 213, "date": "1433402823", "time_retrieved": "2024-06-20T18:21:28.913518", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n// Specific shaders stolen from\n// ROT FUNCTIONS  : https://www.shadertoy.com/view/XsSSzG\n\n\nconst float MAX_TRACE_DISTANCE = 20.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .01;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 80;\n\t\nvec3 startPoints[ 25 ];\nvec3 endPoints[ 25 ];\n\nfloat fbm( vec3 p, vec3 n )\n{\n\tp *= 0.15;\n\tfloat x = texture( iChannel0, p.yz ).x;\n\tfloat y = texture( iChannel0, p.zx ).x;\n\tfloat z = texture( iChannel0, p.xy ).x;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k ){\n    \n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n    \n}\n\n\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat opBlend( vec2 d1, vec2 d2 ){\n\n    return smin( d1.x , d2.x , 8.);\n    \n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdPlane( vec3 p )\n{\n\n    //float f = fbm( p.xy );\n    //f *= fbm( p.yz );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y;// + sin( p.x * 1. * p.z ) * .002; //- (f * .4); //(abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \tvec2 res = vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n    \n    for( int i = 0; i < 25; i++ ){\n        \n        // using textures instead of arrays seems to speed up alot!\n        vec3 sp = texture( iChannel0 , vec2( float( i ) / 25. , .2 + sin( iTime * .00005 ) * .1 )).xyz;\n        vec3 ep = texture( iChannel0 , vec2( float( i ) / 25. , .4 + sin( iTime * .0001 ) * .1 )).xyz;\n\n        sp.x =( rand( sp.xy ) - .5 ) * 2.;\n        sp.y =( rand( sp.zy ) - .5 ) * 2.;\n        sp.z =( rand( sp.xz ) - .5 ) * 2.;\n       \n        ep.x =( rand( ep.xy ) - .5 ) * 2.;\n        ep.y =( rand( ep.zy ) - .5 ) * 2.;\n        ep.z =( rand( ep.xz ) - .5 ) * 2.;\n\n\n    \tfloat intersection = sdCapsule( pos , sp * 1. , ep * 1.  , .05 );\n    \tvec2 res2 = vec2( intersection ,  float( i ) + 1.);\n    \tres.x = opBlend( res ,  res2 );\n    }\n    \n    /*vec2 res = vec2( rotatedPlane( pos - vec3( 0. , -2. , 0. ) , vec3(.9 , 0. , 0)) , 0.);\n    \n    res.x = opBlend( res , vec2( rotatedPlane( pos - vec3( 0. , -2. , 0. ) , vec3(-.7 , 0. , 0)) , 0.));\n    res.x = opBlend( res , vec2( rotatedPlane( pos - vec3( 0. , -2. , 0. ) , vec3(0. , 0. , 1.)) , 0.));\n    //vec2 res = vec2( sdSphere( pos , 8. ) , 0.); , 1.\n   \n    for( int i = 0; i < 8; i++ ){\n   \t\t\n\n        vec3 rot = sphereRot[i];\n        vec3 p = pos- spherePos[i].xyz;\n        vec3 s = vec3( spherePos[i].w , spherePos[i].w / 100. , spherePos[i].w / 100.);\n        float r = spherePos[i].w / 4.;\n        \n        float intersection = rotatedBox( p , rot , s , r );\n      \tvec2 res2 = vec2( intersection , float(i) + 1.);\n       \tres.x = opBlend( res ,  res2 );\n        \n   \t}*/\n    \n\n   \treturn res;\n    \n}\n\n// Calculates our intersection by stepping through the\n// map function, and returning both the object hit and the distance\n// it is hit at\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    //vec2 m = vec2( 1.1 +( sin( iTime * 0.4 ) + sin( iTime * 0.01 )) * .04 , 0. );\n    \n    for( int i = 0; i < 25; i++ ){\n    \tstartPoints[i].x = sin( float(i) * iTime * .01  ); \n        startPoints[i].y = sin( float(i) * iTime * .01 * .2 );   \n       \tstartPoints[i].z = sin( float(i)* iTime * .01  * .5 );\n        \n        endPoints[i].x = sin( float(i)* iTime * .01  * 3. ); \n        endPoints[i].y = cos( float(i)* iTime * .01  * 1.2 );   \n       \tendPoints[i].z = cos( float(i)* iTime * .01  * .5 );\n\n        \n    }\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,1.5 + abs(sin( iTime * .01 ) + sin( iTime * .0315 ))) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n\n    vec3 col = vec3( 1. );\n        \n    if( res.y > -.5 ){\n    \n        \n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 nor = calcNormal( pos );\n        \n        float AO = calcAO( pos , normalize(nor) );\n        \n        \n        col = vec3(1.) * AO; //nor * .5 + .5;\n    }\n\t\n    \n    fragColor = vec4( col ,1.0);\n    \n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tS3Dt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tSGDd", "name": "Look At", "author": "cabbibo", "description": "Trying to understand rotations", "tags": ["raytrace"], "likes": 4, "viewed": 207, "date": "1433453847", "time_retrieved": "2024-06-20T18:21:30.119450", "image_code": "\n#define time iTime\n\nconst float INTERSECTION_PRECISION = .01;\nconst float MAX_TRACE_DISTANCE     = 10.;\nconst int NUM_TRACE_STEPS          = 100;\n\nconst vec3 lightPos = vec3( 3. , 0.  , 0. );\n\nvec3 lookPos;\n\n\nfloat smin_2_3(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n\nvoid doCamera( out vec3 camPos , out vec3 camTar , in float time ){\n\n  camPos = vec3( 0. , 0. , 2.5 );\n  camTar = vec3( 0. );\n\n}\n\nmat3 calcLookAtMatrix( vec3 camPos , vec3 camTar , float roll ){\n\n  vec3 up = vec3( sin( roll ) ,cos( roll ) , 0. );\n  vec3 ww = normalize( camTar - camPos );\n  vec3 uu = normalize( cross( ww , up ) );\n  vec3 vv = cross( uu , ww ); // already normalized\n\n  return mat3( uu , vv , ww );\n\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xy), -p.z );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n\n    vec2 w = v - q;\n\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n\n    vec2 d = max(qv,0.0)*qv/vv;\n\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nmat3 matInverse( mat3 m ){\n    \n  \n    vec3 a = vec3(\n      \n        m[1][1] * m[2][2] - m[2][1] * m[1][2],\n        m[0][2] * m[2][1] - m[2][2] * m[0][1],\n        m[0][1] * m[1][2] - m[1][1] * m[0][2]\n        \n    );\n    \n    vec3 b = vec3(\n      \n        m[1][2] * m[2][0] - m[2][2] * m[1][0],\n        m[0][0] * m[2][2] - m[2][0] * m[0][2],\n        m[0][2] * m[1][0] - m[1][2] * m[0][0]\n        \n    );\n    \n     vec3 c = vec3(\n      \n        m[1][0] * m[2][1] - m[2][0] * m[1][1],\n        m[0][1] * m[2][0] - m[2][1] * m[0][0],\n        m[0][0] * m[1][1] - m[1][0] * m[0][1]\n        \n    );\n    \n    \n    return mat3( \n        \n       a.x , a.y , a.z ,\n       b.x , b.y , b.z ,\n       c.x , c.y , c.z\n        \n    );\n    \n \n  \n    \n}\n\nfloat lookAtCone( vec3 p , vec3 pos   , vec3 lookP , vec3 c ){\n    \n    mat3 rot = calcLookAtMatrix( p , lookPos , 0. );\n    rot = matInverse( rot );\n    //vec2 res2 = vec2(udBox( rot * (pos - p) , vec3( .01 , .01 , .2 )  ) , float( i ) ); \n         \n    float v = sdCappedCone( rot * ( pos - p ) ,c  ); \n\treturn v;\n    \n    \n}\n\nvec2 map( vec3 pos ){\n\n\n  vec2 res = vec2( sdSphere( pos - lookPos , .1 ) ,1. );\n\n  float fRes = res.x;\n  for( int i = 0; i < 10; i ++ ){\n   \n    vec3 p  = vec3( \n      .8 * sin( ( float( i +1)+ time * .01 ) * 2. ) ,\n      .8 * sin( ( float( i +1)+ time * .01 ) * 5. ) ,\n      .8 * sin( ( float( i +1)+ time * .01 ) * 9. ) \n    );   \n\n         \n    vec2 res2 = vec2( lookAtCone(p , pos , lookPos ,  vec3( .1 , .02  , .3 ) ) , float( i ) ); \n\n\n    res = opU( res , res2 );\n\n  }  \n\n  return res;\n\n\n\n}\n\n\n// res = result;\nvec2 calcIntersection( in vec3 ro , in vec3 rd ){\n\n  float h     = INTERSECTION_PRECISION * 2.;\n  float t     = 0.;\n  float res   = -1.;\n  float id    = -1.;\n\n  for( int i = 0; i < NUM_TRACE_STEPS; i++ ){\n      \n    if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n    \n    vec2 m = map( ro + rd * t );\n  \n    h  = m.x;\n    t += h;\n    id = m.y;\n\n  }\n\n  if( t < MAX_TRACE_DISTANCE ) res = t;\n  if( t > MAX_TRACE_DISTANCE ) id = -1.;\n\n  return vec2( res , id ); \n\n}\n\nvec3 calcNormal( vec3 pos ){\n\n  vec3 eps = vec3( 0.01 , 0. , 0. );\n  \n  vec3 nor = vec3(  \n    map( pos + eps.xyy ).x - map( pos - eps.xyy ).x,\n    map( pos + eps.yxy ).x - map( pos - eps.yxy ).x,\n    map( pos + eps.yyx ).x - map( pos - eps.yyx ).x\n  );\n\n  return normalize( nor );\n  \n\n}\n\n\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord){\n\n  vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n  \n  // Getting mouse position!\n  vec2 m =  ( -iResolution.xy + 2.0 * iMouse.xy ) / iResolution.y;;\n    \n  vec3 ro , ta;\n  \n  doCamera( ro , ta , time  );\n\n  mat3 camMat = calcLookAtMatrix( ro , ta , 0. ); \n \n  // z = lens length \n  vec3 rd = normalize( camMat * vec3( p.xy , 2. ) ); \n    \n  // Getting our mouse ray direction\n  vec3 md = normalize( camMat * vec3( m.xy , 2. ) ); \n    \n  lookPos = ro + md * 3.;\n \n  vec2 res = calcIntersection( ro , rd );\n  vec3 col = vec3( 0. );\n\n  if( res.x > 0. ){\n\n    vec3 pos = ro + rd * res.x;\n\n    vec3 lightDir = normalize( pos - lightPos );\n    vec3 nor = calcNormal( pos );\n\n    float lightMatch = max( 0. , dot( nor , lightDir ) );\n\n    vec3 refl = reflect( lightDir , nor );\n    float reflMatch = max( 0. , dot( refl , rd ) );\n\n    float rimMatch =  1. - max( 0. , dot( nor , -rd ) );\n\n\n    vec3 norCol = (nor * .5 + .5);\n\n    vec3 lambCol = ((nor * .5 + .5)* lightMatch);\n    vec3 ambiCol = ( vec3( 1. ) -norCol )*.1;\n    vec3 specCol = vec3( 1. , .8 , 0. ) * pow( reflMatch , 20. );\n    vec3 rimCol  = vec3( .4 , 1. , .8 ) * pow( rimMatch, 4. );\n    \n    col = lambCol + ambiCol + specCol + rimCol;\n\n  }\n\n  fragColor = vec4( col , 1. );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tSGDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tsSRN", "name": "Trip2016", "author": "ophilbinbriscoe", "description": "first shader sandbox", "tags": ["circle", "psychedelic", "circular"], "likes": 3, "viewed": 212, "date": "1435005253", "time_retrieved": "2024-06-20T18:21:30.798394", "image_code": "//noise function taken from https://www.shadertoy.com/view/XslGRr\n\nfloat hash( float n ){\n\treturn fract(sin(n)*43758.5453);\n}\n\n//this noise function was originally 3D noise, \n//but I am just setting z to 0 for the sake of simplicity here\n//also cause most effects only care about 2D noise\nfloat noise( vec2 uv ){\n\tvec3 x = vec3(uv, 0);\n\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf       = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\t\n\treturn mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n\t\t\t\t   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat ring( float angle, float dist, float ANG, float THICKNESS, float POS, float SIZE ) {\n    //angles between 4 and 15 are good\n    //negative thickness makes it black, values around 0.02 are good\n    \n    float ZIGZAG = abs( mod( angle, ANG ) - ANG * 0.5 ) * SIZE;\n    return ceil( dist - POS + ZIGZAG) - ceil( dist - (POS+THICKNESS) + ZIGZAG);   \n}\nfloat burst( float angle, float dist, float ANG ) {\n    float B = abs( mod( angle, ANG ) - ANG * 0.5 );\n    return B;\n}\nfloat lim( float IN, float amount ) {\n\treturn IN * amount + (1.0 - amount);   \n}\nfloat inv( float IN ) {\n \treturn 1.0 - IN;   \n}\nfloat ppp( float IN ) {\n \treturn IN * IN * IN;   \n}\nfloat dots( float angle, float dist, float ANG, float POS ) {\n    return ppp(7.5*burst( angle, dist, ANG )/ANG) * ppp(inv(ANG*1.5*distance( dist, POS )));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float shortside = min( iResolution.x, iResolution.y );\n    float longside = max( iResolution.x, iResolution.y );\n    \n\tvec2 uv = fragCoord.xy / vec2( shortside, shortside );\n    \n    uv.x = uv.x - (longside/shortside - 1.0) * 0.5;\n    \n   \tfloat dist = distance( vec2( 0.5, 0.5 ), uv );\n    \n    uv = vec2( uv.x - 0.5, uv.y - 0.5 );\n    \n    float angle = degrees( atan( uv.y / uv.x ) );\n    \n    float TIMESCALE = 0.1;\n    float T = iTime * TIMESCALE * 2.0;\n    \n    \n    float n = noise( vec2( dist, T ) );\n    float slow_n = noise( vec2( dist, T * 0.2) );\n    float fast_n = noise( vec2( dist, T * 2.0) );\n    float vslow_n = noise( vec2( dist, T * 0.01) );\n    float vfast_n = noise( vec2( dist, T * 50.0) );\n    float t = noise( vec2( iTime, T ) );\n    \n    float rand_r = noise( vec2( -T, T ) );\n    float slow_r = noise( vec2( -T * 0.5, 1.0 ) );\n    float vslow_r = noise( vec2( -T * 0.2, 1.0 ) );\n    float vvslow_r = noise( vec2( -T* 0.05, 1.0 ) );\n    \n    float div = 7.0;\n    float m = sin ( mod( angle, div )/(div*0.5) * 3.14 * 0.5 );\n    float a = mod( angle, 10.0 ) * noise( vec2( T, angle ) );\n        \n    float TIME_MOD_SCALE = 1.0;\n    float TIME_MOD = floor(0.5+sin( noise( vec2(-iTime + 1000.0, 1.0 )) ))*0.5*TIMESCALE*TIME_MOD_SCALE;\n\n    TIMESCALE = TIMESCALE * TIME_MOD;\n    \n    float GRANULARITY = 1.75;\n    float GRAN_DIST_FALLOFF = 0.5;\n    float GRAN_DIST_FALLOFF_MOD = tan(noise (vec2( 500.0, -T ) ));\n    GRAN_DIST_FALLOFF = GRAN_DIST_FALLOFF + GRAN_DIST_FALLOFF_MOD * 0.5;\n    \n    float Gr = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 50.0;\n    float Gg = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 80.0;\n    float Gb = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 100.0;\n    \n    float Gsign = clamp( sign( noise (vec2( T * 0.22, -T * 1.5 )) -0.5 ), -1.0, 0.0 );\n    \n    float rn = 360.0 / (ceil( noise(vec2( sin(T*0.1), 0.5 ) ) * 50.0) * 2.0 );\t//randomly some divisor of 360\n    float rd1 = ceil( noise(vec2( tan(T), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd2 = ceil( noise(vec2( sin(T), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd3 = ceil( noise(vec2( cos(T), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd4 = ceil( noise(vec2( tan(T*0.75+99.0), 1.0 ) ) * 1.2 );\t//randomly either 1 or 2\n    float rd5 = ceil( noise(vec2( tan(T*0.8+124.0), 1.0 ) ) * 1.5 );\t//randomly either 1 or 2\n    float rd6 = ceil( noise(vec2( tan(T*0.7+24.0), 1.0 ) ) * 1.7 );\t//randomly either 1 or 2\n    float rd7 = ceil( noise(vec2( tan(T*0.5), 1.0 ) ) * 1.4 );\t//randomly either 1 or 2\n    float exp4 = ceil( noise(vec2( tan(T*0.5), 1.0 ) ) * 2.0 ) * rd1;\n    float coarse3 = ceil( noise(vec2( cos(T), 1.0 ) ) * 3.0 );\n    float coarse10 = ceil( noise(vec2( cos(T), 1.0 ) ) * 10.0 );\n    \n    vec3 RING1 = rd2 * 0.5 * ring( angle, dist,6.0, 0.02, n, 0.01) * vec3( 1.0, 1.0, 1.0 ) * floor( n + 0.5 );\n    vec3 RING2 = ring( angle, dist,10.0, 0.01, n/2.0, 0.01) * vec3( 1.0, 1.0, 1.0 ) * ceil( n - 0.3 );\n    vec3 RING3 = ring( angle+(vslow_n*200.0*coarse3)*(2.0+n), dist,90.0*rd1/rd4, (0.02 + rand_r*0.01 + ppp(slow_r)*0.011)*ppp(rd4), n, 0.01) * vec3( 1.0, 1.0, 1.0 ) * 0.5;\n    vec3 RING4 = ring( angle-iTime*(5.0*n), dist,10.0, 0.05, n, 0.01) * vec3( sin(T), cos(T), 0.1 ) * 0.5;\n    vec3 RING5 = ring( angle, dist,30.0, n*20.0, n+0.3, 0.01) * vec3( 1.0, 1.0, 1.0 ) * 0.05 + (dist)*0.05;\n    vec3 BURST1 = burst( angle, dist, rn * rd1 ) * vec3( 1.0, 1.0, 1.0 ) * 0.03 * (1.0 - dist);\n    vec3 RING6 = max(ring( angle-(vslow_n*200.0*coarse3)*(2.0+vslow_n), dist,45.0*rd1, 0.3, n, 0.01),0.0) * vec3( sin(T), tan(T), rand_r ) * (rd7 - 1.0) * inv(dist) * 0.5;\n    vec3 DOTS1 = max(ceil(dots( angle + T*30.0, dist, 10.0, 0.25 + rand_r*0.1 )-24.5 * (1.0+rand_r)),0.0) * vec3( rand_r, inv(rand_r), n ) * 0.15;\n    vec3 DOTS2 = max(ceil(dots( angle - T*35.0, dist, 10.0, 0.3 + rand_r*0.2 )-16.4 * (2.0-rand_r)),0.0) * vec3( n, rand_r, inv(rand_r) ) * 0.15;\n    vec3 DOTS3 = clamp( 1.0 * dots( angle + T * 45.0, dist, 15.0, 0.9 ), 0.0, 1.0) * vec3( 1.0, 1.0, 1.0 ) * 0.05;\n    vec3 DOTS4 = clamp( 1.0 * dots( angle - T * 45.0, dist, 15.0, 0.82 ), 0.0, 1.0) * vec3( 1.0, 1.0, 1.0 ) * 0.025;\n    vec3 RING = RING1 + RING2 + RING3 + RING4 + RING5 + BURST1 + DOTS1 + DOTS2 + RING6 + DOTS3 + DOTS4;\n    \n    float r = RING.r + max((1.0 - dist * 2.0),-0.5) + noise( vec2( dist * Gr * sin( noise(vec2( iTime * 8.0 * TIMESCALE, -iTime )) ), dist ) );;//floor(n*2.0) * a;\n    float g = RING.g + max((1.0 - dist * 3.5),-1.5) + noise( vec2( dist * Gg * TIMESCALE * cos( noise(vec2( iTime * 12.0 * TIMESCALE, -iTime )) ), dist ) );;//ceil(n/3.0 - 0.1) - a;\n    float b = RING.b + max((1.0 - dist * 2.5),-1.0) + noise( vec2( dist * Gb * tan( noise(vec2( iTime * 1.0 * TIMESCALE, -iTime )) ), dist ) );;//ceil(n/3.0 - 0.2) - a;\n    \n    vec3 boost = vec3( 1.0 * lim(ppp(slow_r) + 0.4, 0.5), 0.2 + 2.0 * lim(inv(ppp(slow_r)), 0.5), 0.5 * lim(rand_r,0.2) + 0.1);    \n       \n\tfragColor = vec4(r*boost.r,g*boost.g,b*boost.b,1.0) * mix(dist,1.0,0.7);\n    \n    dist;\n    float over = fragCoord.y/iResolution.y;\n    //fragColor = vec4(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y,0.0,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tsSRr", "name": "Hinge - distance 2D", "author": "ajs15822", "description": "Signed distance to a 2D hinge (triangle with one side open). Just a quick modification of iq's 2D triangle SDF.", "tags": ["2d", "distance"], "likes": 7, "viewed": 355, "date": "1434099597", "time_retrieved": "2024-06-20T18:21:31.028681", "image_code": "\n// signed distance to hinge, based on iq's 2d tri SDF\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0;\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), 1.0 ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec2 v1 = cos( iTime + vec2(0.0,1.57) + 0.0 );\n\tvec2 v2 = cos( iTime + vec2(0.0,1.57) + 2.0 );\n\tvec2 v3 = cos( iTime + vec2(0.0,1.57) + 4.0 );\n\n\tfloat d = sdTriangle( v1, v2, v3, p );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsSRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tsSzN", "name": "tiedie onetweet raymarch attempt", "author": "public_int_i", "description": "Somewhat of an attempt at raymarching in as little chararacters as possible, didnt really have an idea of what i wanted to make but ended up with this. Also this is my first try at a one tweet shader let me know if theres any rules i broke.", "tags": ["raymarch", "one", "tweet"], "likes": 1, "viewed": 119, "date": "1434977485", "time_retrieved": "2024-06-20T18:21:31.028681", "image_code": "#define v vec4\n#define n normalize\nvoid mainImage( out v p, in vec2 c )\n{\n\tv r = n(v(c/iResolution.xy,1.,1.5)-v(.5)),o=vec4(0.);\n    for (float i=0.; i < 100.; i+=2.)\n        o += dot(n(cos(i*r+iTime)),r)*cos(i*r)*.2;\n    \n    p=o;\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsSzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tsXzN", "name": "SubabaRecycle", "author": "gyabo", "description": "plane rehabilitation...and Mouse move", "tags": ["plane", "rehabilitation"], "likes": 1, "viewed": 122, "date": "1434981228", "time_retrieved": "2024-06-20T18:21:31.028681", "image_code": "#define ITE_MAX 15\n\nvec2 rot(vec2 p, float a)\n{\n\treturn vec2(cos(a) * p.x - sin(a) * p.y, sin(a) * p.x + cos(a) * p.y);\n}\n\nvec3 tex(vec2 uv)\n{\n\tvec3 c = vec3(fract(uv.xyy));\n\tif(mod(uv.x * 2.0, 2.0) < 0.9) return vec3(0);\n\tif(mod(uv.y * 1.0, 1.0) < 0.9) return vec3(0);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tfloat M   = iTime * 0.5;\n\tfloat fog = 1.0;\n\tvec2 uv   = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\t     uv  *= vec2(iResolution.x / iResolution.y, 1.0);\n\t     uv   = rot(uv, -iMouse.y * 0.015);\n\tvec3  c   = vec3(0);\n\tfor(int i = 0 ; i < ITE_MAX; i++) {\n\t\tc = tex(vec2(uv.x / abs(uv.y / (float(i) + 1.0)) + M + iMouse.x * 0.015, abs(uv.y)));\n\t\tif(length(c) > 0.5) break;\n\t\tuv   = uv.yx * 1.3;\n        uv.y -= M * 5.0;\n        uv.x += M * 5.0;\n\t\tfog *= 0.9;\n\t}\n\tfragColor = (1.0 - vec4(c.yxxy * (fog * fog)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tXSR4", "name": "Analytic Area Light ", "author": "dys129", "description": "http://research.microsoft.com/en-us/um/people/johnsny/papers/arealights.pdf for reference solution (Arvo 1995)\nhttp://pascal.lecocq.home.free.fr/publications/lecocq_i3D2016_specularAreaLighting.pdf for Accurate Analytic Approximation", "tags": ["arealight"], "likes": 24, "viewed": 1408, "date": "1434635317", "time_retrieved": "2024-06-20T18:21:32.713819", "image_code": "#define PI 3.14159265359\n\n#define MAT_ID_LIGHT 3.\n#define saturate(a) clamp(a, 0.,1.)\n\n/*\nSet USE_APPROX to 0 to use reference solution (Arvo 1995)\nSet USE_APPROX to 1 to use Siggraph 2015: Accurate Analytic Approximations for Real-Time Specular Area Lighting\n*/\n#define USE_APPROX 1\n\n//0 - for triangle area light\n//1 - for quad area light\n#define AREA_LIGHT_TYPE 0\n\nvec3 lightClr = vec3(1.0, 0.0, 0.0);\n\n//specular power\nconst int N = 65; \n\n#if AREA_LIGHT_TYPE==0\n#define NUM_VERTS 3\nvec3 get_arr(int i)\n{  \n \tif(i == 0) return vec3(0.1,  0.01, 0.01);  \n \tif(i == 1) return vec3(-0.5, 2.0,  0.02);\n \tif(i == 2) return vec3(0.5, 2.0,0.03);\n    \n   \treturn vec3(0.);\n}\n#elif AREA_LIGHT_TYPE==1\n#define NUM_VERTS 6\nvec3 get_arr(int i)\n{  \n \tif(i == 0) return vec3(1.0,  0.1, 0.0);  \n \tif(i == 1) return vec3(-1.0, 0.1,  0.0);\n \tif(i == 2) return vec3(-1.0, 2.0,0.0);\n    \n    if(i == 5) return vec3(-1.0,  2.0, 0.0);  \n \tif(i == 3) return vec3(1.0, 2.0,  0.0);\n \tif(i == 4) return vec3(1.0, 0.1,0.0);\n    \n   \treturn vec3(0.);\n}\n#endif\n\n\nfloat plane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sphere(vec3 ro, float r)\n{\n return length(ro) - r;   \n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec2 scene(vec3 ro)\n{\n    vec2 polygon = vec2(1000.0, 0.);\n    \n    for(int i = 0; i < NUM_VERTS; i += 3)\n    {\n    \tpolygon = opU(polygon, vec2(udTriangle(ro, get_arr(i), get_arr(i+1), get_arr(i+2)), MAT_ID_LIGHT));\n    }\n    vec2 pl0 = vec2(plane(ro), 0.0);\n\n return opU(polygon, pl0);  \n}\n\nvec4 getMaterial(float mat_id)\n{\n\tif(mat_id == 0.0) return vec4(1.0, 1.0, 1.0, 0.0);\n    else if(mat_id == 1.0) return vec4(0.0, 1.0, 0.0, 0.0);\n    else if(mat_id == 2.0) return vec4(1.0, 0.0, 0.0, 0.0);  \n    else if(mat_id == MAT_ID_LIGHT) return vec4(1.0, 1.0, 1.0, 0.0);\n        return vec4(0.0);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat cosine_sine_power_integral_sum(float theta,float cos_theta,float sin_theta,\nint n,float a,float b)\n{\n    float f = a*a + b*b;\n    float g = a*cos_theta + b*sin_theta;\n    float gsq = g*g;\n    float asq = a*a;\n    float h = a*sin_theta - b*cos_theta;\n    float T,Tsum;\n    float l,l2;\n    int start;\n    /* initial conditions for recurrence */\n    //if (n&1) {\n    /*T = h+b;\n    l = gsq*h;\n    l2 = b*asq;\n    start = 1;*/\n    /*} else { */\n    T = theta;\n    l = g*h;\n    l2 = b*a;\n    start = 0;\n    //}\n    Tsum = T;\n    for (int i = 2; i <= N-1; i += 2) \n    {\n        T = (l + l2 + f*(float(i)-1.)*T)/float(i);\n        l *= gsq;\n        l2 *= asq;\n        Tsum += T;\n    }\n    return Tsum;\n}\n\nfloat P(float theta, float a)\n{\n\treturn 1.0 / (1.0 + a * theta * theta);    \n}\n\nfloat I_org(float theta, float c, float n)\n{\n    float cCos = c * cos(theta);\n    return (pow(cCos, n+2.) - 1.0) / (cCos * cCos  - 1.)-1.0;\n}\n\nfloat evaluateXW(float c, float n)\n{\n\treturn PI/4.*pow(1. - pow(c - c /(n-1.), 2.5), 0.45);   \n}\n\n\nfloat shd_edge_contribution_approx(vec3 v0, vec3 v1, vec3 n, int e)\n{\n   float f;\n    float cos_theta,sin_theta;\n    vec3 q = cross(v0,v1);\n    sin_theta = length(q);\n    q = normalize(q);\n    cos_theta = dot(v0,v1);\n    \n    if (e == 1) {\n        f = acos(cos_theta);\n    } else {\n        vec3 w;\n        float theta;\n        theta = acos(cos_theta);\n        w = cross(q,v0);\n       \n        float a = dot(v0,n);\n        float b = dot(w,n);\n        float x = theta;\n        float delta = atan(b, a);\n        float c = sqrt(a*a + b*b);\n        \n        float xw = evaluateXW(c, float(N));\n        \n        float bias = -0.01; //?\n        \n        float s = (pow(c, float(e)+2.) - 1.) / (c*c - 1.)-1.;\n        float Io = I_org(xw, c, float(e));\n        \n        float A = (s-Io)/(Io*(xw + bias)*(xw + bias));\n \n        float integral =  1. / sqrt(A) * atan(sqrt(A) * x , (1. - A * delta * (x - delta))); \n        \n        float vShift = P(PI/2., A);\n        float d = 1. - vShift;\n        float sNorm = s / d;\n                        \n        f  = sNorm * (integral - x * vShift)+x;\n        f = max(theta,f);\n    }\nreturn f*dot(q,n); \n}\n\nfloat shd_edge_contribution(vec3 v0,vec3 v1,vec3 n,int e)\n{\n    float f;\n    float cos_theta,sin_theta;\n    vec3 q = cross(v0,v1);\n    sin_theta = length(q);\n    q = normalize(q);\n    cos_theta = dot(v0,v1);\n    \n    if (e == 1) {\n        f = acos(cos_theta);\n    } else {\n        vec3 w;\n        float theta;\n        theta = acos(cos_theta);\n        w = cross(q,v0);\n        f = cosine_sine_power_integral_sum(theta,cos_theta,sin_theta,e-1,dot(v0,n),dot(w,n));\n    }\nreturn f * dot(q,n);\n}\n\n\n\nvoid seg_plane_intersection(vec3 v0, vec3 v1, vec3 n, out vec3 q)\n{\n vec3 vd;\n float t;\n vd = v1 - v0;\n t = -dot(v0,n)/(dot(vd, n));\n q = v0 + t * vd;\n}\n\nfloat shd_polygonal(vec3 p, vec3 n, bool spc)\n{\n    int i,i1;\n    int J = 0;\n    float sum = 0.;\n    vec3 ui0,ui1; /* unnormalized vertices of edge */\n    vec3 vi0,vi1; /* unit-length vector vertices of edge */\n    int belowi0 = 1,belowi1 = 1; /* flag for whether last vertex was below pointâ€™s \"horizon\" */\n    /* find first vertex above horizon */\n    for (int j = 0; j < NUM_VERTS; j++) {\n        vec3 u;\n        u = get_arr(j) - p;\n        if (dot(u,n) >= 0.0) {\n            ui0 = u;\n            vi0 = u;\n            vi0 = normalize(vi0);\n            belowi0 = 0;\n            J = j;\n            break;\n        }\n    } \n    \n    if (J >= NUM_VERTS) return 0.;\n    \n    i1 = J;\n\tfor (int i = 0; i < NUM_VERTS; i++) \n    {\n        i1++;\n        if (i1 >= NUM_VERTS) i1 = 0;\n        \n        ui1 = get_arr(i1) - p;\n        belowi1 = int(dot(ui1,n) < 0.);\n        \n        if (belowi1 == 0) {\n            vi1 = ui1;\n            vi1 = normalize(vi1);\n        }\n \n        if (belowi0!=0 && belowi1==0) {\n            vec3 vinter;\n            seg_plane_intersection(ui0,ui1,n,vinter);\n            vinter = normalize(vinter+0.01);                        \n            sum += shd_edge_contribution(vi0,vinter,n,1);            \n            vi0 = vinter;\n        }  else if (belowi0==0 && belowi1!=0) {\n            seg_plane_intersection(ui0,ui1,n,vi1);\n            vi1 = normalize(vi1);\n        }\n     \tint K = spc ? N : 1;\n        #if USE_APPROX\n       \tif (belowi0==0 || belowi1==0) sum += shd_edge_contribution_approx(vi0,vi1,n,K);\n        #else\n        if (belowi0==0 || belowi1==0) sum += shd_edge_contribution(vi0,vi1,n,K);\n        #endif\n        \n\t\tui0 = ui1;\n\t\tvi0 = vi1;\n\t\tbelowi0 = belowi1;\n    }\n    \n    if (sum < 0.) sum = -sum;\n    \n    return sum / (2.0 * PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{     \n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n   // vec2 mo = -1.0 + 2.0 * iMouse.xy/iResolution.xy;\n   \n\n    vec3 ro = vec3(6.0 * sin(iTime), 2.2, 6.0 * cos(iTime));\n\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    \n    float t = 1.0;\n    vec4 clr = vec4(0.0);\n    for(int i =0; i<64; i++)\n    {\n        vec2 hit = scene(ro+t*rd);\n        float eps = 0.001;\n        if(hit.x < eps)\n        {\n            vec4 mat = getMaterial(hit.y);\n            if(hit.y ==  MAT_ID_LIGHT)\n            {\n                clr.rgb = lightClr;\n                break;\n            }\n                 \n        \tvec3 pos = ro + t*rd;\n        \tvec3 nrm = calcNormal( pos );\n        \tvec3 rfl = reflect( rd, nrm );   \n             vec3 test_out;           \n            float diff = shd_polygonal(pos, nrm, false);\n            \n            \n            float spc = saturate(shd_polygonal(pos, rfl, true));\n\t\t\tclr.rgb = lightClr * (diff+spc) * mat.rgb;\n            break;\n        }\n        \n        t += max(hit.x, 0.001);\n    }\n   \n    clr.rgb = pow(clr.rgb, vec3(1.0 / 2.2));\n    \n\tfragColor = clr;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXSR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tXSRM", "name": "Skyline Explanation", "author": "gsingh93", "description": "A fully commented version of this shader: http://glslsandbox.com/e#22564.0", "tags": ["tutorial", "explanation", "skyline"], "likes": 30, "viewed": 2090, "date": "1435092267", "time_retrieved": "2024-06-20T18:21:32.938060", "image_code": "#define MAX_DEPTH 20\n\n// Magic noise function, described here:\n// https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat noise(vec2 p) {\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 456367.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Scale coordinates to [0, 1]\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    float col = 0.;\n    // Start from the back buildings and work forward, so buildings in the front cover the ones in the back\n\tfor (int i = 1; i < MAX_DEPTH; i++) {\n        // This is really \"inverse\" depth since we start from the back\n\t\tfloat depth = float(i);\n        \n        // Create a step function where the width of each step is constant at each depth, but increases as\n        // the depth increases (as we move forward). We will get the same step value for multiple p.x\n        // values, which will give our building width. iTime creates the scrolling effect.\n\t\tfloat step = floor(200. * p.x / depth + 50. * depth + iTime);\n        \n        // Use the noise function to get the y coordinate of the top of the building, and decrease this\n        // height the closer we are to the front. If our pixel is below this height, we set it's color\n        // depending on it's depth. \n\t\tif (p.y < noise(vec2(step)) - depth * .04) {\n\t\t\tcol = depth / 20.;\n\t\t}\n\t}\n    \n    fragColor = vec4(vec3(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXSRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tXSRN", "name": "Deform - waves", "author": "iq", "description": "2D deformation plus color trickery. Similar to [url]https://www.shadertoy.com/view/Mdl3RH[/url] and  [url]https://www.shadertoy.com/view/4ssSRX[/url] (but in 2D), and clearly this: [url]https://www.shadertoy.com/view/llsSzH[/url]", "tags": ["2d", "planedeformation", "deform"], "likes": 34, "viewed": 2599, "date": "1434733133", "time_retrieved": "2024-06-20T18:21:32.944001", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 p = q;\n    \n    p += .2*cos( 1.5*p.yx + 1.0*iTime + vec2(0.1,1.1) );\n\tp += .2*cos( 2.4*p.yx + 1.6*iTime + vec2(4.5,2.6) );\n\tp += .2*cos( 3.3*p.yx + 1.2*iTime + vec2(3.2,3.4) );\n\tp += .2*cos( 4.2*p.yx + 1.7*iTime + vec2(1.8,5.2) );\n\tp += .2*cos( 9.1*p.yx + 1.1*iTime + vec2(6.3,3.9) );\n\n\tfloat r = length( p );\n    \n    vec3 col1 = texture( iChannel0, vec2(r,     0.0), 0.0 ).zyx;\n    vec3 col2 = texture( iChannel0, vec2(r+0.04,0.0), 0.0 ).zyx;\n\n    vec3 col = col1;\n    col += 0.1;\n    col *= 1.0 + 0.4*sin(r+vec3(0.0,3.0,3.0));\n    col -= 4.0*max(vec3(0.0),col1-col2).x;\n    col += 1.0*max(vec3(0.0),col2-col1).x - 0.1;\n    col *= 1.7 - 0.5*length(q);\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll23Dc", "name": "Burning fuse", "author": "TroyOfEarth", "description": "just a demo... will add a sparkly later", "tags": ["2d"], "likes": 0, "viewed": 148, "date": "1433348458", "time_retrieved": "2024-06-20T18:21:33.471490", "image_code": "/*\nInfo on curves:\nhttp://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nhttp://research.microsoft.com/en-us/um/people/cloop/LoopBlinn05.pdf\nhttp://www.pouet.net/topic.php?which=9119&page=1\nhttp://blog.gludion.com/2009/08/distance-to-quadratic-bezier-curve.html\n\nThe top link is where the get_distance_vector comes from.\n\nThanks also to other bezier curve shadertoys:\nhttps://www.shadertoy.com/view/XsX3zf\nhttps://www.shadertoy.com/view/lts3Df\n*/\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\nfloat T = iTime * 0.1;\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 get_distance_vector2(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 1.0-fract(T) - 0.01, 1.0-fract(T)+0.01); // ð‘¡Ì…\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // ð‘£ð‘– = ð‘(ð‘¡Ì…)\n}\n\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0, 1.0-fract(T)); // ð‘¡Ì…\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // ð‘£ð‘– = ð‘(ð‘¡Ì…)\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\nfloat approx_distance2(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector2(b0-p, b1-p, b2-p));\n}\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) - vec2(0.25,0.5);\n    mouse.x *= aspectRatio;\n    vec2 A = vec2(0.5,-0.4);\n    vec2 B = vec2(0.5,0.0);\n    vec2 C = length(iMouse.xy) > 0.0 ? mouse : vec2(-0.3,0.2);\n\n    vec3 color = vec3(1.0,1.0,1.0);\n\n\n    float dist = approx_distance(percent, A, B, C);\n    if (dist < EDGE + SMOOTH)\n    {\n        dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        color *= vec3(dist);\n    }\n    \n    dist = approx_distance2(percent, A, B, C);\n    if (dist < EDGE + SMOOTH)\n    {\n        dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        color = vec3(1.0,1.0,0.);\n    }    \n       \n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll23Dc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll23Wt", "name": "Interpolation: Bezier, Cubic", "author": "4rknova", "description": "Cubic Bezier interpolation.\nNote that I use line segments, not the curve distance field.", "tags": ["bezier", "interpolation"], "likes": 20, "viewed": 1408, "date": "1433765475", "time_retrieved": "2024-06-20T18:21:34.283603", "image_code": "// by Nikos Papadopoulos, 4rknova / 2015\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ANIMATED\n#define SHOW_CONTROL_POINTS\n//#define SHOW_SEGMENT_POINTS\n//#define MOUSE_ENABLED \n//#define AA 1.\n\n#define STEPS  25.\n#define STROKE .8\n\n#define EPS    .01\n\n#define BG   vec3(0.0745, 0.0862, 0.1058)\n#define COL0 vec3(.2, .35, .55)\n#define COL1 vec3(.9, .43, .34)\n#define COL3 vec3(1.)\n\n#define T (mod(iTime * 2., 10.) / 10.)\n\nvec2 interpolate(vec2 a, vec2 b, vec2 c, vec2 d, float p)\n{\n    vec2 v0 = mix(a, b, p);\n    vec2 v1 = mix(b, c, p);\n    vec2 v2 = mix(c, d, p);\n    vec2 v3 = mix(v0, v1, p);\n    vec2 v4 = mix(v1, v2, p);\n    \n    return mix(v3, v4, p);\n}\n\nfloat df_circ(in vec2 p, in vec2 c, in float r)\n{\n    return abs(r - length(p - c));\n}\n\nfloat df_line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat sharpen(in float d, in float w)\n{\n    float e = 1. / min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n\nfloat ip_control(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{    \n    float cp = 0.;\n    \n#ifdef SHOW_CONTROL_POINTS    \n    float c0 = sharpen(df_circ(uv, a, .02), EPS * .75);\n    float c1 = sharpen(df_circ(uv, b, .02), EPS * .75);\n    float c2 = sharpen(df_circ(uv, c, .02), EPS * .75);\n    float c3 = sharpen(df_circ(uv, d, .02), EPS * .75);\n\n    float l0 = sharpen(df_line(uv, a, b), EPS * .6);\n    float l1 = sharpen(df_line(uv, b, c), EPS * .6);\n    float l2 = sharpen(df_line(uv, c, d), EPS * .6);\n\n    cp = max(max(max(c0, c1),max(c2, c3)),\n\t         max(max(l0, l1),l2));\n#endif\n\n    return cp;\n}\n\nfloat ip_aux(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    vec2 v0 = mix(a, b, T);\n    vec2 v1 = mix(b, c, T);\n    vec2 v2 = mix(c, d, T);\n    vec2 v3 = mix(v0, v1, T);\n    vec2 v4 = mix(v1, v2, T);    \n    \n    float l0 = 0.5 * sharpen(df_line(uv, v0, v1), EPS * .6);\n    float l1 = 0.5 * sharpen(df_line(uv, v1, v2), EPS * .6);\n    float l2 = 0.3 *sharpen(df_line(uv, v3, v4), EPS * .6);\n    \n    return max(l0, max(l1, l2));\n}\n\n\nfloat ip_point(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    vec2 p = interpolate(a, b, c, d, T);\n    return sharpen(df_circ(uv, p, .025), EPS * 1.);\n}\n\nfloat ip_curve(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{ \n    float e = 0.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = interpolate(a, b, c, d, (i   ) / STEPS);\n        vec2  p1 = interpolate(a, b, c, d, (i+1.) / STEPS);\n#ifdef SHOW_SEGMENT_POINTS        \n        float m = sharpen(df_circ(uv, p0, .01), EPS * .5);\n        float n = sharpen(df_circ(uv, p1, .01), EPS * .5);\n        e = max(e, max(m, n));\n#endif\n        float l = sharpen(df_line(uv, p0, p1), EPS * STROKE);\n        e = max(e, l);\n    }\n                \n    return e;\n}\n\nvec3 scene(in vec2 uv, in vec2 a, in vec2 b, in vec2 c, in vec2 d)\n{\n    float d0 = max(ip_control(uv, a, b, c, d), ip_aux(uv, a, b, c, d));\n    float point = 0.;\n    \n#ifdef ANIMATED\n    point = ip_point(uv, a, b, c, d);\n#endif\n    \n    float d1 = ip_curve(uv, a, b, c, d);    \n    float rs = max(d0, d1);\n    \n    return (point < .5)\n        ? rs * (d0 > d1 ? COL0 : COL1)\n        : point * COL3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = BG;\n    \n    vec2 a = vec2(-.50,-.25);\n    vec2 b = vec2( .00, .75);\n    vec2 c = vec2( .75,-.75);\n    vec2 d = vec2(-.75,-.75);\n        \n#ifdef MOUSE_ENABLED        \n    a = (iMouse.xy / iResolution.xy * 2. - 1.)\n           * vec2(iResolution.x / iResolution.y, 1.);\n#endif\n    \n#ifdef AA\n    // Antialiasing via supersampling\n    float e = 1. / min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\tcol += scene(uv + vec2(i, j) * (e/AA), a, b, c, d) / (4.*AA*AA);\n        }\n    }\n#else\n    col += scene(uv, a, b, c, d);\n#endif /* AA */\n    \n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll23Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll2GD3", "name": "Palettes", "author": "iq", "description": "Cosine based palettes (faster than linear interpolation or triangle waves). \nMore info: [url]http://iquilezles.org/www/articles/palettes/palettes.htm[/url]", "tags": ["2d", "color", "palettes"], "likes": 375, "viewed": 70482, "date": "1433235426", "time_retrieved": "2024-06-20T18:21:34.289730", "image_code": "// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright © 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n// A simple way to create color variation in a cheap way (yes, trigonometrics ARE cheap\n// in the GPU, don't try to be smart and use a triangle wave instead).\n\n// See http://iquilezles.org/www/articles/palettes/palettes.htm for more information\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    // animate\n    p.x += 0.01*iTime;\n    \n    // compute colors\n    vec3                col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    if( p.y>(1.0/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    if( p.y>(2.0/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    if( p.y>(3.0/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if( p.y>(4.0/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    if( p.y>(5.0/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    if( p.y>(6.0/7.0) ) col = pal( p.x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n\n    // band\n    float f = fract(p.y*7.0);\n    // borders\n    col *= smoothstep( 0.49, 0.47, abs(f-0.5) );\n    // shadowing\n    col *= 0.5 + 0.5*sqrt(4.0*f*(1.0-f));\n    // dithering\n    col += (1.0/255.0)*texture( iChannel0, fragCoord.xy/iChannelResolution[0].xy ).xyz;\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/ll2GD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llB3Rc", "name": "Heavy", "author": "huwb", "description": "Light travelling sloooooooow. The slider controls how much time passes as the photons fly (inverse speed). This trivial addition to raymarching leads to some really weird and wonderful effects, such as the nice inherent doppler effect on the motion.", "tags": ["light", "doppler", "relativity", "timeofflight"], "likes": 16, "viewed": 442, "date": "1433708685", "time_retrieved": "2024-06-20T18:21:35.489743", "image_code": "// the core technique here is a simple extension of raymarching - instead of the render\n// time being a fixed global constant, it is advanced as rays are marched through the scene.\n\n// this produces some interesting phenomena:\n// * distorted shape of both spheres\n// * doppler effect on vertical oscillation of orbiting sphere\n// * propogation of light from src->surface->camera evident as light changes intensity\n// * light propagation also evident in shadows, causing weird lava lamp effects\n\n// the orbiting sphere appears broken up or sliced at slow photon speeds because the\n// sphere is moving away from the ray and the raymarch struggles to catch it. there\n// may be elegant ways to inform the raymarch of the motion in the scene so that the\n// step size takes motion into account, but i couldnt think of an elegant and general\n// solution.\n// EDIT: over relaxation should help convergence in theory but i havent tried it:\n// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n// https://www.shadertoy.com/view/ldSSDV\n\n// disable this if the framerate is low\n#define MOTIONBLUR\n\n#define MOUSEX (iMouse.x/iResolution.x)\n#define MOUSEY (iMouse.y/iResolution.y)\n#define PI (3.14159265)\n#define TWOPI (2.*PI)\n#define FLOORY -3.\n#define ZFAR 1000.\n\n// vol texture\nfloat checker( vec3 pos, float scale );\n\n// time it takes a photon to travel 1m. easier to deal with than light speed.\nfloat light_time_per_m()\n{\n    return (iMouse.z > 0.) ? (min(1.,max((MOUSEY-0.25)/0.7,0.))*0.06) : (sin(iTime*.25)*.5+.5)*.06 ;\n}\n\n// light pos\nvec3 light( float t )\n{\n    return vec3(2.,3.5*sin(4.*t),2.);\n}\nfloat lightI( float t )\n{\n    // fade light when close to floor to avoid harsh pop\n    return clamp((light(t).y-FLOORY)/2.,0.,1.);\n}\n\n// scene\nfloat sdf( vec3 pos, float t, out vec4 objPos )\n{\n    float d = ZFAR;\n    \n    float r = 1.;\n\n    float stepR = 1.;\n    \n    vec3 c1 = vec3(.0,-0.5,0.);\n    float d1 = stepR * length(pos-c1) - r;\n    if( d1 < d )\n    {\n        objPos.xyz = c1;\n        objPos.w = 1.;\n        d = d1;\n    }\n    \n    vec3 c2 = vec3(5.*cos(2.*t), sin(8.*t), 5.*sin(2.*t));\n    float d2 = stepR * length(pos-c2) - r;\n    if( d2 < d )\n    {\n        objPos.xyz = c2;\n        objPos.w = 1.;\n        d = d2;\n    }\n\n    vec3 c3 = vec3(0.,FLOORY,0.);\n    vec3 n3 = vec3(0.,1.,0.);\n    float d3 = abs(dot(pos-c3,n3));\n    if( d3 < d )\n    {\n        objPos.xyz = c3;\n        objPos.w = 5.;\n        d = d3;\n    }\n    \n    return d;\n}\nvec3 normal( vec3 pos, float t )\n{\n    vec2 dd = vec2(0.01,0.);\n    vec4 c;\n    return normalize(\n        vec3(sdf(pos+dd.xyy,t,c), sdf(pos+dd.yxy,t,c), sdf(pos+dd.yyx,t,c) ) - vec3(sdf(pos,t,c))\n                    );\n}\n\n// 4D raymarch\nfloat raymarch( vec3 o, vec3 target, float start_time, float timeDir, out vec4 objPos )\n{\n    objPos = vec4(0.,0.,0.,1.);\n    vec3 delta = target - o;\n    float dist = length( delta );\n   \n    vec3 d = delta / dist;\n    \n    float eps = 0.001;\n    \n    float x = 0.;\n    float t = start_time;\n    \n    for( int i = 0; i < 150; i++ )\n    {\n        float dx = sdf( o + x * d, t, objPos );\n        \n        if( abs(dx) < eps )\n        {\n            return x;\n        }\n\n        dx *= .7;\n        x += dx;\n        if( x >= dist )\n            break;\n        \n        // progress time as ray advances to simulate flight time of photon\n        t += timeDir * light_time_per_m() * dx;\n    }\n    \n    return ZFAR;\n}\nfloat raymarch_againstphotons( vec3 o, vec3 target, float start_time, out vec4 objPos )\n{\n    return raymarch( o, target, start_time, -1., objPos );\n}\nfloat raymarch_withphotons( vec3 o, vec3 target, float start_time, out vec4 objPos )\n{\n    return raymarch( o, target, start_time, 1., objPos );\n}\n\n// given a surface position and time - when would a photon have set off from\n// the light to arrive at the surface? not straightforward for a moving light\nfloat lightPhotonStartTime( vec3 finalPos, float finalTime )\n{\n    float startTime = finalTime;\n    \n    // my old friend FPI\n    for( int i = 0; i < 3; i++ )\n    {\n        startTime = finalTime - light_time_per_m() * length( light( startTime ) - finalPos );\n    }\n    \n    return startTime;\n}\n\nvec3 render( vec3 o, vec3 d, float ti )\n{\n    vec4 objPos;\n\tfloat geom = raymarch_againstphotons( o, o + ZFAR * d, ti, objPos );\n    \n    vec3 amb = vec3(1.,0.9,0.8) * .3;\n    \n    if( geom == ZFAR )\n        return amb * .5;\n    \n    float geomT = ti - geom * light_time_per_m();\n    \n    vec3 pt = o + geom * d;\n    vec3 n = normal( pt, geomT );\n    vec3 col = amb * checker(pt-objPos.xyz,objPos.w);\n    \n    // raymarch from light to surface for shadow\n    float lightT = lightPhotonStartTime( pt, geomT );\n    float lenToLight = length(light(lightT) - pt);\n    \n    vec4 dummy;\n    float lightGeom = raymarch_withphotons( light(lightT), pt, lightT, dummy );\n    if( lightGeom > lenToLight-.1 )\n    {\n        vec3 lightDir = normalize( light(lightT) - pt );\n        col = (amb + lightI(lightT)*vec3(.7) * clamp(dot( n, lightDir ), 0., 1.)) * checker(pt-objPos.xyz,objPos.w);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    float fov = .5;\n    uv *= fov;\n    \n    // cam setup\n    float r = 15.;\n    vec3 o = vec3( r*cos(MOUSEX*TWOPI*1.5), 0., r*sin(MOUSEX*TWOPI*1.5) );\n    vec3 d = normalize(-o);\n    vec3 ri = vec3( -sin(MOUSEX*TWOPI*1.5), 0., cos(MOUSEX*TWOPI*1.5) );\n    d += uv.x * ri + uv.y * vec3(0.,1.,0.);\n    d = normalize(d);\n    \n   \tfragColor = vec4(.0);\n    \n    // shoot 5 rays for some brute force MB\n   \tfragColor += vec4(render(o,d,iTime), 1.);\n    \n    #ifdef MOTIONBLUR\n   \tfragColor += vec4(render(o,d,iTime-0.006), 1.);\n   \tfragColor += vec4(render(o,d,iTime-0.003), 1.);\n   \tfragColor += vec4(render(o,d,iTime+0.003), 1.);\n   \tfragColor += vec4(render(o,d,iTime+0.006), 1.);\n    fragColor /= 5.;\n    #endif\n    \n    // finally blend in slider\n    float tpm = light_time_per_m();\n\tvec2 uvs = (fragCoord.xy / iResolution.xy);\n    if( uvs.x == clamp(uvs.x,0.06,0.09) )\n    {\n        float lw = 2./iResolution.x;\n        float alpha = smoothstep( 0.075-lw,0.075, uvs.x ) - smoothstep( 0.075,0.075+lw, uvs.x );\n        alpha *= smoothstep(0.25-lw,0.25,uvs.y) - smoothstep(0.948,0.95,uvs.y);\n        float sliderHeight = 0.25 + 0.7*tpm/0.06;\n        float sliderR = 0.02;\n        float r = length((uvs-vec2(0.075,sliderHeight))/vec2(iResolution.y/iResolution.x,1.));\n        float sliderAlpha = smoothstep(sliderR-lw*1.5,sliderR,r) - smoothstep(sliderR,sliderR+lw*1.5,r);\n        alpha = .5*max(alpha, sliderAlpha );\n\t    fragColor.xyz = mix( fragColor.xyz, vec3(1.), alpha );\n    }\n}\n\nfloat checker( vec3 pos, float scale )\n{\n    float mi = .9;\n    float ma = 1.;\n    \n    pos /= scale;\n    \n    bool greater = abs(fract(pos.x)) > 0.5;\n    \n    if( abs(fract(pos.z)) > 0.5 )\n        greater = !greater;\n    if( abs(fract(pos.y)) > 0.5 )\n        greater = !greater;\n    \n    return greater ? ma : mi;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llB3Rc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llfSRN", "name": "1D Linear Uniform B-Spline II", "author": "demofox", "description": "1D Linear B-Spline.  Use the mouse to control the yellow control point.\nThere are 8 control points P0-P7 and implicitly 10 knots: [0-9].  Only time 1.0 through 8.0 are valid due to how bsplines work.\nSigned distance used for rendering curve.", "tags": ["2d", "bspline"], "likes": 7, "viewed": 1478, "date": "1434820958", "time_retrieved": "2024-06-20T18:21:36.259619", "image_code": "/*\n\nMore info on b-splines and other curves here:\nhttp://www.ibiblio.org/e-notes/Splines/Intro.htm\n\n*/\n\n#define P0  0.25\n#define P1  (sin(iTime*1.5) * 0.5)\n#define P2  0.21\n#define P3  -0.1\n#define P4  0.2\n#define P5  (iMouse.z <= 0.0 ? 0.25 : iMouse.y / iResolution.y - 0.5)\n#define P6  -0.25\n#define P7  0.0\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.0) * (i + 2.0 - t);\n}\n\nfloat SplineValue(in float t)\n{\n    return\n        P0 * N_i_2(t, 0.0) +\n        P1 * N_i_2(t, 1.0) +\n        P2 * N_i_2(t, 2.0) +\n        P3 * N_i_2(t, 3.0) +\n        P4 * N_i_2(t, 4.0) +\n        P5 * N_i_2(t, 5.0) +\n        P6 * N_i_2(t, 6.0) +\n        P7 * N_i_2(t, 7.0);       \n}\n\n// F(x,y) = F(x) - y\nfloat F ( in vec2 coords )\n{\n    // time in this curve goes from 0.0 to 9.0 but values\n    // are only valid between 1.0 and 8.0\n    float T = coords.x*7.0 + 1.0;    \n    return SplineValue(T) - coords.y;\n}\n\n// signed distance function for F(x,y)\nfloat SDF( in vec2 coords )\n{\n    float v = F(coords);\n    float slope = dFdx(v) / dFdx(coords.x);\n    return abs(v)/length(vec2(slope, -1.0));\n}\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, vec2(0.0 / 7.0,P0));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, vec2(1.0 / 7.0,P1));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(2.0 / 7.0,P2));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(3.0 / 7.0,P3));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }     \n    \n    dist = SDFCircle(percent, vec2(4.0 / 7.0,P4));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }   \n    \n    dist = SDFCircle(percent, vec2(5.0 / 7.0,P5));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }      \n    \n    dist = SDFCircle(percent, vec2(6.0 / 7.0,P6));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }        \n    \n    dist = SDFCircle(percent, vec2(7.0 / 7.0,P7));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }       \n    \n    if (percent.x >= 0.0 && percent.x <= 1.0)\n    {\n    \tdist = SDF(percent);\n    \tif (dist < EDGE + SMOOTH)\n    \t{\n        \tdist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        \tcolor *= vec3(dist);\n    \t}\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llfSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llfXzn", "name": "Fake Refraction", "author": "zephmann", "description": "Would love tips on how to do some cheap anti-aliasing, outside of just supersampling :)", "tags": ["2d", "boring"], "likes": 1, "viewed": 138, "date": "1434003612", "time_retrieved": "2024-06-20T18:21:36.259619", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sep = 15.;\n\tfloat lines = iResolution.y / sep;\n    \n    vec2 oguv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy-(iResolution.xy*0.5)) / iResolution.yy;\n    uv *= vec2(1.2);\n    \n    vec2 c = vec2(sin(iTime*1.7)*0.4, cos(iTime*1.3)*0.25);\n    c = vec2(uv.x-c.x, uv.y-c.y);\n    \n    float dist = sqrt(c.x*c.x + c.y*c.y);\n    \n    if(dist < 0.5) {\n       uv.y -= (c.y) * sin( (0.5-dist)/(0.5) * 3.14);\n    }\n    \n    if(mod((uv.y+0.125)*lines, 1.0) < 0.25) {\n        fragColor = vec4(0.0);\n    }\n    else {\n\t\tfragColor = vec4(oguv,0.5+0.5*sin(iTime),1.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llfXzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lljGDt", "name": "Light rays", "author": "ElusivePete", "description": "Simulating light rays which you might see underwater or passing through a cloud. I also used this technique in my \"Seasick\" shader: https://www.shadertoy.com/view/MdXGW7", "tags": ["lighting"], "likes": 84, "viewed": 4454, "date": "1433768595", "time_retrieved": "2024-06-20T18:21:36.562617", "image_code": "float rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord, float seedA, float seedB, float speed)\n{\n\tvec2 sourceToCoord = coord - raySource;\n\tfloat cosAngle = dot(normalize(sourceToCoord), rayRefDirection);\n\t\n\treturn clamp(\n\t\t(0.45 + 0.15 * sin(cosAngle * seedA + iTime * speed)) +\n\t\t(0.3 + 0.2 * cos(-cosAngle * seedB + iTime * speed)),\n\t\t0.0, 1.0) *\n\t\tclamp((iResolution.x - length(sourceToCoord)) / iResolution.x, 0.5, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y = 1.0 - uv.y;\n\tvec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n\t\n\t\n\t// Set the parameters of the sun rays\n\tvec2 rayPos1 = vec2(iResolution.x * 0.7, iResolution.y * -0.4);\n\tvec2 rayRefDir1 = normalize(vec2(1.0, -0.116));\n\tfloat raySeedA1 = 36.2214;\n\tfloat raySeedB1 = 21.11349;\n\tfloat raySpeed1 = 1.5;\n\t\n\tvec2 rayPos2 = vec2(iResolution.x * 0.8, iResolution.y * -0.6);\n\tvec2 rayRefDir2 = normalize(vec2(1.0, 0.241));\n\tconst float raySeedA2 = 22.39910;\n\tconst float raySeedB2 = 18.0234;\n\tconst float raySpeed2 = 1.1;\n\t\n\t// Calculate the colour of the sun rays on the current fragment\n\tvec4 rays1 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\trayStrength(rayPos1, rayRefDir1, coord, raySeedA1, raySeedB1, raySpeed1);\n\t \n\tvec4 rays2 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\trayStrength(rayPos2, rayRefDir2, coord, raySeedA2, raySeedB2, raySpeed2);\n\t\n\tfragColor = rays1 * 0.5 + rays2 * 0.4;\n\t\n\t// Attenuate brightness towards the bottom, simulating light-loss due to depth.\n\t// Give the whole thing a blue-green tinge as well.\n\tfloat brightness = 1.0 - (coord.y / iResolution.y);\n\tfragColor.x *= 0.1 + (brightness * 0.8);\n\tfragColor.y *= 0.3 + (brightness * 0.6);\n\tfragColor.z *= 0.5 + (brightness * 0.5);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lljGDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llSGWt", "name": "chain link", "author": "joeedh", "description": "chain link pattern", "tags": ["chainlink"], "likes": 1, "viewed": 130, "date": "1433490512", "time_retrieved": "2024-06-20T18:21:37.077616", "image_code": "/*\ntodo: clean up code\n\nround chain link/brick pattern.\n*/\n\nfloat min2(float x, float y) {\n    return x*y*2.0;\n}\n\n//main texture function\nfloat sample_chainlink(vec2 uv, int do_dv) {\n    \n    float stepsa = floor(7.0*4.0*0.5);\n    float stepsb = floor(10.0/2.0);\n\tfloat c;\n    float tm = iTime*2.0;\n    \n    //tm = sin(tm)*0.5+0.5;// + sin(tm*2.0) + cos(tm*3.0);\n    //tm = pow(tm, 5.0)*5.0;\n    tm *= 2.0;\n    uv[0] -= iTime*0.2;\n    \n    float yadd = sin(uv[0]*1.0+tm)*0.1;//*sin(uv[0]*5.0+tm)*0.1;\n    \n    uv[1] += yadd;\n    vec2 pos = uv;\n\n    float xadd = mod(floor(pos[1]*10.0), 2.0);\n    c = mod(floor((pos[0])*7.0*stepsa+xadd*stepsa*0.5), stepsa)*mod(floor(pos[1]*10.0*stepsb), stepsb);\n    c = max(min(c, 1.0), 0.0);\n\n    float inside = mod(c+1.0, 2.0);\n\n    xadd = mod(floor(-0.1+pos[1]*10.0), 2.0);\n    float x =  mod(abs(-0.033+pos[0]*7.0+(1.0-xadd)*0.5), 1.0);\n    float y =  mod(abs(-0.1+pos[1]*10.0)+0.5, 1.0);\n\n    x = (x-0.5)*4.0 + 0.5;\n\n    x = smoothstep(0.0, 1.0, x)*0.25 + x*0.75;\n    y = smoothstep(0.0, 1.0, y)*0.25 + y*0.75;\n    x = x-0.5;\n    y = y-0.5;\n    \n    //box\n    c = min2(abs(x), abs(y));\n\tfloat c2 = c;\n    \n    c = pow(smoothstep(0.0, 1.0, c), 1.0);\n    \n    uv *= 3.141*0.5;\n    float thx = uv[0]*28.0+3.0, thy=uv[1]*20.0+3.1;\n    \n    float ring = abs((cos(thx)+sin(thy)));\n    ring = 1.0 - pow(ring, 2.0);\n    \n    float parta = 1.0-2.0*pow(c, 0.5);\n    float partb = parta*ring;\n    \n    if (do_dv == 0) {\n        parta = max(parta, 0.0);\n        partb = max(parta*ring, 0.0);\n    }\n    \n    c = c + 0.5*pow(abs(partb), 1.5);\n\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv *= 1.5;\n    uv[0] *= 0.75;\n    float filter1 = 0.3;\n\n    //offset the crappy derivatives of this function to get a mirror-like effect.\n    \n#define DF 0.05 - abs(sin(7.0*uv[0])*sin(15.0*uv[1]+1.0))*0.01\n    float c = sample_chainlink(uv, 1);\n    float dx = (sample_chainlink(uv+vec2(DF, 0.0), 1)-c)/DF;\n    float dy = (sample_chainlink(uv+vec2(0.0, DF), 1)-c)/DF;\n    \n    c = sample_chainlink(uv, 0);\n    \n    vec3 dv = normalize(vec3(dx, dy, c));\n    \n    vec3 light = normalize(vec3(-1.0, 1.5, 1.0));\n    \n    float d = abs(dot(dv, light)*0.5+0.5);\n    d = pow(d, 1.0)*1.0;\n    d = d*0.5 + 0.5;\n    \n    c = c*d;\n    fragColor = vec4(c, c, c, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llSGWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llsSR7", "name": "boomlinde brain", "author": "aji", "description": "a plasma effect I stole from boomlinde, raymarched into a field of waves and a fisheye projection", "tags": ["raymarch", "plasma"], "likes": 28, "viewed": 688, "date": "1435526039", "time_retrieved": "2024-06-20T18:21:37.083839", "image_code": "#define RM_FACTOR   0.9\n#define RM_ITERS     90\n\nfloat plasma(vec3 r) {\n\tfloat mx = r.x + iTime / 0.130;\n\tmx += 20.0 * sin((r.y + mx) / 20.0 + iTime / 0.810);\n\tfloat my = r.y - iTime / 0.200;\n\tmy += 30.0 * cos(r.x / 23.0 + iTime / 0.710);\n\treturn r.z - (sin(mx / 7.0) * 2.25 + sin(my / 3.0) * 2.25 + 5.5);\n}\n\nfloat scene(vec3 r) {\n\treturn plasma(r);\n}\n\nfloat raymarch(vec3 pos, vec3 dir) {\n\tfloat dist = 0.0;\n\tfloat dscene;\n\n\tfor (int i = 0; i < RM_ITERS; i++) {\n\t\tdscene = scene(pos + dist * dir);\n\t\tif (abs(dscene) < 0.1)\n\t\t\tbreak;\n\t\tdist += RM_FACTOR * dscene;\n\t}\n\n\treturn dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat c, s;\n\tfloat vfov = 3.14159 / 2.3;\n\n\tvec3 cam = vec3(0.0, 0.0, 30.0);\n\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y *= -1.0;\n\n\tvec3 dir = vec3(0.0, 0.0, -1.0);\n\n\tfloat xrot = vfov * length(uv);\n\n\tc = cos(xrot);\n\ts = sin(xrot);\n\tdir = mat3(1.0, 0.0, 0.0,\n\t           0.0,   c,  -s,\n\t           0.0,   s,   c) * dir;\n\n\tc = normalize(uv).x;\n\ts = normalize(uv).y;\n\tdir = mat3(  c,  -s, 0.0,\n\t             s,   c, 0.0,\n\t           0.0, 0.0, 1.0) * dir;\n\n\tc = cos(0.7);\n\ts = sin(0.7);\n\tdir = mat3(  c, 0.0,   s,\n\t           0.0, 1.0, 0.0,\n\t            -s, 0.0,   c) * dir;\n\n\tfloat dist = raymarch(cam, dir);\n\tvec3 pos = cam + dist * dir;\n\n\tfragColor.rgb = mix(\n\t\tvec3(0.4, 0.8, 1.0),\n\t\tmix(\n\t\t\tvec3(0.0, 0.0, 1.0),\n\t\t\tvec3(1.0, 1.0, 1.0),\n\t\t\tpos.z / 10.0\n\t\t),\n\t\t1.0 / (dist / 20.0)\n\t);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llsSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llsSRM", "name": "Creation in 162 chars", "author": "GregRostami", "description": "My attempt at reducing the brilliant Creation by Silexars:\nhttps://www.shadertoy.com/view/XsXXDn\nAny help reducing this further will be appreciated. Thank you.", "tags": ["2d", "explode", "short", "tweet", "2tc"], "likes": 20, "viewed": 1017, "date": "1435456909", "time_retrieved": "2024-06-20T18:21:37.083839", "image_code": "void mainImage(out vec4 o, vec2 U) {\nvec2 u=U/iResolution.x-.5;\nfloat L=length(u),t=iTime;\nfor(int i=0;i<3;i++)\n    o[i]=.01/length(fract(.5+u+u/L*(sin(t+=.05)+1.)*sin(L*9.-t-t))-.5)/L; }  /*\n\n//Thanks to coyote the shader is now 171 chars!\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    float L = length(u=u/iResolution.x-.5), t=iTime;\n    for(int i=0;i<3;i++)\n        o[i] = .01/length( fract(.5+u+u/L*(sin(t+=.05)+1.) * sin(L*9.-t-t))-.5)/L;\n}\n\n\n//Original Shader\nvoid mainImage(out vec4 f, vec2 u )\n{\n    f = iDate;\n\tfor(int i=0;i<3;i++)\n    {\n\t\tvec2 u = u/iResolution.x, v=u;\n\t\tfloat l = length(u-=.5);\n\t\tv += u/l * (sin(f.a+=.05)+1.) * sin(l*9.-f.a/.5);\n\t\tf[i] = .01/length(mod(v,1.)-.5)/l;\n\t}\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llsSRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llXSRN", "name": "1D Quadratic Uniform B-Spline", "author": "demofox", "description": "1D Quadratic B-Spline.  Mouse controls the yellow control point.\nThere are 4 control points A,B,C,D and implicitly 7 knots: [0,1,2,3,4,5,6]. Only time 2.0 through 4.0 are valid due to how bsplines work.\nSigned distance used for rendering curve.", "tags": ["2d", "bspline"], "likes": 2, "viewed": 1326, "date": "1434818929", "time_retrieved": "2024-06-20T18:21:37.720342", "image_code": "/*\n\nMore info on b-splines and other curves here:\nhttp://www.ibiblio.org/e-notes/Splines/Intro.htm\n\n*/\n\n#define A  0.25\n#define B  (sin(iTime*1.5) * 0.5)\n#define C  (iMouse.z <= 0.0 ? 0.25 : iMouse.y / iResolution.y - 0.5)\n#define D  -0.1\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.0) * (i + 2.0 - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i + 1.0) * (i + 3.0 - t) / 2.0;\n}\n\nfloat SplineValue(in float t)\n{\n    return\n        A * N_i_3(t, 0.0) +\n        B * N_i_3(t, 1.0) +\n        C * N_i_3(t, 2.0) +\n        D * N_i_3(t, 3.0);\n}\n\n// F(x,y) = F(x) - y\nfloat F ( in vec2 coords )\n{\n    // time in this curve goes from 0.0 to 6.0 but values\n    // are only valid between 2.0 and 4.0\n    float T = coords.x*2.0 + 2.0;\n    return SplineValue(T) - coords.y;\n}\n\n// signed distance function for F(x,y)\nfloat SDF( in vec2 coords )\n{\n    float v = F(coords);\n    float slope = dFdx(v) / dFdx(coords.x);\n    return abs(v)/length(vec2(slope, -1.0));\n}\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, vec2(0.0,A));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, vec2(0.33,B));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(0.66,C));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(1.0,D));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }      \n    \n    if (percent.x >= 0.0 && percent.x <= 1.0)\n    {\n    \tdist = SDF(percent);\n    \tif (dist < EDGE + SMOOTH)\n    \t{\n        \tdist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        \tcolor *= vec3(dist);\n    \t}\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llXSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llXSRr", "name": "message: click to see", "author": "FabriceNeyret2", "description": "Some shaders cannot give a working icon, typically when not all fragments are drawn at each frame.\nHere, we show how to add a text message to the icon to alert and invite the users to click to see the real thing.", "tags": ["text", "font", "utils"], "likes": 2, "viewed": 1540, "date": "1434008578", "time_retrieved": "2024-06-20T18:21:37.720342", "image_code": "// === icon message: \"click to see\". link: https://www.shadertoy.com/view/MtyXRW\n\n// add a text alert in the icon view \n\nfloat message(vec2 p) {  // the alert function to add to your shader\n    int x = int(p.x+1.)-1, y=int(p.y)-10,  i;\n    if (x<1||x>32||y<0||y>2) return -1.; \n    i = ( y==2? i=  757737252: y==1? i= 1869043565: y==0? 623593060: 0 )/ int(exp2(float(32-x)));\n \treturn i==2*(i/2) ? 1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iResolution.y<2000.) { // replace by 200 to display only in the icon \n        float c=message(fragCoord.xy/8.); if(c>=0.){ fragColor=vec4(c);return; } }\n\n    \n    // your shader\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}\n\n\n\n\n\n\n/*  // expended version: \nfloat message(vec2 uv) {\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  757737252/bit; // 11010010 11010101 11011000 11011011\n    if (int(uv.y)==1) i= 1869043565/bit; // 10010000 10011000 10101000 10010010\n    if (int(uv.y)==0) i=  623593060/bit; // 11011010 11010100 10111001 10011011\n \treturn float(1-i+2*(i/2));\n}\n*/\n\n\n\n/* // more expended version: \n\nfloat decode(int char, float x) {\n    int i = ((x<0.)||(x>=32.)) ? 1 : char / int(pow(2.,floor(32.-x)));\n\treturn float(1-i+2*(i/2));\n}\n\nfloat message(vec2 uv) {\n    float c=0.;\n    if (int(uv.y)==12) c = decode( 757737252, uv.x); // 11010010 11010101 11011000 11011011\n    if (int(uv.y)==11) c = decode(1869043565, uv.x); // 10010000 10011000 10101000 10010010\n    if (int(uv.y)==10) c = decode( 623593060, uv.x); // 11011010 11010100 10111001 10011011\n \treturn c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    fragColor = vec4(message((fragCoord.xy-iResolution.xy/2.)/8.));\n}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llXSRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llXXz4", "name": "voronoi fracture", "author": "mattz", "description": "Fun with fake physics!", "tags": ["voronoi", "collision", "spherical", "explode", "fracture", "fakephysics"], "likes": 56, "viewed": 2926, "date": "1434845526", "time_retrieved": "2024-06-20T18:21:40.290059", "image_code": "/* voronoi fracture, by mattz - Voronoi brittle fracture simulation. \n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Yet another use of fast spherical Voronoi computations. \n   See https://www.shadertoy.com/view/MtBGRD for technical details.\n\n   Note the code below is not as nice or pretty as the linked shader MtBGRD.\n   Please consider that one the \"reference implementation\".\n\n\n*/\n\n\n/* Magic angle that equalizes projected area of squares on sphere. */\n#define MAGIC_ANGLE 0.868734829276 // radians\n\nconst float warp_theta = MAGIC_ANGLE;\nfloat tan_warp_theta = tan(warp_theta);\n\nconst float farval = 1e5;\nconst vec3 tgt = vec3(0);\nconst vec3 cpos = vec3(0,0,8.0);\nconst float fovy = 0.6; \nvec3 L = normalize(vec3(-0.4, 0.4, 1.0));\n\nconst float plane_dist = 3.0;\nvec3 plane_n = normalize(vec3(0, .2, .5));\n\nconst float eps = 0.05;\n\nconst float thickness = 0.015;\n\nconst float N = 3.0;\nconst float fragment_radius = 0.5;\n\nconst float period = 10.0;\nconst float appear_time = 0.8;\n\nconst float coll_time = 3.6;\nconst vec3 coll_normal = vec3(1.0, 0.0, 0.0);\nconst float r2 = 1.0;\nconst float r1 = 0.25;\nconst float m1 = 4.0;\nconst float m2 = 1.0;\nconst float u1 = 2.0;\nconst float v1 = u1*(m1-m2)/(m1+m2);\nconst float cr = 0.7;\nconst float v2 = cr*2.0*m1*u1 /(m1 + m2);\n\nfloat abs_time, rel_time, seed;\n\nmat3 Rview;\n\nstruct rayhit {\n    vec4 ntmin;\n    vec4 ntmax;\n};\n\nconst rayhit miss = rayhit(vec4(farval), vec4(-farval));\n\n/* Choose vector with smaller w. */\nvec4 v4min(vec4 a, vec4 b) {\n\treturn a.w < b.w ? a : b;\n}\n\n/* Choose vector with larger w. */\nvec4 v4max(vec4 a, vec4 b) {\n\treturn a.w > b.w ? a : b;\n}\n\n/* Intersection of two ray intervals. */\nrayhit rayinter(rayhit a, rayhit b) {\n\treturn rayhit(v4max(a.ntmin, b.ntmin),\n                  v4min(a.ntmax, b.ntmax));\n}\n\n/* Union of two ray intervals. */\nrayhit rayunion(rayhit a, rayhit b) {\n\treturn rayhit(v4min(a.ntmin, b.ntmin),\n                  v4max(a.ntmax, b.ntmax));\n}\n\n/* Difference of two ray intervals. */\nrayhit raydiff(rayhit a, rayhit b) {\n\n    if (b.ntmin.w <= a.ntmin.w) {\n        return rayhit(v4max(a.ntmin, vec4(-b.ntmax.xyz, b.ntmax.w)), a.ntmax);\n    } else {\n        return rayhit(a.ntmin, v4min(a.ntmax, vec4(-b.ntmin.xyz, b.ntmin.w)));\n    }\n    \n\t\t    \n}\n\n/* Ray-sphere intersection. */\nrayhit sphere(in vec3 o, in vec3 d, in float r) {\n\t\n\t\n\tfloat p = -dot(o, d);\n\tfloat q = dot(o, o) - r*r;\n\t\t\n\tfloat D = p*p - q;\n\n\tif (D > 0.0) {\n\t\tfloat sqrtD = sqrt(D);\n        float t0 = p-sqrtD;\n        float t1 = p+sqrtD;\n        if (t1 < 0.0) { return miss; }\n        return rayhit(vec4(normalize(o+t0*d), t0),\n                      vec4(normalize(o+t1*d), t1));\n\t}\n\t\n\treturn miss;\n\t\t\n}\n\n/* Ray-plane intersection. */\nrayhit plane(vec3 o, vec3 d, vec3 n) {\n\n\tfloat t = -dot(n,o)/dot(n,d);    \n    \n    if (dot(d, n) > 0.0) {\n        return rayhit(vec4(n, eps), vec4(n, t));\n    } else {\n        return rayhit(vec4(n, t), vec4(n, farval));\n    }\n        \n    \n}\n\n/* Ray-box intersection. */\nrayhit box(vec3 ro, vec3 rd, vec3 b) {\n\t\n\tvec3 rdi = 1.0/rd;\t\n\t\t\n\tvec3 t1 = (-b - ro)*rdi;\n\tvec3 t2 = ( b - ro)*rdi;\n\t\n\tvec3 tmin = min(t1, t2);\n\tvec3 tmax = max(t1, t2);\n\t\n\tconst vec3 x = vec3(1.0, 0.0, 0.0);\n\tconst vec3 y = vec3(0.0, 1.0, 0.0);\n\tconst vec3 z = vec3(0.0, 0.0, 1.0);\n\t\n\tvec4 vmin = v4max(v4max(vec4(x,tmin.x), vec4(y,tmin.y)), vec4(z,tmin.z));\n\tvec4 vmax = v4min(v4min(vec4(x,tmax.x), vec4(y,tmax.y)), vec4(z,tmax.z));\n    \n    if (vmin.w > 0.0 && vmin.w <= vmax.w) {\n        vmin.xyz *= -sign(dot(rd, vmin.xyz));\n        vmax.xyz *= sign(dot(rd, vmax.xyz));        \n        return rayhit(vmin, vmax);                \n\t} else {\n\t\treturn miss;\n\t}\t\t\n\t\n}\n\n/* Return a permutation matrix whose first two columns are u and v basis \n   vectors for a cube face, and whose third column indicates which axis \n   (x,y,z) is maximal. */\nmat3 getPT(in vec3 p) {\n\n    vec3 a = abs(p);\n    float c = max(max(a.x, a.y), a.z);    \n    vec3 s = c == a.x ? vec3(1.,0,0) : c == a.y ? vec3(0,1.,0) : vec3(0,0,1.);\n    s *= sign(dot(p, s));\n    vec3 q = s.yzx;\n    return mat3(cross(q,s), q, s);\n\n}\n\n/* For any point in 3D, obtain the permutation matrix, as well as grid coordinates\n   on a cube face. */\nvoid posToGrid(in float N, in vec3 pos, out mat3 PT, out vec2 g) {\n    \n    // Get permutation matrix and cube face id\n    PT = getPT(pos);\n    \n    // Project to cube face\n    vec3 c = pos * PT;     \n    vec2 p = c.xy / c.z;      \n    \n    // Unwarp through arctan function\n    vec2 q = atan(p*tan_warp_theta)/warp_theta; \n    \n    // Map [-1,1] interval to [0,N] interval\n    g = (q*0.5 + 0.5)*N;\n    \n}\n\n/* For any grid point on a cube face, along with projection matrix, \n   obtain the 3D point it represents. */\nvec3 gridToPos(in float N, in mat3 PT, in vec2 g) {\n    \n    // Map [0,N] to [-1,1]\n    vec2 q = g/N * 2.0 - 1.0;\n    \n    // Warp through tangent function\n    vec2 p = tan(warp_theta*q)/tan_warp_theta;\n\n    // Map back through permutation matrix to place in 3D.\n    return PT * vec3(p, 1.0);\n    \n}\n\n/* Return whether a neighbor can be identified for a particular grid cell.\n   We do not allow moves that wrap more than one face. For example, the \n   bottom-left corner (0,0) on the +X face may get stepped by (-1,0) to \n   end up on the -Y face, or, stepped by (0,-1) to end up on the -Z face, \n   but we do not allow the motion (-1,-1) from that spot. If a neighbor is \n   found, the permutation/projection matrix and grid coordinates of the \n   neighbor are computed.\n*/\nbool gridNeighbor(in float N, in mat3 PT, in vec2 g, in vec2 delta, out mat3 PTn, out vec2 gn) {\n\n    vec2 g_dst = g.xy + delta;\n    vec2 g_dst_clamp = clamp(g_dst, 0.0, N);\n\n    vec2 extra = abs(g_dst_clamp - g_dst);\n    float esum = extra.x + extra.y;\n \n    if (max(extra.x, extra.y) == 0.0) {\n        PTn = PT;\n        gn = g_dst;\n        return true;\n    } else if (min(extra.x, extra.y) == 0.0 && esum < N) {\n        vec3 pos = PT * vec3(g_dst_clamp/N*2.0-1.0, 1.0 - 2.0*esum/N);\n        PTn = getPT(pos);\n        gn = ((pos * PTn).xy*0.5 + 0.5) * N;\n        return true;\t        \n    } else {\n        return false;\n    }\n    \n\n}\n\n/* From https://www.shadertoy.com/view/Xd23Dh */\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n                  dot(p,vec2(269.5,183.3)), \n                  dot(p,vec2(419.2,371.9)) );\n    return fract(sin(q)*43758.5453);\n}\n\n/* Perturb a cube sample based upon location. */\nvec3 getRandomPos(in float N, in mat3 PTn, in vec2 gn) {\n    \n    float face = dot(PTn[2], vec3(1.,2.,3.));   \n                \n    // Perturb based on grid cell ID\n    gn = floor(gn);\n    vec3 rn = hash3(gn*seed + face);\n    gn += 0.5 + (rn.xy * 2.0 - 1.0)*0.45;\n\n    // Get the 3D position\n    return normalize(gridToPos(N, PTn, gn));  \n    \n}\n\n/* Check one edge of voronoi diagram. */\nvoid checkNeighbor(in vec3 ro, in vec3 rd,\n                   in float N, in mat3 PT, in vec2 g, \n                   in vec3 p1, in vec2 uv, \n                   inout rayhit r) {\n    \n    if (r.ntmin.w < r.ntmax.w) {\n\n        vec2 gn;\n        mat3 PTn;\n\n        if (gridNeighbor(N, PT, g, uv, PTn, gn)) {                \n            vec3 p2 = getRandomPos(N, PTn, gn);                              \n            vec3 n1 = cross(p1.xyz,p2.xyz);\n            vec3 n2 = normalize(cross(n1, 0.5*(p1.xyz+p2.xyz)));\n            r = rayinter(r, plane(ro, rd, n2));\n        }\n        \n    }\n    \n}\n\n/* Given hit on sphere, intersect with voronoi */ \nvoid fragment(in vec3 ro, in vec3 rd, \n              in float N, in mat3 PT, in vec2 g, in vec3 p1,\n              inout rayhit r) {\n    \n    checkNeighbor(ro, rd, N, PT, g, p1, vec2(-1.0, -1.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2( 0.0, -1.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2( 1.0, -1.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2(-1.0,  0.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2( 1.0,  0.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2(-1.0,  1.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2( 0.0,  1.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2( 1.0,  1.0), r);\n\n}\n\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n/* Rotation matrix from angle-axis */\nmat3 rotaxisangle(in vec3 a, float t) {\n    mat3 K = mat3(0, a.z, -a.y,\n                  -a.z, 0, a.x,\n                  a.y, -a.x, 0);\n    return mat3(1.0) + K*(mat3(sin(t)) + (1.0-cos(t))*K);\n}\n\n/* Cast a ray into the scene and get result. */\nvoid castRay( in vec3 ro, in vec3 rd, out vec4 result, out vec3 mat){\n\n    result = vec4(farval);\n\n    const vec3 x = vec3(1.0, 0.0, 0.0);\n    const vec3 y = vec3(0.0, 1.0, 0.0);\n    const vec3 z = vec3(0.0, 0.0, 1.0); \n\n    rayhit p = plane(ro+plane_dist*plane_n, rd, plane_n);\n    if (p.ntmin.w > eps) {\n        result = p.ntmin;\n        mat = vec3(1.95, 0.2, 8.0);\n    }       \n    \n    vec2 rando = fract(seed*vec2(139398.4339482,9304.371));    \n    vec3 v1_perp = vec3(0.0, rando*vec2(6.0, 1.0)-vec2(3.0, 0)); \n  \n    vec3 p1 = -coll_normal*(r1+r2);\n    if (rel_time < coll_time) {\n        p1 -= (u1*coll_normal + v1_perp)*(coll_time-rel_time);\n    } else {\n        p1 -= (v1*coll_normal + v1_perp)*(coll_time-rel_time);\n    }    \n    \n    rayhit s = sphere(ro-p1, rd, r1);\n    if (s.ntmin.w < s.ntmax.w && s.ntmin.w < result.w) {\n        result = s.ntmin;\n        mat = vec3(1.1, 0.5, 24.0);\n    }\n        \n    for (int k=0; k<6; ++k) {\n        \n        mat3 PT;\n        \n        if (k < 3) {\n            if (k == 0) {\n                PT = mat3(x, y, z);\n            } else if (k == 1) {\n                PT = mat3(y, z, x);\n            } else {\n                PT = mat3(z, x, y);\n            }\n        } else {\n            if (k == 3) {\n                PT = mat3(x, -y, -z);\n            } else if (k == 4) {\n                PT = mat3(y, -z, -x);\n            } else {\n                PT = mat3(z, -x, -y);\n            }\n        }        \n        \n        for (float u=0.0; u<N; ++u) {\n            for (float v=0.0; v<N; ++v) {\n\n                vec2 g = vec2(u,v) + 0.5;\n                \n                vec3 p1 = r2*getRandomPos(N, PT, g);\n                \n                \n                vec3 pos = p1;\n                float a = max(appear_time-rel_time, 0.0)/appear_time;\n                a = 3.0*a*a - 2.0*a*a*a;\n                float da = 2.0*r2+plane_dist+eps;\n                pos -= da*plane_n*a;\n                \n                float time_after_coll = max(rel_time-coll_time, 0.0);\n                \n                if (time_after_coll > 0.0) {                    \n                    vec3 fragment_delta = (p1+coll_normal*v2)*(rel_time-coll_time);\n                    pos += fragment_delta;\n                    float dp = dot(pos, plane_n) + plane_dist - fragment_radius;                \n                    pos -= plane_n * min(0.0, dp);\n                }\n                \n                rayhit f = sphere(ro-pos, rd, fragment_radius);\n\n                if (f.ntmin.w < f.ntmax.w && f.ntmin.w < result.w) {\n\n                    vec3 h1 = hash3(p1.xy);\n                    vec3 h2 = hash3(p1.yz);\n                    \n                    vec3 omega = normalize(2.*h1 - 1.);\n\n                    mat3 R = rotaxisangle(omega, 4.*time_after_coll*h2.x);\n\n                    vec3 fro = R*(ro-pos) + p1;\n                    vec3 frd = R*rd;\n\n                    f = sphere(fro, frd, r2);\n\n                    fragment(fro, frd, N, PT, g, p1, f);\n                    rayhit s2 = sphere(fro, frd, r2-thickness);\n                    f = raydiff(f, s2);\n                    \n                    if (f.ntmax.w >= f.ntmin.w && f.ntmin.w < result.w) {\n                        \n                        result = vec4(f.ntmin.xyz*R, f.ntmin.w);\n                                                \n                        float hue_mod = floor(abs_time/period)*0.6532;\n                        float sphere_h = fract(0.03 + hue_mod);\n                        \n                        mat = vec3(sphere_h, 0.4, 15.0);\n                        \n                    }\n                    \n                }\n                \n            }\n        }\n    }\n    \n    \n}\n\nvec3 hue(float h) {\n\tvec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n\treturn h >= 1.0 ? vec3(h-1.0) : (clamp(min(c, -c+4.0), 0.0, 1.0)*0.75 + 0.2);\n}\n\nvec3 shade(in vec3 ro, in vec3 rd) {\n    \n    vec3 c = vec3(1.0);\n    \n    vec4 r;\n    vec3 m;\n    \n    castRay(ro, rd, r, m);\n\n    if (r.w < farval) {\n        \n        vec3 n = r.xyz;\n        vec3 color = hue(m.x);\n        \n        ro = ro + r.w*rd + 2.0*eps * r.xyz;\n\n        vec3 amb = 0.2 * color;\n        vec3 diff = 0.8*clamp(dot(n,L), 0.0, 1.0) * color;\n                \n        vec3 R = 2.0*n*dot(n,L)-L;\n                \n        float spec = pow(clamp(-dot(R, rd), 0.0, 1.0), m.z)*m.y;\n        \n\t\tcastRay(ro, L, r, m);\n\n        if (r.w < farval) {\n\t\t\tdiff = vec3(0);\n            spec = 0.0;\n        }\n                  \n        c = diff + amb + spec;\n\n    }\n    \n    return c;   \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    abs_time = iTime + appear_time;\n    rel_time = mod(abs_time, period);\n    seed = 0.2134 + floor(abs_time/period)*0.05395029;        \n        \n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * fovy / (iResolution.y);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float t = iTime;\n         \n    float thetay = 0.0;\n    float thetax = 0.0;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * 0.5/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * -1.0/iResolution.x; \n    }\n\n    Rview = mat3(rx,ry,rz)*rotX(thetax)*rotY(thetay);        \n  \n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n        \n    vec3 color = shade(ro, rd);\n    \n    color = pow(color, vec3(0.7));\n    \n    // stole iq's vingette code\n    color *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );       \n\n    fragColor = vec4(color, 1.0);\n\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llXXz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llXXz7", "name": "very sleepy 2", "author": "spencersalazar", "description": "You are feeling very sleepy (again)", "tags": ["2d"], "likes": 3, "viewed": 122, "date": "1435259661", "time_retrieved": "2024-06-20T18:21:40.290059", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float width = iResolution.x;\n    float height = iResolution.y;\n    float t = iTime;\n    float x = fragCoord.x-width/2.0;\n    float y = fragCoord.y-height/2.0;\n\t\n    float p = 0.20;\n    float d = pow(x*x+y*y, 0.25)*1.0/p+t*4.0;\n    \n    float b = sin(d)*2.0;\n    fragColor = vec4(b, b, b, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llXXz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt23D3", "name": "Brush Experiment 2", "author": "104", "description": "Brush strokes / calligraphy experiments. Use the mouse. All you need to apply the effect is distance-to-geometry, and \"how far along the path\". So if you can get those 2 things for bezier curves for example, this can get curvy. Working on a circle version", "tags": ["2d", "brush"], "likes": 98, "viewed": 2745, "date": "1433278566", "time_retrieved": "2024-06-20T18:21:41.199218", "image_code": "////////////////////////////////////////////////////////////////\n// BOILERPLATE UTILITIES...................\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat opS( float d2, float d1 ){return max(-d1,d2);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\nvec3 colorAxisAlignedBrushStroke(vec2 uv, vec2 uvPaper, vec3 inpColor, vec4 brushColor, vec2 p1, vec2 p2)\n{\n    // how far along is this point in the line. will come in handy.\n    vec2 posInLine = smoothstep(p1, p2, uv);//(uv-p1)/(p2-p1);\n\n    // wobble it around, humanize\n    float wobbleAmplitude = 0.13;\n    uv.x += sin(posInLine.y * pi2 * 0.2) * wobbleAmplitude;\n\n    // distance to geometry\n    float d = sdAxisAlignedRect(uv, p1, vec2(p1.x, p2.y));\n    d -= abs(p1.x - p2.x) * 0.5;// rounds out the end.\n    \n    // warp the position-in-line, to control the curve of the brush falloff.\n    posInLine = pow(posInLine, vec2((nsin(iTime * 0.5) * 2.) + 0.3));\n\n    // brush stroke fibers effect.\n    float strokeStrength = dtoa(d, 100.);\n    float strokeAlpha = 0.\n        + noise01((p2-uv) * vec2(min(iResolution.y,iResolution.x)*0.25, 1.))// high freq fibers\n        + noise01((p2-uv) * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\n        + noise01((p2-uv) * vec2(14., 1.))// low freq noise, gives more variation\n        ;\n    strokeAlpha *= 0.66;\n    strokeAlpha = strokeAlpha * strokeStrength;\n    strokeAlpha = strokeAlpha - (1.-posInLine.y);\n    strokeAlpha = (1.-posInLine.y) - (strokeAlpha * (1.-posInLine.y));\n\n    // fill texture. todo: better curve, more round?\n    const float inkOpacity = 0.85;\n    float fillAlpha = (dtoa(abs(d), 90.) * (1.-inkOpacity)) + inkOpacity;\n\n    // todo: splotches ?\n    \n    // paper bleed effect.\n    float amt = 140. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n    \n\n    float alpha = fillAlpha * strokeAlpha * brushColor.a * dtoa(d, amt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStroke(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1, vec2 p2, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    vec2 rectDimensions = p2 - p1;\n    float angle = atan(rectDimensions.x, rectDimensions.y);\n    mat2 rotMat = rot2D(-angle);\n    p1 *= rotMat;\n    p2 *= rotMat;\n    float halfLineWidth = lineWidth / 2.;\n    p1 -= halfLineWidth;\n    p2 += halfLineWidth;\n\tvec3 ret = colorAxisAlignedBrushStroke(uv * rotMat, uv, inpColor, brushColor, p1, p2);\n    // todo: interaction between strokes, smearing like my other shader\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord / iResolution.y * 2.0) - 1.;\n    vec2 mouse = (iMouse.xy / iResolution.y * 2.0) - 1.;\n    \n    vec3 col = vec3(1.,1.,0.86);// bg\n    float dist;\n    \n    // black stroke\n    col = colorBrushStroke(uv, col, vec4(vec3(.8,.1,0),.8),// red fixed line\n                           vec2(1.7, .8),\n                           vec2(-0.6, -.6), 0.1);\n\n    col = colorBrushStroke(uv, col, vec4(vec3(0.),.8),// black fixed line\n                           vec2(.6, -.8),\n                           vec2(2.3, .2),\n                           0.1);\n\n    if(iMouse.x == 0.)\n        mouse = vec2(1.1,.8);\n    col = colorBrushStroke(uv, col, vec4(vec3(0.),.9),// black movable line\n                           vec2(-0.4, 0.0),\n                           mouse,0.3);\n\n    // red-orangeish signature\n    dist = sdAxisAlignedRect(uv, vec2(-0.68), vec2(-0.55));\n    float amt = 90. + (rand(uv.y) * 100.) + (rand(uv.x / 4.) * 90.);\n    float vary = sin(uv.x*uv.y*50.)*0.0047;\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\n    col = mix(col, vec3(0.99,.4, 0.0), dtoa(dist, amt) * 0.7);\n    col = mix(col, vec3(0.85,0.,0.), dtoa(dist, 700.));\n\n    // grain\n    col.rgb += (rand(uv)-.5)*.08;\n    col.rgb = saturate(col.rgb);\n\n    uv -= 1.0;// vignette\n\tfloat vignetteAmt = 1.-dot(uv*0.5,uv* 0.12);\n    col *= vignetteAmt;\n    \n    \n    fragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt23D3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt2GDt", "name": "iq-bad Voronoi distance ", "author": "FabriceNeyret2", "description": "dmin2-dmin1=0 gives Voronoi diagram, but  dmin2-dmin1 is not what you think.\nSPACE: iq-good dist .  R: round dist.  C: col vs isovals.  T: stop time.\n(still, for natural textures you might prefer Worley noise and its deformed distances).", "tags": ["voronoi", "worley", "distance"], "likes": 28, "viewed": 2110, "date": "1433769827", "time_retrieved": "2024-06-20T18:21:41.811346", "image_code": "float scale = 5.;\nfloat time;\n\n#define PI 3.14159\n\nbool keyToggle(int ascii)  {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n// --- End of: Created by inigo quilez --------------------\n\n// more 2D noise\nvec2 hash12( float n ) {\n    return fract(sin(n+vec2(1.,12.345))*43758.5453);\n}\nfloat hash21( vec2 n ) {\n    return hash(n.x+10.*n.y);\n}\nvec2 hash22( vec2 n ) {\n    return hash12(n.x+10.*n.y);\n}\n\nfloat cell;   // id of closest cell\nvec2  center; // center of closest cell\n\nvec3 worley( vec2 p ) {\n    vec3 d = vec3(1e15);\n    vec2 ip = floor(p);\n    for (float i=-2.; i<3.; i++)\n   \t \tfor (float j=-2.; j<3.; j++) {\n                vec2 p0 = ip+vec2(i,j);\n            \tfloat a0 = hash21(p0), a=5.*a0*time+2.*PI*a0; vec2 dp=vec2(cos(a),sin(a)); \n                vec2  c = hash22(p0)*.5+.5*dp+p0-p;\n                float d0 = dot(c,c);\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; cell=hash21(p0); center=c;}\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\n                else if (d0<d.z) {            d.z=d0; }  \n            }\n    return sqrt(d);\n}\n\n// distance to Voronoi borders, as explained in https://www.shadertoy.com/view/ldl3W8 \nfloat worleyD( vec2 p) {\n    float d = 1e15;\n    vec2 ip = floor(p);\n    for (float i=-2.; i<3.; i++)\n   \t \tfor (float j=-2.; j<3.; j++) {\n            vec2 p0 = ip+vec2(i,j);\n            float a0 = hash21(p0), a=5.*a0*time+2.*PI*a0; vec2 dp=vec2(cos(a),sin(a)); \n            vec2  c = hash22(p0)*.5+.5*dp+p0-p;\n            float d0 = dot(c,c);\n \t    \tfloat c0 = dot(center+c,normalize(c-center));\n        \td=min(d, c0);\n    \t}\n\n    return .5*d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    if (keyToggle(64+20)) time=0.;\n    vec2 p = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\n  \n\tvec3 w = scale*worley(scale*p); \n    float dist=w.x, c0,c;\n    if (keyToggle(32)) \n        c0 =  2.*scale*worleyD(scale*p);\n    else if (!keyToggle(64+18))\n \t    c0= w.y-w.x;\t// c0 = 1.-1./(w.y-w.x);\n    else {\n        // c0 = length(vec2(w.y-w.x,w.z-w.x));\n        // c0 = .5*(w.z+w.y)-w.x;\n        c0 = 2./(1./(w.y-w.x)+1./(w.z-w.x));   // formula (c) Fabrice NEYRET - BSD3:mention author.\n        // used for 3D trabeculum here : https://www.shadertoy.com/view/MlB3Wt\n    }\n    \n    if (!keyToggle(64+3))\n      c=sin(c0*5.);\n    else\n      c=.5*c0; // c=1.-.5*c0;\n    \n    vec3 col0= .5+.5*sin(6.28*cell+vec3(0.,2.*PI/3.,-2.*PI/3.));\n    vec3 col = c*col0; \n    float seed = smoothstep(0.3,.0, dist); col = seed+(1.-seed)*col;\n    if ((!keyToggle(64+3))&&(mod(100.*cell,2.)>1.)) col=1.-col;\n\n    //vec3 col = vec3(c);\n\n   fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt2GDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltfSRn", "name": "Stupid plasma effect", "author": "dogeshibu", "description": "Just simple plasma effect", "tags": ["2d", "simple", "plasma"], "likes": 3, "viewed": 278, "date": "1433967870", "time_retrieved": "2024-06-20T18:21:41.811346", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float pi = 3.14;\n    float color = 0.0;\n    color += 0.7*sin(0.5*uv.x + iTime/5.0);\n    color += 3.0*sin(1.6*uv.y + iTime/5.0);\n    color += 1.0*sin(10.0*(uv.y * sin(iTime/2.0) + uv.x * cos(iTime/5.0)) + iTime/2.0);\n    float cx = uv.x + 0.5*sin(iTime/2.0);\n    float cy = uv.y + 0.5*cos(iTime/4.0);\n    color += 0.4*sin(sqrt(100.0*cx*cx + 100.0*cy*cy + 1.0) + iTime);\n    color += 0.9*sin(sqrt(75.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += -1.4*sin(sqrt(256.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += 0.3 * sin(0.5*uv.y + uv.x + sin(iTime));\n    float r = 0.5+0.5*sin(color * pi);\n    float g = 0.5+0.5*sin(color * pi + 2.0 * pi / 3.0);\n    float b = 0.5+0.5*sin(color + 4.0 * pi / 3.0);\n\tfragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltfSRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltfXz7", "name": "gamma test - RGB", "author": "FabriceNeyret2", "description": "in the spirit of https://www.shadertoy.com/view/llfSRM (just for the classical 50%),\nbut testing the 3 channels separately.  Mouse control. for blue, mouse.z = mean(mouse.x. mouse.y).\nNumbers =  100*gammaRGB.", "tags": ["gamma", "gammacorrection"], "likes": 5, "viewed": 1335, "date": "1435262329", "time_retrieved": "2024-06-20T18:21:41.811346", "image_code": "int D(vec2 p, float n) { // display digit  see https://www.shadertoy.com/view/MlXXzH\n    int i=int(p.y), b=int(pow(2.,floor(30.-p.x-n*3.)));\n    i = p.x<0.||p.x>3.? -1:\n    i==5? 972980223: i==4? 690407533: i==3? 704642687: i==2? 696556137:i==1? 972881535: -1;\n \treturn i<0 ? -1 : i/b-2*(i/b/2);\n}\nint F(vec2 p, float n) { // display number \n    float c=1e3;\n    for (int i=0; i<3; i++) { \n        if ((p.x-=4.)<3.) return D(p,mod(floor(n/c),10.));  \n        c*=.1;\n    }\n    return -1;\n}\n\n\n#define S(k) sin(k*iTime+vec2(1.6,0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 pos;   pos.xy   = fragCoord.xy / iResolution.xy; \n    vec4 mouse; mouse.xy = iMouse.xy / iResolution.xy;  \n    if (mouse.x*mouse.y<=0.) mouse.xy = .5+.4*(S(1.)+.5*S(1.78))/1.5;\n    pos.z = (pos.x+pos.y)/2.; mouse.z = (mouse.x+mouse.y)/2.;\n    \n    vec4 gamma = pow (pos.xxxx, 1./(3.*mouse));\n    \n    float c = texture(iChannel0,floor(fragCoord.xy)/iChannelResolution[0].x).x; \n         if (pos.y>8./9.) fragColor.x = pos.x;\n    else if (pos.y>7./9.) fragColor.x = step(c,pos.x);\n    else if (pos.y>6./9.) fragColor.x = gamma.x;\n    else if (pos.y>5./9.) fragColor.y = pos.x;\n    else if (pos.y>4./9.) fragColor.y = step(c,pos.x);\n    else if (pos.y>3./9.) fragColor.y = gamma.y;\n    else if (pos.y>2./9.) fragColor.z = pos.x;\n    else if (pos.y>1./9.) fragColor.z = step(c,pos.x);\n    else if (pos.y>0./9.) fragColor.z = gamma.z;\n    \n    fragColor -= smoothstep(.02, .01,length((pos-mouse).xy*iResolution.xy/iResolution.y));\n        \n#define at(x,y) (fragCoord-iResolution.xy*vec2(x,y))/4.\n    if ( F(at(.4,1./6.), 1e3*(3.*mouse.x)) >0) fragColor=vec4(1);\n    if ( F(at(.4,3./6.), 1e3*(3.*mouse.y)) >0) fragColor=vec4(1);\n    if ( F(at(.4,5./6.), 1e3*(3.*mouse.z)) >0) fragColor=vec4(1);\n        \n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltfXz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltfXzH", "name": "Speed Experiment 1", "author": "aiekick", "description": "Based on shader [url=https://www.shadertoy.com/view/XtXXRH]Metamonolith [/url] from ryk. ", "tags": ["experiment", "1", "speed"], "likes": 18, "viewed": 1230, "date": "1434473795", "time_retrieved": "2024-06-20T18:21:42.195296", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Based on shader https://www.shadertoy.com/view/XtXXRH Named 'Metamonolith' from ryk. \n\nfloat hash(float f){return fract(sin(f*32.34182) * 43758.5453);}\nfloat hash(vec2 p){return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);}\nvoid mainImage( out vec4 f, in vec2 g )\n{\n\tfloat \n        t = iTime,\n        sgn,h,h2,h3,band,ff,df=0.;\n    \n    vec2 \n        s = iResolution.xy,\n        uv= (2.*g-s)/s.y;\n        \n    vec3 \n        dir=-normalize(vec3(-8.,2.*sin(t/10.),-4.*sin(t/4.))),\n        up = vec3(0.,0.,1.),\n        k=vec3(1,2,3)/3.,\n        col=k-k;\n    \n    up=normalize(up-dir*dot(dir,up));\n    \n    dir=normalize(dir+=cross(dir,up)*uv.x+s.y/s.x*up*uv.y);        \n    \n    for (float a =0.;a<3.14159; a += 1.152)\n    {\n        df += 0.05;\n        \n        dir *= mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));\n\t\t\n        vec2 p = dir.zx / max(.001, abs(dir.y))*vec2(3., 0.18);\n        \n        p.y += t * 12. + a ;\n        \n        sgn = sign(dir.y);\n        h = hash(floor((p+=.5+a)*sgn));\n        h2 = hash(floor(p.y/6.));\n        h3 = hash(floor(p.y/20.*a)+sgn);\n        band = abs(p.x) < 2. + floor(30.*h3*h3) ? 1. : 0.;\n        ff = h2 < .5 ? smoothstep(.6, 0.,length( mod(p, vec2(1.)) - .5))*6. : 2.;\n\n        h = h < h2/1.2 + .1 ? 1. : 0.;\n\n        col += .9 * mix(k, clamp(abs(fract(h2/5.+t/30.+k)*6. - 3.) - k, 0., 1.), .9) * h * band * 3. * ff * pow(abs(dir.y),0.5);  \n    }\n    f.rgb = clamp(col*.25, 0., 1.)+df;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltfXzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltj3D3", "name": "multicolored 2D metaballs", "author": "the23", "description": "further modification of https://www.shadertoy.com/view/4lSGDc . Used iq's excellent cosine color gradient article (www.iquilezles.org/www/articles/palettes/palettes.htm).", "tags": ["2d", "metaballs", "glow", "zen"], "likes": 38, "viewed": 1037, "date": "1433258283", "time_retrieved": "2024-06-20T18:21:42.563071", "image_code": "const float speed = 3.3;\n\nconst float radius = 2.7;\nconst float thresholdFactor = 0.008;\nconst int ballCount = 23;\n\nconst vec3 backgroundColor = vec3(0.0);\nconst vec3 metaballColor = vec3(1.0, 0.5, 0.0);\n\nconst float zoomFactor = 2.5;\nconst float orbitRadius = 0.3;\n\nfloat dstMetaball(vec2 pos, vec2 center, float radius)\n{\n  vec2 diff = pos - center;\n  return radius / dot(diff, diff);\n}\n\nvec3 colorByDistance(float dst, float falloff, vec3 color, vec3 oldColor)\n{\n  return mix(color, oldColor, smoothstep(0.0, falloff, dst));\n}\n\n// see: www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 colorIQ(float i)\n{\n  vec3 a = vec3(0.5);\n  vec3 b = vec3(0.5);\n  vec3 c = vec3(1.0);\n  vec3 d = vec3(0.0, 0.1, 0.2);\n  return (a + b * cos(((c * i + d) * 6.2831852)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // create centered local positions\n  float aspect = iResolution.x / iResolution.y;\n  vec2 pos = (fragCoord.xy / iResolution.xy) * vec2(aspect, 1.0);\n  pos -= clamp(vec2(aspect, 1.0 / aspect) - 1.0, 0.0, 1.0)  * 0.5;\n  pos = pos * 2.0 - 1.0;\n  pos /= zoomFactor;\n    \n  vec3 color = backgroundColor;\n  float time = float(iTime);\n    \n  float dst = dstMetaball(pos, vec2(0.0), radius);\n  color += colorIQ(time * speed * 0.01) * dst * thresholdFactor * (sin(radians(time * (speed + 5.3))) * 0.5 + 0.5) * 30.0;\n\n  // init the vars for the other balls\n  vec2 ballPos = vec2(orbitRadius, 0.0);\n  float angle = radians(time * speed);\n  mat2 matRotate = mat2(cos(angle), -sin(angle),\n                        sin(angle),  cos(angle));\n\n  // iterate over the balls, sum up the distance, rotate the ball position\n  for (int i=0; i < ballCount; ++i)\n  {\n    ballPos = matRotate * ballPos;\n    dst = dstMetaball(pos, ballPos, radius);\n    color += colorIQ(((float(i) + 1.0) / float(ballCount)) + time * speed * 0.01) * dst * thresholdFactor;\n    //color += getColor(tex.x) * dst * thresholdFactor;\n  }\n  color /= float(ballCount) + 1.0;\n\n  fragColor = vec4(pow(color, vec3(0.5)) - 0.5, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltj3D3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltj3Dc", "name": "hypertexture - trabeculum", "author": "FabriceNeyret2", "description": "Trabeculum pattern. (camera follow mouse).\nYou can play with the defines for other patterns (NOISE) or larger trabelucum (VARIANT=0), and params in tweaknoise (thresh, scale).\nCheaper with SHADED=0 & FOG=1.", "tags": ["procedural", "noise", "perlin", "hypertexture", "trabeculum"], "likes": 33, "viewed": 3035, "date": "1433422918", "time_retrieved": "2024-06-20T18:21:43.484267", "image_code": "#define SHADED 1\n#define FOG 0\n#define NOISE 3 // Perlin, Worley, Trabeculum\n#define VARIANT 1\n\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\nconst vec3 ambient  = vec3(.2,0.,0.), \n           diffuse  = vec3(.8);\n\n#define PI 3.14159\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\n// more 3D noise\nvec3 hash13( float n ) {\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\n}\nfloat hash31( vec3 n ) {\n    return hash(n.x+10.*n.y+100.*n.z);\n}\nvec3 hash33( vec3 n ) {\n    return hash13(n.x+10.*n.y+100.*n.z);\n}\n\nvec4 worley( vec3 p ) {\n    vec4 d = vec4(1e15);\n    vec3 ip = floor(p);\n    for (float i=-1.; i<2.; i++)\n   \t \tfor (float j=-1.; j<2.; j++)\n            for (float k=-1.; k<2.; k++) {\n                vec3 p0 = ip+vec3(i,j,k),\n                      c = hash33(p0)+p0-p;\n                float d0 = dot(c,c);\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\n                else if (d0<d.w) {              d.w=d0; }   \n            }\n    return sqrt(d);\n}\n\n\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\n\n// my noise\nfloat tweaknoise( vec3 p , bool step) {\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\n          d=d1;\n#if NOISE==1 // 3D Perlin noise\n    float v = fbm(scale*p);\n#elif NOISE==2 // Worley noise\n    float v = (.9-scale*worley(scale*p).x);\n#elif NOISE>=3 // trabeculum 3D\n  #if !VARIANT\n    d = (1.-d1)*d2; \n  #endif\n    if (d<0.5) return 0.;\n    grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\n    vec4 w=scale*worley(scale*p); \n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\n#endif\n    \n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\n}\n\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\nfloat shadedNormal( vec3 p, float v ) {\n    float epsL = 0.01;\n#if 1// centered directional derivative\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\n#else // cheap directional derivative\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\n#endif\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \n    // { fragColor = vec4(ambient,1.); return; }\n    \n    vec2 mouse=iMouse.xy/iResolution.xy;\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\n\n    //camera\n    float theta = (mouse.x*2. - 1.)*PI;\n    float phi = (mouse.y - .5)*PI;\n#if 1 // camera shake \n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\n#endif\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \n    vec3 cameraTarget = vec3(0.);\n    vec3 ww = normalize( cameraPos - cameraTarget );\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\n  \n    // ray-trace volume\n    vec3 col=vec3(0.);\n \tfloat transp=1., epsC=.01/2.;\n    float l = .5;\n    vec3 p=cameraPos+l*rayDir, p_=p;\n    \n    for (int i=0; i<200; i++) { \n        float Aloc = tweaknoise(p,true); // density field\n        if (Aloc>0.01) {\n            \n#if FOG \n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\n            col += transp*skyColor*(1.-fog);\n    \t    transp *= fog; \n            if (transp<.001) break;\n#endif            \n\n#if SHADED          \n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\n#else\n            vec3 c = vec3(0.);\n#endif\n \t        col += transp*c*Aloc;\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\n            col = clamp(col,0.,1.); // anomaly :-(\n    \t    transp *= 1.-Aloc;\n\t        if (transp<.001) break;\n        }\n \n        p += epsC*rayDir;\n    }\n    \n   fragColor = vec4(col+ transp*skyColor, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltj3Dc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltj3W3", "name": "Un Poco d'Acqua", "author": "jonobr1", "description": "Move your mouse and see an endless ebb of vector water.", "tags": ["noise", "water", "field", "vector"], "likes": 18, "viewed": 1781, "date": "1433204747", "time_retrieved": "2024-06-20T18:21:44.163087", "image_code": "/**\n * Deconstructed fish.fp from Eddie Lee's\n * Polysonic: http://eddietree.github.io/polysonic\n *\n * @author jonobr1 / http://jonobr1.com/\n */\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n/**\n * Convert rgb 0 - 255 floats to vec3 component.\n */\nvec3 rgb(float r, float g, float b) {\n  return vec3( r / 255.0, g / 255.0, b / 255.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = vec2( fragCoord.x / iResolution.x, fragCoord.y / iResolution.y );\n    float time = iTime + 2048.0;\t// Offset so that iTime is in the same order of magnitude...\n    \n    // Parameters\n    float scale = 512.0;\n    float falloff = 64.0;\n    float speed = 0.85;\n    float spread = 10.0;\n\n   \tvec3 field = time * vec3( uv.x, uv.y, 0.0 ) / scale;\n    vec3 movement = vec3(\n        spread * iMouse.x / iResolution.x, // X Position\n        spread * iMouse.y / iResolution.y, // Y Position\n        speed * time                // Ebb of water\n    );\n    float t = clamp( falloff * snoise( field + movement ), 0.0, 1.0 );\n\n    // Colors\n    vec3 a = rgb( 050.0, 150.0, 255.0 );\n    vec3 b = rgb( 255.0, 255.0, 255.0 );\n    \n    fragColor = vec4( mix( a, b, t ), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltj3W3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltjGDc", "name": "Study iQ's dir deriv ", "author": "tyleeer", "description": "Simple trick save operations.\n\nThere is some visible difference, especially when there is more detailed thing.\n\nMathematically equivalent, but why there is difference?", "tags": ["learning"], "likes": 7, "viewed": 227, "date": "1433300240", "time_retrieved": "2024-06-20T18:21:44.993654", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Usign directional derivatives for lighting is much faster than computing \n// gradients/normals and doing lighting with it (if the number of lights is\n// less than four). Mostly useful for volumetric effects.\n//\n// See \n//\n//  http://iquilezles.org/www/articles/derivative/derivative.htm\n//\n// and also:\n//\n//  https://www.shadertoy.com/view/XslGRr\n//  https://www.shadertoy.com/view/Xd23zh]Xd23zh\n//  https://www.shadertoy.com/view/MsfGzM\n//\n// In the left haf of the screen, directional derivatives. On the right, the\n// traditional gradient-based lighting. Move the mouse to compare.\n\nfloat noise(vec3 p) {\n \n    return 0.3*cos(sin(5.0*p.x)+cos(10.0*p.y+cos(iTime))+0.5*sin(4.0*p.z+sin(iTime)))*sin(0.5*iTime); \n}\n\nfloat map( vec3 p )\n{\n\tfloat d1 = p.y - 0.0 + noise(cos(0.8*p)); // ground plane\n    float d2 = length(p-vec3(0.0,0.0,0.0)) - 1.0 + noise(cos(p)); // ball1\n    float d3 = length(p.xz-vec2(-3.0,0.0)) - 0.5 + noise(sin(2.0*p)); // cylinder\n    float d4 = length(p-vec3(1.0,1.0,1.0)) - 1.0 + noise(p); // ball2\n    return min( min(d1,d2), min(d3,d4) ); // Union all of them\n}\n\n// ray casting\nfloat intersect( in vec3 ro, in vec3 rd, const float maxdist )\n{\n    float res = -1.0;\n    float t = 0.1;\n    for( int i=0; i<128; i++ )\n    {\n\t    float h = map(ro + t*rd);\n        res = t;\n        if( h<(0.0001*t) || t>maxdist ) break;\n        t += h;\n    }\n\treturn res;\n}\n\n// calculate normal\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    // so weird formula.... see the one below for more clear one\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvec3 calcGradient(vec3 pos) {\n    // the distance field F(p) = 0 defines the isosurface\n    // according to the definition of gradient DF_p = normal\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 ); // small perturbation\n\tvec3 grad = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy), // [D(x+dx,y,z)-D(x,y,z)]/dx \n\t    map(pos+eps.yxy) - map(pos-eps.yxy), // [D(x,y+dy,z)-D(x,y,z)]/dy\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) ); //[D(x,y,z+dz)-D(x,y,z)]/dz\n    \n    return grad/(2.0*eps.x);\n}\n\nvec3 calcNormal( in vec3 pos )\n{   \n\treturn normalize(calcGradient(pos));\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float doAB )\n{\n    vec3 col = vec3(0.0);\n    \n    const float maxdist = 32.0;\n    float t = intersect( ro, rd, maxdist );\n    \n    if( t < maxdist )\n    {\n        float eps = 0.001;\n        vec3  pos = ro + t*rd;\n\n        vec3 lig = normalize( vec3(1.0,1.0,1.0) ); // this is a vector point from position to light source\n        float dif = 0.0;\n\n        // directional derivative\n        if( doAB>0.0 )\n        {\n            dif = (map(pos+lig*eps) - map(pos)) / eps;\n            float s = length(calcGradient(pos));\n            dif = dif*(1.0/s);\n        }\n        // gradient based lighting\n\t\telse\n        {\n            vec3 nor = calcNormal( pos);\n            dif = dot(nor,lig);\n        }\n        \n        dif = clamp( dif, 0.0, 1.0 ); // ignore negative things which means in shadow\n        \n        col = vec3(1.0,0.8,0.3)*dif + vec3(0.1,0.15,0.3); // diffision light color + ambient, shadow is not completly black but the opposite of light\n        \n        col *= exp( -0.1*t ); // simulate light intensity decay\n    }\n    \n    return pow( col, vec3(0.45) ); // gamma correction, why this formular....\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y; // uv space and preserve aspect ratio\n    \n    // camera configuration\n\tvec3  ro = vec3(0.0,1.0,7.0); // ray origin, camera center\n\tvec3  ta = vec3(0.0,1.0,0.0); // camera direction, camera aim at\n    vec3  ww = normalize( ta - ro); // z direction\n    vec3  uu = normalize( cross( ww,vec3(0.0,1.0,0.0 ) )); // front X up is right \n    vec3  vv = normalize( cross(uu,ww) ); // right x front = UP\n    vec3  rd = normalize( p.x*uu + p.y*vv + 3.0*ww ); // ray direction take focal len into consideration\n\n    float im = iMouse.x; if( iMouse.z<=0.001 ) im = iResolution.x/2.0; // set mouse to center when there is no clicking\n    float dm = im - fragCoord.x; // for each pixel calculate its signed distance to mouse position\n\n    vec3 col = render( ro, rd, dm ); // render scene\n    \n\tcol = mix( vec3(0.0), col, smoothstep( 1.0, 2.0, abs(dm) ) ); // draw splitting line\n    \n\tfragColor = vec4( col, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-2.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltjGDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltS3Dt", "name": "shadeaday 6 / 6 / 15", "author": "cabbibo", "description": "trying to get a basic understanding of repetition", "tags": ["raytrace"], "likes": 7, "viewed": 153, "date": "1433522674", "time_retrieved": "2024-06-20T18:21:46.296533", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\t\n\t\nvec4 spherePos[100];\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat repBox( vec3 p, vec3 c , vec3 b , float r)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return  udRoundBox( q , b,  r);\n}\n\n\nfloat sdPlane( vec3 p )\n{\n    \n    float f = sin( p.z * 5. ) * sin( p.x * 5. );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y - (abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\n\nfloat sdSphere( vec3 p, float s , float offset)\n{\n\n\n    float d1 = length(p) - .1*smoothstep(0.0,1.0,iTime);;\n    d1 *= .8;\t\n    \n   // vec3 nP = vec3( x , y , z );\n    return d1 -s;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \tvec2 res = vec2( 10000. , 0.);// vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    for( int i = 0; i < 5; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , spherePos[i].w  , float( i )) , float(i) + 1.);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n  \tvec2 res2 = vec2( repBox( pos , vec3( .4 , .4 , .4 ) , vec3( .01 , .01 , .01 ) , .01 ) , 10. );\n    \n    res.x = opBlend( res,res2 );\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n   for( int i =0; i < 20; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n    \tspherePos[i] = vec4( x ,  y ,  z , r  );\n        \n        \n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n    vec3 col = vec3( 0. );//vec3( .8 , .8 , .8 ); \n   \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 nor = calcNormal( pos );\n        \n        float AO = calcAO( pos , nor );\n        \n        float match = -dot( nor , rd );\n        \n\n       // float c = pow(( 1.-AO) , 5.)*  10.;\n        float c = 0.;\n        c += pow((1.- match),4.) * 1.;\n        c += pow(( 1.-AO) , 5.)*  2.;\n        col = vec3( c );// * .4 * ( nor * .5 + .5 );\n        \n       /* if( res.y < .5 ){\n            \n            float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n            col *= abs( f );\n            col /= pow( length( pos ), 4.);\n        }*/\n    }\n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltS3Dt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltsSzn", "name": "Ellipsoid - shadow", "author": "iq", "description": "Ellipsoid - ray intersection, shadow and normal. ", "tags": ["3d", "shadow", "ellipsoide"], "likes": 4, "viewed": 1395, "date": "1434492756", "time_retrieved": "2024-06-20T18:21:46.939108", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\n// https://creativecommons.org/licenses/by-sa/3.0/\n\n\n// Compute fake soft shadows for sphere objects. Can see this in action here: \n// https://www.shadertoy.com/view/XdjXWK\n\n\n\n//-------------------------------------------------------------------------------------------\n// ellipsoid related functions\n//-------------------------------------------------------------------------------------------\n\nstruct Ellipsoid\n{\n    vec3 cen;\n    vec3 rad;\n};\n\nfloat eliShadow( in vec3 ro, in vec3 rd, in Ellipsoid sph, in float k )\n{\n    vec3 oc = ro - sph.cen;\n    \n    vec3 ocn = oc / sph.rad;\n    vec3 rdn = rd / sph.rad;\n    \n    float a = dot( rdn, rdn );\n\tfloat b = dot( ocn, rdn );\n\tfloat c = dot( ocn, ocn );\n\n    if( b>0.0 || (b*b-a*(c-1.0))<0.0 ) return 1.0;\n    \n    return 0.0;\n}    \n            \nvec3 eliNormal( in vec3 pos, in Ellipsoid sph )\n{\n    return normalize( (pos-sph.cen)/sph.rad );\n}\n\nfloat eliIntersect( in vec3 ro, in vec3 rd, in Ellipsoid sph )\n{\n    vec3 oc = ro - sph.cen;\n    \n    vec3 ocn = oc / sph.rad;\n    vec3 rdn = rd / sph.rad;\n    \n    float a = dot( rdn, rdn );\n\tfloat b = dot( ocn, rdn );\n\tfloat c = dot( ocn, ocn );\n\tfloat h = b*b - a*(c-1.0);\n\tif( h<0.0 ) return -1.0;\n\treturn (-b - sqrt( h ))/a;\n}\n\n//=====================================================\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    // sphere animation\n    Ellipsoid sph = Ellipsoid( vec3(0.0,0.25,0.0) + vec3(1.0,0.5,1.0)*cos( iTime*0.1 + vec3(2.0,1.0,1.0) + 0.0 )*vec3(1.5,0.5,1.0), \n                               vec3(1.0,0.6,1.0) + vec3(0.5,0.5,0.5)*cos( iTime*0.31 + vec3(0.0,0.71,2.71) ) );\n\n    vec3 lig = normalize( vec3(0.6,0.3,0.4) );\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    vec3 nor;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + t1*rd;\n        nor = vec3(0.0,1.0,0.0);\n    }\n\n    float t2 = eliIntersect( ro, rd, sph );\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        vec3 pos = ro + t2*rd;\n        nor = eliNormal( pos, sph );\n\t}\n    \n    if( tmin<1000.0 )\n    {\n        vec3 pos = ro + tmin*rd;\n        \n\t\tcol = vec3(1.0);\n        col *= clamp( dot(nor,lig), 0.0, 1.0 );\n        col *= eliShadow( pos + nor*0.001, lig, sph, 8.0 );\n        col += 0.05*(0.5+0.5*nor.y);\n\t    col *= exp( -0.05*tmin );\n    }\n\n    col = sqrt(col);\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltsSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltsXz7", "name": "gyro", "author": "FabriceNeyret2", "description": "Try mouse.x ...\n\nBe sure to wait long enough ;-)", "tags": ["3d", "raymarching", "spheremarching"], "likes": 54, "viewed": 2516, "date": "1435595726", "time_retrieved": "2024-06-20T18:21:47.308806", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define T iTime\n#define r(v,t) { float a = (t)*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n#define SQRT3_2  1.26\n#define SQRT2_3  1.732\n#define smin(a,b) (1./(1./(a)+1./(b)))\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d,c; p.x-=.3; // init ray \n    //    r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);   // camera rotations\n    d = p;                                 // ray dir = ray0-vec3(0)\n    p.z -= 5. ; // *T;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float closest = 999.0;\n    f = vec4(0);\n    \n    for (float i=1.; i>0.; i-=.01)  {\n        \n        //vec4 u = floor(p/8.), t = mod(p, 8.)-4., ta; // objects id + local frame\n        vec4 u=floor(p/18.+3.5), t = p, ta,v;\n        // r(t.xy,u.x); r(t.xz,u.y); r(t.yz,1.);    // objects rotations\n        u = sin(78.*(u+u.yzxw));                    // randomize ids\n        // t -= u;                                  // jitter positions\n        c = p/p*1.2;\n \n        float x1,x2,x=1e9;\n        for (float j=2.5; j>1.; j-= .1) {\n            r(t.xy,u.x); r(t.xz,u.y); r(t.yz,u.z);\n            // t -= 2.*u;   // try ;-)\n            ta = abs(t);\n            x1 = length(t.xyz) -j*SQRT3_2*1.1;       // inside carving sphere\n            x2 = max(ta.x,max(ta.y,ta.z)) -j;        // cube\n            x2 = max(-x1,x2);                        // cube-sphere\n            x1 = length(t.xyz) -j*SQRT3_2*1.1-.03;   // outside carving sphere\n            if (p.z<-5.5+9.*mouse.x) break; // mouse.cut\n            if (p.z>-1. && x1 > .1) break;  // culling. save 50% cost.\n            x2 = max(x1,x2);                         // shape inter sphere\n#define cyl(a,b,c) {v = vec4(a,b,c,0)/SQRT2_3; x1 = length(t.xyz-dot(t,v)*v.xyz)-.2*j; x2 = max(-x1,x2);}            \n            cyl( 1, 1, 1); cyl( 1, 1,-1);  \n            cyl( 1,-1, 1); cyl( 1,-1,-1);\n            x =  min(x,x2);                          // union with the others\n        }\n\n        x1 = length(t.xyz) -.6;                      // central sphere\n        closest = min(closest, x1); \n        x = min(x1,x);\n        if (x==x1) c  = vec4(2.,.3,0,0);\n        if (cos(.25*T)>0.) c += vec4(2.,.3,0,0)*pow(abs((x-x1)),.2)*(.5+.5*cos(.5*T));  // thanks squid !\n        \n        // f = i*i*c;      // color texture + black fog \n\n        if(x<.01) // hit !\n            { f = i*i*c; break;  }  // color texture + black fog \n        \n        p -= d*x;           // march ray\n     }\n     f += vec4(1,0,0,0) * exp(-closest)*(.5+.5*cos(.5*T)); // thanks kuvkar ! \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltsXz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltXSRH", "name": "Reflective spheres", "author": "berber", "description": "Just some flying ballz", "tags": ["raytracing", "spheres"], "likes": 2, "viewed": 162, "date": "1434409311", "time_retrieved": "2024-06-20T18:21:47.805960", "image_code": "struct orb {\n    vec3 pos;\n    float rad;\n    float emit;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ---------------------------------------\n    \n    #define OBJ_COUNT 3\n    \n    orb orbs[OBJ_COUNT];\n    \n    orbs[0].pos = vec3(-20.2 + cos(iTime) * 30.0, -15.7 + sin(iTime) * 11.0, 120.0 + sin(iTime / 3.5) * 60.0);\n    orbs[0].rad = 25.0;\n    orbs[0].emit = 0.0;\n    \n    orbs[1].pos = orbs[0].pos + vec3(cos(iTime) * 45.0, sin(iTime) * 42.0, sin(iTime) * 38.0);\n    orbs[1].rad = 20.0;\n    orbs[1].emit = 0.0;\n    \n    orbs[2].pos = orbs[0].pos + vec3(cos(iTime) * 104.0, sin(iTime / 2.6) * 92.0, sin(iTime) * 104.0);\n    orbs[2].rad = 20.0;\n    orbs[2].emit = 0.0;\n    \n    // ---------------------------------------\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * 2.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.y /= aspectRatio;\n    \n    vec3 rayUnit = normalize(vec3(uv, 1.0));\n    vec3 rayColor = vec3(0.0, 0.0, 0.0);\n    float rayStrength = 1.0;\n    vec3 rayPos = vec3(0.0, 0.0, -1.0);\n    \n    float wallDepth = 50.0;\n    float wallScale = 80.0;\n    float wallLength = 5000.0;\n    \n    float minZ;\n    bool collision;\n    orb minOrb;\n    float underRoot;\n    float notUnder;\n    float currentZ;\n    vec3 surfaceNormal;\n    vec3 oMinusC;\n    float wallY;\n    float wallTileX;\n    float wallTileZ;\n    \n    bool emitterHit = false;\n    \n    for(int b = 0; b < OBJ_COUNT + 2; b++) {\n        \n        collision = false;\n        minZ = 0.0;\n        \n        for(int i = 0; i < OBJ_COUNT; i++) {\n\n            oMinusC = rayPos - orbs[i].pos;\n            underRoot = pow(dot(rayUnit, oMinusC), 2.0) - pow(length(oMinusC), 2.0) + pow(orbs[i].rad, 2.0);\n            notUnder = -1.0 * dot(rayUnit, oMinusC);\n\n            if(underRoot > 0.0) {\n\n                currentZ = min(max(notUnder + sqrt(underRoot), 0.0), max(notUnder - sqrt(underRoot), 0.0));\n\n                if(currentZ > 0.0 && (!collision || currentZ <= minZ)) {\n                    minZ = currentZ;\n                    collision = true;\n                    minOrb = orbs[i];\n                }\n            }\n        }\n        \n        if(collision && !emitterHit) {\n\t\t\t\n            rayPos = minZ * rayUnit + rayPos;\n            surfaceNormal = normalize(rayPos - minOrb.pos);\n            rayStrength *= -dot(rayUnit, surfaceNormal);\n            rayUnit = rayUnit + 2.0 * surfaceNormal * -1.0 * dot(surfaceNormal, rayUnit);\n            \n            if(minOrb.emit > 0.0) {\n                emitterHit = true;\n                rayColor += rayStrength * minOrb.emit;\n            }\n            \n        } else if(!emitterHit) {\n            \n            emitterHit = true;\n            wallY = abs(rayPos.y + wallDepth / rayUnit.y);\n            if(wallY * abs(rayUnit.z) <= wallLength && wallY * abs(rayUnit.x) <= wallLength) {\n                wallTileX = abs(floor(rayUnit.x * wallY / wallScale) - rayUnit.x * wallY / wallScale);\n                wallTileZ = abs(floor(rayUnit.z * wallY / wallScale) - rayUnit.z * wallY / wallScale);\n                if(wallTileX > 0.5 ^^ wallTileZ <= 0.5) {\n                    rayColor += rayStrength * abs(dot(vec3(0.0, 1.0, 0.0), rayUnit));\n                }\n            }\n            \n        }\n    }\n    \n\tfragColor = vec4(rayColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltXSRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltXSz4", "name": "NightRide", "author": "kuvkar", "description": "boat ride at night.", "tags": ["waves", "water"], "likes": 26, "viewed": 1184, "date": "1434815042", "time_retrieved": "2024-06-20T18:21:48.921212", "image_code": "mat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nconst float WLEN = 8.0;\nconst float phase = 2.2;\n\n\nstruct Ray\n{\n    vec3 o;\n    vec3 p;\n    vec3 d;\n};\n\n    \nvoid flter(inout vec4 col, float f)\n{\n    col -= f;\n    col = clamp(col, 0.0, 1.0);\n    col /= 1.0 - f;\n}\n\nfloat flter(float f, float a)\n{\n    f -= a;\n    f = clamp(f, 0.0, 1.0);\n    f /= 1.0 - a;\n    return f;\n}\n    \nfloat wv(in vec2 uv, vec2 d, float t, float A)\n{\n    \n    float h1 = (sin ( dot(d, uv) / WLEN + phase * t)) * 0.5;\n    \n    float h2 = (sin ( dot(d, uv) / WLEN + phase * t));\n    h2 *= h2;\n    h2 *= 0.2;\n    \n    float h3 = (sin ( dot(d, uv) / WLEN + phase * t));\n    h3 *= h3 * h3;\n    h3 *= 0.1;\n        \n    float w = sin(dot(uv.yx * .015, d)) * 0.5 + 0.5; \n    return mix(w, 1.0, 0.9) * (h1 + h2 + h3) * A;\n}\n\nfloat waves(in vec2 uv, float t, float A)\n{\n    float w1 = wv(uv, vec2(1.0, -0.1), t, A) * 0.4;\n    float w2 = wv(uv * 14.0, vec2(0.5, 0.2), t, A) * 0.015;\n    \n    vec2 d2 = vec2(0.4, 0.7);\n    float w3 = wv(uv * 2.0, d2, t * 1.5, A) * 0.25;\n\n    vec2 d3 = (vec2(0.7, 0.5));\n    float w4 = wv(uv * 5.0, d3, t * 1.5, A) * 0.15;\n    float w5 = wv(uv * 14.0, vec2(0.0, 0.5), t, A) * 0.015;\n    \n    return w5 + w4 + w3 + w2 + w1;\n}\n\nfloat map(in vec3 rp)\n{\n    \n    vec2 uv = rp.xz * 0.08;\n    float b = texture(iChannel0, uv, -100.0).r * 0.5;\n    b += texture(iChannel0, uv * 2.0, -100.0).r * 0.25;\n    b += texture(iChannel0, uv * 4.0, -100.0).r * 0.0125;\n    b *= 0.025;\n    // choppy waves by offsetting ray\n    rp.x += pow(max(rp.y, 0.0), 2.3) * 0.45;\n    \n    float A = 4.0;\n    float w = rp.y - waves(rp.xz, 2.0 + iTime * 0.5, A);\n    return w + b;\n}\n\nvec3 grad(vec3 rp)\n{\n    vec2 off = vec2(0.001, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yxy) - map(rp - off.yxy),                  \n\t\t\t\t  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\nvec3 light = normalize(vec3(-0.2, 0.1, -1.0));\n\n\nbool trace(inout Ray r, inout vec4 color)\n{\n    vec3 rd = r.d;\n    float topy = 2.8;\n    r.p += r.d * (r.p.y - topy) / abs(r.d.y);\n    \n    float dist = 0.0;\n    bool hit = false;\n\tfor (int i = 0; i < 85; ++i)\n    {\n        float h = map(r.p);\n        if ( h < 0.7)\n        {\n            hit = true;\n            \n        }\n        float trvl = max(h * (0.25 * exp(max(0.0, dist - 5.0) * .07)), 0.01); \n        r.p += r.d * trvl;\n        dist += trvl;\n        if(dist > 180.0)\n        {\n            return false;\n        }\n    }\n    \n    if (hit)\n    {\n        vec3 rp = r.p;\n        vec3 g = grad(r.p);\n        // diffuse\n        float d = dot(g, light);\n        d = clamp(d, 0.1, 1.0) * 0.4;\n        color = vec4(0.6, 0.85, 0.9, 1.0) * d;\n\n        // rim\n        float r = 1.0 - clamp(dot(-r.d, g), 0.0, 1.0);\n\n        r = pow(r, 4.0);\n        color += vec4(0.6, 0.8, 0.95, 1.0) * r * 0.6;\n\n        // static foam\n        vec4 wcol = texture(iChannel1, rp.xz * 0.003, -100.0);\n        wcol = vec4(wcol.r);\n        flter(wcol, 0.7);\n        color += wcol * 0.6;\n\n        // dynamic foam\n        vec4 topfoam = texture(iChannel1, rp.xz * 0.02, -100.0).rrrr;\n        vec4 topfoam2 = texture(iChannel1, (rp.zy +vec2(0.0, -iTime * 5.0)) * 0.05, -100.0).rrrr;\n\n        topfoam = mix(topfoam, topfoam2, dot(g, normalize(vec3(-1.0, -0.0, 0.5))));\n        topfoam = clamp(topfoam, 0.0, 1.0);\n        float f = smoothstep(2.0, 2.4, rp.y);\n        topfoam = mix(vec4(0.0), topfoam, f) * 0.5;\n        color += topfoam;\n\n        // spec\n        vec3 H = normalize(-rd + normalize(vec3(0.0, 2.0, 9.0)));\n        float spc = dot(H, g);\n        spc = clamp(spc, 0.0, 1.0);\n        spc = pow(spc, 30.0);\n\n        color += vec4(0.7, 0.7, 0.6, 1.0) * spc * 0.6;\n        \n    }\n    \n    return hit;\n}\n\nfloat fbm (vec2 uv)\n{\n    float f = (texture(iChannel0, uv).r - 0.5, -100.0) * 0.5;\n    f += (texture(iChannel0, uv * 2.0).r - 0.5, -100.) * 0.25;\n    f += (texture(iChannel0, uv * 4.0).r - 0.5, -100.) * 0.125;\n    f += (texture(iChannel0, uv *  8.0).r - 0.5, -100.) * 0.125 * 0.5;\n    f += (texture(iChannel0, uv * 16.0).r - 0.5, -100.) * 0.125 * 0.5 * 0.5;\n    f += (texture(iChannel0, uv * 32.0).r - 0.5, -100.) * 0.125 * 0.5 * 0.5 * 0.5;\n    return clamp(f + 0.5, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    fragColor = vec4(1.0);\n    \n    // movement\n    vec3 _uv = vec3(uv, 0.0);\n    _uv.y += sin(iTime * 0.5) * 0.05;\n    _uv *= rotz(sin(iTime * 0.5) * 0.1);\n    \n    uv = vec2(_uv);\n    \n    // tracing\n    Ray r;\n    r.o = vec3(0.0, 10.0, -1.0 + iTime * 5.0);\n    r.p = r.o;\n    r.d = normalize(vec3(uv + vec2(0.0, -0.1), 1.));\n    \n    vec3 ro = r.o;\n    bool hit = trace(r, fragColor);\n    \n    // bg fog\n    float l = length(ro - r.p);\n    float s = smoothstep(70.0, 170.0, l);\n    vec4 fog = vec4(0.3, 0.7, 0.95, 1.0);\n    float fg = smoothstep(-0.3, 0.3, uv.y);\n    fog = mix(fog, vec4(0.2), fg);\n    fragColor = mix(fragColor, fog,  s);\n\n    \n\t// out of gamut correction    \n    float m = max(fragColor.r, fragColor.g);\n    m = max(fragColor.b, m);\n    m /= max(1.0, m);\n    \n    // clouds\n    vec2 skyuv = vec2(r.d.x / r.d.y, r.d.z / r.d.y) * 0.005;\n    float t = iTime * .012;\n    \n    float f = fbm(skyuv + vec2(0.0, t));\n    f = flter(f, 0.5) * 0.5;\n\n    float f2 = fbm(skyuv * 1.5 + vec2(0.0, t * 1.1));\n    f += flter(f2, 0.4) * 0.25;\n\n    float f3 = fbm(skyuv * 2.5 + vec2(0.0, t * 1.4));\n    f += flter(f2, 0.2) * 0.0125;\n    f = clamp(f, 0.0, 1.0) * smoothstep(0.05, 0.5, uv.y);\n    \n    vec4 sky = vec4(1.0) * f;\n    \n    float moon = 1.0 - smoothstep(0.04, 0.05, length(uv - vec2(0.0, 0.2)));\n    float halo = 1.0 - smoothstep(0.04, 0.4, length(uv - vec2(0.0, 0.2)));\n    \n    vec4 mooncol = moon * mix(texture(iChannel1, uv * 2.0, -100.0).rrrr, vec4(1.0), 0.3);\n    mooncol += halo * vec4(1.0) * 0.2;\n    mooncol = clamp(mooncol, 0.0, 1.0);\n    \n    fragColor += mix(mooncol, sky, clamp(f * 15.0, 0.0, 1.0));\n\t\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltXSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltXSzr", "name": "Rotating 4D Cube", "author": "Justaway", "description": "Rotating 4D cube.", "tags": ["raymarching"], "likes": 2, "viewed": 259, "date": "1434047494", "time_retrieved": "2024-06-20T18:21:48.927060", "image_code": "#define MAXITER 50\n#define FOV 0.3\n#define MINDIST 0.001\n#define NORMALSAMPLE 0.1\n\n/* 3d rotations*/\nmat3 rotX(float a);\nmat3 rotY(float a);\nmat3 rotZ(float a);\nmat3 rot(vec3 z,float a);\n\n/* 4d rotations */\nmat4 rotXY(float t);\nmat4 rotYZ(float t);\nmat4 rotZX(float t);\nmat4 rotXW(float t);\nmat4 rotYW(float t);\nmat4 rotZW(float t);\n\n/* raymarch functions*/\nfloat dist(vec4 p);\nvec4 normal(vec4 p, float d);\n\nmat4 rotXY(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,st,0.0,0.0,\n        -st,ct,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n\nmat4 rotYZ(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,ct,st,0.0,\n        0.0,-st,ct,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n        \nmat4 rotZX(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,0.0,-st,0.0,\n        0.0,1.0,0.0,0.0,\n        st,0.0,ct,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n        \nmat4 rotXW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,0.0,0.0,st,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        -st,0.0,0.0,ct\n    );\n}\n\nmat4 rotYW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,ct,0.0,-st,\n        0.0,0.0,1.0,0.0,\n        0.0,st,0.0,ct\n    );\n}\n\nmat4 rotZW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,ct,-st,\n        0.0,0.0,st,ct\n    );\n}\n\nfloat dist(vec4 a)\n{\n    vec4 p = a \n        * rotXW(iTime*0.3)\n        * rotYW(iTime*0.35)\n        * rotZW(iTime*0.4)\n        * rotXY(iTime*0.45)\n        * rotYZ(iTime*0.5)\n        * rotZX(iTime*0.55);\n    return max(abs(p.x),max(abs(p.y),max(abs(p.z),abs(p.w))))-0.8;\n}\n\nvec4 normal(vec4 p)\n{\n    float d = dist(p);\n    vec4 s=vec4(NORMALSAMPLE,0.0,0.0,0.0);    \n    return normalize(vec4(\n        dist(p+s.xyyy-d),\n        dist(p+s.yxyy-d),\n        dist(p+s.yyxy-d),\n        dist(p+s.yyyx-d)\n    ));\n}\n\n\nmat3 rotX(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\n\nmat3 rotY(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\n\nmat3 rotZ(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\n\nmat3 rot(vec3 z,float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat ic=1.0-c;\n\treturn mat3(\n\t\tic*z.x*z.x+c,ic*z.x*z.y-z.z*s,ic*z.z*z.x+z.y*s,\n\t\tic*z.x*z.y+z.z*s,ic*z.y*z.y+c,ic*z.y*z.z-z.x*s,\n\t\tic*z.z*z.x-z.y*s,ic*z.y*z.z+z.x*s,ic*z.z*z.z+c);\n}\n\nvec4 background(vec4 v)\n{\n    return vec4(smoothstep(0.0, 1.0, 1.0-abs(v.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 sc = fragCoord.xy/iResolution.xy;\n    sc = (sc-0.5)*2.0;\n\tsc.x *= float(iResolution.x)/float(iResolution.y);\n    \n    vec4 eye = vec4(0.0,0.0,-5.0,0.0);\n    \n    //eye.xyz *= rotX(0.5*sin(0.33*iTime));\n    //eye.xyz *= rotY(sin(0.66*iTime));\n    \n    vec4 left = vec4(0.0);\n    vec4 camUp = vec4(0.0);\n    \n    vec4 up = vec4(0.0,-1.0,0.0,0.0);\n    vec4 look = vec4(0.0);\n \tvec4 dir = normalize(look - eye);\n    left.xyz = normalize(cross(up.xyz,dir.xyz));\n    camUp.xyz = normalize(cross(dir.xyz,left.xyz));\n    \n    dir.xyz *= rot(camUp.xyz,sc.x*FOV);\n    dir.xyz *= rot(left.xyz,sc.y*FOV);\n    \n    bool hit = false;\n    vec4 p = eye;\n    float d;\n    vec4 color;\n    vec4 n;\n    \n    for(int i = 0; i < MAXITER; i++)\n    {\n        if(!hit)\n        {\n        \td = dist(p);\n            if(d < 0.0)\n            {\n                n = normal(p);\n                hit = true;\n            }\n        \td = max(MINDIST,d);\n            p += dir*d;\n        }\n    }\n    \n    \n    if(hit)\n    {\n        color = vec4(abs(dot(dir,n)));\n    }\n    else\n    {\n        color = background(dir);\n    }\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltXSzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltXXz8", "name": "Synchro_1", "author": "gcorallo", "description": "no se chocan(?)", "tags": ["2d", "circles", "sin"], "likes": 3, "viewed": 160, "date": "1434393934", "time_retrieved": "2024-06-20T18:21:48.927318", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 rgb = vec3(0.,0.,0.);\n\tfloat s= .3;\n\tfloat t=iTime*.12;\n\t\n\tfloat f=iResolution.x/iResolution.y;\n\tvec2 pos  = mod(vec2(uv.x*f,uv.y+s*.25)+ vec2(.0,s*.5)+ vec2(t*1.5,0.), vec2(s)) - vec2(s*.5);\n\tvec2 pos2 = mod(vec2(uv.x*f,uv.y+s*.25)+ vec2(s*.0)  + vec2(0.,t*1.5), vec2(s)) - vec2(s*.5);\n\tfloat d1= dot(pos, pos)*100.;\n\tfloat d2= dot(pos2, pos2)*100.;\n    \n\trgb.r+=(1.-step(sin(uv.x*f*50.)*.15+.25, d1 *1.7))*.8;\n\trgb.b+=.2*rgb.r;\n\n\trgb.b+=(1.-step(sin(uv.y*50.)*.15+.25, d2 *1.7))*.7;\n\trgb.r+=.2*rgb.b;\n\n\trgb.g+=(rgb.r*.3+rgb.b*.7)*.5;\n    \n\trgb+= vec3(.3, (1.-uv.y)*.1, (uv.y)*.3);\n\t\n\tfloat d3= distance(uv, vec2(.5,0.2))*.2;\n\trgb-=vec3(d3);\n\n\tfragColor = vec4(rgb,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltXXz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ml23Dt", "name": "Interpolation: Bezier, Quadratic", "author": "4rknova", "description": "Quadratic Bezier interpolation.\nNote that I use line segments, not the curve distance field.", "tags": ["bezier", "interpolation"], "likes": 15, "viewed": 1154, "date": "1433798298", "time_retrieved": "2024-06-20T18:21:48.927318", "image_code": "// by Nikos Papadopoulos, 4rknova / 2015\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ANIMATED\n#define SHOW_CONTROL_POINTS\n//#define SHOW_SEGMENT_POINTS\n//#define MOUSE_ENABLED \n//#define AA 4.\n\n#define STEPS  20.\n#define STROKE .8\n\n#define EPS    .01\n\n#define BG   vec3(0.0745, 0.0862, 0.1058)\n#define COL0 vec3(.2, .35, .55)\n#define COL1 vec3(.9, .43, .34)\n#define COL3 vec3(1.)\n\n#define T (mod(iTime * 2., 10.) / 10.)\n\nvec2 interpolate(vec2 a, vec2 b, vec2 c, float p)\n{\n    vec2 v0 = mix(a, b, p);\n    vec2 v1 = mix(b, c, p);\n    return mix(v0, v1, p);\n}\n\nfloat df_circ(in vec2 p, in vec2 c, in float r)\n{\n    return abs(r - length(p - c));\n}\n\nfloat df_line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat sharpen(in float d, in float w)\n{\n    float e = 1. / min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n\nfloat ip_control(vec2 uv, vec2 a, vec2 b, vec2 c, float t)\n{    \n    float cp = 0.;\n    \n#ifdef SHOW_CONTROL_POINTS    \n    float c0 = sharpen(df_circ(uv, a, .02), EPS * .75);\n    float c1 = sharpen(df_circ(uv, b, .02), EPS * .75);\n    float c2 = sharpen(df_circ(uv, c, .02), EPS * .75);\n    \n    float l0 = sharpen(df_line(uv, a, b), EPS * .6);\n    float l1 = sharpen(df_line(uv, b, c), EPS * .6);\n    cp = max(max(max(c0, c1), c2),\n\t         max(l0, l1));\n#endif\n\n    return cp;\n}\n\nfloat ip_aux(vec2 uv, vec2 a, vec2 b, vec2 c)\n{\n    return 0.5 * sharpen(df_line(uv, mix(a, b, T), mix(b, c, T)), EPS * .6);\n}\n\nfloat ip_point(vec2 uv, vec2 a, vec2 b, vec2 c)\n{\n    vec2 p = interpolate(a, b, c, mod(iTime * 2., 10.) / 10.);\n    return sharpen(df_circ(uv, p, .025), EPS * 1.);\n}\n\nfloat ip_curve(vec2 uv, vec2 a, vec2 b, vec2 c)\n{ \n    float e = 0.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = interpolate(a, b, c, (i   ) / STEPS);\n        vec2  p1 = interpolate(a, b, c, (i+1.) / STEPS);\n#ifdef SHOW_SEGMENT_POINTS        \n        float m = sharpen(df_circ(uv, p0, .01), EPS * .5);\n        float n = sharpen(df_circ(uv, p1, .01), EPS * .5);\n        e = max(e, max(m, n));\n#endif\n        float l = sharpen(df_line(uv, p0, p1), EPS * STROKE);\n        e = max(e, l);\n    }\n                \n    return e;\n}\n\nvec3 scene(in vec2 uv, in vec2 a, in vec2 b, in vec2 c)\n{\n    float d0 = max(ip_control(uv, a, b, c, T), ip_aux(uv, a, b, c));\n    float point = 0.;\n    \n#ifdef ANIMATED\n    point = ip_point(uv, a, b, c);\n#endif\n    \n    float d1 = ip_curve(uv, a, b, c);\n    float rs = max(d0, d1);\n    \n    return (point < .5)\n        ? rs * (d0 > d1 ? COL0 : COL1)\n        : point * COL3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = BG;\n    \n    vec2 a = vec2(-.75,-.75);\n    vec2 b = vec2( .00, .75);\n    vec2 c = vec2( .75,-.75);\n    \n#ifdef MOUSE_ENABLED        \n    a = (iMouse.xy / iResolution.xy * 2. - 1.)\n           * vec2(iResolution.x / iResolution.y, 1.);\n#endif\n    \n#ifdef AA\n    // Antialiasing via supersampling\n    float e = 1. / min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\tcol += scene(uv + vec2(i, j) * (e/AA), a, b, c) / (4.*AA*AA);\n        }\n    }\n#else\n    col += scene(uv, a, b, c);\n#endif /* AA */\n    \n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml23Dt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ml2GDd", "name": "music visualizer circles", "author": "KitVanDeBunt", "description": "combined two of my previous shaders to make this one", "tags": ["music", "visualizer", "normalmaps"], "likes": 0, "viewed": 187, "date": "1433841696", "time_retrieved": "2024-06-20T18:21:49.933361", "image_code": "// used\n// https://www.shadertoy.com/view/XdX3z2 music visualizer\n// https://www.shadertoy.com/view/Xlj3Dt music map\n// https://www.shadertoy.com/view/Ml2GWd normalmap\n\n// atan2 en lerp:\n// http://http.developer.nvidia.com/Cg/index_stdlib.html\n\n// colors\n// https://color.adobe.com/nl/Mijn-Kuler-thema-color-theme-4149936/?showPublished=true\n\n#define PI 3.14159265359\n\n#define twoThirdPI 3.14159265359/3.0*2.0\n#define twelfthPI 3.14159265359/12.0\nvec3 lightPos = vec3(0.5,0.5,0.2);\n\n#define bars 10.0\t\t\t\t// How many buckets to divide spectrum into\n#define barSize 0.2 / bars\t\t// Constant to avoid division in main loop\n#define barGap 0.1 * barSize\t// 0.1 represents gap on both sides, so a bar is\n#define sampleSize 0.1\t\t\t// How accurately to sample spectrum, must be a factor of 1.0\n\n#define circleRadius 0.1;\n\n#define c1 vec4(0.24)\t\t\t\t// grey\n#define c2 vec4(.71,.32,.36,1.0)\t// red\n#define c3 vec4(.91,.64, .0,1.0)\t// yello\n#define c4 vec4(.27,.48,.44,1.0)\t// green\n#define c5 vec4(.21,.40,.51,1.0)\t// blue\n\n\n#define colorOnCenter c1*1.5\n#define colorOff (c5*4.0)\n#define colorOn (c1*10.0)\n\n\nfloat lerp(float a, float b, float t)\n{\n  return a + t*(b-a);\n}\n\nvec4 lerp(vec4 a, vec4 b, float t)\n{\n  return a + t*(b-a);\n}\n\nfloat atan2(float y, float x)\n{\n  float t0, t1, t2, t3, t4;\n\n  t3 = abs(x);\n  t1 = abs(y);\n  t0 = max(t3, t1);\n  t1 = min(t3, t1);\n  t3 = float(1) / t0;\n  t3 = t1 * t3;\n\n  t4 = t3 * t3;\n  t0 =         - float(0.013480470);\n  t0 = t0 * t4 + float(0.057477314);\n  t0 = t0 * t4 - float(0.121239071);\n  t0 = t0 * t4 + float(0.195635925);\n  t0 = t0 * t4 - float(0.332994597);\n  t0 = t0 * t4 + float(0.999995630);\n  t3 = t0 * t3;\n\n  t3 = (abs(y) > abs(x)) ? float(1.570796327) - t3 : t3;\n  t3 = (x < 0.0) ?  float(3.141592654) - t3 : t3;\n  t3 = (y < 0.0) ? -t3 : t3;\n\n  return t3;\n}\n\nbool drawCircle(vec2 circlePos, vec2 pixelPos, float radius)\n{\n    float deltaX = circlePos.x-pixelPos.x;\n    float deltaY = circlePos.y-pixelPos.y;\n    return(sqrt((deltaX*deltaX)+(deltaY*deltaY))<radius);\n}\n\nvec3 circleNormal(vec2 circlePos, vec2 pixelPos, float radius)\n{\n    float deltaX = circlePos.x-pixelPos.x;\n    float deltaY = circlePos.y-pixelPos.y;\n    float dist = sqrt((deltaX*deltaX)+(deltaY*deltaY));\n    float dist2 = (((1.0*(radius*2.0))-dist)*(1.0/(radius*2.0)));\n    vec2 dir = vec2(deltaX,deltaY);\n    \n    float normalY = (-deltaY*4.0);\n    float normalX = (-deltaX*4.0);\n    return vec3(normalX,normalY,dist2); \n}\n\nvec2 circleMusicMap(vec2 circlePos, vec2 pixelPos, float radius){\n\tvec2 musicMap;\n    // create music map red (angle center)\n    float deltaX = pixelPos.x-circlePos.x;\n    float deltaY = pixelPos.y-circlePos.y;\n    float angleFromCenter = atan2(deltaX,deltaY);  \n    musicMap.r = 1.0-(angleFromCenter+PI)/(PI*2.0);\n    \n    // create music map blue (dist center)\n    float distFromCenter = sqrt((deltaY*deltaY)+(deltaX*deltaX));\n    float circleFromCenter = (distFromCenter*3.0);\n    circleFromCenter = circleFromCenter-radius;\n    musicMap.g = circleFromCenter;   \n    return musicMap;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 aspactRatio = vec2((iResolution.x/iResolution.y),1.0);\n\tvec2 uv = fragCoord.xy / (iResolution.xy/aspactRatio);\n    vec2 center = aspactRatio*0.5;\n\tvec4 color = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    // light position\n    lightPos.xy = (vec2(sin(iTime*2.0),-cos(iTime*2.0))/1.5)+center;\n\tif( iMouse.z > 0.0 )\n\t{\n\t\tlightPos = vec3((iMouse.xy / (iResolution.xy/aspactRatio)), lightPos.z);\n\t}\n    \n    bool filled = false;\n    \n    vec3 musicMap;\n    for (float i = 0.0;i < 2.6;i+=0.5){\n        for (float j = 1.0;j < 5.0;j+=1.0){\n            float size = (0.01+(j*0.04));\n            float fromCenter = 0.05+(0.01*j)+(size*j);\n            vec2 circlePos = vec2(sin((-iTime/3.0)+(i*twoThirdPI)+(j*twelfthPI)),cos((-iTime/3.0)+(i*twoThirdPI)+(j*twelfthPI)));\n            circlePos = (circlePos*fromCenter)+center;\n            if(drawCircle(circlePos,uv,size)){\n\n                // normal\n                vec3 circelNormal = circleNormal(circlePos,uv,size);\n\n                vec3 lightDir = normalize(lightPos-vec3(uv.x,uv.y,0.0));\n                float lightDot = dot(lightDir,circelNormal);\n                float lightPower = clamp( lightDot,0.0,1.0);\n                // draw circle\n                vec4 diffuse = vec4(lightPower);\n                \n                \n\t\t\t\tfloat fViewHeight = 2.0;\n\t\t\t\tvec3 vSurfacePos = vec3(uv, 0.0);\n\t\n\t\t\t\tvec3 vViewPos = vec3(0.5, 0.5, fViewHeight);\n\t\t\t\tvec3 vDirToView = normalize( vViewPos - vSurfacePos );\n                vec3 vHalf = normalize( vDirToView + lightDir );\n                float fNDotH = clamp( dot(circelNormal, vHalf), 0.0, 1.0);\n                float specular = pow(fNDotH, 10.0) * lightDot * 0.5;\n\t\t\t\t\n                // draw normalmaps\n                //fragColor = vec4(circelNormal.xyz,0) * 0.5 + 0.5; \n                // draw music maps\n                musicMap.xz = circleMusicMap(circlePos,uv,size);\n                //fragColor = vec4(musicMap.x,0.0,musicMap.z,1.0);\n                filled = true;\n                \n                // music visualizer\n    \t\t\t\n                ////old\n                if(musicMap.b < 0.0){\n                    fragColor = colorOnCenter*diffuse+specular;\n                }else{\n\n                    // use music map red\n                    float musicChannelnput = texture( iChannel0, vec2( musicMap.r,0.0)).r;\n\n                    // Get the starting x for this bar by rounding down\n                    float barStart = floor(musicMap.r * bars) / bars;\n\n                    // Sample spectrum in bar area, keep cumulative total\n                    float intensity = 0.0;\n                    for(float s = 0.0; s < barSize; s += barSize * sampleSize) {\n                        intensity += texture(iChannel0, vec2(barStart + s, 0.0)).r;\n                    }\n                    fragColor = vec4(intensity/10.0);\n                    intensity *= sampleSize*size;\n                    //if(musicMap.r - barStart < barGap || musicMap.r > barStart + barSize - barGap) {\n                        //intensity = 0.0;\n                    //}\n                    //fragColor = vec4(intensity);\n                    // use music map blue\n                    float onOff = musicMap.b-(intensity*3.0);\n                    onOff = clamp(onOff,-0.5,0.5); \n                    onOff = floor(onOff+1.0);\n                    fragColor = lerp(colorOn, (colorOff*color),onOff)*diffuse+(specular*50.0);\n                    //fragColor = vec4(musicChannelnput/1.0);\n                }\n            }\n        }\n    }\n    \n    \n    \n    \n    if(!filled){\n       fragColor = vec4(0.20);  \n    }else{\n        //fragColor = vec4(musicMap.xyz,0.0);\n    }\n    //fragColor = vec4(musicMap.xyz,0.0);\n}\n\n\n\n", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2GDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlfSRN", "name": "1D Quadratic Uniform B-Spline II", "author": "demofox", "description": "1D Quadratic B-Spline.  Mouse controls the yellow control point.\nThere are 8 control points P0-P7 and implicitly 11 knots: [0-10]. Only time 2.0 through 8.0 are valid due to how bsplines work.\nSigned distance used for rendering curve.", "tags": ["2d", "bspline"], "likes": 19, "viewed": 5751, "date": "1434820962", "time_retrieved": "2024-06-20T18:21:50.739583", "image_code": "/*\n\nMore info on b-splines and other curves here:\nhttp://www.ibiblio.org/e-notes/Splines/Intro.htm\n\n*/\n\n#define P0  0.25\n#define P1  (sin(iTime*1.5) * 0.5)\n#define P2  0.21\n#define P3  -0.1\n#define P4  0.2\n#define P5  (iMouse.z <= 0.0 ? 0.25 : iMouse.y / iResolution.y - 0.5)\n#define P6  -0.25\n#define P7  0.0\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.0) * (i + 2.0 - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i + 1.0) * (i + 3.0 - t) / 2.0;\n}\n\nfloat SplineValue(in float t)\n{\n    return\n        P0 * N_i_3(t, 0.0) +\n        P1 * N_i_3(t, 1.0) +\n        P2 * N_i_3(t, 2.0) +\n        P3 * N_i_3(t, 3.0) +\n        P4 * N_i_3(t, 4.0) +\n        P5 * N_i_3(t, 5.0) +\n        P6 * N_i_3(t, 6.0) +\n        P7 * N_i_3(t, 7.0);      \n}\n\n// F(x,y) = F(x) - y\nfloat F ( in vec2 coords )\n{\n    // time in this curve goes from 0.0 to 10.0 but values\n    // are only valid between 2.0 and 8.0\n    float T = coords.x*6.0 + 2.0;\n    return SplineValue(T) - coords.y;\n}\n\n// signed distance function for F(x,y)\nfloat SDF( in vec2 coords )\n{\n    float v = F(coords);\n    float slope = dFdx(v) / dFdx(coords.x);\n    return abs(v)/length(vec2(slope, -1.0));\n}\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, vec2(0.0 / 7.0,P0));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, vec2(1.0 / 7.0,P1));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(2.0 / 7.0,P2));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(3.0 / 7.0,P3));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }     \n    \n    dist = SDFCircle(percent, vec2(4.0 / 7.0,P4));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }   \n    \n    dist = SDFCircle(percent, vec2(5.0 / 7.0,P5));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }      \n    \n    dist = SDFCircle(percent, vec2(6.0 / 7.0,P6));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }        \n    \n    dist = SDFCircle(percent, vec2(7.0 / 7.0,P7));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }           \n    \n    if (percent.x >= 0.0 && percent.x <= 1.0)\n    {\n    \tdist = SDF(percent);\n    \tif (dist < EDGE + SMOOTH)\n    \t{\n        \tdist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        \tcolor *= vec3(dist);\n    \t}\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlfXzN", "name": "Matrix", "author": "patriciogv", "description": "Shader used on http://www.thebookofshaders.com/08 and in http://patriciogonzalezvivo.github.io/tangram-sandbox/tangram.html?styles/matrix", "tags": ["random", "matrix"], "likes": 36, "viewed": 4118, "date": "1434888465", "time_retrieved": "2024-06-20T18:21:51.072923", "image_code": "// Copyright Patricio Gonzalez Vivo, 2015 - http://patriciogonzalezvivo.com/\n// I am the sole copyright owner of this Work.\n//\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n\nfloat random(in float x){\n    return fract(sin(x)*43758.5453);\n}\n\nfloat random(in vec2 st){\n    return fract(sin(dot(st.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat randomChar(in vec2 outer,in vec2 inner){\n    float grid = 5.;\n    vec2 margin = vec2(.2,.05);\n    float seed = 23.;\n    vec2 borders = step(margin,inner)*step(margin,1.-inner);\n    return step(.5,random(outer*seed+floor(inner*grid))) * borders.x * borders.y;\n}\n\nvec3 matrix(in vec2 st){\n    float rows = 50.0;\n    vec2 ipos = floor(st*rows)+vec2(1.,0.);\n\n    ipos += vec2(.0,floor(iTime*20.*random(ipos.x)));\n\n    vec2 fpos = fract(st*rows);\n    vec2 center = (.5-fpos);\n\n    float pct = random(ipos);\n    float glow = (1.-dot(center,center)*3.)*2.0;\n\n    return vec3(randomChar(ipos,fpos) * pct * glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    st.y *= iResolution.y/iResolution.x;\n\n\tfragColor = vec4(matrix(st),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MljGWd", "name": "Interpolation: Linear", "author": "4rknova", "description": "Linear interpolation.", "tags": ["linear", "interpolation"], "likes": 3, "viewed": 866, "date": "1433801390", "time_retrieved": "2024-06-20T18:21:51.072923", "image_code": "// by Nikos Papadopoulos, 4rknova / 2015\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ANIMATED\n#define SHOW_CONTROL_POINTS\n//#define SHOW_SEGMENT_POINTS\n//#define MOUSE_ENABLED \n//#define AA 4.\n\n#define STEPS  10.\n#define STROKE .8\n\n#define EPS    .01\n\n#define BG   vec3(0.0745, 0.0862, 0.1058)\n#define COL0 vec3(.2, .35, .55)\n#define COL1 vec3(.9, .43, .34)\n#define COL3 vec3(1.)\n\nvec2 interpolate(vec2 a, vec2 b, float p)\n{\n    return mix(a, b, p);    \n}\n\nfloat df_circ(in vec2 p, in vec2 c, in float r)\n{\n    return abs(r - length(p - c));\n}\n\nfloat df_line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat sharpen(in float d, in float w)\n{\n    float e = 1. / min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n\nfloat ip_control(vec2 uv, vec2 a, vec2 b)\n{    \n    float cp = 0.;\n    \n#ifdef SHOW_CONTROL_POINTS    \n    float c0 = sharpen(df_circ(uv, a, .02), EPS * .75);\n    float c1 = sharpen(df_circ(uv, b, .02), EPS * .75);\n    \n    float l0 = sharpen(df_line(uv, a, b), EPS * .6);\n     \n    cp = max(max(c0, c1), l0);\n#endif\n\n    return cp;\n}\n\nfloat ip_point(vec2 uv, vec2 a, vec2 b)\n{\n    vec2 p = interpolate(a, b, mod(iTime * 2., 10.) / 10.);\n    return sharpen(df_circ(uv, p, .025), EPS * 1.);\n}\n\nfloat ip_curve(vec2 uv, vec2 a, vec2 b)\n{ \n    float e = 0.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = interpolate(a, b, (i   ) / STEPS);\n        vec2  p1 = interpolate(a, b, (i+1.) / STEPS);\n#ifdef SHOW_SEGMENT_POINTS        \n        float m = sharpen(df_circ(uv, p0, .02), EPS * .5);\n        float n = sharpen(df_circ(uv, p1, .02), EPS * .5);\n        e = max(e, max(m, n));\n#endif\n        float l = sharpen(df_line(uv, p0, p1), EPS * STROKE);\n        e = max(e, l);\n    }\n                \n    return e;\n}\n\nvec3 scene(in vec2 uv, in vec2 a, in vec2 b)\n{\n    float d0 = ip_control(uv, a, b);\n    float point = 0.;\n    \n#ifdef ANIMATED\n    point = ip_point(uv, a, b);\n#endif\n    \n    float d1 = ip_curve(uv, a, b);\n    float rs = max(d0, d1);\n    \n    return (point < .5)\n        ? rs * (d0 > d1 ? COL0 : COL1)\n        : point * COL3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = BG;\n    \n    vec2 a = vec2(-.95, .0);\n    vec2 b = vec2( .95, .0);\n    \n#ifdef MOUSE_ENABLED        \n    a = (iMouse.xy / iResolution.xy * 2. - 1.)\n           * vec2(iResolution.x / iResolution.y, 1.);\n#endif\n    \n#ifdef AA\n    // Antialiasing via supersampling\n    float e = 1. / min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\tcol += scene(uv + vec2(i, j) * (e/AA), a, b) / (4.*AA*AA);\n        }\n    }\n#else\n    col += scene(uv, a, b);\n#endif /* AA */\n    \n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MljGWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MllSzM", "name": "Particle Experiment 5", "author": "aiekick", "description": "Mouse.x => Zoom\nMouse.y => Particle Duration\ni would be great to use this with sound but i dont know how :)", "tags": ["experiment", "4", "particle"], "likes": 4, "viewed": 1244, "date": "1435497214", "time_retrieved": "2024-06-20T18:21:51.078786", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        float t = iTime+5.;\n    \n        // vars\n        float z = 1.;\n    \n        const int n = 200; // particle count\n    \n        vec3 startColor = normalize(vec3(1,.1,0));\n        vec3 endColor = normalize(vec3(1,sin(7.)*.5+.5,cos(7.)*.5+.5));\n    \n        float startRadius = .38;\n        float endRadius = .42;\n    \n        float power = 1.;\n        float duration = 0.8;\n    \n        vec2 \n        \ts = iResolution.xy,\n        \tv = z*(2.*gl_FragCoord.xy-s)/s.y;\n    \n        // Mouse axis y => zoom\n        if(iMouse.z>0.) v *= iMouse.y/s.y * 20.;\n    \n        // Mouse axis x => duration\n        if(iMouse.z>0.) duration = iMouse.x/s.x * 10.;\n    \n        vec3 col = vec3(0.);\n    \n        vec2 pm = v.yx*2.8;\n    \n        float dMax = duration;\n    \n        float mb = 0.;\n        float mbRadius = 0.;\n        float sum = 0.;\n        for(int i=0;i<n;i++)\n        {\n                float d = fract(t*power+48934.4238*sin(float(i)*692.7398))*duration;\n                float a = 6.28*float(i)/float(n);\n                 \n                float x = d*cos(a);\n                float y = d*sin(a);\n                \n                float distRatio = d/dMax;\n                \n                mbRadius = mix(startRadius, endRadius, distRatio); \n                \n                vec2 p = v - vec2(x,y);\n                    \n                //p = mod(p,pm) - 0.5*pm;\n                \n                mb = mbRadius/dot(p,p);\n                    \n                sum += mb;\n                \n                col = mix(col, mix(startColor, endColor, distRatio), mb/sum);\n        }\n    \n        sum /= float(n);\n    \n        sum = clamp(sum, 7.6, 1000.);\n    \n        col = normalize(col) * sum;\n    \n        col = smoothstep(vec3(2.7), vec3(2.85), col);\n        \n        fragColor.rgb = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MllSzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MllXRN", "name": "Raymarching Worley", "author": "Lallis", "description": "I started playing around with raymarching some Worley noise and this is where I ended up. :)", "tags": ["3d", "raymarching", "worley"], "likes": 18, "viewed": 378, "date": "1435060659", "time_retrieved": "2024-06-20T18:21:51.078786", "image_code": "#define time iTime*0.25\n#define PI 3.14159265359\n\nmat3 rot(vec3 ang)\n{\n    vec3 s = sin(ang);\n    vec3 c = cos(ang);\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,c.x,-s.x,0.0,s.x,c.x);\n\tmat3 y = mat3(c.y,0.0,s.y,0.0,1.0,0.0,-s.y,0.0,c.y);\n\tmat3 z = mat3(c.z,-s.z,0.0,s.z,c.z,0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,126.7235))) * 43758.5453);\n}\n\nfloat worley3D(vec3 p)\n{\t\t\t\t\t \t\t\t\t\t \n\tfloat r = 3.0;\n    vec3 f = floor(p);\n    vec3 x = fract(p);\n\tfor(int i = -1; i<=1; i++)\n\t{\n\t\tfor(int j = -1; j<=1; j++)\n\t\t{\n\t\t\tfor(int k = -1; k<=1; k++)\n\t\t\t{\n                vec3 q = vec3(float(i),float(j),float(k));\n    \t\t\tvec3 v = q + vec3(noise3D((q+f)*1.11), noise3D((q+f)*1.14), noise3D((q+f)*1.17)) - x;\n    \t\t\tfloat d = dot(v, v);\n\t\t\t\tr = min(r, d);\n\t\t\t}\n\t\t}\n\t}\n    return sqrt(r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 p = uv*2.0-1.0;\n\tp.x*=(iResolution.x/iResolution.y);\n\tvec3 col = vec3(0.1,0.2,0.3);\n    vec3 ro = vec3(0.0,0.0,-2.0);\n    vec3 rd = normalize(vec3(p,0.0)-ro);\n    float mx = iMouse.x > 0.0 ? iMouse.x/iResolution.x : 0.5;\n    float my = iMouse.y > 0.0 ? iMouse.y/iResolution.y : 0.5;\n    vec3 ang = vec3((my-0.5)*PI, (mx-0.5)*PI, 0.0);\n    ro*=rot(ang);\n    rd*=rot(ang);\n    vec3 rp = ro;\n    float t = 1.0;\n    float w;\n    float ww;\n    vec3 add;\n    for(int i = 0; i<12; i++)\n   \t{       \n        rp+= rd*t;\n        w = worley3D(rp+vec3(0.0,0.0,time));\n        ww = w*w*w*w*w*(2.0/distance(rp,ro));\n        add = vec3(0.85,0.95,1.0);\n        col = mix(col, add, ww);\n    }\n    \n    rp = ro + rd*(12.0*(time-floor(time))+0.5);\n    w = worley3D(rp+vec3(0.0,0.0,time));\n    ww = w*w*w*w*w*w*(4.0/distance(rp,ro));\n    add = vec3(0.12,0.35,0.5);\n    col = mix(col, add , ww);\n    \n    rp = ro + rd*(8.0);\n    w = worley3D(rp+vec3(0.0,0.0,time));\n    ww = w*w*w*w*w*w*(2.0/distance(rp,ro));\n    add = vec3(1.0,0.65,0.0);\n    col = mix(col, add , ww);\n    \n    rp = ro + rd*(12.0);\n    w = worley3D(rp+vec3(0.0,0.0,time));\n    ww = w*w*w*w*w*w*(2.0/distance(rp,ro));\n    add = vec3(1.0,0.81,0.0);\n    col = mix(col, add , ww);\n\n\tfragColor = vec4(col*rot(ang*.05),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MllXRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MllXz4", "name": "Warmified", "author": "ophilbinbriscoe", "description": "2nd pass", "tags": ["psychedelic"], "likes": 6, "viewed": 198, "date": "1435040035", "time_retrieved": "2024-06-20T18:21:52.194441", "image_code": "//noise function taken from https://www.shadertoy.com/view/XslGRr\n\nfloat hash( float n ){\n\treturn fract(sin(n)*43758.5453);\n}\n\n//this noise function was originally 3D noise, \n//but I am just setting z to 0 for the sake of simplicity here\n//also cause most effects only care about 2D noise\nfloat noise( vec2 uv ){\n\tvec3 x = vec3(uv, 0);\n\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf       = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\t\n\treturn mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n\t\t\t\t   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat ring( float angle, float dist, float ANG, float THICKNESS, float POS, float SIZE ) {\n    //angles between 4 and 15 are good\n    //negative thickness makes it black, values around 0.02 are good\n    \n    float ZIGZAG = abs( mod( angle, ANG ) - ANG * 0.5 ) * SIZE;\n    return ceil( dist - POS + ZIGZAG) - ceil( dist - (POS+THICKNESS) + ZIGZAG);   \n}\nfloat burst( float angle, float dist, float ANG ) {\n    float B = abs( mod( angle, ANG ) - ANG * 0.5 );\n    return B;\n}\nfloat lim( float IN, float amount ) {\n\treturn IN * amount + (1.0 - amount);   \n}\nfloat inv( float IN ) {\n \treturn 1.0 - IN;   \n}\nfloat ppp( float IN ) {\n \treturn IN * IN * IN;   \n}\nfloat dots( float angle, float dist, float ANG, float POS ) {\n    return ppp(7.5*burst( angle, dist, ANG )/ANG) * ppp(inv(ANG*1.5*distance( dist, POS )));\n}\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec4 myoutput( vec2 fragCoord )\n{\n    \n    float shortside = min( iResolution.x, iResolution.y );\n    float longside = max( iResolution.x, iResolution.y );\n    \n\tvec2 uv = fragCoord.xy / vec2( shortside, shortside );\n    \n    uv.x = uv.x - (longside/shortside - 1.0) * 0.5;\n    \n   \tfloat dist = distance( vec2( 0.5, 0.5 ), uv );\n    \n    uv = vec2( uv.x - 0.5, uv.y - 0.5 );\n    \n    float angle = degrees( atan( uv.y / uv.x ) );\n    \n    float TIMESCALE = 0.3;\n    float T = iTime * TIMESCALE * 2.0;\n    \n    \n    float n = noise( vec2( dist, T ) );\n    float slow_n = noise( vec2( dist, T * 0.2) );\n    float fast_n = noise( vec2( dist, T * 2.0) );\n    float vslow_n = noise( vec2( dist, T * 0.01) );\n    float vfast_n = noise( vec2( dist, T * 50.0) );\n    float t = noise( vec2( iTime, T ) );\n    \n    float rand_r = noise( vec2( -T, T ) );\n    float slow_r = noise( vec2( -T * 0.5, 1.0 ) );\n    float vslow_r = noise( vec2( -T * 0.2, 1.0 ) );\n    float vvslow_r = noise( vec2( -T* 0.05, 1.0 ) );\n    \n    float div = 7.0;\n    float m = sin ( mod( angle, div )/(div*0.5) * 3.14 * 0.5 );\n    float a = mod( angle, 10.0 ) * noise( vec2( T, angle ) );\n        \n    float TIME_MOD_SCALE = 1.0;\n    float TIME_MOD = floor(0.5+sin( noise( vec2(-iTime + 1000.0, 1.0 )) ))*0.5*TIMESCALE*TIME_MOD_SCALE;\n\n    TIMESCALE = TIMESCALE * TIME_MOD;\n    \n    float GRANULARITY = 1.75;\n    float GRAN_DIST_FALLOFF = 0.5;\n    float GRAN_DIST_FALLOFF_MOD = tan(noise (vec2( 500.0, -T ) ));\n    GRAN_DIST_FALLOFF = GRAN_DIST_FALLOFF + GRAN_DIST_FALLOFF_MOD * 0.5;\n    \n    float Gr = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 50.0;\n    float Gg = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 80.0;\n    float Gb = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 100.0;\n    \n    float Gsign = clamp( sign( noise (vec2( T * 0.22, -T * 1.5 )) -0.5 ), -1.0, 0.0 );\n    \n    float rn = 360.0 / (ceil( noise(vec2( sin(T*0.1), 0.5 ) ) * 50.0) * 2.0 );\t//randomly some divisor of 360\n    float rd1 = ceil( noise(vec2( tan(T/10.0), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd2 = ceil( noise(vec2( sin(T/10.0), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd3 = ceil( noise(vec2( cos(T/10.0), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd4 = ceil( noise(vec2( tan(T*0.0075+99.0), 1.0 ) ) * 1.2 );\t//randomly either 1 or 2\n    float rd5 = ceil( noise(vec2( tan(T*0.008+124.0), 1.0 ) ) * 1.5 );\t//randomly either 1 or 2\n    float rd6 = ceil( noise(vec2( tan(T*0.007+24.0), 1.0 ) ) * 1.7 );\t//randomly either 1 or 2\n    float rd7 = ceil( noise(vec2( tan(T*0.005), 1.0 ) ) * 1.4 );\t//randomly either 1 or 2\n    float exp4 = ceil( noise(vec2( tan(T*0.5), 1.0 ) ) * 2.0 ) * rd1;\n    float coarse3 = ceil( noise(vec2( cos(T), 1.0 ) ) * 3.0 );\n    float coarse10 = ceil( noise(vec2( cos(T), 1.0 ) ) * 10.0 );\n    \n    vec3 RING1 = rd2 * 0.5 * ring( angle, dist,6.0, 0.02, n, 0.01) * vec3( 1.0, 1.0, 1.0 ) * floor( n + 0.5 );\n    vec3 RING2 = ring( angle, dist,10.0, 0.01, n/2.0, 0.01) * vec3( 1.0, 1.0, 1.0 ) * ceil( n - 0.3 );\n    vec3 RING3 = ring( angle+(vslow_n*200.0*coarse3)*(2.0+n), dist,90.0*rd1/rd4, (0.02 + rand_r*0.01 + ppp(slow_r)*0.011)*ppp(rd4), n, 0.01) * vec3( 1.0, 1.0, 1.0 ) * 0.5;\n    vec3 RING4 = ring( angle-iTime*(5.0*n), dist,10.0, 0.05, n, 0.01) * vec3( sin(T), cos(T), 0.1 ) * 0.5;\n    vec3 RING5 = ring( angle, dist,30.0, n*20.0, n+0.3, 0.01) * vec3( 1.0, 1.0, 1.0 ) * 0.05 + (dist)*0.05;\n    vec3 BURST1 = burst( angle, dist, rn * rd1 ) * vec3( 1.0, 1.0, 1.0 ) * 0.03 * (1.0 - dist);\n    vec3 RING6 = max(ring( angle-(vslow_n*200.0*coarse3)*(2.0+vslow_n), dist,45.0*rd1, 0.3, n, 0.01),0.0) * vec3( sin(T), tan(T) * 0.5, rand_r ) * (rd7 - 1.0) * inv(dist) * 0.5;\n    vec3 DOTS1 = max(ceil(dots( angle + T*30.0, dist, 10.0, 0.25 + rand_r*0.1 )-24.5 * (1.0+rand_r)),0.0) * vec3( rand_r, inv(rand_r), n ) * 0.15;\n    vec3 DOTS2 = max(ceil(dots( angle - T*35.0, dist, 10.0, 0.3 + rand_r*0.2 )-16.4 * (2.0-rand_r)),0.0) * vec3( n, rand_r, inv(rand_r) ) * 0.15;\n    vec3 DOTS3 = clamp( 1.0 * dots( angle + T * 45.0, dist, 15.0, 0.9 ), 0.0, 1.0) * vec3( 1.0, 1.0, 1.0 ) * 0.05;\n    vec3 DOTS4 = clamp( 1.0 * dots( angle - T * 45.0, dist, 15.0, 0.82 ), 0.0, 1.0) * vec3( 1.0, 1.0, 1.0 ) * 0.025;\n    vec3 RING = RING1 + RING2 + RING3 + RING4 + RING5 + BURST1 + DOTS1 + DOTS2 + RING6 + DOTS3 + DOTS4;\n    \n    float r = RING.r + max((1.0 - dist * 2.0),-0.5) + noise( vec2( dist * Gr * sin( noise(vec2( iTime * 8.0 * TIMESCALE, -iTime )) ), dist ) );;//floor(n*2.0) * a;\n    float g = RING.g + max((1.0 - dist * 3.5),-1.5) + noise( vec2( dist * Gg * TIMESCALE * cos( noise(vec2( iTime * 12.0 * TIMESCALE, -iTime )) ), dist ) );;//ceil(n/3.0 - 0.1) - a;\n    float b = RING.b + max((1.0 - dist * 2.5),-1.0) + noise( vec2( dist * Gb * tan( noise(vec2( iTime * 1.0 * TIMESCALE, -iTime )) ), dist ) );;//ceil(n/3.0 - 0.2) - a;\n    \n    vec3 boost = vec3( 1.3, 1.3 - slow_r * 0.3, 0.4 + slow_n * 0.3);    \n       \n\treturn vec4(r*boost.r,g*boost.g,b*boost.b,1.0) * mix(dist,1.0,0.7);\n    \n    float over = DOTS3.x + DOTS4.x;\n    //fragColor = vec4( DOTS3 + DOTS4, 1.0);//vec4(over,over,over,1.0);\n    //fragColor = blur( \n}\nvec4 myoverlay( vec2 fragCoord )\n{ \n\tfloat shortside = min( iResolution.x, iResolution.y );\n    float longside = max( iResolution.x, iResolution.y );\n    \n\tvec2 uv = fragCoord.xy / vec2( shortside, shortside );\n    \n    uv.x = uv.x - (longside/shortside - 1.0) * 0.5;\n    \n   \tfloat dist = distance( vec2( 0.5, 0.5 ), uv );\n    \n    uv = vec2( uv.x - 0.5, uv.y - 0.5 );\n    \n    float angle = degrees( atan( uv.y / uv.x ) );\n    \n    float TIMESCALE = 0.3;\n    float T = iTime * TIMESCALE * 2.0;\n    \n    float ar = noise( vec2( angle / 5.0, 1.0 ) );\n    float ar2 = noise ( vec2( mod ( angle, 30.0 ) / 5.0, 1.0 ) );\n    \n    vec3 DOTS1 = max(ceil(dots( angle, dist + ar * ar2 * sin( T ) * 0.35, 10.0, 0.5) - 40.0 ), 0.0) * vec3(1.0,1.0,1.0);\n    vec3 DOTS2 = max(ceil(dots( angle + 5.0, dist + ar * ar2 * sin( (T+uv.x) * 0.5 ) * 1.5 + 0.2, 10.0, 0.5) - 40.0 ), 0.0) * vec3(1.0,1.0,1.0);\n    vec3 DOTS3 = max(ceil(dots( angle + 5.0, dist + ar * ar2 * cos( (T+uv.y) * 0.5 ) * 1.0 + 0.1, 5.0, 0.5) - 45.0 ), 0.0) * vec3(1.0,1.0,1.0);\n   \n    return vec4( DOTS1 + DOTS2 + DOTS3, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float shortside = min( iResolution.x, iResolution.y );\n    float longside = max( iResolution.x, iResolution.y );\n    \n\tvec2 uv = fragCoord.xy / vec2( shortside, shortside );\n    \n    uv.x = uv.x - (longside/shortside - 1.0) * 0.5;\n    \n   \tfloat dist = distance( vec2( 0.5, 0.5 ), uv );\n\tvec3 c = myoutput(fragCoord.xy).rgb;\n\tif (fragCoord.x < iMouse.x)\n\t{\n\t\tfragColor = vec4(c, 1.0);\t\n\t} else {\n\t\t\n\t\t//declare stuff\n\t\tconst int mSize = 11;\n\t\tconst int kSize = (mSize-1)/2;\n\t\tfloat kernel[mSize];\n\t\tvec3 final_colour = vec3(0.0);\n\t\t\n\t\t//create the 1-D kernel\n\t\tfloat sigma = 0.75 + dist * 5.0;\n\t\tfloat Z = 0.0;\n\t\tfor (int j = 0; j <= kSize; ++j)\n\t\t{\n\t\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t\t}\n\t\t\n\t\t//get the normalization factor (as the gaussian has been clamped)\n\t\tfor (int j = 0; j < mSize; ++j)\n\t\t{\n\t\t\tZ += kernel[j];\n\t\t}\n\t\t\n\t\t//read out the texels\n\t\tfor (int i=-kSize; i <= kSize; ++i)\n\t\t{\n\t\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t\t{\n\t\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*myoutput((fragCoord.xy+vec2(float(i),float(j)))).rgb;\n\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfragColor = vec4(final_colour/(Z*Z), 1.0);\n        fragColor.rgb += myoverlay( fragCoord.xy ).rgb;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MllXz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MllXz7", "name": "crowded gyros", "author": "FabriceNeyret2", "description": "one more variant of https://www.shadertoy.com/view/ltfXRM \nBe sure to wait long enough ;-)", "tags": ["3d", "raymarching", "short", "spheremarching"], "likes": 15, "viewed": 1741, "date": "1435593116", "time_retrieved": "2024-06-20T18:21:52.509170", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define T iTime\n#define r(v,t) { float a = (t)*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n#define SQRT3_2  1.26\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d,c; p.x-=.4; // init ray \n    r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);   // camera rotations\n    d = p;                                 // ray dir = ray0-vec3(0)\n    p.z += 5. *T;\n    f = vec4(0);\n    float closest = 999.0; vec4 u_c=f;\n   \n    for (float i=1.; i>0.; i-=.01)  \n    {\n        vec4 u = floor(p/8.), t = mod(p, 8.)-4., ta; // objects id + local frame\n        // r(t.xy,u.x); r(t.xz,u.y); r(t.yz,1.);     // objects rotations\n        u = sin(78.*(u+u.yzxw));                     // randomize ids\n        // t -= u;                                   // jitter positions\n        c = p/p*1.2;\n        \n    \n \n        float x1,x2,x=1e9;\n        for (float j=2.3; j>1.; j-= .3) {\n            r(t.xy,u.x); r(t.xz,u.y); r(t.yz,u.z);\n            ta = abs(t);\n            x1 = length(t.xyz) -j*SQRT3_2;       // inside carving sphere\n            x2 = max(ta.x,max(ta.y,ta.z)) -j;    // cube\n            x2 = max(-x1,x2);                    // cube-sphere\n            x1 = length(t.xyz) -j*SQRT3_2-.1;    // outside carving sphere\n            x2 = max(x1,x2);                     // shape inter sphere\n            x = min(x,x2);                       // union with the others\n        }\n\n        x1 = length(t.xyz) -.6;                  // central spheres\n        if (x1 < closest) { closest = x1; u_c = u; } \n        x = min(x1,x);\n        if (x==x1)  c  = u*3.; \n        //   else   c += u*3.*pow(abs((x-x1)),.2)*(.5+.5*sin(.5*T));  // thanks squid !\n        \n        // f = i*i*c;      // color texture + black fog \n\n        if(x<.01) // hit !\n            { f = i*i*c; break;  }  // color texture + black fog \n        p -= d*x;           // march ray\n     }\n     if (cos(.25*T)>0.) f += u_c * exp(-closest)*(.5+.5*cos(.5*T)); // thanks kuvkar ! \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MllXz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlS3Dt", "name": "150606NyokiNyoki", "author": "chimanaco", "description": "My first Ray Tracing", "tags": ["raytracing"], "likes": 2, "viewed": 113, "date": "1433527806", "time_retrieved": "2024-06-20T18:21:52.509170", "image_code": "float radius = 100.8;\n\nvec3 trans(vec3 p)\n{\n  return mod(p, 8.0)-4.0;\n}\n\nfloat lengthN(vec3 v, float n)\n{\n  vec3 tmp = pow(abs(v), vec3(n));\n  return pow(tmp.x+tmp.y+tmp.z, 1.0/n);\n}\n \nfloat distanceFunction(vec3 pos)\n{\n  return length(trans(pos)) - 1.0;\n}\n\n\nvec3 getNormal(vec3 p) {\n    const float d = 0.0001;\n    return\n        normalize\n        (\n            vec3\n            (\n                distanceFunction(p + vec3(d, 0., 0.)) - distanceFunction(p + vec3(-d, 0., 0.)),\n                distanceFunction(p + vec3(0., d, 0.)) - distanceFunction(p + vec3(0., -d, 0.)),\n                distanceFunction(p + vec3(0., 0., d)) - distanceFunction(p + vec3(0., 0., -d))\n            )\n         );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;    \n    //vec3 camPos = vec3(cos(iTime * 0.01) * radius, 0.0, sin(iTime * 0.01) * radius);\n    //vec3 camPos = vec3(0., 0., smoothstep(uv.x, uv.y, cos(iTime * 10.1)));\n\tvec3 camPos = vec3(10., 10., smoothstep(0.01, uv.x, sin(iTime * 1.1)));\n\n    //vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 camDir = vec3(cos(iTime * 0.1) * 30., sin(iTime * 0.1) * 10., abs(sin(iTime * 0.1) * 10.));\n    //vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    //vec3 camUp = vec3( pow(cos(iTime * 0.01) , 112.0), cos(iTime) * 10., sin(iTime) * 10.);\n    vec3 camSide = cross(camDir, camUp);\n    float focus = 1.8 + dot(uv.x, uv.y) * dot(uv.x, uv.y);\n    \n    vec3 rayDir = normalize(camSide * uv.x + camUp * uv.y + camDir * focus);\n    \n    float t = 0.0, d;\n    vec3 posOnRay = camPos;\n    \n    for(int i = 0; i < 50; ++i) {\n        d = distanceFunction(posOnRay);\n        t += d;\n        posOnRay = camPos + t * rayDir;\n    }\n    \n    vec3 normal = getNormal(posOnRay);\n    if(abs(d) < 0.01) {\n        fragColor = vec4(normal, 1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlS3Dt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlsXRN", "name": "Collatz Conjecture Plot", "author": "krazykylep", "description": "This is a plot of the Collatz Conjecture. Each \"tower\" of pixels represents the journey that value took to get to 1. (The x pixel value defines the starting number.) The heat of the color (sort of) defines how close the number is to 1.", "tags": ["math", "plot", "collatzconjecture", "collatz", "conjecture"], "likes": 4, "viewed": 1324, "date": "1435053499", "time_retrieved": "2024-06-20T18:21:52.824555", "image_code": "#define LIMIT 800\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat cam(float f) {\n    float tt = mod(f, 25.0) * 4.0;\n\tfloat go = smoothstep(10.0, 45.0, tt) - smoothstep(60.0, 95.0, tt);\n    return go * 100000.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime;\n    float x = floor(fragCoord.x) + floor(cam(t));\n    float y = floor(fragCoord.y);\n    //float wtf = 2.0 * floor(mod(t*10.0, x*tan(t/y))) + 1.0;\n    //float wtf = 2.0 * floor(mod(t*2.0, 10.0)) + 1.0;\n    float wtf = 1.0;\n    float c = 0.0;\n    //float maxx = 0.0;\n    float bgOff = 1.0;\n    //x = x * x;\n    for (int k = 0; k < LIMIT; k++) {\n        c++;\n        if (x <= 1.0) {\n            c = 0.0;\n            //maxx = 0.0;\n            bgOff = 0.0;\n        \tbreak;   \n        }\n        if (c >= y / (0.0025 * iResolution.y)) {\n        \tbreak;   \n        }\n        if (mod(x,  2.0) == 0.0) {\n            x = x / 2.0;\n        } else {\n            x = x * 3.0 + wtf;\n            if (x <= wtf * 4.0) {\n            \tx = 1.0;   \n            }\n        }\n        //maxx = max(maxx, x);\n    }\n    float bgOn = (1.0 - bgOff);\n    float bg1 = sin(t)*bgOn*0.1;\n    float bg2 = sin(t + (3.14159) / 2.0)*bgOn*0.1;\n    fragColor = vec4(hsv2rgb(vec3(mod(x/10.0, 360.0) / 360.0, 1.0, 0.5 * bgOff)), 1.0) + vec4(bg1, bg2, (0.1-bg1-bg2)*bgOn, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlsXRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlXSzM", "name": "very sleepy", "author": "spencersalazar", "description": "You are getting very sleepy", "tags": ["2d"], "likes": 3, "viewed": 107, "date": "1435197244", "time_retrieved": "2024-06-20T18:21:52.824555", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    float width = iResolution.x;\n    float height = iResolution.y;\n    float t = iTime;\n    float x = fragCoord.x-width/2.0;\n    float y = fragCoord.y-height/2.0;\n\t\n    float d = sqrt(x*x+y*y)*0.25+t*4.0;\n    \n    float b = sin(d)*2.0;\n    fragColor = vec4(b, b, b, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlXSzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlXXz8", "name": "Bouncing sphere", "author": "ryanmichael", "description": "An implicit sphere drawn through screen coordinates. Uses the radius+sphere equation to extract the z-axis coordinate. The surface normal is computed from the z-axis coordinate and is used to create diffuse and specular shading effects.", "tags": ["specular", "diffuse"], "likes": 1, "viewed": 163, "date": "1434984052", "time_retrieved": "2024-06-20T18:21:53.412131", "image_code": "float _max( float a, float b )\n{\n\treturn a < b ? b : a;   \n}\nfloat _pow2( float x )\n{\n\treturn x*x;   \n}\n\nfloat _dot( vec3 a, vec3 b )\n{\n \treturn a.x*b.x + a.y*b.y + a.z*b.z;   \n}\n\nvec3 _normalize( vec3 a )\n{\n\treturn a / sqrt( _dot(a,a) ); \n}\n\n\n//Implicit sphere equation for inside/outside test\nbool insideCircle( vec2 coord, vec2 center, float radius )\n{\n    float phi = _pow2(coord.x - center.x) + _pow2(coord.y - center.y) - _pow2(radius);\n    return (phi < 0.0) ? true : false;\n}\n\n//Sphere Z-coord returned by solving sphere equation\nfloat findSphereZ( vec2 coord, vec2 center, float radius ) \n{\n    //Assume sphere center is at z = 0\n\treturn sqrt( _pow2(radius) - _pow2(coord.x - center.x) - _pow2(coord.y - center.y) );   \n}\n\n//Sphere normal finder\nvec3 getSphereNormal( vec3 coord, vec2 center ) \n{\n    //Assume sphere center is at z = 0 - bad practice to do this though\n    vec3 normVec = vec3( coord.x - center.x, coord.y - center.y, coord.z );\n    return _normalize(normVec);\n}\n\nvec2 getCenter( float loopTime, float radius )\n{\n    vec2 p0 = vec2( iResolution.x / 2.0, radius );\n    vec2 p1 = vec2( radius, iResolution.y / 2.0 );\n    vec2 p2 = vec2( iResolution.x / 2.0, iResolution.y - radius );\n    vec2 p3 = vec2( iResolution.x - radius, iResolution.y / 2.0 );\n        \n    float rem = mod(iTime,loopTime);\n    float frac = rem / loopTime;\n\n    //Scripted motion - compiler wouldn't let me embed ternary operators\n    vec2 center = (frac < 0.25 ) ? (p0 + frac*4.0*(p1-p0)) : vec2(0.0);\n    center = (frac > 0.25 && frac < 0.5 ) ? (p1 + (frac-0.25)*4.0*(p2-p1)) : center;\n    center = (frac > 0.5 && frac < 0.75 ) ? (p2 + (frac-0.5)*4.0*(p3-p2)) : center;\n    center = (frac > 0.75 && frac <= 1.0 ) ? (p3 + (frac-0.75)*4.0*(p0-p3)) : center;\n\n \treturn center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat radius = iResolution.x/5.0;\n    vec2 center = getCenter( 10.0, radius);\n    \n    //Camera position\n    vec3 cam = vec3( iResolution.x/2.0,iResolution.y/2.0, -radius*2.0 );\n    \n    //Light source vector\n    vec3 L1Pos = vec3( iResolution.x/2.0,iResolution.y/2.0, -radius*3.0 );\n    vec3 L1Color = vec3(0.5, 0.25, 0.5);\n    \n    vec3 L2Pos = vec3( iResolution.x,iResolution.y, -radius  );\n    vec3 L2Color = vec3(0.0, 0.5, 1.0);\n    \n    //Draw sphere if coord inside 2-D circle projection\n    if( insideCircle( fragCoord, center, radius ) )\n    {        \n        \n        float z = findSphereZ( fragCoord, center, radius );\n    \tvec3 surfaceCoord = vec3( fragCoord.x, fragCoord.y, -z );\n        vec3 N = getSphereNormal( surfaceCoord, center );\n        \n        vec3 L1 = _normalize( L1Pos - surfaceCoord );\n        \n        vec3 diffuseColor = L1Color * _dot( N, L1 );                  \n        \n        vec3 V = _normalize( cam - surfaceCoord );\n        \n        vec3 L2 = _normalize( L2Pos - surfaceCoord );\n               \n        vec3 R2 = 2.0 * _dot( N, L2 ) * N - L2;\n        \n        vec3 specularColor =L2Color * pow(_max(0.0,_dot(R2,V)),8.0);\n        \n        fragColor = vec4( diffuseColor + specularColor, 1.0 );\n    }\n    //Draw background colour otherwise\n    else fragColor = vec4(.45,.65,0.2,1.0);\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlXXz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt23Dt", "name": "Guilin", "author": "dr2", "description": "An idealized version of an amazing landscape.", "tags": ["landscape"], "likes": 2, "viewed": 594, "date": "1433784085", "time_retrieved": "2024-06-20T18:21:53.423037", "image_code": "// \"Guilin\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nmat3 flMat;\nvec3 flPos, qHit, noiseDisp;\nfloat tCur;\nint idObj;\nconst float dstFar = 100.;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (20. * sin (0.2 * t) * sin (0.11 * t) * cos (0.07 * t) +\n     19. * sin (0.02 * t), 1.3, 0.6 * t);\n}\n\nfloat GrndHt (vec2 p)\n{\n  return 0.1 + 0.05 * smoothstep (0.6, 1.3, Fbm2 (2. * p));\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.3, 0.4 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 4; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy), e.x,\n     ht - GrndHt (p.xz + e.yx)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 g, q;\n  float dMin, d, r, ht, rad, a, aa;\n  dMin = dstFar;\n  g.xz = floor ((p.xz + 2.) / 4.);\n  q = p;\n  q.xz -= g.xz * 4.;\n  q.xz += 1.6 * (Hashv2v2 (21. * g.zx) - 0.5);\n  q.xz = Rot2D (q.xz, 2. * pi * Hashfv2 (13.55 * g.xz));\n  aa = 0.15 * Hashfv2 (12.4 * g.xz);\n  q.xy = Rot2D (q.xy, aa);\n  a = atan (q.z, q.x) / (2. * pi) + 0.5;\n  ht = 0.2 + 0.5 * Hashfv2 (11.2 * g.xz);\n  rad = 0.3 + 0.2 * Hashfv2 (11.7 * g.xz);\n  r = max (0., (ht + rad - q.y) / (ht + rad));\n  d = PrCapsDf (q.xzy, (1. + 0.3 * r * r) * rad *\n     (1. + 0.15 * clamp (0.7 * r, 0., 1.) * abs (sin (30. * pi * a))), ht);\n  d = min (d, p.y + 0.1);\n  if (d < dMin) { dMin = d;  idObj = 1;  qHit = q; }\n  if (ht > 0.5) {\n    q.y -= ht + rad - 0.02;\n    q.xy = Rot2D (q.xy, - aa);\n    d = max (PrCylDf (q.xzy, 0.3 * rad, 0.04),\n       - PrCylDf (q.xzy, 0.25 * rad, 0.05));\n    if (d < dMin) { dMin = d;  idObj = 2;  qHit = q; }\n    d = PrCapsDf (q.xzy, 0.02, 0.11);\n    if (d < dMin) { dMin = d;  idObj = 3;  qHit = q; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat FrAbsf (float p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nvec3 FrAbsv3 (vec3 p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nfloat TriNoise3d (vec3 p)\n{\n  vec3 q;\n  float a, f;\n  a = 2.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += FrAbsv3 (q + FrAbsv3 (q).yzx) + noiseDisp;\n    p *= 1.2;\n    f += a * (FrAbsf (p.x + FrAbsf (p.y + FrAbsf (p.z))));\n    q = 2. * q + 0.2;\n    a *= 0.7;\n  }\n  return f;\n}\n\nfloat FogAmp (vec3 p, float d)\n{\n  vec3 q;\n  q = p + noiseDisp;\n  q.x += 0.3 * sin (tCur * 1.5);\n  q.z += sin (0.5 * q.x);\n  q.y *= 2.;\n  q.y += 0.2 * sin (0.3 * q.x) + 0.1 * sin (tCur * 0.6);\n  return 0.2 * TriNoise3d (1.5 * q / (d + 30.)) *\n     (1. - smoothstep (1., 7., p.y)) * (2. - smoothstep (0., 0.2, p.y));\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dHit)\n{\n  vec3 q;\n  float d, dq, fFac, f, fa;\n  d = 2.5;\n  dq = 0.2;\n  fFac = 1.;\n  for (int i = 0; i < 6; i ++) {\n    q = ro + rd * d;\n    f = FogAmp (q, d);\n    fa = 1. - clamp (f - FogAmp (q + dq, d), 0., 1.);\n    col = mix (col, vec3 (0.95, 0.95, 0.9) * fa,\n       clamp (fFac * f * smoothstep (0.9 * d, 2.3 * d, dHit), 0., 1.));\n    d *= 1.6;\n    dq *= 0.8;\n    fFac *= 1.1;\n    if (d > dHit) break;\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, roo, ltDir;\n  float dstHit, dstGrnd, dstObj;\n  ltDir = normalize (vec3 (-1., 1., -1.));\n  noiseDisp = 0.05 * tCur * vec3 (-1., 0., 1.);\n  dstHit = dstFar;\n  roo = ro;\n  dstGrnd = GrndRay (ro, rd);\n  idObj = -1;\n  dstObj = ObjRay (ro, rd);\n  if (idObj < 0) dstObj = dstFar;\n  vec3 skyCol = vec3 (0.5, 0.6, 0.9) - rd.y * 0.2 * vec3 (1., 0.5, 1.) +\n     0.2 * vec3 (1., 0.6, 0.1) * pow (clamp (dot (ltDir, rd), 0., 1.), 8.);\n  dstHit = min (dstObj, dstGrnd);\n  if (dstHit >= dstFar) col = skyCol;\n  else {\n    if (dstHit < dstGrnd) {\n      ro += rd * dstHit;\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n\tvn = VaryNf (20. * qHit, vn, 2.);\n\tcol = mix (vec3 (0.3, 0.5, 0.1), vec3 (0.55, 0.5, 0.45),\n\t   clamp (1.4 * ro.y, 0., 1.));\n      } else if (idObj == 2) {\n        vn = VaryNf (10. * qHit, vn, 1.);\n        col = vec3 (0.6, 0.4, 0.3);\n      } else if (idObj == 3) {\n        col = vec3 (1., 1., 0.) * (0.8 - 0.2 * dot (vn, rd));\n      }\n      if (idObj != 3) col = col * (0.55 + 0.45 * max (dot (vn, ltDir), 0.)) ;\n    } else {\n      ro += rd * dstHit;\n      vn = GrndNf (ro, dstHit);\n      vn = VaryNf (10. * ro, vn, 0.3);\n      col = mix (vec3 (0.6, 0.3, 0.2), vec3 (0.4, 0.7, 0.3),\n\t clamp (5. * ro.y, 0., 1.));\n      col = col * (0.6 + 0.4 * max (dot (vn, ltDir), 0.)) ;\n    }\n    col = mix (vec3 (0.5, 0.6, 0.9), col,\n       exp (- 2. * clamp (5. * (dstHit / dstFar - 0.8), 0., 1.)));\n  }\n  col = FogCol (col, roo, rd, min (dstGrnd, dstObj));\n  return col;\n}\n\nvoid FlyerPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 2.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, 0.2 * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec3 rd, ro;\n  FlyerPM (tCur);\n  ro = flPos;\n  rd = normalize (vec3 (uv, 2.)) * flMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt23Dt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt23W3", "name": "Quad Test", "author": "tyleeer", "description": "Draw a quad", "tags": ["learning"], "likes": 0, "viewed": 143, "date": "1433218518", "time_retrieved": "2024-06-20T18:21:53.836779", "image_code": "vec2 pixelSpaceToUVSpace(vec2 p, vec2 resolution) {\n  vec2 uv = 2.0*p/resolution-1.0;\n  if (resolution.x > resolution.y)\n      uv[0] *= resolution.x/resolution.y;\n  else\n      uv[1] *= resolution.y/resolution.x;\n  return uv;\n}\n\nvec2 closestPointToLine(vec2 p, vec2 a, vec2 b) {\n  vec2 ap = p-a;\n  vec2 ab = b-a;\n    \n  float projectedRatio = dot(ap,ab)/dot(ab,ab);\n  float t = clamp(projectedRatio,0.0,1.0);\n  \n  return a+ab*t;\n}\n\nfloat distanceToLine(vec2 p, vec2 a, vec2 b) {\n\tvec2 p_c = closestPointToLine(p,a,b);\n    return length(p-p_c);\n}\n\nint imod(int a,int b) {\n \treturn a-b*(a/b);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = pixelSpaceToUVSpace(fragCoord.xy,iResolution.xy);   \n    float t = iTime;\n    \n    // Quad vertices\n    const int N = 4;\n    float a = 1.0*sin(t)*sin(t);\n    float b = 0.5;\n    vec2 v[N];\n    v[0] = vec2(-a,b);\n    v[1] = vec2(a,b);\n    v[2] = vec2(a,-b);\n    v[3] = vec2(-a,-b);\n\n    // settings\n    float w = 0.01;\n    vec4 backgroundColor = vec4(0.0,0.0,0.0,1.0);\n    vec4 lineColor = vec4(1.0,1.0,1.0,1.0);\n    vec4 color = backgroundColor;\n    \n    // draw each of the 4 edges\n    float D[N];\n    vec2 C[N];\n    for (int i = 0; i < N; i++) {\n        D[i] = distanceToLine(p,v[imod(i,N)],v[imod(i+1,N)]);\n        C[i] = closestPointToLine(p,v[imod(i,N)],v[imod(i+1,N)]);\n        float e1 = 1.0-smoothstep(0.0,w,D[i]); \n        color = mix(color,lineColor,e1);\n    }\n    \n    // Merge sort the distance\n    for (int i = 0; i < N-1; i++) {\n        for (int j = 0; j < N; j++) {\n            if (j > i && D[j] < D[i]) {\n                float temp = D[i];\n                D[i] = D[j];\n                D[j] = temp;\n                \n                vec2 tempv = C[i];\n                C[i] = C[j];\n                C[j] = tempv;\n            }\n        }\n    }\n    \n    // Note there is some numerical issue here.... UV is around [0,1]x[0,1]\n    if (abs(D[0]-D[1]) < 0.01 \n        && ( abs(C[0].x-C[1].x) > 0.01 || abs(C[0].y - C[1].y) > 0.01)) {\n        color = mix(color,vec4(1.0,0.0,0.0,1.0),1.0);\n    }\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt23W3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt23Wh", "name": "Fractal Experiment 6", "author": "aiekick", "description": "Fractal Experiment 6", "tags": ["fractal", "experiment", "6"], "likes": 3, "viewed": 1058, "date": "1433862477", "time_retrieved": "2024-06-20T18:21:53.836779", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n              \nvoid mainImage( out vec4 f, in vec2 g )\n{\n\tfloat \n        z = 4.,\n        t = iTime,\n        t0 = sin(t)*.5+.8,\n        t1 = sin(t*.2)*.5+.8,\n        r = 0.,\n        k = 11.*.02\n        ;\n    \n    vec2 \n        s = iResolution.xy,\n        u = vec2(t1, -.8*.5/t1),\n        d = s-s,\n        v = z * (2.*g-s)/s.y * mat2(0,1,-1,0)\n        ;\n        \n   \tvec3 \n        c = d.xxx,\n        a = c\n        ;\n    \n    //vec4 \n    //    m = iMouse;\n    \n   \t//if (m.z >0.) u = m.xy/s; \n                \n    for(float i=0.;i<1.;i+=.02) //1./50.\n    {\n        if (i > k ) break;\n    \t\n        if (dot(d,d) > 1e12) \n        {       \n        \tr = i/k;\n            \n            a.y = fract(r);\n            \n            // based iq palette formula  => https://www.shadertoy.com/view/ll2GD3\n            c += ( t0 + a*cos( 6.*(t0*t0+a) ) )*r;\n            \n            break;\n        }\n        \n        d = v + vec2(d.x * d.x - d.y * d.y, d.x * d.y) * u;\n    }\n    f.rgb = c;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt23Wh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt2GDt", "name": "Worley , n-Voronoi", "author": "FabriceNeyret2", "description": "dmin(n) = distance to nth closest seed.\nRed: dmin2-dmin1=0: borders of  cells of min distance to seeds.\nGreen: dmin3-dmin2=0: continuation of these borders inside neighbor cells.\nBlue: dmin3-dmin1=0:  nodes of  cells of min distance to seeds.", "tags": ["voronoi", "worley", "distance"], "likes": 7, "viewed": 1422, "date": "1433772242", "time_retrieved": "2024-06-20T18:21:53.836779", "image_code": "const float scale = 5.; \n\n#define PI 3.14159\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n// --- End of: Created by inigo quilez --------------------\n\n// more 2D noise\nvec2 hash12( float n ) {\n    return fract(sin(n+vec2(1.,12.345))*43758.5453);\n}\nfloat hash21( vec2 n ) {\n    return hash(n.x+10.*n.y);\n}\nvec2 hash22( vec2 n ) {\n    return hash12(n.x+10.*n.y);\n}\nfloat cell;   // id of closest cell\nvec2  center; // center of closest cell\nfloat dist;   // diss to closest cell\n\nvec3 worley( vec2 p ) {\n    vec3 d = vec3(1e15);\n    vec2 ip = floor(p);\n    for (float i=-2.; i<3.; i++)\n   \t \tfor (float j=-2.; j<3.; j++) {\n                vec2 p0 = ip+vec2(i,j);\n            \tfloat a0 = hash21(p0), a=5.*a0*iTime+2.*PI*a0; vec2 dp=vec2(cos(a),sin(a)); \n                vec2  c = hash22(p0)*.5+.5*dp+p0-p;\n                float d0 = dot(c,c);\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; cell=hash21(p0); center=c+p;}\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\n                else if (d0<d.z) {            d.z=d0; }  \n            }\n\tdist = d.x;\n    return sqrt(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\n  \n    \n\tvec3 w = scale*worley(scale*p);\n \tfloat d21 = w.y-w.x, d32=w.z-w.y, d31=w.z-w.x;\n    vec3 col = 1.-clamp(vec3(d21,d32,d31),0.,1.); col = vec3((1.-col.b)*col.rg,col.b);\n    //col = 1.-smoothstep(0.,.5,col);\n    float seed = smoothstep(0.003,.0, dist); col = seed+(1.-seed)*col;\n\n   fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2GDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt2GWd", "name": "Interpolation: Catmull Rom", "author": "4rknova", "description": "Catmull Rom interpolation.\nNote that I use line segments, not the curve distance field.", "tags": ["interpolation", "catmullrom"], "likes": 15, "viewed": 1153, "date": "1433803898", "time_retrieved": "2024-06-20T18:21:53.847343", "image_code": "// by Nikos Papadopoulos, 4rknova / 2015\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ANIMATED\n#define SHOW_CONTROL_POINTS\n//#define SHOW_SEGMENT_POINTS\n//#define MOUSE_ENABLED \n//#define AA 1.\n\n#define STEPS  15.\n#define STROKE .8\n\n#define EPS    .01\n\n#define BG   vec3(0.0745, 0.0862, 0.1058)\n#define COL0 vec3(.2, .35, .55)\n#define COL1 vec3(.9, .43, .34)\n#define COL3 vec3(1.)\n\nvec2 interpolate(vec2 a, vec2 b, vec2 c, vec2 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec2 P = -a + (3. * (b - c)) + d;\n    vec2 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec2 R = c - a;\n    vec2 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nfloat df_circ(in vec2 p, in vec2 c, in float r)\n{\n    return abs(r - length(p - c));\n}\n\nfloat df_line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat sharpen(in float d, in float w)\n{\n    float e = 1. / min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n\nfloat ip_control(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{    \n    float cp = 0.;\n    \n#ifdef SHOW_CONTROL_POINTS    \n    float c0 = sharpen(df_circ(uv, a, .02), EPS * .75);\n    float c1 = sharpen(df_circ(uv, b, .02), EPS * .75);\n    float c2 = sharpen(df_circ(uv, c, .02), EPS * .75);\n    float c3 = sharpen(df_circ(uv, d, .02), EPS * .75);\n\n    float l0 = sharpen(df_line(uv, a, b), EPS * .6);\n    float l1 = sharpen(df_line(uv, b, c), EPS * .6);\n    float l2 = sharpen(df_line(uv, c, d), EPS * .6);\n\n    cp = max(max(max(c0, c1),max(c2, c3)),\n\t         max(max(l0, l1),l2));\n#endif\n\n    return cp;\n}\n\nfloat ip_point(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    vec2 p = interpolate(a, b, c, d, mod(iTime * 2., 10.) / 10.);\n    return sharpen(df_circ(uv, p, .025), EPS * 1.);\n}\n\nfloat ip_curve(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{ \n    float e = 0.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = interpolate(a, b, c, d, (i   ) / STEPS);\n        vec2  p1 = interpolate(a, b, c, d, (i+1.) / STEPS);\n#ifdef SHOW_SEGMENT_POINTS        \n        float m = sharpen(df_circ(uv, p0, .01), EPS * .5);\n        float n = sharpen(df_circ(uv, p1, .01), EPS * .5);\n        e = max(e, max(m, n));\n#endif\n        float l = sharpen(df_line(uv, p0, p1), EPS * STROKE);\n        e = max(e, l);\n    }\n                \n    return e;\n}\n\nvec3 scene(in vec2 uv, in vec2 a, in vec2 b, in vec2 c, in vec2 d)\n{\n    float d0 = ip_control(uv, a, b, c, d);\n    float point = 0.;\n    \n#ifdef ANIMATED\n    point = ip_point(uv, a, b, c, d);\n#endif\n    \n    float d1 = ip_curve(uv, a, b, c, d);    \n    float rs = max(d0, d1);\n    \n    return (point < .5)\n        ? rs * (d0 > d1 ? COL0 : COL1)\n        : point * COL3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = BG;\n    \n    vec2 a = vec2(-.75,-.8);\n    vec2 b = vec2(-.50, .0);\n    vec2 c = vec2( .50, .0);\n    vec2 d = vec2( .75, .8);\n        \n#ifdef MOUSE_ENABLED        \n    a = (iMouse.xy / iResolution.xy * 2. - 1.)\n           * vec2(iResolution.x / iResolution.y, 1.);\n#endif\n    \n#ifdef AA\n    // Antialiasing via supersampling\n    float e = 1. / min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\tcol += scene(uv + vec2(i, j) * (e/AA), a, b, c, d) / (4.*AA*AA);\n        }\n    }\n#else\n    col += scene(uv, a, b, c, d);\n#endif /* AA */\n    \n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2GWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtBGRt", "name": "Solines", "author": "poljere", "description": "One more reactive shader in my little collection, in this case just playing around with color and simple shapes.\n * Yellow Manipus [url]https://www.shadertoy.com/view/ltB3RK[/url]\n * Twisted Rings [url]https://www.shadertoy.com/view/Xtj3DW[/url]", "tags": ["2d", "sound", "music", "audio", "microphone"], "likes": 108, "viewed": 12242, "date": "1434685452", "time_retrieved": "2024-06-20T18:21:53.850699", "image_code": "// Created by Pol Jeremias - poljere/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SOUND_MULTIPLIER 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Calculate polar coordinates\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n       \n    // Draw the lines\n    const float it = 5.0;\n    float c = 0.0;\n    for( float i = 0.0 ; i < it ; i += 1.0 )\n    {\n        float i01 = i / it;\n        float rnd = texture( iChannel0, vec2(i01)).x;\n        float react = SOUND_MULTIPLIER * texture( iChannel1, vec2(i01, 0.0) ).x;    \n        \n        float c1 = (uv.x + 1.1 + react) * 0.004 * abs( 1.0 / sin( (uv.y +0.25) +\n                                                         sin(uv.x * 4.0 * rnd + rnd * 7.0 + iTime * 0.75) *\n                                                                 (0.01 + 0.15*react)) );\n        c = clamp(c + c1, 0.0, 1.0);\n    }\n    \n    float s = 0.0;\n    const float it2 = 20.0;\n    for( float i = 0.0 ; i < it2 ; i += 1.0 )\n    {\n        float i01 = i / it2;       \n        float react = SOUND_MULTIPLIER * texture( iChannel1, vec2(i01, 0.0) ).x;  \n        vec2 rnd = texture( iChannel0, vec2(i01)).xy;\n        vec2 rnd2 = rnd - 0.5;\n      \n        rnd2 = vec2(0.85*sin(rnd2.x * 200.0 + rnd2.y * iTime * 0.1), \n                    -0.1 - 0.15 * sin(rnd2.x * rnd2.x * 200.0 + iTime  * rnd2.x * 0.25));\n        \n        float r1 = 1.0 - length(uv - rnd2);\n        float rad = ( 1.0 - clamp(0.03 * rnd.y + react * 0.05, 0.0, 1.0) );\n\n        r1 = smoothstep(rad, rad + 0.015, r1);\n        s += r1;\n    }\n    \n    \n    // Calculate the final color mixing lines and backgrounds\n    vec3 bg = mix( vec3(0.93, 0.71, 0.62), vec3(0.9, 0.44, 0.44), r);\n    bg = mix(bg, vec3(0.9, 0.91, 0.62), c);\n    bg = mix(bg, vec3(0.9, 0.91, 0.82), s);\n    \n    fragColor = vec4(bg, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtBGRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtfSR4", "name": "1D Linear Uniform B-Spline", "author": "demofox", "description": "1D Linear B-Spline.  Use the mouse to control the yellow control point.\nThere are 4 control points A,B,C,D and implicitly 6 knots: [0,1,2,3,4,5].  Only time 1.0 through 4.0 are valid due to how bsplines work.\nSigned distance used for rendering curve.", "tags": ["2d", "bspline"], "likes": 3, "viewed": 1303, "date": "1434816534", "time_retrieved": "2024-06-20T18:21:54.448792", "image_code": "/*\n\nMore info on b-splines and other curves here:\nhttp://www.ibiblio.org/e-notes/Splines/Intro.htm\n\n*/\n\n#define A  0.25\n#define B  (sin(iTime*1.5) * 0.5)\n#define C  (iMouse.z <= 0.0 ? 0.25 : iMouse.y / iResolution.y - 0.5)\n#define D  -0.1\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.0) * (i + 2.0 - t);\n}\n\nfloat SplineValue(in float t)\n{\n    return\n        A * N_i_2(t, 0.0) +\n        B * N_i_2(t, 1.0) +\n        C * N_i_2(t, 2.0) +\n        D * N_i_2(t, 3.0);\n}\n\n// F(x,y) = F(x) - y\nfloat F ( in vec2 coords )\n{\n    // time in this curve goes from 0.0 to 5.0 but values\n    // are only valid between 1.0 and 4.0\n    float T = coords.x*3.0 + 1.0;    \n    return SplineValue(T) - coords.y;\n}\n\n// signed distance function for F(x,y)\nfloat SDF( in vec2 coords )\n{\n    float v = F(coords);\n    float slope = dFdx(v) / dFdx(coords.x);\n    return abs(v)/length(vec2(slope, -1.0));\n}\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, vec2(0.0,A));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, vec2(0.33,B));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(0.66,C));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(1.0,D));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }      \n    \n    if (percent.x >= 0.0 && percent.x <= 1.0)\n    {\n    \tdist = SDF(percent);\n    \tif (dist < EDGE + SMOOTH)\n    \t{\n        \tdist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        \tcolor *= vec3(dist);\n    \t}\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtfSR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtlXR4", "name": "Golden Mandelbox", "author": "LeWiZ", "description": "A golden mandelbox !\n\nBut still too slow to visit inside... :-(", "tags": ["raymarching", "fractal", "mandelbox"], "likes": 12, "viewed": 2579, "date": "1435001585", "time_retrieved": "2024-06-20T18:21:55.406574", "image_code": "// Removing soft shadows improves FPS by a factor ~2.5, but it's less pretty\n#define SHADOWS\n\nvoid sphereFold(inout vec3 z, inout float dz)\n{\n\tfloat r2 = dot(z,z);\n\tif (r2 < 0.5)\n    { \n\t\tfloat temp = 2.0;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n    else if (r2 < 1.0)\n    { \n\t\tfloat temp = 1.0 / r2;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z, inout float dz)\n{\n\tz = clamp(z, -1.0, 1.0) * 2.0 - z;\n}\n\nfloat mandelbox(vec3 z)\n{\n    float scale = 2.0;\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n < 10; n++)\n    {\n\t\tboxFold(z,dr);\n\t\tsphereFold(z,dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;\n\t}\n\tfloat r = length(z);\n\treturn r / abs(dr);\n}\n\nfloat plane(vec3 pos)\n{\n\treturn length(max(abs(pos)-vec3(12.0,0.5,12.0),0.0));\n}\n\nfloat scene(vec3 pos)\n{\n    return min(mandelbox(pos), plane(pos-vec3(0.0,-6.5,0.0)));\n}\n\nfloat raymarcher( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 50.0;\n\tconst float precis = 0.01;\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = scene( ro+rd*t );\n        t += h * 1.0;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 normal( in vec3 pos )\n{\n    const float eps = 0.005;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*scene( pos + v1*eps ) + \n\t\t\t\t\t  v2*scene( pos + v2*eps ) + \n\t\t\t\t\t  v3*scene( pos + v3*eps ) + \n\t\t\t\t\t  v4*scene( pos + v4*eps ) );\n}\n\nfloat softray( in vec3 ro, in vec3 rd , in float hn)\n{\n    float res = 1.0;\n    float t = 0.0005;\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )\n    {\n        h = scene(ro + rd*t);\n        res = min( res, hn*h/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat ambocc( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 light( in vec3 lightdir, in vec3 lightcol, in vec3 tex, in vec3 norm, in vec3 camdir )\n{    \n    float cosa = pow(0.5 + 0.5*dot(norm, -lightdir),2.0);\n    float cosr = max(dot(-camdir, reflect(lightdir, norm)), -0.0);\n    \n    float diffuse = cosa;\n    float phong = pow(cosr, 8.0);\n    \n    return lightcol * (tex * diffuse + phong);\n}\n\nvec3 background( in vec3 rd )\n{\n\treturn vec3(1.0+2.0*rd.y);\n}\n\nvec3 material( in vec3 pos , in vec3 camdir )\n{    \n\tvec3 norm = normal(pos);\n    \n    vec3 d1 = -normalize(vec3(5.0,10.0,-20.0));\n    vec3 d2 = -normalize(vec3(-5,10.0,20.0));\n    vec3 d3 = -normalize(vec3(20,5.0,-5.0));\n    vec3 d4 = -normalize(vec3(-20.0,5.0,5.0));\n\t\n    vec3 tex = vec3(0.2);\n    if (pos.y > -5.95) tex = vec3(0.32,0.28,0.0);\n    \n    #ifdef SHADOWS\n    float sha = 0.7 * softray(pos, -d1, 32.0) + 0.3 * softray(pos, -d4, 16.0);\n    #else\n    float sha = 1.0;\n    #endif\n    float ao = ambocc(pos, norm);\n    \n    vec3 l1 = light(d1, vec3(1.0,0.9,0.8), tex, norm, camdir);\n    vec3 l2 = light(d2, vec3(0.8,0.7,0.6), tex, norm, camdir);\n    vec3 l3 = light(d3, vec3(0.3,0.3,0.4), tex, norm, camdir);\n    vec3 l4 = light(d4, vec3(0.5,0.5,0.5), tex, norm, camdir);\n    \n    #ifdef SHADOWS\n    return 0.2 * ao + 0.8 * (l1+l2+l3+l4)*sha;\n    #else\n    return 0.5 * ao + 0.5 * (l1+l2+l3+l4)*sha;\n    #endif\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 rayrender(vec3 pos, vec3 dir)\n{\n   vec3 col = vec3(0.0);\n    \n   float dist = raymarcher(pos, dir);\n    \n    if (dist==-1.0) col = background(dir);\n    else\n    {\n    \tvec3 inters = pos + dist * dir;\n    \tcol = material(inters, dir);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    \n    vec2 xy = (fragCoord.xy - iResolution.xy/2.0) / max(iResolution.xy.x, iResolution.xy.y);\n    \n    vec3 campos = vec3(35.0*cos(t/5.0),10.0,35.0*sin(t/5.0));\n    vec3 camtar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );\n\tvec3 camdir = normalize( camMat * vec3(xy,0.9) );\n    \n    vec3 col = rayrender(campos, camdir);\n    \n    #ifdef SHADOWS\n    col = pow(col, vec3(1.0/2.2));\n    #else\n    col = pow(col, vec3(1.0));\n    #endif\n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtlXRM", "name": "bouncing_ball", "author": "md", "description": "bouncing ball!", "tags": ["bouncingball"], "likes": 0, "viewed": 1123, "date": "1435517611", "time_retrieved": "2024-06-20T18:21:55.406574", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    float aspect_ratio = iResolution.y / iResolution.x;\n    \n    vec2 center = vec2(0.5, 0.3*aspect_ratio + 0.2* abs(cos(iTime)));\n    float radius = 0.2*aspect_ratio;\n    float val = (p.x - center.x) * (p.x - center.x) + (p.y*aspect_ratio - center.y) * (p.y*aspect_ratio - center.y);\n    if (val < radius*radius)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1);\n    }\n    else if (p.y > 0.1 && p.y < 0.11) \n    {\n        fragColor = vec4(0.5, 0.5, 0.5, 1);\n    }\n    else\n    {\n        fragColor = vec4(1.0, 1.0, 1.0, 1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlXRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtlXz4", "name": "My First Raymarch", "author": "rubixcom", "description": "My first try at simple raymarching. Sorry for the performance.", "tags": ["sphereraymarch"], "likes": 6, "viewed": 235, "date": "1435030178", "time_retrieved": "2024-06-20T18:21:55.412616", "image_code": "vec3 rayVector(in vec3 position, in vec3 target, in vec2 fragCoord)\n{\n    vec3 eye = normalize(target - position);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = cross(eye, up);\n    up = cross(eye,right);\n\n    mat3 cameraMatrix = mat3(right.x, up.x, eye.x,\n                \t\t\t right.y, up.y, eye.y,\n                \t\t\t right.z, up.z, eye.z);\n\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    float focalDistance = 0.5;\n    return normalize(vec3(uv.x,uv.y,focalDistance)) * cameraMatrix;\n}\n\nvec4 shade(in vec3 pos, in vec3 normal, in vec3 cameraLoc, in vec3 lightPos, in vec4 lightColor, in vec4 surface)\n{\n    vec3 light = normalize(lightPos - pos);\n    float dotlight = dot(normal,light);\n\n    vec3 camera = normalize(cameraLoc - pos);\n    vec3 cameraReflected = normalize(reflect(camera,normal));\n    float spec = 0.0;\n    if (dot(cameraReflected,light) < 0.0)\n        spec = min(1.0,pow(dot(cameraReflected,light),2.0));\n    return (surface\n        * vec4(0.2+dotlight) * lightColor\n        + vec4(0.5*spec)) * 10.0/length(lightPos - pos); // Sphere color\n}\n\n    const int maxSteps = 60;\n    const int reflectionSteps = 10;\n\nvec4 reflection(in vec3 ro, in vec3 rd, in vec3 cameraLoc, in vec3 shapeLoc, in vec3 light,  in vec3 light2,  in vec3 light3)\n{\n    vec4 color = vec4(0.0); // Sky color\n\n    float t = 0.0;\n    for(int i = 0; i < reflectionSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        \n        vec3 pm = mod(p,6.0) - shapeLoc;\n        \n        float d = length(mod(p,6.0) - shapeLoc) - 1.8; \n        if(d < 0.1)\n        {\n            vec3 normal = normalize(pm);\n            color = (shade(\n                p, normal, cameraLoc, light, \n                vec4(1.0,0.0,0.0,0.0), \n                texture( iChannel0, vec2(atan(pm.x,pm.z),pm.y)))\n                + shade(\n                p, normal, cameraLoc, light2, \n                vec4(0.0,1.0,0.0,0.0), \n                texture( iChannel0, vec2(atan(pm.x,pm.z),pm.y)))\n                + shade(\n                p, normal, cameraLoc, light3, \n                vec4(0.0,0.0,1.0,0.0), \n                texture( iChannel0, vec2(atan(pm.x,pm.z),pm.y)))) * .333;\n                ;\n            break;\n        }\n\n        t += d;\n    }\n    return color;\n}\n\nvec4 march(in vec3 ro, in vec3 rd, in vec3 cameraLoc, in vec3 shapeLoc, in vec3 light,  in vec3 light2,  in vec3 light3)\n{\n    vec4 color = vec4(0.0); // Sky color\n\n    float t = 0.0;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        \n        vec3 pm = mod(p,6.0) - shapeLoc;\n        \n        float d = length(mod(p,6.0) - shapeLoc) - 1.8; \n        if(d < 0.01)\n        {\n            vec3 normal = normalize(pm);\n\n            vec3 cameraReflected = normalize(reflect(rd, normal));\n\n            color = (shade(\n                p, normal, cameraLoc, light, \n                vec4(1.0,0.0,0.0,0.0), \n                texture( iChannel0, vec2(atan(pm.x,pm.z),pm.y)))\n                + shade(\n                p, normal, cameraLoc, light2, \n                vec4(0.0,1.0,0.0,0.0), \n                texture( iChannel0, vec2(atan(pm.x,pm.z),pm.y)))\n                + shade(\n                p, normal, cameraLoc, light3, \n                vec4(0.0,0.0,1.0,0.0), \n                texture( iChannel0, vec2(atan(pm.x,pm.z),pm.y)))) * .333\n            + 0.5*reflection(p + normal*.1, cameraReflected, p, shapeLoc, light, light2, light3);\n                ;\n            break;\n        }\n\n        t += d;\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 shapeLoc = vec3(3.0,3.0,3.0);\n    vec3 cameraLoc = vec3(3. + 4.0 * sin(iTime), 3.0 + 4.0 * sin(0.4*iTime) , 3.+4.0 * cos(iTime));\n    vec3 cameraTarget = shapeLoc;\n    vec3 light = vec3(3. + 4.0 * sin(iTime*2.), 3.0 + 8.0 * sin(0.4*iTime) , 3.+4.0 * cos(2.*iTime));\n    vec3 light2 = vec3(3. + 4.0 * sin(iTime*3.), 3.0 + 4.0 * sin(0.2*iTime) , 3.+8.0 * cos(3.*iTime));\n    vec3 light3 = vec3(3. + 8.0 * sin(iTime*4.), 3.0 + 4.0 * sin(0.1*iTime) , 3.+4.0 * cos(4.*iTime));\n    \n    vec3 ro = cameraLoc;\n    vec3 rd = rayVector(cameraLoc, cameraTarget, fragCoord);\n\n    \n    fragColor = march(ro, rd, cameraLoc, shapeLoc, light, light2, light3);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlXz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtsXRn", "name": "BirthMachine", "author": "dila", "description": "A birth-machine for a parallel universe.", "tags": ["fractal", "tunnel"], "likes": 23, "viewed": 348, "date": "1434149144", "time_retrieved": "2024-06-20T18:21:55.412616", "image_code": "const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nvec2 map(vec3 p)\n{\n    float t = p.z;\n    p = fract(p) * 2.0 - 1.0;\n    vec3 q = p;\n    float k = 1.0;\n    float fd = 1000.0;\n    float mt = 0.0;\n    const int n = 8;\n    for (int i = 0; i < n; ++i) {  \n    \tfloat d = length(q) - 0.1;\n        if (d < fd) {\n            mt = float(i);\n            fd = d;\n        }\n        fd = min(fd, d);\n        q += -sign(q) * (length(q)-0.15);\n    }\n    mt /= float(n-1);\n    float tr = 1.0 + 0.4 * sin(t*3.0);\n    float ca = length(p.xy) - tr;\n    fd = max(fd, -ca);\n    return vec2(fd, mt);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d * 0.25;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n                          map(p+o.yxy).x - map(p-o.yxy).x,\n                          map(p+o.yyx).x - map(p-o.yyx).x));\n}\n\nvec3 col(float x)\n{\n\tvec3 ka = vec3(1.0, 1.0, 0.0) * 0.5;\n    vec3 kb = vec3(1.0, 0.5, 0.0) * 0.5;\n    vec3 kc = vec3(0.0, 0.0, 1.0) * 0.5;\n    vec3 ma = mix(ka, kb, x);\n    vec3 mb = mix(kb, kc, x);\n    return mix(ma, mb, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    mat3 xfm = yrot(iTime) * xrot(iTime*0.5) * zrot(iTime*0.25);\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv)*0.333));\n \tr *= xfm;\n    \n    vec3 o = vec3(0.5, 0.5, 0.0);\n    o.z += iTime * 0.125;\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    vec2 fd = map(w);\n    \n    float prod = max(dot(sn, -r), 0.0);\n    \n    float fog = 1.0 / (1.0 + t * t + fd.x * 100.0);\n    \n    float flmb = 0.0;\n    float fspec = 0.0;\n    float fls = 0.0;\n    \n    for (int j = -1; j <= 1; j+=2) {\n    \n        vec3 lpos = o + vec3(0.0,0.0,1.0) * float(j);\n\n        float lt = 0.0;\n        for (int i = 0; i < 16; ++i) {\n            lt += (length(o + r * lt - lpos) - 0.1) * 0.5;\n        }\n\n        float lm = 1.0;\n        if (t < lt) {\n            lm = 1.0 / (1.0 + lm * lm * 0.1);\n        }\n\n        float ls = 1.0 / (1.0 + lt * lt * 0.001);\n\n        vec3 ld = lpos - w;\n        float la = length(ld);\n        ld /= la;\n        float lmb = max(dot(ld, sn), 0.0);\n        vec3 refl = reflect(ld, sn);\n        float spec = max(dot(refl, r), 0.0);\n        spec = clamp(pow(1.0+spec, 4.0), 0.0, 1.0);\n        spec = mix(spec, 0.0, fd.y);\n        float atten = 1.0 / (1.0 + la * la * 0.01);\n        \n        flmb += lmb * atten;\n        fspec += spec * atten;\n        fls += ls * lm;\n    }\n    \n    vec3 diff = col(fd.y);\n    \n    diff = mix(diff, vec3(1.0, 1.0, 1.0), abs(sn.z));\n    \n    vec3 fc = diff * (flmb + fspec) * fog + fls;\n    \n\tfragColor = vec4(fc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtsXRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtsXz4", "name": "necsoft_001", "author": "necsoft", "description": "Experiment with gradients.", "tags": ["cool", "gradients"], "likes": 0, "viewed": 185, "date": "1435031814", "time_retrieved": "2024-06-20T18:21:55.412616", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    if(uv.x>0.5){\n\tfragColor = vec4(sin((iTime*1.)+uv.x) +uv.y,\n                     cos((iTime*5.)-uv.y)+uv.x,\n                     cos(uv.x+iTime),1.);\n    }else{\n\n\tfragColor = vec4(cos((iTime*1.)+uv.x) +uv.y,\n                     sin((iTime*5.)-uv.y)+uv.x,\n                     cos(uv.x+iTime),1.);    \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtsXz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtXSR7", "name": "Skyline in 132 chars", "author": "GregRostami", "description": "This is a reduction of gsingh93's shader down to one tweet (138 chars).\nhttps://www.shadertoy.com/view/4tXSRM#\nThanks to 834144373, FabriceNeyret2 and 104 we went from 174 chars down to 138 chars!", "tags": ["2d", "short", "2tc", "onetweet", "skyline"], "likes": 6, "viewed": 742, "date": "1435237595", "time_retrieved": "2024-06-20T18:21:55.412616", "image_code": "// Greg removed a few extra chars:\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u /= iResolution.xy;\n    for (float i = 1.; i++ < 20.;)\n        o = u.y < sin( ceil(2e2*u.x/i+i*i+iTime) ) - .04*i ? o-o+i/20. : o;\n}\n\n/*\n//  Next to the last version ...\n\nvoid mainImage(out vec4 f, vec2 U) {\nvec2 u=U/iResolution.xy;\nfor (float i = 1.; i++ < 20.;)\n    f = u.y < sin( ceil(2e2*u.x/i+i*i+iTime) ) - .04*i ? f-f+i/20. : f; }\n\n// Thanks to 834144373, FabriceNeyret2, 104 and iapafoto we went from 174 to 139 chars!\n\nvoid mainImage(out vec4 f, vec2 u)\n{\n    f-=f;\n    u /= iResolution.xy;\n    for (float i = 1.; i++ < 20.;) \n\t\tf = u.y < sin( ceil(2e2*u.x/i+i*i+iTime) ) - .04*i ? f-f+i/20. : f; \n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtXSRM", "name": "Perlin Noise/FBM", "author": "addminztrator", "description": "Check out an audioreactive version here: \nhttps://www.youtube.com/watch?v=FgCs3C9Q258 \n( â—œâ—¡ï¼¾)ã£", "tags": ["perlinnoise", "fbm"], "likes": 0, "viewed": 239, "date": "1435152173", "time_retrieved": "2024-06-20T18:21:55.412616", "image_code": "mat2 m = mat2( 0.8, 0.6, -0.6, 0.8);\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n} \n\nvec2 fade(vec2 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat noise(vec2 P)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n     \n    vec4 i = permute(permute(ix) + iy);\n     \n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n     \n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n     \n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;  \n    g01 *= norm.y;  \n    g10 *= norm.z;  \n    g11 *= norm.w;  \n     \n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n     \n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfloat fbm( vec2 p ){\n\tfloat f = 0.0;\n\tf += 0.5000*noise(p); p*=m*2.02;\n\tf += 0.2500*noise(p); p*=m*2.03;\n\tf += 0.1250*noise(p); p*=m*2.01;\n\tf += 0.0625*noise(p); p*=m*2.04;\n\tf /= 0.9375;\n\treturn f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tfloat r = sqrt( dot(p,p));\n\tfloat a = atan( p.y, p.x );\n\tfloat k = fbm(vec2(48.0*q+iTime));\n\tvec3 col = vec3(k, k, 0);\n\tif (r < 1.0){\n\t\tcol = vec3(0.2, 0.3, 0.4);\n\t\tfloat f = fbm( 12.0*p+iTime );\n\t\tcol = mix(col, vec3(0.2, 0.5, 0.4), f);\n\t\t\n\t\tf = smoothstep( 0.45, 1.0, r);\n\t\tcol = mix(col, vec3(k, k, 0), f);\n\t}\n\tfragColor = vec4(col, 0.25);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXSRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtXSzH", "name": "Worley3D noise", "author": "Lallis", "description": "Some worley noise with animation and color. Unfortunately it's not very efficient :(\n\nEDIT: Now it's a quite a bit faster than before :)\nThanks to FabriceNeyret2&iq!\n", "tags": ["noise", "worley"], "likes": 26, "viewed": 585, "date": "1434448633", "time_retrieved": "2024-06-20T18:21:55.412616", "image_code": "float noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,126.7235))) * 43758.5453);\n}\n\nfloat worley3D(vec3 p)\n{\t\t\t\t\t \t\t\t\t\t \n\tfloat r = 3.0;\n    vec3 f = floor(p);\n    vec3 x = fract(p);\n\tfor(int i = -1; i<=1; i++)\n\t{\n\t\tfor(int j = -1; j<=1; j++)\n\t\t{\n\t\t\tfor(int k = -1; k<=1; k++)\n\t\t\t{\n                vec3 q = vec3(float(i),float(j),float(k));\n    \t\t\tvec3 v = q + vec3(noise3D((q+f)*1.11), noise3D((q+f)*1.14), noise3D((q+f)*1.17)) - x;\n    \t\t\tfloat d = dot(v, v);\n\t\t\t\tr = min(r, d);\n\t\t\t}\n\t\t}\n\t}\n    return sqrt(r);\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv*2.0-1.0;\n    p.x*=iResolution.x/iResolution.y;\n    float my = (iMouse.y==0.0 ? 0.5 : iMouse.y/iResolution.y);\n    p*=20.0*my;\n   \tfloat f = worley3D(vec3(p,iTime*0.2));\n    \n    float mx = (iMouse.x==0.0 ? 0.5 : iMouse.x/iResolution.x);\n    if(uv.x>mx)\n    {\n        f = worley3D(vec3(p*0.25,1.0)*f);; \n    }\n    vec3 col = vec3(f);\n\tcol*=vec3(0.6,1.0,0.1)*f*f;\n    col*=exp(1.0-col);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXSzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlB3Wd", "name": "Fractal Experiment 5", "author": "aiekick", "description": "the same as 4 but with another coloration attempt", "tags": ["fractal", "experiment", "5"], "likes": 7, "viewed": 1169, "date": "1433450536", "time_retrieved": "2024-06-20T18:21:55.418654", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = sin(iTime*.1)*.5+.5;\n    \n    vec2 s = iResolution.xy;\n    vec2 g = fragCoord.xy;\n    vec2 uv = (2.*g-s)/s.y;\n    \n    vec2 mo = s / 2. * vec2(0.986, t);\n    mo = (2.*mo-s)/s.y;\n        \n    float \n    \tx=uv.x,\n        y=uv.y,\n        m=0.;\n       \n    vec3 col = vec3(0.);\n\tvec2 res = col.xy;\n    \n    for (int i=0;i<49;i++)\n    {\n        // kali formula \n        // from http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns\n     \tx=abs(x);\n        y=abs(y);\n        m=x*x+y*y;\n        x=x/m+mo.x;\n        y=y/m+mo.y;\n        \n        col = mix(col, vec3(x,y,m), fract(length(col)));\n    \tcol = smoothstep(min(x,y), max(x,y), fract(col));\n    }\n         \n        \n        \n    \n    \n    fragColor.rgb = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlB3Wd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlBGWd", "name": "rings3", "author": "Justaway", "description": "rings", "tags": ["rings"], "likes": 2, "viewed": 119, "date": "1433448328", "time_retrieved": "2024-06-20T18:21:56.000436", "image_code": "mat3 rotX(float a);\nmat3 rotY(float a);\nmat3 rotZ(float a);\nmat3 rot(vec3 z,float a);\nfloat dist(vec3 p);\nvec3 normal(vec3 p);\nvec3 myRefract(vec3 i, vec3 n, float r);\n\nmat3 rotX(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\n\nmat3 rotY(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\n\nmat3 rotZ(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\n\nmat3 rot(vec3 z,float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat ic=1.0-c;\n\treturn mat3(\n\t\tic*z.x*z.x+c,ic*z.x*z.y-z.z*s,ic*z.z*z.x+z.y*s,\n\t\tic*z.x*z.y+z.z*s,ic*z.y*z.y+c,ic*z.y*z.z-z.x*s,\n\t\tic*z.z*z.x-z.y*s,ic*z.y*z.z+z.x*s,ic*z.z*z.z+c);\n}\n\nfloat dist(vec3 p)\n{\n    float d = 100.0;\n    vec3 tp; /*temp point*/\n    for(int i = 0; i < 8; i++)\n    {\n        tp = p*rotX(iTime/float(i+1));\n        tp *=rotZ(2.0*iTime/float(i+1));\n    \td = min(d,length(vec2(length(tp.xz)-0.28*float(i)-0.25, tp.y))-0.13);\n    }\n    return d;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    vec3 s=vec3(0.1,0.0,0.0);\n    return normalize(vec3(\n        dist(p+s.xyy-d),\n        dist(p+s.yxy-d),\n        dist(p+s.yyx-d)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*screen coordinates (sc)*/\n\tvec2 sc = vec2(fragCoord.x-0.5*iResolution.x,fragCoord.y-0.5*iResolution.y);\n    sc /= iResolution.xy;\n    sc.x *= iResolution.x/iResolution.y;\n    \n    /*calculate vectors for raymarching*/\n    vec3 upVec = vec3(0.0,-1.0,0.0);/*up vector is on y-axis*/\n    vec3 lookPos = vec3(0.0,0.0,0.0); /*eye looking at origin*/\n    vec3 eyePos = vec3(0.0,0.0,-5.0); /*eye offset on z-axis*/\n    \n    /*animate camera*/\n    eyePos *= rotX(sin(0.1*iTime));\n    eyePos *= rotY(sin(0.2*iTime));\n    \n    vec3 rayVec = normalize(lookPos - eyePos); /*direction of ray*/\n    \n    /*calculate a vector pointing directly to the left of the eye*/\n    vec3 leftVec = normalize(cross(upVec,rayVec));\n    /*calculate the up for the eye*/\n    vec3 eyeUpVec = normalize(cross(rayVec,leftVec));\n    \n    rayVec *= rot(eyeUpVec,sc.x*0.8);\n    rayVec *= rot(leftVec,sc.y*0.8);\n    \n    /*march ray*/\n    float d;\n    float marchLen;\n    vec3 rayPos = eyePos;\n    vec4 color = vec4(1.0,1.0,1.0,1.0);\n    bool hit = false;\n    vec3 n;\n    for(int i = 0; i < 100; i++)\n    {\n        d = dist(rayPos);\n        if(hit == false)\n        {\n            if(d<0.0)\n            {\n                hit=true;\n                n = normal(rayPos,d);\n                color=vec4(abs(dot(rayVec,n)));\n            }\n            marchLen = max(0.001,abs(d));\n            rayPos += rayVec*marchLen;\n        }\n    }\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlBGWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlfXR4", "name": "Curvature - Parametric 3D", "author": "iq", "description": "Curvature computation for parametric curves (same as [url]https://www.shadertoy.com/view/Mlf3zl[/url]. but in 3D in this case), and displays it with colors (red is high curvature, yellow is medium, green is low)", "tags": ["3d", "curvature", "parametric"], "likes": 93, "viewed": 11090, "date": "1434657962", "time_retrieved": "2024-06-20T18:21:56.861140", "image_code": "// The MIT License\n// Copyright © 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n\n//\n// Computes the curvature of a parametric curve f(x) as \n//\n// c(f) = |f'|^3 / | f' x f''|\n//\n// More info here: https://en.wikipedia.org/wiki/Curvature\n//\n\n\n//----------------------------------------\n\nvec3 a, b, c, m, n;\n\n// curve\nvec3 mapD0(float t)\n{\n    return 0.25 + a*cos(t+m)*(b+c*cos(t*7.0+n));\n}\n// curve derivative (velocity)\nvec3 mapD1(float t)\n{\n    return -7.0*a*c*cos(t+m)*sin(7.0*t+n) - a*sin(t+m)*(b+c*cos(7.0*t+n));\n}\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return 14.0*a*c*sin(t+m)*sin(7.0*t+n) - a*cos(t+m)*(b+c*cos(7.0*t+n)) - 49.0*a*c*cos(t+m)*cos(7.0*t+n);\n}\n\n//----------------------------------------\n\nfloat curvature( float t )\n{\n    vec3 r1 = mapD1(t); // first derivative\n    vec3 r2 = mapD2(t); // second derivative\n    return pow(length(r1),3.0) / length(cross(r1,r2));\n}\n\n//-----------------------------------------\n\n// unsigned squared distance between point and segment\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec3  q = pa - ba*h;\n\treturn vec2( dot(q,q), h );\n}\n\n\n// unsigned squared distance between ray and segment\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n#if 1\n\tvec3 oa = a-o;\n    vec3 ob = b-o;\n\tvec3 va = oa-d*dot(oa,d);\n    vec3 vb = ob-d*dot(ob,d);\n    \n    vec3 ba = va-vb;\n    float h = clamp( dot(va,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3  q = va - ba*h;\n    return vec2( dot(q,q), h );\n#else\n    return usqdPointSegment( vec3(0.0), o+d*dot(a-o,d)-a, o+d*dot(b-o,d)-b );\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    a = vec3(1.85,1.25,1.85) + 0.1*cos(5.0+0.7*iTime + vec3(0.5,1.0,2.0) );\n    b = vec3(0.60,0.60,0.60) + 0.1*cos(4.0+0.5*iTime + vec3(2.5,5.0,3.0) );\n    c = vec3(0.40,0.40,0.40) + 0.1*cos(1.0+0.3*iTime + vec3(6.0,2.0,4.2) );\n    m = cos( 0.11*iTime + vec3(2.0,0.0,5.0) );\n    n = cos( 0.17*iTime + vec3(3.0,1.0,4.0) );\n\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n \n    vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3(p.xy, -2.0) );\n\n    vec3 col = vec3(0.0);\n    \n    vec3  gp = vec3(0.0);\n    float pt = (-1.0-ro.y)/rd.y;\n    vec3 gc = vec3(0.0);\n    if( pt>0.0 )\n    {\n        gp = ro + pt*rd;\n        gc = vec3(1.0) * (0.2 + 0.1*smoothstep(-0.01,0.01,sin(4.0*gp.x)*sin(4.0*gp.z)));\n        col = 0.3*gc*exp(-0.05*pt);\n    }\n    \n    const int kNum = 150;\n    \n    float dt = 6.2831/float(kNum);\n\tfloat t = 0.0;\n    vec3  xb = mapD0(t); t += dt;\n    for( int i=0; i<kNum; i++ )\n    {\n        vec3 xc = mapD0(t);\n        xc.y = max(-1.0,xc.y); // clip to ground\n        vec2 ds = usqdLineSegment( xb, xc, ro, rd );\n\n        // compute curvature\n        float h = t - dt + dt*ds.y;\n        float c = curvature( h );\n\n        vec3  cc = clamp( 0.25 + 0.75*cos( -clamp(3.0*c,0.0,2.0) + 1.0 + vec3(0.0,1.5,2.0) ), 0.0, 1.0 );\n        \n        col += 1.0*cc*exp2( -800.0*ds.x );\n        col += 0.1*cc*exp2( -40.0*ds.x );\n\n        // light ground\n        if( pt > 0.0 )\n        {\n            vec2 sd = usqdPointSegment( gp, xb, xc );\n            col += gc*0.8*cc*exp(-2.0*sd.x)*exp( -0.05*pt );\n        }\n        \n        xb = xc; t += dt;\n\t}    \n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/XlfXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlfXRn", "name": "Box Frames", "author": "Justaway", "description": "Rotating box frames.", "tags": ["raymarching"], "likes": 5, "viewed": 120, "date": "1433873625", "time_retrieved": "2024-06-20T18:21:57.661250", "image_code": "mat3 rotX(float a);\nmat3 rotY(float a);\nmat3 rotZ(float a);\nmat3 rot(vec3 z,float a);\nfloat dist(vec3 p);\nvec3 normal(vec3 p);\nvec3 myRefract(vec3 i, vec3 n, float r);\nvec4 background(vec3 v);\n\nvec4 background(vec3 v)\n{\n    vec4 c1 = vec4(0.0);\n    vec4 c2 = vec4(1.0);\n    if(fract(v.y*3.0) < 0.5){\n        if(fract(atan(v.x/v.z)+0.5) < 0.5)\n        {\n            return c1;\n        }\n        else\n        {\n            return c2;\n        }\n    }\n    else\n    {\n        if(fract(atan(v.x/v.z)+0.5) < 0.5)\n        {\n            return c2;\n        }\n        else\n        {\n            return c1;\n        }\n    }\n}\n\nmat3 rotX(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\n\nmat3 rotY(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\n\nmat3 rotZ(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\n\nmat3 rot(vec3 z,float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat ic=1.0-c;\n\treturn mat3(\n\t\tic*z.x*z.x+c,ic*z.x*z.y-z.z*s,ic*z.z*z.x+z.y*s,\n\t\tic*z.x*z.y+z.z*s,ic*z.y*z.y+c,ic*z.y*z.z-z.x*s,\n\t\tic*z.z*z.x-z.y*s,ic*z.y*z.z+z.x*s,ic*z.z*z.z+c);\n}\n\nfloat dist(vec3 p)\n{\n    float r,r2,d1,d2;\n    float d = 100.0;\n    vec3 pt;\n    \n    r = 0.2;\n    r2 = 0.2;\n    \n    for(int i = 0; i < 5; i++)\n    {\n        pt = rotX(iTime/float(i))*p;\n        pt *= rotZ(iTime/float(i));\n        d1 = max(abs(pt.x),max(abs(pt.y),abs(pt.z))) - r;\n        d2 = max(abs(pt.x),abs(pt.y))-r+r2;\n        d2 = min(d2,max(abs(pt.y),abs(pt.z))-r+r2);\n        d2 = min(d2,max(abs(pt.z),abs(pt.x))-r+r2);\n        d = min(d,max(d1,-d2));\n        r += 0.3;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    vec3 s=vec3(0.1,0.0,0.0);\n    return normalize(vec3(\n        dist(p+s.xyy-d),\n        dist(p+s.yxy-d),\n        dist(p+s.yyx-d)));\n}\n\nvec3 myRefract(vec3 i, vec3 n, vec3 r)\n{\n    float d = abs(dot(i,n));\n    return normalize(i+n*abs(dot(i,n))*0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*screen coordinates (sc)*/\n\tvec2 sc = vec2(fragCoord.x-0.5*iResolution.x,fragCoord.y-0.5*iResolution.y);\n    sc /= iResolution.xy;\n    sc.x *= iResolution.x/iResolution.y;\n    \n    /*calculate vectors for raymarching*/\n    vec3 upVec = vec3(0.0,-1.0,0.0);/*up vector is on y-axis*/\n    vec3 lookPos = vec3(0.0,0.0,0.0); /*eye looking at origin*/\n    vec3 eyePos = vec3(0.0,0.0,-5.0); /*eye offset on z-axis*/\n    \n    /*animate camera*/\n    eyePos *= rotX(sin(0.1*iTime));\n    eyePos *= rotY(sin(0.2*iTime));\n    \n    vec3 rayVec = normalize(lookPos - eyePos); /*direction of ray*/\n    \n    /*calculate a vector pointing directly to the left of the eye*/\n    vec3 leftVec = normalize(cross(upVec,rayVec));\n    /*calculate the up for the eye*/\n    vec3 eyeUpVec = normalize(cross(rayVec,leftVec));\n    \n    rayVec *= rot(eyeUpVec,sc.x*0.8);\n    rayVec *= rot(leftVec,sc.y*0.8);\n    \n    /*march ray*/\n    float d;\n    float marchLen;\n    vec3 rayPos = eyePos;\n    float attenuation = 1.0;\n    vec4 color = vec4(1.0,0.95,1.0,1.0);\n    bool hit = false;\n    for(int i = 0; i < 50; i++)\n    {\n        d = dist(rayPos);\n        if(d < 0.0 && hit == false)\n        {\n            hit = true;\n            vec3 n = normal(rayPos, d);\n            rayVec = refract(rayVec, n, 1.0/1.5);\n            attenuation *= abs(dot(rayVec,n));\n        }\n        else if(d > 0.0 && hit == true)\n        {\n            hit = false;\n            vec3 n = normal(rayPos, d);\n            rayVec = refract(rayVec, -n, 1.0/1.5);\n            attenuation *= abs(dot(rayVec,n));\n        }\n        marchLen = max(0.001,abs(d));\n        rayPos += rayVec*marchLen;\n    }\n    \n    \n\tfragColor = background(rayVec)*attenuation;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlfXRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xlj3D3", "name": "Seizure Machine", "author": "jackdavenport", "description": "If you are prone to seizures, please watch in fullscreen", "tags": ["flashing", "seizure"], "likes": 3, "viewed": 1370, "date": "1433129855", "time_retrieved": "2024-06-20T18:21:57.661250", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = 1. * abs(sin(iTime * 1000.));\n    fragColor = vec4(x);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xlj3D3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xlj3Wd", "name": "psycheyes", "author": "public_int_i", "description": "looks pretty cool, changed it so mouse y changes params", "tags": ["psycheyes"], "likes": 4, "viewed": 146, "date": "1433677136", "time_retrieved": "2024-06-20T18:21:57.661250", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    \n    uv *= 8.;\n    \n    float n = 0.;\n    if (iMouse.w > 0.) n = iMouse.y/iResolution.y*2.-1.;\n    \n    mat2 m;\n    for (int i = 1; i < 4; i++) {\n        m = mat2(sin(length(uv)*float(i)),cos(atan(uv.y,uv.x)),\n                 0., n);\n        uv *= m;\n    }\n    \n    float cl = ceil(length(uv)*100.)/10.;\n\tfragColor = (length(uv)-.2) * vec4(mod(cl+iTime,1.),mod(cl+6.2464+iTime,1.),mod(cl+3.4365+iTime,1.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xlj3Wd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XljGD3", "name": "arc of the covenant", "author": "tabularasa1992", "description": "random sketch. Kind of reminds me of the covenant those old halo games.", "tags": ["abstract"], "likes": 1, "viewed": 126, "date": "1433210588", "time_retrieved": "2024-06-20T18:21:57.661250", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tuv = 2.0 * uv.xy / iResolution.y;\n    \n    uv = tan(uv) * 5. + sin(uv * -5.0);\n    \n    vec3 color = vec3(0);\n    \n    for (int i = 0; i < 3; i++){\n    \tfloat amp = 0.0;\n        amp += sin(iTime + uv.y * float(i)) + 1.5;\n        amp += cos(uv.x + iTime - float(i));\n        amp += sin(uv.y * uv.x);\n        color[i] = amp * .6 + float (i)*.75;\n    }\n    \n\tfragColor = vec4(pow(color, vec3(.9)), 1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XljGD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XllSRN", "name": "A Sphere on the Floor", "author": "codywatts", "description": "A raycaster which casts multiple rays per fragment in order to achieve basic antialiasing. Click and drag the mouse to move the camera.", "tags": ["raycasting", "antialiasing"], "likes": 6, "viewed": 1296, "date": "1435472596", "time_retrieved": "2024-06-20T18:21:58.837205", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define X_AXIS vec3(1, 0, 0)\n#define Y_AXIS vec3(0, 1, 0)\n#define Z_AXIS vec3(0, 0, 1)\n\nstruct Material\n{\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat shininess;\n};\n\nstruct Sphere\n{\n\tvec3 center;\n\tfloat radius;\n\tMaterial material;\n};\n    \nstruct Plane\n{\n\tvec3 point;\n\tvec3 normal;\n\tMaterial material;\n};\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Intersection\n{\n\tbool hit;\n\tvec3 position;\n\tvec3 normal;\n\tMaterial material;\n};\n\nstruct Camera\n{\n\tvec3 position;\n\tvec3 forward;\n\tvec3 up;\n\tvec3 right;\n};\n\nstruct Spotlight\n{\n\tvec3 position;\n\tvec3 direction;\n\tfloat angle;\n};\n\nIntersection raySphereIntersection(in Ray ray, in Sphere sphere)\n{\n\tIntersection i;\n\ti.hit = false;\n\t\n\tvec3 centerToOrigin = ray.origin - sphere.center;\n\tfloat dotProduct = dot(ray.direction, centerToOrigin);\n\tfloat squareRootTerm = pow(dotProduct, 2.0) - pow(length(centerToOrigin), 2.0) + pow(sphere.radius, 2.0);\n\tif (squareRootTerm < 0.0)\n\t{\n\t\treturn i;\n\t}\n\t\n\tfloat distanceToHit = (-dotProduct) - sqrt(squareRootTerm);\n\tif (distanceToHit < 0.0)\n\t{\n\t\treturn i;\n\t}\n\ti.position = ray.origin + (ray.direction * distanceToHit);\n\ti.normal = normalize(i.position - sphere.center);\n\ti.material = sphere.material;\n\ti.hit = true;\n\treturn i;\n}\n\nIntersection rayPlaneIntersection(in Ray ray, in Plane plane)\n{\n\tIntersection i;\n\ti.hit = false;\n\t\n\tfloat dotProduct = dot(ray.direction, plane.normal);\n\tif (dotProduct == 0.0)\n\t{\n\t\treturn i;\n\t}\n\t\n\tfloat distanceToHit = dot(plane.point - ray.origin, plane.normal)/dotProduct;\n\tif (distanceToHit < 0.0)\n\t{\n\t\treturn i;\n\t}\n\ti.position = ray.origin + (ray.direction * distanceToHit);\n\ti.normal = plane.normal;\n\ti.material = plane.material;\n\ti.hit = true;\n\treturn i;\n}\n\nvec3 blinnPhong(in vec3 lightPosition, in vec3 cameraPosition, in vec3 objectPosition, in vec3 objectNormal, in Material material)\n{\n\tvec3 fromObjectToLight = normalize(lightPosition - objectPosition);\n\tfloat lambertian = dot(fromObjectToLight, objectNormal);\n\tfloat specularIntensity = 0.0;\n    \n    if (lambertian > 0.0) // = diffuseIntensity > 0.0\n    {\n        vec3 fromObjectToCamera = normalize(cameraPosition - objectPosition);\n        vec3 halfwayVector = normalize(fromObjectToLight + fromObjectToCamera);\n        float specTmp = max(dot(objectNormal, halfwayVector), 0.0);\n        specularIntensity = pow(specTmp, material.shininess);\n    }\n    \n    return lambertian * material.diffuseColor + specularIntensity * material.specularColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Declare constants\n    const int RaysPerFragment = 5;\n\tconst vec3 BallColorOne = vec3(1, 0, 0);\n\tconst vec3 BallColorTwo = vec3(1, 1, 1);\n\tconst int BallSegmentCount = 3;\n\tconst float BallSegmentTransitionFactor = 0.05;\n\tconst float DistanceFromBall = 50.0;\n\tconst float PlaneTextureSize = 12.0;\n\tconst float SpotlightSoftness = 0.2;\n\t\t\n\t// Define our sphere\n\tSphere s;\n\ts.center = vec3(0, 0, 0);\n\ts.radius = 12.0;\n\ts.material.specularColor = vec3(0, 0, 0);\n\ts.material.shininess = 100.0;\n\t\n\t// Define our plane\n\tPlane p;\n\tp.point = s.center - vec3(0, s.radius, 0);\n\tp.normal = Y_AXIS;\n\tp.material.specularColor = vec3(1, 1, 1);\n\tp.material.shininess = 1000.0;\n\t\n\t// Define our spotlight\n\tSpotlight spotlight;\n\tspotlight.position = vec3(10.0, 20.0, 10.0);\n\tspotlight.direction = normalize(s.center - spotlight.position);\n\tspotlight.angle = PI / 5.0;\n\t\n\t// Define our camera\n\tCamera camera;\n\tfloat cameraRotationValue = (iMouse.xy == vec2(0) ? 0.8 * -iTime : (iMouse.x / iResolution.x) * TWO_PI);\n\tcamera.position = s.center + vec3(cos(cameraRotationValue) * DistanceFromBall, DistanceFromBall * (1.0 - (iMouse.y / iResolution.y)), sin(cameraRotationValue) * DistanceFromBall);\n\t\n\tvec3 targetPosition = s.center;\n\tcamera.forward = normalize(targetPosition - camera.position);\n\tcamera.right = cross(Y_AXIS, camera.forward);\n\tcamera.up = cross(camera.forward, camera.right);\n\t\n\t// To antialias our image, we cast multiple rays per fragment and \"average\" the result.\n\tvec3 accumulatedColor = vec3(0, 0, 0);\n\tfloat accumulatedSignificance = 0.0;\n\t\n\tfor (int i = 0; i < RaysPerFragment; ++i)\n\t{\n\t\tfloat t = float(i) / float(RaysPerFragment);\n\t\t\n\t\tfloat significance = (1.0 - t);\n\t\t\n\t\tvec2 fragCoordOffset = vec2(cos(t * TWO_PI) * t, sin(t * TWO_PI) * t);\n\t\tvec2 uv = 2.0 * (fragCoord + fragCoordOffset) / iResolution.xy - 1.0;\n\t\tuv.x *= iResolution.x / iResolution.y;\n\t\t\n\t\tRay r;\n\t\tr.origin = camera.position;\n\t\tr.direction = normalize(camera.forward + camera.right * uv.x + camera.up * uv.y);\n\t\t\n\t\tfloat percentLit = 1.0;\n\t\t\n\t\tIntersection intersection = raySphereIntersection(r, s);\n\t\t// If our ray hit the sphere...\n\t\tif (intersection.hit == true)\n\t\t{\n\t\t\tvec2 flattenedNormal = normalize(vec2(intersection.normal.x, intersection.normal.z));  \n\t\t\tfloat polarCoordinate = atan(flattenedNormal.y, flattenedNormal.x);\n\t\t\tpolarCoordinate += PI; // polarCoordinate is now between (0, 2*PI)\n\t\t\tpolarCoordinate = pow(sin(float(BallSegmentCount) * polarCoordinate), 2.0); // polarCoordinate is now between (0, 1)\n\t\t\t\n\t\t\tfloat smoothFactor = smoothstep(0.5 - BallSegmentTransitionFactor, 0.5 + BallSegmentTransitionFactor, polarCoordinate);\n\t\t\tintersection.material.diffuseColor = BallColorOne * smoothFactor + BallColorTwo * (1.0 - smoothFactor);\n\t\t}\n\t\t// If the ray didn't hit the sphere, test to see if it hits the plane.\n\t\telse\n\t\t{\n\t\t\tintersection = rayPlaneIntersection(r, p);\n\t\t\t\n\t\t\tif (intersection.hit == true)\n\t\t\t{\n\t\t\t\tvec3 fromPointToIntersection = intersection.position - p.point;\n\t\t\t\tvec2 textureCoordinates = vec2(dot(fromPointToIntersection, X_AXIS), dot(fromPointToIntersection, Z_AXIS)) * (1.0 / PlaneTextureSize);\n\t\t\t\t\n\t\t\t\tintersection.material.diffuseColor = texture(iChannel0, textureCoordinates).xyz;\n\t\t\t\t\n\t\t\t\t// We cast a ray from the intersection point back to the light to test whether this position lies in shadow.\n\t\t\t\tRay shadowRay;\n\t\t\t\tshadowRay.origin = intersection.position;\n\t\t\t\tshadowRay.direction = normalize(spotlight.position - intersection.position);\n\t\t\t\t\n\t\t\t\tIntersection shadowIntersection = raySphereIntersection(shadowRay, s);\n\t\t\t\tif (shadowIntersection.hit == true)\n\t\t\t\t{\n\t\t\t\t\tpercentLit = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec3 objectColor = vec3(0, 0, 0);\n\t\t\n\t\t// If the ray hit the sphere or the plane...\n\t\tif (intersection.hit == true)\n\t\t{\n\t\t\tif (percentLit > 0.0)\n\t\t\t{\n\t\t\t\tvec3 fromLightToObject = normalize(intersection.position - spotlight.position);\n\t\t\t\tfloat angleFromLightToObject = acos(dot(fromLightToObject, spotlight.direction));\n\t\t\t\t\n\t\t\t\t// Smoothstep softens the edges of the spotlight\n\t\t\t\tpercentLit = smoothstep(-SpotlightSoftness, SpotlightSoftness, spotlight.angle - angleFromLightToObject);\n\t\t\t\t\n\t\t\t\tobjectColor = blinnPhong(spotlight.position, camera.position, intersection.position, intersection.normal, intersection.material);\n\t\t\t}\n\t\t\t\n\t\t\tobjectColor = max(objectColor * percentLit, intersection.material.diffuseColor * 0.0025);\n\t\t\tobjectColor *= clamp((60000.0 / pow(distance(s.center, intersection.position), 2.0)), 0.0, 1.0);\n\t\t}\n\t\t\n\t\taccumulatedColor += objectColor * significance;\n\t\taccumulatedSignificance += significance;\n\t}\n\t\n\taccumulatedColor /= accumulatedSignificance;\n\taccumulatedColor = pow(accumulatedColor, vec3(1.0/2.2)); // Gamma correction\n\tfragColor = vec4(accumulatedColor, 1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XllSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XllXz4", "name": "Britnifalopa", "author": "necsoft", "description": "falopa", "tags": ["falopa"], "likes": 4, "viewed": 104, "date": "1434924532", "time_retrieved": "2024-06-20T18:21:58.837205", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture( iChannel0, uv );\n    \n\tfragColor = col;//vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    \n    fragColor = vec4(sin(col.r+iTime*2.0),cos(col.g+iTime*1.0),abs(sin(((iTime*0.01)+fragCoord.x)*10.0)),abs(uv.y));\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XllXz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlsSzn", "name": "Weird Pink Ball", "author": "dgreensp", "description": "Just a weird pink ball", "tags": ["raymarch", "sphere", "pink"], "likes": 10, "viewed": 1316, "date": "1434064836", "time_retrieved": "2024-06-20T18:21:59.327990", "image_code": "const int MAX_STEPS = 64;\nconst float CLOSENESS = 0.01;\nconst float EPSILON = 0.01;\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f);\n\t\n    float n = p.x + p.y*157. + 113.*p.z;\n    \n    vec4 v1 = fract(753.5453123*sin(n + vec4(0., 1., 157., 158.)));\n    vec4 v2 = fract(753.5453123*sin(n + vec4(113., 114., 270., 271.)));\n    vec4 v3 = mix(v1, v2, f.z);\n    vec2 v4 = mix(v3.xy, v3.zw, f.y);\n    return mix(v4.x, v4.y, f.x);\n}\n\nfloat field(vec3 p) {\n   // random rotation reduces artifacts\n   mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                 0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                 -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n   vec3 p1 = M*p;\n   vec3 p2 = M*p1;\n   float n1 = noise(p1*5.);\n   float n2 = noise(p2*10.);\n   float n3 = noise(p1*20.);\n   float n4 = noise(p1*40.);\n   float rocky = 0.1*n1*n1 + 0.05*n2*n2 + 0.02*n3*n3 + 0.01*n4*n4;\n   float sph_dist = length(p) - 1.0;\n   return sph_dist + (sph_dist < 0.1 ? rocky*0.8 : 0.);\n}\n\nfloat field_lores(vec3 p) {\n   // random rotation reduces artifacts\n   mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                 0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                 -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n   vec3 p1 = M*p;\n   float n1 = noise(p1*5.);\n   float rocky = 0.1*n1*n1;\n   float sph_dist = length(p) - 1.0;\n   return sph_dist + (sph_dist < 0.1 ? rocky*0.8 : 0.);\n}\n\n\nvec3 getNormal(vec3 p, float value, mat3 rot) {\n    vec3 n = vec3(field(rot*vec3(p.x+EPSILON,p.y,p.z)),\n                  field(rot*vec3(p.x,p.y+EPSILON,p.z)),\n                  field(rot*vec3(p.x,p.y,p.z+EPSILON)));\n    return normalize(n - value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 src = vec3(3. * (fragCoord.xy - 0.5*iResolution.xy) / iResolution.yy, 2.0);\n    vec3 dir = vec3(0., 0., -1.);\n    \n    float ang = iTime*2.0;\n    mat3 rot = mat3(-sin(ang),0.0,cos(ang),0.,1.,0.,cos(ang),0.,sin(ang));\n\n    \n    float t = 0.0;\n    vec3 loc = src;\n    float value;\n    int steps = 0;\n    for (int i=0; i < MAX_STEPS; i++) {\n        steps++;\n        loc = src + t*dir;\n        if (loc.z < -1.) break;\n        value = field(rot*loc);\n        if (value <= CLOSENESS) break;\n        t += value*0.5;\n    }\n    vec3 lightVec = normalize(vec3(-1.,1.,1.));\n    // attempt at self-occlusion\n    float shad1 = max(0.,field_lores(rot*(loc+lightVec*0.1)))/0.1;\n    float shad2 = max(0.,field_lores(rot*(loc+lightVec*0.2)))/0.2;\n    float shad = clamp(shad1*0.5 + shad2*0.5, 0., 1.);\n    shad = mix(shad, 1.0, 0.5);\n    // attempt at some sort of ambient \"glow\"\n    float ambient = clamp(field(rot*(loc - 0.5 * dir))/0.5*1.5, 0., 1.);\n        \n    if (value > CLOSENESS) fragColor = vec4(0., 0., 0., 1.);\n    else {\n      vec3 normal = getNormal(loc, value, rot);\n      vec3 bounceVec = lightVec + 2.*(normal * dot(normal, lightVec) - lightVec);\n      float light = dot(normal, lightVec);\n      float totalLight = mix(ambient, 1.0*max(0.,shad*light), 0.6);\n    \n      vec3 color = mix(vec3(0.8,0.5,0.8), vec3(1.,0.5,0.9), 1.-(1.0-length(loc))*10.);\n        \n      fragColor = vec4(color*totalLight + vec3(0.5)*pow(max(0.,bounceVec.z),20.), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlsSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlsXRn", "name": "squid - Planets", "author": "squid", "description": "Strange colored planets in space. Best in Fullscreen, also less dense ", "tags": ["3d", "raymarch", "dde"], "likes": 4, "viewed": 1315, "date": "1434063008", "time_retrieved": "2024-06-20T18:22:00.303778", "image_code": "#define GRADIENT_DELTA 0.5\n#define FUDGE_FACTOR 0.5\n#define COMPARE_FUDGE_FACTOR 0.2\n\n\n#define time iTime\n#define size iResolution\n\n//code here is from iq(Distance Functions + shading), effie(DDE), Dave_Hoskins(hash), dgreensp(fbm)\n//also very simular to \"Spinning Rings\"\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nmat3 rotateY(float r)\n{\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, 0, cs.y, 0, 1, 0, -cs.y, 0, cs.x);\n}\n\nmat3 rotateZ(float r)\n{\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, cs.y, 0., -cs.y, cs.x, 0., 0., 0., 1.);\n}\n\n#define MOD2 vec2(443.8975,397.2973)\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\nfloat hash13(vec3 p)\n{\n\tp  = fract(p * MOD3);\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\nvec3 hash33(vec3 p)\n{\n\tp = fract(p * MOD3);\n    p += dot(p.zxy, p+19.19);\n    return fract(vec3(p.x * p.y, p.x*p.z, p.y*p.z));\n}\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx) * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nvec2 map( in vec3 pos )\n{\n    vec3 c = vec3(16.);\n    vec3 q = opRep(pos, c);\n    vec4 h = hash43( floor(pos/c-(.5*c)) )*2. - 1.;\n    float rad = h.y*.5 + .5;\n    vec3 ctr = q-vec3(sin(h.z)*cos(h.w),cos(h.z)*sin(h.w),sin(h.z))*(6.5);\n    vec2 res = vec2(\n        sdSphere(ctr , rad), h.x);\n    if(h.y > 0.8)  {\n    \tmat3 r = rotateY(iTime*h.z*.2)*rotateZ(iTime*h.w*.2);\n        res = opU(res, vec2(sdTorus(ctr*r, vec2(rad*3., 0.01)), 20.));\n    }\n    return res;\n}\n\n\nfloat DE(vec3 p0)\n{\n    return map(p0).x;\n}\n\nvec2 DDE(vec3 p, vec3 rd){\n\tfloat d1=DE(p);\n  \t//return vec2(d1,d1*COMPARE_FUDGE_FACTOR);\n\tfloat dt=GRADIENT_DELTA*log(d1+1.0);\n\tfloat d2=DE(p+rd*dt);\n\tdt/=max(dt,d1-d2);\n\treturn vec2(d1,FUDGE_FACTOR*log(d1*dt+1.0));\n}\n\nfloat rndStart(vec2 co){return fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 eps = vec2(.001, 0.);\n    return normalize(vec3(\n        DE(p+eps.xyy) - DE(p-eps.xyy),\n        DE(p+eps.yxy) - DE(p-eps.yxy),\n        DE(p+eps.yyx) - DE(p-eps.yyx)));\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f);\n\t\n    float n = p.x + p.y*157. + 113.*p.z;\n    \n    vec4 v1 = fract(753.5453123*sin(n + vec4(0., 1., 157., 158.)));\n    vec4 v2 = fract(753.5453123*sin(n + vec4(113., 114., 270., 271.)));\n    vec4 v3 = mix(v1, v2, f.z);\n    vec2 v4 = mix(v3.xy, v3.zw, f.y);\n    return mix(v4.x, v4.y, f.x);\n}\n\nfloat fnoise(vec3 p) {\n  // random rotation reduces artifacts\n  p = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n           0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n           -0.9548821651308448, 0.26025457467376617, 0.14306504491456504)*p;\n  return dot(vec4(noise(p), noise(p*2.), noise(p*4.), noise(p*8.)),\n             vec4(0.5, 0.25, 0.125, 0.06));\n}\nvec3 compute_color(vec3 ro, vec3 rd, float t)\n{\n    vec3 p = ro+rd*t;\n    vec3 l = normalize(vec3(0., .7, .2));\n    vec3 nor = normal(p);\n    vec3 ref = reflect(rd, nor);\n    \n    float m = map(p).y;\n    vec3 c = vec3(0.);\n    if(m == 20.) {\n        c = vec3(pow(fnoise(p*vec3(2.,1.,1.)),1.4)*.3);\n    } else {\n\t\tc = mix(vec3(1., .2, 0.), vec3(.1, .3, .8), m+.05)*(pow(fnoise(p),2.6)*2.+.3); //hsv2rgb(vec3(.1+m*.2, 1.3, .9));\n    }\n     \n    \n    \n    float dif = clamp( dot( nor, l ), 0.0, 1.0 );\n   \tfloat fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    \n    vec3 v = vec3(0.);\n    v += .6*vec3(dif);\n    v += .3*fre*vec3(.6, .7, .8);\n \treturn c*v;\n}\n\nvec4 pixel(vec2 pxx)\n{\n    float pxl=4.0/size.y;//find the pixel size\n\tfloat tim=time*0.08+(iMouse.x/size.x)*5.;\n\t\n\t//position camera\n\tvec3 ro=vec3(cos(tim),0.5+(iMouse.y/size.y)*2.-1.,sin(tim))*50.4;\n\tvec3 rd=normalize(vec3((2.0*pxx-size.xy)/size.y,2.0));\n\trd=lookat(-ro,vec3(0.0,1.0,0.0))*rd;\n\t//ro=eye;rd=normalize(dir);\n\tvec3 bcol=vec3(1.0);\n\t//march\n\t\n\tfloat t=DDE(ro,rd).y*rndStart(pxx),d,od=1.0;\n    bool hit = false;\n\tfor(int i=0;i<240;i++){\n\t\tvec2 v=DDE(ro+rd*t,rd);\n\t\td=v.x;\n\t\tfloat px=pxl*(1.0+t);\n\t\tif(d<px){\n            hit = true;\n            break;\n\t\t}\n\t\tod=d;\n\t\tt+=v.y;//d;\n\t\tif(t>150.0)break;\n\t}\n    return hit ? vec4(compute_color(ro, rd, t), 1.) : \n    \t\t\t vec4(vec3(.01 + pow(hash13(rd), 3000.)), 1.) ;//hsv2rgb(vec3(.45, 1., rd.y*.7 + .5)).xyzz*.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 xy = (fragCoord.xy/size.xy);\n\tfloat v = .6 + 0.4*pow(20.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.5);\n\tfragColor=pow(pixel(fragCoord.xy)*v, vec4(1./2.2));\n\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlsXRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlsXRr", "name": "Chinese Puzzle Balls", "author": "dr2", "description": "Chinese Puzzle Balls (no ivory and no decorations).", "tags": ["raymarching", "shapes"], "likes": 10, "viewed": 737, "date": "1434119244", "time_retrieved": "2024-06-20T18:22:00.318187", "image_code": "// \"Chinese Puzzle Balls\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Octavio Good's \"Protophore\" got me thinking about this.\n\nconst float pi = 3.14159;\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  vec2 q = vec2 (length (p.xy) - rc, p.z);\n  return length (q) - ri;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float k)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / k, 0., 1.);\n  return mix (b, a, h) - k * h * (1. - h);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat aSpin, sHole, redFac, tCur;\nint idObj;\nconst float dstFar = 100.;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float cLen, rad, smVal, dMin, d, aRot, r;\n  dMin = dstFar;\n  rad = 1.;\n  smVal = 0.02;\n  q = p;\n  d = PrTorusDf (q.xzy, 0.03 * rad, 1.02 * rad);\n  if (d < dMin) { dMin = d;  idObj = 11; }\n  q.xz = abs (q.xz) - 0.707 * 1.02 * rad;\n  cLen = 0.7;\n  q.y -= - cLen;\n  d = PrCylDf (q.xzy, 0.03, cLen);\n  if (d < dMin) { dMin = d;  idObj = 11; }\n  aRot = 1.5 * aSpin;\n  q = p;\n  for (int j = 0; j < 10; j ++) {\n    r = length (q);\n    d = max (r - rad, - (r - 1.03 * redFac * rad));\n    d = - SmoothMin (- d, length (abs (q) - 0.5 * rad) - rad * sHole, smVal);\n    if (d < dMin) { dMin = d;  idObj = j; }\n    q = q.yzx;\n    q.xz = Rot2D (q.xz, aRot);\n    rad *= redFac;\n    smVal *= redFac;\n    aRot *= 1.23;\n  }\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    float d = 0.3 * float (j + 1) / 8.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return clamp (1. - 0.6 * ao, 0., 1.);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float d, h;\n  d = 0.;\n  for (int j = 0; j < 100; j ++) {\n    h = ObjDf (ro + d * rd);\n    d += h;\n    if (h < 0.001 || d > dstFar) break;\n  }\n  return d;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float d, h, sh;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, 20. * h / d);\n    d *= 1.04;\n    if (h < 0.0001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ltDir, col, bgCol, vn;\n  float dstHit, ts, amb, bAmb, fi, c, sh, bk;\n  int idObjT;\n  ts = fract (tCur * 0.333 + 0.125) - 0.25;\n  aSpin = 0.1 * (tCur + max (0., ts) - 3. * min (0., ts));\n  sHole = clamp (1.1 + sin (tCur * 0.4), 0.17, 0.51);\n  redFac = 0.87;\n  dstHit = dstFar;\n  dstHit = ObjRay (ro, rd);\n  ltDir = normalize (vec3 (0.2, 1., -0.1));\n  col = vec3 (0.);\n  bAmb = 1.;\n  idObjT = idObj;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    amb = ObjAO (ro, vn);\n    rd = reflect (rd, vn);\n    if (idObjT <= 10) {\n      fi = 0.1 * float (idObjT);\n      col = HsvToRgb (vec3 (fi, 1., 1.));\n    } else {\n      col = vec3 (0.5, 0.5, 0.);\n    }\n    bk = max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.);\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.2 + 0.2 * bk +\n       sh * 0.8 * max (dot (vn, ltDir), 0.)) +\n       sh * 0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n    bAmb = 0.2 * amb;\n  }\n  c = (rd.y > max (abs (rd.x), abs (rd.z * 0.25))) ? min (2. * rd.y, 1.) :\n     0.05 * (1. + dot (rd, ltDir));\n  if (rd.y > 0.) c += 0.5 * pow (clamp (1.05 - 0.5 *\n     length (max (abs (rd.xz / rd.y) - vec2 (1., 4.), 0.)), 0., 1.), 6.);\n  bgCol = vec3 (0.5, 0.5, 1.) * c + 2. * vec3 (1., 0.8, 0.9) *\n     (clamp (0.0002 / (1. - abs (rd.x)), 0., 1.) +\n      clamp (0.0002 / (1. - abs (rd.z)), 0., 1.));\n  col += bAmb * bgCol;\n  return sqrt (clamp (col, 0., 1.));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mat3 vuMat;\n  vec3 ro, rd, ca, sa;\n  float el, az;\n  az = 0.25 * pi - 0.1 * tCur;\n  el = 0.4 + 0.1 * sin (0.3 * tCur);\n  ca = cos (vec3 (el, az, 0.));\n  sa = sin (vec3 (el, az, 0.));\n  vuMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  rd = normalize (vec3 (uv, 4.)) * vuMat;\n  ro = vec3 (0., 0., -5.) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlsXRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlXGzB", "name": "Edge of atmosphere", "author": "ruba", "description": "Use mouse to look around. Press 'm' to change view.", "tags": ["noise", "planet", "stars", "scattering"], "likes": 63, "viewed": 3498, "date": "1433173893", "time_retrieved": "2024-06-20T18:22:01.419070", "image_code": "/*\n* created by dmytro rubalskyi (ruba)\n*\n* all values are in kilometers\n*\n* references: \n*\n* http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\n* \n* http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n*\n* http://www-evasion.imag.fr/people/Eric.Bruneton/\n*\n* https://software.intel.com/en-us/blogs/2013/09/19/otdoor-light-scattering-sample-update\n*\n*/\n\n#define M_MAX 1e9\n#define KEY_M (float(77)+0.5)/256.0\n\nconst float M_PI = 3.1415926535;\nconst float M_4PI = 4.0 * M_PI;\n\n///////////////////////////////////////\n// planet\nconst float earthRadius \t= 6360.0;\nconst float atmoHeight \t\t= 60.0;\nconst float atmoRadius \t\t= earthRadius + atmoHeight;\nconst vec3 earthCenter \t\t= vec3(0.0, 0.0, 0.0);\n\n///////////////////////////////////////\n// sun\nconst float distanceToSun = 1.496e8;\nconst float sunRadius = 2.0 * 109.0 * earthRadius;\nconst float sunIntensity = 10.0;\n\n///////////////////////////////////////\n// atmosphere\nconst vec3 betaR \t\t\t= vec3(5.8e-4, 1.35e-3, 3.31e-3);\nconst vec3 betaM \t\t\t= vec3(4.0e-3, 4.0e-3, 4.0e-3);\n\nconst vec3 M_4PIbetaR\t \t= M_4PI * betaR;\nconst vec3 M_4PIbetaM \t\t= M_4PI * betaM;\n\nconst float heightScaleRayleight = 6.0;\nconst float heightScaleMie = 1.2;\nconst float g = -0.76;\n\nconst float NUM_DENSITY_SAMPLES = 8.0;\nconst float NUM_VIEW_SAMPLES = 8.0;\nconst int \tINT_NUM_DENSITY_SAMPLES = int(NUM_DENSITY_SAMPLES);\nconst int\tINT_NUM_VIEW_SAMPLES = int(NUM_VIEW_SAMPLES);\n\n///////////////////////////////////////\n// ray - sphere intersection\nvec2 iSphere(vec3 ro, vec3 rd, vec4 sph)\n{\n    vec3 tmp = ro - sph.xyz;\n\n    float b = dot(rd, tmp);\n    float c = dot(tmp, tmp) - sph.w * sph.w;\n    \n    float disc = b * b - c;\n    \n    if(disc < 0.0) return vec2(-M_MAX, -M_MAX);\n    \n    float disc_sqrt = sqrt(disc);\n\t\n    float t0 = -b - disc_sqrt;\n    float t1 = -b + disc_sqrt;\n    \n    return vec2(t0, t1);\n}\n\n///////////////////////////////////////\n// Henyey-Greenstein phase function\nfloat phase(float nu, float g)\n{\n\treturn (3.0 * (1.0 - g * g) * (1.0 + nu * nu)) / (2.0 * (2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * nu, 1.5));\n}\n\n///////////////////////////////////////\n// density integral calculation from p0 to p1 \n// for mie and rayleight\nvec2 densityOverPath(vec3 p0, vec3 p1, vec2 prescaler)\n{\n    float l = length(p1 - p0);\n    vec3  v = (p1 - p0) / l;\n    \n    l /= NUM_DENSITY_SAMPLES;\n    \n    vec2 density = vec2(0.0);\n    float t = 0.0;\n    \n\tfor(int i = 0; i < INT_NUM_DENSITY_SAMPLES; i++)\n    {\n        vec3 sp = p0 + v * (t + 0.5 * l);\n        vec2 h = vec2(length(sp) - earthRadius);\n        density += exp(-h / prescaler);\n        \n        t += l;\n    }\n    \n    return l * density;\n}\n\n///////////////////////////////////////\n// inscatter integral calculation\nvec4 inscatter(vec3 cam, vec3 v, vec3 sun)\n{    \n    vec4 atmoSphere \t= vec4(earthCenter, atmoRadius);\n    vec4 earthSphere \t= vec4(earthCenter, earthRadius);\n        \n\tvec2 t0 = iSphere(cam, v, atmoSphere);\n    vec2 t1 = iSphere(cam, v, earthSphere);\n   \n    bool bNoPlanetIntersection = t1.x < 0.0 && t1.y < 0.0;\n    \n    float farPoint = bNoPlanetIntersection ? t0.y : t1.x;\n    float nearPoint = t0.x > 0.0 ? t0.x : 0.0;\n    \n    float l = (farPoint - nearPoint) / NUM_VIEW_SAMPLES;\n\tcam += nearPoint * v;  \n    \n    float t = 0.0;\n\n    vec3 rayleight = vec3(0.0);\n\tvec3 mie = vec3(0.0);\n    \n    vec2 prescalers = vec2(heightScaleRayleight, heightScaleMie);\n    \n    vec2 densityPointToCam = vec2(0.0);\n    \n    for(int i = 0; i < INT_NUM_VIEW_SAMPLES; i++)\n    {\n        vec3 sp = cam + v * (t + 0.5 * l);\n        float tc = iSphere(sp, sun, vec4(earthCenter, atmoRadius)).y;\n        \n        vec3 pc = sp + tc * sun;\n        \n        vec2 densitySPCam = densityOverPath(sp, cam, prescalers);\n        vec2 densities = densityOverPath(sp, pc, prescalers) + densitySPCam;\n        \n        vec2 h = vec2(length(sp) - earthRadius);\n        vec2 expRM = exp(-h / prescalers);\n        \n        rayleight \t+= expRM.x * exp( -M_4PIbetaR * densities.x );\n\t\tmie \t\t+= expRM.y * exp( -M_4PIbetaM * densities.y );\n\n\t\tdensityPointToCam += densitySPCam;\n        \n        t += l;\n    }\n    \n\trayleight *= l;\n    mie *= l;\n    \n    vec3 extinction = exp( - (M_4PIbetaR * densityPointToCam.x + M_4PIbetaM * densityPointToCam.y));\n    \n    float nu = dot(sun, -v);\n    \n    vec3 inscatter_ = sunIntensity * (betaM * mie * phase(nu, g) + betaR * phase(nu, 0.0) * rayleight);\n    return vec4(inscatter_, extinction.r * float(bNoPlanetIntersection));\n}\n\n///////////////////////////////////////\n// rotation around axis Y\nvec3 rotate_y(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\n///////////////////////////////////////\n// noise from iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0) * p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv + 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sc = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    sc.x *= iResolution.x / iResolution.y;\n    \n    vec3 mouse = 4.0 * vec3(2.0 * iMouse.xy / iResolution.xy - 1.0,0.0);\n    \n    vec3 ro = vec3(0.0);\n    \n    bool key_m = texture(iChannel1, vec2(KEY_M, 0.75)).x > 0.0;\n   \tro = key_m ?\t2.0 * vec3(earthRadius * sin(mouse.x), 0.0, earthRadius * cos(mouse.x)): \n    \t\t\t\tvec3(0.0, earthRadius + 0.1, 1000.0 * abs(cos(iTime / 10.0)));\n    \n    vec3 rd = normalize(rotate_y(vec3(sc, 1.2), M_PI - mouse.x));\n    \n    vec3 sun = normalize(vec3(1.0, 1.0, 1.0));\n    \n    vec4 col = inscatter(ro, rd, sun);\n    \n    vec3 sunPos = sun * distanceToSun;\n    \n    vec4 star = vec4(sunPos, sunRadius);\n    vec2 t0 = iSphere(ro, rd, star);\n    \n    if(t0.x > 0.0)\n    {\n    \tcol.xyz += vec3(1.0,1.0,1.0) * col.a;\n    }\n    \n    vec3 stars = vec3(noise(rd * iResolution.y * 0.75));\n    stars += vec3(noise(rd * iResolution.y * 0.5));\n    stars += vec3(noise(rd * iResolution.y * 0.25));\n    stars += vec3(noise(rd * iResolution.y * 0.1));\n    stars = clamp(stars, 0.0, 1.0);\n    stars = (vec3(1.0) - stars);\n    \n    col.xyz = col.xyz + stars * col.a;\n    col.xyz = pow(col.xyz, vec3(1.0 / 2.2));\n    \n    fragColor = col;\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXGzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlXSzn", "name": "maelstrom", "author": "FabriceNeyret2", "description": ".", "tags": ["noise"], "likes": 23, "viewed": 1419, "date": "1433878535", "time_retrieved": "2024-06-20T18:22:01.425316", "image_code": "\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\nvec2 sfbm2( vec3 p ) {\n    return 2.*vec2(fbm(p),fbm(p-327.67))-1.;\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (iMouse.z<0.) \n         mouse = vec2(.9,.5)*vec2(cos(1.*t)+.5*sin(2.2*t),sin(1.1*t)+.5*cos(1.9*t))/1.5;   \n    else \n         mouse = 2.*mouse-1.;\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.9,.5));\n    float a = .5*t, c=cos(a), s=sin(a); uv *= mat2(c,-s,s,c);\n    \n    vec4 col=vec4(0.);\n    vec3 paint = vec3(.3,.9,.7);\n    \n    int i=0; for(float z=0.; z<1.; z+= 1./30.) {\n        vec2 duv = vec2(.8,.5)*sfbm2(vec3(1.2*uv,3.*z+t)) - 3.*z*mouse;\n    \tfloat d = abs(length(uv+duv)-1.2*(1.-z)),\n              a = smoothstep(.2,.19,d); \n        d = a-.5*smoothstep(.18,.17,d)+.5*smoothstep(.02,.01,d);\n        col += (1.-col.a)*vec4(d*paint*exp(-3.*z),a);\n        if (col.a>=.9) break;\n        // nemo ;-) if (i++==5) { d=smoothstep(.1,.09,length(vec2(1.,2.)*(uv+2.*z*mouse))); col += (1.-col.a)*d*vec4(1.,.5,0.,1.);}\n    }\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlXXR7", "name": "Walking spider", "author": "cedric", "description": "2015: i coded this a year ago on linux and it was causing the world to crash. I am now on windows and it seems to run smooth so i give it a new try here.\n2018: on a visit here to correct others shaders, new try to publish this one :-)", "tags": ["perlin", "walk"], "likes": 5, "viewed": 187, "date": "1435134444", "time_retrieved": "2024-06-20T18:22:01.425316", "image_code": "//\n//\n// Spider by cedric voisin 2014\n//\n//\n\n#define PI 3.14\n#define maxH 1.5\n\nstruct leg {\n\tvec3 pHip, pKnee, pAnkle, pFoot;\n\tvec2 rp; // (cosp, sinp)\n};\nleg legs[8];\n\n// perlin\n\nfloat r(vec2 c){\n\treturn fract(sin(dot(c ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat pn (vec2 p){\n\tp/=2.;\n    vec2 i = floor(p), w = fract(p), j = vec2(1.,0.);\n    w = w*w*(3.-2.*w);\n    return mix(mix(r(i), r(i+j), w.x), mix(r(i+j.yx), r(i+1.), w.x), w.y);\n}\n\nfloat an (vec2 p){\n\tconst int n=7;\n\tfloat m = 0., f = 1.;\n\tfor ( int i=0; i<n; i++ ){ m += pn(f*p)/f; f*=2.; }\n\treturn m/(2.-pow(.5,float(n)));\n}\n\n// primitive (from iq's website)\nfloat deC(vec3 p, vec3 a, vec3 b, float r){\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// leg\nfloat deLeg(vec3 p){\n\tfloat sil = 1000.;\n\tfor (int i=0;i<8;i++){\n    \tsil = min(sil, deC(p, legs[i].pHip, legs[i].pKnee, .03));\n    \tsil = min(sil, deC(p, legs[i].pKnee, legs[i].pAnkle, .02));\n    \tsil = min(sil, deC(p, legs[i].pAnkle, legs[i].pFoot, .01));\n\t}\n\treturn sil;\n}\n\nvec3 norLeg(vec3 p){\n\tvec3 dp = vec3(.0001,0.,0.);\n\tvec3 n=normalize(vec3(deLeg(p+dp.xyy),deLeg(p+dp.yxy),deLeg(p+dp.yyx))); \n\treturn n;\n}\n\nfloat field(vec2 f){return maxH*pn(f);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// global\n\tvec2 xy = -2.5 + 5.*fragCoord.xy / iResolution.xy;\n\txy.y *= iResolution.y/iResolution.x;\n\t\n\t// time\t\n\tfloat camTime = .03*iTime;\n\tfloat spiTime = (iTime+cos(.5*iTime)+cos(.4*iTime));\n\t\n\t// spider main\n\tvec3 pSpi, pAbdo;\n\tfloat rBody, rAbdo, rf;\n\trBody = .2;\n\tpSpi = vec3(spiTime,0.,0.);;\n\tpSpi.z = .2+rBody+field(pSpi.xy);\n\t\t\n\t// sun\n\tvec3 pSun = pSpi+vec3(100.*sin(.2*camTime),100.*cos(.2*camTime),100.);\n\t\n\t// cam\n\tfloat xCam, yCam, zCam;\n\tvec3 pCam, nCam, uCam, rCam, pEye;\n\txCam = pSpi.x + 5. * sin(6.*camTime);\n\tyCam = pSpi.y - 5. * cos(6.*camTime);\n\tzCam = max(7. + 2.*cos(camTime-5.), .2+field(vec2(xCam, yCam)) );\n\t//zCam = 4.;\n\t\n\tpEye = vec3(xCam, yCam, zCam);\n\tnCam = normalize(pSpi-pEye);\n\trCam = normalize(vec3(nCam.y,-nCam.x,0.));\n\tuCam = cross(rCam,nCam);\n\tpCam = pEye + 5.*nCam;\n\t\n\t// spider parts\n\t// abdomen\n\trAbdo = 1.7*rBody;\n\tvec3 oldPos = vec3(spiTime-.05,0.,0.);\n\toldPos.z = .22+rBody+field(oldPos.xy);\n\tpAbdo = pSpi-(rBody+rAbdo)*normalize(pSpi - oldPos);\n\t\n\t// directions\n\tvec3 spiF, spiL, spiU;\n\tspiF = normalize(pSpi - pAbdo);\n\tspiL = normalize(vec3(-spiF.y,spiF.x,0.));\n\tspiU = cross(spiF, spiL);\n\t\n\t// eyes co(-pi/32), sin(-pi/32), sin(pi/5)\n\tvec3 pOcelli[2];\n\tpOcelli[0] = pSpi + .7*rBody*spiF + rBody*.1*spiL + rBody*.8*spiU;\n\tpOcelli[1] = pSpi + .7*rBody*spiF - rBody*.1*spiL + rBody*.8*spiU;\n\t\n\t//legs a=hip->knee, b=knee->ankle, c=ankle->foot\n\trf = rBody + 1.35; // 1.35 = leg span\n\tfloat a=.9, b=1., f=.35;\n\n\tfloat rcosp, rsinp, cosa, dt, tf, tc, to, tPct, c;\n\tvec2 pf;\n\tvec3 base, up;\n\t\n\t//defined manually to get them out of the loop and avoid cos/sin calls\n\tlegs[0].rp =  vec2(-.588,-.809); // vec2(cos(-PI/5.-3.*PI/6.),sin(-PI/5.-3.*PI/6.));\n\tlegs[1].rp =  vec2(-.105,-.995); // vec2(cos(-PI/5.-2.*PI/6.),sin(-PI/5.-2.*PI/6.));\n\tlegs[2].rp =  vec2(.407,-.914); // vec2(cos(-PI/5.-PI/6.),sin(-PI/5.-PI/6.));\n\tlegs[3].rp =  vec2(.809, -.588); // vec2(cos(-PI/5.),sin(-PI/5.));\n\tlegs[4].rp =  vec2(.809,.588); // vec2(cos(PI/5.),sin(PI/5.));\n\tlegs[5].rp =  vec2(.407,.914); // vec2(cos(PI/5.+PI/6.),sin(PI/5.+PI/6.));\n\tlegs[6].rp =  vec2(-.105,.995); // vec2(cos(PI/5.+2.*PI/6.),sin(PI/5.+2.*PI/6.));\n\tlegs[7].rp =  vec2(-.588,.809); // vec2(cos(PI/5.+3.*PI/6.),sin(PI/5.+3.*PI/6.));\n\t\n\tfor (int i=0;i<8;i++){\n\t\t\n\t\t// hip\t\n\t\tlegs[i].pHip = pSpi + rBody*legs[i].rp.x*spiF + rBody*legs[i].rp.y*spiL;\n\n\t\t// foot\n\t\tdt = mod(float (i),2.)*.5;\n\t\ttf = spiTime+dt+.3; // .3 = how much foot precedes body (tuning)\n\t\ttc = fract(tf);\n\t\tto = floor(tf);\n\t\trcosp = rf*legs[i].rp.x;\n\t\trsinp = rf*legs[i].rp.y;\n\t\t\n\t\t// cycle: .67s on the ground, .33s to catch up\n\t\tif (tc < .67){\n\t\t\tpf = vec2(to-dt+rcosp,rsinp);\n\t\t\tlegs[i].pFoot = vec3(pf, field(pf));\n\t\t} else {\n\t\t\ttPct = (tc-.67)/.33;\n\t\t\tpf = vec2(to-dt+tPct*tc+rcosp,rsinp);\n\t\t\tlegs[i].pFoot = vec3(pf, field(pf.xy)+2.5*tPct*(1.-tPct)); // parabola 2.5~step height\n\t\t}\n\t\t\n\t\t// ankle: cos(foot angle) ~ distance from the hip\n\t\tbase = legs[i].pHip-legs[i].pFoot;\n\t\tup = normalize(cross(vec3(base.y,-base.x,0.),base));\n\t\tcosa = cos( 2.8*(1.-length(base)/(a+b+f)) ); // amax+base*(amin-amax)/(a+b+f), amin = 0, amax=2.8\n\t\tlegs[i].pAnkle = legs[i].pFoot + cosa*f*normalize(base) + sqrt(1.-cosa*cosa)*f*up; \n\n\t\t// knee\t(triangle)\n\t\tbase = legs[i].pAnkle - legs[i].pHip;\n\t\tup = normalize(cross(vec3(base.y,-base.x,0.),base));\n\t\tc = length(base);\n\t\tcosa = (a*a+c*c-b*b)/(2.*a*c);\n\t\tlegs[i].pKnee = legs[i].pHip + cosa*a*normalize(base) + sqrt(1.-cosa*cosa)*a*up;\n\t}\n\t\n\t// virtual screen\n\tvec3 pStart = pCam+xy.x*rCam+xy.y*uCam;\n\tvec3 dir = normalize(pStart-pEye);\n\t\n\t// ray march\n\tint idI = 0; //Background 0, Terrain 1, Body 2, Abdo 3, Leg 4, eyes 5\n\tfloat eps = .001, fov = 30., de = fov, si = 10.*fov, shad = 1., s = 0., h = 1.;\n\tvec3 npi = -dir, pi = pEye, dp = vec3(.0001,0.,0.);\n\tfloat dpx, dpy;\n\t\n\tfor (int i=0; i<150; i++){\n\t\t\t\n\t\t// body\n\t\tde = min(de, clamp(length(pi-pSpi)-rBody,eps,fov));\n\t\tif (de == eps) {si = s; idI = 2; break;}\n\t\t// abdomen\n\t\tde = min(de, clamp(length(pi-pAbdo)-rAbdo,eps,fov));\n\t\tif (de == eps) {si = s; idI = 3; break;}\n\t\t// eyes\n\t\tde = min(de, clamp(length(pi-pOcelli[0])-.1*rBody,eps,fov));\n\t\tif (de == eps) {si = s; idI = 5; break;}\n\t\tde = min(de, clamp(length(pi-pOcelli[1])-.1*rBody,eps,fov));\n\t\tif (de == eps) {si = s; idI = 5; break;}\n\t\t// legs\t\n\t\tde = min(de, clamp(deLeg(pi),eps,fov));\n\t\tif (de == eps) {si = s; idI = 4; break;}\n\t\t// terrain\n\t\th = pi.z - field(pi.xy);\n\t\tif (h<.01) {si = s; idI = 1; break;}\n\t\t\n\t\ts += min(de,.5*h);\n\t\tif (s > fov) break;\n\t\tpi = pEye + dir*s;\n\n\t}\t\n\t\n\t// common colors\n\tvec3 col, co, li;\n\tvec3 colSky = vec3(.8,.7,.6);\n\tvec3 colSun = vec3 (1.,1.,.7);\n\t\n\t// illuminations\n\tif (idI == 0){ // background\n\t\t\n\t\t//base\n\t\tco = vec3(0.,0.,0.);\n\t\tfloat vGrad=clamp(1.5-fragCoord.y / iResolution.y,0.,1.);\n\t\tco += vGrad*colSky;\n\t\t\n\t\t// lightning\n\t\tli = vec3(0.,0.,0.);\n\t\tfloat sunGrad = 1.+dot(normalize(pSun-pEye), normalize(pi-pEye) );\n\t\tli += (1.+sunGrad)*colSun;\n\t\t\n\t\tcol = co*li;\n\t}\n\t\n\tif (idI == 1){ // terrain\n\t\tdpx = maxH * (an(pi.xy+dp.xy)-an(pi.xy-dp.xy)) / (2.*dp.x);\t\t\t\t\t\t\t  \n\t\tdpy = maxH * (an(pi.xy+dp.yx)-an(pi.xy-dp.yx)) / (2.*dp.x);\n\t\tnpi = normalize( vec3(-dpx, -dpy, 1.) );\t\n\t\tpi = pEye + dir*si;\n\t\t\n\t\t// base\n\t\tco = vec3(0.,0.,0.);\n\t\tvec3 colField = vec3(.62,.6,.6);\n\t\tco += colField;\n\t\t\n\t\t// occlusion\n\t\tfloat iOcc = npi.z;\n\t\t\n\t\t// spider occlusion\n\t\tfloat sOcc = smoothstep(0., .8, length(pi-.5*pSpi-.5*pAbdo)/rf );\n\t\t\n\t\t// lightning\n\t\t// spider shadows\n\t\tfloat sShad = 1., tShad = 1.;\n\t\tdir = normalize(pSun-pi);\n\t\tde = fov;\n\t\tvec3 ps = pi;\n\t\ts = 0.;\n\t\tfor (int i=0; i<50; i++){\n\t\t\ttShad = 1.;\n\t\t\t// body\n\t\t\tde = min(de, clamp(length(ps-pSpi)-rBody,eps,fov));\n\t\t\tde = min(de, clamp(length(ps-pAbdo)-rAbdo,eps,fov));\n\t\t\tde = min(de, clamp(deLeg(ps),eps,fov));\n\t\t\t\n\t\t\ts += de;\n\t\t\tif (ps.z > pSpi.z+5.) break;\n\t\t\tps = pi + dir*s;\n\t\t\ttShad = min(tShad, 60.*de/s);\n\t\t\tsShad *= tShad;\n\t\t}\t\n\t\t\n\t\tfloat iDif = dot(npi,normalize(pSun-pi));\n\n\t\tli = vec3(0.,0.,0.);\n\t\tli += iDif*colSun;\n\t\tli *= sShad;\n\t\tli *= sOcc;\n\t\tli += .8*iOcc*colSky;\n\t\t\n\t\tcol = co*li;\n\t}\n\t\n\tif (idI == 2){ // body\n\t\tnpi = normalize(pi-pSpi);\n\n\t\t// base\n\t\tco = vec3(0.,0.,0.);\n\t\tvec3 colBase = vec3 (.9,.6,.2);\n\t\tco += colBase;\n\t\t\t\n\t\t// dark below\n\t\tco = mix(.4*colBase, co,smoothstep(-.4,1.,dot(npi,spiU)) );\n\t\t\n\t\t// occlusion\n\t\tfloat iOcc = .5 + .5*dot(npi,spiF);\n\t\t\n\t\t// lightning\n\t\tfloat iAmb = .5+.5*npi.z;\n\t\tfloat iDif = .5+.5*dot(npi,normalize(pSun-pi));\n\t\t\n\t\tli = vec3(0.,0.,0.);\n\t\tli += iDif*colSun;\n\t\tli += .2*iAmb*colSky;\n\t\tli *= iOcc;\n\n\t\tcol = 2.*co*li;\n\t}\n\t\n\tif (idI == 3){ // abdomen\n\t\tvec3 piInA = vec3(dot(pi-pAbdo,spiF), dot(pi-pAbdo,spiL), dot(pi-pAbdo,spiU));\n\t\tnpi = normalize(pi-pAbdo);\n\n\t\t// base\n\t\tco = vec3(0.,0.,0.);\n\t\tvec3 colBase = vec3 (.9,.5,.1);\n\t\tco += colBase;\n\t\t\n\t\t// decoration (black)\n\t\tfloat theta = acos(piInA.x/length(piInA));\n\t\tfloat phi = .2+abs(atan(piInA.y, piInA.z)); // abs for symmetry\n\t\tco *= 1.05-smoothstep(.5,.5,an(4.*vec2(theta, phi)));\n\t\tco = mix(.9*colBase, co,smoothstep(-.4,1.,dot(npi,spiU)) );\n\t\t\n\t\t// occlusion\n\t\tfloat iOcc = .5-.5*dot(npi,spiF);\n\t\t\n\t\t// lightning\n\t\tfloat iAmb = .5+.5*npi.z;\n\t\tfloat iDif = dot(npi,normalize(pSun-pi));\n\t\t\n\t\tli = vec3(0.,0.,0.);\n\t\tli += .07*iDif*colSun;\n\t\tli += .2*iAmb*colSky;\n\t\tli *= iOcc;\n\n\t\tcol = 12.*co*li;\n\t}\n\t\n\tif (idI == 4){ // legs\n\t\tnpi = norLeg(pi);\n\t\t\n\t\t// base\n\t\tco = vec3(0.,0.,0.);\n\t\tvec3 colBase = vec3 (.6,.4,.1);\n\t\tco += colBase;\n\t\t\t\n\t\t// black articulations\n\t\tfloat iArt = 2.*rf;\n\t\tfor (int i=0;i<8;i++){\n\t\t\tiArt = min(iArt, length(pi-legs[i].pKnee));\n\t\t\tiArt = min(iArt, length(pi-legs[i].pAnkle));\n\t\t}\n\t\tco *= 10.*iArt*iArt*iArt;\n\t\t\n\t\t// occlusion\n\t\tfloat iOcc = length(pi-pSpi)/rf;\t\n\t\t\n\t\t// lightning\n\t\tfloat iAmb = .5+.5*npi.z;\n\t\tfloat iDif = dot(npi,normalize(pSun-pi));\n\t\t\n\t\tli = vec3(0.,0.,0.);\n\t\tli += iDif*colSun;\n\t\tli += iAmb*colSky;\n\t\tli *= 2.*iOcc;\n\n\t\tcol = co*li;\n\t}\n\t\n\tif (idI == 5){ // eyes\n\t\tcol = vec3(0.,0.,0.);\n\t}\n\t\n\t// fog\n\tvec3 colFog = vec3(.5,.6,.7);\n\tfloat cFog = 1.-smoothstep(.3*fov, fov, length(dir*si))+smoothstep(fov, 1.1*fov,length(dir*si));\n    col = mix(colFog, col, cFog );\n\n\tcol = clamp(col,0.,1.);\n\tfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXXR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlXXz8", "name": "Playing with FBM", "author": "Lallis", "description": "Playing around with some linear value noise FBM.\nEDIT: Added some gradient color.", "tags": ["noise", "fbm", "linear", "value"], "likes": 11, "viewed": 572, "date": "1434291860", "time_retrieved": "2024-06-20T18:22:01.425316", "image_code": "#define time iTime\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,126.7378))) * 43758.5453)*2.0-1.0;\n}\n\nfloat linear3D(vec3 p)\n{\n\tvec3 p0 = floor(p);\n\tvec3 p1x = vec3(p0.x+1.0, p0.y, p0.z);\n\tvec3 p1y = vec3(p0.x, p0.y+1.0, p0.z);\n\tvec3 p1z = vec3(p0.x, p0.y, p0.z+1.0);\n\tvec3 p1xy = vec3(p0.x+1.0, p0.y+1.0, p0.z);\n\tvec3 p1xz = vec3(p0.x+1.0, p0.y, p0.z+1.0);\n\tvec3 p1yz = vec3(p0.x, p0.y+1.0, p0.z+1.0);\n\tvec3 p1xyz = p0+1.0;\n\t\n\tfloat r0 = noise3D(p0);\n\tfloat r1x = noise3D(p1x);\n\tfloat r1y = noise3D(p1y);\n\tfloat r1z = noise3D(p1z);\n\tfloat r1xy = noise3D(p1xy);\n\tfloat r1xz = noise3D(p1xz);\n\tfloat r1yz = noise3D(p1yz);\n\tfloat r1xyz = noise3D(p1xyz);\n\t\n\tfloat a = mix(r0, r1x, p.x-p0.x);\n\tfloat b = mix(r1y, r1xy, p.x-p0.x);\n\tfloat ab = mix(a, b, p.y-p0.y);\n\tfloat c = mix(r1z, r1xz, p.x-p0.x);\n\tfloat d = mix(r1yz, r1xyz, p.x-p0.x);\n\tfloat cd = mix(c, d, p.y-p0.y);\n\t\n\t\n\tfloat res = mix(ab, cd, p.z-p0.z);\n\t\n\treturn res;\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f = 0.5000*linear3D(p*1.0); \n\t\t  f+= 0.2500*linear3D(p*2.01); \n\t\t  f+= 0.1250*linear3D(p*4.02); \n\t\t  f+= 0.0625*linear3D(p*8.03);\n\t\t  f/= 0.9375;\n\treturn f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\tuv.x*=1.78;\n\tfloat ang = time*0.1;\n    mat2 rot = mat2(cos(ang),-sin(ang),sin(ang),cos(ang));\n\tuv*=16.0*(sin(time*0.1)+1.5)*rot;\n\t\n\tfloat f = fbm(vec3(uv,time)+fbm(vec3(uv,time)+fbm(vec3(uv,time))))*0.5+0.5;\n    \n    vec3 col, col2;\n    col = vec3(fbm(vec3(uv*f*0.3,time*0.75)));\n    col2 = col;\n    \n\tcol *= vec3((sin(time*0.2)*0.5+1.5),1.0,0.6);\n    col +=  vec3(0.1,0.7,0.8)*f;\n    \n    col2 *= vec3(0.9,1.0,(sin(time*0.2)*0.5+1.5));\n    col2 += vec3(0.8,0.5,0.1)*f;\n    \n\tcol = mix(col, col2, smoothstep(-50.0,50.0,uv.x));\n    \n    col *= mix(0.5,sin(time*0.5)*0.25+1.0,length(col));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXXz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt2GWt", "name": "Procedural Houndstooth", "author": "ChristinaCoffin", "description": "example of how to create a procedural texture by breaking it down to its basic components and layering them to create vector pattern shapes.", "tags": ["procedural", "2d"], "likes": 10, "viewed": 537, "date": "1433619483", "time_retrieved": "2024-06-20T18:22:01.988987", "image_code": "// Procedural Houndstooth shader\n// \ttutorial of one way to combine multiple procedural shapes without using if() branches\n// \tto create a complex pattern.\n//\n// by @christinacoffin\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// for application as a procedural texture on 3d obj+environment,\n//\tyou'd need to supersample+filter the results of Houndstooth() function.\n// a good article on that can be found here:\n//\thttp://iquilezles.org/www/articles/filtering/filtering.htm\n \nfloat Houndstooth( vec2 uv_A )\n{\n    // generate working vars for 2x2 checker shape\n    float sub_A = step(uv_A.x, 0.5);\n    float sub_B = step(1.0-uv_A.y, 0.5);\n    float sub_C = max(sub_A,sub_B);// L shape black\n    float sub_D = min(sub_A,sub_B);// L shape black (inverted)\n    float sub_E = 1.0-sub_C;// corner\n    \n    float stripe_A =  step( (uv_A.x) + (uv_A.y),  0.25 ); \n    float stripe_B =  step( (uv_A.x) + (uv_A.y),  0.5 ); \n    float stripe_C =  step( (uv_A.x) + (uv_A.y),  0.75 ); \n\n    float stripe_F =  step( (uv_A.x-0.5) + (uv_A.y-0.5),  0.25 );\n    float stripe_G =  step( (uv_A.x-0.5) + (uv_A.y-0.5),  0.5 );\n    float stripe_H =  step( (uv_A.x-0.5) + (uv_A.y-0.5),  0.75 );    \n    \n\t// build diagonal parts as 3 bands and generate that before mixing in the square quadrants.\n    \n    // subtracting the results of a stepfunction with a lower threshold value from a higher one\n    //\tcreates a square wave function that we use to create the diagonal bands    \n    \n    // a good reference to visualize step+pulse functions and mixing them can be found here:\n    //\thttp://realtimecollisiondetection.net/blog/?p=95    \n    \n    // 1st band\n    float lum = (stripe_B  - stripe_A);\n    // larger inner diagonal\n    lum +=\t(stripe_F  - stripe_C);\n    // 3rd band\n    lum +=\t(stripe_H  - stripe_G);\n    \n    // put the black+white squares in the diagonal quadrants 'on top' to finish the pattern\n    lum += sub_E;// top diag corner white  \n    lum -= sub_D;// upper left corner black    \n    \n    return clamp(lum , 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = iTime;// animated rotation over time.\n  \n\tvec2 uv;\n    vec2 vignetteUV;\n    uv = fragCoord.xy / iResolution.xy;\n    vignetteUV = uv;// copy UV for vignette code\n    \n    vec4 animFragColor;\n    animFragColor = vec4(fract(uv),0.5+0.5*sin(iTime),1.0);\n    \n    uv.xy += vec2( -.5, -.5);// offset uv so it rotates in the center of screen\n    uv.x /= iResolution.y/iResolution.x;// aspect correct\n    uv *= 6.0;// tiling factor of pattern\n\n\t// rotate UV space\n    vec2 rotCoord;\n    rotCoord.x = uv.x * cos(angle) + uv.y * sin(angle);\n    rotCoord.y = uv.x * - sin(angle) + uv.y * cos(angle);    \n      \n    vec2 uv_A = rotCoord;// copy rotated UV\n    uv_A = uv_A - floor(uv_A);// turn the tiled UV coords into 0-1 space for the procedural texture func\n    \n    fragColor.rgb = vec3( Houndstooth( uv_A ) );// 'sample' the procedural texture\n    \n    fragColor.rgb*= animFragColor.rgb;// mul with screen gradient wash color to colorize it \n    \n\t//-----------------------------------------------------\n\t// Vignette\n\tfragColor.rgb *= 0.15 + 0.85*pow( abs(32.0*vignetteUV.x*vignetteUV.y*(1.0-vignetteUV.x)*(1.0-vignetteUV.y)), 0.85 );    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2GWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtBGDd", "name": "2d tests", "author": "rammoskar", "description": "test", "tags": ["2d"], "likes": 0, "viewed": 91, "date": "1433462585", "time_retrieved": "2024-06-20T18:22:01.988987", "image_code": "float dis(vec2 a, vec2 b) {\n    float dx = a.x - b.x;\n    float dy = a.y - b.y;\n\treturn sqrt(dx*dx + dy*dy);\n}\n\nfloat u(float a, float b) {\n    return max(a, b);\n}\n\nfloat circle(vec2 uv, vec2 p, float r) {\n\treturn -1.0 * sign(length(uv - p)  - r);\n}\n\nfloat box( vec2 uv, vec2 p, vec2 s )\n{\n  vec2 res = abs(uv - p) - s;\n  return -1.0 * sign(max(res.x,res.y));\n}\n\nvec2 rot(vec2 uv, float a) {\n    uv -= vec2(0.5, 0.5);\n\tfloat s = sin(a);\n    float c = cos(a);\n    return vec2(uv.x*c + uv.y*s, uv.x*s + uv.y*c) + vec2(0.5, 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime;\n    float hit = u(circle(uv, vec2(0.5 + sin(t*0.75), 0.5 + sin(t)), 0.3),\n                  circle(uv, vec2(0.1 + 0.5*sin(t*0.3), 0.1 + 0.6*cos(t*0.4)), 0.1));\n    hit = u(hit, box(rot(uv, t), vec2(0.5, 0.5), vec2(0.1,0.7)));\n    vec3 col = vec3(1,0,0);\n    \n    float c = max(sin(t*1.0 + uv.x * 20.0), sin(t*1.0 + uv.y * 20.0));\n    hit = max(0.0, hit);\n    c += hit * (0.5 * c + 0.5);\n    vec3 wCol = vec3(c,c,c);\n    \n    \n    wCol.x = max(wCol.x, 0.0);\n    wCol.y = max(wCol.y, 0.0);\n    wCol.z = max(wCol.z, 0.0);\n    \n    col.x = max(col.x, 0.0);\n    col.y = max(col.y, 0.0);\n    col.z = max(col.z, 0.0);\n    \n    \n\tfragColor = vec4(/*col * hit + wCol  * (1.0 - hit)*/wCol, 1.0);\n    \n    \n    vec2 p = vec2(0.5 + sin(iTime*0.1),0.5+ sin(iTime*0.1));\n    vec2 p2 = vec2(0.3+ cos(iTime*0.2),0.7+ sin(iTime*0.15));\n    vec2 p3 = vec2(1.0+ sin(iTime*0.06),1.0+ sin(iTime*0.07));\n\tfragColor += (1.0-hit) * 0.1 * vec4(sin(dis(uv, p3) * 100.0 - 3.0*iTime) + \n                     cos(dis(uv, p2) * 100.0 - 2.0*iTime) + \n                     sin(dis(uv, p) * 100.0 - 1.0*iTime), \n                     \n                     sin(dis(uv, p3) * 100.0 - 3.0*iTime) + \n                     sin(dis(uv, p2) * 100.0 - 2.0*iTime) + \n                     cos(dis(uv, p) * 100.0 - 1.0*iTime), \n                     \n                     sin(dis(uv, p3) * 100.0 - 3.0*iTime) + \n                     sin(dis(uv, p2) * 100.0 - 2.0*iTime) + \n                     sin(dis(uv, p) * 100.0 - 1.0*iTime)\n                     ,1.0);\n    \n    //fragColor += (sign(sin(t*2.0) - 0.9) + 1.0) * 0.5 * 0.5 * vec4(-fragColor.x, 1, -fragColor.z,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtBGDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtfSDr", "name": "Loader001", "author": "mu6k", "description": "I used this as a load screen for some intro :)", "tags": ["loader2d"], "likes": 4, "viewed": 357, "date": "1435692668", "time_retrieved": "2024-06-20T18:22:01.994992", "image_code": "/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. */\n\n#define load (fract(iTime*.1+sin(iTime*4.0)*.01))\n\n\n#define t (load*2.0-51.2)\nvec4 circles(vec2 p,float s) {\n   p=p*s;\n   vec2 pr = fract(p+vec2(.5))-vec2(.5);\n   vec2 i = p-pr; p=pr;\n   p+=(sin(dot(i,vec2(81.2,54.24))+t)+sin(dot(i,vec2(1.2,5.24))+t))*.13;\n   float z=sin(dot(i,vec2(51.154,5368.1)))*.01;\n   vec3 c = vec3(sin(i.x+i.y*41.2)*.5+.5,cos(i.y)*.5+.5,sin(i.x*2.4)*.5+.5);\n   c=mix(c,vec3(1.9,.4,.1),.5);\n   float sh = -(sqrt(dot(p,p))-.2)*iResolution.y/(.4+s*s*s*s);\n   sh=max(0.0,min(1.0,sh));\n   sh=sin(sh);\n   return vec4(c,sh/s);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uvp = fragCoord.xy / iResolution.yy-vec2(.5);\n     \n    vec3 w = vec3(.0);\n    for (int i=1;i<20;i++){\n        float fi = float(i);\n        fi=fi*.2+.05;\n        vec4 c=circles(uvp+vec2(fi*3.725+t*.1,t*-0.2/fi)+vec2(cos(fi),sin(fi))*t*.01,fi);\n        w+=c.rgb*c.a*.25;\n    }\n    \n    if(uv.y<.31&&uv.y>.30&&uv.x<load)w+=vec3(1.0);\n    w+=vec3(.4,.5,.7)*.1*uv.y;\n    w/=(1.0+pow(length(uv+vec2(-load,-.3))*4.0,2.0));\n    float g=length(w);\n    w=mix(w,vec3(g),g*.2-.3)*.7,\n    w=pow(w,vec3(1.0/1.8));\n\tfragColor = vec4(w,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfSDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtfSR8", "name": "2dDrawTest_1", "author": "gcorallo", "description": "2d drawing test.", "tags": ["2d", "circles", "symmetry"], "likes": 4, "viewed": 351, "date": "1434235508", "time_retrieved": "2024-06-20T18:22:01.994992", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 rgb = vec3(0.,0.,0.);\n\t\n\t\n\tfloat time = iTime*.1;\t\n\t\n\tfloat f = iResolution.x/iResolution.y; \n\n\n\tfloat s = .3;\n\n\tvec2 pos  = mod( vec2(uv.x*f,uv.y)+vec2(time,0.) , vec2(s,s))- vec2(s*.5,s*.5);\n\tvec2 pos2  = mod( vec2(uv.x*f,uv.y)+vec2(-time,s*.5), vec2(s,s))- vec2(s*.5,s*.5);\n\tfloat d1 =dot(pos,pos)*uv.x*1000.;\n\tfloat d2 =dot(pos2,pos2)*(1000.-uv.x*1000.);\n\n\trgb.r+=(1.-step(0.0015*iResolution.x, d1 ))*(1.-uv.x);\n\trgb.g+=(1.-step(0.0015*iResolution.x, d2 ))*uv.x;\n\n\trgb.b = (rgb.r+rgb.g)*  (uv.y*.7+.3);\n\n\tfragColor = vec4(rgb,1.) ;\n    \n    \n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfSR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtfSRn", "name": "iterated square", "author": "FabriceNeyret2", "description": "( try SPACE or F )", "tags": ["ifs", "short"], "likes": 15, "viewed": 1537, "date": "1433858263", "time_retrieved": "2024-06-20T18:22:01.994992", "image_code": "float n = 120.; \nfloat a = 4.*2.*3.1416;\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5)); \n    float luv = length(uv)/sqrt(2.);\n    if (keyToggle(32)) { uv.x /= (1.-.5*uv.y); uv.y /= (.8-.2*uv.y); luv*=.9; }\n      \n    float t = cos(.5*iTime);\n    a = a/n*pow(t,3.);   float  c=cos(a),s=sin(a);  \n    float z=(0.98+.03*cos(.1*iTime))/(abs(s)+abs(c)),  l=1.; \n    mat2 m=mat2(c,-s,s,c)/z;\n    vec4 paint = vec4(pow(.4,1.),pow(.15,1.),pow(.06,1.),1.), col=vec4(1.), p=vec4(1.);\n    \n    for (float i=0.; i<250.; i++) {\n        if (l<luv) break;\n        float w = l/n;\n        p *= pow(paint,vec4(w,w,w,1.));\n        float d = max(abs(uv.x),abs(uv.y));\n        vec4 col0 = smoothstep(.9+.008*l,.9-.008*l,d)*p; if (keyToggle(64+6)) col0*=(.5+.5*sin(100.*d));\n           col0.a = smoothstep(.9+.008*l,.9-.008*l*(1.-abs(t)),d);\n        col = col0 + (1.-col0.a)*col;\n        l /= z;\n        uv *= m;  if (keyToggle(32)) uv.y -= .02*l;\n    }\n    \n\tfragColor = col;\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfSRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtfSzn", "name": "maelstrom 2", "author": "FabriceNeyret2", "description": ".", "tags": ["noise"], "likes": 10, "viewed": 1218, "date": "1433879364", "time_retrieved": "2024-06-20T18:22:01.994992", "image_code": "\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\nvec2 sfbm2( vec3 p ) {\n    return 2.*vec2(fbm(p),fbm(p-327.67))-1.;\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (iMouse.z<0.) \n         mouse = vec2(.9,.5)*vec2(cos(1.*t)+.5*sin(2.2*t),sin(1.1*t)+.5*cos(1.9*t))/1.5;   \n    else \n            mouse = 2.*mouse-1.;\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.9,.5));\n    float a = .5*t, c=cos(a), s=sin(a); uv *= mat2(c,-s,s,c);\n    \n    vec4 col=vec4(0.);\n    vec3 paint = vec3(1.,.3,.1); // vec3(.3,.9,.7);\n    \n    for(float z=0.; z<1.; z+= 1./60.) {\n        vec3 p = vec3(4.2*uv,3.*z-t);\n        vec2 duv = vec2(.8,.5)*sfbm2(p) - 3.*z*mouse;\n    \tfloat d = abs(length(uv+duv)-2.1*(1.-z)),\n              a = smoothstep(.2,.19,d); \n        d = a;//-.3*smoothstep(.18,.17,d)+.3*smoothstep(.02,.01,d);\n        //float b = 2.*fbm(p)-1.; paint = vec3(.7+.3*b,.3+.3*b,.1);\n        float b = fbm(.5*p); paint = 1.-vec3(0.,.7*b,b);\n        col += (1.-col.a)*vec4(d*paint*exp(-3.*z),a);\n        if (col.a>=.9) break;\n    }\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtfXR8", "name": "TV Noise (WIP)", "author": "oinariman", "description": "An attempt at making noisy TV screen", "tags": ["vhs"], "likes": 26, "viewed": 1681, "date": "1434268469", "time_retrieved": "2024-06-20T18:22:01.994992", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_org = vec2(uv);\n\n    float t = mod(iTime, 360.0);\n    float t2 = floor(t*0.6);\n\n    float x,y,yt,xt;\n\n        yt= abs(cos(t)) * rand(vec2(t,t)) * 100.0;\n        xt=sin(360.0*rand(vec2(t,t)))*0.25;\n        if (xt < 0.0) {\n            xt=0.125;\n                }\n        x=uv.x-xt*exp(-pow(uv.y*100.0-yt,2.0)/24.0);\n        y=uv.y;\n        \n        \n    uv.x=x;\n    uv.y=y;\n\n   yt=0.5*cos((yt/100.0)/100.0*360.0);\n   float yr=0.1*cos((yt/100.0)/100.0*360.0);\n    if (uv_org.y > yt && uv_org.y < yt+rand(vec2(t2,t))*0.25) {\n        float md = mod(x*100.0,10.0);\n        if (md*sin(t) > sin(yr*360.0) || rand(vec2(md,md))>0.4) {\n       \t\tvec4 org_c = texture(iChannel0, uv);\n            float colx = rand(vec2(t2,t2)) * 0.75;\n            float coly = rand(vec2(uv.x+t,t));// * 0.5;\n            float colz = rand(vec2(t2,t2));// * 0.5;\n           fragColor = vec4(org_c.x+colx,org_c.y+colx,org_c.z+colx,0.0);\n\n        }\n    }\n    else if (y<cos(t) && mod(x*40.0,2.0)>rand(vec2(y*t,t*t))*1.0 ||  mod(y*12.0,2.0)<rand(vec2(x,t))*1.0) {\n        if (rand(vec2(x+t,y+t))>0.8) {\n   fragColor = vec4(rand(vec2(x*t,y*t)),rand(vec2(x*t,y*t)),rand(vec2(x*t,y*t)),0.0);\n\n        }\n        else \n        {\n   fragColor = texture(iChannel0, uv);\n        }\n    }\n    else {\n    \n        uv.x = uv.x + rand(vec2(t,uv.y)) * 0.0087 * sin(y*2.0);\n                                                        \n                                                        \n    \n   fragColor = texture(iChannel0, uv);\n    }\n\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfXR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtfXRn", "name": "hypertexture - trabeculum 3", "author": "FabriceNeyret2", "description": "Trabeculum pattern. (camera follow mouse).\n\n( a variant from https://www.shadertoy.com/view/MlB3Wt ).", "tags": ["procedural", "raytracing", "noise", "perlin", "hypertexture", "trabeculum"], "likes": 25, "viewed": 2184, "date": "1433871485", "time_retrieved": "2024-06-20T18:22:03.116175", "image_code": "// a variant from https://www.shadertoy.com/view/ltj3Dc and https://www.shadertoy.com/view/MlB3Wt\n\n#define SHADED 0\n#define FOG 1\n#define NOISE 3 // Perlin, Worley, Trabeculum\n#define VARIANT 2\n#define SPIKES 1\n#define RANDtex 1 // 0: math rand 1: texture rand ( thanks Dave ! :-) )\nfloat time;\n\nconst vec3 skyColor = vec3(1.); const float skyTrsp = .5;\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\nconst vec3 ambient  = vec3(.2,0.,0.), \n           diffuse  = vec3(.8);\n\n#define PI 3.14159\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n#if !RANDtex\nfloat noise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n#else\nfloat noise( in vec3 f )\n{\n    vec3 p = floor(f);\n    f = fract(f);\n    f = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\n// more 3D noise\nvec3 hash13( float n ) {\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\n}\nfloat hash31( vec3 n ) {\n    return hash(n.x+10.*n.y+100.*n.z);\n}\nvec3 hash33( vec3 n ) {\n#if !RANDtex\n    return hash13(n.x+10.*n.y+100.*n.z);\n#else  // thanks Dave ! :-)\n    return texture( iChannel0, ((n.xy+vec2(37.0,17.0)*n.z+.5))/256.0, -100.0).xyz;\n#endif\n}\n\nvec4 worley( vec3 p ) {\n    vec4 d = vec4(1e15);\n    vec3 ip = floor(p);\n    for (float i=-1.; i<2.; i++)\n   \t \tfor (float j=-1.; j<2.; j++)\n            for (float k=-1.; k<2.; k++) {\n                vec3 p0 = ip+vec3(i,j,k),\n                      c = hash33(p0)+p0-p;\n                float d0 = dot(c,c);\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\n                else if (d0<d.w) {              d.w=d0; }   \n            }\n    return sqrt(d);\n}\n\n\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\n\n// my noise\nfloat tweaknoise( vec3 p , bool step) {\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\n          d=d1;\n#if NOISE==1 // 3D Perlin noise\n    float v = fbm(scale*p);\n#elif NOISE==2 // Worley noise\n    float v = (.9-scale*worley(scale*p).x);\n#elif NOISE>=3 // trabeculum 3D\n  #if VARIANT==0\n    d = (1.-d1)*d2; \n  #elif VARIANT==2\n    d=1.; //d=d2;\n  #endif\n    if (d<0.5) return 0.;\n    grad=.8, scale = 7., thresh=.7+.2*(cos(.5*time)+.36*cos(.5*3.*time))/1.36;\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*time)); \n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\n#  if SPIKES    \n    v *= 1.-.9*(2.*fbm(10.*scale*p)-1.);\n#  endif\n#endif\n    \n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\n}\n\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\nfloat shadedNormal( vec3 p, float v ) {\n    float epsL = 0.01;\n#if 1// centered directional derivative\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\n#else // cheap directional derivative\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\n#endif\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \n    // { fragColor = vec4(ambient,1.); return; }\n    time = iTime*1.;\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.4,.5);\n\n    //camera\n    float theta = (mouse.x*2. - 1.)*PI;\n    float phi = (mouse.y - .5)*PI;\n#if 1 // camera shake \n    float t=3.*time,B=.07; theta += B*cos(t); phi += B*sin(t);\n#endif\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \n    vec3 cameraTarget = vec3(0.);\n    vec3 ww = normalize( cameraPos - cameraTarget );\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\n    { float  t=.5*time, c=cos(t),s=sin(t); q *= mat2(c,-s,s,c); }\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\n  \n    // ray-trace volume\n    vec3 col=vec3(0.);\n \tfloat transp=1., epsC=.01/2.;\n    float l = .5;\n    vec3 p=cameraPos+l*rayDir, p_=p;\n    \n    for (int i=0; i<200; i++) { \n        float Aloc = tweaknoise(p,true); // density field\n        if (Aloc>0.01) {\n            \n#if FOG \n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\n            col += transp*skyColor*(1.-fog);\n    \t    transp *= fog; \n            if (transp<.001) break;\n#endif            \n\n            //{ vec3 pp=smoothstep(0.,0.2,mod(p*scale,1.)); if (pp.x*pp.y*pp.z<.02) {col+=vec3(1.); break;}}\n#if SHADED          \n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\n#else\n            vec3 c = vec3(0.,.05,0.);\n#endif            \n \t        col += transp*c*Aloc;\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\n            col = clamp(col,0.,1.); // anomaly :-(\n    \t    transp *= 1.-Aloc;\n\t        if (transp<.001) break;\n        }\n \n        p += epsC*rayDir;\n    }\n    \n   fragColor = vec4(col+ transp*skyColor, 1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfXRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtfXzN", "name": "Julia rotation", "author": "LeWiZ", "description": "A pink quaternion julia !\n\nJulia DE from Kindernoiser (https://www.shadertoy.com/view/MsfGRr)\n\nRaymarching-related functions (soft shadows, ambiant occlusion, etc.) from iq's tutorials & other shaders (like https://www.shadertoy.com/view/ldfSWs)", "tags": ["fractal", "julia", "quaternion"], "likes": 20, "viewed": 2166, "date": "1434791377", "time_retrieved": "2024-06-20T18:22:04.025368", "image_code": "float plane(vec3 pos)\n{\n\treturn length(max(abs(pos)-vec3(4.0,0.05,4.0),0.0));\n}\n\nfloat julia(vec3 pos)\n{\n    float t = iTime / 3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<10;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n\nfloat scene(vec3 pos)\n{\n    return min(julia(pos-vec3(0.0,1.5,0.0)), plane(pos));\n}\n\nfloat raymarcher( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 15.0;\n\tconst float precis = 0.0001;\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = scene( ro+rd*t );\n        t += h * 1.0;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 normal( in vec3 pos )\n{\n    const float eps = 0.005;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*scene( pos + v1*eps ) + \n\t\t\t\t\t  v2*scene( pos + v2*eps ) + \n\t\t\t\t\t  v3*scene( pos + v3*eps ) + \n\t\t\t\t\t  v4*scene( pos + v4*eps ) );\n}\n\nfloat softray( in vec3 ro, in vec3 rd , in float hn)\n{\n    float res = 1.0;\n    float t = 0.0005;\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )\n    {\n        h = scene(ro + rd*t);\n        res = min( res, hn*h/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat ambocc( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 light( in vec3 lightdir, in vec3 lightcol, in vec3 tex, in vec3 norm, in vec3 camdir )\n{    \n    float cosa = pow(0.5 + 0.5*dot(norm, -lightdir),2.0);\n    float cosr = max(dot(-camdir, reflect(lightdir, norm)), -0.0);\n    \n    float diffuse = cosa;\n    float phong = pow(cosr, 128.0);\n    \n    return lightcol * (tex * diffuse + phong);\n}\n\nvec3 background( in vec3 rd )\n{\n\treturn vec3(1.0+2.0*rd.y);\n}\n\nvec3 material( in vec3 pos , in vec3 camdir )\n{    \n\tvec3 norm = normal(pos);\n    \n    vec3 d1 = -normalize(vec3(5.0,10.0,-20.0));\n    vec3 d2 = -normalize(vec3(-5,10.0,20.0));\n    vec3 d3 = -normalize(vec3(20,5.0,-5.0));\n    vec3 d4 = -normalize(vec3(-20.0,5.0,5.0));\n\t\n    vec3 tex = vec3(1.0);\n    float sha = 1.0;\n    float ao = 1.0;\n    \n    if (pos.y < 0.2)\n    {\n        tex = vec3(0.2);\n    \tsha = 0.3 + 0.7 * softray(pos, -d1,4.0) * (0.7+softray(pos, norm,2.0));\n    }\n    else\n    {\n        tex = vec3(0.3,0.1,0.2);\n    \tsha = 0.5 + 0.5 * softray(pos, norm, 2.0);\n        ao = ambocc(pos, norm);\n    }\n    \n    vec3 l1 = light(d1, vec3(1.5,1.4,1.2), tex, norm, camdir);\n    vec3 l2 = light(d2, vec3(1.2,1.1,0.9), tex, norm, camdir);\n    vec3 l3 = light(d3, vec3(0.6,0.7,0.9), tex, norm, camdir);\n    vec3 l4 = light(d4, vec3(0.2,0.2,0.2), tex, norm, camdir);\n    \n    vec3 amb = vec3(0.05);\n    \n    return amb*ao+(l1+l2+l3+l4)*sha;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 rayrender(vec3 pos, vec3 dir)\n{\n   vec3 col = vec3(0.0);\n    \n   float dist = raymarcher(pos, dir);\n    \n    if (dist==-1.0) col = background(dir);\n    else\n    {\n    \tvec3 inters = pos + dist * dir;\n    \tcol = material(inters, dir);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    \n    vec2 xy = (fragCoord.xy - iResolution.xy/2.0) / max(iResolution.xy.x, iResolution.xy.y);\n    \n    vec3 campos = vec3(5.0*cos(t/5.0),3.0,5.0*sin(t/5.0));\n    vec3 camtar = vec3(0.0,1.5,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );\n\tvec3 camdir = normalize( camMat * vec3(xy,0.9) );\n    \n    vec3 col = rayrender(campos, camdir);\n    \n    col = pow(col, vec3(1.0/2.2));\n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtlSR7", "name": "crowded cheesy place", "author": "FabriceNeyret2", "description": "a swiss variant of https://www.shadertoy.com/view/ltfXRM :-)", "tags": ["3d", "raymarching", "short", "spheremarching"], "likes": 19, "viewed": 1537, "date": "1435340116", "time_retrieved": "2024-06-20T18:22:04.286058", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define T iTime\n#define r(v,t) { float a = t*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d; p.x-=.4; // init ray \n    r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);      // camera rotations\n    d = p*.5;                                 // ray dir = ray0-vec3(0)\n    p.z += 5.*T;\n    \n    for (float i=1.; i>0.; i-=.01)  \n    {\n        vec4 u = floor(p/8.), t = mod(p, 8.)-4.; // objects id + local frame\n        r(t.xy,u.x); r(t.xz,u.y); r(t.yz,1.);    // objects rotations\n        u = sin(78.*(u+u.yzxw));                 // randomize ids\n        t -= u;                                  // jitter positions (also cause artifacts..)\n        u= .5+.5*u;\n\n        vec4 ta = abs(t);     \n        float x = max(ta.x,max(ta.y,ta.z)) -2.;      // bricks\n\n        vec4 w,v, w1,v1;\n        w = floor(t-.5)+u, v =  mod(t-4.5,1.)-.5,\n        w1 = sin(78.*(w+w.yzxw)), v1 = v-w1/4.;\n        x = max(-length(v1.xyz) +.4, x);             // small holes\n        w = floor(t/2.-.1)+u, v =  mod(t-4.2,2.)-1., \n        w1 = sin(13.*(w+w.yzxw)), v1 = v-w1/3.;\n        x = max(-length(v1.xyz) +.8, x);             // medium holes\n        w = floor(t/3.)+u, v =  mod(t-4.,3.)-1.5, \n        w1 = sin(57.*(w+w.yzxw)), v1 = v-w1/2.;\n        x = max(-length(v1.xyz) +1.3, x);            // big holes\n\n\n        u=vec4(.7,.6,.2,1)*1.2;\n        f = (.2+i)*u; \n \n        if(x<.01) break;    // hit !\n        p -= d*x;           // march ray\n     }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtlSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtlXzn", "name": "Weird Fractal 6", "author": "aiekick", "description": "Weird Fractal 6", "tags": ["fractal", "weird", "6"], "likes": 8, "viewed": 1198, "date": "1434069100", "time_retrieved": "2024-06-20T18:22:04.292027", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//another variation of my Weird Fractal 4 : https://www.shadertoy.com/view/MtsGzB\n\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\n\nfloat map(in vec3 p, in vec3 q, inout vec3 r, inout float m)\n{\n\tfloat d = 0.;\n    for (int j = 0; j < 3 ; j++)\n    \tr=max(r.zyx*=r*=r*=r=mod(q*m+1.,2.)-1.,r.yzx),\n        d=max(d,(0.12 -length(r))/m),\n        m*=1.1;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 s = iResolution.xy;\n    float t = iTime*.2, c,d,m,f=0.;\n    vec3 p=vec3((2.*fragCoord.xy-s)/s.x,1.),r=p-p,q=r;\n    p*=getRotYMat(-t);\n    q.zx += 10.+vec2(sin(t),cos(t))*3.;\n    for (float i=1.; i>0.; i-=.001) \n    {\n    \tc=d=0.,m=1.;\n        f+=0.01;\n        d = map(p,q,r,m);\n        q+=p*d;\n        c = i;\n        if(d<1e-5) break;\n   \t}\n    \n    vec3 eps = vec3( 0.001, 0., 0. );\n    vec3 nor = normalize(vec3(\n    \tmap(p,q+eps.xyy,r,m) - map(p,q-eps.xyy,r,m),\n        map(p,q+eps.yxy,r,m) - map(p,q-eps.yxy,r,m),\n        map(p,q+eps.yyx,r,m) - map(p,q-eps.yyx,r,m) ));\n\n    float k = dot(r,r+.15);\n    vec3 col= vec3(1.,k,k/c)-vec3(0.7 ,0.8, 0);\n    fragColor.rgb = col/f;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtlXzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtSGWt", "name": "Taxi Menger", "author": "eiffie", "description": "It is new to me - hence play.", "tags": ["menger", "manhattan", "recursion", "taxicab"], "likes": 5, "viewed": 1085, "date": "1433357918", "time_retrieved": "2024-06-20T18:22:04.292027", "image_code": "//drawing a menger in taxicab space can be done by rotating around\n//the perimeter and recursively rotating around a perimeter 1/3 the size every\n//8th of a turn similar to how a sierpinski can be drawn with 1/2 scale and \n//a 3rd of a turn. You can't do both in euclidean space... s'all I'm say'n.\n\nfloat sqrt2=sqrt(2.0);\nfloat tx_cos(float a){return abs(mod(a,4.0*sqrt2)-2.0*sqrt2)/sqrt2-1.0;}\nfloat tx_sin(float a){return tx_cos(a-sqrt2);}\nvec2 tx_cossin(float a){return vec2(tx_cos(a),tx_sin(a));}\nfloat tx_length(vec2 p){return abs(p.x)+abs(p.y);}\n\nfloat InOrOut(vec2 p){\n    float sn=0.5*sin(iTime);\n\tp.x-=(1.0-sn*2.0)*0.25;\n\tfloat b=1.0,a=0.0;\n\tfor(int n=0;n<32;n++){\n\t\tfloat r=tx_length(p+tx_cossin(a)*b);\n\t\tif(r<b/(1.5+sn)){\n\t\t\tif(b<0.03)return 0.0; //in menger\n\t\t\tp+=tx_cossin(a)*b;a=0.0;b=b/(2.5+sn);\n\t\t}else {\n\t\t\tif(a>4.0*sqrt2)return 1.0; //not in the menger\n\t\t\ta+=mix(4.0/3.0,0.5,0.5+sn)*sqrt2;\n\t\t}\n\t}\n\treturn 0.5;//maybies\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 3.0*(fragCoord.xy / iResolution.xy-0.5);\n\tfragColor = vec4(uv,InOrOut(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtSGWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtsSzM", "name": "Rotating rings", "author": "harshaduntwale", "description": "first attemp on shader toy :)", "tags": ["rings"], "likes": 1, "viewed": 176, "date": "1435322590", "time_retrieved": "2024-06-20T18:22:04.292027", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.*q-1.0;\n     vec3 col = vec3(0.1,0.2,0.3);\n\n    float theta = 0.0;   \n    vec2 pos = vec2(0.0,0.0);\n    float f=0.0;\n    f=distance(p,pos)*3.0;\n    col += vec3(0.1,0.2,0.3)/(1.0-f);\n    float rad = 0.3;\n    \n     \n        for(int i=0;i<6;i++)\n        {\n            theta = 60.0 * float(i);\n\n            pos = vec2(sin((theta*3.14/180.0)+iTime)*rad,cos((theta*3.14/180.0)+iTime)*rad);\n            float r = distance(p,pos);\n            f=r*3.2;\n            col += vec3(0.1,0.2,0.3)/(1.0-f);\n        }\n    \n     \n\tfragColor = vec4((abs(col)*0.1),1.0);\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtsSzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtsXz8", "name": "BjakkeFirstTestShader", "author": "bjakke", "description": "First test @shadertoy", "tags": ["test"], "likes": 3, "viewed": 161, "date": "1434487448", "time_retrieved": "2024-06-20T18:22:04.292027", "image_code": "//This is my first test @ shadertoy\nfloat fun(float x, float y, float t, float v, float w){\n    return sin(x*y * t)*0.022+sin(t*t)*0.001+cos(v+w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat x = fragCoord.x;\n    float y = fragCoord.y;\n    float t = iTime;\n    float v = x+y-t;\n    float w = x*y;\n    float z = 3.0*x+4.0*y;\n    \n    float cr = fun(x,y,z,v,w);\n    float cg = fun(x,y,t+1.0,v,w);\n    float cb = fun(x,y,t+2.0,v,w);\n\n    fragColor = vec4(cr, cg, cb, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtsXz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtsXzN", "name": "Implicit ray cast", "author": "Ultraviolet", "description": "Casting a ray toward an implicit surface is fun !", "tags": ["raycasting", "implicitsurface"], "likes": 3, "viewed": 254, "date": "1435134301", "time_retrieved": "2024-06-20T18:22:04.292027", "image_code": "\n\n#define PI 3.1415972\n\nconst float dMin = 0.0;\nconst float dMax = 500.0;\nconst float stp = .05;\n\n\n#define evol iTime * 0.2\n#define centre1  vec3(sin(evol * PI))\n#define centre2  vec3(sin(evol * PI + PI))\nfloat radius1 = 1.0;\nfloat radius2 = 1.0;\nvec3 color1 = vec3(1,0,0);\nvec3 color2 = vec3(0,0,1);\n\n\nvec3 lightDir = normalize(vec3(0, -1, -0.3));\n\n\nfloat spherePotential(vec3 pos, vec3 centre, float radius)\n{\n    float dist = length(pos - centre);\n    \n    return radius / dist - 1.0;\n}\n\nvec3 sphereNormal(vec3 pos, vec3 centre)\n{\n    return normalize(pos - centre);\n}\n\n\nfloat objectPotential(vec3 pos)\n{\n    return \n          spherePotential(pos, centre1, radius1) \n        + spherePotential(pos, centre2, radius2);\n}\n\nvec3 objectNormal(vec3 pos)\n{\n    float w1 = spherePotential(pos, centre1, radius1) + 1.0;\n    float w2 = spherePotential(pos, centre2, radius2) + 1.0;\n    \n    return normalize(\n          sphereNormal(pos, centre1) * w1\n        + sphereNormal(pos, centre2) * w2);\n}\n\nbool isInsideObject(vec3 pos)\n{\n    if(objectPotential(pos) > 0.0)\n    \treturn true;\n    \n    return false;\n}\n\n\nvec3 objectColor(in vec3 pos)\n{\n    float t = abs(dot(objectNormal(pos), lightDir)) * 0.8 + 0.2;\n    \n    float w1 = spherePotential(pos, centre1, radius1) + 1.0;\n    float w2 = spherePotential(pos, centre2, radius2) + 1.0;\n    \n    vec3 color = (w1 * color1 + w2 * color2) / (w1 + w2);\n    \n    //return vec3(1.0) * t;\n    return color * t;\n}\n\nvec3 skyColor(in vec3 ro, in vec3 rd)\n{\n    return abs(rd);\n    \n    float latitude = acos(length(rd.xy)) / PI;\n    float longitude = acos(length(rd.x) / length(rd.xy)) / 2.0 / PI;\n    \n    return vec3(latitude, longitude, 0.5);\n}\n\n\nvec3 castRay(in vec3 ro, in vec3 rd)\n{    \n    for(float d = dMin; d < dMax; d += stp)\n    {\n        vec3 pos = ro + d * rd;\n        if(isInsideObject(pos))\n        {\n            return objectColor(pos);\n        }\n    }\n    \n    return skyColor(ro, rd);\n}\n\nmat3 idMatrix()\n{\n    return mat3(\n        1.0, 0.0, 0.0, \n        0.0, 1.0, 0.0, \n        0.0, 0.0, 1.0);\n}\n\nmat3 crossProdMatrix(in vec3 v)\n{\n    return mat3(\n         0.0, -v.z,  v.y,\n    \t v.z,  0.0, -v.x,\n    \t-v.y,  v.x,  0.0);\n}\n\nmat3 tensProdMatrix(in vec3 v)\n{\n    return mat3(\n        v.x * v.x, v.y * v.x, v.z * v.x,\n    \tv.x * v.y, v.y * v.y, v.z * v.y,\n    \tv.x * v.z, v.y * v.z, v.z * v.z);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    return idMatrix() * cos(angle) + crossProdMatrix(axis) * sin(angle) + tensProdMatrix(axis) * (1.0 - cos(angle));\n}\n\nmat3 polarTransformation(float longitude, float latitude)\n{\n    vec3 X = vec3(1,0,0);\n    vec3 Y = vec3(0,1,0);\n    vec3 Z = vec3(0,0,1);\n    \n    mat3 m = rotationMatrix(Z, longitude);\n    Y = m * Y;\n    \n    m = rotationMatrix(Y, latitude) * m;\n    X = m * X;\n    Z = m * Z;\n    \n    return mat3(X, Y, Z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 ro = vec3(0, -5, 0); // ray origin\n    \n    float longitude = iMouse.x / iResolution.x * 2.0 * PI;//0.0;//\n    float latitude = iMouse.y / iResolution.y * PI - 0.5 * PI;\n    \n    mat3 m = polarTransformation(longitude, latitude);\n    \n    vec3 X = m * vec3(1,0,0);\n    vec3 Y = m * vec3(0,1,0);\n    vec3 Z = m * vec3(0,0,1);\n    \n    ro = -X * 5.0;\n    \n    float ratio = iResolution.x / iResolution.y;\n    float angle = PI * 0.5;\n    \n    float alpha_d = (fragCoord.x / iResolution.x - 0.5) * angle;\n    float beta_d  = (fragCoord.y / iResolution.y - 0.5) * angle / ratio;\n    \n    \n    mat3 m2 = polarTransformation(alpha_d, beta_d);\n    \n    vec3 rd = m * m2 * vec3(1,0,0);\n    \n    vec3 col = castRay(ro, rd);\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtsXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtXSR8", "name": "Julia set stuff", "author": "Lallis", "description": "Playing around with some simple julia stuff :)", "tags": ["2d", "fractal", "julia"], "likes": 3, "viewed": 127, "date": "1434229859", "time_retrieved": "2024-06-20T18:22:04.292027", "image_code": "#define iMax 1024.\n\n\n\nvec3 julia(vec2 z)\n{\n   // vec2 c = vec2(sin(iTime*0.5),cos(iTime*0.5));\n   // vec2 c = vec2(-0.1,0.85)+sin(iTime*0.5)*0.05;\n    vec2 c = vec2(-0.125,0.7252)+sin(iTime*0.1)*0.0002;\n    float j;\n    for(float i = 0.0 ; i<iMax; i++)\n    {\n        j = i;\n        z = vec2(z.x*z.x-z.y*z.y, z.x*z.y+z.x*z.y);\n        z = vec2(z.x*z.x-z.y*z.y, z.x*z.y+z.x*z.y);\n    \tz = vec2(z.x*z.x-z.y*z.y, z.x*z.y+z.x*z.y) + c;\n        float d = length(z);\n        if(d > 2.0) break;\n    }\n\treturn vec3(j/64.,j/32.,j/16.);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.0*uv-1.0;\n    uv.x*=1.78;\n    float ang = sin(iTime*(-0.25));\n\tmat2 rotation = mat2(cos(ang), sin(ang),-sin(ang), cos(ang));\n    uv*=rotation;\n    uv*=sin(iTime*0.1)*0.5+1.0;\n    \n    vec3 col = julia(uv);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXSR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtXXR8", "name": "RayCast rehabilitation", "author": "gyabo", "description": "rehabilitation...", "tags": ["rehabilitation"], "likes": 16, "viewed": 265, "date": "1434249084", "time_retrieved": "2024-06-20T18:22:04.292027", "image_code": "#define REP  256\n#define STEP 0.125\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a));\n}\n\nvec3 toCol(float t) {\n\tvec3 col = vec3(0.0);\n\tcol.r += 0.1;\n\tif(t < 0.3)  col.r += 1.5;\n\tif(t < 0.5)  col.g += 1.2;\n\tif(t < 0.7)  col.b += 1.0;\n\treturn vec3(col);\n}\n\nfloat map(vec3 p) { return abs(cos(p.x * 0.9) + sin(p.y * 0.9) + cos(p.z * 0.9)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n\tvec2 uv   = -1.0 + 2.0 * (  fragCoord.xy / iResolution.xy );\n\tuv.x     *= iResolution.x / iResolution.y;\n\tvec3 dir  = normalize(vec3(uv, 0.5 + sin(time) * 0.2));\n\tdir.yz    = rot(dir.yz, time * 0.03);\n\tdir.xy    = rot(dir.xy, time * 0.05);\n\tvec3 pos  = vec3(time, 0, time * 5.0);\n\tfloat d   = 0.0;\n\tvec3 col  = vec3(0.0);\n\tfor(int i = 0 ; i < REP; i++) {\n\t\tfloat temp = map(pos + dir * d);\n\t\tcol += toCol(temp);\n\t\td   += STEP;\n\t}\n\tcol *= 0.007;\n\tcol = pow(col, vec3(2.2));\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXXR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtXXRH", "name": "metamonolith", "author": "ryk", "description": "Some code-duplication for the sake of self-reflections, no regrets.", "tags": ["3d", "reflection", "raymarch", "glow"], "likes": 24, "viewed": 1651, "date": "1434309667", "time_retrieved": "2024-06-20T18:22:04.292027", "image_code": "float time;\nvec2 size;\n#define PI 3.141592653589\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\nmat3 rotateX(float a){\n    return mat3(1.,0.,0.,\n                0.,cos(a), -sin(a),\n                0.,sin(a), cos(a));\n}\n\nmat3 rotateY(float a){\n    return mat3(cos(a), 0., -sin(a),\n                0.,1.,0.,\n                sin(a), 0., cos(a));\n}\n\nmat3 rotation;\n\nfloat hash(float f)\n{\n    return fract(sin(f*32.34182) * 43758.5453);\n}\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 grid(vec3 dir, bool vert){\n    vec2 p = dir.xy / max(0.001, abs(dir.z));\n    p *= 3.;\n    p.y *= 0.06;\n    p.y += time * 20.3;\n    vert = hash(floor(p.y/5. + 0.5)) < 0.5 ? vert : !vert;\n    p += 0.5;\n    float h = hash(floor(p*sign(dir.z)));\n    float h2 = hash(floor(p.y/6.));\n    float h3 = hash(floor(p.y/20.)+sign(dir.z));\n    float band = abs(p.x) < 2. + floor(30.*h3*h3) ? 1. : 0.;\n    p = mod(p, vec2(1.));\n    p -= 0.5;\n    float f = h2 < 0.5 ? smoothstep(0.6, 0.0,length(p))*6. : 2.;\n    h = h < h2/1.2 + 0.1 && vert ? 1. : 0.;\n    vec3 acc = hsv2rgb(vec3(h2/5.+time/30.,.9,0.9))*h*band*3.*f;\n    return acc*pow(abs(dir.z),.5);\n}\n\nvec3 background(vec3 dir){\n    return grid(dir.zxy, true) + grid(dir.yxz, false);\n}\n\nfloat box(vec3 p, vec3 w){\n    p = abs(p);\n    return max(p.x-w.x, max(p.y-w.y, p.z-w.z));\n}\n\nfloat map(vec3 p){\n    for (int i = 0; i < 3; i++){\n        p = abs(p*rotation + vec3(0.1, .0, .0));\n        p.x -= (sin(time/8.) + 1.)/2.;\n        p.y -= (sin(time/7.) + 1.)/3.;\n        p.z -= (sin(time/3.) + 1.)/4.;\n    }\n    return box(p, vec3(0.8, 4.4, 0.4));\n}\n\nvec3 normal(vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(map(pos+eps.xyy) - map(pos-eps.xyy),\n                    map(pos+eps.yxy) - map(pos-eps.yxy),\n                    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nvec3 selfReflect(Ray ray){\n    float dist = 0.01;\n    vec3 pos;\n    float minDist = 1000.;\n    float curMap;\n    for (int i = 0; i < 30; i++){\n        pos = ray.org + dist*ray.dir;\n        curMap = map(pos);\n        dist+=curMap;\n        if(i > 7){\n            minDist = min(minDist,curMap);\n        }\n    }\n    float m = map(pos);\n    if (m < 0.01){\n        vec3 n = normal(pos);\n        vec3 r = reflect(ray.dir, n);\n        vec3 refl = background(r);\n        float rf = 0.8-abs(dot(ray.dir, n))*.4;\n        rf *= rf;\n        return refl*rf*1.3; \n    }\n    float glow = 0.02/minDist;\n\n    return background(ray.dir)*0.5 + glow * vec3(1.9, 2.4, 3.2);\n}\n\nvec3 render(Ray ray){\n    float dist = 0.;\n    vec3 pos;\n    float minDist = 1000.;\n    float curMap;\n    for (int i = 0; i < 40; i++){\n        pos = ray.org + dist*ray.dir;\n        curMap = map(pos);\n        dist+=curMap;\n        minDist = min(minDist,curMap);\n    }\n    float m = map(pos);\n    if (m < 0.01){\n        vec3 n = normal(pos);\n        vec3 r = reflect(ray.dir, n);\n        vec3 refl = selfReflect(Ray(pos, r));\n        float rf = 0.8-abs(dot(ray.dir, n))*.4;\n        rf *= rf;\n        return refl*rf*1.3; \n    }\n    float glow = 0.02/minDist;\n\n    return background(ray.dir)*0.5 + glow * vec3(1.9, 2.4, 3.2);\n}\n\nRay createRay(vec3 center, vec3 lookAt, vec3 up, vec2 uv, float fov, float aspect)\n{\n\tRay ray;\n\tray.org = center;\n\tvec3 dir = normalize(lookAt - center);\n\tup = normalize(up - dir*dot(dir,up));\n\tvec3 right = cross(dir, up);\n\tuv = 2.*uv - vec2(1.);\n\tfov = fov * 3.1415/180.;\n\tray.dir = dir + tan(fov/2.) * right * uv.x + tan(fov/2.) / aspect * up * uv.y;\n\tray.dir = normalize(ray.dir);\t\n\treturn ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    size.xy = iResolution.xy;\n    time = iTime;\n    vec2 p = fragCoord / size;\n\tvec3 cameraPos = vec3(-8.,2.*sin(time/10.),-4.*sin(time/4.));\n\tvec3 lookAt = vec3(0.);\n\tvec3 up = vec3(0.,0.,1.);\n\tfloat aspect = size.x/size.y;\n    float xt = floor(time/8.) + clamp(fract(time/8.)*20.,0.,1.);\n    float yt = floor(time/2.) + clamp(fract(time/2.)*5.,0.,1.);\n    rotation = rotateX(xt*PI/4.)*rotateY(yt*PI/2.);\n\tRay ray = createRay(cameraPos, lookAt, up, p, 90., aspect);\n    vec3 col = render(ray);\n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXXRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
