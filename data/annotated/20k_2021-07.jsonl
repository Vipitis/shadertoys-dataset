{"id": "3lfXR4", "name": "Morphing solids", "author": "martytram", "description": "An example of solid union, intesetion and minus using smooth min/max functions.", "tags": ["raymarch", "morph", "shaded"], "likes": 0, "viewed": 57, "published": "Public", "date": "1626422667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100.\n#define MAX_DIST 100.\n#define EPSILON .0001\n#define PI 3.14159\n\nstruct ray{ vec3 org, dir; };\n\nray getRay(vec2 uv, vec3 camPos, vec3 lookAt, float zoom){\n    ray ray;\n    vec3 f = normalize(lookAt - camPos);\n    vec3 r = cross(vec3(0,1,0), f);\n    vec3 u = cross(f, r);\n    vec3 centre = camPos + f*zoom;\n    vec3 intersection = centre + uv.x*r + uv.y*u;\n    \n    ray.org = camPos;\n    ray.dir = normalize(intersection - camPos);\n    return ray;\n}\n\nfloat sMin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.-h);\n}\n\nfloat sMax(float a, float b, float k){\n    return sMin(a,b,-k);\n}\n\nfloat soUnion(float a, float b){\n    return min(a, b);\n}\n\nfloat smUnion(float a, float b, float k){\n    return sMin(a, b, k);\n}\n\nfloat soIntersect(float a, float b){\n    return max(a, b);\n}\n\nfloat smIntersect(float a, float b, float k){\n    return sMax(a, b, k);\n}\n\nfloat soMinus(float a, float b){\n    return max(a, -b);\n}\n\nfloat smMinus(float a, float b, float k){\n    return sMax(a, -b, k);\n}\n\nfloat sMorph(float a, float b, float k){\n    return mix(a, b, k);\n}\n\nfloat sdSphere(vec3 p, vec3 c, float r){\n    return length(p-c)-r;\n}\n\nfloat sdBox(vec3 p, vec3 c, vec3 dims){\n    vec3 off = abs(p-c)-dims;\n    float outside = length(max(off, 0.));\n    float inside = min(max(off.x, max(off.y, off.z)), 0.);\n    return outside+inside;\n}\n\nfloat sdTorus(vec3 p, vec3 c, vec2 r){\n    p -= c;\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat fastSin(float x) {\n    x = abs(mod(x-PI/2.,2.*PI)-PI)-PI/2.;\n    return x-pow(x,3.)/6.;//+pow(x,5.)/120.;\n}\n\nfloat getSceneDist(vec3 p){\n    float ground = p.y;\n    float d = ground;\n    \n    float sD = sdSphere(p, vec3(0,1,0), 1.);\n    float sD2 = sdSphere(p, vec3(0,1.3,0), 1.);\n    float sD3 = sdSphere(p, vec3(0,1,0), .5);\n    float bD = sdBox(p, vec3(0,1,0), vec3(1.));\n    float tD = sdTorus(p, vec3(0,1,0), vec2(1., .5));\n    \n    sD = smMinus(sD, sD2, .2);\n    sD = smUnion(sD, sD3, .7);\n    float t = sin(iTime)+1.;\n    //float t = fastSin(iTime)+1.; // no added fps\n    if(t<=1.){\n        sD = sMorph(sD, bD, t);\n    }else{\n        sD = sMorph(bD, tD, t-1.);\n    }\n    \n    d = soUnion(d, sD);\n    \n    return d;\n}\n\nfloat rayMarchDist(ray ray){\n    float dist = 0.;\n    for(float i = 0.; i<MAX_STEPS; i+=1.){\n        vec3 p = ray.org + dist*ray.dir;\n        float currD = getSceneDist(p);\n        dist += currD;\n        \n        if(dist >= MAX_DIST)\n            return MAX_DIST;\n        if(currD <= EPSILON)\n            return dist;\n    }\n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    float d = getSceneDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        getSceneDist(p-e.xyy),\n        getSceneDist(p-e.yxy),\n        getSceneDist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 v){\n    vec3 lPos1 = vec3(8.*sin(iTime),10,8.*cos(iTime));\n    vec3 lPos2 = vec3(6.*sin(iTime*.4),10,6.*cos(iTime*.4));\n    float ambC = .15;\n    float difC = .5;\n    float speC = .2;\n    float phongC = 3.;\n    \n    vec3 l1 = normalize(lPos1 - p);\n    vec3 l2 = normalize(lPos2 - p);\n    vec3 n = getNormal(p);\n    vec3 r1 = normalize(2.*dot(n, l1)*n - l1);\n    vec3 r2 = normalize(2.*dot(n, l2)*n - l2);\n    \n    float amb = ambC;\n    float dif = difC * (dot(n, l1)+.6*dot(n, l2));\n    float spe = speC * (pow(dot(v,r1), phongC)+.8*pow(dot(v,r2), phongC));\n    \n    float intensity = dif + spe;\n    //shadow\n    float d1 = rayMarchDist(ray(p+.01*n, l1));\n    float d2 = rayMarchDist(ray(p+.01*n, l2));\n    if(d1<length(lPos1-p))\n        intensity *= .3;\n    if(d2<length(lPos2-p))\n        intensity *= .5;\n    \n    intensity += amb;\n    \n    vec3 col = vec3(.7,.8,1.);\n    return intensity * col;\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 getColor(vec2 uv, vec3 camPos, vec3 lookAt) {\n    ray ray = getRay(uv, camPos, lookAt, 1.);\n    \n    float d = rayMarchDist(ray);\n    vec3 p = ray.org + d*ray.dir;\n    \n    return getLight(p, -ray.dir);\n}\n\n\n// weird complicated way of AA\nvec3 getColorAAv1(vec2 uv, vec3 camPos, vec3 lookAt) {\n    const float eps = 4.*EPSILON;\n    vec3[9] mat;\n    \n    for(int i = 0; i < 3; i++){\n        for(int j = 0; j < 3; j++){\n            mat[i*3+j] = getColor(uv+vec2(float(i-1)*eps, float(j-1)*eps), camPos, lookAt);\n        }\n    }\n    \n    vec3 res = vec3(0);\n    for(int i = 0; i < 3; i++){\n        for(int j = 0; j < 3; j++){\n            res += mat[i*3+j];\n        }\n    }\n    \n    return res/9.;\n}\n\n// subdivide pixel\nvec3 getColorAA(vec2 uv, vec3 camPos, vec3 lookAt) {\n    const float subdivCount = 2.;\n    vec2 subdivDim = (1./iResolution.xy) * (1./subdivCount);\n    \n    vec3 res = vec3(0);\n    for(float i = 0.; i < subdivCount; i+=1.){\n        for(float j = 0.; j < subdivCount; j+=1.){\n            res += getColor(uv+vec2(i*subdivDim.x, j*subdivDim.y), camPos, lookAt);\n        }\n    }\n    \n    return res/pow(subdivCount, 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0.);\n    \n    vec3 camPos = vec3(0, 3. ,-6);\n    camPos.yz *= rot(-m.y+.4);\n    camPos.xz *= rot(-m.x*6.2831);\n    vec3 lookAt = vec3(0, 1., 0);\n    \n    \n    //col = getColor(uv, camPos, lookAt);\n    col = getColorAA(uv, camPos, lookAt);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 176, 176, 470], [472, 472, 510, 510, 594], [596, 596, 634, 634, 661], [663, 663, 695, 695, 719], [721, 721, 762, 762, 790], [792, 792, 828, 828, 852], [854, 854, 899, 899, 927], [929, 929, 961, 961, 986], [988, 988, 1029, 1029, 1058], [1060, 1060, 1100, 1100, 1127], [1129, 1129, 1169, 1169, 1197], [1199, 1199, 1238, 1238, 1398], [1400, 1400, 1438, 1438, 1521], [1523, 1523, 1547, 1547, 1636], [1638, 1638, 1665, 1665, 2253], [2255, 2255, 2283, 2283, 2596], [2598, 2598, 2621, 2621, 2837], [2839, 2839, 2869, 2869, 3765], [3767, 3767, 3786, 3786, 3862], [3864, 3864, 3914, 3914, 4073], [4565, 4584, 4636, 4636, 5002], [5004, 5004, 5061, 5061, 5456]], "test": "error"}
{"id": "4tsBD7", "name": "Disk - intersection", "author": "iq", "description": "ray-disk intersection", "tags": ["3d", "raytracing", "raycast", "intersection", "raytrace", "disk"], "likes": 13, "viewed": 494, "published": "Public API", "date": "1626387735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Ray-disk intersection. For general planar shapes, please see the\n// \"coord system intersector\" at https://www.shadertoy.com/view/lsfGDB\n//\n//\n// List of other ray-surface intersectors:\n//    https://www.shadertoy.com/playlist/l3dXRf\n// and \n//    http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n// disk: center c, normal n, radius r\nfloat diskIntersect( in vec3 ro, in vec3 rd, vec3 c, vec3 n, float r )\n{\n\tvec3  o = ro - c;\n    float t = -dot(n,o)/dot(rd,n);\n    vec3  q = o + rd*t;\n    return (dot(q,q)<r*r) ? t : -1.0;\n}\n\n// disk: center c, normal n, radius r\nfloat diskIntersectWithBackFaceCulling( in vec3 ro, in vec3 rd, vec3 c, vec3 n, float r )\n{\n    float d = dot(rd,n);\n    if( d>0.0 ) return -1.0;\n\tvec3  o = ro - c;\n    float t = -dot(n,o)/d;\n    vec3  q = o + rd*t;\n    return (dot(q,q)<r*r) ? t : -1.0;\n}\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n        // camera\n        vec3 ro = 1.5*vec3(cos(0.15*iTime),0.0,sin(0.15*iTime));\n        vec3 ta = vec3(0.0,0.0,0.0);\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.0*ww );\n\n        // render background\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\n        // render disks (raycast them)\n        const int num = 64;  // number of disks\n\n        float tmin = 1e20;\n        vec3  onor = vec3(0.0);\n        for( int i=0; i<num; i++ )\n        {\n            // fibonacci points on a sphere\n            const float kInvPhi = (sqrt(5.0)-1.0)/2.0; // one over golden ratio\n            float cb = 1.0-2.0*(float(i)+0.5)/float(num);\n            float sb = sqrt(1.0-cb*cb);\n            float aa = 6.283185*kInvPhi*float(i);\n            vec3  cen = vec3( sb*sin(aa), sb*cos(aa), cb );\n\n            // orient disk tangent to sphere surface\n            vec3  nor = normalize(cen);\n\n            // for full coverage, each disk's area should be 4PI/num,\n            // ie, their radius should be 2/sqrt(num)\n            float rad = (2.0/sqrt(float(num))); \n            // but we only want partial coverage, for aesthetic reasons\n            rad *= 0.5;\n\n            // test for intersection with disk\n            float t = diskIntersect( ro, rd, cen, nor, rad );\n\n            // trak intersections\n            if( t>0.0 && t<tmin ) \n            {\n                tmin = t;\n                onor = nor;\n            }\n        }\n\n        // shade disk, if one found\n        if( tmin<1000.0 )\n        {\n            float dif = clamp( dot(onor,vec3(0.8,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*onor.y;\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.75,0.6)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsBD7.jpg", "access": "shaders20k", "license": "mit", "functions": [[1395, 1433, 1505, 1505, 1623], [1625, 1663, 1754, 1754, 1918]], "test": "valid"}
{"id": "7l2SR1", "name": "mfglsl", "author": "momie", "description": "my first glsl", "tags": ["mf"], "likes": 0, "viewed": 39, "published": "Public", "date": "1627118898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14;\n\nvec4 funya(vec2 uv){\n    vec3 destColor = vec3(0.0);\n    float num = .15*iTime < 40.0 ? .15*iTime : 40.0;\n    for(float i = 0.0; i < num; i++){\n        vec2 q = uv + .7*vec2(cos( ( i/num ) * PI + .179*iTime), sin( ( i / num ) * PI + .199*iTime));\n        float theta  = atan(q.y,q.x);\n        destColor.yz += cos(theta*30.0);\n    }\n    return vec4(destColor, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 step_uv = floor(uv * 5.0) / 5.0;\n    vec4 sound = texture(iChannel1, vec2(.001,0.0));\n    vec4 s2 = texture(iChannel1, vec2(.1,0.0));\n    fragColor = funya(uv-.5+ vec2 (.3*(sound.x -.5) + .1*(s2.x - .5) , .0));\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2SR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 38, 38, 384], [386, 386, 443, 443, 705]], "test": "error"}
{"id": "7l2SRh", "name": "CLIP+CPPN Synthwave", "author": "atara", "description": "This CPPN and CLIP fed shader is rendering a neon synthwave style grod! ", "tags": ["synthwaveneoncppnclipneuralnetnerualrenderingnftnftartneuralgeneration"], "likes": 11, "viewed": 199, "published": "Public", "date": "1627101129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#define N_HIDDEN 20\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(0.008, -0.384, -0.418, -0.459) + mat4(vec4(-0.968, 0.784, -0.035, -0.054), vec4(-0.146, 0.540, 0.290, 0.774), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[1] = vec4(0.036, -0.066, -0.206, -0.069) + mat4(vec4(0.423, -0.304, -1.230, 1.680), vec4(0.081, 0.712, 1.174, 0.784), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[2] = vec4(-0.424, 0.085, -0.494, -0.152) + mat4(vec4(0.335, 1.118, 0.461, 0.507), vec4(0.703, -0.949, -0.364, -0.695), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[3] = vec4(-0.336, 0.139, 0.065, 0.352) + mat4(vec4(0.378, 0.000, -0.780, 0.048), vec4(1.212, -0.013, -0.103, -0.340), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[4] = vec4(0.196, 0.341, -0.015, -0.213) + mat4(vec4(-1.227, -0.850, -0.835, 0.488), vec4(0.529, 0.253, 0.527, 0.272), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(-0.367, -0.352, -0.352, -0.403) + mat4(vec4(0.263, 0.095, 0.090, 0.031), vec4(-0.191, 0.491, -0.007, 0.173), vec4(-0.058, -0.168, 0.002, -0.046), vec4(0.141, -0.105, 0.269, 0.002)) * bufB[0] + mat4(vec4(-0.341, 0.084, 0.150, 0.100), vec4(0.009, 0.151, 0.109, 0.207), vec4(0.073, 0.011, -0.064, -0.049), vec4(0.056, 0.362, 0.025, 0.058)) * bufB[1] + mat4(vec4(0.085, 0.073, -0.032, -0.172), vec4(0.160, -0.198, -0.119, -0.377), vec4(0.137, 0.141, -0.281, -0.067), vec4(0.297, -0.327, -0.035, 0.018)) * bufB[2] + mat4(vec4(0.008, 0.121, 0.264, -0.345), vec4(0.271, 0.163, -0.228, 0.165), vec4(0.037, -0.170, -0.014, -0.214), vec4(-0.161, 0.041, 0.095, 0.228)) * bufB[3] + mat4(vec4(-0.217, 0.549, -0.010, 0.164), vec4(0.244, 0.057, 0.208, -0.025), vec4(0.007, 0.135, -0.144, -0.136), vec4(-0.011, 0.253, 0.024, -0.220)) * bufB[4] + mat4(vec4(0.067, 0.120, -0.003, 0.035), vec4(-0.103, -0.160, -0.102, -0.200), vec4(-0.089, -0.222, -0.124, -0.017), vec4(-0.117, -0.396, -0.276, 0.083)) * bufB[5] + mat4(vec4(-0.031, -0.037, 0.159, -0.086), vec4(-0.192, -0.075, -0.313, 0.137), vec4(-0.029, -0.099, -0.252, 0.053), vec4(-0.170, -0.185, 0.353, -0.135)) * bufB[6] + mat4(vec4(0.483, -0.138, -0.010, 0.091), vec4(0.063, -0.003, -0.252, -0.126), vec4(0.234, 0.117, 0.089, 0.052), vec4(-0.094, 0.020, -0.175, -0.296)) * bufB[7] + mat4(vec4(-0.462, -0.287, -0.151, 0.141), vec4(-0.077, 0.145, 0.169, 0.032), vec4(-0.243, 0.110, 0.048, 0.093), vec4(0.205, 0.141, -0.230, 0.075)) * bufB[8] + mat4(vec4(0.086, 0.243, 0.106, 0.053), vec4(0.244, 0.048, 0.221, 0.192), vec4(0.334, -0.092, -0.199, 0.321), vec4(0.030, -0.089, -0.302, -0.266)) * bufB[9];\nbufA[1] = vec4(-0.136, -0.070, -0.390, 0.449) + mat4(vec4(0.266, -0.009, 0.066, 0.069), vec4(-0.213, 0.024, 0.321, -0.002), vec4(0.186, 0.300, -0.030, -0.108), vec4(-0.147, -0.063, -0.286, -0.039)) * bufB[0] + mat4(vec4(-0.284, -0.051, -0.085, -0.308), vec4(0.155, 0.273, 0.181, -0.172), vec4(0.208, 0.111, 0.461, -0.038), vec4(-0.206, 0.024, 0.073, -0.137)) * bufB[1] + mat4(vec4(0.109, 0.012, -0.082, -0.201), vec4(-0.099, 0.171, 0.044, -0.171), vec4(-0.176, -0.115, 0.060, 0.126), vec4(0.030, 0.016, -0.061, -0.043)) * bufB[2] + mat4(vec4(-0.019, 0.576, 0.070, 0.194), vec4(-0.233, 0.004, -0.120, 0.108), vec4(-0.081, -0.094, 0.007, 0.126), vec4(0.098, -0.082, -0.217, 0.142)) * bufB[3] + mat4(vec4(0.280, 0.030, 0.060, -0.062), vec4(0.336, 0.148, 0.164, -0.061), vec4(0.364, -0.186, 0.309, -0.085), vec4(-0.093, 0.002, 0.211, -0.042)) * bufB[4] + mat4(vec4(-0.077, -0.382, 0.046, 0.001), vec4(0.122, 0.148, 0.188, 0.036), vec4(0.155, -0.059, 0.038, 0.038), vec4(0.169, -0.007, -0.225, 0.119)) * bufB[5] + mat4(vec4(-0.161, 0.296, -0.166, -0.189), vec4(0.140, 0.001, -0.021, -0.124), vec4(-0.269, -0.319, -0.214, -0.073), vec4(0.414, 0.286, -0.010, -0.127)) * bufB[6] + mat4(vec4(-0.236, -0.093, -0.399, -0.169), vec4(0.059, -0.357, -0.069, -0.175), vec4(0.356, -0.046, -0.127, 0.208), vec4(-0.015, -0.021, 0.042, 0.203)) * bufB[7] + mat4(vec4(0.109, -0.135, -0.234, 0.026), vec4(0.045, 0.247, -0.130, -0.144), vec4(0.100, -0.541, -0.084, 0.036), vec4(-0.095, 0.005, -0.197, -0.050)) * bufB[8] + mat4(vec4(-0.108, -0.202, 0.016, 0.128), vec4(-0.194, -0.044, 0.197, -0.170), vec4(0.018, 0.030, -0.120, -0.025), vec4(0.263, -0.459, 0.255, 0.317)) * bufB[9];\nbufA[2] = vec4(0.315, -0.006, 0.274, 0.157) + mat4(vec4(-0.031, -0.132, -0.077, -0.235), vec4(-0.014, -0.261, 0.165, 0.305), vec4(-0.119, 0.128, 0.153, -0.180), vec4(-0.132, -0.324, -0.031, 0.081)) * bufB[0] + mat4(vec4(-0.109, 0.078, 0.194, -0.021), vec4(-0.137, -0.183, 0.185, -0.026), vec4(0.173, -0.198, -0.048, -0.261), vec4(0.199, 0.172, 0.242, -0.107)) * bufB[1] + mat4(vec4(0.032, 0.028, 0.052, -0.019), vec4(0.099, 0.079, 0.343, -0.039), vec4(-0.199, -0.018, -0.043, -0.057), vec4(-0.100, -0.023, 0.184, 0.241)) * bufB[2] + mat4(vec4(-0.125, 0.001, -0.132, -0.107), vec4(-0.119, 0.243, 0.002, -0.121), vec4(-0.002, 0.069, -0.083, -0.140), vec4(-0.035, 0.134, -0.068, 0.357)) * bufB[3] + mat4(vec4(0.091, 0.000, -0.459, -0.214), vec4(-0.110, -0.043, -0.020, -0.035), vec4(0.036, 0.153, -0.017, -0.204), vec4(-0.272, -0.186, 0.040, 0.114)) * bufB[4] + mat4(vec4(0.411, -0.159, -0.082, -0.161), vec4(-0.103, 0.020, -0.072, 0.112), vec4(-0.281, 0.020, -0.177, -0.104), vec4(-0.317, -0.084, -0.019, 0.145)) * bufB[5] + mat4(vec4(-0.043, 0.082, -0.054, 0.296), vec4(-0.135, -0.168, -0.072, -0.144), vec4(-0.047, -0.340, -0.016, -0.015), vec4(0.521, 0.237, -0.144, -0.207)) * bufB[6] + mat4(vec4(-0.087, 0.147, 0.006, 0.046), vec4(-0.110, -0.269, 0.108, -0.040), vec4(-0.002, 0.073, -0.088, -0.059), vec4(0.020, -0.235, 0.338, -0.374)) * bufB[7] + mat4(vec4(-0.155, 0.375, 0.122, 0.093), vec4(-0.176, 0.073, -0.054, 0.029), vec4(-0.180, -0.045, -0.189, 0.038), vec4(0.389, -0.144, -0.365, 0.160)) * bufB[8] + mat4(vec4(-0.084, -0.108, -0.076, 0.053), vec4(0.002, 0.236, 0.189, -0.171), vec4(-0.166, 0.030, 0.022, 0.026), vec4(0.103, 0.140, -0.309, 0.179)) * bufB[9];\nbufA[3] = vec4(0.286, -0.403, -0.088, 0.005) + mat4(vec4(0.050, 0.102, -0.308, -0.144), vec4(-0.065, -0.016, 0.410, 0.242), vec4(-0.171, -0.130, -0.151, 0.003), vec4(-0.017, 0.458, -0.003, 0.098)) * bufB[0] + mat4(vec4(-0.032, 0.013, 0.072, 0.101), vec4(0.153, 0.145, 0.090, -0.328), vec4(-0.132, -0.195, 0.249, 0.152), vec4(-0.125, -0.035, 0.171, -0.119)) * bufB[1] + mat4(vec4(-0.058, 0.114, 0.148, -0.126), vec4(0.117, -0.286, -0.043, 0.232), vec4(-0.096, -0.057, 0.039, -0.020), vec4(-0.038, -0.076, -0.082, 0.051)) * bufB[2] + mat4(vec4(-0.123, 0.004, 0.454, -0.020), vec4(0.057, -0.037, 0.130, 0.212), vec4(-0.359, 0.325, -0.030, -0.209), vec4(-0.132, -0.009, 0.132, 0.067)) * bufB[3] + mat4(vec4(0.195, 0.166, 0.052, 0.017), vec4(-0.112, 0.118, 0.070, -0.123), vec4(-0.251, 0.011, -0.193, 0.290), vec4(0.022, -0.128, 0.160, 0.103)) * bufB[4] + mat4(vec4(-0.019, 0.105, 0.249, -0.018), vec4(0.006, 0.142, -0.141, 0.299), vec4(-0.162, -0.076, -0.141, 0.109), vec4(-0.121, -0.233, -0.325, 0.077)) * bufB[5] + mat4(vec4(-0.259, 0.040, 0.019, -0.109), vec4(-0.018, -0.175, -0.047, 0.051), vec4(-0.004, -0.286, -0.044, 0.340), vec4(0.341, 0.056, 0.391, 0.203)) * bufB[6] + mat4(vec4(-0.116, 0.152, 0.136, -0.139), vec4(0.187, -0.476, -0.143, 0.179), vec4(-0.044, 0.150, 0.033, -0.001), vec4(0.148, -0.122, -0.152, -0.024)) * bufB[7] + mat4(vec4(-0.013, 0.006, 0.026, -0.200), vec4(-0.125, -0.007, 0.074, -0.035), vec4(0.043, 0.138, 0.176, 0.425), vec4(0.200, 0.054, -0.132, -0.123)) * bufB[8] + mat4(vec4(-0.308, 0.162, 0.186, 0.187), vec4(-0.190, 0.041, -0.130, 0.268), vec4(-0.040, 0.006, -0.173, 0.035), vec4(0.022, 0.169, -0.170, 0.033)) * bufB[9];\nbufA[4] = vec4(-0.223, -0.024, 0.426, 0.242) + mat4(vec4(-0.057, -0.215, -0.273, -0.139), vec4(-0.147, 0.134, 0.015, -0.162), vec4(-0.141, 0.158, -0.058, -0.134), vec4(-0.229, -0.012, -0.028, 0.279)) * bufB[0] + mat4(vec4(0.114, 0.242, 0.066, -0.076), vec4(-0.429, 0.117, 0.343, 0.123), vec4(-0.321, 0.270, 0.128, -0.053), vec4(-0.178, 0.101, 0.086, 0.054)) * bufB[1] + mat4(vec4(-0.042, 0.297, 0.004, 0.175), vec4(0.270, -0.108, -0.092, -0.164), vec4(0.180, 0.001, -0.088, 0.118), vec4(0.280, -0.192, 0.018, -0.109)) * bufB[2] + mat4(vec4(-0.359, 0.437, 0.337, 0.208), vec4(-0.014, -0.068, -0.011, 0.263), vec4(0.139, -0.337, -0.190, -0.313), vec4(0.278, -0.136, 0.003, 0.023)) * bufB[3] + mat4(vec4(-0.137, -0.075, -0.195, -0.035), vec4(0.230, -0.096, 0.031, 0.130), vec4(-0.407, 0.285, 0.147, -0.085), vec4(-0.173, 0.415, -0.075, 0.165)) * bufB[4] + mat4(vec4(-0.050, -0.047, -0.123, 0.145), vec4(0.038, 0.165, -0.210, -0.135), vec4(0.062, 0.066, -0.109, 0.042), vec4(0.178, 0.026, -0.132, 0.116)) * bufB[5] + mat4(vec4(-0.071, 0.059, 0.027, 0.004), vec4(0.174, -0.203, 0.070, 0.022), vec4(0.235, -0.258, 0.148, -0.109), vec4(0.199, 0.270, -0.334, -0.114)) * bufB[6] + mat4(vec4(0.173, 0.010, -0.332, -0.040), vec4(-0.126, -0.370, -0.167, 0.183), vec4(-0.173, 0.111, -0.145, 0.015), vec4(-0.102, -0.078, 0.068, 0.158)) * bufB[7] + mat4(vec4(0.278, -0.254, -0.192, -0.345), vec4(0.031, 0.109, 0.034, 0.174), vec4(0.042, -0.061, 0.080, -0.116), vec4(0.034, -0.046, -0.031, 0.062)) * bufB[8] + mat4(vec4(-0.117, -0.139, 0.255, 0.220), vec4(-0.279, -0.086, 0.196, -0.239), vec4(0.021, 0.042, -0.009, 0.101), vec4(-0.019, -0.181, -0.141, -0.067)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(0.167, 0.013, 0.214, -0.092) + mat4(vec4(0.039, -0.391, -0.072, 0.197), vec4(-0.136, -0.307, 0.086, -0.056), vec4(-0.041, 0.115, -0.120, 0.179), vec4(0.148, -0.089, 0.145, 0.007)) * bufB[0] + mat4(vec4(0.293, -0.106, -0.148, 0.030), vec4(-0.059, -0.200, -0.206, -0.125), vec4(0.153, 0.003, -0.018, -0.098), vec4(-0.069, -0.156, -0.393, 0.143)) * bufB[1] + mat4(vec4(0.122, -0.071, -0.134, 0.179), vec4(-0.005, -0.129, -0.243, -0.080), vec4(-0.168, 0.201, -0.194, -0.003), vec4(-0.112, -0.156, -0.036, -0.136)) * bufB[2] + mat4(vec4(-0.168, 0.180, 0.046, -0.052), vec4(0.115, -0.306, -0.067, 0.180), vec4(-0.438, -0.032, -0.040, -0.040), vec4(0.091, -0.057, -0.037, 0.200)) * bufB[3] + mat4(vec4(-0.078, -0.075, 0.011, 0.080), vec4(-0.146, 0.117, -0.165, -0.031), vec4(-0.189, -0.005, 0.075, -0.038), vec4(0.266, 0.151, 0.129, 0.095)) * bufB[4] + mat4(vec4(0.004, -0.046, -0.095, 0.002), vec4(0.174, 0.255, 0.231, 0.255), vec4(0.183, -0.208, -0.018, -0.202), vec4(-0.006, 0.209, 0.044, 0.008)) * bufB[5] + mat4(vec4(-0.052, -0.185, -0.093, 0.202), vec4(-0.049, 0.149, 0.167, -0.118), vec4(0.084, -0.015, 0.045, -0.082), vec4(0.251, -0.049, 0.131, 0.022)) * bufB[6] + mat4(vec4(0.063, 0.132, -0.304, -0.060), vec4(0.008, -0.051, 0.135, 0.353), vec4(-0.236, 0.088, 0.148, -0.254), vec4(-0.247, 0.235, -0.039, -0.017)) * bufB[7] + mat4(vec4(-0.122, -0.090, -0.342, -0.031), vec4(-0.156, 0.078, 0.198, 0.130), vec4(-0.043, 0.089, -0.368, -0.212), vec4(0.074, -0.046, -0.158, -0.281)) * bufB[8] + mat4(vec4(0.083, 0.096, -0.181, 0.239), vec4(0.077, 0.192, -0.020, 0.275), vec4(0.120, 0.191, 0.179, 0.016), vec4(0.212, 0.041, 0.301, 0.109)) * bufB[9];\nbufA[1] = vec4(-0.039, -0.168, -0.116, -0.467) + mat4(vec4(-0.222, 0.177, -0.063, 0.106), vec4(0.019, -0.270, 0.113, 0.122), vec4(-0.162, 0.162, -0.255, -0.105), vec4(-0.220, 0.122, 0.047, 0.102)) * bufB[0] + mat4(vec4(-0.046, 0.032, -0.150, -0.013), vec4(-0.048, -0.122, -0.081, 0.145), vec4(-0.098, 0.026, -0.158, 0.040), vec4(-0.101, 0.055, -0.015, -0.096)) * bufB[1] + mat4(vec4(0.233, -0.049, -0.227, 0.078), vec4(0.174, -0.267, -0.317, 0.143), vec4(-0.018, 0.232, -0.000, -0.064), vec4(-0.110, -0.030, -0.041, -0.108)) * bufB[2] + mat4(vec4(-0.087, -0.169, -0.132, -0.195), vec4(0.098, -0.396, 0.149, -0.077), vec4(0.420, 0.408, -0.186, -0.207), vec4(0.024, -0.132, 0.163, -0.225)) * bufB[3] + mat4(vec4(0.060, 0.099, 0.185, -0.158), vec4(-0.003, -0.037, 0.053, -0.233), vec4(0.005, 0.293, -0.120, -0.279), vec4(0.105, -0.262, 0.199, -0.093)) * bufB[4] + mat4(vec4(0.112, 0.255, -0.159, 0.031), vec4(-0.161, 0.138, 0.243, 0.105), vec4(-0.007, 0.034, -0.244, 0.057), vec4(0.049, 0.224, 0.255, -0.145)) * bufB[5] + mat4(vec4(0.095, -0.091, -0.043, 0.228), vec4(-0.178, 0.248, -0.077, -0.010), vec4(-0.081, -0.106, 0.109, -0.031), vec4(-0.152, -0.277, -0.137, 0.024)) * bufB[6] + mat4(vec4(0.082, -0.142, 0.078, -0.079), vec4(0.082, -0.030, -0.204, 0.237), vec4(0.143, -0.026, 0.001, 0.102), vec4(-0.106, 0.221, -0.073, -0.028)) * bufB[7] + mat4(vec4(0.149, 0.225, -0.172, 0.081), vec4(0.064, -0.124, 0.148, -0.000), vec4(0.196, 0.251, 0.174, 0.089), vec4(-0.361, 0.177, -0.224, 0.026)) * bufB[8] + mat4(vec4(0.071, 0.155, 0.109, -0.123), vec4(0.167, 0.003, 0.098, -0.053), vec4(0.206, -0.359, -0.006, -0.064), vec4(0.022, 0.046, 0.008, 0.188)) * bufB[9];\nbufA[2] = vec4(-0.241, 0.381, 0.069, 0.124) + mat4(vec4(0.035, -0.062, -0.008, -0.076), vec4(0.035, -0.034, -0.322, 0.026), vec4(0.177, 0.262, 0.090, -0.320), vec4(-0.000, 0.106, -0.011, -0.067)) * bufB[0] + mat4(vec4(0.176, 0.322, 0.171, -0.048), vec4(0.023, 0.033, -0.047, -0.071), vec4(0.206, 0.053, -0.002, -0.253), vec4(-0.039, -0.060, -0.090, 0.206)) * bufB[1] + mat4(vec4(0.086, 0.031, -0.034, 0.216), vec4(-0.147, 0.190, 0.070, 0.082), vec4(0.168, -0.066, 0.052, 0.015), vec4(0.062, -0.159, 0.039, 0.260)) * bufB[2] + mat4(vec4(0.283, 0.253, -0.023, -0.078), vec4(-0.079, 0.001, 0.114, 0.066), vec4(0.205, 0.112, -0.239, -0.105), vec4(0.065, -0.041, -0.157, 0.045)) * bufB[3] + mat4(vec4(-0.407, 0.002, 0.117, 0.209), vec4(0.362, -0.092, -0.038, 0.021), vec4(-0.057, -0.085, 0.034, -0.051), vec4(0.470, -0.025, -0.216, -0.040)) * bufB[4] + mat4(vec4(0.034, -0.232, -0.099, -0.019), vec4(0.065, 0.079, -0.155, -0.029), vec4(0.068, -0.153, 0.234, 0.120), vec4(0.045, -0.022, -0.093, -0.194)) * bufB[5] + mat4(vec4(0.036, -0.107, -0.006, 0.042), vec4(0.090, -0.210, 0.075, 0.070), vec4(0.218, -0.121, 0.110, -0.002), vec4(-0.074, -0.103, 0.147, -0.256)) * bufB[6] + mat4(vec4(0.103, -0.007, -0.056, -0.059), vec4(-0.297, 0.158, 0.081, -0.087), vec4(-0.242, -0.265, 0.005, 0.199), vec4(-0.288, -0.004, -0.061, -0.093)) * bufB[7] + mat4(vec4(-0.233, -0.128, 0.165, 0.187), vec4(0.090, 0.054, -0.111, 0.102), vec4(0.016, -0.358, 0.003, 0.162), vec4(-0.083, -0.016, -0.041, 0.057)) * bufB[8] + mat4(vec4(0.007, 0.140, -0.231, -0.062), vec4(-0.101, -0.341, -0.058, 0.373), vec4(0.023, 0.315, -0.135, 0.099), vec4(0.248, 0.246, 0.147, 0.044)) * bufB[9];\nbufA[3] = vec4(0.191, -0.103, -0.386, 0.331) + mat4(vec4(-0.201, 0.118, 0.355, -0.171), vec4(0.234, 0.077, -0.128, 0.162), vec4(0.188, 0.174, 0.017, 0.011), vec4(-0.163, -0.051, 0.219, -0.062)) * bufB[0] + mat4(vec4(0.133, 0.009, 0.032, -0.036), vec4(-0.010, 0.086, -0.091, -0.034), vec4(0.448, 0.070, 0.056, -0.020), vec4(0.155, -0.064, -0.223, 0.137)) * bufB[1] + mat4(vec4(-0.158, 0.018, 0.227, 0.134), vec4(0.228, 0.034, -0.162, 0.063), vec4(0.274, 0.158, 0.020, -0.146), vec4(0.028, -0.341, -0.216, -0.120)) * bufB[2] + mat4(vec4(-0.003, 0.058, -0.109, 0.218), vec4(0.031, 0.004, 0.068, 0.122), vec4(0.110, 0.256, -0.096, -0.164), vec4(-0.231, -0.093, 0.117, -0.135)) * bufB[3] + mat4(vec4(0.109, -0.049, -0.054, 0.030), vec4(0.083, -0.176, 0.046, -0.125), vec4(0.024, 0.031, 0.137, -0.156), vec4(-0.135, -0.033, 0.093, -0.141)) * bufB[4] + mat4(vec4(-0.236, 0.124, -0.066, 0.249), vec4(-0.067, -0.024, -0.042, 0.133), vec4(-0.271, 0.022, 0.179, 0.026), vec4(0.058, -0.137, 0.205, 0.065)) * bufB[5] + mat4(vec4(-0.243, 0.024, 0.049, -0.245), vec4(0.011, -0.230, 0.203, 0.397), vec4(-0.015, 0.224, 0.196, 0.051), vec4(-0.027, -0.194, 0.078, 0.085)) * bufB[6] + mat4(vec4(0.182, 0.227, -0.270, -0.018), vec4(-0.036, -0.050, -0.234, 0.087), vec4(-0.095, 0.121, 0.101, -0.021), vec4(-0.092, 0.239, 0.296, -0.113)) * bufB[7] + mat4(vec4(-0.015, 0.284, -0.025, 0.027), vec4(-0.217, -0.005, 0.045, -0.150), vec4(-0.537, 0.217, -0.154, -0.108), vec4(-0.003, -0.043, 0.259, -0.187)) * bufB[8] + mat4(vec4(-0.129, 0.213, 0.132, 0.018), vec4(-0.270, 0.068, -0.150, -0.150), vec4(0.079, -0.100, -0.016, 0.240), vec4(0.136, 0.250, 0.046, -0.251)) * bufB[9];\nbufA[4] = vec4(0.057, -0.244, -0.173, -0.349) + mat4(vec4(0.147, -0.046, 0.137, 0.140), vec4(-0.111, -0.317, -0.060, -0.044), vec4(-0.033, -0.040, -0.192, -0.034), vec4(-0.035, 0.055, -0.044, 0.061)) * bufB[0] + mat4(vec4(-0.016, -0.039, 0.073, -0.195), vec4(0.214, -0.063, 0.022, 0.006), vec4(0.193, -0.244, -0.061, 0.120), vec4(0.260, -0.072, 0.107, 0.006)) * bufB[1] + mat4(vec4(0.204, 0.245, -0.024, -0.174), vec4(-0.014, 0.142, -0.152, 0.019), vec4(-0.043, -0.176, -0.037, -0.080), vec4(0.308, -0.180, 0.172, 0.079)) * bufB[2] + mat4(vec4(0.012, 0.080, -0.146, 0.130), vec4(-0.074, 0.229, -0.047, -0.052), vec4(-0.048, -0.143, -0.011, -0.003), vec4(-0.070, -0.251, -0.137, 0.093)) * bufB[3] + mat4(vec4(-0.079, 0.153, 0.017, -0.096), vec4(0.021, -0.135, 0.175, 0.275), vec4(-0.102, -0.022, -0.161, 0.221), vec4(0.454, 0.010, -0.076, 0.005)) * bufB[4] + mat4(vec4(0.084, -0.254, 0.116, -0.150), vec4(0.033, -0.087, 0.290, -0.142), vec4(0.166, -0.036, -0.051, 0.015), vec4(0.354, -0.018, 0.031, -0.194)) * bufB[5] + mat4(vec4(-0.032, 0.171, -0.244, 0.206), vec4(0.217, -0.088, -0.363, 0.200), vec4(-0.132, -0.021, 0.201, 0.013), vec4(0.060, -0.008, 0.270, 0.067)) * bufB[6] + mat4(vec4(0.007, -0.168, -0.382, -0.292), vec4(-0.030, -0.138, -0.117, -0.175), vec4(0.105, -0.051, 0.038, 0.232), vec4(0.054, -0.017, 0.013, -0.086)) * bufB[7] + mat4(vec4(0.140, 0.069, 0.051, -0.241), vec4(-0.017, 0.279, 0.016, 0.156), vec4(0.206, -0.107, -0.101, 0.011), vec4(-0.316, -0.067, 0.132, 0.071)) * bufB[8] + mat4(vec4(-0.073, 0.073, 0.170, 0.129), vec4(0.036, -0.110, -0.111, -0.060), vec4(-0.123, 0.193, -0.023, 0.118), vec4(0.158, -0.014, 0.301, -0.342)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(0.371, -0.301, 0.423, 0.110) + mat4(vec4(-0.033, 0.107, 0.280, 0.042), vec4(0.246, 0.118, 0.062, -0.006), vec4(-0.003, 0.028, 0.070, 0.107), vec4(-0.218, 0.004, 0.103, -0.001)) * bufB[0] + mat4(vec4(0.200, -0.114, -0.236, -0.051), vec4(0.287, -0.313, 0.174, 0.132), vec4(0.068, -0.006, 0.190, -0.211), vec4(0.020, -0.019, -0.100, 0.273)) * bufB[1] + mat4(vec4(-0.087, -0.071, 0.105, 0.058), vec4(0.042, -0.087, 0.148, -0.055), vec4(-0.298, 0.347, -0.243, 0.112), vec4(0.314, 0.124, -0.243, -0.011)) * bufB[2] + mat4(vec4(-0.165, 0.035, 0.259, 0.018), vec4(-0.053, 0.234, 0.109, 0.047), vec4(0.050, -0.065, 0.122, 0.349), vec4(-0.124, 0.122, 0.158, -0.061)) * bufB[3] + mat4(vec4(0.048, -0.003, 0.034, -0.108), vec4(0.076, 0.063, -0.103, -0.208), vec4(0.057, 0.431, 0.278, 0.289), vec4(0.079, -0.048, 0.100, -0.187)) * bufB[4] + mat4(vec4(0.167, 0.024, 0.130, 0.147), vec4(-0.201, -0.096, -0.328, 0.026), vec4(0.143, -0.052, 0.034, -0.090), vec4(-0.151, -0.242, 0.053, 0.010)) * bufB[5] + mat4(vec4(0.059, 0.076, -0.095, -0.110), vec4(0.099, 0.153, -0.065, -0.189), vec4(-0.162, -0.067, -0.095, -0.086), vec4(0.018, -0.066, -0.028, 0.135)) * bufB[6] + mat4(vec4(0.087, 0.440, 0.172, 0.280), vec4(-0.250, 0.175, 0.233, -0.249), vec4(-0.271, -0.326, 0.239, 0.060), vec4(0.019, 0.249, -0.070, -0.208)) * bufB[7] + mat4(vec4(-0.078, -0.299, -0.037, -0.053), vec4(-0.056, -0.330, -0.086, 0.020), vec4(-0.057, 0.097, -0.177, 0.108), vec4(-0.156, -0.087, -0.052, -0.168)) * bufB[8] + mat4(vec4(-0.039, 0.196, 0.017, -0.103), vec4(-0.040, 0.088, 0.047, 0.214), vec4(-0.124, -0.320, -0.169, -0.281), vec4(-0.089, -0.107, 0.184, -0.211)) * bufB[9] + in0;\nbufA[1] = vec4(-0.237, -0.279, -0.534, -0.072) + mat4(vec4(-0.031, -0.340, -0.004, 0.206), vec4(-0.007, 0.141, -0.068, -0.174), vec4(-0.183, 0.059, 0.061, 0.129), vec4(-0.209, -0.022, 0.212, -0.164)) * bufB[0] + mat4(vec4(0.136, -0.296, 0.244, -0.365), vec4(0.200, 0.202, -0.137, 0.275), vec4(-0.078, -0.226, 0.175, -0.008), vec4(0.396, -0.104, -0.060, 0.067)) * bufB[1] + mat4(vec4(0.041, -0.169, 0.124, -0.111), vec4(-0.100, 0.355, -0.190, -0.126), vec4(-0.154, -0.054, -0.015, 0.172), vec4(0.018, 0.195, 0.029, -0.340)) * bufB[2] + mat4(vec4(0.113, 0.342, -0.147, -0.011), vec4(0.070, 0.091, 0.240, -0.116), vec4(-0.204, -0.277, 0.022, -0.017), vec4(0.072, 0.110, -0.200, -0.031)) * bufB[3] + mat4(vec4(0.085, -0.018, 0.151, -0.048), vec4(-0.021, -0.068, -0.158, -0.010), vec4(-0.007, -0.132, 0.200, 0.311), vec4(0.125, 0.304, 0.013, -0.220)) * bufB[4] + mat4(vec4(0.129, -0.043, 0.194, -0.163), vec4(0.071, -0.025, 0.220, 0.089), vec4(-0.043, 0.090, 0.155, -0.057), vec4(0.019, -0.017, 0.052, -0.380)) * bufB[5] + mat4(vec4(-0.063, -0.216, -0.137, 0.003), vec4(-0.079, -0.375, 0.367, -0.081), vec4(0.010, 0.049, 0.226, -0.279), vec4(-0.063, -0.408, 0.150, 0.056)) * bufB[6] + mat4(vec4(0.005, -0.062, -0.120, 0.338), vec4(-0.074, 0.054, 0.085, 0.183), vec4(0.455, -0.031, 0.194, 0.164), vec4(0.206, 0.130, -0.155, 0.016)) * bufB[7] + mat4(vec4(0.214, -0.056, -0.054, 0.180), vec4(-0.118, -0.158, -0.116, 0.045), vec4(0.216, -0.089, 0.000, -0.013), vec4(0.210, 0.031, -0.187, 0.105)) * bufB[8] + mat4(vec4(0.188, -0.027, 0.179, -0.131), vec4(0.124, 0.001, 0.082, -0.041), vec4(-0.049, 0.131, 0.245, -0.042), vec4(-0.033, 0.108, 0.054, 0.250)) * bufB[9] + in1;\nbufA[2] = vec4(0.017, -0.451, 0.261, -0.121) + mat4(vec4(-0.028, -0.183, -0.102, -0.176), vec4(0.026, 0.310, -0.058, -0.121), vec4(0.130, 0.128, -0.042, 0.178), vec4(-0.035, -0.069, 0.218, -0.080)) * bufB[0] + mat4(vec4(-0.158, -0.036, -0.108, -0.083), vec4(0.084, 0.229, -0.015, 0.126), vec4(0.280, -0.072, -0.003, 0.063), vec4(0.148, 0.090, 0.346, -0.097)) * bufB[1] + mat4(vec4(0.159, -0.177, 0.112, -0.179), vec4(-0.253, 0.033, -0.253, -0.035), vec4(-0.099, 0.276, 0.260, 0.070), vec4(0.167, 0.248, 0.217, -0.054)) * bufB[2] + mat4(vec4(-0.310, 0.036, -0.256, -0.025), vec4(-0.212, -0.211, -0.081, -0.056), vec4(-0.177, -0.012, 0.012, -0.106), vec4(-0.059, -0.119, -0.024, -0.056)) * bufB[3] + mat4(vec4(0.095, -0.002, 0.024, 0.073), vec4(-0.129, -0.201, -0.060, 0.129), vec4(-0.259, -0.110, 0.114, -0.120), vec4(0.140, -0.130, -0.399, -0.044)) * bufB[4] + mat4(vec4(-0.031, -0.207, -0.039, -0.231), vec4(0.028, -0.208, 0.104, 0.163), vec4(0.201, 0.033, 0.404, -0.013), vec4(0.108, -0.142, -0.066, -0.115)) * bufB[5] + mat4(vec4(-0.070, -0.091, -0.054, -0.133), vec4(0.189, -0.312, 0.285, -0.081), vec4(0.106, -0.047, 0.033, -0.010), vec4(0.107, 0.122, -0.098, -0.119)) * bufB[6] + mat4(vec4(-0.058, -0.147, 0.031, -0.011), vec4(0.293, -0.034, 0.238, -0.208), vec4(-0.021, 0.048, -0.056, 0.041), vec4(-0.202, -0.146, -0.144, 0.066)) * bufB[7] + mat4(vec4(0.091, 0.270, -0.189, -0.029), vec4(-0.033, 0.009, 0.150, 0.097), vec4(-0.297, 0.013, 0.278, 0.025), vec4(0.107, 0.166, -0.117, -0.017)) * bufB[8] + mat4(vec4(0.064, -0.037, 0.245, 0.110), vec4(-0.136, -0.103, 0.284, -0.179), vec4(-0.156, 0.094, 0.153, -0.225), vec4(0.254, 0.132, 0.251, -0.072)) * bufB[9] + in2;\nbufA[3] = vec4(-0.080, 0.229, 0.290, -0.204) + mat4(vec4(-0.170, 0.331, 0.160, -0.082), vec4(-0.073, 0.170, 0.071, 0.223), vec4(-0.219, 0.289, -0.089, 0.068), vec4(-0.041, -0.074, -0.077, -0.008)) * bufB[0] + mat4(vec4(-0.059, -0.088, 0.083, 0.043), vec4(-0.230, 0.008, 0.108, 0.209), vec4(0.107, -0.100, -0.052, 0.035), vec4(-0.151, 0.030, 0.289, -0.006)) * bufB[1] + mat4(vec4(-0.227, -0.127, -0.136, 0.122), vec4(0.236, 0.118, 0.170, 0.116), vec4(0.290, 0.166, 0.353, 0.192), vec4(-0.208, -0.269, 0.028, 0.345)) * bufB[2] + mat4(vec4(-0.088, 0.088, -0.052, -0.197), vec4(-0.220, -0.008, 0.075, -0.095), vec4(-0.166, -0.006, -0.013, -0.109), vec4(0.060, 0.102, -0.050, 0.360)) * bufB[3] + mat4(vec4(-0.170, -0.142, 0.295, 0.134), vec4(-0.015, -0.265, 0.019, 0.028), vec4(-0.091, -0.003, 0.266, -0.035), vec4(0.036, -0.320, -0.248, -0.025)) * bufB[4] + mat4(vec4(0.177, -0.357, -0.185, 0.466), vec4(0.038, -0.085, 0.086, 0.040), vec4(0.095, -0.081, 0.042, -0.130), vec4(0.366, 0.039, -0.130, 0.368)) * bufB[5] + mat4(vec4(-0.030, 0.126, 0.136, 0.022), vec4(-0.108, -0.051, 0.157, -0.213), vec4(0.235, -0.205, -0.071, 0.048), vec4(-0.103, -0.078, 0.087, -0.045)) * bufB[6] + mat4(vec4(-0.101, 0.326, -0.228, 0.003), vec4(-0.083, -0.307, 0.200, -0.051), vec4(-0.039, -0.061, 0.364, 0.220), vec4(-0.059, 0.072, 0.052, 0.053)) * bufB[7] + mat4(vec4(0.087, -0.189, -0.203, -0.003), vec4(-0.072, -0.086, 0.106, 0.240), vec4(-0.105, 0.269, 0.199, 0.220), vec4(0.181, 0.146, -0.001, -0.046)) * bufB[8] + mat4(vec4(-0.048, -0.013, 0.160, 0.144), vec4(0.073, -0.177, 0.156, 0.075), vec4(0.082, -0.164, 0.281, 0.198), vec4(0.107, 0.319, 0.268, 0.039)) * bufB[9] + in3;\nbufA[4] = vec4(-0.154, 0.184, -0.304, -0.068) + mat4(vec4(0.033, -0.115, 0.208, -0.057), vec4(0.065, -0.078, 0.010, 0.107), vec4(-0.039, -0.215, -0.272, -0.059), vec4(-0.029, 0.003, 0.206, -0.132)) * bufB[0] + mat4(vec4(0.241, -0.195, 0.078, 0.110), vec4(-0.285, 0.097, 0.095, -0.142), vec4(0.400, 0.083, 0.124, -0.276), vec4(-0.069, -0.080, -0.146, -0.031)) * bufB[1] + mat4(vec4(-0.214, -0.222, -0.203, 0.292), vec4(-0.326, 0.091, -0.060, -0.171), vec4(0.143, 0.228, 0.037, -0.051), vec4(-0.127, 0.303, 0.123, -0.341)) * bufB[2] + mat4(vec4(-0.202, 0.169, -0.039, 0.081), vec4(0.123, -0.127, 0.130, 0.079), vec4(0.274, -0.068, -0.219, -0.115), vec4(-0.071, 0.037, -0.029, 0.257)) * bufB[3] + mat4(vec4(0.009, 0.005, -0.168, 0.027), vec4(0.183, -0.049, 0.200, 0.040), vec4(0.011, -0.215, -0.190, -0.146), vec4(0.194, -0.286, -0.037, 0.115)) * bufB[4] + mat4(vec4(0.148, -0.005, 0.195, 0.337), vec4(0.150, 0.143, -0.094, -0.117), vec4(-0.047, 0.165, -0.128, 0.035), vec4(-0.132, 0.091, -0.077, 0.080)) * bufB[5] + mat4(vec4(-0.132, 0.150, -0.283, 0.197), vec4(0.141, -0.144, 0.015, 0.110), vec4(-0.435, 0.251, -0.114, 0.076), vec4(-0.009, 0.077, 0.182, 0.150)) * bufB[6] + mat4(vec4(0.083, -0.079, 0.232, -0.246), vec4(-0.195, -0.363, 0.089, -0.130), vec4(-0.259, 0.188, -0.081, -0.192), vec4(0.290, -0.265, -0.178, -0.275)) * bufB[7] + mat4(vec4(-0.039, -0.060, 0.053, 0.113), vec4(0.032, -0.045, -0.017, 0.245), vec4(-0.061, 0.049, -0.104, 0.043), vec4(-0.071, -0.092, -0.080, 0.014)) * bufB[8] + mat4(vec4(0.244, 0.077, -0.150, 0.112), vec4(0.073, -0.054, 0.123, 0.051), vec4(-0.031, -0.110, -0.336, 0.207), vec4(-0.088, 0.053, -0.008, -0.039)) * bufB[9] + in0;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(-0.055, 0.531, -0.397, -0.065) + mat4(vec4(0.048, -0.070, -0.260, -0.137), vec4(0.074, 0.110, -0.085, 0.029), vec4(-0.143, 0.265, 0.317, 0.147), vec4(-0.156, 0.103, -0.148, -0.374)) * bufB[0] + mat4(vec4(-0.037, -0.291, -0.130, 0.027), vec4(0.242, 0.023, 0.173, -0.059), vec4(-0.040, -0.112, -0.101, 0.081), vec4(-0.037, -0.282, -0.118, -0.002)) * bufB[1] + mat4(vec4(-0.329, -0.316, -0.094, -0.001), vec4(0.157, -0.108, -0.216, 0.115), vec4(0.343, -0.247, 0.159, 0.024), vec4(0.051, -0.065, -0.279, 0.193)) * bufB[2] + mat4(vec4(-0.194, 0.221, -0.021, 0.063), vec4(0.155, 0.250, 0.094, 0.107), vec4(-0.021, -0.210, -0.121, -0.003), vec4(0.001, -0.018, -0.024, 0.116)) * bufB[3] + mat4(vec4(0.042, -0.131, -0.124, -0.184), vec4(-0.092, -0.009, 0.151, -0.035), vec4(-0.029, 0.061, 0.101, 0.095), vec4(-0.111, -0.007, -0.093, 0.049)) * bufB[4] + mat4(vec4(0.175, -0.146, -0.211, -0.282), vec4(0.003, -0.015, 0.043, -0.319), vec4(-0.247, -0.033, 0.348, 0.117), vec4(-0.217, -0.160, -0.181, -0.035)) * bufB[5] + mat4(vec4(-0.059, -0.231, 0.130, -0.071), vec4(-0.009, 0.358, -0.137, 0.068), vec4(0.249, 0.349, 0.006, 0.148), vec4(-0.140, -0.153, 0.106, 0.012)) * bufB[6] + mat4(vec4(-0.065, -0.050, -0.305, -0.041), vec4(-0.185, 0.102, 0.077, 0.028), vec4(-0.109, -0.101, 0.048, 0.020), vec4(0.006, 0.021, 0.088, -0.117)) * bufB[7] + mat4(vec4(0.005, 0.129, 0.177, -0.172), vec4(-0.008, 0.107, 0.097, 0.151), vec4(-0.225, 0.184, 0.209, 0.129), vec4(-0.090, 0.104, 0.134, -0.006)) * bufB[8] + mat4(vec4(-0.122, 0.156, 0.008, 0.090), vec4(0.267, -0.084, 0.008, 0.180), vec4(0.054, 0.080, 0.049, -0.002), vec4(-0.131, -0.024, 0.260, -0.009)) * bufB[9];\nbufA[1] = vec4(0.106, 0.463, 0.080, -0.469) + mat4(vec4(-0.151, -0.236, -0.032, -0.276), vec4(-0.129, 0.044, 0.065, -0.077), vec4(0.018, 0.024, -0.064, 0.149), vec4(0.057, -0.104, 0.046, -0.083)) * bufB[0] + mat4(vec4(-0.024, 0.121, 0.065, 0.135), vec4(-0.252, -0.136, 0.141, -0.074), vec4(0.256, 0.087, 0.097, -0.012), vec4(0.052, 0.009, -0.053, 0.035)) * bufB[1] + mat4(vec4(-0.127, -0.071, 0.230, 0.252), vec4(-0.123, -0.046, -0.013, 0.196), vec4(0.129, -0.179, 0.016, -0.132), vec4(-0.200, 0.185, 0.104, 0.084)) * bufB[2] + mat4(vec4(0.186, 0.132, 0.175, 0.069), vec4(0.100, -0.143, -0.040, 0.122), vec4(0.011, -0.054, 0.076, 0.040), vec4(0.106, -0.199, 0.057, -0.060)) * bufB[3] + mat4(vec4(-0.090, 0.355, 0.162, -0.336), vec4(-0.003, 0.114, 0.131, -0.090), vec4(-0.151, -0.008, 0.323, -0.309), vec4(0.187, 0.144, 0.148, 0.092)) * bufB[4] + mat4(vec4(0.468, 0.353, -0.002, -0.126), vec4(0.156, -0.032, -0.364, -0.223), vec4(0.243, 0.059, -0.141, 0.055), vec4(0.061, -0.048, 0.001, -0.165)) * bufB[5] + mat4(vec4(0.010, -0.068, -0.105, -0.038), vec4(-0.134, -0.064, 0.058, 0.083), vec4(0.065, 0.377, 0.070, 0.060), vec4(0.032, -0.374, -0.103, -0.027)) * bufB[6] + mat4(vec4(-0.275, -0.046, 0.144, -0.159), vec4(-0.172, 0.045, 0.086, 0.255), vec4(0.131, 0.092, 0.038, 0.198), vec4(0.260, -0.222, 0.223, -0.118)) * bufB[7] + mat4(vec4(-0.034, -0.068, -0.022, 0.094), vec4(-0.107, -0.098, -0.143, -0.006), vec4(-0.056, -0.185, 0.001, -0.121), vec4(-0.118, -0.246, 0.125, 0.155)) * bufB[8] + mat4(vec4(0.076, 0.198, -0.233, 0.179), vec4(-0.082, 0.017, 0.019, 0.179), vec4(0.216, -0.126, -0.119, 0.206), vec4(0.073, -0.095, -0.101, -0.172)) * bufB[9];\nbufA[2] = vec4(0.448, 0.134, 0.412, 0.295) + mat4(vec4(-0.185, 0.166, -0.071, -0.139), vec4(-0.264, 0.225, -0.028, -0.020), vec4(0.269, 0.038, 0.318, -0.053), vec4(0.049, 0.019, -0.085, 0.020)) * bufB[0] + mat4(vec4(-0.228, -0.223, -0.249, -0.180), vec4(-0.139, -0.033, -0.060, 0.182), vec4(0.114, 0.174, 0.002, -0.190), vec4(-0.230, -0.268, -0.330, 0.144)) * bufB[1] + mat4(vec4(0.054, -0.221, -0.426, 0.009), vec4(-0.117, -0.151, 0.231, -0.105), vec4(0.010, 0.056, 0.106, -0.138), vec4(-0.033, 0.000, -0.172, 0.004)) * bufB[2] + mat4(vec4(0.224, 0.122, 0.051, 0.141), vec4(-0.091, 0.162, 0.050, -0.288), vec4(0.268, 0.195, 0.025, -0.386), vec4(-0.037, -0.016, 0.102, 0.094)) * bufB[3] + mat4(vec4(0.130, -0.031, -0.121, 0.033), vec4(-0.037, 0.340, 0.109, 0.121), vec4(0.054, 0.160, 0.074, 0.333), vec4(-0.090, 0.061, -0.127, -0.072)) * bufB[4] + mat4(vec4(-0.176, 0.158, -0.042, 0.118), vec4(-0.143, 0.165, -0.164, 0.219), vec4(-0.177, 0.007, -0.154, -0.016), vec4(-0.149, -0.002, 0.155, 0.104)) * bufB[5] + mat4(vec4(0.053, 0.092, 0.034, 0.183), vec4(0.333, -0.023, 0.007, -0.043), vec4(0.114, -0.121, 0.149, -0.046), vec4(0.045, 0.063, 0.140, -0.170)) * bufB[6] + mat4(vec4(-0.073, 0.031, -0.023, 0.028), vec4(0.162, 0.187, 0.432, 0.020), vec4(-0.088, 0.145, -0.075, -0.295), vec4(0.027, 0.070, -0.047, -0.300)) * bufB[7] + mat4(vec4(0.088, -0.196, -0.072, 0.322), vec4(-0.207, -0.041, -0.011, -0.255), vec4(0.034, 0.087, 0.279, -0.350), vec4(-0.203, 0.052, -0.108, -0.232)) * bufB[8] + mat4(vec4(0.006, -0.265, -0.072, 0.094), vec4(-0.125, -0.142, 0.232, 0.178), vec4(-0.051, 0.061, -0.077, -0.004), vec4(-0.294, -0.007, -0.051, -0.143)) * bufB[9];\nbufA[3] = vec4(-0.352, 0.131, -0.023, 0.456) + mat4(vec4(-0.303, -0.118, 0.064, 0.005), vec4(0.063, 0.310, -0.017, -0.288), vec4(0.149, 0.322, -0.185, 0.185), vec4(-0.084, 0.038, 0.055, 0.104)) * bufB[0] + mat4(vec4(0.200, 0.238, -0.014, 0.168), vec4(0.098, 0.012, 0.018, -0.073), vec4(-0.116, -0.004, 0.042, 0.089), vec4(-0.074, 0.291, -0.058, 0.148)) * bufB[1] + mat4(vec4(0.015, -0.254, -0.164, -0.368), vec4(0.016, -0.040, 0.044, 0.053), vec4(-0.117, 0.252, -0.119, 0.384), vec4(-0.276, 0.038, -0.007, 0.172)) * bufB[2] + mat4(vec4(0.276, 0.055, 0.007, -0.075), vec4(0.386, 0.082, 0.173, -0.022), vec4(0.099, 0.082, 0.077, 0.099), vec4(0.218, 0.162, 0.006, 0.030)) * bufB[3] + mat4(vec4(-0.137, -0.255, -0.088, 0.200), vec4(-0.276, -0.196, 0.229, 0.086), vec4(-0.206, -0.036, 0.072, -0.009), vec4(0.039, 0.124, 0.205, 0.204)) * bufB[4] + mat4(vec4(-0.233, -0.207, 0.037, -0.040), vec4(-0.103, -0.104, 0.131, 0.099), vec4(0.083, 0.104, -0.177, -0.100), vec4(-0.125, -0.158, -0.117, 0.145)) * bufB[5] + mat4(vec4(0.082, -0.124, 0.069, 0.020), vec4(-0.055, 0.120, 0.205, 0.096), vec4(0.122, 0.006, -0.186, 0.001), vec4(0.111, 0.000, -0.004, 0.220)) * bufB[6] + mat4(vec4(-0.028, -0.060, -0.088, -0.128), vec4(0.297, -0.070, -0.065, 0.068), vec4(0.076, 0.129, -0.148, -0.096), vec4(0.008, -0.076, 0.012, -0.152)) * bufB[7] + mat4(vec4(0.332, -0.063, 0.203, -0.053), vec4(-0.141, 0.013, -0.092, 0.083), vec4(0.270, 0.325, -0.261, -0.176), vec4(-0.022, -0.085, -0.116, -0.136)) * bufB[8] + mat4(vec4(0.109, 0.275, 0.137, 0.060), vec4(-0.047, -0.048, -0.005, 0.231), vec4(-0.176, -0.049, -0.066, -0.164), vec4(-0.106, -0.202, 0.005, 0.013)) * bufB[9];\nbufA[4] = vec4(0.506, 0.422, -0.259, -0.141) + mat4(vec4(0.179, -0.012, 0.058, -0.082), vec4(-0.037, -0.040, -0.128, -0.174), vec4(-0.012, -0.188, 0.014, -0.042), vec4(0.106, -0.161, -0.129, 0.310)) * bufB[0] + mat4(vec4(0.177, 0.087, -0.089, -0.113), vec4(0.084, 0.209, 0.036, 0.166), vec4(0.062, 0.103, 0.018, 0.016), vec4(0.254, 0.178, 0.458, 0.263)) * bufB[1] + mat4(vec4(-0.419, 0.135, 0.215, 0.113), vec4(-0.117, 0.090, 0.106, -0.151), vec4(0.057, -0.161, 0.085, 0.169), vec4(-0.147, -0.140, 0.066, 0.058)) * bufB[2] + mat4(vec4(0.294, -0.160, 0.090, 0.196), vec4(0.178, -0.061, 0.067, -0.157), vec4(0.344, -0.035, 0.104, -0.128), vec4(0.055, 0.284, -0.245, 0.188)) * bufB[3] + mat4(vec4(0.079, -0.252, -0.176, -0.411), vec4(-0.040, -0.046, 0.196, -0.035), vec4(0.529, -0.157, -0.088, 0.205), vec4(-0.243, 0.173, -0.109, 0.055)) * bufB[4] + mat4(vec4(0.232, -0.281, 0.024, -0.131), vec4(-0.001, 0.099, -0.119, -0.210), vec4(-0.039, -0.010, 0.046, 0.007), vec4(-0.144, 0.137, 0.010, -0.017)) * bufB[5] + mat4(vec4(0.135, -0.059, 0.025, 0.107), vec4(0.035, -0.101, 0.099, 0.157), vec4(-0.147, 0.091, -0.053, 0.086), vec4(-0.069, 0.050, -0.182, 0.029)) * bufB[6] + mat4(vec4(-0.286, 0.152, 0.239, -0.207), vec4(-0.238, -0.038, -0.131, 0.082), vec4(-0.027, 0.090, 0.072, 0.290), vec4(0.101, -0.268, -0.117, -0.157)) * bufB[7] + mat4(vec4(-0.272, -0.045, -0.170, -0.054), vec4(0.226, -0.042, 0.029, -0.066), vec4(0.237, -0.098, -0.096, 0.097), vec4(0.014, -0.030, -0.159, 0.044)) * bufB[8] + mat4(vec4(-0.037, -0.412, 0.064, -0.198), vec4(-0.097, 0.125, 0.217, 0.018), vec4(-0.170, -0.050, -0.291, 0.166), vec4(0.064, 0.447, 0.116, 0.025)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(-0.438, 0.341, -0.337, 0.160) + mat4(vec4(-0.000, 0.093, -0.171, -0.460), vec4(0.093, 0.300, -0.041, -0.359), vec4(0.079, -0.259, -0.085, 0.025), vec4(0.046, 0.090, 0.044, -0.201)) * bufB[0] + mat4(vec4(-0.126, -0.430, 0.060, -0.073), vec4(-0.059, -0.231, 0.218, -0.008), vec4(0.256, 0.154, 0.298, 0.115), vec4(0.076, -0.156, 0.032, -0.041)) * bufB[1] + mat4(vec4(-0.026, 0.010, 0.089, 0.165), vec4(0.089, -0.296, 0.215, -0.147), vec4(-0.026, -0.070, -0.034, -0.189), vec4(-0.132, 0.029, -0.428, -0.182)) * bufB[2] + mat4(vec4(-0.110, 0.063, -0.031, 0.030), vec4(0.058, 0.138, -0.055, -0.045), vec4(0.147, -0.123, 0.098, -0.218), vec4(0.053, 0.024, 0.192, -0.074)) * bufB[3] + mat4(vec4(-0.025, 0.145, -0.029, -0.143), vec4(0.099, -0.084, -0.072, 0.139), vec4(0.034, -0.180, 0.172, -0.104), vec4(-0.217, 0.164, -0.075, -0.323)) * bufB[4] + mat4(vec4(-0.290, 0.063, -0.125, -0.140), vec4(0.103, 0.245, -0.113, -0.058), vec4(-0.283, -0.068, -0.057, -0.154), vec4(0.127, -0.064, 0.285, 0.015)) * bufB[5] + mat4(vec4(-0.170, -0.074, -0.186, 0.126), vec4(-0.309, 0.137, 0.135, 0.068), vec4(-0.041, 0.276, -0.049, -0.127), vec4(-0.054, -0.029, -0.262, 0.041)) * bufB[6] + mat4(vec4(0.157, -0.145, 0.044, 0.100), vec4(0.123, -0.096, 0.034, 0.403), vec4(0.076, 0.045, 0.113, -0.197), vec4(0.061, 0.162, -0.276, -0.049)) * bufB[7] + mat4(vec4(-0.045, -0.033, -0.405, -0.141), vec4(0.060, -0.152, -0.226, 0.063), vec4(-0.044, -0.036, -0.037, 0.106), vec4(0.049, -0.096, -0.184, 0.171)) * bufB[8] + mat4(vec4(0.020, 0.028, 0.112, -0.312), vec4(-0.046, 0.025, -0.165, 0.032), vec4(-0.031, 0.095, -0.067, 0.206), vec4(-0.055, 0.022, 0.192, 0.021)) * bufB[9];\nbufA[1] = vec4(-0.304, 0.264, 0.061, 0.332) + mat4(vec4(-0.023, -0.247, 0.016, 0.013), vec4(-0.137, 0.058, -0.142, 0.101), vec4(0.141, 0.001, -0.206, 0.079), vec4(-0.245, 0.049, -0.314, 0.035)) * bufB[0] + mat4(vec4(0.146, 0.077, 0.134, -0.282), vec4(-0.099, -0.244, -0.105, -0.230), vec4(-0.030, -0.107, -0.039, 0.181), vec4(0.215, 0.106, -0.096, 0.001)) * bufB[1] + mat4(vec4(0.083, -0.242, -0.253, 0.019), vec4(0.070, 0.270, 0.324, 0.057), vec4(-0.066, -0.052, -0.093, -0.221), vec4(0.133, -0.146, -0.145, -0.134)) * bufB[2] + mat4(vec4(0.046, -0.047, -0.278, 0.013), vec4(0.226, -0.117, -0.149, -0.087), vec4(-0.136, -0.297, -0.003, -0.155), vec4(0.102, 0.299, -0.004, -0.008)) * bufB[3] + mat4(vec4(-0.174, 0.282, 0.161, -0.024), vec4(0.167, 0.103, -0.240, 0.024), vec4(-0.199, -0.037, -0.155, 0.073), vec4(-0.298, 0.115, 0.149, 0.159)) * bufB[4] + mat4(vec4(0.234, 0.004, 0.032, 0.165), vec4(0.030, 0.010, 0.019, -0.115), vec4(-0.074, 0.113, 0.092, 0.392), vec4(-0.177, -0.023, -0.386, 0.402)) * bufB[5] + mat4(vec4(0.199, -0.031, 0.084, -0.062), vec4(-0.083, 0.003, -0.168, -0.166), vec4(0.383, 0.110, -0.251, 0.105), vec4(-0.059, -0.080, -0.010, -0.062)) * bufB[6] + mat4(vec4(0.147, 0.017, -0.039, -0.009), vec4(-0.303, -0.053, -0.122, 0.156), vec4(0.321, -0.099, -0.147, 0.126), vec4(0.007, -0.243, -0.050, -0.284)) * bufB[7] + mat4(vec4(-0.167, -0.056, -0.027, 0.140), vec4(-0.102, -0.066, -0.176, 0.069), vec4(-0.068, -0.266, -0.136, -0.098), vec4(-0.201, 0.154, -0.045, 0.020)) * bufB[8] + mat4(vec4(-0.106, -0.011, 0.569, 0.006), vec4(0.197, -0.004, 0.189, 0.015), vec4(0.057, -0.071, 0.261, -0.223), vec4(-0.094, -0.142, -0.035, 0.157)) * bufB[9];\nbufA[2] = vec4(-0.038, -0.326, 0.164, -0.175) + mat4(vec4(-0.039, -0.023, -0.108, 0.253), vec4(-0.126, 0.133, -0.039, 0.120), vec4(-0.097, 0.130, 0.033, -0.282), vec4(-0.033, 0.132, 0.304, 0.007)) * bufB[0] + mat4(vec4(-0.103, -0.043, 0.224, -0.104), vec4(0.014, -0.116, 0.276, 0.012), vec4(0.158, 0.009, -0.251, 0.070), vec4(0.024, 0.157, 0.255, -0.129)) * bufB[1] + mat4(vec4(-0.220, -0.003, -0.423, -0.145), vec4(0.170, -0.162, -0.240, 0.044), vec4(-0.271, 0.139, 0.281, 0.327), vec4(-0.038, 0.017, 0.425, 0.031)) * bufB[2] + mat4(vec4(-0.108, 0.183, 0.156, 0.079), vec4(-0.043, -0.121, 0.156, 0.096), vec4(0.137, -0.014, 0.106, -0.076), vec4(-0.173, 0.011, 0.011, 0.322)) * bufB[3] + mat4(vec4(-0.116, -0.294, 0.098, -0.086), vec4(-0.183, 0.037, -0.104, -0.084), vec4(-0.179, 0.028, -0.076, -0.015), vec4(0.265, 0.174, 0.050, 0.263)) * bufB[4] + mat4(vec4(0.154, -0.032, -0.250, 0.434), vec4(0.496, 0.062, 0.238, -0.020), vec4(0.057, -0.121, 0.016, -0.200), vec4(-0.339, -0.095, -0.385, 0.018)) * bufB[5] + mat4(vec4(0.158, 0.058, -0.064, 0.056), vec4(0.225, 0.221, -0.127, -0.360), vec4(0.033, 0.120, -0.222, 0.064), vec4(-0.284, -0.178, 0.100, 0.156)) * bufB[6] + mat4(vec4(-0.214, -0.046, -0.029, -0.062), vec4(-0.076, -0.085, -0.152, 0.180), vec4(0.083, 0.005, 0.023, 0.073), vec4(0.194, 0.016, -0.249, 0.028)) * bufB[7] + mat4(vec4(-0.104, -0.337, -0.027, 0.012), vec4(-0.393, 0.096, -0.140, 0.110), vec4(-0.189, -0.003, 0.097, 0.046), vec4(-0.102, 0.291, 0.045, -0.157)) * bufB[8] + mat4(vec4(0.219, -0.209, 0.059, 0.169), vec4(0.119, -0.105, 0.033, 0.026), vec4(0.106, -0.098, -0.021, 0.099), vec4(0.177, 0.003, 0.228, 0.098)) * bufB[9];\nbufA[3] = vec4(0.577, -0.035, 0.058, 0.310) + mat4(vec4(-0.103, -0.026, -0.077, 0.174), vec4(-0.013, -0.006, 0.118, -0.114), vec4(-0.013, 0.338, 0.078, -0.095), vec4(0.146, -0.120, -0.205, -0.070)) * bufB[0] + mat4(vec4(0.125, 0.019, -0.148, 0.033), vec4(0.085, 0.033, -0.199, 0.168), vec4(-0.144, -0.063, 0.187, -0.101), vec4(-0.114, 0.150, -0.045, -0.260)) * bufB[1] + mat4(vec4(0.087, 0.018, 0.122, -0.297), vec4(0.029, -0.000, 0.071, 0.116), vec4(-0.046, 0.035, 0.148, -0.011), vec4(-0.029, 0.067, 0.036, 0.010)) * bufB[2] + mat4(vec4(-0.105, 0.110, 0.101, -0.343), vec4(0.217, 0.089, -0.218, 0.066), vec4(-0.098, -0.011, -0.087, -0.374), vec4(0.007, -0.220, 0.102, -0.137)) * bufB[3] + mat4(vec4(0.114, -0.286, -0.421, -0.084), vec4(-0.205, -0.064, 0.211, -0.092), vec4(0.023, 0.151, 0.129, 0.118), vec4(0.134, 0.146, 0.076, -0.065)) * bufB[4] + mat4(vec4(-0.207, 0.159, 0.280, 0.282), vec4(0.009, -0.013, 0.149, -0.039), vec4(0.132, 0.094, -0.016, -0.001), vec4(-0.127, 0.135, -0.028, -0.328)) * bufB[5] + mat4(vec4(-0.129, 0.079, -0.272, -0.059), vec4(-0.053, -0.171, -0.109, -0.120), vec4(-0.203, 0.045, -0.004, -0.072), vec4(-0.071, 0.122, 0.053, 0.246)) * bufB[6] + mat4(vec4(-0.127, -0.211, -0.011, -0.014), vec4(-0.128, -0.017, 0.097, -0.118), vec4(0.046, 0.190, 0.078, 0.082), vec4(0.068, -0.140, -0.144, -0.317)) * bufB[7] + mat4(vec4(0.011, -0.000, -0.071, -0.170), vec4(0.028, -0.169, -0.386, -0.012), vec4(-0.201, -0.040, -0.062, -0.176), vec4(0.136, 0.280, -0.059, 0.392)) * bufB[8] + mat4(vec4(-0.140, -0.137, -0.088, 0.215), vec4(0.091, 0.013, -0.090, -0.156), vec4(0.256, 0.356, 0.013, 0.234), vec4(-0.058, -0.188, -0.046, -0.075)) * bufB[9];\nbufA[4] = vec4(0.345, -0.075, 0.440, 0.286) + mat4(vec4(0.088, 0.058, 0.055, -0.118), vec4(-0.105, -0.025, 0.138, 0.081), vec4(-0.192, 0.176, -0.147, 0.149), vec4(-0.022, -0.154, -0.132, 0.049)) * bufB[0] + mat4(vec4(-0.139, 0.060, 0.040, 0.083), vec4(0.129, 0.068, 0.031, -0.222), vec4(0.109, 0.125, -0.196, -0.083), vec4(0.003, -0.015, -0.165, -0.302)) * bufB[1] + mat4(vec4(0.152, 0.053, 0.128, -0.096), vec4(-0.264, -0.124, -0.006, -0.137), vec4(-0.268, 0.336, -0.013, -0.229), vec4(0.017, 0.064, 0.449, 0.063)) * bufB[2] + mat4(vec4(-0.148, 0.062, -0.075, -0.176), vec4(-0.113, 0.064, 0.283, -0.199), vec4(0.059, 0.233, 0.245, -0.222), vec4(0.157, 0.196, 0.040, 0.007)) * bufB[3] + mat4(vec4(-0.201, 0.189, 0.341, -0.179), vec4(0.156, 0.066, 0.005, 0.049), vec4(-0.224, -0.091, 0.140, -0.118), vec4(0.023, 0.268, 0.126, 0.059)) * bufB[4] + mat4(vec4(-0.250, -0.084, 0.041, 0.025), vec4(-0.085, -0.111, -0.011, -0.153), vec4(-0.056, -0.016, -0.003, 0.163), vec4(-0.024, 0.008, 0.059, -0.117)) * bufB[5] + mat4(vec4(0.067, 0.166, -0.017, -0.027), vec4(0.407, -0.010, 0.063, 0.214), vec4(0.101, -0.007, -0.168, -0.108), vec4(0.030, -0.038, 0.039, -0.058)) * bufB[6] + mat4(vec4(0.054, 0.068, -0.125, 0.300), vec4(0.247, -0.081, 0.218, -0.163), vec4(0.126, -0.033, -0.106, -0.153), vec4(0.100, 0.280, -0.086, -0.083)) * bufB[7] + mat4(vec4(-0.170, 0.162, 0.064, 0.131), vec4(-0.118, 0.053, -0.003, -0.002), vec4(0.162, -0.119, 0.033, 0.009), vec4(-0.217, -0.214, -0.159, -0.147)) * bufB[8] + mat4(vec4(0.162, 0.002, -0.110, -0.118), vec4(0.075, -0.435, -0.085, -0.053), vec4(-0.245, -0.246, 0.043, -0.113), vec4(0.025, -0.062, 0.002, 0.049)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(-0.296, -0.186, 0.177, 0.265) + mat4(vec4(-0.001, -0.026, -0.145, 0.094), vec4(0.162, -0.123, 0.105, 0.014), vec4(0.149, 0.226, 0.289, 0.082), vec4(0.187, -0.029, 0.192, 0.116)) * bufB[0] + mat4(vec4(0.009, 0.022, 0.018, 0.017), vec4(0.097, -0.142, 0.163, 0.226), vec4(-0.118, 0.052, -0.222, 0.482), vec4(0.062, -0.027, 0.382, -0.354)) * bufB[1] + mat4(vec4(0.070, -0.154, -0.010, 0.088), vec4(-0.146, -0.226, -0.298, -0.004), vec4(-0.288, -0.107, -0.056, -0.342), vec4(-0.067, 0.080, -0.035, 0.089)) * bufB[2] + mat4(vec4(-0.114, 0.055, 0.266, 0.065), vec4(0.178, -0.099, -0.051, -0.147), vec4(0.004, -0.302, -0.170, 0.212), vec4(-0.050, 0.067, 0.002, -0.055)) * bufB[3] + mat4(vec4(-0.135, 0.101, 0.107, -0.046), vec4(0.034, -0.030, -0.306, -0.187), vec4(0.106, -0.100, -0.210, -0.078), vec4(-0.194, -0.089, -0.167, -0.109)) * bufB[4] + mat4(vec4(-0.129, -0.138, 0.028, -0.014), vec4(0.129, -0.034, -0.067, 0.142), vec4(0.077, -0.267, 0.101, 0.008), vec4(0.120, 0.032, -0.084, 0.198)) * bufB[5] + mat4(vec4(-0.052, 0.250, 0.021, -0.057), vec4(0.066, -0.011, -0.148, 0.400), vec4(0.119, -0.216, -0.117, 0.092), vec4(-0.119, 0.239, 0.152, 0.253)) * bufB[6] + mat4(vec4(0.174, -0.173, 0.138, 0.252), vec4(0.198, 0.134, 0.057, -0.206), vec4(-0.237, -0.083, -0.107, -0.236), vec4(0.180, -0.272, -0.253, 0.311)) * bufB[7] + mat4(vec4(0.380, 0.219, 0.027, 0.194), vec4(-0.044, -0.103, 0.063, 0.051), vec4(0.055, 0.060, 0.080, -0.282), vec4(-0.044, 0.157, -0.230, -0.150)) * bufB[8] + mat4(vec4(0.120, 0.297, -0.029, 0.073), vec4(0.087, 0.125, 0.022, -0.042), vec4(0.375, 0.012, -0.051, -0.059), vec4(0.017, -0.131, -0.180, -0.030)) * bufB[9];\nbufA[1] = vec4(-0.038, -0.082, -0.034, 0.137) + mat4(vec4(0.038, 0.260, 0.231, 0.049), vec4(-0.131, 0.141, -0.173, 0.053), vec4(0.018, 0.101, 0.120, -0.151), vec4(-0.154, 0.310, -0.121, -0.035)) * bufB[0] + mat4(vec4(-0.079, -0.321, 0.297, -0.077), vec4(0.048, -0.085, -0.173, 0.354), vec4(0.083, 0.276, 0.120, 0.016), vec4(-0.142, 0.092, 0.001, 0.065)) * bufB[1] + mat4(vec4(0.092, 0.111, 0.317, 0.263), vec4(0.092, -0.155, -0.272, 0.211), vec4(0.097, -0.412, 0.064, -0.270), vec4(0.005, 0.224, -0.001, 0.098)) * bufB[2] + mat4(vec4(-0.079, -0.187, 0.032, 0.085), vec4(-0.039, -0.295, 0.290, 0.083), vec4(-0.056, 0.035, 0.068, -0.181), vec4(-0.088, 0.206, 0.021, -0.329)) * bufB[3] + mat4(vec4(-0.022, 0.225, 0.357, -0.155), vec4(0.262, -0.101, -0.037, 0.363), vec4(0.157, -0.146, -0.062, 0.074), vec4(0.070, 0.283, 0.076, 0.017)) * bufB[4] + mat4(vec4(0.162, -0.074, 0.181, 0.015), vec4(-0.048, 0.028, -0.378, -0.069), vec4(-0.071, 0.170, -0.002, -0.042), vec4(-0.212, -0.300, 0.016, 0.061)) * bufB[5] + mat4(vec4(-0.062, 0.112, -0.086, 0.077), vec4(-0.147, 0.143, -0.257, 0.261), vec4(-0.030, 0.354, -0.356, 0.227), vec4(0.165, -0.293, -0.001, -0.001)) * bufB[6] + mat4(vec4(0.117, -0.076, -0.025, -0.240), vec4(0.049, 0.248, 0.319, 0.191), vec4(0.182, -0.191, -0.128, 0.014), vec4(0.231, 0.243, 0.197, -0.165)) * bufB[7] + mat4(vec4(0.317, -0.048, -0.053, -0.132), vec4(0.184, 0.069, 0.330, -0.127), vec4(0.189, -0.162, 0.261, -0.032), vec4(-0.148, 0.277, -0.076, 0.173)) * bufB[8] + mat4(vec4(0.062, 0.187, -0.160, 0.368), vec4(-0.069, -0.049, 0.024, -0.217), vec4(-0.100, 0.072, -0.105, -0.070), vec4(-0.054, 0.073, 0.030, -0.114)) * bufB[9];\nbufA[2] = vec4(0.106, 0.404, -0.330, 0.071) + mat4(vec4(-0.023, -0.123, -0.056, -0.265), vec4(0.139, 0.084, -0.365, 0.436), vec4(0.021, -0.319, -0.083, -0.142), vec4(-0.403, -0.256, -0.084, 0.025)) * bufB[0] + mat4(vec4(0.157, -0.202, -0.069, 0.049), vec4(0.015, 0.075, -0.050, 0.116), vec4(0.281, 0.109, 0.226, 0.330), vec4(-0.143, -0.124, 0.054, 0.170)) * bufB[1] + mat4(vec4(0.073, -0.083, 0.128, 0.257), vec4(0.043, -0.204, -0.003, -0.269), vec4(0.025, -0.115, -0.129, 0.221), vec4(0.328, 0.335, 0.268, 0.326)) * bufB[2] + mat4(vec4(-0.049, -0.068, -0.136, 0.255), vec4(-0.032, -0.263, -0.167, -0.163), vec4(-0.483, -0.126, -0.000, 0.011), vec4(-0.012, 0.067, 0.154, 0.164)) * bufB[3] + mat4(vec4(0.413, 0.110, -0.277, -0.151), vec4(-0.173, -0.127, -0.013, 0.034), vec4(0.039, -0.016, 0.325, 0.345), vec4(-0.254, -0.172, -0.062, 0.145)) * bufB[4] + mat4(vec4(-0.138, -0.077, -0.084, -0.023), vec4(-0.031, 0.118, 0.448, -0.059), vec4(0.048, -0.273, -0.029, 0.189), vec4(-0.070, -0.095, -0.013, 0.004)) * bufB[5] + mat4(vec4(-0.188, -0.099, 0.095, 0.190), vec4(0.431, -0.234, -0.132, 0.176), vec4(-0.326, -0.113, 0.145, -0.226), vec4(0.261, -0.167, -0.074, -0.362)) * bufB[6] + mat4(vec4(-0.063, -0.257, 0.040, 0.244), vec4(0.071, 0.032, -0.101, 0.153), vec4(-0.041, 0.020, -0.017, -0.049), vec4(0.196, -0.077, 0.019, 0.178)) * bufB[7] + mat4(vec4(0.233, -0.281, -0.039, -0.361), vec4(-0.200, 0.066, -0.026, 0.135), vec4(0.063, 0.234, 0.092, 0.107), vec4(0.095, 0.376, 0.141, -0.227)) * bufB[8] + mat4(vec4(0.067, 0.001, -0.259, -0.524), vec4(0.265, 0.317, -0.169, -0.015), vec4(-0.043, 0.074, 0.101, -0.041), vec4(0.010, 0.080, -0.057, 0.067)) * bufB[9];\nbufA[3] = vec4(0.137, -0.326, -0.215, 0.563) + mat4(vec4(-0.031, 0.043, 0.178, -0.123), vec4(-0.228, -0.028, 0.325, 0.204), vec4(-0.017, -0.152, -0.048, 0.038), vec4(-0.029, -0.158, -0.093, -0.332)) * bufB[0] + mat4(vec4(0.152, -0.214, -0.073, -0.169), vec4(-0.097, -0.127, -0.041, -0.028), vec4(0.087, 0.024, -0.125, -0.316), vec4(0.232, 0.011, 0.380, 0.311)) * bufB[1] + mat4(vec4(0.009, -0.201, -0.195, -0.098), vec4(-0.033, 0.004, -0.327, -0.122), vec4(-0.204, 0.411, 0.001, 0.087), vec4(0.455, -0.051, 0.141, -0.103)) * bufB[2] + mat4(vec4(0.214, -0.046, -0.168, 0.129), vec4(-0.183, -0.227, -0.156, -0.091), vec4(0.015, -0.441, 0.350, 0.064), vec4(0.332, 0.278, 0.027, -0.125)) * bufB[3] + mat4(vec4(-0.015, -0.029, -0.091, -0.131), vec4(-0.180, -0.161, -0.027, 0.111), vec4(-0.026, -0.146, -0.002, 0.347), vec4(0.011, 0.045, 0.123, 0.059)) * bufB[4] + mat4(vec4(-0.084, 0.065, -0.040, -0.044), vec4(0.180, 0.168, 0.158, -0.171), vec4(0.118, 0.063, 0.083, 0.218), vec4(0.176, 0.114, -0.014, -0.316)) * bufB[5] + mat4(vec4(-0.046, -0.219, 0.387, -0.006), vec4(-0.111, -0.107, -0.183, -0.244), vec4(-0.221, 0.188, 0.479, 0.355), vec4(-0.097, 0.301, -0.166, 0.136)) * bufB[6] + mat4(vec4(0.184, -0.373, -0.229, 0.124), vec4(0.064, -0.136, 0.257, 0.140), vec4(0.232, 0.084, 0.004, 0.119), vec4(-0.122, -0.148, 0.177, -0.355)) * bufB[7] + mat4(vec4(0.185, 0.062, -0.366, -0.088), vec4(0.091, -0.060, 0.248, 0.298), vec4(0.194, 0.021, -0.115, 0.144), vec4(-0.199, -0.150, 0.398, 0.094)) * bufB[8] + mat4(vec4(-0.269, 0.055, 0.106, -0.069), vec4(-0.029, 0.113, -0.013, 0.076), vec4(0.119, 0.107, -0.103, -0.199), vec4(-0.053, -0.056, 0.033, -0.453)) * bufB[9];\nbufA[4] = vec4(-0.362, -0.063, -0.141, 0.295) + mat4(vec4(0.030, 0.163, -0.210, 0.169), vec4(-0.102, 0.054, -0.147, 0.251), vec4(-0.147, 0.050, 0.095, -0.004), vec4(0.257, 0.232, 0.006, -0.136)) * bufB[0] + mat4(vec4(0.201, -0.122, -0.020, -0.162), vec4(0.029, -0.143, 0.150, -0.156), vec4(-0.265, 0.219, -0.075, 0.481), vec4(0.045, 0.073, 0.211, 0.139)) * bufB[1] + mat4(vec4(0.193, -0.002, 0.036, -0.003), vec4(0.040, -0.073, 0.299, 0.035), vec4(-0.044, -0.030, -0.128, -0.130), vec4(-0.190, -0.155, -0.148, 0.044)) * bufB[2] + mat4(vec4(0.241, -0.262, 0.378, -0.273), vec4(0.156, -0.028, -0.084, -0.197), vec4(-0.268, 0.187, -0.418, -0.061), vec4(0.192, 0.101, 0.267, -0.103)) * bufB[3] + mat4(vec4(0.047, 0.004, -0.103, 0.046), vec4(-0.026, -0.068, -0.109, -0.031), vec4(0.310, -0.051, 0.106, -0.152), vec4(0.124, 0.058, -0.077, -0.155)) * bufB[4] + mat4(vec4(0.203, 0.034, -0.035, -0.093), vec4(-0.467, -0.189, 0.104, 0.007), vec4(0.193, -0.146, 0.162, 0.038), vec4(-0.056, 0.253, 0.023, 0.157)) * bufB[5] + mat4(vec4(-0.159, 0.044, -0.223, 0.003), vec4(-0.206, 0.227, -0.263, -0.046), vec4(0.343, 0.229, 0.023, 0.210), vec4(-0.125, -0.227, 0.124, 0.031)) * bufB[6] + mat4(vec4(0.004, 0.002, -0.064, -0.396), vec4(0.084, 0.142, 0.104, 0.266), vec4(0.167, -0.489, -0.117, -0.034), vec4(-0.092, 0.012, 0.254, -0.140)) * bufB[7] + mat4(vec4(-0.117, -0.274, -0.172, 0.212), vec4(0.300, 0.069, -0.006, -0.002), vec4(-0.076, 0.009, 0.039, -0.025), vec4(0.230, 0.260, -0.198, 0.378)) * bufB[8] + mat4(vec4(0.003, 0.094, 0.032, 0.434), vec4(-0.018, 0.206, -0.205, -0.047), vec4(-0.127, 0.320, 0.081, 0.020), vec4(0.183, 0.113, 0.153, 0.250)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(0.477, 0.304, 0.121, 0.532) + mat4(vec4(-0.079, -0.060, -0.091, 0.204), vec4(-0.227, 0.139, -0.046, 0.036), vec4(0.139, -0.316, -0.116, 0.136), vec4(0.122, 0.283, -0.424, -0.117)) * bufB[0] + mat4(vec4(0.228, 0.106, 0.013, -0.003), vec4(-0.372, 0.041, -0.224, -0.390), vec4(-0.482, 0.045, 0.028, -0.053), vec4(0.020, -0.169, -0.173, -0.344)) * bufB[1] + mat4(vec4(0.038, -0.180, 0.101, -0.131), vec4(-0.004, 0.190, -0.053, 0.053), vec4(-0.062, -0.065, -0.408, 0.139), vec4(-0.053, 0.117, -0.180, 0.065)) * bufB[2] + mat4(vec4(-0.065, 0.328, 0.204, 0.056), vec4(0.256, 0.034, -0.023, -0.104), vec4(0.393, -0.223, 0.305, 0.143), vec4(0.399, -0.028, -0.187, 0.183)) * bufB[3] + mat4(vec4(-0.024, 0.008, 0.599, -0.192), vec4(-0.373, 0.007, 0.030, -0.232), vec4(-0.131, 0.328, 0.092, -0.000), vec4(-0.146, 0.301, -0.006, -0.045)) * bufB[4] + mat4(vec4(0.088, 0.086, -0.020, 0.200), vec4(0.184, 0.002, -0.197, 0.038), vec4(0.036, 0.058, -0.099, -0.181), vec4(-0.211, -0.114, 0.363, -0.210)) * bufB[5] + mat4(vec4(0.015, 0.138, 0.006, -0.101), vec4(-0.019, 0.196, 0.214, 0.109), vec4(-0.259, 0.010, -0.048, -0.055), vec4(0.173, 0.099, -0.072, 0.185)) * bufB[6] + mat4(vec4(0.030, 0.195, 0.107, -0.024), vec4(0.085, -0.145, -0.207, -0.035), vec4(-0.182, 0.186, -0.013, 0.080), vec4(-0.240, 0.002, 0.145, 0.009)) * bufB[7] + mat4(vec4(-0.302, -0.133, 0.222, -0.186), vec4(-0.019, 0.033, 0.202, -0.167), vec4(-0.026, -0.025, 0.101, -0.355), vec4(0.036, -0.283, -0.268, -0.061)) * bufB[8] + mat4(vec4(-0.230, -0.098, -0.016, 0.304), vec4(-0.132, 0.163, 0.105, 0.155), vec4(-0.069, -0.197, -0.220, -0.149), vec4(-0.150, 0.125, -0.278, -0.082)) * bufB[9];\nbufA[1] = vec4(-0.126, -0.352, -0.415, -0.377) + mat4(vec4(-0.033, 0.057, 0.183, 0.129), vec4(0.287, 0.098, 0.083, 0.200), vec4(-0.171, -0.031, 0.168, 0.034), vec4(-0.068, -0.266, -0.081, -0.209)) * bufB[0] + mat4(vec4(-0.098, 0.072, -0.152, 0.076), vec4(-0.067, 0.128, -0.178, 0.299), vec4(0.137, 0.026, -0.202, -0.103), vec4(0.365, 0.109, -0.014, -0.202)) * bufB[1] + mat4(vec4(0.162, 0.057, -0.120, 0.062), vec4(0.014, 0.487, -0.007, 0.035), vec4(0.099, 0.225, 0.128, 0.114), vec4(-0.206, 0.309, 0.061, 0.046)) * bufB[2] + mat4(vec4(-0.168, -0.068, -0.012, 0.159), vec4(0.173, -0.032, -0.119, -0.188), vec4(-0.120, 0.120, 0.193, -0.305), vec4(0.010, -0.045, -0.183, 0.127)) * bufB[3] + mat4(vec4(0.048, 0.040, -0.353, -0.234), vec4(-0.278, 0.245, -0.321, 0.178), vec4(0.056, -0.075, 0.216, -0.004), vec4(0.033, 0.264, -0.230, 0.056)) * bufB[4] + mat4(vec4(-0.027, -0.015, 0.020, -0.103), vec4(-0.020, -0.061, -0.293, 0.058), vec4(0.049, 0.207, -0.249, 0.070), vec4(-0.169, -0.286, 0.315, 0.147)) * bufB[5] + mat4(vec4(-0.127, -0.100, -0.274, -0.037), vec4(-0.035, -0.163, 0.157, 0.059), vec4(-0.093, 0.091, -0.067, -0.008), vec4(-0.172, 0.225, -0.051, 0.025)) * bufB[6] + mat4(vec4(0.137, -0.214, 0.281, -0.144), vec4(0.053, 0.117, -0.022, 0.103), vec4(0.170, -0.224, -0.070, 0.078), vec4(-0.362, 0.007, 0.057, -0.163)) * bufB[7] + mat4(vec4(0.070, -0.249, 0.110, -0.067), vec4(-0.088, 0.158, 0.042, -0.346), vec4(-0.014, 0.268, -0.256, 0.476), vec4(0.082, -0.013, -0.037, -0.216)) * bufB[8] + mat4(vec4(0.243, -0.286, 0.337, -0.255), vec4(0.112, -0.036, 0.044, -0.118), vec4(0.293, -0.240, 0.052, -0.286), vec4(-0.186, 0.063, -0.225, 0.038)) * bufB[9];\nbufA[2] = vec4(-0.528, -0.552, -0.526, -0.414) + mat4(vec4(0.241, -0.012, 0.218, 0.159), vec4(0.299, -0.128, -0.093, 0.036), vec4(-0.287, -0.173, 0.285, -0.026), vec4(-0.286, -0.163, -0.019, 0.178)) * bufB[0] + mat4(vec4(0.316, -0.105, -0.075, -0.036), vec4(-0.444, -0.311, 0.033, -0.152), vec4(-0.072, -0.192, 0.025, -0.014), vec4(-0.161, -0.025, 0.077, 0.067)) * bufB[1] + mat4(vec4(0.277, 0.216, 0.142, 0.220), vec4(-0.188, 0.027, -0.017, 0.183), vec4(0.046, 0.055, 0.033, 0.089), vec4(-0.190, -0.343, -0.051, -0.042)) * bufB[2] + mat4(vec4(0.053, 0.132, -0.057, 0.318), vec4(0.089, 0.031, -0.351, 0.080), vec4(0.269, -0.113, -0.027, 0.293), vec4(-0.271, 0.039, 0.070, -0.076)) * bufB[3] + mat4(vec4(0.342, -0.230, -0.006, -0.023), vec4(-0.069, -0.377, 0.015, 0.250), vec4(-0.072, 0.085, -0.042, 0.166), vec4(-0.013, -0.118, 0.105, 0.228)) * bufB[4] + mat4(vec4(0.201, -0.009, 0.280, 0.212), vec4(-0.064, -0.013, 0.095, -0.204), vec4(-0.029, 0.053, 0.282, 0.087), vec4(-0.597, -0.323, 0.131, -0.053)) * bufB[5] + mat4(vec4(0.011, 0.094, -0.018, -0.141), vec4(0.036, 0.077, -0.084, -0.308), vec4(-0.109, -0.062, -0.121, 0.007), vec4(-0.041, 0.321, -0.023, 0.011)) * bufB[6] + mat4(vec4(0.077, 0.163, -0.323, -0.052), vec4(-0.252, -0.200, -0.024, -0.022), vec4(0.064, -0.227, 0.165, -0.128), vec4(-0.134, -0.152, 0.225, -0.000)) * bufB[7] + mat4(vec4(0.292, -0.038, -0.200, 0.098), vec4(0.291, 0.187, 0.006, -0.113), vec4(-0.182, -0.242, 0.166, 0.412), vec4(-0.082, 0.131, -0.516, -0.257)) * bufB[8] + mat4(vec4(-0.387, 0.195, 0.203, -0.142), vec4(0.115, 0.191, -0.110, 0.023), vec4(0.128, 0.485, 0.375, 0.105), vec4(-0.191, 0.092, -0.112, 0.211)) * bufB[9];\nbufA[3] = vec4(-0.013, -0.175, 0.064, -0.252) + mat4(vec4(-0.136, -0.026, -0.240, -0.018), vec4(-0.129, -0.036, -0.110, -0.015), vec4(-0.071, -0.138, -0.082, 0.018), vec4(0.091, -0.209, -0.337, 0.049)) * bufB[0] + mat4(vec4(0.049, 0.108, 0.251, -0.223), vec4(-0.110, 0.121, -0.094, -0.097), vec4(0.112, -0.071, 0.077, 0.197), vec4(0.039, 0.048, 0.131, 0.094)) * bufB[1] + mat4(vec4(-0.186, 0.390, 0.245, 0.229), vec4(0.261, 0.139, -0.007, 0.179), vec4(0.355, 0.033, -0.032, 0.117), vec4(0.198, 0.079, -0.349, 0.360)) * bufB[2] + mat4(vec4(0.229, -0.140, -0.027, 0.146), vec4(-0.069, 0.080, 0.244, -0.059), vec4(-0.250, -0.135, 0.014, -0.048), vec4(-0.092, 0.147, 0.141, -0.053)) * bufB[3] + mat4(vec4(0.066, -0.035, -0.066, -0.248), vec4(0.230, 0.081, 0.009, 0.030), vec4(0.021, -0.106, -0.140, 0.011), vec4(-0.418, 0.323, -0.086, 0.344)) * bufB[4] + mat4(vec4(-0.157, -0.032, -0.187, -0.028), vec4(0.104, -0.307, -0.214, 0.013), vec4(0.055, -0.001, 0.152, 0.121), vec4(0.315, 0.002, 0.013, 0.114)) * bufB[5] + mat4(vec4(-0.132, -0.100, -0.119, -0.030), vec4(0.395, 0.034, 0.126, -0.206), vec4(-0.314, -0.202, -0.170, 0.031), vec4(-0.213, 0.243, 0.031, -0.010)) * bufB[6] + mat4(vec4(-0.039, 0.067, 0.396, 0.057), vec4(0.097, 0.233, 0.025, 0.285), vec4(-0.027, -0.009, -0.152, 0.130), vec4(0.289, -0.096, -0.080, -0.133)) * bufB[7] + mat4(vec4(-0.144, 0.070, 0.066, -0.208), vec4(-0.159, -0.100, -0.170, 0.040), vec4(0.076, -0.153, -0.245, 0.120), vec4(0.360, -0.040, 0.019, -0.185)) * bufB[8] + mat4(vec4(0.055, -0.280, 0.409, 0.046), vec4(0.064, 0.349, -0.075, 0.100), vec4(-0.263, 0.113, 0.338, 0.020), vec4(-0.320, -0.218, 0.051, 0.082)) * bufB[9];\nbufA[4] = vec4(0.405, 0.074, -0.081, 0.422) + mat4(vec4(-0.239, -0.082, 0.113, 0.007), vec4(0.176, -0.095, -0.202, -0.115), vec4(0.392, -0.197, 0.048, -0.105), vec4(0.105, -0.141, -0.171, -0.167)) * bufB[0] + mat4(vec4(-0.066, 0.127, 0.271, -0.057), vec4(0.011, -0.111, 0.094, -0.194), vec4(0.074, -0.046, -0.203, -0.163), vec4(0.276, -0.026, 0.098, 0.015)) * bufB[1] + mat4(vec4(-0.202, -0.062, 0.066, 0.175), vec4(-0.032, -0.090, 0.163, 0.028), vec4(-0.217, 0.032, -0.070, 0.085), vec4(0.023, 0.144, 0.201, 0.108)) * bufB[2] + mat4(vec4(-0.248, -0.151, -0.050, 0.141), vec4(0.094, -0.158, 0.105, -0.024), vec4(-0.082, 0.049, 0.070, 0.482), vec4(-0.017, 0.210, -0.159, -0.080)) * bufB[3] + mat4(vec4(0.105, 0.371, -0.213, -0.462), vec4(-0.172, -0.012, -0.132, 0.081), vec4(-0.183, -0.184, 0.202, 0.081), vec4(-0.219, 0.137, -0.018, -0.166)) * bufB[4] + mat4(vec4(-0.118, 0.153, 0.154, -0.121), vec4(0.066, 0.328, 0.102, 0.142), vec4(-0.196, 0.294, 0.026, 0.021), vec4(0.202, -0.138, 0.175, -0.111)) * bufB[5] + mat4(vec4(0.170, 0.062, -0.338, -0.184), vec4(0.060, -0.196, 0.225, -0.060), vec4(0.006, 0.175, 0.058, 0.037), vec4(0.231, 0.022, 0.058, -0.088)) * bufB[6] + mat4(vec4(-0.075, -0.132, -0.181, 0.172), vec4(-0.171, -0.196, 0.150, -0.053), vec4(-0.075, -0.153, -0.103, 0.064), vec4(0.034, 0.178, -0.060, -0.136)) * bufB[7] + mat4(vec4(-0.238, 0.064, 0.182, -0.008), vec4(-0.298, 0.009, -0.078, 0.112), vec4(0.202, -0.222, 0.050, 0.047), vec4(0.024, 0.124, 0.020, -0.106)) * bufB[8] + mat4(vec4(0.151, -0.168, -0.044, 0.164), vec4(0.154, 0.088, -0.051, 0.006), vec4(-0.114, 0.154, 0.059, 0.085), vec4(-0.124, 0.066, -0.141, -0.268)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(0.249, -0.066, -0.318, -0.070) + mat4(vec4(-0.364, -0.000, 0.206, 0.116), vec4(0.271, -0.196, -0.109, 0.007), vec4(-0.139, 0.388, -0.012, 0.047), vec4(0.110, 0.070, 0.199, 0.190)) * bufB[0] + mat4(vec4(0.264, -0.066, 0.162, 0.370), vec4(-0.018, 0.107, 0.027, -0.284), vec4(0.070, -0.094, 0.100, -0.042), vec4(-0.244, -0.301, 0.081, -0.056)) * bufB[1] + mat4(vec4(0.192, -0.053, 0.390, 0.010), vec4(0.048, 0.526, -0.054, -0.389), vec4(0.243, 0.218, 0.110, 0.115), vec4(0.004, 0.008, -0.084, 0.435)) * bufB[2] + mat4(vec4(-0.133, 0.170, 0.210, 0.297), vec4(0.027, 0.246, 0.048, 0.044), vec4(0.005, -0.009, -0.105, -0.187), vec4(0.044, 0.253, 0.031, -0.051)) * bufB[3] + mat4(vec4(-0.087, -0.513, -0.029, 0.069), vec4(-0.075, 0.314, -0.076, 0.199), vec4(-0.320, 0.502, 0.026, 0.392), vec4(0.005, -0.387, 0.361, 0.290)) * bufB[4] + mat4(vec4(0.060, -0.211, 0.027, 0.249), vec4(0.000, 0.039, -0.005, 0.010), vec4(0.055, -0.077, 0.375, -0.045), vec4(-0.206, 0.042, -0.517, -0.389)) * bufB[5] + mat4(vec4(-0.095, 0.113, -0.011, 0.328), vec4(-0.096, 0.191, -0.503, -0.231), vec4(0.221, 0.173, -0.503, 0.246), vec4(-0.026, -0.063, 0.110, -0.166)) * bufB[6] + mat4(vec4(0.037, -0.196, -0.006, -0.448), vec4(0.016, -0.190, 0.339, 0.443), vec4(-0.081, 0.150, 0.421, -0.145), vec4(-0.033, 0.050, 0.181, 0.415)) * bufB[7] + mat4(vec4(0.017, 0.141, -0.251, -0.461), vec4(0.033, 0.001, -0.011, -0.175), vec4(-0.380, 0.023, -0.235, 0.190), vec4(0.214, 0.420, -0.047, 0.268)) * bufB[8] + mat4(vec4(-0.163, -0.311, 0.099, 0.069), vec4(0.164, -0.019, -0.103, 0.205), vec4(0.114, 0.154, 0.163, 0.010), vec4(0.034, 0.262, -0.058, -0.037)) * bufB[9];\nbufA[1] = vec4(0.010, -0.077, -0.104, 0.402) + mat4(vec4(-0.024, 0.083, -0.055, 0.140), vec4(0.109, 0.119, 0.085, 0.111), vec4(-0.013, -0.272, -0.142, -0.011), vec4(0.221, -0.165, 0.260, -0.010)) * bufB[0] + mat4(vec4(-0.250, 0.203, 0.011, -0.222), vec4(0.091, 0.083, 0.066, -0.134), vec4(0.073, 0.446, 0.041, -0.141), vec4(0.020, -0.003, 0.063, -0.209)) * bufB[1] + mat4(vec4(0.007, -0.223, -0.301, -0.040), vec4(-0.072, 0.074, 0.036, -0.177), vec4(0.329, 0.082, 0.011, -0.419), vec4(0.171, -0.011, 0.054, 0.015)) * bufB[2] + mat4(vec4(-0.105, 0.063, -0.139, 0.029), vec4(-0.113, -0.264, 0.106, -0.248), vec4(0.093, 0.130, 0.041, 0.179), vec4(-0.115, -0.213, -0.025, -0.156)) * bufB[3] + mat4(vec4(-0.042, 0.090, 0.166, 0.003), vec4(0.022, -0.133, -0.003, 0.334), vec4(0.078, 0.131, 0.176, -0.180), vec4(-0.337, -0.091, -0.170, 0.185)) * bufB[4] + mat4(vec4(0.133, 0.336, -0.211, 0.180), vec4(-0.155, 0.317, 0.091, -0.156), vec4(0.058, 0.354, 0.136, 0.054), vec4(-0.039, -0.043, -0.030, 0.122)) * bufB[5] + mat4(vec4(-0.089, 0.222, -0.174, 0.047), vec4(0.008, -0.348, 0.298, 0.079), vec4(0.034, -0.047, -0.039, -0.001), vec4(-0.150, -0.080, -0.320, -0.168)) * bufB[6] + mat4(vec4(0.230, -0.001, -0.029, -0.001), vec4(-0.008, 0.287, -0.018, -0.241), vec4(-0.024, 0.151, -0.128, 0.025), vec4(-0.281, -0.273, -0.142, -0.111)) * bufB[7] + mat4(vec4(-0.221, -0.621, 0.001, 0.424), vec4(0.049, -0.251, 0.090, -0.162), vec4(-0.214, 0.030, -0.082, -0.213), vec4(-0.222, -0.122, -0.191, -0.018)) * bufB[8] + mat4(vec4(0.027, 0.041, -0.172, 0.170), vec4(0.060, -0.001, 0.187, 0.016), vec4(-0.138, -0.088, 0.215, 0.140), vec4(-0.015, -0.003, 0.353, -0.205)) * bufB[9];\nbufA[2] = vec4(-0.275, 0.536, -0.163, -0.451) + mat4(vec4(0.132, 0.094, -0.074, -0.234), vec4(-0.052, -0.332, -0.393, -0.169), vec4(0.151, -0.280, 0.261, -0.203), vec4(-0.086, 0.268, -0.101, -0.192)) * bufB[0] + mat4(vec4(-0.100, -0.141, -0.029, -0.085), vec4(0.117, 0.084, 0.063, -0.376), vec4(0.171, -0.179, -0.104, -0.027), vec4(-0.024, -0.091, -0.190, 0.095)) * bufB[1] + mat4(vec4(0.395, -0.521, 0.040, 0.208), vec4(0.017, -0.215, -0.127, -0.365), vec4(-0.217, 0.200, 0.191, 0.007), vec4(-0.079, -0.331, -0.014, 0.151)) * bufB[2] + mat4(vec4(-0.033, -0.276, -0.112, -0.092), vec4(0.096, 0.064, 0.088, 0.198), vec4(0.158, -0.208, 0.075, -0.139), vec4(-0.079, -0.064, -0.280, -0.283)) * bufB[3] + mat4(vec4(-0.087, 0.380, 0.086, -0.244), vec4(-0.025, -0.096, 0.222, -0.078), vec4(0.390, 0.118, -0.100, -0.097), vec4(0.534, 0.107, -0.006, -0.030)) * bufB[4] + mat4(vec4(0.171, -0.048, 0.027, -0.287), vec4(-0.205, -0.552, 0.113, -0.154), vec4(-0.024, 0.215, 0.060, 0.012), vec4(0.209, -0.146, 0.034, 0.145)) * bufB[5] + mat4(vec4(0.041, -0.083, -0.061, -0.077), vec4(-0.210, -0.002, 0.329, 0.002), vec4(-0.076, 0.429, 0.070, 0.114), vec4(-0.011, -0.278, 0.108, 0.065)) * bufB[6] + mat4(vec4(-0.169, 0.136, 0.057, -0.019), vec4(0.122, 0.125, 0.025, -0.208), vec4(0.166, -0.055, -0.011, -0.024), vec4(-0.085, 0.277, -0.025, -0.214)) * bufB[7] + mat4(vec4(-0.114, -0.370, -0.087, -0.286), vec4(0.137, -0.231, -0.115, 0.051), vec4(0.039, 0.098, 0.025, -0.263), vec4(-0.122, 0.250, 0.043, -0.107)) * bufB[8] + mat4(vec4(0.133, -0.023, 0.068, -0.100), vec4(0.088, -0.060, -0.053, 0.495), vec4(-0.194, -0.277, 0.030, -0.077), vec4(-0.177, -0.049, -0.247, 0.255)) * bufB[9];\nbufA[3] = vec4(0.186, -0.006, 0.542, 0.455) + mat4(vec4(0.010, 0.155, 0.127, 0.227), vec4(-0.244, -0.084, 0.150, 0.096), vec4(-0.254, 0.139, 0.125, -0.294), vec4(-0.059, -0.093, 0.045, -0.339)) * bufB[0] + mat4(vec4(-0.147, -0.144, -0.356, 0.022), vec4(0.021, 0.261, 0.003, 0.784), vec4(0.062, -0.001, -0.273, -0.194), vec4(0.205, 0.076, 0.131, 0.346)) * bufB[1] + mat4(vec4(0.069, 0.262, 0.073, -0.249), vec4(-0.065, -0.097, 0.062, -0.003), vec4(0.068, -0.003, 0.029, 0.039), vec4(-0.160, -0.059, -0.318, 0.093)) * bufB[2] + mat4(vec4(-0.002, 0.180, 0.325, -0.326), vec4(0.254, -0.010, 0.044, 0.027), vec4(0.093, -0.027, -0.113, 0.012), vec4(-0.220, -0.154, -0.147, -0.004)) * bufB[3] + mat4(vec4(0.061, -0.330, -0.102, 0.129), vec4(-0.103, -0.025, 0.084, -0.262), vec4(-0.122, 0.033, 0.076, -0.037), vec4(-0.060, 0.283, -0.182, -0.230)) * bufB[4] + mat4(vec4(0.013, -0.272, -0.155, 0.001), vec4(0.010, -0.053, -0.351, 0.279), vec4(-0.212, 0.074, 0.095, 0.208), vec4(-0.122, 0.001, 0.122, 0.226)) * bufB[5] + mat4(vec4(-0.211, -0.012, -0.155, 0.415), vec4(0.275, -0.088, 0.086, 0.075), vec4(0.246, -0.056, -0.194, -0.542), vec4(0.080, 0.009, 0.069, -0.255)) * bufB[6] + mat4(vec4(0.094, -0.046, 0.107, 0.260), vec4(-0.201, -0.037, -0.117, 0.037), vec4(-0.247, -0.309, 0.006, 0.231), vec4(0.088, -0.094, -0.176, 0.350)) * bufB[7] + mat4(vec4(0.033, -0.128, -0.143, -0.208), vec4(0.050, -0.224, 0.155, -0.308), vec4(-0.188, -0.161, 0.001, -0.182), vec4(-0.105, 0.085, -0.139, 0.263)) * bufB[8] + mat4(vec4(-0.221, -0.031, -0.364, 0.075), vec4(-0.198, 0.094, 0.274, -0.127), vec4(0.042, -0.146, -0.322, -0.315), vec4(-0.029, -0.008, -0.146, -0.043)) * bufB[9];\nbufA[4] = vec4(-0.079, 0.171, 0.037, 0.355) + mat4(vec4(0.039, -0.189, -0.053, -0.450), vec4(0.109, -0.245, 0.068, -0.006), vec4(-0.014, -0.111, 0.120, 0.171), vec4(-0.032, -0.050, 0.176, 0.147)) * bufB[0] + mat4(vec4(-0.077, -0.100, 0.380, 0.271), vec4(-0.216, -0.183, -0.032, -0.143), vec4(-0.300, -0.131, -0.149, 0.152), vec4(-0.400, -0.280, -0.123, -0.217)) * bufB[1] + mat4(vec4(-0.182, 0.012, 0.134, 0.112), vec4(0.204, -0.315, 0.050, 0.031), vec4(-0.177, -0.281, -0.055, -0.100), vec4(0.138, 0.137, 0.016, -0.055)) * bufB[2] + mat4(vec4(0.209, -0.336, 0.093, 0.370), vec4(-0.008, -0.282, 0.154, -0.139), vec4(-0.028, -0.015, 0.149, -0.109), vec4(-0.024, -0.348, -0.492, 0.079)) * bufB[3] + mat4(vec4(0.208, 0.039, 0.258, -0.049), vec4(0.075, -0.057, -0.313, 0.325), vec4(0.118, -0.057, -0.260, -0.058), vec4(-0.156, -0.162, -0.272, -0.224)) * bufB[4] + mat4(vec4(-0.116, 0.034, 0.045, 0.101), vec4(-0.062, 0.075, -0.285, -0.015), vec4(0.127, 0.027, -0.177, -0.027), vec4(0.117, 0.032, 0.161, -0.066)) * bufB[5] + mat4(vec4(-0.176, 0.291, 0.153, -0.324), vec4(-0.169, -0.038, 0.130, 0.255), vec4(-0.456, 0.195, -0.130, 0.101), vec4(0.315, 0.285, -0.051, -0.213)) * bufB[6] + mat4(vec4(0.353, -0.181, -0.208, 0.064), vec4(-0.149, 0.605, -0.127, -0.122), vec4(-0.146, -0.096, 0.057, 0.129), vec4(-0.053, 0.189, 0.061, -0.170)) * bufB[7] + mat4(vec4(0.065, -0.094, 0.055, -0.092), vec4(0.013, 0.017, 0.213, 0.058), vec4(-0.366, 0.297, 0.078, -0.143), vec4(0.031, -0.373, 0.058, -0.072)) * bufB[8] + mat4(vec4(-0.036, -0.153, 0.103, 0.236), vec4(-0.087, 0.125, -0.389, 0.313), vec4(-0.123, -0.018, -0.400, -0.143), vec4(0.134, -0.416, -0.046, -0.027)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 9 \nbufA[0] = vec4(-0.095, 0.232, 0.134, 0.000) + mat4(vec4(0.104, -0.173, -0.083, 0.000), vec4(0.097, 0.240, 0.175, 0.000), vec4(-0.042, -0.094, -0.026, 0.000), vec4(0.073, 0.047, 0.103, 0.000)) * bufB[0] + mat4(vec4(-0.106, 0.003, -0.182, 0.000), vec4(0.181, 0.305, 0.118, 0.000), vec4(-0.258, -0.030, -0.032, 0.000), vec4(-0.270, 0.009, 0.195, 0.000)) * bufB[1] + mat4(vec4(-0.011, 0.025, 0.052, 0.000), vec4(0.256, -0.085, -0.019, 0.000), vec4(-0.216, 0.089, -0.129, 0.000), vec4(-0.208, 0.126, -0.048, 0.000)) * bufB[2] + mat4(vec4(-0.217, 0.129, 0.013, 0.000), vec4(-0.439, 0.091, -0.182, 0.000), vec4(0.081, -0.223, -0.102, 0.000), vec4(0.087, -0.065, -0.039, 0.000)) * bufB[3] + mat4(vec4(0.209, 0.085, 0.073, 0.000), vec4(-0.064, -0.216, -0.074, 0.000), vec4(-0.360, -0.071, 0.018, 0.000), vec4(0.234, -0.058, -0.032, 0.000)) * bufB[4] + mat4(vec4(-0.178, -0.155, -0.202, 0.000), vec4(0.015, -0.011, 0.111, 0.000), vec4(-0.094, -0.309, -0.065, 0.000), vec4(0.239, 0.222, 0.158, 0.000)) * bufB[5] + mat4(vec4(0.300, 0.293, -0.053, 0.000), vec4(-0.074, 0.062, -0.068, 0.000), vec4(-0.220, -0.235, -0.213, 0.000), vec4(-0.234, 0.013, -0.052, 0.000)) * bufB[6] + mat4(vec4(-0.043, 0.273, 0.095, 0.000), vec4(0.141, 0.060, 0.070, 0.000), vec4(0.317, -0.130, -0.025, 0.000), vec4(-0.242, -0.247, -0.119, 0.000)) * bufB[7] + mat4(vec4(-0.245, -0.167, -0.161, 0.000), vec4(-0.456, -0.020, -0.114, 0.000), vec4(0.420, -0.014, 0.091, 0.000), vec4(-0.199, -0.362, -0.135, 0.000)) * bufB[8] + mat4(vec4(-0.312, -0.328, -0.214, 0.000), vec4(0.066, 0.150, 0.115, 0.000), vec4(0.093, -0.067, 0.074, 0.000), vec4(-0.138, 0.072, 0.081, 0.000)) * bufB[9];\n\n return vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.23*sin(iTime), 0.32*sin(0.69*iTime), 0.32*sin(0.44*iTime), 0.23*sin(1.23*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2SRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 185, 185, 72865], [72867, 72867, 72924, 72974, 73422]], "test": "valid"}
{"id": "7l2Szz", "name": "fork: Peacock feather spiral 2", "author": "elenzil", "description": "A simple fractal formula, with a very minor tweak", "tags": ["fractal", "spiral"], "likes": 5, "viewed": 165, "published": "Public API", "date": "1626988897", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Peacock feather spiral 2\" by jarble. https://shadertoy.com/view/7tjSRz\n// 2021-07-22 21:19:20\n\n#define ITERS 12\n\nfloat getS0(vec2 uv, float t)\n{\n    float ret = 2.1;\n    \n    ret += (sin(t * 10.0 * (1.0 + sin(length(uv) * 0.3) * 0.3)) * 0.5 + 0.5) * sin(uv.x * 0.05) * 0.5;\n    \n    return ret;\n}\n\nfloat getS1(vec2 uv, float t)\n{\n    float ret = 1.125;\n    \n    ret *= 1.0 + sin(t * 35.0) * 0.001 * sin(length(uv) * 20.0);\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale0 = getS0(uv, iTime / 25.0);\n        float scale1 = getS1(uv, iTime / 25.0);\n        float s1 = scale1*scale0;\n        col_prev = col.yzx;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(uv.x/scale0-uv.y/scale1,uv.y/scale0-uv.x/scale1)/(scale0))))/scale1;\n            \n            uv = fract(-uv.yx/s1)*s1;\n            uv.x *= scale1;\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2Szz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 156, 156, 308], [310, 310, 341, 341, 457], [459, 459, 516, 516, 1295]], "test": "valid"}
{"id": "7l2XRh", "name": "Julia Set #2", "author": "kowalski_analytics", "description": "Julia Set shader over the main cardioid of the Mandelbrot Set", "tags": ["fractal", "julia"], "likes": 0, "viewed": 18, "published": "Public", "date": "1627105919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 1000\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 c = vec2(cos(iTime * 0.1), sin(iTime * 0.1));\n    c = vec2(2. * c.x - c.x*c.x + c.y * c.y, 2. * c.y - c.x * c.y);\n    c /= 4.;\n\n    fragCoord -= iResolution.xy/2.;\n    fragCoord /= iResolution.y;\n    fragCoord *= 2.;\n    \n    vec2 z = fragCoord;\n    \n    int i = 0;\n    while (i < ITERATIONS) {\n        z = vec2(z.x*z.x - z.y*z.y + c.x, 2. * z.x * z.y + c.y);\n        i++;\n        if (length(z) > 2.) break;\n    }\n    \n    float t = float(i)/float(ITERATIONS);\n    \n    fragColor = \n      vec4(2.0, 0., 0., 0.) / (1.0 + pow(2.0, pow(2.0 - 100.0* t, 2.0)))\n    + vec4(0., 0., 15., 1.) * (t * pow(1. - t, 9.0)) \n    + vec4(0., 20., 0., 1.) * (t * t * (1. - t)) \n    + vec4(1., 1., 1., 1.)  * t;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2XRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 82, 789]], "test": "valid"}
{"id": "7lBSRh", "name": "Mandelbrot Zoom #2", "author": "kowalski_analytics", "description": "Mandelbrot Zoom", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 20, "published": "Public", "date": "1627065711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 1000\n\nvec2 zoomC = vec2(-0.745428, 0.113009);\nfloat zoomrate = 1.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float zoom = exp(-zoomrate * iTime);\n    \n    fragCoord -= iResolution.xy/2.;\n    fragCoord /= iResolution.y;\n    fragCoord *= 2.;\n    \n    vec2 c = fragCoord;\n    c *= zoom;\n    c += zoomC * (1. - zoom);\n    \n    \n    vec2 z = c;\n    \n    int i = 0;\n    while (i < ITERATIONS) {\n        z = vec2(z.x*z.x - z.y*z.y + c.x, 2. * z.x * z.y + c.y);\n        i++;\n        if (length(z) > 2.) break;\n    }\n    \n    float t = float(i)/float(ITERATIONS);\n    \n    if (i == ITERATIONS) {\n        fragColor = vec4(0., 0., 0., 0.);\n    }\n    else {\n        fragColor = \n      vec4(0., 0., 2., 0.) / (1.0 + pow(2.0, pow(2.0 - 100.0* t, 2.0)))\n    + vec4(10., 20., 10., 1.) * (t * pow(1. - t, 9.0)) \n    + vec4(20., 0., 0., 1.) * (t * t * (1. - t)) \n    + vec4(1., 1., 1., 1.)  * t;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 145, 145, 929]], "test": "valid"}
{"id": "7lBSWz", "name": "double spiral Tangent", "author": "TLC123", "description": "double spiral with limitations.\n Tried to solve limitation with linear\"middle\" piece but  failed to get perfect tangens\nOnly support Archimedean spiral for now, expand to log and hyp later\n ", "tags": ["2d", "sdf", "spiral", "distance", "saffronbun"], "likes": 10, "viewed": 65, "published": "Public", "date": "1627412741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"double spiral \" by TLC123. https://shadertoy.com/view/ft2SRh\n// 2021-07-27 16:21:03\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n \nvec4  getTangents(float x1, float y1, float r1, float x2, float y2, float r2) {\n        float d_sq = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n        if (d_sq <= (r1-r2)*(r1-r2)) return vec4(0);\n\n        float d =  sqrt(d_sq);\n        float vx = (x2 - x1) / d;\n        float vy = (y2 - y1) / d;\n\n        vec4 res  ;\n        int i = 0;\n\n        // Let A, B be the centers, and C, D be points at which the tangent\n        // touches first and second circle, and n be the normal vector to it.\n        //\n        // We have the system:\n        //   n * n = 1          (n is a unit vector)          \n        //   C = A + r1 * n\n        //   D = B +/- r2 * n\n        //   n * CD = 0         (common orthogonality)\n        //\n        // n * CD = n * (AB +/- r2*n - r1*n) = AB*n - (r1 -/+ r2) = 0,  <=>\n        // AB * n = (r1 -/+ r2), <=>\n        // v * n = (r1 -/+ r2) / d,  where v = AB/|AB| = AB/d\n        // This is a linear equation in unknown vector n.\n\n            float sign1 = -1.;\n            {\n            float c = (r1 - sign1 * r2) / d;\n\n            // Now we're just intersecting a line with a circle: v*n=c, n*n=1\n\n            if (c*c > 1.0)  ;\n            float h =  sqrt( max(0.0, 1.0 - c*c));\n\n             float sign2 = -1.;  {\n                float nx = vx * c - sign2 * h * vy;\n                float ny = vy * c + sign2 * h * vx;\n\n               res= vec4(\n                x1 + r1 * nx,\n                y1 + r1 * ny,\n                 x2 + sign1 * r2 * nx,\n                 y2 + sign1 * r2 * ny);\n            }\n        }\n        \n        return res ;\n    }\n \n \n float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat  smin( float a, float b,float k )\n{\n    float h =  clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 ) ;\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n  \n\nfloat f(vec2 p,vec2 from ,vec2 to,float r0,float r1,float t0,float t1,float e0,float e1)\n{\n\n vec4 res=getTangents(from.x,from.y, r0, to.x, to.y, r1);\nvec2 p0=res.xy;\nvec2 p1=res.zw;\nvec2 v0=p0-from;\nvec2 v1=p1-to;\nvec2 vec=normalize(to-from);\nvec2 p2=from+vec2(-vec.y,vec.x)*-r0;\nvec2 p3=to+vec2(-vec.y,vec.x)*r1; \n\nfloat av= atan(vec.x,vec.y) ;\n    float c = cos(-av+3.1415*0.5);\n    float s = sin(-av+3.1415*0.5);\n    mat2 rot =mat2(c,s,-s,c);\nvec2 l0=(p-from)* rot;\n\n  av= atan(vec.x,vec.y) ;\n      c = cos(-av+3.1415*0.5);\n      s = sin(-av+3.1415*0.5);\n      rot =mat2(c,s,-s,c);\n \nvec2 l1=(p-to)* rot;\n\n\n\nfloat a0= atan(l0.x,l0.y)/(3.1415*2.) ;\nfloat a1= atan(-l1.x,-l1.y)/(3.1415*2.) ;\n\nfloat step0=.5+( a0 ) ;\nfloat step1=.5+ a1 ;\n\nfloat d=1./0.;\n \nfor (float i=fract(t0);i<= (t0);i++){\n d=min(d,abs(length  (p-from)-(( (i)-step0)/t0)*r0 ));\n}\nfor (float i=fract(t1);i<= (t1);i++){\n d=min(d,abs(length  (p-to  )-(( (i)-step1)/t1)*r1 ));\n}\n \n // the litte knob at centers\nd=smin(d,length(from-p)-r0*0.025,r0*0.1);\nd=smin(d,length(to-p)-r1*0.025,r1*0.1);\n \n\nd=min(d,sdSegment(   p, res.xy,res.zw ));\nd=min(d,length(p-(p0+p1)/2.)-(r0+r1)*.05);\nd=min(d,length(p-(p0 ) )-(r0+r1)*.025);\nd=min(d,length(p-(p1 ) )-(r0+r1)*.025);\nd=min(d,length(p-(p2 ) )-(r0+r1)*.025);\nd=min(d,length(p-(p3 ) )-(r0+r1)*.025);\n \nreturn d;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p =   (fragCoord*2.0-iResolution.xy)/iResolution.y;\n     \n     \n    // driver code \n \tvec2 r;\n    vec2 from = .5*vec2(-sin (iTime*0.4365  ), cos(iTime*0.3355  ));\n    vec2 to = .5*vec2(1, cos(iTime*0.8647   )*.9);\n  \n    r.x= length(from-to)- abs(sin(iTime*0.46436   ))*length(from-to)*.5-length(from-to)*.25 ;\n    r.y =length(from-to)-r.x;\n  r*=.5;\n    vec2 t =  3.+(2.*vec2(sin(iTime*0.513546   ), cos(iTime*0.96764   ) ));\n    t=clamp(t,.5,2.);\n  \n    // distance\n    float d=f(p,from ,to,r.x,r.y,t.x,t.y,1.,1.);\n\n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n \n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBSWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 252, 252, 1748], [1754, 1754, 1806, 1806, 1925], [1927, 1927, 1968, 1968, 2063], [2068, 2068, 2158, 2158, 3391], [3393, 3393, 3450, 3486, 4249]], "test": "valid"}
{"id": "7lBXRh", "name": "CLIP+CPPN Bladerunner ", "author": "atara", "description": "Another CLIP and CPPN neuraly generated shader. This time the starting point is concept art for Bladerunner and a prompt describing the feeling of being lost in a futuristic city, designed by Syd Mead.\n", "tags": ["clipcppnaineuralrenderingneuralartselfgeneratedbladerunnersydmead"], "likes": 4, "viewed": 115, "published": "Public", "date": "1627044302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#define N_HIDDEN 20\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(0.473, -0.326, -0.486, -0.324) + mat4(vec4(-0.156, -0.050, 0.134, 1.288), vec4(-0.242, 0.594, 1.156, -0.136), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[1] = vec4(0.317, 0.261, -0.007, -0.065) + mat4(vec4(1.520, 0.236, 0.178, 0.895), vec4(0.825, 0.156, -0.104, 0.366), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[2] = vec4(-0.536, 0.104, -0.186, 0.179) + mat4(vec4(0.330, -0.147, 0.845, -0.268), vec4(1.180, -1.279, -0.210, -0.328), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[3] = vec4(0.479, -0.343, -0.685, -0.223) + mat4(vec4(1.086, -0.462, 0.745, 1.386), vec4(-0.506, 0.834, 1.480, -0.185), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[4] = vec4(-0.246, -0.219, 0.306, -0.312) + mat4(vec4(1.192, 0.527, -0.017, -1.016), vec4(-1.420, -0.510, -0.210, 0.455), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(-0.153, -0.086, 0.408, -0.065) + mat4(vec4(0.210, 0.096, 0.164, -0.394), vec4(0.138, 0.223, 0.140, -0.064), vec4(-0.119, 0.181, -0.043, 0.248), vec4(-0.407, 0.029, 0.032, 0.011)) * bufB[0] + mat4(vec4(-0.219, -0.009, -0.150, 0.052), vec4(-0.200, -0.147, 0.134, -0.064), vec4(-0.144, 0.146, 0.055, -0.393), vec4(-0.166, -0.106, 0.034, 0.243)) * bufB[1] + mat4(vec4(-0.068, 0.017, 0.184, 0.254), vec4(-0.131, 0.098, -0.156, -0.403), vec4(0.081, -0.127, -0.057, -0.251), vec4(-0.203, 0.040, -0.133, -0.139)) * bufB[2] + mat4(vec4(0.039, 0.170, -0.386, -0.020), vec4(-0.144, 0.010, -0.002, -0.166), vec4(-0.208, 0.189, 0.013, 0.132), vec4(-0.007, 0.110, -0.030, 0.184)) * bufB[3] + mat4(vec4(-0.024, -0.074, -0.056, -0.198), vec4(0.173, 0.065, -0.018, -0.361), vec4(0.018, -0.278, -0.145, -0.379), vec4(-0.247, -0.001, 0.107, -0.019)) * bufB[4] + mat4(vec4(-0.091, -0.145, 0.125, 0.020), vec4(0.148, -0.148, 0.108, -0.057), vec4(0.104, 0.008, 0.282, -0.158), vec4(-0.108, -0.064, -0.201, -0.000)) * bufB[5] + mat4(vec4(0.237, 0.044, -0.110, 0.475), vec4(-0.052, -0.148, -0.018, -0.064), vec4(0.165, -0.031, 0.104, -0.135), vec4(0.087, -0.092, 0.106, -0.022)) * bufB[6] + mat4(vec4(0.155, 0.163, 0.245, -0.160), vec4(0.297, 0.239, 0.076, 0.201), vec4(-0.050, -0.108, -0.380, 0.117), vec4(-0.114, -0.230, -0.054, -0.113)) * bufB[7] + mat4(vec4(0.435, -0.149, -0.167, 0.336), vec4(-0.004, -0.059, -0.006, -0.129), vec4(-0.008, 0.097, 0.107, -0.241), vec4(0.126, -0.004, -0.293, 0.265)) * bufB[8] + mat4(vec4(0.115, -0.103, 0.123, 0.097), vec4(0.176, -0.083, 0.265, -0.074), vec4(0.201, 0.188, -0.028, -0.147), vec4(-0.224, -0.210, -0.204, 0.125)) * bufB[9];\nbufA[1] = vec4(-0.343, 0.128, 0.355, 0.209) + mat4(vec4(-0.155, 0.049, 0.184, -0.137), vec4(0.035, 0.062, 0.179, 0.069), vec4(0.192, -0.354, -0.017, 0.178), vec4(0.048, 0.174, -0.196, -0.232)) * bufB[0] + mat4(vec4(0.097, -0.026, 0.150, -0.129), vec4(-0.067, -0.082, -0.021, -0.057), vec4(0.222, -0.120, 0.078, 0.047), vec4(-0.208, 0.033, -0.172, 0.208)) * bufB[1] + mat4(vec4(0.115, -0.217, 0.038, 0.076), vec4(0.048, 0.248, 0.084, -0.103), vec4(0.125, 0.283, 0.051, 0.212), vec4(-0.202, -0.061, 0.117, 0.129)) * bufB[2] + mat4(vec4(-0.159, 0.204, 0.160, -0.109), vec4(0.198, 0.113, -0.034, -0.256), vec4(0.062, -0.160, 0.227, 0.029), vec4(-0.251, 0.042, -0.154, 0.343)) * bufB[3] + mat4(vec4(0.287, -0.229, -0.087, 0.115), vec4(0.196, -0.032, -0.034, -0.124), vec4(0.083, -0.065, 0.052, -0.037), vec4(0.123, 0.081, -0.180, 0.121)) * bufB[4] + mat4(vec4(-0.154, -0.329, 0.114, -0.042), vec4(-0.173, 0.151, 0.079, -0.081), vec4(-0.079, 0.057, 0.410, -0.023), vec4(-0.201, 0.113, -0.168, -0.167)) * bufB[5] + mat4(vec4(-0.305, 0.316, 0.088, -0.036), vec4(-0.026, 0.115, -0.158, 0.162), vec4(0.130, -0.117, 0.029, 0.143), vec4(-0.213, -0.095, -0.036, 0.000)) * bufB[6] + mat4(vec4(-0.050, 0.313, 0.075, -0.408), vec4(0.198, 0.176, -0.063, -0.318), vec4(-0.035, 0.354, -0.113, -0.267), vec4(0.033, 0.038, -0.196, -0.307)) * bufB[7] + mat4(vec4(-0.199, -0.308, -0.222, -0.009), vec4(-0.435, -0.194, 0.182, 0.050), vec4(0.177, -0.398, 0.029, -0.109), vec4(0.175, 0.473, 0.269, -0.029)) * bufB[8] + mat4(vec4(0.026, 0.100, 0.055, -0.013), vec4(-0.124, -0.181, -0.076, 0.166), vec4(-0.182, 0.015, 0.139, -0.121), vec4(-0.011, -0.107, 0.007, -0.026)) * bufB[9];\nbufA[2] = vec4(-0.143, -0.150, -0.268, -0.161) + mat4(vec4(-0.135, -0.045, -0.010, -0.231), vec4(-0.176, -0.206, -0.012, 0.075), vec4(-0.191, 0.009, -0.202, -0.353), vec4(0.094, 0.015, -0.003, -0.277)) * bufB[0] + mat4(vec4(-0.028, 0.049, -0.028, 0.072), vec4(-0.172, 0.109, -0.135, 0.082), vec4(0.242, -0.110, -0.062, 0.210), vec4(0.209, -0.141, 0.013, -0.118)) * bufB[1] + mat4(vec4(0.170, -0.008, 0.096, 0.071), vec4(0.016, -0.019, -0.116, 0.004), vec4(-0.049, -0.076, -0.072, -0.139), vec4(-0.258, 0.121, -0.139, -0.114)) * bufB[2] + mat4(vec4(0.009, 0.141, -0.097, 0.057), vec4(-0.260, 0.054, 0.125, -0.123), vec4(-0.014, 0.164, -0.065, -0.142), vec4(0.097, -0.177, 0.111, -0.091)) * bufB[3] + mat4(vec4(0.213, -0.029, 0.234, -0.025), vec4(0.133, -0.042, -0.144, 0.167), vec4(0.101, 0.186, 0.103, -0.134), vec4(-0.382, 0.093, 0.211, 0.071)) * bufB[4] + mat4(vec4(-0.056, -0.002, 0.024, 0.051), vec4(0.041, 0.109, 0.107, 0.092), vec4(-0.234, 0.023, -0.068, 0.244), vec4(0.058, -0.127, -0.241, 0.291)) * bufB[5] + mat4(vec4(-0.009, -0.038, -0.157, 0.224), vec4(0.092, 0.011, -0.087, 0.209), vec4(0.054, -0.014, -0.205, -0.022), vec4(0.066, -0.130, 0.103, 0.014)) * bufB[6] + mat4(vec4(-0.272, -0.092, -0.155, 0.173), vec4(-0.006, -0.023, 0.174, 0.093), vec4(-0.095, 0.032, 0.005, 0.075), vec4(-0.267, -0.073, -0.024, -0.138)) * bufB[7] + mat4(vec4(0.232, -0.091, 0.006, 0.122), vec4(0.337, -0.278, 0.194, 0.115), vec4(-0.579, 0.113, -0.017, -0.058), vec4(-0.109, 0.195, -0.121, 0.333)) * bufB[8] + mat4(vec4(0.176, -0.159, 0.287, -0.375), vec4(0.027, -0.321, -0.061, 0.146), vec4(-0.104, -0.004, 0.319, 0.004), vec4(0.408, -0.087, 0.201, -0.126)) * bufB[9];\nbufA[3] = vec4(0.089, -0.012, -0.051, 0.016) + mat4(vec4(0.021, -0.007, -0.134, -0.367), vec4(0.001, 0.141, -0.001, 0.156), vec4(0.231, -0.048, -0.212, 0.280), vec4(-0.062, 0.011, 0.353, -0.002)) * bufB[0] + mat4(vec4(-0.123, -0.223, 0.117, -0.003), vec4(0.175, 0.108, 0.124, -0.001), vec4(-0.303, 0.155, 0.189, -0.118), vec4(0.047, 0.301, -0.073, 0.098)) * bufB[1] + mat4(vec4(-0.183, 0.170, -0.001, 0.182), vec4(0.131, 0.115, -0.067, 0.004), vec4(0.106, 0.123, 0.111, 0.003), vec4(0.072, 0.202, -0.070, -0.058)) * bufB[2] + mat4(vec4(-0.127, -0.095, -0.176, 0.016), vec4(0.086, 0.234, 0.108, 0.316), vec4(-0.024, 0.170, -0.236, 0.118), vec4(0.059, 0.148, 0.086, -0.148)) * bufB[3] + mat4(vec4(0.197, -0.082, 0.018, -0.097), vec4(-0.023, 0.268, -0.042, -0.033), vec4(-0.069, -0.114, -0.039, -0.073), vec4(0.154, 0.329, -0.133, -0.089)) * bufB[4] + mat4(vec4(-0.182, 0.014, 0.014, -0.141), vec4(0.145, 0.199, 0.230, 0.025), vec4(0.012, 0.016, -0.102, 0.283), vec4(0.288, 0.239, 0.070, -0.119)) * bufB[5] + mat4(vec4(-0.178, 0.011, 0.440, -0.285), vec4(0.203, 0.162, 0.086, -0.077), vec4(0.117, -0.017, -0.066, -0.140), vec4(0.029, 0.219, 0.154, 0.171)) * bufB[6] + mat4(vec4(0.092, 0.099, -0.142, 0.209), vec4(-0.279, -0.315, 0.144, 0.119), vec4(-0.288, 0.221, 0.091, -0.036), vec4(0.137, -0.054, -0.079, -0.044)) * bufB[7] + mat4(vec4(-0.335, -0.007, -0.063, 0.083), vec4(0.021, -0.007, -0.056, 0.153), vec4(0.281, 0.324, 0.012, 0.254), vec4(0.106, 0.043, 0.144, -0.244)) * bufB[8] + mat4(vec4(0.012, 0.173, 0.152, -0.082), vec4(0.079, 0.012, 0.135, -0.144), vec4(-0.021, 0.201, 0.079, 0.137), vec4(-0.213, -0.059, 0.151, -0.184)) * bufB[9];\nbufA[4] = vec4(0.159, -0.291, -0.418, 0.017) + mat4(vec4(0.111, 0.170, -0.049, -0.092), vec4(-0.194, -0.149, -0.020, -0.141), vec4(-0.141, 0.158, 0.162, -0.005), vec4(0.013, -0.036, -0.071, -0.098)) * bufB[0] + mat4(vec4(-0.234, -0.056, 0.201, -0.178), vec4(0.047, -0.136, 0.076, -0.247), vec4(-0.220, -0.082, 0.036, 0.034), vec4(-0.033, -0.002, -0.286, -0.125)) * bufB[1] + mat4(vec4(-0.015, 0.045, 0.031, -0.386), vec4(-0.168, 0.013, -0.035, 0.010), vec4(0.116, -0.192, -0.012, -0.004), vec4(0.096, -0.298, 0.047, 0.051)) * bufB[2] + mat4(vec4(0.047, -0.091, 0.132, -0.031), vec4(-0.072, 0.159, -0.185, -0.149), vec4(-0.215, -0.181, 0.369, -0.041), vec4(0.024, 0.043, -0.289, 0.140)) * bufB[3] + mat4(vec4(0.296, -0.199, -0.057, 0.281), vec4(0.158, -0.021, -0.005, 0.040), vec4(0.058, -0.118, -0.138, 0.050), vec4(0.103, -0.207, -0.209, -0.067)) * bufB[4] + mat4(vec4(0.164, -0.146, -0.164, -0.034), vec4(-0.153, -0.201, -0.137, -0.042), vec4(-0.006, -0.122, -0.141, -0.090), vec4(-0.226, 0.407, -0.175, -0.026)) * bufB[5] + mat4(vec4(-0.149, 0.356, -0.199, 0.230), vec4(-0.224, -0.002, -0.064, 0.113), vec4(0.079, -0.035, -0.027, -0.185), vec4(-0.122, 0.182, 0.005, -0.143)) * bufB[6] + mat4(vec4(-0.037, 0.084, -0.394, -0.086), vec4(-0.243, 0.063, 0.150, 0.050), vec4(0.076, 0.352, -0.197, -0.106), vec4(0.134, -0.036, 0.071, 0.145)) * bufB[7] + mat4(vec4(-0.054, -0.122, -0.082, 0.253), vec4(-0.092, -0.212, -0.051, 0.031), vec4(-0.093, 0.176, 0.024, -0.060), vec4(0.093, -0.093, -0.285, -0.025)) * bufB[8] + mat4(vec4(-0.330, 0.260, -0.120, -0.029), vec4(0.019, 0.085, 0.089, 0.025), vec4(-0.282, -0.015, 0.282, 0.057), vec4(0.308, 0.155, 0.186, 0.058)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(-0.428, 0.197, -0.479, 0.381) + mat4(vec4(-0.214, 0.271, -0.119, -0.179), vec4(-0.141, 0.168, 0.012, -0.045), vec4(-0.075, -0.047, -0.199, 0.109), vec4(-0.159, -0.204, 0.108, 0.073)) * bufB[0] + mat4(vec4(-0.070, -0.071, -0.389, -0.017), vec4(-0.065, -0.027, -0.009, 0.061), vec4(0.171, -0.061, 0.045, 0.190), vec4(0.103, 0.094, -0.150, 0.307)) * bufB[1] + mat4(vec4(-0.173, 0.297, 0.190, -0.009), vec4(0.142, 0.008, 0.013, 0.113), vec4(0.086, 0.448, -0.019, -0.019), vec4(0.172, 0.275, 0.138, -0.161)) * bufB[2] + mat4(vec4(0.277, 0.118, 0.053, 0.004), vec4(-0.050, 0.067, -0.018, -0.196), vec4(-0.038, -0.401, 0.199, -0.130), vec4(0.159, 0.242, 0.059, 0.113)) * bufB[3] + mat4(vec4(0.041, -0.172, 0.195, 0.068), vec4(0.014, -0.237, 0.260, -0.104), vec4(0.248, 0.014, 0.089, -0.265), vec4(0.224, -0.012, 0.041, -0.248)) * bufB[4] + mat4(vec4(-0.097, 0.075, 0.116, -0.325), vec4(-0.227, -0.084, 0.067, 0.143), vec4(-0.178, -0.109, 0.113, 0.163), vec4(-0.084, 0.125, -0.270, -0.175)) * bufB[5] + mat4(vec4(-0.069, 0.169, -0.008, -0.126), vec4(0.115, -0.429, 0.358, -0.150), vec4(-0.141, -0.077, -0.014, -0.203), vec4(-0.134, -0.046, 0.166, -0.349)) * bufB[6] + mat4(vec4(-0.162, -0.079, 0.103, -0.055), vec4(-0.026, -0.060, 0.165, -0.051), vec4(-0.051, 0.096, 0.294, -0.233), vec4(0.107, -0.059, 0.132, -0.031)) * bufB[7] + mat4(vec4(-0.108, 0.019, 0.094, -0.126), vec4(0.259, -0.086, -0.182, -0.045), vec4(0.248, 0.105, -0.058, 0.078), vec4(-0.018, -0.073, 0.045, 0.079)) * bufB[8] + mat4(vec4(-0.072, 0.276, -0.251, 0.101), vec4(-0.170, 0.261, 0.072, -0.057), vec4(-0.351, -0.234, 0.282, -0.399), vec4(-0.247, 0.229, -0.297, -0.105)) * bufB[9];\nbufA[1] = vec4(0.004, -0.364, -0.156, 0.150) + mat4(vec4(0.029, -0.100, -0.184, -0.040), vec4(0.062, -0.042, 0.145, -0.029), vec4(-0.122, 0.022, 0.223, -0.229), vec4(-0.042, -0.202, -0.123, -0.030)) * bufB[0] + mat4(vec4(-0.213, 0.292, -0.088, -0.220), vec4(-0.205, -0.225, 0.105, -0.054), vec4(-0.167, -0.023, 0.108, -0.210), vec4(0.227, 0.126, -0.106, 0.029)) * bufB[1] + mat4(vec4(0.011, 0.199, -0.208, -0.222), vec4(0.100, 0.092, 0.020, 0.025), vec4(0.007, 0.024, -0.099, 0.071), vec4(-0.011, 0.085, 0.068, 0.027)) * bufB[2] + mat4(vec4(-0.323, -0.023, 0.058, -0.202), vec4(0.163, 0.039, -0.127, 0.190), vec4(-0.034, -0.130, 0.030, 0.007), vec4(0.162, 0.112, 0.269, -0.086)) * bufB[3] + mat4(vec4(0.286, 0.074, 0.111, 0.059), vec4(-0.360, -0.062, 0.215, 0.115), vec4(-0.192, 0.335, 0.127, 0.093), vec4(-0.074, 0.047, -0.172, 0.051)) * bufB[4] + mat4(vec4(-0.021, 0.072, -0.046, -0.056), vec4(0.078, -0.049, 0.117, -0.036), vec4(0.036, 0.029, 0.011, -0.214), vec4(0.022, -0.187, 0.066, -0.111)) * bufB[5] + mat4(vec4(0.103, -0.036, -0.306, -0.177), vec4(-0.173, -0.237, -0.075, -0.221), vec4(-0.116, 0.098, 0.021, -0.072), vec4(-0.009, -0.043, 0.109, 0.098)) * bufB[6] + mat4(vec4(-0.299, -0.498, -0.107, 0.005), vec4(-0.022, 0.047, 0.020, -0.145), vec4(-0.055, 0.237, 0.284, 0.053), vec4(-0.250, 0.123, 0.205, -0.216)) * bufB[7] + mat4(vec4(0.164, 0.081, -0.260, 0.017), vec4(0.403, 0.095, -0.053, 0.262), vec4(-0.004, 0.106, 0.167, -0.229), vec4(0.083, -0.275, 0.050, 0.143)) * bufB[8] + mat4(vec4(-0.038, -0.060, 0.097, -0.013), vec4(0.069, -0.057, -0.327, 0.270), vec4(-0.178, 0.083, -0.032, -0.131), vec4(-0.231, -0.012, 0.045, 0.004)) * bufB[9];\nbufA[2] = vec4(-0.332, -0.275, 0.091, 0.527) + mat4(vec4(0.085, -0.004, -0.111, 0.286), vec4(0.225, 0.209, -0.059, -0.029), vec4(-0.023, 0.110, -0.321, 0.106), vec4(-0.029, 0.121, 0.118, -0.133)) * bufB[0] + mat4(vec4(-0.008, -0.119, 0.045, -0.082), vec4(-0.114, 0.095, 0.047, 0.169), vec4(-0.030, 0.011, -0.070, 0.033), vec4(-0.369, -0.110, 0.148, 0.022)) * bufB[1] + mat4(vec4(0.006, 0.152, 0.182, 0.194), vec4(-0.019, 0.317, 0.071, 0.092), vec4(-0.064, 0.147, -0.051, -0.101), vec4(0.240, 0.055, 0.070, -0.259)) * bufB[2] + mat4(vec4(0.164, 0.034, -0.054, -0.357), vec4(-0.124, -0.085, -0.090, -0.047), vec4(-0.173, 0.014, 0.027, -0.075), vec4(0.127, -0.015, -0.271, 0.061)) * bufB[3] + mat4(vec4(-0.017, 0.128, -0.144, 0.134), vec4(-0.132, 0.096, -0.263, -0.228), vec4(-0.166, 0.074, 0.072, -0.086), vec4(0.105, 0.161, -0.046, 0.072)) * bufB[4] + mat4(vec4(-0.121, -0.034, -0.257, 0.171), vec4(-0.124, -0.260, -0.066, -0.053), vec4(-0.030, 0.071, -0.138, 0.241), vec4(0.055, 0.194, -0.056, -0.021)) * bufB[5] + mat4(vec4(-0.063, 0.007, -0.052, 0.037), vec4(-0.017, 0.189, -0.022, -0.104), vec4(0.144, 0.001, -0.218, -0.023), vec4(-0.006, 0.147, -0.067, -0.075)) * bufB[6] + mat4(vec4(-0.105, -0.173, -0.128, 0.052), vec4(0.150, -0.098, 0.061, -0.126), vec4(-0.082, 0.071, 0.262, -0.011), vec4(0.071, 0.217, -0.060, -0.388)) * bufB[7] + mat4(vec4(-0.108, 0.073, 0.236, -0.137), vec4(-0.098, -0.101, 0.070, -0.021), vec4(0.063, -0.256, -0.014, -0.018), vec4(0.081, -0.118, -0.305, 0.206)) * bufB[8] + mat4(vec4(0.294, -0.060, -0.197, -0.162), vec4(0.274, -0.143, -0.135, -0.160), vec4(0.118, -0.227, 0.204, -0.241), vec4(-0.180, 0.030, -0.128, 0.129)) * bufB[9];\nbufA[3] = vec4(-0.060, -0.320, 0.144, -0.106) + mat4(vec4(0.049, 0.082, -0.188, -0.081), vec4(-0.011, 0.030, -0.062, 0.095), vec4(-0.096, 0.031, -0.029, 0.008), vec4(-0.332, 0.102, -0.057, -0.037)) * bufB[0] + mat4(vec4(-0.264, -0.240, 0.073, 0.056), vec4(0.135, 0.305, 0.218, -0.097), vec4(-0.126, 0.073, 0.118, 0.216), vec4(-0.310, -0.046, -0.113, -0.113)) * bufB[1] + mat4(vec4(0.202, 0.183, -0.222, -0.103), vec4(-0.177, -0.176, -0.084, 0.096), vec4(0.017, -0.058, -0.195, -0.075), vec4(0.206, 0.172, -0.342, 0.130)) * bufB[2] + mat4(vec4(-0.079, -0.119, 0.396, 0.205), vec4(0.080, -0.481, -0.084, -0.117), vec4(0.234, 0.101, -0.098, -0.061), vec4(-0.021, 0.169, -0.019, -0.131)) * bufB[3] + mat4(vec4(0.234, -0.455, -0.038, 0.240), vec4(-0.022, 0.128, -0.150, -0.020), vec4(-0.070, 0.076, -0.046, -0.043), vec4(-0.023, 0.075, -0.187, -0.051)) * bufB[4] + mat4(vec4(-0.016, 0.051, 0.042, 0.046), vec4(-0.038, -0.022, 0.034, -0.130), vec4(0.069, 0.253, -0.248, 0.257), vec4(-0.202, -0.029, -0.226, -0.133)) * bufB[5] + mat4(vec4(0.175, 0.164, 0.162, 0.021), vec4(0.183, 0.059, -0.009, 0.180), vec4(0.184, 0.160, 0.119, -0.067), vec4(-0.003, 0.018, -0.035, 0.023)) * bufB[6] + mat4(vec4(0.060, 0.176, -0.109, 0.205), vec4(0.046, -0.103, -0.056, -0.085), vec4(0.155, -0.241, 0.141, -0.014), vec4(-0.115, -0.028, 0.116, 0.034)) * bufB[7] + mat4(vec4(0.030, -0.126, -0.143, -0.019), vec4(0.001, -0.131, 0.046, -0.011), vec4(0.095, -0.073, -0.068, 0.397), vec4(0.117, 0.175, 0.032, -0.022)) * bufB[8] + mat4(vec4(0.077, 0.213, 0.183, 0.005), vec4(-0.123, -0.016, 0.119, -0.199), vec4(-0.137, 0.036, -0.126, -0.122), vec4(-0.003, 0.022, 0.125, -0.087)) * bufB[9];\nbufA[4] = vec4(-0.312, 0.254, -0.148, 0.164) + mat4(vec4(-0.063, -0.206, -0.037, -0.162), vec4(0.151, 0.294, -0.336, 0.179), vec4(-0.030, -0.081, 0.197, -0.106), vec4(-0.131, 0.127, 0.273, 0.405)) * bufB[0] + mat4(vec4(0.030, 0.198, -0.075, 0.063), vec4(0.036, 0.044, -0.138, -0.183), vec4(-0.216, -0.322, -0.059, -0.395), vec4(-0.039, 0.016, 0.112, -0.008)) * bufB[1] + mat4(vec4(0.469, 0.129, -0.036, -0.040), vec4(0.050, 0.140, -0.376, 0.113), vec4(0.102, 0.296, -0.013, -0.267), vec4(-0.073, 0.053, 0.005, -0.163)) * bufB[2] + mat4(vec4(0.102, 0.008, 0.040, -0.201), vec4(0.115, -0.129, 0.075, 0.200), vec4(-0.031, -0.179, 0.140, 0.207), vec4(-0.180, 0.004, -0.119, 0.042)) * bufB[3] + mat4(vec4(0.024, -0.336, -0.122, 0.137), vec4(0.189, 0.073, 0.122, -0.044), vec4(-0.053, -0.044, -0.067, -0.022), vec4(-0.114, 0.046, 0.079, -0.143)) * bufB[4] + mat4(vec4(0.014, -0.041, 0.172, -0.169), vec4(-0.042, 0.007, -0.005, 0.025), vec4(-0.059, -0.037, -0.016, 0.174), vec4(-0.270, 0.074, 0.122, -0.043)) * bufB[5] + mat4(vec4(0.019, 0.033, 0.141, 0.099), vec4(-0.202, 0.077, 0.342, 0.058), vec4(0.308, 0.308, -0.188, 0.089), vec4(-0.001, -0.056, -0.025, -0.152)) * bufB[6] + mat4(vec4(0.159, 0.082, -0.152, 0.360), vec4(0.219, -0.075, -0.140, 0.024), vec4(-0.048, 0.103, -0.257, -0.034), vec4(-0.114, -0.042, 0.087, -0.135)) * bufB[7] + mat4(vec4(0.111, 0.089, -0.097, 0.044), vec4(0.062, 0.053, 0.024, -0.222), vec4(-0.056, -0.102, 0.137, 0.008), vec4(-0.014, -0.043, 0.067, 0.112)) * bufB[8] + mat4(vec4(0.116, 0.128, -0.174, -0.032), vec4(-0.231, -0.131, 0.425, -0.056), vec4(0.064, -0.009, 0.100, -0.260), vec4(-0.159, 0.241, 0.213, -0.164)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(-0.257, 0.365, -0.338, 0.190) + mat4(vec4(0.301, -0.039, 0.024, 0.162), vec4(0.021, 0.029, 0.235, -0.041), vec4(-0.154, 0.155, -0.078, -0.009), vec4(-0.272, -0.020, -0.462, 0.022)) * bufB[0] + mat4(vec4(0.109, 0.096, 0.153, 0.177), vec4(-0.123, -0.155, 0.171, 0.306), vec4(0.132, 0.021, 0.468, 0.066), vec4(0.059, 0.100, -0.226, 0.209)) * bufB[1] + mat4(vec4(-0.011, -0.021, 0.257, -0.307), vec4(-0.134, -0.014, -0.103, 0.033), vec4(-0.140, -0.229, -0.250, 0.264), vec4(-0.088, -0.158, 0.327, -0.103)) * bufB[2] + mat4(vec4(0.267, -0.267, 0.314, -0.066), vec4(-0.001, -0.017, -0.168, -0.043), vec4(-0.207, 0.142, -0.225, -0.244), vec4(-0.100, 0.139, -0.053, -0.082)) * bufB[3] + mat4(vec4(0.025, 0.216, -0.051, 0.033), vec4(-0.338, -0.133, -0.118, 0.114), vec4(0.068, 0.024, 0.070, -0.178), vec4(-0.030, -0.176, 0.090, 0.365)) * bufB[4] + mat4(vec4(0.172, 0.129, -0.001, -0.283), vec4(-0.055, -0.057, 0.170, -0.194), vec4(-0.033, 0.181, 0.010, -0.160), vec4(0.305, 0.000, -0.012, 0.119)) * bufB[5] + mat4(vec4(-0.044, 0.053, 0.014, -0.044), vec4(0.320, -0.029, 0.189, -0.553), vec4(-0.081, -0.188, -0.002, 0.169), vec4(0.078, 0.046, -0.080, -0.177)) * bufB[6] + mat4(vec4(0.016, 0.094, 0.076, 0.215), vec4(-0.182, -0.059, 0.077, 0.365), vec4(-0.359, -0.038, 0.100, -0.149), vec4(0.086, 0.190, 0.029, 0.251)) * bufB[7] + mat4(vec4(-0.118, 0.056, -0.017, -0.005), vec4(0.239, -0.022, -0.110, -0.240), vec4(0.061, 0.114, 0.182, -0.003), vec4(0.089, -0.015, -0.014, -0.064)) * bufB[8] + mat4(vec4(0.101, 0.371, 0.139, 0.155), vec4(-0.268, -0.278, -0.069, -0.032), vec4(-0.113, 0.203, 0.243, -0.068), vec4(-0.077, -0.286, 0.158, -0.268)) * bufB[9] + in0;\nbufA[1] = vec4(0.109, -0.252, -0.458, -0.431) + mat4(vec4(0.156, 0.061, -0.120, 0.008), vec4(0.306, 0.237, -0.235, 0.085), vec4(-0.160, -0.092, 0.056, -0.014), vec4(0.047, -0.036, -0.092, 0.074)) * bufB[0] + mat4(vec4(-0.134, 0.178, -0.069, -0.141), vec4(-0.273, 0.030, 0.033, -0.141), vec4(-0.463, 0.069, 0.074, 0.040), vec4(0.202, 0.245, -0.032, -0.074)) * bufB[1] + mat4(vec4(0.058, -0.127, -0.049, 0.194), vec4(-0.031, -0.057, 0.156, -0.371), vec4(0.048, 0.000, 0.207, 0.126), vec4(0.204, 0.114, -0.192, 0.088)) * bufB[2] + mat4(vec4(0.049, -0.186, -0.181, 0.164), vec4(-0.013, 0.305, -0.126, 0.155), vec4(0.100, 0.006, 0.031, -0.034), vec4(0.184, -0.036, -0.172, 0.076)) * bufB[3] + mat4(vec4(0.139, 0.002, -0.138, 0.346), vec4(-0.018, 0.030, 0.332, 0.086), vec4(-0.049, -0.120, 0.003, -0.092), vec4(0.162, 0.111, -0.120, -0.403)) * bufB[4] + mat4(vec4(0.083, -0.055, -0.012, 0.155), vec4(-0.052, -0.214, -0.045, -0.187), vec4(-0.238, -0.022, 0.258, -0.166), vec4(0.170, -0.201, -0.200, -0.096)) * bufB[5] + mat4(vec4(0.075, -0.076, -0.225, -0.111), vec4(-0.131, -0.142, -0.032, 0.080), vec4(-0.236, 0.076, 0.150, 0.243), vec4(-0.123, -0.194, -0.204, -0.050)) * bufB[6] + mat4(vec4(-0.192, -0.166, 0.017, -0.442), vec4(-0.011, -0.108, 0.029, -0.058), vec4(-0.316, 0.550, -0.281, -0.090), vec4(0.002, 0.106, -0.041, 0.127)) * bufB[7] + mat4(vec4(0.105, 0.142, -0.129, -0.096), vec4(0.135, -0.039, -0.232, -0.070), vec4(0.052, -0.249, -0.091, -0.091), vec4(-0.367, -0.110, 0.300, -0.010)) * bufB[8] + mat4(vec4(-0.187, -0.157, -0.070, -0.291), vec4(-0.008, 0.080, 0.302, -0.051), vec4(-0.119, 0.019, -0.075, -0.102), vec4(-0.166, -0.106, -0.109, -0.270)) * bufB[9] + in1;\nbufA[2] = vec4(-0.197, -0.056, 0.214, -0.245) + mat4(vec4(0.151, 0.017, 0.006, -0.095), vec4(0.124, -0.082, -0.271, 0.164), vec4(-0.025, -0.129, 0.046, -0.319), vec4(0.261, -0.257, -0.092, 0.104)) * bufB[0] + mat4(vec4(0.188, -0.283, 0.122, -0.116), vec4(-0.140, -0.133, 0.106, 0.163), vec4(0.107, 0.146, 0.000, -0.046), vec4(-0.083, -0.148, 0.160, -0.178)) * bufB[1] + mat4(vec4(-0.154, 0.162, 0.105, 0.182), vec4(-0.096, 0.147, 0.142, 0.034), vec4(0.088, -0.021, -0.220, 0.052), vec4(0.317, 0.044, 0.045, -0.128)) * bufB[2] + mat4(vec4(-0.140, 0.105, 0.007, -0.056), vec4(0.436, 0.151, -0.074, -0.148), vec4(-0.001, 0.080, -0.098, -0.174), vec4(-0.249, 0.287, -0.278, -0.078)) * bufB[3] + mat4(vec4(0.065, 0.188, -0.017, 0.059), vec4(0.124, 0.143, -0.019, 0.081), vec4(-0.045, -0.029, 0.368, -0.103), vec4(-0.022, -0.032, 0.129, -0.135)) * bufB[4] + mat4(vec4(0.136, -0.123, 0.108, -0.047), vec4(-0.162, -0.315, 0.132, -0.071), vec4(0.133, 0.123, -0.125, -0.070), vec4(-0.023, 0.169, 0.287, 0.073)) * bufB[5] + mat4(vec4(-0.361, 0.097, 0.273, -0.275), vec4(0.033, -0.024, 0.003, 0.137), vec4(0.202, -0.042, 0.031, 0.011), vec4(-0.250, 0.269, -0.002, 0.060)) * bufB[6] + mat4(vec4(-0.066, -0.047, -0.006, -0.086), vec4(-0.138, -0.020, 0.127, -0.114), vec4(-0.104, 0.115, 0.177, -0.023), vec4(0.297, -0.120, -0.169, 0.153)) * bufB[7] + mat4(vec4(0.161, -0.070, 0.060, -0.121), vec4(0.235, -0.042, 0.061, -0.111), vec4(0.155, 0.220, -0.111, -0.169), vec4(-0.131, -0.194, 0.097, 0.152)) * bufB[8] + mat4(vec4(0.011, -0.071, 0.190, 0.212), vec4(-0.134, 0.208, 0.191, -0.252), vec4(-0.036, -0.178, 0.173, 0.191), vec4(-0.115, 0.083, 0.014, 0.177)) * bufB[9] + in2;\nbufA[3] = vec4(0.049, 0.575, -0.137, 0.228) + mat4(vec4(0.157, 0.197, -0.067, 0.117), vec4(0.005, 0.320, 0.050, -0.206), vec4(-0.125, -0.291, 0.251, -0.149), vec4(0.258, 0.028, -0.162, -0.143)) * bufB[0] + mat4(vec4(0.205, 0.100, -0.169, 0.135), vec4(-0.127, 0.023, 0.140, -0.236), vec4(-0.072, 0.108, 0.036, -0.004), vec4(0.007, 0.053, -0.015, 0.117)) * bufB[1] + mat4(vec4(-0.036, 0.136, 0.084, 0.295), vec4(0.031, -0.021, -0.125, 0.011), vec4(0.295, -0.058, -0.145, -0.125), vec4(0.061, 0.316, -0.014, -0.197)) * bufB[2] + mat4(vec4(-0.152, -0.109, -0.066, 0.136), vec4(-0.372, -0.217, -0.034, -0.115), vec4(0.110, 0.421, -0.398, 0.202), vec4(-0.084, -0.016, -0.231, 0.118)) * bufB[3] + mat4(vec4(0.039, -0.222, 0.188, -0.105), vec4(-0.133, 0.015, 0.272, -0.135), vec4(-0.025, -0.053, 0.211, -0.528), vec4(-0.020, -0.200, 0.177, 0.078)) * bufB[4] + mat4(vec4(-0.326, -0.025, 0.399, -0.031), vec4(-0.062, -0.236, -0.016, 0.301), vec4(-0.001, 0.250, -0.102, 0.100), vec4(-0.102, -0.089, -0.017, 0.084)) * bufB[5] + mat4(vec4(0.028, -0.058, -0.095, 0.085), vec4(-0.131, -0.215, 0.206, -0.298), vec4(-0.017, -0.018, -0.220, -0.124), vec4(0.125, 0.026, 0.212, -0.111)) * bufB[6] + mat4(vec4(-0.042, -0.183, -0.050, 0.165), vec4(-0.093, -0.230, 0.314, -0.121), vec4(0.056, 0.035, 0.277, 0.080), vec4(-0.247, 0.045, 0.302, 0.305)) * bufB[7] + mat4(vec4(-0.118, 0.074, -0.168, -0.504), vec4(-0.172, -0.015, 0.248, 0.006), vec4(-0.128, -0.230, 0.349, 0.046), vec4(0.101, 0.079, -0.014, 0.045)) * bufB[8] + mat4(vec4(-0.075, -0.178, 0.075, -0.207), vec4(-0.186, -0.043, 0.263, -0.218), vec4(0.025, 0.084, -0.188, -0.180), vec4(-0.323, -0.008, 0.429, -0.036)) * bufB[9] + in3;\nbufA[4] = vec4(-0.375, 0.182, 0.406, -0.111) + mat4(vec4(0.287, 0.279, 0.149, 0.183), vec4(-0.273, 0.032, 0.053, 0.121), vec4(0.210, -0.337, -0.056, 0.037), vec4(0.254, 0.145, 0.092, -0.224)) * bufB[0] + mat4(vec4(-0.173, -0.179, 0.042, 0.094), vec4(0.006, 0.141, 0.243, 0.297), vec4(-0.067, 0.464, 0.197, 0.191), vec4(-0.057, -0.055, -0.066, -0.123)) * bufB[1] + mat4(vec4(-0.051, 0.015, -0.177, 0.133), vec4(-0.197, -0.174, -0.077, -0.163), vec4(0.056, -0.168, 0.188, -0.248), vec4(-0.198, -0.123, -0.203, 0.146)) * bufB[2] + mat4(vec4(-0.124, -0.115, -0.107, -0.077), vec4(-0.328, -0.316, -0.163, -0.216), vec4(0.026, -0.021, 0.238, -0.078), vec4(0.177, -0.175, 0.259, -0.052)) * bufB[3] + mat4(vec4(-0.119, 0.056, 0.192, -0.074), vec4(-0.091, 0.026, -0.134, -0.159), vec4(0.218, 0.140, 0.069, 0.415), vec4(0.433, -0.047, 0.141, -0.162)) * bufB[4] + mat4(vec4(0.070, 0.155, -0.128, 0.060), vec4(0.257, 0.043, 0.019, 0.037), vec4(-0.261, -0.075, -0.265, -0.057), vec4(-0.283, 0.166, 0.230, 0.207)) * bufB[5] + mat4(vec4(-0.056, -0.127, -0.016, 0.063), vec4(0.202, -0.073, 0.127, -0.207), vec4(-0.101, 0.205, -0.081, -0.361), vec4(0.035, -0.003, -0.032, -0.153)) * bufB[6] + mat4(vec4(-0.035, 0.059, -0.059, 0.077), vec4(0.099, 0.230, 0.168, 0.305), vec4(-0.103, -0.132, 0.346, 0.185), vec4(0.150, -0.117, -0.098, 0.019)) * bufB[7] + mat4(vec4(0.011, -0.215, 0.084, 0.129), vec4(0.267, 0.342, 0.203, 0.026), vec4(0.299, 0.287, 0.054, 0.290), vec4(0.059, 0.144, 0.028, -0.156)) * bufB[8] + mat4(vec4(-0.270, 0.190, 0.238, 0.109), vec4(0.236, 0.414, -0.124, 0.154), vec4(0.040, 0.237, 0.150, 0.018), vec4(0.299, -0.260, 0.177, 0.080)) * bufB[9] + in0;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(-0.312, -0.269, -0.459, 0.127) + mat4(vec4(0.063, -0.051, 0.158, -0.293), vec4(0.163, -0.119, -0.132, -0.333), vec4(0.205, 0.175, -0.278, -0.141), vec4(0.237, 0.056, -0.083, 0.111)) * bufB[0] + mat4(vec4(0.312, -0.275, 0.073, -0.333), vec4(-0.092, 0.013, 0.033, 0.150), vec4(-0.056, 0.129, 0.276, 0.108), vec4(0.227, -0.106, -0.383, -0.353)) * bufB[1] + mat4(vec4(-0.095, -0.389, 0.251, 0.132), vec4(-0.024, 0.084, 0.210, -0.309), vec4(-0.141, 0.168, -0.241, 0.055), vec4(-0.244, -0.120, 0.050, 0.093)) * bufB[2] + mat4(vec4(0.073, -0.149, 0.120, -0.002), vec4(0.025, -0.230, 0.168, 0.226), vec4(-0.015, 0.266, 0.106, 0.039), vec4(0.248, -0.141, -0.384, 0.292)) * bufB[3] + mat4(vec4(0.078, 0.170, 0.069, -0.060), vec4(-0.222, -0.165, -0.076, -0.144), vec4(-0.010, 0.073, 0.156, 0.131), vec4(-0.177, 0.023, 0.286, 0.060)) * bufB[4] + mat4(vec4(-0.099, 0.052, 0.030, 0.106), vec4(0.093, -0.159, 0.316, 0.120), vec4(0.013, -0.137, -0.178, 0.125), vec4(0.084, 0.312, -0.296, -0.107)) * bufB[5] + mat4(vec4(0.102, 0.147, 0.260, 0.005), vec4(0.287, 0.309, -0.234, -0.252), vec4(-0.311, -0.104, -0.109, -0.021), vec4(0.016, -0.006, 0.438, -0.161)) * bufB[6] + mat4(vec4(0.305, 0.047, -0.285, -0.017), vec4(-0.133, 0.084, 0.303, 0.102), vec4(-0.089, 0.025, 0.052, -0.003), vec4(-0.046, 0.039, -0.069, 0.299)) * bufB[7] + mat4(vec4(0.153, 0.397, 0.011, 0.091), vec4(-0.186, -0.003, 0.164, 0.617), vec4(-0.022, -0.127, 0.064, -0.019), vec4(-0.040, -0.028, -0.087, -0.093)) * bufB[8] + mat4(vec4(-0.079, -0.177, -0.128, 0.360), vec4(0.092, -0.083, -0.178, -0.061), vec4(0.307, 0.012, 0.023, -0.236), vec4(-0.385, -0.155, -0.254, -0.140)) * bufB[9];\nbufA[1] = vec4(-0.181, -0.415, 0.025, 0.307) + mat4(vec4(-0.179, -0.097, -0.057, 0.302), vec4(0.095, 0.045, -0.024, -0.250), vec4(0.099, 0.044, 0.203, 0.075), vec4(-0.076, -0.119, 0.281, -0.049)) * bufB[0] + mat4(vec4(-0.030, 0.009, 0.080, -0.033), vec4(-0.149, -0.265, 0.012, -0.165), vec4(0.291, 0.175, 0.218, 0.085), vec4(-0.163, 0.013, -0.060, 0.303)) * bufB[1] + mat4(vec4(-0.325, -0.334, 0.317, 0.159), vec4(0.091, 0.030, -0.098, 0.020), vec4(0.022, 0.077, -0.169, -0.135), vec4(0.003, 0.066, 0.034, -0.133)) * bufB[2] + mat4(vec4(0.078, 0.137, -0.101, -0.189), vec4(-0.310, 0.126, -0.095, -0.044), vec4(0.019, 0.091, 0.188, -0.385), vec4(-0.108, 0.127, 0.053, 0.104)) * bufB[3] + mat4(vec4(-0.068, 0.073, -0.354, 0.070), vec4(-0.077, -0.005, -0.160, -0.092), vec4(-0.150, 0.011, -0.018, 0.016), vec4(0.188, -0.257, 0.177, 0.014)) * bufB[4] + mat4(vec4(0.051, -0.079, 0.032, -0.341), vec4(0.015, -0.012, 0.068, -0.066), vec4(-0.010, 0.058, -0.001, -0.159), vec4(-0.085, -0.105, -0.228, -0.048)) * bufB[5] + mat4(vec4(-0.011, 0.326, 0.199, 0.108), vec4(-0.026, 0.185, -0.391, 0.035), vec4(-0.061, -0.033, 0.293, -0.208), vec4(-0.151, -0.297, -0.049, -0.067)) * bufB[6] + mat4(vec4(-0.000, -0.264, -0.015, 0.467), vec4(0.066, -0.085, -0.097, -0.334), vec4(0.133, 0.209, -0.036, -0.098), vec4(-0.092, 0.043, -0.160, -0.076)) * bufB[7] + mat4(vec4(-0.205, -0.127, 0.055, 0.075), vec4(-0.124, 0.024, 0.318, -0.037), vec4(-0.174, 0.117, -0.020, -0.085), vec4(0.195, -0.130, 0.020, -0.321)) * bufB[8] + mat4(vec4(0.264, 0.148, 0.243, -0.180), vec4(0.015, -0.264, 0.408, -0.056), vec4(-0.263, 0.056, -0.132, 0.342), vec4(-0.027, -0.251, 0.005, 0.036)) * bufB[9];\nbufA[2] = vec4(0.370, 0.326, 0.367, -0.349) + mat4(vec4(-0.158, -0.156, 0.006, 0.094), vec4(0.013, 0.064, -0.113, -0.227), vec4(0.061, 0.438, -0.036, 0.334), vec4(0.183, -0.042, -0.096, -0.046)) * bufB[0] + mat4(vec4(-0.047, -0.310, 0.105, 0.176), vec4(-0.014, 0.211, 0.439, 0.304), vec4(0.044, 0.021, -0.305, -0.145), vec4(-0.058, -0.204, 0.306, 0.116)) * bufB[1] + mat4(vec4(0.083, -0.027, -0.124, 0.160), vec4(0.166, 0.001, 0.276, -0.229), vec4(-0.009, 0.222, 0.180, -0.173), vec4(-0.106, 0.113, -0.186, 0.209)) * bufB[2] + mat4(vec4(0.237, 0.045, 0.119, -0.019), vec4(-0.132, 0.111, -0.003, 0.078), vec4(-0.187, -0.012, -0.246, 0.156), vec4(0.074, 0.276, -0.155, 0.151)) * bufB[3] + mat4(vec4(-0.193, 0.053, -0.089, -0.127), vec4(-0.196, -0.055, -0.169, -0.104), vec4(-0.068, 0.079, 0.193, -0.033), vec4(-0.041, -0.227, -0.028, 0.172)) * bufB[4] + mat4(vec4(0.219, -0.082, 0.011, 0.096), vec4(0.015, 0.274, -0.184, -0.156), vec4(0.029, -0.059, 0.080, -0.085), vec4(0.188, 0.083, -0.004, 0.066)) * bufB[5] + mat4(vec4(0.128, -0.120, 0.295, 0.121), vec4(0.130, -0.028, 0.093, -0.058), vec4(0.043, -0.313, 0.143, -0.097), vec4(0.151, -0.246, 0.040, 0.014)) * bufB[6] + mat4(vec4(-0.219, 0.025, 0.175, -0.068), vec4(0.087, 0.126, 0.349, -0.362), vec4(-0.002, 0.192, -0.082, -0.034), vec4(0.142, 0.103, -0.085, 0.034)) * bufB[7] + mat4(vec4(-0.260, -0.089, 0.158, 0.008), vec4(-0.090, 0.081, -0.218, -0.040), vec4(0.158, -0.251, -0.210, -0.195), vec4(-0.091, 0.037, -0.333, 0.111)) * bufB[8] + mat4(vec4(0.005, 0.026, -0.118, -0.031), vec4(-0.382, 0.087, -0.217, 0.285), vec4(0.165, 0.217, 0.055, 0.311), vec4(-0.035, -0.046, 0.173, 0.073)) * bufB[9];\nbufA[3] = vec4(0.278, -0.390, -0.165, -0.213) + mat4(vec4(-0.237, -0.249, 0.138, 0.177), vec4(0.125, 0.146, -0.185, -0.075), vec4(-0.004, 0.031, -0.042, 0.237), vec4(-0.038, 0.121, -0.158, -0.186)) * bufB[0] + mat4(vec4(-0.021, -0.002, -0.101, 0.256), vec4(0.161, -0.224, 0.063, 0.145), vec4(-0.112, 0.220, -0.046, -0.017), vec4(-0.273, -0.078, 0.192, -0.102)) * bufB[1] + mat4(vec4(-0.031, -0.038, 0.199, 0.062), vec4(0.072, 0.089, -0.010, -0.030), vec4(0.142, -0.047, -0.128, -0.143), vec4(0.212, 0.103, 0.321, 0.020)) * bufB[2] + mat4(vec4(-0.155, 0.159, -0.167, 0.097), vec4(0.020, -0.026, 0.017, -0.027), vec4(0.058, 0.075, 0.189, -0.026), vec4(-0.250, 0.082, -0.071, 0.203)) * bufB[3] + mat4(vec4(-0.277, 0.034, -0.087, -0.074), vec4(-0.008, -0.123, -0.005, -0.099), vec4(0.086, -0.096, 0.193, -0.246), vec4(0.020, 0.192, 0.177, -0.064)) * bufB[4] + mat4(vec4(0.196, 0.135, 0.046, -0.107), vec4(-0.079, 0.094, -0.375, 0.028), vec4(0.239, 0.151, 0.051, -0.044), vec4(-0.045, 0.006, 0.176, 0.242)) * bufB[5] + mat4(vec4(0.107, -0.068, 0.213, -0.368), vec4(0.151, 0.110, -0.315, -0.176), vec4(-0.037, 0.211, 0.070, -0.120), vec4(0.308, -0.006, -0.049, 0.173)) * bufB[6] + mat4(vec4(0.046, -0.230, -0.131, 0.294), vec4(0.134, 0.049, -0.298, -0.112), vec4(0.015, -0.306, -0.122, -0.031), vec4(0.024, -0.238, 0.163, 0.154)) * bufB[7] + mat4(vec4(0.202, 0.074, 0.170, -0.026), vec4(-0.116, 0.172, -0.197, 0.128), vec4(-0.152, 0.245, -0.202, -0.108), vec4(-0.025, 0.142, -0.018, 0.131)) * bufB[8] + mat4(vec4(0.073, -0.066, 0.040, -0.490), vec4(-0.042, -0.286, 0.246, 0.115), vec4(0.063, -0.095, 0.109, 0.025), vec4(-0.242, -0.087, 0.040, 0.170)) * bufB[9];\nbufA[4] = vec4(-0.347, -0.173, 0.440, 0.378) + mat4(vec4(0.188, 0.049, 0.016, 0.114), vec4(-0.180, 0.134, -0.011, -0.061), vec4(-0.043, -0.001, 0.135, 0.034), vec4(0.204, -0.435, -0.084, -0.157)) * bufB[0] + mat4(vec4(0.103, 0.060, -0.342, -0.047), vec4(0.081, 0.023, -0.220, -0.169), vec4(0.170, 0.257, 0.290, 0.063), vec4(0.271, -0.046, 0.072, 0.311)) * bufB[1] + mat4(vec4(-0.054, -0.106, -0.136, -0.144), vec4(0.108, 0.254, 0.037, -0.323), vec4(0.149, 0.072, -0.080, 0.135), vec4(0.106, 0.001, 0.324, 0.292)) * bufB[2] + mat4(vec4(-0.262, -0.003, 0.176, 0.007), vec4(-0.074, 0.007, 0.149, 0.031), vec4(0.146, 0.152, -0.350, 0.206), vec4(-0.489, 0.044, 0.014, -0.267)) * bufB[3] + mat4(vec4(-0.120, 0.181, -0.118, -0.373), vec4(-0.156, -0.046, -0.007, 0.413), vec4(-0.126, 0.120, 0.198, 0.256), vec4(0.232, 0.066, -0.044, 0.037)) * bufB[4] + mat4(vec4(0.051, 0.036, -0.066, 0.008), vec4(0.012, 0.051, -0.060, -0.121), vec4(-0.018, -0.071, 0.061, -0.239), vec4(0.177, 0.079, 0.372, 0.198)) * bufB[5] + mat4(vec4(0.104, -0.196, -0.124, 0.105), vec4(0.012, 0.180, -0.090, -0.083), vec4(0.022, 0.032, -0.209, -0.020), vec4(0.141, -0.056, -0.018, 0.237)) * bufB[6] + mat4(vec4(0.262, -0.470, -0.000, 0.121), vec4(0.237, 0.111, 0.189, 0.267), vec4(0.323, 0.092, 0.157, 0.042), vec4(-0.046, 0.232, 0.216, -0.147)) * bufB[7] + mat4(vec4(0.189, 0.199, -0.227, 0.371), vec4(-0.287, 0.361, 0.143, 0.108), vec4(-0.325, -0.162, -0.125, 0.057), vec4(0.076, 0.111, 0.230, 0.175)) * bufB[8] + mat4(vec4(0.061, -0.086, 0.320, 0.023), vec4(-0.032, -0.141, -0.044, -0.047), vec4(0.260, 0.109, 0.004, -0.237), vec4(0.052, -0.222, 0.115, -0.135)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(-0.171, 0.349, -0.019, -0.205) + mat4(vec4(0.199, 0.109, -0.206, -0.360), vec4(0.299, 0.120, -0.223, 0.157), vec4(-0.115, -0.108, 0.118, 0.064), vec4(-0.124, -0.233, -0.285, -0.078)) * bufB[0] + mat4(vec4(-0.094, -0.043, -0.023, 0.080), vec4(0.317, 0.203, -0.441, 0.005), vec4(-0.303, -0.308, -0.214, 0.109), vec4(0.097, 0.015, -0.338, 0.146)) * bufB[1] + mat4(vec4(0.154, 0.102, -0.012, -0.206), vec4(-0.172, -0.147, 0.058, 0.265), vec4(0.057, 0.068, 0.178, -0.068), vec4(-0.160, 0.128, 0.034, 0.057)) * bufB[2] + mat4(vec4(0.256, 0.045, -0.054, -0.186), vec4(-0.098, -0.070, 0.129, 0.069), vec4(-0.050, 0.246, 0.247, 0.220), vec4(-0.065, -0.083, 0.032, 0.236)) * bufB[3] + mat4(vec4(0.199, -0.246, -0.025, 0.196), vec4(-0.430, -0.148, -0.246, 0.031), vec4(0.203, -0.275, 0.163, 0.233), vec4(0.077, -0.233, 0.053, 0.005)) * bufB[4] + mat4(vec4(0.208, -0.152, -0.153, 0.261), vec4(-0.007, 0.003, -0.173, -0.465), vec4(-0.039, 0.137, 0.082, 0.040), vec4(-0.149, 0.177, -0.277, 0.036)) * bufB[5] + mat4(vec4(-0.036, -0.331, -0.287, 0.044), vec4(0.251, 0.112, 0.055, -0.148), vec4(0.109, 0.055, 0.149, 0.001), vec4(0.088, -0.178, 0.148, 0.153)) * bufB[6] + mat4(vec4(0.018, 0.262, -0.202, 0.059), vec4(-0.042, 0.226, -0.274, -0.126), vec4(-0.192, 0.182, -0.030, -0.133), vec4(-0.010, -0.224, 0.085, -0.052)) * bufB[7] + mat4(vec4(-0.141, -0.330, 0.644, 0.384), vec4(-0.138, -0.096, 0.171, 0.001), vec4(0.010, -0.258, -0.023, 0.089), vec4(0.553, -0.058, -0.069, -0.123)) * bufB[8] + mat4(vec4(0.157, -0.003, -0.115, 0.076), vec4(0.232, 0.158, 0.184, 0.333), vec4(0.043, 0.049, 0.247, 0.200), vec4(0.228, 0.050, 0.096, 0.219)) * bufB[9];\nbufA[1] = vec4(-0.513, -0.525, -0.201, 0.444) + mat4(vec4(-0.008, -0.081, -0.105, -0.255), vec4(0.108, 0.082, 0.005, 0.037), vec4(0.302, 0.262, -0.228, -0.085), vec4(0.054, -0.166, -0.157, 0.281)) * bufB[0] + mat4(vec4(-0.084, 0.241, -0.035, -0.150), vec4(-0.188, -0.078, 0.379, -0.026), vec4(0.114, 0.071, -0.139, 0.368), vec4(-0.191, 0.306, -0.232, -0.103)) * bufB[1] + mat4(vec4(-0.241, 0.141, -0.031, -0.241), vec4(0.208, 0.092, -0.107, 0.298), vec4(0.400, -0.481, -0.382, -0.161), vec4(0.256, 0.093, -0.133, 0.142)) * bufB[2] + mat4(vec4(0.307, -0.044, 0.160, -0.126), vec4(0.120, 0.129, 0.334, 0.103), vec4(0.261, 0.178, -0.075, 0.110), vec4(-0.159, 0.254, 0.104, 0.297)) * bufB[3] + mat4(vec4(0.429, -0.019, -0.508, 0.043), vec4(0.199, -0.078, 0.458, -0.079), vec4(-0.089, -0.048, -0.246, -0.210), vec4(0.284, -0.151, 0.016, -0.218)) * bufB[4] + mat4(vec4(-0.072, 0.143, 0.197, -0.026), vec4(-0.578, 0.034, -0.032, 0.163), vec4(0.073, -0.132, 0.075, -0.269), vec4(0.333, 0.385, 0.371, -0.139)) * bufB[5] + mat4(vec4(-0.032, -0.204, 0.264, 0.192), vec4(-0.156, 0.180, -0.233, 0.190), vec4(0.197, 0.071, -0.162, -0.108), vec4(0.160, 0.281, -0.029, 0.193)) * bufB[6] + mat4(vec4(0.074, 0.242, -0.015, 0.253), vec4(0.015, 0.518, 0.200, -0.072), vec4(0.047, 0.088, -0.315, 0.246), vec4(-0.086, 0.083, -0.609, -0.392)) * bufB[7] + mat4(vec4(0.149, -0.268, -0.292, -0.389), vec4(0.192, 0.046, -0.201, 0.212), vec4(0.309, 0.132, -0.204, -0.105), vec4(-0.024, -0.050, -0.104, -0.376)) * bufB[8] + mat4(vec4(0.175, -0.428, 0.285, 0.252), vec4(-0.055, 0.051, -0.467, 0.127), vec4(-0.079, 0.260, 0.006, -0.517), vec4(0.076, -0.180, 0.145, 0.059)) * bufB[9];\nbufA[2] = vec4(0.066, -0.274, 0.031, 0.148) + mat4(vec4(-0.059, -0.012, -0.030, -0.039), vec4(0.217, -0.024, -0.128, 0.234), vec4(0.382, 0.029, -0.068, 0.047), vec4(-0.204, 0.424, -0.049, -0.031)) * bufB[0] + mat4(vec4(-0.161, -0.037, 0.124, -0.260), vec4(-0.063, -0.096, 0.305, -0.307), vec4(-0.324, 0.171, -0.129, 0.526), vec4(0.010, 0.243, 0.129, 0.215)) * bufB[1] + mat4(vec4(0.299, -0.383, -0.063, -0.097), vec4(0.031, 0.037, -0.032, -0.166), vec4(0.429, -0.227, 0.338, -0.164), vec4(0.191, 0.075, -0.241, 0.033)) * bufB[2] + mat4(vec4(-0.079, -0.162, -0.176, -0.434), vec4(0.312, 0.149, -0.033, 0.000), vec4(-0.057, -0.037, 0.027, 0.133), vec4(0.153, -0.062, 0.051, 0.095)) * bufB[3] + mat4(vec4(0.389, 0.138, 0.432, -0.306), vec4(-0.427, 0.046, 0.288, -0.012), vec4(-0.209, 0.167, -0.116, 0.129), vec4(-0.091, 0.191, -0.116, -0.012)) * bufB[4] + mat4(vec4(-0.146, 0.193, -0.137, 0.118), vec4(-0.050, -0.087, -0.122, 0.180), vec4(0.098, 0.079, -0.002, 0.093), vec4(0.151, 0.114, -0.098, 0.074)) * bufB[5] + mat4(vec4(0.193, 0.002, 0.088, -0.128), vec4(0.245, 0.000, 0.069, 0.030), vec4(0.102, 0.000, 0.113, -0.177), vec4(0.230, -0.185, -0.106, 0.111)) * bufB[6] + mat4(vec4(-0.165, 0.208, 0.083, 0.125), vec4(-0.101, 0.161, 0.212, 0.014), vec4(0.061, -0.185, 0.009, -0.038), vec4(0.065, -0.050, -0.099, -0.316)) * bufB[7] + mat4(vec4(0.279, -0.279, -0.079, 0.048), vec4(0.126, 0.184, 0.291, -0.050), vec4(0.196, -0.093, 0.201, -0.007), vec4(0.301, 0.159, 0.392, -0.400)) * bufB[8] + mat4(vec4(-0.179, 0.142, -0.102, 0.178), vec4(0.308, -0.242, -0.153, 0.161), vec4(-0.203, -0.179, 0.388, -0.157), vec4(0.098, 0.237, 0.275, -0.097)) * bufB[9];\nbufA[3] = vec4(-0.085, 0.246, 0.450, 0.150) + mat4(vec4(-0.101, -0.229, -0.088, 0.624), vec4(-0.284, -0.102, 0.283, -0.219), vec4(-0.056, -0.053, 0.001, 0.143), vec4(-0.108, 0.077, 0.001, -0.438)) * bufB[0] + mat4(vec4(0.404, 0.192, 0.109, -0.051), vec4(0.257, -0.075, -0.143, 0.168), vec4(0.201, -0.261, 0.054, -0.691), vec4(-0.379, -0.029, 0.124, -0.084)) * bufB[1] + mat4(vec4(0.144, 0.162, -0.048, 0.342), vec4(-0.111, 0.009, -0.183, -0.341), vec4(-0.281, -0.250, -0.174, 0.320), vec4(-0.069, 0.352, -0.134, 0.070)) * bufB[2] + mat4(vec4(0.025, -0.164, 0.008, 0.339), vec4(-0.104, 0.192, -0.000, 0.012), vec4(-0.239, 0.266, -0.043, -0.165), vec4(0.219, -0.064, -0.120, -0.402)) * bufB[3] + mat4(vec4(0.105, -0.456, 0.158, 0.301), vec4(0.060, 0.203, -0.131, 0.198), vec4(0.334, -0.250, 0.025, -0.216), vec4(0.112, -0.095, -0.148, -0.546)) * bufB[4] + mat4(vec4(0.106, -0.165, 0.123, -0.248), vec4(0.319, -0.418, 0.068, 0.376), vec4(-0.157, -0.115, 0.190, 0.153), vec4(-0.292, 0.172, 0.087, -0.513)) * bufB[5] + mat4(vec4(-0.119, 0.058, -0.226, 0.030), vec4(-0.006, 0.029, 0.074, -0.052), vec4(-0.110, 0.093, -0.052, 0.029), vec4(0.174, 0.028, 0.073, 0.023)) * bufB[6] + mat4(vec4(-0.253, 0.081, -0.231, -0.009), vec4(0.058, -0.280, -0.413, 0.078), vec4(0.075, -0.192, 0.173, 0.573), vec4(0.015, 0.078, 0.154, -0.029)) * bufB[7] + mat4(vec4(-0.082, -0.042, 0.250, 0.277), vec4(0.253, -0.107, -0.326, -0.111), vec4(0.154, 0.018, 0.199, -0.149), vec4(-0.008, 0.119, 0.131, 0.013)) * bufB[8] + mat4(vec4(-0.054, 0.134, 0.115, 0.098), vec4(0.036, -0.275, 0.120, -0.052), vec4(-0.100, 0.230, 0.152, -0.403), vec4(-0.130, -0.117, 0.204, -0.307)) * bufB[9];\nbufA[4] = vec4(-0.470, 0.189, -0.409, 0.217) + mat4(vec4(-0.173, 0.049, -0.185, -0.199), vec4(-0.261, -0.042, -0.259, 0.094), vec4(-0.103, 0.112, 0.105, -0.233), vec4(-0.209, -0.061, 0.265, 0.321)) * bufB[0] + mat4(vec4(0.030, -0.421, -0.101, -0.239), vec4(-0.082, 0.015, 0.050, -0.021), vec4(0.024, 0.016, 0.044, 0.103), vec4(-0.156, 0.094, 0.337, 0.084)) * bufB[1] + mat4(vec4(-0.144, 0.219, -0.190, 0.185), vec4(-0.381, -0.057, -0.233, 0.054), vec4(0.037, 0.292, -0.223, 0.174), vec4(-0.031, 0.181, -0.121, -0.176)) * bufB[2] + mat4(vec4(0.022, -0.026, -0.386, 0.003), vec4(-0.391, -0.093, -0.210, 0.052), vec4(-0.073, -0.083, -0.122, 0.114), vec4(-0.092, -0.011, -0.074, 0.006)) * bufB[3] + mat4(vec4(-0.282, -0.270, -0.240, -0.128), vec4(0.070, -0.089, 0.010, -0.298), vec4(0.078, 0.062, 0.219, -0.143), vec4(-0.345, 0.279, -0.219, -0.069)) * bufB[4] + mat4(vec4(0.214, -0.230, -0.219, -0.289), vec4(-0.257, 0.274, 0.037, -0.037), vec4(0.083, 0.489, 0.143, 0.240), vec4(-0.015, 0.111, -0.054, -0.075)) * bufB[5] + mat4(vec4(-0.161, 0.094, -0.095, -0.231), vec4(0.124, 0.004, -0.036, 0.182), vec4(0.055, -0.407, 0.178, -0.327), vec4(-0.175, 0.229, -0.358, -0.193)) * bufB[6] + mat4(vec4(0.045, 0.040, -0.056, 0.162), vec4(0.032, 0.110, -0.125, 0.199), vec4(0.079, 0.113, 0.057, 0.197), vec4(0.008, -0.155, -0.016, -0.134)) * bufB[7] + mat4(vec4(0.122, -0.209, -0.173, 0.062), vec4(0.124, -0.227, 0.127, 0.096), vec4(-0.216, 0.166, -0.326, -0.313), vec4(-0.080, -0.083, 0.103, -0.283)) * bufB[8] + mat4(vec4(-0.131, 0.068, -0.270, -0.343), vec4(0.081, -0.266, 0.343, 0.387), vec4(-0.404, 0.270, 0.192, 0.132), vec4(0.280, 0.091, 0.057, -0.282)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(-0.201, 0.032, -0.014, 0.367) + mat4(vec4(-0.186, -0.060, 0.002, -0.480), vec4(0.189, -0.258, -0.117, -0.369), vec4(0.332, 0.050, 0.011, 0.284), vec4(0.115, -0.374, 0.035, -0.075)) * bufB[0] + mat4(vec4(-0.013, -0.068, 0.417, 0.724), vec4(0.083, -0.019, 0.085, 0.012), vec4(-0.090, 0.011, -0.019, 0.062), vec4(0.000, 0.064, 0.139, 0.203)) * bufB[1] + mat4(vec4(0.227, 0.119, -0.396, 0.054), vec4(-0.352, -0.324, -0.097, 0.064), vec4(-0.318, 0.081, 0.093, -0.050), vec4(-0.025, -0.118, -0.065, 0.209)) * bufB[2] + mat4(vec4(-0.368, 0.001, 0.018, -0.137), vec4(-0.090, -0.273, 0.034, -0.026), vec4(0.399, 0.035, 0.058, 0.099), vec4(0.172, 0.136, 0.386, -0.201)) * bufB[3] + mat4(vec4(0.250, -0.065, -0.093, 0.015), vec4(0.136, -0.258, 0.246, 0.147), vec4(-0.083, -0.149, 0.117, 0.023), vec4(0.163, -0.020, -0.325, -0.212)) * bufB[4] + mat4(vec4(0.092, -0.127, 0.271, -0.328), vec4(0.066, 0.078, -0.146, -0.065), vec4(0.031, 0.128, 0.047, -0.342), vec4(0.085, 0.008, -0.398, 0.299)) * bufB[5] + mat4(vec4(-0.088, -0.317, -0.122, 0.230), vec4(-0.201, -0.217, 0.034, -0.399), vec4(-0.011, -0.364, -0.128, 0.064), vec4(-0.354, 0.075, 0.119, 0.026)) * bufB[6] + mat4(vec4(-0.014, -0.102, 0.297, -0.043), vec4(0.104, 0.355, 0.023, 0.201), vec4(0.439, -0.061, 0.051, -0.048), vec4(-0.209, 0.009, 0.299, 0.139)) * bufB[7] + mat4(vec4(-0.302, 0.416, -0.052, -0.115), vec4(0.173, 0.054, -0.103, 0.014), vec4(-0.075, 0.047, -0.110, 0.085), vec4(-0.000, -0.158, -0.209, 0.127)) * bufB[8] + mat4(vec4(0.332, 0.099, -0.235, -0.465), vec4(-0.223, 0.146, 0.184, -0.019), vec4(-0.004, 0.062, -0.209, 0.200), vec4(-0.221, 0.206, 0.048, 0.345)) * bufB[9];\nbufA[1] = vec4(-0.134, 0.428, 0.215, 0.507) + mat4(vec4(-0.021, -0.133, 0.229, -0.026), vec4(0.099, -0.118, 0.220, -0.160), vec4(0.019, -0.068, 0.483, 0.045), vec4(0.435, 0.041, -0.113, -0.137)) * bufB[0] + mat4(vec4(0.073, -0.163, 0.079, -0.399), vec4(-0.226, 0.616, 0.198, 0.078), vec4(0.149, 0.054, -0.195, -0.252), vec4(-0.151, -0.017, -0.194, 0.199)) * bufB[1] + mat4(vec4(-0.023, -0.180, -0.083, 0.118), vec4(0.155, -0.309, -0.141, 0.042), vec4(0.154, -0.331, 0.154, -0.131), vec4(0.075, 0.310, -0.139, 0.328)) * bufB[2] + mat4(vec4(-0.012, 0.015, 0.563, 0.187), vec4(0.016, 0.174, 0.223, -0.109), vec4(0.050, 0.147, 0.009, 0.059), vec4(-0.230, -0.324, 0.102, -0.210)) * bufB[3] + mat4(vec4(-0.177, -0.024, 0.229, 0.011), vec4(0.308, -0.194, -0.112, 0.044), vec4(0.045, 0.001, -0.071, 0.230), vec4(0.138, 0.094, -0.001, -0.066)) * bufB[4] + mat4(vec4(-0.224, -0.157, 0.051, -0.284), vec4(0.090, 0.159, 0.381, 0.259), vec4(-0.225, -0.155, 0.237, 0.068), vec4(-0.217, -0.145, -0.084, 0.020)) * bufB[5] + mat4(vec4(0.352, -0.396, -0.325, -0.453), vec4(-0.450, -0.042, 0.073, -0.043), vec4(0.206, -0.474, -0.028, -0.072), vec4(0.016, 0.186, 0.317, 0.504)) * bufB[6] + mat4(vec4(-0.011, -0.146, -0.045, -0.218), vec4(-0.210, 0.525, 0.094, 0.057), vec4(-0.154, 0.097, 0.075, 0.074), vec4(-0.194, 0.115, 0.035, 0.097)) * bufB[7] + mat4(vec4(-0.288, 0.145, 0.100, 0.176), vec4(0.148, 0.059, 0.164, -0.008), vec4(-0.020, -0.256, -0.110, 0.041), vec4(0.300, 0.194, -0.262, 0.047)) * bufB[8] + mat4(vec4(0.192, 0.035, -0.163, 0.049), vec4(0.409, 0.292, 0.008, -0.003), vec4(0.003, 0.094, -0.469, -0.167), vec4(0.041, 0.161, 0.177, 0.125)) * bufB[9];\nbufA[2] = vec4(-0.028, -0.150, 0.203, 0.533) + mat4(vec4(-0.076, 0.124, -0.326, -0.059), vec4(-0.330, 0.387, 0.057, -0.048), vec4(0.060, -0.164, -0.234, -0.113), vec4(0.166, -0.087, -0.014, 0.065)) * bufB[0] + mat4(vec4(-0.019, -0.064, 0.261, -0.210), vec4(-0.140, -0.140, 0.122, -0.539), vec4(0.219, 0.564, -0.762, 0.129), vec4(-0.098, 0.263, -0.442, -0.094)) * bufB[1] + mat4(vec4(-0.048, -0.209, 0.048, -0.029), vec4(-0.037, -0.045, -0.048, -0.103), vec4(-0.434, -0.059, 0.083, 0.071), vec4(0.057, 0.248, -0.086, -0.054)) * bufB[2] + mat4(vec4(0.253, -0.050, 0.318, -0.301), vec4(-0.055, 0.036, 0.015, -0.234), vec4(-0.027, -0.071, 0.177, -0.001), vec4(-0.250, 0.126, 0.047, 0.165)) * bufB[3] + mat4(vec4(0.004, -0.037, -0.128, -0.307), vec4(0.152, 0.234, -0.039, -0.038), vec4(-0.185, 0.095, -0.063, 0.049), vec4(0.151, -0.360, -0.184, 0.289)) * bufB[4] + mat4(vec4(-0.142, -0.010, 0.146, 0.040), vec4(-0.144, -0.399, 0.088, -0.048), vec4(-0.041, -0.109, 0.293, -0.315), vec4(0.373, 0.188, 0.089, -0.297)) * bufB[5] + mat4(vec4(-0.103, 0.150, 0.455, 0.132), vec4(-0.367, 0.026, -0.567, -0.105), vec4(0.057, -0.116, 0.094, 0.366), vec4(-0.155, -0.102, -0.043, 0.093)) * bufB[6] + mat4(vec4(0.328, 0.303, 0.280, -0.131), vec4(0.106, -0.378, 0.251, 0.143), vec4(-0.320, 0.038, -0.100, 0.322), vec4(-0.189, -0.210, -0.330, 0.168)) * bufB[7] + mat4(vec4(-0.169, -0.002, -0.246, 0.144), vec4(0.134, -0.161, 0.316, 0.120), vec4(-0.204, -0.134, -0.062, 0.019), vec4(-0.017, 0.341, 0.028, -0.047)) * bufB[8] + mat4(vec4(-0.069, -0.131, 0.350, 0.044), vec4(0.009, 0.104, -0.116, 0.114), vec4(0.156, 0.029, 0.142, -0.036), vec4(0.161, -0.339, -0.286, -0.257)) * bufB[9];\nbufA[3] = vec4(0.356, 0.421, 0.168, -0.174) + mat4(vec4(-0.000, -0.192, 0.010, 0.194), vec4(-0.048, -0.031, 0.378, 0.236), vec4(0.185, 0.154, 0.092, 0.015), vec4(0.105, 0.086, 0.234, 0.081)) * bufB[0] + mat4(vec4(-0.106, 0.251, -0.015, 0.309), vec4(0.192, 0.181, 0.251, -0.007), vec4(-0.031, 0.276, -0.018, 0.060), vec4(0.178, 0.015, 0.071, 0.051)) * bufB[1] + mat4(vec4(0.275, 0.318, 0.078, 0.076), vec4(-0.277, -0.170, -0.158, -0.063), vec4(0.078, 0.511, 0.105, 0.050), vec4(-0.113, 0.163, 0.256, -0.007)) * bufB[2] + mat4(vec4(-0.451, 0.153, 0.049, -0.243), vec4(-0.206, 0.280, 0.180, 0.117), vec4(-0.263, -0.083, -0.022, -0.088), vec4(0.302, -0.152, 0.199, 0.474)) * bufB[3] + mat4(vec4(0.406, -0.172, -0.184, 0.174), vec4(-0.109, 0.295, 0.133, 0.325), vec4(0.009, -0.037, -0.257, 0.002), vec4(0.149, -0.407, -0.146, -0.142)) * bufB[4] + mat4(vec4(-0.027, 0.064, -0.140, -0.213), vec4(0.300, -0.236, -0.128, -0.306), vec4(0.126, 0.021, 0.017, -0.256), vec4(0.050, 0.069, -0.114, 0.213)) * bufB[5] + mat4(vec4(0.187, 0.179, 0.056, -0.147), vec4(-0.462, -0.093, -0.226, 0.121), vec4(-0.019, 0.069, -0.082, 0.193), vec4(0.485, -0.045, -0.006, -0.092)) * bufB[6] + mat4(vec4(0.064, 0.167, 0.487, 0.033), vec4(0.149, 0.132, 0.361, 0.049), vec4(-0.017, -0.254, 0.107, -0.336), vec4(0.323, -0.396, -0.270, 0.211)) * bufB[7] + mat4(vec4(0.377, -0.171, -0.177, 0.024), vec4(0.233, -0.104, -0.160, -0.130), vec4(-0.040, -0.348, 0.035, -0.414), vec4(-0.463, -0.242, 0.088, 0.585)) * bufB[8] + mat4(vec4(-0.092, 0.128, -0.390, 0.045), vec4(-0.151, 0.159, 0.045, 0.430), vec4(0.318, 0.151, -0.300, 0.188), vec4(-0.082, -0.068, 0.222, 0.064)) * bufB[9];\nbufA[4] = vec4(0.369, 0.176, 0.140, 0.460) + mat4(vec4(-0.213, 0.056, -0.116, -0.049), vec4(0.007, -0.019, 0.171, -0.244), vec4(0.120, 0.073, 0.050, 0.013), vec4(-0.139, 0.236, 0.284, 0.377)) * bufB[0] + mat4(vec4(0.107, -0.139, -0.135, 0.210), vec4(-0.163, -0.169, 0.074, 0.064), vec4(0.013, -0.208, 0.096, -0.396), vec4(0.121, 0.384, -0.189, 0.010)) * bufB[1] + mat4(vec4(-0.183, 0.159, -0.368, 0.211), vec4(-0.064, -0.142, -0.276, 0.112), vec4(-0.107, -0.078, 0.142, 0.363), vec4(0.070, 0.080, -0.160, 0.159)) * bufB[2] + mat4(vec4(-0.372, 0.133, -0.086, -0.104), vec4(0.024, 0.041, 0.063, -0.178), vec4(0.258, -0.034, 0.180, 0.276), vec4(-0.202, 0.069, 0.104, -0.099)) * bufB[3] + mat4(vec4(-0.267, 0.102, 0.186, -0.427), vec4(0.365, 0.350, 0.028, -0.032), vec4(0.123, 0.103, 0.075, -0.048), vec4(-0.169, -0.045, 0.123, -0.051)) * bufB[4] + mat4(vec4(-0.225, -0.115, -0.098, -0.021), vec4(-0.191, 0.397, 0.041, -0.164), vec4(-0.116, -0.117, 0.027, 0.059), vec4(0.123, -0.023, -0.223, 0.137)) * bufB[5] + mat4(vec4(0.210, -0.086, -0.353, 0.220), vec4(0.165, -0.104, -0.008, 0.099), vec4(-0.411, -0.182, -0.319, -0.165), vec4(0.423, 0.547, 0.309, -0.023)) * bufB[6] + mat4(vec4(-0.063, -0.050, 0.223, -0.060), vec4(0.074, -0.056, 0.330, -0.174), vec4(0.224, -0.337, -0.058, 0.073), vec4(0.235, 0.180, -0.081, 0.015)) * bufB[7] + mat4(vec4(0.216, 0.109, -0.086, 0.025), vec4(-0.054, -0.109, -0.102, 0.055), vec4(0.149, 0.031, 0.025, 0.073), vec4(0.125, 0.179, -0.001, -0.272)) * bufB[8] + mat4(vec4(0.205, -0.250, -0.040, -0.159), vec4(0.078, -0.125, 0.080, -0.264), vec4(0.099, -0.011, -0.008, 0.351), vec4(0.049, -0.138, 0.061, -0.110)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(-0.111, -0.201, 0.275, 0.211) + mat4(vec4(0.089, 0.350, -0.428, 0.088), vec4(0.139, 0.125, 0.189, 0.026), vec4(0.107, -0.190, -0.330, -0.079), vec4(0.130, -0.282, -0.289, -0.370)) * bufB[0] + mat4(vec4(0.270, 0.191, -0.156, 0.063), vec4(-0.082, -0.262, -0.200, -0.585), vec4(0.144, 0.390, -0.042, 0.090), vec4(0.338, -0.267, -0.154, -0.276)) * bufB[1] + mat4(vec4(0.023, 0.216, 0.110, -0.020), vec4(0.515, 0.274, -0.041, -0.222), vec4(-0.548, 0.107, -0.389, -0.179), vec4(0.229, 0.045, 0.010, -0.200)) * bufB[2] + mat4(vec4(0.108, 0.274, -0.054, 0.358), vec4(0.326, 0.150, -0.044, 0.099), vec4(-0.169, 0.185, -0.246, 0.136), vec4(-0.039, 0.130, -0.108, -0.214)) * bufB[3] + mat4(vec4(-0.110, -0.068, 0.341, -0.483), vec4(0.130, -0.079, 0.329, 0.147), vec4(0.269, -0.109, -0.006, -0.372), vec4(-0.273, -0.317, 0.187, -0.034)) * bufB[4] + mat4(vec4(-0.147, -0.380, 0.054, 0.313), vec4(-0.387, -0.214, -0.341, -0.043), vec4(0.190, -0.379, -0.120, -0.087), vec4(0.296, 0.702, 0.025, -0.004)) * bufB[5] + mat4(vec4(-0.267, -0.030, -0.046, -0.118), vec4(0.365, -0.077, -0.195, 0.352), vec4(-0.230, -0.373, 0.048, 0.217), vec4(0.163, -0.240, 0.095, -0.056)) * bufB[6] + mat4(vec4(0.198, -0.310, -0.042, -0.233), vec4(-0.227, 0.046, -0.082, 0.365), vec4(0.240, 0.086, -0.369, 0.189), vec4(-0.008, -0.405, 0.136, 0.025)) * bufB[7] + mat4(vec4(-0.713, 0.048, -0.241, 0.148), vec4(0.403, -0.062, 0.351, -0.077), vec4(-0.016, 0.272, -0.062, -0.179), vec4(0.406, 0.279, -0.043, 0.072)) * bufB[8] + mat4(vec4(0.250, -0.231, 0.420, -0.527), vec4(0.042, 0.256, -0.022, -0.378), vec4(-0.068, -0.069, -0.247, 0.452), vec4(-0.223, -0.313, -0.021, 0.169)) * bufB[9];\nbufA[1] = vec4(-0.382, 0.195, -0.409, -0.156) + mat4(vec4(-0.187, -0.313, -0.254, -0.145), vec4(-0.379, -0.094, 0.369, -0.060), vec4(-0.021, -0.200, 0.017, -0.407), vec4(-0.450, -0.174, 0.187, -0.151)) * bufB[0] + mat4(vec4(0.135, 0.090, 0.018, 0.028), vec4(0.253, -0.025, 0.426, -0.210), vec4(0.125, 0.326, -0.011, 0.002), vec4(-0.028, 0.252, 0.056, 0.036)) * bufB[1] + mat4(vec4(-0.114, 0.196, -0.080, 0.134), vec4(-0.403, -0.045, 0.102, 0.200), vec4(-0.158, 0.113, 0.094, 0.120), vec4(0.139, -0.078, -0.138, -0.362)) * bufB[2] + mat4(vec4(-0.063, -0.135, -0.077, 0.462), vec4(0.020, -0.048, 0.149, 0.186), vec4(-0.035, 0.032, 0.037, -0.080), vec4(-0.051, -0.239, -0.133, 0.116)) * bufB[3] + mat4(vec4(-0.081, -0.004, -0.064, 0.191), vec4(-0.175, 0.115, -0.144, -0.046), vec4(0.110, 0.111, 0.308, 0.162), vec4(-0.081, 0.165, 0.009, -0.008)) * bufB[4] + mat4(vec4(-0.086, -0.256, -0.066, 0.229), vec4(0.271, -0.076, -0.179, 0.031), vec4(-0.078, -0.007, -0.142, 0.266), vec4(-0.069, 0.195, 0.041, -0.193)) * bufB[5] + mat4(vec4(0.277, 0.134, 0.108, 0.318), vec4(0.235, -0.504, 0.032, -0.229), vec4(-0.001, 0.295, -0.052, -0.136), vec4(-0.079, -0.124, 0.010, -0.361)) * bufB[6] + mat4(vec4(-0.089, 0.178, -0.093, 0.364), vec4(0.191, 0.042, -0.335, -0.133), vec4(0.060, -0.502, 0.043, 0.152), vec4(-0.324, 0.251, 0.067, 0.078)) * bufB[7] + mat4(vec4(0.057, -0.049, -0.092, -0.286), vec4(0.210, -0.027, -0.233, 0.007), vec4(0.027, -0.024, -0.175, 0.025), vec4(-0.422, 0.244, 0.351, 0.110)) * bufB[8] + mat4(vec4(0.046, -0.201, 0.015, 0.076), vec4(-0.027, -0.128, 0.258, -0.235), vec4(-0.041, 0.412, 0.057, -0.082), vec4(-0.030, -0.145, -0.170, 0.187)) * bufB[9];\nbufA[2] = vec4(-0.278, 0.444, -0.606, -0.096) + mat4(vec4(0.010, 0.168, -0.505, -0.188), vec4(0.263, -0.079, 0.454, -0.115), vec4(0.095, -0.095, 0.092, -0.097), vec4(0.174, -0.013, 0.263, -0.193)) * bufB[0] + mat4(vec4(-0.046, -0.260, -0.460, -0.013), vec4(0.767, -0.129, -0.445, -0.087), vec4(0.297, 0.387, -0.059, 0.219), vec4(-0.026, -0.011, -0.401, -0.083)) * bufB[1] + mat4(vec4(-0.257, -0.092, 0.137, 0.032), vec4(-0.218, 0.092, 0.143, -0.109), vec4(0.002, 0.164, -0.137, 0.091), vec4(0.076, -0.250, -0.080, -0.203)) * bufB[2] + mat4(vec4(0.008, 0.036, 0.396, 0.119), vec4(-0.180, -0.249, -0.140, -0.324), vec4(0.275, 0.204, 0.424, -0.117), vec4(-0.055, 0.054, -0.324, -0.060)) * bufB[3] + mat4(vec4(-0.180, 0.170, -0.140, -0.017), vec4(-0.000, 0.149, -0.168, -0.105), vec4(0.407, -0.117, 0.125, -0.027), vec4(-0.050, -0.131, -0.458, -0.455)) * bufB[4] + mat4(vec4(-0.108, 0.233, -0.291, -0.038), vec4(-0.313, 0.099, 0.050, -0.357), vec4(0.089, -0.317, 0.904, -0.132), vec4(-0.084, 0.173, -0.570, 0.893)) * bufB[5] + mat4(vec4(-0.140, -0.430, 0.395, -0.041), vec4(-0.485, 0.223, -0.200, -0.005), vec4(0.401, 0.086, 0.211, -0.052), vec4(0.131, 0.566, 0.054, 0.094)) * bufB[6] + mat4(vec4(0.554, -0.049, 0.558, -0.213), vec4(0.065, -0.109, -0.386, -0.381), vec4(-0.269, -0.075, -0.337, -0.576), vec4(-0.119, -0.324, 0.148, -0.209)) * bufB[7] + mat4(vec4(0.046, 0.143, -0.279, 0.309), vec4(0.138, 0.269, -0.419, 0.217), vec4(0.427, 0.172, 0.329, 0.327), vec4(0.211, -0.046, 0.028, 0.168)) * bufB[8] + mat4(vec4(-0.077, -0.056, -0.156, -0.161), vec4(0.062, 0.236, -0.032, 0.105), vec4(-0.134, 0.177, -0.180, 0.024), vec4(-0.116, -0.038, -0.176, 0.170)) * bufB[9];\nbufA[3] = vec4(0.439, -0.339, 0.013, 0.213) + mat4(vec4(-0.180, -0.051, -0.020, 0.156), vec4(-0.188, -0.187, -0.468, 0.131), vec4(-0.288, 0.000, 0.167, -0.117), vec4(0.225, 0.397, -0.016, 0.163)) * bufB[0] + mat4(vec4(0.203, 0.069, 0.285, 0.039), vec4(-0.101, -0.190, -0.306, -0.018), vec4(0.124, -0.105, 0.035, -0.270), vec4(0.382, -0.263, -0.430, -0.306)) * bufB[1] + mat4(vec4(0.144, 0.075, 0.235, 0.263), vec4(-0.291, 0.105, 0.089, -0.032), vec4(0.096, -0.121, -0.299, 0.400), vec4(0.283, 0.267, -0.142, -0.152)) * bufB[2] + mat4(vec4(0.220, -0.532, -0.186, -0.214), vec4(-0.111, 0.053, 0.123, 0.240), vec4(-0.234, -0.070, -0.056, 0.098), vec4(0.027, 0.349, -0.073, 0.042)) * bufB[3] + mat4(vec4(0.326, -0.189, -0.016, -0.025), vec4(0.265, -0.185, -0.170, -0.349), vec4(-0.149, -0.202, 0.168, -0.429), vec4(-0.253, -0.151, -0.246, 0.334)) * bufB[4] + mat4(vec4(-0.227, -0.357, 0.166, -0.410), vec4(-0.161, 0.210, -0.152, -0.169), vec4(-0.101, 0.315, 0.111, 0.064), vec4(0.105, -0.127, -0.049, 0.277)) * bufB[5] + mat4(vec4(-0.055, -0.015, 0.079, 0.097), vec4(0.069, -0.376, -0.077, 0.110), vec4(0.727, 0.032, -0.064, -0.156), vec4(0.327, -0.013, -0.200, 0.167)) * bufB[6] + mat4(vec4(-0.285, 0.012, -0.076, 0.096), vec4(0.340, 0.227, 0.079, -0.003), vec4(-0.101, 0.011, -0.038, 0.113), vec4(0.160, -0.134, -0.114, -0.161)) * bufB[7] + mat4(vec4(0.234, 0.124, -0.081, 0.070), vec4(-0.208, 0.120, -0.211, 0.439), vec4(-0.334, -0.044, -0.216, 0.206), vec4(0.355, 0.207, -0.102, -0.087)) * bufB[8] + mat4(vec4(0.185, -0.342, 0.257, -0.303), vec4(-0.507, 0.004, 0.113, 0.309), vec4(-0.321, 0.180, 0.030, 0.061), vec4(-0.124, -0.027, 0.010, -0.067)) * bufB[9];\nbufA[4] = vec4(0.145, -0.282, -0.182, -0.060) + mat4(vec4(0.330, -0.010, 0.216, 0.021), vec4(-0.276, -0.159, -0.071, -0.485), vec4(0.175, 0.165, -0.139, -0.062), vec4(0.154, -0.181, 0.313, -0.191)) * bufB[0] + mat4(vec4(0.358, 0.222, -0.183, 0.218), vec4(0.338, 0.143, 0.033, 0.001), vec4(-0.119, 0.317, 0.001, -0.098), vec4(-0.317, 0.001, 0.097, -0.065)) * bufB[1] + mat4(vec4(-0.173, 0.156, -0.212, 0.304), vec4(0.004, -0.121, 0.087, 0.547), vec4(0.310, 0.207, 0.237, 0.128), vec4(0.140, 0.057, -0.306, 0.011)) * bufB[2] + mat4(vec4(0.194, -0.371, -0.053, -0.111), vec4(0.162, -0.102, 0.262, 0.460), vec4(-0.107, -0.178, 0.396, 0.043), vec4(-0.245, -0.189, 0.220, -0.242)) * bufB[3] + mat4(vec4(0.236, 0.040, -0.322, -0.165), vec4(-0.145, -0.279, -0.043, -0.179), vec4(0.263, 0.149, -0.217, 0.084), vec4(-0.058, 0.155, 0.141, 0.017)) * bufB[4] + mat4(vec4(-0.243, -0.017, 0.004, 0.021), vec4(-0.026, -0.262, -0.024, 0.040), vec4(0.537, 0.168, 0.082, 0.078), vec4(-0.325, -0.268, 0.088, -0.210)) * bufB[5] + mat4(vec4(0.334, 0.285, -0.322, 0.293), vec4(0.088, -0.089, 0.242, -0.336), vec4(0.715, -0.194, -0.239, 0.195), vec4(0.036, -0.146, 0.049, -0.774)) * bufB[6] + mat4(vec4(-0.121, -0.015, 0.065, -0.335), vec4(0.126, 0.242, -0.284, -0.135), vec4(0.197, -0.448, -0.020, 0.043), vec4(-0.140, 0.023, -0.072, 0.149)) * bufB[7] + mat4(vec4(0.487, 0.340, -0.025, -0.041), vec4(0.164, 0.613, 0.044, 0.090), vec4(-0.371, -0.021, -0.110, 0.307), vec4(-0.244, 0.050, -0.186, -0.482)) * bufB[8] + mat4(vec4(0.026, 0.163, 0.197, 0.216), vec4(0.047, 0.013, 0.321, 0.040), vec4(0.099, 0.045, 0.187, -0.219), vec4(-0.237, 0.179, -0.079, 0.291)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(-0.021, -0.599, 0.528, -0.122) + mat4(vec4(0.083, -0.067, 0.266, 0.022), vec4(0.154, 0.068, -0.097, -0.263), vec4(0.075, -0.020, -0.012, 0.039), vec4(-0.173, 0.073, -0.090, 0.159)) * bufB[0] + mat4(vec4(-0.135, -0.118, 0.015, -0.169), vec4(-0.167, 0.105, -0.054, 0.010), vec4(0.030, -0.047, 0.143, 0.033), vec4(0.419, -0.409, 0.486, -0.099)) * bufB[1] + mat4(vec4(-0.021, 0.091, -0.043, 0.056), vec4(0.026, 0.072, 0.219, -0.003), vec4(-0.023, 0.163, -0.037, -0.103), vec4(-0.039, 0.281, 0.232, -0.127)) * bufB[2] + mat4(vec4(-0.183, 0.110, 0.236, -0.438), vec4(0.275, -0.230, -0.267, -0.076), vec4(0.228, -0.140, -0.109, -0.361), vec4(0.107, -0.019, -0.327, 0.075)) * bufB[3] + mat4(vec4(0.206, -0.020, 0.001, 0.005), vec4(-0.115, -0.131, -0.208, 0.199), vec4(-0.041, 0.159, -0.224, -0.221), vec4(0.524, -0.273, -0.028, 0.286)) * bufB[4] + mat4(vec4(0.069, 0.065, 0.211, 0.023), vec4(-0.215, 0.116, 0.226, -0.051), vec4(0.040, 0.287, -0.309, -0.120), vec4(0.063, -0.169, -0.096, -0.006)) * bufB[5] + mat4(vec4(0.133, -0.204, -0.031, 0.166), vec4(-0.181, -0.335, -0.011, 0.014), vec4(0.293, -0.018, -0.310, 0.306), vec4(0.114, -0.059, -0.271, -0.066)) * bufB[6] + mat4(vec4(0.256, -0.324, -0.363, 0.044), vec4(0.144, 0.243, -0.084, -0.102), vec4(0.014, -0.077, 0.005, -0.075), vec4(0.011, -0.131, -0.078, 0.016)) * bufB[7] + mat4(vec4(-0.223, 0.048, 0.326, -0.204), vec4(-0.122, 0.191, 0.305, 0.034), vec4(-0.210, 0.375, 0.077, -0.107), vec4(0.164, -0.218, -0.179, 0.141)) * bufB[8] + mat4(vec4(0.002, 0.145, -0.153, 0.021), vec4(-0.101, -0.225, 0.227, -0.035), vec4(-0.143, -0.203, -0.129, 0.090), vec4(-0.266, 0.355, 0.397, -0.354)) * bufB[9];\nbufA[1] = vec4(-0.176, 0.149, 0.230, 0.188) + mat4(vec4(0.179, -0.078, 0.053, -0.054), vec4(-0.156, 0.272, -0.110, 0.185), vec4(0.170, 0.089, 0.104, 0.169), vec4(-0.125, 0.024, -0.269, 0.108)) * bufB[0] + mat4(vec4(-0.018, -0.091, 0.180, 0.229), vec4(-0.288, -0.036, -0.111, 0.201), vec4(0.103, 0.139, -0.011, -0.216), vec4(0.075, -0.281, 0.032, 0.145)) * bufB[1] + mat4(vec4(0.002, -0.157, 0.135, 0.091), vec4(-0.136, -0.092, 0.100, 0.201), vec4(-0.103, -0.126, 0.196, 0.016), vec4(-0.069, 0.047, -0.073, -0.098)) * bufB[2] + mat4(vec4(-0.019, 0.008, -0.243, -0.205), vec4(-0.047, -0.274, 0.061, -0.022), vec4(0.158, 0.118, -0.102, -0.045), vec4(-0.045, -0.039, 0.169, 0.019)) * bufB[3] + mat4(vec4(0.039, -0.088, -0.215, -0.079), vec4(-0.017, 0.124, -0.165, -0.115), vec4(0.009, 0.339, -0.032, 0.258), vec4(-0.038, -0.190, 0.348, 0.200)) * bufB[4] + mat4(vec4(0.265, 0.089, -0.115, 0.085), vec4(-0.096, 0.109, 0.113, -0.020), vec4(0.202, 0.050, -0.079, 0.014), vec4(0.066, 0.394, -0.085, 0.098)) * bufB[5] + mat4(vec4(0.092, -0.093, -0.085, -0.073), vec4(-0.059, 0.193, -0.133, -0.090), vec4(0.125, 0.019, -0.032, 0.142), vec4(-0.081, -0.222, 0.166, -0.038)) * bufB[6] + mat4(vec4(0.173, -0.024, 0.120, -0.014), vec4(0.001, -0.027, 0.104, 0.011), vec4(0.067, 0.467, -0.246, -0.271), vec4(-0.125, -0.291, 0.259, 0.040)) * bufB[7] + mat4(vec4(0.103, 0.001, -0.133, -0.308), vec4(0.139, 0.255, -0.198, 0.280), vec4(-0.302, 0.084, -0.155, 0.385), vec4(-0.025, -0.066, 0.219, 0.176)) * bufB[8] + mat4(vec4(-0.007, 0.055, 0.321, 0.164), vec4(-0.282, 0.116, 0.077, 0.054), vec4(-0.201, 0.131, -0.179, 0.123), vec4(0.187, 0.166, -0.190, -0.269)) * bufB[9];\nbufA[2] = vec4(0.051, 0.475, -0.638, -0.230) + mat4(vec4(0.145, 0.224, -0.091, 0.410), vec4(-0.157, 0.021, 0.209, 0.042), vec4(0.657, -0.068, -0.045, 0.262), vec4(-0.217, -0.054, 0.249, 0.067)) * bufB[0] + mat4(vec4(-0.207, 0.151, 0.260, 0.008), vec4(0.131, -0.017, -0.238, 0.020), vec4(0.054, -0.098, -0.148, -0.027), vec4(0.191, -0.077, 0.057, 0.237)) * bufB[1] + mat4(vec4(-0.187, 0.093, -0.036, -0.054), vec4(0.389, -0.168, -0.082, 0.373), vec4(-0.342, -0.055, -0.053, 0.251), vec4(-0.130, 0.111, 0.138, 0.085)) * bufB[2] + mat4(vec4(0.129, 0.040, -0.220, 0.071), vec4(-0.199, 0.264, 0.325, 0.040), vec4(0.069, 0.222, 0.214, -0.096), vec4(-0.314, 0.094, -0.256, -0.048)) * bufB[3] + mat4(vec4(-0.270, 0.144, -0.123, -0.073), vec4(-0.000, -0.216, -0.267, -0.162), vec4(0.086, -0.161, 0.012, 0.059), vec4(-0.308, 0.376, -0.206, -0.340)) * bufB[4] + mat4(vec4(0.516, 0.190, 0.136, 0.343), vec4(0.282, -0.232, 0.030, 0.011), vec4(-0.015, -0.120, 0.071, 0.047), vec4(0.311, -0.418, 0.087, -0.017)) * bufB[5] + mat4(vec4(0.033, 0.223, -0.289, -0.207), vec4(0.263, -0.219, 0.022, -0.141), vec4(-0.072, -0.113, 0.200, -0.062), vec4(-0.045, -0.131, 0.001, 0.081)) * bufB[6] + mat4(vec4(-0.416, 0.049, 0.090, -0.117), vec4(0.019, -0.297, 0.343, 0.032), vec4(-0.051, -0.022, -0.619, -0.001), vec4(-0.795, 0.624, 0.052, -0.065)) * bufB[7] + mat4(vec4(0.259, -0.087, -0.439, 0.034), vec4(0.643, -0.226, -0.084, 0.069), vec4(0.228, -0.291, 0.033, -0.020), vec4(-0.575, 0.649, -0.039, -0.145)) * bufB[8] + mat4(vec4(-0.685, 0.428, 0.184, -0.049), vec4(-0.180, 0.122, -0.034, -0.001), vec4(-0.506, 0.311, 0.007, -0.295), vec4(0.031, -0.163, -0.310, 0.162)) * bufB[9];\nbufA[3] = vec4(-0.223, 0.226, -0.045, 0.193) + mat4(vec4(0.220, -0.156, 0.245, 0.044), vec4(-0.033, 0.069, 0.057, 0.081), vec4(0.354, -0.055, 0.094, -0.070), vec4(-0.088, 0.034, -0.116, 0.051)) * bufB[0] + mat4(vec4(0.064, -0.246, 0.191, 0.322), vec4(-0.016, 0.048, -0.202, -0.213), vec4(-0.000, 0.143, 0.118, 0.113), vec4(-0.321, -0.281, 0.070, 0.093)) * bufB[1] + mat4(vec4(0.010, -0.117, -0.158, 0.067), vec4(-0.016, 0.250, 0.133, 0.232), vec4(0.249, -0.100, 0.130, 0.068), vec4(-0.199, -0.110, -0.106, -0.177)) * bufB[2] + mat4(vec4(0.028, -0.108, 0.085, -0.240), vec4(0.031, 0.013, 0.098, 0.315), vec4(0.108, -0.060, 0.172, -0.027), vec4(-0.004, 0.090, 0.260, -0.033)) * bufB[3] + mat4(vec4(-0.055, -0.011, 0.055, 0.258), vec4(0.203, -0.003, -0.091, -0.058), vec4(-0.087, 0.077, 0.359, -0.116), vec4(-0.059, 0.240, 0.384, 0.289)) * bufB[4] + mat4(vec4(0.394, 0.013, 0.136, -0.110), vec4(-0.077, -0.205, 0.015, -0.082), vec4(-0.359, 0.217, -0.195, 0.072), vec4(0.122, -0.053, 0.174, -0.176)) * bufB[5] + mat4(vec4(0.478, 0.334, 0.024, 0.137), vec4(-0.211, -0.157, 0.066, -0.308), vec4(-0.229, -0.100, 0.097, 0.163), vec4(0.023, -0.340, 0.050, 0.141)) * bufB[6] + mat4(vec4(-0.238, -0.038, 0.164, 0.195), vec4(0.111, -0.082, 0.052, 0.094), vec4(0.077, -0.219, 0.106, -0.239), vec4(-0.200, 0.098, -0.053, 0.032)) * bufB[7] + mat4(vec4(0.275, 0.102, -0.161, -0.257), vec4(0.019, -0.067, -0.063, -0.049), vec4(0.208, 0.019, -0.235, 0.109), vec4(-0.101, 0.259, 0.094, 0.084)) * bufB[8] + mat4(vec4(-0.232, -0.003, -0.053, -0.042), vec4(0.409, -0.268, -0.019, -0.152), vec4(0.059, -0.233, -0.143, 0.002), vec4(-0.113, -0.199, -0.406, -0.508)) * bufB[9];\nbufA[4] = vec4(-0.165, -0.489, 0.566, -0.646) + mat4(vec4(0.215, 0.284, -0.219, 0.096), vec4(0.304, 0.171, -0.013, 0.141), vec4(0.181, -0.240, 0.390, -0.435), vec4(-0.075, -0.398, 0.219, -0.147)) * bufB[0] + mat4(vec4(0.294, -0.272, -0.158, 0.101), vec4(0.259, 0.358, -0.331, -0.295), vec4(0.116, 0.301, 0.012, 0.445), vec4(0.029, -0.322, 0.142, -0.299)) * bufB[1] + mat4(vec4(0.149, -0.074, -0.208, 0.049), vec4(-0.189, -0.126, 0.366, -0.068), vec4(0.212, 0.177, -0.042, 0.359), vec4(-0.397, -0.268, 0.226, 0.024)) * bufB[2] + mat4(vec4(0.144, -0.190, 0.049, -0.262), vec4(0.104, 0.362, -0.279, 0.113), vec4(0.112, -0.187, 0.049, 0.176), vec4(0.047, -0.216, -0.212, 0.366)) * bufB[3] + mat4(vec4(-0.098, 0.068, -0.179, -0.228), vec4(-0.035, -0.001, 0.042, -0.035), vec4(-0.013, 0.074, -0.043, 0.408), vec4(0.314, 0.029, 0.140, -0.053)) * bufB[4] + mat4(vec4(0.053, -0.031, 0.040, -0.018), vec4(0.256, -0.159, -0.783, 0.137), vec4(0.039, 0.040, 0.033, 0.261), vec4(-0.404, -0.543, 0.754, -0.726)) * bufB[5] + mat4(vec4(0.303, 0.450, -0.362, -0.197), vec4(-0.216, 0.323, 0.394, 0.552), vec4(-0.102, -0.317, 0.354, 0.102), vec4(0.027, 0.270, -0.460, -0.310)) * bufB[6] + mat4(vec4(-0.325, -0.315, 0.442, -0.239), vec4(0.000, 0.127, 0.299, 0.476), vec4(-0.185, -0.716, 0.451, -0.778), vec4(0.227, 0.637, -0.731, 0.473)) * bufB[7] + mat4(vec4(-0.058, -0.052, -0.042, -0.895), vec4(-0.107, -0.448, 0.383, 0.074), vec4(-0.039, -0.012, -0.068, 0.257), vec4(-0.073, 0.043, 0.022, -0.472)) * bufB[8] + mat4(vec4(-0.048, -0.133, 0.169, -0.031), vec4(0.417, -0.201, -0.628, 0.513), vec4(0.215, -0.135, 0.033, -0.080), vec4(-0.018, -0.279, 0.222, -0.474)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 9 \nbufA[0] = vec4(0.337, 0.101, -0.372, 0.000) + mat4(vec4(-0.175, 0.009, -0.052, 0.000), vec4(0.009, -0.082, -0.133, 0.000), vec4(-0.399, -0.041, 0.012, 0.000), vec4(-0.069, -0.064, -0.116, 0.000)) * bufB[0] + mat4(vec4(0.107, -0.006, 0.059, 0.000), vec4(-0.281, -0.144, -0.167, 0.000), vec4(-0.019, 0.091, 0.076, 0.000), vec4(0.017, -0.058, -0.041, 0.000)) * bufB[1] + mat4(vec4(-0.446, -0.334, -0.372, 0.000), vec4(-0.010, 0.101, 0.134, 0.000), vec4(0.156, 0.031, 0.016, 0.000), vec4(0.016, 0.040, -0.039, 0.000)) * bufB[2] + mat4(vec4(0.108, 0.066, 0.078, 0.000), vec4(-0.189, -0.051, -0.085, 0.000), vec4(-0.007, -0.142, -0.042, 0.000), vec4(0.075, 0.159, 0.147, 0.000)) * bufB[3] + mat4(vec4(-0.043, -0.097, -0.096, 0.000), vec4(0.041, 0.046, 0.001, 0.000), vec4(-0.205, -0.166, -0.154, 0.000), vec4(0.573, 0.354, -0.096, 0.000)) * bufB[4] + mat4(vec4(-0.184, -0.073, -0.063, 0.000), vec4(-0.091, -0.002, -0.038, 0.000), vec4(-0.090, -0.039, -0.038, 0.000), vec4(0.136, -0.024, -0.021, 0.000)) * bufB[5] + mat4(vec4(-0.037, -0.057, -0.086, 0.000), vec4(0.130, 0.134, 0.112, 0.000), vec4(0.106, 0.081, 0.086, 0.000), vec4(-0.081, -0.023, -0.024, 0.000)) * bufB[6] + mat4(vec4(-0.188, -0.159, -0.156, 0.000), vec4(0.073, 0.076, 0.100, 0.000), vec4(-0.082, -0.057, -0.044, 0.000), vec4(0.034, 0.050, 0.098, 0.000)) * bufB[7] + mat4(vec4(-0.055, -0.037, -0.066, 0.000), vec4(-0.081, -0.044, -0.031, 0.000), vec4(-0.028, -0.049, -0.065, 0.000), vec4(-0.033, -0.092, -0.110, 0.000)) * bufB[8] + mat4(vec4(-0.138, -0.111, -0.135, 0.000), vec4(-0.174, -0.148, -0.157, 0.000), vec4(0.164, 0.124, 0.150, 0.000), vec4(0.325, 0.186, 0.013, 0.000)) * bufB[9];\n\n return vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.0*sin(iTime), 0.5*sin(0.69*iTime), 0.0*sin(0.44*iTime), 0.5*sin(0.5*iTime));\n    //fragColor = cppn_fn(uv, 0.0, 0.0, 0.0, 0.0);\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 185, 185, 72840], [72842, 72842, 72899, 72949, 73443]], "test": "valid"}
{"id": "7lBXzz", "name": "Class 3: Fork 4 359 Cephalopod", "author": "Cephalopodium", "description": "Sphereflake. adapated from siggraph course . Expanded to level 3. Increased horizontal rotational options. Varying separation. test2 43, 151, 223, 259 objects. Note to self.. Strangely only compiles with > 151 objects if I'm running it at off peak hours.", "tags": ["sphereflake"], "likes": 0, "viewed": 57, "published": "Public", "date": "1627194729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXX 1000000.0\n\nfloat seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n    int id;\n    int firstChild;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n  \n  \n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t = MAXX; // initialize to a large number\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return t;\n}\n\n\nconst int NUM_SPHERE = 223; // 151; // 259; // 43 2nd gen ok - 259 for full 3rd gen \nSphere spheres[NUM_SPHERE];\nLight  lights[1];\n\nfloat theta = 0.0;\n\nvoid rotateSceneTenDegrees(int f, int parent, int child) {\n    theta += float(f)/5.0 * 3.1415/45.0;\n    //theta = 0.0;\n    for (int i=child+2; i<child+6; i++) { // cda was i=0 i=2 skips Top and bottom sphere rotations\n        // rotate each child sphere about y-axis \n        // through the center of the large one\n        vec3 v1 = spheres[i].center - spheres[parent].center;\n        vec3 axis = normalize(vec3(0.0, spheres[parent].radius, 0.0));\n        vec3 newv = v1*cos(theta) + cross(axis, v1)* sin(theta) + axis*dot(axis, v1)*(1.0-cos(theta));\n        spheres[i].center = newv + spheres[parent].center;\n  /*      if (parent==0) {  // cda move the grandkids\n           for (int j=spheres[i].firstChild;j<spheres[i].firstChild+6;j++) {\n             // deal with 4 middle level 2 spheres [2..5]\n             vec3 v2 = spheres[j].center - spheres[i].center;\n             vec3 axis2 = normalize(vec3(0.0, spheres[i].radius, 0.0));\n             vec3 newv2 = v2*cos(theta) + cross(axis2, v2)* sin(theta) + axis2*dot(axis2, v2)*(1.0-cos(theta));\n             spheres[j].center = newv + spheres[i].center;\n           }\n        } */\n    } \n}\n\nint addSixSpheres(Sphere parentSphere, int count) {\n    float radius = parentSphere.radius;\n    vec3 center = parentSphere.center;\n    int id = parentSphere.id;\n    parentSphere.firstChild = count+1;   // set firstChild attribute\n    float sep = -0.1; // sin(iTimeDelta)/10.0; // -0.1;  // cda separation variable\n    float dTop = 1.0; float dBot  = 1.0; float dRhs = 1.0; // cda seperation factors\n    float dLhs = 1.0; float dNear = 1.0; float dFar = 1.0;  // cda positive values push out \n    float childRadius = radius/2.181;   // parent to child reduction factor was 2.8\n    int cdaCount = count;\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y+radius+childRadius+(sep*dTop), center.z), vec3(0,0,1), id, cdaCount+1); // random(), random(), random())); // top blue\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y-radius-childRadius-(sep*dBot), center.z), vec3(1,1,0), id, cdaCount+2); // random(), random(), random())); // bot yellow\n    spheres[++count] = Sphere(childRadius, vec3(center.x+radius+childRadius+(sep*dRhs), center.y, center.z), vec3(1,0,0), id, cdaCount+3); // random(), random(), random())); // rhs red \n    spheres[++count] = Sphere(childRadius, vec3(center.x-radius-childRadius-(sep*dLhs), center.y, center.z), vec3(0,1,0), id, cdaCount+4); // random(), random(), random())); // lhs green\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y, center.z+radius+childRadius+(sep*dNear)), vec3(1,1,1), id, cdaCount+5); // random(), random(), random())); //  // near white -was vec3(sin(iTime)+1.0/2.0, random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y, center.z-radius-childRadius-(sep*dFar)), vec3(.5,.5,.5), id, cdaCount+6); // random(), random(), random())); // far grey\n   /* if (id<7) {\n       spheres[cdaCount+1].color = vec3(1/6,1,1);\n       spheres[cdaCount+2].color = vec3(2/6,1,1); \n       spheres[cdaCount+3].color = vec3(3/6,1,1);\n       spheres[cdaCount+4].color = vec3(4/6,1,1);\n       spheres[cdaCount+5].color = vec3(5/6,1,1);\n       spheres[cdaCount+6].color = vec3(6/6,1,1); \n    } else {\n       spheres[cdaCount+1].color = vec3(1,1/6,0);\n       spheres[cdaCount+2].color = vec3(1,2/6,0);\n       spheres[cdaCount+3].color = vec3(1,3/6,0);\n       spheres[cdaCount+4].color = vec3(1,4/6,0);\n       spheres[cdaCount+5].color = vec3(1,5/6,0);\n       spheres[cdaCount+6].color = vec3(1,6/6,0); \n    } */\n    return count;\n}\n\nvoid makeScene(int f) {\n    float radius=0.8;\n    vec3 center = vec3(0, 0, -6); \n    vec3 color = vec3(random(), random(), random());\n    int count = -1; // cda TBRLNF top[1] bottom[2] right[3] left[4] near[5] far[6]\n    spheres[++count] = Sphere(radius, center, color,0,-1);    // root count = 0 id=0 firstChild = -1;\n    count = addSixSpheres(spheres[0], count);  // 1st gen returns count=6\n    count = addSixSpheres(spheres[1], count);  // 2nd gen for 1st of 6 kids count=12 top T\n    count = addSixSpheres(spheres[2], count);  // count = 18 bot B\n    count = addSixSpheres(spheres[3], count);  // 24 rhs R\n    count = addSixSpheres(spheres[4], count);  // 30 lhs L\n    count = addSixSpheres(spheres[5], count);  // 36 near N\n//    count = addSixSpheres(spheres[6], count);  // 2nd gen for Last of six kids count = 42 far F invisible\n\nif (1==1) {\n    count = addSixSpheres(spheres[7], count);  // 3rd gen TT count = 48\n    count = addSixSpheres(spheres[8], count);  // 3rd gen TB count = 54\n    count = addSixSpheres(spheres[9], count);  // 3rd gen TR count = 60\n    count = addSixSpheres(spheres[10], count); // 3rd gen TL count = 66\n    count = addSixSpheres(spheres[11], count); // 3rd gen TN count = 7\n//  count = addSixSpheres(spheres[12], count); // 3rd gen TF count = 78 Invisible\n\n    count = addSixSpheres(spheres[13], count); // 3rd gen BT count = 84\n    count = addSixSpheres(spheres[14], count); // 3rd gen BB count = 90\n    count = addSixSpheres(spheres[15], count); // 3rd gen BR count = 96\n    count = addSixSpheres(spheres[16], count); // 3rd gen BL count = 102\n    count = addSixSpheres(spheres[17], count); // 3rd gen BN count = 108\n//    count = addSixSpheres(spheres[18], count); // 3rd gen BF count = 114 Invisible\n\n    count = addSixSpheres(spheres[19], count); // 3rd gen RT count = 120\n    count = addSixSpheres(spheres[20], count); // 3rd gen RB count = 126\n    count = addSixSpheres(spheres[21], count); // 3rd gen RR count = 132\n    count = addSixSpheres(spheres[22], count); // 3rd gen RL count = 138\n    count = addSixSpheres(spheres[23], count); // 3rd gen RN count = 144\n//    count = addSixSpheres(spheres[24], count); // 3rd gen RF count = 150 Invisible\n/* */\n    count = addSixSpheres(spheres[25], count); // 3rd gen LT count = 156\n    count = addSixSpheres(spheres[26], count); // 3rd gen LB count = 162\n    count = addSixSpheres(spheres[27], count); // 3rd gen LR count = 168\n    count = addSixSpheres(spheres[28], count); // 3rd gen LL count = 174\n    count = addSixSpheres(spheres[29], count); // 3rd gen LN count = 180\n//    count = addSixSpheres(spheres[30], count); // 3rd gen LF count = 186\n\n    count = addSixSpheres(spheres[31], count); // 3rd gen NT count = 192\n    count = addSixSpheres(spheres[32], count); // 3rd gen NB count = 198\n    count = addSixSpheres(spheres[33], count); // 3rd gen NR count = 204\n    count = addSixSpheres(spheres[34], count); // 3rd gen NL count = 210\n    count = addSixSpheres(spheres[35], count); // 3rd gen NN count = 216\n//    count = addSixSpheres(spheres[36], count); // 3rd gen NF count = 222\n/*\n    count = addSixSpheres(spheres[37], count); // 3rd gen FT count = 228\n    count = addSixSpheres(spheres[38], count); // 3rd gen FB count = 234\n    count = addSixSpheres(spheres[39], count); // 3rd gen FR count = 240\n    count = addSixSpheres(spheres[40], count); // 3rd gen FL count = 246\n    count = addSixSpheres(spheres[41], count); // 3rd gen FN count = 252\n    count = addSixSpheres(spheres[42], count); // 3rd gen FF count = 258 */\n  }\n    lights[0] = Light(vec3(0.0, 0.0, 0.0), vec3(1, 1, 1)); \n    rotateSceneTenDegrees(f*9,23,139);  // level 3 RN 23,145\n//  rotateSceneTenDegrees(f*9,22,133);  // level 3 RL 22,133    // hidden by FR\n    rotateSceneTenDegrees(f*9,21,127);  // level 3 RR 21,127\n    rotateSceneTenDegrees(f*9,20,121);  // level 3 RB 20,121\n    rotateSceneTenDegrees(f*9,19,115);  // level 3 RT 19,115);    // level 3 top top 7,43\n/*    rotateSceneTenDegrees(f*4,1,7);    // level 2 top\n    rotateSceneTenDegrees(f*4,2,13);   // level 2 bottom \n    rotateSceneTenDegrees(f*4,3,19);   // level 2 right\n    rotateSceneTenDegrees(f*4,4,25);   // level 2 left\n    rotateSceneTenDegrees(f*4,5,31);   // level 2 near\n  //  rotateSceneTenDegrees(f*4,6,37);   // level 2 far \n    rotateSceneTenDegrees(f*9,0,1);    // level 1 */\n}\n\nint numSamples = 1;\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   if (iFrame==0) theta = 0.0;\n   \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -1.50; // was -2.0\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       float t = MAXX;\n       int iSphere = -1;\n       float minT = MAXX;\n       for (int i=0; i < NUM_SPHERE; i++) {\n           Sphere sphere = spheres[i];\n         \n           t = raySphereIntersect(ray, sphere);\n         \n           if (t < minT) {\n               minT = t;\n               iSphere = i;\n           }\n       }\n       if (iSphere > -1 && minT < MAXX) {\n           Sphere sphere = spheres[iSphere];\n           vec3 hit = ray.origin + minT*ray.direction;\n           vec3 norm = normalize(hit - sphere.center);\n           vec3 hitPointNormal = normalize(hit-sphere.center);\n           vec3 hitPointToEye = normalize(vec3(0, 0, 0)-hit);\n           float angle = dot(hitPointNormal, hitPointToEye);\n           samp = samp + angle*sphere.color;\n          \n       }\n   }\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 107, 123, 123, 170], [553, 593, 649, 649, 1128], [1283, 1283, 1341, 1341, 2421], [2423, 2423, 2474, 2474, 4868], [4870, 4870, 4893, 4893, 9199], [9223, 9302, 9357, 9515, 11144]], "test": "valid"}
{"id": "7lfSzs", "name": "Pipes and Torus", "author": "wildniklin", "description": "that time when u were a kid and played in those indoor playgrounds... but it didn't have this terrifying lighting.", "tags": ["torus", "pipe"], "likes": 5, "viewed": 191, "published": "Public API", "date": "1626310813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 100;\nconst float MAX_DIST = 50.0;\nconst float MIN_DIST = 0.001;\nconst float PI = 3.1415;\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat rand1(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 42.1581))) * 43758.5453123);\n}\n\nfloat sdTorus(vec3 p, float t, float r) {\n  return length(vec2(length(p.xz) - t, p.y)) - r;\n}\n\nfloat sdTorus(vec3 p, float t) {\n  return length(vec2(length(p.xz) - t, p.y));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    vec3 m = abs(p) - s;\n    return length(max(m, 0.0)) + min(max(m.x, max(m.y, m.z)), 0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdSphere(vec3 p) {\n    return length(p);\n}\n\nvec3 closestPointLine(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n    float d = clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n    if(d < 0.0) return a;\n    if(d > 1.0) return b;\n    return mix(a, b, d);\n}\n\nfloat sdLine(vec3 p, vec3 a, vec3 b, float r) {\n    return length(p - closestPointLine(p, a, b)) - r;\n}\n\nfloat sdLine(vec3 p, vec3 a, vec3 b) {\n    return length(p - closestPointLine(p, a, b));\n}\n\nfloat sdTruchet(vec3 p) {\n    return min(min(sdLine(p, vec3(0.25, 0.0, 0.0), vec3(0.5, 0.0, 0.0)), sdLine(p, vec3(-0.25, 0.0, 0.0), vec3(-0.5, 0.0, 0.0))), min(min(sdTorus(p, 0.25), sdLine(p, vec3(0.0, -0.5, 0.0), vec3(0.0, 0.5, 0.0))), min(sdSphere(p - vec3(0.0, 0.0, 0.5)), sdSphere(p + vec3(0.0, 0.0, 0.5)))));\n}\n\nfloat map(vec3 p) {\n    vec3 i = floor(p);\n    vec3 m = p - i - 0.5;\n    m.xz *= rot(floor(rand1(i) * 4.0) * PI * 0.5);\n    m.xy *= rot(floor(rand1(i + 62.0) * 4.0) * PI * 0.5);\n    m.yz *= rot(floor(rand1(i + 25.0) * 4.0) * PI * 0.5);\n    //m.xz *= rot(iTime * rand1(i)); // spinnnnyyyy but glitchy... i should do 3x3 boundary sdf instead of 1x1 but im lazy lol\n    return sdTruchet(m) - 0.0625;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float ds = map(ro + (rd * d));\n        d += ds;\n        if(d > MAX_DIST) return MAX_DIST;\n        if(abs(ds) <= MIN_DIST) return d;\n    }\n    return MAX_DIST;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(MIN_DIST, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nfloat shadedPointLight(vec3 p, vec3 n, vec3 lp, float r) {\n    vec3 ln = lp - p;\n    float d = length(ln);\n    ln /= d;\n    \n    return max(0.0, dot(n, ln) * (1.0 - (d / r)) * ((march(p + ((n * MIN_DIST) * 2.0), ln) > d) ? 1.0 : 0.0));\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 uv = (i - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n    \n    float t = (iTime * 0.5) + 50.0;\n    \n    vec3 ro = vec3(0.0, 0.0, t);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    rd.yz *= rot(sin(t * PI * 0.05) * PI * 0.0625);\n    rd.xz *= rot(cos(t * PI * 0.05) * PI * 0.0625);\n\n    float d = march(ro, rd);\n    vec3 p = ro + (rd * d);\n    vec3 n = normal(p);\n\n    vec3 col = vec3(sin(p * PI * 0.25) * 0.25 + 0.5);\n    \n    vec3 light = vec3(0.0);\n    \n    light += shadedPointLight(p, n, ro + (sin(t * vec3(0.5, 0.2, 0.7)) * 0.25), 8.0);\n    light += shadedPointLight(p, n, ro + (sin(t * vec3(0.3, 0.8, 0.4)) * 0.25), 8.0);\n\n    col *= light;\n    \n    col = mix(col, vec3(0.0), smoothstep(0.0, MAX_DIST, d));\n\n    col *= smoothstep(1.8, -0.5, length(uv));\n    \n    o = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfSzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 131, 131, 197], [199, 199, 220, 220, 301], [303, 303, 344, 344, 396], [398, 398, 430, 430, 478], [480, 480, 509, 509, 604], [606, 606, 639, 639, 667], [669, 669, 693, 693, 717], [719, 719, 766, 766, 927], [929, 929, 976, 976, 1032], [1034, 1034, 1072, 1072, 1124], [1126, 1126, 1151, 1151, 1441], [1443, 1443, 1462, 1462, 1841], [1843, 1843, 1874, 1874, 2103], [2105, 2105, 2126, 2126, 2319], [2321, 2321, 2379, 2379, 2558], [2560, 2560, 2596, 2596, 3410]], "test": "valid"}
{"id": "7lfXD4", "name": "Flag - Bahamas", "author": "Eggy42", "description": "Flag of The Bahamas. Based on BigWIngs tutorial. Note I'm not from The Bahamas, only admiring their flag. :) ", "tags": ["flag", "bahama"], "likes": 4, "viewed": 28, "published": "Public", "date": "1625712497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\n// Flag of the Bahamas\n// Based on BigWIngs flag tutorial\n// https://www.shadertoy.com/view/flsXRM\n\nfloat PI = 3.14159;\nvec3 BLUE = vec3(0, 119, 139)/255.; // PANTONE 3145 \nvec3 YELLOW = vec3(255, 199, 44)/255.; // PANTONE 123\nvec3 BLACK = vec3(0.1); // A little grey so we can see the shading\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Wavy uv\n    float t = uv.x*2.-2.*iTime+uv.y*3.;\n    uv.y += sin(t)*.05;\n  \n    // Default color\n    vec3 col = BLACK;\n    \n    // Pixel width\n    float w = fwidth(uv.x);\n    \n    // Draw stripes\n    // Stripe width. Three equal stripes, so 1/3 is yellow.  \n    float swidth = 1./3./2.;\n    // AA between background and stripe\n    float hstripe = S(swidth-w, swidth+w, abs(uv.y));\n    // Color the stripes\n    col = mix(YELLOW, BLUE, hstripe);\n    \n    // Triangle\n    vec2 sv = uv+vec2(0.025, 0.);\n    sv.y = abs(sv.y);\n    float tri = dot(sv, vec2(tan(PI/6.), 1.));\n    tri = S(-w, w, tri);\n    col = mix(BLACK, col, tri);\n    \n    // Shading \n    col *= .7+cos(t)*.3;\n\n    // Clip top and bottom\n    col *= S(w, .0, abs(uv.y)-.5);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 335, 392, 443, 1302]], "test": "valid"}
{"id": "7lfXDn", "name": "Wave - distance", "author": "rodolphito", "description": "Distance to an arbitrarily rounded triangle wave with arbitrary slope.", "tags": ["2d", "wave", "sdf", "distance"], "likes": 11, "viewed": 72, "published": "Public", "date": "1625449190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2021 Rodol Phito\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a squiggly line/triangle wave\n// Heavily based on IQ's work obviously, only the actual sdf is original here\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n// c must be a positive unit vector pointing along the triangle's slope\nfloat sdWave( in vec2 p, in float r, in vec2 c )\n{\n    p.x = abs(mod(p.x,2.0)-1.0)-0.5;\n    float d = dot(p,c);\n    if (abs(d)*c.x+r*c.y-0.5 > 0.0)\n    {\n        float s = (d > 0.0) ? 1.0 : -1.0;\n        p -= s*vec2(0.5,(0.5*c.y-r)/c.x);\n        return s*(r-length(p));\n    }\n    return dot(p,vec2(c.y,-c.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = 2.*(fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = 2.*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n \n    // animation\n    float time = iTime;\n    float r = 0.25+0.25*cos(time*0.41+3.0);\n    float t = 3.*(0.5+0.5*cos(time*0.8));\n    vec2 c = normalize(vec2(1.,t + 1e-3));\n    // radius can be larger when slope is shallower\n    r /= c.y;\n    \n    // distance\n    float d = sdWave(p, r, c);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdWave(m, r, c);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfXDn.jpg", "access": "shaders20k", "license": "mit", "functions": [[1358, 1430, 1480, 1480, 1741], [1743, 1743, 1800, 1836, 2738]], "test": "valid"}
{"id": "7lfXR4", "name": "ÐÐ°Ð´Ð°Ð½Ð¸Ðµ 1.2,1.3 02.07", "author": "ndzaitsev", "description": "ÐÐ°Ð´Ð°Ð½Ð¸Ðµ 1.2,1.3 02.07", "tags": ["practice"], "likes": 2, "viewed": 49, "published": "Public", "date": "1625230587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float r = 0.5;\nconst float pi = 3.141592;\n\nvec2 cycloid(float t) {\n\treturn vec2( r*(t - sin(t)), r*(1.0 - cos(t)) );    \n}\n\nfloat disttoline(vec2 a, vec2 b, vec2 p) {\n \treturn abs( (b.y-a.y)*p.x - (b.x-a.x)*p.y + b.x*a.y-a.x*b.y ) / sqrt( dot(b-a, b-a) ) \n        * (length(a-p) + length(b-p) - length(a-b) < 0.001 ? 1.0 : 3000.0);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*pi*r * (2.0 * fragCoord - iResolution.xy)/iResolution.x + vec2(pi*r, 0.7);\n\n    float dist = 10.0;\n    float x = iTime * 3.0;\n    float tpos = 4.0*pi*r*sin(x*0.25) + pi;// = mod( (x - 2.0*mod(x, 4.0*pi) * step(4.0*pi, mod(x, 8.0*pi))), 4.0*pi ) - pi;\n    for(float t = -pi; t < tpos; t += 0.01) {\n    \tvec2 point = cycloid(t);\n        dist = min(dist, length(point - uv));\n    }\n    \n    vec2 circle = vec2(r*tpos, r);\n    vec2 finalpoint = cycloid(tpos);\n    float linedist = disttoline( circle, finalpoint, uv );\n    vec3 color = mix(vec3(0.0), mix( vec3(1.0), vec3(0.95, 0.96, 0.73), smoothstep(0.0, -0.01, length(uv-circle)-r) ), smoothstep(0.0, 0.01, abs(length(uv-circle)-r)));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(0.01, 0.0, dist));\n    color = mix(color, vec3(0.0), step(length(uv - finalpoint), 0.02));\n    color = mix( color, mix( vec3(0.0), vec3(.8, .5, .51) + pow(0.5, 1.2+7.0*abs(circle.x-uv.x))*pow(0.5, 2.0*(-uv.y)), smoothstep(0.0, 0.01, abs(uv.y + 0.005)) ), step(uv.y, 0.00) );\n    color = mix(color, vec3(0.0), smoothstep(0.01, 0.0, linedist));\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 72, 72, 128], [130, 130, 172, 172, 342], [344, 344, 401, 401, 1547]], "test": "valid"}
{"id": "7lfXW8", "name": "SDF Frog, hierarchical joints", "author": "shyuriken", "description": "modeled with \"Magica CSG\", and convert to \"SDF Editor\"\nmodel data for \"SDF Editor\" -> https://github.com/ultrahamlet/sdf_frog\n", "tags": ["sdf", "frog", "joints"], "likes": 15, "viewed": 127, "published": "Public", "date": "1625559194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SDF frog with  hierarchical joints structure\n// modeled with \"MagicaCSG\", converted to for  \"SDF Editor\"\n// SDF data for \"SDF Editor\" -> https://github.com/ultrahamlet/sdf_frog\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 3,167 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nmat3 rotateMat(vec3 p, float angle, vec3 axis) {\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle),\n\t      c = cos(angle),\n\t      r = 1. - c;\n\treturn mat3(a.x * a.x * r + c, a.y * a.x * r + a.z * s, a.z * a.x * r - a.y * s, a.x * a.y * r - a.z * s, a.y * a.y * r + c, a.z * a.y * r + a.x * s, a.x * a.z * r + a.y * s, a.y * a.z * r - a.x * s, a.z * a.z * r + c);\n}\n\nfloat pCapsule(float r, float h, vec3 p) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat pEllipsoid(vec3 r, vec3 p) {\n\tfloat k0 = length(p / r);\n\treturn k0 * (k0 - 1.) / length(p / (r * r));\n}\n\nvec3 mTranslation(vec3 inv_translation, vec3 p) { return p + inv_translation; }\n\nvec3 mRotation(mat3 inv_rotation, vec3 p) { return inv_rotation * p; }\n\nvec3 mMirror(vec3 normal, float dist, vec3 p) { return p - 2. * max(0., dot(normal, p) - dist) * normal; }\n\nfloat oUnion(float d1, float d2) { return min(d1, d2); }\n\nfloat oSmoothSubtraction(float k, float d1, float d2) {\n\tfloat h = clamp(.5 - .5 * (d1 + d2) / k, 0., 1.);\n\treturn mix(d1, -d2, h) + k * h * (1. - h);\n}\n\nfloat sdf(vec3 p0) {\n\tfloat d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19, d20;\n\t{\n\t\tvec3 p1 = mRotation(mat3(1, 0, 0, 0, -0, 1, 0, -1, -0), p0);\n\t\t{\n\t\t\tvec3 p2 = mTranslation(vec3(-0, -.493172, -3.01572), p1);\n\t\t\t{\n\t\t\t\tvec3 p3 = mRotation(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p2);\n\t\t\t\td1 = pEllipsoid(vec3(1.99929, 1.97652, 1.28), p3);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mMirror(vec3(-1, 0, 0), 0., p3);\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 p5 = mRotation(mat3(1, 0, 0, 0, -0, 1, 0, -1, -0), p4);\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 p6 = mTranslation(vec3(-1.67, -2.32, -0), p5);\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmat3 mt = rotateMat(p6, 1.5707963 - sin(iTime) * .5, vec3(0, 0, 1));\n\t\t\t\t\t\t\t\tvec3 p7 = mRotation(mt, p6);\n\t\t\t\t\t\t\t\td2 = pCapsule(.383695, 1.6905, p7);\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvec3 p8 = mTranslation(vec3(-0, -2.03, -0), p7);\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmat3 mt = rotateMat(p7, 1.5707963 + sin(iTime) * .4, vec3(0, 0, 1));\n\t\t\t\t\t\t\t\t\t\tvec3 p9 = mRotation(mt, p8);\n\t\t\t\t\t\t\t\t\t\td3 = pCapsule(.383695, 1.444452, p9);\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tvec3 p10 = mTranslation(vec3(-0, -1.83, -0), p9);\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvec3 p11 = mRotation(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p10);\n\t\t\t\t\t\t\t\t\t\t\t\td4 = pCapsule(.47, .319634, p11);\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tvec3 p12 = mTranslation(vec3(-0, -.73, -0), p11);\n\t\t\t\t\t\t\t\t\t\t\t\t\t{ d5 = pCapsule(.147221, 1.21, mRotation(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p12)); }\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tvec3 p12 = mTranslation(vec3(.25, -.82, -0), p11);\n\t\t\t\t\t\t\t\t\t\t\t\t\t{ d6 = pCapsule(.15, .93, mRotation(mat3(.866025, -.5, 0, .5, .866025, -0, -0, 0, 1), p12)); }\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tvec3 p12 = mTranslation(vec3(-.28, -.59, -0), p11);\n\t\t\t\t\t\t\t\t\t\t\t\t\t{ d7 = pCapsule(.15, .93, mRotation(mat3(.939693, .34202, -0, -.34202, .939693, 0, 0, -0, 1), p12)); }\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tvec3 p12 = mTranslation(vec3(-.13, -.03, -0), p11);\n\t\t\t\t\t\t\t\t\t\t\t\t\t{ d8 = pCapsule(.15, .93, mRotation(mat3(.652231, .758021, -0, -.758021, .652231, 0, 0, -0, 1), p12)); }\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 p5 = mRotation(mat3(1, 0, 0, 0, -0, 1, 0, -1, -0), p4);\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 p6 = mTranslation(vec3(-.82, -4.86, -0), p5);\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmat3 mt = rotateMat(p6, .7854 + cos(iTime) * .5, vec3(0, 0, 1));\n\t\t\t\t\t\t\t\tvec3 p7 = mRotation(mt, p6);\n\t\t\t\t\t\t\t\td9 = pCapsule(.383695, 1.6905, p7);\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvec3 p8 = mTranslation(vec3(-0, -2.2, -0), p7);\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmat3 mt = rotateMat(p8, -.31416 + sin(iTime) * .4, vec3(0, 0, 1));\n\t\t\t\t\t\t\t\t\t\tvec3 p9 = mRotation(mt, p8);\n\t\t\t\t\t\t\t\t\t\td10 = pCapsule(.383695, 1.444452, p9);\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tvec3 p10 = mTranslation(vec3(-0, -1.99, -0), p9);\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvec3 p11 = mRotation(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p10);\n\t\t\t\t\t\t\t\t\t\t\t\td11 = pCapsule(.477884, .319634, p11);\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tvec3 p12 = mTranslation(vec3(-0, -.53, -0), p11);\n\t\t\t\t\t\t\t\t\t\t\t\t\t{ d12 = pCapsule(.147221, 1.13, mRotation(mat3(1, 0, -0, -0, .766045, .642788, 0, -.642788, .766045), p12)); }\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tvec3 p12 = mTranslation(vec3(-.09, -.51, -0), p11);\n\t\t\t\t\t\t\t\t\t\t\t\t\t{ d13 = pCapsule(.15, 1., mRotation(mat3(.866025, .5, -0, -.469846, .813798, .34202, .17101, -.296198, .939693), p12)); }\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tvec3 p12 = mTranslation(vec3(-.32, -.31, -0), p11);\n\t\t\t\t\t\t\t\t\t\t\t\t\t{ d14 = pCapsule(.15, .93, mRotation(mat3(.766045, .642788, 0, -.633022, .754407, .173648, .111619, -.133022, .984808), p12)); }\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tvec3 p12 = mTranslation(vec3(-.19, -.49, -0), p11);\n\t\t\t\t\t\t\t\t\t\t\t\t\t{ d15 = pCapsule(.15, .93, mRotation(mat3(.505883, -.862602, 0, .862602, .505883, -0, -0, 0, 1), p12)); }\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvec3 p2 = mMirror(vec3(-1, 0, 0), 0., p1);\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(-1.23772, -.467108, -4.0436), p2);\n\t\t\t\t{ d16 = pEllipsoid(vec3(.625824, .357147, .8914), mRotation(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p3)); }\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvec3 p2 = mTranslation(vec3(-0, .876456, -3.01572), p1);\n\t\t\t{ d17 = pEllipsoid(vec3(1.33164, 1.29976, .572888), mRotation(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p2)); }\n\t\t}\n\t\t{\n\t\t\tvec3 p2 = mMirror(vec3(-1, 0, 0), 0., p1);\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(-1.186, -.2179, -4.0436), p2);\n\t\t\t\t{ d18 = pEllipsoid(vec3(.4139, .357147, .66314), mRotation(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p3)); }\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvec3 p2 = mMirror(vec3(-1, 0, 0), 0., p1);\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(-1.23772, -.467108, -4.0436), p2);\n\t\t\t\t{ d19 = pEllipsoid(vec3(.39685, .357147, .507432), mRotation(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p3)); }\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvec3 p2 = mTranslation(vec3(-0, -.951508, -.05504), p1);\n\t\t\t{ d20 = pEllipsoid(vec3(1.72792, 1.4785, 2.16554), mRotation(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p2)); }\n\t\t}\n\t}\n\treturn oUnion(oSmoothSubtraction(.05, d1, d17), oUnion(oSmoothSubtraction(.05, d16, d18), oUnion(d19, oUnion(d20, oUnion(d5, oUnion(d4, oUnion(d3, oUnion(d2, oUnion(d6, oUnion(d8, oUnion(d7, oUnion(d12, oUnion(d11, oUnion(d10, oUnion(d9, oUnion(d13, oUnion(d14, d15)))))))))))))))));\n}\n\nvec3 calcNormal(vec3 pos) {\n\tconst vec2 e = vec2(1, -1) * 58e-5;\n\treturn normalize(e.xyy * sdf(pos + e.xyy) + e.yyx * sdf(pos + e.yyx) + e.yxy * sdf(pos + e.yxy) + e.xxx * sdf(pos + e.xxx));\n}\n\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 4; i++) {\n\t\taopos = pos + nor * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 pos = ro + t * rd;\n\t\tfloat h = sdf(pos);\n\t\tif (h < .001) break;\n\t\tt += h;\n\t\tif (t > 20.) break;\n\t}\n\n\tif (t > 20.) t = -1.;\n\treturn t;\n}\n\nvec3 env_color(vec3 dir) {\n\tif (dir.y > 0.) return mix(vec3(0, .5, 1), vec3(0, .1, .8), dir.y);\n\treturn mix(vec3(0, .5, 1), vec3(.8, .7, .6), pow(-dir.y, .5));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tfloat t,\n\t      fi = 10. * iMouse.x / iResolution.x,\n\t      th = 10. * iMouse.y / iResolution.y;\n\tvec3 ro = vec3(5. * cos(fi) * sin(th), 5. * sin(th) * sin(fi), 15. * cos(th)),\n\t     ww = normalize(vec3(0) - ro),\n\t     uu = normalize(cross(ww, vec3(0, 1, 0))),\n\t     rd = normalize(p.x * uu + p.y * normalize(cross(uu, ww)) + 1.5 * ww),\n\t     col = vec3(.25, .72, .75) - .005 * rd.y;\n\tt = castRay(ro, rd);\n\tif (t > 0.) {\n\t\tcol = vec3(0);\n\t\tvec3 pos = ro + t * rd,\n\t\t     nor = calcNormal(pos);\n\t\tfloat occ = calcOcclusion(pos, nor);\n\t\tvec3 sun_dir = normalize(vec3(.8, .4, .2));\n\t\tfloat sun_sha = step(castRay(pos + nor * .001, sun_dir), 0.),\n\t\t      sun_dif = clamp(dot(nor, sun_dir), 0., 1.),\n\t\t      sky_dif = clamp(.5 + .5 * dot(nor, vec3(0, 1, 0)), 0., 1.),\n\t\t      bou_dif = clamp(.5 + .5 * dot(nor, vec3(0, -1, 0)), 0., 1.);\n\t\tcol = vec3(.05, .4, .3) * vec3(7, 4.5, 3) * sun_dif * sun_sha;\n\t\tcol += vec3(.05, .4, .3) * vec3(.5, .8, .9) * sky_dif * occ;\n\t\tcol += vec3(.05, .4, .3) * vec3(.7, .3, .2) * bou_dif * occ;\n\t}\n\telse col = env_color(rd);\n\n\tfragColor = vec4(pow(col, vec3(.4545)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfXW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 308, 356, 356, 671], [673, 673, 715, 715, 767], [769, 769, 803, 803, 878], [880, 880, 929, 929, 959], [961, 961, 1004, 1004, 1031], [1033, 1033, 1080, 1080, 1139], [1141, 1141, 1175, 1175, 1197], [1199, 1199, 1254, 1254, 1351], [1353, 1353, 1373, 1373, 6483], [6485, 6485, 6512, 6512, 6677], [6679, 6679, 6720, 6720, 6894], [6896, 6896, 6929, 6929, 7120], [7122, 7122, 7148, 7148, 7283], [7285, 7285, 7337, 7337, 8500]], "test": "timedout"}
{"id": "7ljSRR", "name": "torus voronoi 2d", "author": "CyanMARgh", "description": "torus voronoi 2d", "tags": ["2d", "voronoi", "torus"], "likes": 0, "viewed": 37, "published": "Public", "date": "1626968162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct point {\n    vec2 p;\n    vec3 c;\n};\n\nfloat torusDist(vec2 a, vec2 b) {\n    a = abs(a - b);\n    return length(min(abs(a), abs(1. - a)));\n}\n\nconst int S = 8;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    uv = mod(uv, 1.);\n    point centers[S];\n    centers[0] = point(vec2(0., 0.), vec3(0., 0., 0.));\n    centers[1] = point(vec2(.7, .7), vec3(0., 0., 1.));\n    centers[2] = point(vec2(.3, .6), vec3(0., 1., 0.));\n    centers[3] = point(vec2(.2, .2 + .1*sin(iTime)), vec3(0., 1., 1.));\n    centers[4] = point(vec2(.2 + .1 * cos(iTime+1.), .4), vec3(1., 0., 0.));\n    centers[5] = point(vec2(.4, .4), vec3(1., 0., 1.));\n    centers[6] = point(vec2(.5, .3), vec3(1., 1., 0.));\n    centers[7] = point(vec2(.1, .5 + .3 * cos(iTime)), vec3(1., 1., 1.));\n    \n    \n    float md = 1e20;\n    vec3 col = vec3(1.);\n    for(int i = 0; i < S; i++) {\n        float d = torusDist(uv, centers[i].p);\n        if(d < md) {\n            md = d;\n            col = centers[i].c;\n        }\n    }\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 76, 76, 143], [162, 162, 217, 217, 1063]], "test": "valid"}
{"id": "7ljXzw", "name": "Improved Tesseract", "author": "xertrov", "description": "so far, the best method I've found to render 4d objects is to just sample the W axis multiple times.\nI tried 2-step ray marching too, i.e., ray march in Z then, at the minimum, ray march in W. That should be better but I had some issues w that method.", "tags": ["raymarching", "experiment", "4d", "learning", "hypercube"], "likes": 4, "viewed": 168, "published": "Public API", "date": "1627370783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define S(a, b, t)smoothstep(a, b, t)\n#define hh(x)(x * 0.5 + 0.5)\n#define zoth vec4(0.0, 1.0, 2.0, 0.5)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n#define GROW_SHRINK 0.3\n#define ROTATE_IDLE 0.2\n#define BASE_TWINKLE 99.0\n#define D4_DIST_MODULO (0.141421356 * 2.0)\n#define STAR_RARITY 0.95\n// set to 10k+ for a hyperspace bungee; curious noise patterns at 2000.\n#define BG_SCALE 100.0\n\nvec2 best2(vec3 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nvec3 best3(vec4 p) {\n  vec2 zw = vec2(max(p.z, p.w), min(p.z, p.w));\n  // p.z > p.w ? vec2(p.z, p.w) : vec2(p.w, p.z);\n  vec2 xy = vec2(max(p.x, p.y), min(p.x, p.y));\n  if (xy.y > zw.x) {return vec3(xy, zw.x);} // testme\n  if (zw.y > xy.x) {return vec3(zw, xy.x);}\n  return vec3(max(xy.x, zw.x), min(xy.x, zw.x), max(xy.y, zw.y));\n\n  /* tests\n  col = best2(zoth.xyz) == vec2(2., 1.) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.zywx) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxzy) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxyz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.xywz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  */\n}\n\nvec3 rainbow(vec2 uv, float time) {\n  return sin(vec3(time) + uv.xyx * vec3(1.0, 1.0, 1.0) + vec3(0, 2, 4)) * 0.49 + 0.5;\n}\n\n// from an art of code video I think\nfloat N21b(vec2 p) {\n  vec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n  a += dot(a, a.yzx + 79.76);\n  return fract((a.x + a.y) * a.z);\n}\n\nfloat sdBoxEdge(in vec3 p, in vec3 b) {\n  return length(best2(abs(p) - b));\n}\n\nfloat distTesseractEdge(in vec4 p, in vec4 b) {\n  vec4 d = abs(p) - b;\n  vec3 db = best3(d);\n  return length(db);\n}\n\nfloat sdBox(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.z, max(d.x, d.y)), 0.0);\n}\n\nfloat growShrink() {\n  return GROW_SHRINK * sin(u_time / 9.0 * PI) * 0.1 + 0.9;\n}\n\nconst vec2 e = vec2(0.0001, 0.0);\n\nfloat distFunc(in vec4 p) {\n  float grow_shrink = growShrink();\n  vec4 s = vec4(.8, .8, .8, .8) * grow_shrink;\n  float ed = distTesseractEdge(p, s) - 0.04;\n  return ed;\n}\n\nvec4 getIDGV(vec2 uv, float scale) {\n  vec2 id = floor(uv * scale);\n  vec2 gv = fract(uv * scale) - 0.5;\n  return vec4(id, gv);\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\n\nfloat mkNoise(vec2 uv, float t, float minDS) {\n  float scale = fwidth(uv.x) * 100.0 * BG_SCALE;\n  vec4 idgv = getIDGV(uv, scale);\n  vec2 id = idgv.xy;\n  vec2 gv = idgv.zw;\n  float n = N21b(id);\n  float transFreq = BASE_TWINKLE * n + 0.01;\n  t -= 3877.627 * n;\n  float transProgress = fract(t * transFreq);\n  float transId = floor(t * transFreq);\n  float lastIdOffset = N21b(vec2(n, transId - 1.0));\n  float idOffset = N21b(vec2(n, transId));\n  float nextIdOffset = N21b(vec2(n, transId + 1.0));\n  float noiseThresh = STAR_RARITY;\n  float noise = S(1.0, 0.0, transProgress) * S(noiseThresh, 1.0, N21b(id + lastIdOffset));\n  noise += S(noiseThresh, 1.0, N21b(id + idOffset));\n  noise += S(0.0, 1.0, transProgress) * S(noiseThresh, 1.0, N21b(id + nextIdOffset));\n  return S(0.0, 0.2, minOf(0.5 - abs(gv))) * (noise * S(0.1, 2.0, minDS));\n}\n\nmat4 rot4(float angle, int axis) {\n  float s = sin(angle), c = cos(angle);\n  mat4 r = mat4(\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  // XY, XZ, XW\n  return axis == 0 ? r\n    : axis == 1 ? mat4(r[0].xzyw, r[2].xzyw, r[1].xzyw, r[3].xzyw)\n    : axis == 2 ? mat4(r[0].xwzy, r[3].xwzy, r[2].xwzy, r[1].xwzy)\n    // YZ, YW\n    : axis == 3 ? mat4(r[3].wxyz, r[0].wxyz, r[1].wxyz, r[2].wxyz)\n    : axis == 4 ? mat4(r[3].wxzy, r[0].wxzy, r[1].wxzy, r[2].wxzy)\n    // ZW\n    : axis == 5 ? mat4(r[3].wzxy, r[2].wzxy, r[0].wzxy, r[1].wzxy) : mat4(0.);\n}\nvec2 sinCos(float a) {\n  return vec2(sin(a), cos(a));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (gl_FragCoord.xy - .5 * u_resolution.xy) / u_resolution.y;\n  vec2 mouse = (u_mouse.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  float t = u_time / 1.0;\n  vec3 col = BLACK;\n  uv *= 4.0;\n\n  float fw = max(fwidth(uv.x), fwidth(uv.y));\n\n  float grow_shrink = growShrink();\n  //GROW_SHRINK * sin(t * PI) * 0.1 + 0.9;\n\n  mat4 boxTrans = rot4(mouse.x * TAU / 2.0, 4) * rot4(mouse.y * TAU / 2.0 + .3, 1);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE + PI / 3.0 + .9, 0) * rot4(t * 13.0 / 11.0 * ROTATE_IDLE - 17.0 * PI / 7.0, 2);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE + PI - .2, 2) * rot4(t * 13.0 / 11.0 * ROTATE_IDLE - 12.0 * PI / 7.0 - .2, 3);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE + PI / 1.0, 4) * rot4(t * 9.0 / 11.0 * ROTATE_IDLE - 7.9 * PI / 7.0, 5);\n\n  // raymarch over the orthogonal scene\n  // vec2 sc = sinCos(vec2(t));\n  vec2 an = sinCos(12.0 + 0.5*t + 10.0*mouse.x);\n\n  vec4 ro = vec4(0.0, 0., - 2.0, 0.);\n  vec4 rd;\n\n  float fov = 1.3;\n  vec3 ta = vec3( 0.0, 0.0, 0.0 );\n  vec3 ww = normalize( ta - ro.xyz );\n  vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n  vec3 vv = normalize( cross(uu,ww));\n  rd = normalize(vec4(uv.x*uu + uv.y*vv + fov*ww, 0.));\n\n  float d = 0.0, dS = 999.0, minDS = 999.0;\n  float ed = 999.0, ed2 = ed;\n  float steps = 0.0;\n  vec4 p = ro;\n  for(int i = 0; i < 50; i ++ ) {\n    steps ++ ;\n    ed = 999.;\n    for (float w = -1.41; w < 1.41; w += .05) {\n      ed = min(ed, distFunc((vec4(p.xyz, p.w + w)) * boxTrans));\n    }\n    dS = ed;\n    minDS = min(minDS, dS);\n    p = p + dS * rd;\n    d += dS;\n    if (dS < 0.001 || d > 100.0)break;\n  }\n\n  vec3 RED = zoth.yxx * 0.3;\n\n  float noise = mkNoise(uv * grow_shrink, t, minDS);\n  col += noise;\n  col += S(0.01, 0.0, dS) * WHITE * (.5 + .5 * rainbow(uv, u_time + 2.0));\n  col += S(0.023, 0.005, minDS) * rainbow(uv, u_time + 2.0);\n\n  gl_FragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[555, 555, 575, 575, 731], [733, 733, 753, 753, 1510], [1512, 1512, 1547, 1547, 1635], [1637, 1674, 1694, 1694, 1826], [1828, 1828, 1867, 1867, 1905], [1907, 1907, 1954, 1954, 2022], [2024, 2024, 2059, 2059, 2150], [2152, 2152, 2172, 2172, 2233], [2270, 2270, 2297, 2297, 2440], [2442, 2442, 2478, 2478, 2571], [2573, 2573, 2594, 2594, 2620], [2622, 2622, 2668, 2668, 3458], [3460, 3460, 3494, 3494, 4032], [4033, 4033, 4055, 4055, 4088], [4091, 4091, 4146, 4146, 6035]], "test": "valid"}
{"id": "7llSRf", "name": "100%", "author": "geoffp", "description": "100% gif inspired. \nAlso i'm 100% sure there's a more efficient way's to code this", "tags": ["sdf", "text", "gif"], "likes": 1, "viewed": 51, "published": "Public", "date": "1626292579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotationMatrix(float angle)\n{\n\tangle *= 3.14159 / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat sdfBox(vec2 p, vec2 size)\n{\n    vec2 d = abs(p) - size;  \n\treturn length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdCircle( vec2 uv, float r )\n{\n    return length(uv) - r;\n}\n\nfloat one( vec2 uv)\n{\n    float f = sdfBox(uv + vec2(0.63,0), vec2(0.06, 0.18) );\n    float f1 = sdfBox(uv + vec2(0.68,-0.13), vec2(0.05, 0.05) );\n    return min(f,f1);\n}\n\nfloat zero( vec2 uv){\n    float d = sdCircle(uv / vec2(.96,1.0) + vec2(0.33,0.07), .20);\n    float d2 = sdCircle(uv / vec2(.80,1.0) + vec2(0.395,0.07), .10);\n    return -min(-d,d2);\n}\n\nfloat zpercent( vec2 uv){\n    float d = sdCircle( uv * vec2(1.3,1.) + vec2(0.45,-0.01), .095);\n    float d2 = sdCircle( uv * vec2(1.65,1.) + vec2(0.57,-0.01), .045);\n    return -min(-d,d2);\n}\n\nfloat barpercent( vec2 uv){\n    vec2 rotuv = uv*rotationMatrix( -50.0 );\n    return sdfBox( rotuv - vec2( 0.29, -0.475), vec2(.19,.03) ) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv-= vec2(0.0,0.05); \n \n    float x = min( zero(uv), one(uv + vec2(0.,0.06) ) );\n    x = min( x, zero(uv + vec2(-0.435,0.)) );\n    x = min( x, zpercent(uv + vec2(-.8,0.)) );\n    x = min( x, zpercent(uv + vec2(-1.006,0.175)) );\n    x = min( x, barpercent(uv) );\n    float textmask = sign( x );\n    \n    \n    float stripemask = 1.0-smoothstep(0.,.25,cos(75.0*x - iTime*3.5) ) ;\n    vec3 stripecol = mix( vec3(104,226,113), vec3( 77,182,90), uv.y+.5 )/255.;\n    \n    vec3 bgcol = mix( vec3(20,190,199), vec3(0,251,251), uv.y+.5 )/255.;\n    bgcol = mix( bgcol, stripecol, stripemask);\n    \n    vec3 col = mix( bgcol, vec3(1.), 1.-textmask);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.,.004,abs(x)) );\n    col = clamp( col, 0., 1.)* 1.-dot(uv,uv)*0.25;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llSRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 133], [135, 135, 168, 168, 259], [261, 261, 297, 297, 326], [328, 328, 349, 349, 498], [500, 500, 521, 521, 683], [685, 685, 710, 710, 876], [878, 878, 905, 905, 1018], [1020, 1020, 1077, 1077, 1952]], "test": "valid"}
{"id": "7llSWS", "name": "Iq's distance 2D from 3D", "author": "wildniklin", "description": "Useful for checking unnoticeable errors in 3D SDF's without raymarching. Individual frames are slices of planes from x and y facing z.", "tags": ["sdf", "iq", "sd"], "likes": 3, "viewed": 152, "published": "Public API", "date": "1626460695", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// https://www.iquilezles.org/www/index.htm\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nconst vec3 offset = vec3(0.0);\nconst vec3 scale = vec3(1.0);\nconst float scanSpeed = 0.125;\nconst float epsilon = 0.01;\n\nfloat sdCircle(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sd(vec3 p) {\n    return sdCircle(p, 0.5);\n}\n\nvec3 sdColor(float d) {\n    return mix((1.0 - (sign(d) * vec3(0.1, 0.4, 0.7))) * (1.0 - exp(-3.0 * abs(d))) * (0.8 + (0.2 * cos(150.0 * d))), vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.0, epsilon);\n    return normalize(vec3(\n        sd(p + e.yxx) - sd(p - e.yxx),\n        sd(p + e.xyx) - sd(p - e.xyx),\n        sd(p + e.xxy) - sd(p - e.xxy)\n    ));\n}\nvec2 closestPointLine(vec2 a, vec2 b, vec2 p) {\n    vec2 ab = b - a;\n    float dist = clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n    if(dist <= 0.0) return a;\n    if(dist >= 1.0) return b;\n    return mix(a, b, dist);\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    float tp = 1.0 / min(iResolution.x, iResolution.y);\n    \n\tvec2 vp = ((i * 2.0) - iResolution.xy) * tp;\n    vec2 vm = ((iMouse.xy * 2.0) - iResolution.xy) * tp;\n\n    float vz = ((fract(iTime * scanSpeed) * 2.0) - 1.0);\n    float z = vz * scale.z;\n    \n    vec3 p = vec3(vp * scale.xy, z) + offset;\n\n\tfloat d = sd(p);\n    \n    vec3 col = sdColor(d);\n\n    if(iMouse.z > 0.0) {\n        vec3 m = vec3(vm * scale.xy, z) + offset;\n        float md = sd(m);\n        vec3 n = normal(p);\n        vec3 c = (n * 0.5) + 0.5;\n        col = mix(c, col, smoothstep(-tp, tp, abs(length(p - m) - abs(md)) - tp));\n        col = mix(c, col, smoothstep(-tp, tp, abs(length(p.xy - closestPointLine(m.xy, m.xy - n.xy * md, p.xy))) - tp));\n    }\n    \n    if((vp.y < -0.97) && (vp.x < 1.0) && (vp.x > -1.0)) col = mix(col, step(vp.x, vz) * sdColor(vp.x * scale.z), 0.5);\n\n\to = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llSWS.jpg", "access": "shaders20k", "license": "mit", "functions": [[1319, 1319, 1352, 1352, 1380], [1382, 1382, 1400, 1400, 1431], [1433, 1433, 1456, 1456, 1625], [1627, 1627, 1648, 1648, 1834], [1835, 1835, 1882, 1882, 2057], [2059, 2059, 2095, 2095, 2969]], "test": "valid"}
{"id": "7llXR4", "name": "broken glass worley", "author": "ejosiah", "description": "worley noise generated using difference between 1st and 2nd order distance", "tags": ["worley", "glass", "cellnoise", "broken"], "likes": 2, "viewed": 65, "published": "Public", "date": "1625267112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323\n\nvec2 grid[9] = vec2[](\n    vec2(-1, -1),\n    vec2(0, -1),\n    vec2(1, - 1),\n    vec2(-1, 0),\n    vec2(0, 0),\n    vec2(1, 0),\n    vec2(-1, 1),\n    vec2(0, 1),\n    vec2(1, 1)\n);\n\nvoid sort(inout float array[9]){\n    for(int i = 1; i < 9; i++){\n        for(int j = 0; j < 9 - i; j++){\n            if(array[j] > array[j + 1]){\n                float temp = array[j];\n                array[j] = array[j+1];\n                array[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 10.0;\n    vec2 f = fract(uv);\n    vec2 uv_i = floor(uv);\n    \n   float distances[9]; \n   for(int i = 0; i < 9; i++){\n       vec2 p = hash22(uv_i + grid[i]);\n       p = 0.5 + 0.5 * sin(2.0 * PI * p + iTime);\n       vec2 dist = f - (p + grid[i]);\n       float d = distance(f, p + grid[i]); \n     // float d = abs(dist.x) + abs(dist.y);  \n       distances[i] = d;\n   }\n    sort(distances);\n    float d = distances[1] - distances[0];\n\n    vec3 col = vec3(d);\n   // col.r += step(0.99, f.x) + step(0.99, f.y);\n    col += 1.0 - step(0.01, d);\n\n    // Output to screen\n    fragColor = vec4( col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 241, 241, 501], [503, 503, 524, 524, 658], [660, 660, 717, 717, 1363]], "test": "valid"}
{"id": "7llXWj", "name": "Onion Sphere", "author": "kithy", "description": "based on iq's onion function\nhttps://www.shadertoy.com/view/MlcBDj", "tags": ["raymarching", "sphere", "onion"], "likes": 0, "viewed": 67, "published": "Public", "date": "1626615577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.001\n#define MAX_STEPS 64\n\nmat2 rot(float angle){\n\tfloat s=sin(angle);\n\tfloat c=cos(angle);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat onion(in float d,in float h){\n\treturn abs(d)-h;\n}\n\nfloat sdSphere(vec3 p){\n\treturn length(p)-0.2;\n}\n\nfloat map(vec3 p){\n\tfloat d;\n\tp.xz*=rot(iTime);\n\tp.xy*=rot(-iTime);\n\n\t//sphere\t\n\tfloat s=sdSphere(p);\n\t\n\t//onion\n\tfloat o=onion(s,0.5);\t\n\tfloat o2=onion(o,0.3);\t\n\tfloat o3=onion(o2,0.15);\n\td=min(s,onion(o3,0.05));\n\n\t//cut\n\td=max(d,p.y);\n\n\treturn d;\n}\n\nvec3 calcNormal(vec3 p){\n\tfloat d=map(p);\n\treturn normalize(vec3(\n\t\tmap(p+vec3(EPS,0.0,0.0))-d,\n\t\tmap(p+vec3(0.0,EPS,0.0))-d,\n\t\tmap(p+vec3(0.0,0.0,EPS))-d\n\t));\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(0.0,0.0,2.0);\n\tvec3 rd=normalize(vec3(p,-1.0));\n\n\tfloat d,t=0.0;\n\tvec3 rp,n;\n\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\trp=ro+rd*t;\n\t\td=map(rp);\n\t\tif(d<0.001)break;\n\t\tt+=d;\n\t}\n\n\tn=calcNormal(rp);\n\n\tfragColor=vec4(n,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 62, 62, 130], [132, 132, 167, 167, 187], [189, 189, 212, 212, 237], [239, 239, 257, 257, 489], [491, 491, 515, 515, 652], [655, 655, 708, 708, 994]], "test": "valid"}
{"id": "7lSSRw", "name": "Wave Funct Viz", "author": "MarcFly", "description": "Stemming from a tweet by @pixelsnafuy https://twitter.com/pixelsnafu/status/1419580211591516160?s=20.\nIt's been a couple years since I studied or learned about wave functions and things, so I tried making this as a visualization challenge.\n\nThe ", "tags": ["visualization", "illusion", "sine"], "likes": 8, "viewed": 38, "published": "Public", "date": "1627297051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float k = 50.;\nfloat w = 1.;\nfloat A = .05;\n\nfloat freq1 = 1.62;\nfloat freq2 = 1.6;\n\nfloat pi = acos(-1.);\n\n#define PI 3.14159265358979323846\nfloat shift1 = 0.;\nfloat shift2 = PI/.9;\n\nfloat dist = .02;\n\nfloat wave(in vec2 pos, float height, float time)\n{\n    return  height * sin(w*time + k*pos.x) - pos.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n\n    vec2 norm_vec = vec2(pi, 1.);\n    vec2 wave1_pos = uv + vec2(0., -.75);\n    float wave1 = wave(wave1_pos * norm_vec*freq1, A, shift1);\n    float abs_wave1 = float(abs(wave1) < dist);\n    \n    vec2 wave2_pos = uv + vec2(0., -.25);\n    float wave2 = wave(wave2_pos * norm_vec*freq2, A, shift2);\n    float abs_wave2 = float(abs(wave2) < dist);\n    \n    col -= vec3(0, abs_wave1, abs_wave1);\n    col -= vec3(0, abs_wave2,abs_wave2);\n    \n    uv.x -= fract(iTime/10.); //mod(iTime/10., 2.);\n    \n    if(fract(uv.x) <= .43)\n        col -= vec3(1. - ceil(sin(200.*uv.x - 5.)-.9));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSSRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 254, 254, 308], [311, 311, 368, 418, 1158]], "test": "valid"}
{"id": "7lsSWn", "name": "Diffraction Patterns", "author": "diabolix17", "description": "Diffraction patterns of N equally spaced oscillators along the horizontal midline. Peaks (positive amplitude) are red and troughs (negative amplitude) are green. Click to compare with a formula for the intensity derived by Feynman.", "tags": ["waves", "diffraction"], "likes": 5, "viewed": 73, "published": "Public", "date": "1625496021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 5\n#define ZOOM 1.0\n#define OSCILLATOR_SPAN (1.0 / ZOOM)\n#define FREQ -3.0\n#define ALPHA 3.1415926 // phase difference between oscillators\n#define WAVELEN (0.03 / ZOOM)\n#define PI 3.1415926\n#define PLOT_INTENSITY false\n#define SHOW_OSCILLATORS false\n#define OSCILLATOR_RADIUS 0.01\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec2 pixel_position = fragCoord/iResolution.y;\n    \n    if(iMouse.z > 0.0){\n    \n        // Feynman intensity approximation from his lecture (https://www.feynmanlectures.caltech.edu/I_30.html)\n        // works in the limit as the distance goes to infinity, which can be verified here (e.g. set ZOOM to 100.0)\n        vec2 dir = pixel_position - vec2(aspect_ratio*0.5, 0.5);\n        dir /= length(dir);\n        float angle = acos(dir.y);\n        float phase_diff = ALPHA + 2.0*PI*OSCILLATOR_SPAN/float(N-1)*sin(angle)/WAVELEN;\n        float intensity = sin(float(N) * phase_diff / 2.0) / (sin(phase_diff / 2.0) * float(N));\n        intensity *= intensity;\n        fragColor = vec4(vec3(intensity), 1.0);\n    \n    } else {\n    \n        //float wave_amplitude = 0.5*(cos(iTime + pixel_position.y*10.0) + cos(iTime + pixel_position.x*10.0));\n    \n        float wave_amplitude = 0.0;\n    \n        if(N == 1){\n            float dist = length(pixel_position - vec2(0.5*aspect_ratio, 0.5));\n            wave_amplitude = cos(iTime * FREQ + dist/WAVELEN * 2.0 * PI);\n        } else {\n            for(int i = 0; i < N; i++){\n                vec2 oscillator_position = vec2(0.5*aspect_ratio -OSCILLATOR_SPAN/2.0 + float(i) * OSCILLATOR_SPAN / float(N-1), 0.5);\n                float dist = length(pixel_position - oscillator_position);\n                if(SHOW_OSCILLATORS && dist < OSCILLATOR_RADIUS){\n                    fragColor = texture(iChannel0, (pixel_position-oscillator_position + vec2(OSCILLATOR_RADIUS)) / (2.0*OSCILLATOR_RADIUS));\n                    return;\n                }\n                wave_amplitude += cos(iTime * FREQ + float(i)*ALPHA + dist / WAVELEN * 2.0 * PI);\n            }\n            \n        }\n        \n        wave_amplitude /= float(N);\n    \n        if(PLOT_INTENSITY){\n            float intensity = wave_amplitude * wave_amplitude;\n            fragColor = vec4(vec3(intensity), 1.0);\n        } else {\n            float r = (wave_amplitude > 0.0) ? wave_amplitude : 0.0;\n            float g = (wave_amplitude < 0.0) ? -wave_amplitude : 0.0;\n            fragColor = vec4(r,g,0.0,1.0);\n        }\n    }\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 292, 349, 349, 2537]], "test": "error"}
{"id": "7lsSz2", "name": "Fire ball", "author": "Vinicius_Jesus", "description": "simple flame shape", "tags": ["fire", "flames"], "likes": 8, "viewed": 139, "published": "Public", "date": "1626145600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FLAMECOLOR vec3(50.0, 5.0, 1.0)\n#define PI 3.14159\n\nfloat FlameShape(vec2 uv) {\n    /*play with these values\n\n    try:\n        float flameControl1 = 4.5;\n        float flameControl2 = .5;\n    */\n    float flameControl1 = 5.;\n    float flameControl2 = 1.5;\n    \n    float a = mod(atan(uv.x,uv.y+2.),PI*2. )/flameControl1-PI/flameControl1;\n    float angle = PI-(.5+.25);\n    float d = length(uv-vec2(0., -2.)) * sin(angle+abs(a));\n    return smoothstep(0., flameControl2, d);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat R21 (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(2.3245,5.234)))*123.5632145);\n}\n\nfloat NoiseValue (vec2 uv) {\n    vec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    \n    gv = gv * gv * (3. - 2. * gv);\n\n    float a = R21(id);\n    float b = R21(id + vec2(1., 0.));\n    float c = R21(id + vec2(0., 1.));\n    float d = R21(id + vec2(1., 1.));\n\n    return mix(a, b, gv.x) + (c - a)* gv.y * (1. - gv.x) + (d - b) * gv.x * gv.y;\n}\n\nfloat SmoothNoise (vec2 uv) {\n    float value = 0.;\n    float amplitude = .5;\n\n    for (int i = 0; i < 8; i++) {\n        value += NoiseValue(uv) * amplitude;\n        uv *= 2.;\n        amplitude *= .5;\n    }\n\n    return value;\n}\n\nvec3 Flame(vec2 uv) {\n    uv *= 6.;\n    \n    vec3 col = vec3(0.);\n    float shape = FlameShape(uv);//smoothstep(0., 6.5, abs(uv.x)+abs(uv.y));\n\n    uv *= Rot(2.5);\n    \n    vec2 rn = vec2(0.);\n    rn.x = SmoothNoise(uv + 1.984 + 4.5*iTime);\n    rn.y = SmoothNoise(uv + 1. + 4.5*iTime);\n    \n    col += SmoothNoise(uv+rn*2.5);\n    col -= shape;\n    \n    col = col / (1.5+col);\n    col = pow(col, vec3(3./2.2));\n    \n    //background white\n    //col = clamp(col, 0., 1.);\n    \n    col *= FLAMECOLOR;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = Flame(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsSz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 87, 202, 483], [485, 485, 504, 504, 566], [568, 568, 588, 588, 656], [658, 658, 686, 686, 999], [1001, 1001, 1030, 1030, 1228], [1230, 1230, 1251, 1251, 1750], [1752, 1752, 1809, 1809, 1933]], "test": "valid"}
{"id": "7lsSz8", "name": "Dr Greeble's spawn filter", "author": "evvvvil", "description": "Dr Greeble's spawn filter - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_\n", "tags": ["displacement", "demoscene", "glow", "blend", "material", "control", "greeble", "shrine", "detail", "birth", "contraception"], "likes": 18, "viewed": 410, "published": "Public", "date": "1625161570", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Dr Greeble's spawn filter - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"Gimme a clamp and a sin, son, and watch how it's done, yeah?\" - Dr Greeble\n\nvec2 z,v,e=vec2(.00035,-.00035);float t,tt,bb,g,gg,r=0.;vec3 np,bp,pp,po,no,al,ld,lp,op,cp,rd;\nfloat smin(float a,float b,float k){  float h=max(0.,k-abs(a-b));return min(a,b)-h*h*.25/k;}\nfloat smax(float a,float b,float k){  float h=max(0.,k-abs(-a-b));return max(-a,b)+h*h*.25/k;}\nvec2 smin( vec2 a, vec2 b,float k ){ float h=clamp(.5+.5*(b.x-a.x)/k,.0,1.);return mix(b,a,h)-k*h*(1.0-h);}\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nfloat cz(vec3 p,vec3 r){return max(abs(length(p.xy)-r.x)-r.y,abs(p.z)-r.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nconst mat2 deg45=mat2(0.70738827,0.706825,-0.706825,0.70738827);\nvec2 mp( vec3 p,float ga )\n{ \n  op=pp=p;   \n  pp=abs(pp)-vec3(0,0,3.5-cos(p.y*.2)*2.); // SPLINES POS  \n  pp.xy*=r2(-.785);  \n  float tn=texNoise(op.xz*.03,iChannel0).r; //Tex noise sample\n  r=1.0; vec4 np=vec4(pp,1);\n  for(int i=0;i<4;i++){ //Greeble Displacement KIFS\n    np.x=abs(np.x)-1.4;\n    np.xy*=deg45;\n    np*=2.;\n    r=min(r,clamp(sin(np.y)*sin(np.x*3.),-.3,.3)/np.w);\n  }\n  r/=2.;\n  vec2 h,t=vec2(.8*(length(pp.xz)-.2+r),0);  // SPLINES\n  vec3 sp=pp;//sp.xz*=r2(cos(sp.y)*.3+tt);\n  sp.xz=abs(sp.xz)-.4-cos(sp.y*.5)*.5-sp.y*.05;\n  vec3 pinch=cos(p*2.5)*.2; \n  t.x=smin(t.x,.6*(length(p)-3.+pinch.x+pinch.y+r),.5); //SYNAPSE SPHERE\n  t.x=smin(t.x,.7*(cz(p,vec3(4.+(pinch.x+pinch.y)*.5,.15,.2))),1.3); //SYNAPSE CYL  \n  t.x=smax((length(p.xy)-1.-r)*.8,t.x,.5);\n  float synapse=t.x-.2; //BLACK SYNAPSE     \n  h=vec2(synapse,1);\n  h.x=max(h.x,.7*abs(abs(abs(pp.y-4.9)-1.5-r)-1.5)-.5);   //CUT BLACK OUTTER  \n  h.x=smin(h.x,max(.7*(cz(p,vec3(3.2,1.5-r,.2-r))),-(abs(p.z)-.2)),.5); //BLACK CYL AROUND  \n  h.x=smin(h.x,max(.7*(length(sp.xz)-.15-r),-(abs(sp.y)-1.7)),.2); //SMALLER SPLINES\n  h.x=min(h.x,bo(abs(op)-11.-r,vec3(1,100,2))); //OUTTER BOXES\n  vec3 rp=op+vec3(0,5,0);rp.x=abs(rp.x)-17.;\n  h.x=min(h.x,bo(rp-r,vec3(1,7,2))); //OUTTER BOXES\n  h.x=smin(h.x,(op.y+7.+tn*2.+r)*.6,.5); //TERRAIN  \n  pp=p*.5; pp.y-=tt;                    //PARTICLES\n  bb=cos(clamp(op.y*.9-.9+tn*3.,-10.,1.));\n  pp.xz*=r2(bb*.7);  \n  float bro=max((.7-abs(bb)*.5)*(length(sin(pp))+clamp(p.y-1.,0.,2.)*.05),length(p.xz)-10.);\n  gg+=0.1/(0.1*bro*bro*(2000.-1940.*bb))*ga;   \n  t=smin(t,h,.1);    \n  float cylglo=max(length(p.xy)-4.7,abs(p.z)-.05); //GLOW CYL AROUND    \n  v=sin((p.xy-tt*vec2(-1,.5))*15.)*0.03;\n  vec3 ep=abs(p)-vec3(1.7-cos(p.y*.5-2.5)-v.x+v.y,0.,0.); //VERTICAL GLOW LINES POS\n  ep.x=abs(ep.x)-.3;\n  cylglo=min(cylglo,0.7*length(ep.xz));   //VERTICAL GLOW LINES\n  gg+=0.1/(0.1*cylglo*cylglo*200.)*ga*max(0.,1.-p.y*.1);  //GLOW VERTICAL LINES + CYL GLO\n  h=vec2(cylglo,6);  \n  h.x=smin(h.x,bro,.4); //PARTICLES ADDED AT END\n  t=t.x<h.x?t:h; \n  return t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x,1.);\n    if(h.x<.0001||t.x>30.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>30.) t.y=-1.;\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); \n  tt=7.86+mod(iTime,62.82);\n  vec3 ro=mix(vec3(cos(tt*.1)*10.,cos(tt*.2)*5.,sin(tt*.1)*10.),\n          vec3(cos(tt*.4)*5.,-3,cos(tt*.2)*10.),ceil(sin(tt*.4))),\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;  \n  co=fo=clamp(vec3(.1,.12,.13)-length(uv)*.12-rd.y*.1,0.,1.);\n  z=tr(ro,rd);t=z.x;\n  if(z.y>-1.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(e.xyy+po,0.).x+e.yyx*mp(e.yyx+po,0.).x+e.yxy*mp(e.yxy+po,0.).x+e.xxx*mp(e.xxx+po,0.).x);\n    al=clamp(mix(mix(vec3(.4,.6,.8),vec3(1,1,1),abs(r*20.)-1.5),vec3(-1)-sin(r*50.)*2.,z.y),0.,1.);\n    if(z.y>5.) al=vec3(1);    \n    lp=ro; ld=normalize(lp-po);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.),   \n    attn=1.-pow(min(1.,length(lp-po)/15.),4.0),\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.);\n    co=attn*mix(.5*sp+al*(a(.15)*a(.3)+.2)*(dif+s(1.)*.5),fo,fr);    \n    co=mix(fo,co,exp(-.0001*t*t*t));\n  }\t\n  fragColor = vec4(pow(co+g*.2+gg*.2*vec3(.1,.2,.7),vec3(.55)),1);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsSz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[372, 372, 408, 408, 464], [465, 465, 501, 501, 559], [560, 560, 596, 596, 667], [668, 668, 692, 692, 733], [734, 734, 758, 758, 810], [811, 811, 828, 828, 871], [872, 872, 910, 910, 1204], [1270, 1270, 1298, 1298, 3331], [3332, 3332, 3360, 3360, 3527], [3623, 3623, 3680, 3680, 4803]], "test": "error"}
{"id": "7lsXR2", "name": "XOR Towers in Fog & Rain", "author": "GregRostami", "description": "Another variation of KilledByAPixel's Voxel Fractal:\n[url]https://www.shadertoy.com/view/NlB3Rz[/url]\nRain code from P_Malin's SmallStars\n[url]https://www.shadertoy.com/view/Ml2XDt[/url]", "tags": ["3d", "voxel", "fog", "city", "lights", "short"], "likes": 11, "viewed": 293, "published": "Public API", "date": "1626119791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Added rain code from P_Malin\n// You can toggle features by placing a comment \"//\" in front of each line that has a \"*\" in comments.\nvoid mainImage(out vec4 o, vec2 u)\n{ \n    ivec4 b = ivec4(o -= o);                   // Initialize b=0\n     vec2 R = iResolution.xy;\n    float t = .1*iTime, B, h, z;\n            \n    u =\n        (2. + cos(t)) *                        // * Camera push in/out \n        (u+u-R)/R.y                            //   Center coordinates\n        * mat2( cos( vec4(0,33,55,0) - .1*t))  // * Rotate camera\n        ;\n            \n    for ( z = (h = cos(B = ceil(atan(u.x, u.y) * 2e2))) / dot(u,u); //Variables for Rain\n          (b.x^b.y^b.z)%99 > b.z-8 ; )         // The XOR function for towers!!\n          b = ivec4(u * o.a + 2e2\n                + vec2(7,30)*t                 // * Move camera (x,y)\n                , o+=.1 );                     // Increment layer\n                \n    o =\n        o.a < 8.1 ? .1+sin(t/.1)*vec4(b%32 & b.x%9 & b.z%9) :  // * Blinking lights\n        o/70. - .02 *                                          // * Distance fog\n        vec4(b%3)                                              // * building colors\n        + .06 * texture( iChannel1, .02*u - .03*t ).r          // * Moving fog\n        + .01 * max(exp(fract(h * B - z + t+t) * -1e2) / z,0.) // * Rain\n        ;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4tsSDS", "previewfilepath": "https://soundcloud.com/appy-the-gm/blade-runner-blues-vangelis-hd", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/appy-the-gm/blade-runner-blues-vangelis-hd", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsXR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 135, 171, 171, 1330]], "test": "error"}
{"id": "7lsXWl", "name": "Terraforming Survey ", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 4, "viewed": 221, "published": "Public API", "date": "1626863848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ANY and ALL adulation belongs to IQ, and his new sphere noise.\n// read about it here: https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\n// see it in action in his shadertoy here: https://www.shadertoy.com/view/3dGSWR\n\nfloat rnd ( float t ) {\n  return fract( sin(t * 1841.63623 + 2714.23423));\n\n}\nvec2 unit ( float t ) {\n  float a =  fract( sin(t * 1841.63623 + 2714.23423))* 324.114;\n  float x = cos(a);\n  float y = sin(a);\n  return vec2(x,y);\n\n}\nfloat box (vec3 p, vec3 s) {\n  p = abs(p) -s ;\n  return max(p.x,max(p.y,p.z));\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nvec2 repeat(vec2 p, vec2 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nfloat repeat(float p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n} \nfloat sph(vec3 p, float r){\n  return length(p) - r;\n}\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.7*w*w;\n    // distance to sphere at grid vertex i+c\n    return length(f-c) - r; \n}\n\n// NuSan's improvement\nfloat sdBase(in vec3 p) {\nreturn length(fract(p)-0.5)-(0.3+dot(sin(p*vec3(2.21,1.13,1.7)),vec3(.2)));\n}\n/*\nfloat sdBase( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}\n*/\nfloat tick( float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  \n  for ( int n = 0; n < 4; n++) {\n    r = smoothstep(0.,1.,r);\n  }\n  return i + r;\n}\nvec2 sdFbm( in vec3 p, in float th, in float d )\n{\n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.00,  1.60,  1.20,\n                        -1.60,  0.72, -0.96,\n                        -1.20, -0.96,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    const int ioct = 11;\n    for( int i=0; i<ioct; i++ )\n    {\n        if( d>s*0.866 ) break; // early exit\n        if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        float porous = mix(0.02,0.2,sin(iTime/10.)*.5+0.5);  // default 0.1;\n        float y = 0.3;//(sin(iTime/24.) * 0.5 + 0.5) * .3 + .1;\n        n = smax(n,d-porous*s,y*s); // default 0.3\n        d = smin(n,d      ,y*s);    // default 0.3\n        q = m*q;\n        s = 0.415*s;\n     \n        t += d; \n        q.z += -4.33*t*s; // deform things a bit\n    }\n    return vec2( d, t );\n}    \n\n\n\n\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<11; i++ )\n    {\n        float n = texture(iChannel1,p).x;\n        f += s*n;\n        p *= 2.01*mat2(4.0,-3.0,3.0,4.0)/5.0;\n        s *= 0.55;\n    }\n    return f;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, cos(cr),sin(cr));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//=========================================\n\nconst float precis = 0.0005;  // default 0.0005\n\nfloat cyl(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\nvec2 off ( vec3 p) {\n  return vec2(sin(p.x/3.0), cos(p.y/4.1));\n}\nfloat layer (vec3 p, float r ) {\n  return length(p) -r ;\n}\nvec3 ro;\nvec3 ta;\nvec2 map( in vec3 p, in float dis )\n{\n    \n   \n    float spot = sph(p - ro   - vec3(0,0,2), .01); \n    \n    p.y *= .5; // default 1.0\n    // ground\n    float d = length(p-vec3(0.0,-250.0,0.0))-250.0;\n    d = p.y;\n    // terrain\n    vec2 dt = sdFbm( p, dis*precis, d );\n   \n    //float hole = box(p - ro, vec3(1.));\n    //dt.x = max(dt.x, -hole);\n    dt.x = min(dt.x, spot);\n    return dt;\n}\n\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis*t;\n    return normalize( e.xyy*map( pos + e.xyy, t ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, t ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, t ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, t ).x );\n}\n\n\n\nmat2 rot ( float a ) {\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca, sa, -sa, ca);\n}\nvec3 jump( float t ) {\n  float sc = 4.;\n  float y = sin(iTime);\n  vec2 a = unit(floor(t)) *sc *y;;\n  vec2 b = unit(floor(t)+1.)*sc*y;\n  \n  float height = 5.6 + sin(iTime);\n  return ( mix( vec3(a.x, height,a.y), vec3(b.x,height,b.y), fract(t)));  \n\n}\n\nvec2 offset (float t ) {\n  \n  t /= 1.;\n  float a = cos(t) + cos(t*2.1)/2.3 + cos(t*4.2)/ 4.1;\n  float b = cos(t*1.1) + cos(t*1.9)/1.7 + cos(t*4.)/ 3.6;\n \n  \n \n  return vec2(a,b)/10.;\n\n}\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist,1.).x*3.0,0.0,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n \n    vec2 p = (2.0*(fragCoord)-iResolution.xy)/ iResolution.y;\n\n       \n    float time = iTime * 1.3;\n\n\t// scene setup\n  \n    float cr, fl, fad;\n    \n  \n    float n = time;\n   \n \n    float tt = time * .43;\n    \n \n    vec3 pole = vec3( cos(tt), 0., sin(-tt) )* 1.2;\n   \n    ro = vec3(offset(n), tt);\n    ta = vec3(offset(n+1.), tt +2.*sin(iTime/4.1));\n    ro.y +=.5;\n    ro += pole;\n    ta += pole;\n    \n    \n   \n    \n\n    \n    // camera matrix\t\n    mat3 ca = setCamera( ro, ta, cr );\n    \n    vec3 rd = ca * normalize( vec3(p.xy,2.0));\n    \n   \n\n\n  \n\n    // raymarch\n    float t = 0.;\n    vec2 h = vec2(0.0,0.0);\n    bool hit = false;\n    vec3 pos;\n    float dd;\n    float i;\n\tfor( i=0.; i<300.; i++ )\n\t{\n        pos = ro + t*rd;\n        float flip = sign(map(pos,t).x);\n\t\th = map( pos, t )*flip;\n        if( abs(h.x)<.0001) {//(precis*t)) {\n          \n          hit = true;\n          break;\n        }\n       if (t>300.0 ) {\n          break;\n       }\n\t   t += h.x   * 1.; // overstepping\n       dd += t;\n\t}\n   \n\t\n   \n    vec3 nor = calcNormal( pos, t );\n    vec3 light = normalize(vec3(1,0,3));\n    light.xz *= rot(iTime*.31);\n    \n    float shade = dot(nor,light) + .45; \n    float ao = pow(1. - i/300.,8.);\n    \n    float spec= pow(max(dot(reflect(light,nor),-rd),.0), 17.);\n    //float sss = getsss(ro,rd,1.2);\n    vec3 col = vec3(1.,.5,.3);\n    col *= pow(shade,1.2);\n    col *= pow(ao,1.2) ;\n    //col += spec  ;\n    //col *= sss * 20.;\n    \n    float spot = length(pos - ((ro + vec3(0.,0.,2.))  ));\n    \n    \n    col += .001/pow(spot,10.) * vec3(.6,.5,1);\n   \n  \n    \n    if (! hit) {\n      col = vec3(.9,.2,.1) * rd.y/.4; \n    }\n    \n    // fog\n    col = mix(col, vec3(.3), i/2000.);\n  \n  \n   \n    col = pow(col,vec3(.35));\n    \n  \n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 248, 248, 302], [303, 303, 326, 326, 453], [454, 454, 482, 482, 534], [536, 536, 565, 565, 600], [602, 602, 631, 631, 666], [668, 668, 700, 700, 735], [738, 738, 779, 779, 851], [854, 854, 895, 895, 967], [969, 969, 996, 996, 1022], [1023, 1023, 1060, 1201, 1416], [1418, 1441, 1466, 1466, 1544], [1545, 1994, 2017, 2017, 2148], [2149, 2149, 2199, 2235, 2996], [3005, 3005, 3029, 3029, 3250], [3252, 3252, 3304, 3304, 3481], [3577, 3577, 3605, 3605, 3631], [3634, 3634, 3654, 3654, 3699], [3700, 3700, 3732, 3732, 3758], [3777, 3777, 3814, 3814, 4167], [4170, 4170, 4214, 4214, 4436], [4440, 4440, 4462, 4462, 4538], [4539, 4539, 4561, 4561, 4788], [4790, 4790, 4814, 4814, 4975], [4977, 4977, 5019, 5019, 5069], [5072, 5072, 5129, 5129, 6915]], "test": "error"}
{"id": "7lXSR7", "name": "spectral renderer attempt", "author": "incription", "description": "i didnt really research anything for this but you can see my approach I tried, im not sure how to do it properly, if anyone can provide some pointers that would be great", "tags": ["raytracing", "spectral"], "likes": 2, "viewed": 76, "published": "Public", "date": "1625335305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define W_Min 1e-6\n#define W_Max 4e-6\n#define W_Count 20\n#define slices 10.0\n\nfloat SURF_DIST;\n\n//From https://www.shadertoy.com/view/WddczH, thx\nvec3 nm_xyz(int i)\n{\n    switch(i)\n    {\n     \tcase 0:\n        \treturn vec3(0.001368, \t0.000039,\t0.00645);\t//380nm\n        case 1:\n        \treturn vec3(0.13438,\t0.004,\t\t0.6456); \t//420\n        case 2:\n        \treturn vec3(0.2908,\t\t0.06,\t\t1.6692); \t//460\n        case 3:\n        \treturn vec3(0.0049,\t\t0.323,\t\t0.272); \t//500\n        case 4:\n        \treturn vec3(0.2904,\t\t0.954,\t\t0.0203); \t//540\n        case 5:\n        \treturn vec3(0.9163,\t\t0.87,\t\t0.00165); \t//580\n        case 6:\n        \treturn vec3(0.85445,\t0.381,\t\t0.00019); \t//620\n        case 7:\n        \treturn vec3(0.1649,\t\t0.061,\t\t0); \t\t//660\n        case 8:\n        \treturn vec3(0.002899,\t0.001047,\t0); \t\t//720\n        case 9:\n        \treturn vec3(0.000166,\t0.00006,\t0); \t\t//760\n        default:\n        \treturn vec3(0.0);\n    }\n}\n\nvec3 xyz_to_sRGB(vec3 xyz)\n{\n    //assuming xyz coded relative to D65\n\n    //XYZ-to-sRGB conversion matrix (taken from another site)\n    mat3x3 conv_matrix = mat3x3(\t3.2404542f, -1.5371385f, -0.4985314f,\n     \t\t\t\t\t\t\t\t-0.9692660f, 1.8760108f, 0.0415560f,\n     \t\t\t\t\t\t\t\t0.0556434f,  - 0.2040259f, 1.0572252f);\n\n    vec3 ret = xyz * conv_matrix;\n\n    //companding for gamma?\n    //nah\n\n    //companding..? for sRGB\n    ret.x = ret.x <= 0.0031308f ? (12.92f * ret.x) : (1.055f * pow(ret.x, 1.0f / 2.4f) - 0.055f);\n    ret.y = ret.y <= 0.0031308f ? (12.92f * ret.y) : (1.055f * pow(ret.y, 1.0f / 2.4f) - 0.055f);\n    ret.z = ret.z <= 0.0031308f ? (12.92f * ret.z) : (1.055f * pow(ret.z, 1.0f / 2.4f) - 0.055f);\n    //\n\n    ret.x = clamp(ret.x,0.0,1.0);\n    ret.y = clamp(ret.y,0.0,1.0);\n    ret.z = clamp(ret.z,0.0,1.0);\n\n    return ret;\n}\n\nvec3 xyz_to_srgb_lerped(float nm)\n{\n    int i = int(floor((nm - 380.0) / (400.0 / slices)));\n    \n    return mix(xyz_to_sRGB(nm_xyz(i)), xyz_to_sRGB(nm_xyz(i+1)), mod(nm-380.0,(400.0 / slices)) /40.0);\n}\n\nvec3 wToRgb(float w) {\n    return xyz_to_srgb_lerped(w * 1e7);\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opTwist(vec3 p )\n{\n    float k = iTime; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat GetDist(vec3 p) {\n\tvec3 s = vec3(0, 1, 6);\n    \n    float sphereDist = sdBox(opTwist(p - s), vec3(1.));\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) { //ri: tet index, ro: position on tet, rd: direction on tet\n\tfloat dO=0.;\n    float surfDist = min(W_Max, SURF_DIST);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    int j;\n    for(j = 0; j < W_Count; j++)\n    {\n        SURF_DIST = (W_Min + (W_Max - W_Min) * float(j)) * 1.;\n        float d = RayMarch(ro, rd);\n        vec3 p = ro + rd * d;\n       \n        col += 2. * (wToRgb(SURF_DIST * 2.) * GetLight(p));\n    }\n    \n    col = pow(col / float(j), vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 190, 210, 210, 978], [980, 980, 1008, 1112, 1813], [1815, 1815, 1850, 1850, 2018], [2020, 2020, 2042, 2042, 2084], [2086, 2086, 2127, 2127, 2199], [2201, 2201, 2232, 2232, 2319], [2321, 2321, 2344, 2344, 2502], [2504, 2504, 2527, 2527, 2703], [2705, 2705, 2739, 2798, 3048], [3050, 3050, 3074, 3074, 3263], [3265, 3265, 3289, 3289, 3594], [3596, 3596, 3653, 3653, 4182]], "test": "error"}
{"id": "7t2SWR", "name": "cheese_FirstToy", "author": "lokichen", "description": "toy", "tags": ["first"], "likes": 1, "viewed": 129, "published": "Public API", "date": "1627461742", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col.r = cos(iTime)*0.5+0.5;\n    col.g = sin(iTime)*0.5+0.5;\n    col.b = cos(iTime)*0.5+0.5;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2SWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 395]], "test": "valid"}
{"id": "7t2XDh", "name": "Expanding Red Giant", "author": "Ubiquitous", "description": "This is my interpretation of a red giant star expanding. I'm not sure about the plausibility of it being accurate or not, although since we've never seen one up close it's anyone's guess. \n\nadjusted parameters from Kali's \"Dwarf\" shader. ", "tags": ["star", "supernova", "redgiant", "expansion", "mainsequence"], "likes": 5, "viewed": 110, "published": "Public", "date": "1627607894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Expanding Red Giant by Ubiquitous \n// 2021-06-28\n\n// Majority of code used is based from the following: \n// Dwarf by Kali https://www.shadertoy.com/view/3sjGDV\n// Corona effect based on https://www.shadertoy.com/view/4dXGR4\n// Inspiration: kodelife https://hexler.net/software/kodelife/\n\nfloat \tinner_radius=.304;\nfloat \touter_radius=.225;\nfloat \tfov=0.8; // not working in this version\nfloat\tzoom=1.8;\n\nconst float vol_steps=28.;\nfloat \tvol_rot=0.8;\nfloat \tvol_fade=.15;\n\nfloat \tsurf_scale=6.95;\nconst int surf_iterations=6;\nvec3\tsurf_param_1=vec3(.46,.35,.76);\nfloat\tsurf_param_2=0.97;\nfloat\tsurf_param_3=0.25;\nfloat \tsurf_exp=2.42;\nfloat\tsurf_base_value=.39;\nfloat\tsurf_intensity=.41;\nfloat\tsurf_brightness=3.6;\nfloat\tsurf_contrast=1.86;\nfloat \tsurf_rotation_speed=0.25;\nfloat \tsurf_turbulence_speed=.15;\n\nfloat \tcor_size=.57;\nfloat \tcor_offset=.09;\nconst int cor_iterations=14;\nfloat \tcor_iteration_fade=2.3;\nfloat \tcor_param_1=1.24;\nfloat \tcor_param_2=1.3;\nfloat \tcor_exp_1=1.6;\nfloat \tcor_exp_2=1.5;\nfloat \tcor_brightness=0.81;\nfloat \tcor_speed=0.21;\nfloat \tcor_speed_vary=1.2;\n\nfloat\tglow_intensity=1.24;\nfloat \tglow_size=3.42;\n\n\nvec3\tcolor_1=vec3(.21,.02,.01);\nvec3\tcolor_2=vec3(.4,.21,.01);\nfloat\tcolor_saturation=0.3;\nfloat\tcolor_contrast=3.8;\nfloat\tcolor_brightness=0.65;\n\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nfloat sphere(vec3 p, vec3 rd, float r){\n\tfloat b = dot( -p, rd ), i = b*b - dot(p,p) + r*r;\n\treturn i < 0. ?  -1.5 : b - sqrt(i);\n}\n\n\nmat2 rot(float a) {\n    float si = sin(a);\n    float co = cos(a);\n    return mat2(co,si,-si,co);\n}\n\nfloat snoise(vec3 uv, float res) //by trisomie21\n{\n    const vec3 s = vec3(1e0, 1e2, 1e4);\t\n\tuv *= res;\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\t\n\tvec4 r = fract(sin(v*3e-3)*4e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\t\n\tr = fract(sin((v + uv1.z - uv0.z)*3e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\t\n\treturn mix(r0, r1, f.z)*2.-1.3;\n}\n\nfloat kset(vec3 p) { //by me :P\n    p*=surf_scale*(1.+outer_radius);\n    float m=1000.;\n\tfor (int i=0; i<surf_iterations; i++) {\n        float d=dot(p,p);\n\t\tp=abs(p)/d*surf_param_2-vec3(surf_param_1);\n\t\tm=min(m,abs(d-surf_param_3))*(1.+surf_param_3);\n    }\n    float c=pow(max(0.,1.-m)/1.,surf_exp);\n\tc=pow(c,surf_exp)*surf_exp*surf_intensity;\n\treturn c; \n}\n\n\n//stolen and mutated code\nfloat cor(vec2 p) { \n\tfloat ti=iTime*cor_speed*cor_param_1+100.;\n    float d=length(p);\n\tfloat fad = (exp(-13.5*d)-outer_radius)/(outer_radius+cor_size)*(1.3-step(2.5,d));\n    \n    \n    float v1 = fad;\n\tfloat v2 = fad;\n\tfloat angle = atan( p.x, p.y )/6.2832;\n\tfloat dist = length(p)*cor_param_1/fov;\n\tvec3 crd = vec3( angle, dist, ti * 1.2 );\n    float ti2=ti+fad*cor_speed_vary*cor_param_1;\n    float t1=abs(snoise(crd+vec3(0.3,-ti2*1.,ti2*.1),15.));\n\tfloat t2=abs(snoise(crd+vec3(0.3,-ti2*.5,ti2*.2),45.));\t\n    float it=float(cor_iterations);\n    float s=1.;\n\tfor( int i=1; i<=cor_iterations; i++ ){\n\t\tti*=12.5;\n        float pw = pow(0.5,float(i));\n\t\tv1+=snoise(crd+vec3(0.7,-ti,ti*.02),(pw*50.*(t1+1.5)))/it*s*.23;\n\t\tv2+=snoise(crd+vec3(0.7,-ti,ti*.02),(pw*50.*(t2+1.5)))/it*s*.23;\n    }\n\tv1=max(v1,0.);v2=max(v2,0.);\n\tfloat co=pow(v1*fad,cor_exp_2)*cor_brightness;\n\tco+=pow(v2*fad,cor_exp_2)*cor_brightness;\n\tco*=1.4-t1*cor_param_2*(1.-fad*.7);\n    return co;\n}\n\n\n//messy code below\nvec3 render(vec2 uv) {\n    vec3 ro=vec3(0.2,0.3,1.);\n    ro.xz*=rot(iTime*surf_rotation_speed);\n    vec3 rd=normalize(vec3(uv,fov));\n    rd.xy*=.8;\n    rd=lookat(-ro,vec3(0.,1.,0.))*rd;\n    float tot_dist=outer_radius-inner_radius;\n\tfloat st=tot_dist/vol_steps;\n    float br=1./vol_steps;\n    float tr=iTime*surf_rotation_speed;\n\tfloat tt=iTime*surf_turbulence_speed;\n    float dist=0.;\n    float c=0.;\n    float dout=step(0.,sphere(ro, rd, outer_radius));\n    float d;\n    for (float i=0.; i<vol_steps; i++) {\n        d=sphere(ro, rd, inner_radius+i*st);\n        dist+=st;\n        vec3 p = ro+rd*d;\n        float a=vol_rot*i+tt;\n        p.yz*=rot(a);\n        p.xy*=rot(a);\n        c+=kset(p)*br*step(0.5,d)*max(0.,1.-smoothstep(0.,tot_dist,dist)*vol_fade);\n    }\n\tc+=surf_base_value;    \n    vec3 col=1.*mix(color_1, color_2, vec3(c))*c;\n    inner_radius*=fov;\n    outer_radius*=fov;\n    glow_size*=fov;\n    cor_size*=fov;\n    float cor=cor(uv);\n    float r1=inner_radius;\n    float r2=outer_radius;\n    float l=smoothstep(r1-cor_offset,r2, length(uv));\n    float rt=outer_radius+glow_size;\n    float sw=1.-smoothstep(0.3,rt,length(uv));\n    col=min(vec3(5.),pow(col,vec3(surf_contrast))*surf_brightness*surf_contrast);\n    col+=cor*color_1*l+sw*color_2*glow_intensity;\n    col=mix(vec3(length(col)), col, color_saturation)*color_brightness;\n    return pow(col,vec3(color_contrast));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-.5;\n\tuv.x*=iResolution.x/iResolution.y;\n    uv.x+=cos(iTime*.178924387342)*.1;\n    zoom*=1.+sin(iTime*.2)*.2;\n\tvec3 col = render(uv/zoom);\n    col=pow(col,vec3(1.5))*vec3(1.1,1.,1.);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2XDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1288, 1288, 1317, 1317, 1413], [1415, 1415, 1454, 1454, 1546], [1549, 1549, 1568, 1568, 1647], [1649, 1649, 1699, 1699, 2222], [2224, 2224, 2244, 2255, 2581], [2584, 2610, 2629, 2629, 3577], [3580, 3599, 3621, 3621, 4985], [4989, 4989, 5046, 5046, 5303]], "test": "valid"}
{"id": "7t2XRm", "name": "Celestial Globe", "author": "CrescentMax", "description": "A simple ray tracing scene.", "tags": ["3d", "raytracing"], "likes": 1, "viewed": 66, "published": "Public", "date": "1627376428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 5;\nconst int NUM_PLANES = 1;\nconst int NUM_SPHERES = 3;\nconst int NUM_TRIANGLES = 20;\n\n// Constant values for setting up\nconst float NEBULA_HEIGHT = 1.0;\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Triangle_t {\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n    int materialID;\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nTriangle_t Triangle[NUM_TRIANGLES];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    // Plane[1].A = 0.0;\n    // Plane[1].B = 0.0;\n    // Plane[1].C = 1.0;\n    // Plane[1].D = 3.5;\n    // Plane[1].materialID = 0;\n\n    // Center bouncing sphere.\n    // Sphere[0].center = vec3( 0.0, abs(sin(2.0 * iTime)) + 1.0, 0.0 );\n    // Sphere[0].radius = 0.5;\n    // Sphere[0].materialID = 1;\n\n    // Circling sphere1.\n    Sphere[0].center = vec3( 1.5 * cos(iTime), 0.5 + NEBULA_HEIGHT, 1.5 * sin(iTime) );\n    Sphere[0].radius = 0.3;\n    Sphere[0].materialID = 2;\n\n    // Circling sphere2.\n    Sphere[1].center = vec3( 1.5 * cos(iTime) + 0.6 * cos(1.5 * iTime + PI / 6.0), \n                             0.5 + NEBULA_HEIGHT + 0.2 * sin(iTime), \n                             1.5 * sin(iTime) + 0.6 * sin(1.5 * iTime + PI / 6.0) );\n    Sphere[1].radius = 0.12;\n    Sphere[1].materialID = 2;\n\n    // Circling sphere3.\n    Sphere[2].center = vec3( 2.8 * cos(2.5 * iTime), \n                             0.5 + NEBULA_HEIGHT + 0.5 * sin(2.5 * iTime), \n                             2.8 * sin(2.5 * iTime) );\n    Sphere[2].radius = 0.2;\n    Sphere[2].materialID = 3;\n\n    // Cube Trianles.\n    Triangle[0].p1 = vec3(-0.5, 1.0, -0.5);\n    Triangle[0].p2 = vec3( 0.5, 0.0, -0.5);\n    Triangle[0].p3 = vec3(-0.5, 0.0, -0.5);\n\n    Triangle[1].p1 = vec3( 0.5, 1.0, -0.5);\n    Triangle[1].p3 = vec3(-0.5, 1.0, -0.5);\n    Triangle[1].p2 = vec3( 0.5, 0.0, -0.5);\n\n    Triangle[2].p1 = vec3( 0.5, 1.0, -0.5);\n    Triangle[2].p2 = vec3( 0.5, 0.0,  0.5);\n    Triangle[2].p3 = vec3( 0.5, 0.0, -0.5);\n\n    Triangle[3].p1 = vec3( 0.5, 1.0, -0.5);\n    Triangle[3].p3 = vec3( 0.5, 0.0,  0.5);\n    Triangle[3].p2 = vec3( 0.5, 1.0,  0.5);\n\n    Triangle[4].p1 = vec3(-0.5, 1.0,  0.5);\n    Triangle[4].p2 = vec3( 0.5, 0.0,  0.5);\n    Triangle[4].p3 = vec3( 0.5, 1.0,  0.5);\n\n    Triangle[5].p1 = vec3(-0.5, 1.0,  0.5);\n    Triangle[5].p3 = vec3( 0.5, 0.0,  0.5);\n    Triangle[5].p2 = vec3(-0.5, 0.0,  0.5);\n\n    Triangle[6].p1 = vec3(-0.5, 0.0, -0.5);\n    Triangle[6].p3 = vec3(-0.5, 1.0,  0.5);\n    Triangle[6].p2 = vec3(-0.5, 0.0,  0.5);\n\n    Triangle[7].p1 = vec3(-0.5, 0.0, -0.5);\n    Triangle[7].p2 = vec3(-0.5, 1.0,  0.5);\n    Triangle[7].p3 = vec3(-0.5, 1.0, -0.5);\n\n    Triangle[8].p1 = vec3(-0.5, 0.0, -0.5);\n    Triangle[8].p2 = vec3( 0.5, 0.0,  0.5);\n    Triangle[8].p3 = vec3(-0.5, 0.0,  0.5);\n\n    Triangle[9].p1 = vec3(-0.5, 0.0, -0.5);\n    Triangle[9].p3 = vec3( 0.5, 0.0,  0.5);\n    Triangle[9].p2 = vec3( 0.5, 0.0, -0.5);\n\n    Triangle[10].p1 = vec3(-0.5, 1.0, -0.5);\n    Triangle[10].p2 = vec3( 0.5, 1.0,  0.5);\n    Triangle[10].p3 = vec3( 0.5, 1.0, -0.5);\n\n    Triangle[11].p1 = vec3(-0.5, 1.0, -0.5);\n    Triangle[11].p3 = vec3( 0.5, 1.0,  0.5);\n    Triangle[11].p2 = vec3(-0.5, 1.0,  0.5);\n\n    vec3 crystal[7] = vec3[]( vec3( 0.0, 1.7, 0.0 ),       // center\n                              vec3( 0.0, 1.1, 0.0 ),       // bottom\n                              vec3( 0.0, 2.3, 0.0 ),       // top\n                              vec3( 0.3 * cos(iTime), 1.7, 0.3 * sin(iTime) ),\n                              vec3(-0.3 * sin(iTime), 1.7, 0.3 * cos(iTime) ),\n                              vec3( 0.3 * sin(iTime), 1.7,-0.3 * cos(iTime) ),\n                              vec3(-0.3 * cos(iTime), 1.7,-0.3 * sin(iTime) ) );\n\n    Triangle[12].p1 = crystal[1];\n    Triangle[12].p2 = crystal[3];\n    Triangle[12].p3 = crystal[4];\n\n    Triangle[13].p1 = crystal[1];\n    Triangle[13].p2 = crystal[3];\n    Triangle[13].p3 = crystal[5];\n\n    Triangle[14].p1 = crystal[1];\n    Triangle[14].p2 = crystal[6];\n    Triangle[14].p3 = crystal[4];\n\n    Triangle[15].p1 = crystal[1];\n    Triangle[15].p2 = crystal[6];\n    Triangle[15].p3 = crystal[5];\n\n    Triangle[16].p1 = crystal[2];\n    Triangle[16].p2 = crystal[3];\n    Triangle[16].p3 = crystal[4];\n\n    Triangle[17].p1 = crystal[2];\n    Triangle[17].p2 = crystal[3];\n    Triangle[17].p3 = crystal[5];\n\n    Triangle[18].p1 = crystal[2];\n    Triangle[18].p2 = crystal[6];\n    Triangle[18].p3 = crystal[4];\n\n    Triangle[19].p1 = crystal[2];\n    Triangle[19].p2 = crystal[6];\n    Triangle[19].p3 = crystal[5];\n\n    // Apply transformation to cube triangles\n    for (int i = 0; i < 12; i++)\n    {\n        Triangle[i].p1.y *= 0.7 * abs(sin(iTime + PI / 2.0));\n        Triangle[i].p2.y *= 0.7 * abs(sin(iTime + PI / 2.0));\n        Triangle[i].p3.y *= 0.7 * abs(sin(iTime + PI / 2.0));\n        Triangle[i].materialID = 1;\n    }\n\n    // Apply transformation to crystal triangles\n    for (int i = 12; i < NUM_TRIANGLES; i++)\n    {\n        // Move up and down\n        Triangle[i].p1.y += 0.5 * (sin(2.0 * iTime));\n        Triangle[i].p2.y += 0.5 * (sin(2.0 * iTime));\n        Triangle[i].p3.y += 0.5 * (sin(2.0 * iTime));\n            \n        // Material\n        Triangle[i].materialID = 4;\n    }\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // Blue frosted material\n    Material[3].k_d = vec3( 0.235, 0.364, 0.866 );\n    Material[3].k_a = 0.2 * Material[2].k_d;\n    Material[3].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[3].k_rg = 0.5 * Material[2].k_r;\n    Material[3].n = 32.0;\n\n    // Rainbow material\n    Material[4].k_d = vec3( abs(cos(iTime + PI / 6.0)), abs(sin(iTime + PI / 3.0)), abs(cos(iTime - PI / 2.0)) );\n    Material[4].k_a = 0.1 * Material[2].k_d;\n    Material[4].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[4].k_rg = 0.6 * Material[2].k_r;\n    Material[4].n = 64.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 0.85, 0.85, 0.85 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 10.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 0.8, 0.8, 0.8 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    vec3 l_o = ray.o - sph.center;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(ray.d,  l_o);\n    float c = dot(l_o, l_o) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a *c;\n    \n    if (d < 0.0) return false;\n    float t_m = (-b-sqrt(d)) / (2.0*a);\n    float t_p = (-b+sqrt(d)) / (2.0*a);\n    if ( (t_m >= tmin && t_m <= tmax) )\n    {\n        t = t_m;\n        hitPos = ray.o + t * ray.d;\n        hitNormal = normalize( l_o + t * ray.d );\n        return true;\n    }\n    else if ( (t_p >= tmin &&  t_p <= tmax) )\n    {\n        t = t_p;\n        hitPos = ray.o + t * ray.d;\n        hitNormal = normalize( l_o + t * ray.d );\n        return true;\n    }\n    return false;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    vec3 l_o = ray.o - sph.center;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(ray.d,  l_o);\n    float c = dot(l_o, l_o) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a *c;\n    \n    if (d < 0.0) return false;\n    float t_m = (-b-sqrt(d)) / (2.0*a);\n    float t_p = (-b+sqrt(d)) / (2.0*a);\n    if ( (t_m >= tmin && t_m <= tmax) )\n    {\n        return true;\n    }\n    else if ( (t_p >= tmin &&  t_p <= tmax) )\n    {\n        return true;\n    }\n    return false;\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    mat3 cramer;\n    mat3 A;\n    A[0] = tri.p1 - tri.p2;\n    A[1] = tri.p1 - tri.p3;\n    A[2] = ray.d;\n    float detA = determinant(A);\n\n    cramer[0] = tri.p1 - ray.o;\n    cramer[1] = tri.p1 - tri.p3;\n    cramer[2] = ray.d;\n\n    float beta = determinant(cramer) / detA;\n\n    cramer[0] = tri.p1 - tri.p2;\n    cramer[1] = tri.p1 - ray.o;\n    cramer[2] = ray.d;\n\n    float gamma = determinant(cramer) / detA;\n\n    cramer[0] = tri.p1 - tri.p2;\n    cramer[1] = tri.p1 - tri.p3;\n    cramer[2] = tri.p1 - ray.o;\n\n    float t0 = determinant(cramer) / detA;\n\n    if (beta + gamma < 1.0 && beta > 0.0 && gamma > 0.0 && t0 > 0.0 && t0 > tmin && t0 < tmax) {\n        t = t0;\n        hitPos = ray.o + t * ray.d;\n        hitNormal = normalize(cross(tri.p1 - tri.p2, tri.p1 - tri.p3));\n        return true;\n    }\n\n    return false;\n\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax )\n{\n    mat3 cramer;\n    mat3 A;\n\n    A[0] = tri.p1 - tri.p2;\n    A[1] = tri.p1 - tri.p3;\n    A[2] = ray.d;\n    float detA = determinant(A);\n\n    cramer[0] = tri.p1 - ray.o;\n    cramer[1] = tri.p1 - tri.p3;\n    cramer[2] = ray.d;\n\n    float beta = determinant(cramer) / detA;\n\n    cramer[0] = tri.p1 - tri.p2;\n    cramer[1] = tri.p1 - ray.o;\n    cramer[2] = ray.d;\n\n    float gamma = determinant(cramer) / detA;\n\n    cramer[0] = tri.p1 - tri.p2;\n    cramer[1] = tri.p1 - tri.p3;\n    cramer[2] = tri.p1 - ray.o;\n\n    float t0 = determinant(cramer) / detA;\n\n    if (beta + gamma < 1.0 && beta > 0.0 && gamma > 0.0 && t0 > 0.0 && t0 > tmin && t0 < tmax) {\n        return true;\n    }\n\n    return false;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light, in vec2 uv )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        vec3 diffuse = texture(iChannel0, uv).rgb;\n        vec3 specular = diffuse;\n\n        return light.I_a * mat.k_a +\n               light.I_source * (diffuse * N_dot_L + specular * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for ( int i = 0; i < NUM_PLANES; i++ )\n    {\n        temp_hasHit = IntersectPlane( Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                                        temp_t, temp_hitPos, temp_hitNormal );\n        if ( temp_hasHit && temp_t < nearest_t )\n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Plane[i].materialID;\n        }\n        if (!hasHitSomething && temp_hasHit) hasHitSomething = true;\n    }\n    \n    for ( int i = 0; i < NUM_SPHERES; i++ )\n    {\n        temp_hasHit = IntersectSphere( Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                                        temp_t, temp_hitPos, temp_hitNormal );\n        if ( temp_hasHit && temp_t < nearest_t )\n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Sphere[i].materialID;\n        }\n        if (!hasHitSomething && temp_hasHit) hasHitSomething = true;\n    }\n\n    for ( int i = 0; i < NUM_TRIANGLES; i++ )\n    {\n        temp_hasHit = IntersectTriangle( Triangle[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                                        temp_t, temp_hitPos, temp_hitNormal );\n        if ( temp_hasHit && temp_t < nearest_t )\n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Triangle[i].materialID;\n        }\n        if (!hasHitSomething && temp_hasHit) hasHitSomething = true;\n    }\n\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for ( int i = 0; i < NUM_LIGHTS; i++ )\n    {\n        Ray_t shadowRay;\n        shadowRay.o = nearest_hitPos;\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n        float shadowTMax = length(Light[i].position - nearest_hitPos);\n        temp_hasHit = false;\n\n        for ( int j = 0; j < NUM_PLANES; j++ )\n        {\n            if (temp_hasHit) break;\n            temp_hasHit = IntersectPlane( Plane[j], shadowRay, DEFAULT_TMIN, shadowTMax );\n        }\n        \n        for ( int j = 0; j < NUM_SPHERES; j++ )\n        {\n            if (temp_hasHit) break;\n            temp_hasHit = IntersectSphere( Sphere[j], shadowRay, DEFAULT_TMIN, shadowTMax );\n        }\n\n        for ( int j = 0; j < NUM_TRIANGLES; j++ )\n        {\n            if (temp_hasHit) break;\n            temp_hasHit = IntersectTriangle( Triangle[j], shadowRay, DEFAULT_TMIN, shadowTMax );\n        }\n\n\n        vec3 L = normalize(Light[i].position - nearest_hitPos);\n        vec3 N = normalize(nearest_hitNormal);\n        vec3 V = normalize(cross(L, N));\n        I_local += PhongLighting(L, N, V, temp_hasHit, Material[nearest_hitMatID], Light[i]);\n    }\n\n\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 4.5 * sin(0.3 * iTime), 3.0, 4.5 );\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2XRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[9449, 9945, 10099, 10099, 10429], [10433, 10765, 10848, 10848, 11060], [11064, 11582, 11739, 11853, 12542], [12546, 12879, 12964, 13078, 13561], [13563, 13563, 13724, 13724, 14545], [14547, 14547, 14636, 14636, 15333], [15337, 15691, 15821, 15821, 16233], [16235, 16235, 16377, 16377, 16875], [16879, 17668, 17781, 17872, 22706], [22710, 23071, 23128, 23128, 24568]], "test": "error"}
{"id": "7tBSzW", "name": "Graphed Music", "author": "wildniklin", "description": "Music...", "tags": ["graph"], "likes": 6, "viewed": 192, "published": "Public API", "date": "1627171846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float segments = 50.0; // Segments per unit, must be less than (1.0 / thickness), or else will glitch visually, because lines are wider than segments.\nconst float thickness = 0.01; // Line thickness\nconst float gridThickness = 0.001; // Grid line thickness\nconst float scale = 8.0;\n\nfloat value(float x, int i) {\n    if(i == 0)\n        return (texture(iChannel0, vec2((x * 0.125) + 0.5, 1.0)).x * 2.0) - 1.0;\n    if(i == 1)\n        return (texture(iChannel0, vec2((x * 0.125) + 0.5, 0.0)).x * 2.0) - 1.0;\n}\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nvec2 closestPointLine(vec2 a, vec2 b, vec2 p) {\n    vec2 ab = b - a;\n    float dist = clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n    if(dist <= 0.0) return a;\n    if(dist >= 1.0) return b;\n    return mix(a, b, dist);\n}\n\nfloat distToLine(vec2 a, vec2 b, vec2 p) {\n    return length(p - closestPointLine(a, b, p));\n}\n\nvec2 point(int i, float unit, int e) {\n    float x = (float(i) + 0.5) * unit;\n    return vec2(x, value(x, e));\n}\n\nfloat getDist(vec2 uv, int i) {\n    int ip = int(floor(uv.x * segments));\n    float unit = 1.0 / segments;\n\n    vec2 p0 = point(ip - 2, unit, i),\n         p1 = point(ip - 1, unit, i),\n         p2 = point(ip    , unit, i),\n         p3 = point(ip + 1, unit, i),\n         p4 = point(ip + 2, unit, i);\n\n    return min(min(distToLine(p0, p1, uv), distToLine(p1, p2, uv)),\n               min(distToLine(p2, p3, uv), distToLine(p3, p4, uv))) - thickness;\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    float un = 1.0 / max(iResolution.x, iResolution.y);\n    \n    un *= scale;\n    \n    vec2 uv = (i - (0.5 * iResolution.xy)) * un;\n    \n    uv *= rot(radians(sin(radians(iTime * 22.5)) * 4.0));\n\n    vec3 d = vec3(1.0);\n\n    vec2 f = fract(uv);\n    d = mix(d, vec3(0.75), min(1.0, smoothstep(un, -un, (1.0 - f.x) - gridThickness) + smoothstep(un, -un, f.x - gridThickness) + smoothstep(un, -un, (1.0 - f.y) - gridThickness) + smoothstep(un, -un, f.y - gridThickness)));\n    \n    d = mix(d, vec3(0.6, 0.0, 0.0), 0.8 * smoothstep(un, -un, getDist(uv, 1)));\n    \n    d = mix(d, vec3(0.1, 0.1, 0.4), 0.8 * smoothstep(un, -un, getDist(uv, 0)));\n\n    d = mix(d, vec3(0.0), smoothstep(0.0, 3.0 * scale, length(uv)));\n    \n    o = vec4(d, 1.0);\n}", "image_inputs": [{"id": "MllSDS", "previewfilepath": "https://soundcloud.com/nilowhbeats/a-sweet-beginning", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/nilowhbeats/a-sweet-beginning", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 289, 318, 318, 512], [514, 514, 533, 533, 599], [601, 601, 648, 648, 823], [825, 825, 867, 867, 919], [1035, 1035, 1066, 1066, 1484], [1486, 1486, 1522, 1522, 2261]], "test": "error"}
{"id": "7tBXDh", "name": "Ray Tracing One Weekend Improved", "author": "chenglou", "description": "Revisited my original ray tracer from the beginning of the month! Speed went from 11 fps to 55 fps :)\n- Way better random in unit sphere & vector & disk\n- Unrolled the loop from `hit`; static spheres list\n- Removed a few conditionals. That's it!", "tags": ["raytracing"], "likes": 13, "viewed": 479, "published": "Public API", "date": "1627545462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://raytracing.github.io/books/RayTracingInOneWeekend.html\n\nconst float PI = 3.14159;\nconst float SAMPLES_PER_PIXEL = 10.;\nconst int MAX_RAY_BOUNCES = 6;\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash32(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random_in_unit_sphere(vec2 p) {\n    vec3 rand = hash32(p);\n    float phi = 2.0 * PI * rand.x;\n    float cosTheta = 2.0 * rand.y - 1.0;\n    float u = rand.z;\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\nvec3 random_unit_vector(vec2 p) {\n    return normalize(random_in_unit_sphere(p));\n}\n\nvec3 random_in_unit_disk(vec2 p) {\n    return vec3(random_in_unit_sphere(p).xy, 0);\n}\n\nconst int material_lambertian = 0;\nconst int material_metal = 1;\nconst int material_dielectric = 2;\n\nstruct ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct material {\n    int type;\n    vec3 albedo;\n    float metal_fuzz;\n    float dielectric_index_of_refraction;\n};\n\nstruct hit_record {\n    vec3 p;\n    vec3 normal;\n    float t;\n    material material;\n};\n\nstruct sphere {\n    vec3 center;\n    float radius;\n    material material;\n};\n\nsphere s1 = sphere(vec3( 0.0, -1000., -1.0), 1000., material(material_lambertian, vec3(0.5), 0., 0.));\nsphere s2 = sphere(vec3(-4.0,    1.0, 2.),   1.0, material(material_dielectric, vec3(0), 0., 1.5));\nsphere s3 = sphere(vec3( 0.0,    1.0, 0.),   1.0, material(material_metal, vec3(0.7, 0.6, 0.5), 0., 0.));\nsphere s4 = sphere(vec3( 4.0,    1.0, 2.),   1.0, material(material_lambertian, vec3(0.7, 0.3, 0.3), 0., 0.));\nsphere s5 = sphere(vec3(-6, 0.2, 2.8), 0.2, material(material_dielectric, vec3(0, 0, 0.2), 0., 1.5));\nsphere s6 = sphere(vec3(1.6, 0.2, -0.9), 0.2, material(material_dielectric, vec3(0), 0., 1.5));\nsphere s7 = sphere(vec3(-5.7, 0.2, -2.7), 0.2, material(material_lambertian, vec3(0.8, 0.3, 0.3), 0., 0.));\nsphere s8 = sphere(vec3(-3.6, 0.2, -4.4), 0.2, material(material_lambertian, vec3(0.9, 0.3, 0.2), 0., 0.));\nsphere s9 = sphere(vec3(0.8, 0.2, 2.3), 0.2, material(material_lambertian, vec3(0.2, 0, 0.5), 0., 0.));\nsphere s10 = sphere(vec3(3.8, 0.2, 4.2), 0.2, material(material_lambertian, vec3(0.4, 0.3, 0.7), 0., 0.));\nsphere s11 = sphere(vec3(-0.1, 0.2, -1.9), 0.2, material(material_lambertian, vec3(0.4, 0, 0.4), 0., 0.));\nsphere s12 = sphere(vec3(-2.5, 0.2, 5.4), 0.2, material(material_metal, vec3(0.3, 0.7, 0.9), 0.3, 0.));\nsphere s13 = sphere(vec3(-3.9, 0.2, -0.3), 0.2, material(material_lambertian, vec3(0.9, 0.8, 0.5), 0., 0.));\nsphere s14 = sphere(vec3(-6, 0.2, 4), 0.2, material(material_lambertian, vec3(0.9, 0.9, 0.5), 0., 0.));\nsphere s15 = sphere(vec3(4.4, 0.2, -0.5), 0.2, material(material_lambertian, vec3(0.5, 0.4, 0.8), 0., 0.));\nsphere s16 = sphere(vec3(3.4, 0.2, 5.3), 0.2, material(material_lambertian, vec3(0.1, 0.6, 0.2), 0., 0.));\nsphere s17 = sphere(vec3(4.6, 0.2, -3.8), 0.2, material(material_lambertian, vec3(0.2, 0.2, 0.2), 0., 0.));\nsphere s18 = sphere(vec3(0.7, 0.2, -2.5), 0.2, material(material_metal, vec3(0, 0.2, 0.1), 0., 0.));\nsphere s19 = sphere(vec3(2.4, 0.2, -4.3), 0.2, material(material_lambertian, vec3(0.8, 0.9, 0), 0., 0.));\nsphere s20 = sphere(vec3(4.4, 0.2, 4.9), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0), 0., 0.));\nsphere s21 = sphere(vec3(-4.7, 0.2, 4.6), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.7), 0., 0.));\nsphere s22 = sphere(vec3(4.2, 0.2, -3.5), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.6), 0., 0.));\nsphere s23 = sphere(vec3(-5.2, 0.2, 0.5), 0.2, material(material_lambertian, vec3(0.2, 0.7, 0.9), 0., 0.));\nsphere s24 = sphere(vec3(5.7, 0.2, -0.8), 0.2, material(material_lambertian, vec3(0.3, 0, 0.7), 0., 0.));\n\nvoid hit_sphere(sphere sph, ray r, inout hit_record rec, inout bool hit_anything) {\n    float closest_so_far = rec.t;\n    vec3 oc = r.origin - sph.center;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discriminant = half_b * half_b - a * c;\n    if (discriminant < 0.) {\n        return;\n    }\n\n    float sqrtd = sqrt(discriminant);\n\n    // Find the nearest root that lies in the acceptable range\n    float root = (-half_b - sqrtd) / a; // the t. from -b - sqrt(dis) / 2a\n    if (root < 0.001 || closest_so_far < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < 0.001 || closest_so_far < root) {\n            return;\n        }\n    }\n\n    hit_anything = true;\n    vec3 p = r.origin + r.dir * root;\n    rec = hit_record(p, (p - sph.center) / sph.radius, root, sph.material);\n}\n\nbool hit(ray r, out hit_record rec) {\n    bool hit = false;\n    // dummy. Set initial hit distance to max\n    rec = hit_record(vec3(0), vec3(0), 9999., material(material_lambertian, vec3(0), 0., 0.));\n\n    // unrolling this loop gave 4x perf boost...\n    hit_sphere(s1, r, rec, hit);\n    hit_sphere(s2, r, rec, hit);\n    hit_sphere(s3, r, rec, hit);\n    hit_sphere(s4, r, rec, hit);\n    hit_sphere(s5, r, rec, hit);\n    hit_sphere(s6, r, rec, hit);\n    hit_sphere(s7, r, rec, hit);\n    hit_sphere(s8, r, rec, hit);\n    hit_sphere(s9, r, rec, hit);\n    hit_sphere(s11, r, rec, hit);\n    hit_sphere(s12, r, rec, hit);\n    hit_sphere(s13, r, rec, hit);\n    hit_sphere(s14, r, rec, hit);\n    hit_sphere(s15, r, rec, hit);\n    hit_sphere(s16, r, rec, hit);\n    hit_sphere(s17, r, rec, hit);\n    hit_sphere(s18, r, rec, hit);\n    hit_sphere(s19, r, rec, hit);\n    hit_sphere(s21, r, rec, hit);\n    hit_sphere(s22, r, rec, hit);\n    hit_sphere(s23, r, rec, hit);\n    hit_sphere(s24, r, rec, hit);\n    return hit;\n}\n\nbool near_zero(vec3 p) {\n    float s = 1e-8;\n    return p.x < s && p.y < s && p.z < s;\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance\n    float r0 = (1. - ref_idx) / (1. + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1. - cosine), 5.);\n}\n\nvoid scatter(hit_record rec, ray r, vec2 seed, inout vec3 attenuation, inout ray scattered) {\n    material m = rec.material;\n\n    if (m.type == material_lambertian) {\n        vec3 scatter_direction = normalize(rec.normal + random_unit_vector(seed));\n\n        // catch degenerate scatter direction\n        if (near_zero(scatter_direction)) {\n            scatter_direction = rec.normal;\n        }\n\n        scattered = ray(rec.p, scatter_direction);\n        attenuation = m.albedo;\n    } else if (m.type == material_metal) {\n        vec3 reflected = reflect(r.dir, rec.normal);\n        ray scattered_ = ray(rec.p, normalize(reflected + m.metal_fuzz * random_in_unit_sphere(seed)));\n        if (dot(scattered_.dir, rec.normal) > 0.) {\n            scattered = scattered_;\n            attenuation = m.albedo;\n        }\n    } else if (m.type == material_dielectric) {\n        bool front_face = dot(r.dir, rec.normal) < 0.;\n        vec3 adjusted_normal = front_face ? rec.normal : -rec.normal;\n        float ref = m.dielectric_index_of_refraction;\n        float refraction_ratio = front_face ? 1.0/ref : ref;\n\n        float cos_theta = min(dot(-r.dir, adjusted_normal), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\n        bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n        vec3 direction;\n\n        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > hash12(seed)) {\n            direction = reflect(r.dir, adjusted_normal);\n        } else {\n            direction = refract(r.dir, adjusted_normal, refraction_ratio);\n        }\n\n        scattered = ray(rec.p, direction);\n        attenuation = vec3(1);\n    }\n}\n\nvec3 ray_color(in ray r, vec2 seed) {\n    vec3 color = vec3(1);\n    hit_record rec;\n    int depth;\n    for (depth = 0; depth < MAX_RAY_BOUNCES; depth++) {\n        if (hit(r, rec)) {\n            ray scattered;\n            vec3 attenuation;\n            scatter(rec, r, seed * 999. + float(depth), attenuation, scattered);\n            r = scattered;\n            color *= attenuation;\n        } else {\n            // hit bg, aka nothing\n            float t = 0.5 * (r.dir.y + 1.0);\n            color *= mix(vec3(1.), vec3(0.5, 0.7, 1.0), t);\n\n            break;\n        }\n    }\n\n    if (depth == MAX_RAY_BOUNCES) {\n        return vec3(0);\n    }\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // camera\n    vec3 lookfrom = vec3(cos(iTime) * 13., 2.0, sin(iTime) * 10.);\n    vec3 lookat = vec3(0, 0, 0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 30.0;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    float aperture = 0.1;\n    float focus_dist = 10.0;\n\n    float theta = radians(vfov);\n    float h = tan(theta / 2.);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n\n    vec3 origin = lookfrom;\n    vec3 horizontal = focus_dist * viewport_width * u;\n    vec3 vertical = focus_dist * viewport_height * v;\n    vec3 lower_left_corner = origin - horizontal / 2. - vertical / 2. - focus_dist * w;\n\n    float lens_radius = aperture / 2.;\n\n    // render\n    vec3 color = vec3(0);\n    for (float s = 0.; s < SAMPLES_PER_PIXEL; s++) {\n        vec2 rand = hash22(fragCoord * 999. + s + iTime);\n\n        vec2 normalizedCoord = (fragCoord + rand) / iResolution.xy;\n        vec3 rd = lens_radius * random_in_unit_disk(normalizedCoord * 999. + s + iTime);\n        vec3 offset = u * rd.x + v * rd.y;\n        ray r = ray(\n            origin + offset,\n            normalize(lower_left_corner + normalizedCoord.x * horizontal + normalizedCoord.y * vertical - origin - offset)\n        );\n        color += ray_color(r, normalizedCoord);\n    }\n\n    fragColor = vec4(sqrt(color / SAMPLES_PER_PIXEL), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 183, 183, 303], [304, 304, 325, 325, 462], [463, 463, 484, 484, 623], [625, 625, 661, 661, 996], [998, 998, 1031, 1031, 1081], [1083, 1083, 1117, 1117, 1168], [4138, 4138, 4221, 4221, 5010], [5012, 5012, 5049, 5049, 6019], [6021, 6021, 6045, 6045, 6109], [6111, 6111, 6159, 6210, 6330], [6332, 6332, 6425, 6425, 7983], [7985, 7985, 8022, 8022, 8645], [8648, 8648, 8705, 8719, 10173]], "test": "valid"}
{"id": "7tBXDz", "name": "Lunch Doudeul", "author": "Flopine", "description": "A smol doodle I made during my launch break. It felt great to experiment with that!", "tags": ["3d", "animation", "isometric", "symmetry"], "likes": 19, "viewed": 169, "published": "Public", "date": "1627420972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n#define PI acos(-1.)\n#define TAU 6.283185\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define mo(p,d) p=abs(p)-d;if(p.y>p.x)p=p.yx\n#define crep(p,c,l) p=p-c*clamp(round(p/c),-l,l)\n\n#define dt(sp) fract(iTime*sp)\n#define swi(sp) floor(dt(sp)*3.)\n\nstruct obj\n{\n    float d;\n    vec3 col;\n};\n\nobj minobj (obj a, obj b)\n{\n    if (a.d<b.d) return a;\n    else return b;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));  \n    p.xz *= rot(PI/4.);\n    crep(p.xz, 16., 2.);\n    \n    float boxes = max(-box(p+vec3(0.5,-0.5,0.5),vec3(4.3)),box(p,vec3(4.))),\n    size = 0.8, pipes;\n    p.y += 0.4;\n    for (int i=0; i<4; i++)\n    {\n        mo(p.xz,vec2(size));\n        p.xz -= size*0.7;\n        mo(p.zy,vec2(size*.7));\n        p.y -= 0.3;\n        boxes = min(boxes, box(p,vec3(size)));\n        pipes = length(p.xz-vec2(0.1+sin(dt(0.2)*TAU)*0.03,0.))-0.04;\n        size -= 0.2;       \n    }\n    obj B = obj(boxes, vec3(1.));\n    obj P = obj(pipes, vec3(0.8,0.1,0.1));\n    \n    return minobj(B, P);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float fov = (swi(0.1)<.5)?2.5:(swi(0.1)<1.5)?4.5:18.;\n    vec3 ro=vec3(uv*fov,-30.), rd=vec3(0.,0.,1.), p=ro, col=vec3(0.), l=normalize(vec3(-1.,2.,-1.));\n    obj O; bool hit=false;\n    \n    for(float i=0.; i<64.; i++)\n    {\n        O = SDF(p);\n        if (O.d<0.001)\n        {hit=true; break;}\n       p += O.d*rd;\n    }\n    \n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = dot(n,l)*.5+.3;\n        col = O.col*light;\n    }\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[657, 657, 684, 684, 732], [734, 734, 762, 762, 847], [849, 849, 867, 867, 1477], [1479, 1479, 1502, 1502, 1624], [1626, 1626, 1683, 1683, 2260]], "test": "valid"}
{"id": "7tBXRw", "name": "space cube w twinkling stars", "author": "xertrov", "description": "I'm happy with how it turned out. I had to figure out a signed dist function for cube edges. I also had a lot of trouble (with rotations and things) getting the cube on the screen. I eventually \"resorted\" to raymarching and it worked pretty well!", "tags": ["raymarch", "cube", "art", "signeddistance"], "likes": 5, "viewed": 173, "published": "Public API", "date": "1627299682", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define S(a, b, t)smoothstep(a, b, t)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n#define GROW_SHRINK 0.3\n#define ROTATE_IDLE 0.2\n#define BASE_TWINKLE 99.0\n#define STAR_RARITY 0.95\n// set to 5k+ for a hyperspace bungee; curious noise patterns at 2000.\n#define BG_SCALE 100.0\n\n/* lib/util stuff */\n\nfloat N21b(vec2 p) {  // from an art of code video i think\n  vec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n  a += dot(a, a.yzx + 79.76);\n  return fract((a.x + a.y) * a.z);\n}\n\n\nfloat sdBox(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.z, max(d.x, d.y)), 0.0);\n}\n\n\nvec2 best2(vec3 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\n\nvec2 sinCos(in vec2 ab) {\n  return vec2(sin(ab.x), cos(ab.y));\n}\n\n// roll from XY to XZ or YZ (0 no roll, 1=XZ, 2=YZ)\nmat3 rot3XY(float angle, int roll) {\n  float s = sin(angle), c = cos(angle);\n  mat3 r = mat3(c, - s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n  if (roll == 1) {\n    r = mat3(r[0].xzy, r[2].xzy, r[1].xzy);\n  } else if (roll == 2) {\n    r = mat3(r[2].zxy, r[0].zxy, r[1].zxy);\n  }\n  return r;\n}\n\n\nvec3 rainbow(vec2 uv, float time) {\n  return sin(vec3(time) + uv.xyx * vec3(1.0, 1.0, 1.0) + vec3(0, 2, 4)) * 0.49 + 0.5;\n}\n\n/* meat */\n\nfloat sdBoxEdge(in vec3 p, in vec3 b) {\n  return length(best2(abs(p) - b));  // rly elegant\n}\n\nvec4 getIDGV(vec2 uv, float scale) {\n  vec2 id = floor(uv * scale);\n  vec2 gv = fract(uv * scale) - 0.5;\n  return vec4(id, gv);\n}\n\nfloat mkNoise(vec2 uv, float t, float minDS) {\n  float scale = fwidth(uv.x) * 100.0 * BG_SCALE;\n  vec4 idgv = getIDGV(uv, scale);\n  vec2 id = idgv.xy;\n  vec2 gv = idgv.zw;\n  float n = N21b(id);\n  float transFreq = BASE_TWINKLE * n + 0.01;\n  t -= 3877.627 * n;\n  float transProgress = fract(t * transFreq);\n  float transId = floor(t * transFreq);\n  float lastIdOffset = N21b(vec2(n, transId - 1.0));\n  float idOffset = N21b(vec2(n, transId));\n  float nextIdOffset = N21b(vec2(n, transId + 1.0));\n  float noiseThresh = STAR_RARITY;\n  float noise = S(1.0, 0.0, transProgress) * S(noiseThresh, 1.0, N21b(id + lastIdOffset));\n  noise += S(noiseThresh, 1.0, N21b(id + idOffset));\n  noise += S(0.0, 1.0, transProgress) * S(noiseThresh, 1.0, N21b(id + nextIdOffset));\n  return S(0.0, 0.2, minOf(0.5 - abs(gv))) * (noise * S(0.1, 2.0, minDS));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (gl_FragCoord.xy - .5 * u_resolution.xy) / u_resolution.y;\n  vec2 mouse = (u_mouse.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  float t = u_time / 9.0;\n  vec3 col = BLACK;\n  uv *= 4.0;\n\n  float fw = max(fwidth(uv.x), fwidth(uv.y));\n\n  float grow_shrink = GROW_SHRINK * sin(t * PI) * 0.1 + 0.9;\n\n  vec3 s = vec3(1.0, 1.0, 1.0) * grow_shrink;\n  vec3 p = vec3(uv, - 4.0);\n\n  mat3 boxTrans = rot3XY(mouse.x * TAU / 2.0, 1) * rot3XY(mouse.y * TAU / 2.0, 2);\n  boxTrans *= rot3XY(t * 13.0 / 17.0 * ROTATE_IDLE + PI / 3.0, 0) * rot3XY(t * 13.0 / 11.0 * ROTATE_IDLE - 17.0 * PI / 7.0, 2);\n\n  // raymarch over the orthogonal scene\n  vec2 sc = sinCos(vec2(t));\n  vec3 rd = normalize(vec3(0.0, 0.0, 1.0));\n  float d = 0.0, dS = 999.0, minDS = 999.0, edgeDist;\n  float steps = 0.0;\n  for(int i = 0; i < 1000; i ++ ) {\n    steps ++ ;\n    edgeDist = sdBoxEdge(p * boxTrans, s) - 0.01;\n    dS = edgeDist;\n    //dS = min(edgeDist, sdBox(p*boxTrans, s));\n    minDS = min(minDS, dS);\n    p = p + dS * rd;\n    d += dS;\n    if (dS < 0.0001 || d > 100.0)break;\n  }\n\n  float noise = mkNoise(uv * grow_shrink, t, minDS);\n  col += noise;\n  col += S(0.01, 0.0, minDS) * WHITE;\n  col += S(0.023, 0.005, minDS) * rainbow(uv, u_time + 2.0);\n\n  gl_FragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 486, 524, 656], [659, 659, 694, 694, 785], [788, 788, 808, 808, 964], [966, 966, 987, 987, 1013], [1015, 1015, 1040, 1040, 1079], [1081, 1133, 1169, 1169, 1416], [1419, 1419, 1454, 1454, 1542], [1556, 1556, 1595, 1595, 1649], [1651, 1651, 1687, 1687, 1780], [1782, 1782, 1828, 1828, 2618], [2620, 2620, 2675, 2675, 3939]], "test": "valid"}
{"id": "7tBXWR", "name": "double spiral limited", "author": "TLC123", "description": "double spiral with limitations.\nradii must sum to distance between centers\nTried to solve limitation with quadratic curve \"middle\" piece but  failed to get perfect tangens\nOnly support Archimedean spiral for now, expand to log and hyp later\n", "tags": ["2d", "sdf", "spiral", "distance", "saffronbun"], "likes": 9, "viewed": 51, "published": "Public", "date": "1627403864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"double spiral \" by TLC123. https://shadertoy.com/view/ft2SRh\n// 2021-07-27 16:21:03\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n \nfloat  smin( float a, float b,float k )\n{\n    float h =  clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 ) ;\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n  \n\nfloat f(vec2 p,vec2 from ,vec2 to,float r0,float r1,float t0,float t1,float e0,float e1)\n{\nvec2 vec=normalize(to-from); // center to center vector\n \nfloat av= atan(vec.x,vec.y) ;\n    float c = cos(-av+3.1415);\n    float s = sin(-av+3.1415);\n    mat2 rot =mat2(c,s,-s,c);\nvec2 l0=(p-from)* rot;\nvec2 l1=(p-to)* rot;\n\nfloat a0= atan(l0.x,l0.y)/(3.1415*2.) ;\nfloat a1= atan(-l1.x,-l1.y)/(3.1415*2.) ;\n\nfloat step0=.5+( a0 ) ;\nfloat step1=.5+ a1 ;\n\nfloat d=1./0.;\n \nfor (float i=fract(t0);i<= (t0);i++){\n d=min(d,abs(length  (p-from)-(( (i)-step0)/t0)*r0 ));\n}\nfor (float i=fract(t1);i<= (t1);i++){\n d=min(d,abs(length  (p-to  )-(( (i)-step1)/t1)*r1 ));\n}\n \n // the litte knob at centers\nd=smin(d,length(from-p)-r0*0.025,r0*0.1);\nd=smin(d,length(to-p)-r1*0.025,r1*0.1);\n \nreturn d;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p =   (fragCoord*2.0-iResolution.xy)/iResolution.y;\n     \n     \n    // driver code \n \tvec2 r;\n    vec2 from = .5*vec2(-sin (iTime*0.4365  ), cos(iTime*0.3355  ));\n    vec2 to = .5*vec2(1, cos(iTime*0.8647   )*.9);\n  \n    r.x= length(from-to)- abs(sin(iTime*0.46436   ))*length(from-to)*.5-length(from-to)*.25 ;\n    r.y =length(from-to)-r.x;\n  \n    vec2 t =  3.+(2.*vec2(sin(iTime*0.513546   ), cos(iTime*0.96764   ) ));\n    t=clamp(t,.5,2.);\n  \n    // distance\n    float d=f(p,from ,to,r.x,r.y,t.x,t.y,1.,1.);\n\n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n \n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 214, 214, 309], [314, 314, 404, 404, 1094], [1096, 1096, 1153, 1189, 1946]], "test": "valid"}
{"id": "7tfSR7", "name": "City View (Twitch)", "author": "rimina", "description": "Here is the shader I did on my Twitch live coding stream on 2nd of July 2021. I added some quick camera run which goes to static scene after 2min. So start over if you want to see some flyby.", "tags": ["sdf", "twitch"], "likes": 3, "viewed": 52, "published": "Public", "date": "1625334413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float E = 0.001;\nconst float FAR = 100.0;\nconst int STEPS = 64;\n\nint M = 0;\n\nconst vec3 FOG_COLOR = vec3(0.6, 0.7, 0.8);\nconst vec3 LIGHT_COLOR = vec3(0.9, 0.9, 0.7);\n\nfloat plane(vec3 p, vec3 n, float d){\n  return dot(p, n) + d;\n}\n\nfloat sphere(vec3 p, float r){\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 b){\n  vec3 d = abs(p)-b;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat cosNoise(vec2 p){\n  return 0.5*(sin(p.x) + sin(p.y));\n}\n\nfloat scene(vec3 p){\n  \n  vec3 pp = p;\n  vec3 ppp = p;\n  \n  //For the plane distortion I have taken some inspiration from here:\n  //https://www.shadertoy.com/view/XlSSzK\n  float h = 0.0;\n  vec2 q = p.xz*0.5;\n  float s = 0.5;\n\n  const mat2 m2 = mat2(1.,-1.,1., 0.5);\n  \n  float a = iTime;\n  float b = 0.0;\n  if(p.z > -30.0){\n\n    for(int i = 0; i < 6; ++i){\n      h += s*cosNoise(q+a); \n      q = m2*q*0.8; \n      q += vec2(5.41+b+cos(a+b),3.13+b+sin(a+b));\n      s *= 0.52 + 0.2*h;\n    }\n    h *= 1.2;\n  }\n  \n  //maa = ground\n  float maa = plane(p, vec3(0.0, 1.0, 0.0), 0.0)-h;\n  //pallo = ball\n  float pallo = sphere(p-vec3(0.0, 1.0, -10.0), 1.5);\n  \n  vec2 offset = vec2(40.0, 20.0);\n  vec2 offset2 = vec2(25.0, 40.0);\n  \n  float building = 100.0;\n  \n  vec2 id = floor((p.xz + offset*0.5)/offset);\n  pp.xz = mod(p.xz + offset*0.5, offset) - offset*0.5;\n  \n  vec2 id2 = floor((p.xz + offset2*0.5)/offset2);\n  ppp.xz = mod(p.xz + offset2*0.5, offset2) - offset2*0.5;\n  \n  if(p.z < -30.0){\n    building = box(pp, vec3(10.0, 20.0-cosNoise(id)*5.0, 6.0));\n    building = min(building, box(ppp, vec3(7.0, 30.0-cosNoise(id2)*10.0, 4.0)));\n  }\n  float guard = -box(pp, vec3(20.0, 50.0, 10.0));\n  guard = abs(guard) + offset.x * 0.1;\n  \n  float guard2 = -box(ppp, vec3(10.0, 50.0, 20.0));\n  guard2 = abs(guard2) + offset2.y * 0.1;\n  \n  guard = min(guard, guard2);\n\n\n  \n  if(maa < pallo && maa < building){\n    M = 1;\n  }\n  else if(building < pallo && building < maa){\n    M = 2;\n  }\n  else{\n    M = 0;\n  }\n  \n  return min(maa, min(pallo, min(guard , building)));\n}\n\n//ro = ray origin, rd = ray direction\nfloat march(vec3 ro, vec3 rd){\n  float t = E;\n  //p = position\n  vec3 p = ro;\n  for(int i = 0; i < STEPS; ++i){\n    float d = scene(p);\n    t += d;\n    p = ro + rd * t;\n    \n    if(d < E || t > FAR){\n      break;\n    }\n  }\n  \n  return t;\n}\n\nvec3 normals(vec3 p){\n  vec3 e = vec3(E, 0.0, 0.0);\n  return normalize(vec3(\n    scene(p + e.xyy) - scene(p - e.xyy),\n    scene(p + e.yxy) - scene(p - e.yxy),\n    scene(p + e.yyx) - scene(p - e.yyx)\n  ));\n}\n\nvec3 shade(vec3 rd, vec3 p, vec3 n, vec3 ld){\n  float l = max(dot(n, ld), 0.0);\n  float a = max(dot(reflect(ld, n), rd), 0.0);\n  float shiny = 20.0;\n  vec3 col = vec3(0.1, 0.3, 0.35);\n  vec3 col2 = vec3(0.7, 0.9, 1.0);\n  if(p.z < -30.0){\n    col = vec3(0.5, 0.8, 0.2);\n    col2 = vec3(0.5, 1.0, 0.4);\n    shiny = 1.0;\n  }\n  \n  if(M == 0){\n    col = col.rrg;\n    shiny = 2.0;\n  }\n  else if( M == 2){\n    col = vec3(1.0, 0.0, 1.0);\n    col2 = col + 0.2;\n    shiny = 2.0;\n  }\n  else{\n  }\n  \n  float s = pow(a, shiny);\n  \n  return l * col*0.4 + s * col2*0.6;\n  \n}\n\n//http://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld){\n  float dist = length(p-ro);\n\tfloat sunAmount = max( dot(rd, -ld), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.035);\n\tvec3  fogColor = mix(FOG_COLOR, LIGHT_COLOR, pow(sunAmount, 4.0));\n  return mix(col, fogColor, fogAmount);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = -1.0 + uv*2.0;\n    uv *= vec2(iResolution.x / iResolution.y, 1);\n\n    //ray origin\n    vec3 ro = vec3(15.0*smoothstep(0.0, 50.0, iTime), 10.0+30.5*smoothstep(0.0, 60.0, iTime), 30.0-80.0*smoothstep(0.0, 60.0, iTime));\n    //ray target\n    vec3 rt = vec3(15.0*smoothstep(0.0, 60.0, iTime), 30.0*smoothstep(0.0, 60.0, iTime), ro.z-20.0);\n    \n    if(iTime >= 60.00 && iTime < 120.00){\n        ro = vec3(15.0, 40.5, -50.0-(iTime-50.0));\n        rt = vec3(15.0, 30.0, -70.0 + 71.0*smoothstep(60.0, 70.0, iTime));\n        \n    }\n    else if(iTime >= 120.00){\n        ro = vec3(15.0, 30.0, 10.0);\n        rt = vec3(15.0, 18.0, -10.0);\n    }\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x, y, z) * vec3(uv, radians(60.0)));\n\n    vec3 col = FOG_COLOR;\n    float t = march(ro, rd);\n\n    vec3 p = ro + rd *t;\n    vec3 n = normals(p);\n\n    vec3 lp = vec3(30.0, -50.0, 100.0);\n    vec3 lt = ro;\n    vec3 ld = normalize(lt-lp);\n\n    if(t < FAR){\n        col = shade(rd, p, n, ld);\n\n        if((M == 1 && p.z > -30.0) || M == 2){\n            vec3 refd = reflect(rd, n);\n            vec3 refo = p + 2.0*E*n;\n            t = march(refo, refd);\n            vec3 pr = refo + refd * t;\n            if(t < FAR){\n                n = normals(pr);\n                col += shade(refd, pr, n, ld);\n                col *= 0.5;\n            }\n        }\n    }\n    col = fog(col, p, ro, rd, -ld);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 211, 211, 237], [239, 239, 269, 269, 293], [295, 295, 321, 321, 410], [412, 412, 435, 435, 473], [475, 475, 495, 495, 2032], [2034, 2072, 2102, 2102, 2311], [2313, 2313, 2334, 2334, 2519], [2521, 2521, 2566, 2566, 3080], [3082, 3135, 3189, 3189, 3417], [3420, 3420, 3477, 3527, 5109]], "test": "valid"}
{"id": "7tfSWr", "name": "RippleWave", "author": "ZenithGD", "description": "My first GLSL shader!", "tags": ["trippy", "psychodelic"], "likes": 4, "viewed": 123, "published": "Public API", "date": "1625450956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define sides 9.0\n\nfloat ripple(float d)\n{\n    return d / 3.0 + sin(30.0 * d * d - 5.0 * (iTime + sin(6.0 * iTime) / 10.0) ) / 2.0 * sqrt(d * d + 1.0) + 0.5;\n}\n\nfloat angle(vec2 v)\n{\n    return acos(dot(normalize(v),vec2(0.0, 1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angleNorm = fract(angle(fragCoord / iResolution.xy - vec2(0.5, 0.5)) / ( 2.0 * PI ));\n    \n    float d = sin(2.0 * sides * PI * angleNorm + PI/2.0)/(50.0 * (sin(2.0 * iTime) + 2.0)) + 1.0 - distance(vec2(0.5, 0.5), vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y)); \n                  ;\n    \n    float r = ripple(d);\n    \n    // Output to screen\n    vec4 nv   = vec4(abs(sin(iTime + PI / 4.0)) * r * d * d + abs(sin(iTime)) / 2.0, \n                     abs(cos(iTime + PI / 2.0)) * r * (1.0 - d * d / 2.0),\n                     abs(cos(iTime + PI / 4.0)) * r * (1.0 - d),\n                     1.0);\n    fragColor = nv;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfSWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 64, 64, 181], [183, 183, 204, 204, 257], [259, 259, 316, 316, 961]], "test": "valid"}
{"id": "7tjGDD", "name": "Bouncing Ball [116 chars]", "author": "Xor", "description": "Boing", "tags": ["bounce", "golf"], "likes": 4, "viewed": 74, "published": "Public", "date": "1625278227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 I)\n{\n    vec2 R = iResolution.xy-98.;\n    O += 49.-length(I-abs(mod(iTime*R/R.y/3.,2.)*R-R)-49.)-O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjGDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 133]], "test": "valid"}
{"id": "7tjSzw", "name": "Intersection Line Segments", "author": "Yusef28", "description": "Just a quick exploration with lot's of comments:\n[url]http://blog.jliszka.org/2013/10/24/exact-numeric-nth-derivatives[/url]\nand here:\n[url]http://blog.sigfpe.com/2005/07/automatic-differentiation.html[/url]", "tags": ["ad", "autodiff", "autodiff", "automaticdifferentiation", "dualnumbers", "autodifferentiation", "dn"], "likes": 8, "viewed": 65, "published": "Public", "date": "1627616854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 26-07-2021                                  //\n// Status: On Going                                        //\n// Topic: Line Segment Intersection                        //\n// Sources: http://paulbourke.net/geometry                 //\n// Listening to: Andromida - Hellscape (FULL ALBUM STREAM) //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n#define line1Col vec3(1.,.2,.5)\n#define line2Col vec3(1.,.3,.3)\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  BACKGROUND GRID DESIGN             //\n      //                                   //\n      /////////////////////////////////////\n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    //graph background\n    vec3 col = vec3(0.1);\n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  LINE INTERSECTION CALCULATIONS     //\n      //                                   //\n      /////////////////////////////////////\n      \n    //Line Points\n    vec2 A1 = vec2(-3.4+sin(iTime),-2.4+sin(iTime+0.5));\n    vec2 B1 = vec2(3.4+sin(iTime+4.),3.4+sin(iTime+2.));\n    \n    vec2 A2 = vec2(-3.3+sin(iTime+1.4),-3.6+sin(iTime+3.));\n    vec2 B2 = vec2(2.3+sin(iTime+0.2),3.1+sin(iTime+0.3));\n    \n    //For line segments we want to create a linear interpolation\n    // x1 + s(x2-x1) is how far we are on the x of a line\n    // same for y, and that's one line. We do that for 2 line and\n    //we get this expression\n    \n    // point1 = (A1.x + s*(B1.x-A1.x)), (A1.y + s*(B1.y-A1.y))\n    // point2 = (A2.x + t*(B2.x-A2.x)), (A2.y + t*(B2.y-A2.y))\n    //the way this is structured differs from the line-line intersection\n    //in that we know the x and y values. The only unknowns are s and t\n    //so to find them we need to set up two equations.\n    //one that means x1 = x2 with s and t as unknowns\n    //and one where y1  = y2 with s and t as unknowns.\n    \n    //we turn that into a linear equation \n    //the point where these two lines is the samw is the point where\n    //the left sides are equal:\n    //(A1x + s(B1x-A1x)) = (A2x + t(B2x-A2x))\n    //as well as the right\n    //(A1y + s(B1y-A1y)) = (A2y + t(B2y-A2y))\n    \n    //so now we are basically in the same position as\n    //with the basic line-line intersection, but we'll want to\n    //have all the additions solved at this point and any\n    //hanging constants are basically the b's in y = mx + b\n    \n    //instead of y,x we have s,t but otherwise it's the same\n    //so we solve and substitute\n    //for x's \n    //first I'll take all those coefficients from above and \n    //put them in smaller containers\n    \n    float B = B2.x-A2.x;\n    float A = B1.x-A1.x;\n    \n    float E = B2.y-A2.y;\n    float D = B1.y-A1.y;\n    \n    float C = A1.x-A2.x;\n    float F = A1.y-A2.y;\n    \n    //there nice and neat\n    // s(A) - t(B) = C;// <- (A1x + s(B1x-A1x)) = (A2x + t(B2x-A2x))\n    // s(D) - t(E) = F;// <- (A1y + s(B1y-A1y)) = (A2y + t(B2y-A2y))\n    \n    //using paper...\n    //getting frustrated...\n    //going to sleep...\n    //waking up and trying again...\n    //http://paulbourke.net/geometry/\n    //trying the obviouse way I ignored for the last few hours...\n    float s = (B*F-C*E)/(A*E-D*B);\n    float t = (A*F-D*C)/(A*E-D*B);\n    //I was trying to sub the answer for s into \n    //one of the neater formulas above but something wasn't working\n    //so I finally went with the basic t solution.\n    \n    //subbing back into the line equations\n    //these are both the same point but on two different lines\n    vec2 pointOnLine1 = vec2(A1.x + s*(B1.x-A1.x), A1.y + s*(B1.y-A1.y));\n    vec2 pointOnLine2 = vec2(A2.x + t*(B2.x-A2.x), A2.y + t*(B2.y-A2.y));\n   \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////        DRAWING EVERYTHING           //\n      //                                   //\n      /////////////////////////////////////\n    \n        \n    //line 1\n    float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));\n    col = mix(col, vec3(1.,.2,.5), f);//0.5\n    \n    //line 2\n    f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A2, B2, uv)));\n    col = mix(col, vec3(1.,.3,.3), f);\n    \n    \n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-A1)-0.02);\n    col = mix(col, line1Col, f);\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-B1)-0.02);\n    col = mix(col, line1Col, f);\n    \n    //segment end points line 2\n    f = 1.-smoothstep(0.03,0.08,length(uv-A2)-0.02);\n    col = mix(col, line2Col, f);\n    //segment end points line 2\n    f = 1.-smoothstep(0.03,0.08,length(uv-B2)-0.02);\n    col = mix(col, line2Col, f);\n    \n    \n    // if s and t are both between 0. and 1. they are\n    // valid for both the linear interpolations we need.\n    // so show the intersection point.\n    if((s >= 0. && s <= 1.) && (t >= 0. && t <= 1.)){\n    \n    //intersection\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv-pointOnLine2)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-pointOnLine2)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    \n    }\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n     \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}\n", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[687, 687, 728, 728, 930], [932, 932, 989, 1041, 7336]], "test": "error"}
{"id": "7tjXRh", "name": "3D Palette Dithering", "author": "ENDESGA", "description": "using 3D cubic noise for the dither", "tags": ["raymarching", "dither", "c64", "palette"], "likes": 2, "viewed": 303, "published": "Public API", "date": "1627125488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DITHER\n#define AUTO_MODE\n#define DOWN_SCALE 4.0\n\n#define MAX_STEPS 777\n#define MIN_DIST 0.002\n#define NORMAL_SMOOTHNESS 0.1\n#define PI 3.14159265359\n\n#define PALETTE_SIZE 16\n#define SUB_PALETTE_SIZE 7\n\n#define RGB(r,g,b) (vec3(r,g,b) / 255.0)\n\nvec3 palette[PALETTE_SIZE];\nvec3 subPalette[SUB_PALETTE_SIZE];\n\n//Initalizes the color palette.\nvoid InitPalette()\n{\n    //16-Color C64 color palette.\n\tpalette = vec3[](\n        RGB(  0,  0,  0),\n        RGB(255,255,255),\n        RGB(152, 75, 67),\n        RGB(121,193,200),\t\n        RGB(155, 81,165),\n        RGB(104,174, 92),\n        RGB( 62, 49,162),\n        RGB(201,214,132),\t\n        RGB(155,103, 57),\n        RGB(106, 84,  0),\n        RGB(195,123,117),\n        RGB( 85, 85, 85),\t\n        RGB(138,138,138),\n        RGB(163,229,153),\n        RGB(138,123,206),\n        RGB(173,173,173)\n\t);\n    \n    //8-Color metalic-like sub palette.\n\tsubPalette = vec3[](\n        RGB(  0,  0,  0),\n        \n        RGB( 32,  0,127),\n        RGB(127,  0, 64),\n        \n        RGB(255,  0, 64),\n        \n        RGB(127,127,127),\n        RGB(  0,255,196),\n        \n        RGB(255,255,255)\n\t);\n\t\n}\n\nint _HEPT32_X = 0x77777777, _HEPT32_Y = 0x77777777, _HEPT32_Z = 0x77777777;\n\nuint hept32(int x, int y, int z) {\t\n    x = (x * _HEPT32_X) - (~x * 0x77777777) - ~(x * _HEPT32_Y);\n\ty = (y * _HEPT32_Y) - (~y * 0x77777777) - ~(y * _HEPT32_Z);\n\tz = (z * _HEPT32_Z) - (~z * 0x77777777) - ~(z * _HEPT32_X);\n\treturn uint(~(~(~x * y * z) * ~(x * ~y * z) * ~(x * y * ~z)));\n    //return uint(z) ^ (uint(z) >> 16);\n}\n\nvoid hept32_seed(int seed) {\n    // multi-layer seed expansion and extraction\n\tseed = int((hept32(seed,seed,seed) * 0x77777777u) - 0x77777777u);\n\t_HEPT32_X = int((hept32(0x77777777,seed,seed) * uint(seed)) - uint(seed));\n\t_HEPT32_Y = int((hept32(seed,0x77777777,seed) * uint(seed)) - uint(seed));\n\t_HEPT32_Z = int((hept32(seed,seed,0x77777777) * uint(seed)) - uint(seed));\n}\n\nfloat noise(int x, int y, int z) {\n    //int x = int(v.x), y = int(v.y), z = int(7.0);\n    \n    return floor((float(hept32((x),(y),(z))) * 2.32830644e-10) + 0.5);\n}\n\nfloat tetra_mean(vec3 v) {\n    \n    int x = int(v.x), y = int(v.y), z = int(v.z);\n    \n    //return noise(x,y,z);\n    \n    float n = (\n        ((\n            noise(x-1,y,z) + noise(x+1,y,z) +\n            noise(x,y-1,z) + noise(x,y+1,z) +\n            noise(x,y,z-1) + noise(x,y,z+1)\n            ) / 6.0) +\n        noise(x,y,z)\n    ) * 0.5;\n    return ((n * n) + n) * 0.5;\n}\n\nfloat interpolate(float a, float b, float c, float d, float x) {\n    float p = (d - c) - (a - b);\n    \n    return x * (x * (x * p + ((a - b) - p)) + (c - a)) + b;\n}\n\nfloat sampleX(vec3 at) {\n    float floored = floor(at.x);\n    \n    return interpolate(\n        tetra_mean(vec3(floored - 1.0, at.yz)),\n        tetra_mean(vec3(floored, at.yz)),\n        tetra_mean(vec3(floored + 1.0, at.yz)),\n        tetra_mean(vec3(floored + 2.0, at.yz)),\n    \tat.x - floored);\n}\n\nfloat sampleY(vec3 at) {\n    float floored = floor(at.y);\n    \n    return interpolate(\n        sampleX(vec3(at.x, floored - 1.0, at.z)),\n        sampleX(vec3(at.x, floored, at.z)),\n        sampleX(vec3(at.x, floored + 1.0, at.z)),\n        sampleX(vec3(at.x, floored + 2.0, at.z)),\n        at.y - floored);\n}\n\nfloat cubic(vec3 at) {\n    float floored = floor(at.z);\n    \n    float n = interpolate(\n        sampleY(vec3(at.xy, floored - 1.0)),\n        sampleY(vec3(at.xy, floored)),\n        sampleY(vec3(at.xy, floored + 1.0)),\n        sampleY(vec3(at.xy, floored + 2.0)),\n        at.z - floored);\n        \n        return clamp(n * n,0.0,1.0);\n}\n\n//Blends the nearest two palette colors with dithering.\nvec3 GetDitheredPalette(float x,vec3 p)\n{\n\tfloat idx = clamp(x,0.0,1.0)*float(SUB_PALETTE_SIZE-1);\n\t\n\tvec3 c1 = vec3(0);\n\tvec3 c2 = vec3(0);\n\t\n\tc1 = subPalette[int(idx)];\n    c2 = subPalette[int(idx) + 1];\n    \n    #ifdef DITHER\n    \tfloat dith = cubic(p);\n    \tfloat mixAmt = float(fract(idx) > dith);\n    #else\n    \tfloat mixAmt = fract(idx);\n    #endif\n    \n\treturn mix(c1,c2,mixAmt);\n}\n\n//Returns a 2D rotation matrix for the given angle.\nmat2 Rotate(float angle)\n{\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));   \n}\n\n//Distance field functions & operations by iq. (http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\nfloat opU( float d1, float d2 )\n{\n    float k = 0.5;\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n//Scene definition/distance function.\nfloat Scene(vec3 pos)\n{\n    float map = -sdSphere(pos, 24.0);\n    \n    vec3 rep = opRep(pos - 2.0, vec3(4.0));\n    \n    map = opU(map, opI(sdBox(pos, vec3(5.5)), sdSphere(rep, 1.0)));\n    \n    vec3 gSize = vec3(0, 0, 0.25);\n    \n    float grid = opU(opU(sdCylinder(rep.xyz, gSize), sdCylinder(rep.xzy, gSize)), sdCylinder(rep.zxy, gSize));\n     \n    grid = opI(sdBox(pos,vec3(4.5)),grid);\n    \n    map = opU(map, grid);\n    \n    return map;\n}\n\n//Returns the normal of the surface at the given position.\nvec3 Normal(vec3 pos)\n{\n\tvec3 offset = vec3(NORMAL_SMOOTHNESS, 0, 0);\n    \n    vec3 normal = vec3\n    (\n        Scene(pos - offset.xyz) - Scene(pos + offset.xyz),\n        Scene(pos - offset.zxy) - Scene(pos + offset.zxy),\n        Scene(pos - offset.yzx) - Scene(pos + offset.yzx)\n    );\n    \n    return normalize(normal);\n}\n\n//Marches a ray defined by the origin and direction and returns the hit position.\nvec3 RayMarch(vec3 origin,vec3 direction)\n{\n    float hitDist = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Scene(origin + direction * hitDist);\n        \n        hitDist += sceneDist;\n        \n        if(sceneDist < MIN_DIST)\n        {\n            break;\n        }\n    }\n    \n    return origin + direction * hitDist;\n}\n\n//Scene shading.\nvec3 Shade(vec3 position, vec3 normal, vec3 rayOrigin,vec3 rayDirection,vec2 pixel)\n{\n    vec3 color = vec3(0);\n    \n    float ang = iTime * 2.0;\n    \n    vec3 lightPos = vec3(cos(ang), cos(ang*2.0), sin(ang)) * 2.0;  \n    \n    //Normal shading\n\tfloat shade = 0.4 * max(0.0, dot(normal, normalize(-lightPos)));\n    \n    //Specular highlight\n    shade += 0.6 * max(0.0, dot(-reflect(normalize(position - lightPos), normal), rayDirection));\n    \n    //Linear falloff\n    shade *= (16.0-distance(position, lightPos))/16.0,\n    \n    //Apply palette\n    color = GetDitheredPalette(shade, position * 7.777);\n\n    //color = mix(color, vec3(0.1), step(22.0, length(position)));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    hept32_seed(7777777);\n\n    InitPalette();\n    \n    vec2 aspect = iResolution.xy / iResolution.y;\n    \n    fragCoord = floor(fragCoord / DOWN_SCALE) * DOWN_SCALE;\n    \n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n    \n    vec2 camAngle = vec2(0);\n    \n    #ifdef AUTO_MODE\n\t\tcamAngle.x = (PI * (-1.0 / 8.0) * sin(iTime * 0.5)) * 0.5;\n    \tcamAngle.y = (-iTime) * 0.5;\n    #else\n        camAngle.x = PI * mouse.y + PI / 2.0;\n        camAngle.x += PI / 3.0;\n\n        camAngle.y = 2.0 * PI * -mouse.x;\n        camAngle.y += PI;\n    #endif\n    \n    vec3 rayOrigin = vec3(0 , 0, -16.0);\n    vec3 rayDirection = normalize(vec3(uv - aspect / 2.0, 1.0));\n    \n    mat2 rotateX = Rotate(camAngle.x);\n    mat2 rotateY = Rotate(camAngle.y);\n    \n    //Transform ray origin and direction\n    rayOrigin.yz *= rotateX;\n    rayOrigin.xz *= rotateY;\n    rayDirection.yz *= rotateX;\n    rayDirection.xz *= rotateY;\n    \n    vec3 scenePosition = RayMarch(rayOrigin, rayDirection);\n    \n    vec3 outColor = Shade(scenePosition,Normal(scenePosition), rayOrigin, rayDirection, fragCoord / DOWN_SCALE);\n    \n    //Palette preview\n    if(uv.x < 0.05) \n    {\n        outColor = GetDitheredPalette(uv.y, vec3(fragCoord / DOWN_SCALE,7) * 0.777);\n    }\n    \n\tfragColor = vec4(outColor, 1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1214, 1214, 1248, 1248, 1541], [1543, 1543, 1571, 1620, 1917], [2085, 2085, 2111, 2111, 2457], [2459, 2459, 2523, 2523, 2623], [2625, 2625, 2649, 2649, 2921], [2923, 2923, 2947, 2947, 3230], [3232, 3232, 3254, 3254, 3566], [3568, 3624, 3665, 3665, 4013], [4015, 4067, 4093, 4093, 4161], [4163, 4279, 4312, 4312, 4407], [4409, 4409, 4442, 4442, 4468], [4470, 4470, 4503, 4503, 4528], [4530, 4530, 4560, 4560, 4605], [4607, 4607, 4642, 4642, 4666], [4668, 4668, 4699, 4699, 4795], [4797, 4797, 4833, 4833, 4867], [4869, 4907, 4930, 4930, 5349], [5351, 5410, 5433, 5433, 5733], [5735, 5817, 5860, 5860, 6170], [6172, 6189, 6274, 6274, 6883], [6885, 6885, 6942, 6942, 8265]], "test": "valid"}
{"id": "7tjXWD", "name": "3D hand sketch", "author": "yasuo", "description": "no nails", "tags": ["hand"], "likes": 13, "viewed": 161, "published": "Public API", "date": "1627740653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 128\n#define MAX_DIST 128.\n#define SURF_DIST .0001\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Box(p,s) max(max(abs(p).x-s.x,abs(p).y-s.y),abs(p).z-s.z)\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n#define MATERIAL_DIFFUSE0 0\n#define MATERIAL_DIFFUSE1 1\n#define MATERIAL_REFLECT 2\n\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 combine(vec2 val1, vec2 val2){\n    vec2 res1 = val1;\n    vec2 res2 = val2;\n    return (val1.x < val2.x)?res1:res2;\n}\n\n// by iq https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5*(b - a)/k, .0, 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// by iq https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n    return length(max(abs(p)-b, .0)) -r;\n}\n\n// by reinder https://www.shadertoy.com/view/4tdcWS\n// This one is super fast.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, const float r0, const float r1) {\n    vec3 d = b -a;\n    float h = length(d);\n    d = normalize(d);\n    float t=clamp(dot(p-a, d), 0., h);\n    return distance(a+t*d, p) -mix(r0, r1, t/h);\n}\n\nfloat dHand(vec3 p){\n    vec3 prevP = p;\n    \n    const float k = 1.1;\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(0.0);    \n    q.y = p.y;\n    q.xz=m*p.xz;\n    \n    float d = udRoundBox(q-vec3(0.01,0.05,0.0),vec3(0.1,0.05,0.001),0.04);\n    d = smin(d,udRoundBox(p-vec3(0.005,-0.02,0.01),vec3(0.09,0.02,0.0001),0.035),0.03);\n    d = smin(d,udRoundBox(p-vec3(0.0,-0.1,0.0),vec3(0.065,0.02,0.0001),0.035),0.03);\n    \n    // palm\n    float d2 = sdCapsule(q,vec3(0.13,0.05,0.0425),vec3(-0.03,0.09,0.045),0.005,0.001);\n    d = smax(d2,d,0.01);\n    d2 = sdCapsule(q,vec3(0.03,0.03,0.05),vec3(-0.13,0.06,0.0425),0.001,0.005);\n    d = smax(d2,d,0.01);\n    d2 = sdCapsule(q,vec3(0.00,-0.1,0.045),vec3(-0.04,0.01,0.06),0.005,0.001);\n    d = smax(d2,d,0.01);\n    \n    p = prevP;\n    \n    // pinky\n    d = smin(d,sdCapsule(p,vec3(0.13,0.15,0.0),vec3(0.15,0.18,0.0),0.035,0.03),0.03);\n    d = smin(d,sdCapsule(p,vec3(0.15,0.18,0.0),vec3(0.165,0.22,0.01),0.03,0.027),0.005);\n    d = smin(d,sdCapsule(p,vec3(0.165,0.22,0.01),vec3(0.175,0.26,0.03),0.028,0.025),0.005);\n    \n    // ring\n    d = smin(d,sdCapsule(p,vec3(0.06,0.15,0.0),vec3(0.07,0.21,0.0),0.035,0.03),0.01);\n    d = smin(d,sdCapsule(p,vec3(0.07,0.21,0.0),vec3(0.085,0.27,0.01),0.03,0.027),0.005);\n    d = smin(d,sdCapsule(p,vec3(0.085,0.27,0.01),vec3(0.095,0.33,0.03),0.028,0.025),0.005);\n    \n    // middle\n    d = smin(d,sdCapsule(p,vec3(-0.015,0.15,0.0),vec3(-0.015,0.22,-0.01),0.035,0.03),0.02);\n    d = smin(d,sdCapsule(p,vec3(-0.015,0.22,-0.01),vec3(-0.015,0.29,0.00),0.03,0.027),0.005);\n    d = smin(d,sdCapsule(p,vec3(-0.015,0.29,0.00),vec3(-0.015,0.36,0.02),0.028,0.025),0.005);\n    \n    // index\n    d = smin(d,sdCapsule(p,vec3(-0.09,0.15,0.0),vec3(-0.105,0.21,0.0),0.035,0.03),0.03);\n    d = smin(d,sdCapsule(p,vec3(-0.105,0.21,0.0),vec3(-0.12,0.26,0.01),0.03,0.027),0.005);\n    d = smin(d,sdCapsule(p,vec3(-0.12,0.26,0.01),vec3(-0.13,0.32,0.03),0.028,0.025),0.005);   \n    \n    // thumb\n    d = smin(d,sdCapsule(p,vec3(-0.08,-0.03,0.0),vec3(-0.13,0.02,0.0),0.035,0.037),0.035);\n    d = smin(d,sdCapsule(p,vec3(-0.13,0.02,0.0),vec3(-0.17,0.09,0.01),0.037,0.032),0.005);\n    d = smin(d,sdCapsule(p,vec3(-0.17,0.09,0.01),vec3(-0.19,0.15,0.02),0.032,0.03),0.005);\n    \n    // knuckles\n    d = smin(d,sdCapsule(p,vec3(0.12,0.12,-0.027),vec3(0.08,0.0,-0.02),0.01,0.005),0.03);\n    d = smin(d,sdCapsule(p,vec3(0.05,0.13,-0.03),vec3(0.03,0.0,-0.02),0.01,0.005),0.03);\n    d = smin(d,sdCapsule(p,vec3(-0.015,0.13,-0.03),vec3(-0.015,0.0,-0.02),0.01,0.005),0.03);\n    d = smin(d,sdCapsule(p,vec3(-0.09,0.12,-0.03),vec3(-0.07,0.0,-0.02),0.01,0.005),0.03);\n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p.x = abs(p.x);\n    p.x-=0.3;\n    float d = dHand(p);\n    \n    p = prevP;\n    p.y+=0.15;\n    float d2 = Box(p,vec3(1.2,0.01,1.2));\n    \n    vec2 res = vec2(d, MATERIAL_DIFFUSE0);\n    vec2 res2 = vec2(d2, MATERIAL_DIFFUSE1);\n       \n    vec2 model = combine(res,res2);\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n    vec2 dO = vec2(0.0);\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n   \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n   \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n   \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 col) {\n    vec3 lightDir = normalize(vec3(0.8,0.4,0.2));\n    float diff = dot(n,normalize(lightDir))*0.5+0.5;\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    \n    vec3 res = col*(diff);\n    res += col*bounceDiff*0.5;    \n    \n    return res;\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    vec3 r = reflect(rd,n);\n    \n    vec3 col = r;\n    \n    float k = r.y*r.y;\n    col = mix(col,vec3(1.5),k);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \n    vec3 ro = vec3(0, 0, -3.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(10.0));\n    ro.xz *= Rot(-iTime*.5+1.0);\n    \n    #endif\n   \n    vec3 rd = R(uv, ro, vec3(0,0.2,0), 3.0);\n    vec2 d = RayMarch(ro, rd, 1.);\n    vec3 col = vec3(0.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n\n        int mat = int(d.y);\n        if(mat == MATERIAL_DIFFUSE0){\n            float h = hash12(p.xz*5.0)*0.05;\n            col = diffuseMaterial(n,vec3(0.95)+h);\n        } else if(mat == MATERIAL_DIFFUSE1) {\n            p.x = abs(p.x);\n            p.x-=0.3;\n            float fakeShadow = length(p.xz)-0.3;\n            col = diffuseMaterial(n,mix(vec3(0.9),vec3(0.2),S(fakeShadow,-0.5)));\n        } else if(mat == MATERIAL_REFLECT) {\n            col = reflectMaterial(p,rd,n);\n        }\n        \n    }\n   \n    // gamma correction\n    col = pow( col, vec3(0.6545) );\n   \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[794, 813, 835, 835, 952], [954, 954, 989, 989, 1075], [1077, 1158, 1197, 1197, 1291], [1293, 1374, 1417, 1417, 1517], [1519, 1519, 1562, 1562, 1605], [1607, 1686, 1759, 1759, 1915], [1917, 1917, 1937, 1937, 4593], [4595, 4595, 4617, 4617, 4929], [4931, 4931, 4976, 4976, 5239], [5241, 5241, 5265, 5265, 5464], [5466, 5466, 5508, 5508, 5703], [5705, 5705, 5745, 5745, 6005], [6007, 6007, 6054, 6054, 6188], [6190, 6190, 6247, 6247, 7364]], "test": "valid"}
{"id": "7tlSW4", "name": "Light With Object", "author": "oneshade", "description": "Testing in a simple scene with a rotating box. I'm really missing a volumetric shadow! I think that will go on my todo list. Control the light with the mouse.", "tags": ["3d", "illumination", "light", "volumetric", "integration"], "likes": 11, "viewed": 105, "published": "Public", "date": "1625792094", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float getIllumination(in vec3 p, in float k, in float d) {\n    return k / (1.0 + dot(p, p) / (d * d));\n}\n\n// Short range (up to oclluder at t)\nfloat volumeLightPartial(in vec3 ro, in vec3 rd, in float k, in float d, in float t) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(c - b * b), r = b / h;\n    return d * d * k * (atan(t / h + r) - atan(r)) / h;\n}\n\n// Infinite range\nfloat volumeLightFull(in vec3 ro, in vec3 rd, in float k, in float d) {\n    const float rho = 1.57079632679;\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(c - b * b);\n    return d * d * k * (rho - atan(b / h)) / h;\n}\n\nfloat iSphere(in vec3 ro, in vec3 rd, in float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n    float h = sqrt(b * b - c);\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// Modified from https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iBox(in vec3 ro, in vec3 rd, in vec3 boxSize, out vec3 outNormal)  {\n    vec3 n = ro / rd;\n    vec3 k = boxSize / abs(rd);\n    vec3 q = abs(ro) - boxSize;\n    vec3 t1 = -k - n, t2 = +k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return -1.0;\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return mix(tN, tF, step(0.0, -max(q.x, max(q.y, q.z))));\n}\n\n// Camera matrix\nmat3 getCamera(in vec2 viewDir) {\n    vec2 c = cos(viewDir); vec2 s = sin(viewDir);\n    return mat3(       c.x, 0.0,         s.x,  // Right\n                s.x * -s.y, c.y, -c.x * -s.y,  // Up\n                s.x *  c.y, s.y, -c.x *  c.y); // Forward\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    fragColor = vec4(0.0);\n\n    // Camera ray\n    mat3 cam = getCamera(vec2(0.65, 0.0));\n    vec3 ro = vec3(-2.0, 0.0, 4.5);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n\n    // Light control\n    float k = 0.8 + 0.1 * cos(iTime), d = 0.5;\n    vec3 lightColor = vec3(1.0, 0.75, 0.15);\n\n    vec3 lightPos = vec3(0.0);\n    if (iMouse.z > 0.0) {\n        vec3 md = normalize(cam * vec3(mouse, 1.0));\n        lightPos = ro - vec3(md.xy * ro.z / md.z, ro.z);\n    }\n\n    // Box control\n    vec3 boxSize = vec3(1.0), boxNor;//, dummy;\n    vec3 boxPos = vec3(3.0, 0.0, 0.0);\n\n    mat3 boxRot = mat3(1.0); // Identity\n    float c = cos(iTime), s = sin(iTime);\n    boxRot *= mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c); // XZ rotation\n    boxRot *= mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); // YZ rotation\n\n    // Intersect box\n    vec3 roBox = (ro - boxPos) * boxRot;\n    vec3 rdBox = rd * boxRot;\n    float tBox = iBox(roBox, rdBox, boxSize, boxNor);\n\n    if (tBox > 0.0) {\n        vec3 hitPos = ro + rd * tBox;\n        boxNor = boxRot * boxNor;\n\n        // Lighting\n        vec3 lightDir = normalize(lightPos - hitPos);\n        float diff = max(0.0, dot(lightDir, boxNor));\n        float illum = clamp(getIllumination(hitPos - lightPos, k, d), 0.0, 1.0) * diff * 10.0;\n        float scatterLight = volumeLightPartial(ro - lightPos, rd, k, d, tBox);\n        //if (iBox((hitPos + lightDir * 0.001 - boxPos) * boxRot, lightDir * boxRot, boxSize, dummy) > 0.0) illum = 0.0, scatterLight = 0.0;\n\n        float checkers = 0.5 + 0.5 * mod(dot(floor((roBox + rdBox * tBox) * 2.0 + 0.001), vec3(1.0)), 2.0);\n        fragColor.rgb += vec3(1.0, 0.0, 0.0) * checkers * lightColor * illum;\n        fragColor.rgb = mix(fragColor.rgb, lightColor, clamp(scatterLight, 0.0, 1.0));\n    }\n\n    else {\n        fragColor.rgb += volumeLightFull(ro - lightPos, rd, k, d) * lightColor;\n    }\n\n    float tSphere = iSphere(ro - lightPos, rd, 0.1);\n    if (tSphere > 0.0 && (tBox > 0.0 ? (tSphere < tBox) : true)) {\n        fragColor.rgb = 2.0 * lightColor;\n    }\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlSW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 104], [106, 143, 229, 229, 391], [393, 411, 482, 482, 662], [664, 664, 715, 715, 865], [867, 950, 1024, 1024, 1409], [1411, 1428, 1461, 1461, 1680], [1682, 1682, 1737, 1737, 3916]], "test": "valid"}
{"id": "7tlSWS", "name": "[TWITCH] It's a pattern", "author": "Flopine", "description": "A piece made live on Twitch, with absolutely no inspiration ^^\"\"\nYou can watch all my streams here: https://www.twitch.tv/flopine", "tags": ["3d", "raymarching", "animation", "isometric", "live", "twitch"], "likes": 8, "viewed": 97, "published": "Public", "date": "1626460397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.283185\n\n#define time iTime\n#define dt(sp,off) fract((time+off)*sp)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define crep(p,c,l) p=p-c*clamp(round(p/c),-l,l)\n#define hash11(x) fract(sin(x)*1455.2)\n#define hash21(x) fract(sin(dot(x,vec2(12.5,23.4)))*124.2)\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat od (vec3 p, float d)\n{return dot(p,normalize(sign(p)))-d;}\n\nfloat sc (vec3 p, float d)\n{\n    p=abs(p)-d;\n    p=max(p,p.yzx);\n    return min(p.x,min(p.y,p.z));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat g1=0.; vec2 starid;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n\n    vec3 pp = p;\n    float per = 4.;\n    vec2 id = floor(p.xz/per);\n    p.xz = mod(p.xz,per)-per*.5;\n    p.xz *= rot(dt(0.5,id.y)*TAU);\n    p.xy *= rot(dt(0.3,id.x)*TAU);\n\n    p.x -= 1.;\n    float s = mix(od(p,0.25),box(p,vec3(0.4)),0.5);\n    g1 += 0.1/(0.1+s*s);\n\n    p=pp;\n    starid = round(p.xz/per); \n    crep(p.xz,per,4.);\n    float scene = max(-box(p,vec3(0.85)),mix(od(p,0.8),sc(p,0.4),0.7));\n\n    return min(scene,s);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(uv*7.,-50.), \n    rd=vec3(0.,0.,1.),\n    p=ro,\n    col=vec3(0.99),\n    l=normalize(vec3(1.,2.,-3.));\n\n    bool hit=false;\n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if(d<0.001)\n        {\n            hit=true;break;\n        }\n        d *= .9+dither*.05;\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(0.,dot(n,l));\n        float colid = length(starid);\n        col = (mod(colid,2.)<=0.) ? \n              mix(vec3(0.5,0.,0.6),vec3(0.1,0.95,0.99),light):\n              mix(vec3(0.05,0.7,hash11(colid)*0.4),vec3(.8,1.,hash11(colid)),light);\n\n    }\n    col -= g1*.08;\n    col = clamp(col,0.,1.);\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[662, 662, 690, 690, 775], [777, 777, 805, 805, 841], [843, 843, 871, 871, 943], [945, 945, 983, 983, 1022], [1050, 1050, 1070, 1070, 1561], [1563, 1563, 1586, 1586, 1700], [1702, 1702, 1758, 1758, 2583]], "test": "valid"}
{"id": "7tlSWX", "name": "Space Ocean", "author": "HyPeRbLaH", "description": "Mandelbrot, but rotate c around z by an animated angle.", "tags": ["fractal", "waves", "mandelbrot", "ocean"], "likes": 4, "viewed": 55, "published": "Public", "date": "1626715640", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define II 128.0\n#define pi 3.14\n\nvec2 mul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 step(vec2 z, vec2 c, float i)\n{\n    float l = length(c);\n    float t =(l + (iTime + 30.0) * 0.75) * i;\n    vec2 z2 = mul((c - z), vec2(cos(t), sin(t))) + z;\n    return mul(z, z2) + c;\n}\n\nfloat iter(vec2 c, float q)\n{\n    vec2 z = vec2(0, 0);\n    \n    float i = 0.0;\n    \n    for (; i < q; ++i)\n    {\n        z = step(z, c, i / q);\n        if (length(z) > 4.0)\n        {\n            break;\n        }\n    }\n    \n    return i / q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float m = min(iResolution.x, iResolution.y);\n    vec2 uv1 = fragCoord - vec2(-0.25, -0.25);\n    vec2 uv2 = fragCoord - vec2(0.25, -0.25);\n    vec2 uv3 = fragCoord - vec2(0.25, 0.25);\n    vec2 uv4 = fragCoord - vec2(-0.25, 0.25);\n    \n    uv1 = 2.0*(uv1 - 0.5 * iResolution.xy)/m;\n    uv2 = 2.0*(uv2 - 0.5 * iResolution.xy)/m;\n    uv3 = 2.0*(uv3 - 0.5 * iResolution.xy)/m;\n    uv4 = 2.0*(uv4 - 0.5 * iResolution.xy)/m;\n    \n    float theta = pi * 0.5;\n    uv1 = mul(uv1, vec2(cos(theta), sin(theta)));\n    uv2 = mul(uv2, vec2(cos(theta), sin(theta)));\n    uv3 = mul(uv3, vec2(cos(theta), sin(theta)));\n    uv4 = mul(uv4, vec2(cos(theta), sin(theta)));\n    \n    float scale = 16.0;\n    vec2 pos = vec2(-.8, 0.125);\n    \n    \n    uv1 /= scale;\n    uv1 += pos;\n    uv2 /= scale;\n    uv2 += pos;\n    uv3 /= scale;\n    uv3 += pos;\n    uv4 /= scale;\n    uv4 += pos;\n    \n    float c1 = iter(uv1, II);\n    float c2 = iter(uv2, II);\n    float c3 = iter(uv3, II);\n    float c4 = iter(uv4, II);\n    \n    float c = (c1 + c2 + c3 + c4) * 0.25;\n\n    // Output to screen\n    fragColor = vec4(c, c * c - sin(iTime / pi + pi) * 0.1 + 0.1, c * c * c - sin(iTime / 1.414) * 0.1 + 0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlSWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 60, 60, 125], [127, 127, 163, 163, 317], [319, 319, 348, 348, 561], [563, 563, 620, 670, 1848]], "test": "valid"}
{"id": "7tlXR4", "name": "shading with 1 random color (2)", "author": "sympou", "description": "random ball shading again,\nthis time using the hsl color representation format.\nit is less simple, but more balanced and more tweakable.", "tags": ["shadingpalette"], "likes": 4, "viewed": 175, "published": "Public API", "date": "1625323007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float gridSize = 75.;\nconst float sphereSize = 0.92;\nconst float speed = 10.;\n\n//https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsl2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 lightDir = normalize(vec3(cos(iTime)*0.25,0.5,sin(iTime)*0.25));\n    \n    //slowly panning coordinates\n    vec2 uv = (fragCoord+iTime*vec2(2.,1.)*speed)/gridSize;\n\n    //a square that contains the sphere\n    vec2 uv2 = (fract(uv)*2.-1.)/sphereSize;\n    \n    // a method to get sphere normals in orthographic projection\n    // (if d >= 1. then we are not touching the sphere)  \n    float d = dot(uv2,uv2);\n    float z = (d>=1.) ? 0. : sqrt(1.-d);\n    vec3 normals = vec3(uv2,z);\n    \n    //phong reflection model\n    float specular = pow(max(2.*z*dot(lightDir,normals) -lightDir.z, 0.0),20.)*0.25;\n    float diffuse = 0.5 + dot(normals,lightDir)*0.5;\n    \n    vec2 seed = floor(uv);\n    vec3 rnd = hash32(seed);\n    \n    //we create 2 slightly different colors\n    \n    float hue  = rnd.x;\n    float hue2 = rnd.x + 0.25 + fract(rnd.x*99.99)*0.1;\n    \n    float saturation = 0.1 + rnd.z*0.9;\n    \n    float luminosity  = 0.05 + rnd.y*0.5;\n    float luminosity2 = 0.2  + rnd.y*0.5;\n    \n    vec3 colA = hsl2rgb(vec3(hue , saturation, luminosity));\n    vec3 colB = hsl2rgb(vec3(hue2, saturation, luminosity2));\n    \n    vec3 col = mix(colA, colB, diffuse);\n    \n    //light space blending\n    //vec3 col = pow(mix(pow(colA,vec3(2.2)), pow(colB,vec3(2.2)), diffuse),vec3(1./2.2));\n\n    //antialiasing\n    col *= min(15.*z*z,1.);\n    \n    // Output to screen\n    fragColor = vec4(col+specular,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 125, 146, 146, 282], [284, 324, 351, 351, 493], [495, 495, 552, 552, 1961]], "test": "valid"}
{"id": "7tlXRB", "name": "Mandelbrot 001 orbit trap 2", "author": "RiceFields", "description": "Mandelbrot", "tags": ["mandelbrot", "fractals", "orbittrap"], "likes": 7, "viewed": 186, "published": "Public", "date": "1626512075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define B 4.0\n#define N 200\n#define PERIOD 1.0/15.0\n#define LINE vec2(1.0, 1.0)\n#define C_MUL(a,b) vec2(a.x*b.x - a.y*b.y, a.x*b.y+a.y*b.x)\n\nfloat line_trap(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a;\n    vec2 lvec = pa - dot(pa, b) / dot(b, b) * b;\n\treturn dot(lvec, lvec); \n}\n\nfloat trap(vec2 z) {\n    return line_trap(abs(sin(z)), abs(cos(z)), LINE);\n}\n\n\nfloat mandelbrot_pert(vec2 c, vec2 dc) {\n   vec2 z = vec2(.0);\n   vec2 dz = vec2(.0);\n   \n   float dist = 10e5;\n   for(int i = 0; i < N; ++i) {\n     // p(Z) = 2*Z*dz + dz^2 + c \n     dz = C_MUL((2.0*z+dz),dz) + dc;\n     // f(z) = z^2 + c\n     z = C_MUL(z, z) + c; \n     // check if perturbation escapes\n     if( dot(dz,dz)>(B*B) ) break;\n     dist = min(dist, trap(z+dz));\n   }\n   return dist;\n}\n\nvec3 image(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0; // remap uv to [-1, 1]\n    uv.x *= iResolution.x / iResolution.y;\n        \n    // calculate and apply zoom\n    float zoom = .62 + .38*cos(iTime/PERIOD);\n    zoom = pow(zoom, 12.5);\n    vec2 c = vec2(-.745,.186);\n    vec2 dc = uv*zoom;\n    \n    float f = mandelbrot_pert(c, dc);\n    f = .5*log(f)/27.0;\n    \n    // calculate color\n    vec3 col = vec3(f*f);;\n\n    return (f*f*(100.0 - 1.0*f))*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// anti-aliasing\n\tfragColor = vec4(image(fragCoord.xy + vec2(0,0)), 1.0f);\n\tfragColor.rgb += image(fragCoord.xy + vec2(.5,.0));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.0,.5));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.5,.5));\n    fragColor.rgb += image(fragCoord.xy + vec2(.25,.25));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.75,.25));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.25,.75));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.75,.75));\n\tfragColor.rgb /= 8.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 182, 182, 277], [279, 279, 299, 299, 355], [358, 358, 398, 398, 753], [755, 755, 783, 783, 1237], [1240, 1240, 1297, 1315, 1780]], "test": "valid"}
{"id": "7tlXzs", "name": "another color shift", "author": "StrangerintheQ", "description": "color shift", "tags": ["colorshift"], "likes": 3, "viewed": 37, "published": "Public", "date": "1626381473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsl2rgb(vec3 c) \n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    float gray = dot(col, vec3(fract(iTime+2.*length(uv-0.5))));\n    gray = fract(gray + iTime);\n    col = hsl2rgb(vec3(gray, 0.55, 0.55));    \n    fragColor = vec4(col, 1.);\n   \n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 163], [165, 165, 222, 222, 487]], "test": "error"}
{"id": "7tSGRG", "name": "Sierpinski's Experiment", "author": "smjty", "description": "Keep opening the Sierpinski's triangle. If you like to see a more simplified version, delete two lines I've pointed out in the code", "tags": ["fractal", "triangle", "animation", "loop", "hexagonal"], "likes": 24, "viewed": 272, "published": "Public", "date": "1625304477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Twitter: @smjtyazdi\n#define PI 3.14159265\nconst float scale = 0.1;\n\nvec2 trans(vec2 p){\n    vec2 a = vec2(1.,0.);\n    vec2 b = vec2(0.5,0.5*sqrt(3.));\n    float ab = dot(a,b);\n    \n    float aa = (dot(p,a) - dot(p,b)*ab) / ( 1. - ab*ab);\n    float bb = (dot(p,b) - dot(p,a)*ab) / ( 1. - ab*ab);\n    \n    return vec2(aa,bb);\n}\n\nvec2 rot(vec2 p ,float t){\n    return vec2(p.x*cos(t) + p.y*sin(t) , p.y*cos(t)-p.x*sin(t));\n}\n\nfloat sierp2(vec2 p,float kk){\n\n    float col = 1.;\n    \n    vec2 base = vec2(0.);\n    float scale = 1.;\n    \n    for(float k=0.;k<kk;k+=1.){\n        vec2 g = trans(p-base)*scale;\n        scale*=2.;\n        if(min(g.x,g.y)>0.)\n            if(g.x+g.y<1.){col = 0.; continue;}\n        \n        g.x += -1.;\n\n        base += vec2(1.,0.)/scale*2.;\n\n        \n        if(min(g.x,g.y)>0.)\n            if(g.x+g.y<1.){col = 0.; continue;}\n        \n        g.x +=1.;\n        g.y += -1.;\n        base += vec2(-0.5,0.5*sqrt(3.))/scale*2.;\n\n        if(min(g.x,g.y)>0.)\n            if(g.x+g.y<1.){col = 0.; continue;}\n        \n       col = 1.;\n        \n        break;\n    }\n    \n    \n    return col;\n}\n\nfloat sierp_mix(vec2 p,float time){\n    return mix(sierp2(p,4.),sierp2(p,5.),time);\n}\n\n\nfloat render(vec2 p,float time){\n \n    float col = 1.;\n    \n    float time_ind = floor(time);\n    time = mod(time,1.);\n    \n    \n    time = 0.5 - 0.5*cos(time*PI);\n    \n    p = rot(p,2.*PI/3.*mod(time_ind,3.)); //Delete this if you like to see the simplified version\n    \n    float tt = PI/3.*(-time);\n    p.y += sin(PI/3.)*2./3.;\n    \n    p *= exp(-(time)*log(2.));\n    \n    \n    \n    float d = 1. + 2.*cos(tt+PI/3.);\n    float dy= sqrt(3.)*1.0 + 2.*sin(tt+PI/3.);\n    \n    float ind = mod(round(p.x/d)+1.,2.)*2.-1.;\n    float indy = mod(round(p.y/dy)+1.,2.)*2.-1.;\n    p.x = p.x - round(p.x/d)*d;\n    p.y = p.y - round(p.y/dy)*dy; //Delete this if you like to see the simplified version\n    p.y *= ind*indy;\n  \n    col = sierp_mix(rot(p-vec2(-d/2.,0.),tt)*2.,time)*sierp_mix(rot(p-vec2(d/2.,0.),PI-tt-PI/3.)*2.,time)*sierp_mix((p-vec2(-0.5,sin(tt+PI/3.)))*2.,time);\n  \n    \n    return col;\n}\n\n\nfloat rend(vec2 p ,float time){\n    float d = 1./(scale*iResolution.y)/2.;\n    return (render(p,time)+render(p+vec2(d,0.),time)+render(p+vec2(0.,d),time)+render(p+vec2(d),time))/4.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n   vec2 p = (fragCoord.xy  - iResolution.xy/2.0)/(scale*iResolution.y);\n   \n\n   float time = iTime;\n   \n   \n   vec3 col;\n   \n   for(float k=0.;k<3.;k+=1.){\n       float res = rend(p,time-k/3./60.);\n       \n       if(k==2.)col.x=1.-res;\n       if(k==1.)col.y=1.-res;\n       if(k==0.)col.z=1.-res;\n   }\n   \n   fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSGRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 89, 89, 327], [329, 329, 355, 355, 423], [425, 425, 455, 455, 1111], [1113, 1113, 1148, 1148, 1198], [1201, 1201, 1233, 1233, 2094], [2097, 2097, 2128, 2128, 2280], [2282, 2282, 2339, 2339, 2680]], "test": "valid"}
{"id": "7tsSDs", "name": "Fractal 63_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 6, "viewed": 249, "published": "Public API", "date": "1626856661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.15),.8)*1./e/8e3\n    )\n    {\n        p=g*d;\n        p.z-=3.5;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.3);\n        s=1.;\n        for(int i=0;i++<12;p=abs(p)*e-vec3(1,2,1))\n            p=.2-abs(p-.6),\n            p.x<p.z?p=p.zyx:p,\n            p.z<p.y?p=p.xzy:p,\n            s*=e=1.22;\n         g+=e=abs(p.x)/s+.001;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 636]], "test": "valid"}
{"id": "7tSSRD", "name": "Fractal 66_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 6, "viewed": 155, "published": "Public API", "date": "1627176606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.7;\n        ++i<160.;\n        O.xyz+=mix(vec3(1),H(cos(log(s)))*.5,.8)*.01*exp(-80.*e*i*i)\n    )\n    {\n        p=g*d;\n        p.z-=2.;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        s=3.;\n        vec4 q=vec4(p,tanh(sin(iTime*3.))*.2);\n        \n        for(int i;i++<8;)\n            q=mod(q-1.,2.)-1.,\n            s*=e=1.4/dot(q,q)-.03,\n            q*=e;\n        g+=e=length(q-clamp(q,-.7,.7))/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 665]], "test": "valid"}
{"id": "7tSSRR", "name": "Cloudy Planet", "author": "Dunk", "description": "An amalgamation of https://www.shadertoy.com/view/WdVfDD and https://www.shadertoy.com/view/3lf3z2", "tags": ["noise", "planet", "dither"], "likes": 10, "viewed": 84, "published": "Public", "date": "1626892697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Dither functions from: https://github.com/hughsk/glsl-dither\n// Improved version: https://www.shadertoy.com/view/tsKfDW\n\nfloat dither2x2(vec2 position, float brightness) {\n  int x = int(mod(position.x, 2.0));\n  int y = int(mod(position.y, 2.0));\n  int index = x + y * 2;\n  float limit = 0.0;\n\n  if (x < 8) {\n    if (index == 0) limit = 0.25;\n    if (index == 1) limit = 0.75;\n    if (index == 2) limit = 1.00;\n    if (index == 3) limit = 0.50;\n  }\n\n  return brightness < limit ? 0.0 : 1.0;\n}\n\n\nfloat dither4x4(vec2 position, float brightness) {\n  int x = int(mod(position.x, 4.0));\n  int y = int(mod(position.y, 4.0));\n  int index = x + y * 4;\n  float limit = 0.0;\n\n  if (x < 8) {\n    if (index == 0) limit = 0.0625;\n    if (index == 1) limit = 0.5625;\n    if (index == 2) limit = 0.1875;\n    if (index == 3) limit = 0.6875;\n    if (index == 4) limit = 0.8125;\n    if (index == 5) limit = 0.3125;\n    if (index == 6) limit = 0.9375;\n    if (index == 7) limit = 0.4375;\n    if (index == 8) limit = 0.25;\n    if (index == 9) limit = 0.75;\n    if (index == 10) limit = 0.125;\n    if (index == 11) limit = 0.625;\n    if (index == 12) limit = 1.0;\n    if (index == 13) limit = 0.5;\n    if (index == 14) limit = 0.875;\n    if (index == 15) limit = 0.375;\n  }\n\n  return brightness < limit ? 0.0 : 1.0;\n}\n\nfloat dither8x8(vec2 position, float brightness) {\n  int x = int(mod(position.x, 8.0));\n  int y = int(mod(position.y, 8.0));\n  int index = x + y * 8;\n  float limit = 0.0;\n\n  if (x < 8) {\n    if (index == 0) limit = 0.015625;\n    if (index == 1) limit = 0.515625;\n    if (index == 2) limit = 0.140625;\n    if (index == 3) limit = 0.640625;\n    if (index == 4) limit = 0.046875;\n    if (index == 5) limit = 0.546875;\n    if (index == 6) limit = 0.171875;\n    if (index == 7) limit = 0.671875;\n    if (index == 8) limit = 0.765625;\n    if (index == 9) limit = 0.265625;\n    if (index == 10) limit = 0.890625;\n    if (index == 11) limit = 0.390625;\n    if (index == 12) limit = 0.796875;\n    if (index == 13) limit = 0.296875;\n    if (index == 14) limit = 0.921875;\n    if (index == 15) limit = 0.421875;\n    if (index == 16) limit = 0.203125;\n    if (index == 17) limit = 0.703125;\n    if (index == 18) limit = 0.078125;\n    if (index == 19) limit = 0.578125;\n    if (index == 20) limit = 0.234375;\n    if (index == 21) limit = 0.734375;\n    if (index == 22) limit = 0.109375;\n    if (index == 23) limit = 0.609375;\n    if (index == 24) limit = 0.953125;\n    if (index == 25) limit = 0.453125;\n    if (index == 26) limit = 0.828125;\n    if (index == 27) limit = 0.328125;\n    if (index == 28) limit = 0.984375;\n    if (index == 29) limit = 0.484375;\n    if (index == 30) limit = 0.859375;\n    if (index == 31) limit = 0.359375;\n    if (index == 32) limit = 0.0625;\n    if (index == 33) limit = 0.5625;\n    if (index == 34) limit = 0.1875;\n    if (index == 35) limit = 0.6875;\n    if (index == 36) limit = 0.03125;\n    if (index == 37) limit = 0.53125;\n    if (index == 38) limit = 0.15625;\n    if (index == 39) limit = 0.65625;\n    if (index == 40) limit = 0.8125;\n    if (index == 41) limit = 0.3125;\n    if (index == 42) limit = 0.9375;\n    if (index == 43) limit = 0.4375;\n    if (index == 44) limit = 0.78125;\n    if (index == 45) limit = 0.28125;\n    if (index == 46) limit = 0.90625;\n    if (index == 47) limit = 0.40625;\n    if (index == 48) limit = 0.25;\n    if (index == 49) limit = 0.75;\n    if (index == 50) limit = 0.125;\n    if (index == 51) limit = 0.625;\n    if (index == 52) limit = 0.21875;\n    if (index == 53) limit = 0.71875;\n    if (index == 54) limit = 0.09375;\n    if (index == 55) limit = 0.59375;\n    if (index == 56) limit = 1.0;\n    if (index == 57) limit = 0.5;\n    if (index == 58) limit = 0.875;\n    if (index == 59) limit = 0.375;\n    if (index == 60) limit = 0.96875;\n    if (index == 61) limit = 0.46875;\n    if (index == 62) limit = 0.84375;\n    if (index == 63) limit = 0.34375;\n  }\n\n  return brightness < limit ? 0.0 : 1.0;\n}\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n#define octaves 14\nfloat fbm (in vec2 p) {\n\n    float value = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;    \n\n    for (int i = 0; i < octaves; i++) {\n        value += amp * (noise((p - vec2(1.0)) * freq));\n        freq *= 1.9;\n        amp *= 0.6;\n    }\n    return value;\n}\n\nfloat pattern(in vec2 p) {\n    vec2 offset = vec2(-0.5);\n\n    vec2 aPos = vec2(sin(iTime * 0.005), sin(iTime * 0.01)) * 6.;\n    vec2 aScale = vec2(3.0);\n    float a = fbm(p * aScale + aPos);\n\n    vec2 bPos = vec2(sin(iTime * 0.01), sin(iTime * 0.01)) * 1.;\n    vec2 bScale = vec2(0.6);\n    float b = fbm((p + a) * bScale + bPos);\n\n    vec2 cPos = vec2(-0.6, -0.5) + vec2(sin(-iTime * 0.001), sin(iTime * 0.01)) * 2.;\n    vec2 cScale = vec2(2.6);\n    float c = fbm((p + b) * cScale + cPos);\n    return c;\n}\n\nvec3 palette(in float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.45, 0.25, 0.14);\n    vec3 c = vec3(1.0 ,1.0, 1.0);\n    vec3 d = vec3(0.0, 0.1, 0.2);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n    float value = pow(pattern(p), 2.); // more \"islands\"\n   \tvec3 color = palette(value);\n    float bright = dot(color, vec3(0.4,0.6,0.3));\n    \n    \n    \n    vec3 ditherCol = color * vec3(dither8x8(fragCoord, bright));\n    \n    vec2 ratio = vec2(iResolution.x / iResolution.y, 1.);\n   \tvec2 pos = vec2(fragCoord / iResolution.xy);\n    vec2 npos = 2. * pos - 1.;\n    vec2 cpos = npos * ratio;\n    \n    vec3 viewVec = vec3(0,0,1);\n   \t\n    vec3 sun = vec3(cos(iTime * 0.25), 0., sin(iTime * 0.25));\n    vec3 norm = normalize(vec3(cpos, sqrt(1. - dot(cpos, cpos))));\n    \n    float d = length(cpos);    \n    float a = dot(sun, norm);\n    \n    float spec = pow(clamp(dot(reflect(sun, -norm), -viewVec), 0.0, 1.0), 64.0) * 4.0;\n    a += 0.1 + spec;\n    a = clamp(a, 0.0, 1.0);\n    \n    ditherCol *= a;\n    \n    if (d < 0.99) {\n    \t// Output to screen\n    \tfragColor = vec4(ditherCol, 1.0);\n        //fragColor = vec4(1) * ceil(a);\n    } else if (d > 1.0) {\n        fragColor = vec4(0);\n    } else {\n     \tfragColor = vec4(0.5,0.5,0.5,1.0) * a;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 174, 174, 494], [497, 497, 547, 547, 1299], [1301, 1301, 1351, 1351, 3959], [3961, 3961, 3981, 3981, 4069], [4070, 4070, 4091, 4091, 4375], [4396, 4396, 4419, 4419, 4654], [4656, 4656, 4682, 4682, 5161], [5163, 5163, 5189, 5189, 5377], [5379, 5379, 5435, 5435, 6570]], "test": "valid"}
{"id": "7tsXRB", "name": "Forkpsychedelic.toby", "author": "toby80", "description": "Another play on IQ's tunnel", "tags": ["tunnel"], "likes": 1, "viewed": 28, "published": "Public", "date": "1625998596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"psychedelic tunnel\" by None. https://shadertoy.com/view/-1\n// 2021-07-11 09:06:41\n\n// Fork of \"psychedelic tunnel\" by None. https://shadertoy.com/view/-1\n// 2021-07-11 08:51:50\n\n// Fork of \"psychedelic tunnel\" by StanRee. https://shadertoy.com/view/4lX3W7\n// 2021-07-11 07:56:38\n\n\n// Deform - square tunnel : REDUX\n// Modifications by Stanley Hayes\n// Original Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Hsv conversion from http://ploobs.com.br/?p=1499\n\nvec3 Hue(float a){\nvec3 K = vec3(3,2,1)/3.;\nreturn clamp(abs(fract(vec3(a)+K)*6. - vec3(3.)) - K.xxx, 0., 1.);\n}\n\n\n#define Time (iTime * .06) \n\nvec3 HSVtoRGB(vec3 HSV)\n{\n    return vec3(((Hue(HSV.x) - 1.0) * HSV.y + 1.0) * HSV.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized coordinates (-1 to 1 vertically)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    // angle of each pixel to the center of the screen\n    \n    \n    // modified distance metric. Usually distance = (xÃÂ² + yÃÂ²)^(1/2). By replacing all the \"2\" numbers\n    // by 32 in that formula we can create distance metrics other than the euclidean. The higher the\n    // exponent, then more square the metric becomes. More information here:\n    \n    // http://en.wikipedia.org/wiki/Minkowski_distance\n    \n    float exp = 1.0;\n    float crayStationsCoef = 1.01; \n    p.x +=  sin(pow(Time,.5))*crayStationsCoef*2.0;\n   //p.y +=  cos(Time)*crayStationsCoef*10.0;\n    float a = atan(p.y,p.x) + Time * sin(Time)*.002 + iMouse.x * .0001;\n    float r = pow( pow(p.x*p.x,exp) + pow(p.y*p.y,exp), 1.0/(exp * 2.0) ) + sin(Time)*crayStationsCoef;\n    a += pow(r,.50); \n    \n       \n    // index texture by angle and radious, and animate along radius    \n    vec2 uv = vec2( 0.5/r + 0.5*Time + iMouse.y,                    a/3.1416 );\n\n    r -= sin(Time)*.05;\n    // fecth color and darken in the center\n    vec3 col =  texture( iChannel0, uv ).xyz * r;\n    col = HSVtoRGB(vec3(col.r, 1.0, 1.0)); \n\t\n    col.r *= (sin(uv.x*5.0)*.7 + 1.0) * .9;\n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsXRB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[547, 547, 565, 565, 659], [691, 691, 716, 716, 779], [782, 782, 839, 890, 2140]], "test": "error"}
{"id": "7tsXRN", "name": "2D rounded rectangular outline ", "author": "Rabbid76", "description": "a 2 dimensional rectangular outline with rounded corners", "tags": ["2d", "square", "rectangle", "outline", "quad", "rounded"], "likes": 1, "viewed": 227, "published": "Public", "date": "1625397422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat roundedBoxSDF(vec2 CenterPosition, vec2 Size, float Radius)\n{\n    return length(max(abs(CenterPosition)-Size+Radius,0.0))-Radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2  size           = vec2(300.0, 200.0);\n    vec2  location       = iMouse.xy;\n    float thickness      = 5.0;\n    float shadowSoftness = 30.0f;\n    vec2  shadowOffset   = vec2(10.0, -10.0);\n    float edgeSoftness   = 1.0;\n    float radius         = (sin(iTime*2.0) + 1.0) * 30.0 + thickness * 2.0;\n    \n    float distance       = roundedBoxSDF(location - fragCoord.xy, size/2.0, radius);\n    float smoothedAlpha  = 1.0 - smoothstep(-edgeSoftness, edgeSoftness, abs(distance) - thickness);\n    vec4  quadColor      = mix(vec4(1.0), vec4(0.0, 0.2, 1.0, smoothedAlpha), smoothedAlpha);\n    \n    float shadowDistance = roundedBoxSDF(location + shadowOffset - fragCoord.xy, size/2.0, radius);\n    float shadowAlpha    = 1.0 - smoothstep(-shadowSoftness/2.0, shadowSoftness/2.0, abs(shadowDistance));\n    vec4 shadowColor     = vec4(0.4, 0.4, 0.4, 1.0);\n    fragColor            = mix(quadColor, shadowColor, shadowAlpha - smoothedAlpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsXRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 79, 146, 146, 216], [218, 218, 273, 273, 1215]], "test": "valid"}
{"id": "7tsXzN", "name": "mandelbrot 001 orbit trap", "author": "RiceFields", "description": "mandelbrot, orbit trap", "tags": ["mandelbrot", "fractals", "orbittrap"], "likes": 5, "viewed": 54, "published": "Public", "date": "1626510791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define B 256.0\n#define N 200\n#define PERIOD 1.0/10.0\n#define LINE vec2(1.0, 1.0)\n\nfloat line_segment(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n    vec2 lvec = pa - clamp(dot(pa, ba) / dot(ba, ba), 0., 1.) * ba;\n\treturn dot(lvec, lvec); // length between pa and porject of pa on ba\n}\n\nfloat trap(vec2 z) {\n    vec2 l = 0.5 + 0.5*cos(iTime+LINE);\n    return line_segment(abs(sin(z)), abs(cos(z)), l);\n}\n\n\nfloat mandelbrot(vec2 c) {\n   vec2 z = vec2(.0);\n   float dist = 10e5;\n   for(int i = 0; i < N; ++i) {\n     z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c; // z = z^2 + c\n     if( dot(z,z)>(B*B) ) break;\n     dist = min(dist, trap(z));\n   }\n   return sqrt(dist);\n}\n\nvec3 image(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0; // remap uv to [-1, 1]\n    uv.x *= iResolution.x / iResolution.y;\n        \n    vec2 c = vec2(-.4,.1) + uv*.8;  \n    float f = mandelbrot(c);\n    f = .5*log(f)/14.0;\n    \n    // calculate color\n    vec3 col = vec3(f*f);\n\n    return (f*f*(100.0 - f))*col;\n \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// anti-aliasing\n\tfragColor = vec4(image(fragCoord.xy + vec2(0,0)), 1.0f);\n\tfragColor.rgb += image(fragCoord.xy + vec2(.5,.0));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.0,.5));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.5,.5));\n    fragColor.rgb += image(fragCoord.xy + vec2(.25,.25));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.75,.25));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.25,.75));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.75,.75));\n\tfragColor.rgb /= 8.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 127, 127, 303], [305, 305, 325, 325, 421], [424, 424, 450, 450, 688], [690, 690, 718, 718, 1032], [1035, 1035, 1092, 1110, 1575]], "test": "valid"}
{"id": "7tXSD7", "name": "Morphing Infinity", "author": "wildniklin", "description": "Morphing sdfs was easier than what I'd imagined.", "tags": ["sdf", "morph"], "likes": 6, "viewed": 184, "published": "Public API", "date": "1625791038", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 200;\nconst float MAX_DIST = 100.0;\nconst float MIN_DIST = 0.001;\nconst float PI = 3.1415;\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    vec3 m = abs(p) - s;\n    return length(max(m, 0.0)) + min(max(m.x, max(m.y, m.z)), 0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 p) {\n    vec3 i = floor(p);\n    vec3 m = p - i - 0.5;\n    return mix(sdBox(m, vec3(0.25)), sdSphere(m, 0.25), sin(iTime + ((p.x + p.y + p.z) * 2.0)) * 0.5 + 0.5);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float ds = map(ro + (rd * d));\n        d += ds;\n        if(d > MAX_DIST) return MAX_DIST;\n        if(abs(ds) <= MIN_DIST * 0.5) return d; // somehow adding * 0.5 after MIN_DIST removes the unwanted artifacts.\n    }\n    return MAX_DIST;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(MIN_DIST, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvec4 getCol(vec3 ro, vec3 rd, out float d, out vec3 p, out vec3 n) {\n    d = march(ro, rd);\n    p = ro + (rd * d);\n    n = normal(p);\n\n    vec3 col = vec3(sin(p * PI * 0.5) * 0.5 + 0.5);\n    \n    vec3 light = vec3(0.0);\n    \n    light += 4.0 * clamp(dot(n, normalize(vec3(0.7, 1.0, -0.5))), 0.0, 1.0);\n    light += 1.0;\n\n    col *= light;\n    col = mix(col, vec3(0.2, 0.2, 0.2), smoothstep(0.0, MAX_DIST, d));\n\n    return vec4(col, 1.0);\n}\n\nvec4 image(vec2 i, float t) {\n    vec2 uv = (i.xy - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(0., 0.0, iTime * 0.5);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    rd.yz *= rot(sin(iTime * PI * 0.05) * PI * 0.125);\n    rd.xz *= rot(cos(iTime * PI * 0.05) * PI * 0.125);\n\n    vec4 col = vec4(0.0);\n\n    float factor = 1.0;\n    \n    for(int i = 0; i < 5; i++) {\n        if(factor < 0.001) break;\n        \n        float d; vec3 p, n;\n        vec4 tc = getCol(ro, rd, d, p, n);\n        \n        factor *= 0.35;\n        \n        col = mix(col, tc, factor);\n        \n        ro = p + (n * MIN_DIST);\n        rd = reflect(rd, n);\n    }\n    \n    col *= smoothstep(2.2, -0.5, length(uv));\n\n    return col;\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    o = image(i, iTime);\n}", "image_inputs": [{"id": "MtXXDB", "previewfilepath": "https://soundcloud.com/tonymakesmusic/flowing-with-the-wind", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/tonymakesmusic/flowing-with-the-wind", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXSD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 132, 132, 198], [200, 200, 229, 229, 324], [326, 326, 359, 359, 387], [389, 389, 408, 408, 568], [570, 570, 601, 601, 907], [909, 909, 930, 930, 1123], [1125, 1125, 1193, 1193, 1564], [1566, 1566, 1595, 1595, 2305], [2307, 2307, 2343, 2343, 2370]], "test": "valid"}
{"id": "fdlSWB", "name": "Mandelbrot Party antialiased", "author": "adamjmurray", "description": "Anti-aliased and slightly modified version of https://www.shadertoy.com/view/Ns23zm", "tags": ["fractals"], "likes": 2, "viewed": 45, "published": "Public", "date": "1626505091", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int quality = 3; // antialiasing: 1=off, 2=on, >2=more anti-aliasing\n\nconst float speed = 0.1;\n\nvec2 rotate(vec2 p, float angle) {\n\treturn vec2(\n\t\tp.x*cos(angle) - p.y*sin(angle), \n\t\tp.x*sin(angle) + p.y*cos(angle)\n\t);\n}\n\nvec3 hsl2rgb(float h, float s, float l) {\n  float c = (1. - abs(2.*l - 1.)) * s;\n  float hp = 6. * mod(h,1.);\n  float x = c * (1. - abs(mod(hp,2.) - 1.));\n\n  vec3 rgb1 = vec3(0,0,0);\n  if (hp <= 1.)      rgb1 = vec3(c,x,0);\n  else if (hp <= 2.) rgb1 = vec3(x,c,0);\n  else if (hp <= 3.) rgb1 = vec3(0,c,x);\n  else if (hp <= 4.) rgb1 = vec3(0,x,c);\n  else if (hp <= 5.) rgb1 = vec3(x,0,c);\n  else if (hp <= 6.) rgb1 = vec3(c,0,x);\n\n  float m = l - c/2.;\n  return vec3(rgb1.r + m, rgb1.g + m, rgb1.b + m);\n}\n\nvec3 draw(vec2 c, float iterations, float hueShift) {\n    vec2 z = vec2(0,0);\n    float i;     \n    for (i=0.; i < iterations && dot(z,z) < 16.; i++) {\n        z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c; // z^2 + c\n    }\n    if (i >= iterations) {\n        return vec3(0,0,0);\n    } else {\n        float hue = (i - log(log(dot(z,z)))) / iterations;\n        hue = mod(hue + hueShift, 1.);\n        return hsl2rgb(hue, 0.7, 0.45);\n    }\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = speed*iTime;\n    float zoom = 150.*pow(1.4 - cos(time), 5.);\n    float angle = 10.*sin(time/11.07);\n    float hueShift = time/23.;\n    float iterations = 180. + 100.*sin(2.03*time);\n    vec2 offset = vec2(\n        -0.4822 - sin(time/3.11)/4000., \n        0.6141 + cos(time/1.43)/5500.\n    );\n    \n    vec3 color = vec3(0,0,0);\n    float samples = 0.;\n    float subpixel = 1./float(quality);\n    for (float x=0.; x<1.; x+=subpixel) {\n        for (float y=0.; y<1.; y+=subpixel) {\n            vec2 coord = (2.*(fragCoord + vec2(x,y)) - iResolution.xy)/iResolution.y; // [-1,1] vertically    \n            vec2 c = rotate(coord/zoom, angle) + offset;           \n            color += draw(c, iterations, hueShift);\n            samples++;\n        }\n    }\n    fragColor = vec4(color/samples,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlSWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 130, 130, 220], [222, 222, 263, 263, 726], [728, 728, 781, 781, 1163], [1166, 1166, 1223, 1223, 2030]], "test": "valid"}
{"id": "fl2XD1", "name": "Lines  by line", "author": "Liners", "description": "lines", "tags": ["lines"], "likes": 6, "viewed": 71, "published": "Public", "date": "1627593696", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= vec2(0.6);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Calculate polar coordinates\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n       \n    //  lines\n    const float it = 10.0;\n    float c = 0.0;\n    for( float i = 0.0 ; i < it ; i += 1.0 )\n    {\n        float i01 = i / it;\n        float rnd = texture( iChannel0, vec2(i01)).x;    \n        \n        float c1 = (uv.y + 1. ) * 0.004 * abs( 1.5 / sin( (cos(uv.x + uv.y) + cos(t * 0.5)) + sin(uv.y * 4.0 * rnd + rnd * 7.0 + iTime * 0.75)) );\n        c = clamp(c + c1, 0.0, 1.0);\n    }\n    \n    float s = 0.0;\n    const float it2 = 200.0;\n    for( float i = 0.0 ; i < it2 ; i += 1.0 )\n    {\n        float i01 = i / it2;       \n        float react =  texture( iChannel1, vec2(i01, 0.0) ).x;  \n        vec2 rnd = texture( iChannel0, vec2(i01)).xy;\n        vec2 rnd2 = rnd - 0.15;\n      \n        rnd2 = vec2(sin(rnd2.x * 200.0 + rnd2.x * iTime * 0.2), - 0.9 * sin(rnd2.y * rnd2.x * 200.0 + iTime  * rnd2.y * 0.5));\n        \n        float r1 = 1.0 - length(uv - rnd2 * 2.);\n        float rad = ( 1.0 - clamp(0.03 * rnd.y + react * 0.05, 0.0, 1.0) );\n\n        r1 = smoothstep(rad, rad + 0.015, r1);\n        s += r1;\n    }\n    \n\n    \n    // color mixing lines backgrounds\n    vec3 bg = mix( vec3(0., 0.11, 0.12), vec3(0., 0.04, 0.04), r);\n    bg = mix(bg, mix( vec3(0.25, 0.69, 0.91), vec3(0.5, 0.4, 0.4), -c), c);\n    bg = mix(bg, vec3(0.75, 0.95, 1.), s );\n    \n    fragColor = vec4(bg, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2XD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 1587]], "test": "error"}
{"id": "fl2Xzh", "name": "Texture Shadow", "author": "intrakits", "description": "This is an experiment to project a texture onto where a shadow would normally go.", "tags": ["textureshadow"], "likes": 1, "viewed": 127, "published": "Public API", "date": "1627081543", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nvec2 GetDist(vec3 p){\n    vec2 res = vec2(p.y+.3,1.);\n    vec2 sphere = vec2(length(p-vec3(0,1,-2))-.4,2.);\n    res = colMin(res, sphere);\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,-6);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3( 0, 0., -3);\n    vec3 ro = ta + vec3( 4.5, 4.3, 4.5);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    //------------------\n    vec2 d = RayMarch(ro,rd);\n    \n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n    \n    //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    \n    if(d.y == 1.){\n        col *= vec3(1,0,0);\n    }\n    else if(d.y==2.){\n       col *= vec3(0,1,0);\n    }\n    else if(d.y==3.){\n        col=vec3(1,0,0);\n    }\n    else if(d.y==4.){\n      //  col*=decCol(p, n, rd)*vec3(1,1,0);\n    }\n    vec3 colXZ = texture(iChannel0, p.xz*.5+.5).rgb;\n    vec3 colXY = texture(iChannel0, p.xy*.5+.5).rgb;\n    vec3 colYZ = texture(iChannel0, p.yz*.5+.5).rgb;\n    vec3 shadow = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n    col = max(smoothstep(.5,.1,diff)*shadow,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2Xzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 112, 112, 140], [142, 142, 162, 162, 269], [271, 271, 291, 291, 354], [356, 356, 419, 419, 1469], [1471, 1471, 1490, 1490, 1552], [1553, 1553, 1604, 1604, 1888], [1890, 1890, 1939, 1962, 2395], [2397, 2397, 2427, 2427, 2498], [2500, 2500, 2527, 2527, 2566], [2567, 2567, 2631, 2631, 2882], [2883, 2883, 2915, 2915, 3016], [3017, 3069, 3107, 3107, 3204], [3206, 3258, 3299, 3299, 3371], [3372, 3372, 3430, 3430, 3531], [3532, 3532, 3555, 3555, 3750], [3751, 3751, 3772, 3772, 3907], [3908, 3908, 3940, 3968, 4478], [4479, 4479, 4502, 4541, 4912], [4913, 4913, 4936, 4971, 5910], [5911, 5911, 5963, 5963, 6140]], "test": "error"}
{"id": "flBSRW", "name": "Texture Shadow (reg self shadow)", "author": "intrakits", "description": "Trying to get a texture to render instead of a shadow on objects other than the shadow caster.", "tags": ["texture", "shadow"], "likes": 1, "viewed": 128, "published": "Public API", "date": "1627137412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nvec2 GetDist(vec3 p){\n    vec2 res = vec2(p.y+.3,1.);\n    vec2 sphere = vec2(length(p-vec3(0,1,-2))-.4,2.);\n    res = colMin(res, sphere);\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,-6);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3( 0, 0., -3);\n    vec3 ro = ta + vec3( 4.5, 4.3, 4.5);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    //------------------\n    vec2 d = RayMarch(ro,rd);\n    \n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n    \n    //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    \n    if(d.y == 1.){\n        col *= vec3(1,0,0);\n        vec3 colXZ = texture(iChannel0, p.xz*.5+.5).rgb;\n    vec3 colXY = texture(iChannel0, p.xy*.5+.5).rgb;\n    vec3 colYZ = texture(iChannel0, p.yz*.5+.5).rgb;\n    vec3 shadow = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n    col = max(smoothstep(.5,.1,diff)*shadow,col);\n    }\n    else if(d.y==2.){\n       col *= vec3(0,1,0);\n    }\n    else if(d.y==3.){\n        col=vec3(1,0,0);\n    }\n    else if(d.y==4.){\n      //  col*=decCol(p, n, rd)*vec3(1,1,0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBSRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 112, 112, 140], [142, 142, 162, 162, 269], [271, 271, 291, 291, 354], [356, 356, 419, 419, 1469], [1471, 1471, 1490, 1490, 1552], [1553, 1553, 1604, 1604, 1888], [1890, 1890, 1939, 1962, 2395], [2397, 2397, 2427, 2427, 2498], [2500, 2500, 2527, 2527, 2566], [2567, 2567, 2631, 2631, 2882], [2883, 2883, 2915, 2915, 3016], [3017, 3069, 3107, 3107, 3204], [3206, 3258, 3299, 3299, 3371], [3372, 3372, 3430, 3430, 3531], [3532, 3532, 3555, 3555, 3750], [3751, 3751, 3772, 3772, 3907], [3908, 3908, 3940, 3968, 4478], [4479, 4479, 4502, 4541, 4912], [4913, 4913, 4936, 4971, 5910], [5911, 5911, 5963, 5963, 6140]], "test": "error"}
{"id": "flBSzw", "name": "Fractal Pattern Doodle", "author": "Plento", "description": "A little fractaly doodle to pass some time.", "tags": ["2d", "fractal", "doodle"], "likes": 28, "viewed": 507, "published": "Public API", "date": "1627285346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define m ( iMouse.xy - .5*R ) / R.y\n#define ss(a, b, t) smoothstep(a, b, t)\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    float t = iTime*.25 - 1.5;\n    \n    vec2 uv = vec2( u - .5*R ) / R.y;\n    uv += vec2(t, t*.2 - .4);\n    \n    if(iMouse.z > 0.)\n        uv += m*5.;\n    \n    uv = (uv + vec2(-uv.y,uv.x) ) / 1.41;\n    uv = fract(uv * .35) - .5;\n    uv = abs(uv);\n    \n    vec2 v = vec2(cos(.09), sin(.09));\n    float dp = dot(uv, v);\n    uv -= v*max(0., dp)*2.;\n    \n    float w = 0.;\n    for(float i = 0.; i < 27.;i++){\n        uv *= 1.23;\n        uv = abs(uv);\n    \tuv -= 0.36;\n    \tuv -= v*min(0., dot(uv, v))*2.;\n        uv.y += cos(uv.x*45.)*.007;\n        w += dot(uv, uv);\n    }\n    \n    float n = (w*12. + dp*15.);\n    vec3 col = 1. - (.6 + .6*cos(vec3(.45, 0.6, .81) * n + vec3(-.6, .3, -.6)));\n    \n    col *= max(ss(.0, .11, abs(uv.y*.4)), .8);\n    col = pow(col * 1.2, vec3(1.6));\n    f = vec4(1.-exp(-col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 161, 161, 971]], "test": "valid"}
{"id": "flBXRz", "name": "torus voronoi", "author": "CyanMARgh", "description": "3d version of 7ljSRR shader\n", "tags": ["voronoi", "torus"], "likes": 1, "viewed": 58, "published": "Public", "date": "1626968182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cameraPos = vec3(0., 10., -13.5);\nfloat softShadow = 10.;\nfloat depthmax = 80.; \nconst float eps = 0.0001;\nvec3 backcol = vec3(.6,.7,1.);\nfloat inf = 1e20;\nfloat pi=3.14159265;\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n//additioanal operations\nstruct point {\n    vec2 p;\n    vec3 c;\n};\nfloat torusDist(vec2 a, vec2 b) {\n    a = abs(a - b);\n    return length(min(abs(a), abs(1. - a)));\n}\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//SDF operations\nvec4 cun(vec4 d1, vec4 d2){\n    return d1.w<d2.w?d1:d2;\n}\n//SDF\nfloat torus(vec3 p, vec3 p0, float RL, float RS) {\n    p -= p0;\n    vec3 h = vec3(0., p.y, 0.);\n    vec3 v = p - h;\n    return sqrt(pow(length(v) - RL, 2.) + p.y * p.y) - RS;\n}\nfloat box(vec3 b, vec3 p){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n//color functions\nbool cb3(vec3 p){\n    ivec3 d = ivec3(floor(p));\n    return (d.x+d.y+d.z)%2==0;\n}\nvec2 torusCoordinate(vec3 p, vec3 p0, float RL) {\n    p -= p0;\n    float phi = atan(p.z, p.x) / pi;\n    float theta = atan(p.y, length(p.xz) - RL) / pi;\n    return vec2(phi+1., theta + 1.) / 2.;\n}\nconst uint S = 8u;\nvec3 torusColor(vec2 uv) {\n    uv = mod(uv, 1.);\n    point centers[S];\n    centers[0] = point(vec2(0., 0.), vec3(0., 0., 0.));\n    centers[1] = point(vec2(.7, .7), vec3(0., 0., 1.));\n    centers[2] = point(vec2(.3, .6), vec3(0., 1., 0.));\n    centers[3] = point(vec2(.2, .2 + .1*sin(iTime)), vec3(0., 1., 1.));\n    centers[4] = point(vec2(.25 + .1 * cos(iTime+1.), .4), vec3(1., 0., 0.));\n    centers[5] = point(vec2(.4, .4), vec3(1., 0., 1.));\n    centers[6] = point(vec2(.5, .3), vec3(1., 1., 0.));\n    centers[7] = point(vec2(.1, .5 + .3 * cos(iTime)), vec3(1., 1., 1.));\n    \n    float md = 1e20;\n    vec3 col = vec3(1.);\n    for(uint i = 0u; i < S; i++) {\n        float d = torusDist(uv, centers[i].p);\n        if(d < md) {\n            md = d;\n            col = centers[i].c;\n        }\n    }\n    return col;\n}\n\n//scene SDF\nvec4 map(vec3 p){\n    vec4 d0 = vec4(1.,1.,1.,-box(vec3(20.,20.,20.),p-vec3(0.,20.,0.)));\n    d0.xyz*=cb3(p)?1.:.8;\n    vec2 uv = torusCoordinate(p, vec3(0., 6., 0.), 5.);\n    vec4 d = vec4(torusColor(uv), torus(p, vec3(0., 6., 0.), 5., 1.5));\n    d0 = cun(d0,d);    \n    return d0;\n}\n//normals\nvec3 norm(vec3 p){\n    const vec2 e = vec2(eps,0.);\n    float d = map(p).w;\n    return normalize(vec3(\n        map(p + e.xyy).w-d,\n        map(p + e.yxy).w-d,\n        map(p + e.yyx).w-d\n    ));\n}\n// color of lighting for point\nvec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){\n    p += n * eps;\n    vec3 ld=mode?lp:lp-p;\n    float l = length(ld);ld/=l;\n\tfloat diff = dot(ld,n);\n    \n    float h, c=eps, r=1.;\n    \n    for (float t = 0.0; t < 50.0; t++){\n        h = map(p + ld * c).w;\n        if (h < eps){\n            return vec3(0.);\n        }\n        r = min(r, h * softShadow / c);\n        c += h;//clamp(h,0.,3.0);\n        if(c>l)break;\n    }\n    \n    return lc*po*r*diff/(l*l);\n}\n// ambient occlusion by point\nfloat getOcc(vec3 ro, vec3 rd){\n    float totao = 0.0;\n    float sca = 1.0;\n    for (int aoi = 0; aoi < 2; aoi++){\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = map(aopos).w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n    const float aoCoef = 0.5;\n    return totao*(1.0 - clamp(aoCoef * totao, 0.0, 1.0));\n}\nvec3 getFullLight(vec3 pos, vec3 n){   \n    pos+=eps*n;\n    vec3 col;\n\n    if (length(pos) < depthmax){\n        col = vec3(.25);\n\t\tcol += getLight(pos, vec3(11., 13., 8.), n, vec3(1.,.9,.9), 60.,false);\n        col += getLight(pos, vec3(-8.,13., 11.), n, vec3(1.,1.,1.), 60.,false);\n        col += getLight(pos, vec3(-11.,13.,-8.), n, vec3(1.,1.,1.), 60.,false);\n        col += getLight(pos, vec3(8., 13.,-11.), n, vec3(1.,.9,.9), 60.,false);\n    }else{\n        col = backcol;\n    }\n    return col;\n}\n//direction of ray by pixel coord\nvec3 getDir(vec2 fragCoord, float angle){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec3 eye = cameraPos;\n    float targetDepth = 2.;\n    vec3 dir = normalize(vec3(p,targetDepth));\n    dir.zy*=ro(-.25);\n    dir.xz*=ro(angle);\n    return dir;\n}\n\n//color and length of ray\nvec3 rayCast(vec3 eye, vec3 dir){\n    vec3 col = vec3(0.);\n    float k=1.;\n    \n    vec3 pos; float depth=0., sdepth=0., dist;\n    vec4 rc;\n    const int maxsteps = 500;\n    for (int i = 0; i < maxsteps; i++){\n        pos = eye + dir * depth;\n        rc = map(pos);\n        dist = rc.w;;\n\n        depth += dist;\n        sdepth += dist;\n        \n        if(dist < eps){ //intersection with object\n            break; \n        }else if(length(pos)>depthmax){ //ray \n            depth = depthmax+eps;\n            break;\n        }\n    } \n    vec3 n = norm(pos);\n    pos+=eps*n*5.;\n    col+=map(pos).xyz*k*getFullLight(pos,n);\n\tif(map(pos).w<0.)col+=vec3(1e20);\n    return col * exp(-0.003*sdepth);\n}\n//full render\nvoid mainImage(out vec4 color, in vec2 uv){\n    //direction calculation\n    float angle = iTime*.2;    \n    vec3 eye = cameraPos;\n    eye.xz*=ro(angle);\n    vec3 dir = getDir(uv,angle);\n\n    //raymarching\n    vec3 col = rayCast(eye, dir);    \n    color = vec4(1.5*log(1.+ col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[407, 407, 440, 440, 507], [508, 508, 527, 527, 587], [589, 606, 633, 633, 663], [664, 670, 720, 720, 846], [847, 847, 873, 873, 964], [965, 983, 1000, 1000, 1064], [1065, 1065, 1114, 1114, 1261], [1281, 1281, 1307, 1307, 2095], [2097, 2109, 2126, 2126, 2393], [2394, 2404, 2422, 2422, 2599], [2600, 2631, 2700, 2700, 3109], [3110, 3140, 3171, 3171, 3565], [3566, 3566, 3602, 3602, 4066], [4067, 4101, 4142, 4142, 4395], [4397, 4423, 4456, 4456, 5117], [5118, 5132, 5175, 5203, 5417]], "test": "valid"}
{"id": "flBXWR", "name": "chungaTest1", "author": "chungaloid", "description": "mouse 1 down to place first circle, mouse 1 up to place second", "tags": ["2d"], "likes": 0, "viewed": 34, "published": "Public", "date": "1627385248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p = 5. * cos(iTime);\n    \n    float r = pow(100., p);\n    \n    float d1 = pow(distance(fragCoord, iMouse.xy), p);\n    float d2 = pow(distance(fragCoord, abs(iMouse.zw)), p);\n    \n    \n    vec3 col1 = mix(vec3(1), vec3(0., 0., 1.), vec3(1. - d2 / r));\n    vec3 col2 = mix(vec3(1), vec3(0., 1., 0.), vec3(1. - d1 / r));\n    \n    vec3 col = mix(col1, col2, 0.5);\n        \n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 474]], "test": "valid"}
{"id": "flfSRr", "name": "SDF - RAY 01", "author": "pedrogarlaschi", "description": "First Attempt of Ray Marching\nThanks to Yuri Artyukh and his great tutorial.\n\nFinally getting a better understanding of it. \n\nhttps://www.youtube.com/watch?v=q2WcGi3Cr9w&t=1872s", "tags": ["sdf", "raymaching"], "likes": 2, "viewed": 61, "published": "Public", "date": "1625757376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 32\n// SDF function from a sphere\nfloat sdSphere(vec3 p , float r ){\n  return length(p)-r;\n}\n\nvec2 matcap(vec3 eye, vec3 normal) {\n  vec3 reflected = reflect(eye, normal);\n  float m = 2.8284271247461903 * sqrt( reflected.z+1.0 );\n  return reflected.xy / m + 0.5;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t0.0,                                0.0,                                0.0,                                1.0\n\t);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\treturn (rotation3d(axis, angle) * vec4(v, 1.0)).xyz;\n}\n\n// \nfloat f(vec3 p){\n    \n   \n   float px = ((iMouse.x / iResolution.x) * 2.) - 1.;\n   float py = ((iMouse.y / iResolution.y) * 2.) - 1.;\n   vec3 pRot = rotate(p , vec3(1. , 1. , 0.) , iTime * 0.8);\n    \n    float box = sdBox(pRot , vec3(0.20));\n    float sBox = sdSphere(p, 0.25);\n    float roundBox = smin(box,sBox,0.2);\n    \n    \n    float sphere = sdSphere(p - vec3(px  , py ,0.) , 0.2);\n    \n    return smin(roundBox,sphere,0.2);\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(f(p+h.xyy) - f(p-h.xyy),\n                           f(p+h.yxy) - f(p-h.yxy),\n                           f(p+h.yyx) - f(p-h.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float ratio = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord/(iResolution.x);\n    uv += vec2(0.,0.25);\n\n    vec3 camPo = vec3(0.,0.,2.);\n    vec3 rayPo = camPo;\n    vec3 ray = normalize(vec3((uv - vec2(0.5)) , -1));\n    \n    float t = 0.;\n    float tMax = 5.;\n\n    for(int i = 0 ; i < STEPS ; ++i){\n    \n        vec3 pos = rayPo + t * ray;\n        float h = f(pos);\n        if(h < 0.0001 || h > tMax)break;\n        t += h;\n    \n    }\n    \n    vec3 col = vec3(0.);\n    \n    if(t < tMax)\n    {\n        vec3 pos = rayPo + t * ray;\n        vec3 normal = calcNormal(pos);\n        \n        float diff = dot(vec3(0.1,0.  , 1.),normal);\n        col = vec3(diff);\n        vec2 matcapUV = matcap(ray , normal);\n        col = vec3(matcapUV,1.);\n        col = vec3(matcapUV,0.);\n        //col = texture( iChannel0, matcapUV ).xyz;\n       \n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 47, 81, 81, 105], [107, 107, 143, 143, 277], [279, 279, 310, 310, 397], [399, 435, 476, 476, 569], [571, 571, 612, 612, 1193], [1195, 1195, 1240, 1240, 1296], [1298, 1302, 1318, 1318, 1734], [1736, 1736, 1787, 1787, 2034], [2036, 2036, 2093, 2093, 2982]], "test": "valid"}
{"id": "flfSWn", "name": "wandering bubbles", "author": "EzaExponential", "description": "bubbles", "tags": ["colors", "bubbles", "colours"], "likes": 3, "viewed": 83, "published": "Public", "date": "1625411385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float GetCircle(vec2 uv, vec2 position, float radius)\n{ \n    //Get modified distance to circle\n    float dist = distance(position, uv); \n    dist =  smoothstep(dist - 0.6, dist, radius);\n    return dist * dist * dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{ \n    vec2 uv = 2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float pixel = 0.;\n    \n    // define bubbles \n    vec3 positions[8]; \n    float Time = iTime / 2.;\n    positions[0] = vec3(tan(Time * 1.4) * 1.3, cos(iTime * 2.3) * 0.4, 0.22);\n    positions[1] = vec3(tan(Time * 3.0) * 1.0, cos(iTime * 1.3) * 0.6, 0.12);\n    positions[2] = vec3(tan(Time * 2.1) * 1.5, cos(iTime * 1.9) * 0.8, 0.4);\n    positions[3] = vec3(tan(Time * 1.1) * 1.1, cos(iTime * 2.6) * 0.7, 0.15); \n    positions[4] = vec3(tan(Time * 1.8) * 1.1, cos(iTime * 2.1) * 0.5, 0.25); \n    positions[5] = vec3(tan(Time * 1.1) * 1.2, cos(iTime * 1.3) * 0.2, 0.15); \n    positions[6] = vec3(tan(Time * 1.7) * 1.4, cos(iTime * 2.4) * 0.3, 0.11);\n    positions[7] = vec3(tan(Time * 2.8) * 1.5, cos(iTime * 1.1) * 0.4, 0.21);   \n        \n        \n    for\t(int i = 0; i < 8; i++)\n        pixel += GetCircle(uv, positions[i].xy, positions[i].z);\n    \n    pixel = smoothstep(.8, 1., pixel) * smoothstep(1.5, .9, pixel);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); \n    //draw\n    fragColor = vec4(vec3(pixel) * col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 94, 219], [221, 221, 277, 277, 1435]], "test": "valid"}
{"id": "flfXDH", "name": "Oriented BBox of QBezier I", "author": "oneshade", "description": "Still haven't figured out a way to compute the tightest bbox of a quadratic bezier that seems surefire. Instead using linear regression on the bezier curve to try approximating the optimal orientation.", "tags": ["bezier", "quadratic", "boundingbox", "obb", "oriented", "linearregression"], "likes": 8, "viewed": 63, "published": "Public", "date": "1625553688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nStill haven't figured out a way to compute the tightest bbox of a\nquadratic bezier that seems surefire. Instead using analytical\nlinear regression of the bezier curve to try guessing an orientation.\n\nBased on and inspired by @fizzer's approach:\n\"Cubic Bezier Analytic OBB\": https://www.shadertoy.com/view/stfSR7\n\nWhen the OBB is red, it has a larger area than the axis aligned bbox.\nWhen the OBB is green, it has a smaller area than the axis aligned bbox.\n\nThe axis aligned bbox is yellow.\n(I think I need to modify my color scheme, somewhat low contrast :))\n*/\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nstruct AxisAlignedBBox { vec2 bmin; vec2 bmax; };\nstruct OrientedBBox { mat2 ori; vec2 bmin; vec2 bmax; };\n\n// SDFs\nfloat sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec2 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec2 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nfloat sdBBox(in vec2 p, in AxisAlignedBBox bbox) {\n    p = abs(p - 0.5 * (bbox.bmin + bbox.bmax)) - 0.5 * (bbox.bmax - bbox.bmin);\n    return abs(length(max(p, 0.0)) + min(0.0, max(p.x, p.y)));\n}\n\nfloat sdBBox(in vec2 p, in OrientedBBox bbox) {\n    return sdBBox(p * bbox.ori, AxisAlignedBBox(bbox.bmin, bbox.bmax));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\n// Best linear fit of discrete points on a qudratic bezier curve (not optimal)\n//#define N 50\n//vec2 linearFitBezierDiscrete(in vec2 v1, in vec2 v2, in vec2 v3) {\n//    vec4 w = vec4(0.0);\n//    for (float t=0.0; t < 1.0; t += 1.0 / float(N)) {\n//        vec2 p = mix(mix(v1, v2, t), mix(v2, v3, t), t);\n//        w += vec4(p, p * p.xx);\n//    }\n//\n//    float b = (w.y * w.z - w.x * w.w) / (float(N) * w.z - w.x * w.x);\n//    return vec2((w.w - w.x * b) / w.z, b);\n//}\n\n// Integrals instead of summations of discrete points\nvec2 linearFitBezierContinuous(in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1;\n\n    vec4 w;\n    w.x = a.x / 3.0 + 0.5 * b.x + c.x;\n    w.y = a.y / 3.0 + 0.5 * b.y + c.y;\n    w.z = (0.2 * a.x + 0.5 * b.x) * a.x + (2.0 * a.x * c.x + b.x * b.x) / 3.0 + (b.x + c.x) * c.x;\n    w.w = 0.2 * (a.x * a.y) + 0.25 * dot(a, b.yx) + (dot(a, c.yx) + b.x * b.y) / 3.0 + 0.5 * dot(b, c.yx) + c.x * c.y;\n\n    float rb = (w.y * w.z - w.x * w.w) / (w.z - w.x * w.x);\n    return vec2((w.w - w.x * rb) / w.z, rb);\n}\n\n// Axis aligned\nAxisAlignedBBox bezierAABB(in vec2 v1, in vec2 v2, in vec2 v3) {\n    AxisAlignedBBox bbox;\n    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1; // Coefficients\n\n    vec2 extrema = -0.5 * b / a;\n    bbox.bmin = min(v1, v3), bbox.bmax = max(v1, v3);\n    if (abs(extrema.x - 0.5) < 0.5) {\n        vec2 p = (a * extrema.x + b) * extrema.x + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    if (abs(extrema.y - 0.5) < 0.5) {\n        vec2 p = (a * extrema.y + b) * extrema.y + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    return bbox;\n}\n\n// Oriented\nOrientedBBox bezierOBB(in vec2 v1, in vec2 v2, in vec2 v3) {\n    OrientedBBox bbox;\n    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1; // Coefficients\n\n    // Linear regression\n    vec4 w;\n    w.x = a.x / 3.0 + 0.5 * b.x + c.x;\n    w.y = a.y / 3.0 + 0.5 * b.y + c.y;\n    w.z = (0.2 * a.x + 0.5 * b.x) * a.x + (2.0 * a.x * c.x + b.x * b.x) / 3.0 + (b.x + c.x) * c.x;\n    w.w = 0.2 * (a.x * a.y) + 0.25 * dot(a, b.yx) + (dot(a, c.yx) + b.x * b.y) / 3.0 + 0.5 * dot(b, c.yx) + c.x * c.y;\n\n    float rb = (w.y * w.z - w.x * w.w) / (w.z - w.x * w.x);\n    vec2 fit = vec2((w.w - w.x * rb) / w.z, rb);\n\n    // Compute the orientation matrix from the fitting\n    vec2 p1 = vec2(0.0, fit.y), p2 = vec2(1.0, fit.x + fit.y);\n    vec2 dir = normalize(p2 - p1);\n    bbox.ori = mat2(dir, -dir.y, dir.x);\n\n    // Reposition and reorient, then compute new a, b, and c\n    v1 -= p1, v2 -= p1, v3 -= p1;\n    v1 *= bbox.ori, v2 *= bbox.ori, v3 *= bbox.ori;\n    a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1;\n\n    // Axis aligned bbox in new coordinate frame\n    vec2 extrema = -0.5 * b / a;\n    bbox.bmin = min(v1, v3), bbox.bmax = max(v1, v3);\n    if (abs(extrema.x - 0.5) < 0.5) {\n        vec2 p = (a * extrema.x + b) * extrema.x + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    if (abs(extrema.y - 0.5) < 0.5) {\n        vec2 p = (a * extrema.y + b) * extrema.y + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    vec2 offs = p1 * bbox.ori;\n    bbox.bmin += offs, bbox.bmax += offs;\n\n    return bbox;\n}\n\n// --- Insert exact minimal area OBB code here. ---\n// Still haven't got it figured out but at least its only a parabola segment :/\n//OrientedBBox bezierOBB2(in vec2 v1, in vec2 v2, in vec2 v3) {\n//    OrientedBBox bbox;\n//\n//    \n//\n//    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1; // Coefficients\n//\n//    vec2 extrema = -0.5 * b / a;\n//    bbox.bmin = min(v1, v3), bbox.bmax = max(v1, v3);\n//    if (abs(extrema.x - 0.5) < 0.5) {\n//        vec2 p = (a * extrema.x + b) * extrema.x + c;\n//        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n//    }\n//\n//    if (abs(extrema.y - 0.5) < 0.5) {\n//        vec2 p = (a * extrema.y + b) * extrema.y + c;\n//        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n//    }\n//\n//    return bbox;\n//}\n\n// // https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 getPoint(in float id) {\n    float freq = Hash11(id * 393.84 + 673.48) * 4.0 - 2.0;\n    float phase = Hash11(id * 348.46 + 183.37);\n    float amp = Hash11(id * 275.35 + 741.69) * 4.0;\n    float ang = iTime * freq + phase;\n    return vec2(cos(ang), sin(ang)) * amp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.0);\n\n    // Grid\n    //drawSDF(abs(mod(uv.x + 0.25, 0.5) - 0.25), vec3(0.0, 0.0, 1.0));\n    //drawSDF(abs(mod(uv.y + 0.25, 0.5) - 0.25), vec3(0.0, 0.0, 1.0));\n    //drawSDF(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    //drawSDF(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Vignette\n    color -= pow(length(fragCoord / iResolution.xy - 0.5), 1.5);\n\n    // Bezier control points\n    vec2 a = getPoint(10.0);\n    vec2 b = getPoint(8.0);\n    vec2 c = getPoint(4.0);\n\n    // Fit it with a line\n    vec2 fit = linearFitBezierContinuous(a, b, c);\n    drawSDF(abs(uv.y - (fit.x * uv.x + fit.y)) / sqrt(1.0 + fit.x * fit.x), vec3(1.0, 0.0, 1.0));\n\n    // Draw the different bounding boxes\n    AxisAlignedBBox aabb = bezierAABB(a, b, c);\n    float aabbArea = (aabb.bmax.x - aabb.bmin.x) * (aabb.bmax.y - aabb.bmin.y);\n    drawSDF(sdBBox(uv, aabb), vec3(1.0, 0.8, 0.0));\n\n    OrientedBBox obb = bezierOBB(a, b, c);\n    float obbArea = (obb.bmax.x - obb.bmin.x) * (obb.bmax.y - obb.bmin.y);\n    drawSDF(sdBBox(uv, obb), obbArea > aabbArea ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n\n    // Draw hull\n    drawSDF(sdLine(uv, a, b, 0.001), vec3(0.5, 0.0, 1.0));\n    drawSDF(sdLine(uv, b, c, 0.001), vec3(0.5, 0.0, 1.0));\n\n    // Draw bezier\n    drawSDF(sdBezier(uv, a, b, c) - 0.01, vec3(0.0));\n\n    // Draw control points\n    drawSDF(sdDisk(uv, a, 0.05), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisk(uv, b, 0.05), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisk(uv, c, 0.05), vec3(1.0, 0.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfXDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[768, 776, 839, 839, 2052], [2054, 2054, 2104, 2104, 2249], [2251, 2251, 2298, 2298, 2372], [2374, 2374, 2433, 2433, 2545], [2547, 2547, 2595, 2595, 2627], [3100, 3154, 3222, 3222, 3701], [3703, 3719, 3783, 3783, 4332], [4334, 4346, 4406, 4406, 5919], [6711, 6755, 6781, 6781, 6867], [6869, 6869, 6897, 6897, 7139], [7141, 7141, 7196, 7215, 9034]], "test": "error"}
{"id": "flfXDn", "name": "Retro cube effect with twist", "author": "mrange", "description": "License CC0: Retro cube effect with twist\nWe made a retro demo some time ago and wanted a version of the classic Amiga effect:\nMusic: Hyperbased by Firefox: https://soundcloud.com/firefox-amigamus", "tags": ["3d", "raymarch", "retro"], "likes": 23, "viewed": 375, "published": "Public API", "date": "1625421836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Retro cube effect with twist\n//  We made a retro demo some time ago and in one of the effects\n//  We wanted to recreate the classic \"Amiga Cube that intersects a translucent plane\"\n//  But having accesss to a few more Teraflops than the Amiga we wanted to add a bit of a twist to it\n//  Music: Hyperbased by Firefox: https://soundcloud.com/firefox-amigamusician/hyperbased\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            (iTime+155.0)\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(a)         (0.5+0.5*cos(a))\n#define PSIN(a)         (0.5+0.5*sin(a))\n#define L2(x)           dot(x, x)\n#define SCA(a)          vec2(sin(a), cos(a))\n#define MISS            1E6\n#define BTIME(n)        (n*beat+start)\n\n#define CUBE_TOLERANCE       0.0001\n#define CUBE_MAX_RAY_LENGTH  8.0\n#define CUBE_MAX_RAY_MARCHES 80\n#define CUBE_NORM_OFF        0.0005\n\nconst float beat            = 0.48;\nconst float start           = 41.1;\nconst float bounce_freq     = 0.5/beat;\n\nconst mat2 rot0             = ROT(0.00);\nconst vec3 std_gamma        = vec3(2.2);\n\nconst float cube_begin      = BTIME(240.0); // ~156\nconst float cube_flash0     = BTIME(334.0);\nconst float cube_flash1     = BTIME(335.0);\nconst float cube_end        = BTIME(336.0);\n\n// GLOBAL MUTABLES\n\nvec4  cube_g_plane       = vec4(normalize(vec3(1.0, 0.0, 0.0)), 0.0);\nfloat cube_g_pw          = 0.0;\nmat2 cube_g_rotxy        = rot0;\nmat2 cube_g_rotxz        = rot0;\nmat2 cube_g_rotxw        = rot0;\nmat2 cube_g_rotyw        = rot0;\nmat2 cube_g_rotzw        = rot0;\n\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat plane(vec3 p, vec4 plane) {\n  return dot(plane.xyz, p)+plane.w;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n// -----------------------------------------------------------------------------\n// CUBE\n// -----------------------------------------------------------------------------\n\nvec2 cube_mengerSponge(vec4 p) {\n  float db = box(p, vec4(1.0));\n  if(db > .125) vec2(db, db);\n\n  float d_ = db;\n  float res = d_;\n\n  float s = 1.0;\n  for(int m = 0; m < 4; ++m) {\n    float ss = 0.75;\n    vec4 a = mod(p*s, 2.0)-1.0;\n    s *= 3.0;\n    vec4 r = abs(1.0 - 3.0*abs(a));\n\n    float da = max(max(r.x,r.y),r.w);\n    float db = max(max(r.y,r.z),r.w);\n    float dc = max(max(r.z,r.x),r.w);\n    float dd = max(max(r.z,r.x),r.y);\n    float df = length(r)-2.16;\n\n    float du = da;\n    du = min(du, db);\n    du = min(du, dc);\n    du = pmin(du, dd, ss); // Soften the edges a bit\n    du = max(du, -df);\n    du -= 1.0;\n    du /= s;\n\n    res = max(res, du);\n  }\n\n  return vec2(db, res);\n}\n\nfloat cube_intersectTransformPlane(vec3 ro, vec3 rd) {\n  return rayPlane(ro, rd, cube_g_plane);\n}\n\nfloat cube_dtransformPlane(vec3 p) {\n  return plane(p, cube_g_plane);\n}\n\nfloat cube_df(vec3 p) {\n  float dp = cube_dtransformPlane(p);\n  const float s = 1.0/3.0;\n  p /= s;\n  p.xy *= cube_g_rotxy;\n  p.xz *= cube_g_rotxz;\n  vec4 pp = vec4(p, cube_g_pw);\n  pp.xw *= cube_g_rotxw;\n  pp.yw *= cube_g_rotyw;\n  pp.zw *= cube_g_rotzw;\n\n  // TODO: Optimize\n  vec2 dms = cube_mengerSponge(pp);\n\n  float d0 = dms.x*s;\n  float d2 = d0;\n  d0 = max(dp, d0);\n\n  float d1 = dms.y*s;\n  d1 = max(-dp, d1);\n  return max(d2, pmin(d0, d1, 0.05));\n}\n\nfloat cube_rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < CUBE_MAX_RAY_MARCHES; i++) {\n    float d = cube_df(ro + rd*t);\n    if (d < CUBE_TOLERANCE || t > CUBE_MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 cube_normal(vec3 pos) {\n  vec2  eps = vec2(CUBE_NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = cube_df(pos+eps.xyy) - cube_df(pos-eps.xyy);\n  nor.y = cube_df(pos+eps.yxy) - cube_df(pos-eps.yxy);\n  nor.z = cube_df(pos+eps.yyx) - cube_df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat cube_softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = cube_df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 cube_transformPlane(vec3 ro, vec3 rd, vec4 plane, out float ttp) {\n  vec3 tnor = plane.xyz;\n  float t = rayPlane(ro, rd, plane);\n  ttp = t;\n  if (t < 0.0) return vec3(0.0);\n  vec3 tp = ro + t*rd;\n  float td = cube_df(tp);\n  td -= 0.025;\n  float otd = td;\n  td = abs(td)- 0.005;\n  const vec3 tup = vec3(0.0, 1.0, 0.0);\n  vec3 txx = normalize(cross(tnor, tup));\n  vec3 tyy = normalize(cross(tnor, txx));\n  vec2 tp2 = vec2(dot(txx, tp), dot(tyy, tp));\n  float a  = mix(0.0, PI/4.0 + 0.5*(TIME-BTIME(288.0)), smoothstep(BTIME(288.0), BTIME(292.0), TIME));\n  tp2 *= ROT(a);\n  float tpd = box(tp2, 0.6*vec2(4.0/3.0, 1.0));\n  float taa = 0.001;\n  mod2(tp2, vec2(0.125));\n  float tpgd = min(abs(tp2.x), abs(tp2.y));\n  tpgd = max(tpgd, -otd);\n  tpgd = max(tpgd, tpd);\n  float tgd = tpd;\n  tgd -= 0.0125;\n  tgd = abs(tgd)- 0.005;\n  tgd = min(tgd, td);\n\n  const vec3 greenGlow = vec3(1.25, 2.0, 1.25);\n  const vec3 redGlow = vec3(2.0, 1.25, 1.5);\n  vec3 tcol = vec3(0.0125);\n  tcol += greenGlow*exp(-max(tpgd, 0.0)*900.0);\n  tcol += greenGlow*(1.0-abs(dot(rd, tnor)))*0.2*PSIN(500.*tp2.y);\n  tcol = mix(vec3(0.0), tcol, smoothstep(-taa, taa, -(tpd-0.025)));\n  tcol += redGlow*exp(-max(tgd, 0.0)*100.0);\n  return tcol;\n}\n\nvec3 cube_render(in vec3 ro, in vec3 rd) {\n  vec3 lightPos = 2.0*vec3(1.5, 3.0, 1.0);\n\n  float alpha   = 0.05*TIME;\n  vec3 tnor     = normalize(vec3(1.0, 0.0, 0.0));\n  tnor.xy       *= ROT(PI*(1.0-cos(sqrt(0.3)*max(TIME-BTIME(296.0), 0.0))));\n  tnor.xz       *= ROT(PI*(1.0-cos(sqrt(0.15)*max(TIME-BTIME(304.0), 0.0))));\n\n  float tm      = -0.5*(cos((2.0*TAU/(4.0/beat))*max(TIME-BTIME(292.0), 0.0)));\n  tm  = mix(0.75 , tm, smoothstep(BTIME(272.0), BTIME(288.0), TIME));\n  tm  = mix(-0.75, tm, smoothstep(BTIME(248.0), BTIME(272.0), TIME));\n  tm  = mix(-3.0 , tm, smoothstep(BTIME(244.0), BTIME(248.0), TIME));\n\n  vec4 plane    = vec4(tnor, tm);\n\n  cube_g_plane       = plane;\n  cube_g_rotxy       = ROT(TIME);\n  cube_g_rotxz       = ROT(TIME*sqrt(0.5));\n  cube_g_pw          = 0.5*cos(alpha*sqrt(2.0));\n  cube_g_rotxw       = ROT(alpha);\n  cube_g_rotyw       = ROT(alpha*sqrt(0.5));\n  cube_g_rotzw       = ROT(alpha*sqrt(2.0));\n\n//  tnor.xy *= g_rotxy;\n  // background color\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = cube_rayMarch(ro, rd, iter);\n  float tp;\n  vec3 tcol = cube_transformPlane(ro, rd, plane, tp);\n  tcol = mix(vec3(0.0), tcol, float(tp < t));\n\n  float ifade = 1.0-tanh_approx(2.0*float(iter)/float(CUBE_MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;\n  vec3 nor = vec3(0.0, 1.0, 0.0);\n\n  vec3 color = vec3(0.0);\n\n  float dp   = -(ro.y+1.)/rd.y;\n\n  if (dp > 0.0 && dp < t) {\n    // Ray intersected plane\n    t   = dp;\n    pos = ro + t*rd;\n    nor = vec3(0.0, 1.0, 0.0);\n    vec2 pp = pos.xz*1.5;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.025);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(100.0, 10.0, m)*dp), 1.0);\n    color = 2.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n  } else if (t < CUBE_MAX_RAY_LENGTH) {\n    // Ray intersected object\n    nor        = cube_normal(pos);\n    vec3 hsv   = (vec3(-0.2+0.25*t, 1.0-ifade, 1.0));\n    color = hsv2rgb(hsv);\n  } else {\n    // Ray intersected sky\n    return (skyCol)*ifade+tcol;\n  }\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = cube_softShadow(pos, ld, ll, 0.01, 64.0);\n\n  float dm  = min(1.0, 40.0/ll2);\n  float dif = max(dot(nor,ld),0.0)*dm;\n  float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 10.);\n  float l   = dif*sha;\n\n  float lin = mix(0.2, 1.0, l);\n\n  vec3 col = lin*color + spe*sha;\n\n  float f = exp(-20.0*(max(t-3.0, 0.0) / CUBE_MAX_RAY_LENGTH));\n\n  return (mix(skyCol, col , f))*ifade+tcol;\n}\n\nvec3 cube_effect(vec2 p, vec2 q) {\n  float m = smoothstep(BTIME(264.0), BTIME(272.0), TIME);\n  float tm = TIME-BTIME(264.0);\n  // camera\n  vec3 ro = mix(1.0, 0.6, m)*vec3(2.0, 0, 0.2)+vec3(0.0, 0.25, 0.0);\n  ro.xz *= ROT(mix(0.0, tm*0.25, m));\n  ro.yz *= ROT(-(1.0-PCOS(tm*0.25*sqrt(0.5)))*0.25);\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return cube_render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = cube_effect(p, q);\n\n  col = postProcess(col, q);\n  col = mix(vec3(1.0), col, smoothstep(cube_begin+0.25, cube_begin+1.5, TIME));\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "ltfSWS", "previewfilepath": "https://soundcloud.com/firefox-amigamusician/hyperbased", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/firefox-amigamusician/hyperbased", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfXDn.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1805, 1805, 1844, 1844, 1933], [1935, 1935, 1977, 1977, 2024], [2026, 2026, 2054, 2074, 2150], [2152, 2152, 2185, 2185, 2223], [2225, 2225, 2252, 2252, 2328], [2330, 2330, 2357, 2357, 2454], [2456, 2456, 2492, 2492, 2586], [2588, 2588, 2610, 2610, 2779], [2781, 2808, 2844, 2844, 3077], [3250, 3250, 3282, 3282, 3940], [3942, 3942, 3996, 3996, 4039], [4041, 4041, 4077, 4077, 4112], [4114, 4114, 4137, 4137, 4568], [4570, 4570, 4623, 4623, 4838], [4840, 4840, 4868, 4868, 5111], [5113, 5113, 5186, 5186, 5470], [5472, 5472, 5543, 5543, 6685], [6687, 6687, 6729, 6729, 9285], [9287, 9287, 9321, 9321, 9808], [9810, 9810, 9865, 9865, 10138]], "test": "error"}
{"id": "flfXzX", "name": "MovingQuadtree", "author": "FoRenard", "description": "Use Quadtree", "tags": ["quadtree"], "likes": 7, "viewed": 164, "published": "Public", "date": "1626147800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592;\n\n#define AA 2\nmat2 rotate2d(float _angle) {\n    return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nstruct di {\n    vec2 p;\n    vec2 i;\n};\n\ndi devision(in vec2 p) {\n    float dec = 4.;\n    vec2 res = fract(p * dec);\n    vec2 ind = floor(p * dec) / dec;\n    float pl = abs(floor(sin(iTime))) * .3;\n    for(float i = 0.; i < 4.; i++) {\n        if(rand(ind + i) < .5) {\n            dec *= 2.;\n            res = fract(p * dec);\n            ind = floor(p * dec) / dec;\n        } else {\n            break;\n        }\n    }\n    return di(res, ind);\n}\n\nfloat circle(in vec2 p) {\n    p -= vec2(.5);\n    return floor(4. * dot(p, p));\n}\n\nfloat cros(in vec2 p) {\n    p -= vec2(.5);\n    float r = (abs(p.x) < .15) || (abs(p.y) < .15) ? 0. : 1.;\n    return r;\n}\n\nfloat rcros(in vec2 p) {\n    p -= vec2(.5);\n    p *= rotate2d(PI / 4.);\n    p += vec2(.5);\n    return cros(p);\n}\n\nfloat box(in vec2 p) {\n    p -= vec2(.5);\n    return (abs(p.x) < .3) && (abs(p.y) < .3) ? 0. : 1.;\n}\n\nfloat ibox(in vec2 p) {\n    return 1. - box(p);\n}\n\nvec2 movep(in vec2 p, in float r) {\n    float t = cos(mod(iTime, PI));\n    vec2 ep = p + (r < .5 ? vec2(t, 0.) : vec2(0., t));\n    return fract(ep);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 cols=vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (fragCoord+o)/iResolution.y;\n        //vec2 p = fragCoord / min(iResolution.x,iResolution.y);\n        di dis = devision(p);\n        p = dis.p;\n        vec2 ind = dis.i;\n\n        float d = 1., r;\n        r = rand(ind * .11);\n\n        p = movep(p, r);\n\n        if(r < .2) {\n            d = circle(p);\n        } else if(r < .4) {\n            d = cros(p);\n        } else if(r < .6) {\n            d = rcros(p);\n        } else if(r < .8) {\n            d = box(p);\n        } else {\n            d = ibox(p);\n        }\n\n        vec3 color = vec3(d);\n        cols+=color;\n    }\n    cols/=float(AA*AA);\n    fragColor = vec4(cols, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 70, 70, 142], [144, 144, 164, 164, 233], [275, 275, 299, 299, 677], [679, 679, 704, 704, 759], [761, 761, 784, 784, 881], [883, 883, 907, 907, 995], [997, 997, 1019, 1019, 1097], [1099, 1099, 1122, 1122, 1148], [1150, 1150, 1185, 1185, 1300], [1302, 1302, 1357, 1357, 2181]], "test": "valid"}
{"id": "fljSDz", "name": "Canyon Fog", "author": "Ubiquitous", "description": "Playing with fog shadows and blur...", "tags": ["blur", "fog", "shadows", "rocks", "flythrough", "granite", "canyon"], "likes": 8, "viewed": 114, "published": "Public", "date": "1627450291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tCanyon Fog\n    -----------\n    Modified From: [https://www.shadertoy.com/view/ltGBRR, https://www.shadertoy.com/view/MlG3zh]\n\n\tCombining some cheap distance field functions with some functional and texture-based bump \n\tmapping to carve out a rocky canyon-like passageway.\n\n\tThere's nothing overly exciting about this example. I was trying to create a reasonably\n    convincing looking rocky setting using cheap methods.\n\n\tI added in some light frosting, mainly to break the monotony of the single colored rock.\n\tThere's a mossy option below, for anyone interested. Visually speaking, I find the moss more\n\tinteresting, but I thought the frost showed the rock formations a little better. Besides,\n\tI'd like to put together a more dedicated greenery example later.\n\n    2021 Update: Playing with some fog and blur.\n\n*/\n\n#define PI 3.14159265\n#define FAR 60.\n\n// Extra settings. Use one or the other. The MOSS setting overrides the HOT setting.\n// Mossy setting. Better, if you want more color to liven things up. For this example, I wanted subtlety.\n//#define MOSS \n// Hot setting. It represents 2 minutes of post processing work, so it's definitely nothing to excited about. :)\n//#define HOT\n\n// Coyote's snippet to provide a virtual reality element. Really freaky. It gives the scene \n// physical depth, but you have to do that magic picture focus adjusting thing with your eyes.\n//#define THREE_D \n\n\n// Rotation matrix.\nconst mat2 rM = mat2(.7071, .7071, -.7071, .7071); \n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    //vec3 col = mix(vec3(.7, 1, 1.3), vec3(1), n.y*.5 + .5);\n    \n    n = max(abs(n) - 6.5, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);//*col;\n}\n\n\n// Cellular tile setup. Draw four overlapping objects (spheres, in this case) \n// at various positions throughout the tile.\n \nfloat drawObject(in vec3 p){\n  \n    p = fract(p)-3.14;\n    return dot(p, p);\n    \n}\n\n\n// 3D cellular tile function.\nfloat cellTile(in vec3 p){\n   \n    vec4 d; \n    \n    // Plot four objects.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy *= rM;\n    d.y = drawObject(p - vec3(1.6, .82, .64));\n    p.yz *= rM;\n    d.z = drawObject(p - vec3(.51, .06, .70));\n    p.zx *= rM;\n    d.w = drawObject(p - vec3(.22, .62, .64));\n\n\t// Obtaining the minimum distance.\n    d.xy = min(d.xz, d.yw);\n    \n    // Normalize... roughly. Trying to avoid another min call (min(d.x*A, 1.)).\n    return  min(d.x, d.y)*0.9;\n    \n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n// https://www.shadertoy.com/view/4ts3z2\nvec3 tri(in vec3 x){return abs(fract(x)-.51);} // Triangle function.\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){\n   \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.03);\n    float b = cos(z * 0.17);\n    return vec2(a*3.8 -b*-1.8, b*1.7 + a*2.8); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n\n\n// A fake noise looking sinusoial field - flanked by a ground plane and some walls with\n// some triangular-based perturbation mixed in. Cheap, but reasonably effective.\nfloat map(vec3 p){\n    \n \n    p.xy -= path(p.z); // Wrap the passage around\n    \n    vec3 w = p; // Saving the position prior to mutation.\n    \n    vec3 op = tri(p*.4*3. + tri(p.zxy*.1*2.)); // Triangle perturbation.\n   \n    \n    float ground = p.y + 1.4 + dot(op, vec3(.511))*0.22; // Ground plane, slightly perturbed.\n \n    p += (op - 0.55)*.53; // Adding some triangular perturbation.\n   \n\tp = cos(p*.51*0.51 + sin(p.zxy*1.09*1.12)); // Applying the sinusoidal field (the rocky bit).\n    \n    float canyon = (length(p) - 0.032)*0.22 - (w.x*w.x)*0.055; // Spherize and add the canyon walls.\n    \n    return min(ground, canyon);\n\n    \n}\n\n\n\n// Surface bump function. I'm reusing the \"cellTile\" function, but absoulte sinusoidals\n// would do a decent job too.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n    \n    //return (cellTile(p/1.5))*.66 + (cellTile(p*2./1.5))*.34;\n    \n    return cellTile(p/1.5);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(4.201, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\nfloat accum;\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n\n    float t = 0.4, h;\n    for(int i = 0; i < 160; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.35 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;//*.7;\n        \n        if(abs(h)<0.15) accum += (.12-abs(h))/26.;///(1.+t);//.0005/abs(h);\n        //if(abs(h)<0.25)accum += (.25-abs(h))*vec3(3, 2, 1)/4.*n3D((ro+rd*t)*16. - vec3(0, 0, 1)*iTime*1.);\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n/*\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO2( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n*/\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.7;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.61 - occ, 0.2, 1.); // lower base shadow   \n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.001, -0.001); \n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Shadows.\nfloat shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 33.3;\n    const int shadIter = 5; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 1.32, 1.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.3) + 1.4, 1.0); \n}\n\n//////\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected (or refracted) ray at the surface \n// hit point, then index into a repeat texture in some way. It can be pretty convincing \n// (in an abstract way) and facilitates environment mapping without the need for a cube map, \n// or a reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\n\nvec3 envMap(vec3 rd, vec3 n){\n    \n    return tex3D(iChannel0, rd, n);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    #ifdef THREE_D\n    float sg = sign(fragCoord.x - 0.5*iResolution.x);\n    uv.x -= sg*.25*iResolution.x/iResolution.y;\n    #endif\n\t\n\t// Camera Setup.\n    vec3 camPos = vec3(1.1, 0.1, iTime*6.); // Camera position, doubling as the ray origin.\n\n\tvec3 lookAt = camPos + vec3(0.3, 0.2, 2.3);  // \"Look At\" position.\n\n \n    // Light positioning. The positioning is fake. Obviously, the light source would be much \n    // further away, so illumination would be relatively constant and the shadows more static.\n    // That's what direct lights are for, but sometimes it's nice to get a bit of a point light \n    // effect... but don't move it too close, or your mind will start getting suspicious. :)\n \tvec3 lightPos = camPos + vec3(-30, 10, -50);\n\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\t//lightPos.xy += path(lightPos.z);\n    \n    \n    #ifdef THREE_D\n    camPos.x -= sg*3.15; lookAt.x -= sg*3.15; lightPos.x -= sg*3.15;\n    #endif\n    \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 4.333;//PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, -0.12, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Lens distortion.\n    //vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/14. )*rd.xy;\n\n    /*    \n    // Mouse controls. I use them as a debugging device, but they can be used to look around. \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*/\n    \n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);   \n    \n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        //vec3 sn = -(mask * sign( rd ));\n        vec3 sn = calcNormal(sp);\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1.5/4.3;\n        \n        \n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, 1.5);\n        \n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, 4.2);//(-sign(sn.y)*.15+.85)*\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n        \n        // Shadows.\n        float shading = shadows(sp + sn*.065, ld, 1.45, lDist, 44.);\n        \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);//*.75 + .25;\n\n\t    \n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(3.3 + lDist*.057);\n    \t\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 1.1);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.7 ), 52.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 2.1, .5, 1.), 1.3);\n        \n        // Ambient light, due to light bouncing around the the canyon.\n\t    float ambience = 0.55*ao + fre*fre*.25;\n\n        // Object texturing, coloring and shading.\n\t    vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n\n        // Tones down the pinkish limestone\\granite color.\n        //texCol *= mix(vec3(.7, 1, 1.3), vec3(1), snNoBump.y*.5 + .5);\n        \n        #ifdef MOSS\n        // Some quickly improvised moss.\n        texCol = texCol*mix(vec3(1), vec3(.3, 3.5, 1.5), abs(snNoBump));\n        texCol = texCol*mix(vec3(1), vec3(.6, 1, 1.5), pow(abs(sn.y), 7.));\n        #else\n        // Adding in the white frost. A bit on the cheap side, but it's a subtle effect.\n        // As you can see, it's improvised, but from a physical perspective, you want the frost to accumulate\n        // on the flatter surfaces, hence the \"sn.y\" factor. There's some Fresnel thrown in as well to give\n        // it a tiny bit of sparkle.\n        texCol = mix(texCol, vec3(.45, .65, 1)*(texCol*.5+.5)*vec3(2), ((snNoBump.y*.5 + sn.y*.5)*.3+.5)*pow(abs(sn.y), 64.)*texCol.r*fre*1.);\n        #endif      \n\n        \n        // Final color. Pretty simple.\n        sceneCol = texCol*(diff + spec + ambience);// + vec3(.2, .5, 1)*spec;\n        \n        // A bit of accumulated glow.\n        sceneCol += texCol*((sn.y)*3.5+.5)*min(vec3(1, 0.75, 0.5)*accum, 1.4);  \n     \n        \n        // Adding a touch of Fresnel for a bit of glow.\n        sceneCol += texCol*vec3(.7, .65, 1)*pow(fre, 24.)*.2;\n        \n        \n        // Faux environmental mapping. Adds a bit more ambience.        \n        vec3 sn2 = snNoBump*.5 + sn*.5;\n        vec3 ref = reflect(rd, sn2);//\n        vec3 em = envMap(ref/2., sn2);\n        ref = refract(rd, sn2, 1./1.31);\n        vec3 em2 = envMap(ref/8., sn2);\n        //sceneCol += ((sn.y)*.25+.75)*sceneCol*(em + em2);\n        sceneCol += sceneCol*2.*(sn.y*.45+.75)*mix(em2, em, pow(fre, 2.4));\n\n\n\t    // Shading. Adding some ambient occlusion to the shadow for some fake global lighting.\n        sceneCol *= atten*min(shading + ao*.15, 1.)*ao;\n\t   \n\t\n\t}\n    \n       \n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fog = vec3(0.7, 0.8, 1.4)*(rd.y*0.6 + 0.3);\n    #ifdef MOSS\n    fog *= vec3(24, 1.4, 2.5);\n    #else\n    #ifdef HOT\n    fog *= 8.5;\n    #endif\n    #endif\n    sceneCol = mix(sceneCol, fog, smoothstep(0.06, .15, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n    \n    \n    //sceneCol *= vec3(.5, .75, 1.5); // Nighttime vibe.\n    #ifndef MOSS\n    #ifdef HOT\n    float gr = dot(sceneCol, vec3(.299, .187, .414)); // Grayscale.\n    // A tiny portion of the original color blended with a very basic fire palette.\n    sceneCol = sceneCol*.4 + pow(min(vec3(1.1, 1, 1)*gr*1.2, 1.), vec3(1, 1, 16));\n    // Alternative artsy look. Comment out the line above first.\n    //sceneCol = mix(sceneCol, pow(min(vec3(1.5, 1, 1)*gr*1.2, 1.), vec3(1, 3, 16)), -uv.y + .5);\n    #endif\n    #endif\n    \n    // Subtle, bluish vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneCol = mix(vec3(0, .2, 1), sceneCol, pow( 24.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .025)*.15 + .85);\n    \n\n    // Clamp and present the badly gamma corrected pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0.01, 0.8)), 1.1);\n\t\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1478, 1630, 1651, 1651, 1717], [1720, 1874, 1920, 1987, 2521], [2650, 2650, 2678, 2678, 2733], [2736, 2766, 2792, 2792, 3264], [3267, 3506, 3526, 3526, 3552], [3578, 3678, 3700, 3739, 3942], [3946, 4115, 4133, 4133, 4752], [4756, 4874, 4914, 4982, 5022], [5024, 5074, 5131, 5131, 5533], [5535, 5722, 5784, 5784, 6294], [6313, 6334, 6370, 6370, 7023], [7780, 7932, 7972, 7972, 8241], [8244, 8437, 8464, 8573, 8723], [8956, 8968, 9048, 9048, 9657], [10269, 10269, 10298, 10298, 10341], [10345, 10345, 10401, 10427, 18401]], "test": "error"}
{"id": "fljSW1", "name": "Lucerna Silva-Pastorensis", "author": "evvvvil", "description": "Lucerna Silva-Pastorensis - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_\n", "tags": ["demoscene", "flower", "organic", "petals", "leaves", "london", "buds", "bush", "stems", "horticulture", "shepherd"], "likes": 40, "viewed": 389, "published": "Public", "date": "1627575522", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Lucerna Silva-Pastorensis - \"The light of Shepherd's Bush\"\n// I discovered this flower growing in London on Shepherd'Bush high-street, between KFC and McDonalds.\n// Aptly named in ye-olde-broken-horticultural-Latin by yours truly.\n\n//\"Yeah I seen this fucking flower round Bush... Bloody thing popped out of my Happy Meal box...\n//\"Never been so fucking scared in my life, bruvs. It put me right off my chicken nuggets.\" Aaron Buckwheat - clearly easily shook local QPR fan.\n\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,v,e=vec2(.00035,-.00035);float t,tt,g,tn,b,bb,bbb,ridges;vec3 po,no,al,ld,pp; //GLOBAL VARS\nfloat cy(vec3 p,vec2 r){ return max(length(p.xz)-r.x,abs(p.y)-r.y);} //CYLINDER ALONG Y PRIMITIVE\nfloat smin(float a,float b,float k){float h=max(0.,k-abs(a-b));return min(a,b)-h*h*.25/k;  } //SMOOTH BLENd\nfloat smax(float a,float b,float k){float h=max(0.,k-abs(-a-b));return max(-a,b)+h*h*.25/k;  } //SMOOTH SUBSTRACTION\nvec2 smin( vec2 a, vec2 b,float k ){ float h=clamp(.5+.5*(b.x-a.x)/k,.0,1.);return mix(b,a,h)-k*h*(1.0-h);} //SMOOTH BLEND WITH MATERIAL ID AS WELL\nmat2 r2(float r){ return mat2(cos(r),sin(r),-sin(r),cos(r)); } //ROTATE 2D FUNCTION\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nfloat leaf( vec3 p){ //CREATES A LEAF\n  float leafD=cos(p.z*2.)*.3; //LEAF DEFORMER\n  vec3 lp=pp=p;  //LEAF+RIDGE POSITION\n  pp.z=abs(pp.z); //ABS SYMETRY RIDGES POSITION\n  pp.xz*=r2(.785-sin(pp.x*2.)*.2);   //ROTATE POSITION TOWARDS END OF LEAF\n  float bulge=sin(abs(p.z*1.5))*.4; //BULGE LEAF WITH SEAM IN MIDDLE WHERE STEM IS\n  ridges=abs(sin(pp.x*10.))*.1;  //RDIGES ON LEAF ITSELF\n  pp.z=abs(pp.z);  // EXTRA SPLIT VEIN / RIDGE\n  pp.xz*=r2(-.185);  //EXTRA RIDGE SPLIT LIKE FORK\n  ridges+=abs(sin(pp.x*10.))*.1;  //EXTRA RIDGE ADDED\n  lp.y-=bulge+ridges*.5*(min(1.,1.-(length(p.xz*vec2(.7,1.))-1.))); //MODIFY LEAF POSITION WITH DEFORMERS, BULGE ETC\n  lp.z-=sin(abs(pp.x)*10.)*.1;  //MAKE LEAF MORE PINCHED . LONGER LIKE ELLIPSI RATHER THAN CYLINDER\n  float t=.55*cy(lp+tn,vec2(2.+leafD,.02-ridges/tn*.0135));// ACTUAL LEAF, WITH THE EATEN OUT THING //float t=.5*cy(lp+tn,vec2(2+leafD,.02)); //NON EATEN LEAF   \n  float stem=0.7*max(length(p.yz-vec2(0.1+cos(p.x*.5)*.05,0.))-.08-min(.03,p.x*.02),abs(p.x-2.7)-7.);//leaf stem\n  t=smin(stem,t,.25);//add stem to leaf\n  return t;\n}\nfloat petal( vec3 p){  \n  p.y-=tn;//GIVE PETAL CRUNCHY DETAILS BY RE-USING TEXTURE NOISE\n  pp=p;pp.xz*=r2(.785);  //ROTATE PETALS AWAY FROM LEAF BRANCHES\n  float t=0.7*cy(p,vec2(2.-cos(p.x*2.)*.3-tn*3.,.015)); //PETAL MADE OF DEFORMED CYLINDER\n  t=smin(t,0.75*max(length(abs(pp.yz)-vec2(0,1.5-pp.x*.25))-.1,abs(pp.x)-7.0),.5); //ADD CYLINDER ON EDGES OF PETAL TO GIVE IT MORE MENACING / UNUSUAL LOOK\n  return t;\n}\nvec2 mp( vec3 p, float ga){\n  vec3 np,bp,rp,op; //DEFINE VARIABLES\n  op=np=p; //REMEMBER OP AS ORIGINAL POS AS WE WILL CHANGE IT\n  p.xz*=r2(sin(p.y*.3+tt*.3+bb)*.3);  //TWIST WHOLE FLOWER A BIT\n  p.xy*=r2(sin(p.y*.1+tt*.3+bb)*.3); //TWIST WHOLE FLOWER A BIT AGAIN\n  tn=texNoise(p.xz*.05,iChannel0).r*.6; //SAMPLE PERLIN NOISE TEXTURE TO ADD ORGANIC FEEL\n  np=bp=pp=rp=p; //SETUP POSITIONS VARIABLES FOR LATER\n  pp.x=abs(pp.x)-6.5;    //LEAVES POSITION\n  pp.y+=sin(pp.x)*.6; //WAVE THE LEAVES\n  pp.x*=-1.; //BULLSHIT SHIFT TO CORRECT MISTAKE IN LEAF FUNCTION\n  pp.z=abs(pp.z)-6.5; //MAKE MORE LEAVES\n  pp.xz*=r2(-.785);    //SHIFT IN POSITION\n  pp.y=mod(pp.y,5.)-2.5; //INFINITE AMOUNT OF LEAF NODES ALONG Y\n  vec2 h,t=vec2(max(leaf(pp),abs(p.y-3.8)-7.),0.); //LEAVES, CUT ONES ABOVE CERTAIN HEIGHT\n  float trunkD=sin(p.y*1.75)*.2; //TRUNK DEFORMER\n  float trunk=length(p.xz)-.75-trunkD; //TRUNK\n  float core=trunk+.1; //OPTIMIZED WAY TO CREATE A CORE BASED ON GEOM BY JUST SHIFTING DF FURTHER\n  np.xz*=r2(.785); //SIDE TRUNKS POSITION\n  np.xz=abs(np.xz)-.5-trunkD; \n  trunk=smax(length(np.xz)-.3-trunkD,trunk,.1); //SIDE TRUNK cut hole to reveal core in trunk \n  t.x=smin(t.x,trunk,.5);   // ADD TRUNK TO SCENE\n  bp.y=abs(abs(bp.y)-5.)-2.5; //TRUNK BUDS POSITION\n  bp.xz=abs(bp.xz)-1.; //CLONE SYMETRY TO GET MORE\n  bp.xz-=trunkD;  //SHIFT TRUNK BUDS POSITION ALONG TRUNK\n  pp=vec3(np.x,abs(bp.y+0.05)-.2,np.z); //SMALL BALLS POISTION  \n  pp.xz+=trunkD; //SHIFT SMALL BALLS POS ALONG TRUNK\n  t.x=smin(t.x,length(pp)-0.1,.15);   //ADD SMALL BALLS TO SCENE\n  float trunkBuds=length(bp-vec3(.5,0.,.5))-.5; //TRUNK BUDS BIG BALLS\n  bp.xz=abs(bp.xz)-.2;   //TUBES POSITION\n  float taper=cos(bp.y*3.5-1.)*.1; //TAPER TUBES\n  trunkBuds=smin(trunkBuds,max(abs(length(bp.xz)-.04-taper-tn*2.)-.07,abs(bp.y)-1.85-tn*2.),.5);//TRUNK TUBES  \n  t.x=smin(t.x,trunkBuds,.5);  //ADD TRUNK BUDS + TUBES TO SCENE\n  vec3 fp=p-vec3(0,9.1,0);  //FLOWER HEAD POSITON\n  h=vec2(.8*(length(fp)-1.5-sin(fp.y*2.)*.7),1);  //FLOWER HEAD\n  h.x=min(h.x,core+tn*2.);  //FLOWER CORE\n  rp.xz*=r2(cos(op.y*.4)+.785); //PARTICLES POSITON\n  rp.xz=abs(rp.xz)-2.5-sin(rp.y*.5+.5);rp.y=mod(rp.y-tt*1.019+bbb,2.)-1.;  \n  float part=0.7*max(length(rp)-.05,-p.y+7.5); //PARTICLES\n  g+=0.1/(0.1+part*part*20.)*ga;   //MAKE PARTICLES GLOW\n  t.x=smin(t.x,part,1.);  //ADD PARTICLES TO SCENE\n  t=smin(t,h,.2);  //SMOOTH MERGE GREEN AND BLACK GEOMETRIES AND MATERIAL IDS\n  h=vec2(max(0.8*length(bp.xz),abs(p.y)-9.5),6); //YELLOW GLOW LINES\n  g+=0.1/(0.1+h.x*h.x*(400.-390.*sin(p.y-tt+bbb)))*ga;  //MAKE LINES GLOW\n  float ter=0.65*(p.y+15.+sin(length(p)));  //WAVEY TERRAIN\n  ter=smin(ter,max(abs(length(p.xz)-5.)-.5,abs(p.y+10.)-5.),5.5); //FLOWER POT\n  h.x=min(h.x,ter); //ADD TERRAIN TO SCENE\n  fp.xz*=r2(.785); //SPETAL POSITION\n  fp.xz=abs(fp.xz)-2.5; \n  fp.y-=sin(fp.x+fp.z)*.4;\n  h.x=min(h.x,petal(fp-ridges*.5));  //PETALS\n  t=t.x<h.x?t:h; //ADD GLOW + PETAL WHITE MATERIAL TO SCENE\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd ){//RAYMARCHING LOOP\n  vec2 h,t=vec2(.1); //NEAR PLANE\n  for(int i=0;i<128;i++){ //LOOOP MAX 128 STEPS\n    h=mp(ro+rd*t.x,1.); //GET DISTANCE TO GEOM\n    if(abs(t.x)<.0001|| t.x>50.) break;  //IF WE CLOSE ENOUGH OR IF WE TOO FAR, BREAK\n    t.x+=h.x;t.y=h.y; //BIG JUMP TO GEOMETRY IN NEXT ITERATION, REMEMBER MATERIAL ID\n  }\n  if(t.x>50.) t.y=-1.; //IF WE TOO FAR RETURN -1 MAT ID\n  return t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){ //LINES ABOVE ARE ambient ollcusion and sss\nvec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);   //GET UVS\n  tt=mod(iTime,62.83); //MOD TIME TO AVOID ARTIFACT\n  b=smoothstep(0.,1.,clamp(cos(tt*.3),-.25,.25)*2.+.5);bb=b*3.14;bbb=bb*2.;  //ANIMATION VARIABLE FOR CAMERA ETC\n  vec3 ro=mix(vec3(sin(tt*.3)*15.,5,cos(tt*.2)*15.),vec3(sin(tt*.3)*4.,cos(tt*.3)*5.+10.,10.),b), //RAY ORIGINA = CAMERA POSITION\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//CAMERA STUFF\n  ld=normalize(vec3(.2,.5,-.2));  //LIGHT DIRECTION\n  co=fo=vec3(.15,.3,.5)-length(uv)*.15-rd.y*.3-sin(rd.y*40.)*.01+vec3(1,.5,0)*pow(clamp(dot(ld,rd),0.,1.),3.);  //BACKGROUND COLOUR\n  z=tr(ro,rd);t=z.x; //LET'S TRACE THIS PIXEL\n  if(z.y>-1.){ //IF WE HIT SOMETHING THEN DO LIGHTING\n    po=ro+rd*t; //GET WHERE WE AT\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);//DERIVE NORMALS FROM WEHERE WE AT\n    al=mix(vec3(.4,.7,.6)-tn*3.,vec3(0.),min(z.y*1.0,1.)); //ALBEDO IS BASE COLOUR OF GEWOMETRIES BLENDED BETWEEN THEM WITH MATERIAL ID\n    if(z.y>5.) al=vec3(1.); //IF MAT ID IS MORE THAN 5 THEN MAKE IT WHITE\n    float dif=max(0.,dot(no,ld)), //DIFFUSE LIGHTING\n    fr=pow(1.+dot(no,rd),4.), //FRESNEL \n    sp=0.5*pow(max(dot(reflect(-ld,no),-rd),0.),50.); // SPECULAR\n    co=mix(sp+al*(a(.1)+.2)*(dif+s(1.)),fo,min(fr,.5));     //FINAL COLOUR MIX\n    co=mix(fo,co,exp(-.00003*t*t*t)); //FOG\n  }  \n  fragColor = vec4(pow(co+g*.1*vec3(1,.5,0.2),vec3(.55)),1); //ADD GLOW AT END AND DOM SOME GAMMA CORRECTION\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljSW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[676, 690, 714, 714, 758], [759, 788, 824, 824, 880], [881, 896, 932, 932, 990], [991, 1013, 1049, 1049, 1120], [1121, 1161, 1178, 1178, 1223], [1224, 1245, 1283, 1283, 1577], [1578, 1578, 1598, 1615, 2661], [2662, 2662, 2683, 2683, 3075], [3076, 3076, 3103, 3103, 6032], [6033, 6033, 6061, 6079, 6453], [6545, 6545, 6601, 6645, 8260]], "test": "error"}
{"id": "fllSD4", "name": "Flag - Marshall Islands", "author": "Eggy42", "description": "Flag of The Marshall Islands. Based on BigWIngs tutorial. Note I'm also not from The Marshall Islands. Neat flag! ", "tags": ["flag", "marshallislands"], "likes": 3, "viewed": 35, "published": "Public", "date": "1625712490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\n// Flag of Marshall Islands\n// Based on BigWIngs flag tutorial\n// https://www.shadertoy.com/view/flsXRM\n//\n// https://flagcolor.com/marshall-islands-flag-colors/\n\nfloat PI = 3.14159;\nvec3 GOLD = vec3(229, 114, 0)/255.; // PANTONE PMS 152 C \nvec3 BLUE = vec3(0, 48, 135)/255.; // PANTONE PMS 287 C\nvec3 WHITE = vec3(1.);\n\n// signed distance to a n-star polygon with external angle en\n// From iq: https://www.shadertoy.com/view/3tSGDy\nfloat sdStar_24(in vec2 p, in int n, in float m)\n{\n    float r = 0.7;\n    \n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvec2 Remap(vec2 p, float b, float l, float t, float r) {\n    return vec2( (p.x-l) / (r-l), (p.y-b) / (t-b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Wavy uv\n    float t = uv.x*2.-2.*iTime+uv.y*3.;\n    uv.y += sin(t)*.05;\n  \n    // Default color\n    vec3 col = BLUE;\n \n    // Pixel width\n    float w = fwidth(uv.x);\n     \n    // Rays\n    vec2 sv = uv+vec2(1.1, .55);\n    float ray = dot(sv, vec2(-.51, 1.0));\n    ray = S(-w, w, ray);\n    col = mix(GOLD, BLUE, ray);\n    \n    ray = dot(sv, vec2(-.42, 1.));\n    ray = S(-w, w, ray);\n    col = mix(WHITE, col, ray); \n    \n    ray = dot(sv, vec2(-.33, 1.));\n    ray = S(-w, w, ray);\n    col = mix(BLUE, col, ray); \n  \n    // Star\n    sv = Remap(uv, 0.15, -.5, 0.45, -.2);\n    float sw = fwidth(sv.x);\n    float star = sdStar_24(sv, 24, 14.);\n    star = S(-sw, sw, star);\n    col = mix(WHITE, col, star); \n    \n    sv = Remap(uv, 0.15, -.5, 0.6, -.1);\n    star = sdStar_24(sv, 4, 3.8);\n    star = S(-sw, sw, star);\n    col = mix(WHITE, col, star); \n\n    // Shading \n    col *= .7+cos(t)*.3;\n\n    // Clip top and bottom\n    col *= S(w, .0, abs(uv.y)-.5);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[361, 473, 523, 523, 1041], [1043, 1043, 1099, 1099, 1153], [1155, 1155, 1212, 1263, 2338]], "test": "valid"}
{"id": "fllSD8", "name": "Psychedelic Eye", "author": "mrange", "description": "License CC0: Psychedelic eye\nContinuation of weekend experiment\n", "tags": ["2d", "fbm", "warp"], "likes": 15, "viewed": 255, "published": "Public API", "date": "1625589701", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Psychedelic eye\n//  Continuation of weekend experiment\n\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define TIME          iTime\n#define TTIME         (TAU*TIME)\n#define RESOLUTION    iResolution\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)       (0.5 + 0.5*cos(x))\n#define DOT2(x)       dot(x, x)\n#define BPERIOD       5.6\n#define MPERIOD       7.2\n#define FLIP          10.0\n\nconst vec2 iris_center = vec2(0.0, 0.28);\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3  grid_color    = HSV2RGB(vec3(0.6, 0.3, 1.0)); \nconst vec3  light0_color  = 16.0*HSV2RGB(vec3(0.6, 0.5, 1.0)); \nconst vec3  light1_color  = 8.0*HSV2RGB(vec3(0.9, 0.25, 1.0)); \nconst vec3  sky0_color    = HSV2RGB(vec3(0.05, 0.65, -0.25)); \nconst vec3  sky1_color    = HSV2RGB(vec3(0.6, 0.5, 0.25)); \nconst vec3  light0_pos    = vec3(1.0, 5.0, 4.0);\nconst vec3  light1_pos    = vec3(3.0, -1.0, -8.0);\nconst vec3  light0_dir    = normalize(light0_pos);\nconst vec3  light1_dir    = normalize(light1_pos);\nconst vec4  planet_sph    = vec4(50.0*normalize(light1_dir+vec3(0.025, -0.025, 0.0)), 10.0);\n\nint   g_eff = 0;\n\nfloat g_hf;\n\nvec2 g_vx = vec2(0.0);\nvec2 g_vy = vec2(0.0);\n\nvec2 g_wx = vec2(0.0);\nvec2 g_wy = vec2(0.0);\n\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// Based on: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// IQ's box\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat eye_shape(vec2 p) {\n  float a  = mix(0.0, 1.0, smoothstep(0.995, 1.0, cos(TTIME/BPERIOD)));\n  const float w = 1.14;\n  float h = mix(0.48, 0.05, a);\n  float d0 =  vesica(p, vec2(w, h));\n  return d0;\n}\n\n// IQ's ray sphere intersect: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\n// IQ's ray plane intersect: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nvec3 toRect(vec3 p) {\n  return p.x*vec3(cos(p.z)*sin(p.y), sin(p.z)*sin(p.y), cos(p.y));\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// https://iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(-a, a, k);\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\n// https://iquilezles.org/www/articles/fbm/fbm.htm\nfloat fbm(vec2 p, float aa) {\n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); \n    p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= aa;\n  }\n  return f/s;\n}\n\n// https://iquilezles.org/www/articles/warp/warp.htm\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\n  const float r  = 0.5;\n  const float rr = 0.25;\n  float l2 = length(p);\n  float f  = 1.0;\n\n  switch (g_eff) {\n  case 0:\n//    f = smoothstep(r, r+rr, l2);\n    f = smoothstep(-0.1, 0.15, eye_shape(p));\n    p.y += TIME*0.125;\n    p.x = pabs(p.x, 0.1);\n    break;\n  case 1:\n    const float z = 0.75; \n    f = smoothstep(-0.05, 0.1, eye_shape(p.yx/z)*z);\n    f = smoothstep(r, r+rr, l2);\n    p = -p.yx;\n    p = toPolar(p);\n//    f = smoothstep(r, r+rr, l2);\n    p.y -= -0.125*TIME+p.x*1.25;\n    break;\n  default:\n    break;\n  }\n\n  g_hf = f;\n  vec2 pp = p;\n\n  vec2 vx = g_vx;\n  vec2 vy = g_vy;\n\n  vec2 wx = g_wx;\n  vec2 wy = g_wy;\n\n\n  //float aa = mix(0.95, 0.25, tanh_approx(pp.x));\n  float aa = 0.5;\n\n  v = vec2(fbm(p + vx, aa), fbm(p + vy, aa))*f;\n  w = vec2(fbm(p + 3.0*v + wx, aa), fbm(p + 3.0*v + wy, aa))*f;\n  \n  return -tanh_approx(fbm(p + 2.25*w, aa)*f);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvoid compute_globals() {\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vx *= ROT(TTIME/1000.0);\n  vy *= ROT(TTIME/900.0);\n\n  wx *= ROT(TTIME/800.0);\n  wy *= ROT(TTIME/700.0);\n  \n  g_vx = vx;\n  g_vy = vy;\n  \n  g_wx = wx;\n  g_wy = wy;\n}\n\nvec3 iris(vec2 p) {\n  const vec3 up  = vec3(0.0, 1.0, 0.0);\n  const vec3 lp1 = 1.0*vec3(1.0, 1.25, 1.0);\n  const vec3 lp2 = 1.0*vec3(-1.0, 2.5, 1.0);\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec2 v;\n  vec2 w;\n \n  float h  = warp(p, v, w);\n  float hf = g_hf;\n  vec3  n  = normal(p);\n\n  vec3 lcol1 = hsv2rgb(vec3(0.7, 0.5, 1.0)); \n  vec3 lcol2 = hsv2rgb(vec3(0.4, 0.5, 1.0));\n  vec3 po  = vec3(p.x, 0.0, p.y);\n  vec3 rd  = normalize(po - ro);\n  \n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 col1 = vec3(0.1, 0.7, 0.8).xzy;\n  const vec3 col2 = vec3(0.7, 0.3, 0.5).zyx;\n  \n  float a = length(p);\n  vec3 col = vec3(0.0);\n//  col += hsv2rgb(vec3(fract(0.3*TIME+0.25*a+0.5*v.x), 0.85, abs(tanh_approx(v.y))));\n//  col += hsv2rgb(vec3(fract(-0.5*TIME+0.25*a+0.125*w.x), 0.85, abs(tanh_approx(w.y))));\n  col += hsv2rgb(vec3(fract(-0.1*TIME+0.125*a+0.5*v.x+0.125*w.x), abs(0.5+tanh_approx(v.y*w.y)), tanh_approx(0.1+abs(v.y-w.y))));\n//  col += (length(v)*col1 + length(w)*col2*1.0);\n//  col += diff1;\n//  col += diff2;\n//  col *= 0.0;\n  col += 0.5*lcol1*pow(ref1, 20.0);\n  col += 0.5*lcol2*pow(ref2, 10.0);\n  col *= hf;\n\n//  col = n;\n  return col;\n}\n\nvec3 eye_complete(vec2 p) {\n  const float iris_outer = 0.622;\n  const float iris_inner = 0.285;\n\n  \n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  float dt0 = mix(0.0125, -0.0025, t0);\n\n  vec2 p0 = p;\n  float d0 = eye_shape(p);\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1 -= iris_center;\n  float d1 = circle(p1, iris_outer);\n  d1 = max(d1,d0+dt0);\n  float d6 = d1;\n\n  vec2 p2 = p;\n  p2 -= vec2(0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3 -= iris_center;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-1.0*length(p1));\n\n  vec2 p4 = p;\n  p4 -= iris_center;\n  float d4 = circle(p4, iris_inner);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  d0 = abs(d0)-dt0;\n\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return vec3(d, d6, d5);\n}\n\nvec3 df(vec2 p) {\n  return eye_complete(p); \n}\n\nvec3 render_background(vec3 ro, vec3 rd, vec3 nrd) {\n  rd.xy *= ROT(-PI/2.0+0.6);\n  vec3 srd = toSpherical(rd.xzy);\n  srd.z += 0.025*TIME;\n  vec2 pg  = srd.yz;\n  float f  = sin(pg.x); \n  float lf2= ceil(log(f)/log(2.0)-0.505);\n  float mf = pow(2.0, lf2);\n\n  float aa = 0.005;\n  const float count = 20.0;\n  const vec2 sz = vec2(2.0*PI/count);\n  vec2 ng = mod2(pg, vec2(mf, 1.0)*sz);\n\n  float dg = min(abs(pg.y)*f, abs(pg.x))-aa*0.0;\n  vec3 lines = grid_color*smoothstep(-aa, aa, -dg)*f*f;\n\n  vec3 sky  = smoothstep(1.0, 0.0, rd.y)*sky1_color+smoothstep(0.5, 0.0, rd.y)*sky0_color;\n\n  vec2 pi = raySphere(ro, rd, planet_sph);\n\n  float lf1 = 1.0;\n  if (pi.x > 0.0) {\n    vec3 ppos = ro+rd*pi.x;\n    float t = 1.0-tanh_approx(1.5*(pi.y - pi.x)/planet_sph.w);\n    sky *= mix(0.5, 1.0, t);\n    lf1 = t;\n  } else {\n    sky += lines;\n  }\n\n  sky += pow(max(dot(rd, light0_dir), 0.0), 800.0)*light0_color; \n  sky += pow(max(dot(rd, light0_dir), 0.0), 80.0)*light1_color*0.1; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 150.0)*light1_color; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 50.0)*light0_color*0.1; \n\n\n  return sky;\n}\n\nvec4 render_iris(vec3 ro, vec3 rd, vec3 nrd) {\n  vec4 plane = vec4(normalize(vec3(1.0, 0.165-0.00, 0.0)), -0.944);\n  float aa = TTIME/MPERIOD;\n  float bb = smoothstep(-0.125, 0.125, sin(aa));\n  plane.xy *= ROT(0.075*bb);\n  plane.xz *= ROT(0.25*bb*sign(-sin(PI/4.0+0.5*aa)));\n  vec3 tnor  = plane.xyz;\n  const vec3 tup   = normalize(vec3(0.0, -1.0, 0.0));\n  float t = rayPlane(ro, rd, plane);\n  if (t <= 0.0) {\n    return vec4(0.0);\n  }\n  \n  vec3 tpos = ro + t*rd;\n  tpos *= 4.0;\n  vec3 txx = normalize(cross(tnor, tup));\n  vec3 tyy = normalize(cross(tnor, txx));\n  \n  vec2 tpos2 = vec2(dot(txx, tpos), dot(tyy, tpos));\n  \n  vec3 col = iris(tpos2)*smoothstep(0.0, 1.0/75.0, t);\n  \n  return vec4(col, smoothstep(0.0, 1.0/500.0, t));\n}\n\n\nvec4 render_body(vec2 p, vec3 dd, float z) {\n//  p -= iris_center;\n  float aa = 2.0/RESOLUTION.y;\n  \n  vec3 ro = vec3(2.0, 0.0, 0.0);\n  vec3 la = vec3(0.0, 0.0, 0.0); \n\n  vec2 np   = p + vec2(4.0/RESOLUTION.y); \n\n  vec3 ww   = normalize(la - ro);\n  vec3 uu   = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv   = normalize(cross(ww,uu));\n  float rdd = 2.0;\n  vec3 rd   = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd  = normalize(np.x*uu + np.y*vv + rdd*ww);\n  \n  vec4 sph  = vec4(vec3(0.0), 1.0);\n  \n  vec2 si   = raySphere(ro, rd, sph);\n  if (si.x <= 0.0) {\n    return vec4(0.0);\n  }\n  \n  float a = smoothstep(-aa, aa, -dd.z);\n  float b = smoothstep(0.0, mix(0.25, 1.0, float(p.y > 0.0))*mix(0.075, 0.0025, smoothstep(0.5, 1.0, abs(p.x))), -dd.z/z);\n  float c = smoothstep(-aa, aa, -dd.x);\n\n  vec3 pos  = ro + rd*si.x;\n  \n  vec3 nor  = normalize(pos - sph.xyz);\n  \n  float dif0= max(dot(nor, light0_dir), 0.0);\n  float dif1= max(dot(nor, light1_dir), 0.0);\n  \n  vec3 ref  = reflect(rd, nor); \n  vec3 nref = reflect(nrd, nor); \n\n  vec3 refr = refract(rd, nor, 0.9); \n  vec3 nrefr= refract(nrd, nor, 0.9); \n\n  vec3 rbkg = render_background(pos, ref, nref);\n  vec4 riris= render_iris(pos, refr, nrefr);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5);\n  col += dif1*0.5;\n  col += dif0*0.5;\n  if (fract((TIME/BPERIOD)/(2.0*FLIP)) > 0.5) {\n    rbkg = max(rbkg, 0.0);\n    rbkg = tanh(vec3(0.5, 1.0, 1.6)*rbkg).zxy;\n    col = mix(rbkg, rbkg*0.6, c);\n  } else {\n    col = alphaBlend(col, riris);\n    col += rbkg*mix(0.33, 1.0, riris.w);\n  }\n  col *= b;\n  \n  return vec4(col, a);\n}\n\nfloat synth(vec2 p) {\n  const float z = 4.0;\n  const float st = 0.02;\n  float dob = box(p, vec2(1.4, 0.5));\n  p.x = abs(p.x);\n  p.x += st*20.0;\n  p /= z;\n  float n = mod1(p.x, st);\n  float dib = 1E6;\n  const int around = 1;\n  for (int i = -around; i <=around ;++i) {\n    float fft = texture(iChannel0, vec2((n+float(i))*st, 0.25)).x; \n    fft *= fft;\n    float dibb = box(p-vec2(st*float(i), 0.0), vec2(st*0.25, 0.05*fft+0.001));\n    dib = min(dib, dibb);\n  }\n  \n  float dl = p.y;\n  dl = abs(dl) - 0.005;\n  dl = abs(dl) - 0.0025;\n  dl = abs(dl) - 0.00125;\n  float d = dib;\n  d = max(d, -dl);\n  //d = pmax(d, dob, 0.025);\n  return d*z;\n}\n\nvec3 effect(vec2 p) {\n  compute_globals();\n\n  float aa = 2.0/RESOLUTION.y;\n  const float m = 3.0; \n  const float z = 1.0;\n  p /= z;\n  vec2 pp  = p;\n  \n  vec3 d   = df(pp)*z;\n\n  vec4 dcol = vec4(mix(vec3(0.9), vec3(0.0), smoothstep(-aa, aa, -d.x)) , smoothstep(-aa, aa, -d.z));\n  g_eff = 1;\n  vec4 scol = render_body(p, d, z); \n  \n  vec3 col  = vec3(1.0);\n  g_eff = 0;\n  col = iris(p);\n\n  vec2 dp = p;\n  dp.y = -pabs(dp.y, 1.0);\n  dp -= vec2(0.0, -0.85);\n  dp = toPolar(dp);\n  dp.y += -0.2*(p.x);\n  dp = toRect(dp);\n  float dd = synth(dp);\n  \n  vec4 ddcol = vec4(vec3(0.9), smoothstep(-aa, aa, -dd));\n\n  col = alphaBlend(col, dcol);\n  if (fract((TIME/BPERIOD)/FLIP) > 0.5) {\n    col = alphaBlend(col, scol);\n  }\n  col -= 0.5*exp(-75.0*max(dd, 0.0));\n  col = alphaBlend(col, ddcol);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = effect(p);\n  col = mix(vec3(0.0), col, smoothstep(0.5, 5.0, TIME));\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "llfSWB", "previewfilepath": "https://soundcloud.com/lifeformsmusic/one-of-a-kind-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lifeformsmusic/one-of-a-kind-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllSD8.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[628, 628, 650, 650, 796], [1731, 1731, 1771, 1771, 1930], [1932, 1932, 1972, 1972, 2014], [2016, 2016, 2052, 2052, 2285], [2287, 2287, 2318, 2318, 2344], [2346, 2431, 2462, 2462, 2760], [2762, 2774, 2801, 2801, 2877], [2879, 2879, 2904, 2904, 3084], [3086, 3186, 3230, 3230, 3427], [3429, 3528, 3570, 3570, 3617], [3619, 3619, 3647, 3667, 3743], [3745, 3745, 3767, 3767, 3811], [3813, 3813, 3834, 3834, 3875], [3877, 3877, 3903, 3903, 4012], [4014, 4014, 4035, 4035, 4104], [4106, 4138, 4177, 4177, 4302], [4304, 4336, 4372, 4372, 4466], [4468, 4521, 4560, 4560, 4649], [4651, 4651, 4690, 4690, 4719], [4721, 4721, 4751, 4751, 4779], [4781, 4781, 4802, 4802, 4924], [4926, 4977, 5006, 5006, 5258], [5260, 5313, 5357, 5357, 6219], [6221, 6221, 6242, 6242, 6464], [6466, 6466, 6490, 6490, 6770], [6772, 6772, 6791, 6791, 8173], [8175, 8175, 8202, 8202, 9033], [9035, 9035, 9052, 9052, 9081], [9083, 9083, 9135, 9135, 10209], [10211, 10211, 10257, 10257, 10943], [10946, 10946, 10990, 11012, 12521], [12523, 12523, 12544, 12544, 13159], [13161, 13161, 13182, 13182, 13957], [13959, 13959, 14014, 14014, 14287]], "test": "error"}
{"id": "fllSRf", "name": "Circle11111", "author": "ASkkk", "description": "for church", "tags": ["cfm"], "likes": 5, "viewed": 265, "published": "Public API", "date": "1626193582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 100.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllSRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 230, 251, 251, 420], [422, 422, 446, 446, 496], [498, 498, 527, 527, 620], [622, 622, 658, 658, 869], [871, 871, 906, 906, 970], [972, 972, 1014, 1014, 1481], [1486, 1486, 1543, 1543, 1938]], "test": "error"}
{"id": "fllSWl", "name": "Rainbowspiral", "author": "phaiax", "description": "First shader :)", "tags": ["rainbow"], "likes": 2, "viewed": 136, "published": "Public API", "date": "1626810294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/vec2(iResolution.y, iResolution.y);\n    vec2 m = iMouse.xy/vec2(iResolution.y, iResolution.y);\n    vec2 v = st - m;\n    v = v / 0.01;\n    float tau = 6.283185;\n    float hue = atan(v.x, v.y)/tau;\n    hue = hue + length(v)/80. - iTime/2.;\n    vec3 rgb = hsl2rgb ( vec3(hue, 1., \n                              cos(2.0-length(v)*3.5)));\n    fragColor = vec4(rgb.r,rgb.g,rgb.b,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 171], [173, 173, 230, 230, 638]], "test": "valid"}
{"id": "flS3D3", "name": "invaderz ufos", "author": "z0rg", "description": "zey r cOmInG fOr uS", "tags": ["invaders", "ufo", "invaderz", "zerfef"], "likes": 16, "viewed": 211, "published": "Public API", "date": "1626281460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a,0.,1.)\nmat2 r2d(float a){float ca = cos(a),sa=sin(a);return mat2(ca,-sa,sa,ca);}\n#define PI 3.14159265\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\nfloat _cir(vec2 p, float r)\n{\nreturn length(p)-r;\n}\n\nfloat _bbox(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n//  l = abs(l)-s*.9;\n  return max(l.x,max(l.y,l.z));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if(a.x<b.x)\n  return a;\n  return b;\n}\n\nfloat _sph(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nvec4 ovnip[3];\n\nfloat ovni(vec3 p)\n{\n  float acc = 1000.;\n  acc = min(acc, max(length(p)-2.,p.y+1.5));\n\n  acc= min(acc,max(length(p.xz)-1.3,abs(p.y+1.1)-.4));\n\n  vec3 pc = p-vec3(0.,2.9,0.);\n  acc = min(acc, max(length(pc)-4.,pc.y+3.5));\n\n // float a = atan(p.x,p.z);\n\n  float repa = 2.*PI/3.;\n\n  for(int i = 0;i<3;++i)\n  {\n    float a = float(i)*repa+iTime;\n    float r = 1.2;\n    vec3 pos = p+vec3(sin(a)*r,0.55,cos(a)*r);\n    acc = min(acc, _sph(pos,.25));\n  }\n  acc = min(acc, _sph(p-vec3(0.,-.6,0.),.5));\n  return acc;\n}\n\nvec2 map(vec3 p)\n{\n  vec2 acc = vec2(1000.,-1.);\n\n  for (int i = 0;i<3;++i)\n  {\n    float a = ovnip[i].w;\n    vec3 pos = p-ovnip[i].xyz;\n    vec3 opos = pos;\n    pos.xy*=r2d(a);\n    acc = _min(acc, vec2(ovni(pos),float(i)));\n\n    vec3 dest = vec3(0.,-2.,0.);\n    vec3 plaser = mix(opos, dest, mod(iTime*2.+float(i)*.33, 1.)/1.);\n    plaser.yz *= r2d(-.5);\n   plaser.xz *= r2d(-a*.5);\n    acc= _min(acc, vec2(_sph(plaser*vec3(1.,1.,.1),.1), 12.));\n  }\n\n  acc = _min(acc, vec2(_sph(p-vec3(0.,19.,8.), 15.5), 5.));\n  return acc;\n}\nvec3 gradient(float f)\n{\n    vec3 cols[3];\n    \n    cols[0] = vec3(0.169,0.086,0.816);\n    cols[1] = vec3(0.835,0.216,0.843);\n    cols[2] = vec3(1.,1.,1.);\n    \n    float cnt = 2.;\n    float cur = f*cnt;\n    float curIdx = floor(cur);\n    return mix(cols[int(curIdx)], cols[int(min(curIdx+1., cnt))], sat(fract(cur)));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  vec3 p = ro;\n  for (int i = 0; i<steps;++i)\n  {\n    vec2 res = map(p);\n    if (res.x<0.01)\n      return vec3(res.x,distance(p,ro),res.y);\n      if (res.y > 10.)\n          accCol += vec3(0.2,1.,0.2)*pow(1.-sat(res.x/0.2),5.);\n      else if (res.y != 5.)\n          accCol += (1.-sat(p.z*.045))*.1*gradient(sat(p.z*.05))*pow(1.-sat(res.x/2.7),5.);\n    p+= rd*res.x;\n  }\n  return vec3(-1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = .75;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd,r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvoid setup()\n{\n  ovnip[0]= vec4(-2.+cos(iTime*2.)*.2,sin(iTime*2.)*.25-.5,2.,.3);\n  ovnip[1]= vec4(3.,sin(iTime*2.+1.)*.25,10.,-.3);\n  ovnip[2]= vec4(0.,sin(iTime*2.+2.)*.25,20.,0.);\n}\n\nfloat _person(vec2 uv, float off)\n{\n    float shape = _sqr(uv, vec2(.03,.07));\n    shape = min(shape, _cir(uv-vec2(0.,.1), .03));\n    shape = min(shape, _sqr(uv-vec2(0.02,-.05), vec2(.01,0.05+0.05*(sin(iTime*16.+off)*.5+.5))));\n    shape = min(shape, _sqr(uv-vec2(-0.02,-.05), vec2(.01,0.05+0.05*(sin((iTime)*16.+3.14+off)*.5+.5))));\n    float th = 0.01;\n    uv -= vec2(0.,-.03);\n    uv *= r2d(-sign(uv.x)*.5);\n    shape = min(shape, max(abs(uv.y-.05-sat(abs(uv.x*2.))*sin(abs(uv.x*50.)-iTime*5.+off)*.02)-th, abs(uv.x)-.2));\n    return shape;\n}\n\nvec3 drawPeople(vec3 col, vec2 uv)\n{\n    float shapea = _person((uv*r2d(.25)*.5-vec2(0.2,-.1))*r2d(sin(iTime*2.+1.)*.1),0.);\n    float shapeb = _person((uv*r2d(-.25)*1.5-vec2(-0.3,-.6))*r2d(sin(iTime)*.2),1.);\n\n    float shape = min(shapea, shapeb);\n    col = mix(col, vec3(0.), 1.-sat(shapea*400.));\n    col = mix(col, col*.25, 1.-sat(shapeb*400.));\n    return col;\n}\n\nfloat letter(vec2 uv, int idx, int idy)\n{\n    uv *= .25;\n    float width = 1./16.;\n    float height = 1./16.;\n    float x = float(idx);\n    float y = float(idy);\n    vec2 topl = vec2(x*width, y*height);\n    vec2 coords = uv+vec2(width, height)*.5;//+topl;\n    coords = clamp(coords, vec2(0.), vec2(width, height));\n    coords -= topl;\n    return texture(iChannel1, coords).x;\n}\n\nvec3 drawText(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    uv -= vec2(-.5,.3);\n    uv *= r2d(-.5);\n    uv.y *= 1.-sat(abs(uv.x))+sin(uv.x*7.+iTime*2.)*.1;\n    uv.x += .4;\n    vec2 off = vec2(0.12, 0.);\n    col = mix(col, vec3(1.), letter(uv*r2d(.1),-9,5));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*r2d(-.2),-14,5));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*r2d(.1),10,6));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*r2d(-.1),-1,5));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*r2d(-.3),-4,5));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv,-5,5));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*r2d(-.1),14,6));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*.75*r2d(.25),6,6));\n\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  \n  vec2 skyp = uv-vec2(0.,-1.75);\n  float a = atan(skyp.y,skyp.x)+iTime*.25;\n  vec3 sk = mix(vec3(0.863,0.486,0.196), vec3(0.875,0.125,0.424), sat(length(.5*uv-vec2(0.,-.5))));\n  col = mix(vec3(0.286,0.467,0.553), sk, pow(sat(texture(iChannel0, vec2(length(skyp)*.5,a*.1)*.5).x),.5));\n  col *= 1.-sat(length(uv)-.5);\n  col = pow(col, vec3(.75));\ncol += vec3(0.863,0.486,0.196)*(1.-sat(length(uv-vec2(0.,-.5))));\n\nfloat offh = 1.2;\n  vec3 ro = vec3(0.,1.5+offh,-7.);\n  vec3 ta = vec3(0.,-.15+offh,0.);\n  vec3 rd = normalize(ta-ro);\n\n  rd = getCam(rd,uv);\n  setup();\n  accCol = vec3(0.);\n  vec3 res = trace(ro,rd,128);\n  if (res.y>0.)\n  {\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p,res.x);\n    col = n*.5+.5;\n    vec3 lpos = vec3(0.,5.,25.);\n    vec3 ldir = lpos-p;\n    vec3 h = normalize(rd+ldir);\n    if (res.z < 3.5)\n    {\n        vec3 pr = p-ovnip[int(res.z)].xyz;\n        col = vec3(0.349,0.235,0.447)*.25+vec3(0.722,0.667,0.875)*pow(texture(iChannel0, 3.*vec2(atan(pr.x, pr.z)*.1, 2.*length(pr))).x,2.);\n        float ndoth = sat(dot(n,h));\n       col *= sat(.5+ndoth);\n       col += vec3(0.863,0.486,0.196)*ndoth;\n\n    }   \n    if (res.z == 5.)\n    {\n        float rep = .1;\n            col = mix(col, vec3(1.),1.-sat(max(abs(uv.x)-0.08*pow(sat(-uv.y),2.),sin(uv.y*20.-iTime*10.))*400.));\n    }\n  }\n  col = drawPeople(col, uv-vec2(0.,.1));\n  col += accCol;\n  vec3 bucol = col;\n  col *= 1.-sat(drawText(uv*.95));\n  col += bucol.zxy*drawText(uv);\n  return col;\n}\n\nvec3 mixcol(vec3 col, vec2 uv)\n{\n    vec3 rgb = col;\n    \n    rgb.xy *= r2d(sin(iTime));\n    //rgb.yz *= r2d(-iTime*.5);\n    rgb = sat(rgb);\n    \n    return mix(col, rgb, sat(.5+.5*sin(uv.y*5.-iTime*3.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy) / iResolution.xx;\n  uv *= length(uv+vec2(sin(iTime), cos(iTime))*.2)+.8;\n  uv *= mix(1.,1.5,sat(sin(iTime*.5)*.5+.5));\n  vec3 col = rdr(uv*2.);\n  col = mixcol(col, uv);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "XlfSDB", "previewfilepath": "https://soundcloud.com/lfttrax/helena-hauff-b2b-lft-october-6-7pm-9pm", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lfttrax/helena-hauff-b2b-lft-october-6-7pm-9pm", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flS3D3.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[427, 427, 445, 445, 500], [524, 524, 552, 552, 603], [604, 604, 633, 633, 655], [657, 657, 686, 686, 762], [764, 764, 791, 791, 831], [833, 833, 862, 862, 886], [904, 904, 924, 924, 1413], [1415, 1415, 1433, 1433, 1942], [1943, 1943, 1967, 1967, 2263], [2277, 2277, 2318, 2318, 2709], [2711, 2711, 2742, 2742, 2891], [2893, 2893, 2924, 2924, 3032], [3034, 3034, 3048, 3048, 3218], [3220, 3220, 3255, 3255, 3765], [3767, 3767, 3803, 3803, 4135], [4137, 4137, 4178, 4178, 4514], [4516, 4516, 4540, 4540, 5277], [5279, 5279, 5298, 5298, 6795], [6797, 6797, 6829, 6829, 7004], [7006, 7006, 7063, 7063, 7315]], "test": "error"}
{"id": "flsSWf", "name": "/polder/flight", "author": "_fov", "description": "somewhat akin a flight over a polder landscape", "tags": ["grid", "abstract", "polder"], "likes": 0, "viewed": 60, "published": "Public API", "date": "1626707523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec2 cell_size = 1. / vec2(3., 10.);\nconst float diagonal_slope = 0.45;\nconst float diagonal_offset = 0.6;\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n    // implementation copied from https://www.shadertoy.com/view/llGSzw\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 image(vec2 uv)\n{\n    uv.y = 2.+uv.y;\n    vec2 cell_uv;\n    vec2 cell_fraction = modf(uv / cell_size, cell_uv);\n    cell_uv = cell_uv * cell_size;\n\n\n    // horizontal lines\n    bool h = (abs(cell_fraction.y -.5)>0.4275);\n\n    // vertical lines\n    float tex = hash1(uint(cell_uv.y * 20. + (cell_uv.x + floor(uv.x))* 20.));\n\n    float v_offset = 0.5 + tex /2.;\n    float cell_d_x = diagonal_offset + (1.0 - cell_uv.y) * diagonal_slope;\n    bool v = abs(cell_fraction.x - v_offset)<0.045;\n\n    if(cell_fraction.x > v_offset)\n    {\n        cell_uv.x += cell_size.x;\n        tex = hash1(uint(cell_uv.y * 20. + (cell_uv.x + floor(uv.x + cell_size.x))* 20.));\n    }\n\n    // diagonal line\n    float patch_slope = diagonal_slope * (hash1(uint(uv.x))-.5);\n    bool d = abs(diagonal_offset - fract(uv.x) + patch_slope * (1.0 - uv.y)) < 0.03;\n\n    vec3 col = h || v || d ? vec3(0.0) : vec3(tex);\n\n    return vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // dirty zoom\n    uv += 0.5;\n    uv *= 0.5;\n    \n    // basic perspective from https://www.shadertoy.com/view/ttscW2\n    float coeff =0.25 *sin(iTime/5.)+0.75;\n    \n    uv.x -= 0.5f;\n\tuv.x /= (1.0 - uv.y * coeff);\n    uv.y /= (1.0 - uv.y * coeff);\n   \n    uv.y += iTime/10.;\n    uv.x += sin(iTime/5.)/10.;\n    // Output to screen\n    fragColor = image(uv.yx);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 138, 253, 391], [393, 393, 414, 414, 1310], [1312, 1312, 1369, 1419, 1825]], "test": "error"}
{"id": "flsXDs", "name": "Rainbow Spiral (bouncy!)", "author": "froggynotacon", "description": "Fork of https://www.shadertoy.com/view/fllSWl\n\nInstead of using the mouse coordinates to indicate the origin, it just uses simple sin and cos functions.\n", "tags": ["rainbow", "fork"], "likes": 4, "viewed": 146, "published": "Public API", "date": "1626834188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/vec2(iResolution.y, iResolution.y);\n    vec2 m = vec2(abs(sin(iTime /4.))* iResolution.x, abs(cos(iTime *.95)) * iResolution.y)/vec2(iResolution.y, iResolution.y);\n    vec2 v = st - m;\n    v = v / 0.01;\n    float tau = 6.283185;\n    float hue = atan(v.x, v.y)/tau;\n    hue = hue + length(v)/80. - iTime/2.;\n    vec3 rgb = hsl2rgb ( vec3(hue, 1., \n                              cos(2.0-length(v)*3.5)));\n    fragColor = vec4(rgb.r,rgb.g,rgb.b,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsXDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 171], [173, 173, 230, 230, 707]], "test": "valid"}
{"id": "flSXDz", "name": "task2_frag", "author": "HUANG", "description": "Solar system", "tags": ["raytracing"], "likes": 1, "viewed": 142, "published": "Public API", "date": "1627398313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//============================================================================\n// PROJECT ID:  SWS3005_04\n//\n// GROUP NUMBER: 04\n//\n// STUDENT NAME: Huang Chenxuan\n// NUS User ID.: t0922598\n//\n// STUDENT NAME: OuYifan\n// NUS User ID.: t0922624\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 12;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 9;\nconst int NUM_CONES = 1;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.2, 0., 1.0 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Define new struct types.\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Cone_t {\n\t// Half angle\n\tfloat cosa;\n\t// Height\n\tfloat h;\n\t// Tip position\n\tvec3 c;\n\t// Axis\n\tvec3 v;\n\tint materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n\t// Ambient coefficient.\n    vec3 k_a;   \n    // Diffuse coefficient.\n    vec3 k_d;   \n    // Reflected specular coefficient.\n    vec3 k_r;   \n    // Global reflection coefficient.\n    vec3 k_rg;  \n    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n    float n;    \n};\n\n\n// Global scene data.\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCone_t Cone[NUM_CONES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n// Initializes the scene.\nvoid InitScene()\n{\n\n    // Vertical plane.\n    Plane[1].A = -1.0;\n    Plane[1].B = 1.0;\n    Plane[1].C = 0.0;\n    Plane[1].D = 20.5;\n    Plane[1].materialID = 0;\n\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 0.0;\n    Plane[0].C = 1.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 1;\n    \n    // Sun\n    Sphere[0].center = vec3( 0., 0., 4.5);\n    Sphere[0].radius = 2.5;\n    Sphere[0].materialID = 10;\n\n    // Mercury\n    Sphere[1].center = vec3( 2.8 * cos(3.3*iTime), 4. * sin(3.3*iTime), 4.5 +.2* sin(iTime));\n    Sphere[1].radius = .1;\n    Sphere[1].materialID = 2;\n    \n    // Venus\n    Sphere[2].center = vec3( 3.3 * cos(1.6*iTime), -4. * sin(1.6*iTime), 4.5 +.2* sin(iTime));\n    Sphere[2].radius = .18;\n    Sphere[2].materialID = 3;\n\n    // Earth\n    Sphere[3].center = vec3( 3.7 * cos(iTime), 4. * sin(iTime)+2., 4.5 + .3* cos(iTime) );\n    Sphere[3].radius = .2;\n    Sphere[3].materialID = 4;\n\n    // Mars\n    Sphere[4].center = vec3( 4.3 * cos(0.8*iTime), 4. * sin(0.8*iTime), 4.5 + .2* cos(iTime) );\n    Sphere[4].radius = .1;\n    Sphere[4].materialID = 5;\n\n    // Jupiter\n    Sphere[5].center = vec3( 6.5* cos(0.4*iTime), 4. * sin(0.4*iTime), 4.5 + .1* cos(iTime) );\n    Sphere[5].radius = .65;\n    Sphere[5].materialID = 6;\n\n    // Saturn\n    Sphere[6].center = vec3( 8.1 * cos(0.2*iTime), 4. * sin(0.2*iTime), 4.5 + .1* cos(0.8*iTime) );\n    Sphere[6].radius = .58;\n    Sphere[6].materialID = 7;\n\n    // Uranus\n    Sphere[7].center = vec3( 9.5* cos(0.1*iTime), 4. * sin(0.1*iTime), 4.5 + .3* cos(iTime) );\n    Sphere[7].radius = .3;\n    Sphere[7].materialID = 8;\n\n    // Neptune\n    Sphere[8].center = vec3( 11.1 * cos(0.05*iTime), 4. * sin(0.05*iTime), 4.5 + .1* cos(0.7*iTime) );\n    Sphere[8].radius = .3;\n    Sphere[8].materialID = 9;\n\n\n    // SUN\n    Material[10].k_d = vec3( 0.9, 0.5, 0.3 );\n    Material[10].k_a = 0.2 * Material[10].k_d;\n    Material[10].k_r = 2.0 * Material[10].k_d;\n    Material[10].k_rg = 0.5 * Material[10].k_r;\n    Material[10].n = 100.0;\n\n    // Vertical plane: Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.4 );\n    Material[0].k_a = 0.9 * Material[0].k_d;\n    Material[0].k_r = 1.2 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n    \n    // Horizontal plane: Red material.\n    Material[1].k_d = vec3( 0.2, 0.1, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 0.2 * Material[1].k_d;\n    Material[1].k_rg = 0.1 * Material[1].k_r;\n    Material[1].n = 128.0;\n\n    // Mercury\n    Material[2].k_d = vec3( 0.6, 0.8, 0.8);\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = 4.0 * Material[2].k_d;\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // Venus\n    Material[3].k_d = vec3( 0.9, 0.9, 0.0 );\n    Material[3].k_a = 0.4 * Material[3].k_d;\n    Material[3].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 64.0;\n    \n    \n    // Earth\n    Material[4].k_d = vec3( 0.1, 0.1, 0.8 );\n    Material[4].k_a = 0.4 * Material[4].k_d;\n    Material[4].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[4].k_rg = 0.5 * Material[4].k_r;\n    Material[4].n = 64.0;\n    \n    // Mars\n    Material[5].k_d = vec3( 0.4, 0.3, 0.0 );\n    Material[5].k_a = 0.4 * Material[5].k_d;\n    Material[5].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[5].k_rg = 0.5 * Material[5].k_r;\n    Material[5].n = 64.0;\n    \n    // Jupiter\n    Material[6].k_d = vec3( 0.3, 0.4, 0.2 );\n    Material[6].k_a = 0.4 * Material[6].k_d;\n    Material[6].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[6].k_rg = 0.5 * Material[6].k_r;\n    Material[6].n = 64.0;\n    \n    // Saturn\n    Material[7].k_d = vec3( 0.5, 0.5, 0.1 );\n    Material[7].k_a = 0.4 * Material[7].k_d;\n    Material[7].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[7].k_rg = 0.5 * Material[7].k_r;\n    Material[7].n = 64.0;\n    \n    // Uranus\n    Material[8].k_d = vec3( 0.4, 0.8, 1.0 );\n    Material[8].k_a = 0.4 * Material[8].k_d;\n    Material[8].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[8].k_rg = 0.5 * Material[8].k_r;\n    Material[8].n = 64.0;\n    \n    // Neptune\n    Material[9].k_d = vec3( 0.2, 0.5, 0.7 );\n    Material[9].k_a = 0.4 * Material[9].k_d;\n    Material[9].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[9].k_rg = 0.5 * Material[9].k_r;\n    Material[9].n = 64.0;\n\n\n\n    // Light 0.\n    Light[0].position = vec3( 10.0, -2.0, 9.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( 3.0, 8.0, 8.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n// Computes intersection between a plane and a ray.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n// Computes intersection between a plane and a ray for shadow ray intersection.\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n// Computes intersection between a sphere and a ray.\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n\t// A vector from sphere center towards ray origin\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n\n    if (DdotV <= 0.0) {\n    \t// When the ray shoots towards the sphere\n    \tfloat discr = DdotV * DdotV - a0;\n    \tif (discr >= 0.0) {\n    \t\t// Smaller intersection point\n    \t\tt = -DdotV - sqrt(discr);\n    \t\thitPos = ray.o + t * ray.d;\n    \t\thitNormal = normalize(hitPos - sph.center);\n    \t\treturn (t >= tmin && t<= tmax);\n    \t}\n    }\n\treturn false;\n}\n\n// Computes intersection between a sphere and a ray for shadow ray intersection.\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    // A vector from sphere center towards ray origin\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n\n    if (DdotV <= 0.0) {\n    \t// When the ray shoots towards the sphere\n    \tfloat discr = DdotV * DdotV - a0;\n    \tif (discr >= 0.0) {\n    \t\tfloat t = -DdotV - sqrt(discr);\n    \t\treturn (t >= tmin && t<= tmax);\n    \t}\n    }\n\treturn false;\n}\n\n\n\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n// Casts a ray into the scene and returns color computed at the nearest hit position.\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    bool hasHitSomething = false;\n    // The ray parameter t at the nearest hit point.\n    float nearest_t = DEFAULT_TMAX;\n    // 3D position of the nearest hit point.   \n    vec3 nearest_hitPos; \n    // Normal vector at the nearest hit point.             \n    vec3 nearest_hitNormal;\n    // MaterialID of the object at the nearest hit point.          \n    int nearest_hitMatID;             \n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    // Try interesecting input ray with all the planes and spheres,\n    // and record the front-most (nearest) interesection.\n    for (int i = 0; i < NUM_SPHERES; i++ ) {\n    \t// Try intersect with spheres\n    \ttemp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n    \t// If intersect with spheres, compare and find the nearest\n    \tif (temp_hasHit && temp_t < nearest_t) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Sphere[i].materialID;\n    \t}\n    \t\n    }\n\n    for (int i = 0; i < NUM_PLANES; i++ ) {\n    \t// Try intersect with planes\n    \t// Use nearest_t as input tmax to determine whether the intersection point\n    \t//with planes is the nearest\n    \ttemp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, nearest_t,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n    \t// If hit, then now the hit point is nearer than spheres if any\n    \tif (temp_hasHit && temp_t < nearest_t ) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Plane[i].materialID;\n    \t}\n    \t\n    }\n    \t\n    \t\n    \n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );\n\n    // For each light source, make a shadow ray, and check if the shadow ray\n    // intersects any of the objects.\n    Ray_t ShadowRay[NUM_LIGHTS];\n    bool inshadow[NUM_LIGHTS];\n    for (int i = 0; i < NUM_LIGHTS; i++ ) {\n    \t// Make a shadow ray (from surface to light) for each light\n    \tShadowRay[i].o = nearest_hitPos;\n    \tShadowRay[i].d = normalize(Light[i].position - ShadowRay[i].o);\n\n    \tfor (int j = 0; j < NUM_SPHERES; j++ ) {\n    \t\t// If already in shadow, inshadow[i] becomes inaccessible\n    \t\tif(!inshadow[i]) {\n    \t\t\t// The point is in shadow if the shadow ray intersects with anything\n    \t\tinshadow[i] = IntersectSphere(Sphere[j], ShadowRay[i], DEFAULT_TMIN, \n    \t\t\tdistance(nearest_hitPos, Light[i].position));\n    \t\t}\n    \t}\n    \t// If not occluded, consider intersection with planes\n    \tif (!inshadow[i]) {\n    \t\tfor(int j = 0; j < NUM_PLANES; j++ ) {\n    \t\t\t// If already in shadow, inshadow[i] becomes inaccessible\n    \t\t\tif(!inshadow[i]) {\n    \t\t\t\tinshadow[i] = IntersectPlane(Plane[j], ShadowRay[i], DEFAULT_TMIN, \n    \t\t\t\tdistance(nearest_hitPos, Light[i].position));\n    \t\t\t}\n    \t\t}\n    \t}\n\n\n    \tI_local += PhongLighting( ShadowRay[i].d, nearest_hitNormal, - ray.d, inshadow[i], \n    \t\tMaterial[nearest_hitMatID], Light[i] );\n    }\n\n    \n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 4. * cos(iTime / 2.) + 1., 10.0, 1. * sin(iTime / 2.) + 5.);\n    vec3 cam_lookat = vec3( 0., 0., 2. );\n    vec3 cam_up_vec = vec3( 0.0, 0.0, 1.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2520, 2546, 2564, 2588, 7157], [7159, 7376, 7531, 7531, 7861], [7863, 7943, 8026, 8026, 8238], [8240, 8293, 8451, 8502, 8975], [8977, 9058, 9143, 9197, 9556], [9560, 9641, 9772, 9772, 10185], [10187, 10273, 10388, 10445, 13830], [13832, 14037, 14094, 14094, 15554]], "test": "valid"}
{"id": "flsXRM", "name": "[TUT] The American Flag", "author": "BigWIngs", "description": "I decided to make an American Flag for the fourth of July. This is the end result of a tutorial on YouTube. Link in the comments.", "tags": ["tutorial", "flag", "usa", "america", "artofcode"], "likes": 19, "viewed": 442, "published": "Public", "date": "1625489936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"The American Flag\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// This shader is the end result of a tutorial on YouTube you can\n// find here: https://youtu.be/t4XnK50ocMk\n\nvec3 WHITE = vec3(1);\nvec3 RED = vec3(178, 34, 52)/255.;\nvec3 BLUE = vec3(60, 59, 110)/255.;\n\nfloat Star(vec2 uv, float size) {\n    uv.x = abs(uv.x);\n    \n    float a = 6.2832/5.;\n    float d1 = dot(uv, vec2(sin(a), cos(a)));\n    a = 3.*6.2832/5.;\n    float d2 = dot(uv, vec2(sin(a), cos(a)));\n    \n    a = 2.*6.2832/5.;\n    float d4 = dot(uv, vec2(sin(a), cos(a)));\n    \n    float d = min(max(d1, d2), max(uv.y, d4));\n    float w = min(fwidth(d), 0.05);\n    \n    return smoothstep(w, -w, d-size);\n}\n\nvec2 Remap(vec2 p, float b, float l, float t, float r) {\n    return vec2( (p.x-l) / (r-l), (p.y-b) / (t-b));\n}\n\nvec3 Flag(vec2 uv) {\n    float y = sin(uv.y*3.1415*13.);\n    float w = fwidth(y);\n    float stripes = smoothstep(-w, w, y);\n    w = fwidth(uv.y);\n    vec3 col = mix(WHITE, RED, stripes);\n    \n    vec2 st = Remap(uv, .46, 0., 1., .4);\n    \n    float size = .07;\n    if(st.x>0. && st.x<1. && st.y>0. && st.y<1.) {        \n        vec2 gv = fract( st*vec2(6,5) )-.5;\n        \n        col = mix(\n            mix(col, BLUE, smoothstep(0., w*3., st.y)), \n            WHITE, \n            Star(gv, size)\n        );\n        \n        st = Remap(st, .1, .0833, .9, .9166);\n        if(st.x>0. && st.x<1. && st.y>0. && st.y<1.) { \n            vec2 gv = fract( st*vec2(5,4) )-.5;\n            col = mix(col, WHITE, Star(gv, size));\n        }\n    }\n    \n    col *= smoothstep(w, .0, abs(uv.y-.5)-.5+w);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = uv.x*7.-2.*iTime+uv.y*3.;\n    uv.y += sin(t)*.05;\n    \n    vec3 col = Flag(uv);\n    \n    col *= .7+cos(t)*.3;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsXRM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[541, 541, 574, 574, 946], [948, 948, 1004, 1004, 1058], [1060, 1060, 1080, 1080, 1864], [1867, 1867, 1924, 1924, 2127]], "test": "valid"}
{"id": "flSXWh", "name": "minimum implementation of d2d", "author": "yasuo", "description": "my private stuff. I just wanted to do this from scratch.", "tags": ["distance2d"], "likes": 4, "viewed": 199, "published": "Public API", "date": "1627488941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The minimum implementation of the distance 2D utilities for private use.\n// I guess most of the stuff is similar implementation someone has done.\n// The following distance functions can not use the round shape technique and etc...\n#define USE_MOUSE 0\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define M() (iMouse.xy-0.5*iResolution.xy)/iResolution.y\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n\n#define SliceB(p,a,b,s) max(-dot(p-a,vec2(cos(b),sin(b))),max(abs(p).x-s,abs(p).y-s))\nfloat customTri(vec2 p, vec2 a, vec2 b, vec2 c){\n    float s = 1.0;\n    float d = max(SliceB(p,b,-atan(b.x-a.x,b.y-a.y),s),SliceB(p,b,-atan(c.x-b.x,c.y-b.y),s));\n    return max(SliceB(p,c,-atan(a.x-c.x,a.y-c.y),s),d);\n}\n\nfloat bevelCornerBox(vec2 p, vec2 s, float k, float deg){\n    float d = max(abs(p).x-s.x,abs(p).y-s.y);\n    float a = radians(deg);\n    p = abs(p);\n    p-=s/k;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    return d;\n}\n\n// taper box\nfloat taperBox(vec2 p, vec2 s, float l, float r){\n    float d = max(abs(p).x-s.x,abs(p).y-s.y);\n    float al = radians(-l);\n    float ar = radians(r);\n    d = max(-dot(p-vec2(-s.x*0.5,0.0),vec2(cos(al),sin(al))),d);\n    d = max(dot(p-vec2(s.x*0.5,0.0),vec2(cos(ar),sin(ar))),d);\n    return d;\n}\n\n// I won't recommend using the following distance 2d line. This implementation is straight foward. Please use the Iq's sdLine is the best one.\n// This one is for me to use. I just wanted to create a distance line by myself.\nfloat dLine(vec2 p, vec2 a, vec2 b, float w){\n    vec2 v = normalize(b-a);\n    vec2 right = normalize(cross(vec3(v,0.0),vec3(0.0,0.0,1.0)).xy);\n    vec2 newRightVec = right*(w*0.5);\n    vec2 a1 = a+newRightVec, a2 = a-newRightVec, b1 = b+newRightVec, b2 = b-newRightVec;\n    vec2 mida = vec2((a1.x + b1.x) * 0.5, (a1.y + b1.y) * 0.5);\n    vec2 midb = vec2((a2.x + b2.x) * 0.5, (a2.y + b2.y) * 0.5);\n    \n    float rad1 = -atan(b1.x-a1.x,b1.y-a1.y);\n    float rad2 = -atan(a2.x-a1.x,a2.y-a1.y);\n    \n    float mad = Slice(p-mida,rad1);\n    float mbd = Slice(p-midb,rad1);\n    \n    float ad = Slice(p-a,rad2);\n    float bd = Slice(p-b,rad2);\n    float d = max(max(mad,-mbd),max(-ad,bd));\n    return d;\n}\n\nfloat drawExample(vec2 p){\n    // i.e. draw circle\n    float d = length(p-vec2(-0.75,0.0))-0.1;\n    \n    // i.e. draw box\n    float d2 = B(p-vec2(-0.5,0.0),vec2(0.1));\n    d = min(d,d2);\n    d2 = B(p-vec2(-0.3,0.0),vec2(0.05,0.1));\n    d = min(d,d2);\n    \n    // i.e. draw triangle\n    d2 = Tri(p-vec2(-0.09,0.1),vec2(0.2),radians(30.0));\n    d = min(d,d2);\n    \n    d2 = customTri(p,vec2(0.15,0.1),vec2(0.3,0.0),vec2(0.08,-0.1));\n    d = min(d,d2);\n    \n    // i.e. draw bevel corner box\n    d2 = bevelCornerBox(p-vec2(0.45,0.0),vec2(0.1,0.1),1.3,45.0);\n    d = min(d,d2);\n    \n    // i.e. draw taper box\n    d2 = taperBox(p-vec2(0.72,0.0),vec2(0.2,0.1),-10.0,-10.0);\n    d = min(d,d2);\n    return d;\n}\n\nfloat demo(vec2 uv){\n    vec2 prevUV = uv;\n    float d = 100.0;\n    uv+=(uv/length(uv*1.6))*sin(length(uv*1.6)*5.0-iTime*2.0)*0.05+cos(length(uv*1.6)*5.0-iTime*2.0)*0.05; \n    uv.x+=sin(uv.y+iTime*0.3)*0.8*cos(uv.x+iTime*0.6)*0.7;\n    for(float i = 0.0; i<2.0; i+=0.05){\n        d = min(abs(length(uv)-i)-0.0001,d);\n    }\n    \n    uv.y = mod(uv.y,0.05)-0.025;\n    float d2 = dLine(uv,vec2(-2.0,0.0),vec2(2.0,0.0),0.001);\n    \n    float t = mod(iTime,20.0);\n    float morph = 0.0;\n    if(t>=7.0 && t<10.0){\n        float now = t-7.0;\n        morph = (now/3.0)*1.0; \n    } else if(t>=10.0 && t<17.0){\n        morph = 1.0;\n    } else if(t>=17.0 && t<20.0){\n        float now = t-17.0;\n        morph = 1.0-(now/3.0)*1.0;\n    }\n    \n    return mix(d,d2,morph);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    vec2 m = M();\n\n    // xy axis\n    float d = dLine(uv,vec2(0.0,0.5),vec2(0.0,-0.5),0.001);\n    d = min(d,dLine(uv,vec2(-1.0,0.0),vec2(1.0,0.0),0.001));\n    col = mix(col,vec3(0.6,0.0,0.0),S(uv,d,0.0));\n\n    // test demo\n    d = demo(uv);\n    col = mix(col,vec3(0.9),S(uv,d,0.0));\n    \n    // draw example shape\n    d = drawExample(uv-vec2(0.0,0.35));\n    col = mix(col,vec3(1.0),S(uv,d,0.0));\n    \n    // i.e. outline\n    d = drawExample(uv-vec2(0.0,-0.35));\n    col = mix(col,vec3(1.0),S(uv,abs(d)-0.001,0.0));\n    \n    #if USE_MOUSE\n    // i.e. draw line\n    vec2 a = vec2(0.0), b = m;\n    float w = 0.05+abs(sin(iTime)*0.1); // for test\n    d = dLine(uv,a,b,w);\n    col = mix(col,vec3(0.9),S(uv,d,0.0));\n    \n    // draw points\n    d = min(B(uv-a,vec2(0.01)),B(uv-b,vec2(0.01)));\n    col = mix(col,vec3(1.0,0.0,0.0),S(uv,d,0.0));    \n    #endif\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSXWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[654, 654, 702, 702, 873], [875, 875, 932, 932, 1093], [1095, 1108, 1157, 1157, 1402], [1404, 1628, 1673, 1673, 2329], [2331, 2331, 2357, 2381, 3034], [3036, 3036, 3056, 3056, 3793], [3795, 3795, 3852, 3852, 4828]], "test": "valid"}
{"id": "flsXz7", "name": "2D perlin noise demo", "author": "yunhai", "description": "looks ok", "tags": ["noise"], "likes": 5, "viewed": 95, "published": "Public", "date": "1625375837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iR iResolution.xy\n#define PIXW (5.+iMouse.x/iR.x*10.)/iR.y\n#define SS(a,b,t) smoothstep(a,b,t)\nconst float PI=3.14159265;\nconst float ATR=PI/180.;\nvec2 randDir(vec2 id,float time)\n{\n    id+=vec2(3,181);\n    float t=time+PI*2.*fract(sin(83.*id.x)*(id.y)*(414.-id.y*5.));\n    return vec2(cos(t),sin(t));\n}\nmat2 getRot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat dVec(vec2 uv,vec2 dir)\n{\n    float t=clamp(dot(uv,dir)/dot(dir,dir),0.,1.);\n    t=SS(.02,.02-2.*PIXW,length(uv-dir*t));\n    float o=.8,ang=60.*ATR,ldir=length(dir);\n    vec2 op=dir*o;\n    vec2 r=dir/ldir,\n         l=getRot(ang)*r;r=getRot(-ang)*r;\n    float a=ldir*(1.01-o)*cos(ang)*1.4;\n    float tri=\n    min(min(SS(a,a-PIXW,dot(r,uv-op)),\n        SS(a,a-PIXW,dot(l,uv-op))),\n        SS(ldir*o,ldir*o+PIXW,dot(uv,dir/ldir)));\n    return max(t,tri);\n}\nfloat pnoise(vec2 uv)\n{\n    vec2 id=floor(uv);uv=fract(uv);\n    vec2 of=vec2(1,0);\n    float t=iTime;\n    float a=dot(uv-of.yy,randDir(id+of.yy,t)),\n          b=dot(uv-of.xy,randDir(id+of.xy,t)),\n          c=dot(uv-of.yx,randDir(id+of.yx,t)),\n          d=dot(uv-of.xx,randDir(id+of.xx,t));\n    uv=uv*uv*(vec2(3)-2.*uv);\n    a=mix(a,b,uv.x),b=mix(c,d,uv.x);      \n    return mix(a,b,uv.y)/1.4+.5;\n}\nfloat mpnoise(vec2 uv,int level)\n{\n    float res=0.;\n    if(level==1)\n        res=pnoise(uv);\n    else\n    {\n        res+=pnoise(uv);\n        res+=pnoise(uv*2.)*.5;\n        res+=pnoise(uv*4.)*.25;\n        res+=pnoise(uv*8.)*.125;\n        res*=.5;\n    }\n    return res;\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv= C*PIXW;\n    //draw gradient vec\n    vec2 cid=floor(uv+.5),cuv=(fract(uv+.5)-.5);\n    float t01=clamp(sin(iTime*.8)*1.+.5,0.,1.),\n          grad=min(1.,SS(.03,.025,length(cuv))+\n                      dVec(cuv,.48*randDir(cid,iTime)));\n    \n    float perlin=mix(mpnoise(uv,1),1.,grad*t01);\n    float multiPerlin=mpnoise(uv,2);\n    \n    O.rgb=vec3(mix(perlin,multiPerlin,step(.5,C.x/iR.x)));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsXz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 189, 189, 311], [312, 312, 333, 333, 376], [377, 377, 407, 407, 835], [836, 836, 859, 859, 1233], [1234, 1234, 1268, 1268, 1504], [1505, 1505, 1546, 1546, 1955]], "test": "valid"}
{"id": "flXSDH", "name": "Independence Day Fireworks", "author": "oneshade", "description": "Inspired by Martijn's tutorial [url=https://www.youtube.com/watch?v=t4XnK50ocMk]https://www.youtube.com/watch?v=t4XnK50ocMk[/url]\nA bit late but I had to finish it still :)", "tags": ["flag", "fireworks", "shaderart", "american", "independence", "fourthofjuly"], "likes": 17, "viewed": 119, "published": "Public", "date": "1625600742", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Constants\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define RHO 1.57079632679\n\n// Utilities\n#define fillDraw(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n#define glowDraw(dist, col, glow) color += col / exp((glow) * (dist))\n#define remap01(x, a, b) ((x) - (a)) / ((b) - (a))\n\n// SDFs\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0.0, 1.0);\n    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\n// Simple trajectory with an initial position, linear velocity and gravity\nvec2 posInTrajectory(in vec2 p0, in vec2 v0, in float g, in float t) {\n    vec2 p = p0 + v0 * t;\n    p.y -= 0.5 * g * t * t;\n    return p;\n}\n\nvec2 velInTrajectory(in vec2 p0, in vec2 v0, in float g, in float t) {\n    v0.y -= g * t;\n    return v0;\n}\n\n// I would try optimizing with a bbox check but unfortunately\n// the glow just doesn't work well with that :(\nvec2 sdTrajectory(in vec2 p, in vec2 p0, in vec2 v0, in float g, in float tStart, in float tEnd) {\n    vec2 q = p0 - p;\n    float t3 = 0.5 * g * g;\n    float t2 = -1.5 * g * v0.y;\n    float t1 = dot(v0, v0) - q.y * g;\n    float t0 = dot(q, v0);\n\n    t2 /= t3, t1 /= t3, t0 /= t3;\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = -2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0;\n        return vec2(length(p - posInTrajectory(p0, v0, g, clamp(root, tStart, tEnd))), root);\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = 2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0;\n        vec2 p1 = p - posInTrajectory(p0, v0, g, clamp(roots.x, tStart, tEnd));\n        vec2 p2 = p - posInTrajectory(p0, v0, g, clamp(roots.y, tStart, tEnd));\n        float d1 = dot(p1, p1), d2 = dot(p2, p2);\n        return  d1 < d2 ? vec2(sqrt(d1), roots.x) : vec2(sqrt(d2), roots.y);\n    }\n}\n\n// Modified hash from https://www.shadertoy.com/view/4djSRW\nfloat gSeed = 167.23;\nfloat random() {\n    float x = fract(gSeed++ * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvoid doFirework(inout vec3 color, in vec2 uv, in float time, in float seed) {\n    float timeFrame = floor(time / 3.0) * 3.0;\n    float fireTime = time - timeFrame;\n\n    // Generate random traits\n    gSeed = timeFrame + seed;\n    float angle = mix(0.4, 0.6, random()) * PI;\n    float speed = mix(2.0, 2.5, random());\n    vec3 sparkColor = normalize(vec3(random(), random(), random())) * 1.25;\n\n    // Compute start position, velocity, and gravity\n    vec2 p0 = vec2(0.0, 0.6);\n    vec2 v0 = vec2(cos(angle), sin(angle)) * speed;\n    float g = 1.0;\n\n    // Tracking\n    float tApogee = v0.y / g;\n    float t = tApogee * fireTime;\n    vec2 pos = posInTrajectory(p0, v0, g, t);\n\n    // Projectile and trail\n    vec3 fadeColor = sparkColor * (1.0 - fireTime / 3.0);\n    vec2 arc = sdTrajectory(uv, p0, v0, g, max(0.0, t - 2.0), t);\n    glowDraw(arc.x - 0.01, fadeColor * clamp(remap01(arc.y, t - 2.0, t), 0.0, 1.0), 15.0);\n    glowDraw(sdDisk(uv - pos, 0.02), fadeColor, 25.0);\n\n    // Cast a circle of sparks from the apogee (highest point in the trajectory)\n    if (t > tApogee) {\n        fireTime -= 1.0;\n        vec2 vApogee = velInTrajectory(p0, v0, g, tApogee);\n        p0 = posInTrajectory(p0, v0, g, tApogee);\n        for (float an=0.0; an < TAU; an += TAU / 25.0) {\n            // Tracking\n            v0 = vec2(cos(an), sin(an)) * (0.5 + random()) + vApogee;\n            t = tApogee * fireTime;\n            pos = posInTrajectory(p0, v0, g, t);\n\n            // Projectile with trail\n            vec3 fadeColor = sparkColor * (1.0 - 0.5 * fireTime);\n            vec2 arc = sdTrajectory(uv, p0, v0, g, 0.0, t);\n            glowDraw(arc.x - 0.01, fadeColor * clamp(remap01(arc.y, t - 1.0, t), 0.0, 1.0), 15.0);\n            glowDraw(sdDisk(uv - pos, 0.02), fadeColor, 25.0);\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - vec2(0.5 * iResolution.x, 0.0)) / iResolution.y * 4.0;\n    vec3 color = mix(vec3(1.0, 0.8, 0.0), vec3(0.5, 0.0, 0.0), 0.25 * (length(uv) - 0.25));\n    float unit = 8.0 / iResolution.y;\n\n    // Flagpole\n    fillDraw(sdBox(vec2(uv.x, uv.y - 1.75), vec2(0.035, 1.75)), vec3(0.0));\n\n    // Flag\n    vec2 flagUv = uv - vec2(0.845, 2.85);\n\n    // Wave and shear to make it look like its more in perspective\n    float x = uv.x - 0.035;\n    flagUv.x = 1.1 * flagUv.x + 0.08;\n    flagUv.y += 0.1 * x * sin(3.0 * (flagUv.x - iTime)) + 0.3 * x;\n\n    // Shadows to highlight the ripples\n    float shadow = 0.4 * sin(3.0 * (flagUv.x - iTime));\n    shadow *= shadow;\n\n    fillDraw(sdBox(flagUv, vec2(0.8, 0.64)), vec3(1.0) - shadow);\n\n    // Red and white stripes (one for each of the original 13 colonies)\n    vec2 stripesUv = flagUv;\n    stripesUv.y -= clamp(round(stripesUv.y * 5.0) * 0.2, -0.6, 0.6);\n    fillDraw(sdBox(stripesUv, vec2(0.8, 0.6 / 13.0)), vec3(0.78, 0.06, 0.18) - shadow);\n\n    // Blue background and stars (one star for each of the 50 current states)\n    // The stars are in staggered rows, 6 stars, 5 stars, repeat for 9 rows total\n    vec2 starsUv = flagUv - vec2(-0.38, 0.3);\n    fillDraw(sdBox(starsUv, vec2(0.425, 0.35)), vec3(0.0, 0.13, 0.41) - shadow);\n\n    vec2 repSize = vec2(0.85, 0.7) / vec2(6.0, 9.0);\n    float cy = floor(starsUv.y / repSize.y + 0.5) * repSize.y; // Cell y coordinate\n\n    float stagger = mod(floor(cy / repSize.y), 2.0) * 0.5;\n    float bx = 0.375 - stagger * repSize.x; // Repetition x bound (varied to create staggered rows)\n    float cx = (floor(starsUv.x / repSize.x + stagger) + abs(stagger - 0.5)) * repSize.x; // Cell x coordinate\n\n    starsUv -= clamp(vec2(cx, cy), -vec2(bx, 0.3), vec2(bx, 0.3));\n    fillDraw(sdStar5(starsUv, 0.02, 0.4), vec3(1.0) - shadow);\n\n    // Fireworks\n    vec2 fireUv = uv;\n    fireUv.x = abs(fireUv.x) - 2.0;\n\n    // Spouts\n    fillDraw(sdBox(vec2(fireUv.x, fireUv.y - 0.04), vec2(0.15, 0.04)), vec3(0.0));\n    fillDraw(sdBox(vec2(fireUv.x, fireUv.y - 0.3), vec2(0.06, 0.3)), vec3(0.0));\n\n    // Sparks\n    doFirework(color, vec2(uv.x - 2.0, uv.y), iTime, 394.438);\n    doFirework(color, vec2(uv.x + 2.0, uv.y), iTime + 1.0, 593.458);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXSDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 315, 352, 352, 380], [382, 382, 429, 429, 537], [539, 539, 574, 574, 654], [656, 735, 786, 786, 1196], [1198, 1273, 1343, 1343, 1413], [1415, 1415, 1485, 1485, 1521], [1523, 1633, 1731, 1731, 2948], [3032, 3032, 3048, 3048, 3146], [3148, 3148, 3225, 3225, 4940], [4942, 4942, 4997, 4997, 7270]], "test": "valid"}
{"id": "flXXR4", "name": "patiently", "author": "vivavolt", "description": "used iq's cosine filtering as a base", "tags": ["fft", "color", "audio"], "likes": 2, "viewed": 56, "published": "Public", "date": "1625191632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)â«cos(t)dt with t â (x-Â½w, x+Â½w)\n// = [sin(x+Â½w) - sin(x-Â½w)]/w\n// = cos(x)Â·sin(Â½w)/(Â½w)\n//\n// Can approximate smoothstep(2Ï,0,w) â sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\nbool mode = true;\n\nvec3 fcos( vec3 x )\n{\n    if( mode) return cos(x);                // naive\n\n    vec3 w = fwidth(x);\n    #if 0\n    return cos(x) * sin(0.5*w)/(0.5*w);     // filtered-exact\n\t#else\n    return cos(x) * smoothstep(6.28,0.0,w); // filtered-approx\n\t#endif  \n}\n\nvec3 getColorB( in float t, float k )\n{\n    vec3 col = vec3(0.4,0.4,0.4);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.2+k,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,1.4,0.1+k));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1+k,0.7,1.1));\n    col += 0.09*fcos(6.28318*t*  9.1+vec3(0.2,0.8+k,1.4));\n    return col;\n}\n\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.4,0.4,0.4);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.09*fcos(6.28318*t*  9.1+vec3(0.2,0.8,1.4));\n    col += 0.08*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.07*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.06*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.06*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.09*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\nvec2 deform( in vec2 p, float t, float k )\n{\n    // deform 1\n    p *= 0.55;\n    p = mix(p, 3.*p/dot(p,p), .1);\n    p.x += t*0.1;\n    \n    // deform 2\n    p += k*0.2*cos( 5.*k+ 1.5*p.yx + 0.03*1.0*t + vec2(0.1,1.1) );\n    p += k*0.2*sin( 5.*k+ 2.4*p.yx + 0.03*1.6*t + vec2(4.5,2.6) );\n    p += k*0.2*cos( 5.*k+ 3.3*p.yx + 0.03*1.2*t + vec2(3.2,3.4) );\n    p += k*0.2*sin( 5.*k+ 4.2*p.yx + 0.03*1.7*t + vec2(1.8,5.2) );\n    p += k*0.2*cos( 5.*k+ 9.1*p.yx + 0.03*1.1*t + vec2(6.3,3.9) );\n    \n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixellate\n    float d = iResolution.x / 320.;\n    fragCoord = floor(fragCoord / d)*d;\n    \n    // coordiantes\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 w = p;\n    \n    \n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    int ty = int(uv.y*512.0);\n    float sx = texelFetch(iChannel0, ivec2(tx, 0), 0).x;\n    float sy = texelFetch(iChannel0, ivec2(ty, 0), 0).x;\n    float ss = .5*sin(sx) + .5*cos(sy);\n    //ss = 1.;\n\n    // deformation\n    p = deform( p, iTime * 20. + (ss * 30.) , ss * 1.);\n\n    // base color pattern\n    vec3 col = getColorB( 0.5*length(p ), ss*10.);\n    \n \n    // output\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXXR4.jpg", "access": "shaders20k", "license": "mit", "functions": [[1882, 1882, 1903, 1903, 2135], [2137, 2137, 2176, 2176, 2464], [2466, 2466, 2495, 2495, 3060], [3062, 3062, 3106, 3122, 3567], [3569, 3569, 3625, 3642, 4346]], "test": "error"}
{"id": "flXXWs", "name": "hept32 :::. bitmagic hash", "author": "ENDESGA", "description": "Using some pretty neat bitmagic tricks, this cross-language integer hash (was made in C during testing and creation) gives some really good distribution statistics. In C, it showed some promising performance levels too!\n\nFeel free to suggest improvements!", "tags": ["noise", "random", "hash", "prng", "bitmagic", "hept", "hept32"], "likes": 3, "viewed": 355, "published": "Public API", "date": "1626771911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    777    777    777 \n\t7777   7777   7777\n\n\t777    777    777    777 \n\t7777   7777   7777   7777\n*/\n// Copyright Â© 2021 ENDESGA\n// MIT License:\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nuint HEPT32_SEED = 0x12334567u; // global seed, can be anything\n\nuint _HEPT32_X = 0x77777777u, _HEPT32_Y = 0x77777777u, _HEPT32_Z = 0x77777777u;\n\nuint hept32(uint x, uint y, uint z) {\t\n    x = (x * _HEPT32_X) - (~x * 0x77777777u) - ~(x * _HEPT32_Y);\n\ty = (y * _HEPT32_Y) - (~y * 0x77777777u) - ~(y * _HEPT32_Z);\n\tz = (z * _HEPT32_Z) - (~z * 0x77777777u) - ~(z * _HEPT32_X);\n\treturn ~(~(~x * y * z) * ~(x * ~y * z) * ~(x * y * ~z));\n}\n\nvoid hept32_seed(uint seed) {\n    // multi-layer seed expansion and extraction\n\tseed = (hept32(seed,seed,seed) * 0x77777777u) - 0x77777777u;\n\t_HEPT32_X = (hept32(0x77777777u,seed,seed) * seed) - seed;\n\t_HEPT32_Y = (hept32(seed,0x77777777u,seed) * seed) - seed;\n\t_HEPT32_Z = (hept32(seed,seed,0x77777777u) * seed) - seed;\n}\n\n// high-entropy reliable alternative, but a lot slower (4-6x slower in some tests in C++)\nuint hept32e(uint x, uint y) {\n    uint e = 0u;\n    \n    x = ((0xBBBBBBBBu * x)) * ((0xDDDDDDDDu - ~x) - HEPT32_SEED);\n\ty = ((0xEEEEEEEEu - y)) * ((0x77777777u * ~y) - HEPT32_SEED);\n    e = ~((x - y) * HEPT32_SEED);\n    x = ((0x7777EEDBu * x)) * ((0xBBBB77EDu - ~x) - e);\n\ty = ((0xDDDDBB7Eu - y)) * ((0xEEEEDDB7u * ~y) - e);\n    \n    x = (x >> 16) | (x << 16);\n    y = (y >> 16) | (y << 16);\n\te = ~(~(~x * y) * ~(x * ~y));\n    // all bit-planes now resemble complex noise even before the mix:\n    return (e ^ ~(e >> 16));\n}\n\n///////\n\nuint noise(uint x, uint y, uint z) {\n\n    return hept32(x,y,z);\n\n    // start of a blending/blur attempt\n    // probably need to be done with floats rather than uint?\n    return (\n        ((hept32(x,y,z) + hept32(x-1u,y,z) + hept32(x,y-1u,z) + hept32(x+1u,y,z) + hept32(x,y+1u,z)) / 5u) +\n        hept32(x,y,z)\n    ) >> 1;\n}\n\nvoid mainImage( out vec4 o, in vec2 i ) {\n    \n    // need to set the seed at least once\n    hept32_seed(7u);\n\n    o = vec4(vec3(float(noise(\n        uint(i.x + (iTime*77.777)),\n        uint(i.y + (iTime*77.777)),\n        7u)) * 2.32830644e-10), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXXWs.jpg", "access": "shaders20k", "license": "mit", "functions": [[1320, 1320, 1357, 1357, 1607], [1609, 1609, 1638, 1687, 1931], [1933, 2023, 2053, 2053, 2546], [2557, 2557, 2593, 2593, 2881], [2883, 2883, 2924, 2971, 3136]], "test": "valid"}
{"id": "fsSSzh", "name": "Haru86_RaymarchHole", "author": "Haru86_", "description": "Haru86_RaymarchHole", "tags": ["raymarching"], "likes": 8, "viewed": 114, "published": "Public", "date": "1625233303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n float rand(vec2 st)\n{\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\n              \n\nvec2 pmod(vec2 p, float n)\n{\nfloat a = atan(p.x, p.y) + PI / n;\nfloat th = 2.0 * PI / n;\na = floor(a / th) * th;\nreturn rot(a)* p;\n}\n\nfloat Cube(vec3 p, float s)\n{\np = abs(p);\nreturn length(max(p - vec3(s, s, s), 0.0));\n}\n\nfloat sdCross(vec3 p, float scale)\n{\np = abs(p);\nfloat dxy = max(p.x, p.y);\nfloat dyz = max(p.y, p.z);\nfloat dzx = max(p.z, p.x);\nreturn min(dxy, min(dyz, dzx)) - scale;\n}\n\n\nfloat menger(vec3 p)\n{\n    float k = 1.;\n    p.z = mod(p.z, k) - 0.5 * k;\n\n    //\n    float s = .8;\n    p = abs(p);\n    float d = Cube(p, s);\n    //\n    float scale = 4.;\n    //\n    float h = 1.5;\n    for (int i = 0; i < 4; i++)\n    {\n\n        p = mod(p, h) - h * 0.5;\n        s *= scale;\n        p = 1.0 - scale * abs(p);\n        //\n        d = max(d, sdCross(p, .75) / s);\n\n    }\n\n    return d;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h)\n{\nconst vec3 k = vec3(-0.8660254, 0.5, 0.57735);\np = abs(p);\np.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\nvec2 d = vec2(\n    length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x),\n    p.z - h.y);\nreturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n#define rootT 1.73205080757\n\n\nfloat hex(vec3 p,float height) {\n    p.yz *=rot(PI / 2.0); \n    p.xy *=rot(PI / 2.0); \n\n    float r = .015;\n    float l = .015;\n    p.z -= height;\n    p.xy = abs(p.xy);\n    float offset = 0.025;\n\n    vec3 pos1 = p;\n    vec3 pos2 = p;\n    vec2 off1 = vec2(2.0, 2.0 * rootT) * r + vec2(offset, offset);\n\n\n\n\n    pos1.x = mod(pos1.x, off1.x) - off1.x * 0.5;\n\n\n    pos2.x= mod(pos2.x + 0.5 * off1.x, off1.x) - off1.x * 0.5;\n    pos2.y -= off1.y * 0.5;\n\n\n    float d1 = sdHexPrism(pos1, vec2(r, l));\n    float d2 = sdHexPrism(pos2, vec2(r, l));\n\n\n\n\n    d1 = min(d1, d2);\n\n    return d1;\n}\n\nfloat AirPlane(vec3 p){\n\n    return 1.0;\n\n}\n\nfloat map(vec3 p,inout float flash)\n{\n     vec3 pos2=p;\n     p.z -= iTime * 0.5;\n    \n    \n    /////////////////////////\n    vec3 pos = p;\n    pos=abs(pos)-0.5;\n    pos.z-=0.5;\n    pos.z-=0.2;\n    pos.z-=0.5;\n    pos.z-=0.1;\n    \n    pos.xy = pmod(pos.xy, 10.0);\n    float k=1.2;\n    pos=mod(pos,k)-k*0.5;\n    float d2 = menger(pos);\n  \n    if (d2 < 0.001) {\n        flash =1.0- abs(sin(p.z+iTime*4.0));\n        flash += .15;\n        flash = clamp(flash,0.0, 1.0);\n    }\n    \n    ////////////////////////\n    //pos2\n    float d3=AirPlane(pos2);\n    \n    \n    ////////////////////////\n    \n\n    return d2;\n\n\n\n}\n\n\nvec3 gn(vec3 p) {\n    vec2 e = vec2(0.0001, 0.0);\n    float flash = 0.0;\n    return normalize(vec3(\n        map(p + e.xyy, flash) - map(p - e.xyy, flash),\n        map(p + e.yxy, flash) - map(p - e.yxy, flash),\n        map(p + e.yyx, flash) - map(p - e.yyx, flash)\n        ));\n}\n\nvec3 hsv2rgb2(vec3 c, float k) {\n    return smoothstep(0. + k, 1. - k,\n        .5 + .5 * cos((vec3(c.x, c.x, c.x) + vec3(3., 2., 1.) / 3.) * radians(360.)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   vec2 st=(fragCoord.xy*2.-iResolution.xy)/min(iResolution.x,iResolution.y);\n//st*=rot(iTime);\n float radius=.25;\n   float phi=iTime*0.2;\n   \n   vec3 ro=vec3(0.0,-0.05,1.0);\n  // vec3 ro=vec3(radius*cos(phi),0.0,radius*sin(phi));\n   //vec3 rd=normalize(vec3(uv.xy,-3.0));\n   vec3 ta=vec3(0.0,0.0,0.0);\n   \n   vec3 cDir=normalize(ta-ro);\n   vec3 side=cross(cDir,vec3(0.0,1.0,0.0));\n   vec3 up=cross(cDir,side);\n   float fov=0.6;\n   \n   vec3 rd=normalize(vec3(st.x*side+st.y*up+cDir*fov));\n    \n      vec3 col = vec3(0., 0., 0.);\n\n    float d, t, acc, flash = 0.0;\n    float adjD = .75;\n\n    for (int i = 0; i < 80; i++)\n    {\n        d = map(ro + rd * t, flash);\n        if (d < 0.001 || t>1000.0)break;\n        t += d * adjD;\n        acc += exp(-1.0 * d);\n\n\n    }\n\n    vec3 refRo = ro + rd * t;\n    vec3 n = gn(refRo);\n    //rd = refract(rd, n,.25);\n    rd = reflect(rd, n);\n    ro = refRo;\n    t = 0.1;\n    float acc2, flash2 = 0.0;\n    for (int i = 0; i < 20;i++){\n        d = map(ro + rd * t, flash2);\n        if (d < 0.0001 || t>1000.0)break;\n        t += d * adjD;\n        acc2 += exp(-1.0 * d);\n    }\n    float H = mod(iTime*0.1, 1.0);\n    col = acc * hsv2rgb2(vec3(H,1.0,1.0),2.2) * 0.08 * flash;\n    //col += acc2 *vec3(1.,1.,1.) * 0.01 * flash2 ;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 95, 95, 165], [182, 182, 210, 210, 314], [316, 316, 345, 345, 403], [405, 405, 441, 441, 576], [579, 579, 601, 601, 977], [979, 979, 1013, 1013, 1290], [1322, 1322, 1354, 1354, 1904], [1906, 1906, 1929, 1929, 1949], [1951, 1951, 1988, 1988, 2560], [2563, 2563, 2580, 2580, 2840], [2842, 2842, 2874, 2874, 3001], [3004, 3004, 3061, 3061, 4361]], "test": "valid"}
{"id": "ft2SRm", "name": "Intersection Quadratic - X axis", "author": "Yusef28", "description": "Quadratic Formula", "tags": ["intersection", "x", "quadratic", "y0"], "likes": 4, "viewed": 158, "published": "Public API", "date": "1627698740", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 26-07-2021                                  //\n// Status: On Going                                        //\n// Topic: Quadratic X Axis Intersection                    //\n// Sources: Rudimentary Concept (Google/Wikipedia/Youtube) //\n// Listening to: Best Of Djent Instrumental Volume 1       //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////      BACKGROUND GRID DESIG          //\n      //                                   //\n      /////////////////////////////////////\n      \n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    \n    //graph background\n    vec3 col = vec3(0.1);\n    \n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    \n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////     INTERSECTION CALCULATIONS       //\n      //                                   //\n      /////////////////////////////////////\n\n\n    //a b and c for the quadratic formula \n    //work out to this based on my algebraic manipulations\n    //starting with substituting y in the circle formula\n    //with the right hand side of the line equation y = mx+b\n    \n    float a = 1.;\n    float b = sin(iTime)*4.5;\n    float c = cos(iTime)*3.;\n    \n    //y calculated based on some qaudratic function of x\n    float y = uv.x*uv.x*a + uv.x*b + c;\n    \n    //the descriminant\n    float desc = b*b - 4.*a*c;\n    \n    //the two roots (or one or none depending)\n    float root1 = (-b + sqrt(desc))/2.*a;\n    float root2 = (-b - sqrt(desc))/2.*a;\n\n    //calculate the intersection points\n    vec2 intersectionPoint1 = vec2(root1, 0.);\n    vec2 intersectionPoint2 = vec2(root2, 0.);\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////        DRAWING EVERYTHING           //\n      //                                   //\n      /////////////////////////////////////\n    \n    \n    //Drawing the quadratic line\n    //float f = 1.0-smoothstep(0.02,0.06,abs(y-uv.y)); //old way\n    //new way using derivatives\n    //it's y - uv.y where \"y\" is some quadratic of x\n    float f = 1.0-smoothstep(0.02,0.15,abs(y-uv.y)/fwidth(y-uv.y)/20.);\n    col = mix(col, vec3(1.,.2,0.5), f);\n    \n    if(desc >= 0.){\n    //intersection point 1\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv-intersectionPoint1)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-intersectionPoint1)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    \n    //intersection point 2\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv-intersectionPoint2)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-intersectionPoint2)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    }\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2SRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[622, 622, 679, 731, 4734]], "test": "error"}
{"id": "ft2SRw", "name": "infinite cubes", "author": "calimops", "description": "cubes on loop", "tags": ["infiniteabberationrecursion"], "likes": 6, "viewed": 175, "published": "Public API", "date": "1627321763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926\n\n// SETTINGS\nconst float zFar = 50.;\nconst float zNear = 1.;\n\nconst vec3 background_color = vec3(0.7);\nconst float collision_distance = 0.001;\nconst int marching_iterations = 64;\n\nconst float normal_partial_derivative_epsilon = 0.00001;\n\n// COLORS\nconst vec3 red   = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue  = vec3(0.8);\n\nfloat sq(in float n) {\n    return n * n;\n}\n\n// Transformations\nmat4 worldMatrix = mat4(1., 0., 0., 0.,   0., 1., 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);\n\nvoid identity() {\n    worldMatrix = mat4(1., 0., 0., 0.,   0., 1., 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);\n}\n\nvoid scale(in float a, in float b, in float c) {\n    worldMatrix *= mat4(a , 0., 0., 0.,\n                        0., b , 0., 0.,\n                        0., 0., c , 0.,\n                        0., 0., 0., 1.);\n}\n\nvoid trans(in vec3 v) {\n    worldMatrix *= mat4(1., 0., 0., v.x,\n                        0., 1., 0., v.y,\n                        0., 0., 1., v.z,\n                        0., 0., 0., 1.);\n}\n\n\nconst float factor = 0.001;\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n//      p = vec3(p.x*cos(iTime*factor) - p.y*sin(iTime*factor), p.x*sin(iTime*factor) + p.y*cos(iTime*factor), p.z);\n      p = abs(p)-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec4 scene(vec3 pos) {\n    pos = (vec4(pos, 1.) * worldMatrix).xyz;\n    pos = mod(pos, 10.)-5.0;\n    return vec4(blue, sdBoundingBox(pos, vec3(3.0), 0.3)); \n}\n\nvec3 calcNormal( in vec3 p ) {\n    const float h = 0.001;\n    const vec2 k = vec2(1, -1);\n    return normalize( k.xyy * scene( p + k.xyy * h ).a + \n                      k.yyx * scene( p + k.yyx * h ).a + \n                      k.yxy * scene( p + k.yxy * h ).a + \n                      k.xxx * scene( p + k.xxx * h ).a );\n}\n\nvec4 ray_marching(vec3 pos, vec3 dir) {\n    dir = normalize(dir);\n    float len = 0.;\n    float mindist;\n    vec3 color;\n    vec3 norm;\n\n    for (int i = 0; i < marching_iterations; ++i) {\n    \n//        pos = vec3(pos.x*cos(len*factor) - pos.y*sin(len*factor), pos.x*sin(len*factor) + pos.y*cos(len*factor), pos.z);\n\n        vec4 tmp = scene(pos);\n        \n        color = tmp.rgb;\n        mindist = tmp.a;\n        norm = calcNormal(pos);\n        len += mindist;\n        \n        //pos = vec3(pos.x*cos(len*factor) - pos.y*sin(len*factor), pos.x*sin(len*factor) + pos.y*cos(len*factor), pos.z);\n\n        if (mindist < collision_distance) \n        {\n            return vec4(color * max(0.4, dot(normalize(vec3(0.) - pos), norm)), len);\n        }\n        \n        if (len > zFar) \n        {\n            return vec4(background_color, len);\n        }\n\n        //len += mindist;\n        pos += dir * mindist;\n    }\n    return vec4(background_color, len);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / vec2(min(iResolution.x, iResolution.y));\n    uv -= (iResolution.xy / min(iResolution.x, iResolution.y) - vec2(1.)) / 2.;\n    //uv.y = 1. - uv.y;\n    \n    float aberrationAmount = 0.1;\n    vec2 distFromCenter = uv - 0.5;\n    \n    vec2 aberrated = aberrationAmount * pow(distFromCenter, vec2(3.0, 3.0));\n    \n\n    identity();\n    trans(vec3(5, 5, 10.*iTime));\n    //rotx(iTime/10.0 + 2.);\n    //rotz(iTime/10.0 + 2.);\n    //roty(iTime/10.0 + 2.);\n    \n    vec4 rayMar1 = ray_marching(vec3(0.), vec3(uv - vec2(0.5)-aberrated, zNear));\n    vec4 rayMar2 = ray_marching(vec3(0.), vec3(uv - vec2(0.5), zNear));\n    vec4 rayMar3 = ray_marching(vec3(0.), vec3(uv - vec2(0.5)+aberrated, zNear));\n    \n    vec3 color = (exp(-0.06 * rayMar2.a)) * vec3(rayMar1.r, rayMar2.g, rayMar3.b);\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2SRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[376, 376, 398, 398, 418], [535, 535, 552, 552, 648], [650, 650, 698, 698, 861], [863, 863, 886, 886, 1052], [1084, 1084, 1132, 1249, 1541], [1543, 1543, 1565, 1565, 1701], [1703, 1703, 1733, 1733, 2026], [2028, 2028, 2067, 2067, 2980], [2982, 2982, 3039, 3039, 3878]], "test": "valid"}
{"id": "ft2XDR", "name": "Warpy squiggly thingy", "author": "SnoopethDuckDuck", "description": "Forked from iq. Code is slopppyyyyyy", "tags": ["cool"], "likes": 4, "viewed": 62, "published": "Public", "date": "1627439652", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\nconst float tau = 2. * 3.14159;\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n     float t = 0.01* log(iTime + 10.);\n     float K1 = 0.366025404; // (sqrt(3)-1)/2;\n     float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( t + n, vec3(70.0) );\n}\n\nvec4 colorMap(vec3 a, vec3 b, vec3 c, vec3 d, float t) {\nvec3 col = a + b * vec3(cos(tau * (c.r * t + d.r)),\n                        cos(tau * (c.g * t + d.g)),\n                        cos(tau * (c.b * t + d.b)));\n\nreturn vec4(col.r, col.g, col.b, 1.);\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 p = fragCoord.xy / iResolution.xy;\n\n\t//vec2 uv = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\tvec2 R = iResolution.xy;\nvec2 uv = 2.8 * (fragCoord.xy  -0.5 * R.xy)/R.y;\nfloat screenWarp = 1.0+pow(length(uv), 3. * cos(0.4 * iTime))*0.3;\nuv *= screenWarp;\nuv += vec2(2. * sin(iTime), 0.4 *iTime);\n\n\tfloat f = 0.0;\n\t\tuv = uv * 0.04;\n        mat2 m = (1. + 0.005 * noise(uv + 0.5 * vec2(cos(0.5 *iTime),0.5 * sin(0.5*iTime)))) * mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.800*noise( uv ); uv = m*uv;\n\t\tf += 0.100*noise( uv ); uv = m*uv;\n\t\tf += 0.050*noise( uv ); uv = m*uv;\n\t\tf += 0.025*noise( uv ); uv = m*uv;\n        \n\tf += 1.8 * noise(4.8* (1.-uv));//cos(3.14159 * 2. * (1. + cos(0.3 * iTime)) * f * (1.-f));\n    \nvec3 h = vec3(0.5, 0.5, 0.5);\nfloat t = 0.05 * iTime +1.1;\nfloat b1 = 0.25 * (1. + cos(t));\nfloat b2 = 0.25 * (1. + cos(t + tau / 3.));\nfloat b3 = 0.25 * (1. + cos(t + 2. * tau / 3.));\nfloat k = 0.1 * cos(0.8 * iTime + f);\nfragColor = colorMap(h-t, h + t, h, vec3(0.5 + k,0.5,0.5 - k), f);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2XDR.jpg", "access": "shaders20k", "license": "mit", "functions": [[2053, 2053, 2110, 2110, 2225], [2227, 2227, 2253, 2253, 2765], [2767, 2767, 2823, 2823, 3021], [3075, 3075, 3132, 3246, 4155]], "test": "valid"}
{"id": "ft2XWh", "name": "Fixed-Point Int Voxel Traversal", "author": "ENDESGA", "description": "In C, this method is faster than Bresenham's. It might not be good for voxel rendering, but I feel like it MIGHT have some advantages somewhere?\n\nThis can be easily expanded to multiple dimensions", "tags": ["ray", "line", "voxel", "integer", "fixedpoint", "traversal"], "likes": 3, "viewed": 164, "published": "Public API", "date": "1627563304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat line2d(vec2 uv, ivec2 pos, ivec2 dir)  \n{  \n    int x1 = pos.x, y1 = pos.y;\n    int x2 = dir.x + x1, y2 = dir.y + y1;\n    \n    int xd = x2 - x1, yd = y2 - y1, hs = (x1 << 16) + 0x8000, vs = (y1 << 16) + 0x8000;\n\tint a = max(abs(xd), abs(yd)); // a must not = 0\n\tint xs = ((xd << 16) / a), ys = ((yd << 16) / a); // only 2 int-divides per-line\n\twhile (a-- >= 0) {\n    \n        // ivec2((hs >> 16), (vs >> 16)) is the voxel point\n        \n        if (ivec2(floor(uv * 64.0)) == ivec2((hs >> 16), (vs >> 16))) return 1.0; \n        \n\t\ths += xs;\n\t\tvs += ys;\n\t};\n    \n    return 0.0;\n} \n\nvoid mainImage( out vec4 frag, in vec2 coord )\n{\n    coord.xy+=.01;\n\tvec2 uv = coord.xy / iResolution.xy;\n\tvec2 gr = coord.xy;\n\tfloat aspect = iResolution.y / iResolution.x;\n\tvec2 pixel = vec2(1.0);\n\tuv.y    *= aspect;\n\tpixel.y *= aspect;\n\tgr.y    *= aspect;\n\n\tvec2 gridXY  = step(pixel,  mod(gr, iResolution.xy/64.0)) * .5;\n\tvec3 backCol = vec3(gridXY.x*gridXY.y) * vec3(.5)+.15;\n\n\tfloat ang = iTime * 1.777;\n\t\n\tfloat l = line2d(uv, ivec2(32,18), ivec2(floor(vec2(sin(ang)*30., cos(ang)*16.))));\n\tvec4 col = vec4(min(backCol+backCol*l*2.0, 1.0), 1.0);\n\t\n    frag = ((col * col) + col) * vec4(0.5,0.0,0.125,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2XWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 48, 48, 586], [589, 589, 637, 637, 1203]], "test": "valid"}
{"id": "ft2Xzz", "name": "Fractal 65_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 1, "viewed": 212, "published": "Public API", "date": "1626960194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<160.;\n        O.xyz+=mix(vec3(1),H(cos(log(s)))*.5,.8)*1e-4*i/e/s\n    )\n    {\n        p=g*d;\n        p.z+=iTime;\n        s=3.;\n        p=abs(mod(p,2.)-1.)-1.;\n        p.x<p.z?p=p.zyx:p;\n        p.y<p.z?p=p.xzy:p;\n        for(int j;j++<8;p=abs(p)*e-vec3(.03,.4,20))\n            s*=e=2.5/clamp(dot(p,p),.3,1.3);\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2Xzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 612]], "test": "valid"}
{"id": "ftBXR1", "name": "CLIP+CPPN Self portait", "author": "atara", "description": "Hevily inspired by the work of @eps696 a self portrait using CLIP and image reference, a text prompt and self generating code. \nThis is evaluating a neural net with the right weights and biases to generate me.", "tags": ["clip", "ai", "neuralnet", "cppn", "neuralrendering"], "likes": 6, "viewed": 147, "published": "Public", "date": "1627021107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#define N_HIDDEN 20\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(-0.265, 0.235, -0.180, -0.363) + mat4(vec4(-0.192, 0.696, -0.572, 0.724), vec4(-0.327, -0.696, 0.280, 0.089), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[1] = vec4(-0.280, 0.300, 0.089, -0.424) + mat4(vec4(0.237, 1.067, -0.209, -0.865), vec4(1.126, -0.670, 1.496, 0.711), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[2] = vec4(-0.398, 0.244, -0.141, -0.111) + mat4(vec4(-0.233, -0.332, 0.467, 0.577), vec4(0.086, 0.006, -1.265, -0.257), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[3] = vec4(-0.116, 0.133, 0.043, 0.130) + mat4(vec4(0.227, -1.379, -0.616, -0.620), vec4(0.291, -0.721, 0.053, -0.668), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[4] = vec4(-0.211, -0.339, 0.407, -0.224) + mat4(vec4(0.096, 1.032, 0.356, 0.647), vec4(-0.135, 0.344, 1.315, -0.002), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(0.043, -0.190, -0.127, -0.483) + mat4(vec4(0.155, -0.041, 0.359, 0.468), vec4(0.108, 0.064, 0.136, -0.188), vec4(0.205, -0.299, -0.168, -0.124), vec4(-0.132, -0.126, -0.055, 0.156)) * bufB[0] + mat4(vec4(0.006, -0.377, -0.058, -0.232), vec4(-0.213, -0.119, 0.025, 0.266), vec4(-0.035, -0.152, 0.056, -0.078), vec4(0.091, -0.095, 0.287, 0.052)) * bufB[1] + mat4(vec4(0.010, -0.135, -0.209, 0.017), vec4(-0.225, -0.008, -0.170, 0.021), vec4(-0.065, 0.015, 0.142, -0.045), vec4(-0.151, -0.006, 0.310, -0.188)) * bufB[2] + mat4(vec4(-0.114, -0.049, 0.018, 0.028), vec4(-0.098, -0.026, 0.129, 0.034), vec4(-0.107, 0.046, -0.363, 0.046), vec4(-0.044, 0.166, 0.049, 0.111)) * bufB[3] + mat4(vec4(-0.115, 0.181, -0.063, -0.202), vec4(-0.221, -0.049, -0.168, -0.029), vec4(-0.158, -0.098, 0.017, -0.129), vec4(0.057, 0.047, 0.025, 0.067)) * bufB[4] + mat4(vec4(0.145, -0.040, 0.058, -0.124), vec4(-0.136, -0.035, -0.250, -0.174), vec4(0.303, 0.148, 0.106, -0.055), vec4(-0.012, 0.057, 0.179, 0.070)) * bufB[5] + mat4(vec4(0.065, 0.153, -0.145, 0.128), vec4(0.038, 0.233, -0.240, 0.107), vec4(-0.022, 0.191, 0.003, 0.216), vec4(0.006, 0.174, -0.105, 0.238)) * bufB[6] + mat4(vec4(-0.191, 0.091, 0.002, -0.142), vec4(0.071, -0.065, -0.014, -0.188), vec4(0.060, -0.041, 0.025, -0.081), vec4(0.176, 0.056, 0.231, 0.022)) * bufB[7] + mat4(vec4(-0.098, 0.026, 0.033, 0.019), vec4(0.229, -0.113, 0.155, -0.063), vec4(-0.084, -0.014, 0.256, 0.138), vec4(0.081, 0.089, 0.021, 0.117)) * bufB[8] + mat4(vec4(-0.167, -0.002, 0.076, -0.084), vec4(0.032, 0.015, 0.067, -0.179), vec4(0.241, 0.082, 0.002, -0.133), vec4(0.090, 0.035, -0.023, -0.202)) * bufB[9];\nbufA[1] = vec4(-0.467, 0.142, 0.450, 0.215) + mat4(vec4(-0.029, -0.076, 0.414, 0.038), vec4(-0.331, 0.157, -0.095, 0.021), vec4(0.035, 0.010, 0.038, -0.031), vec4(-0.042, 0.093, 0.051, 0.051)) * bufB[0] + mat4(vec4(0.031, 0.134, 0.169, -0.002), vec4(-0.052, -0.082, 0.102, 0.033), vec4(-0.077, -0.322, 0.009, 0.100), vec4(0.210, 0.029, 0.127, -0.112)) * bufB[1] + mat4(vec4(-0.336, -0.174, -0.165, 0.113), vec4(-0.088, -0.036, 0.248, -0.047), vec4(-0.089, -0.397, 0.172, -0.204), vec4(-0.291, 0.257, -0.299, 0.102)) * bufB[2] + mat4(vec4(-0.012, -0.089, -0.004, -0.076), vec4(0.104, 0.124, 0.201, 0.047), vec4(0.143, -0.009, -0.077, -0.230), vec4(-0.197, -0.114, 0.067, -0.026)) * bufB[3] + mat4(vec4(-0.083, 0.088, -0.058, -0.020), vec4(-0.306, -0.146, 0.113, -0.000), vec4(0.070, -0.103, -0.052, -0.124), vec4(-0.156, 0.042, 0.097, 0.311)) * bufB[4] + mat4(vec4(-0.002, -0.059, -0.260, 0.134), vec4(0.133, -0.117, 0.368, -0.149), vec4(0.025, 0.042, 0.205, -0.034), vec4(0.157, 0.132, 0.016, 0.016)) * bufB[5] + mat4(vec4(0.350, 0.088, 0.177, 0.170), vec4(-0.032, 0.031, 0.123, -0.009), vec4(0.196, 0.203, -0.180, 0.332), vec4(0.150, 0.087, 0.270, 0.199)) * bufB[6] + mat4(vec4(-0.037, 0.172, 0.285, 0.094), vec4(0.013, -0.096, 0.084, 0.219), vec4(0.061, 0.089, 0.113, 0.202), vec4(-0.068, -0.015, 0.008, -0.147)) * bufB[7] + mat4(vec4(0.052, 0.027, 0.268, -0.301), vec4(-0.203, -0.266, 0.179, -0.123), vec4(-0.025, -0.230, 0.260, -0.044), vec4(-0.066, -0.017, -0.166, 0.041)) * bufB[8] + mat4(vec4(0.020, 0.064, 0.025, -0.095), vec4(0.006, -0.213, -0.188, -0.254), vec4(-0.188, -0.395, -0.165, 0.121), vec4(-0.017, -0.083, 0.119, -0.264)) * bufB[9];\nbufA[2] = vec4(-0.307, 0.091, 0.321, 0.416) + mat4(vec4(-0.138, -0.073, -0.035, -0.140), vec4(0.176, -0.124, 0.060, 0.125), vec4(0.276, -0.201, 0.150, 0.139), vec4(-0.035, 0.334, 0.080, -0.127)) * bufB[0] + mat4(vec4(-0.113, -0.052, -0.082, 0.085), vec4(0.050, 0.206, -0.318, -0.018), vec4(0.032, -0.283, -0.076, -0.072), vec4(0.151, 0.080, -0.285, -0.097)) * bufB[1] + mat4(vec4(0.104, 0.160, 0.252, -0.117), vec4(0.069, -0.138, 0.234, -0.208), vec4(-0.077, 0.113, -0.087, -0.023), vec4(0.158, 0.212, -0.236, 0.099)) * bufB[2] + mat4(vec4(0.063, -0.162, 0.120, 0.046), vec4(-0.255, 0.239, -0.146, -0.209), vec4(0.092, -0.010, 0.110, 0.123), vec4(0.124, -0.197, 0.029, -0.099)) * bufB[3] + mat4(vec4(0.092, 0.010, 0.068, 0.280), vec4(-0.318, 0.045, -0.090, 0.202), vec4(-0.117, -0.022, 0.014, 0.110), vec4(-0.159, -0.136, 0.174, 0.049)) * bufB[4] + mat4(vec4(0.114, 0.085, 0.088, -0.125), vec4(0.388, -0.457, 0.042, -0.014), vec4(-0.075, -0.058, 0.259, -0.125), vec4(-0.354, -0.134, 0.054, 0.109)) * bufB[5] + mat4(vec4(0.257, -0.463, 0.149, 0.052), vec4(0.024, 0.094, -0.221, -0.123), vec4(0.386, 0.027, -0.222, -0.093), vec4(-0.039, -0.074, -0.040, -0.077)) * bufB[6] + mat4(vec4(0.129, 0.060, 0.042, 0.041), vec4(-0.227, 0.094, -0.111, 0.032), vec4(0.545, -0.021, 0.208, -0.171), vec4(-0.060, 0.025, -0.002, -0.163)) * bufB[7] + mat4(vec4(-0.035, -0.104, 0.353, -0.017), vec4(-0.501, -0.092, 0.261, -0.242), vec4(0.112, -0.304, 0.263, -0.116), vec4(-0.337, -0.312, 0.160, 0.127)) * bufB[8] + mat4(vec4(0.009, 0.123, -0.172, 0.125), vec4(0.148, 0.117, 0.401, -0.079), vec4(0.207, 0.037, -0.140, 0.273), vec4(0.025, -0.126, 0.016, -0.029)) * bufB[9];\nbufA[3] = vec4(-0.114, 0.076, -0.334, 0.308) + mat4(vec4(0.002, -0.092, 0.014, -0.113), vec4(0.174, 0.049, 0.128, -0.250), vec4(0.146, 0.072, 0.059, 0.129), vec4(0.059, 0.116, -0.136, -0.075)) * bufB[0] + mat4(vec4(0.053, 0.062, 0.095, 0.131), vec4(0.031, -0.072, 0.021, -0.117), vec4(-0.090, 0.125, -0.029, 0.109), vec4(0.093, -0.146, 0.105, -0.034)) * bufB[1] + mat4(vec4(-0.066, -0.096, -0.067, -0.002), vec4(0.274, 0.257, 0.175, -0.009), vec4(0.086, -0.327, -0.022, 0.043), vec4(0.020, 0.057, -0.040, 0.039)) * bufB[2] + mat4(vec4(-0.076, -0.022, 0.213, -0.060), vec4(0.009, 0.004, -0.072, -0.053), vec4(0.042, -0.139, 0.111, 0.010), vec4(0.021, -0.255, 0.204, 0.346)) * bufB[3] + mat4(vec4(0.043, 0.120, -0.052, -0.014), vec4(0.136, 0.032, -0.156, -0.157), vec4(-0.094, -0.056, -0.178, -0.294), vec4(-0.403, -0.034, 0.119, 0.154)) * bufB[4] + mat4(vec4(-0.046, -0.165, 0.126, 0.197), vec4(0.161, 0.170, -0.156, -0.065), vec4(-0.251, 0.184, 0.004, 0.196), vec4(-0.096, 0.098, 0.144, -0.065)) * bufB[5] + mat4(vec4(0.434, -0.096, -0.060, 0.053), vec4(-0.227, -0.021, 0.170, 0.012), vec4(0.004, -0.157, -0.108, 0.134), vec4(-0.058, -0.017, -0.020, -0.087)) * bufB[6] + mat4(vec4(0.069, 0.254, -0.164, -0.074), vec4(0.126, 0.200, -0.247, -0.138), vec4(0.006, -0.010, 0.090, -0.238), vec4(0.109, 0.111, 0.032, 0.105)) * bufB[7] + mat4(vec4(-0.132, 0.179, 0.119, -0.095), vec4(0.124, 0.077, -0.233, -0.267), vec4(-0.095, 0.078, -0.009, 0.174), vec4(0.306, -0.320, 0.154, -0.193)) * bufB[8] + mat4(vec4(0.040, -0.336, -0.152, 0.138), vec4(0.319, 0.052, -0.262, -0.177), vec4(0.130, -0.068, -0.021, 0.048), vec4(0.133, 0.170, 0.016, -0.044)) * bufB[9];\nbufA[4] = vec4(-0.033, -0.166, -0.180, 0.340) + mat4(vec4(0.030, 0.043, 0.111, -0.021), vec4(0.097, 0.056, -0.111, -0.108), vec4(0.380, 0.058, 0.013, 0.119), vec4(0.092, -0.105, -0.232, -0.036)) * bufB[0] + mat4(vec4(0.165, 0.022, -0.097, 0.129), vec4(-0.071, 0.039, -0.323, 0.140), vec4(0.143, 0.188, -0.060, -0.074), vec4(-0.109, 0.084, 0.187, -0.123)) * bufB[1] + mat4(vec4(0.042, -0.292, 0.158, -0.167), vec4(-0.055, 0.065, -0.053, 0.168), vec4(-0.036, -0.219, -0.258, -0.022), vec4(0.138, -0.117, -0.082, -0.058)) * bufB[2] + mat4(vec4(-0.094, -0.039, -0.199, -0.095), vec4(0.138, -0.266, 0.207, 0.054), vec4(0.090, 0.166, 0.007, 0.039), vec4(0.223, -0.041, -0.056, 0.008)) * bufB[3] + mat4(vec4(-0.069, -0.163, -0.088, -0.105), vec4(-0.081, 0.006, -0.150, -0.026), vec4(-0.009, 0.046, 0.095, -0.167), vec4(0.011, -0.009, 0.038, -0.095)) * bufB[4] + mat4(vec4(-0.233, 0.289, -0.062, -0.127), vec4(0.357, 0.025, -0.128, 0.171), vec4(0.141, -0.080, -0.126, 0.082), vec4(-0.048, -0.133, -0.330, 0.128)) * bufB[5] + mat4(vec4(-0.117, -0.099, 0.070, -0.226), vec4(0.336, 0.066, -0.321, 0.196), vec4(0.001, -0.184, -0.206, 0.154), vec4(0.361, 0.218, 0.120, -0.108)) * bufB[6] + mat4(vec4(0.143, 0.140, -0.028, -0.088), vec4(0.126, -0.082, 0.006, -0.017), vec4(0.104, 0.247, -0.222, 0.154), vec4(0.089, 0.067, 0.145, 0.106)) * bufB[7] + mat4(vec4(-0.018, -0.134, -0.224, 0.025), vec4(0.135, -0.096, 0.004, 0.276), vec4(0.031, -0.092, 0.022, 0.064), vec4(0.113, 0.037, 0.140, -0.053)) * bufB[8] + mat4(vec4(0.083, -0.130, -0.049, -0.064), vec4(0.098, -0.422, 0.086, 0.047), vec4(-0.368, 0.282, -0.229, -0.007), vec4(0.092, -0.033, 0.111, 0.142)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(0.326, 0.009, 0.427, 0.019) + mat4(vec4(0.123, -0.118, -0.167, -0.226), vec4(0.157, -0.317, -0.091, -0.108), vec4(0.253, 0.206, -0.259, -0.031), vec4(0.243, -0.278, 0.037, -0.115)) * bufB[0] + mat4(vec4(-0.133, 0.150, 0.037, -0.012), vec4(-0.229, 0.060, -0.150, 0.062), vec4(-0.025, 0.033, -0.095, 0.130), vec4(0.102, 0.059, -0.006, 0.082)) * bufB[1] + mat4(vec4(-0.028, -0.102, -0.007, 0.005), vec4(0.226, -0.045, -0.105, -0.260), vec4(0.120, -0.031, 0.246, -0.112), vec4(0.344, 0.263, -0.136, 0.025)) * bufB[2] + mat4(vec4(-0.242, 0.288, 0.241, -0.301), vec4(-0.127, 0.023, -0.154, -0.129), vec4(0.034, 0.218, 0.013, -0.016), vec4(0.020, 0.011, -0.133, 0.109)) * bufB[3] + mat4(vec4(0.042, 0.095, 0.189, 0.053), vec4(-0.069, 0.073, 0.084, -0.117), vec4(-0.001, 0.040, -0.002, -0.220), vec4(-0.099, 0.053, 0.140, -0.089)) * bufB[4] + mat4(vec4(-0.014, -0.060, 0.246, -0.048), vec4(-0.189, -0.115, 0.039, -0.163), vec4(0.138, 0.084, 0.053, -0.082), vec4(-0.026, 0.336, 0.091, -0.107)) * bufB[5] + mat4(vec4(0.163, -0.388, -0.043, -0.125), vec4(-0.263, 0.054, -0.011, 0.005), vec4(-0.141, -0.029, -0.061, -0.231), vec4(0.147, 0.083, -0.118, -0.156)) * bufB[6] + mat4(vec4(0.241, -0.197, 0.073, 0.138), vec4(0.287, 0.149, 0.055, 0.027), vec4(0.238, -0.157, 0.390, -0.153), vec4(0.003, 0.053, 0.136, -0.021)) * bufB[7] + mat4(vec4(0.075, -0.033, 0.106, -0.265), vec4(-0.011, 0.035, 0.092, 0.167), vec4(0.249, 0.315, 0.248, 0.026), vec4(-0.048, 0.086, 0.047, 0.036)) * bufB[8] + mat4(vec4(-0.296, -0.069, -0.034, -0.055), vec4(0.433, -0.018, 0.177, -0.117), vec4(0.105, -0.129, -0.016, -0.029), vec4(-0.023, -0.008, 0.038, -0.262)) * bufB[9];\nbufA[1] = vec4(-0.118, -0.369, 0.262, -0.424) + mat4(vec4(-0.125, -0.309, 0.231, -0.061), vec4(-0.135, -0.131, -0.121, -0.137), vec4(0.238, -0.024, 0.103, -0.019), vec4(-0.180, -0.080, -0.104, -0.213)) * bufB[0] + mat4(vec4(0.207, 0.245, 0.245, 0.088), vec4(0.036, 0.200, 0.001, -0.204), vec4(0.162, -0.121, -0.077, 0.046), vec4(0.159, -0.026, -0.197, 0.009)) * bufB[1] + mat4(vec4(-0.279, -0.045, -0.286, 0.204), vec4(-0.243, 0.340, -0.071, -0.028), vec4(0.217, -0.143, -0.223, 0.155), vec4(-0.144, 0.151, -0.088, -0.343)) * bufB[2] + mat4(vec4(-0.023, -0.309, -0.128, 0.121), vec4(-0.013, 0.041, 0.234, 0.187), vec4(0.186, 0.283, -0.317, 0.051), vec4(0.098, 0.251, 0.145, 0.007)) * bufB[3] + mat4(vec4(0.069, -0.130, 0.241, 0.226), vec4(-0.090, 0.110, -0.043, 0.134), vec4(-0.109, 0.035, -0.196, -0.207), vec4(-0.028, -0.064, 0.296, 0.197)) * bufB[4] + mat4(vec4(0.157, -0.110, 0.163, 0.080), vec4(-0.082, -0.163, 0.084, 0.055), vec4(-0.075, 0.267, 0.081, -0.030), vec4(-0.040, 0.138, -0.103, -0.068)) * bufB[5] + mat4(vec4(-0.148, 0.083, 0.054, 0.100), vec4(0.071, -0.167, 0.025, 0.058), vec4(0.005, -0.038, 0.125, 0.087), vec4(-0.226, -0.169, -0.188, 0.082)) * bufB[6] + mat4(vec4(-0.304, 0.078, -0.081, 0.064), vec4(-0.007, -0.067, -0.221, -0.031), vec4(0.089, 0.143, 0.033, 0.045), vec4(-0.469, 0.080, -0.134, 0.394)) * bufB[7] + mat4(vec4(0.138, 0.053, 0.026, -0.166), vec4(0.093, -0.331, -0.082, 0.048), vec4(-0.051, -0.088, -0.173, -0.068), vec4(0.116, 0.018, 0.182, -0.133)) * bufB[8] + mat4(vec4(-0.001, -0.258, -0.036, -0.085), vec4(-0.138, 0.074, 0.165, -0.012), vec4(-0.013, 0.045, 0.262, -0.005), vec4(-0.344, 0.016, -0.102, 0.168)) * bufB[9];\nbufA[2] = vec4(-0.246, -0.179, -0.479, -0.310) + mat4(vec4(-0.115, -0.103, -0.012, -0.002), vec4(-0.272, 0.016, -0.104, -0.111), vec4(0.232, -0.285, -0.063, 0.127), vec4(-0.113, 0.123, 0.014, 0.280)) * bufB[0] + mat4(vec4(-0.211, 0.243, -0.146, 0.071), vec4(0.001, 0.189, -0.131, -0.062), vec4(-0.140, -0.070, -0.082, -0.185), vec4(0.242, -0.001, 0.114, 0.040)) * bufB[1] + mat4(vec4(-0.088, 0.086, -0.083, -0.153), vec4(0.164, -0.043, 0.040, 0.175), vec4(-0.245, -0.055, 0.114, 0.002), vec4(0.027, -0.034, 0.167, -0.268)) * bufB[2] + mat4(vec4(0.052, 0.183, 0.225, 0.036), vec4(0.077, 0.100, -0.294, 0.089), vec4(0.145, 0.066, -0.070, -0.137), vec4(-0.006, 0.115, 0.030, 0.082)) * bufB[3] + mat4(vec4(-0.044, 0.072, 0.129, -0.116), vec4(0.143, -0.022, -0.396, 0.038), vec4(-0.020, 0.146, -0.090, 0.090), vec4(-0.147, 0.000, 0.074, -0.301)) * bufB[4] + mat4(vec4(-0.109, -0.045, 0.161, -0.076), vec4(0.134, -0.017, 0.173, -0.185), vec4(-0.046, -0.160, -0.100, -0.055), vec4(0.136, 0.143, 0.035, -0.027)) * bufB[5] + mat4(vec4(0.211, -0.337, -0.035, -0.067), vec4(-0.204, -0.230, -0.017, -0.114), vec4(0.103, -0.159, 0.057, 0.328), vec4(-0.237, -0.302, -0.112, -0.099)) * bufB[6] + mat4(vec4(-0.168, -0.475, -0.457, -0.008), vec4(-0.195, -0.187, 0.146, -0.095), vec4(-0.089, 0.055, 0.233, -0.073), vec4(-0.005, -0.174, -0.013, 0.054)) * bufB[7] + mat4(vec4(0.362, 0.014, 0.274, -0.005), vec4(-0.059, 0.040, 0.207, 0.139), vec4(-0.294, -0.144, 0.212, -0.046), vec4(-0.092, 0.092, -0.057, 0.026)) * bufB[8] + mat4(vec4(0.187, -0.308, 0.081, 0.123), vec4(0.186, 0.172, 0.133, 0.255), vec4(0.475, -0.291, -0.178, -0.201), vec4(-0.223, -0.081, -0.104, -0.086)) * bufB[9];\nbufA[3] = vec4(-0.050, -0.413, 0.175, -0.222) + mat4(vec4(-0.073, 0.115, 0.049, 0.048), vec4(-0.018, 0.109, -0.157, -0.241), vec4(0.500, 0.060, -0.058, 0.172), vec4(-0.052, 0.161, 0.047, -0.020)) * bufB[0] + mat4(vec4(0.089, 0.119, 0.122, 0.027), vec4(-0.197, -0.014, 0.043, -0.279), vec4(-0.094, 0.177, -0.208, 0.024), vec4(-0.059, -0.365, 0.318, 0.124)) * bufB[1] + mat4(vec4(0.034, -0.197, 0.101, 0.068), vec4(-0.377, 0.014, -0.047, -0.041), vec4(0.134, 0.190, -0.133, 0.219), vec4(-0.346, 0.091, -0.098, -0.113)) * bufB[2] + mat4(vec4(0.263, -0.000, -0.289, -0.149), vec4(0.057, 0.084, 0.079, 0.002), vec4(0.052, -0.048, -0.059, -0.111), vec4(0.069, 0.015, -0.063, -0.040)) * bufB[3] + mat4(vec4(0.103, 0.076, 0.042, -0.187), vec4(-0.112, -0.288, -0.083, 0.057), vec4(0.108, -0.046, 0.008, 0.095), vec4(0.295, 0.142, 0.047, -0.096)) * bufB[4] + mat4(vec4(0.052, 0.031, 0.113, -0.112), vec4(-0.034, -0.074, 0.275, 0.199), vec4(0.151, -0.148, 0.298, 0.074), vec4(-0.043, -0.282, 0.069, 0.055)) * bufB[5] + mat4(vec4(0.189, 0.091, -0.190, -0.122), vec4(0.178, -0.245, 0.051, -0.147), vec4(-0.123, 0.063, 0.091, 0.278), vec4(0.227, -0.177, 0.042, 0.109)) * bufB[6] + mat4(vec4(0.483, 0.187, -0.143, 0.093), vec4(0.192, 0.062, -0.027, -0.028), vec4(0.341, -0.150, 0.248, -0.109), vec4(-0.176, -0.098, 0.061, 0.189)) * bufB[7] + mat4(vec4(-0.117, 0.164, -0.044, 0.064), vec4(0.026, -0.024, 0.091, -0.194), vec4(-0.101, 0.019, -0.038, 0.089), vec4(0.245, -0.016, -0.096, 0.069)) * bufB[8] + mat4(vec4(-0.113, 0.075, 0.149, 0.357), vec4(-0.185, 0.008, -0.260, 0.159), vec4(0.064, 0.029, -0.127, 0.001), vec4(-0.030, 0.263, 0.266, 0.249)) * bufB[9];\nbufA[4] = vec4(-0.004, 0.184, -0.214, -0.227) + mat4(vec4(0.049, -0.080, 0.244, 0.314), vec4(0.018, -0.086, -0.035, -0.242), vec4(0.014, 0.165, -0.200, -0.012), vec4(0.119, -0.369, 0.027, 0.189)) * bufB[0] + mat4(vec4(0.042, -0.059, 0.006, 0.125), vec4(-0.143, -0.249, -0.168, 0.047), vec4(-0.053, -0.265, 0.115, 0.117), vec4(0.034, -0.158, -0.008, -0.204)) * bufB[1] + mat4(vec4(-0.188, -0.132, -0.235, 0.180), vec4(0.130, 0.002, -0.202, -0.227), vec4(-0.056, 0.169, 0.020, -0.130), vec4(0.081, -0.239, 0.150, -0.150)) * bufB[2] + mat4(vec4(0.130, 0.019, 0.360, -0.025), vec4(-0.128, 0.045, -0.251, -0.178), vec4(-0.158, -0.077, -0.050, 0.220), vec4(-0.025, -0.019, -0.028, 0.147)) * bufB[3] + mat4(vec4(0.003, -0.071, -0.125, -0.241), vec4(0.196, 0.142, -0.233, -0.207), vec4(-0.113, 0.000, 0.120, -0.049), vec4(0.278, 0.114, -0.249, 0.157)) * bufB[4] + mat4(vec4(-0.189, -0.071, -0.216, 0.040), vec4(-0.144, 0.113, 0.168, -0.038), vec4(0.036, -0.145, -0.106, 0.035), vec4(0.082, 0.082, 0.056, -0.004)) * bufB[5] + mat4(vec4(0.085, -0.169, -0.064, -0.168), vec4(-0.129, 0.044, 0.032, -0.103), vec4(-0.264, 0.216, 0.431, -0.192), vec4(-0.015, -0.283, -0.185, 0.162)) * bufB[6] + mat4(vec4(0.041, -0.214, 0.080, 0.171), vec4(-0.216, -0.056, 0.004, -0.163), vec4(-0.266, -0.323, -0.226, 0.076), vec4(-0.226, 0.110, 0.066, 0.057)) * bufB[7] + mat4(vec4(-0.159, -0.039, -0.023, -0.222), vec4(-0.194, 0.004, 0.223, 0.031), vec4(0.091, 0.022, 0.086, -0.156), vec4(-0.090, -0.087, 0.107, -0.205)) * bufB[8] + mat4(vec4(-0.039, 0.016, 0.019, 0.089), vec4(-0.047, -0.150, 0.202, -0.004), vec4(0.273, -0.050, -0.013, -0.193), vec4(0.229, -0.076, -0.013, -0.156)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(0.376, 0.238, -0.038, 0.220) + mat4(vec4(0.167, 0.043, -0.096, -0.151), vec4(-0.035, -0.023, 0.064, -0.026), vec4(-0.046, 0.166, 0.103, 0.082), vec4(0.101, -0.071, 0.045, 0.130)) * bufB[0] + mat4(vec4(0.238, 0.051, 0.063, 0.136), vec4(0.147, 0.028, 0.006, 0.005), vec4(0.128, -0.256, -0.290, -0.115), vec4(-0.173, -0.049, -0.265, 0.265)) * bufB[1] + mat4(vec4(0.006, -0.105, -0.157, -0.072), vec4(-0.039, 0.024, 0.119, 0.103), vec4(0.184, -0.153, 0.341, -0.262), vec4(-0.025, -0.169, -0.295, -0.091)) * bufB[2] + mat4(vec4(0.096, -0.218, 0.334, -0.070), vec4(0.264, 0.085, -0.221, 0.189), vec4(-0.010, 0.126, 0.222, 0.168), vec4(-0.197, 0.111, 0.321, 0.050)) * bufB[3] + mat4(vec4(0.094, 0.093, 0.041, -0.077), vec4(0.026, 0.009, -0.194, -0.242), vec4(0.162, 0.118, -0.205, -0.153), vec4(-0.147, 0.134, 0.100, 0.186)) * bufB[4] + mat4(vec4(0.183, 0.102, -0.155, 0.050), vec4(0.170, -0.033, 0.160, -0.086), vec4(0.108, 0.107, 0.202, -0.040), vec4(0.155, 0.139, 0.255, 0.255)) * bufB[5] + mat4(vec4(0.029, 0.091, 0.274, 0.144), vec4(0.377, 0.143, -0.045, 0.095), vec4(0.102, 0.247, 0.027, 0.060), vec4(0.246, -0.010, -0.106, 0.140)) * bufB[6] + mat4(vec4(-0.287, 0.018, -0.167, 0.007), vec4(-0.220, -0.213, 0.068, -0.108), vec4(0.142, 0.065, 0.124, 0.029), vec4(0.088, -0.313, 0.256, 0.167)) * bufB[7] + mat4(vec4(-0.007, -0.224, -0.303, -0.230), vec4(-0.211, 0.028, 0.375, -0.023), vec4(0.165, -0.153, -0.075, 0.071), vec4(-0.120, -0.011, -0.016, 0.121)) * bufB[8] + mat4(vec4(0.154, 0.050, 0.005, 0.115), vec4(-0.003, -0.219, 0.374, -0.029), vec4(0.084, 0.030, 0.125, 0.185), vec4(0.186, -0.128, 0.089, -0.268)) * bufB[9] + in0;\nbufA[1] = vec4(0.391, 0.414, -0.021, -0.364) + mat4(vec4(0.012, -0.116, 0.066, -0.006), vec4(-0.253, 0.112, -0.322, 0.296), vec4(-0.121, -0.049, 0.123, -0.019), vec4(-0.134, -0.277, 0.090, 0.152)) * bufB[0] + mat4(vec4(-0.088, 0.144, -0.024, 0.145), vec4(-0.097, -0.177, 0.084, 0.186), vec4(-0.075, 0.152, 0.143, -0.089), vec4(0.052, 0.166, -0.096, -0.043)) * bufB[1] + mat4(vec4(-0.035, 0.202, 0.290, 0.068), vec4(0.389, 0.052, -0.228, -0.202), vec4(0.161, -0.130, -0.196, 0.257), vec4(0.175, -0.044, 0.136, 0.078)) * bufB[2] + mat4(vec4(-0.033, -0.116, 0.156, 0.213), vec4(-0.037, -0.089, 0.137, -0.002), vec4(-0.008, -0.034, -0.256, 0.004), vec4(0.082, -0.064, -0.033, 0.189)) * bufB[3] + mat4(vec4(-0.045, 0.010, 0.228, -0.177), vec4(0.093, -0.144, 0.171, 0.003), vec4(-0.013, -0.243, 0.055, -0.116), vec4(0.071, 0.123, 0.073, -0.121)) * bufB[4] + mat4(vec4(0.203, 0.088, -0.101, 0.404), vec4(-0.036, 0.188, -0.069, 0.173), vec4(-0.057, -0.022, -0.258, 0.244), vec4(-0.254, -0.196, 0.041, 0.223)) * bufB[5] + mat4(vec4(-0.200, -0.186, 0.150, 0.047), vec4(0.448, -0.137, 0.089, 0.015), vec4(-0.024, -0.090, -0.265, 0.192), vec4(0.060, -0.025, -0.093, 0.033)) * bufB[6] + mat4(vec4(-0.033, -0.241, 0.013, 0.139), vec4(-0.098, -0.003, -0.077, -0.053), vec4(-0.120, -0.176, 0.042, 0.102), vec4(0.120, 0.049, -0.335, -0.250)) * bufB[7] + mat4(vec4(-0.059, 0.064, 0.239, -0.134), vec4(0.188, 0.012, -0.082, -0.181), vec4(0.096, 0.076, -0.289, -0.146), vec4(0.432, -0.030, -0.231, -0.009)) * bufB[8] + mat4(vec4(-0.043, 0.189, 0.019, -0.187), vec4(-0.074, -0.112, -0.002, 0.104), vec4(0.193, 0.153, 0.041, 0.084), vec4(-0.311, 0.236, 0.208, 0.083)) * bufB[9] + in1;\nbufA[2] = vec4(-0.403, 0.025, -0.309, 0.152) + mat4(vec4(-0.127, 0.178, 0.017, -0.111), vec4(0.135, 0.051, 0.175, 0.016), vec4(-0.123, 0.008, -0.034, -0.003), vec4(0.102, 0.053, -0.090, -0.155)) * bufB[0] + mat4(vec4(0.252, 0.069, -0.114, 0.056), vec4(-0.088, -0.035, -0.043, 0.058), vec4(-0.139, -0.104, -0.151, -0.014), vec4(0.175, 0.344, -0.188, -0.054)) * bufB[1] + mat4(vec4(-0.224, -0.353, 0.050, 0.145), vec4(0.269, -0.241, 0.018, 0.057), vec4(0.134, -0.116, -0.048, 0.165), vec4(0.254, -0.112, 0.217, -0.243)) * bufB[2] + mat4(vec4(0.042, 0.118, 0.084, -0.050), vec4(0.173, -0.016, -0.173, -0.140), vec4(-0.066, -0.151, -0.434, -0.259), vec4(-0.134, 0.285, -0.073, 0.083)) * bufB[3] + mat4(vec4(0.145, 0.428, 0.158, 0.179), vec4(0.204, -0.086, 0.058, 0.072), vec4(0.136, 0.164, -0.042, -0.154), vec4(0.151, 0.013, 0.086, -0.208)) * bufB[4] + mat4(vec4(0.061, -0.306, -0.207, -0.073), vec4(0.237, 0.002, 0.082, -0.019), vec4(0.008, -0.104, -0.252, -0.292), vec4(-0.056, 0.134, -0.355, 0.079)) * bufB[5] + mat4(vec4(-0.059, 0.041, -0.162, 0.099), vec4(-0.105, -0.170, 0.002, 0.216), vec4(0.090, -0.165, -0.018, 0.260), vec4(0.053, 0.082, -0.112, -0.098)) * bufB[6] + mat4(vec4(0.011, 0.213, -0.277, -0.259), vec4(-0.017, 0.074, 0.016, -0.181), vec4(0.137, -0.277, 0.202, 0.161), vec4(-0.025, 0.133, -0.203, -0.095)) * bufB[7] + mat4(vec4(0.145, 0.133, -0.117, -0.203), vec4(-0.234, 0.254, -0.065, -0.228), vec4(-0.229, 0.080, 0.212, 0.004), vec4(-0.224, 0.157, 0.116, 0.011)) * bufB[8] + mat4(vec4(0.136, -0.204, 0.039, 0.316), vec4(0.154, 0.003, -0.370, 0.187), vec4(0.022, -0.171, 0.110, -0.098), vec4(-0.096, 0.130, 0.038, 0.178)) * bufB[9] + in2;\nbufA[3] = vec4(-0.142, -0.401, 0.150, -0.355) + mat4(vec4(-0.048, -0.046, -0.076, -0.133), vec4(-0.068, 0.007, 0.243, 0.098), vec4(0.069, 0.147, 0.019, -0.113), vec4(0.058, 0.004, -0.280, -0.293)) * bufB[0] + mat4(vec4(0.104, 0.166, 0.126, 0.162), vec4(0.100, -0.031, -0.150, -0.085), vec4(0.166, 0.070, 0.222, -0.166), vec4(0.052, 0.012, 0.394, 0.012)) * bufB[1] + mat4(vec4(-0.120, -0.304, 0.070, 0.005), vec4(-0.072, 0.345, -0.212, -0.013), vec4(0.179, -0.045, 0.118, 0.024), vec4(-0.010, -0.201, -0.023, -0.119)) * bufB[2] + mat4(vec4(-0.154, -0.065, 0.368, -0.275), vec4(0.150, -0.109, 0.151, -0.045), vec4(0.083, -0.033, -0.155, -0.096), vec4(-0.111, -0.050, -0.051, -0.146)) * bufB[3] + mat4(vec4(-0.113, 0.023, -0.030, -0.047), vec4(-0.165, -0.188, -0.169, 0.013), vec4(0.035, -0.284, 0.188, -0.156), vec4(-0.168, -0.035, 0.212, 0.140)) * bufB[4] + mat4(vec4(0.014, -0.018, 0.287, 0.112), vec4(0.025, -0.174, 0.085, 0.062), vec4(0.152, -0.080, -0.034, -0.221), vec4(0.211, 0.257, 0.105, -0.122)) * bufB[5] + mat4(vec4(-0.144, 0.039, 0.220, 0.088), vec4(0.145, -0.259, 0.145, -0.457), vec4(-0.010, 0.201, 0.103, -0.099), vec4(0.174, -0.309, -0.253, -0.180)) * bufB[6] + mat4(vec4(-0.095, 0.117, -0.185, 0.198), vec4(0.208, 0.125, 0.050, -0.077), vec4(0.161, 0.171, 0.093, -0.017), vec4(0.136, 0.180, 0.075, 0.530)) * bufB[7] + mat4(vec4(0.083, -0.045, 0.039, -0.059), vec4(-0.427, 0.186, -0.144, 0.096), vec4(-0.045, 0.035, 0.150, 0.154), vec4(0.079, 0.414, 0.068, 0.204)) * bufB[8] + mat4(vec4(-0.106, 0.047, 0.224, -0.098), vec4(-0.070, 0.106, 0.202, -0.077), vec4(0.207, -0.000, 0.021, 0.008), vec4(0.050, -0.023, -0.038, -0.048)) * bufB[9] + in3;\nbufA[4] = vec4(-0.293, 0.406, 0.210, -0.439) + mat4(vec4(0.207, -0.036, 0.163, 0.009), vec4(0.130, 0.203, -0.259, 0.020), vec4(0.107, 0.074, -0.082, 0.065), vec4(-0.098, -0.112, 0.084, -0.067)) * bufB[0] + mat4(vec4(0.158, 0.039, -0.202, -0.061), vec4(-0.086, -0.207, -0.074, 0.012), vec4(0.136, -0.212, 0.163, -0.099), vec4(-0.228, 0.090, 0.012, 0.258)) * bufB[1] + mat4(vec4(0.006, -0.044, 0.076, -0.071), vec4(-0.229, -0.100, -0.208, -0.226), vec4(0.055, -0.049, 0.293, 0.164), vec4(0.053, 0.330, -0.066, 0.160)) * bufB[2] + mat4(vec4(0.087, -0.095, 0.109, -0.089), vec4(0.241, -0.116, -0.123, -0.193), vec4(-0.126, 0.097, 0.157, 0.051), vec4(0.103, 0.142, -0.136, 0.046)) * bufB[3] + mat4(vec4(-0.197, 0.126, 0.098, -0.193), vec4(0.124, 0.208, -0.025, -0.286), vec4(-0.031, 0.141, -0.203, -0.241), vec4(0.042, -0.100, 0.020, 0.043)) * bufB[4] + mat4(vec4(0.151, 0.035, 0.424, 0.104), vec4(-0.022, -0.053, 0.248, -0.020), vec4(-0.294, 0.032, 0.077, 0.068), vec4(0.196, -0.234, -0.200, 0.143)) * bufB[5] + mat4(vec4(0.175, -0.155, 0.126, 0.250), vec4(-0.022, 0.059, -0.104, 0.337), vec4(-0.103, 0.069, 0.148, 0.058), vec4(0.281, 0.208, 0.137, -0.230)) * bufB[6] + mat4(vec4(0.246, 0.143, -0.040, 0.067), vec4(-0.081, 0.106, 0.001, -0.066), vec4(-0.282, -0.051, 0.126, -0.056), vec4(-0.069, -0.130, 0.108, 0.154)) * bufB[7] + mat4(vec4(0.468, -0.174, 0.331, -0.101), vec4(0.338, 0.019, -0.063, 0.183), vec4(0.002, 0.036, -0.084, 0.045), vec4(0.309, -0.240, 0.044, -0.103)) * bufB[8] + mat4(vec4(-0.319, 0.449, 0.051, 0.060), vec4(-0.069, -0.027, -0.095, -0.096), vec4(-0.012, -0.036, 0.008, -0.303), vec4(-0.040, -0.050, 0.118, -0.074)) * bufB[9] + in0;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(0.616, -0.261, 0.183, 0.132) + mat4(vec4(0.018, -0.112, -0.016, 0.021), vec4(0.005, 0.014, 0.079, -0.182), vec4(-0.158, 0.406, -0.031, -0.112), vec4(0.156, 0.099, 0.103, 0.075)) * bufB[0] + mat4(vec4(0.257, -0.086, 0.082, -0.162), vec4(0.055, -0.110, -0.050, 0.073), vec4(0.179, -0.208, -0.091, 0.123), vec4(0.165, 0.014, -0.111, -0.078)) * bufB[1] + mat4(vec4(-0.124, -0.110, -0.150, 0.016), vec4(-0.036, 0.232, -0.193, 0.000), vec4(0.042, -0.068, -0.384, 0.048), vec4(0.114, -0.105, -0.162, 0.221)) * bufB[2] + mat4(vec4(-0.165, 0.156, 0.190, 0.102), vec4(-0.088, 0.002, 0.183, 0.048), vec4(-0.191, 0.126, -0.111, 0.173), vec4(-0.151, 0.005, 0.026, -0.047)) * bufB[3] + mat4(vec4(-0.147, -0.328, 0.226, 0.347), vec4(-0.022, -0.148, -0.007, -0.270), vec4(0.214, -0.062, 0.080, 0.173), vec4(-0.317, 0.121, 0.080, -0.120)) * bufB[4] + mat4(vec4(0.072, 0.159, -0.113, 0.052), vec4(-0.050, 0.194, 0.037, 0.223), vec4(0.132, -0.032, -0.336, 0.022), vec4(-0.009, -0.020, 0.066, 0.284)) * bufB[5] + mat4(vec4(-0.275, 0.269, 0.039, -0.205), vec4(-0.307, -0.026, 0.141, -0.088), vec4(-0.304, 0.045, -0.138, 0.242), vec4(-0.143, 0.211, 0.192, 0.124)) * bufB[6] + mat4(vec4(-0.149, -0.213, -0.096, 0.048), vec4(0.048, 0.169, 0.100, -0.213), vec4(-0.302, -0.036, -0.115, 0.015), vec4(-0.097, 0.123, -0.106, 0.172)) * bufB[7] + mat4(vec4(-0.231, -0.077, -0.056, -0.092), vec4(-0.131, -0.184, -0.162, -0.026), vec4(0.170, -0.114, -0.006, -0.151), vec4(-0.023, 0.292, -0.190, 0.058)) * bufB[8] + mat4(vec4(-0.135, 0.263, 0.334, 0.142), vec4(-0.155, -0.058, 0.104, 0.431), vec4(0.155, -0.043, 0.057, 0.004), vec4(-0.186, -0.129, -0.155, -0.068)) * bufB[9];\nbufA[1] = vec4(0.417, -0.263, -0.325, -0.014) + mat4(vec4(0.175, 0.294, -0.291, 0.064), vec4(0.240, 0.055, -0.101, -0.083), vec4(-0.165, 0.088, -0.198, -0.026), vec4(0.061, 0.205, -0.030, 0.140)) * bufB[0] + mat4(vec4(0.034, 0.121, 0.171, -0.009), vec4(-0.107, 0.031, -0.016, 0.305), vec4(0.101, 0.026, -0.176, -0.121), vec4(-0.052, -0.134, -0.167, -0.051)) * bufB[1] + mat4(vec4(-0.246, -0.162, -0.025, 0.169), vec4(-0.008, -0.360, -0.160, -0.059), vec4(0.113, 0.162, 0.046, -0.399), vec4(0.194, 0.197, -0.194, 0.134)) * bufB[2] + mat4(vec4(-0.198, -0.140, -0.060, 0.505), vec4(-0.223, 0.142, -0.031, 0.053), vec4(-0.113, -0.285, -0.064, 0.036), vec4(0.051, 0.206, -0.159, 0.087)) * bufB[3] + mat4(vec4(0.431, 0.138, 0.150, 0.167), vec4(0.304, -0.163, 0.209, 0.396), vec4(-0.077, -0.142, -0.120, 0.006), vec4(0.001, -0.128, -0.127, -0.034)) * bufB[4] + mat4(vec4(-0.024, -0.376, 0.016, 0.330), vec4(-0.349, -0.050, -0.245, -0.088), vec4(0.095, -0.081, -0.300, -0.207), vec4(-0.238, 0.271, 0.170, -0.018)) * bufB[5] + mat4(vec4(0.137, 0.326, 0.309, -0.157), vec4(-0.373, 0.036, -0.143, 0.026), vec4(0.167, 0.086, 0.056, -0.278), vec4(-0.226, -0.129, 0.250, -0.111)) * bufB[6] + mat4(vec4(0.035, 0.033, -0.018, -0.164), vec4(0.256, -0.322, 0.016, 0.104), vec4(-0.258, 0.209, 0.211, 0.067), vec4(0.090, 0.040, -0.038, -0.050)) * bufB[7] + mat4(vec4(0.061, -0.453, -0.158, -0.132), vec4(0.151, 0.306, -0.098, 0.031), vec4(0.090, 0.001, 0.067, 0.138), vec4(-0.028, 0.019, -0.159, 0.224)) * bufB[8] + mat4(vec4(0.056, -0.218, 0.275, 0.246), vec4(0.032, -0.085, 0.149, 0.092), vec4(-0.200, -0.018, -0.143, 0.258), vec4(0.449, 0.303, -0.151, 0.104)) * bufB[9];\nbufA[2] = vec4(0.326, -0.120, 0.323, 0.361) + mat4(vec4(0.014, 0.106, 0.131, 0.175), vec4(0.015, 0.101, 0.101, 0.018), vec4(-0.140, 0.106, -0.185, -0.228), vec4(-0.111, -0.078, -0.037, -0.032)) * bufB[0] + mat4(vec4(-0.131, 0.283, -0.123, -0.039), vec4(0.082, 0.093, -0.153, 0.002), vec4(0.173, -0.089, 0.070, -0.130), vec4(0.106, 0.059, 0.114, 0.115)) * bufB[1] + mat4(vec4(-0.185, 0.109, -0.152, 0.168), vec4(-0.031, -0.096, -0.062, -0.018), vec4(0.108, -0.039, 0.129, 0.268), vec4(0.176, -0.169, -0.181, 0.134)) * bufB[2] + mat4(vec4(0.265, -0.118, 0.153, 0.033), vec4(-0.028, -0.033, 0.038, 0.045), vec4(0.131, -0.143, -0.110, 0.274), vec4(-0.234, 0.046, 0.203, 0.204)) * bufB[3] + mat4(vec4(0.068, 0.072, 0.340, -0.234), vec4(0.312, 0.098, 0.124, 0.147), vec4(-0.041, 0.156, 0.120, 0.052), vec4(-0.234, -0.007, -0.028, 0.171)) * bufB[4] + mat4(vec4(-0.030, 0.192, -0.004, -0.117), vec4(0.172, -0.178, -0.043, 0.204), vec4(-0.012, -0.168, 0.275, 0.001), vec4(0.028, -0.235, 0.086, -0.001)) * bufB[5] + mat4(vec4(-0.023, 0.176, -0.260, 0.107), vec4(0.085, -0.091, 0.029, 0.125), vec4(0.200, -0.138, -0.024, -0.185), vec4(0.079, 0.160, 0.044, -0.069)) * bufB[6] + mat4(vec4(-0.174, -0.180, 0.040, -0.173), vec4(-0.254, 0.045, -0.160, -0.112), vec4(-0.150, -0.033, -0.122, 0.308), vec4(-0.100, -0.033, -0.050, 0.253)) * bufB[7] + mat4(vec4(-0.142, -0.029, -0.137, 0.241), vec4(0.030, 0.148, -0.032, -0.033), vec4(-0.163, 0.080, 0.296, 0.058), vec4(-0.028, 0.043, 0.186, -0.046)) * bufB[8] + mat4(vec4(-0.005, 0.150, -0.340, 0.279), vec4(0.068, 0.034, 0.045, 0.176), vec4(0.027, -0.191, 0.015, -0.168), vec4(-0.317, 0.035, -0.053, 0.419)) * bufB[9];\nbufA[3] = vec4(0.037, 0.463, 0.272, 0.433) + mat4(vec4(-0.169, -0.013, -0.055, -0.284), vec4(0.138, 0.213, 0.070, -0.090), vec4(0.055, 0.064, 0.155, 0.057), vec4(0.270, -0.078, -0.031, 0.089)) * bufB[0] + mat4(vec4(0.253, -0.211, 0.165, 0.391), vec4(0.308, -0.128, -0.032, -0.197), vec4(0.163, 0.027, 0.443, -0.037), vec4(-0.116, 0.021, -0.028, 0.079)) * bufB[1] + mat4(vec4(0.261, 0.035, 0.089, -0.152), vec4(0.028, 0.399, -0.096, 0.079), vec4(0.140, -0.080, -0.044, -0.348), vec4(0.170, -0.155, -0.302, 0.065)) * bufB[2] + mat4(vec4(-0.070, -0.481, -0.118, -0.040), vec4(0.110, -0.034, -0.116, 0.076), vec4(0.066, -0.381, -0.119, -0.188), vec4(-0.123, -0.038, -0.058, 0.171)) * bufB[3] + mat4(vec4(-0.111, -0.012, -0.150, -0.029), vec4(0.094, 0.022, 0.270, -0.140), vec4(-0.019, 0.044, 0.005, -0.104), vec4(-0.277, -0.252, -0.254, -0.100)) * bufB[4] + mat4(vec4(-0.136, 0.114, -0.137, -0.078), vec4(0.054, -0.306, 0.038, -0.064), vec4(0.006, 0.003, 0.066, 0.458), vec4(-0.253, 0.278, -0.230, 0.142)) * bufB[5] + mat4(vec4(-0.099, 0.363, 0.007, 0.165), vec4(-0.322, -0.234, -0.145, 0.072), vec4(-0.125, 0.158, 0.043, 0.079), vec4(0.095, 0.250, -0.120, -0.195)) * bufB[6] + mat4(vec4(0.143, -0.169, -0.202, 0.142), vec4(-0.045, -0.126, 0.458, 0.085), vec4(-0.187, 0.208, 0.127, 0.060), vec4(0.306, 0.134, 0.010, -0.100)) * bufB[7] + mat4(vec4(-0.012, 0.113, -0.244, -0.048), vec4(-0.247, 0.050, -0.028, 0.315), vec4(0.177, 0.109, -0.169, 0.174), vec4(-0.029, 0.003, -0.054, -0.065)) * bufB[8] + mat4(vec4(0.222, -0.206, 0.122, -0.088), vec4(-0.186, 0.006, 0.195, 0.221), vec4(-0.198, -0.077, -0.029, 0.159), vec4(-0.118, 0.033, -0.039, -0.009)) * bufB[9];\nbufA[4] = vec4(-0.348, 0.400, 0.275, 0.083) + mat4(vec4(0.055, -0.018, -0.228, -0.022), vec4(0.240, 0.074, -0.361, 0.338), vec4(0.370, 0.269, 0.319, -0.166), vec4(0.066, 0.195, -0.032, 0.038)) * bufB[0] + mat4(vec4(0.007, 0.235, -0.347, 0.023), vec4(0.086, 0.171, -0.160, -0.031), vec4(-0.029, 0.078, 0.073, 0.115), vec4(-0.183, -0.219, 0.028, -0.360)) * bufB[1] + mat4(vec4(-0.036, -0.323, -0.306, -0.127), vec4(0.180, 0.132, -0.064, 0.138), vec4(0.010, 0.008, -0.137, 0.067), vec4(-0.129, -0.089, 0.252, -0.116)) * bufB[2] + mat4(vec4(-0.072, 0.203, 0.058, 0.018), vec4(0.086, 0.244, -0.220, 0.139), vec4(0.350, -0.071, -0.109, -0.295), vec4(-0.035, 0.060, -0.264, -0.150)) * bufB[3] + mat4(vec4(-0.239, -0.075, -0.250, 0.101), vec4(0.206, -0.058, 0.158, -0.081), vec4(0.034, 0.199, 0.157, 0.277), vec4(-0.155, -0.010, 0.132, -0.128)) * bufB[4] + mat4(vec4(0.002, 0.270, -0.103, -0.158), vec4(0.089, -0.171, -0.007, 0.014), vec4(0.011, -0.165, 0.076, 0.059), vec4(0.011, 0.162, 0.154, 0.209)) * bufB[5] + mat4(vec4(-0.029, 0.265, -0.155, -0.177), vec4(0.006, -0.032, 0.059, 0.221), vec4(0.089, 0.152, -0.071, -0.008), vec4(0.024, -0.101, -0.199, 0.298)) * bufB[6] + mat4(vec4(0.019, 0.181, -0.008, 0.032), vec4(0.364, -0.064, -0.047, -0.104), vec4(0.089, -0.457, -0.205, 0.289), vec4(-0.057, 0.460, 0.097, 0.131)) * bufB[7] + mat4(vec4(-0.010, 0.071, -0.116, 0.114), vec4(-0.310, -0.082, -0.011, 0.133), vec4(-0.075, -0.390, 0.091, 0.211), vec4(0.013, 0.185, -0.064, 0.099)) * bufB[8] + mat4(vec4(0.114, 0.443, 0.023, 0.157), vec4(-0.280, -0.046, 0.061, -0.275), vec4(-0.228, 0.270, -0.002, 0.060), vec4(-0.504, -0.026, -0.019, -0.198)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(0.133, 0.544, 0.372, -0.106) + mat4(vec4(-0.155, -0.025, 0.157, 0.115), vec4(-0.039, 0.010, 0.129, 0.143), vec4(0.043, -0.224, -0.094, 0.073), vec4(-0.017, -0.007, 0.166, -0.058)) * bufB[0] + mat4(vec4(0.201, 0.178, 0.243, 0.051), vec4(-0.175, 0.074, -0.320, -0.202), vec4(0.037, -0.060, -0.107, -0.059), vec4(-0.303, 0.184, -0.199, 0.135)) * bufB[1] + mat4(vec4(0.169, 0.118, -0.025, 0.181), vec4(-0.184, 0.244, 0.078, 0.068), vec4(0.141, -0.140, -0.062, -0.238), vec4(0.267, -0.094, 0.237, 0.297)) * bufB[2] + mat4(vec4(0.143, 0.072, -0.038, -0.136), vec4(0.107, -0.093, -0.074, -0.130), vec4(-0.303, 0.073, 0.106, -0.061), vec4(0.124, 0.113, -0.195, -0.042)) * bufB[3] + mat4(vec4(-0.220, 0.061, 0.215, -0.147), vec4(-0.250, -0.080, 0.375, 0.443), vec4(-0.077, 0.002, 0.134, 0.048), vec4(0.156, -0.152, -0.172, 0.060)) * bufB[4] + mat4(vec4(0.109, -0.080, -0.124, 0.076), vec4(0.171, 0.140, -0.123, -0.041), vec4(0.152, 0.070, -0.283, 0.028), vec4(-0.342, -0.102, -0.027, 0.031)) * bufB[5] + mat4(vec4(0.163, 0.225, 0.003, 0.186), vec4(0.049, -0.240, -0.019, 0.080), vec4(0.140, -0.022, -0.480, -0.054), vec4(-0.025, -0.240, 0.167, -0.164)) * bufB[6] + mat4(vec4(0.275, -0.361, -0.127, 0.010), vec4(0.209, 0.076, -0.113, 0.080), vec4(-0.140, 0.178, -0.036, 0.036), vec4(-0.136, -0.018, -0.308, -0.000)) * bufB[7] + mat4(vec4(0.048, -0.175, 0.101, 0.082), vec4(-0.068, -0.228, -0.097, -0.096), vec4(-0.277, 0.186, 0.175, -0.019), vec4(-0.369, 0.289, -0.106, -0.233)) * bufB[8] + mat4(vec4(-0.167, -0.299, -0.071, -0.149), vec4(0.036, -0.155, 0.154, -0.210), vec4(-0.127, -0.139, -0.073, -0.042), vec4(0.005, 0.088, 0.151, -0.056)) * bufB[9];\nbufA[1] = vec4(0.385, 0.417, -0.114, 0.511) + mat4(vec4(0.070, -0.193, 0.222, 0.124), vec4(0.200, -0.219, 0.016, -0.168), vec4(0.148, 0.185, 0.159, 0.149), vec4(0.226, -0.132, -0.090, 0.357)) * bufB[0] + mat4(vec4(0.146, -0.097, -0.044, 0.103), vec4(-0.134, 0.154, 0.366, 0.157), vec4(0.143, 0.316, 0.008, 0.083), vec4(-0.147, 0.060, 0.076, -0.067)) * bufB[1] + mat4(vec4(-0.129, 0.002, 0.207, 0.045), vec4(-0.094, -0.073, 0.000, -0.068), vec4(0.102, -0.308, 0.247, 0.185), vec4(-0.485, 0.226, -0.304, 0.131)) * bufB[2] + mat4(vec4(0.192, -0.181, -0.265, -0.101), vec4(0.178, -0.303, -0.261, 0.363), vec4(0.068, 0.022, 0.047, 0.271), vec4(0.006, -0.080, -0.176, 0.003)) * bufB[3] + mat4(vec4(0.179, 0.150, -0.051, -0.335), vec4(-0.080, 0.115, -0.142, -0.033), vec4(0.123, 0.364, 0.134, -0.000), vec4(0.080, 0.301, -0.070, 0.040)) * bufB[4] + mat4(vec4(0.140, -0.203, 0.173, -0.228), vec4(0.095, 0.176, -0.155, 0.203), vec4(-0.128, 0.153, 0.071, 0.048), vec4(-0.103, 0.093, 0.136, -0.248)) * bufB[5] + mat4(vec4(-0.059, 0.156, 0.001, 0.315), vec4(0.200, -0.121, -0.129, -0.156), vec4(0.145, -0.009, 0.139, 0.116), vec4(-0.272, 0.072, -0.268, 0.134)) * bufB[6] + mat4(vec4(-0.103, -0.316, -0.057, 0.266), vec4(-0.114, -0.057, -0.063, 0.258), vec4(0.278, 0.162, -0.156, -0.055), vec4(0.130, -0.039, -0.181, -0.067)) * bufB[7] + mat4(vec4(0.030, -0.130, 0.070, -0.269), vec4(-0.085, 0.090, -0.035, 0.482), vec4(-0.033, 0.024, 0.267, -0.031), vec4(0.026, 0.046, -0.014, -0.205)) * bufB[8] + mat4(vec4(0.114, 0.510, 0.178, 0.031), vec4(-0.023, -0.146, -0.144, -0.136), vec4(-0.086, 0.067, 0.131, -0.017), vec4(0.213, 0.237, -0.020, 0.351)) * bufB[9];\nbufA[2] = vec4(-0.074, -0.471, -0.421, 0.146) + mat4(vec4(-0.176, 0.036, 0.041, -0.235), vec4(-0.004, -0.142, -0.033, 0.059), vec4(-0.040, -0.051, 0.331, -0.247), vec4(-0.047, -0.085, 0.245, -0.008)) * bufB[0] + mat4(vec4(0.211, -0.056, -0.024, 0.077), vec4(0.093, 0.203, -0.041, -0.078), vec4(0.252, 0.149, -0.024, -0.153), vec4(-0.034, -0.037, -0.287, -0.160)) * bufB[1] + mat4(vec4(-0.339, -0.032, 0.112, 0.059), vec4(0.008, 0.187, 0.120, -0.066), vec4(0.249, -0.028, 0.275, -0.030), vec4(0.016, 0.044, -0.166, 0.088)) * bufB[2] + mat4(vec4(-0.130, -0.204, 0.083, 0.093), vec4(-0.028, -0.041, -0.098, -0.040), vec4(-0.191, 0.213, 0.137, 0.206), vec4(0.231, 0.301, 0.037, -0.206)) * bufB[3] + mat4(vec4(0.135, 0.137, -0.095, 0.156), vec4(-0.056, -0.027, -0.002, 0.266), vec4(-0.080, -0.073, -0.028, 0.037), vec4(-0.215, -0.126, 0.192, -0.088)) * bufB[4] + mat4(vec4(0.114, -0.369, 0.060, -0.292), vec4(-0.107, 0.050, -0.084, -0.160), vec4(0.064, 0.035, 0.052, 0.076), vec4(-0.186, -0.394, -0.037, -0.260)) * bufB[5] + mat4(vec4(-0.029, -0.251, -0.170, 0.224), vec4(0.360, 0.044, 0.052, 0.080), vec4(0.008, 0.023, 0.081, 0.105), vec4(-0.036, 0.104, 0.005, -0.128)) * bufB[6] + mat4(vec4(0.058, 0.073, -0.091, -0.033), vec4(-0.121, 0.127, -0.220, -0.258), vec4(0.046, -0.209, -0.010, -0.215), vec4(0.347, -0.217, 0.409, -0.170)) * bufB[7] + mat4(vec4(-0.240, 0.079, -0.009, 0.170), vec4(0.098, -0.051, 0.119, 0.089), vec4(0.097, 0.019, 0.034, 0.250), vec4(0.060, -0.016, -0.253, -0.263)) * bufB[8] + mat4(vec4(0.091, 0.264, -0.036, 0.050), vec4(0.050, -0.191, -0.181, -0.147), vec4(-0.001, 0.118, -0.215, 0.075), vec4(-0.168, -0.043, 0.032, 0.017)) * bufB[9];\nbufA[3] = vec4(-0.120, -0.333, 0.463, 0.353) + mat4(vec4(-0.158, 0.017, 0.253, -0.118), vec4(-0.087, 0.100, 0.168, 0.091), vec4(-0.109, 0.202, 0.581, 0.292), vec4(-0.019, -0.203, -0.178, -0.087)) * bufB[0] + mat4(vec4(-0.270, -0.241, -0.186, 0.066), vec4(0.058, 0.074, 0.090, 0.021), vec4(-0.039, -0.053, -0.134, -0.234), vec4(0.279, 0.160, 0.158, -0.240)) * bufB[1] + mat4(vec4(0.174, -0.181, 0.022, -0.084), vec4(-0.106, -0.077, -0.094, -0.203), vec4(-0.319, 0.188, -0.036, 0.156), vec4(0.262, 0.135, -0.123, -0.360)) * bufB[2] + mat4(vec4(0.270, 0.206, 0.196, -0.249), vec4(0.099, -0.391, -0.150, 0.162), vec4(0.004, -0.126, -0.122, -0.181), vec4(-0.005, 0.120, 0.360, 0.270)) * bufB[3] + mat4(vec4(-0.195, 0.145, 0.041, 0.135), vec4(0.107, 0.028, 0.261, 0.089), vec4(0.200, -0.089, -0.013, 0.082), vec4(-0.128, -0.106, 0.348, 0.018)) * bufB[4] + mat4(vec4(0.004, 0.029, 0.089, -0.132), vec4(-0.247, -0.024, -0.027, 0.215), vec4(0.226, 0.030, -0.021, 0.016), vec4(0.325, 0.207, -0.253, 0.185)) * bufB[5] + mat4(vec4(-0.328, 0.279, 0.006, -0.007), vec4(0.037, 0.067, 0.213, -0.072), vec4(-0.215, 0.220, 0.247, 0.099), vec4(0.203, -0.103, 0.090, -0.090)) * bufB[6] + mat4(vec4(0.141, -0.137, 0.142, 0.062), vec4(-0.083, -0.257, -0.154, 0.012), vec4(-0.201, -0.019, -0.096, 0.240), vec4(-0.141, -0.045, -0.075, 0.001)) * bufB[7] + mat4(vec4(0.025, -0.122, 0.035, -0.300), vec4(0.224, -0.118, -0.408, 0.046), vec4(-0.189, 0.091, -0.030, 0.053), vec4(-0.200, 0.074, -0.140, 0.128)) * bufB[8] + mat4(vec4(-0.118, 0.526, -0.138, 0.016), vec4(-0.219, -0.145, 0.337, -0.169), vec4(0.187, -0.083, -0.213, 0.043), vec4(-0.082, -0.005, 0.124, -0.090)) * bufB[9];\nbufA[4] = vec4(0.216, 0.214, -0.251, -0.377) + mat4(vec4(-0.040, -0.273, -0.153, -0.178), vec4(0.172, 0.011, 0.307, 0.136), vec4(-0.086, -0.073, -0.126, -0.247), vec4(-0.200, 0.048, -0.033, 0.221)) * bufB[0] + mat4(vec4(-0.022, 0.112, -0.067, -0.042), vec4(-0.112, -0.212, 0.154, -0.175), vec4(-0.104, 0.312, -0.179, -0.035), vec4(-0.234, -0.373, 0.014, -0.072)) * bufB[1] + mat4(vec4(-0.092, -0.058, 0.278, 0.366), vec4(-0.178, 0.070, 0.130, 0.092), vec4(-0.069, -0.127, 0.281, 0.062), vec4(-0.259, 0.148, -0.417, -0.438)) * bufB[2] + mat4(vec4(0.084, -0.014, 0.007, -0.516), vec4(-0.210, 0.080, -0.216, 0.095), vec4(-0.082, -0.298, -0.082, 0.160), vec4(0.048, 0.153, 0.277, -0.162)) * bufB[3] + mat4(vec4(-0.233, -0.067, -0.009, -0.153), vec4(-0.090, 0.018, -0.082, 0.031), vec4(0.455, -0.106, 0.079, -0.131), vec4(-0.176, -0.055, -0.069, -0.037)) * bufB[4] + mat4(vec4(0.053, -0.100, -0.074, -0.094), vec4(-0.029, -0.236, 0.014, 0.001), vec4(-0.152, 0.171, -0.361, 0.033), vec4(0.190, -0.032, 0.405, 0.126)) * bufB[5] + mat4(vec4(-0.089, 0.145, 0.179, 0.187), vec4(0.012, -0.025, 0.089, 0.110), vec4(0.002, 0.176, -0.064, 0.170), vec4(-0.208, -0.063, 0.076, -0.358)) * bufB[6] + mat4(vec4(-0.280, 0.094, -0.102, -0.008), vec4(-0.166, 0.273, -0.084, 0.092), vec4(0.311, -0.182, 0.069, 0.101), vec4(-0.034, -0.029, 0.136, 0.166)) * bufB[7] + mat4(vec4(0.345, -0.139, -0.062, -0.188), vec4(-0.268, -0.148, -0.198, 0.007), vec4(0.126, -0.047, -0.337, 0.103), vec4(0.183, 0.061, -0.115, 0.070)) * bufB[8] + mat4(vec4(0.077, -0.065, -0.130, -0.166), vec4(0.083, 0.010, 0.003, -0.395), vec4(-0.125, -0.100, 0.226, -0.016), vec4(0.017, -0.197, -0.074, 0.092)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(0.114, -0.333, 0.580, 0.424) + mat4(vec4(0.008, -0.249, -0.029, 0.411), vec4(-0.060, 0.053, 0.128, 0.068), vec4(-0.342, -0.106, 0.096, -0.210), vec4(-0.277, -0.187, -0.149, 0.090)) * bufB[0] + mat4(vec4(0.109, -0.309, 0.272, 0.168), vec4(0.015, 0.046, 0.331, -0.122), vec4(-0.011, 0.064, 0.067, 0.097), vec4(-0.194, -0.045, -0.192, 0.039)) * bufB[1] + mat4(vec4(-0.087, -0.006, -0.047, -0.134), vec4(0.176, -0.015, -0.150, 0.064), vec4(0.090, 0.031, 0.038, -0.066), vec4(-0.079, -0.061, 0.072, 0.013)) * bufB[2] + mat4(vec4(-0.239, 0.005, -0.168, 0.103), vec4(0.381, 0.024, 0.057, -0.253), vec4(-0.185, 0.131, 0.402, 0.274), vec4(-0.110, -0.051, 0.163, 0.228)) * bufB[3] + mat4(vec4(0.140, -0.049, 0.059, -0.204), vec4(0.208, -0.092, 0.104, 0.082), vec4(-0.093, 0.008, -0.108, 0.060), vec4(-0.070, -0.294, -0.258, -0.287)) * bufB[4] + mat4(vec4(-0.079, -0.210, -0.070, 0.411), vec4(0.155, 0.008, -0.210, 0.264), vec4(-0.301, 0.027, -0.103, 0.356), vec4(0.122, 0.238, -0.069, 0.010)) * bufB[5] + mat4(vec4(0.307, -0.062, -0.016, -0.050), vec4(-0.095, 0.128, -0.000, 0.017), vec4(0.066, 0.165, 0.110, 0.067), vec4(-0.011, 0.049, 0.056, 0.188)) * bufB[6] + mat4(vec4(-0.068, -0.139, 0.125, 0.239), vec4(-0.238, 0.097, 0.158, -0.033), vec4(0.129, -0.035, -0.239, -0.022), vec4(0.076, -0.232, -0.171, -0.125)) * bufB[7] + mat4(vec4(0.152, 0.229, -0.004, -0.077), vec4(-0.159, 0.010, 0.145, -0.026), vec4(-0.291, -0.179, 0.052, -0.277), vec4(-0.047, 0.208, -0.254, -0.286)) * bufB[8] + mat4(vec4(-0.298, -0.133, -0.193, -0.063), vec4(0.055, -0.127, -0.053, -0.355), vec4(-0.079, 0.124, 0.320, -0.232), vec4(-0.079, -0.019, 0.009, 0.029)) * bufB[9];\nbufA[1] = vec4(0.222, 0.252, 0.103, 0.159) + mat4(vec4(-0.030, 0.264, 0.152, -0.116), vec4(-0.117, 0.478, 0.290, 0.132), vec4(-0.192, -0.087, 0.287, 0.005), vec4(0.142, -0.304, 0.269, -0.071)) * bufB[0] + mat4(vec4(-0.125, -0.044, -0.173, -0.014), vec4(0.182, 0.284, 0.046, 0.267), vec4(0.056, 0.229, -0.186, 0.123), vec4(0.041, -0.017, -0.176, -0.075)) * bufB[1] + mat4(vec4(-0.387, -0.160, -0.212, 0.292), vec4(-0.325, 0.109, 0.115, -0.060), vec4(0.108, 0.358, -0.173, -0.028), vec4(0.091, 0.124, 0.268, 0.122)) * bufB[2] + mat4(vec4(0.158, -0.198, 0.175, 0.273), vec4(0.097, 0.008, 0.172, -0.167), vec4(-0.014, -0.083, 0.263, -0.044), vec4(-0.019, 0.109, 0.113, -0.057)) * bufB[3] + mat4(vec4(-0.122, -0.045, -0.226, 0.199), vec4(0.075, -0.186, 0.421, -0.182), vec4(-0.065, -0.226, -0.419, 0.115), vec4(0.066, -0.131, 0.095, 0.120)) * bufB[4] + mat4(vec4(-0.103, -0.106, 0.401, -0.126), vec4(-0.242, 0.028, 0.020, 0.139), vec4(-0.113, 0.040, 0.154, -0.331), vec4(0.064, -0.278, 0.186, -0.218)) * bufB[5] + mat4(vec4(-0.159, -0.077, -0.084, 0.264), vec4(-0.155, -0.059, -0.019, 0.050), vec4(0.038, -0.060, -0.011, 0.119), vec4(-0.092, 0.054, 0.144, 0.065)) * bufB[6] + mat4(vec4(0.026, -0.412, 0.153, -0.164), vec4(-0.006, 0.017, -0.132, -0.075), vec4(-0.265, -0.293, -0.026, 0.485), vec4(-0.060, 0.088, -0.070, 0.009)) * bufB[7] + mat4(vec4(-0.209, -0.061, -0.151, 0.237), vec4(0.001, -0.048, 0.152, -0.037), vec4(0.129, -0.012, 0.260, 0.004), vec4(0.198, 0.230, 0.414, 0.058)) * bufB[8] + mat4(vec4(-0.136, -0.178, 0.394, 0.069), vec4(-0.122, 0.077, 0.319, -0.350), vec4(0.296, 0.165, -0.218, -0.244), vec4(0.128, 0.224, -0.246, -0.328)) * bufB[9];\nbufA[2] = vec4(-0.202, -0.349, -0.535, 0.222) + mat4(vec4(-0.069, 0.223, 0.006, -0.037), vec4(0.035, 0.205, -0.102, -0.267), vec4(0.122, 0.131, -0.218, 0.080), vec4(0.097, -0.099, -0.299, -0.176)) * bufB[0] + mat4(vec4(-0.153, -0.234, -0.156, -0.143), vec4(0.160, 0.053, 0.526, 0.103), vec4(0.027, 0.126, 0.181, -0.097), vec4(0.078, -0.116, -0.112, 0.565)) * bufB[1] + mat4(vec4(-0.312, -0.165, -0.006, 0.121), vec4(0.107, -0.139, 0.342, -0.325), vec4(0.172, -0.135, -0.133, -0.323), vec4(0.087, 0.128, -0.084, -0.396)) * bufB[2] + mat4(vec4(0.243, -0.136, -0.069, 0.077), vec4(0.114, 0.014, -0.018, 0.156), vec4(-0.038, 0.233, -0.303, -0.066), vec4(-0.227, -0.063, 0.005, -0.177)) * bufB[3] + mat4(vec4(0.332, 0.157, 0.128, -0.065), vec4(-0.394, 0.002, -0.040, 0.367), vec4(0.089, -0.111, 0.066, -0.090), vec4(-0.202, -0.103, 0.021, 0.283)) * bufB[4] + mat4(vec4(-0.057, 0.010, 0.048, 0.113), vec4(0.040, -0.112, 0.002, 0.051), vec4(0.299, -0.097, -0.020, -0.345), vec4(0.400, -0.172, -0.156, -0.313)) * bufB[5] + mat4(vec4(0.199, 0.232, 0.080, -0.001), vec4(0.186, -0.179, 0.131, -0.156), vec4(-0.012, 0.374, 0.013, 0.053), vec4(-0.148, -0.174, 0.122, 0.511)) * bufB[6] + mat4(vec4(0.137, 0.117, 0.257, 0.047), vec4(0.081, 0.057, -0.188, 0.071), vec4(0.054, -0.165, -0.192, -0.236), vec4(-0.154, -0.086, 0.206, 0.116)) * bufB[7] + mat4(vec4(0.138, -0.106, -0.012, 0.052), vec4(0.070, -0.012, 0.036, 0.297), vec4(0.202, 0.081, 0.194, -0.023), vec4(-0.031, -0.152, 0.155, 0.023)) * bufB[8] + mat4(vec4(-0.078, 0.053, 0.024, -0.063), vec4(-0.097, -0.018, 0.097, -0.217), vec4(-0.266, -0.059, 0.053, 0.031), vec4(0.229, 0.501, -0.237, -0.066)) * bufB[9];\nbufA[3] = vec4(-0.159, 0.405, 0.383, -0.061) + mat4(vec4(-0.175, -0.192, -0.032, -0.171), vec4(0.362, -0.085, 0.306, 0.069), vec4(-0.220, 0.263, 0.075, 0.194), vec4(-0.040, -0.154, 0.065, -0.141)) * bufB[0] + mat4(vec4(0.144, -0.194, 0.146, 0.266), vec4(0.059, 0.056, -0.158, 0.412), vec4(0.053, -0.209, 0.049, 0.040), vec4(0.163, 0.147, 0.090, -0.068)) * bufB[1] + mat4(vec4(0.068, 0.070, -0.121, 0.127), vec4(-0.253, 0.094, -0.188, -0.058), vec4(-0.068, 0.148, 0.186, 0.054), vec4(-0.113, 0.019, 0.158, -0.346)) * bufB[2] + mat4(vec4(0.047, -0.272, -0.108, -0.005), vec4(-0.076, 0.257, 0.007, 0.026), vec4(0.215, 0.239, -0.149, 0.232), vec4(0.151, -0.091, 0.034, 0.002)) * bufB[3] + mat4(vec4(0.120, 0.179, 0.177, -0.163), vec4(-0.289, -0.147, -0.183, -0.243), vec4(0.013, 0.248, -0.045, -0.081), vec4(0.106, -0.142, -0.178, -0.050)) * bufB[4] + mat4(vec4(-0.302, -0.132, -0.095, -0.159), vec4(-0.092, 0.088, 0.225, 0.025), vec4(-0.303, 0.152, -0.079, 0.110), vec4(-0.123, 0.090, 0.402, 0.038)) * bufB[5] + mat4(vec4(0.247, -0.167, 0.073, 0.364), vec4(-0.074, 0.313, 0.019, 0.389), vec4(-0.107, -0.050, 0.043, -0.199), vec4(0.197, -0.203, -0.097, 0.010)) * bufB[6] + mat4(vec4(-0.172, -0.043, 0.037, 0.348), vec4(-0.150, 0.076, 0.127, -0.113), vec4(0.033, -0.246, -0.094, 0.029), vec4(0.081, 0.048, -0.024, 0.102)) * bufB[7] + mat4(vec4(0.259, -0.075, -0.027, 0.477), vec4(0.030, -0.214, 0.093, -0.250), vec4(-0.347, -0.023, -0.170, -0.056), vec4(-0.075, -0.017, 0.086, 0.197)) * bufB[8] + mat4(vec4(-0.052, 0.056, -0.241, 0.289), vec4(-0.092, 0.097, -0.101, -0.089), vec4(-0.123, -0.041, -0.149, -0.371), vec4(0.060, 0.328, 0.046, -0.168)) * bufB[9];\nbufA[4] = vec4(-0.236, -0.139, 0.150, 0.083) + mat4(vec4(-0.028, 0.007, -0.029, -0.102), vec4(0.212, 0.166, 0.141, 0.080), vec4(-0.217, -0.031, -0.078, -0.269), vec4(0.010, -0.095, -0.040, -0.001)) * bufB[0] + mat4(vec4(0.143, 0.065, -0.109, 0.245), vec4(-0.104, 0.066, 0.082, -0.107), vec4(-0.268, 0.252, 0.080, 0.007), vec4(-0.037, 0.007, -0.191, -0.009)) * bufB[1] + mat4(vec4(0.157, -0.118, 0.039, 0.063), vec4(0.100, 0.007, -0.140, 0.145), vec4(0.020, -0.068, 0.027, 0.165), vec4(-0.029, 0.119, 0.186, 0.111)) * bufB[2] + mat4(vec4(0.333, -0.092, 0.125, -0.037), vec4(0.191, 0.201, 0.228, 0.074), vec4(-0.113, 0.006, 0.080, 0.172), vec4(-0.270, -0.087, 0.046, -0.303)) * bufB[3] + mat4(vec4(0.011, 0.196, -0.021, -0.085), vec4(0.067, -0.110, -0.107, -0.099), vec4(0.041, 0.015, -0.005, -0.046), vec4(0.016, 0.010, -0.010, 0.138)) * bufB[4] + mat4(vec4(0.179, 0.020, -0.064, -0.084), vec4(-0.342, 0.325, 0.079, 0.033), vec4(0.173, -0.305, -0.151, 0.008), vec4(0.304, 0.312, 0.003, -0.134)) * bufB[5] + mat4(vec4(-0.073, 0.023, -0.039, -0.073), vec4(-0.276, 0.064, -0.047, 0.188), vec4(0.120, -0.145, 0.190, 0.313), vec4(-0.218, 0.098, 0.119, 0.172)) * bufB[6] + mat4(vec4(0.002, -0.037, -0.278, 0.267), vec4(0.432, 0.067, -0.232, 0.020), vec4(0.089, -0.006, -0.210, -0.160), vec4(0.109, 0.046, 0.174, -0.303)) * bufB[7] + mat4(vec4(-0.053, 0.130, 0.117, 0.098), vec4(-0.206, -0.238, -0.214, -0.390), vec4(0.126, 0.185, 0.275, -0.300), vec4(0.111, -0.314, -0.033, -0.116)) * bufB[8] + mat4(vec4(-0.390, -0.102, 0.059, 0.214), vec4(-0.231, 0.110, -0.313, 0.462), vec4(-0.073, -0.169, 0.108, 0.204), vec4(-0.003, -0.051, -0.205, -0.112)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(0.409, -0.318, 0.344, -0.045) + mat4(vec4(0.019, -0.131, -0.547, -0.131), vec4(0.155, -0.168, -0.212, -0.202), vec4(0.281, 0.031, 0.107, 0.148), vec4(0.070, 0.107, 0.085, 0.039)) * bufB[0] + mat4(vec4(-0.256, -0.084, 0.264, 0.015), vec4(-0.075, -0.373, -0.117, 0.070), vec4(-0.115, -0.028, 0.496, 0.298), vec4(-0.008, -0.178, -0.112, -0.094)) * bufB[1] + mat4(vec4(-0.273, 0.025, 0.168, -0.083), vec4(-0.138, -0.146, 0.063, 0.174), vec4(-0.014, 0.034, -0.373, -0.062), vec4(0.274, 0.017, 0.064, -0.035)) * bufB[2] + mat4(vec4(0.053, -0.094, -0.232, -0.073), vec4(0.105, 0.118, 0.087, 0.192), vec4(-0.009, -0.248, -0.226, 0.118), vec4(0.457, 0.126, 0.177, 0.181)) * bufB[3] + mat4(vec4(0.103, 0.163, -0.285, -0.009), vec4(-0.160, -0.058, 0.180, 0.022), vec4(-0.429, 0.261, 0.024, 0.291), vec4(0.049, -0.144, -0.187, -0.209)) * bufB[4] + mat4(vec4(-0.124, -0.236, -0.061, -0.405), vec4(-0.092, -0.144, 0.068, -0.026), vec4(0.233, -0.071, 0.211, 0.051), vec4(0.263, 0.076, 0.131, 0.192)) * bufB[5] + mat4(vec4(-0.161, -0.160, -0.147, 0.250), vec4(0.112, -0.011, -0.137, 0.045), vec4(-0.147, -0.161, 0.192, -0.063), vec4(-0.118, -0.109, 0.320, -0.261)) * bufB[6] + mat4(vec4(0.094, 0.174, 0.569, -0.166), vec4(0.048, -0.124, 0.186, 0.064), vec4(-0.243, 0.005, 0.014, -0.136), vec4(-0.060, 0.106, -0.374, -0.006)) * bufB[7] + mat4(vec4(0.212, 0.224, -0.164, -0.198), vec4(-0.213, 0.013, 0.244, -0.241), vec4(-0.065, 0.161, -0.173, 0.063), vec4(0.257, 0.099, 0.150, 0.012)) * bufB[8] + mat4(vec4(0.113, 0.052, -0.181, 0.154), vec4(-0.212, 0.088, -0.177, -0.076), vec4(-0.267, 0.071, 0.103, -0.194), vec4(0.106, -0.004, 0.309, 0.186)) * bufB[9];\nbufA[1] = vec4(0.259, -0.560, -0.461, 0.228) + mat4(vec4(-0.070, 0.238, 0.308, 0.153), vec4(0.292, -0.017, -0.047, 0.113), vec4(-0.050, 0.176, -0.386, 0.089), vec4(0.137, 0.142, 0.320, 0.044)) * bufB[0] + mat4(vec4(-0.002, -0.281, -0.028, -0.252), vec4(0.110, -0.183, -0.094, -0.195), vec4(-0.001, -0.213, -0.402, -0.240), vec4(0.226, -0.030, -0.003, 0.427)) * bufB[1] + mat4(vec4(-0.125, -0.224, 0.058, 0.139), vec4(-0.147, -0.166, -0.007, -0.064), vec4(-0.070, 0.112, 0.089, -0.390), vec4(-0.266, 0.102, -0.381, 0.332)) * bufB[2] + mat4(vec4(0.024, 0.142, -0.005, 0.155), vec4(0.355, -0.112, -0.017, -0.006), vec4(0.125, 0.184, 0.162, 0.357), vec4(-0.151, -0.129, -0.175, 0.308)) * bufB[3] + mat4(vec4(-0.087, 0.018, -0.138, -0.007), vec4(-0.150, -0.084, -0.122, -0.067), vec4(-0.248, -0.190, -0.196, -0.154), vec4(0.048, 0.165, 0.198, 0.046)) * bufB[4] + mat4(vec4(-0.001, -0.201, -0.072, -0.198), vec4(-0.115, -0.096, -0.085, -0.417), vec4(0.100, -0.173, 0.090, -0.126), vec4(0.093, -0.109, 0.343, 0.224)) * bufB[5] + mat4(vec4(-0.422, -0.228, 0.032, -0.071), vec4(-0.162, -0.044, 0.293, 0.195), vec4(0.078, -0.102, -0.017, -0.334), vec4(-0.125, 0.140, -0.003, -0.435)) * bufB[6] + mat4(vec4(0.166, 0.133, -0.048, -0.215), vec4(-0.019, -0.161, 0.122, -0.254), vec4(0.260, -0.006, -0.044, -0.177), vec4(-0.289, -0.083, -0.176, 0.006)) * bufB[7] + mat4(vec4(-0.092, 0.039, 0.303, 0.514), vec4(-0.091, -0.173, 0.006, -0.097), vec4(0.118, 0.235, -0.006, -0.563), vec4(0.111, 0.341, 0.028, 0.271)) * bufB[8] + mat4(vec4(0.047, -0.125, 0.078, 0.222), vec4(-0.280, 0.078, -0.061, -0.082), vec4(-0.176, 0.040, 0.005, -0.073), vec4(0.050, -0.156, 0.112, 0.011)) * bufB[9];\nbufA[2] = vec4(0.230, -0.004, -0.213, 0.018) + mat4(vec4(-0.195, -0.047, -0.237, 0.192), vec4(0.075, -0.043, -0.289, -0.028), vec4(-0.168, 0.110, 0.056, 0.254), vec4(-0.000, 0.119, -0.075, 0.099)) * bufB[0] + mat4(vec4(-0.274, 0.221, -0.213, 0.143), vec4(-0.093, -0.015, -0.305, -0.379), vec4(0.160, 0.034, -0.026, -0.237), vec4(0.080, 0.048, 0.147, -0.157)) * bufB[1] + mat4(vec4(0.170, 0.052, 0.094, 0.089), vec4(-0.327, -0.301, -0.028, 0.191), vec4(0.443, -0.112, 0.053, -0.037), vec4(-0.169, 0.034, -0.373, 0.005)) * bufB[2] + mat4(vec4(-0.072, -0.042, -0.106, -0.008), vec4(0.034, 0.065, -0.040, 0.230), vec4(0.180, -0.045, 0.255, 0.119), vec4(0.269, 0.015, 0.300, -0.059)) * bufB[3] + mat4(vec4(0.083, 0.114, -0.048, -0.110), vec4(-0.069, 0.241, 0.240, -0.120), vec4(0.065, -0.095, -0.085, -0.222), vec4(-0.120, 0.105, 0.010, -0.063)) * bufB[4] + mat4(vec4(-0.150, 0.024, -0.110, 0.059), vec4(0.004, 0.148, 0.348, 0.021), vec4(-0.057, -0.096, -0.489, 0.169), vec4(0.030, 0.024, 0.018, 0.231)) * bufB[5] + mat4(vec4(0.206, 0.189, 0.084, -0.177), vec4(0.048, 0.129, 0.581, 0.248), vec4(-0.070, -0.181, -0.034, 0.023), vec4(0.111, 0.047, -0.029, -0.313)) * bufB[6] + mat4(vec4(-0.191, 0.045, 0.189, -0.201), vec4(-0.038, -0.197, -0.118, 0.144), vec4(0.314, -0.127, 0.018, -0.219), vec4(-0.120, 0.112, 0.043, 0.195)) * bufB[7] + mat4(vec4(-0.082, -0.329, 0.250, -0.193), vec4(-0.126, -0.088, 0.161, -0.065), vec4(-0.130, 0.254, -0.144, -0.074), vec4(0.231, 0.178, -0.210, 0.014)) * bufB[8] + mat4(vec4(-0.205, -0.090, -0.164, 0.091), vec4(0.044, 0.158, -0.320, 0.236), vec4(-0.343, -0.149, -0.175, -0.182), vec4(0.006, 0.076, -0.183, -0.111)) * bufB[9];\nbufA[3] = vec4(0.162, 0.141, -0.217, -0.081) + mat4(vec4(0.033, 0.150, 0.294, -0.276), vec4(-0.259, -0.174, -0.107, -0.267), vec4(-0.103, 0.090, 0.025, -0.028), vec4(-0.142, -0.217, 0.141, -0.317)) * bufB[0] + mat4(vec4(0.131, 0.037, -0.031, 0.165), vec4(-0.077, 0.007, -0.077, -0.248), vec4(-0.182, -0.070, 0.171, 0.037), vec4(-0.035, 0.472, -0.278, -0.015)) * bufB[1] + mat4(vec4(-0.005, -0.104, 0.103, 0.190), vec4(-0.198, 0.141, -0.008, 0.153), vec4(0.216, 0.076, 0.274, 0.129), vec4(0.076, 0.268, -0.009, -0.277)) * bufB[2] + mat4(vec4(-0.266, -0.303, 0.104, -0.052), vec4(-0.048, 0.287, -0.034, 0.285), vec4(0.049, -0.210, -0.038, -0.160), vec4(0.142, 0.102, -0.158, 0.307)) * bufB[3] + mat4(vec4(-0.140, -0.076, 0.189, -0.000), vec4(-0.305, 0.456, 0.148, 0.384), vec4(0.020, -0.079, 0.212, 0.307), vec4(0.052, 0.015, -0.073, 0.021)) * bufB[4] + mat4(vec4(0.031, -0.307, -0.030, -0.019), vec4(-0.204, -0.256, 0.154, -0.004), vec4(-0.035, -0.336, -0.200, 0.159), vec4(0.068, -0.116, -0.066, -0.278)) * bufB[5] + mat4(vec4(-0.194, -0.362, -0.038, -0.172), vec4(-0.171, 0.101, 0.362, -0.064), vec4(-0.114, -0.093, -0.232, -0.159), vec4(0.059, -0.008, 0.422, 0.029)) * bufB[6] + mat4(vec4(-0.048, -0.059, -0.174, 0.023), vec4(-0.016, 0.179, 0.341, -0.097), vec4(0.062, -0.340, 0.123, -0.283), vec4(-0.122, 0.041, -0.058, -0.195)) * bufB[7] + mat4(vec4(-0.099, 0.205, 0.050, -0.203), vec4(0.139, 0.030, -0.146, 0.030), vec4(-0.149, -0.093, 0.084, 0.037), vec4(-0.148, 0.288, -0.251, 0.135)) * bufB[8] + mat4(vec4(-0.073, -0.230, -0.125, -0.167), vec4(-0.136, 0.032, -0.110, -0.077), vec4(-0.143, -0.064, -0.164, 0.060), vec4(0.077, 0.064, -0.036, -0.302)) * bufB[9];\nbufA[4] = vec4(-0.249, -0.290, 0.083, -0.226) + mat4(vec4(0.026, -0.144, -0.064, 0.090), vec4(-0.129, 0.091, -0.003, -0.329), vec4(-0.114, -0.110, -0.428, 0.210), vec4(-0.168, -0.069, 0.184, 0.118)) * bufB[0] + mat4(vec4(-0.145, 0.175, 0.466, -0.124), vec4(0.124, 0.075, 0.156, -0.154), vec4(0.044, 0.030, 0.257, 0.139), vec4(-0.058, -0.105, -0.224, 0.060)) * bufB[1] + mat4(vec4(-0.032, -0.148, -0.113, 0.205), vec4(0.105, -0.124, 0.189, 0.112), vec4(-0.057, -0.022, 0.053, -0.097), vec4(0.050, -0.231, -0.305, 0.062)) * bufB[2] + mat4(vec4(0.197, 0.191, -0.266, -0.278), vec4(0.239, -0.263, 0.135, 0.018), vec4(-0.419, -0.253, -0.170, 0.166), vec4(-0.036, 0.095, -0.115, 0.124)) * bufB[3] + mat4(vec4(-0.257, 0.102, 0.034, 0.009), vec4(-0.199, 0.231, -0.011, 0.149), vec4(-0.198, 0.099, -0.203, -0.144), vec4(-0.467, 0.320, 0.184, 0.348)) * bufB[4] + mat4(vec4(0.114, 0.128, 0.246, -0.192), vec4(0.349, -0.055, 0.013, 0.006), vec4(0.164, 0.334, -0.054, -0.060), vec4(-0.092, 0.058, 0.101, 0.101)) * bufB[5] + mat4(vec4(-0.215, 0.211, 0.244, 0.131), vec4(-0.019, 0.003, 0.122, -0.268), vec4(-0.500, 0.153, -0.234, -0.056), vec4(-0.075, 0.169, -0.036, 0.034)) * bufB[6] + mat4(vec4(-0.279, 0.221, -0.039, -0.143), vec4(0.052, -0.006, 0.464, 0.071), vec4(0.088, -0.137, 0.114, 0.068), vec4(-0.014, -0.086, 0.012, -0.084)) * bufB[7] + mat4(vec4(-0.104, -0.225, -0.112, 0.194), vec4(0.157, 0.137, 0.152, -0.196), vec4(0.060, -0.327, 0.069, 0.225), vec4(-0.147, -0.050, -0.024, 0.141)) * bufB[8] + mat4(vec4(0.133, 0.055, 0.000, -0.142), vec4(-0.165, 0.093, 0.519, 0.127), vec4(0.042, 0.057, 0.065, -0.116), vec4(-0.036, -0.050, -0.020, 0.241)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(0.148, 0.232, -0.239, 0.157) + mat4(vec4(0.054, -0.004, -0.029, 0.181), vec4(-0.094, -0.350, 0.029, -0.334), vec4(-0.292, 0.024, 0.090, -0.194), vec4(0.324, 0.219, 0.210, -0.116)) * bufB[0] + mat4(vec4(0.313, -0.130, -0.149, 0.215), vec4(0.024, -0.144, 0.127, 0.241), vec4(-0.177, 0.336, -0.219, -0.043), vec4(-0.051, -0.276, 0.147, -0.005)) * bufB[1] + mat4(vec4(0.008, 0.072, 0.048, -0.087), vec4(-0.082, 0.143, -0.049, 0.104), vec4(-0.008, -0.279, -0.106, -0.370), vec4(-0.115, 0.186, -0.109, 0.060)) * bufB[2] + mat4(vec4(-0.027, 0.130, -0.117, 0.042), vec4(0.325, -0.357, 0.227, 0.158), vec4(-0.025, -0.059, 0.182, 0.126), vec4(-0.144, -0.349, -0.274, -0.084)) * bufB[3] + mat4(vec4(0.071, 0.078, -0.059, 0.046), vec4(0.005, 0.009, 0.094, 0.377), vec4(-0.201, 0.187, 0.119, 0.016), vec4(0.015, -0.212, -0.102, 0.252)) * bufB[4] + mat4(vec4(-0.043, 0.184, 0.048, 0.113), vec4(-0.048, -0.322, -0.199, -0.127), vec4(-0.439, 0.109, 0.235, 0.108), vec4(-0.004, -0.197, 0.557, -0.012)) * bufB[5] + mat4(vec4(-0.124, -0.036, -0.286, -0.033), vec4(0.150, 0.288, 0.134, 0.103), vec4(0.093, 0.177, 0.013, -0.202), vec4(-0.096, -0.181, 0.114, -0.015)) * bufB[6] + mat4(vec4(0.002, 0.003, -0.105, -0.036), vec4(-0.162, 0.166, 0.154, -0.004), vec4(-0.168, 0.022, 0.153, 0.081), vec4(0.235, -0.044, -0.032, -0.033)) * bufB[7] + mat4(vec4(-0.027, -0.285, 0.052, -0.186), vec4(-0.196, -0.380, 0.078, -0.151), vec4(0.012, 0.002, 0.226, -0.021), vec4(0.265, 0.148, -0.267, 0.184)) * bufB[8] + mat4(vec4(0.073, -0.468, -0.000, 0.001), vec4(0.238, 0.124, -0.057, 0.141), vec4(0.137, 0.158, -0.195, -0.095), vec4(0.316, -0.143, -0.122, -0.059)) * bufB[9];\nbufA[1] = vec4(-0.331, -0.321, -0.337, 0.006) + mat4(vec4(-0.146, -0.048, 0.203, 0.366), vec4(0.376, 0.248, -0.026, -0.061), vec4(0.025, 0.503, 0.012, -0.070), vec4(-0.086, 0.011, 0.269, -0.138)) * bufB[0] + mat4(vec4(-0.087, -0.228, -0.193, -0.003), vec4(-0.224, -0.262, 0.146, -0.058), vec4(-0.087, 0.076, -0.029, 0.023), vec4(-0.052, -0.053, -0.070, -0.038)) * bufB[1] + mat4(vec4(0.083, 0.032, 0.031, 0.352), vec4(-0.045, 0.049, 0.223, -0.024), vec4(0.369, 0.132, -0.040, -0.045), vec4(-0.198, 0.105, -0.182, 0.235)) * bufB[2] + mat4(vec4(-0.356, 0.163, -0.143, 0.204), vec4(0.145, -0.135, 0.073, 0.065), vec4(-0.082, -0.046, 0.097, 0.163), vec4(-0.441, -0.004, -0.347, -0.158)) * bufB[3] + mat4(vec4(-0.074, 0.104, -0.210, -0.196), vec4(-0.226, -0.097, 0.048, 0.243), vec4(-0.329, -0.021, -0.143, -0.624), vec4(0.042, -0.381, 0.073, 0.138)) * bufB[4] + mat4(vec4(0.026, -0.310, 0.269, 0.000), vec4(-0.623, -0.086, 0.114, 0.338), vec4(0.091, -0.179, 0.076, -0.003), vec4(0.182, -0.123, 0.183, 0.034)) * bufB[5] + mat4(vec4(0.322, -0.195, 0.088, 0.189), vec4(0.290, -0.056, -0.047, -0.250), vec4(0.256, -0.046, 0.072, -0.176), vec4(0.170, 0.104, 0.034, 0.152)) * bufB[6] + mat4(vec4(0.220, -0.076, 0.084, 0.051), vec4(0.136, -0.043, -0.257, -0.285), vec4(0.126, -0.083, 0.037, -0.066), vec4(0.007, 0.076, 0.087, 0.051)) * bufB[7] + mat4(vec4(0.294, 0.077, -0.268, 0.019), vec4(-0.098, 0.191, 0.075, -0.091), vec4(-0.522, 0.396, 0.097, -0.234), vec4(0.020, -0.311, 0.018, 0.334)) * bufB[8] + mat4(vec4(0.009, -0.099, 0.022, 0.198), vec4(-0.027, 0.001, 0.091, -0.042), vec4(0.086, 0.421, -0.200, -0.325), vec4(0.159, 0.069, 0.053, 0.027)) * bufB[9];\nbufA[2] = vec4(0.306, -0.060, -0.574, -0.087) + mat4(vec4(-0.520, 0.092, -0.224, 0.409), vec4(-0.331, -0.259, -0.153, -0.276), vec4(-0.545, 0.192, -0.005, 0.205), vec4(-0.286, 0.084, 0.003, -0.018)) * bufB[0] + mat4(vec4(0.073, 0.013, -0.060, 0.222), vec4(0.037, -0.262, 0.134, -0.135), vec4(-0.337, -0.222, 0.182, -0.386), vec4(-0.329, -0.144, 0.186, 0.056)) * bufB[1] + mat4(vec4(-0.212, 0.038, 0.062, -0.022), vec4(0.070, -0.068, 0.058, -0.183), vec4(0.119, 0.009, -0.139, 0.082), vec4(-0.138, 0.150, -0.046, 0.235)) * bufB[2] + mat4(vec4(0.136, 0.022, -0.184, -0.152), vec4(0.036, -0.072, -0.169, 0.025), vec4(0.104, -0.352, 0.030, -0.238), vec4(-0.266, -0.058, 0.170, -0.138)) * bufB[3] + mat4(vec4(0.112, 0.026, 0.202, 0.093), vec4(-0.069, -0.081, 0.059, -0.046), vec4(0.166, 0.058, -0.105, 0.119), vec4(0.118, -0.066, 0.010, -0.015)) * bufB[4] + mat4(vec4(0.044, 0.161, -0.024, 0.211), vec4(0.077, -0.138, -0.092, -0.399), vec4(-0.067, 0.029, -0.243, 0.217), vec4(-0.085, -0.411, 0.139, 0.158)) * bufB[5] + mat4(vec4(0.419, 0.196, -0.183, -0.068), vec4(0.162, 0.103, 0.135, 0.212), vec4(0.007, 0.179, -0.386, 0.184), vec4(0.009, -0.040, 0.147, -0.074)) * bufB[6] + mat4(vec4(-0.082, 0.209, 0.151, 0.069), vec4(0.384, -0.240, 0.187, -0.317), vec4(-0.082, 0.026, -0.055, -0.151), vec4(0.495, -0.137, -0.270, -0.074)) * bufB[7] + mat4(vec4(0.022, 0.097, 0.382, -0.085), vec4(0.073, -0.085, 0.143, 0.311), vec4(-0.163, 0.414, -0.004, -0.124), vec4(-0.158, 0.262, -0.117, 0.218)) * bufB[8] + mat4(vec4(-0.024, -0.049, -0.088, -0.029), vec4(0.445, 0.294, -0.377, 0.073), vec4(0.176, 0.178, 0.047, 0.324), vec4(0.099, -0.192, -0.187, -0.015)) * bufB[9];\nbufA[3] = vec4(-0.559, -0.296, 0.133, 0.038) + mat4(vec4(-0.057, -0.079, 0.118, 0.276), vec4(0.264, 0.230, -0.335, 0.294), vec4(-0.097, 0.393, 0.157, -0.001), vec4(0.045, -0.161, 0.289, -0.102)) * bufB[0] + mat4(vec4(-0.110, 0.092, 0.096, 0.012), vec4(-0.065, -0.188, -0.320, -0.112), vec4(0.104, -0.234, -0.106, -0.194), vec4(-0.107, 0.361, -0.469, 0.286)) * bufB[1] + mat4(vec4(-0.328, 0.231, 0.261, -0.124), vec4(-0.523, 0.204, 0.222, 0.008), vec4(0.169, -0.075, -0.011, -0.099), vec4(-0.026, 0.127, 0.012, 0.086)) * bufB[2] + mat4(vec4(-0.019, 0.061, 0.073, -0.104), vec4(0.046, -0.025, -0.174, -0.215), vec4(-0.139, -0.172, 0.115, 0.049), vec4(0.443, -0.412, -0.034, -0.252)) * bufB[3] + mat4(vec4(0.212, -0.128, 0.052, -0.235), vec4(0.361, 0.233, 0.203, 0.108), vec4(0.007, -0.287, 0.117, 0.209), vec4(-0.056, 0.004, -0.225, 0.188)) * bufB[4] + mat4(vec4(-0.245, -0.338, -0.118, 0.137), vec4(-0.039, -0.049, 0.459, 0.110), vec4(0.100, 0.372, 0.148, -0.044), vec4(0.060, 0.007, -0.368, -0.093)) * bufB[5] + mat4(vec4(-0.102, 0.079, 0.266, -0.007), vec4(-0.366, 0.111, 0.190, -0.241), vec4(0.037, 0.175, -0.092, 0.139), vec4(0.006, -0.470, -0.226, 0.052)) * bufB[6] + mat4(vec4(-0.072, -0.042, -0.016, -0.189), vec4(0.214, -0.038, -0.127, -0.139), vec4(0.016, -0.100, 0.190, -0.209), vec4(0.056, 0.226, 0.269, 0.011)) * bufB[7] + mat4(vec4(0.001, -0.418, 0.367, 0.033), vec4(-0.103, 0.049, 0.082, -0.060), vec4(0.034, 0.078, 0.249, -0.420), vec4(-0.125, -0.081, -0.059, 0.143)) * bufB[8] + mat4(vec4(0.135, -0.014, 0.113, -0.003), vec4(0.016, -0.082, -0.183, -0.147), vec4(-0.076, 0.354, 0.125, 0.366), vec4(0.144, -0.112, -0.133, -0.082)) * bufB[9];\nbufA[4] = vec4(-0.531, 0.040, 0.492, 0.372) + mat4(vec4(-0.278, -0.096, -0.284, 0.038), vec4(-0.048, -0.050, -0.107, 0.466), vec4(0.096, -0.057, 0.072, 0.141), vec4(-0.038, -0.262, 0.120, 0.041)) * bufB[0] + mat4(vec4(0.044, -0.262, -0.178, 0.061), vec4(0.262, 0.109, -0.320, -0.348), vec4(-0.060, 0.153, 0.204, 0.247), vec4(0.220, -0.390, -0.121, 0.181)) * bufB[1] + mat4(vec4(0.040, -0.058, -0.059, 0.149), vec4(0.010, 0.188, 0.021, 0.238), vec4(-0.035, -0.193, -0.050, -0.194), vec4(0.057, 0.443, 0.059, -0.095)) * bufB[2] + mat4(vec4(-0.074, 0.098, -0.164, -0.074), vec4(-0.236, -0.145, -0.016, -0.225), vec4(0.025, 0.189, 0.290, -0.045), vec4(0.182, -0.094, -0.006, -0.019)) * bufB[3] + mat4(vec4(0.413, 0.037, 0.079, 0.010), vec4(-0.005, -0.149, 0.202, -0.179), vec4(-0.011, 0.115, -0.198, 0.018), vec4(0.187, -0.181, -0.133, -0.101)) * bufB[4] + mat4(vec4(-0.246, -0.037, -0.037, -0.004), vec4(0.323, 0.076, -0.000, 0.214), vec4(-0.146, -0.001, -0.106, 0.094), vec4(-0.025, 0.038, -0.009, 0.043)) * bufB[5] + mat4(vec4(0.199, 0.324, -0.162, 0.168), vec4(0.058, -0.079, 0.235, -0.261), vec4(0.071, -0.019, 0.041, 0.251), vec4(-0.421, -0.346, -0.013, -0.433)) * bufB[6] + mat4(vec4(-0.184, 0.028, 0.021, -0.269), vec4(0.324, -0.013, -0.101, -0.060), vec4(-0.000, 0.016, 0.189, -0.304), vec4(0.121, -0.060, 0.001, 0.085)) * bufB[7] + mat4(vec4(-0.155, 0.036, 0.004, -0.071), vec4(0.079, 0.084, -0.050, 0.190), vec4(-0.084, 0.230, 0.203, 0.100), vec4(-0.079, -0.112, 0.259, 0.070)) * bufB[8] + mat4(vec4(0.134, -0.032, -0.142, 0.173), vec4(-0.199, -0.109, -0.280, -0.044), vec4(-0.157, 0.049, -0.228, -0.190), vec4(-0.220, 0.047, -0.159, 0.074)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 9 \nbufA[0] = vec4(0.203, 0.101, -0.080, 0.000) + mat4(vec4(0.071, 0.083, 0.098, 0.000), vec4(-0.101, -0.063, -0.034, 0.000), vec4(0.017, -0.016, 0.004, 0.000), vec4(0.208, 0.204, 0.150, 0.000)) * bufB[0] + mat4(vec4(0.164, 0.187, 0.121, 0.000), vec4(-0.044, -0.006, 0.005, 0.000), vec4(0.139, 0.212, 0.114, 0.000), vec4(0.062, 0.079, 0.130, 0.000)) * bufB[1] + mat4(vec4(0.060, 0.037, 0.032, 0.000), vec4(-0.019, -0.118, -0.078, 0.000), vec4(-0.035, -0.008, 0.016, 0.000), vec4(-0.044, -0.040, 0.044, 0.000)) * bufB[2] + mat4(vec4(-0.006, 0.001, 0.046, 0.000), vec4(-0.128, -0.107, -0.147, 0.000), vec4(0.143, 0.139, 0.123, 0.000), vec4(0.061, 0.055, -0.011, 0.000)) * bufB[3] + mat4(vec4(-0.229, -0.108, 0.134, 0.000), vec4(-0.092, -0.076, -0.040, 0.000), vec4(0.041, 0.009, -0.020, 0.000), vec4(-0.004, -0.018, -0.032, 0.000)) * bufB[4] + mat4(vec4(-0.079, -0.068, -0.061, 0.000), vec4(0.077, 0.053, 0.041, 0.000), vec4(-0.128, -0.116, -0.084, 0.000), vec4(0.054, 0.060, 0.014, 0.000)) * bufB[5] + mat4(vec4(-0.005, 0.003, 0.028, 0.000), vec4(0.170, 0.160, 0.166, 0.000), vec4(0.076, 0.064, 0.077, 0.000), vec4(0.189, 0.163, 0.133, 0.000)) * bufB[6] + mat4(vec4(0.140, 0.132, 0.135, 0.000), vec4(-0.138, -0.074, -0.089, 0.000), vec4(0.045, 0.010, 0.052, 0.000), vec4(-0.292, -0.212, -0.184, 0.000)) * bufB[7] + mat4(vec4(0.058, -0.023, 0.002, 0.000), vec4(-0.137, -0.125, -0.108, 0.000), vec4(-0.125, -0.115, -0.097, 0.000), vec4(0.030, 0.040, 0.053, 0.000)) * bufB[8] + mat4(vec4(-0.041, -0.081, -0.000, 0.000), vec4(-0.201, -0.165, -0.149, 0.000), vec4(-0.145, -0.121, -0.106, 0.000), vec4(-0.115, -0.120, -0.123, 0.000)) * bufB[9];\n\n return vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.23*sin(iTime), 0.32*sin(0.69*iTime), 0.32*sin(0.44*iTime), 0.23*sin(1.23*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 185, 185, 72782], [72784, 72784, 72841, 72891, 73339]], "test": "valid"}
{"id": "ftfSD2", "name": "Lightweight Planet Shader", "author": "NaitoOokami", "description": "First shadertoy shader.  Felt like making as light of a planet shader that I could.", "tags": ["space", "planet"], "likes": 5, "viewed": 121, "published": "Public", "date": "1626525095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415;\nconst float planetRotation = 0.1;\nconst float lightRotation = 0.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord/iResolution.xy)-vec2(0.5);\n    \n    //Correct aspect ratio (I know this can be done better)\n    uv *= vec2(3.5,2.0);\n    \n    //Slightly scaled UVs for planet\n    vec2 uv2 = uv*1.15;\n    \n    //Create spherical normals from UVs for planet\n    float planet = clamp(1.0-(dot(uv2,uv2)),0.0,1.0);\n    vec3 planetN = vec3(uv,sqrt(planet))*step(0.001,planet);\n    \n    //Planet UVs\n    vec2 planetUV;\n    planetUV.x = (atan(planetN.x,planetN.z)+0.5)/(pi*2.0)+(iTime*planetRotation);\n    planetUV.y = (asin(planetN.y)-0.5)/pi;\n    \n    //Atmosphere generation\n    float atmosphere = clamp(1.0-(dot(uv,uv)),0.0,1.0);\n    vec3 atmosphereN = vec3(uv,sqrt(atmosphere))*step(0.001,atmosphere);\n    \n    //Light Direction\n    vec3 l = normalize(vec3(sin(iTime*lightRotation),0,cos(iTime*lightRotation)));\n    float planetNL = clamp(dot(l,planetN),0.0,1.0);\n    float atmosphereNL = clamp(dot(l,atmosphereN),0.0,1.0);\n    \n    //Texture\n    vec4 tex = texture(iChannel0,planetUV)*step(0.001,planet);\n\n    // Output to screen\n    fragColor = vec4(tex*planetNL+((atmosphere*atmosphereNL)-planet));\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 150, 205, 1314]], "test": "error"}
{"id": "ftfSRj", "name": "Bilinear Patch 2D SDF + Normal", "author": "sdfgeoff", "description": "Computes an approximate surface bormal and SDF in 2D for a bilinear patch. Click for normals\nSDF and normals are only accurate near 0.0 - I think. Probably not even there :(\n\nI'd love to know if there are better ways to generate the normal/SDF", "tags": ["sdf", "normal", "bilinear"], "likes": 4, "viewed": 96, "published": "Public", "date": "1626010763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    +-----------------------------------------------------+\n    | There are probably better solutions and I'd love to |\n    | learn about them! If you know one, please comment   |\n    +-----------------------------------------------------+\n\n\n\n\n-------------------------- CONTEXT -----------------------------\nI wanted to generate an interesting 2D environment by thresholding\ninterpolated noise. Then came the challenge of applying physics to\nit. For this I needed the normal vector of the zero-crossing and\nan approximate distance to the surface.\n\nThis is the function I came up with. It's an approximation using\nthe partial derivatives. It has two major issues:\n\n1) when the interpolated surface is surface goes hyperbolic as it \n   cannot model the discontinuity in the distance function.\n   The partial derivatives tend to zero, 1/length(normal) -> inf\n\n2) Neigbouring patches are not taken into account, so the SDF/normal\n   of a larger texture will not be continuous.\n\nSo long as you only care about the values near the zero crossing\nyou'll probably be OK.\n\nAs far as I can tell it is impossible to get a perfect sdf. Imagine\nif all four corners have the same value. How can evenly spaced lines\nbe drawn on it? \n\n\n------------------------- CONTROLS --------------------------\nClick to show normal\n\nYou can select from two approximation modes below using the #defines\nbelow:\n - EVEN_SPACING uses an experimental approximation to try get more\n   even line spacing closer to hyperbolic inflection points, but it\n   gains dependence on the scale of the corners.\n\n- CONSTANT_LINECOUNT is \"analytic\" and is properly independant on the\n  scale of the corners matrix, but it behaves poorly if there is an\n  inflection point anywhere vaguely close.\n  \nIn practice, if you know that the corners matrix ranges from\n-1.0 to 1.0 I find that EVEN_SPACING gives a better approximation.\n\n*/\n\n#define EVEN_SPACING\n//#define CONSTANT_LINECOUNT\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \n\n \n    //We're only interested in a single patch\n    vec2 co = uv * 2.0 - 1.0;\n    co.x *= iResolution.x / iResolution.y;\n    co = co * 0.6 + 0.5;\n    \n    if (co.x > 1.0 || co.x < 0.0 || co.y > 1.0 || co.y < 0.0) {\n        fragColor = vec4(0.2);\n        return;\n    }\n\n    // The patch we will be sampling. We will be finding the zero\n    // crossing, so this can range from -1.0 to 1.0\n    mat2 corners = mat2(\n        sin(iTime * 2.0), // COORD [0,0]\n        cos(iTime * 0.5), // COORD [0,1samples]\n        sin(iTime), // COORD [1,0]\n        -cos(iTime) // COORD [1,1]\n    );\n\n    \n    vec2 co_int = floor(co);\n    ivec2 here_co = ivec2(co_int);\n    vec2 delta = co - co_int;\n    vec2 inv_delta = vec2(1.0) - delta;\n    \n\n    // Contain some numbers for ease of future referencing\n    vec4 x = vec4(inv_delta.x, delta.x, -1.0, 1.0);\n    vec4 y = vec4(inv_delta.y, delta.y, -1.0, 1.0);\n    \n    \n    // Bilinear interpolation\n    float bilinear_interpolation = dot(x.xy * corners, y.xy);\n    \n    // Partial derivatives in X/Y direction combined to make an\n    // approximate normal vector.\n    \n    // At this stage it is non-normalized.\n    float dx = dot(x.zw * corners, y.xy);\n    float dy = dot(x.xy * corners, y.zw);\n    vec2 normal = vec2(\n        dx,\n        dy\n    );\n    \n    // Approx sdf.\n#ifdef CONSTANT_LINECOUNT\n    // This approximation ensures a constant number of dividing lines\n    // across the patch regardless of scale between points.\n    float sdf = bilinear_interpolation / length(normal);\n#endif\n#ifdef EVEN_SPACING\n    // This approximation ensures a more even spacing\n    float sdf = bilinear_interpolation / sqrt(length(normal));\n#endif\n    \n    normal = normalize(normal);\n    \n    \n    vec4 out_col = vec4(0.0);\n    \n    if (iMouse.z < 0.0) {\n        // Draw the value produced by the interpolation\n        out_col += vec4(bilinear_interpolation * 0.5 + 0.5);\n\n        // Shade one side of the SDF\n        out_col += mix(vec4(0.0, 0.2, 0.0, 1.0), vec4(0.0), step(0.0, sdf));\n\n\n        // Draw equal distance lines\n        float lines = step(1.0 / iResolution.y, abs(0.01 - mod(sdf, 0.1)));\n        out_col = mix(vec4(1.0, 0.0, 1.0, 1.0), out_col, lines);\n\n        // Draw where the interpolation crosses the zero mark\n        float crossing = step(1.0 / iResolution.y, abs(0.01 - sdf));\n        out_col = mix(vec4(0.0, 0.0, 1.0, 1.0), out_col, crossing);\n    } else {\n        \n        out_col.rg = normal * 0.5 + 0.5;\n    }\n    \n    \n\n    // Output to screen\n    fragColor = out_col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1939, 1939, 1996, 2046, 4606]], "test": "valid"}
{"id": "ftfSWH", "name": "Bamboo Forest", "author": "will7007", "description": "A gray bamboo forest based off of the Arashiyama Bamboo Forest and the bamboo forest near the fox shrine that I visited while in Japan.", "tags": ["raymarching", "forest", "bamboo"], "likes": 5, "viewed": 153, "published": "Public API", "date": "1626660198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Donut factory\" by anclin. https://shadertoy.com/view/MsffDS\n// 2021-07-05 22:22:34\n\n// I was going to make things much more complex with crepuscular rays, textures, curving bamboo\n// trunks, and moving leaves (among other things), but I wanted to have a \"good enough\" version to\n// wrap things up and just get this thing out the door!\n\nconst float EPSILON = 0.001;\n\nconst vec3 leafColorDark = vec3(0x58, 0x66, 0x0f)/255.;\nconst vec3 leafColorLight = vec3(0xc0, 0xc0, 0x6e)/255.;\nconst vec3 trunkColor = vec3(0xb1, 0xb5, 0xb1)/255.;\n\n// credit to iq for making these SDF transforms/shapes\nfloat opExtrussion(in vec3 p, in float sdf, in float h) {\n    vec2 w = vec2( sdf, abs(p.y) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}\n\nfloat bamboo(vec3 origin, float height, float radius) {\n  float radiusBumpy = max(-.02*abs(sin(10.*origin.y))+radius,radius-.002);\n  origin.y -= clamp(origin.y, 0.0, height);\n  return length(origin) - radiusBumpy;\n}\n\nfloat leaves(vec3 origin, float h, float distortion) {\n    // don't look too closely at these crazy, distorted \"leaves\"!\n    origin.y -= h;\n    float c = opExtrussion( origin, sdCircle( vec2(origin.x,origin.z), .5 ), 0.6 );\n    return c-.7*sin(distortion*origin.x)*sin(distortion*origin.y)*sin(distortion*origin.z);\n}\n\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\n\nfloat SceneSDF(vec3 p){\n    //p = rotateY(iTime * 0.2) * p;\n    float smallest = 5.;\n    float d = 100.;\n    vec3 xyz = fract(p);  // point within a grid cell\n    xyz.y = p.y;  // we want the absolute y position in the grid cell for correctly calculating notches\n    vec2 id = floor(p.xz);  // the grid cell we are in\n    \n    for(float y=-1.; y <= 1.; y++) {  // look at the neighboring cells\n        for(float x=-1.; x <= 1.; x++) {  // to see which cell has a point that is the closest to our pixel\n            vec2 off = vec2(x, y);\n            vec2 coord = id+off;\n            vec2 n = N22(id+off);\n            \n            // calculate the point, then add the offset to it\n            // so that the point is moved into its own grid cell\n            // this is the origin for the purposes of this grid cell (i.e. the place where the bamboo trunk is centered)\n            // and xyz is the pixel where we are, so we measure from xyz->point since we want to know dist from point->origin\n            vec2 point = off+n;\n            \n            // dist between Voronoi point and current pixel RELATIVE TO GRID\n            // because the point is created relative to the grid\n            // so there won't be any Voronois if uv goes too far from the origin\n            vec3 gridCenter = vec3(xyz.x-point.x,xyz.y,xyz.z-point.y);\n            \n            d = bamboo(vec3(gridCenter),20.,.05);\n            d = min(d,leaves(gridCenter,21.9,20.));\n            \n            smallest = (d < smallest) ? d : smallest;\n        }\n    }\n    return smallest;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec4 ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n\tvec3 pos = eye;\n    for(int i = 0; i < 255; i++){\n        vec3 pos = eye + depth * marchingDirection;\n        //if(pos.y >= 30.) break;\n    \tfloat dist = SceneSDF(pos);\n        if( dist <= EPSILON){\n            return vec4(pos,depth);\n        }\n        depth += dist;\n        if(depth >= end){\n            pos = eye + depth * marchingDirection;\n        \treturn vec4(pos,end);\n        }\n    }\n    return vec4(pos,end);\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 rayDir = RayDirection(45.0, fragCoord.xy, iResolution.xy);\n    \n    float t = iTime*0.05;\n    vec3 eye = vec3(30.0+10.0*sin(t),3.,10.*cos(t));\n    \n    vec3 lookAtPos = vec3(1.0,40.,1.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAtPos, vec3(0,1,0) );\n    vec3 worldDir = (viewToWorld*vec4(rayDir,0)).xyz;\n    \n    vec4 shortDist = ShortestDistanceToSurface(eye,worldDir,0.,100.0);\n    vec3 pos = shortDist.xyz;\n    float dist = shortDist.w;\n    \n    vec3 lightPos = vec3(.5,1.5,.5);\n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse,0.);\n    \n    vec3 finalColor = vec3(0);\n\n    if(shortDist.y >= 21.35) {\n        finalColor = leafColorLight;\n    } else if(shortDist.y >= 20.) {\n        finalColor = leafColorDark;\n    } else {\n        finalColor = trunkColor;\n    }\n\n    vec3 ambientColor = vec3(.4);\n    finalColor = finalColor*(diffuse+ambientColor);\n\n\tfragColor = vec4(finalColor,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[545, 600, 657, 657, 753], [755, 755, 790, 790, 818], [820, 820, 875, 875, 1035], [1037, 1037, 1091, 1157, 1354], [1356, 1356, 1374, 1374, 1497], [1499, 1499, 1522, 1558, 3049], [3051, 3051, 3080, 3080, 3390], [3392, 3392, 3456, 3456, 3585], [3587, 3587, 3676, 3676, 4119], [4121, 4448, 4497, 4532, 4758], [4760, 4760, 4817, 4817, 5876]], "test": "valid"}
{"id": "ftfXDj", "name": "Class 3: Fork 1 877 Cephalopod", "author": "Cephalopodium", "description": "Simple texturing shading and lighting. To implement lighting get normals from its position instead of the eye / camera position. This is called Lambertian or diffuse shading. ", "tags": ["texture", "shading"], "likes": 0, "viewed": 36, "published": "Public", "date": "1626549621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n  \n  \n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t = 1000000.0; // initialize to a large number\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return t;\n}\n\n\nSphere spheres[4];\nLight  lights[1];\n\nvoid makeScene(int f) {\n    // CDA Added blue to yellow ball\n    spheres[0] = Sphere(1.5, vec3(0, 0, -6), vec3(1, 1, 0.1));   \n    // CDA light position and color oscillations\n    lights[0] = Light(vec3(-1.0+sin(float(f)/20.0)*3.0,\n                           -1.0+cos(float(f)/20.0)*3.0, \n                           -2.0+sin(float(f)/20.0)*3.0), \n                      vec3(abs(tan(float(f)/20.0)+.250)*3.0,     // prefix with abs(trig(..)) \n                           abs(cos(float(f)/20.0)+1.0)*3.0,      // to remove shadow\n                           (sin(float(f)/20.0)-1.0)*3.0));       // colour artifacts\n //   lights[0] = Light(vec3(-1.0, 0.0, -4.0), vec3(1, 1, 1));\n//    lights[0] = Light(vec3(0.0,0.0, 0.0), vec3(1, 1, 1));\n}\n\nint numSamples=1;\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   float screenSize = 1.0;\n   if (iResolution.x>640.0) screenSize=2.0;\n   \n   float width = iResolution.x/screenSize;\n   float height = iResolution.y/screenSize;\n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<=1; i++) { // Must compare loop index with const on iphone \n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       Sphere sphere = spheres[0];\n       \n       float t = raySphereIntersect(ray, sphere);\n       if (t < 1000000.0) {\n           vec3 hit = ray.origin + t*ray.direction;\n     //      vec3 norm = normalize(hit - sphere.center);\n           vec3 hitPointNormal = normalize(hit-sphere.center);\n           vec3 hitPointToEye = normalize(vec3(0, 0, 0)-hit);\n           vec3 hitPointToLight = normalize(lights[0].location-hit);\n           float angle = dot(hitPointNormal, hitPointToLight); // hitPointToEye);\n           samp = samp + angle*sphere.color*lights[0].color; // CDA multipled by light color\n       } \n   }\n   fragColor = vec4(samp/float(numSamples), 1.0); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 83, 99, 99, 146], [497, 537, 593, 593, 1077], [1118, 1118, 1141, 1178, 1854], [1876, 1955, 2010, 2168, 3721]], "test": "valid"}
{"id": "ftfXWH", "name": "Another Galaxy (Technicolor)", "author": "froggynotacon", "description": "Fork of https://www.shadertoy.com/view/sdXSz7\n\nAdded more color variety.", "tags": ["noise", "circles", "fork"], "likes": 4, "viewed": 81, "published": "Public", "date": "1625540793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p) {\n    return fract(sin(p.x*100.+p.y*6574.)*5647.);\n}\nvec2 N22(vec2 p)\n{\n    float x = N21(p);\n    float y = N21(p + x);\n    return vec2(x, y);\n}\nvec2 GetPos(vec2 id)\n{\n    vec2 n = N22(id) * (iTime + 100.0) * 0.6;\n    return sin(n) * .4;\n}\n\n//from bigwings' tutorial\nfloat SmoothNoise(vec2 uv) {\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n\n    c += SmoothNoise(uv*8.2)*.5;\n    c += SmoothNoise(uv*16.7)*.25;\n    c += SmoothNoise(uv*32.4)*.125;\n    c += SmoothNoise(uv*64.5)*.0625;\n    \n    c /= 2.;\n    \n    return c;\n}\nfloat Shines(vec2 uv)\n{\n    uv *= 1.5;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    vec2 p = GetPos(id);\n    float d = length(gv - p);\n    float m = smoothstep(0.08, 0.01, d);\n    return m;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float shine = 0.;\n    for(int i = 0; i < 4; i ++)\n    {\n        shine += Shines(uv * 2.0 * float(i) + float(i));\n    }\n    uv *= dot(uv, vec2(0.9, 2.4));\n    vec2 polarUV = vec2(atan(uv.x, uv.y), length(uv));\n    float polarLenght = length(polarUV);\n    float noise = SmoothNoise2(polarUV);\n    noise *= 1. - length(uv);\n    noise += abs(sin(noise * iTime)) * noise;\n\n    vec3 col = (noise + shine * noise) * vec3(abs(sin(iTime * .25)), 0.4 * abs(sin(iTime/5.00)), 0.7 * abs(sin(iTime*1.25)));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 70], [71, 71, 89, 89, 162], [163, 163, 185, 185, 257], [259, 285, 313, 313, 632], [634, 634, 663, 663, 878], [879, 879, 902, 902, 1085], [1086, 1086, 1143, 1143, 1744]], "test": "valid"}
{"id": "ftfXWr", "name": "Truchet effect", "author": "Vinicius_Jesus", "description": "Simple Truchet effect", "tags": ["lines", "effect", "truchet"], "likes": 5, "viewed": 89, "published": "Public", "date": "1625436403", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float R21(vec2 p) {\n    return fract(sin(dot(p.xy, vec2(2.3245,5.234)))*12.5632145);\n}\n\nvoid mainImage(out vec4 o, in vec2 i) {\n    vec2 r = iResolution.xy;\n    \n    vec2 uv = (i-.5*r)/r.y;\n    uv *= 5.;\n    \n    vec3 col = vec3(0.);\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float n = R21(id);\n    if (n < .5) gv.x *= -1.;\n    \n    float d = abs(abs(gv.x+gv.y)-.5);\n    vec2 cUv = gv-sign(gv.x+gv.y+.001)*.5;\n    d = length(cUv);\n    \n    float width = .1 * length(uv+vec2(sin(iTime),cos(iTime)));\n    \n    float mask = smoothstep(.01, -.01, abs(d-.5)-width);\n    \n    float angle = atan(cUv.x, cUv.y);\n    float checker = mod(id.x+id.y, 2.)*2.-1.;\n    \n    float x = checker*angle/1.57+iTime*.2;\n    float y = (d-(.5-width))/(2.*width);\n    y = abs(y-.5)*2.;\n    \n    vec2 tUv = vec2(x,y);\n    vec3 irgb = texture(iChannel0, tUv).rgb;\n    vec3 neg = vec3(1.,1.,1.) - irgb;\n    \n    col += mix(irgb, neg, mask);\n    col += mask;\n\n    col *= tUv.y;\n    \n    o = vec4(col, 1.);\n    \n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfXWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 86], [88, 88, 127, 127, 1008]], "test": "error"}
{"id": "ftfXzM", "name": "doublej - fog", "author": "boudartjj", "description": "generate fog", "tags": ["fog"], "likes": 0, "viewed": 55, "published": "Public", "date": "1625316544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand2D(in vec2 co, float seed){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 + seed);\n}\n\nfloat noise2D(vec2 norm_fragCoord, int resolution, int iterations, float amplitude, float smoothness, float blur, float seed) {\n    float level = 0.5;\n    float variation_amplitude = 0.5;\n    float grid_resolution = float(resolution);\n    \n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n    vec2 p3;\n    \n    float d0;\n    float d1;\n    float d2;\n    float d3;\n    \n    float c0 = level;\n    float c1 = level;\n    float c2 = level;\n    float c3 = level;\n    \n    for(int i = 0; i < iterations; i++) { \n        grid_resolution = grid_resolution * pow(2.0, float(i));\n        float grid_cell_size = 1.0 / grid_resolution;\n        \n        variation_amplitude = variation_amplitude / (smoothness * float(i + 1));\n        p0 = vec2(floor(grid_resolution * norm_fragCoord) / grid_resolution);\n        p3 = floor(grid_resolution * (norm_fragCoord + grid_cell_size)) / grid_resolution;\n        p1 = vec2(p3.x, p0.y);\n        p2 = vec2(p0.x, p3.y);\n\n        \n        d0 = 1.0 / pow(distance(norm_fragCoord, p0), blur);\n        d1 = 1.0 / pow(distance(norm_fragCoord, p1), blur);\n        d2 = 1.0 / pow(distance(norm_fragCoord, p2), blur);\n        d3 = 1.0 / pow(distance(norm_fragCoord, p3), blur);\n\n        c0 = level + variation_amplitude * (rand2D(p0, seed) - 0.5);\n        c1 = level + variation_amplitude * (rand2D(p1, seed) - 0.5);\n        c2 = level + variation_amplitude * (rand2D(p2, seed) - 0.5);\n        c3 = level + variation_amplitude * (rand2D(p3, seed) - 0.5);\n       \n        level = (\n                    c0 * d0 + \n                    c1 * d1 + \n                    c2 * d2 +\n                    c3 * d3\n                ) / (d0 + d1 + d2 + d3);\n    }\n        \n    return pow(level, amplitude);\n}\n\nvec2 brownian_motion2D (vec2 norm_fragCoord, float time) {\n    float frequency = 1.0;\n    float amplitude = 0.2;\n    \n    norm_fragCoord.x = norm_fragCoord.x * (1.0 + 0.2 * amplitude * cos(0.22 * time + 0.5 * norm_fragCoord.x * frequency));\n    norm_fragCoord.x = norm_fragCoord.x * (1.0 + 0.2 * amplitude * cos(0.35 * time + 0.8 * norm_fragCoord.x * frequency));\n    norm_fragCoord.x = norm_fragCoord.x * (1.0 + 0.2 * amplitude * cos(0.18 * time + 0.32 * norm_fragCoord.x * frequency));\n    \n    norm_fragCoord.y = norm_fragCoord.y * (1.0 + 0.7 * amplitude * cos(0.22 * time + 0.25 * norm_fragCoord.y * frequency));\n    norm_fragCoord.y = norm_fragCoord.y * (1.0 + 0.4 * amplitude * cos(0.35 * time + 0.44 * norm_fragCoord.y * frequency));\n    norm_fragCoord.y = norm_fragCoord.y * (1.0 + 0.3 * amplitude * cos(0.18 * time + 0.54 * norm_fragCoord.y * frequency));\n    \n\n    return norm_fragCoord;\n}\n\nvec4 fog(vec2 norm_fragCoord, vec3 color, float intensity, float speed, float time, float seed) { \n    norm_fragCoord = brownian_motion2D(norm_fragCoord, time);\n    \n    float level1 = noise2D(norm_fragCoord, 8, 3, 2.0, 1.5, 3.0, seed);\n    float level2 = noise2D(norm_fragCoord, 6, 3, 2.0, 1.5, 3.0, seed + 0.5);\n    float level = pow(sin(speed * time), 2.0) * level1 + pow(cos(speed * time), 2.0) * level2;\n    \n    return vec4(color * pow(level, 1.0/intensity), pow(level, 0.25));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 image_color = vec3(0.5, 0.75, 1.0);\n    vec2 norm_fragCoord = fragCoord.xy / iResolution.xx;\n    \n    fragColor = fog(norm_fragCoord, image_color, 2.0, 0.5, iTime, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 116], [118, 118, 245, 245, 1815], [1817, 1817, 1875, 1875, 2716], [2718, 2718, 2815, 2815, 3203], [3205, 3205, 3262, 3262, 3446]], "test": "valid"}
{"id": "ftjSz1", "name": "HoloGlenn", "author": "sk7725", "description": "Holographic framebuffer spicer for all your glenning needs.", "tags": ["framebuffer", "overlay", "hologram"], "likes": 2, "viewed": 68, "published": "Public", "date": "1627090797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float absin(float t) {\n    return 0.5 + sin(t) * 0.5;\n}\n\nfloat ababsin(float t) {\n    return 0.75 + sin(t) * 0.25;\n}\n\nfloat abababsin(float t) {\n    return 0.7 + sin(t) * 0.24;\n}\n\nfloat absincos(float t, float n){\n    return clamp(abababsin(n * 3.14159 * cos(t)), 0. ,1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    //vec4 base = texture(iChannel0, uv); //represents framebuffer feed (alternative)\n    vec4 base = vec4(.3, .9, 1., 1.); //represents framebuffer feed\n    vec4 game = texture(iChannel1, uv); //represents in-game screen\n    \n    float L = 2800. + 50.0 * cos(iTime / 5.);\n    float P = 25.;\n    float N = 27.0; //should be #defines\n    float M = 250.0 + 50.0 * sin(iTime / 5.);\n    float x = fragCoord.x;\n    float y = fragCoord.y;\n    float a = absincos((x - 2.0 * y) / L + iTime * .15, P) * absincos(iTime * .3 + y / M, N);\n    //float a = abababsin((x - 2.0 * y) / L + iTime * 5.) * abababsin(N * 3.14159 * cos(iTime + y / M));\n    fragColor = base * a + game * (1.-a);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 55], [57, 57, 81, 81, 116], [118, 118, 144, 144, 178], [180, 180, 213, 213, 274], [276, 276, 331, 331, 1049]], "test": "error"}
{"id": "ftjXRD", "name": "Fractal 68_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 23, "viewed": 316, "published": "Public API", "date": "1627220646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.3;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.8)*.03*exp(-i*i*e)\n    )\n    {\n        p=g*d;\n        p+=vec3(.3,.3,-1.8);\n        p=R(p,vec3(.577),iTime*.1);\n        s=3.;\n        for(int j=0;j++<8;)\n            p=clamp(p,-.5,.5)*2.-p,\n            s*=e=7.*clamp(.3/min(dot(p,p),1.),.0,1.),\n            p*=e;\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjXRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 609]], "test": "valid"}
{"id": "ftjXWh", "name": "3D Mandelbrot Set by Gera", "author": "geranyan", "description": "3D Mandelbrot Set by Gera", "tags": ["raymarching", "mandelbrot"], "likes": 4, "viewed": 75, "published": "Public", "date": "1627554155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sph(in vec3 pos, in vec3 cen, in float r) {\n\treturn length(pos - cen) - r; \n}\n\nfloat plane(in vec3 pos, in float r) {\n\n\treturn pos.y - (-r);\n}\nfloat mnd(in vec3 pos) {\n    vec3 z = pos;\n    float dr = 2.0;\n    float r = 0.0;\n    \n    for(int i = 0; i < 200; i++) {\n        \n        r = length(z);\n        \n        if (r >= 2.0 ) {\n            break;\n        }\n        \n        float power = 9.0; //abs(6.0 *sin(iTime * 0.1)) + 2.0;\n        \n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n        \n        dr = pow(r, power - 1.0 ) * power * dr + 1.0;\n        \n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n        \n        z = zr * vec3(sin(theta) * cos(phi),\n                      sin(phi) * sin(theta),\n                      cos(theta));\n        z += pos;\n    }\n    \n    return 0.5 * log(r) * r / dr;\n}\n\nvec2 mmin(in vec2 a, in vec2 b) {\n\t\n\treturn abs(a.x) < abs(b.x) ? a: b;\n}\n\nvec2 map(in vec3 pos) {\n    \n    vec2 d1 = vec2(mnd(pos), 1.0);\n    \n    vec2 d2 = vec2(sph(pos, vec3(0.0), 700.0), 2.0);\n    \n    return mmin(d1, d2);\n}\n\nvec3 normal(in vec3 pos)\n{\n\tconst vec3 eps = vec3(0.001, 0.0, 0.0);\n        \n    float grad_x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    float grad_y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    float grad_z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n  \n    return normalize(vec3(grad_x, grad_y, grad_z));\n}\n\n\nvec2 rayMarch(in vec3 ro, in vec3 rd) \n{\n\n    float t = 0.0; \n    float d = 0.0; \n    \n    for(int i = 0; i < 200; i++){\n    \n    \tvec2 pos = map(ro + t* rd); \n        \n        if(pos.x < 0.001){\n        \t\n        \tpos.x = t; \n           \t\n            return pos;\n        } \n        \n        if(pos.x > 1000.0){\n        \tbreak;\n        }\n        \n        t += pos.x;\n    }\n    \n    return vec2(-1.0);\n\n}\n\nfloat diffuse_light(in vec3 pos, in vec3 cen){\n    \n\tvec3 nor = normal(pos);\n    vec3 dir_to_light = normalize(cen-pos);\n    float diff_intens = dot(nor, dir_to_light);\n    \n    return diff_intens;\n\n}\n\nfloat phong_light(in vec3 pos, in vec3 cen, in vec3 ro, in float k){\n\t\n    float specPower = k;\n    vec3 n = normal(pos);\n    vec3 l = normalize(cen-pos);\n    vec3 v = normalize(ro-pos);\n    vec3 r = reflect(-v, n);\n    float phong_light = pow ( max ( dot ( l, r ), 0.0 ), specPower );\n    return phong_light;\n\n}\n\n\nfloat shadow(vec3 pos, vec3 lightpos){\n\tvec3 rd = normalize(lightpos-pos);\n    float res = 1.0;\n    float t = 0.0;\n    \n    for (float i = 0.0; i < 100.0; i++)\n    {\n\t\tvec2 h = map(pos + rd * t);\n        res = min(res, 200.0 * h.x / t);\n        t += h.x;\n        \n        if ((res < 0.0001 || t > 320.0)) break;\n        \n    }\n    \n    return clamp(res, 0.0, 1.0);\n    \n}\n\nvec3 mnd2D(in vec2 C){\n    vec2 z = vec2(0.0 , 0.0);\n    float n = .0;\n    while (length(z) <= abs(20.0 * sin(iTime*0.5))+1.0 && n < abs(20.0 * sin(iTime*0.5))+1.0){\n        z = vec2(z.x * z.x -  z.y * z.y,  2.0 * z.x * z.y) + C;\n        n += 1.0;\n    }\n    return vec3(n / (abs(20.0 * sin(iTime*0.1))+1.0));\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/5.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    \n    vec2 h = rayMarch(ro, rd);\n    vec3 col = vec3(1.0,1.0,1.0);\n    vec3 pos = ro + h.x * rd;\n    if (h.y == 1.0) {\n        \n        //col *= phong_light(pos, vec3(50.0*sin(iTime), 200.0, cos(iTime)), ro, 20.5) * vec3(1.0,1.0,1.0);\n        //col *= diffuse_light(pos, vec3(50.0*sin(iTime), 200.0, cos(iTime))) * vec3(1.3, 1.3, 1.3);\n        col *= calcAO(pos, normal(pos)) * vec3(1.9);\n        \n        return col;\n    }\n    else if (h.y == 2.0){\n    \n    \n       \n        vec3 n_pos = normalize(pos);\n        vec2 C =  vec2(-n_pos.x - n_pos.z -n_pos.y + sin(iTime * 0.5),-n_pos.x - n_pos.z +n_pos.y + cos(iTime * 0.5));\n        col *= vec3(1.0) - mnd2D(C);\n    \n        //col *= diffuse_light(pos, vec3(50.0, 200.0, 1.0)) * vec3(0.2, 0.2, 0.1);\n        //col *= shadow(pos, vec3(50.0*sin(iTime), 200.0, cos(iTime)));\n        return col;\n        \n    }\n    \n    return vec3(0.0);\n    \n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    \n    float an = iTime * 0.1;//10.0 * iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(1.0*cos(an)*1.5, 1.3*sin(iTime*0.05), 1.0*sin(an) * 1.5);\n    vec3 ta = vec3(0.0); // target for camera\n\n\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize( cross(uu, ww));\n\n\n\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + ww);\n    vec3 col = render(ro, rd); \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjXWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 50, 50, 84], [86, 86, 124, 124, 149], [150, 150, 174, 174, 883], [885, 885, 918, 918, 958], [960, 960, 983, 983, 1113], [1115, 1115, 1141, 1141, 1440], [1443, 1443, 1483, 1483, 1846], [1848, 1848, 1894, 1894, 2048], [2050, 2050, 2118, 2118, 2362], [2365, 2365, 2403, 2403, 2736], [2738, 2738, 2760, 2760, 3048], [3049, 3049, 3091, 3091, 3397], [3399, 3399, 3435, 3435, 4337], [4339, 4339, 4396, 4396, 4902]], "test": "valid"}
{"id": "ftlSDf", "name": "New retro wave", "author": "Citiral", "description": "Simple shader to emulate the new retro wave 'laser grid' style, with distortion.", "tags": ["simple", "wave", "retro", "laser"], "likes": 0, "viewed": 186, "published": "Public API", "date": "1626707211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float line(float p, float l, float w)\n{\n\treturn max(distance(p, l) - w, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 r = normalize(vec3(p.x - iResolution.x / iResolution.y * 0.5, -1, p.y - 0.5));\n\t\n\tr.x += tan(iTime+sin(p.y))*0.01;\n\tr.z += sin(iTime*4.01+r.x*2.0)*0.005;\n\t\n\tif (r.z <= 0.0) {\n        vec2 sp = mod(r.xy / r.z, 1.0);\n\t\tfloat d = line(sp.x, 0.0, 0.01) *\n                  line(sp.y, 0.0, 0.01) *\n                  line(sp.x, 1.0, 0.01) *\n                  line(sp.y, 1.0, 0.01);\n\n\t\tfragColor.rgb = (1.0-pow(d, 0.06)) * vec3(0.3, 1, 0.2);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlSDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 79], [81, 81, 138, 138, 668]], "test": "valid"}
{"id": "ftlSDr", "name": "Flag of Macedonia", "author": "jjovanovski", "description": "Macedonian flag.\n\nInspired by The Art Of Code's video: https://www.youtube.com/watch?v=t4XnK50ocMk", "tags": ["flag", "macedonian"], "likes": 4, "viewed": 128, "published": "Public", "date": "1625481727", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 RED = vec3(210.0/255.0, 0.0, 0.0);\nvec3 YELLOW = vec3(255.0/255.0, 231.0/255.0, 0.0);\n\nvec3 drawCircle (vec2 uv, vec2 pos, float radius, vec3 color)\n{\n    float d = length(uv - pos);\n    float white = smoothstep(radius, radius - 0.002, d);\n    vec3 result = color * vec3(white);\n    \n    return result;\n}\n\nvec3 drawTriangle (vec2 uv, vec2 pos, vec2 scale, vec3 color)\n{\n    int N = 3;\n    \n    vec2 sUv = pos + uv / scale;\n    \n    float a = atan(sUv.x, sUv.y) + PI;\n    float r = TWO_PI / float(N);\n    float d = cos(floor(0.5 + a / r) * r - a) * length(sUv);\n    \n    return vec3(smoothstep(0.21, 0.190, d)) * color;\n}\n\nvec3 drawRay (vec2 uv, vec2 pos, vec2 scale, float angle, vec3 color)\n{\n    uv *= mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n\n    vec2 tUv = uv + pos;\n    tUv /= scale;\n    \n    vec3 circle = drawCircle(tUv, vec2(0, 0), 0.04, color);\n    vec3 triangle = drawTriangle(tUv, vec2(0.0, -0.2), vec2(0.115, 0.8), color);\n    vec3 area = vec3(1) * smoothstep(0.0, length(color) - 0.005, length(circle + triangle));\n    vec3 col = area * color; \n    \n    return col;\n}\n\nvec3 drawSun (vec2 uv)\n{\n    vec3 col = vec3(0);\n\n    // draw sun circle\n    col += drawCircle(uv, vec2(0.0, 0.0), 0.055, YELLOW);\n    \n    // draw major rays\n    for (float angle = 0.0; angle < 2.0; angle += 0.25)\n    {\n        col += drawRay(uv, vec2(0.0, -0.1), vec2(0.6), PI * angle, YELLOW);\n    }\n    \n    // draw minor rays\n    for (float angle = 0.0; angle < 2.0; angle += 0.25)\n    {\n        col += drawRay(uv, vec2(0.0, -0.15), vec2(0.4, 0.5), PI * (angle + 0.125), YELLOW);\n    }\n    \n    return col;\n}\n\nvec3 rect(vec2 uv, vec2 pos, float width, float height, vec3 color) {\n\tfloat t = 0.0;\n\tif ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)\n\t\t&& (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {\n\t\tt = 1.0;\n\t}\n\treturn color * t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // center the uv coordinates\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = uv.x * 7.0 - iTime * 2.0 + uv.y * 4.0;\n    uv.y += sin(t) * 0.025;\n\n    vec3 col = rect(uv, vec2(0), 1.0 * iResolution.x / iResolution.y, 1.0, RED);\n    col += drawSun(uv);\n    \n    float shadow = 0.15;\n    col *= (1.15 - shadow) + cos(t) * shadow;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlSDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 210, 210, 364], [366, 366, 429, 429, 680], [682, 682, 753, 753, 1154], [1156, 1156, 1180, 1180, 1669], [1671, 1671, 1740, 1740, 1928], [1931, 1931, 1988, 2038, 2495]], "test": "valid"}
{"id": "ftlXD4", "name": "20210708_slerpUniformVec3", "author": "FMS_Cat", "description": "Describe your shader", "tags": ["3d", "math"], "likes": 1, "viewed": 58, "published": "Public", "date": "1625710281", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(i) clamp((i),0.,1.)\n\nconst float PI = acos( -1.0 );\nconst float TAU = 2.0 * PI;\n\n/**\n * Spherical lerp between a and b.\n * a and b must be normalized.\n */\nvec3 slerpUniformVec3( vec3 a, vec3 b, float t ) {\n  // early abort if t is exactly zero or one\n  if ( t == 0.0 ) { return a; }\n  if ( t == 1.0 ) { return b; }\n  \n  // ss for a, st for b\n  // ( ss + st ) can be like 1.414 (when the angle between a and b is 90 deg and t is 0.5)\n  float ss;\n  float st;\n  \n  float cosv = dot( a, b );\n  \n  if ( cosv > 1.0 - 1E-4 ) {\n    // avoid precision funny, just lerp it\n    st = t;\n    ss = 1.0 - t;\n  } else {\n    // do the proper slerp\n    float sinv = sqrt( 1.0 - cosv * cosv );\n    float theta = acos( cosv );\n\n    ss = sin( ( 1.0 - t ) * theta ) / sinv;\n    st = sin( t * theta ) / sinv;\n  }\n  \n  return ss * a + st * b;\n}\n\n/**\n * SDF of capsule.\n * See: https://iquilezles.untergrund.net/www/articles/distfunctions/distfunctions.htm\n */\nfloat sdcapsule( vec3 p, vec3 tail ) {\n  float h = saturate( dot( p, tail ) / dot( tail, tail ) );\n  return length( p - tail * h );\n}\n\nfloat map( vec3 p, out vec3 diffuseColor ) {\n  vec3 a = normalize( vec3( 1.0, 1.0, 1.0 ) );\n  vec3 b = normalize( vec3( -1.0, 0.0, 0.0 ) );\n  float t = 0.5 + 0.5 * sin( iTime );\n\n  vec3 tail = mix( a, b, t );\n  float d = sdcapsule( p, tail ) - 0.1;\n  diffuseColor = vec3( 1.0, 0.0, 0.0 );\n\n  tail = slerpUniformVec3( a, b, t );\n  float d2 = sdcapsule( p, tail ) - 0.1;\n  if ( d2 < d ) {\n    d = d2;\n    diffuseColor = vec3( 0.0, 1.0, 0.0 );\n  }\n\n  return d;\n}\n\nvec3 nmap( vec3 p ) {\n  vec2 d = vec2( 0.0, 1E-3 );\n  vec3 _;\n  return normalize( vec3(\n    map( p + d.yxx, _ ) - map( p - d.yxx, _ ),\n    map( p + d.xyx, _ ) - map( p - d.xyx, _ ),\n    map( p + d.xxy, _ ) - map( p - d.xxy, _ )\n  ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 p = uv * 2.0 - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n\n  vec3 col = vec3( 0.8 );\n\n  vec3 ro = vec3( 0.0, 0.0, 2.0 );\n  vec3 rd = normalize( vec3( p, -1.0 ) );\n  \n  float rl = 1E-2;\n  vec3 rp = ro + rd * rl;\n  float dist;\n  vec3 diffuseColor;\n  \n  for ( int i = 0; i < 64; i ++ ) {\n    dist = map( rp, diffuseColor );\n    rl += dist;\n    rp = ro + rd * rl;\n  }\n  \n  if ( dist < 1E-2 ) {\n    vec3 N = nmap( rp );\n    const vec3 L = normalize( vec3( 1.0 ) );\n    float halfLambert = 0.5 + 0.5 * dot( N, L );\n    \n    // Gooch shading\n    col = (\n      0.5 * halfLambert * diffuseColor +\n      0.5 * mix( vec3( 0.0, 0.0, 1.0 ), vec3( 1.0, 1.0, 0.0 ), halfLambert )\n    );\n  }\n  \n  fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 172, 222, 267, 837], [839, 953, 991, 991, 1086], [1088, 1088, 1132, 1132, 1547], [1549, 1549, 1570, 1570, 1785], [1787, 1787, 1844, 1844, 2606]], "test": "error"}
{"id": "ftlXDj", "name": "Neon Warbler", "author": "TEttinger", "description": "An edit of my Northern Warbler ( https://www.shadertoy.com/view/NsXXWN ) to try to break up large-scale grid patterns; this also made the colors much brighter and changed the shapes.", "tags": ["noise", "plasma", "lights", "neon", "northern", "warbler"], "likes": 1, "viewed": 73, "published": "Public", "date": "1626584488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0 licensed, do what thou wilt.\n\n// change the seed to any not-too-huge float and the colors/shapes will change.\nconst float SEED = 420.69; // starts off nicely.\nconst vec3 COEFFS = fract((SEED + 23.4567) * vec3(0.8191725133961645, 0.6710436067037893, 0.5497004779019703)) + 0.5;\n\n// what's different here is mostly how swayRandomized() incorporates the x, y, and z of seed and value for each component.\nvec3 swayRandomized(vec3 seed, vec3 value)\n{\n    return sin(seed.xyz + value.zxy + (cos(seed.zxy + value.yzx) + 2.0) * sin(seed.yzx + value.xyz));\n}\n\n// this function, if given steadily-increasing values in con, may return exponentially-rapidly-changing results.\n// even though it should always return a vec3 with components between -1 and 1, we use it carefully.\nvec3 cosmic(vec3 c, vec3 con)\n{\n    con += swayRandomized(c, con.yzx);\n    con += swayRandomized(c + 1.0, con.zxy);\n    con += swayRandomized(c + 2.0, con.xyz);\n    return con * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy + swayRandomized(COEFFS.zxy, (iTime * 0.1875) * COEFFS.yzx).xy) * 16.0;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.042 + 0.75;\n    vec3 adj = vec3(-1.11, 1.41, 1.61);\n    vec3 s = (swayRandomized(vec3(34.0, 76.0, 59.0), aTime + adj)) * 0.25;\n    vec3 c = (swayRandomized(vec3(27.0, 67.0, 45.0), aTime - adj)) * 0.25;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    \n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS * 0.618, con);\n//    con = cosmic(COEFFS, con);\n    \n    fragColor = vec4(swayRandomized(COEFFS + 3.0, con * (3.14159265)) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 408, 452, 452, 556], [558, 772, 803, 803, 957], [959, 959, 1016, 1066, 1753]], "test": "error"}
{"id": "ftlXRM", "name": "More surface detail experiments", "author": "kibitz9", "description": "Using mandelbox fractal for surface detail on various primitives.", "tags": ["mandelbox"], "likes": 23, "viewed": 178, "published": "Public", "date": "1625358159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//***************************************************************//\n// Yet More Fractal Surface Experiments by CMiller (kibitz9)\n// I am experimenting with using fractals for surface detail (greebles). \n//***************************************************************// \n\nconst float GLOBAL_EPSILON = .0005;\nconst vec2 GLOBAL_PN = vec2(1,-1);\nconst vec3 GLOBAL_PN_XYY=GLOBAL_PN.xyy;\nconst vec3 GLOBAL_PN_YYX=GLOBAL_PN.yyx;\nconst vec3 GLOBAL_PN_YXY=GLOBAL_PN.yxy;\nconst vec3 GLOBAL_PN_XXX=GLOBAL_PN.xxx;\n\nconst vec3 GLOBAL_PN_XYY_EPS=GLOBAL_PN_XYY*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_YYX_EPS=GLOBAL_PN_YYX*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_YXY_EPS=GLOBAL_PN_YXY*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_XXX_EPS=GLOBAL_PN_XXX*GLOBAL_EPSILON;\nconst float MAX_DIST = 10.0;\n\n\nconst float COSTHETA1=0.70710677;\nconst float SINTHETA1=0.70710677;\nconst float SECTORSIZE1=0.5235987756;\nfloat sdf4(vec3 p){\n\t//Torus1\n\tfloat primaryRadius1=0.55;\n\tfloat secondaryRadius1=0.2;\n\treturn length(vec2(length(p.xz)-primaryRadius1,p.y))-secondaryRadius1;\n}\n\nconst float SCALE1=0.7;\n//Mandelbox1\nconst float S1=-2.9;\nconst float R1=0.5;\nconst int ITR1=10;\nconst float F1=1.0;\nvec3 scale_color1(vec3 q){\n\tvec3 p=q/SCALE1;\n\treturn vec3(1,1,1);\n}\nfloat sdf1(vec3 p){\n\treturn sdf4(p);\n}\nfloat sdf2(vec3 p){\n\tvec3 sp1=p/SCALE1;\n\tvec4 q3=vec4(sp1,1.0);\n\tvec4 c1=vec4(sp1,1.0);\n    float temp = +sin(iTime/4.)*0.25;\n\tfor (int a1=0;a1<ITR1;a1++){\n\t\tq3.xyz=F1*(clamp(q3.xyz,-1.0,1.0)*2.0-q3.xyz);\n\t\tq3 *=S1/clamp(dot(q3.xyz,q3.xyz),R1+temp,1.0);\n\t\tq3 +=c1;\n\t}\n\treturn (.333*length(q3.xyz)/abs(q3.w))*SCALE1;\n}\nfloat sdf3(vec3 p){\n\tfloat thickness=0.05;\n\tfloat surface=sdf1(p);\n\tfloat onioned=abs(surface)-thickness;\n\tif (onioned>thickness){\n\t\treturn onioned;\n\t}\n\telse if (surface<-thickness){\n\t\treturn surface;\n\t}\n\telse{\n\t\tfloat detail=sdf2(p);\n\t\tfloat dist = max(onioned,detail);\n\t\treturn min(dist,surface);\n\t}\n}\nvec3 onion_color1(vec3 p){\n\tfloat d1 = sdf1(p);\n\tfloat d2 = sdf2(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn vec3(2.0,1.0,0.0);\n\t}\n\telse{\n\t\treturn scale_color1(p);\n\t}\n}\nvec3 sector_color1(vec3 q){\n\tfloat sectorNumber1=round(atan(q.x,q.z)/SECTORSIZE1);\n\tfloat angleOffset1=-sectorNumber1*SECTORSIZE1;\n\tfloat cos1=cos(angleOffset1);\n\tfloat sin1=sin(angleOffset1);\n\tvec3 p=vec3(\n\t\tq.x*cos1+q.z*sin1,\n\tq.y,\n\t\tq.z*cos1-q.x*sin1\n\t);\n\treturn onion_color1(p);\n}\nvec3 rotation_color1(vec3 q){\n\tvec3 p=vec3(q.x,q.y*COSTHETA1+q.z*SINTHETA1,q.z*COSTHETA1+q.y*-SINTHETA1);\n\treturn sector_color1(p);\n}\nvec3 rotation_color2(vec3 q){\n\tfloat cosTheta1=cos(iTime/5.);\n\tfloat sinTheta1=sin(iTime/5.);\n\tvec3 p=vec3(q.x*cosTheta1+q.z*+sinTheta1,q.y,q.z*cosTheta1+q.x*-sinTheta1);\n\treturn rotation_color1(p);\n}\nvec3 translation_color1(vec3 q){\n\tvec3 p=q+vec3(-1.5,-0.0,-0.0);\n\treturn rotation_color2(p);\n}\n\nconst float SCALE2=0.5;\n//Box1\nconst vec3 BOX1=vec3(0.95,0.95,0.95);\nfloat sdf8(vec3 p){\n\tvec3 q4=abs(p)-BOX1;\n\treturn length(max(q4,0.0))+min(max(q4.x,max(q4.y,q4.z)),0.0);\n}\n\n//Mandelbox2\nconst float S2=-2.5;\nconst float R2=0.5;\nconst int ITR2=10;\nconst float F2=1.0;\nfloat sdf5(vec3 p){\n\treturn sdf8(p);\n}\nfloat sdf6(vec3 p){\n\tvec4 q5=vec4(p,1.0);\n\tvec4 c2=vec4(p,1.0);\n    float temp = sin(iTime/7.)*.25;\n    float temp2 = sin(iTime/4.)*.25;\n\tfor (int a2=0;a2<ITR2;a2++){\n\t\tq5.xyz=F2*(clamp(q5.xyz,-1.0,1.0)*2.0-q5.xyz);\n\t\tq5 *=(S2+temp)/clamp(dot(q5.xyz,q5.xyz),R2+temp2,1.0);\n\t\tq5 +=c2;\n\t}\n\treturn .333*length(q5.xyz)/abs(q5.w);\n}\nfloat sdf7(vec3 p){\n\tfloat thickness=0.1;\n\tfloat surface=sdf5(p);\n\tfloat onioned=abs(surface)-thickness;\n\tif (onioned>thickness){\n\t\treturn onioned;\n\t}\n\telse if (surface<-thickness){\n\t\treturn surface;\n\t}\n\telse{\n\t\tfloat detail=sdf6(p);\n\t\tfloat dist = max(onioned,detail);\n\t\treturn min(dist,surface);\n\t}\n}\nvec3 onion_color2(vec3 p){\n\tfloat d1 = sdf5(p);\n\tfloat d2 = sdf6(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn vec3(1.0,1.0,2.0);\n\t}\n\telse{\n\t\treturn vec3(1,1,1);\n\t}\n}\nvec3 scale_color2(vec3 q){\n\tvec3 p=q/SCALE2;\n\treturn onion_color2(p);\n}\nvec3 rotation_color3(vec3 q){\n\tfloat cosTheta2=cos(-iTime/5.);\n\tfloat sinTheta2=sin(-iTime/5.);\n\tvec3 p=vec3(q.x*cosTheta2+q.z*+sinTheta2,q.y,q.z*cosTheta2+q.x*-sinTheta2);\n\treturn scale_color2(p);\n}\nfloat sdf9(vec3 p){\n\tvec3 q1=p+vec3(-1.5,-0.0,-0.0);\n\t//Rotate y axis1\n\tfloat cosTheta1=cos(iTime/5.);\n\tfloat sinTheta1=sin(iTime/5.);\n\tvec3 rot1=vec3(q1.x*cosTheta1+q1.z*+sinTheta1,q1.y,q1.z*cosTheta1+q1.x*-sinTheta1);\n\t//Rotate x axis1\n\tvec3 rot2=vec3(rot1.x,rot1.y*COSTHETA1+rot1.z*SINTHETA1,rot1.z*COSTHETA1+rot1.y*-SINTHETA1);\n\tfloat sectorNumber1=round(atan(rot2.x,rot2.z)/SECTORSIZE1);\n\tfloat angleOffset1=-sectorNumber1*SECTORSIZE1;\n\tfloat cos1=cos(angleOffset1);\n\tfloat sin1=sin(angleOffset1);\n\tvec3 q2=vec3(\n\t\trot2.x*cos1+rot2.z*sin1,\n\trot2.y,\n\t\trot2.z*cos1-rot2.x*sin1\n\t);\n\treturn (sdf3(q2));\n}\nfloat sdf10(vec3 p){\n\t//Rotate y axis2\n\tfloat cosTheta2=cos(-iTime/5.);\n\tfloat sinTheta2=sin(-iTime/5.);\n\tvec3 rot3=vec3(p.x*cosTheta2+p.z*+sinTheta2,p.y,p.z*cosTheta2+p.x*-sinTheta2);\n\tvec3 sp2=rot3/SCALE2;\n\treturn ((sdf7(sp2))*SCALE2);\n}\nvec3 union_color1(vec3 p){\n\tfloat d1 = sdf9(p);\n\tfloat d2 = sdf10(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn translation_color1(p);\n\t}\n\telse{\n\t\treturn rotation_color3(p);\n\t}\n}\n\n//Box2\nconst vec3 BOX2=vec3(100.0,10.0,1.0);\nfloat sdf11(vec3 p){\n\tvec3 q7=abs(p)-BOX2;\n\treturn length(max(q7,0.0))+min(max(q7.x,max(q7.y,q7.z)),0.0);\n}\nvec3 translation_color2(vec3 q){\n\tvec3 p=q+vec3(-0.0,-0.0,-3.0);\n\treturn vec3(1.9,1.9,2.0);\n}\nfloat sdf12(vec3 p){\n\treturn (min(sdf9(p),sdf10(p)));\n}\nfloat sdf13(vec3 p){\n\tvec3 q6=p+vec3(-0.0,-0.0,-3.0);\n\treturn (sdf11(q6));\n}\nvec3 union_color2(vec3 p){\n\tfloat d1 = sdf12(p);\n\tfloat d2 = sdf13(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn union_color1(p);\n\t}\n\telse{\n\t\treturn translation_color2(p);\n\t}\n}\n\nfloat sdf14(vec3 p){\n\tvec3 planeAngleNorm1=vec3(0.0,1.0,0.0);\n\tfloat planeHeight1=1.1;\n\tfloat plane1=dot(p,planeAngleNorm1)+planeHeight1;\n\treturn plane1;\n}\nfloat sdf15(vec3 p){\n\treturn (min(sdf12(p),sdf13(p)));\n}\nfloat sdf16(vec3 p){\n\treturn (sdf14(p));\n}\nvec3 union_color3(vec3 p){\n\tfloat d1 = sdf15(p);\n\tfloat d2 = sdf16(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn union_color2(p);\n\t}\n\telse{\n\t\treturn vec3(1.0,0.9,0.9);\n\t}\n}\n\nconst float SCALE3=0.3;\nconst float SECTORSIZE2=0.31415926536;\nconst float SECTORSIZE3=0.31415926536;\nconst float SECTORSIZE4=0.31415926536;\nconst float COSTHETA2=0.70710677;\nconst float SINTHETA2=0.70710677;\nconst float SCALE4=0.75;\n//Mandelbox3\nconst float S3=-2.5;\nconst float R3=0.5;\nconst int ITR3=10;\nconst float F3=1.0;\nvec3 scale_color3(vec3 q){\n\tvec3 p=q/SCALE4;\n\treturn vec3(1,1,1);\n}\nvec3 rotation_color4(vec3 q){\n\tvec3 p=vec3(q.x,q.y*COSTHETA2+q.z*SINTHETA2,q.z*COSTHETA2+q.y*-SINTHETA2);\n\treturn scale_color3(p);\n}\nvec3 sector_color2(vec3 q){\n\tfloat sectorNumber4=round(atan(q.y,q.x)/SECTORSIZE4);\n\tfloat angleOffset4=-sectorNumber4*SECTORSIZE4;\n\tfloat cos4=cos(angleOffset4);\n\tfloat sin4=sin(angleOffset4);\n\tvec3 p=vec3(\n\t\tq.x*cos4-q.y*sin4,\n\t\tq.y*cos4+q.x*sin4,\n\t\tq.z\n\t);\n\treturn rotation_color4(p);\n}\nvec3 sector_color3(vec3 q){\n\tfloat sectorNumber3=round(atan(q.x,q.z)/SECTORSIZE3);\n\tfloat angleOffset3=-sectorNumber3*SECTORSIZE3;\n\tfloat cos3=cos(angleOffset3);\n\tfloat sin3=sin(angleOffset3);\n\tvec3 p=vec3(\n\t\tq.x*cos3+q.z*sin3,\n\tq.y,\n\t\tq.z*cos3-q.x*sin3\n\t);\n\treturn sector_color2(p);\n}\nvec3 sector_color4(vec3 q){\n\tfloat sectorNumber2=round(atan(q.y,q.x)/SECTORSIZE2);\n\tfloat angleOffset2=-sectorNumber2*SECTORSIZE2;\n\tfloat cos2=cos(angleOffset2);\n\tfloat sin2=sin(angleOffset2);\n\tvec3 p=vec3(\n\t\tq.x*cos2-q.y*sin2,\n\t\tq.y*cos2+q.x*sin2,\n\t\tq.z\n\t);\n\treturn sector_color3(p);\n}\n\nfloat sdf17(vec3 p){\n\tfloat rp1=5.336099999999998;\n\tfloat r1=2.3;\n\tfloat d1;\n\tfloat lp=dot(p,p);\n\tif (lp>rp1){\n\t\td1=sqrt(lp)-r1;\n\t}\n\telse{\n\t\tfloat sectorNumber2=round(atan(p.y,p.x)/SECTORSIZE2);\n\t\tfloat angleOffset2=-sectorNumber2*SECTORSIZE2;\n\t\tfloat cos2=cos(angleOffset2);\n\t\tfloat sin2=sin(angleOffset2);\n\t\tvec3 q9=vec3(\n\t\t\tp.x*cos2-p.y*sin2,\n\t\t\tp.y*cos2+p.x*sin2,\n\t\t\tp.z\n\t\t);\n\t\tfloat sectorNumber3=round(atan(q9.x,q9.z)/SECTORSIZE3);\n\t\tfloat angleOffset3=-sectorNumber3*SECTORSIZE3;\n\t\tfloat cos3=cos(angleOffset3);\n\t\tfloat sin3=sin(angleOffset3);\n\t\tvec3 q10=vec3(\n\t\t\tq9.x*cos3+q9.z*sin3,\n\t\tq9.y,\n\t\t\tq9.z*cos3-q9.x*sin3\n\t\t);\n\t\tfloat sectorNumber4=round(atan(q10.y,q10.x)/SECTORSIZE4);\n\t\tfloat angleOffset4=-sectorNumber4*SECTORSIZE4;\n\t\tfloat cos4=cos(angleOffset4);\n\t\tfloat sin4=sin(angleOffset4);\n\t\tvec3 q11=vec3(\n\t\t\tq10.x*cos4-q10.y*sin4,\n\t\t\tq10.y*cos4+q10.x*sin4,\n\t\t\tq10.z\n\t\t);\n\t\t//Rotate x axis2\n\t\tvec3 rot5=vec3(q11.x,q11.y*COSTHETA2+q11.z*SINTHETA2,q11.z*COSTHETA2+q11.y*-SINTHETA2);\n\t\tvec3 sp4=rot5/SCALE4;\n\t\tvec4 q12=vec4(sp4,1.0);\n\t\tvec4 c3=vec4(sp4,1.0);\n        float temp3=+sin(iTime/4.)*.5;\n\t\tfor (int a3=0;a3<ITR3;a3++){\n\t\t\tq12.xyz=F3*(clamp(q12.xyz,-1.0,1.0)*2.0-q12.xyz);\n\t\t\tq12 *=S3/clamp(dot(q12.xyz,q12.xyz),R3-temp3,1.0);\n\t\t\tq12 +=c3;\n\t\t}\n\t\td1=(.333*length(q12.xyz)/abs(q12.w))*SCALE4;\n\t}\nreturn d1;\n}\n\nfloat sdf18(vec3 p){\n\t//Sphere1\n\tfloat radius1 =1.9;\n\treturn length(p)-radius1;\n}\nfloat sdf19(vec3 p){\n\treturn (sdf17(p));\n}\nfloat sdf20(vec3 p){\n\treturn (sdf18(p));\n}\nvec3 union_color4(vec3 p){\n\tfloat d1 = sdf19(p);\n\tfloat d2 = sdf20(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn sector_color4(p);\n\t}\n\telse{\n\t\treturn vec3(1.0,0.0,0.0);\n\t}\n}\nvec3 scale_color4(vec3 q){\n\tvec3 p=q/SCALE3;\n\treturn union_color4(p);\n}\nvec3 rotation_color5(vec3 q){\n\tfloat cosTheta3=cos(iTime/5.);\n\tfloat sinTheta3=sin(iTime/5.);\n\tvec3 p=vec3(q.x*cosTheta3+q.z*+sinTheta3,q.y,q.z*cosTheta3+q.x*-sinTheta3);\n\treturn scale_color4(p);\n}\nvec3 translation_color3(vec3 q){\n\tvec3 p=q+vec3(1.5,-0.0,-0.0);\n\treturn rotation_color5(p);\n}\nfloat sdf21(vec3 p){\n\treturn (min(sdf15(p),sdf16(p)));\n}\nfloat sdf22(vec3 p){\n\tvec3 q8=p+vec3(1.5,-0.0,-0.0);\n\t//Rotate y axis3\n\tfloat cosTheta3=cos(iTime/5.);\n\tfloat sinTheta3=sin(iTime/5.);\n\tvec3 rot4=vec3(q8.x*cosTheta3+q8.z*+sinTheta3,q8.y,q8.z*cosTheta3+q8.x*-sinTheta3);\n\tvec3 sp3=rot4/SCALE3;\n\treturn ((min(sdf19(sp3),sdf20(sp3)))*SCALE3);\n}\nvec3 union_color5(vec3 p){\n\tfloat d1 = sdf21(p);\n\tfloat d2 = sdf22(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn union_color3(p);\n\t}\n\telse{\n\t\treturn translation_color3(p);\n\t}\n}\nfloat map7(vec3 p){\n\n\treturn min(sdf21(p),sdf22(p));\n}\nvec3 map7_color(vec3 p){\n\n\treturn(union_color5(p));\n}\n\n\n\n\n\n\nfloat map(in vec3 q){\n/*\n    float time = iTime/8.5;\n    //return 1.0;\n    vec3 p=q;\n\n    float lookDown=.2;\n    float cosld=cos(lookDown);\n    float sinld=sin(lookDown);\n    p=vec3(p.x,p.y*cosld+p.z*-sinld,p.z*cosld+p.y*sinld);\n    //p =vec3(\n    //    p.x*cos(time)+p.z*-sin(time),\n    //    p.y\n    //    ,p.z*cos(time)+p.x*sin(time)\n    //);\n    p=p+vec3(0.,-2.+sin(time*2.)*.125,0.);\n    \n    //float ang2 = sin(iTime/4.)*.25;\n    //p = vec3(p.x*cos(ang2)-p.y*sin(ang2),p.y*cos(ang2)+p.x*sin(ang2),p.z);\n\n    float m;\n    float mb=0.;\n\n    bool bound = false;\n   */\n    float m= map7(q)*.95;\n   \n    ///if (calcColor){\n     //   color = map7_color(q);\n    //}\n    \n \n    //m=min(m,q.y+1.8);\n   // m=min(m,-q.z+25.4);\n   \n    \n    return m;\n }\n    \n    \nvec3 map_color(vec3 p){\n    return map7_color(p);\n}\n \n \n    \n\n\nvec3 getSurfaceNormal( in vec3 p, float epsilon ) // for function f(p)\n{\n  \n    return normalize(\n        GLOBAL_PN_XYY*map(p+GLOBAL_PN_XYY_EPS) +\n        GLOBAL_PN_YYX*map(p+GLOBAL_PN_YYX_EPS) +\n        GLOBAL_PN_YXY*map(p+GLOBAL_PN_YXY_EPS) +\n        GLOBAL_PN_XXX*map(p+GLOBAL_PN_XXX_EPS) \n    \n    );\n}\n\n\nvoid rayMarch(\n    in vec3 origin, \n    in vec3 ray, \n    in float epsilon,\n    in float maxSteps,\n  \n    out vec3 marchPoint,\n    out float marchPointDist,\n    out float stepsTaken\n\n\n){\n    \n  \n    \n    stepsTaken = 0.0;\n    marchPoint=origin;\n    float h = map(marchPoint);\n    while (h>epsilon&&stepsTaken++<maxSteps&&h<MAX_DIST){\n        marchPoint+=ray*h;       \n        h=map(marchPoint);\n    }   \n    marchPointDist=h;\n   \n}\n\nfloat softShadowBalanced(vec3 surface, vec3 surfaceToLight, float radius, float maxDist){\n   \n    //return 1.0;\n  \n    //vec3 surfaceToLight = light-surface;\n    float distanceToLight=length(surfaceToLight);\n    float maxDist2 = min(maxDist,distanceToLight);\n    vec3 ray =normalize(surfaceToLight);\n    float artifactCompensation = 1.0;\n    float minDist = 0.05;//think about this.\n    \n    float travelled = minDist;\n    float xx=1.0;\n    while (travelled < maxDist2){\n    \n        float ratioTravelled=travelled/distanceToLight;\n        \n       \n        float relativeRadius=ratioTravelled*radius;\n        \n        float dist=map(surface+ray*travelled);\n         \n        if (dist<-relativeRadius){\n            return 0.0;\n        }\n        float relativeDiameter=relativeRadius*2.0;\n        \n        float dist2=dist+relativeRadius;\n        xx = min(xx,dist2/relativeDiameter);\n        \n       \n        float artifatCompensation2 = artifactCompensation*clamp(relativeRadius/dist,0.,1.);\n        travelled +=max(abs(dist/artifactCompensation),minDist);\n        \n        \n    }\n       \n   return xx;\n    \n\n    \n}\n\nvec3 power(vec3 vec, float power){\n    return vec3(pow(vec.x,power),pow(vec.y,power),pow(vec.z,power));\n}\n\n\nvoid calcLight(\n    in vec3 surfacePoint, \n    in float shineAtPosition,\n    in vec3 lightPosition,\n    in vec3 observationPosition,\n    in vec3 lightColor,\n    in float lightBrightness,\n    in vec3 surfaceNormal,\n    in float epsilon,\n    in float lightRadius,\n    out vec3 diffuse, \n    out vec3 specular){\n    \n \n     \n    vec3 col0 = lightColor;\n    \n    \n    vec3 surfaceToLight=lightPosition-surfacePoint;\n    vec3 normalToLight=normalize(surfaceToLight);\n    \n    float oneOverDistToLightSquared = lightBrightness/dot(surfaceToLight,surfaceToLight);\n    \n    \n    \n    float dp = dot(normalToLight,surfaceNormal);\n \n    dp=max(dp,0.0);\n\n    \n    diffuse=dp*lightColor*oneOverDistToLightSquared;\n    \n    \n    vec3 rayToObs=normalize(observationPosition-surfacePoint);\n    vec3 avg = normalize(normalToLight+rayToObs);\n    float spec = dot(avg,surfaceNormal);\n    spec = max(spec,0.0);\n    \n    spec = pow(spec,shineAtPosition);\n\n    specular=lightColor*spec*oneOverDistToLightSquared;\n    \n    float shadowAdjust = 1.0;\n    \n\n    if (true){\n        float s = softShadowBalanced(surfacePoint,surfaceToLight,lightRadius, 500.); \n        diffuse*=s*shadowAdjust;\n        specular*=s*shadowAdjust;\n    }\n \n}\n\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    \n    vec3 lense = vec3(0.0,0.0,1.);\n    \n    \n    vec3 cameraPosition = vec3(0.,2.5,-5);//.+sin(iTime/10.));\n    float specAmt = 0.0;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float epsilon1 = .00125;\n    \n   \n    \n  \n    vec2 ar = (fragCoord/iResolution.x)\n        -vec2(.5,iResolution.y/(2.0*iResolution.x));\n        \n    vec3 lenseIntersection = vec3(ar,lense.z);\n    \n    vec3 ray = normalize(lenseIntersection);//-eye);\n   \n    float lookDown=.09;\n    float cosld=cos(lookDown);\n    float sinld=sin(lookDown);\n   \n    ray = vec3(ray.x,ray.y*cosld+ray.z*-sinld,ray.z*cosld+ray.y*sinld);\n   \n    \n    float stepsTaken;\n    vec3 finalPosition;\n    float finalDistance;\n\n    float maxSteps = 200.0;\n    \n    \n   \n    \n    float time = iTime/8.5;\n\n    vec3 p=cameraPosition+ray;\n\n  \n    p=p+vec3(0.,-2.+sin(time*2.)*.125,0.);\n    \n \n\n    float m;\n    float mb=0.;\n\n    bool bound = false;\n    /////////////\n    \n    rayMarch(p,ray,epsilon1,maxSteps,finalPosition,finalDistance,stepsTaken);\n    \n    vec3 objColor= map_color(finalPosition);\n\n    \n    float objectShine=14.;\n    \n    \n    vec3 diffuse1;\n    vec3 specular1;\n\n    vec3 diffuse2;\n    vec3 specular2;\n\n    vec3 diffuse3;\n    vec3 specular3;\n\n    vec3 diffuse4;\n    vec3 specular4;\n    \n    if (finalDistance<epsilon1){\n    \n\n        finalPosition = finalPosition+(ray*epsilon1*-2.0);\n        vec3 normal = getSurfaceNormal(finalPosition,epsilon1);\n        \n       \n        \n        float lightBrightness = 1200.;\n        float specMult = 2.0;\n        \n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(40.0,30.0,-40.0),//lightposition\n            cameraPosition,//observation position\n            vec3(1.,.9,.8),//light color\n            lightBrightness*2.,//light bright\n       \n            normal,\n            epsilon1,\n            1.,\n            diffuse1,\n            specular1\n        );\n        \n        /*\n         calcLight(\n            finalPosition,\n            objectShine,\n            vec3(-30.0,40.0,-40.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.7,.325,0.)*.5,//light color\n            lightBrightness*1.5,//light bright\n            normal,\n            epsilon1,\n            1.,\n            diffuse2,\n            specular2\n        );\n        \n        \n        \n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(0.0,30.0,-40.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(.35,1.5,.4)*.5,//light color\n            lightBrightness*.75,//light bright\n            normal,\n            epsilon1,\n            .5,\n            diffuse3,\n            specular3\n        );\n        */\n        /*\n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(130.0,30.0,-480.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.,.9,.3)*.5,//light color\n            lightBrightness*5.,//light bright\n            normal,\n            epsilon1,\n            diffuse3,\n            specular3\n        );\n        */\n        \n        \n        /*\n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(0.0,10.0,-5.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.,.8,.5)*.5,//light color\n            lightBrightness/20000.,//light bright\n            normal,\n            epsilon1,\n            diffuse4,\n            specular4\n        );\n    */\n    \n    \n        \n    \n        vec3 col1=objColor*max(diffuse1,0.0);\n        col1+=specular1*specMult;\n        \n        vec3 col2=objColor*max(diffuse2,0.0);\n        col2+=specular2*specMult;\n        \n        vec3 col3=objColor*max(diffuse3,0.0);\n        col3+=specular3*specMult;\n        \n      \n        vec3 colFinal = min(col1+col2+col3,1.);\n        colFinal=power(colFinal,.9);\n        \n     \n        \n        colFinal = pow(colFinal,vec3(.75,.74,.73));\n        \n        fragColor = vec4(colFinal,1.0);\n        \n    }\n    else{\n        fragColor = vec4(.2,0,0,1.0);\n\n    }\n    \n\n    \n    \n}\n\nvoid AntiAlias3( out vec4 fragColor, in vec2 fragCoord, float aaLevel){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float subPixel = 1.0/aaLevel;\n    vec4 result = vec4(0,0,0,1);\n    for (float x=fragCoord.x;x<fragCoord.x+1.0;x+=subPixel){\n        for (float y=fragCoord.y;y<fragCoord.y+1.0;y+=subPixel){\n            vec4 temp;\n            mainImage1(temp,vec2(x,y));\n            result+=temp;\n        }\n    }\n    \n    \n    fragColor = result/(aaLevel*aaLevel);\n   \n    \n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord){\n\n    //vec4 result = vec4(0,0,0,1);\n    //mainImage1(result,fragCoord);\n    //fragColor=result;\n\n    if (HW_PERFORMANCE!=0){\n        AntiAlias3(fragColor, fragCoord,2.);\n    }\n    else{\n        vec4 result = vec4(0,0,0,1);\n        mainImage1(result,fragCoord);\n        fragColor=result;\n     }\n\n    fragColor.xyz = pow(fragColor.xyz,vec3(1.2,1.,.8));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[878, 878, 897, 907, 1038], [1157, 1157, 1183, 1183, 1224], [1225, 1225, 1244, 1244, 1263], [1264, 1264, 1283, 1283, 1581], [1582, 1582, 1601, 1601, 1885], [1886, 1886, 1912, 1912, 2046], [2047, 2047, 2074, 2074, 2331], [2332, 2332, 2361, 2361, 2465], [2466, 2466, 2495, 2495, 2666], [2667, 2667, 2699, 2699, 2761], [2832, 2832, 2851, 2851, 2938], [3033, 3033, 3052, 3052, 3071], [3072, 3072, 3091, 3091, 3399], [3400, 3400, 3419, 3419, 3702], [3703, 3703, 3729, 3729, 3859], [3860, 3860, 3886, 3886, 3931], [3932, 3932, 3961, 3961, 4131], [4132, 4132, 4151, 4151, 4737], [4738, 4738, 4758, 4776, 4977], [4978, 4978, 5004, 5004, 5146], [5193, 5193, 5213, 5213, 5300], [5301, 5301, 5333, 5333, 5394], [5395, 5395, 5415, 5415, 5450], [5451, 5451, 5471, 5471, 5527], [5528, 5528, 5554, 5554, 5694], [5696, 5696, 5716, 5716, 5851], [5852, 5852, 5872, 5872, 5908], [5909, 5909, 5929, 5929, 5951], [5952, 5952, 5978, 5978, 6114], [6443, 6443, 6469, 6469, 6510], [6511, 6511, 6540, 6540, 6643], [6644, 6644, 6671, 6671, 6932], [6933, 6933, 6960, 6960, 7218], [7219, 7219, 7246, 7246, 7505], [7507, 7507, 7527, 7527, 8831], [8833, 8833, 8853, 8864, 8914], [8915, 8915, 8935, 8935, 8957], [8958, 8958, 8978, 8978, 9000], [9001, 9001, 9027, 9027, 9164], [9165, 9165, 9191, 9191, 9236], [9237, 9237, 9266, 9266, 9434], [9435, 9435, 9467, 9467, 9528], [9529, 9529, 9549, 9549, 9585], [9586, 9586, 9606, 9606, 9877], [9878, 9878, 9904, 9904, 10044], [10045, 10045, 10064, 10064, 10099], [10100, 10100, 10124, 10124, 10153], [10160, 10160, 10181, 10730, 10907], [10918, 10918, 10941, 10941, 10969], [10981, 10981, 11053, 11053, 11287], [11290, 11290, 11476, 11476, 11721], [11723, 11723, 11812, 11880, 12837], [12839, 12839, 12873, 12873, 12944], [12947, 12947, 13255, 13255, 14157], [14160, 14160, 14218, 14218, 18323], [18325, 18325, 18396, 18396, 18802], [18804, 18804, 18860, 18956, 19213]], "test": "error"}
{"id": "ftlXWB", "name": "The Phantom Zone", "author": "P_Malin", "description": "A silly webcam filter I made for zoom etc. for use with Memix.", "tags": ["zoom", "memix"], "likes": 14, "viewed": 314, "published": "Public API", "date": "1626719607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The Phantom Zone\n// by @P_Malin\n// https://www.shadertoy.com/view/ftlXWB\n\n// A silly shader designed to work with Memix https://www.memix.app/\n// Save the shader as %LOCALAPPDATA%\\Beautypi\\Memix\\shader.txt\n\n// https://github.com/pmalin/pmalin-memix-shaders\n\n// Thanks for the following:\n// Dave Hoskins - hash function from https://www.shadertoy.com/view/4djSRW\n// iq - soft shadow from https://www.shadertoy.com/view/lsKcDD \n// iq - box intersection from https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n// iq - smooth min from https://www.iquilezles.org/www/articles/smin/smin.htm\n\n// Also see a similar shader from dean_the_coder: https://www.shadertoy.com/view/Wd2fzV\n\n#define RAYMARCH_ITER 32\n#define MAX_RAYMARCH_DIST 70.0\n#define SHADOW_STEPS 16\n\n\nvec3 boxDimensions = vec3(1,1,0.02);\nvec3 glassColour = vec3( 0.6, 0.84, 0.9 );\nfloat glassDensity = 40.0;\n\nvec3 sunDir = normalize(vec3(0.3, 0.5, -0.2));\nvec3 sunColor = vec3(1, 0.95, 0.9) * 1.7;\nvec3 ambientColor = vec3(0.3, 0.7, 1.0) * 1.0;\n\nfloat fogDensity= 0.00005;\nfloat fogHeightFalloff = 1.0;\n\nfloat sliceBegin = -3.5f;\nfloat sliceHeight = 1.0f;\n\n#define PI 3.1415925654\n\nvec3 RotateX( vec3 pos, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec3( pos.x, c * pos.y + s * pos.z, -s * pos.y + c * pos.z);\n}\n\nvec3 RotateY( vec3 pos, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec3( c * pos.x + s * pos.z, pos.y, -s * pos.x + c * pos.z);\n}\n\nvec3 RotateZ( vec3 pos, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec3( c * pos.x + s * pos.y, -s * pos.x + c * pos.y, pos.z);\n}\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct CameraState\n{\n    vec3 pos;\n    vec3 target;\n    vec3 up;\n};\n\nmat3 GetCameraMatrix( CameraState cameraState )\n{\n    vec3 zDir = normalize(cameraState.target - cameraState.pos);    \n    vec3 xDir = normalize( cross( cameraState.up, zDir ) );\n    vec3 yDir = normalize( cross( zDir, xDir ) );\n    \n    mat3 mat = mat3( xDir, yDir, zDir );\n    \n    return mat;\n}\n\nRay GetCameraRay( vec2 coord, CameraState cameraState )\n{\n    vec3 viewDir = normalize(vec3( coord.xy, 1.0f ));\n    \n    mat3 mat = GetCameraMatrix( cameraState );\n    \n    Ray ray = Ray( cameraState.pos, mat * viewDir );\n    \n    return ray;\n}\n\n#define MAT_NONE -1\n#define MAT_DEFAULT 0\n#define MAT_QUAD 1\n\n\n// hash from https://www.shadertoy.com/view/4djSRW\n// Hash without Sine\n// by Dave_Hoskins\n\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nfloat SmoothNoise( vec2 o ) \n{\n\t//vec2 p = floor(o);\n\tvec2 f = fract(o);\n    vec2 p = o-f;\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = hash11(n+  0.0);\n\tfloat b = hash11(n+  1.0);\n\tfloat c = hash11(n+ 57.0);\n\tfloat d = hash11(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat CircleBomb( vec2 pos, float range )\n{   \n    float dist = MAX_RAYMARCH_DIST;\n    for(float yo=-range; yo<=range; yo+=1.0)\n    {\n        for(float xo=-range; xo<=range; xo+=1.0)\n        {\n            vec2 cellPos = pos + vec2(xo,yo);\n            vec2 cellIndex = floor(cellPos);\n            \n            vec3 hash = hash32( cellIndex );\n            \n            vec2 circleOffset = hash.xy * 0.5;\n            \n            vec2 circlePos = cellIndex + 0.5 + circleOffset;\n            \n            float circleRadius = hash.z * 0.5;\n            float circleDist = length( circlePos - pos ) - circleRadius;\n            \n            if ( circleDist < dist )\n            {\n                dist = circleDist;\n            }\n        }\n    }\n    \n    return dist;\n}\n\nfloat GetSlice( float h )\n{\n    return floor( (h-sliceBegin) / sliceHeight );\n}\n\nstruct RaymarchResult\n{\n\tfloat dist;\n\tint objectId;\n    vec3 uvw;\n};\n\nRaymarchResult Scene_GetDistance( vec3 pos );\n\nRaymarchResult Scene_Raymarch( Ray ray, float minDist, float maxDist )\n{\t\n    RaymarchResult result;\n    result.dist = 0.0;\n    result.uvw = vec3(0.0);\n    result.objectId = MAT_NONE;\n    \n\tfloat t = minDist;\n    \n\tfor(int i=0; i<RAYMARCH_ITER; i++)\n\t{\t\t\n        float epsilon = 0.000001 * t;\n\t\tresult = Scene_GetDistance( ray.pos + ray.dir * t );\n        if ( abs(result.dist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.objectId = MAT_NONE;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.dist > 1.0 )\n        {\n            result.objectId = MAT_NONE;\n        }    \n        \n        t += result.dist; \n\t}\n    \n    result.dist = max( t, minDist );\n\n\n    return result;\n}\n\n\nRaymarchResult Scene_Union( RaymarchResult a, RaymarchResult b )\n{\n    if ( b.dist < a.dist )\n    {\n        return b;\n    }\n    return a;\n}\n\nvec3 Scene_GetNormal(vec3 pos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal =\n        Scene_GetDistance( e.yxx * fDelta + pos ).dist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + pos ).dist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + pos ).dist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + pos ).dist * e.yyy;\n    \n    return normalize( vNormal );\n} \n\nstruct TraceResult\n{\n\tfloat dist;\n\tint objectId;\n    vec3 uvw;\n    vec3 pos;    \n    vec3 normal;\n};\n\nvec3 BoxDomainRotate( vec3 pos );\nvec3 BoxDomainInvRotate( vec3 pos );\n\n\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n// axis aligned box centered at the origin, with size boxSize\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n\nTraceResult Scene_Raytrace( Ray ray, float minDist, float maxDist )\n{\n    TraceResult result;\n    \n    result.dist = MAX_RAYMARCH_DIST;\n    result.objectId = MAT_NONE;\n\n    vec3 boxRayDir = BoxDomainRotate( ray.dir );\n    vec3 boxRayPos = BoxDomainRotate( ray.pos );    \n\n    vec2 t = boxIntersection( boxRayPos, boxRayDir, boxDimensions, result.normal);\n\n    result.normal = BoxDomainInvRotate( result.normal );\n\n    result.uvw = (boxRayPos + boxRayDir * t.x);\n\n    if ( t.x  >= 0.0 )\n    {\n        result.dist = t.x;\n        result.objectId = MAT_QUAD;\n    }\n    \n    return result;\n}\n\n\nTraceResult Scene_Trace( Ray ray, float minDist, float maxDist )\n{\n    TraceResult result;    \n\n    TraceResult raytraceResult = Scene_Raytrace( ray, minDist, maxDist );\n        \n    if (ray.dir.y >= 0.0 )\n    {\n        result.dist = MAX_RAYMARCH_DIST;\n        result.objectId = MAT_NONE;\n        result.normal = -ray.dir;\n        result.uvw = vec3(0);\n        result.pos = ray.pos + ray.dir * result.dist;\n    }\n    else\n    {\n        float yStart = sliceBegin;\n        \n        float t = (yStart - ray.pos.y) / ray.dir.y;\n        \n        if ( t > minDist )\n        {\n            minDist = t;\n        }\n        \n        RaymarchResult raymarchResult;\n        \n        raymarchResult = Scene_Raymarch( ray, minDist, maxDist );        \n\n        result.dist = raymarchResult.dist;\n        result.objectId = raymarchResult.objectId;\n        result.uvw = raymarchResult.uvw;\n        result.pos = ray.pos + ray.dir * result.dist;\n        result.normal = Scene_GetNormal( result.pos );     \n        \n    }\n        \n    if ( raytraceResult.dist < result.dist )\n    {\n        result.dist = raytraceResult.dist;\n        result.objectId = raytraceResult.objectId;\n        result.uvw = raytraceResult.uvw;\n        result.pos = ray.pos + ray.dir * result.dist;\n        result.normal = raytraceResult.normal;             \n    }\n\n    return result;\n}\n\nfloat Scene_TraceShadow( Ray ray, float minDist, float lightDist )\n{\n    // Soft Shadow Variation\n    // https://www.shadertoy.com/view/lsKcDD    \n    // based on Sebastian Aaltonen's soft shadow improvement\n    \n\tfloat res = 1.0;\n    float t = minDist;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n        \n    for( int i=0; i<SHADOW_STEPS; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( ray.pos + ray.dir * t ).dist;\n\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res < 0.0001 || t > lightDist ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( Ray ray )\n{\n    float occlusion = 0.0;\n    float scale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.05*float(i)/4.0;\n        vec3 AOPos = ray.dir * fOffsetDist + ray.pos;\n        float dist = Scene_GetDistance( AOPos ).dist;\n        occlusion += (fOffsetDist - dist) * scale;\n        scale *= 0.46;\n    }\n    \n    return clamp( 1.0 - 30.0*occlusion, 0.0, 1.0 );\n}\n\nstruct SurfaceInfo\n{\n    vec3 pos;\n    vec3 normal;\n    vec3 albedo;\n    vec3 r0;\n    float gloss;\n    vec3 emissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( Ray ray, TraceResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 diffuse;\n    vec3 specular;\n};\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat AlphaSqrFromGloss( float gloss )\n{\n\tfloat MAX_SPEC = 10.0;\n\treturn 2.0f  / ( 2.0f + exp2( gloss * MAX_SPEC) );\n}\n    \nvoid Light_Add( inout SurfaceLighting lighting, SurfaceInfo surface, vec3 viewDir, vec3 lightDir, vec3 lightColour )\n{\n\tfloat NDotL = clamp(dot(lightDir, surface.normal), 0.0, 1.0);\n\t\n\tlighting.diffuse += lightColour * NDotL;\n\n    if ( surface.gloss > 0.0 )\n    {\n        vec3 H = normalize( -viewDir + lightDir );\n        float NdotV = clamp(dot(-viewDir, surface.normal), 0.0, 1.0);\n        float NdotH = clamp(dot(surface.normal, H), 0.0, 1.0);\n\n        // D\n\n        float alphaSqr = AlphaSqrFromGloss( surface.gloss );\n        float alpha = sqrt( alphaSqr );\n        float denom = NdotH * NdotH * (alphaSqr - 1.0) + 1.0;\n        float d = alphaSqr / (PI * denom * denom);\n\n        float k = alpha / 2.0;\n        float vis = Light_GIV( NDotL, k ) * Light_GIV( NdotV, k );\n\n        float specularIntensity = d * vis * NDotL;    \n        lighting.specular += lightColour * specularIntensity;    \n    }\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, vec3 viewDir, vec3 lightDir, vec3 lightColour)\n{\t\n\tfloat attenuation = 1.0;\n    Ray shadowRay;\n    shadowRay.pos = surface.pos + surface.normal * 0.001;\n    shadowRay.dir = lightDir;\n\tfloat shadowFactor = Scene_TraceShadow( shadowRay, 0.01, 10.0 );\n\t\n\tLight_Add( lighting, surface, viewDir, lightDir, lightColour * shadowFactor * attenuation);\n}\n\nSurfaceLighting Scene_GetSurfaceLighting( Ray ray, SurfaceInfo surfaceInfo );\n\nvec3 Env_GetSkyColor( Ray ray );\n\nvec3 Light_GetFresnel( vec3 view, vec3 normal, vec3 r0, float gloss )\n{\n    float NdotV = max( 0.0, dot( view, normal ) );\n\n    return r0 + (vec3(1.0) - r0) * pow( 1.0 - NdotV, 5.0 ) * pow( gloss, 20.0 );\n}\n\nvec3 Env_ApplyAtmosphere( vec3 colour, Ray ray, float dist );\n\n\nvec3 Scene_GetColour( Ray ray )\n{\n\tvec3 resultColor = vec3(0.0);\n            \n\tTraceResult firstTraceResult;\n    \n    float startDist = 0.0f;\n    float maxDist = MAX_RAYMARCH_DIST;\n    \n    vec3 remaining = vec3(1.0);\n    \n\tfor( int passIndex=0; passIndex < 2; passIndex++ )\n    {\n    \tTraceResult traceResult = Scene_Trace( ray, startDist, maxDist );\n\n        if ( passIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 colour = vec3(0);\n        vec3 reflectAmount = vec3(0);\n        \n\t\tif( traceResult.objectId < 0 )\n\t\t{\n            colour = Env_GetSkyColor( ray );\n\t\t\tcolour = Env_ApplyAtmosphere( colour, ray, traceResult.dist );\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( ray, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( ray, surfaceInfo );\n                \n            if ( surfaceInfo.gloss <= 0.0 )\n            {\n                reflectAmount = vec3(0.0);\n            }\n            else\n            {\n                // calculate reflectance (Fresnel)\n                reflectAmount = Light_GetFresnel( -ray.dir, surfaceInfo.normal, surfaceInfo.r0, surfaceInfo.gloss );            \n            }\n\t\t\t\n\t\t\tcolour = (surfaceInfo.albedo * surfaceLighting.diffuse + surfaceInfo.emissive) * (vec3(1.0) - reflectAmount); \n            \n            vec3 reflectRayOrigin = surfaceInfo.pos;\n            vec3 reflectRayDir = normalize( reflect( ray.dir, surfaceInfo.normal ) );\n            startDist = 0.001 / max(0.0000001,abs(dot( reflectRayDir, surfaceInfo.normal ))); \n\n            colour += surfaceLighting.specular * reflectAmount;            \n\n\t\t\tcolour = Env_ApplyAtmosphere( colour, ray, traceResult.dist );\n            \n            ray.pos = reflectRayOrigin;\n            ray.dir = reflectRayDir;\n        }\n        \n        resultColor += colour * remaining;\n        remaining *= reflectAmount;                \n        \n        if ( (remaining.x + remaining.y + remaining.z) < 0.01 )\n        {\n            break;\n        }            \n    }\n \n    return vec3( resultColor );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 BoxDomainRotate( vec3 pos )\n{\n    pos = RotateX( pos, iTime );\n    pos = RotateZ( pos, 0.5 );\n    \n    return pos;\n}\n\nvec3 BoxDomainInvRotate( vec3 pos )\n{\n    pos = RotateZ( pos, -0.5 );\n    pos = RotateX( pos, -iTime );\n    \n    return pos;\n}\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nRaymarchResult Scene_GetDistance( vec3 pos )\n{\n    RaymarchResult landscapeResult;\n    landscapeResult.dist = 100000.0;\n    landscapeResult.uvw = pos.xzy;\n    landscapeResult.objectId = MAT_DEFAULT;\n    \n    \n    vec3 landscapeDomain = pos + vec3(30.3,0,iTime);\n    \n    float scale = 10.0;\n    \n    float circleDist = CircleBomb(landscapeDomain.xz / scale, 2.0) * scale;\n\n    circleDist -= CircleBomb(landscapeDomain.xz * 3.0, 1.0) * 0.3;\n\n    float bump = SmoothNoise(landscapeDomain.xz * 5.0) * 0.1;\n\n    float sliceCount = 2.0;\n\n    for ( float slice = 0.0; slice >= -(sliceCount-1.0); slice -= 1.0 )\n    {\n        float sliceDist = circleDist + (slice) * .1 * scale - 1.0;    \n            \n        float sliceY = -slice * slice * sliceHeight + sliceBegin - bump; \n    \n        sliceDist = -sminCubic( -sliceDist, (sliceY - landscapeDomain.y), 0.5 );\n            \n        landscapeResult.dist = sminCubic( landscapeResult.dist, sliceDist, 0.5 );\n    }\n    \n    landscapeResult.dist = sminCubic( landscapeResult.dist, pos.y - (-sliceCount * sliceHeight + sliceBegin) - bump, 0.5 );    \n    \n    RaymarchResult result = landscapeResult;\n\n\n    return result;\n}\n\nSurfaceInfo Scene_GetSurfaceInfo( Ray ray, TraceResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.pos = traceResult.pos;\n    surfaceInfo.normal = traceResult.normal;\n    \n    surfaceInfo.albedo = vec3(1.0);\n    surfaceInfo.r0 = vec3( 0.02 );\n    surfaceInfo.gloss = 0.0;\n    surfaceInfo.emissive = vec3( 0.0 );\n        \n    if ( traceResult.objectId == MAT_DEFAULT )\n    {\n        surfaceInfo.albedo = vec3(0.95, 0.95, 0.95); \n\t    surfaceInfo.gloss = 0.0;\n    \tsurfaceInfo.r0 = vec3( 0.02 );\n    }\n    \n    if ( traceResult.objectId == MAT_QUAD )\n    {\n        surfaceInfo.albedo = vec3(0);\n\t    surfaceInfo.gloss = 0.9;\n    \tsurfaceInfo.r0 = vec3( 0.02 );\n        \n        \n        vec3 dir = refract( ray.dir, surfaceInfo.normal, 1.0 / 1.33 );\n        \n        vec3 boxRayDir = BoxDomainRotate( normalize( dir ) ) / (boxDimensions);\n        vec3 boxRayPos = traceResult.uvw / (boxDimensions);\n\n        vec3 h = -(boxRayPos - sign(boxRayDir)) / boxRayDir;\n        float t = min(min(h.x, h.y), h.z);\n        \n        vec3 p = boxRayPos + boxRayDir * t;\n\n\n        vec2 uv = p.xy;\n        float d = length( boxRayDir * t * boxDimensions );\n        \n        uv = uv * 0.5 + 0.5;\n        \n        ivec2 tSize = textureSize(iChannel0, 0);\n        uv = uv - 0.5;\n        if ( tSize.x > tSize.y )\n        {\n            uv.x *= float(tSize.y) / float(tSize.x);\n        }\n        else\n        {\n            uv.y *= float(tSize.x) / float(tSize.y);\n        }\n        uv = uv + 0.5;\n        \n        vec3 emissiveSample = texture( iChannel0, uv ).rgb;\n        surfaceInfo.emissive = emissiveSample * emissiveSample;\n\n        surfaceInfo.emissive *= exp( -d * (1.0 - glassColour) * glassDensity );                      \n    }   \n    \n    return surfaceInfo;    \n}\n\nvec3 Env_GetSkyColor( Ray ray )\n{\n    return vec3(0.0);\n}\n\nSurfaceLighting Scene_GetSurfaceLighting( Ray ray, SurfaceInfo surfaceInfo )\n{   \n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.diffuse = vec3(0.0);\n    surfaceLighting.specular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, ray.dir, sunDir, sunColor );\n    \n    \n    Ray aoRay;\n    aoRay.pos = surfaceInfo.pos;\n    aoRay.dir = surfaceInfo.normal;\n    float fAO = Scene_GetAmbientOcclusion(aoRay);    \n    surfaceLighting.diffuse += fAO * (surfaceInfo.normal.y * 0.5 + 0.5) * ambientColor;\n    \n    return surfaceLighting;\n}\n\nfloat Env_GetFogFactor( Ray ray, float dist )\n{    \n\n    float fogAmount = fogDensity * exp(-ray.pos.y*fogHeightFalloff) * (1.0-exp(-dist*ray.dir.y*fogHeightFalloff ))/ray.dir.y;\n    \n\treturn exp(dist * -fogAmount);\t    \n}\n\nvec3 Env_GetFogColour(Ray ray)\n{    \n\treturn vec3(0.1, 0.35, 0.9);\n}\n\nvec3 Env_ApplyAtmosphere( vec3 colour, Ray ray, float dist )\n{\n    vec3 result = colour;\n        \n\tfloat fogFactor = Env_GetFogFactor( ray, dist );\n\tvec3 fogColor = Env_GetFogColour( ray );\n    result = mix( fogColor, result, fogFactor );\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 coord = uv - 0.5;\n    coord.x *= iResolution.x / iResolution.y;\n    \n    CameraState camera;\n\n    camera.pos = vec3(0,-0.3,-3);\n    camera.target = vec3(0,0.1,0);\n    camera.up = vec3(0,1,0);\n\n    camera.pos = RotateY( camera.pos, sin(iTime * 0.1) * 0.3 );\n    \n    camera.pos *= (sin( iTime * 0.234 ) * 0.5 + 0.5) * 1.0 + 1.0;\n    \n    Ray ray = GetCameraRay( coord, camera );\n    \n    vec3 sceneColour = Scene_GetColour( ray );\n    \n    vec3 colour = sceneColour;\n    \n    colour = 1.0f - exp( -colour * 1.0 );\n    \n    colour = pow( colour, vec3(1.0f / 2.2f) );\n    \n    fragColor = vec4(colour, 1.0f);\n}\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1160, 1160, 1199, 1199, 1330], [1332, 1332, 1371, 1371, 1502], [1504, 1504, 1543, 1543, 1674], [1790, 1790, 1839, 1839, 2087], [2089, 2089, 2146, 2146, 2333], [2490, 2509, 2532, 2532, 2617], [2619, 2638, 2659, 2659, 2795], [2798, 2798, 2828, 2850, 3212], [3214, 3214, 3257, 3257, 3975], [3977, 3977, 4004, 4004, 4056], [4175, 4175, 4247, 4247, 4952], [4955, 4955, 5021, 5021, 5094], [5096, 5096, 5128, 5128, 5515], [5693, 5828, 5911, 5911, 6389], [6392, 6392, 6461, 6461, 6978], [6981, 6981, 7047, 7047, 8318], [8320, 8320, 8388, 8527, 9207], [9209, 9209, 9253, 9253, 9640], [9905, 9905, 9945, 9945, 9995], [9997, 9997, 10037, 10037, 10115], [10121, 10121, 10239, 10239, 11026], [11028, 11028, 11155, 11155, 11452], [11567, 11567, 11638, 11638, 11773], [11839, 11839, 11872, 11872, 13974], [13976, 13976, 14007, 14007, 14098], [14100, 14100, 14134, 14134, 14221], [14223, 14223, 14260, 14260, 14349], [14351, 14444, 14490, 14490, 14576], [14578, 14578, 14624, 14624, 15739], [15741, 15741, 15811, 15811, 17516], [17518, 17518, 17551, 17551, 17575], [17577, 17577, 17655, 17655, 18148], [18150, 18150, 18197, 18197, 18372], [18374, 18374, 18406, 18406, 18442], [18444, 18444, 18506, 18506, 18704], [18706, 18706, 18763, 18763, 19425]], "test": "error"}
{"id": "ftlXWl", "name": "Lambertian Microsphere BRDF", "author": "AndrewHelmer", "description": "Implementation of the fast version of Eugeon d'Eon's paper: \"An analytic BRDF for materials with spherical Lambertian scatterers\"\nMeant to replicate the figures from the paper. Left sphere is Lambert BRDF, right sphere is new BRDF.", "tags": ["brdf", "spherical", "lambertian", "deon"], "likes": 25, "viewed": 518, "published": "Public", "date": "1626813141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Implementation of fast BRDF from\n// \"An analytic BRDF for materials with spherical Lambertian scatterers\" \n// (d'Eon 2021, winner of EGSR Best Paper)\n// https://developer.nvidia.com/blog/nvidia-research-an-analytic-brdf-for-materials-with-spherical-lambertian-scatterers/\nconst vec3 lightCol = vec3(1.0, 1.0, 1.0);\nconst float PI = 3.141592653589;\nconst vec3 kd = vec3(0.5, 0.25, 0.12);  // Diffuse color parameterization.\nconst vec3 c = (1.0 - pow(1.0 - kd, vec3(2.73556))) / (1.0 - 0.184096*pow(1.0 - kd, vec3(2.48423)));\nconst float whitePoint = 1.0;\n\n// From https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code.\nfloat intersectSphere(vec3 ro, vec3 rd, vec3 center, float rad) {\n    ro -= center;\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - rad*rad;\n    if (c > 0.0f && b > 0.0) return -1.0;\n    float discr = b*b - c;\n    if (discr < 0.0) return -1.0;\n    // Special case: inside sphere, use far discriminant\n    if (discr > b*b) return (-b + sqrt(discr));\n    return -b - sqrt(discr);\n}\n\nfloat safeacos(const float x) {\n    return acos(clamp(x, -1.0, 1.0));\n}\n\nfloat phase(float u) {\n    return (2.0*(sqrt(1.0 - u*u) - u*acos(u)))/(3.0*PI*PI);\n}\n\nvec3 shadeLambertianSphereBRDF(vec3 wi, vec3 wo, vec3 norm) { \n    float ui = dot(wi, norm);\n    float uo = dot(wo, norm);\n    if (ui <= 0.0 || uo <= 0.0) return vec3(0.0);\n    \n    float ui2 = ui*ui;\n    float uo2 = uo*uo;\n    float S = sqrt((1.0-ui2)*(1.0-uo2));\n    float cp = -((-dot(wi, wo) + ui*uo)/S);\n    float phi = safeacos(cp);\n    float iodot = dot(wi, wo);\n    \n    // Single-Scattering component, corresponds to \"f_1\" in the paper.\n    vec3 SS = c*(phase(-iodot) / (ui + uo));\n    \n    // These next two blocks are identical. The first block is a copy of the implementation from\n    // https://github.com/eugenedeon/mitsuba/blob/master/src/bsdfs/lambert_sphere_fast.cpp\n    // The second block is a literal coding of Equation 48 from the paper.\n#if 1\n    float p = ui * uo;\n    return PI * uo * max(\n        vec3(0.0), \n        0.995917*SS+(0.0684744*(((phi+sqrt(p))*(-0.249978+c)/(4.50996*((safeacos(S)/S)+0.113706)))+pow(max(1.94208*kd,0.0),vec3(1.85432))))\n    );\n    \n#else\n    vec3 fr = max( \n        vec3(0.0), \n        SS + 0.234459*pow(kd, vec3(1.85432)) \\\n           + (0.0151829*(c-0.24998)*(abs(phi)+sqrt(ui*uo))) / (0.113706 + (safeacos(S)/S))\n    );\n    return PI * uo * fr;\n#endif\n}\n\nvec3 shadeLambertBRDF(vec3 wi, vec3 wo, vec3 norm) {\n    return kd * (lightCol * clamp(dot(norm, wo), 0.0, 1.0));\n}\n\nvec3 adjustExposureGamma(vec3 col) {\n    col /= whitePoint;\n    col = pow(col, vec3(1.0/2.2));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    vec3 rayDir = vec3(0.0, 0.0, -1.0);\n    vec3 rayOrigin = vec3(2.0*xy*vec2((iResolution.x / iResolution.y), 1.0), 10.0);\n    \n    float lightAngle = PI*(iTime/5.0 + 0.5);\n    vec3 lightPos = vec3(-cos(lightAngle)*10.0, 0.0, sin(lightAngle)*10.0);\n    \n    vec3 center = vec3(1.5, 0.0, 0.0);\n    float rad = 1.3;\n    float t = intersectSphere(rayOrigin, rayDir, center, rad);\n    if (t >= 0.0) {\n        vec3 position = rayOrigin+t*rayDir;\n        vec3 norm = normalize(position-center);\n        vec3 offsetLightPos = lightPos+center;\n        vec3 lightDir = normalize(offsetLightPos-position);\n        \n        vec3 col = shadeLambertianSphereBRDF(-rayDir, lightDir, norm);\n        fragColor = vec4(adjustExposureGamma(col), 1.0);\n        return;\n    }\n    \n    center = vec3(-1.5, 0.0, 0.0);\n    t = intersectSphere(rayOrigin, rayDir, center, rad);\n    if (t >= 0.0) {\n        vec3 position = rayOrigin+t*rayDir;\n        vec3 norm = normalize(position-center);\n        vec3 offsetLightPos = lightPos+center;\n        vec3 lightDir = normalize(offsetLightPos-position);\n        \n        vec3 col = shadeLambertBRDF(-rayDir, lightDir, norm);\n        fragColor = vec4(adjustExposureGamma(col), 1.0);\n        return;\n    }\n    \n    fragColor = vec4(vec3(0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 648, 713, 713, 1034], [1036, 1036, 1067, 1067, 1107], [1109, 1109, 1131, 1131, 1193], [1195, 1195, 1256, 1256, 2405], [2407, 2407, 2459, 2459, 2522], [2524, 2524, 2560, 2560, 2636], [2638, 2638, 2695, 2695, 4021]], "test": "valid"}
{"id": "ftlXz8", "name": "glsl-line-rast", "author": "kusma", "description": "A GLSL line rasterizer\n\nHandles diamond exit-rule rasterization apart for at the end-points.\n\nVisualizes hierarchical rasterization details.\n\nTODO:\n- Z / W interpolation\n- Correct end-point according to diamond-exit\n- More modes", "tags": ["rasterizer", "line"], "likes": 4, "viewed": 54, "published": "Public", "date": "1625142789", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const bool replicate_attrs = true;\n\nconst int SUBPIXEL_BITS = 4;\n\nint round_to_subpixel(float v)\n{\n    return int(floor(v * float(1 << SUBPIXEL_BITS) + 0.5));\n}\n\nstruct primitive {\n    vec2 bmin, bmax; // bounding box\n    \n    ivec3 e[4]; // edge functions\n\n    // z, w, and barycentric interpolants\n    vec3 fz, fw, ft;\n};\n\nvoid calc_bbox(vec4 verts[2], out vec2 bmin, out vec2 bmax)\n{\n    bmin = iResolution.xy;\n    bmax = vec2(0);\n    for (int i = 0; i < 2; ++i) {\n        bmin = min(bmin, verts[i].xy);\n        bmax = max(bmax, verts[i].xy);\n    }\n}\n\n/* Clips the line to the frustum.\n * We do this because external rasterization is a bit\n * involved for lines, but clipping them is trivial.\n *\n * This is still a bit naive, and can probably be optimized\n * a bunch (calculate min/max t once, instead of clipping\n * over and over again?).\n */\nbool clip_line(inout vec4 verts[2], inout vec4 attrs[2])\n{\n    vec4 planes[6];\n    planes[0] = vec4(-1.0, 0.0, 0.0, 1.0);\n    planes[1] = vec4( 1.0, 0.0, 0.0, 1.0);\n    planes[2] = vec4(0.0, -1.0, 0.0, 1.0);\n    planes[3] = vec4(0.0,  1.0, 0.0, 1.0);\n    planes[4] = vec4(0.0, 0.0, -1.0, 1.0);\n    planes[5] = vec4(0.0, 0.0,  1.0, 1.0);\n\n    for (int i = 0; i < 6; ++i) {\n        vec2 dist = vec2(dot(verts[0], planes[i]), dot(verts[1], planes[i]));\n        \n        bvec2 inside = greaterThan(dist, vec2(0.0));\n\n        /* trivial case; neither vertices are inside */\n        if (!any(inside))\n           return false;\n\n        /* trivial case; both vertices are inside */\n        if (all(inside))\n           continue;\n\n        /* clipping lines don't produce new vertices, so\n         * we can just overwrite. */\n        float t = dist.x / (dist.x - dist.y);\n        if (!inside.x) {\n           verts[0] = mix(verts[0], verts[1], t);\n           attrs[0] = mix(attrs[0], attrs[1], t);\n        } else {\n           verts[1] = mix(verts[0], verts[1], t);\n           attrs[1] = mix(attrs[0], attrs[1], t);\n        }\n    }\n\n    return true;\n}\n\nbool setup_line(vec4 verts[2], float lineWidth, out primitive result)\n{\n    int width = round_to_subpixel(lineWidth);\n    int halfWidth = round_to_subpixel(lineWidth * 0.5);\n\n    vec2 d = verts[1].xy - verts[0].xy;\n\tfloat length_squared = dot(d, d);\n    if (length_squared == 0.0)\n        return false;\n\n    calc_bbox(verts, result.bmin, result.bmax);\n\n\n    // floating point line-function\n    ivec2 tmp = ivec2(round_to_subpixel(+d.y),\n                      round_to_subpixel(-d.x));\n    int dist = (tmp.x * round_to_subpixel(-verts[1].x)) +\n               (tmp.y * round_to_subpixel(-verts[1].y));\n\n    // store as twice SUBPIXEL_BITS fractional part to avoid rounding\n    ivec3 e0 = ivec3(tmp << SUBPIXEL_BITS, dist);\n    ivec3 e[4];\n    e[0] = e0;\n    e[1] = ivec3(-e0.xy, -e0.z);\n\n    ivec2 major_range;\n    if (abs(tmp.y) > abs(tmp.x)) {\n        ivec2 offset = (e0.y * ivec2(halfWidth, width)) >> SUBPIXEL_BITS;\n        offset.y -= offset.x;\n        if (tmp.y <= 0)\n            offset = -offset;\n\n        e[0].z += offset.x;\n        e[1].z += offset.y + 1;\n\n        major_range = ivec2(round_to_subpixel(verts[0].x),\n                            round_to_subpixel(verts[1].x));\n\n        e[2] = ivec3( (1 << SUBPIXEL_BITS), 0, 0);\n        e[3] = ivec3(-(1 << SUBPIXEL_BITS), 0, 0);\n\n        if (replicate_attrs) {\n            // use \"ideal\" line attribute interpolation\n            d.x = dot(d, d) / d.x;\n            d.y = 0.0;\n        }\n\n        result.bmin.y -= lineWidth * 0.5;\n        result.bmax.y += lineWidth * 0.5;\n    } else {\n        // y-major\n        ivec2 offset = (e0.x * ivec2(halfWidth, width)) >> SUBPIXEL_BITS;\n        offset.y -= offset.x;\n        if (tmp.x <= 0)\n            offset = -offset;\n\n        e[0].z += offset.x;\n        e[1].z += offset.y + 1;\n\n        major_range = ivec2(round_to_subpixel(verts[0].y),\n                            round_to_subpixel(verts[1].y));\n\n        e[2] = ivec3(0,  (1 << SUBPIXEL_BITS), 0);\n        e[3] = ivec3(0, -(1 << SUBPIXEL_BITS), 0);\n\n        if (replicate_attrs) {\n            // use \"ideal\" line attribute interpolation\n            d.y = dot(d, d) / d.y;\n            d.x = 0.0;\n        }\n\n        result.bmin.x -= lineWidth * 0.5;\n        result.bmax.x += lineWidth * 0.5;\n    }\n    \n    e[2].z = -min(major_range.x, major_range.y);\n    e[3].z = +max(major_range.x, major_range.y);\n\n    result.e[0] = e[0];\n    result.e[1] = e[1];\n    result.e[2] = e[2];\n    result.e[3] = e[3];\n\n    result.ft = vec3(d, dot(-d, verts[0].xy)) / length_squared;\n    \n    // TODO: setup these:\n    result.fz = vec3(0.0);\n    result.fw = vec3(0.0);\n\n    return true;\n}\n\nint eval_edge(ivec3 e, ivec2 pos)\n{\n    return e.x * pos.x + e.y * pos.y + e.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0\n    float th1 = iTime * 0.5, th2 = iTime * 0.5 + 3.1415926;\n    vec4 verts[2] = vec4[2](\n        vec4(sin(th1), cos(th1), 0.0, 1.0),\n        vec4(sin(th2), cos(th2), 0.0, 1.0)\n    );\n#else\n    /* this tests the clipped case, which is currently broken */\n    vec4 verts[2] = vec4[2](\n        vec4(-0.75, -0.75, 0.0, 1.0),\n        vec4( 0.00,  0.75, 1.0, 1.0)\n    );\n    verts[1].w = 0.5 + 1.75 * sin(3.25 + 0.25 * iTime);\n#endif\n\n    vec4 attrs[2] = vec4[2](\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(1.0, 0.0, 0.0, 0.0)\n    );\n\n    if (!clip_line(verts, attrs)) {\n        fragColor = vec4(0.5, 0.5, 0.0, 1.0);\n        return;\n    }\n\n\n    // *** per vertex\n\n    // viewport map\n    for (int i = 0; i < 2; ++i) {\n        float w_rcp = 1.0 / verts[i].w;\n        vec3 tmp = verts[i].xyz * w_rcp;\n        verts[i].xy = iResolution.xy * 0.5 + tmp.xy * iResolution.xy * 0.5;\n        verts[i].z = tmp.z;\n        verts[i].w = w_rcp;\n    }\n\n    // *** per primitive\n\n    primitive prim;\n    if (!setup_line(verts, 40.0, prim)) {\n        fragColor = vec4(0.5, 0.0, 0.0, 1.0);\n        return;\n    }\n\n\n    /* this really belongs elsewhere, but it's cleaner to color here */\n    if (any(lessThan(fragCoord.xy, floor(prim.bmin.xy))) ||\n        any(greaterThan(fragCoord.xy, ceil(prim.bmax.xy)))) {\n        fragColor = vec4(0.0, 0.5, 0.5, 1.0);\n        return;\n    }\n\n    // *** per tile\n\n    fragColor = vec4(0.5, 0.0, 0.0, 1.0);\n\n    /* just proof-of-concept: conservative\n     * block-rasterizing, for hierarchial\n     * rasterization (and could be repurposed\n     * for normal conservative rasterization)\n     */\n    ivec4 de, ne;\n    for (int i = 0; i < 4; ++i) {\n        de[i] = max(prim.e[i].x, 0) + max(prim.e[i].y, 0);\n        ne[i] = prim.e[i].x + prim.e[i].y - de[i];\n    }\n\n    fragColor = vec4(1.0);\n    for (int i = 6; i > 0; i--) {\n        ivec2 hpos = ivec2(fragCoord.xy) & ~((1 << i) - 1);\n        ivec4 d;\n        for (int j = 0; j < 4; ++j)\n            d[j] = eval_edge(prim.e[j], hpos);\n\n        bool fully_outside = any(lessThan(d + (de << i), ivec4(0)));\n        if (fully_outside) {\n            fragColor[i % 3] *= 0.875 / float(1 + i / 3);\n            return;\n        }\n\n        bool fully_inside = all(greaterThan(d + (ne << i), ivec4(0)));\n        if (fully_inside) {\n            fragColor[i % 3] *= 0.875 / float(1 + i / 3);\n            break;\n        }\n    }\n\n    // *** per pixel\n\n    ivec2 pos = ivec2(fragCoord.xy);\n\tint d0 = eval_edge(prim.e[0], pos);\n\tint d1 = eval_edge(prim.e[1], pos);\n\tint d2 = eval_edge(prim.e[2], pos);\n\tint d3 = eval_edge(prim.e[3], pos);\n\n    if (d0 > 0 && d1 > 0 && d2 > 0 && d3 > 0) {\n        float t = dot(prim.ft, vec3(pos, 1));\n#if 1\n        // float z = dot(prim.fz, vec3(pos, 1));\n        float z = mix(verts[0].z, verts[1].z, t);\n\n        if (z < 0.0 || z > 1.0) {\n            fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n            return;\n        }\n#endif\n#if 0\n        float w = 1.0 / dot(prim.fw, vec3(pos, 1));\n        i *= w;\n#endif\n        // interpolate a single vec4 varying\n        vec4 var = mix(attrs[0], attrs[1], t);\n\n        // vec4 tmp = vec4(textureLod(iChannel0, var.xy, 0.0).xyz, 1.0);\n        vec4 tmp = var;\n#if 0\n        tmp.xyz = mix(tmp.xyz, vec3(0.5), 1.0 / (1.0 + z));\n#endif\n        fragColor *= tmp;\n    }\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 98, 98, 160], [325, 325, 386, 386, 553], [555, 847, 905, 905, 1985], [1987, 1987, 2058, 2058, 4604], [4606, 4606, 4641, 4641, 4687], [4689, 4689, 4746, 4746, 8036]], "test": "error"}
{"id": "ftlXzl", "name": "SED4906 - Raymarching Test 1", "author": "sed4906", "description": "Rotom rotom!", "tags": ["raymarching"], "likes": 0, "viewed": 48, "published": "Public", "date": "1626328455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float E = 0.001;\nconst vec3 I = vec3(1,1,1);\nconst vec3 O = vec3(0,0,0);\nconst vec3 U = vec3(0,1,0);\n\nvec3 K_a = vec3(0.2, 0.2, 0.2);\nvec3 K_d = vec3(0.7, 0.2, 0.2);\nvec3 K_s = vec3(1.0, 1.0, 1.0);\nfloat shininess = 10.0;\n\nmat4 view(vec3 look, vec3 eye, vec3 up) {\n\tvec3 f = normalize(eye - look);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nfloat sphere( vec3 pos, float radius, vec3 point )\n{\n    return distance(pos, point) - radius;\n}\n\nfloat cube( vec3 pos, vec3 size, vec3 point )\n{\n    vec3 d = abs(pos - point) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat scene( vec3 point )\n{\n    return min(sphere(O,1.0,point),max(-sphere(O,1.2,point),max(cube(O, I, point),sphere(O,1.3,point))));\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + E, p.y, p.z)) - scene(vec3(p.x - E, p.y, p.z)),\n        scene(vec3(p.x, p.y + E, p.z)) - scene(vec3(p.x, p.y - E, p.z)),\n        scene(vec3(p.x, p.y, p.z  + E)) - scene(vec3(p.x, p.y, p.z - E))\n    ));\n}\n\nvec3 phong(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = normal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 light(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phong(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phong(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nvec3 raymarch( vec3 eye, vec3 dir, float clip )\n{\n    vec3 end = eye;\n    float len = 0.0;\n    while(len < clip)\n    {\n        float dist = scene(end);\n        end += dir * dist;\n        len += dist;\n        if(dist <= E)\n        {\n            vec3 lit = light(K_a, K_d, K_s, shininess, end, eye);\n            return lit;\n        }\n    }\n    return O;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n\n    vec3 camera = vec3(5.0*sin(iTime),5.0*cos(iTime),5.0*cos(iTime));\n    vec3 raydir = normalize(vec3(uv.x-0.5,(uv.y-0.5)/ar,1.0));\n\n    // Raymarch the scene\n    vec3 col = raymarch(camera, (view(O, camera, U) * vec4(raydir,1.0)).xyz, 50.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 270, 270, 455], [457, 457, 509, 509, 553], [555, 555, 602, 602, 710], [712, 712, 739, 739, 847], [849, 849, 870, 870, 1126], [1128, 1128, 1253, 1253, 1835], [1837, 1837, 1910, 1910, 2680], [2682, 2682, 2731, 2731, 3035], [3037, 3037, 3094, 3144, 3531]], "test": "valid"}
{"id": "ftlXzM", "name": "Polar Colo(u)rs", "author": "EzaExponential", "description": "Some pretty colours - First shader experiment", "tags": ["simple", "colors", "spinning", "colours"], "likes": 2, "viewed": 43, "published": "Public", "date": "1625351654", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float CartToPolar(vec2 uv){ \n    float polarAngle = atan(uv.y/uv.x); \n    if(uv.x < 0.0 && uv.y >= 0.0) { \n        polarAngle += radians(180.0);\n    } \n    else if(uv.x < 0.0 && uv.y < 0.0) { \n        polarAngle += radians(180.0);\n    }\n     else if(uv.x >= 0.0 && uv.y < 0.0) { \n        polarAngle += 2.0*radians(180.0);\n    } \n    return polarAngle;\n} \n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord*2.0/iResolution.xy - 1.0;\n\n    uv = rotate(uv, iTime);\n    \n    float polarAngle = CartToPolar(uv);    \n    \n    \n    float brightness = smoothstep(polarAngle, polarAngle+1.0, mod(iTime, 2.0*radians(180.0)+1.0)); \n    \n    if(mod(iTime, 4.0*radians(180.0)+2.0)>2.0*radians(180.0)+1.0){ \n        brightness = 1.0 - brightness;  \n      \n    } \n\n    brightness+= 1.0-smoothstep(0.0, 1.0, polarAngle); \n    brightness+= smoothstep(2.0*radians(180.0)-1.0, 2.0*radians(180.0), polarAngle);\n\n\n    fragColor = vec4(brightness * exp2(sin(iTime + uv.x)) ,brightness * exp(cos(iTime+2.1 + uv.y)), brightness * pow(tan(iTime +3.14+ uv.x + uv.y),2.0), 1.0);\n\n} \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 353], [356, 356, 386, 386, 470], [472, 472, 529, 529, 1202]], "test": "valid"}
{"id": "ftsSDn", "name": "time warp with sine offset", "author": "teadrinker", "description": "Just testing timewarp with a different shape.\nnormal timewarp:  https://www.shadertoy.com/view/NtlXWn", "tags": ["timewarp"], "likes": 2, "viewed": 210, "published": "Public API", "date": "1625470878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float sinePeaks = 3.;\n    float waitPixelRows = 300.;\n    int speed = 1; // higher values will reduce quality\n    int scanPos = int(mod(float(iFrame * speed), iResolution.y + waitPixelRows));\n    int yoffs = int((-1.+cos(fragCoord.x * sinePeaks * 6.28/ iResolution.x)) * iResolution.y / 22.);\n    if(int(fragCoord.y) + yoffs > int(iResolution.y) - scanPos)\n        discard;\n    else if(int(fragCoord.y) + yoffs ==  int(iResolution.y) - scanPos - speed)\n        fragColor = vec4(0.,1.,0.,1.);\n    else\n        fragColor = texture(iChannel0, vec2(iResolution.x - fragCoord.x, fragCoord.y) / iResolution.xy);\n}\n\n\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 58, 58, 670]], "test": "error"}
{"id": "ftSSRR", "name": "Pinku", "author": "adamgoodapp", "description": "FBM", "tags": ["cineshader"], "likes": 7, "viewed": 891, "published": "Public API", "date": "1626861993", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float colormap_red(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 20049.0 / 82979.0) {\n        return 0.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\n    } else if (x <= 1.0) {\n        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 7249.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return 127.0 / 255.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nvec4 colormap(float x) {\n    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\n}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p + iTime  ); p = mtx*p*2.02;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.015625*noise( p + sin(iTime) );\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\tfloat shade = pattern(uv);\n    fragColor = vec4(colormap(shade).rgb, shade);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 203], [205, 205, 236, 236, 572], [574, 574, 604, 604, 989], [991, 991, 1015, 1015, 1093], [1096, 1096, 1116, 1116, 1186], [1188, 1188, 1208, 1208, 1443], [1498, 1498, 1519, 1519, 1846], [1848, 1848, 1876, 1876, 1918], [1920, 1920, 1977, 1977, 2096]], "test": "valid"}
{"id": "ftSSWR", "name": "Data Storage", "author": "dr2", "description": "Accessing the archives...", "tags": ["robot", "kinematics", "mechanism"], "likes": 15, "viewed": 194, "published": "Public API", "date": "1627381375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Data Storage\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Hashv2f (float p);\n\nvec3 qHit,ltPos, cPos;\nvec2 gCur, gSize, cDel, angC;\nfloat dstFar, tCur, tCyc, tPhs, hCyc, bWid, zPos;\nint idObj;\nbool isSh;\nconst int idCyl = 1, idTel = 2, idRail = 3, idFrame = 4, idBase = 5, idWal = 6, idSup = 7, idLamp = 8,\n   idCylP = 9;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, ts, zFrm;\n  dMin = dstFar;\n  zFrm = 3. * 0.9 + 0.96;\n  zPos = 0.;\n  for (float k = float (VAR_ZERO); k <= 3.; k ++) {\n    q = p;\n    q.xy -= vec2 (0.5 * (gCur.x + cDel.x), cDel.y);\n    if (k > 0.) zPos += 0.1 + 0.9 * SmoothBump (0.3 + 0.03 * k, 0.7 - 0.03 * k, 0.03, tPhs);\n    q.xz = Rot2D (q.xz, angC.x);\n    q.yz = Rot2D (q.yz, angC.y);\n    q.z -= 0.9 * zPos;\n    d = PrRoundCylDf (q, 0.2 - 0.03 * k, 0.02, 0.5);\n    DMINQ (idTel);\n  }\n  ts = abs (tPhs - 0.5) - 0.42;\n  if (hCyc == 0. || ts < 0.) cPos.xy = vec2 (0.5 * gCur.x, (hCyc == 0.) ? 0.5 * gCur.y : cDel.y);\n  else cPos.xy = vec2 (0.5 * gCur.x + 2. * bWid * smoothstep (0., 0.08, ts) * sign (tPhs - 0.5),\n     -0.25 * gSize.y - 2. + 0.5);\n  q = p;\n  if (hCyc == 0. || ts < 0.) {\n    q.xy -= cPos.xy;\n    if (hCyc != 0.) {\n      q.xz = Rot2D (q.xz, angC.x);\n      q.yz = Rot2D (q.yz, angC.y);\n      q.z -= 0.9 * (zPos - 3.);\n    }\n    q.z -= zFrm;\n    d = PrRoundCylDf (q, 0.15, 0.02, 0.41);\n  } else {\n    d = bWid - abs (q.x);\n    q.xy -= cPos.xy;\n    q = q.xzy;\n    d = max (PrRoundCylDf (q, 0.15, 0.02, 0.4), - d);\n  }\n  DMINQ (idCylP);\n  q = p;\n  d = max (PrBox2Df (q.xy, 0.25 * gSize), - PrBox2Df (q.xy - 0.5 * gCur, vec2 (0.25)));\n  q.xy = mod (q.xy + 0.25, 0.5) - 0.25;\n  q.z -= zFrm;\n  d = max (d, PrRoundCylDf (q, 0.15, 0.02, 0.4));\n  DMINQ (idCyl);\n  q = p;\n  q.x -= 0.5 * (gCur.x + cDel.x);\n  q.y -= cDel.y;\n  q.xz = Rot2D (q.xz, angC.x);\n  d = PrRoundCylDf (q.yzx, 0.03, 0.02, 0.45);\n  DMINQ (idRail);\n  q = p;\n  q.x -= 0.5 * (gCur.x + cDel.x);\n  q.xz = Rot2D (q.xz, angC.x);\n  q.y -= 0.25 * gSize.y + 0.5;\n  d = min (PrCylDf (vec3 (q.xz, q.y - 0.65), 0.12, 0.9), PrCapsDf (vec3 (q.xz, abs (q.y + 0.05) - 0.2).yzx,\n     0.12, 0.4));\n  q.x = abs (q.x) - 0.4;\n  q.y -= -0.25 * gSize.y - 0.5;\n  d = min (d, SmoothMax (PrCapsDf (q.xzy, 0.12, 0.25 * gSize.y + 0.65),\n     - PrRoundBoxDf (q - vec3 (-0.08, -0.2, 0.), vec3 (0.08, 0.25 * gSize.y + 0.2, 0.04), 0.01), 0.02));\n  DMINQ (idRail);\n  q = p;\n  q.z = abs (q.z - zFrm) - 0.3;\n  d = max (PrRoundBoxDf (q, vec3 (0.25 * gSize + 0.25, 0.05) - 0.05, 0.05),\n     - max (PrBox2Df (q.xy, vec2 (0.25 * gSize)), length (mod (q.xy + 0.25, 0.5) - 0.25) - 0.17));\n  DMINQ (idFrame);\n  q = p;\n  q.xy = abs (q.xy);\n  q -= vec3 (0.25 * gSize.xy + vec2 (0.1, 1.1), zFrm);\n  d = PrRoundCylDf (q.xzy, 0.4, 0.02, 0.9);\n  DMINQ (idSup);\n  if (! isSh) {\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (bWid, -0.25 * gSize.y - 0.98, 2.);\n    d = max (PrRoundBoxDf (q, vec3 (0.25, 1.2, 5.) - 0.02, 0.02), - SmoothMax (q.x - 0.1,\n       PrBox2Df (q.yz - vec2 (-0.4, -2.), vec2 (0.6, 0.3)), 0.02));\n    DMINQ (idWal);\n    q = p;\n    q.y = abs (q.y);\n    q.yz -= vec2 (0.25 * gSize.y + 2.08, 2.);\n    d = PrRoundBoxDf (q, vec3 (bWid + 0.25, 0.1, 5.) - 0.02, 0.02);\n    DMINQ (idBase);\n    q = p - ltPos;\n    d = PrCapsDf (q.yzx, 0.16, 0.3);\n    DMINQ (idLamp);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 ObjCol (vec3 ro)\n{\n  vec4 col4;\n  float s;\n  if (idObj == idCyl || idObj == idCylP) {\n    col4 = vec4 (0.2, 0.7, 1., 0.2) * (1. - 0.3 * smoothstep (0., 0.02, abs (abs (qHit.z) - 0.2)) - 0.1) *\n       (0.6 + 0.4 * smoothstep (0., 0.02, length (qHit.xy) - 0.05));\n    if (abs (qHit.z) < 0.2) col4 *= (1. + 0.3 * smoothstep (0.4, 0.5, sin (16. * atan (qHit.y, - qHit.x))));\n    if (idObj == idCylP && hCyc != 0. && zPos < 2.99 && abs (qHit.z) > 0.3)\n       col4 = mix (col4, vec4 (1., 0., 0., -1.), step (0.5, mod (4. * tCur, 1.)));\n  } else if (idObj == idTel) {\n    col4 = vec4 (0.8, 0.85, 0.8, 0.2) *\n       (1. - 0.2 * smoothstep (0., 0.05, abs (qHit.z) - 0.4));\n  } else if (idObj == idRail) {\n    col4 = vec4 (0.85, 0.85, 0.9, 0.2);\n  } else if (idObj == idFrame) {\n    col4 = vec4 (0.6, 0.6, 0.4, 0.) * (1. - 0.4 * smoothstep (0., 0.02,\n       PrRoundBox2Df (qHit.xy, vec2 (0.25 * gSize) - 0.1, 0.2)));\n    if (cDel.y == 0.5 * gCur.y && length (qHit.xy - cPos.xy) < 0.22) col4 = vec4 (0., 1., 0., -1.);\n  } else if (idObj == idSup) {\n    col4 = vec4 (0.6, 0.6, 0.4, 0.1);\n    if (length (qHit.xz) > 0.35) col4 *= 0.8 + 0.2 * smoothstep (-0.4, -0.2,\n       sin (16. * atan (qHit.z, - qHit.x)));\n  } else if (idObj == idBase) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.);\n    if (abs (ro.x) < bWid + 0.2 && abs (ro.y) < 0.25 * gSize.y + 2.1) {\n      col4 *= 0.6 + 0.4 * smoothstep (0., 0.03, abs (abs (qHit.z + 2.) - 0.2) - 0.02);\n      if (abs (qHit.z + 2.) < 0.2) col4 *= 0.6 + 0.4 * smoothstep (0., 0.03,\n         abs (mod (qHit.x, 0.5) - 0.25) - 0.02);\n    }\n  } else if (idObj == idWal) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.);\n    if (abs (ro.x) < bWid + 0.2) {\n      s = (1. - smoothstep (0., 0.02, abs (qHit.z + 2.) - 0.3)) *\n         (1. - smoothstep (0., 0.02, abs (qHit.y + 0.4) - 0.6));\n      if (s > 0. && sign (ro.x) * sign (cPos.x - 0.5 * gCur.x) > 0. && abs (ro.x) > bWid - 0.15)\n         col4 = vec4 (1., 0., 0., -1.);\n      else col4 *= 1. - 0.2 * s;\n    }\n  } else if (idObj == idLamp) {\n    col4 = vec4 (vec3 (0.9, 0.9, 0.8) * (0.95 + 0.05 * cos (64. * pi * qHit.y)), -1.);\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir;\n  float dstObj, tf, ltDist, sh, nDotL;\n  gSize = vec2 (13., 9.);\n  bWid = 4.5;\n  tCyc = 10.;\n  tCur += 2. * tCyc;\n  tPhs = mod (tCur / tCyc, 1.);\n  hCyc = floor (mod (tCur / tCyc + 0.5, 2.));\n  tf = floor (tCur / (2. * tCyc));\n  gCur = - floor (gSize / 2.) + floor (gSize * Hashv2f (17.11 * tf));\n  angC.y = (hCyc != 0.) ? -0.5 * pi *  (1. - SmoothBump (0.15, 0.85, 0.05, tPhs)) : 0.;\n  angC.x = angC.y;\n  cDel.x = (floor (gSize.x * Hashv2f (17.11 * (tf - 1.)).x - floor (gSize.x / 2.)) - gCur.x) *\n     (1. - smoothstep (0., 1.5, tCur - 2. * tCyc * tf));\n  cDel.y = (0.5 * gCur.y + 2.5) * SmoothBump (0.15, 0.85, 0.06, tPhs) - 2.5;\n  ltPos = vec3 (0., 0.25 * gSize.y + 1.8, -2.6);\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro);\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == idRail || idObj == idTel) nDotL *= nDotL;\n    isSh = true;\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir, ltDist);\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       step (0.95, sh) * col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    else col = col4.rgb * (0.5 - 0.5 * dot (rd, vn));\n  } else {\n    col = vec3 (0.1, 0.1, 0.15);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 1.5 * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    az = 0.2 * pi * (2. * mod (floor (0.05 * tCur), 2.) - 1.) *\n       SmoothBump (0.3, 0.7, 0.15, mod (0.05 * tCur, 1.));\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0.5, -18.);\n  ro.y -= 0.5;\n  zmFac = 3.5;\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSSWR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1008, 1008, 1030, 1030, 3934], [3936, 3936, 3969, 3969, 4152], [4154, 4154, 4175, 4175, 4432], [4434, 4434, 4485, 4485, 4728], [4730, 4730, 4753, 4753, 6842], [6844, 6844, 6879, 6879, 8265], [8267, 8267, 8323, 8323, 9391], [9393, 9393, 9439, 9439, 9486], [9488, 9488, 9521, 9521, 9610], [9612, 9612, 9659, 9659, 9706], [9708, 9708, 9750, 9750, 9801], [9803, 9803, 9860, 9860, 9936], [9938, 9938, 9981, 9981, 10045], [10047, 10047, 10092, 10092, 10184], [10186, 10186, 10231, 10231, 10269], [10271, 10271, 10328, 10328, 10411], [10413, 10413, 10449, 10449, 10655], [10657, 10657, 10687, 10687, 10800], [10834, 10834, 10858, 10858, 10911]], "test": "error"}
{"id": "ftsSWS", "name": "Not The Ship Stamp", "author": "dr2", "description": "Not that overpriced British Guiana 1c magenta postage stamp", "tags": ["ship", "sail", "philately"], "likes": 21, "viewed": 241, "published": "Public API", "date": "1626435716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Not The Ship Stamp\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Not that overpriced British Guiana 1c magenta postage stamp (mouseable - click in\n// lower-right corner for monochrome image)\n\n/*\n  No. 8 in \"Sailing Ship\" series\n    \"Ship in a Shell\"          (XlBfRR)\n    \"Sailing\"                  (MtBBRR)\n    \"Tempting the Mariner\"     (ll2BzR)\n    \"Lighthouse with Ship\"     (MtSBR1)\n    \"Ship of Mirrors\"          (4ljfzw)\n    \"Refractable Ship\"         (MtjBRm)\n    \"Ship in a Bottle\"         (wlXXzf)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEVCapsDf (vec3 p, vec4 u, float r);\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 vum[4], vur[5], shipConf;\nvec3 qHit, ltDirEx, sunDir, vim[4], vir[5], bDeck, sailVel;\nfloat tCur, dstFar;\nint idObj;\nbool monoImg;\nconst int idHull = 1, idRud = 2, idStruc = 3, idMast = 4, idSparT = 5, idSparL = 6, idSailT = 7,\n   idSailA = 8, idSailF = 9, idFlag = 10, idRig = 11;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat WaveHt (vec2 p, float d)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  h = 0.;\n  if (d < 0.3 * dstFar) {\n    q = p;\n    q += sailVel.xz * tCur;\n    wFreq = 0.5;\n    wAmp = 0.1;\n    tw = 0.1 * tCur * vec2 (1., -1.);\n    for (int j = 0; j < 4; j ++) {\n      q *= qRot;\n      t4 = abs (sin (wFreq * (q.xyxy + tw.xxyy) + 2. * Noisev2v4 (t4).xxyy - 1.));\n      v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n      t = 1. - sqrt (v4.xz * v4.yw);\n      t *= t;\n      t *= t;\n      h += wAmp * (t.x + t.y);\n      wFreq *= 2.;\n      wAmp *= 0.5;\n    }\n    h *= 1. - smoothstep (0.1, 0.3, d / dstFar);\n  }\n  return h;\n}\n\nvec4 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  float h;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  h = WaveHt (p.xz, d);\n  return vec4 (normalize (vec3 (h - vec2 (WaveHt (p.xz + e.xy, d),\n     WaveHt (p.xz + e.yx, d)), e.x)).xzy, h);\n}\n\nfloat ShipHullDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, fy, fz, gz;\n  q = p;\n  d = abs (p.z) - 4.5;\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  q.yz -= vec2 (-3.4, -0.4);\n  d = max (d, PrBoxDf (q, vec3 (0.3, 0.1, 0.5)));\n  DMINQ (idStruc);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (-3.8, 0.5);\n  fz = q.z / 5. + 0.3;\n  fz *= fz;\n  fy = 1. - smoothstep (-1.3, -0.1, q.y);\n  gz = smoothstep (2., 5., q.z);\n  bDeck = vec3 ((1. - 0.45 * fz * fz) * (1.1 - 0.5 * fy * fy) *\n     (1. - 0.5 * smoothstep (-5., -2., q.y) * smoothstep (2., 5., q.z)),\n     0.78 - 0.8 * gz * gz - 0.2 * (1. - smoothstep (-5.2, -4., q.z)), 5. * (1. + 0. * 0.02 * q.y));\n  d = min (PrBoxDf (vec3 (q.x, q.y + bDeck.y - 0.6, q.z), bDeck),\n     max (PrBoxDf (q - vec3 (0., 0.72, -4.6), vec3 (bDeck.x, 0.12, 0.4)),\n     - PrBox2Df (vec2 (abs (q.x) - 0.4, q.y - 0.65), vec2 (0.2, 0.08))));\n  d = max (d, - PrBoxDf (vec3 (q.x, q.y - 0.58 - 0.1 * fz, q.z),\n     vec3 (bDeck.x - 0.07, 0.3, bDeck.z - 0.1)));\n  q = p;\n  d = max (d, - max (PrBox2Df (vec2 (q.y + 3.35, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.08, 0.1)),\n     abs (q.z + 0.5) - 3.75));\n  DMINQ (idHull);\n  q = p;\n  d = PrBoxDf (q + vec3 (0., 4.4, 4.05), vec3 (0.03, 0.35, 0.5));\n  DMINQ (idRud);\n  return dMin;\n}\n\nfloat ShipMastDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, fy, fz, s, rSpar, yLim, zLim;\n  rSpar = 0.05;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  zLim = abs (p.z) - 4.5;\n  q = p;\n  d = zLim;\n  q.z = mod (q.z + 1.4, 2.8) - 1.2;\n  d = max (d, PrCapsDf ((q - vec3 (0., 3.7 * (fz - 1.), 0.)).xzy, 0.1 * fy, 3.7 * fz));\n  DMINQ (idMast);\n  q = p;\n  yLim = abs (q.y - 0.2 * fz) - 3. * fz;\n  qq = q;\n  qq.y = mod (qq.y - 3.3 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.1 * fz;\n  d = max (max (min (d, PrCylDf (vec3 (qq - vec3 (0., 0.05 * fy * fz, 0.1 * fz - 0.23)).xzy,\n     0.15 * fy, 0.11 * fy * fz)), yLim), zLim);\n  DMINQ (idMast);\n  d = max (max (PrCapsDf (qq.yzx, 0.05, 1.23 * fy * fz), yLim), zLim);\n  DMINQ (idSparT);\n  q = p;\n  d = dstFar;\n  for (int k = 0; k < 4; k ++) d = min (d, PrEVCapsDf (q - vim[k], vum[k], rSpar));\n  DMINQ (idSparL);\n  return dMin;\n}\n\nfloat ShipSailDf (vec3 p, float dMin)\n{\n  vec3 q, qq, w;\n  float d, fy, fz;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  qq = q;\n  qq.y = mod (qq.y - 3.1 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.2 * (fz - abs (qq.y)) * (fz - abs (qq.y)) - 0.1 * fz;\n  d = max (max (max (PrBoxDf (qq, vec3 ((1.2 - 0.07 * q.y) * fz, fz, 0.01)),\n     min (qq.y, 1.5 * fy * fz - length (vec2 (qq.x, qq.y + 0.9 * fy * fz)))),\n     abs (q.y - 3. * (fz - 1.)) - 2.95 * fz), - PrBox2Df (qq.yz, vec2 (0.01 * fz)));\n  d = max (d, abs (p.z) - 4.5);\n  DMINQ (idSailT);\n  q = p;\n  q.z -= -3.8;\n  q.y -= -1.75 - 0.2 * q.z;\n  d = PrBoxDf (q, vec3 (0.01, 0.9 - 0.2 * q.z, 0.6));\n  DMINQ (idSailA);\n  q = p;\n  q.yz -= vec2 (-1., 4.5);\n  w = vec3 (1., q.yz);\n  d = max (max (max (abs (q.x) - 0.01, - dot (w, vec3 (2.3, 1., -0.35))),\n     - dot (w, vec3 (0.68, -0.74, -1.))), - dot (w, vec3 (0.41, 0.4, 1.)));\n  DMINQ (idSailF);\n  q = p;\n  q.yz -= vec2 (3.4, 0.18);\n  d = PrBoxDf (q, vec3 (0.01, 0.2, 0.3));\n  DMINQ (idFlag);\n  return dMin;\n}\n\nfloat ShipRigDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float rRig, d, fz, gz, s;\n  rRig = 0.02;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  d = abs (p.z) - 4.5;\n  gz = (q.z - 0.5) / 5. + 0.3;\n  gz *= gz;\n  gz = 1.05 * (1. - 0.45 * gz * gz);\n  q.x = abs (q.x);\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  d = max (d, min (PrEECapsDf (q, vec3 (1.05 * gz, -3.25, -0.5),\n     vec3 (1.4 * fz, -2.95, -0.05), 0.7 * rRig),\n     PrEECapsDf (vec3 (q.xy, abs (q.z + 0.2) - 0.01 * (0.3 - 2. * q.y)), vec3 (gz, -3.2, 0.),\n     vec3 (0.05, -0.9 + 2. * (fz - 1.), 0.), rRig)));\n  q = p;\n  d = min (d, PrEVCapsDf (q - vir[0], vur[0], 0.8 * rRig));\n  d = min (min (d, min (PrEVCapsDf (q - vir[1], vur[1], rRig),\n     PrEVCapsDf (q - vir[2], vur[2], rRig))), PrEVCapsDf (q - vir[3], vur[3], rRig));\n  q.x = abs (q.x);\n  d = min (d, PrEVCapsDf (q - vir[4], vur[4], rRig));\n  s = step (1.8, q.y) - step (q.y, -0.2);\n  d = min (min (d, min (PrEECapsDf (q, vec3 (0.95, 0.4, 2.7) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 1.1, -0.15) + vec3 (0., 2., 0.) * s, rRig),\n     PrEECapsDf (q, vec3 (1.05, 1., -0.1) + vec3 (-0.1, 2., 0.) * s,\n     vec3 (0.05, 0.5, -2.95) + vec3 (0., 1.7, 0.) * s, rRig))),\n     PrEECapsDf (q, vec3 (0.95, 0.4, -2.9) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 0.9, -0.25) + vec3 (0., 2., 0.) * s, rRig));\n  DMINQ (idRig);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  p.xz = Rot2D (p.xz, shipConf.w);\n  p.yz = Rot2D (p.yz, -1. * shipConf.z);\n  p.xy = Rot2D (p.xy, 6. * shipConf.y);\n  p.y -= shipConf.x + 4.1;\n  q = p;\n  dMin = dstFar;\n  dMin = ShipHullDf (q, dMin);\n  dMin = ShipMastDf (q, dMin);\n  dMin = ShipSailDf (q, dMin);\n  dMin = ShipRigDf (q, dMin);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid EvalShipConf ()\n{\n  vec4 h;\n  vec3 vd;\n  vec2 e;\n  e = vec2 (4., 0.);\n  h = vec4 (WaveHt (- e, 0.), WaveHt (e, 0.), WaveHt (- e.yx, 0.), WaveHt (e.yx, 0.));\n  shipConf = vec4 (0.25 * dot (h, vec4 (1.)), vec2 (h.xz - h.yw) / (2. * e.x), 0.15 * pi * sin (0.05 * tCur));\n  vim[0] = vec3 (0., -3.5, 4.3);   vd = vec3 (0., -2.6, 6.7) - vim[0];   vum[0] = vec4 (normalize (vd), length (vd));\n  vim[1] = vec3 (0., -4., 4.1);    vd = vec3 (0., -2.9, 6.) - vim[1];    vum[1] = vec4 (normalize (vd), length (vd));\n  vim[2] = vec3 (0., -1.2, -3.);   vd = vec3 (0., -0.5, -4.5) - vim[2];  vum[2] = vec4 (normalize (vd), length (vd));\n  vim[3] = vec3 (0., -2.7, -3.);   vd = vec3 (0., -2.7, -4.5) - vim[3];  vum[3] = vec4 (normalize (vd), length (vd));\n  vir[0] = vec3 (0., -3., -4.45);  vd = vec3 (0., -2.7, -4.5) - vir[0];  vur[0] = vec4 (normalize (vd), length (vd));\n  vir[1] = vec3 (0., 2.45, 2.65);  vd = vec3 (0., -2.7, 6.5) - vir[1];   vur[1] = vec4 (normalize (vd), length (vd));\n  vir[2] = vec3 (0., 2.5, 2.65);   vd = vec3 (0., -3.2, 4.9) - vir[2];   vur[2] = vec4 (normalize (vd), length (vd));\n  vir[3] = vec3 (0., 2.6, -3.);    vd = vec3 (0., -0.5, -4.5) - vir[3];  vur[3] = vec4 (normalize (vd), length (vd));\n  vir[4] = vec3 (0.65, -3.5, 3.5); vd = vec3 (0.05, -2.7, 6.4) - vir[4]; vur[4] = vec4 (normalize (vd), length (vd));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += clamp (h, 0.02, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.6  + 0.4 * sh;\n}\n\nvoid ShipCol (out vec4 col4, out vec2 vf)\n{\n  vec2 cg;\n  vf = vec2 (0.);\n  if (idObj == idHull) {\n    if (abs (qHit.x) < bDeck.x - 0.08 && qHit.y > -3.6 && qHit.z > - bDeck.z + 0.62) {\n      col4 = vec4 (0.5, 0.3, 0., 0.1) * (0.5 +\n         0.5 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.x, 1.)));\n    } else if (qHit.y > -4.) {\n      col4 = vec4 (0.7, 0.5, 0.1, 0.1);\n      if (abs (qHit.z - 4.) < 0.25 && abs (qHit.y + 3.55) < 0.05) col4 *= 1.2;\n      else if (qHit.z < -4. && abs (qHit.x) < 0.84 && abs (qHit.y + 3.62) < 0.125) {\n        cg = step (0.1, abs (fract (vec2 (6. * qHit.x, 8. * (qHit.y + 3.62)) + 0.5) - 0.5));\n        if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, 0.3);\n        else col4 *= 0.8;\n      } else {\n        col4 *= 0.7 + 0.3 * SmoothBump (0.06, 0.94, 0.03, mod (8. * qHit.y, 1.));\n        vf = vec2 (64., 0.3);\n      } \n    } else if (qHit.y > -4.05) {\n      col4 = vec4 (0.8, 0.8, 0.8, 0.1);\n    } else if (qHit.y < -4.7) {\n      col4 = vec4 (0.8, 0., 0., 0.1);\n      vf = vec2 (64., 2.);\n    } else {\n      col4 = vec4 (0.3, 0.2, 0.1, 0.);\n      vf = vec2 (64., 2.);\n    }\n  } else if (idObj == idRud) {\n    col4 = vec4 (0.5, 0.3, 0., 0.);\n  } else if (idObj == idStruc) {\n    col4 = vec4 (0.4, 0.3, 0.1, 0.1);\n    if (max (abs (qHit.x), abs (qHit.z + 0.22)) < 0.2) {\n      cg = step (0.1, abs (fract (vec2 (10. * vec2 (qHit.x, qHit.z + 0.22)) + 0.5) - 0.5));\n      if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, 0.3);\n    }\n  } else if (idObj == idSailT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.06, 0.94, 0.02, mod (4. * qHit.x, 1.)));\n  } else if (idObj == idSailA) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.06, 0.94, 0.02, mod (5. * qHit.z, 1.)));\n  } else if (idObj == idSailF) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.06, 0.94, 0.02,\n       mod (2.95 * qHit.y + 4. * qHit.z - 0.5, 1.)));\n  } else if (idObj == idFlag) {\n    col4 = vec4 (1., 1., 0.5, 0.1);\n    if (abs (abs (length (qHit.yz) - 0.1) - 0.04) < 0.02) col4 = vec4 (0.8, 0.2, 0.2, 0.1);\n  } else if (idObj == idMast) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (length (qHit.xz) < 0.16 * (1. - 0.07 * qHit.y)) col4 *= 0.6 + 0.4 * SmoothBump (0.04, 0.96, 0.01,\n       mod (2. * qHit.y / (1. + 0.14 * step (1., abs (qHit.z))), 1.));\n  } else if (idObj == idSparT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (0.7, 0.4, 0., 0.1) *  (0.6 + 0.4 * SmoothBump (0.08, 0.92, 0.01,\n       mod (4. * qHit.x, 1.)));\n  } else if (idObj == idSparL) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n  } else if (idObj == idRig) {\n    col4 = vec4 (0.25, 0.2, 0.15, 0.);\n    vf = vec2 (32., 0.5);\n  }\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y < 0.001) {\n    rd.y = 0.001;\n    rd = normalize (rd);\n  }\n  q = 0.01 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.2, 0.8, ff);\n  fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  skCol = vec3 (0.4, 0.5, 0.8);\n  sd = max (dot (rd, sunDir), 0.);\n  skCol = mix (skCol, vec3 (1., 1., 0.8), step (0.1, sd) *\n     0.2 * pow (sd, 128.) + 0.8 * pow (sd, 2048.));\n  col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  return col;\n}\n\nvec3 InShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vh4;\n  vec3 vn, col, watCol, row, rdw, rw, vnw;\n  vec2 vf;\n  float dstObj, dstWat, sh, hw;\n  bool waterRefl;\n  sailVel = vec3 (0., 0., 1.);\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  waterRefl = false;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    if (k == 0 || waterRefl) dstObj = ObjRay (ro, rd);\n    if (k == 0) {\n      waterRefl = (dstWat < min (dstFar, dstObj));\n      if (waterRefl) {\n        ro += dstWat * rd;\n        vh4 = WaveNf (ro, dstWat);\n        vnw = vh4.xyz;\n        hw = vh4.w;\n        row = ro;\n        rdw = rd;\n        rd = reflect (rd, vnw);\n        ro += 0.01 * rd;\n      }\n    }\n  }\n  if (dstObj < min (dstWat, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    ShipCol (col4, vf);\n    sh = waterRefl ? 1. : ObjSShadow (ro + 0.01 * vn, sunDir);\n    if (vf.x > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n    col = col4.rgb * (0.2 + 0.1 * max (dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) + col4.a * step (0.95, sh) * pow (max (0.,\n       dot (sunDir, reflect (rd, vn))), 32.);\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (waterRefl) {\n    rw = row + sailVel * tCur;\n    vnw = VaryNf (rw, vnw, 1. - smoothstep (0.1, 0.4, dstWat / dstFar));\n    watCol = mix (vec3 (0., 0.2, 0.4), vec3 (0., 0.15, 0.3),\n       smoothstep (0.3, 0.7, Fbm2 (0.25 * rw.xz))) *\n       (0.3 + 0.7 * (max (vnw.y, 0.) + 0.1 * pow (max (0., dot (sunDir, reflect (rdw, vnw))), 32.)));\n    col = mix (watCol, 0.7 * col, pow (1. - abs (dot (rdw, vnw)), 5.));\n    col = mix (col, SkyCol (row, rdw), smoothstep (0.7, 0.95, dstWat / dstFar));\n  }\n  if (monoImg) col = vec3 (1., 0.3, 0.7) * pow (Maxv3 (col), 1.2);\n  return clamp (col, 0., 1.);\n}\n\nvec3 InMain (vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  float el, az;\n  az = 0.9 * pi;\n  el = -0.05 * pi;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (-1., 3., -25.);\n  rd = vuMat * normalize (vec3 (fCoord, 4.));\n  sunDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n  return clamp (InShowScene (ro, rd), 0., 1.);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec4 t;\n  t = vec4 (mod (p.xy + 0.1, 0.2) - 0.1, abs (p.yx) - 1.21);\n  return SmoothMax (PrBoxDf (p, vec3 (1.2, 1.2, 0.02)), 0.08 -\n     min (length (t.xz), length (t.yw)), 0.01);\n }\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp, u, vn;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 db4;\n  vec3 col, vn;\n  vec2 q;\n  float dstExObj, s;\n  col = vec3 (0.1, 0.12, 0.1);\n  db4 = BlkHit (ro, rd, vec3 (1.55, 1.35, 0.15));\n  if (db4.x < dstFar) {\n    dstExObj = ExObjRay (ro, rd);\n    if (dstExObj < dstFar) {\n      ro += dstExObj * rd;\n      vn = ExObjNf (ro);\n      if (max (abs (ro.x), abs (ro.y)) < 1. && ro.z < -0.01) col = InMain (ro.xy);\n      else col = vec3 (0.8, 0.2, 0.6) * (0.8 + 0.2 * Fbm2 (128. * ro.xy)) *\n         (0.2 + 0.8 * max (dot (vn, ltDirEx), 0.));\n      if (ro.z < -0.01) {\n        q = ro.xy - vec2 (0.95, -0.95);\n        s = abs (length (q) - 0.25) - 0.02;\n        col = mix (vec3 (0.1), col, min (smoothstep (0.002, 0.005, abs (s)), 1. - step (s, 0.) *\n           smoothstep (0.85, 0.9, mod (30. * (atan (q.y, q.x) / (2. * pi) + 0.5), 1.))));\n      }\n    }\n  }\n  if (db4.x < min (dstExObj, dstFar)) {\n    vn = db4.yzw;\n    col = mix (col, vec3 (1.) * (0.2 + 0.8 * max (dot (vn, ltDirEx), 0.)) +\n       0.1 * pow (max (0., dot (ltDirEx, reflect (rd, vn))), 32.),\n       0.1 + 0.9 * pow (1. - abs (dot (rd, vn)), 4.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  monoImg = false;\n  if (mPtr.z > 0. && mPtr.x > 0.4 && mPtr.y < -0.4) monoImg = true;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && ! monoImg) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -9.);\n  dstFar = 100.;\n  ltDirEx = vuMat * normalize (vec3 (1., 1., -1.));\n  EvalShipConf ();\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 6.));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEVCapsDf (vec3 p, vec4 u, float r)\n{\n  return length (p - clamp (dot (p, u.xyz), 0., u.w) * u.xyz) - r;\n}\n\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r)\n{\n  return PrEVCapsDf (p - v1, vec4 (normalize (v2 - v1), length (v2 - v1)), r);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsSWS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1696, 1696, 1728, 1728, 2365], [2367, 2367, 2398, 2398, 2600], [2602, 2602, 2641, 2641, 3838], [3840, 3840, 3879, 3879, 4758], [4760, 4760, 4799, 4799, 5825], [5827, 5827, 5865, 5865, 7171], [7173, 7173, 7195, 7195, 7534], [7536, 7536, 7569, 7569, 7752], [7754, 7754, 7775, 7775, 8030], [8032, 8032, 8054, 8054, 9368], [9370, 9370, 9407, 9407, 9656], [9658, 9658, 9701, 9701, 12439], [12441, 12441, 12473, 12473, 13173], [13175, 13175, 13212, 13212, 14931], [14933, 14933, 14960, 14960, 15254], [15256, 15256, 15280, 15280, 15465], [15467, 15467, 15502, 15502, 15687], [15689, 15689, 15712, 15712, 15969], [15971, 15971, 16012, 16012, 16314], [16316, 16316, 16353, 16353, 17450], [17452, 17452, 17508, 17508, 18558], [18560, 18560, 18592, 18592, 18692], [18694, 18694, 18727, 18727, 18816], [18818, 18818, 18860, 18860, 18911], [18913, 18913, 18956, 18956, 19020], [19022, 19022, 19066, 19066, 19135], [19137, 19137, 19191, 19191, 19272], [19274, 19274, 19296, 19296, 19334], [19336, 19336, 19358, 19358, 19396], [19398, 19398, 19443, 19443, 19546], [19548, 19548, 19593, 19593, 19631], [19633, 19633, 19690, 19690, 19773], [19775, 19775, 19805, 19805, 19918], [19920, 19920, 19956, 19956, 20162], [20196, 20196, 20220, 20220, 20332], [20334, 20334, 20358, 20358, 20421], [20423, 20423, 20448, 20448, 20634], [20636, 20636, 20661, 20661, 20998], [21000, 21000, 21021, 21021, 21176], [21178, 21178, 21207, 21207, 21419], [21421, 21421, 21460, 21460, 21712]], "test": "error"}
{"id": "ftSSWw", "name": "COLOURBURSTII", "author": "jj99", "description": "colors", "tags": ["fbm"], "likes": 13, "viewed": 263, "published": "Public API", "date": "1627752341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*758.5453)*2.;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    //f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n            mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02+0.15;\n    f -= 0.25000*noise( p ); p = p*2.03+0.15;\n    f += 0.12500*noise( p ); p = p*2.01+0.15;\n    f += 0.06250*noise( p ); p = p*2.04+0.15;\n    f -= 0.03125*noise( p );\n    return f/0.984375;\n}\n\nfloat cloud(vec3 p)\n{\n    p-=fbm(vec3(p.x,p.y,0.0)*0.5)*0.7;\n    \n    float a =0.0;\n    a-=fbm(p*3.0)*2.2-1.1;\n    if (a<0.0) a=0.0;\n    a=a*a;\n    return a;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.09);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nvec3 n2 (vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float dd = length(uv*uv)*.025;\n    \n\tvec3 rd = vec3(uv.x, uv.y, 1.0);\n    \n    float rip = 0.5+sin(length(uv)*20.0+iTime)*0.5;\n    rip = pow(rip*.38,4.15);\n    rd.z=1.0+rip*1.15;// apply a subtle ripple\n    rd = normalize(rd);\n    //rd.xy *= rot(dd-iTime*.025);\n    rd*=2.0;\n\t\n\tfloat c = noiseLayers(rd*1.85);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.55,2.5);    \n    vec3 col =  vec3(.55,0.85,.25);\n    vec3 col2 =  vec3(1.4,1.4,1.4)*5.0;\n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n\tvec2 position = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat ss = sin(length(position*3.0)+time*0.125);\n\tss+=5.0;\n    \n    \n   \tvec2 coord = ss*position;\n        coord*=rot(ss*0.1+time*0.037);\n    \n    \n    coord+=fbm(sin(vec3(coord*8.0,time*0.001)))*0.08;\n    coord+=time*0.0171;\n    float q = cloud((vec3(coord*1.0,0.222)));\n    coord+=time*0.0171;\n    q += cloud((vec3(coord*0.6,0.722)));\n    coord+=time*0.0171;\n    q += cloud(vec3(coord*0.3,.722));\n    coord+=time*0.1171;\n    q += cloud((vec3(coord*0.1,0.722)));\n    \n    \n\tfloat vv1 = sin(time+ss+coord.x)*0.3;\n\tfloat vv2 = sin(time*0.9+ss+coord.y)*0.2;\n\nvec3    col = vec3(1.7-vv2,1.7,1.7+vv1) + vec3(q*vec3(0.7+vv1,0.5,0.3+vv2*1.15));\n\tcol = pow(col,vec3(2.2));\n\t\n\tfloat dd = length(col*.48)+vv1;\n\t\n\tfloat nn = 0.5+sin(ss*2.7+position.x*2.41+time*0.9)*0.5;\n\t\n    vec3 col2 = n2(fragCoord)*12.0;\n    col2+=col;\n\tcol = mix(col,col2,nn);\n\t\n    fragColor = vec4( col*0.08, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 63], [65, 65, 91, 91, 440], [442, 442, 461, 461, 718], [720, 720, 741, 741, 879], [881, 881, 902, 902, 970], [973, 973, 994, 994, 1201], [1204, 1224, 1246, 1246, 1643], [1645, 1658, 1688, 1688, 1961], [1963, 1963, 1989, 1989, 2707], [2710, 2710, 2767, 2767, 3751]], "test": "valid"}
{"id": "ftsXD2", "name": "fractal swirl", "author": "TLC123", "description": "swirl distorting noise octaves\nBroken with discontinuities", "tags": ["noise"], "likes": 2, "viewed": 45, "published": "Public", "date": "1626609933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\nmat2 transMatrix(vec2 t)\n{\n \n    return mat2( t.x,0, 0, t.y );\n}\n\nvec3 tex(vec2 uv)\n{\n uv*=1.;\n\nvec2 offs,juv ,f ,c;\nfloat scale=1.,le;\n\n for(int i=0;i<5;i++){\n\n f=floor(uv);\n  \nvec2 s=vec2(0,scale);\nvec2[] tab =vec2[](f+s.xx,f+s.yx,f+s.yy,f+s.xy);\nfor(int j=0;j<4;j++){\noffs=tab[j]-uv;\nuv -=offs*1.;\n  le=length(uv+offs*scale*scale );\nuv *= rotationMatrix( (sin( 7.*(iTime/7.)+float(i+j*10))*4.) *4.0 * sin(iTime*.1) * clamp( 1./   le   ,0.,3.));\nuv+=offs*1.;\n }\n uv*=2.2;\n scale*=2.2;\n uv *= rotationMatrix(PI/3.+sin(float(i))*.7);\n }\n \nreturn vec3(mod(floor(uv.x *15./scale)   ,2.) ) ;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\nvec3 col=tex(uv);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsXD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 51, 51, 145], [146, 146, 172, 172, 210], [739, 739, 796, 846, 994]], "test": "error"}
{"id": "ftsXD4", "name": "An Indian Flag", "author": "Bhavesh_s_", "description": "this is an Indian flag, inspired from bigwings US flag shader tutorial.", "tags": ["flag", "india", "indian"], "likes": 3, "viewed": 57, "published": "Public", "date": "1625711588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    \"An Indian flag\"\n    Created as a learning initiative of shader development.\n    This is inspired from the US flag created by BigWIngs (https://www.shadertoy.com/view/flsXRM)\n*/\n\n#define PI 3.14159265359\n\nvec3 safron = vec3(255.0,153.0,51.0)/255.0;\nvec3 white = vec3(1);\nvec3 green = vec3(19.0,136.0,8.0)/255.0;\nvec3 navyBlue = vec3(0,0,128.0)/255.0;\n\nfloat circle(vec2 uv, float r){\n    float d = length(uv);\n    return smoothstep(d-0.003,d,r);\n}\n\n// Ashoka Chakra in the center of the flag\nfloat Chakra(vec2 uv,float radius){\n    float bCircle = circle(uv,radius+0.02);\n\tfloat cCircle = circle(uv,0.03);\n    float iCircle = circle(uv,radius);\n    iCircle -= cCircle;\n    \n\tfloat count = 24.0;\n    float div = (count)*0.25;\n    \n    for(float i=0.0; i < 24.0; i += 1.0){\n        float turn = i / count;\n        float offset = ((1.0/count)/2.0);\n        float theta = (turn + offset) * (2.0 * PI);\n        vec2 p = vec2(sin(theta),cos(theta)) * radius;\n        float c = circle(uv-p,radius*0.04);\n        \n        float alfa = ((1.0 / count) * (i - div) * (2.0 * PI));\n        float shift = 0.07;\n        float a = alfa + shift;\n        float b = alfa - shift;\n        float angle = (turn) * (2.0 * PI);\n        p = vec2(sin(angle),cos(angle)) * (radius*(0.50));\n        float d1 = dot(uv - p,vec2(sin(a),cos(a)));\n        float d2 = dot(uv - p,-vec2(sin(b),cos(b)));\n        float d3 = dot(uv - p,-vec2(sin(a),cos(a)));\n        float d4 = dot(uv - p,vec2(sin(b),cos(b)));\n        \n        float d = max(max(d1,d2),max(d3,d4))-0.002;\n        iCircle -= smoothstep(0.003,0.0,d);\n        iCircle -= min(iCircle,c);\n    }\n\n    return bCircle - iCircle ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= aspectRatio;\n    \n    float t = uv.x*4.-2.*iTime+uv.y*6.;\n    uv.y += sin(t) * 0.04;\n\n    uv.y *= 3.0;\n\n\tvec3 color = vec3(0);\n    white = step(1.0,uv.y)*white;\n    green= step(0.0,uv.y)*green;\n    safron = step(2.0,uv.y)*safron;\n\n\n\tif(uv.y<3.0){color = safron;}\n    if(uv.y<2.0){color=white;}\n    if(uv.y<1.0){color=green;}\n    \n    uv.y /= 3.0;\n    uv -= vec2(aspectRatio/2.0,0.5);\n    color -= (vec3(Chakra(uv,0.12)) * (white - navyBlue));\n    \n    color *= 0.7 - cos(t) * 0.3;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 359, 390, 390, 454], [456, 499, 534, 534, 1659], [1661, 1661, 1717, 1717, 2339]], "test": "valid"}
{"id": "ftsXD8", "name": "Dim in Another World", "author": "squid", "description": ".", "tags": ["3d"], "likes": 3, "viewed": 142, "published": "Public API", "date": "1625614873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535898\n\n#define MOD2 vec2(443.8975,397.2973)\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\nfloat hash13(vec3 p)\n{\n\tp  = fract(p * MOD3);\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\nvec3 hash33(vec3 p)\n{\n\tp = fract(p * MOD3);\n    p += dot(p.zxy, p+19.19);\n    return fract(vec3(p.x * p.y, p.x*p.z, p.y*p.z));\n}\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx) * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\nmat2 rot2(float a){\n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat SM(float a, float b, float k)\n{\n    float xp = clamp(-(b-a) * k + 0.5, 0.0, 1.0), xp2 = xp*xp;\n   \treturn a+min((b-a), xp2 * (xp2 * 0.5 - xp) / k);\n}\n\nvec2 U(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 path(float ct) {\n    return vec3(cos(ct*0.05)*6.,sin(ct*0.4)*1.6+10.0, ct*3.);\n}\n\nfloat height(vec2 p) {\n    return (sin(p.y*0.5+63.)+sin(p.x*0.5-23.))*1. + (cos(p.y*0.06-35.)+cos(p.x*0.02+95.))*2. + 3.;\n}\n\nvec2 map_(vec3 p){\n    float lt = p.y - height(p.xz);\n    vec3 q = mod(p, 8.)-4.;\n    vec4 h = hash43(floor(p/8.));\n    lt = max(lt, (3.+h.x*h.y)-length(q));\n    return vec2(lt, 1.);\n}\nfloat map(vec3 p) { return map_(p).x; }\n\nvec3 N(in vec3 p)\n{  \n    vec2 e = vec2(-1.,1.)*0.01;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\nfloat G(vec3 uv, float width) {\n\tvec3 c = max(step(abs(uv), vec3(width*.5))*.8,step(fract(uv), vec3(width*1.2))*.2);\n\treturn max(c.x,max(c.y,c.z));\n}\n\n\nvec2 trace(in vec3 ro, in vec3 rd) {\n    float t = 0., dt;\n\tfor(int i=0; i<512; i++){\n\t\tdt = map(ro + rd*t);\n\t\tif(dt<5e-3 || t > 150.) break;\n\t\tt += dt*0.5;\n\t}\n    return vec2(t,dt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    vec3 ro = path(iTime) + vec3(0., 0.0, -2.);\n\tvec3 c,sp,\n        f = normalize(path(iTime+1.)-ro),\n        r = normalize(vec3(f.z, 0., -f.x)),\n        u = cross(f, r),\n        rd = normalize(f + uv.x*r + uv.y*u);\n    \n    const vec3 sun = normalize(vec3(0.15,0.125,0.6));\n    const vec3 sun_col = vec3(1.0,0.8,0.5);\n    const vec3 lamp_col = vec3(0.9,0.99,0.75);\n    const vec3 surf = vec3(0.6,0.6,0.64);\n        \n\tvec2 trs = trace(ro, rd);\n\tfloat t = trs.x, dt = trs.y, x;\n\tif(dt<5e-3){\n    \tsp = t * rd+ro;\n        x = map_(sp).y;\n        vec3 n = N(sp);\n        vec3 L = (sp-(path(iTime+8.0)));\n        float Ld = length(L);\n        L /= -Ld;\n        c = min(1./(0.05*Ld*Ld),1.0)*lamp_col * max(dot(L,n),0.) * surf * (trace(sp+L*0.1,L).y<5e-3?0.:1.) +\n            sun_col * max(dot(sun,n),0.) * surf * (trace(sp+sun*0.1,sun).y<5e-3?0.:1.) +\n            0.5*(1.-surf)*pow(max(1.-abs(dot(n, rd)), 0.),10.);\n        c = mix(c, vec3(0.0), t/150.0);\n\t} else {\n        c = pow(dot(rd,sun),2000.)*sun_col;\n    }\n    c = mix(c, vec3(0.0), pow(length(uv*vec2(0.9,1.2)),5.));\n    c = pow(c, vec3(0.735));\n\t\n\tfragColor = c.xyzz;\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 191, 191, 287], [289, 289, 310, 310, 446], [447, 447, 468, 468, 575], [576, 576, 597, 597, 742], [744, 744, 763, 763, 832], [834, 834, 871, 871, 989], [991, 991, 1015, 1015, 1047], [1049, 1049, 1082, 1082, 1135], [1137, 1137, 1189, 1189, 1296], [1298, 1298, 1319, 1319, 1383], [1385, 1385, 1407, 1407, 1508], [1510, 1510, 1528, 1528, 1694], [1695, 1695, 1714, 1714, 1734], [1736, 1736, 1755, 1755, 1915], [1918, 1918, 1949, 1949, 2067], [2070, 2070, 2106, 2106, 2254], [2256, 2256, 2312, 2312, 3503]], "test": "valid"}
{"id": "ftSXDR", "name": "sws3005_A5-ray tracing", "author": "sws3005_09", "description": "This is the task 2 of assignment 5 of NUS SOC summer workshop 2021.", "tags": ["raytracing"], "likes": 7, "viewed": 276, "published": "Public API", "date": "1627386446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.3, 0.2, 0.3);\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 4;\nconst int NUM_PLANES = 6;\nconst int NUM_CYLINDERS = 4;\nconst int NUM_SPHERES = 27;\n\n// Beat Frequnce for the music\nconst float beatFreq = 115.0 / 60.0;\n\n//Parameters for block\nfloat blockNum = 4.0;\nfloat blockLength = 0.45;\n\n// Time for change\nfloat MyITime;\n\n// The Ball to Show\nint ShowBallNumber;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Cylinder_t{\n    vec3 center;\n    float radius;\n    float height;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCylinder_t Cylinder[NUM_CYLINDERS];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\nSphere_t showSphere[NUM_SPHERES];\n\n\n// Init The Item to be show\nvoid initShowItem(){\n    ShowBallNumber = 0;\n    float OneCircleTime = 2.0 * 8.0 / beatFreq;\n    float nowRoundTime = mod(MyITime / OneCircleTime, 21.0);\n    //Phase1\n    if(nowRoundTime<3.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            showSphere[ShowBallNumber].center.y -= 1.9*(1.0-(nowRoundTime/3.0));\n            ShowBallNumber++;\n        }\n    }\n    //Phase2\n    else if(nowRoundTime>=3.0 && nowRoundTime<4.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n    }\n    //Phase3\n    else if(nowRoundTime>=4.0 && nowRoundTime<6.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=18; i<27; i++){\n            showSphere[i].center.xz *= (1.0 + 1.0*(nowRoundTime-4.0)/2.0);\n        }\n    }\n    //Phase4\n    else if(nowRoundTime>=6.0 && nowRoundTime<8.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=18; i<27; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n        for(int i=9; i<18; i++){\n            showSphere[i].center.xz *= (1.0 + 1.0*(nowRoundTime-6.0)/2.0);\n        }\n    }\n    //Phase5\n    else if(nowRoundTime>=8.0 && nowRoundTime<10.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=18; i<27; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n        for(int i=9; i<18; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n        for(int i=0; i<9; i++){\n            showSphere[i].center.xz *=(1.0 + 1.0*(nowRoundTime-8.0)/2.0);\n        }\n    }\n    //Phase6\n    else if(nowRoundTime>=10.0 && nowRoundTime<12.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=18; i<27; i++){\n            showSphere[i].center.xz *= (2.0 - 1.0*(nowRoundTime-10.0)/2.0);\n        }\n        for(int i=9; i<18; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n        for(int i=0; i<9; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n    }\n    //Phase7\n    else if(nowRoundTime>=12.0 && nowRoundTime<14.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=9; i<18; i++){\n            showSphere[i].center.xz *= (2.0 - 1.0*(nowRoundTime-12.0)/2.0);\n        }\n        for(int i=0; i<9; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n    }\n    //Phase8\n    else if(nowRoundTime>=14.0 && nowRoundTime<16.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=0; i<9; i++){\n            showSphere[i].center.xz *= (2.0 - 1.0*(nowRoundTime-14.0)/2.0);\n        }\n    }\n    //Phase9\n    else if(nowRoundTime>=16.0 && nowRoundTime<17.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n    }\n    //Phase10\n    else if(nowRoundTime>=17.0 && nowRoundTime<20.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            showSphere[ShowBallNumber].center.y -= 1.9*((nowRoundTime-17.0)/3.0);\n            ShowBallNumber++;\n        }\n    }\n    //Phase11\n    else if(nowRoundTime>=20.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            showSphere[ShowBallNumber].center.y -= 1.9;\n            ShowBallNumber++;\n        }\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n     // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 3;\n\n    Plane[5].A = 0.0;\n    Plane[5].B = 1.0;\n    Plane[5].C = 0.0;\n    Plane[5].D = -8.5;\n    Plane[5].materialID = 3;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 4.5;\n    Plane[1].materialID = 3;\n    \n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 4.5;\n    Plane[2].materialID = 3;\n\n    Plane[3].A = 0.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 1.0;\n    Plane[3].D = -4.5;\n    Plane[3].materialID = 3;\n\n    Plane[4].A = 1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = -4.5;\n    Plane[4].materialID = 3;\n\n    MyITime = 2.0 * PI * iTime * beatFreq / 8.0;\n\n    // The upper spheres\n    Sphere[0].center = vec3( 0.2 * cos(MyITime), 1.7, 1.0 * sin(MyITime) );\n    Sphere[0].radius = 0.2;\n    Sphere[0].materialID = 1;\n    Sphere[1].center = vec3( 0.2 * cos(MyITime), 1.7, 0.2 * sin(MyITime) );\n    Sphere[1].radius = 0.2;\n    Sphere[1].materialID = 1;\n    Sphere[2].center = vec3( 0.7 * cos(MyITime), 1.7, 0.5* sin(MyITime) );\n    Sphere[2].radius = 0.2;\n    Sphere[2].materialID = 1;\n    Sphere[3].center = vec3( 1.4 * cos(MyITime), 1.7, 0.5* sin(MyITime) );\n    Sphere[3].radius = 0.2;\n    Sphere[3].materialID = 1;\n    Sphere[4].center = vec3( 1.4 * cos(MyITime), 1.7, 1.5* sin(MyITime) );\n    Sphere[4].radius = 0.2;\n    Sphere[4].materialID = 1;\n    Sphere[5].center = vec3( 0.7 * cos(MyITime), 1.7, 1.5* sin(MyITime) );\n    Sphere[5].radius = 0.2;\n    Sphere[5].materialID = 1;\n    Sphere[6].center = vec3( 1.4 * cos(MyITime), 1.7, 2.2* sin(MyITime) );\n    Sphere[6].radius = 0.2;\n    Sphere[6].materialID = 1;\n    Sphere[7].center = vec3( 0.7 * cos(MyITime), 1.7, 2.0* sin(MyITime) );\n    Sphere[7].radius = 0.2;\n    Sphere[7].materialID = 1;\n    Sphere[8].center = vec3( 0.2 * cos(MyITime), 1.7, 2.1* sin(MyITime) );\n    Sphere[8].radius = 0.2;\n    Sphere[8].materialID = 1;\n\n    //The middle spheres and color changing\n    Sphere[9].center = vec3( 0.2 * cos(MyITime), 1.1, 0.2 * sin(MyITime) );\n    Sphere[9].radius = 0.25;\n    Sphere[9].materialID =  (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[10].center = vec3( 0.2 * cos(MyITime), 1.1, 1.0 * sin(MyITime) );\n    Sphere[10].radius = 0.25;\n    Sphere[10].materialID =  (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[11].center = vec3( 0.7 * cos(MyITime), 1.1, 0.5* sin(MyITime) );\n    Sphere[11].radius = 0.25;\n    Sphere[11].materialID = (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[12].center = vec3( 1.4 * cos(MyITime), 1.1, 0.5* sin(MyITime) );\n    Sphere[12].radius = 0.25;\n    Sphere[12].materialID = (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[13].center = vec3( 1.4 * cos(MyITime), 1.1, 1.5* sin(MyITime) );\n    Sphere[13].radius = 0.25;\n    Sphere[13].materialID = (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[14].center = vec3( 0.7 * cos(MyITime), 1.1, 2.0* sin(MyITime) );\n    Sphere[14].radius = 0.25;\n    Sphere[14].materialID =  (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[15].center = vec3( 0.7 * cos(MyITime), 1.1, 1.5* sin(MyITime) );\n    Sphere[15].radius = 0.25;\n    Sphere[15].materialID =  (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[16].center = vec3( 0.2 * cos(MyITime), 1.1, 2.1* sin(MyITime) );\n    Sphere[16].radius = 0.25;\n    Sphere[16].materialID = (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[17].center = vec3( 1.4 * cos(MyITime), 1.1, 2.2* sin(MyITime) );\n    Sphere[17].radius = 0.25;\n    Sphere[17].materialID = (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n                    \n   \n    //The lower spheres\n    Sphere[18].center = vec3( 0.2 * cos(MyITime), 0.5, 1.0 * sin(MyITime) );\n    Sphere[18].radius = 0.2;\n    Sphere[18].materialID = 1;\n    Sphere[19].center = vec3( 0.2 * cos(MyITime), 0.5, 0.2 * sin(MyITime) );\n    Sphere[19].radius = 0.2;\n    Sphere[19].materialID = 1;\n    Sphere[20].center = vec3( 0.7 * cos(MyITime), 0.5, 0.5* sin(MyITime) );\n    Sphere[20].radius = 0.2;\n    Sphere[20].materialID = 1;\n    Sphere[21].center = vec3( 1.4 * cos(MyITime), 0.5, 0.5* sin(MyITime) );\n    Sphere[21].radius = 0.2;\n    Sphere[21].materialID = 1; \n    Sphere[22].center = vec3( 1.4 * cos(MyITime), 0.5, 1.5* sin(MyITime) );\n    Sphere[22].radius = 0.2;\n    Sphere[22].materialID = 1;\n    Sphere[23].center = vec3( 0.7 * cos(MyITime), 0.5, 1.5* sin(MyITime) );\n    Sphere[23].radius = 0.2;\n    Sphere[23].materialID = 1;\n    Sphere[24].center = vec3( 0.7 * cos(MyITime), 0.5, 2.0* sin(MyITime) );\n    Sphere[24].radius = 0.2;\n    Sphere[24].materialID = 1;\n    Sphere[25].center = vec3( 1.4 * cos(MyITime), 0.5, 2.2* sin(MyITime) );\n    Sphere[25].radius = 0.2;\n    Sphere[25].materialID = 1;\n    Sphere[26].center = vec3( 0.2 * cos(MyITime), 0.5, 2.1* sin(MyITime) );\n    Sphere[26].radius = 0.2;\n    Sphere[26].materialID = 1;\n    \n    //The Cyclinder\n    Cylinder[0].center = vec3(3.5, -0.5, 3.5);\n    Cylinder[0].radius = 0.3;\n    Cylinder[0].height = 10.0;\n    Cylinder[0].materialID = 3;\n\n    Cylinder[1].center = vec3(-3.5, -0.5, 3.5);\n    Cylinder[1].radius = 0.3;\n    Cylinder[1].height = 10.0;\n    Cylinder[1].materialID = 3;\n\n    Cylinder[2].center = vec3(3.5, -0.5, -3.5);\n    Cylinder[2].radius = 0.3;\n    Cylinder[2].height = 10.0;\n    Cylinder[2].materialID = 3;\n\n    Cylinder[3].center = vec3(-3.5, -0.5, -3.5);\n    Cylinder[3].radius = 0.3;\n    Cylinder[3].height = 10.0;\n    Cylinder[3].materialID = 3;\n\n    // red\n    Material[0].k_d = vec3( 0.6, 0.2, 0.2 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    //silver\n    Material[1].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n    \n    //green\n    Material[2].k_d = vec3( 0.0, 0.2, 0.2 );\n    Material[2].k_a = 0.4 * Material[2].k_d;\n    Material[2].k_r = 3.0 * Material[2].k_d;\n    Material[2].k_rg = 0.2 * Material[2].k_r;\n    Material[2].n = 64.0;\n\n    //Special Material\n    Material[3].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[3].k_a = 0.2 * Material[1].k_d;\n    Material[3].k_r = 2.0 * Material[1].k_d;\n    Material[3].k_rg = 0.1 * Material[1].k_r;\n    Material[3].n = 64.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0, 0.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    initShowItem();\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 rayOriInSphere = ray.o - sph.center;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(ray.d, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - sph.radius * sph.radius;\n    float d = b*b - 4.0*a*c;\n    if(d<0.0) return false;\n    float t1 = (-1.0*b + sqrt(d))/(2.0*a);\n    float t2 = (-1.0*b - sqrt(d))/(2.0*a);\n\n    float finalT;\n    bool isSatisfy = false;\n    if(t1>=tmin && t1<=tmax){\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2>=tmin && t2<=tmax){\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false) return false;\n\n    t = finalT;\n    hitPos = ray.o + finalT * ray.d;\n    hitNormal = (hitPos - sph.center)/sph.radius;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 rayOriInSphere = ray.o - sph.center;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(ray.d, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - sph.radius * sph.radius;\n    float d = b*b - 4.0*a*c;\n    if(d<0.0) return false;\n    float t1 = (-1.0*b + sqrt(d))/(2.0*a);\n    float t2 = (-1.0*b - sqrt(d))/(2.0*a);\n\n    float finalT;\n    bool isSatisfy = false;\n    if(t1>=tmin && t1<=tmax){\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2>=tmin && t2<=tmax){\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false) return false;\n    return true;\n}\n\nbool IntersectionCylinder(in Cylinder_t cyl, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal){\n    vec2 rayOriInSphere = ray.o.xz - cyl.center.xz;\n    float a = dot(ray.d.xz, ray.d.xz);\n    float b = 2.0 * dot(ray.d.xz, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - cyl.radius * cyl.radius;\n    float d = b*b - 4.0*a*c;\n    if(d<0.0) return false;\n    float t1 = (-1.0*b + sqrt(d))/(2.0*a);\n    float t2 = (-1.0*b - sqrt(d))/(2.0*a);\n    float finalT;\n    bool isSatisfy = false;\n    if(t1>=tmin && t1<=tmax){\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2>=tmin && t2<=tmax){\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false) return false;\n    t = finalT;\n    hitPos = ray.o + finalT * ray.d;\n    hitNormal = hitPos - cyl.center;\n    if(hitNormal.y - cyl.center.y<0.0 || hitNormal.y - cyl.center.y>cyl.height) return false;\n    hitNormal.y = 0.0;\n    hitNormal = hitNormal / cyl.radius;\n    return true;\n}\n\nbool IntersectionCylinder(in Cylinder_t cyl, in Ray_t ray, in float tmin, in float tmax){\n    vec2 rayOriInSphere = ray.o.xy - cyl.center.xy;\n    float a = dot(ray.d.xy, ray.d.xy);\n    float b = 2.0 * dot(ray.d.xy, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - cyl.radius * cyl.radius;\n    float d = b*b - 4.0*a*c;\n    if(d<0.0) return false;\n    float t1 = (-1.0*b + sqrt(d))/(2.0*a);\n    float t2 = (-1.0*b - sqrt(d))/(2.0*a);\n    float finalT;\n    bool isSatisfy = false;\n    if(t1>=tmin && t1<=tmax){\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2>=tmin && t2<=tmax){\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n//refer to https://www.shadertoy.com/view/XdB3Dw\nvec3 squaresColours(vec2 p)\n{\n\tp+=vec2(MyITime*0.2);\n\t\n\tvec3 orange=vec3(1.0,0.4,0.1)*2.0;\n\tvec3 purple=vec3(1.0,0.2,0.5)*0.8;\n\t\n\tfloat l=pow(0.5+0.5*cos(p.x*7.0+cos(p.y)*8.0)*sin(p.y*2.0),4.0)*2.0;\n\tvec3 c=pow(l*(mix(orange,purple,0.5+0.5*cos(p.x*40.0+sin(p.y*10.0)*3.0))+\n\t\t\t\t  mix(orange,purple,0.5+0.5*cos(p.x*20.0+sin(p.y*3.0)*3.0))),vec3(1.2))*0.7;\n\t\n\tc+=vec3(1.0,0.8,0.4)*pow(0.5+0.5*cos(p.x*20.0)*sin(p.y*12.0),20.0)*2.0;\n\t\n\tc+=vec3(0.1,0.5+0.5*cos(p*20.0))*vec3(0.05,0.1,0.4).bgr*0.7;\n\t\n\treturn c;\n}\n\nvec3 calculateColor(vec2 p,float border){\n    float sm=0.02;\n\tvec2 res=vec2(3.5);\n\tvec2 ip=floor(p*res)/res;\n\tvec2 fp=fract(p*res);\n\tfloat m=1.0-max(smoothstep(border-sm,border,abs(fp.x-0.5)),smoothstep(border-sm,border,abs(fp.y-0.5)));\n\tm+=1.0-smoothstep(0.0,0.56,distance(fp,vec2(0.5)));\n\treturn m*squaresColours(ip);\n}\n\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Light_t light, vec3 nearest_hitPos, int hitWhichPlane )\n{\n    Material_t mat = Material[1];\n    vec2 p, intPart;\n    float countIntPart;\n    if(hitWhichPlane == 0 || hitWhichPlane == 5) p = nearest_hitPos.xz;\n    else if(hitWhichPlane == 1 || hitWhichPlane == 3) p = nearest_hitPos.xy;\n    else if(hitWhichPlane == 2 || hitWhichPlane == 4) p = nearest_hitPos.yz;\n    else if(hitWhichPlane < 0){p.y = nearest_hitPos.y; p.x = length(nearest_hitPos.xz);}\n    p = p / blockNum;\n    mat.k_d = calculateColor(p, blockLength);\n    mat.k_a = 0.4 * mat.k_d;\n    mat.k_r = 3.0 * mat.k_d;\n\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    //which Plane does it hit\n    int hitWhichPlane;\n\n    //Intersection with the plane\n    for(int i=0; i<NUM_PLANES; i++){\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t<nearest_t){\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Plane[i].materialID;\n            hitWhichPlane = i;\n        }\n    }\n    //Intersection with the sphere\n    for(int i=0; i<ShowBallNumber; i++){\n        temp_hasHit = IntersectSphere(showSphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t<nearest_t){\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Sphere[i].materialID;\n        }\n    }\n    //Intersection with the cylinder\n    for(int i=0; i<NUM_CYLINDERS; i++){\n        temp_hasHit = IntersectionCylinder(Cylinder[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t<nearest_t){\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Cylinder[i].materialID;\n            hitWhichPlane = -1;\n        }\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    for(int i=0; i<NUM_LIGHTS; i++){\n        // Check whether it is in shadow\n        bool inShadow = false, tempInShadow;\n        Ray_t shadowRay;\n        shadowRay.o = nearest_hitPos;\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n        // Since it is a line segement, we need to find the endpoint's t value\n        float LineSegmentMin = DEFAULT_TMIN;\n        float LineSegmentMax = length(Light[i].position - nearest_hitPos);\n        for(int j=0; j<NUM_PLANES; j++){\n            if(inShadow) break;\n            tempInShadow = IntersectPlane(Plane[j], shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow) inShadow = true;\n        }\n        for(int j=0; j<ShowBallNumber; j++){\n            if(inShadow) break;\n            tempInShadow = IntersectSphere(showSphere[j], shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow) inShadow = true;\n        } \n        for(int j=0; j<NUM_CYLINDERS; j++){\n            if(inShadow) break;\n            tempInShadow = IntersectionCylinder(Cylinder[j], shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow) inShadow = true;\n        }\n        // Prepare needed parameters\n        vec3 L = normalize(Light[i].position - nearest_hitPos);\n        vec3 N = normalize(nearest_hitNormal);\n        vec3 V = normalize(-ray.d);\n        if(nearest_hitMatID == 3){\n            I_local += PhongLighting(L, N, V, inShadow, Light[i], nearest_hitPos, hitWhichPlane);\n        }\n        else{\n            I_local += PhongLighting(L, N, V, inShadow, Material[nearest_hitMatID], Light[i]);\n        }         \n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 3.5 * cos(MyITime*0.1), 4.0, 3.5 * sin(MyITime*0.1) );\n    vec3 cam_lookat = vec3( 0.0, 1.0 +cos(MyITime) , 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2825, 2853, 2873, 2873, 6627], [6630, 6812, 6830, 6856, 15294], [15298, 15794, 15948, 15948, 16278], [16282, 16614, 16697, 16697, 16909], [16913, 17431, 17588, 17702, 18427], [18431, 18764, 18849, 18963, 19584], [19586, 19586, 19725, 19725, 20606], [20608, 20608, 20697, 20697, 21331], [21335, 21689, 21819, 21819, 22231], [22233, 22282, 22311, 22311, 22790], [22792, 22792, 22833, 22833, 23113], [23115, 23115, 23266, 23266, 24199], [24202, 24991, 25104, 25195, 30423], [30427, 30788, 30845, 30845, 32317]], "test": "valid"}
{"id": "ftSXDz", "name": "Ray Tracing with Phong Shading", "author": "AshutoshR", "description": "Ray Tracing with Phong Shading", "tags": ["raytracing", "phongshading"], "likes": 0, "viewed": 29, "published": "Public", "date": "1627397935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray {\n    vec3 origin;\n    vec3 direction;\n} ray;\n\nstruct Material {\n    vec3 color;\n    float ambience;\n    float diffuse;\n    float specular;\n    float shininess;\n};\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material material;\n} sphere1;\n\nstruct Camera {\n    vec3 position;\n    float aspectRatio;\n} camera;\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n} sunLight;\n\nvoid setupScene() {\n    sphere1.position = vec3(0 , 0 , 30);\n    sphere1.radius = 1.0;\n    \n    sphere1.material.color = vec3(0.5, 0.5, 1.0);\n    sphere1.material.ambience = 0.2;\n    sphere1.material.diffuse = 0.5;\n    sphere1.material.specular = 0.8;\n    sphere1.material.shininess = 25.;\n    \n    camera.position = vec3(0 , 0 , -5);\n    camera.aspectRatio = iResolution.x / iResolution.y;\n    \n    sunLight.direction = normalize(vec3(-0.5 , -0.5 , 0.8));\n    sunLight.color = vec3(1.);\n    \n    ray.origin = camera.position;\n}\n\nbool checkIntersect(Sphere sphere, vec2 px, out float p1, out float p2) {\n    ray.direction = normalize(vec3(px, 1.0) - ray.origin);\n\n    vec3 oc = ray.origin - sphere.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, oc);\n    float c = dot(oc,oc) - pow(sphere.radius, 2.0);\n    \n    float d = pow(b, 2.0) - (4.0 * a *c);\n    if (d < 0.0) {\n        return false;\n    }\n    if (d == 0.0) {\n        p1 = p2 = -b / 2.0 * a;\n        return true;\n    }\n    if (d > 0.0) {\n       p1 = (-b - sqrt(d)) / 2.0 * a;\n       p2 = (-b + sqrt(d)) / 2.0 * a;\n       return true;\n    }\n}\n\nvec3 calculateSunLight(Sphere sphere, vec3 hitPoint) {\n    vec3 sphereNormal = normalize(hitPoint - sphere.position);\n    vec3 invlDir = sunLight.direction;\n    float intensity = max(-dot(invlDir, sphereNormal), 0.);\n    return vec3(1) * intensity;\n}\n\nvec3 calculateShininess(Sphere sphere, vec3 hitPoint) {\n    vec3 sphereNormal = normalize(hitPoint - sphere.position);\n    vec3 viewDirection = normalize(camera.position - hitPoint);\n    \n    vec3 refLight = normalize(reflect(sunLight.direction, sphereNormal));\n    \n    float intensity = max(0.,dot(viewDirection, refLight));\n    \n    float shininess = pow(intensity, sphere1.material.shininess);\n    \n    return shininess * sunLight.color;\n}\n\n\nvec3 rayTrace(vec2 fCord) {\n    float p1 , p2;\n    if(checkIntersect(sphere1, fCord, p1, p2)) {\n        float p = p1;\n        if (p2 < p) {\n            p = p2;\n        }\n        vec3 hitPoint = ray.origin + (ray.direction * p);\n        \n        vec3 ambience = sphere1.material.ambience * sphere1.material.color * sunLight.color;\n        vec3 diffuse = sphere1.material.diffuse * calculateSunLight(sphere1, hitPoint) * sphere1.material.color;\n        vec3 specular = sphere1.material.specular * calculateShininess(sphere1, hitPoint) * sphere1.material.color;\n        \n        return ambience + diffuse + specular;\n    } else {\n        return vec3(0.0);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setupScene();\n    \n    // sphere.position.z = sin(iTime) * 4. + 10.;\n    sphere1.position.x = sin(iTime) * 2.9;\n    // sphere1.position.y = cos(iTime) * 1.5;\n    \n    sunLight.direction.x = sin(iTime);\n    sunLight.direction.y = cos(iTime);\n    \n    ///sphere1.material.shininess = sin(iTime) * 40. + 50.;\n    \n    ray.origin = camera.position;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= camera.aspectRatio;\n    \n    vec3 col = rayTrace(uv);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 427, 427, 936], [938, 938, 1011, 1011, 1556], [1558, 1558, 1612, 1612, 1808], [1810, 1810, 1865, 1865, 2253], [2256, 2256, 2283, 2283, 2916], [2919, 2919, 2976, 2976, 3556]], "test": "error"}
{"id": "ftSXR1", "name": "Voronoi Archipelago [Raymarched]", "author": "Hamish", "description": "A 3D Raymarched version of a previous 2D shader of mine, 'Voronoi Archipelago'.\nMy first published Raymarched shader", "tags": ["voronoi", "noise", "raymarch", "simplex"], "likes": 3, "viewed": 59, "published": "Public", "date": "1627030792", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hello! This is a raymarched 3D version of a previous shader of mine. https://www.shadertoy.com/view/stfSWS\n// Change STEPINTERSECT and STEPSOFTSHADOW to lower values if it is too much for computer\n// (I am already at 40fps but this is bad computer)\n// I am still learning so advice is appreciated\n// Done using a few sources, mostly iq (duh) and some blogs online to wrap head around stuff\n// https://www.shadertoy.com/view/ldfSWs - iq template\n// ArtOfCode Youtube Channel also very helpful\n// Enjoy :)\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define STEPINTERSECT 20\n#define STEPSOFTSHADOW 10\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec4 smin(vec4 a, vec4 b, float k) {\n    float h = clamp(0.5 + 0.5*(a.x-b.x)/k, 0.0, 1.0);\n    return vec4(mix(a.x, b.x, h) - k*h*(1.0-h),mix(a.yzw, b.yzw, h) - k*h*(1.0-h));\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404;\n    const float K2 = 0.211324865;\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 minWithColor(vec4 obj1, vec4 obj2) {\n  if (obj2.x < obj1.x) return obj2;\n  return obj1;\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime + 10.0*mouseX;\n\tcamPos = vec3(3.5-.5*iTime,0.5,-1.0+sin(iTime));\n    camTar = vec3(0.0-.5*iTime,-2.5,-1.0+cos(iTime));\n}\n\nvec3 doBackground( in float x )\n{\n    vec3 skyCol = mix(vec3(0.45,0.62,0.96),vec3(0.01,0.37,0.82),x);\n    return skyCol;\n}\n    \nvec4 doModel( vec3 p )\n{\n    vec2 st = vec2(p.x*10.,p.z*10.);\n    vec2 i_st = floor(st); vec2 f_st = fract(st);    \n    \n    float m_dist = 10.;\n    vec2 m_point;       \n\n    for (int j=-1; j<=1; j++ ) {\n        for (int i=-1; i<=1; i++ ) {\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.6 + 0.4*sin(iTime + 10.*point);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n\n            if( dist < m_dist) {\n                m_dist = dist;\n                m_point = point;\n            }\n        }\n    }\n    \n    vec3 colorbackground = vec3(0.);\n   \tcolorbackground.r += dot(0.5*m_point,vec2(.1,.1));\n  \tcolorbackground.g += dot(0.5*m_point,vec2(.3,.2));   \n    colorbackground.b += dot(0.5*m_point,vec2(.8,.7));\n    \n    vec4 planeIsland = vec4(p.y +0.1 + 0.25*noise(vec2(p.x,p.z)),mix(vec3(0.15,0.35,0.15),vec3(.225,.2,.15),1.-(p.y-2.0*noise(vec2(p.x,p.z)))));\n    vec4 planeRocks = vec4(p.y +.2 + 0.25*noise(vec2(p.z,p.x)),mix(vec3(0.3,0.3,0.3),vec3(.2,.2,.2),1.-(p.y-2.0*noise(vec2(p.x,p.z)))));\n    vec4 planeSea = vec4(p.y-0.001*0.8*sin(iTime)+0.01*noise(vec2(p.z + 0.3*iTime,p.x + 0.3*iTime)),colorbackground);\n    vec4 a = smin(planeIsland, planeRocks, 0.3);\n    vec4 b = minWithColor(a, planeSea);\n    return b;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    vec3  lig = normalize(vec3(0.3,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.02*nor, lig );\n    lin += dif*vec3(2.00,2.00,2.00)*sha;\n\n    lin += vec3(0.50,0.50,0.50);\n\n    vec3 col = mal*lin;\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           \n\tconst float precis = 0.001;        \n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<STEPINTERSECT; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = (doModel( ro+rd*t )).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * doModel(pos + e.xyy).x +\n      e.yyx * doModel(pos + e.yyx).x +\n      e.yxy * doModel(pos + e.yxy).x +\n      e.xxx * doModel(pos + e.xxx).x);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 \n\tfloat h = 1.0;\n    for( int i=0; i<STEPSOFTSHADOW; i++ )         \n    {\n        h = (doModel(ro + rd*t)).x;\n        res = min( res, 64.0*h/t );   \n\t\tt += clamp( h, 0.02, 2.0 );   \n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 ); \n   \n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); \n\n\tvec3 col = doBackground(p.y);\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 mal = (doModel(ro+rd*t)).yzw;\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.5454) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[676, 676, 697, 697, 812], [814, 814, 850, 850, 990], [992, 992, 1018, 1018, 1460], [1462, 1462, 1486, 1486, 1579], [1581, 1581, 1622, 1622, 1675], [1677, 1677, 1760, 1760, 1906], [1908, 1908, 1941, 1941, 2030], [2036, 2036, 2060, 2060, 3369], [3420, 3420, 3504, 3504, 3812], [3814, 3814, 3864, 3864, 4187], [4189, 4189, 4219, 4219, 4438], [4440, 4440, 4488, 4488, 4768], [4770, 4770, 4834, 4834, 5012], [5014, 5014, 5071, 5071, 5685]], "test": "valid"}
{"id": "ftsXW2", "name": "5 AM With Friends", "author": "blackle", "description": "just a random coding session among friends at 5 am", "tags": ["circles", "gold", "gridlines", "livecode"], "likes": 27, "viewed": 455, "published": "Public API", "date": "1626600920", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat stg;\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(k-abs(a-b), 0.)/k;\n  return min(a,b) - h*h*h*k/6.;\n}\n\nfloat comp(vec3 p) {\n  p = asin(sin(p)*.999);\n  return dot(p,normalize(vec3(1,2,3)));\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat w, dts;\nfloat scene(vec3 p) {\n  float h1 = comp(erot(p,normalize(vec3(1,2,3)),2.));\n  float h2 = comp(erot(p,normalize(vec3(3,-1,2)),stg));\n  float h3 = comp(erot(p,normalize(vec3(0,3,2)),stg*2.));\n  float cave = (h1+h2+h3)/2.5;\n  float lvl1 = -smin(-cave,-p.z,.1);\n  float lvl2 = -smin(-cave-.5,1.-p.z,.1);\n  vec3 p2 = p;\n  p2.xy = asin(sin(p2.xy*3.))/3.;\n  p2.xy = abs(p2.xy);\n  if(p2.x < p2.y) p2.xy = p2.yx;\n  p2.z += asin(sin(iTime+stg*2.)*.9)*.5+2.;\n  w = smin(lvl2,lvl1,.1);\n  dts = linedist(p2,vec3(1,0,0), vec3(-1,0,0))-.02;\n  return min(w, dts);\n}\n\nvec3 norm(vec3 p ) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n  \n  stg = floor(iTime);\n\n\tvec3 cam = normalize(vec3(1.5,uv));\n  vec3 init = vec3(-15,0,0);\n  float roz = iTime*.1;\n  if (mod(stg, 2.) < 1.) roz *= -1.;\n  float roy = .8 + sin(stg)*.2;\n  cam = erot(cam,vec3(0,1,0),roy);\n  init = erot(init,vec3(0,1,0),roy);\n  cam = erot(cam,vec3(0,0,1),roz);\n  init = erot(init,vec3(0,0,1),roz);\n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  float glo = 0.;\n  for (int i = 0; i < 150 && !hit; i++) {\n    dist = scene(p);\n    hit = dist*dist < 1e-6;\n    glo += dist/(.1+dts*500.)*10.;\n    p += cam*dist;\n  }\n  bool isgrd = (dts == dist);\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float fres = 1. - abs(dot(cam,n))*.98;\n  r.xy = abs(r.xy);\n  n.xy = abs(n.xy);\n  float ao = smoothstep(-.5,.5,scene(p+n*.5));\n  float ro = smoothstep(-.2,.2,scene(p+r*.2));\n  float spec = length(sin(r*3.5)*.5+.5)/sqrt(3.);\n  float diff = length(sin(n*3.5)*.5+.5)/sqrt(3.);\n  spec = fres*(spec*.1 + pow(spec,8.)*10.) * ro;\n  vec3 col1 = vec3(1,0.4,0.1) * spec; \n  vec3 col2 = vec3(diff)*vec3(.01,.03,.1)*ao + spec*.05;\n  float aaa = sin(p.x*3.+p.y*2.+p.z*8.);\n  vec3 col = mix(col2, col1, smoothstep(-.94,-.96,aaa));\n  if (isgrd) col = vec3(.1,.2,.5)*6.;\n  col = mix(col, vec3(.01), smoothstep(0.,-7.,p.z));\n  col += glo*vec3(.1,.2,.5)+glo*glo;\n  fragColor.xyz = col;\n  fragColor *= 1. - dot(uv,uv);\n  fragColor = smoothstep(-.05,1.1,sqrt(fragColor) + vec4(0.08,0.02,0.1,0));\n  float dt = length(uv);\n  float f1 = step(0.,sin(stg*.7));\n  float f2 = step(0.,sin(stg*1.7));\n  float f3 = step(0.,sin(stg*2.7));\n  float circles = abs(abs(abs(dt-mix(.7,.5,f3))-.1*f1)-.03*f2)-.002;\n  fragColor = mix(vec4(0.2), fragColor,smoothstep(0.,fwidth(dt)*3.,circles));\n  fragColor = mix(vec4(1), fragColor,smoothstep(0.,fwidth(dt)*1.5,circles));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsXW2.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[205, 205, 243, 243, 307], [309, 309, 348, 348, 417], [419, 419, 439, 439, 506], [508, 508, 548, 548, 635], [651, 651, 672, 672, 1200], [1202, 1202, 1222, 1222, 1338], [1340, 1340, 1397, 1397, 3213]], "test": "valid"}
{"id": "ftsXWs", "name": "Scrapyard", "author": "ruojake", "description": "Inspired by iq's article on SDF-based fBM (https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm), using cubes instead of spheres.", "tags": ["3d", "raymarching", "terrain", "fbm", "brdf"], "likes": 9, "viewed": 187, "published": "Public API", "date": "1627079459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Scrapyard by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// set to 1 if you dare - slows down to crawl on my GPU\n#define AA 0\n\n#define sat(x) clamp((x), 1., 0.)\n\nfloat hash(vec3 p)\n{\n    p = fract(p * 21.43125);\n    p += dot(p, p.zxy * 321.32136);\n    return fract(((p.x + p.z) * p.y)*10.);\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// smooth min(q<0)/max(q>=0)\nfloat sm(float a, float b, float q)\n{\n    float d = clamp((b - a) / q + .5, 0., 1.);\n    return mix(a,b,d) + .5 * q * d * (1. - d);\n}\n\nfloat elem(vec3 i, vec3 f, vec3 c)\n{\n    float h = hash(i+c) * .5;\n    vec3 p = f - c;\n    vec3 d = abs(p) - h;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, vec3(0.)));\n}\n\n\nfloat grid(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = p - i;\n    const vec2 o = vec2(1,0);\n    \n    return min(\n        min(\n            min(elem(i, f, o.yyy), elem(i, f, o.yyx)),\n            min(elem(i, f, o.yxy), elem(i, f, o.yxx))\n        )\n        ,\n        min(\n            min(elem(i, f, o.xyy), elem(i, f, o.xyx)),\n            min(elem(i, f, o.xxy), elem(i, f, o.xxx))\n        )\n    );\n}\n\nvec2 scene(vec3 p, float th)\n{\n    float res = p.y;\n    if(p.y > .3) return vec2(res, 0);\n    if(p.y <= .015) return vec2(p.y - .015, 0);\n    float s = 1.;\n    const mat3 r = mat3(-.66, 1.51, -1.12,\n                        1.07, 1.28, 1.1,\n                        1.55, -.23, -1.23);\n    const float q = .4;\n\n    for(int i = 0; i < 8; i++)\n    {\n        float d = sm(s * grid(p), res - s*.1, q*s*s);\n        res = mix(sm(d, res, -q*s*s), res, clamp(th/s * 2. - 1.,0.,1.));\n        \n        p *= r;\n        s *= .5;\n\n        if(th > s) break;\n    }\n    return vec2(res, 1);\n}\n\nvec3 normal(vec3 p, float d, float th)\n{\n    vec2 e = vec2(.1 * th, 0);\n    return normalize(d - vec3(\n        scene(p - e.xyy, th).x,\n        scene(p - e.yxy, th).x,\n        scene(p - e.yyx, th).x));\n}\n\nvec3 sky(vec3 rd, vec3 ld, float k, float l)\n{\n    vec3 col = mix(vec3(.05, .2, .5), vec3(1., .97, .96), min(rd.y * .5 + .5, l));\n    float sun = sat(dot(rd, ld));\n    k = max(k, .0001);\n    col += l * pow(sat((sun - .9992 + k) / k), 5. / k) * (30. - 25. * k * (2. - k)) + sun * sun * vec3(1.,.9,.8) * (.25 + k);\n    return col;\n}\n\n// https://google.github.io/filament/Filament.md.html#table_texturedfg\nvec3 DFGAppr(vec3 f0, float ndv, float roughness)\n{\n    vec4 c0 = vec4(-1., -.0275, -.572, .022);\n    vec4 c1 = vec4(1., .0425, 1.04, -.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * ndv)) * r.x + r.y;\n    vec2 ab = vec2(-1.04, 1.04) * a004 + r.zw;\n    return f0 * ab.x + ab.y;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist, float k)\n{\n    float res = 1.;\n    float d = 0.;\n    float t = .01;\n    for(int i = 0; i < 30; ++i)\n    {\n        d = scene(ro + rd * t, .01).x * 2.;\n        res = min(res, k * d / t);\n        t += d;\n    \tif(abs(d) < .0001 || t >= maxDist)\n            break;\n        if (res < .001)\n        {\n        \tres = 0.;\n            break;\n        }\n    }\n    return res;\n}\n\nvec3 brdf(vec3 albedo, float metal, float roughness, vec3 rd, vec3 ld, vec3 n, float l)\n{\n    vec3 spec = sky(reflect(rd, n), ld, max(roughness, .0001), l);\n        \n    vec3 diff = albedo * sky(n, ld, 1., 1.) * metal;\n    vec3 f0 = max(albedo * (1. - metal), vec3(.04));\n    return mix(diff, spec, DFGAppr(f0, dot(-rd, n), roughness));\n}\n\nvec3 reinhard(vec3 c)\n{\n    float l0 = dot(c, vec3(.2126, .7152, .0722));\n    float l1 = l0 * (1. + l0 / 20.) / (1. + l0);\n    return c / l0 * l1;\n}\n\nvoid img( out vec4 fragColor, in vec2 uv )\n{  \n    vec3 rd = normalize(vec3(uv, 1.5));\n    mat2 camRot = rot(.3);\n    rd.yz *= camRot;\n    vec3 ro = vec3(uv * .02, 0);\n    ro.yz *= camRot;\n    ro += vec3(0,.5,iTime * .05);\n    vec3 p = ro;\n    float t = .01;\n    vec2 d = vec2(0);\n    float duv = length(fwidth(uv));\n    float th = 0.;\n    float i = 0.;\n    \n    for(;i < 1. && t < 25.; i += 1./128.)\n    {\n        p = ro + rd * t;\n        th = clamp(duv * 3. * t - duv, 0., 1.);\n        d = scene(p, th);\n        t += d.x + (.00025 * t) * sign(d.x);\n        if (abs(d.x)<.0005*t) break;\n    }\n\n    float ao = clamp(1.2 - i, 0., 1.);\n    \n    vec3 nml;\n    if (d.y == 0.)\n        nml = vec3(0,1,0);\n    else if (t < 25.)\n        nml = normal(p, d.x, th);\n    else \n        nml = vec3(0, -1, 0);\n        \n    vec3 lDir = normalize(vec3(2,1,-1));\n    float l = (dot(nml, lDir) * .5 + .5) * ao;\n    \n    vec3 shDir = d.y > 0. ? lDir : reflect(rd, nml);\n    l *= shadow(p + nml * .01, shDir, 1., 4.5 - d.y * 2.); \n    \n    vec3 col = vec3(0);\n    if (d.y == 1.)\n    {\n        col = brdf(vec3(.1), .99, .3, rd, lDir, nml, l) \n            * (.7 + .3 * l);\n    }\n    else if (rd.y <= 0.)\n    {\n        col = brdf(vec3(.3, .025, .005), .8, .001, rd, lDir, nml, min(l, 1. + rd.y));\n    }\n    else\n    {\n        col = sky(rd, lDir, .01, 1.);\n    }\n  \n    if (rd.y <= 0.)\n        col = mix(col, sky(rd, lDir, 1., 1.), clamp(t * .05 - .4, 0., 1.));\n\n    fragColor = vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n    img(fragColor, uv);\n    \n    #if AA\n    if (fwidth(fragColor.g) > .1)\n    {\n        fragColor *= 2.;\n        vec2 offs = vec2(.7 * abs(dFdy(uv.y)),0);\n        vec4 c;\n        mat2 r = mat2(-.5,-.866,.866,-.5);\n        for(int i = 0; i < 3; ++i)\n        {\n            img(c, uv + offs);\n            offs *= r;\n            fragColor += c; \n        }\n        fragColor *= .2;\n        //fragColor.rgb *= vec3(1,0,0);\n    }\n    #endif\n    \n    fragColor.rgb = reinhard(fragColor.rgb);\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n\n    fragColor.rgb += hash(vec3(fragCoord, iFrame)) * .01 - .005;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsXWs.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[215, 215, 235, 235, 345], [347, 347, 366, 366, 442], [444, 473, 510, 510, 606], [608, 608, 644, 644, 793], [796, 796, 816, 816, 1193], [1195, 1195, 1225, 1225, 1769], [1771, 1771, 1811, 1811, 1973], [1975, 1975, 2021, 2021, 2305], [2307, 2378, 2429, 2429, 2694], [2696, 2696, 2752, 2752, 3107], [3109, 3109, 3198, 3198, 3447], [3449, 3449, 3472, 3472, 3597], [3599, 3599, 3643, 3643, 5069], [5071, 5071, 5128, 5128, 5802]], "test": "valid"}
{"id": "ftsXz8", "name": "Naive AA vs Exact blend", "author": "pyBlob", "description": "Representing subpixel coverage as transparency for antialiasing assumes that background subpixels are covered independently. In the extreme case (left circle), the covered foreground subpixels exactly match the covered background subpixels.", "tags": ["antialiasing"], "likes": 3, "viewed": 165, "published": "Public API", "date": "1625143773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = radians(180.);\n\nvec4 rainbow(vec2 U)\n{\n    float a = atan(U.y, U.x);\n    vec3 c = cos(vec3(a) - vec3(0, 2, 4)) * .5 + .5;\n    return vec4(c, 1);\n}\n\nbool aa, withcolor;\nvoid blend(inout vec4 O, vec2 R, vec2 U)\n{\n    float d = step(length(U), .12*R.y);\n    if (aa)\n    {\n        float f = 1.2;\n        d = smoothstep(f, 0., length(U) - .12*R.y + f / 2.);\n    }\n\n    vec4 C = vec4(1) * d;\n    if (withcolor)\n        C = rainbow(U) * d;\n\n    O = O * (1. - d) + C;\n}\n\nvec4 image(vec2 R, vec2 U)\n{\n    vec4 O = vec4(0);\n    int N = 20;\n    for (int i=0 ; i<N ; ++i)\n    {\n        float a = (float(i) + .5) / float(N);\n        vec2 M = R/2. + R/4. * cos((a - vec2(0, .25)) * 2. * pi);\n        blend(O, R, U - M);\n    }\n    int M = 20;\n    for (int i=0 ; i<M ; ++i)\n    {\n        blend(O, R, U - vec2(.1, .2) * R);\n        blend(O, R, U - vec2(.1, 1.-.2) * R);\n\n        float y = (float(i) + .5) / float(N);\n        y = mix(.15, .25, y);\n        blend(O, R, U - vec2(.9, y) * R);\n        blend(O, R, U - vec2(.9, 1.-y) * R);\n    }\n    return O;\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    withcolor = u.y > iResolution.y/2.;\n    //aa = u.x < iResolution.x/2.;\n    aa = u.x / iResolution.x < .5 + .5 * sin(iTime * 1.);\n\n    int zoom = 4;\n    vec2 R = iResolution.xy / float(zoom);\n    vec2 U = vec2(ivec2(u) / zoom) + .5;\n\n    O = vec4(0);\n    if (aa)\n        O = image(R, U);\n    else\n    {\n        const int N = 10;\n        for (ivec2 x=ivec2(0) ; x.y<N ; ++x.y)\n        for (x.x=0 ; x.x<N ; ++x.x)\n            O += image(R, U - .5 + (vec2(x) + .5) / float(N));\n        O /= float(N * N);\n    }\n\n    O.xyz = pow(O.xyz, vec3(.45));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsXz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 55, 55, 163], [185, 185, 227, 227, 478], [1057, 1057, 1093, 1093, 1642]], "test": "error"}
{"id": "ftXSWs", "name": "Revolving Planets", "author": "napsternxg", "description": "Simple example of plants revolving along the sun. \nOne this not implemented right now is to handle what happens when objects go behind each other. That will be handled in another example. ", "tags": ["plantes", "simpleraytracing"], "likes": 0, "viewed": 111, "published": "Public API", "date": "1626759973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = radians(180.);\n\nfloat makeCircle(vec3 p, vec3 rd, float r){\n    /**\n    Find inside of circle based on position vector and ray direction\n    Remember each point on screen gets its own ray direction\n    We use the normal vector of the point to control its brightness on screen.\n    **/ \n    float n = length(cross(p, rd));\n    n = smoothstep(r-0.02, r, n);\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv = fract(5.*uv);\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    \n    // Camera Source - Ray Source\n    vec3 ro = vec3(0., 0., -1.);\n    \n    // Ray Direction\n    vec3 rd = vec3(uv.x, uv.y, 0);\n    rd -= ro; // Vector\n    rd /= length(rd); // Normalize\n    \n    int numC = 5;\n    \n    vec3 p = vec3(0.);\n    float n = 0.;\n    vec3 cCol = vec3(1., 0., 0.);\n    \n    vec3 sceneCenter = vec3(0., 0., 5.);\n    sceneCenter -= ro;\n    \n    p = sceneCenter;\n    //p -= ro; // position vector with respect to camera\n    cCol = vec3(1., 1., 0.);\n    float nScene = makeCircle(p, rd, 0.5);\n    n = nScene;\n    col = mix(cCol, col, n);\n    float theta = PI/4.;\n    mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    \n    for(int i=0; i < numC; i++){\n        float id = smoothstep(0., float(numC), float(i+1));\n        p = vec3(cos(id*1.*iTime), 0.0*(id), 5.*sin(id*1.*iTime));\n        // Define a new plane of rotation around the sun for the planet\n        theta = (id-.5)*PI/4.;\n        rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n        p.xy *= rot;\n        p += sceneCenter;\n        //p *= 3.;\n        //p -= ro; // position vector with respect to camera\n        cCol = vec3(id, 1.-id, id*id);\n        //cCol = vec3((id+0.5));\n        n = makeCircle(p, rd, 0.2*(0.5+id));\n        //n = min(nScene, n);;\n        //if(n>0. && nScene > 0. && dot(p - sceneCenter, rd) > 0.){\n        //    n = nScene;\n        //}\n        // step(0., -dot(p - sceneCenter, rd)\n        //n *= mix(nScene, n, step(0., -length(p) + nScene*length(sceneCenter)));\n        //n /= 2.;\n        //n = makeCircle(p, rd, 0.5);\n        col = mix(cCol, col, n);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 70, 295, 382], [384, 384, 441, 491, 2305]], "test": "valid"}
{"id": "ftXXDf", "name": "How Many Sides || Edit", "author": "AlijahT", "description": "Edit of this shader https://www.shadertoy.com/view/4dlBDn", "tags": ["spiralthingedit"], "likes": 0, "viewed": 175, "published": "Public API", "date": "1626654914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat time = 0.1;\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat map(vec3 p)\n{\n\n    vec3 q = p;\n\n    vec3 c = vec3(0.2);\n    p.z = mod(p.z,c.z)-0.5*c.z;\n\n    \n    vec3 p_s;\n    \n    p = p * rotationMatrix(vec3(0.0, 0.0, 1.0), sin(floor(q.z * 10.0) * 10.0) * 4.0 + 0.1 * (time));\n    \n    float bars = 1000.0;\n    int sides = 25; // not really sides\n    float angle = 3.1415 * 1.0 / float(sides) + sin(iTime/10.0)+ 1.0;\n    \n    for ( int i = 0; i < sides; i ++)\n    {\n        \n        p_s = p * rotationMatrix(vec3(0.0, 0.0, 1.0), angle * float(i));\n        \n       \tp_s += vec3(\n            sin(30.0 * floor(q.z))* 0.5 + 1.0, \n            cos(iTime + sin(q.z* 9.0)), \n            0.0);\n        \n        vec3 boxdim = vec3(\n        \t0.05 + 0.05 * sin(q.z*5.0 + iTime* 2.0), \n            sin(q.z * 10.0) * 0.5  + 0.5, \n            0.01 + pow(sin(iTime), 0.5)\n        );\n     \t\n        \n        bars = min(bars, sdBox(p_s, boxdim));  \n    }\n\n        \n    \n    float result = bars;   \n    return result;\n}\n\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = time;\n   // ro.x -= sin(iTime) 2.0;\n}\n\n vec3 gradient(vec3 p, float t) {\n\t\t\tvec2 e = vec2(0., t);\n\n\t\t\treturn normalize( \n\t\t\t\tvec3(\n\t\t\t\t\tmap(p+e.yxx) - map(p-e.yxx),\n\t\t\t\t\tmap(p+e.xyx) - map(p-e.xyx),\n\t\t\t\t\tmap(p+e.xxy) - map(p-e.xxy)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime * 0.5;\n    vec2 _p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);\n    \n    float depth = 0.0, d = 0.0, iter = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 40; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d < 0.001) {\n\t\t\thit = true;\n            break;\n        }\n                   \n        float ratio = 0.2;\n\t\tdepth += d * ratio;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0 - iter / 40.0);\n\t\n    \n    \n    col = pow(col, vec3(\n        0.5,\n         0.1 + sin(iTime - p.z * 3.6)* 0.4 + 0.5,\n        0.1 + sin(iTime - p.z * 10.0)* 0.4 + 0.5));\n\n    \n    \n    fragColor = vec4(col, hit? length(p.xy) : 0.0 );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 50, 50, 137], [139, 139, 172, 172, 198], [201, 201, 246, 246, 718], [720, 720, 739, 739, 1663], [1666, 1666, 1712, 1712, 1761], [1764, 1764, 1796, 1796, 1971], [1974, 1974, 2031, 2031, 2859]], "test": "valid"}
{"id": "ftXXWX", "name": "Cable nest", "author": "mrange", "description": "License CC0: Cable nest\nResult after a few hours programming sunday afternoon\n", "tags": ["raymarching"], "likes": 60, "viewed": 3924, "published": "Public API", "date": "1626634908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Cable nest\n//  Result after a few hours programming sunday afternoon\n#define TOLERANCE       0.0001\n#define NORMTOL         0.00125\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 90\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n// https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n#define PATHA vec2(0.1147, 0.2093)\n#define PATHB vec2(13.0, 3.0)\n\nconst float cam_amp = 1.0;\n\nvec4 g_state = vec4(0.0);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 cam_path(float z) {\n  return vec3(cam_amp*sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam_path(float z) {\n  return vec3(cam_amp*PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam_path(float z) {\n  return cam_amp*vec3(cam_amp*-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n\nfloat df(vec3 p3, out vec4 state) {\n  float cylr = 0.2;\n  vec2 p = p3.xy;\n  float t = p3.z;\n  \n  const float ss = 1.5;\n  mat2 pp = ss*ROT(1.0+0.5*p3.z);\n\n  p *= ROT(-0.2*TIME);\n  float s = 1.0;\n  \n  float d = 1E6;\n  float tt = 0.0;\n  for (int i = 0; i < 3; ++i) {\n    tt += sqrt(2.0)*float(1+i);\n    p *= pp;\n    vec2 sp = sign(p);\n    p = abs(p);\n    tt += dot(sp, vec2(0.25, 0.5))*s;\n    p -= 1.35*s;\n    s *= 1.0/ss;\n    \n    float dd = (length(p-vec2(0.0))-cylr)*s;\n    if (dd < d) {\n      d = dd;\n      state = vec4(p, t, hash(tt+123.4));\n    }\n    \n  }\n  \n  return d;\n}\n\nfloat df(vec3 p) {\n  // Found this world warping technique somewhere but forgot which shader :(\n  vec3 cam = cam_path(p.z);\n  vec3 dcam = normalize(dcam_path(p.z));\n  p.xy -= cam.xy;\n  p -= dcam*dot(vec3(p.xy, 0), dcam)*0.5*vec3(1,1,-1);\n  vec4 state;\n  float d = df(p, state);\n  \n  g_state = state;\n  \n  return d; \n} \n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float distance = df(ro + rd*t);\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += distance;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(NORMTOL,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<25; ++i) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos0  = cam_path(TIME-0.5);\n  vec3 lightPos1  = cam_path(TIME+6.5);\n\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n  vec4 state = g_state;\n\n  float tt = float(iter)/float(MAX_RAY_MARCHES);\n  float bs = 1.0-tt*tt*tt*tt;\n \n  vec3 pos = ro + t*rd;    \n  \n  float lsd1  = sphered(ro, rd, vec4(lightPos1, 2.5), t);\n  float beat  = smoothstep(0.25, 1.0, sin(TAU*TIME*120.0/60.0));\n  vec3 bcol   = mix(1.5*vec3(2.25, 0.75, 0.5), 3.5*vec3(2.0, 1.0, 0.75), beat);\n  vec3 gcol   = lsd1*bcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return skyCol+gcol;\n  }\n  \n  vec3 nor    = normal(pos);\n\n  float sa    = atan(state.y, state.x)+4.0*state.z*(0.5+0.5*state.w);\n  float v     = 0.9*smoothstep(-0.1, 0.1, sin(4.0*sa));\n  vec3 color  = hsv2rgb(vec3(0.0+123.4*state.w, 0.66, 0.75*v));\n  \n  vec3 lv0    = lightPos0 - pos;\n  float ll20  = dot(lv0, lv0);\n  float ll0   = sqrt(ll20);\n  vec3 ld0    = lv0 / ll0;\n  float dm0   = 8.0/ll20;\n  float sha0  = softShadow(pos, ld0, ll0, 0.125, 32.0);\n  float dif0  = max(dot(nor,ld0),0.0)*dm0;\n\n  vec3 lv1    = lightPos1 - pos;\n  float ll21  = dot(lv1, lv1);\n  float ll1   = sqrt(ll21);\n  vec3 ld1    = lv1 / ll1;\n  float spe1  = pow(max(dot(reflect(ld1, nor), rd), 0.), 100.)*tanh_approx(3.0/ll21);\n\n  vec3 col = vec3(0.0);\n  col += dif0*sha0*color;\n  col += spe1*bcol*bs;\n  col += gcol;\n\n  return col;\n}\n\nvec3 effect3d(vec2 p) {\n  float tm = TIME;\n  vec3 cam  = cam_path(tm);\n  vec3 dcam = dcam_path(tm);\n  vec3 ddcam= ddcam_path(tm);\n\n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*-2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = (2.0+0.5*tanh_approx(length(p)));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect3d(p);\n\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXXWX.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[510, 510, 532, 532, 678], [943, 943, 971, 991, 1067], [1069, 1144, 1202, 1202, 1683], [1685, 1685, 1707, 1707, 1755], [1757, 1757, 1781, 1781, 1829], [1831, 1831, 1856, 1856, 1912], [1914, 1914, 1940, 1940, 2011], [2013, 2013, 2048, 2048, 2588], [2590, 2590, 2608, 2685, 2907], [2910, 2910, 2964, 2964, 3180], [3182, 3182, 3208, 3208, 3419], [3421, 3421, 3498, 3498, 3798], [3800, 3800, 3843, 3843, 4095], [4097, 4097, 4128, 4128, 5496], [5498, 5498, 5521, 5521, 5919], [5921, 5921, 5976, 5976, 6150]], "test": "valid"}
{"id": "ldBBRW", "name": "Raymacher  9001.5", "author": "johannesCmayer", "description": "Raymarcher\nMove the mouse in the viewport to look around.", "tags": ["raymacher"], "likes": 1, "viewed": 158, "published": "Public API", "date": "1625659947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXRAYSTEPS 1000\n#define RAYEPSILON 0.0001\n#define NORMALEPSILON 0.0001\n\n#define SATURATION 0.4\n\n#define t iTime\n    \n//>>>>>>>>>>>>>>>>>>>>>>>>>>> Print Util\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nfloat print(vec2 fragCoord, float value, vec2 coord)\n{\n    // Multiples of 4x5 work best\n\tvec2 vFontSize = vec2(16.0, 13.0);\n    float fDigits = 1.0;\n\tfloat fDecimalPlaces = 2.0;    \n    vec3 vColour;        \n\tvec2 vPixelCoord1 = coord;\n    fDigits = 15.0;   \n\t\n\treturn PrintValue( (fragCoord - vPixelCoord1) / vFontSize, value, fDigits, fDecimalPlaces);     \n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n\nstruct HitData\n{\n    float depth;\n    vec3 hitP;\n};\n \n//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DistanceFunctions    \nmat2 rot(float a) \n{\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec4 formula(vec4 p) \n{\n    p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n\n    //p.xz = abs(sin(p.xz+1.))-abs((p.xz-1.))-mod(p.xz, p.y);\n    p.y-=.25;\n    //p.xz*=rot(radians(35.*sin(iTime)+50.)); //Hier Sinus rein!\n    p.xy*=rot(radians(20.));\n    p=p*2./clamp(dot(p.xyz,p.xyz),.2,1.);\n\treturn p;\n}\n\nfloat de(vec3 pos) {\n#ifdef WAVES\n\t//pos.y+=sin(pos.z-t*6.)*.15; //waves!\n    pos.y+= tan(pos.z * 0.1); //waves!\n#endif\n    pos.z = mix(pos.z, pos.z*(4. - min(3.1,iTime)), max(iTime - 1., 1. )); //Zeit Raum Kontinuum brechen\n\t//float hid=0.;\n\tvec3 tpos=sin(pos);\n\ttpos.z=abs(3.-mod(tpos.z,6.));\n\tvec4 p=vec4(tpos,1.);\n\tfor (int i=0; i<4; i++) {p=formula(p);}\n\tfloat fr=(length(max(vec2(0.),p.yz-1.5))-1.)/p.w;\n\treturn fr;\n}\n\nfloat udBox( vec3 p, vec3 pos, vec3 b )\n{\n  return length(max(abs(p + pos)-b,0.0));\n}\n\nfloat sphereF(vec3 p, vec3 pos, float r)\n{\n    return length(p - pos) - r;\n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Operators\nfloat opRepSphere( vec3 p, vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sphereF( q , vec3(0.,0.,0.), 1.);\n}\n\nfloat opRepCube( vec3 p, vec3 c)\n{\n    vec3 q = mod(p,c)-0.5 * c;\n    return udBox( q , vec3(0.,0.,0.), vec3(1., 1., 1.));\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = opRepCube(p, vec3(20., 20., 20.));\n    float d2 = (sin(2.*p.x)*sin(2.*p.y)*sin(2.*p.z)) * 2.;\n    return d1+d2;\n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\nfloat scene(vec3 p)\n{\n    //return de(p);\n    //return opDisplace(p);\n    //return opRepCube (p, vec3(20.,20.,20.));\n    return opRepSphere(p, vec3(20.,20.,20.));\n    //float s = opRepSphere(p, vec3(20.,20.,20.));\n    \n    //return min(c, s);\n    \n    return sphereF(p, vec3(0.,0.,5.), 1.);\n}\n\n//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Rotation\nvec3 RotateX(vec3 toRotate, vec3 camRot)\n{\n    mat3 rX = mat3 (\n        1.0, 0.0, 0.0,\n        0.0, cos(camRot.x), -sin(camRot.x),\n        0.0, sin(camRot.x), cos(camRot.x)\n        );  \n\n        return toRotate * rX;\n}\n\nvec3 RotateY(vec3 toRotate, vec3 camRot)\n{\n    mat3 rY = mat3 (\n        cos(camRot.y), 0.0,sin(camRot.y),\n        0.0, 1.0, 0.0,\n        -sin(camRot.y), 0.0, cos(camRot.y)\n        );  \n\n        return toRotate * rY;\n}\n\nvec3 RotateZ(vec3 toRotate, vec3 camRot)\n{\n    mat3 rZ = mat3 (\n        cos(camRot.z), -sin(camRot.z), 0.0,\n        sin(camRot.z), cos(camRot.z), 0.0,\n        0.0, 0.0, 1.0\n        );  \n\n        return toRotate * rZ;\n}\n\nvec3 Rotate(vec3 toRotate, vec3 camPos, vec3 camRot)\n{\n    return RotateZ(RotateY(RotateX(toRotate, camRot), camRot), camRot);    \n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\nvec3 calcNormal(vec3 p)\n{\n    vec3 n= vec3(scene(vec3(p.x + NORMALEPSILON, p.y, p.z)) - scene(vec3(p.x - NORMALEPSILON, p.y, p.z)),\n                 scene(vec3(p.x, p.y + NORMALEPSILON, p.z)) - scene(vec3(p.x, p.y - NORMALEPSILON, p.z)),\n                 scene(vec3(p.x, p.y, p.z + NORMALEPSILON)) - scene(vec3(p.x, p.y, p.z - NORMALEPSILON))\n               );\n    \n    return normalize(n);\n}\n\nHitData raymarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float t = 0.;\n    HitData hd;\n    \n    rayDirection = normalize(rayDirection);\n    \n    for (int i = 0; i < MAXRAYSTEPS; i++)\n    {\n        float d = scene(rayOrigin + rayDirection * t);\n        if (d < RAYEPSILON)\n        {\n            hd.depth = d;\n            hd.hitP = rayOrigin + rayDirection * t;            \n            return hd;\n        }\n        t += d;\n    }\n    hd.depth = t;\n    hd.hitP = rayOrigin + rayDirection * t;\n    return hd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(t, t*1.5, t);\n    vec3 camRot = vec3((iMouse.y - iMouse.y / 2.) / 100., (-iMouse.x - iMouse.x / 2.) / 100., 0.);\n    \n    float screenSpaceX = fragCoord.x;\n    float screenSpaceY = fragCoord.y;\n    \n    screenSpaceX = (screenSpaceX - iResolution.x / 2.) / iResolution.y;\n    screenSpaceY = (screenSpaceY - iResolution.y / 2.) / iResolution.y;\n       \n    HitData hit = raymarch(camPos, Rotate(vec3(screenSpaceX, screenSpaceY, 1.)\n                                          , camPos, \n                                          \tcamRot));\n    \n    vec3 db = Rotate(vec3(screenSpaceX, screenSpaceY, 1.), camPos, camRot);\n    vec3 db2 = vec3(screenSpaceX, screenSpaceY, 1.);\n    \n    float printColor =  print(fragCoord, hit.depth, vec2(0., 0.)) +\n        \t\t\t\tprint(fragCoord, calcNormal(hit.hitP).x, vec2(0., 20.)) +\n        \t\t\t\tprint(fragCoord, calcNormal(vec3(1.,1.,1.)).y, vec2(0., 40.)) +\n        \t\t\t\tprint(fragCoord, calcNormal(vec3(1.,1.,1.)).z, vec2(0., 60.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 80.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 100.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 120.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 140.));\n    \n    float printLerp = 0.;\n    \n    vec4 color;\n    \n    if (hit.depth > 200.)\n        color = vec4(0.,0.,0.2,1.);\n    else\n    \tcolor = vec4(mix((calcNormal(hit.hitP).x + 1.5 / 3.), printColor, printLerp),\n                     mix((calcNormal(hit.hitP).y + 1.5 / 3.), printColor, printLerp),\n                     mix((calcNormal(hit.hitP).z + 1.5 / 3.), printColor, printLerp), 1.);\n    \n    fragColor = color * vec4(SATURATION, SATURATION, SATURATION, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldBBRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 167, 198, 198, 356], [358, 358, 476, 476, 1446], [1448, 1448, 1502, 1536, 1809], [1907, 1974, 1994, 1994, 2041], [2043, 2043, 2066, 2066, 2335], [2337, 2337, 2357, 2357, 2760], [2762, 2762, 2803, 2803, 2847], [2849, 2849, 2891, 2891, 2925], [2972, 3027, 3063, 3063, 3139], [3141, 3141, 3175, 3175, 3265], [3267, 3267, 3295, 3295, 3424], [3472, 3472, 3493, 3588, 3764], [3766, 3836, 3878, 3878, 4054], [4056, 4056, 4098, 4098, 4273], [4275, 4275, 4317, 4317, 4493], [4495, 4495, 4549, 4549, 4627], [4712, 4712, 4737, 4737, 5104], [5106, 5106, 5159, 5159, 5612], [5614, 5614, 5671, 5671, 7326]], "test": "valid"}
{"id": "lt2yWc", "name": "Loading Indicators", "author": "mileslacey", "description": "Testing a loading indicator", "tags": ["progress", "load", "indicator"], "likes": 1, "viewed": 66, "published": "Public", "date": "1625563601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 indicator(float t, float innerRadius, float outerRadius, in vec2 pos, in vec4 baseColor, in vec4 progressColor)\n{\n    const float pi = 3.14159254;\n    const float twoPi = 2.0 * pi;\n    \n    vec2 uv = pos / outerRadius;\n    vec2 uvNormalized = (vec2(-2.0) * uv + vec2(1.0));\n    float l = length(outerRadius * uvNormalized);\n    \n    float uvAngle = atan(uvNormalized.x, uvNormalized.y) + pi;\n    float interpAngle = t * twoPi;\n    \n    vec4 c0 = baseColor * step(interpAngle, uvAngle);\n    vec4 c1 = progressColor * step(uvAngle, interpAngle);\n    \n    float amInRing = step(l, outerRadius) * step(innerRadius, l);\n    return (c0+c1) * amInRing;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 wh = vec2(iResolution.xy);\n    vec2 aspect = vec2(min(wh.x, wh.y) / max(wh.x, wh.y), 1.0);\n    wh *= aspect;\n    \n    vec2 offset = fragCoord / wh;\n    \n    float percent0 = mod(iTime*0.25, 1.0);\n    float percent1 = mod(iTime, 1.0);\n    float percent2 = mod(iTime*0.33333, 1.0);\n    vec4 baseColor0 = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 baseColor1 = vec4(0.48, 0.35, 0.5, 1.0);\n    \n\tfragColor =\n        indicator(percent0, 0.45, 0.5, offset-vec2(0.1, 0.1), baseColor0, vec4(0.0, 0.675, 0.62, 1.0)) +\n        indicator(percent1, 0.1, 0.25, offset-vec2(0.6, 0.6), baseColor0, vec4(1.0, 0.475, 0.42, 1.0)) +\n        indicator(percent2, 0.0, 0.5,  offset-vec2(1.0, 0.3), baseColor1, vec4(0.75, 0.75, 0.75, 1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2yWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 119, 119, 653], [655, 655, 712, 712, 1433]], "test": "valid"}
{"id": "MsBBzR", "name": "Raymarch 9001", "author": "johannesCmayer", "description": "Raymarch", "tags": ["raymach"], "likes": 0, "viewed": 101, "published": "Public", "date": "1625659980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int maxSteps = 100;\nfloat epsilon = .001;\n\nstruct Sphere\n{\n    int id;\n    vec3 pos;\n    float r;\n};\n    \nstruct HitData\n{\n    bool hit;\n    vec3 hitP;\n};\n\nSphere createSphere(int id, vec3 pos, float r)\n{\n    Sphere sp;\n    sp.id = id;\n    sp.pos = pos;\n\tsp.r = r;\n    \n    return sp;\n}\n\nvec3 RotateX(vec3 toRotate, vec3 camRot)\n{\n    mat3 rX = mat3 (\n        1.0, 0.0, 0.0,\n        0.0, cos(camRot.x), -sin(camRot.x),\n        0.0, sin(camRot.x), cos(camRot.x)\n        );  \n\n        return toRotate * rX;\n}\n\nvec3 RotateY(vec3 toRotate, vec3 camRot)\n{\n    mat3 rY = mat3 (\n        cos(camRot.y), 0.0,sin(camRot.y),\n        0.0, 1.0, 0.0,\n        -sin(camRot.y), 0.0, cos(camRot.y)\n        );  \n\n        return toRotate * rY;\n}\n\nvec3 RotateZ(vec3 toRotate, vec3 camRot)\n{\n    mat3 rZ = mat3 (\n        cos(camRot.z), -sin(camRot.z), 0.0,\n        sin(camRot.z), cos(camRot.z), 0.0,\n        0.0, 0.0, 1.0\n        );  \n\n        return toRotate * rZ;\n}\n\nvec3 Rotate(vec3 toRotate, vec3 camPos, vec3 camRot)\n{\n    vec3 tp = toRotate - camPos;\n    tp = RotateZ(RotateY(RotateX(tp, camRot), camRot), camRot);\n    return tp + camPos;\n}\n\nfloat sceneDistance(vec3 pos, Sphere s)\n{\n    return length(s.pos - pos) - s.r;\n}\n\nvec3 CalcNormal(Sphere sp, vec3 hitpoint)\n{    \n    vec3 n = normalize(hitpoint - sp.pos);\n    n = vec3((n.x + 1.) / 2., (n.y + 1.) / 2., (n.z + 1.) / 2.);\n    return n;\n}\n\nHitData raymarch(vec3 rayOrigin, vec3 rayDirection, Sphere sp)\n{\n    float t = 0.;\n    HitData hd;\n    rayDirection = normalize(rayDirection);\n    \n    for (int i = 0; i < maxSteps; i++)\n    {\n        float d = sceneDistance(rayOrigin + rayDirection * t, sp);\n        if (d < epsilon)\n        {\n            hd.hit = true;\n            hd.hitP = rayOrigin + rayDirection * t;            \n            return hd;\n        }\n        t += d;\n    }\n    hd.hit = false;\n    hd.hitP = rayOrigin + rayDirection * t;\n    return hd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Sphere sp = createSphere(0, vec3(0., 0.1, 1.), .1);\n    Sphere sp2 = createSphere(1, vec3(0., 0.1, -1.), .1);\n        \n    //camera\n    vec3 camPos = vec3(0., 0.1, 0.);\n    vec3 camRot = vec3(0.2, iTime, 0.1);\n    \n    float screenSpaceX = fragCoord.x;\n    float screenSpaceY = fragCoord.y;\n    \n    screenSpaceX = (screenSpaceX - iResolution.x / 2.) / iResolution.y;\n    screenSpaceY = (fragCoord.y - iResolution.y / 2.) / iResolution.y;\n       \n    HitData hit = raymarch(camPos, Rotate(vec3(screenSpaceX, screenSpaceY, 1.), camPos, camRot) + camPos, sp);\n    HitData hit2 = raymarch(camPos, Rotate(vec3(screenSpaceX, screenSpaceY, 1.), camPos, camRot) + camPos, sp2);\n        \n    if (hit.hit || hit2.hit)\n    {\n\tfragColor = vec4(CalcNormal(sp, hit.hitP).x + CalcNormal(sp2, hit2.hitP).x, \n                     CalcNormal(sp, hit.hitP).y + CalcNormal(sp2, hit2.hitP).y, \n                     CalcNormal(sp, hit.hitP).z + CalcNormal(sp2, hit2.hitP).z, 1.);\n    }\n    else if (hit.hitP.y > -0.1 && hit2.hitP.y > -0.1)\n    {\n        fragColor = vec4(0., 0., 0.2, 1.);\n    }\n    else\n    {\n        fragColor = vec4(0., 0.3, 0., 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsBBzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 204, 204, 286], [288, 288, 330, 330, 506], [508, 508, 550, 550, 725], [727, 727, 769, 769, 945], [947, 947, 1001, 1001, 1124], [1126, 1126, 1167, 1167, 1207], [1209, 1209, 1252, 1252, 1380], [1382, 1382, 1446, 1446, 1903], [1905, 1905, 1962, 1962, 3106]], "test": "valid"}
{"id": "Nl2SzD", "name": "Fractal 69_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 18, "viewed": 260, "published": "Public API", "date": "1627225398", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.3;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.8)*.03*exp(-i*i*e)\n    )\n    {\n        p=g*d;\n        p+=vec3(.3,.3,-1.8);\n        p=R(p,vec3(.577),iTime*.1);\n        // https://www.shadertoy.com/view/3ttyzB\n        // Based on the idea of jarble\n        p=cos(p*3.+3.*cos(p*.3));\n        s=3.;\n        for(int j=0;j++<8;)\n            p=clamp(p,-.5,.5)*2.-p,\n            s*=e=7.*clamp(.3/min(dot(p,p),1.),.0,1.),\n            p*=e;\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2SzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 731]], "test": "valid"}
{"id": "Nl2Szw", "name": "Little Sines", "author": "billowers", "description": "Sine bright like a diamond", "tags": ["circle", "sine", "lights", "neon", "pathing", "chasing"], "likes": 5, "viewed": 78, "published": "Public", "date": "1627400128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = I/(iResolution.xy / 2.0);  // range from 0 to 2, so we can have x in [-1,1], y in [-1,1]\n    uv = uv - vec2(1.0,1.0); // move the origin to the centre of the circle/noramlised space\n    \n    float frequency = 8.0; // number of cycles for sine wave, matches crest & dip counts\n    float amplitude = 0.10; // we actually experience +/- of this value so 2 of it in length\n    \n    float circle_radius = 0.8; // this is the radius of the circle before the sine wave gets involved, account for +/- 1 of the amplitude\n    float edge_width = 0.02; // On a disk this is the fade off at the edge, on a line, this the fade off either side\n    \n    \n    \n    // Disc Version\n    //float colour = smoothstep(circle_radius - edge_width, circle_radius, length(uv) + (sin(atan(uv.y, uv.x) * frequency - 3.141 / 2.0) * amplitude));\n    // NOTE: PI/2 is just a constant that aligns the crests with the x/y axis by rotating in x/y, space, but really just offseting our angle that the sine is driven by\n    \n    // Line Version\n    //colour = smoothstep( 0.0, edge_width, abs( circle_radius - length(uv) + (sin(atan(uv.y, uv.x) * frequency - 3.141 / 2.0) * amplitude)));\n    \n    \n\n    // Lines & Discs\n    // A line we want to be a certain distance either side of the radius\n    // A disc we want to be above and below the radius\n    // Essentially the core difference is either just using the distance from the centre, or the the distance from the radius itself\n    \n    // Circle Line\n    // colour = smoothstep(0.0, 0.01, abs(circle_radius- length(uv)));\n    // This essentially says we only accept points 0.01 from our\n    \n    // Circular Disc\n    // colour = smoothstep(circle_radius - 0.01, circle_radius, length(uv));\n    // 0.01 is the distance of the fade at the egdes for both\n    \n    \n    // Smooth step\n    // everything less than first edge is 0\n    // everything greater than second edge is 1\n    // when inbetween, the interpolate between the two edges to give you values between 0 & 1\n   \n    \n    \n    float centre_angle = atan(uv.y, uv.x);\n    // Using the two argument of atan gives nicer results as it handles some of the jankeness around +/- axes and the undefined point\n    // https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/atan.xhtml\n\n    \n    float sine_distortion_1 =  (sin(centre_angle *  frequency        + iTime) * amplitude);\n    float sine_distortion_2 = -(sin(centre_angle * (frequency / 2.0) + iTime) * amplitude); \n    float sine_distortion_3 =  (sin(centre_angle * (frequency / 4.0) + iTime) * amplitude);\n    float sine_distortion_4 = -(sin(centre_angle * (frequency / 8.0) + iTime) * amplitude);\n    // Can cause desync (disconnect in graph) when uv.x = 0. Depends on if they even or odd frequency divisors and if they sync up or not at that value\n    // Sticking to even divisors of an even frequency is kosher!\n\n    float flare_shape_1 = smoothstep(edge_width, 0.0, abs(circle_radius - 0.25 - length(uv) - sine_distortion_1 + sine_distortion_2));\n    float flare_shape_2 = smoothstep(edge_width, 0.0, abs(circle_radius - 0.18 - length(uv) + sine_distortion_1 + sine_distortion_4));\n    float flare_shape_3 = smoothstep(edge_width, 0.0, abs(circle_radius - 0.11 - length(uv) + sine_distortion_2 + sine_distortion_3));\n    float flare_shape_4 = smoothstep(edge_width, 0.0, abs(circle_radius - 0.03  - length(uv) + sine_distortion_1 + sine_distortion_2 + sine_distortion_3 + sine_distortion_4));\n    \n    //flare_shape_1 = 1. - (1.-flare_shape_1)*(1.-flare_shape_1)*(1.-flare_shape_1)*(1.-flare_shape_1);\n    \n    // Colouring\n    vec4 flare_1 = vec4(flare_shape_1 * vec3(0.1,1.0,1.0), 1.0); // blue\n    vec4 flare_2 = vec4(flare_shape_2 * vec3(0.9,0.1,0.5), 1.0); // pink\n    vec4 flare_3 = vec4(flare_shape_3 * vec3(1.0,1.0,1.0), 1.0); // white\n    vec4 flare_4 = vec4(flare_shape_4 * vec3(1.0,0.9,0.1), 1.0); // yellow\n    \n    \n    // Segment\n    \n    //float moving_angle = mod(iTime, 2. * PI) - PI; // want a value that runs from -PI to PI with time\n    \n    float flare_length = PI;\n    float angle_offset = PI / 6.;\n    \n    float min_angle = mod(iTime * 1.2, 2. * PI) - PI;\n    float max_angle = mod(iTime * 1.2 + flare_length, 2. * PI) - PI;\n    \n    if(min_angle > max_angle)\n    {\n        if(centre_angle < max_angle) centre_angle += 2. * PI;\n        \n        max_angle += 2.* PI;\n    }\n    \n    float visible_angle_distance = (max_angle - min_angle);\n    float t = (centre_angle - min_angle) / visible_angle_distance;\n    \n    t *= t *t; // effect the tail drop off\n    \n    flare_1 *= t* step(min_angle, centre_angle) *step(centre_angle, max_angle);\n    flare_2 *= t* step(min_angle, centre_angle) *step(centre_angle, max_angle);\n    flare_3 *= t* step(min_angle, centre_angle) *step(centre_angle, max_angle);\n    flare_4 *= t* step(min_angle, centre_angle) *step(centre_angle, max_angle);\n   \n    \n    O = flare_1 + flare_2 + flare_3 + flare_4;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2Szw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 66, 66, 4972]], "test": "valid"}
{"id": "Nl2XRm", "name": "Fractal 70_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 10, "viewed": 290, "published": "Public API", "date": "1627340359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.3;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.8)*.03*exp(-i*i*e)\n    )\n    {\n        p=g*d;\n        p+=R(vec3(1,.8,1.2),vec3(.577),iTime*.03);\n        p=R(p,vec3(.577),iTime*.1);\n        // https://www.shadertoy.com/view/3ttyzB\n        // Based on the idea of jarble\n        p=cos(p*3.+4.*cos(p*.5));\n        vec4 q=vec4(p,sin(iTime)*.2);\n        s=3.;\n        for(int j=0;j++<8;)\n            q=clamp(q,-.5,.5)*2.-q,\n            s*=e=7.*clamp(.3/min(dot(q,q),1.),.0,1.),\n            q*=e;\n        g+=e=length(q)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2XRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 791]], "test": "valid"}
{"id": "Nl2XzW", "name": "Witted-Tracing", "author": "HigashiSan", "description": "A ray tracing programe, use witted style method.", "tags": ["3d", "raytrcing"], "likes": 0, "viewed": 167, "published": "Public API", "date": "1627210812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926536;\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.3, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 8;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 18;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID_1;\n    int materialID_2;\n    int type; //1 is for grid,2 is for normal plane\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\nfloat height(float time,float h,float arg){\n\n    return abs(h*sin(arg*time)/time);\n}\n\nfloat x_loc(float angle,float time){\n    return 2.*cos(angle)*time;\n}\n\nfloat z_loc(float angle,float time){\n    return 2.*sin(angle)*time;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].type = 1;\n    Plane[0].materialID_1 = 6;\n    Plane[0].materialID_2 = 0;\n    \n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID_1 = 3;\n    Plane[1].type = 2;\n\n    // Center bouncing sphere.\n    \n    float time = mod(iTime,5.);\n    \n    \n    Sphere[0].center = vec3( 3.0+x_loc(45.,time),  height(time,5.,7.) + 0.7, 0.0+z_loc(45.,time ) );\n    Sphere[0].radius = 0.7;\n    Sphere[0].materialID = 7;\n\n    Sphere[1].center = vec3( 2.0+x_loc(30.,time),  height(time,5.,5.5) + 0.2, -8.0+z_loc(30.,time) );\n    Sphere[1].radius = 0.5;\n    Sphere[1].materialID = 7;\n    \n    Sphere[2].center = vec3( 3.0+x_loc(15.,time),  height(time,5.,4.5) + 0.2, -3.0+z_loc(15.,time) );\n    Sphere[2].radius = 0.4;\n    Sphere[2].materialID = 5;\n    \n    Sphere[3].center = vec3( 5.0+x_loc(60.,time),  height(time,4.,7.5) + 0.7, -9.0+z_loc(60.,time) );\n    Sphere[3].radius = 0.7;\n    Sphere[3].materialID = 6;\n    \n    Sphere[4].center = vec3( -2.0+x_loc(-45.,time),  height(time,5.,5.5) + 0.7, 2.0+z_loc(-45.,time) );\n    Sphere[4].radius = 0.7;\n    Sphere[4].materialID = 3;\n    \n    Sphere[5].center = vec3( -3.5+x_loc(-60.,time),  height(time,5.,7.5) + 0.6, 1.0+z_loc(-60.,time) );\n    Sphere[5].radius = 0.6;\n    Sphere[5].materialID = 4;\n    \n    Sphere[6].center = vec3( -3.5+x_loc(-15.,time),  height(time,5.,6.)+ 0.6, 6.0+z_loc(-15.,time) );\n    Sphere[6].radius = 0.6;\n    Sphere[6].materialID = 2;\n    \n    Sphere[7].center = vec3( -5.5+x_loc(-45.,time),  height(time,5.,7.) + 0.4, 3.0+z_loc(-45.,time) );\n    Sphere[7].radius = 0.4;\n    Sphere[7].materialID = 3;\n    \n    Sphere[8].center = vec3( 4.5+x_loc(75.,time),  height(time,5.,4.5) + 0.45, 1.5 +z_loc(75.,time));\n    Sphere[8].radius = 0.45;\n    Sphere[8].materialID = 1;\n    \n    Sphere[9].center = vec3( -2.5+x_loc(-35.,time),  height(time,5.,5.) + 0.3, 4.2 +z_loc(-35.,time));\n    Sphere[9].radius = 0.3;\n    Sphere[9].materialID = 5;\n    \n    Sphere[10].center = vec3( 1.0+x_loc(15.,time),  height(time,5.,3.) + 0.5, 3.5 +z_loc(15.,time));\n    Sphere[10].radius = 0.5;\n    Sphere[10].materialID = 5;\n    \n    Sphere[11].center = vec3( -3.5+x_loc(-80.,time),  height(time,5.,4.) + 0.6, 1.0+z_loc(-80.,time) );\n    Sphere[11].radius = 0.6;\n    Sphere[11].materialID = 3;\n    \n    Sphere[12].center = vec3( 11.0+x_loc(-35.,time),  height(time,5.,4.5) + 0.8, 5.5+z_loc(-35.,time) );\n    Sphere[12].radius = 0.8;\n    Sphere[12].materialID = 4;\n    \n    Sphere[13].center = vec3( -3.5+x_loc(-55.,time),  height(time,5.,3.)+ 0.8, -4.5+z_loc(-55.,time) );\n    Sphere[13].radius = 0.8;\n    Sphere[13].materialID = 4;\n    \n    Sphere[14].center = vec3( 0.5+x_loc(25.,time),  height(time,5.,6.) + 0.3, 7.5+z_loc(25.,time) );\n    Sphere[14].radius = 0.3;\n    Sphere[14].materialID = 2;\n    \n    Sphere[15].center = vec3( 2.5+x_loc(25.,time),  height(time,5.,4.) + 0.4, 1.5+z_loc(25.,time) );\n    Sphere[15].radius = 0.4;\n    Sphere[15].materialID = 4;\n    \n    Sphere[16].center = vec3( 3.5+x_loc(55.,time),  height(time,5.,5.5) + 0.35, 2.5+z_loc(55.,time) );\n    Sphere[16].radius = 0.35;\n    Sphere[16].materialID = 6;\n    \n    Sphere[17].center = vec3( 0.5+x_loc(5.,time),  height(time,5.,5.5) + 0.6, -4.5+z_loc(5.,time) );\n    Sphere[17].radius = 0.6;\n    Sphere[17].materialID = 2;\n\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.4, 0.8, 0.2 );\n    Material[2].k_a = 0.3 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.4 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    //Copper material\n    Material[3].k_d = vec3( 0.780392, 0.568627, 0.113725 );\n    Material[3].k_a = vec3( 0.329412, 0.223529, 0.027451 );\n    Material[3].k_r = vec3( 0.992157, 0.941176, 0.807843 );\n    Material[3].k_rg = 0.4 * Material[3].k_r;\n    Material[3].n = 27.0;\n    \n    //Red diomand\n    Material[4].k_d = vec3( 0.614240, 0.041360, 0.041360 );\n    Material[4].k_a = vec3( 0.174500, 0.011750, 0.011750 );\n    Material[4].k_r = vec3( 0.727811, 0.626959, 0.626959 );\n    Material[4].k_rg = vec3( 0.550000, 0.550000, 0.550000);\n    Material[4].n = 128.0;\n    \n    //pearl\n    Material[5].k_d = vec3( 1.000000, 0.829000, 0.829000 );\n    Material[5].k_a = vec3( 0.250000, 0.207250, 0.207250 );\n    Material[5].k_r = vec3( 0.296648, 0.296648, 0.296648 );\n    Material[5].k_rg = 0.4 * Material[5].k_r;\n    Material[5].n = 128.0;\n    \n    //Bronze\n    Material[6].k_d = vec3( 0.714000, 0.428400, 0.181440 );\n    Material[6].k_a = vec3( 0.212500, 0.127500, 0.054000 );\n    Material[6].k_r = vec3( 0.393548, 0.271906, 0.166721 );\n    Material[6].k_rg = 0.4 * Material[6].k_r;\n    Material[6].n = 128.0;\n    \n    //violet\n    Material[7].k_d = vec3( 0.430000, 0.470000, 0.540000 );\n    Material[7].k_a = vec3( 0.110000, 0.060000, 0.090000 );\n    Material[7].k_r = vec3( 0.330000, 0.330000, 0.520000 );\n    Material[7].k_rg = 0.4 * Material[7].k_r;\n    Material[7].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 15.0, 8.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -10.0 + 30.0 * sin(iTime / 3.0), 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1 + sin(iTime), 0.1, 0.1);\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n    \n}\n\n\n\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n   \n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    // (p.x-sph.center.x)^2 + (p.y-sph.center.y)^2 + (p.z-sph.center.z)^2=sph.radius^2\n    float t1,t2;\n    float a = dot(ray.d,ray.d);\n    float b = 2.0 * dot(ray.o - sph.center, ray.d);\n    float c = dot(ray.o - sph.center, ray.o - sph.center) - sph.radius * sph.radius;\n\n    if((b * b - 4.0 * a * c)<0.0) return false;\n\n    t1 = (-b - sqrt(b * b - 4. * a * c)) / (2. * a);\n    t2 = (-b + sqrt(b * b - 4. * a * c)) / (2. * a);\n\n    if(t1 < tmin || t2 > tmax) return false;\n   \n    t = t1;\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize(ray.o - sph.center + t * ray.d);\n    return true;  \n}\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    float t1,t2;\n    float a = dot(ray.d,ray.d);\n    float b = 2.0 * dot(ray.o - sph.center, ray.d);\n    float c = dot(ray.o - sph.center, ray.o - sph.center) - sph.radius * sph.radius;\n    if((b * b - 4.0 * a * c)<0.0) return false;\n\n    t1 = (-b - sqrt(b * b - 4.0 * a * c)) / 2.0 * a;\n    t2 = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 * a;\n\n    if(t1 < tmin || t2 > tmax) return false;\n\n    return true; \n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    for(int i =0;i<NUM_PLANES;++i){\n        if(IntersectPlane(Plane[i],ray,DEFAULT_TMIN,DEFAULT_TMAX))\n        {\n            IntersectPlane(Plane[i],ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t,temp_hitPos,temp_hitNormal);\n            if(temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                \n                if(Plane[i].type == 1){\n                    float tempX = mod(nearest_hitPos.x,5.)-2.5;\n                    float tempZ = mod(nearest_hitPos.z,5.)-2.5;\n                    if(tempX*tempZ<0.)\n                        nearest_hitMatID = Plane[i].materialID_1;\n                    else\n                        nearest_hitMatID = Plane[i].materialID_2;\n                }\n                else if(Plane[i].type == 2){\n                    nearest_hitMatID = Plane[i].materialID_1;\n                }\n            }\n            hasHitSomething = true;\n        }\n    }\n\n    for(int i =0;i<NUM_SPHERES;++i){\n        if(IntersectSphere(Sphere[i],ray,DEFAULT_TMIN,DEFAULT_TMAX))\n        {\n            IntersectSphere(Sphere[i],ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t,temp_hitPos,temp_hitNormal);\n            if(temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n            hasHitSomething = true;\n        }\n    }\n\n\n    /////////////////////////////////\n\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  \n\n    for(int i=0;i<NUM_LIGHTS;i++){\n        Ray_t shadowRay;\n        vec3 disToLight = nearest_hitPos - Light[i].position;\n        shadowRay.o = Light[i].position;\n        shadowRay.d = normalize(disToLight);\n\n        \n        temp_hasHit = false;\n        for(int j=0;j<NUM_SPHERES;++j){\n            if(temp_hasHit) break;\n            temp_hasHit = IntersectSphere(Sphere[j],shadowRay,DEFAULT_TMIN,length(disToLight)-DEFAULT_TMIN);\n        }\n        for(int j=0;j<NUM_PLANES;++j){\n            if(temp_hasHit) break;\n            temp_hasHit = IntersectPlane(Plane[j],shadowRay,DEFAULT_TMIN,length(disToLight)-DEFAULT_TMIN);\n        }\n        vec3 color = PhongLighting(-shadowRay.d,nearest_hitNormal,normalize(ray.o-nearest_hitPos),temp_hasHit,Material[nearest_hitMatID],Light[i]);\n        I_local += color;\n    }\n\n    /////////////////////////////////\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    I_local = clamp(I_local,vec3(0.,0.,0.) ,vec3(1.,1.,1.) );\n\n    return I_local;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    float addPos = sin(iTime);\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 6.5 + addPos * 1.5, 3.0 , 14.5 + addPos * 1.5);\n    vec3 cam_lookat = vec3( 1.0, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4(I_result , 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2XzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1973, 1973, 2016, 2016, 2057], [2059, 2059, 2095, 2095, 2128], [2130, 2130, 2166, 2166, 2199], [2202, 2384, 2402, 2427, 8253], [8257, 8257, 8411, 8411, 8705], [8707, 8707, 8790, 8790, 9002], [9005, 9005, 9162, 9249, 9765], [9767, 9767, 9852, 9852, 10260], [10264, 10618, 10748, 10748, 11160], [11163, 11163, 11276, 11276, 14528], [14530, 14530, 14587, 14587, 16073]], "test": "valid"}
{"id": "NlBGz3", "name": "Ray Tracing One Weekend", "author": "chenglou", "description": "From [url]https://raytracing.github.io/books/RayTracingInOneWeekend[/url]. A path tracer. Ported it over almost verbatim.\nAnimated it for stress testing speed. No temporal AA hack\nMuch improved version at [url]https://www.shadertoy.com/view/7tBXDh[/url]", "tags": ["raytracing"], "likes": 6, "viewed": 195, "published": "Public API", "date": "1625120774", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://raytracing.github.io/books/RayTracingInOneWeekend.html\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random_in_unit_sphere(vec2 p) {\n    float test = 0.;\n    while (test < 9999.) {\n        vec3 pt = hash32(p * 10000. + test) * 2. - 1.;\n        float len = length(pt);\n        if (len * len >= 1.) {\n            test += 1.;\n            continue;\n        }\n        return pt;\n    }\n}\n\nvec3 random_unit_vector(vec2 p) {\n    return normalize(random_in_unit_sphere(p));\n}\n\nvec3 random_in_unit_disk(vec2 p) {\n    float test = 0.;\n    while (test < 9999.) {\n        vec3 pt = vec3(hash22(p * 10000. + test) * 2. - 1., 0);\n        float len = length(pt);\n        if (len * len >= 1.) {\n            test += 1.;\n            continue;\n        }\n        return pt;\n    }\n}\n\n\nconst int material_lambertian = 0;\nconst int material_metal = 1;\nconst int material_dielectric = 2;\n\nstruct ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct material {\n    int type;\n    vec3 albedo;\n    float metal_fuzz;\n    float dielectric_index_of_refraction;\n};\n\nstruct hit_record {\n    vec3 p;\n    vec3 normal;\n    float t;\n    material material;\n};\n\nstruct sphere {\n    vec3 center;\n    float radius;\n    material material;\n};\n\nsphere[] spheres = sphere[](\n    // ground\n    sphere(vec3( 0.0, -1000., -1.0), 1000., material(material_lambertian, vec3(0.5), 0., 0.)),\n\n    sphere(vec3(-4.0,    1.0, 2.),   1.0, material(material_dielectric, vec3(0), 0., 1.5)),\n    sphere(vec3( 0.0,    1.0, 0.),   1.0, material(material_metal, vec3(0.7, 0.6, 0.5), 0., 0.)),\n    sphere(vec3( 4.0,    1.0, 2.),   1.0, material(material_lambertian, vec3(0.7, 0.3, 0.3), 0., 0.)),\n\n    // smaller balls\n    sphere(vec3(-6, 0.2, 2.8), 0.2, material(material_dielectric, vec3(0, 0, 0.2), 0., 1.5)),\n    sphere(vec3(1.6, 0.2, -0.9), 0.2, material(material_dielectric, vec3(0), 0., 1.5)),\n    sphere(vec3(-5.7, 0.2, -2.7), 0.2, material(material_lambertian, vec3(0.8, 0.3, 0.3), 0., 0.)),\n    sphere(vec3(-3.6, 0.2, -4.4), 0.2, material(material_lambertian, vec3(0.9, 0.3, 0.2), 0., 0.)),\n    sphere(vec3(0.8, 0.2, 2.3), 0.2, material(material_lambertian, vec3(0.2, 0, 0.5), 0., 0.)),\n    sphere(vec3(3.8, 0.2, 4.2), 0.2, material(material_lambertian, vec3(0.4, 0.3, 0.7), 0., 0.)),\n    sphere(vec3(-0.1, 0.2, -1.9), 0.2, material(material_lambertian, vec3(0.4, 0, 0.4), 0., 0.)),\n    sphere(vec3(-2.5, 0.2, 5.4), 0.2, material(material_metal, vec3(0.3, 0.7, 0.9), 0.3, 0.)),\n    sphere(vec3(-3.9, 0.2, -0.3), 0.2, material(material_lambertian, vec3(0.9, 0.8, 0.5), 0., 0.)),\n    sphere(vec3(-6, 0.2, 4), 0.2, material(material_lambertian, vec3(0.9, 0.9, 0.5), 0., 0.)),\n    sphere(vec3(4.4, 0.2, -0.5), 0.2, material(material_lambertian, vec3(0.5, 0.4, 0.8), 0., 0.)),\n    sphere(vec3(3.4, 0.2, 5.3), 0.2, material(material_lambertian, vec3(0.1, 0.6, 0.2), 0., 0.)),\n    sphere(vec3(4.6, 0.2, -3.8), 0.2, material(material_lambertian, vec3(0.2, 0.2, 0.2), 0., 0.)),\n    sphere(vec3(0.7, 0.2, -2.5), 0.2, material(material_metal, vec3(0, 0.2, 0.1), 0., 0.)),\n    sphere(vec3(2.4, 0.2, -4.3), 0.2, material(material_lambertian, vec3(0.8, 0.9, 0), 0., 0.)),\n    sphere(vec3(4.4, 0.2, 4.9), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0), 0., 0.)),\n    sphere(vec3(-4.7, 0.2, 4.6), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.7), 0., 0.)),\n    sphere(vec3(4.2, 0.2, -3.5), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.6), 0., 0.)),\n    sphere(vec3(-5.2, 0.2, 0.5), 0.2, material(material_lambertian, vec3(0.2, 0.7, 0.9), 0., 0.)),\n    sphere(vec3(5.7, 0.2, -0.8), 0.2, material(material_lambertian, vec3(0.3, 0, 0.7), 0., 0.))\n);\n\nbool hit_sphere(sphere sph, ray r, float t_min, float t_max, out hit_record rec) {    \n    vec3 oc = r.origin - sph.center;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discriminant = half_b * half_b - a * c;\n    if (discriminant < 0.) {\n        return false;\n    }\n    \n    float sqrtd = sqrt(discriminant);\n    \n    // Find the nearest root that lies in the acceptable range\n    float root = (-half_b - sqrtd) / a; // the t. from -b - sqrt(dis) / 2a\n    if (root < t_min || t_max < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < t_min || t_max < root) {\n            return false;\n        }\n    }\n    \n    vec3 p = r.origin + r.dir * root;\n    rec = hit_record(p, (p - sph.center) / sph.radius, root, sph.material);\n    \n    return true;\n}\n\nbool hit(ray r, float t_min, float t_max, out hit_record rec) {\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    \n    hit_record rec_;\n    for (int i = 0; i < spheres.length(); i++) {\n        if (hit_sphere(spheres[i], r, t_min, closest_so_far, rec_)) {\n            hit_anything = true;\n            closest_so_far = rec_.t;\n            rec = rec_;\n        }\n    }\n    \n    return hit_anything;\n}\n\nbool near_zero(vec3 p) {\n    float s = 1e-8;\n    return p.x < s && p.y < s && p.z < s;\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance\n    float r0 = (1. - ref_idx) / (1. + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1. - cosine), 5.);\n}\n\nbool scatter(hit_record rec, ray r, vec2 seed, out vec3 attenuation, out ray scattered) {\n    material m = rec.material;\n    \n    if (m.type == material_lambertian) {\n        vec3 scatter_direction = rec.normal + random_unit_vector(seed);\n    \n        // catch degenerate scatter direction\n        if (near_zero(scatter_direction)) {\n            scatter_direction = rec.normal;\n        }\n\n        scattered = ray(rec.p, scatter_direction);\n        attenuation = m.albedo;\n        return true;\n    } else if (m.type == material_metal) {\n        vec3 reflected = reflect(normalize(r.dir), rec.normal);\n        scattered = ray(rec.p, reflected + m.metal_fuzz * random_in_unit_sphere(seed));\n        attenuation = m.albedo;\n        return dot(scattered.dir, rec.normal) > 0.;\n    } else if (m.type == material_dielectric) {\n        attenuation = vec3(1);\n        \n        bool front_face = dot(r.dir, rec.normal) < 0.;\n        vec3 adjusted_normal = front_face ? rec.normal : -rec.normal;\n        float ref = m.dielectric_index_of_refraction;\n        float refraction_ratio = front_face ? 1.0/ref : ref;\n        \n        vec3 unit_direction = normalize(r.dir);\n        float cos_theta = min(dot(-unit_direction, adjusted_normal), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n        \n        bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n        vec3 direction;\n\n        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > hash12(seed)) {\n            direction = reflect(unit_direction, adjusted_normal);\n        } else {\n            direction = refract(unit_direction, adjusted_normal, refraction_ratio);\n        }\n        \n        scattered = ray(rec.p, direction);\n        return true;\n    }\n}\n\nvec3 ray_color(in ray r, vec2 seed, int max_depth) {\n    vec3 color = vec3(1);\n    \n    int depth = max_depth;\n    hit_record rec;\n    while (depth > 0) {\n        if (hit(r, 0.001, 99999., rec)) {\n            ray scattered;\n            vec3 attenuation;\n            if (scatter(rec, r, seed + float(depth), attenuation, scattered)) {\n                r = scattered;\n                color = attenuation * color;\n            }\n        } else {\n            // hit bg, aka nothing\n            vec3 unit_direction = normalize(r.dir);\n            float t = 0.5 * (unit_direction.y + 1.0);\n            color *= mix(vec3(1.), vec3(0.5, 0.7, 1.0), t);\n\n            break;\n        }\n        \n        depth--;\n    }\n    \n    if (depth == 0) {\n        return vec3(0);\n    }\n    return color;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // image\n    float samples_per_pixel = 10.;\n    int max_depth = 6; // number of ray bounces\n    \n    // camera\n    vec3 lookfrom = vec3(cos(iTime) * 13., 2.0, sin(iTime) * 10.);\n    vec3 lookat = vec3(0, 0, 0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 30.0;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    float aperture = 0.1;\n    float focus_dist = 10.0;\n    \n    float theta = radians(vfov);\n    float h = tan(theta / 2.);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n    \n    vec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n    \n    vec3 origin = lookfrom;\n    vec3 horizontal = focus_dist * viewport_width * u;\n    vec3 vertical = focus_dist * viewport_height * v;\n    vec3 lower_left_corner = origin - horizontal / 2. - vertical / 2. - focus_dist * w;\n    \n    float lens_radius = aperture / 2.;\n    \n    // render\n    vec3 color = vec3(0);\n    for (float s = 0.; s < samples_per_pixel; s++) {\n        vec2 rand = hash22(fragCoord * 10000. + s);\n               \n        vec2 normalizedCoord = (fragCoord + rand) / (iResolution.xy - 1.);\n        vec3 rd = lens_radius * random_in_unit_disk(normalizedCoord);\n        vec3 offset = u * rd.x + v * rd.y;\n        ray r = ray(\n            origin + offset, \n            lower_left_corner + normalizedCoord.x * horizontal + normalizedCoord.y * vertical - origin - offset\n        );\n        color += ray_color(r, normalizedCoord, max_depth);\n    }\n    \n    fragColor = vec4(sqrt(color / samples_per_pixel), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 88, 88, 205], [206, 206, 227, 227, 364], [365, 365, 386, 386, 525], [527, 527, 563, 563, 812], [814, 814, 847, 847, 897], [899, 899, 933, 933, 1191], [4023, 4023, 4105, 4105, 4867], [4869, 4869, 4932, 4932, 5284], [5286, 5286, 5310, 5310, 5374], [5376, 5376, 5424, 5475, 5595], [5597, 5597, 5686, 5686, 7336], [7338, 7338, 7390, 7390, 8122], [8124, 8124, 8181, 8194, 9772]], "test": "error"}
{"id": "NlBSWz", "name": "Five-pointed", "author": "shihao", "description": "Five-pointed", "tags": ["fivepointed"], "likes": 1, "viewed": 128, "published": "Public API", "date": "1627391476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Polar equation of a star-shaped decagon (pentagram)\n// adapted from Inigo Quilez's shader, https://www.shadertoy.com/view/lsccR8\n\n/*\nfloat sdfStar5( in vec2 p ) // iq's function\n{\n    // repeat domain 5x\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292); // pi/5\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    \n    // draw triangle\n    const vec2 k3 = vec2(0.951056516295,  0.309016994375); // pi/10\n    return dot( vec2(abs(p.x)-0.3,p.y), k3);\n}\n*/\n\nfloat polarStar( in vec2 p )\n{\n    const float pi5 = 0.628318530718; // pi/5\n    const float ph2 = 3.2360679775; // 2 * phi\n    \n    float m2 = mod(atan(p.y, p.x)/pi5 + 1.0, 2.0);\n    \n    return ph2 * length(p) * cos(pi5 * (m2 - 4.0 * step(1.0, m2) + 1.0)) - 1.0;\n}\n\nfloat polarStar2( in vec2 p )\n{\n    const float pi5 = 0.628318530718; // pi/5\n    const float ph2 = 3.2360679775; // 2 * phi\n    \n    float m2 = mod(atan(p.y, p.x)/pi5 + 1.0, 2.0);\n    \n    return ph2 * length(p) * cos(pi5 * (m2 - 4.0 * step(1.0, m2) + 1.0)) - 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coords\n    float px = 2.0/iResolution.y;\n\tvec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    \n    float uoffset = 0.00;\n    \n    float t  = (0.75 - uoffset) * iTime * sign(-uv.x) ;\n    float t2 = 0.75 * iTime * sign(-uv.x) ;\n    float t3 = (0.75 + uoffset) * iTime * sign(-uv.x) ;\n    \n    float middis = max((1.0 - abs( uv.x * 0.5)) * 2.5 , 1.1 ) ;\n    //middis = 0.1;\n    \n    vec2 q = uv * vec2(2,2) + vec2(t,0);\n    float d = polarStar2( (fract(q) - vec2(0.5)) * vec2( 5.0,5.0 ) * middis );\n\n    vec2 q2 = uv * vec2(2,2) + vec2(t2,0) + vec2(0.7,0.0);\n    float d2 = polarStar2( (fract(q2) - vec2(0.5)) * vec2( 5.0,5.0 )* middis );\n    \n    vec2 q3 = uv * vec2(2,2) + vec2(t3,0) + vec2(0.3,0.0);\n    float d3 = polarStar2( (fract(q3) - vec2(0.5)) * vec2( 5.0,5.0 )* middis );\n    \n    d = step(d,0.8);\n    d2 = step(d2,0.8);\n    d3 = step(d3,0.8);\n    //d += d2 + d3;\n    \n    d = max( max(d,d2),d3);\n    \n    vec3 col = mix(vec3(1.0, 1.0, 1.0), vec3(1.2, 1.4, 1.6), smoothstep(-2.0 * px, 2.0 * px, d));\n\tcol *= smoothstep(0.02, 0.02 + 2.0 * px, abs(d));\n    fragColor = vec4( col, 1.0 );\n    \n   // vec3 col = vec3(d,d,d);\n    col = mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), smoothstep(-2.0 * px, 2.0 * px, d));\n    //col = mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), d);\n    col *= smoothstep(0.02, 0.02 + 2.0 * px, abs(d));\n\t//fragColor = vec4( col, 1.0 );\n  //  fragColor = vec4( fract( q.y) );\n    //fragColor = vec4( uv.x  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBSWz.jpg", "access": "shaders20k", "license": "mit", "functions": [[1620, 1620, 1650, 1650, 1886], [1888, 1888, 1919, 1919, 2155], [2158, 2158, 2215, 2229, 3678]], "test": "valid"}
{"id": "NlBXRR", "name": "loading circle color", "author": "mikeken", "description": "loading ", "tags": ["loadingcircle"], "likes": 0, "viewed": 38, "published": "Public", "date": "1626935032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592654;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    const float count = 8.0;\n    \n    float radius = 10.0;\n    \n    float rotation = 0.0;\n    \n    vec2 pos = vec2(0.0,0.0);\n    \n    float R = 120.0; \n    \n    for(float i = 0.0; i < count; i++){\n        rotation = 2.0 * PI * i / count + iTime * PI ;\n        R = 100.0 * abs(sin(iTime));\n        pos = vec2(R * cos(rotation), R * sin(rotation));\n        radius = 15.0 + cos(rotation) * 4.0;\n        if( distance(iResolution.xy/2.0 - pos,fragCoord) <= radius)\n        {\n            if(R <= 15.0){\n            col = 0.5 + 0.5*cos(iTime+vec3(0,2,4));\n            }else{\n            col = 0.5 + 0.5*cos(iTime+i / 10.0 + vec3(0,2,4));\n            }\n        }\n    }\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 137, 949]], "test": "valid"}
{"id": "NlBXzD", "name": "Ray Marcher attempt 2", "author": "falconXYZ", "description": "ray marcher attempt 2 ", "tags": ["ray", "marching", "casting"], "likes": 3, "viewed": 26, "published": "Public", "date": "1627165139", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 256\n#define QUALITY 0.000001\n#define MAX_DISTANCE 1000.0\n\n\n\nfloat map(vec3 pos) {\n    float sphere = distance(pos,vec3(0.)) - 1.;\n    \n    float sphere2 = distance(pos,vec3(2. * cos(iTime),0.5 * cos(iTime),1.*sin(iTime))) - .125;\n    \n    pos += 0.125*(0.5*cos(iTime)+1.0)*sin(pos.x+2.*iTime) + 1.;\n    pos += 0.125*sin(pos.z+iTime) + 1.;\n    float plane = pos.y + 1.;\n    \n    return min(min(sphere,sphere2),plane);\n}\n\nvec3 getNormal (vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    float d = map(p);\n    vec3 n = d - vec3( map(p-e.xyy) , map(p-e.yxy) , map(p-e.yyx) );\n    return normalize(n);\n}\n\nvec3 diffuseLighting(vec3 pos,vec3 lightPos,vec3 Color, float power) {\n    vec3 light = normalize(lightPos - pos);\n    vec3 normal = getNormal(pos);\n    \n    float diffuse = clamp(dot(normal, light),0.0,1.0);\n    return diffuse * Color * power;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.;\n    uv.y *= 0.5;\n    \n    vec3 rayOrigin = vec3(0,0,-3);\n    vec3 rayDirection = normalize(vec3(uv,1.0));\n    \n    float distanceFromOrigin = 0.0;\n    \n    vec3 diffuseWhite;\n    vec3 diffuseRed;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 rayPosition = rayOrigin + (rayDirection * distanceFromOrigin);\n        \n        float map = map(rayPosition);\n        \n        distanceFromOrigin += map;\n        \n        if (map < QUALITY || distanceFromOrigin > MAX_DISTANCE) {\n        \n            break;\n            }\n        diffuseRed = diffuseLighting(rayPosition,vec3(5.0 * sin(iTime),1,5.0 * cos(iTime)), vec3(1,0,0), 1.0);\n        diffuseWhite = diffuseLighting(rayPosition,vec3(0,1,-5),vec3(1,1,1), 0.2);\n    }\n    vec3 diffuse = diffuseRed + diffuseWhite;\n    diffuse /= 2.0;\n    distanceFromOrigin/=4.0;\n    fragColor = vec4(diffuse,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 99, 99, 436], [438, 438, 463, 463, 611], [613, 613, 683, 683, 859], [861, 861, 918, 918, 1846]], "test": "valid"}
{"id": "NlfXR4", "name": "Warped Noise - Andrew", "author": "andrew741", "description": "Warped noise with a changing color gradient.", "tags": ["noise"], "likes": 2, "viewed": 60, "published": "Public", "date": "1625195894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// from another shadertoy shader (same one as the gradient noise as this is a part of it)\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from another shadertoy shader (im not good with creating/inplmenting gradient noise algerithms)\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n// samples the gradient noise and returns on height\nfloat SampleNoise(vec3 p)\n{\n    float h = noised(p).x;\n    h += noised(p*2. + 100.).x * 0.5;\n    h += noised(p*4. - 100.).x * 0.25;\n    h += noised(p*8. + 1000.).x * 0.125;\n    return h / (1.865);\n}\n\n\n// sample the gradient noise and returns 3 different heights (same as finding 3 different gradient noises)\nvec3 SampleNoiseV3(vec3 p)\n{\n    vec3 h = noised(p).rgb;\n    h += noised(p*2. + 100.).rgb * 0.5;\n    h += noised(p*4. - 100.).rgb * 0.25;\n    h += noised(p*8. + 1000.).rgb * 0.125;\n    return h / (1.865);\n}\n\n\n\n// gets the color based on the height\nvec3 colorGrade(float height)\n{\n    height *= 1.3;\n    vec3 col = SampleNoiseV3(vec3(height * 6., 0., -iTime * 0.3) - 20.);\n    // making it so that all the colors arnt black and also arnt neon\n    col /= pow(dot(col, col), 0.3);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*3.+iMouse.xy/60.;\n\n    // finding the amount of the x and y distortion for the noise\n    vec3 n = SampleNoiseV3(vec3(-uv * 0.2 - 5., -iTime * 0.3) - 20.);\n    n /= dot(n, n);\n    // finding the offset\n    vec3 offset = SampleNoiseV3(vec3(uv * 0.25, iTime) + 20.) * vec3(n.x, n.y, 0);\n    offset.x = length(offset.x + offset.y) * max(offset.x, offset.y) * 7.6;\n\n    // finding the color\n    vec3 col = colorGrade(1. - abs(SampleNoise(vec3(uv, iTime) + offset)));\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 91, 112, 112, 281], [283, 382, 408, 420, 1914], [1917, 1969, 1996, 1996, 2167], [2170, 2277, 2305, 2305, 2483], [2487, 2525, 2556, 2556, 2777], [2780, 2780, 2837, 2837, 3376]], "test": "valid"}
{"id": "NlfXRS", "name": "Raycaster Experiment 3", "author": "Yusef28", "description": "Skipping experiment 2 (although you can find it in the map function).\nNo movement yet.", "tags": ["raycast", "raycaster"], "likes": 4, "viewed": 58, "published": "Public", "date": "1625892484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n\n\nA good 49 percent of the time was debugging, \nbut another 49 percent was trying to fit everything together \nin my head in a way that made sense. Basic stuff but it's the details.\n\nIf we want a field of view of 60 degrees which is what \nmakes the most sense to most viewers, then we want that ratio\nof focal length to half of projection plane.\nAlternatively you could decide you want to be able to adjust\nfield of view so you would then input that first.\n\nfocal length should then depend of projection plane. imo right now.\nI mean, we should calculuate projection plane width first because\nit's like asking, how much do we want to see at once.\nHow much of what?\n\nSo we need to know what the map will be like first.\nan 8 x 8 grid is cool.\n\nSo then if we want to be able to see two blocks in front of us when\neach block is 1x1 then we want a projecet plane of 2 or -1 to 1\nthen we calc focal length from this with trig\n\nand we calculuate ray direction from those two\nand importantly we are going to have floor() involved somehow\nbecause we want id's for each ray so we can paint columns.\nAs long as we ue floor though, we don't need to do anything\nmore for id's as long as we use those rds in the trace and map function.\n\nwe can just have ray origin as 0,0 it's cool\n\nthen we trace using DDA \nand I stole a mapping idea from https://www.shadertoy.com/view/4dG3RD\nwhen my distance function idea failed.\n\nand then draw using heights to color everything\n\nStill can't move around without destroying the whole illusion though\nbut I got a lot done.\n*/\n\n#define res 160.\n#define radius 0.5\n\nmat2 rot(float a){ return mat2(cos(a),-sin(a),sin(a),cos(a) ); }\n\nfloat map(vec2 uv){\n    float d = 1000.;\n   \n    /*\n    for(float i = -4.;i <= 4.; i++){\n \n        //d = min(d, length(uv-vec2(i,4.))-radius);\n        vec2 auv = abs(uv - vec2(i, 4.));\n        float s = max(auv.x,auv.y) - radius;\n        \n        d = min(d, s);\n        d = min(d, length(uv-vec2(i,-4.))-radius);\n        d = min(d, length(uv-vec2(4.,i))-radius);\n        d = min(d, length(uv-vec2(-4.,i))-radius);\n    }\n    */\n\n    //I started by trying to make a map out of distance functions\n    //but found it a bit unwieldy.\n    //So I decided to make a mape like: https://www.shadertoy.com/view/4dG3RD\n    \n    d = uv.x == 4. || \n        uv.x == -4.|| \n        uv.y == 4. || \n        uv.y == -4. \n        ? -1. : 100.;\n        \n    d = (abs(uv.x) == 3. && \n        (abs(uv.y) >= 2. && abs(uv.y) <=3.))\n        ? -1. : d;\n        \n    d = (abs(uv.y) == 3. && \n        (abs(uv.x) >= 2. && abs(uv.x) <=3.))\n        ? -1. : d;\n        \n    d = (abs(uv.x) == 2. && \n        (abs(uv.y) >= 2. && abs(uv.y) <=3.))\n        ? -1. : d;\n        \n    d = (abs(uv.y) == 2. && \n        (abs(uv.x) >= 2. && abs(uv.x) <=3.))\n        ? -1. : d;\n        \n    return d;\n} \n\nfloat trace(vec2 ro, vec2 rd){\n\n    float startX = 0.;\n    float startY = 0.;\n    \n    float stepX = 1.;\n    float stepY = 1.;\n    \n    float dy = (rd.y/rd.x); //y = slope * x x is 1\n    float dx = (rd.x/rd.y); //x = y/slope y is 1\n    \n    //get the sign\n    //because if rd.x is going left we dont want step to remain positive\n    //for the y axis hit calculations. Etc.\n    float sy = sign(rd.y);\n    float sx = sign(rd.x);\n    \n    //initializing height\n    float height;\n    //start with a high distance \n    float dist = 100.;\n    //initialize an ending ray length\n    float endLength;\n    //plantPoint\n    vec2 planePoint = ro + rd; //since it points at the plane from ro\n    //at the start nothing is hit so 0.\n    float hit = 0.;\n    \n    //calculate the first hit points before the loop\n    //the step part is already done. These are the\n    //components that rely on the slope \n    \n    startX = rd.x < 0.0 ? floor(ro.x) - ro.x : ceil(ro.x) - ro.x;//+= dx;\n    startY = rd.y < 0.0 ? floor(ro.y) - ro.y : ceil(ro.y) - ro.y;//+= dy;\n    \n    //trying something else \n    //adding this to precalculate the first hit point in its\n    //entirelty based now also on ro.\n    //if ro is not the 0,0 we need to know where the first hits are\n    stepY = abs((rd.y/rd.x)*startX);\n    stepX = abs((rd.x/rd.y)*startY);\n    //init a current ray\n    vec2 currentRay;\n    for(float i = 1.; i < 10.; i += 1.){\n        \n        //we get both the x axis hit and the y axis hit\n        vec2 yHit = vec2(stepX*sx, startY);\n        vec2 xHit = vec2(startX, stepY*sy);\n        \n        //and we use and increment only the one that is closer to us\n        if(length(yHit) < length(xHit)){\n            currentRay = yHit;\n            stepX += 1.;\n            startY += dy;\n        }\n        \n        else{\n            currentRay = xHit;\n            stepY += 1.;\n            startX += dx;\n        }\n        \n        //we send it to map and check distance\n        dist = map(ro + currentRay);\n        \n        //if hit, record\n        if(dist < 0.){\n            endLength = length(currentRay);\n            hit = 1.;\n            }\n\n        //and send back the height for pixels in this column\n        if(hit == 1.){\n\n            float z = endLength*cos(atan(rd.x,1.7325));\n            height = 2./z;//max hohe / z;\n            return height;            \n        }\n\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)*2./iResolution.xy;\n    vec3 col = vec3(0.);\n    \n    vec2 ro = vec2(0.,0.);\n    \n    //focal point, with a projection plane of -1 to 1\n    //focal point for a fov of 60 degrees\n    //is 1./tan(1.047/2.) where 1 is half projection plane\n    //and 1.047/2. is half 30 degrees.\n    //we cut the fov cone in half, get a right angle triangle\n    // and use tan(a) = opp/adj\n    float fp = 1.7325;\n    \n    vec2 kamX = vec2(floor(uv.x*res)/res, 0.);\n    \n    vec2 rd = kamX + vec2(0.,fp);\n    \n    rd = normalize(rd);\n    \n    float a = iTime;\n    \n    rd *= rot(a);\n    \n    float h = trace(ro,rd);\n    \n    col = mix(vec3(0.3,0.4,0.3), vec3(0.5,0.5,1.), step(0.,uv.y));\n    col = mix(col, vec3(0.)+h, 1.0-step(h, abs(uv.y))); \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfXRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1587, 1587, 1605, 1605, 1651], [1653, 1653, 1672, 1672, 2809], [2812, 2812, 2842, 2842, 5181], [5183, 5183, 5240, 5240, 6069]], "test": "valid"}
{"id": "NljGR1", "name": "Meta CRT - Single Pass", "author": "P_Malin", "description": "A single pass version of Meta CRT : https://www.shadertoy.com/view/4dlyWX", "tags": ["crt"], "likes": 19, "viewed": 657, "published": "Public API", "date": "1626808516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Meta CRT - Single Pass - @P_Malin\n// A single pass version of Meta CRT : https://www.shadertoy.com/view/4dlyWX\n\n// This can be used as a webcam fiter in Memix\n// See github here : https://github.com/pmalin/pmalin-memix-shaders\n\n//#define FIXED_CAMERA_INDEX 2\n\n#define FLIP_V 0\n\n#define USE_MOUSE 0\n\n\n#define PI 3.141592654\n\n\n///////////////////////////\n// Hash Functions\n///////////////////////////\n\n// From: Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10\n\n///////////////////////////\n// Scene\n///////////////////////////\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \nvoid Scene_Union( inout SceneResult a, in SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        a = b;\n    }\n}\n\n    \nvoid Scene_Subtract( inout SceneResult a, in SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        a.fDist = -b.fDist;\n        a.iObjectId = b.iObjectId;\n        a.vUVW = b.vUVW;\n    }\n}\n\nSceneResult Scene_GetDistance( vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).fDist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).fDist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).fDist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).fDist * e.yyy;\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(result.fDist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.fDist > 1.0 )\n        {\n            result.iObjectId = -1;            \n        }    \n        \n        t += result.fDist;        \n\t}\n    \n    result.fDist = t;\n\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )\n{\n    //return 1.0;\n    //return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n\tfloat res = 1.0;\n    float t = fMinDist;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>fLightDist ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.1*float(i)/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 30.0*fOcclusion, 0.0, 1.0 );\n}\n\n///////////////////////////\n// Lighting\n///////////////////////////\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (PI * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n///////////////////////////\n// Rendering\n///////////////////////////\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist );\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec3 vResultColor = vec3(0.0);\n            \n\tSceneResult firstTraceResult;\n    \n    float fStartDist = 0.0f;\n    float fMaxDist = 10.0f;\n    \n    vec3 vRemaining = vec3(1.0);\n    \n\tfor( int iPassIndex=0; iPassIndex < 3; iPassIndex++ )\n    {\n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fMaxDist );\n\n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 vColor = vec3(0);\n        vec3 vReflectAmount = vec3(0);\n        \n\t\tif( traceResult.iObjectId < 0 )\n\t\t{\n            vColor = Env_GetSkyColor( vRayOrigin, vRayDir ).rgb;\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            // calculate reflectance (Fresnel)\n\t\t\tvReflectAmount = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\tvColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectAmount); \n            \n            vec3 vReflectRayOrigin = surfaceInfo.vPos;\n            vec3 vReflectRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n            fStartDist = 0.001 / max(0.0000001,abs(dot( vReflectRayDir, surfaceInfo.vNormal ))); \n\n            vColor += surfaceLighting.vSpecular * vReflectAmount;            \n\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n\t\t\tvColor = FX_Apply( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n            \n            vRayOrigin = vReflectRayOrigin;\n            vRayDir = vReflectRayDir;\n        }\n        \n        vResultColor += vColor * vRemaining;\n        vRemaining *= vReflectAmount;        \n    }\n \n    return vec4( vResultColor, firstTraceResult.fDist );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////\n// Scene Description\n/////////////////////////\n\n// Materials\n\n#define MAT_SKY\t\t \t-1\n#define MAT_DEFAULT \t 0\n#define MAT_SCREEN\t\t 1\n#define MAT_TV_CASING    2\n#define MAT_TV_TRIM      3\n#define MAT_CHROME       4\n\n\nvec3 PulseIntegral( vec3 x, float s1, float s2 )\n{\n    // Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    // V1\n    //if ( x > s2 ) return s2 - s1;\n\t//else if ( x > s1 ) return x - s1;\n\t//return 0.0f; \n    \n    // V2\n    //return clamp( (x - s1), 0.0f, s2 - s1);\n    //return t;\n    \n    return clamp( (x - s1), vec3(0.0f), vec3(s2 - s1));\n}\n\nfloat PulseIntegral( float x, float s1, float s2 )\n{\n    // Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    // V1\n    //if ( x > s2 ) return s2 - s1;\n\t//else if ( x > s1 ) return x - s1;\n\t//return 0.0f; \n    \n    // V2\n    //return clamp( (x - s1), 0.0f, s2 - s1);\n    //return t;\n    \n    return clamp( (x - s1), (0.0f), (s2 - s1));\n}\n\nvec3 Bayer( vec2 vUV, vec2 vBlur )\n{\n    vec3 x = vec3(vUV.x);\n    vec3 y = vec3(vUV.y);           \n\n    x += vec3(0.66, 0.33, 0.0);\n    y += 0.5 * step( fract( x * 0.5 ), vec3(0.5) );\n        \n    //x -= 0.5f;\n    //y -= 0.5f;\n    \n    x = fract( x );\n    y = fract( y );\n    \n    // cell centered at 0.5\n    \n    vec2 vSize = vec2(0.16f, 0.75f);\n    \n    vec2 vMin = 0.5 - vSize * 0.5;\n    vec2 vMax = 0.5 + vSize * 0.5;\n    \n    vec3 vResult= vec3(0.0);\n    \n    vec3 vResultX = (PulseIntegral( x + vBlur.x, vMin.x, vMax.x) - PulseIntegral( x - vBlur.x, vMin.x, vMax.x)) / min( vBlur.x, 1.0);\n    vec3 vResultY = (PulseIntegral(y + vBlur.y, vMin.y, vMax.y) - PulseIntegral(y - vBlur.y, vMin.y, vMax.y))  / min( vBlur.y, 1.0);\n    \n    vResult = min(vResultX,vResultY)  * 5.0;\n        \n    //vResult = vec3(1.0);\n    \n    return vResult;\n}\n\nvec3 GetPixelMatrix( vec2 vUV )\n{\n#if 1\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dU = length( vec2( dx.x, dy.x ) );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dU <= 0.0 || dV <= 0.0 ) return vec3(1.0);\n    return Bayer( vUV, vec2(dU, dV) * 1.0);\n#else\n    return vec3(1.0);\n#endif\n}\n\nfloat Scanline( float y, float fBlur )\n{   \n    float fResult = sin( y * 10.0 ) * 0.45 + 0.55;\n    return mix( fResult, 1.0f, min( 1.0, fBlur ) );\n}\n\n\nfloat GetScanline( vec2 vUV )\n{\n#if 1\n    vUV.y *= 0.25;\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dV <= 0.0 ) return 1.0;\n    return Scanline( vUV.y, dV * 1.3 );\n#else\n    return 1.0;\n#endif\n}\n\n\nvec2 kScreenRsolution = vec2(480.0f, 576.0f);\n\nstruct Interference\n{\n    float noise;\n    float scanLineRandom;\n};\n\nfloat InterferenceHash(float p)\n{\n    float hashScale = 0.1031;\n\n    vec3 p3  = fract(vec3(p, p, p) * hashScale);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat InterferenceSmoothNoise1D( float x )\n{\n    float f0 = floor(x);\n    float fr = fract(x);\n\n    float h0 = InterferenceHash( f0 );\n    float h1 = InterferenceHash( f0 + 1.0 );\n\n    return h1 * fr + h0 * (1.0 - fr);\n}\n\n\nfloat InterferenceNoise( vec2 uv )\n{\n\tfloat displayVerticalLines = 483.0;\n    float scanLine = floor(uv.y * displayVerticalLines); \n    float scanPos = scanLine + uv.x;\n\tfloat timeSeed = fract( iTime * 123.78 );\n    \n    return InterferenceSmoothNoise1D( scanPos * 234.5 + timeSeed * 12345.6 );\n}\n    \nInterference GetInterference( vec2 vUV )\n{\n    Interference interference;\n        \n    interference.noise = InterferenceNoise( vUV );\n    interference.scanLineRandom = InterferenceHash(vUV.y * 100.0 + fract(iTime * 1234.0) * 12345.0);\n    \n    return interference;\n}\n    \nvec3 SampleScreen( vec3 vUVW )\n{   \n    vec3 vAmbientEmissive = vec3(0.1);\n    vec3 vBlackEmissive = vec3(0.02);\n    float fBrightness = 1.75;\n    vec2 vResolution = vec2(480.0f, 576.0f);\n    vec2 vPixelCoord = vUVW.xy * vResolution;\n    \n    vec3 vPixelMatrix = GetPixelMatrix( vPixelCoord );\n    float fScanline = GetScanline( vPixelCoord );\n      \n    vec2 vTextureUV = vUVW.xy;\n    //vec2 vTextureUV = vPixelCoord;\n    vTextureUV = floor(vTextureUV * vResolution * 2.0) / (vResolution * 2.0f);\n \n    \n    Interference interference = GetInterference( vTextureUV );\n\n    float noiseIntensity = 0.1;\n    \n    //vTextureUV.x += (interference.scanLineRandom * 2.0f - 1.0f) * 0.025f * noiseIntensity;\n           \n    vec2 vSampleUV = vTextureUV;\n    #if FLIP_V\n    vSampleUV.y = 1.0 - vSampleUV.y;\n    #endif\n    \n    vec3 vPixelEmissive = textureLod( iChannel0, vSampleUV.xy, 0.0 ).rgb;\n        \n    vPixelEmissive = vPixelEmissive * vPixelEmissive;\n        \n    vPixelEmissive = clamp( vPixelEmissive + (interference.noise - 0.5) * 2.0 * noiseIntensity, 0.0, 1.0 );\n    \n\tvec3 vResult = (vPixelEmissive * fBrightness + vBlackEmissive) * vPixelMatrix * fScanline + vAmbientEmissive;\n    \n    // TODO: feather edge?\n    if( any( greaterThanEqual( vUVW.xy, vec2(1.0) ) ) || any ( lessThan( vUVW.xy, vec2(0.0) ) ) || ( vUVW.z > 0.0 ) )\n    {\n        return vec3(0.0);\n    }\n    \n    return vResult;\n    \n}\n\nfloat Checker(vec2 vUV)\n{\n\treturn step(fract((floor(vUV.x) + floor(vUV.y)) * 0.5), 0.25);\n}\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n    surfaceInfo.vR0 = vec3( 0.02 );\n    surfaceInfo.fSmoothness = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    //return surfaceInfo;\n        \n    if ( traceResult.iObjectId == MAT_DEFAULT )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n        float checker = Checker(traceResult.vUVW.xz * 4.0);\n\t    surfaceInfo.vAlbedo = mix( vec3(.9,.2,.2),vec3(.2,.2,.9), checker );                        \n    \tsurfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);\n        \n    }\n    \n    if ( traceResult.iObjectId == MAT_SCREEN )\n    {\n        surfaceInfo.vAlbedo = vec3(0.02); \n        surfaceInfo.vEmissive = SampleScreen( traceResult.vUVW );        \n    }\n\n    if ( traceResult.iObjectId == MAT_TV_CASING )\n    {\n        surfaceInfo.vAlbedo = vec3(0.5, 0.4, 0.3); \n\t    surfaceInfo.fSmoothness = 0.4;        \n    }\n    \n    if ( traceResult.iObjectId == MAT_TV_TRIM )\n    {\n        surfaceInfo.vAlbedo = vec3(0.03, 0.03, 0.05); \n\t    surfaceInfo.fSmoothness = 0.5;\n    }    \n\n    if ( traceResult.iObjectId == MAT_CHROME )\n    {\n        surfaceInfo.vAlbedo = vec3(0.01, 0.01, 0.01); \n\t    surfaceInfo.fSmoothness = 0.9;\n    \tsurfaceInfo.vR0 = vec3( 0.8 );\n    }    \n \n    return surfaceInfo;\n}\n\n// Scene Description\n\nfloat SmoothMin( float a, float b, float k )\n{\n\t//return min(a,b);\n\t\n\t\n    //float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat UdRoundBox( vec3 p, vec3 b, float r )\n{\n    //vec3 vToFace = abs(p) - b;\n    //vec3 vConstrained = max( vToFace, 0.0 );\n    //return length( vConstrained ) - r;\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nSceneResult Scene_GetCRT( vec3 vScreenDomain, vec2 vScreenWH, float fScreenCurveRadius, float fBevel, float fDepth )\n{\n    SceneResult resultScreen;\n#if 1\n    vec3 vScreenClosest;\n    vScreenClosest.xy = max(abs(vScreenDomain.xy)-vScreenWH,0.0);\n    vec2 vCurveScreenDomain = vScreenDomain.xy;\n    vCurveScreenDomain = clamp( vCurveScreenDomain, -vScreenWH, vScreenWH );\n    float fCurveScreenProjection2 = fScreenCurveRadius * fScreenCurveRadius - vCurveScreenDomain.x * vCurveScreenDomain.x - vCurveScreenDomain.y * vCurveScreenDomain.y;\n    float fCurveScreenProjection = sqrt( fCurveScreenProjection2 ) - fScreenCurveRadius;\n    vScreenClosest.z = vScreenDomain.z - clamp( vScreenDomain.z, -fCurveScreenProjection, fDepth );\n    resultScreen.vUVW.z = vScreenDomain.z + fCurveScreenProjection;        \n    resultScreen.fDist = (length( vScreenClosest ) - fBevel) * 0.95;\n    //resultScreen.fDist = (length( vScreenDomain - vec3(0,0,fScreenCurveRadius)) - fScreenCurveRadius - fBevel);    \n#endif    \n    \n#if 0\n    vec3 vScreenClosest;\n    vScreenClosest.xyz = max(abs(vScreenDomain.xyz)-vec3(vScreenWH, fDepth),0.0);\n    float fRoundDist = length( vScreenClosest.xyz ) - fBevel;\n    float fSphereDist = length( vScreenDomain - vec3(0,0,fScreenCurveRadius) ) - (fScreenCurveRadius + fBevel);    \n    resultScreen.fDist = max(fRoundDist, fSphereDist);\n#endif    \n    \n    resultScreen.vUVW.xy = (vScreenDomain.xy / vScreenWH) * 0.5 + 0.5f;\n\tresultScreen.iObjectId = MAT_SCREEN;\n    return resultScreen;\n}\n\nSceneResult Scene_GetComputer( vec3 vPos )\n{\n    SceneResult resultComputer;\n    resultComputer.vUVW = vPos.xzy;\n\t\n    float fXSectionStart = -0.2;\n    float fXSectionLength = 0.15;\n    float fXSectionT = clamp( (vPos.z - fXSectionStart) / fXSectionLength, 0.0, 1.0);\n    float fXSectionR1 = 0.03;\n    float fXSectionR2 = 0.05;\n    float fXSectionR = mix( fXSectionR1, fXSectionR2, fXSectionT );\n    float fXSectionZ = fXSectionStart + fXSectionT * fXSectionLength;\n    \n    vec2 vXSectionCentre = vec2(fXSectionR, fXSectionZ );\n    vec2 vToPos = vPos.yz - vXSectionCentre;\n    float l = length( vToPos );\n    if ( l > fXSectionR ) l = fXSectionR;\n    vec2 vXSectionClosest = vXSectionCentre + normalize(vToPos) * l;\n    //float fXSectionDist = length( vXSectionClosest ) - fXSectionR;\n    \n    float x = max( abs( vPos.x ) - 0.2f, 0.0 );\n\n    resultComputer.fDist = length( vec3(x, vXSectionClosest - vPos.yz) )-0.01;\n    //resultComputer.fDist = x;\n        \n    resultComputer.iObjectId = MAT_TV_CASING;\n/*\n    vec3 vKeyPos = vPos.xyz - vec3(0,0.125,0);\n    vKeyPos.y -= vKeyPos.z * (fXSectionR2 - fXSectionR1) * 2.0 / fXSectionLength;\n    float fDomainRepeatScale = 0.02;\n    if ( fract(vKeyPos.z * 0.5 / fDomainRepeatScale + 0.25) > 0.5) vKeyPos.x += fDomainRepeatScale * 0.5;\n    vec2 vKeyIndex = round(vKeyPos.xz / fDomainRepeatScale);\n    vKeyIndex.x = clamp( vKeyIndex.x, -8.0, 8.0 );\n    vKeyIndex.y = clamp( vKeyIndex.y, -10.0, -5.0 );\n    //vKeyPos.xz = (fract( vKeyPos.xz / fDomainRepeatScale ) - 0.5) * fDomainRepeatScale;\n    vKeyPos.xz = (vKeyPos.xz - (vKeyIndex) * fDomainRepeatScale);\n    vKeyPos.xz /= 0.7 + vKeyPos.y;\n    SceneResult resultKey;    \n    resultKey.vUVW = vPos.xzy;\n    resultKey.fDist = UdRoundBox( vKeyPos, vec3(0.01), 0.001 );\n    resultKey.iObjectId = MAT_TV_TRIM;\n    Scene_Union( resultComputer, resultKey );\n*/    \n    return resultComputer;\n}\n\nSceneResult Scene_GetDistance( vec3 vPos )\n{\n    SceneResult result;\n    \n\t//result.fDist = vPos.y;\n    float fBenchBevel = 0.01;\n    result.fDist = UdRoundBox( vPos - vec3(0,-0.02-fBenchBevel,0.0), vec3(2.0, 0.02, 1.0), fBenchBevel );\n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_DEFAULT;        \n    \n    vec3 vSetPos = vec3(0.0, 0.0, 0.0);\n    vec3 vScreenPos = vSetPos + vec3(0.0, 0.25, 0.00);\n    \n    //vPos.x = fract( vPos.x - 0.5) - 0.5;\n    \n    vec2 vScreenWH = vec2(4.0, 3.0) / 25.0;\n\n    SceneResult resultSet;\n    resultSet.vUVW = vPos.xzy;\n\tresultSet.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.01,0.2), vec3(.21, 0.175, 0.18), 0.01 );\n    resultSet.iObjectId = MAT_TV_CASING;\n    Scene_Union( result, resultSet );\n\n    SceneResult resultSetRecess;\n    resultSetRecess.vUVW = vPos.xzy;\n    resultSetRecess.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.0, -0.05), vec3(vScreenWH + 0.01, 0.05) + 0.005, 0.015 );\n    resultSetRecess.iObjectId = MAT_TV_TRIM;\n\tScene_Subtract( result, resultSetRecess );\n    \n    SceneResult resultSetBase;\n    resultSetBase.vUVW = vPos.xzy;\n    float fBaseBevel = 0.03;\n\tresultSetBase.fDist = UdRoundBox( vPos - vSetPos - vec3(0.0,0.04,0.22), vec3(0.2, 0.04, 0.17) - fBaseBevel, fBaseBevel );\n    resultSetBase.iObjectId = MAT_TV_CASING;\n    Scene_Union( result, resultSetBase );\n\n\tSceneResult resultScreen = Scene_GetCRT( vPos - vScreenPos, vScreenWH, 0.75f, 0.02f, 0.1f );\n    Scene_Union( result, resultScreen );    \n    \n    //SceneResult resultComputer = Scene_GetComputer( vPos - vec3(0.0, 0.0, -0.1) );\n    //Scene_Union( result, resultComputer );\n\n    SceneResult resultSphere;\n    resultSet.vUVW = vPos.xzy;\n\tresultSet.fDist = length(vPos - vec3(0.35,0.075,-0.1)) - 0.075;\n    resultSet.iObjectId = MAT_CHROME;\n    Scene_Union( result, resultSet );    \n    \n    return result;\n}\n\n\n\n// Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(0.3, 0.4, -0.5));\nvec3 g_vSunColor = vec3(1, 0.95, 0.8) * 3.0;\nvec3 g_vAmbientColor = vec3(0.8, 0.8, 0.8) * 1.0;\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \n    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(1.4, 2.0, 0.8), vec3(1,1,1) * 0.2 );\n    \n    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    // AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n// Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n\n#if 0\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vResult.rgb = vEnvMap;\n#endif    \n    \n#if 0\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vEnvMap = vEnvMap * vEnvMap;\n    float kEnvmapExposure = 0.999;\n    vResult.rgb = -log2(1.0 - vEnvMap * kEnvmapExposure);\n\n#endif\n    \n    vResult.rgb = mix( vec3(0.3,0.8,0.9),vec3(0.3,0.4,0.9), vViewDir.y );\n    \n    // Sun\n    float NdotV = dot( g_vSunDir, vViewDir );\n    vResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 100.0;\n\n    return vResult;\t\n}\n\nfloat Env_GetFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{    \n\tfloat kFogDensity = 0.00001;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor(const in vec3 vDir)\n{    \n\treturn vec3(0.2, 0.5, 0.6) * 2.0;\t\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{\n    //return vColor;\n    vec3 vResult = vColor;\n    \n    \n\tfloat fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\t\n\t//Env_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);    \n    vResult = mix( vFogColor, vResult, fFogFactor );\n\n    return vResult;\t    \n}\n\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{    \n    return vColor;\n}\n\n\nvec4 MainCommon( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec4 vColorLinAndDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAndDepth.rgb = max( vColorLinAndDepth.rgb, vec3(0.0) );\n    \n    vec4 vFragColor = vColorLinAndDepth;\n    \n    float fExposure = 2.0f;\n    \n    vFragColor.rgb *= fExposure;\n    \n    vFragColor.a = vColorLinAndDepth.w;\n    \n    return vFragColor;\n}\n\n///////////////////////////\n// Camera\n///////////////////////////\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n};\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, vec2 res )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= res.x / res.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( vec2 vUV, vec2 res, CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, res );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( vec2 vWindow, vec2 res )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= res.y / res.x;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n\nCameraState GetCameraPosition( int index )\n{\n    CameraState cam;\n\n    vec3 vFocus = vec3(0,0.25,-0.012);   \n    \n    if ( index > 9 )\n    {\n    \tindex = int(hash11(float(index) / 10.234) * 100.0);\n    \tindex = index % 10;\n    }\n\n    #ifdef FIXED_CAMERA_INDEX\n    index=FIXED_CAMERA_INDEX; // Force a camera position\n    #endif\n    \n    if ( index == 0 )\n    {\n        cam.vPos = vec3(-0.1,0.24,-0.08);\n        cam.vTarget = vec3(0.15,0.25,0.1);\n        cam.fFov = 10.0;\n    }\n    if ( index == 1 )\n    {\n        cam.vPos = vec3(0.01,0.25,-0.8);\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.fFov = 10.0;\n    }\n    if ( index == 2 )\n    {\n        cam.vPos = vec3(-0.4,0.3,-1.0);\n        cam.vTarget = vec3(0.25,0.18,0.5);\n        cam.fFov = 10.0;\n    }\n    if ( index == 3 )\n    {\n        cam.vPos = vec3(-0.8,0.5,-1.5);\n        cam.vTarget = vec3(0.2,0.1,0.5);\n        cam.fFov = 8.0;\n    }\n    if ( index == 4 )\n    {\n        cam.vPos = vec3(0.5,0.3,-0.5);\n        cam.vTarget = vec3(-0.4,0.1,0.5);\n        cam.fFov = 16.0;\n    }\n    if ( index == 5 )\n    {\n        cam.vPos = vec3(-0.244,0.334,-0.0928);\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.fFov = 20.0;\n    }\n    if ( index == 6 )\n    {\n        cam.vPos = vec3(0.0,0.1,-0.5);\n        cam.vTarget = vec3(0.08,0.2,-0.1);\n        vFocus = cam.vTarget; \n        cam.fFov = 20.0;\n    }\n    if ( index == 7 )\n    {\n        cam.vPos = vec3(-0.01,0.01,-0.25);\n        cam.vTarget = vec3(0.01,0.27,0.1);\n        vFocus = cam.vTarget; \n        cam.fFov = 23.0;\n    }\n    if ( index == 8 )\n    {\n        cam.vPos = vec3(-0.23,0.3,-0.05);\n        cam.vTarget = vec3(0.1,0.2,0.1);\n        cam.fFov = 15.0;\n    }\n    if ( index == 9 )\n    {\n        cam.vPos = vec3(0.4,0.2,-0.2);\n        cam.vTarget = vec3(-0.1,0.25,0.1);\n        cam.fFov = 12.0;\n    }\n    \n    cam.fPlaneInFocus = length( vFocus - cam.vPos);\n    cam.vJitter = vec2(0.0);        \n    \n    return cam;\n}\n\n\nvec3 Tonemap( vec3 x )\n{\n#if 0 \n    \n    vec3 luminanceCoeffsBT709 = vec3( 0.2126f, 0.7152f, 0.0722f );\n    float f = dot( x, luminanceCoeffsBT709 );\n    x /= f;        \n    f = 1.0f - exp(-f);    \n    x *= f;    \n    x = mix( x, vec3(f), f*f );\n    \n    return x;\n#else       \n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );    \n#endif    \n}\n\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy / iResolution.xy; \n\n    CameraState cam;\n    \n    {\n    \tCameraState camA;\n    \tCameraState camB;\n    \n        float fSeqTime = iTime;\n        float fSequenceSegLength = 5.0;\n        float fSeqIndex = floor(fSeqTime / fSequenceSegLength);\n        float fSeqPos = fract(fSeqTime / fSequenceSegLength);\n        int iIndex = int(fSeqIndex);\n\t\tint iIndexNext = int(fSeqIndex) + 1;\n        camA = GetCameraPosition(iIndex);\n        camB = GetCameraPosition(iIndexNext);\n        \n        float t = smoothstep(0.3, 1.0, fSeqPos);\n        cam.vPos = mix(camA.vPos, camB.vPos, t );\n        cam.vTarget = mix(camA.vTarget, camB.vTarget, t );\n        cam.fFov = mix(camA.fFov, camB.fFov, t );\n        cam.fPlaneInFocus = mix(camA.fPlaneInFocus, camB.fPlaneInFocus, t );\n    }\n    \n#if USE_MOUSE    \n    if ( iMouse.z > 0.0 )\n    {\n        float fDist = 0.01 + 3.0 * (iMouse.y / iResolution.y);\n\n        float fAngle = (iMouse.x / iResolution.x) * radians(360.0);\n    \t//float fElevation = (iMouse.y / iResolution.y) * radians(90.0);\n    \tfloat fElevation = 0.15f * radians(90.0);    \n\n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 20.0 / (1.0 + fDist * 0.5);\n    \tvec3 vFocus = vec3(0,0.25,-0.012);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n#endif    \n    \n#if 0\n    {\n        float fDist = 0.5;\n\n        float fAngle = 0.6 * PI * 2.0f;\n        float fElevation = 0.2;\n        \n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0.05,0.25,0.1);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 22.0;\n    \tvec3 vFocus = vec3(0,0.25,-0.012);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n#endif\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif\n    \n            \n    vec3 vRayOrigin, vRayDir;\n    vec2 vJitterUV = vUV + cam.vJitter / iResolution.xy;\n    Cam_GetCameraRay( vJitterUV, iResolution.xy, cam, vRayOrigin, vRayDir );\n \n    float fHitDist = 0.0f;\n    vFragColor = MainCommon( vRayOrigin, vRayDir );\n    \n    float fShade = GetVignetting( vUV, 0.7, 2.0, 1.0 );\n    \n    vFragColor.rgb *= fShade;\n    \n    vFragColor.rgb = Tonemap( vFragColor.rgb );        \n}\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[909, 1019, 1042, 1042, 1160], [1162, 1181, 1203, 1203, 1317], [1319, 1339, 1361, 1361, 1465], [1467, 1486, 1509, 1509, 1617], [1840, 1840, 1899, 1899, 1957], [1964, 1964, 2026, 2026, 2158], [5042, 5042, 5082, 5082, 5132], [6891, 6891, 6966, 6966, 7106], [8299, 8299, 8361, 8361, 10285], [10634, 10634, 10684, 10952, 11015], [11017, 11017, 11069, 11337, 11392], [11394, 11394, 11430, 11430, 12235], [12237, 12237, 12270, 12270, 12552], [12554, 12554, 12594, 12594, 12702], [12705, 12705, 12736, 12736, 12963], [13082, 13082, 13115, 13115, 13272], [13275, 13275, 13319, 13319, 13495], [13498, 13498, 13534, 13534, 13794], [13800, 13800, 13842, 13842, 14066], [14072, 14072, 14104, 14104, 15473], [15475, 15475, 15500, 15500, 15566], [17199, 17199, 17245, 17291, 17380], [17382, 17382, 17427, 17548, 17590], [17592, 17592, 17710, 17710, 19098], [19100, 19100, 19144, 19144, 20983], [20985, 20985, 21029, 21029, 22832], [23681, 23681, 23747, 23747, 24383], [25247, 25247, 25297, 25297, 25635], [25821, 25821, 25890, 25890, 26122], [26124, 26124, 26175, 26175, 26258], [26260, 26260, 26361, 26361, 26593], [26595, 26595, 26652, 26652, 26767], [27136, 27136, 27180, 27180, 29067], [29070, 29070, 29094, 29094, 29532], [29841, 29841, 29900, 29900, 32338]], "test": "error"}
{"id": "NljXRz", "name": "Menger Sponge 4517489750987401", "author": "jy483752", "description": "My attempt at a Menger Sponge, probably not well optimized, mainly just testing my skill on 3d shader", "tags": ["3d"], "likes": 1, "viewed": 44, "published": "Public", "date": "1626977237", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I learnt ray marching from Art of Code Youtube channel, go check him out!\n\n#define MAX_STEPS 40\n#define MAX_DIST 40.\n#define SURF_DIST .01\n#define LAYER 2\n//feel free to play with layer, tho for me just 3 is enough to lag\n//I didn't optimize this\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 pos, vec3 b )\n{\n  vec3 q = abs(p-pos) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//not used, this is my attempt at a basic box\nfloat MysdBox(vec3 p, vec3 pos, vec3 s){\n    if(length(p-pos)<length(s)){\n        vec3 l = abs(p-pos);\n        return -min(s.x-l.x, min(s.y-l.y, s.z-l.z));\n    }\n    else{\n        return length(max(abs(p-pos)-s, 0.));\n    }\n}\n//------------\n\n//SPONGE\nfloat GetDist(vec3 p){\n    //the main cube\n    float d = sdBox(p, vec3(0.), vec3(1.));\n    \n    //subtracting rods\n    for(int i=0; i<LAYER; i++){\n        float p3 = pow(3., float(i)); //1, 3, 9, 27\n        vec2 e = vec2(2., 1./(p3*3.)); //for the first hole its 1/3 on the two small sides\n                                       //for the second its 1/9\n                                       //the x is at 2 which is bigger than the main cube\n        for(float j=-floor(p3/2.); j<ceil(p3/2.); j++){\n            for(float k=-floor(p3/2.); k<ceil(p3/2.); k++){\n                //-floor(p3/2.); ceil(p3/2.); is basically just for 1, [0]\n                //for 2, [-1, 0, 1], for 3, [-4 ... 4]\n                float g = 2./p3;//this is the distance between one hole center to the next hole center\n                d = max(d, -sdBox(p, vec3(0., j*g, k*g), e.xyy)); //max(shape1, -shape2) is shape subtraction\n                d = max(d, -sdBox(p, vec3(j*g, 0., k*g), e.yxy)); //do the same thing for all three directions\n                d = max(d, -sdBox(p, vec3(j*g, k*g, 0.), e.yyx));\n            }\n        }\n        \n    }\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(2., 10., 6.);\n    \n    vec3 l = normalize(lightPos-p);\n    \n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif*=0.1;\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 ro = vec3(1.);\n    ro.xz = vec2(cos(iTime), sin(iTime))*5.;\n    ro.y = sin(20.+iTime/4.)*5.;\n    \n    \n    vec3 lookat = vec3(0.);\n    \n    float zoom = 1.5;\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    vec3 rd = normalize(i-ro);\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    \n    float dif = GetLight(p);\n    if(d<=MAX_DIST){\n        dif += 0.2;\n    }\n    \n    vec3 col = vec3(dif);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 324, 365, 365, 456], [458, 504, 544, 544, 729], [746, 755, 777, 797, 1894], [1896, 1896, 1929, 1929, 2146], [2148, 2148, 2171, 2171, 2367], [2369, 2369, 2392, 2392, 2658], [2661, 2661, 2718, 2718, 3421]], "test": "valid"}
{"id": "NljXzh", "name": "shaderjam - DJ-Shader party", "author": "Exca", "description": "Jamming for the dj party hosted by Monsieur Soleil. \nGround looks a bit off due to no perlin noise texture.", "tags": ["shaderjam"], "likes": 2, "viewed": 66, "published": "Public", "date": "1627079826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fft = 0.0;\nfloat fftS = 0.0;\nfloat fftI = 0.0;\nfloat beat = 0.0;\nfloat beatStep = 0.0;\nvec3 cam = vec3(0.0);\nvec3 camdir = vec3(0.0);\nfloat bm=0.0;\n\nvec3 rotate( vec3 p, float x, float y, float z)\n{\n  mat3 rotx = mat3( 1.0, 0.0, 0.0, 0.0, cos(x), -sin(x), 0.0, sin(x), cos(x));\n  mat3 roty = mat3( cos(y), 0.0, sin(y), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y));\n  mat3 rotz = mat3( cos(z), -sin(z), 0.0, sin(z), cos(z), 0.0, 0.0, 0.0, 1.0);\n  return rotx*roty*rotz*p;\n}\n\n\nvec3 getcam(vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize(target-cam);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross(forward, right));\n  \n  return normalize( forward*fov + right *uv.x + up*uv.y);\n}\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat roundcube( vec3 p, vec3 b, float r)\n{\n  vec3 d = abs(p)-b;\n  return min(max(d.x, max(d.y, d.z)), 0.0)+length(max(d,0.0))-r;\n}\n\n\nfloat ground( vec3 p, float h)\n{\n  return p.y - h;\n}\n\nfloat U(float a, float b){\n  return min(a,b);\n}\n\nvec3 map( vec3 p)\n{\n  \n  vec3 cp = cam+camdir*5.0;\n    \n  vec3 rp = rotate(p-cp,fftI*3.,fftI*1.0,0.0);\n  rp*= 1.0+beatStep*smoothstep(0.0,0.015,fftS);\n  float s = 9999.0;\n  if(bm< 4.0)\n  {\n  s = roundcube(rotate(rp, smoothstep(0.0, 0.25,beatStep)*3.14,0.0, 0.0),vec3(1.0),0.2);\n  s = U(s,roundcube(rp-vec3(2.5, 0.0, 0.0),vec3(0.5),0.2));\n  s = U(s,roundcube(rp+vec3(2.5, 0.0, 0.0),vec3(0.5),0.2));\n  s = U(s,roundcube(rp-vec3(0.0, 0.0, 2.5),vec3(0.5),0.2));\n  s = U(s,roundcube(rp+vec3(0.0, 0.0, 2.5),vec3(0.5),0.2));\n  }\n  else\n  {\n  s = sphere(rotate(rp, smoothstep(0.0, 0.25,beatStep)*3.14,0.0, 0.0),1.5);\n  s = U(s,sphere(rp-vec3(2.5, 0.0, 0.0),0.5+fftS*5.0));\n  s = U(s,sphere(rp+vec3(2.5, 0.0, 0.0),0.5+fftS*5.0));\n  s = U(s,sphere(rp-vec3(0.0, 0.0, 2.5),0.5+fftS*5.0));\n  s = U(s,sphere(rp+vec3(0.0, 0.0, 2.5),0.5+fftS*5.0));  \n  }\n  \n  p.z-=sin(fftI*0.35)*50.0;\n  p.x-=cos(-fftI*0.15)*50.0;\n  \n  \n  float h = texture( iChannel0, p.xz*0.025+fftI*0.1).r*2.0+texture( iChannel0,0.2*fftI+ p.xz*0.025+0.78).r*0.75;\n  float hLrg = smoothstep( 0.1, 0.5, texture( iChannel0, p.xz*0.01).r)*0.25;\n  float hMnt = smoothstep(0.45, 0.95,texture( iChannel0, p.xz*0.01).r)*255.*fftS*10.;\n  \n  h += hLrg + hMnt;\n  h*=0.5;\n  float ho = h;\n  h = max(0.6, h);\n  \n  float g = ground(p, h);\n  return vec3(U(s,g),h,ho);\n}\n\nvec3 march( vec3 cam, vec3 rd, out vec3 p, out float t, out int steps) \n{\n  t = 1.5;\n  for(int i = 0; i < 100; i++)\n  {\n    steps = i;\n    p = cam + rd*t;\n    vec3 r = map(p);\n    t += r.x*0.75;\n    if(r.x < 0.01) return r;\n    if(t > 50.0) {\n      t = 50.0;\n      return vec3(-1.0);\n    }\n  }\n  return vec3(-1.0);\n}\n\nvec3 normal( vec3 p )\n{\n  vec3 c = map(p);\n  vec2 e = vec2(0.1, 0.0);\n  return normalize(vec3(\n    map(p+e.xyy).x,\n    map(p+e.yxy).x,\n    map(p+e.yyx).x\n  )-c.x);\n}\n\nfloat light( vec3 p, vec3 l, vec3 n)\n{\n  return max(0.0, dot( n, normalize(l-p)));\n}\n\nfloat time;\n\nvec3 calc(vec2 uv )\n{\n  vec3 bgCol = vec3( 0.5, 0.5, 1.05);\n  vec3 sun = vec3( 10,10,10);\n  \n\tvec3 col = vec3(0.0);\n  \n  time = iTime*0.25;\n  \n  cam = vec3( sin(time) ,12.0+cos(time)*5.5,2);\n  vec3 target = vec3(0,cam.y-(3.25+sin(time)*3.25),0);\n  float fov = 0.6+sin(time)*0.3;\n  vec3 rd = getcam(cam, target, uv, fov);\n  \n  camdir = normalize(target - cam);\n  \n  vec3 p = cam;\n  float t = 0.0;\n  int steps = 0;\n  vec3 mat = march( cam, rd, p, t, steps);\n  \n  vec3 n = normal(p);\n  bgCol *=0.5+ min(0.05,fftS) * abs( smoothstep(0.5,1.0,sin( t*1.2+fftI*50. )))*150.8*min(1.0,p.y) * smoothstep(80., 30., t)*0.8;\n  \n  if(mat.y < -0.5){\n    //bg\n    col = bgCol;\n  }\n  else if(mat.y < 50.5)\n  {\n    \n    float id = floor(p.x)+floor(p.z);\n    \n    if(mat.z < 0.6)\n    {\n      col =vec3(0.2, 0.25,0.85)*(mat.z);\n    }\n    else if( mat.z < 1.2)\n    {\n      col = mix( vec3( 0.2, 0.4,0.3), vec3( 0.4,0.4,0.3), (mat.z-0.6)/0.6);\n    }\n    else\n      col = mix( vec3( 0.4,0.4,0.3), vec3(1.0), (mat.z-1.2)/0.6);\n    \n    if(t < 1.0)\n    {\n      col = mix( vec3( 1.0, 0.0, 0.0)*col, col, smoothstep(3.0, 5.5, t));\n    }\n    \n    col = col*light(p, sun, n);\n    \n  }\n  \n  col =mix(col, bgCol*0.4, smoothstep( 5.0, 50.0, t));\n  \n  col*=2.0;\n  return col;\n}\nvec2 barrel( vec2 uv, float k)\n{\n  float rd = length(uv);\n  float ru = rd*(1.0+k*rd*rd);\n  uv/=rd;\n  uv*=ru;\n  return uv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 ouv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  fft = texture(iChannel1, vec2(ouv.x, 0.0)).r/255.;\n  fftS = texture(iChannel1,vec2(0.2,0.0)).r/125.;\n  fftI = texture(iChannel1, vec2(0.1,0.0)).r/155.+iTime;\n  beat = floor(iTime*1.43);\n  beatStep = fract( iTime*2.0);\n  bm = mod(beat/4.0, 8.0);\n  \n  \n  vec3 col = calc(uv);\n  \n  col += calc( barrel(uv*1.2,10.5))*min(1.0,smoothstep(0.0, 0.05,fftS)*2.0);\n  col += calc( barrel(uv*1.5,-fftS*1024.0))*min(1.0,smoothstep(0.0, 0.02,fftS)*5.0);\n  \n  \n  \n  col*=0.95;\n  col=mix(col, smoothstep(vec3(0.0), vec3(1.0),col), beatStep);\n  //col += (previousR+previousRR)*smoothstep(0.0, 1.0,15.*fftS)*0.25;\n  \n  col = clamp( col, vec3(0.0), vec3(1.0));\n  \n  if(bm < 4.0)\n  {\n  col = vec3(1.0)-col;\n  col.rgb = col.gbr;\n  }\n  \n  \n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 204, 204, 470], [473, 473, 529, 529, 733], [735, 735, 766, 766, 790], [792, 792, 835, 835, 923], [926, 926, 958, 958, 978], [980, 980, 1006, 1006, 1027], [1029, 1029, 1048, 1048, 2336], [2338, 2338, 2411, 2411, 2654], [2656, 2656, 2679, 2679, 2821], [2823, 2823, 2861, 2861, 2907], [2922, 2922, 2943, 2943, 4165], [4166, 4166, 4198, 4198, 4289], [4292, 4292, 4349, 4349, 5251]], "test": "error"}
{"id": "NllXD8", "name": "Moded trip rotation", "author": "LuckyLuk_CZ", "description": "Moded space gif by Martijn", "tags": ["circle", "trip"], "likes": 4, "viewed": 102, "published": "Public", "date": "1625596262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//mod by LSC\n\n// Space Gif by Martijn Steinrucken aka BigWings - 2019\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Original idea from:\n// https://boingboing.net/2018/12/20/bend-your-spacetime-continuum.html\n//\n// To see how this was done, check out this tutorial:\n// https://youtu.be/cQXAbndD5CQ\n//\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n\tfloat a=iTime*.5;\n    float s=sin(a);\n    float c=cos(a);\n    uv *= mat2(c, -s, s, c);\n    \n    float zoomer=sin(iTime*0.25)*15.+15.;\n    uv *= zoomer;\n    \n    vec2 gv = fract(uv)-.5; \n\tvec2 id = floor(uv);\n    \n\tfloat m = 0.;\n    float t;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            vec2 offs = vec2(x, y);\n            \n            t = -iTime+length(id-offs)*.2;\n            float r = mix(.4, 1.5, sin(t)*.5+.5);\n    \t\tfloat c = smoothstep(r, r*.9, length(gv+offs));\n    \t\tm = m*(1.-c) + c*(1.-m);\n        }\n    }\n\n    fragColor = vec4(m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllXD8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[400, 400, 457, 457, 1104]], "test": "valid"}
{"id": "NllXDn", "name": "a candle", "author": "j0", "description": "A simple stylized 2D candle", "tags": ["fire"], "likes": 11, "viewed": 93, "published": "Public", "date": "1625488867", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n\n\n\n\nvec3 glow(vec3 original, vec3 col, vec2 uv, vec2 pos, float radius){\n    return original + col * ((1.0-length((uv - pos)/radius)));\n}\n\nvec3 rect(vec3 original, vec3 col, vec2 uv, vec2 pos, vec2 size){\n    pos -= size * 0.5;\n    vec2 r = vec2(step(pos.x, uv.x), step(pos.y, uv.y));\n    r *= vec2(step(uv.x, pos.x + size.x), step(uv.y, pos.y + size.y));\n    return original + col * (r.x * r.y);\n}\n\nvec3 fire(vec3 col, vec2 uv, float t){\n    uv = (uv - vec2(0.5, 0.61)) * 8.0 + 0.5;\n    uv.x += snoise(vec2(uv.y * 2.0, t)) * 0.08;\n    uv.x = (uv.x - 0.5) * clamp(uv.y, 0.1, 1.0) * 18.0 + 0.5;\n    t *= 2.0;\n    float f = mix(0.6, 1.0, snoise(vec3(uv * 50.0 - vec2(0.0, t * 30.0), t * 5.0)));\n    f *= mix(0.6, 1.0, snoise(vec3(uv * 10.0 - vec2(0.0, t * 5.0), t * 2.0)));\n    f *= mix(0.6, 1.0, snoise(vec3(uv * 9.0 - vec2(0.0, t * 3.0), t * 1.5)));\n    if(f < 0.2) f = 0.0; else f = 1.0;\n    f *= clamp(1.0 - length((uv - vec2(0.5, 0.15)) * 3.0), 0.0, 1.0) * 5.0;\n    f *= pow(clamp(1.0 - length((uv - 0.5) * vec2(5.0, 1.5)), 0.0, 1.0), 0.5);\n    f *= clamp(0.3 - uv.y, 0.0, 1.0);\n    return col * f;\n}\n\nvec3 smoke(vec3 col, vec2 uv, float iTime){\n    return mix(col, rect(col, vec3(2.0), vec2(uv.x + snoise(vec2(uv.y * 10.0 - iTime, iTime)) * 0.005, uv.y), vec2(0.5, 1.02), vec2(0.005, 1.0)), clamp(uv.y - 0.61, 0.0, 1.0));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = ((uv.y - 0.5) / iResolution.x * iResolution.y) + 0.5;\n    \n    float intensity = snoise(vec2(iTime * 1.0, 0.0));\n    intensity += snoise(vec2(iTime * 5.0, 1.0)) * 0.2;\n    \n    vec3 col = glow(vec3(mix(0.0, 0.1, intensity)), vec3(0.3), uv, vec2(0.5, 0.5), 1.0);\n    col = rect(col, vec3(0.5, 0.55, 0.4), vec2(uv.x + sin(uv.y * 50.0) * 0.001, uv.y + uv.x * 0.07), vec2(0.5, 0.04), vec2(0.06, 1.03));\n    col = glow(col, vec3(2.0, 1.0, 0.5) * 0.6, uv, vec2(0.5, 0.55), mix(0.1, 0.11, intensity));\n    col = rect(col, vec3(-0.3), vec2(uv.x + sin(iTime * -10.0 + uv.y * 100.0) * 0.0005, uv.y), vec2(0.5, 0.53), vec2(0.003, 0.03));\n    \n    col += fire(vec3(1.0, 0.4, 0.4), uv, iTime);\n    col += fire(vec3(1.0, 1.0, 1.0), uv, iTime * 1.3);\n    col = smoke(col, uv, iTime);\n    col = smoke(col, uv, iTime + 1872.298);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllXDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 25, 47, 47, 86], [88, 88, 109, 109, 929], [931, 985, 1006, 1006, 1043], [1044, 1044, 1071, 1071, 1119], [1121, 1121, 1142, 1142, 2978], [2985, 2985, 3053, 3053, 3118], [3120, 3120, 3185, 3185, 3379], [3381, 3381, 3419, 3419, 4084], [4086, 4086, 4129, 4129, 4308], [4311, 4311, 4366, 4366, 5269]], "test": "valid"}
{"id": "NlS3zc", "name": "wavefunction 1", "author": "smjty", "description": "www", "tags": ["wave1"], "likes": 6, "viewed": 63, "published": "Public", "date": "1627294587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define N 5.\n\nvec2 rot(vec2 p, float t){\n    return vec2(p.x*cos(t) + p.y*sin(t) , p.y*cos(t) - p.x*sin(t));\n}\n\nfloat saw(float x){\n    float res = 0.;\n    for(float k=1.;k<4.;k+=1.){\n        res += (-2.*mod(k,2.)+1.) * sin(2.*PI*k*x)/k;\n    \n    }\n    return pow(clamp(res/1.5,0.,1.),2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy  - iResolution.xy/2.0)/iResolution.x*500.0;\n    \n    p = rot(p , PI/2.);\n    vec2 pold = p;\n\n    float col = sign(p.x)\n          ,R = 50.\n          ,lambda = 2.*R*sin(PI/N)/2.\n          ,d = R*cos(PI/N)\n          ,k;\n\n    bool last = false;\n    vec2 dd = rot(vec2(1.,0.) , PI/N); \n\n    for(k=0.;k<2.*N; k+=1.){\n         vec2 dds = rot(dd , 2.*PI/N*k);\n         if(dot(dds,p)>= d){last=true;}\n         else if(last)break;    \n    }\n\n    float ret1 = 0.; \n\n    if(last){\n        vec2 np = rot(vec2(R,0.) , 2.*PI/N*k);\n        float r = length(p-np)/0.5;\n        ret1 = 0.5 + 0.5*cos(r/lambda*4.*PI  - iTime*2.*PI);\n    }\n\n    fragColor = vec4(vec3(ret1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 62, 62, 132], [134, 134, 153, 153, 313], [315, 315, 372, 372, 1059]], "test": "valid"}
{"id": "NlsSRM", "name": "clock fork new arrows", "author": "4eckme", "description": "new arrows", "tags": ["2d", "time", "clock", "rgb", "date", "calendar"], "likes": 1, "viewed": 47, "published": "Public", "date": "1625346994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 jDate; const float M_PI = 3.14159265358979323846264338327950288;\nvec2 rotate(vec2 xy, float a) {\n  return vec2(xy.x*cos(a)-xy.y*sin(a),xy.x*sin(a)+xy.y*cos(a));\n}\n\n// day of week fuction\nfloat day() {\n    float jDatex=jDate.x;\n    float y366 = floor((jDatex-0.0)/400.0)+floor((jDatex-0.0)/4.0)-floor((jDatex-0.0)/100.0);\n    float y365 = jDatex-y366;\n    y366*=366.0; y365*=365.0;\n    float d=y366+y365;\n    if (jDate.y >= 0.0) d+=0.0;\n    if (jDate.y >= 1.0) d+=31.0;\n    if (jDate.y >= 2.0 && (int(mod(jDatex, 4.0))==0&&(int(mod(jDatex, 100.0))!=0||int(mod(jDatex, 400.0))==0))) d+=29.0;\n    if (jDate.y >= 2.0 && (int(mod(jDatex, 4.0))!=0||int(mod(jDatex, 100.0))==0&&int(mod(jDatex, 400.0))!=0)) d+=28.0;\n    if (jDate.y >= 3.0) d+=31.0;\n    if (jDate.y >= 4.0) d+=30.0;\n    if (jDate.y >= 5.0) d+=31.0;\n    if (jDate.y >= 6.0) d+=30.0;\n    if (jDate.y >= 7.0) d+=31.0;\n    if (jDate.y >= 8.0) d+=31.0;\n    if (jDate.y >= 9.0) d+=30.0;\n    if (jDate.y >= 10.0) d+=31.0;\n    if (jDate.y >= 11.0) d+=30.0;\n    return mod(d+jDate.z-2.0, 7.0)+1.0;\n}\n\n//scene function\nvec4 bg(vec2 fragCoord) {\n    vec2 coord = (fragCoord)*4.0;\n   \tfloat t = (iTime);\n    float x = float(coord.x)+64.0*sin((coord.x+coord.y)/60.0);\n    float y = float(coord.y)+64.0*cos((coord.x-coord.y)/60.0);\n    float r = float(x*x*t + y*y*t);\n    vec4 fragColor = vec4(\n        cos(sqrt(r)/x),\n        cos(sqrt(r)/sqrt(t)),\n        cos(sqrt(r)/y),\n        sin(y/x)\n    );\n    fragColor.x+=(tan((degrees(atan(x, y))*1.0-t*2.0)))/4.0;\n    fragColor.y+=(tan((degrees(atan(x, y))*1.0-t*2.0)))/4.0;\n    fragColor.z+=(tan((degrees(atan(x, y))*1.0-t*2.0)))/4.0;\n    return fragColor;\n}\n\n//clock function\nvec4 f(float x, float y, float t) {float N=iResolution.y/360.0;//clock zoom \n    //float jDatem = floor((13800000000.0-2021.0+jDate.x)/230000000.0);\n    jDate.x = mod(jDate.x, 1000000.0);//do a barrel roll after 1 million years of work \n    float jDatex = mod(jDate.x,10000.0);//4 last digits of year\n    float jDate1 = 0.0; float jDate2 = 0.0;// 4 digits year\n    if (jDate.x>99999.0) {//if year is 6 digits\n        jDate2 = floor(jDate.x/100000.0);\n        jDate1 = mod(jDate.x,100000.0)/10000.0;\n    }\n    else if (jDate.x>9999.0) {//if year is 5 digits\n        jDate2 = floor(jDate.x/100000.0);\n        jDate1 = floor(jDate.x/10000.0);\n    }\n    //jDate.x=123456.0;// 12422311\n    float angle=atan(-x, -y);\n    vec2 C=vec2(-x,-y);\n    \n    \n    \n    /*\n    //galactic years controller\n    vec4 galacticTime = vec4(0.9, 0.2, 0.2, 1.0);\n    float a12=mod(jDatem, 5.0);float b12=floor(jDatem/5.0);\n    float a11=mod(b12, 5.0);float b11=floor(b12/5.0);\n    float a10=mod(b11, 5.0);float b10=floor(b11/5.0);\n    float a9=mod(b10, 5.0);float b9=floor(b10/5.0);\n    float a8=mod(b9, 5.0);float b8=floor(b9/5.0);\n    float a7=mod(b8, 5.0);float b7=floor(b8/5.0);\n    float a6=mod(b7, 5.0);float b6=floor(b7/5.0);\n    float a5=mod(b6, 5.0);float b5=floor(b6/5.0);\n    float a4=mod(b5, 5.0);float b4=floor(b5/5.0);\n    float a3=mod(b4, 5.0);float b3=floor(b4/5.0);\n    float a2=mod(b3, 5.0);float b2=floor(b3/5.0);\n    float a1=mod(b2, 5.0);float b1=floor(b2/5.0);\n    //if (int(a1)==0) return galacticTime;\n    \n    //12 red arcs to 12 digits of fivefold galactic years (max value 244140624 yaers)\n    if ((x*x+y*y)<=146.0*146.0*N&&(x*x+y*y)>143.0*143.0*N) {//140-146 radius\n      //if (degrees(angle)>-180.0&&degrees(angle)<=-180.0+6.0*(floor(jDate2)))\n       //   return galacticTime;\n       if (degrees(angle)>-180.0&&degrees(angle)<=-180.0+6.0*(a1))\n          return galacticTime;\n       if (degrees(angle)>-150.0&&degrees(angle)<=-150.0+6.0*(a2))\n          return galacticTime;\n       if (degrees(angle)>-120.0&&degrees(angle)<=-120.0+6.0*(a3))\n          return galacticTime;\n       if (degrees(angle)>-90.0&&degrees(angle)<=-90.0+6.0*(a4))\n          return galacticTime;\n      if (degrees(angle)>-60.0&&degrees(angle)<=-60.0+6.0*(a5))\n          return galacticTime;\n      if (degrees(angle)>-30.0&&degrees(angle)<=-30.0+6.0*(a6))\n          return galacticTime;\n      if (degrees(angle)>0.0&&degrees(angle)<=6.0*(a7))\n          return galacticTime;\n      if (degrees(angle)>30.0&&degrees(angle)<=30.0+6.0*(a8))\n          return galacticTime;\n      if (degrees(angle)>60.0&&degrees(angle)<=60.0+6.0*(a9))\n          return galacticTime;\n      if (degrees(angle)>90.0&&degrees(angle)<=90.0+6.0*(a10))\n         return galacticTime;\n      if (degrees(angle)>120.0&&degrees(angle)<=(120.0+6.0*(a11)))\n          return galacticTime;\n      if (degrees(angle)>150.0&&degrees(angle)<=(150.0+6.0*(a12)))\n          return galacticTime;\n    } */   \n    //float dangle = degrees()\n    \n    /* Operator \"||\" to set cureent date and day of week when angle arrive +/-180deg. bug fixed by 18.05.2021 */\n    \n    \n    vec4 res = vec4(1.0, 1.0, 1.0, 1.0);//clock color\n    \n    \n    \n                \n                \n                \n    vec4 years = vec4(0.2, 0.2, 0.2, 1.0);//years controller\n    if ((x*x+y*y)<=146.0*146.0*N&&(x*x+y*y)>140.0*140.0*N) {//140-146 radius\n      if (degrees(angle)>-180.0&&degrees(angle)<=-180.0+6.0*(floor(jDate2)))\n          return years;//100000\n      if (degrees(angle)>-120.0&&degrees(angle)<=-120.0+6.0*(floor(jDate1)))\n          return years;//10000\n      if (degrees(angle)>-60.0&&degrees(angle)<=-60.0+6.0*(floor(jDatex/1000.0)))\n          return years;//millenium of year\n      if (degrees(angle)>0.0&&(degrees((angle)))<=6.0*(floor(mod(jDatex, 1000.0)/100.0)))\n          return years;//century of year\n      if (degrees(angle)>60.0&&degrees(angle)<=60.0+6.0*(floor(mod(jDatex,100.0)/10.0)))\n         return years;//dacade of year\n      if (degrees(angle)>120.0&&degrees(angle)<=(120.0+6.0*(floor(mod(jDatex,10.0)))))\n          return years;//last num of year\n    }\n    \n    if ((x*x+y*y)<146.0*146.0*N&&(x*x+y*y)>=135.0*135.0*N)//135-146 radius\n    /*fix*/ if (180.0+degrees(angle)<30.0*(jDate.y+1.0)&&180.0+degrees(angle)>30.0*(jDate.y+1.0)-6.0*day()||30.0*(jDate.y+1.0)-6.0*day()<-180.0+degrees(angle))\n                return vec4(1.0,0.7,0.1,1.0);//day of week yellow color (month, day)\n    if ((x*x+y*y)<146.0*146.0*N&&(x*x+y*y)>=135.0*135.0*N)//135-146 radius\n    /*fix*/ if (180.0+degrees(angle)>30.0*(jDate.y+1.0)&&180.0+degrees(angle)<30.0*(jDate.y+1.0)+6.0*jDate.z||30.0*(jDate.y+1.0)+6.0*jDate.z>360.0+180.0+degrees(angle))\n                return vec4(0.25,0.75,0.25,1.0);//date green color (month, day)\n            \n    \n    float jDatem = floor((13800000000.0-2021.0+jDate.x)/1000000.0);\n    jDate.x = mod(jDatem, 1000000.0);//do a barrel roll after 1 million years of work \n    jDatex = mod(jDate.x,10000.0);//4 last digits of year\n    jDate1 = 0.0; jDate2 = 0.0;// 4 digits year\n    if (jDate.x>99999.0) {//if year is 6 digits\n        jDate2 = floor(jDate.x/100000.0);\n        jDate1 = mod(jDate.x,100000.0)/10000.0;\n    }\n    else if (jDate.x>9999.0) {//if year is 5 digits\n        jDate2 = floor(jDate.x/100000.0);\n        jDate1 = floor(jDate.x/10000.0);\n    }\n    vec4 galacticTime = vec4(0.9, 0.2, 0.2, 1.0);\n    if ((x*x+y*y)>=147.0*147.0*N&&(x*x+y*y)<=149.0*149.0*N) {//140-146 radius\n      if (degrees(angle)>-180.0&&degrees(angle)<=-180.0+6.0*(floor(jDate2)))\n          return galacticTime;//100000\n      if (degrees(angle)>-120.0&&degrees(angle)<=-120.0+6.0*(floor(jDate1)))\n          return galacticTime;//10000\n      if (degrees(angle)>-60.0&&degrees(angle)<=-60.0+6.0*(floor(jDatex/1000.0)))\n          return galacticTime;//millenium of year\n      if (degrees(angle)>0.0&&(degrees((angle)))<=6.0*(floor(mod(jDatex, 1000.0)/100.0)))\n          return galacticTime;//century of year\n      if (degrees(angle)>60.0&&degrees(angle)<=60.0+6.0*(floor(mod(jDatex,100.0)/10.0)))\n         return galacticTime;//dacade of year\n      if (degrees(angle)>120.0&&degrees(angle)<=(120.0+6.0*(floor(mod(jDatex,10.0)))))\n          return galacticTime;//last num of year\n    }\n    if ((x*x+y*y)<=150.0*150.0*N&&(x*x+y*y)>=146.0*146.0*N)//light shadow\n        return vec4(0.92,0.92,0.92,1.0);//shadow\n    \n    \n    \n    if (x*x+y*y<=10.0*10.0*N)//10 radius\n        return vec4(0.9);\n    if (x*x+y*y<=14.0*14.0*N)//10 radius\n        return vec4(0.6);\n    if ((x*x+y*y)<=90.0*90.0*N)//90 radius\n      C=vec2(x,y);\n      C=rotate(C, mod(t/60.0/60.0, 12.0)/12.0*M_PI*2.0);\n      if (C.y<90.0*sqrt(N)&&abs(C.x)<=2.5*sqrt(N)&&C.y>0.0)\n        return vec4(0.0,0.0,0.0,1.0); //hours arrow color\n    if ((x*x+y*y)<=110.0*110.0*N) {//115 radius\n      //if (int(ceil(60.0*angle/2.0/M_PI))==-int(floor(30.0-mod(((t+0.001)/60.0), 60.0))))\n      C=vec2(x,y);\n      C=rotate(C, mod(t/60.0, 60.0)/60.0*M_PI*2.0);\n      if (C.y<110.0*sqrt(N)&&abs(C.x)<=2.5*sqrt(N)&&C.y>0.0)\n        return vec4(0.0,0.8,0.8,1.0);//minutes arrow color\n     }\n    if ((x*x+y*y)<=130.0*130.0*N) {//140 radius\n       //if (int((ceil(60.0*angle/2.0/M_PI)))==-int(floor(30.0-mod(((t+0.001)),60.0)))) {\n      C=vec2(x,y);\n      C=rotate(C, mod(t, 60.0)/60.0*M_PI*2.0);\n      if (C.y<130.0*sqrt(N)&&abs(C.x)<=2.5*sqrt(N)&&C.y>0.0)\n        return vec4(1.0,0.0,0.6,1.0);\n        //}\n    }//seconds arrow color\n    if ((x*x+y*y)<=150.0*150.0*N)//150 radius\n        return res;//clock color\n    if ((x*x+y*y)<=170.0*170.0*N) {//170 radius\n        float dt = 0.0; float jDatew = t;\n        if(mod(floor(jDatew/3600.0), 24.0)>=12.0) dt=1.0;// dt sets PM/AM\n        res.x=float(int(mod(floor(60.0*radians((degrees(angle))-mod(floor(jDatew/3600.0)+dt, 24.0)*30.0)/2.0/M_PI),2.0)));\n        res.y=float(int(mod(floor(60.0*radians((degrees(angle))-mod(floor(jDatew/3600.0)+dt, 24.0)*30.0)/2.0/M_PI/5.0),2.0)));\n        res.z=(res.x+res.y)/abs(2.0-mod(t, 4.0));//clock segmentation animate by t(time)\n        return abs(res);//color for clock segmentation\n    }\n    else {\n        res = (vec4(0.0,0.2,0.2,1.0)*sin((y-535.0)/340.0)*sin((x-1070.0)/680.0));//old background\n        if(abs(y)<10000.0)res = bg(vec2(x,y))/1.0;//new scene\n        return res;\n    }\n}\n\n\n// START\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {float N=iResolution.y/360.0;\n    \n    jDate = iDate; // 4D TIME POINT \n    // You can fix it to display any date and any time of 1 million years.\n    \n    vec2 coord = fragCoord - (iResolution.xy / vec2(2.0));//simmetric\n    float dx = iMouse.x-iResolution.x/2.0;//mouse move x\n    float dy = iMouse.y-iResolution.y/2.0;//mouse move y\n    if(dx!=-iResolution.x/2.0||dy!=-iResolution.y/2.0)\n    { coord.x+=dx; coord.y+=dy; }//move graphics x, y\n    fragColor= f(coord.x,coord.y,float(jDate.w)); //go\n    if (coord.x*coord.x+coord.y*coord.y>170.0*170.0*N){//shadow\n        if (coord.x*coord.x+coord.y*coord.y<180.0*180.0*N)//shadow\n            fragColor/=8.0;//shadow\n     }\n    if (coord.x*coord.x+coord.y*coord.y<=146.0*146.0*N&&fragColor.w!=0.5)//arrows texture animate\n        fragColor+=abs(tan(abs(degrees(atan(coord.x, coord.y))*4.0-jDate.w*2.0)))/16.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsSRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 101, 101, 167], [1056, 1073, 1098, 1098, 1653], [1655, 1672, 1707, 1707, 9909], [9912, 9921, 9978, 9978, 10838]], "test": "valid"}
{"id": "NlsSzf", "name": "AntiPod - Schala Theme", "author": "Flopine", "description": "A shader made as a loop for a track from ThronoCrigger, check out his albums!!! \nhttps://thronocrigger.bandcamp.com/", "tags": ["2d", "palette", "animation", "pattern", "hexagons", "mograph"], "likes": 6, "viewed": 120, "published": "Public", "date": "1626202061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.283185\n#define hr vec2(1.,sqrt(3.))\n\n#define BPM (164./60.)\n#define dt(speed,off) fract(iTime*speed+off)\n#define animCirc(speed,off) easeInOutCirc(dt(speed,off))\n#define bouncy(sp,off) sqrt(sin(dt(sp,off)*PI))\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.07,fwidth(val-thre)))\n#define hdist(puv, s) (max(abs(puv.x),dot(abs(puv),normalize(hr)))-s)\n#define circle(puv,s) (length(puv)-s)\n\n#define mo(puv,d) puv=abs(puv)-d;if(puv.y>puv.x)puv=puv.yx;\n\n\nfloat easeInOutCirc (float x)\n{\n    return x < 0.5\n        ? (1. - sqrt(1. - (2.*x)*(2.*x))) / 2.\n        : (sqrt(1. - (-2.*x+2.)*(-2.*x+2.) + 1.)) / 2.;\n}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = mod(atan(p.y,p.x),per)-per*0.5;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat line (vec2 uv, vec2 a, vec2 b, float r)\n{\n    vec2 pa = uv - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r*h;\n}\n\nfloat shooting_star (vec2 uv, float toff, vec2 uoff)\n{\n    vec2 a = vec2(2.)+uoff,\n        b = vec2(-6.)+uoff,\n        anima = mix(a,b,animCirc(BPM/2.,toff-0.2)),\n        animb = mix(anima,b,animCirc(BPM/2.,toff));\n    return AAstep(0.015,abs(line(uv, anima,animb, 0.1)));\n}\n\nfloat frame (vec2 uv)\n{\n    vec2 uu = uv;\n    mo(uv, vec2(2., 2.1));\n\t\n    moda(uv,6.);\n    uv.x -= 1.4;\n    float size = 0.15, thick=0.01, d = 1.; \n    float iter = floor(abs(sin(dt(BPM/6.,0.)*PI))*5.9);\n    for (float i=0.; i<iter; i++)\n    {\n        d *= AAstep(thick,abs(hdist(uv,size)));\n    \tsize += 0.12; thick += 0.007;\n    }\n    \n   \td *= shooting_star(uu,0.,vec2(1.,0.));\n    d *= shooting_star(uu,0.3,vec2(-1.5,0.5));\n    d *= shooting_star(uu,0.4,vec2(2.5,0.));\n    d *= shooting_star(uu,0.6,vec2(-3.5,0.1));\n    \n    uv = uu;\n    uv.y -= -.3+bouncy(BPM/6.,0.)*0.5;\n    d *= AAstep(0.02,abs(circle(uv,0.6)));\n    \n    return 1.-d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(frame(uv*2.));\n    col.r -= frame(uv*2.02)*0.5;\n    col.g -= frame(uv);\n    col.b += frame(uv*2.08);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4tlXDS", "previewfilepath": "https://soundcloud.com/thronocrigger/schalas-theme-chrono-trigger-thronocrigger-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/thronocrigger/schalas-theme-chrono-trigger-thronocrigger-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[861, 861, 892, 892, 1016], [1018, 1018, 1054, 1054, 1166], [1168, 1168, 1215, 1215, 1345], [1347, 1347, 1401, 1401, 1621], [1623, 1623, 1646, 1646, 2267], [2269, 2269, 2326, 2326, 2554]], "test": "valid"}
{"id": "NlsXDH", "name": "Exit the Matrix", "author": "Kali", "description": "Circuit fractal applied to a KIFS structure and a transparent cube", "tags": ["raymarching", "fractal", "texture"], "likes": 46, "viewed": 495, "published": "Public", "date": "1625676651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float det=.001,t, boxhit;\nvec3 adv, boxp;\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 path(float t)\n    {\n    vec3 p=vec3(vec2(sin(t*.1),cos(t*.05))*10.,t);\n    p.x+=smoothstep(.0,.5,abs(.5-fract(t*.02)))*10.;\n    return p;\n}\n\nfloat fractal(vec2 p)\n{\n    p=abs(5.-mod(p*.2,10.))-5.;\n    float ot=1000.;\n    for (int i=0; i<7; i++)\n    {\n        p=abs(p)/clamp(p.x*p.y,.25,2.)-1.;\n        if(i>0)ot=min(ot,abs(p.x)+.7*fract(abs(p.y)*.05+t*.05+float(i)*.3));\n        \n    }\n    ot=exp(-10.*ot);\n    return ot;\n}\n\nfloat box(vec3 p, vec3 l)\n{\n    vec3 c=abs(p)-l;\n    return length(max(vec3(0.),c))+min(0.,max(c.x,max(c.y,c.z)));\n}\n\nfloat de(vec3 p)\n{\n    boxhit=0.;\n    vec3 p2=p-adv;\n    p2.xz*=rot(t*.2);\n    p2.xy*=rot(t*.1);\n    p2.yz*=rot(t*.15);\n    float b=box(p2,vec3(1.));\n    p.xy-=path(p.z).xy;\n    float s=sign(p.y);\n    p.y=-abs(p.y)-3.;\n    p.z=mod(p.z,20.)-10.;\n    for (int i=0; i<5; i++)\n    {\n        p=abs(p)-1.;\n        p.xz*=rot(radians(s*-45.));\n        p.yz*=rot(radians(90.));\n    }\n    float f=-box(p,vec3(5.,5.,10.));\n    float d=min(f,b);\n    if (d==b) boxp=p2, boxhit=1.;\n    return d*.7;\n}\n\n\nvec3 march(vec3 from, vec3 dir)\n{\n    vec3 p,n,g=vec3(0.);\n    float d, td=0.;\n    for (int i=0; i<80; i++)\n    {\n        p=from+td*dir;\n        d=de(p)*(1.-hash(gl_FragCoord.xy+t)*.3);\n        if (d<det && boxhit<.5) break;\n        td+=max(det,abs(d));\n        float f=fractal(p.xy)+fractal(p.xz)+fractal(p.yz);\n        //boxp*=.5;\n        float b=fractal(boxp.xy)+fractal(boxp.xz)+fractal(boxp.yz);\n        vec3 colf=vec3(f*f,f,f*f*f);\n        vec3 colb=vec3(b+.1,b*b+.05,0.);\n        g+=colf/(3.+d*d*2.)*exp(-.0015*td*td)*step(5.,td)/2.*(1.-boxhit);\n        g+=colb/(10.+d*d*20.)*boxhit*.5;\n    }\n    return g;\n}\n\nmat3 lookat(vec3 dir, vec3 up) \n{\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    t=iTime*7.;\n    vec3 from=path(t);\n    adv=path(t+6.+sin(t*.1)*3.);\n    vec3 dir=normalize(vec3(uv,.7));\n    dir=lookat(adv-from,vec3(0.,1.,0.))*dir;\n    vec3 col=march(from, dir);\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsXDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 63, 63, 180], [183, 183, 202, 202, 261], [263, 263, 287, 287, 407], [409, 409, 432, 432, 691], [693, 693, 720, 720, 809], [811, 811, 829, 829, 1297], [1300, 1300, 1333, 1333, 1915], [1917, 1917, 1950, 1950, 2056], [2059, 2059, 2116, 2116, 2391]], "test": "valid"}
{"id": "NlsXR7", "name": "HEPTAPLEX", "author": "ENDESGA", "description": "based off mla's https://www.shadertoy.com/view/ttlyWf", "tags": ["conformal", "poincare", "cineshader"], "likes": 10, "viewed": 936, "published": "Public API", "date": "1625363003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Original: https://www.shadertoy.com/view/3lscDf by stb\n// Extra animation by mla, 2020\n////////////////////////////////////////////////////////////////////////////////\n\n/*\n\tHyperbolic PoincarÃ© transformed\n\t2015-2020 stb\n\n\tJust messing with some old code, and a few complex functions.\n*/\n\n// change these\nconst int N\t\t= 7;\t// number of polygon vertices\nconst int P\t\t= 7;\t// number of polygons meeting at a vertex\nconst int Iters\t= 7;\t// number of iterations\n\n\n#define E \t\t2.71828182\n#define HALFPI\t1.57079633\n#define PI\t\t3.14159265\n#define TWOPI\t6.28318531\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n#define rotate2(p, a) vec2(p.x*cos(a) - p.y*sin(a), p.x*sin(a) + p.y*cos(a))\n\n\nvec2 radialRepeat(vec2 p, vec2 o, int n) {\n    return rotate(vec2(o.x, o.y), floor(atan(p.x, p.y)*(float(n)/TWOPI)+.5)/(float(n)/TWOPI));\n}\n\nvec2 cInvert(vec2 p, vec2 o, float r) {\n    return (p-o) * pow(r, 2.) / dot(p-o, p-o) + o;\n}\n\nvec2 cInvertMirror(vec2 p, vec2 o, float r, float flip){\n    return (length(p-o)<r ^^ flip==1. ? cInvert(p, o, r) : p);\n}\n\nvec4 poincareGetStuff(int n_, int p_) {\n    float n = PI / float(n_), p = PI / float(p_);\n\tvec2 r1 = vec2(cos(n), -sin(n));\n    vec2 r2 = vec2(cos(p+n-HALFPI), -sin(p+n-HALFPI));\n    float dist = (r1.x - (r2.x/r2.y) * r1.y);\n    float rad = length(vec2(dist, 0.)-r1);\n    float d2 = dist*dist - rad*rad;\n    float s = (d2<0. ? 1. : sqrt(d2));\n\treturn (vec4(vec3(dist, rad, 1.)/s, float(d2<0.)));\n}\n\nvec2 poincareCreateUVs(vec2 p, vec4 pI) {\n    return cInvertMirror(p, radialRepeat(p, vec2(0., pI.x), N), pI.y, pI.w);\n}\n\n// Many complex functions are from: https://raw.githubusercontent.com/julesb/glsl-util/master/complexvisual.glsl\n\n#ifndef sinh\n\t#define sinh(a) (pow(E, a)-pow(E, -a)) / 2.\n#endif\n#ifndef cosh\n\t#define cosh(a) (pow(E, a)+pow(E, -a)) / 2.\n#endif\n\n#define c_abs(a) length(a)\n#define c_arg(a) atan(a.y, a.x)\n\n#define c_conj(a) vec2(a.x, -a.y)\n#define c_exp(a) vec2(exp(a.x)*cos(a.y), exp(a.x)*sin(a.y))\n#define c_sqr(a) vec2(a.x*a.x-a.y*a.y, 2.*a.x*a.y)\n#define c_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define c_div(a, b) vec2((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y), (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y))\n#define c_sin(a) vec2(sin(a.x)*cosh(a.y), cos(a.x)*sinh(a.y))\n#define c_cos(a) vec2(cos(a.x)*cosh(a.y), -sin(a.x)*sinh(a.y))\n#define c_cartToPolar(a) vec2(length(a), atan(a.y, a.x))\n#define c_polarToCart(a) a.x * vec2(cos(a.y), sin(a.y))\n\nvec2 c_sqrt(vec2 a){\n    float r = sqrt(a.x*a.x+a.y*a.y);\n    float rpart = sqrt(.5*(r+a.x));\n    float ipart = sqrt(.5*(r-a.x));\n    if (a.y < 0.) ipart = -ipart;\n    return vec2(rpart, ipart);\n}\n\nvec2 c_tan(vec2 a){ return c_div(c_sin(a), c_cos(a)); }\n\nvec2 c_log(vec2 a){\n    float rpart = length(a);\n    float ipart = atan(a.y, a.x);\n    if (ipart > PI) ipart -= 2. * PI;\n    return vec2(log(rpart), ipart);\n}\n\nvec2 c_toThe(vec2 a, float b){ return c_exp(b*c_log(a)); }\nvec2 c_toThe(vec2 a, vec2 b){ return c_exp(c_mul(b, c_log(a))); }\n\nfloat mmix(float t, float start, float end) {\n  return clamp((t-start)/(end-start),0.0,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = 2. * (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n\tp.y += HALFPI * 0.96;\n    //p *= 7.0;\n    // some transformations\n    float cycle = 22.0;\n    float nArms = 3.0; //1.+floor(16.*abs(fract(.025*iTime)-.5));\n    p = rotate2(p, -HALFPI);\n    float t = mod(4.0,cycle);\n    t = min(t,cycle-t);\n    //p /= dot(p, p);\n    //p = c_toThe(p, pow(nArms,mmix(t,9.0,10.0)));\n    //p.x += 1.0*mmix(t,7.0,8.0);\n    //p = c_toThe(p, pow(.5,mmix(t,5.0,6.0)));\n    //p.x += .5*mmix(t,3.0,4.0);\n    p /= dot(p, p);\n    p.x -= mmix(t,1.0,2.0);\n    p = rotate2(p, .0777*iTime);\n    \n    \n    // get data for the disk model\n \n    vec4 pI = poincareGetStuff(N, P);\n    \n    // build the disk\n    for(int i=0; i<Iters; i++)\n        p = poincareCreateUVs(p, pI);\n    \n    // uncomment to mirror from disk's margin\n    //p = cInvertMirror(p, vec2(0., 0.), 1., 1.);\n    \n    float f = 1. - clamp(1. - dot(p,p) / pow(pI.z, 2.), 0.0, 1.0);\n    \n    f *= f * f;\n    \n    //f = ((sin(f * PI * 0.9) * f * 1.5) + f) * 0.5;\n    \n    // this is the pattern for each polygon\n    /*float f = 1.0 - clamp(1. / (pow(length(p * 7.777),0.5) * 77.777), 0.0, 1.0);//1. - dot(p, p) / pow(pI.z, 2.);\n    f = pow(f * f, 77.777);\n    f = pow(0.01 / f, 0.1) * f;\n    fragColor = vec4(vec3(pow(f * f * 20.0,7.777) * 7.0) * vec3(2.0,0.0,0.5), 1.);*/\n    \n    fragColor = vec4(vec3(f) * vec3(1.,0.,0.25), 1.0);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsXR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[932, 932, 971, 971, 1024], [1149, 1149, 1188, 1188, 1546], [1548, 1548, 1589, 1589, 1668], [2517, 2517, 2537, 2537, 2713], [2715, 2715, 2734, 2734, 2770], [2772, 2772, 2791, 2791, 2930], [2932, 2932, 2962, 2962, 2990], [2991, 2991, 3020, 3020, 3056], [3058, 3058, 3103, 3103, 3152], [3154, 3154, 3209, 3209, 4590]], "test": "valid"}
{"id": "NlSXRz", "name": "Simple blue wave", "author": "Canysway", "description": "studying raymarching.. :)", "tags": ["raymarching", "wave"], "likes": 7, "viewed": 64, "published": "Public", "date": "1626882470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define PI 3.141592\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n  \n    vec2 u = smoothstep(0.,1.,f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n\nfloat dPlane(vec3 p, vec3 n){\n    return dot(p, normalize(n));  // make plane with nomral vector\n}\n\n\nfloat GetDist(vec3 p){\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    p.xz *= Rot(-m.x*PI);\n    float planeDist = dPlane(p, vec3(0., 1., 0.)) - .4 * noise(vec2(p.x, p.z + iTime)) * sin(p.z + iTime * 2.5);\n    return planeDist;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx)\n    );\n    return normalize(n);\n}\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float d0 = 0.;\n    for(int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        if(d0 > MAX_DIST || dS < SURF_DIST) break;\n    }\n\n    return d0;\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0., 5., 6.);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float diffuse = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p + n*SURF_DIST * 2., l); \n    if(d<length(lightPos-p)) diffuse *= .05;\n    return diffuse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0.);\n    vec3 cam = vec3(0., 3., 0.);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    float d = RayMarch(cam, rd);\n    if (d < MAX_DIST){\n        vec3 p = cam + rd* d;\n        float diffuse = GetLight(p);\n        col = vec3(diffuse);\n    }\n    col = pow(col, vec3(.4545));\n    float a = clamp(0., 1., col.r);\n    col = mix(vec3(1.), vec3(0., col.g * .4, col.b * .5), a);\n    // col = mix(vec3(3., 1., .5) * col, col, smoothstep(.0, .01, clamp(0., 1., col.r)));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 105, 105, 181], [183, 183, 210, 210, 327], [329, 416, 439, 439, 782], [786, 786, 815, 815, 884], [887, 887, 909, 909, 1116], [1118, 1118, 1141, 1141, 1335], [1339, 1339, 1372, 1372, 1582], [1584, 1584, 1607, 1607, 1922], [1924, 1924, 1978, 1978, 2618]], "test": "valid"}
{"id": "NlsXW8", "name": "Trippy spiral colours", "author": "turtletennis", "description": "radiating spiral from mouse-click location with colours that vary over time. ", "tags": ["spiral", "color", "colour"], "likes": 3, "viewed": 44, "published": "Public", "date": "1625838390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi=3.14159;\nfloat ringMultiplier=20.0;\nfloat t=1.0;\nvec3 speed=vec3(2.0,2.2,3.0);\nvec3 speedIncrement = vec3(1.1,1.1,1.1);\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nfloat spiral(vec2 m) {\n\tfloat r = length(m);\n\tfloat a = atan(m.y, m.x);\n\tfloat v = sin(100.*(sqrt(r)-0.02*a-.3*iTime))/2.;\n\t//return clamp(v,0.,1.);\n    return v+0.5;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    \n    if (keyToggle(107)) speed=speed+speedIncrement; //+\n    if (keyToggle(109)) speed=speed-speedIncrement; //-\n    float aspect=iResolution.x/iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,0,0));\n    //col=uv.xyx;\n    col.z=iMouse.x/iResolution.x;\n    vec2 distance = vec2(0,0);\n    distance.x=uv.x-iMouse.x/iResolution.x;\n    distance.y=uv.y-iMouse.y/iResolution.y;\n    distance.x=distance.x*aspect;\n    //distance=abs(distance);\n    float d = sqrt(distance.x*distance.x+distance.y*distance.y);\n    \n    d=spiral(distance);\n    \n    col=vec3(sin((d*pi*ringMultiplier+iTime*speed.x)),cos((d*pi*ringMultiplier+iTime*speed.y)),cos((-d*pi*ringMultiplier+iTime*speed.z)));\n    col=vec3(sin(d*pi+iTime*speed.x),cos(d*pi+iTime*speed.y),cos(-d*pi+iTime*speed.z));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(d,d,d,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsXW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 157, 157, 230], [232, 232, 254, 254, 401], [403, 403, 460, 460, 1465]], "test": "error"}
{"id": "NlsXzf", "name": "Fractal webcam", "author": "matigekunstintelligentie", "description": "Webcam as orbit trap", "tags": ["fractal", "webcam", "feedback"], "likes": 1, "viewed": 298, "published": "Public API", "date": "1626211581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nprecision highp float;\n\n\nfloat ShadeMode = 0.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat ImageMode = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat ImageXScale = 1.; // value=1, min=0, max=2, step=0.1\nfloat ImageYScale = 1.; // value=1, min=0, max=2, step=0.1\nfloat Front = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Animate = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Radius = 0.5; // value=0.5, min=0, max=1, step=0.01\nfloat Normalised = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Julia = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Julia_c1 = 0.; // value=0, min=-1.0, max=1.0, step=0.01\nfloat Julia_c2 = 0.; // value=0, min=-1.0, max=1.0, step=0.01\nint MaxIter = 50; // value=50, min=1, max=1000, step=1\nint AA = 4; // value=4, min=1, max=9, step=1\nfloat Zoom = 1.; // value=1, min=0.01, max=20, step=0.01\nfloat Xoffset = 0.; // value=0, min=-1, max=1, step=0.01\nfloat Xpan = 0.; // value=0, min=-1, max=1, step=0.01\nfloat Yoffset = 0.; // value=0, min=-1, max=1, step=0.01\nfloat Ypan = 0.; // value=0, min=-1, max=1, step=0.01\nfloat light = 1.5; // value=1.5, min=0, max=4, step=0.01\nfloat angle = 0.5; // value=0.5, min=0, max=1, step=0.01\nfloat EscapeRadius = 100.; // value=4, min=0, max=100, step=0.01\n\nfloat jc1;\nfloat jc2;\n\n\n\nvec2 cMul(vec2 a, vec2 b) {\n    return vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\nvec2 cInverse(vec2 a) {\n    return  vec2(a.x,-a.y)/dot(a,a);\n}\nvec2 cDiv(vec2 a, vec2 b) {\n    return cMul( a,cInverse(b));\n}\nvec2 cExp(in vec2 z){\n    return vec2(exp(z.x)*cos(z.y),exp(z.x)*sin(z.y));\n}\n\n// https://thebookofshaders.com/10/\n// Random function\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Colour scheme\n// Stolen from llemarie\n// vec3 HSVtoRGB(float iter){\n//     iter = mod(iter+iTime, float(MaxIter));\n//     float value = 1. - float(iter)/float(MaxIter);\n//     value *= value;\n        \n//     float h = value;\n//     float s = 1.;\n//     float v = (iter < float(MaxIter)) ? 1. - value*value : 0.;\n    \n//     float r, g, b, f, p, q, t;\n//     int i;\n//     i = int(h * 6.);\n//     f = h * 6. - float(i);\n//     p = v * (1. - s);\n//     q = v * (1. - f * s);\n//     t = v * (1. - (1. - f) * s);\n//     switch (i % 6){\n//         case 0: r = v, g = t, b = p; break;\n//         case 1: r = q, g = v, b = p; break;\n//         case 2: r = p, g = v, b = t; break;\n//         case 3: r = p, g = q, b = v; break;\n//         case 4: r = t, g = p, b = v; break;\n//         case 5: r = v, g = p, b = q; break;\n//     }\n//     return vec3(r, g, b);\n// }\n\nvec3 palette(float t)\n{\n    //return vec3(0.5,0.5,0.5) + vec3(0.5,0.5,0.5)*cos(6.28318*(vec3(2.0,1.0,0.0)*t + vec3(0.5,0.2,0.25)));\n    return vec3(0.5) + vec3(0.5)*cos(6.28318*(vec3(1.0)*t + vec3(0.,0.33,0.67) + iTime));\n    //return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5)*cos(6.28318*(vec3(1.0, 1.0, 1.0)*t+2.*iTime*vec3(0.01, 0.10, 0.20)) );\n}\n\n\n// Put anything you like here. This is the image that is rendered in the image orbit traps\nvec4 subrender(float xin, float yin){\n    xin = xin/ImageXScale;\n    yin = yin/ImageYScale;\n    float sqr = sqrt((xin-0.5)*(xin-0.5)+(yin-0.5)*(yin-0.5));\n    if(sqr<Radius){\n        return texture( iChannel0,vec2(xin,yin));\n    }\n    else{\n        return vec4(0.0);\n    }\n}\n\nvec4 render(float xin, float yin){\n    // vec4 final_col = vec4(0.0);\n    // for(int i = 0; i<AA;i++){\n        float trap1 = 0.0;\n        float x = 0.0;\n        float y = 0.0;\n        float xx = 0.0;\n        float yy = 0.0;\n        float xy = 0.0;\n        \n        // sample points around the main pixel for anti-aliasing\n        float c1 = (1./Zoom)*(xin + Xoffset + Xpan);\n        float c2 = (1./Zoom)*(yin + Yoffset - Ypan);\n        \n        // Julia mode\n        if(Julia>0.0){\n            x = c1;\n            y = c2;\n            c1 = jc1;\n            c2 = jc2;\n        }\n        \n        vec2 dc = vec2(1, 0);\n        vec2 der = dc;\n        \n        float h2 = light;\n        float angle = angle;\n        vec2 v = cExp(vec2(0.0, angle*2.*3.1415/360.));\n        v = vec2(sin(iTime),angle*cos(iTime));\n        \n        int j = 0;\n        // Flag keeps track of opqque pixels\n        int flag = 0;\n        \n        vec4 col = vec4(palette(1.0), 1.0);\n        \n        while(j<MaxIter){\n            xx = x*x;\n            yy = y*y;\n            col = vec4(palette(trap1), 1.0);\n            if((xx + yy) > EscapeRadius){\n                if(flag<1){\n                    // Normalised/Smooth iteration count\n                    if(Normalised>0.0){\n                        float iter =float(j) - log2(log2(dot(vec2(x,y),vec2(x,y)))) + 4.0;\n                        \n                        // float logzn = log(xx+yy);\n                        // float log4 = log(4.0);\n                        // float log2 = 1.44269504089;\n                        // float logzndiv4 = logzn/log4;\n                        // float loglogzndiv4 = log(logzndiv4);\n                        // float nu = loglogzndiv4 * 1.0/log2;\n                        // nu = log(logzn/log(4.0))/log(2.0);\n                        // float iter = float(j) + 1.0 - nu;\n                        \n                        col = vec4(palette(trap1), 1.0);\n                    }\n                    else{\n    \n                        \n                        col = vec4(palette(float(j)), 1.0);\n                    }\n                }\n                \n                break;\n            }\n            der = cMul(vec2(x,y), der) * 2.0 + dc;\n            \n            // TODO: Karatsuba style - not sure how much time it saves. https://mathr.co.uk/blog/2016-04-10_complex_squaring.html\n            xy = x*y;\n            x = xx - yy + c1;\n            y = xy+xy + c2;\n            \n            float d1 = abs(dot(vec2(x,y)-vec2(0.0,1.0),vec2(0.5)));\n\t\t    float ff = 1.0-smoothstep(0.7,1.3,d1);\n\t\t    trap1 += ff*d1;\n            \n            // Image orbit trap\n            if(ImageMode>0.0 && x>-1.0*ImageXScale && x<=1.0*ImageXScale && y > -1.0*ImageYScale && y<=1.0*ImageYScale){\n                vec4 sr = subrender(x+0.5, y+0.5);\n                if(sr.a>0.0){\n                    col = sr;\n                    if(Front>0.0){\n                        break;\n                    }\n                    flag = 1;\n                }\n            }\n            j++;\n        }\n        \n        if(ShadeMode>0.0){\n        \n            vec2 u = cDiv(vec2(x,y), der);\n            u = cDiv(u, abs(vec2(u.x, u.y)));\n            float t = dot(u,v) + h2;\n            t = t/(1. + h2);\n            \n            if(t<0.){\n                t =0.;\n            }\n            \n            col.xyz *= t;\n        }\n        \n        return col;\n        \n        \n\n    // }\n    \n    // return final_col/float(AA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    for( int m=0; m<AA; m++ ){\n    for( int n=0; n<AA; n++ ){\n    // Screen coordinate (from [-aspect, -1] to [aspect, 1])\n\n    vec2 q   = (2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA))-iResolution.xy) / iResolution.y;\n    \n    jc1 = Julia_c1;\n    jc2 = Julia_c2;\n    if(Animate>0.0){\n        jc1 = sin(Julia_c1 + iTime + 5.);\n        jc2 = cos(Julia_c2 + iTime + 7.);\n    }\n    \n    vec4 col = render(q.x, q.y);\n    col.xyz = pow(col.xyz, vec3(0.9));\n    \n    // Output\n    fragColor += col;\n    }\n    }\n    fragColor/=float(AA*AA);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1291, 1291, 1318, 1318, 1378], [1380, 1380, 1403, 1403, 1442], [1443, 1443, 1470, 1470, 1505], [1506, 1506, 1527, 1527, 1583], [1585, 1640, 1664, 1664, 1771], [2634, 2634, 2657, 2765, 2983], [2986, 3077, 3114, 3114, 3351], [3353, 3353, 3387, 3455, 6787], [6789, 6789, 6846, 6846, 7389]], "test": "error"}
{"id": "NlXSRX", "name": "64 Cubes", "author": "Tater", "description": "Another shader for Sableraph's weekly creative coding challenge, the prompt this time being \"64\". \n\nI sorta ran out of ideas after finishing the pipes and cubes but maybe I will come back to this and add some background details idk. ", "tags": ["3d", "raymarch"], "likes": 15, "viewed": 262, "published": "Public API", "date": "1626155173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\n#define STEPS 96.0\n#define MDIST 50.0\n#define aspect (iResolution.y/iResolution.x)\n\n\nfloat rand1(float a){\n    return fract(sin(dot(vec2(a),vec2(43.234,21.4343)))*94544.3434343)-0.5;\n}\n//cylinder from iq\nfloat cyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 bezier4p(vec2 p1, vec2 p2, vec2 p3, vec2 p4, float t){\n    vec2 p = pow(1.0-t,3.0)*p1+\n           3.0*pow(1.0-t,2.0)*t*p2+ \n           3.0*(1.0-t)*t*t*p3+\n           pow(t,3.0)*p4;  \n    return p;\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nfloat pipe(vec3 p){\n    float a = 0.0;\n    a = cyl(p+vec3(0,9,0),1.0,10.0);\n    a = min(a,cyl(p-vec3(0,1,0),1.2,0.2));\n    a = max(-(length(p.xz)-0.9),a);\n    a-=0.02;\n    return a;\n}\nvec2 aspectize(vec2 a){\n    a.x*=aspect;\n    a.y/=aspect;\n    return a;\n}\nvec2 map(vec3 p){//oops this became a huge mess, oh well\n\n    vec3 po = p;\n    float t = iTime;\n    \n    vec2 a = vec2(0);\n    vec2 b = vec2(1);\n    \n    float ps = 0.5; //Pipe Smooth Time\n    float prt = 3.0;//Pipe Repeat Time\n    \n    vec2 pipe1Pos = vec2(0);\n    vec2 pipe2Pos = vec2(0);\n    float cycleInt = floor(t/prt+1.0);\n    \n    //Pipe Up/Down Movement\n    pipe1Pos.y = 10.0-5.0*smoothstep(0.0,ps,mod(t,prt))*smoothstep(prt,prt-ps,mod(t,prt));\n    //Side to Side randomize\n    float sideScale = 11.75;\n    \n    pipe1Pos.x+=rand1(cycleInt)*sideScale;\n    pipe2Pos.x+=rand1(cycleInt*1.01)*sideScale;\n    \n    pipe2Pos.y = pipe1Pos.y;\n    \n    \n    float pipe1Rot = floor((rand1(cycleInt*1.02)+0.5)*4.0);\n    float pipe2Rot = floor((rand1(cycleInt*1.03)+0.5)*4.0);\n    \n    if(pipe1Rot==pipe2Rot){\n        pipe1Pos.x = abs(pipe1Pos.x)-sideScale*0.5-1.5;\n        pipe2Pos.x = -abs(pipe2Pos.x)+sideScale*0.5+1.5;\n    }\n    \n    if(pipe1Rot==1.0||pipe1Rot==3.0){\n        pipe1Pos.x*=aspect;\n        pipe1Pos.y/=aspect;\n    }\n    \n    p.xy*=rot((pi/2.0)*pipe1Rot);\n    p.xy+=pipe1Pos;\n    a.x = pipe(p);\n    \n    p = po;\n    \n    if(pipe2Rot==1.0||pipe2Rot==3.0){\n        pipe2Pos.x*=aspect;\n        pipe2Pos.y/=aspect;\n    }\n    \n    p.xy*=rot((pi/2.0)*pipe2Rot);\n    p.xy+=pipe2Pos;\n    \n    b = vec2(pipe(p),0.0);\n    \n    a=(a.x<b.x)?a:b;    \n    \n    float pathDisp = 8.5; //Try increasing this :)\n    vec2 p1 = pipe1Pos*rot(3.0*(pi/2.0)*pipe1Rot);\n    vec2 p2 = (pipe1Pos+vec2(0,-pathDisp))*rot(3.0*(pi/2.0)*pipe1Rot);\n    vec2 p3 = pipe2Pos*rot(3.0*(pi/2.0)*pipe2Rot);\n    vec2 p4 = (pipe2Pos+vec2(0,-pathDisp))*rot(3.0*(pi/2.0)*pipe2Rot);\n    \n    float loops =16.0;\n    for(float i = 0.0; i <loops; i ++){\n        float tp = min(-prt*0.5+fract(t/prt)*prt+i/loops,1.1);\n        vec2 boxp = bezier4p(p1,p2,p4,p3,tp);\n        p = po;\n        p+=vec3(boxp,0);\n        p.xy*=rot(t+(i/16.0)*13.0);\n        p.xz*=rot(t+(i/16.0)*13.0);\n        p = abs(p)-vec3(0.45,0.45,0.0);\n        b = vec2(box(p,vec3(0.15)),1.0);\n        if(fract(t/prt)*3.0>ps) a=(a.x<b.x)?a:b;\n    }\n    \n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col =vec3(0);\n    \n    vec3 ro = vec3(0,0,-30);\n    vec3 rd = normalize(vec3(uv,3.0));\n    \n    vec3 p;\n    vec2 d;\n    float dO, shad;\n    bool hit = false;\n    \n    for(float i = 0.0; i < STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        \n        if(abs(d.x)<0.01){\n            shad = i/STEPS;\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            p = ro+rd*MDIST;\n            break;\n        }\n    }\n    if(hit){\n    vec3 n = norm(p);\n    vec3 ld = vec3(-0.5,0.5,-1);\n    vec3 h = normalize(ld-rd);\n    float spec = pow(max(dot(n,h),0.0),30.0);\n    float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n    float diff = max(dot(n, ld),0.);\n    \n    \n    vec3 al;\n    if(d.y == 0.0) al = vec3(0.035,0.757,0.216);\n    if(d.y == 1.0) al = vec3(0.792,0.247,0.255);\n    col = vec3(diff*0.5);\n    col += spec*0.5;\n    col+=fres*0.2;\n    col+=(1.0-shad)*0.5;\n    col*=al;\n    \n    }\n    \n    //vec3 sky = mix(vec3(0.180,0.616,1.000),vec3(0.278,0.235,0.843),clamp(-p.y*0.1+0.4,0.0,1.0));\n    \n    if(!hit)col = vec3(0.302,0.545,1.000)*(1.0-0.5*length(uv*uv));\n    col*=clamp(sin(18.0* uv.y*iResolution.y+iTime*2.0)*0.5+0.5,0.8,1.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 180, 180, 258], [259, 278, 317, 317, 424], [426, 426, 485, 485, 629], [630, 630, 656, 656, 715], [716, 716, 735, 735, 899], [900, 900, 923, 923, 973], [974, 974, 991, 1030, 3070], [3072, 3072, 3090, 3090, 3217], [3219, 3219, 3276, 3276, 4562]], "test": "valid"}
{"id": "NlXXD8", "name": "South Africa Flag", "author": "Eylrid", "description": "South Africa Flag\n\nBased on The Art of Code's flag tutorial", "tags": ["flag"], "likes": 5, "viewed": 36, "published": "Public", "date": "1625532784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 RED = vec3(0.88, 0.22, 0.17);\nvec3 BLUE = vec3(0., 0.04, 0.54);\nvec3 BLACK = vec3(0.);\nvec3 YELLOW = vec3(1., 0.72, 0.08);\nvec3 GREEN = vec3(0., 0.47, 0.27);\nvec3 WHITE = vec3(1.);\n\nvec3 flag(vec2 uv) {\n    float w = fwidth(uv.y)*3.;\n\n    // Red and Blue\n    vec3 col = mix(BLUE, RED, smoothstep(0.5, 0.5+w, uv.y));\n\n    // Fold Horizontally\n    float y = 0.5-abs(0.5-uv.y);\n\n    // Diagonal on the left\n    y -= min(uv.x-0.5, 0.);\n\n    // White Stripe\n    col = mix(col, WHITE, smoothstep(0.333, 0.333+w, y));\n    \n    // Green Stripe\n    col = mix(col, GREEN, smoothstep(0.4, 0.4+w, y));\n    \n    // Yellow Stripe\n    col = mix(col, YELLOW, smoothstep(0.6, 0.6+w, y));\n    \n    // Black\n    col = mix(col, BLACK, smoothstep(0.667, 0.667+w, y));\n    \n    // cutoff top and bottom edges\n    col *= smoothstep(w, 0., abs(uv.y-0.5)-0.5);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = uv.x*5.-iTime*2.+uv.y*2.;\n    uv.y += sin(t)*0.05;\n\n    vec3 col = flag(uv);\n    col *= .7+cos(t)*.3;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 207, 207, 863], [865, 865, 922, 922, 1113]], "test": "valid"}
{"id": "NlXXDj", "name": "Fractal 60_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 12, "viewed": 339, "published": "Public API", "date": "1626515636", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(length(p)*3.),.6)*.015*exp(-8.*i*i*e)\n    )\n    {\n        p=g*d;\n        p=R(p,vec3(.577),iTime*.1);\n        p.z-=iTime;\n        s=6.;\n        p=abs(fract(p*.5)-.5);\n        p=R(p,p/p,.3);\n        for(int i=0;i++<8;)\n            p=.92-abs(p-.81),\n            s*=e=1.3/dot(p,p)-.03,\n            p*=e;\n        g+=e=(dot(p,p/p)-1.1)/s-.002;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 650]], "test": "valid"}
{"id": "NlXXDr", "name": "Look into my eye", "author": "mrange", "description": "License CC0: Look into my eye\nEye designs was the theme of the weekend. Last one.\n", "tags": ["2d"], "likes": 13, "viewed": 193, "published": "Public API", "date": "1625431383", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Look into my eye\n//  Eye designs was the theme of the weekend. Last one.\n\n// Variant flips between B/W design and colorful design\n// #define VARIANT\n\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define TIME          iTime\n#define TTIME         (TAU*iTime)\n#define RESOLUTION    iResolution\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)       (0.5 + 0.5*cos(x))\n#define DOT2(x)       dot(x, x)\n#define PERIOD        5.0\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3  grid_color    = HSV2RGB(vec3(0.6, 0.3, 1.0)); \nconst vec3  light0_color  = 16.0*HSV2RGB(vec3(0.6, 0.5, 1.0)); \nconst vec3  light1_color  = 8.0*HSV2RGB(vec3(0.9, 0.25, 1.0)); \nconst vec3  sky0_color    = HSV2RGB(vec3(0.05, 0.65, -0.25)); \nconst vec3  sky1_color    = HSV2RGB(vec3(0.6, 0.5, 0.25)); \nconst vec3  light0_pos    = vec3(1.0, 5.0, 4.0);\nconst vec3  light1_pos    = vec3(3.0, -1.0, -8.0);\nconst vec3  light0_dir    = normalize(light0_pos);\nconst vec3  light1_dir    = normalize(light1_pos);\nconst vec4  planet_sph    = vec4(50.0*normalize(light1_dir+vec3(0.025, -0.025, 0.0)), 10.0);\n\nfloat g_hf;\n\nvec2 g_vx = vec2(0.0);\nvec2 g_vy = vec2(0.0);\n\nvec2 g_wx = vec2(0.0);\nvec2 g_wy = vec2(0.0);\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// IQ's ray sphere intersect: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\n// IQ's ray plane  intersect: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nvec3 toRect(vec3 p) {\n  return p.x*vec3(cos(p.z)*sin(p.y), sin(p.z)*sin(p.y), cos(p.y));\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// https://iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(-a, a, k);\n}\n\nconst vec2 iris_center = vec2(0.0, 0.28);\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\n// https://iquilezles.org/www/articles/fbm/fbm.htm\nfloat fbm(vec2 p, float aa) {\n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); \n    p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= aa;\n  }\n  return f/s;\n}\n\n// https://iquilezles.org/www/articles/warp/warp.htm\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\n  float d2 = DOT2(p);\n//  p.x = pabs(p.x, 0.1);\n  p = -p.yx;\n  p = toPolar(p);\n  p.y -= -0.125*TIME+p.x*1.25;\n  vec2 pp = p;\n\n  vec2 vx = g_vx;\n  vec2 vy = g_vy;\n\n  vec2 wx = g_wx;\n  vec2 wy = g_wy;\n\n  const float r = 0.5;\n  const float rr = 0.25;\n  float f = smoothstep(r, r+rr, pp.x);\n  g_hf = f;\n\n  //float aa = mix(0.95, 0.25, tanh_approx(pp.x));\n  float aa = 0.5;\n\n  v = vec2(fbm(p + vx, aa), fbm(p + vy, aa))*f;\n  w = vec2(fbm(p + 3.0*v + wx, aa), fbm(p + 3.0*v + wy, aa))*f;\n  \n  return -tanh_approx(fbm(p + 2.25*w, aa)*f);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvoid compute_globals() {\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vx *= ROT(TTIME/1000.0);\n  vy *= ROT(TTIME/900.0);\n\n  wx *= ROT(TTIME/800.0);\n  wy *= ROT(TTIME/700.0);\n  \n  g_vx = vx;\n  g_vy = vy;\n  \n  g_wx = wx;\n  g_wy = wy;\n}\n\nvec3 iris(vec2 p) {\n  const vec3 up  = vec3(0.0, 1.0, 0.0);\n  const vec3 lp1 = 1.0*vec3(1.0, 1.25, 1.0);\n  const vec3 lp2 = 1.0*vec3(-1.0, 2.5, 1.0);\n\n  compute_globals();\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec2 v;\n  vec2 w;\n \n  float h  = warp(p, v, w);\n  float hf = g_hf;\n  vec3  n  = normal(p);\n\n  const vec3 lcol1 = HSV2RGB(vec3(0.7, 0.5, 1.0)); \n  const vec3 lcol2 = HSV2RGB(vec3(0.4, 0.5, 1.0));\n  vec3 po  = vec3(p.x, 0.0, p.y);\n  vec3 rd  = normalize(po - ro);\n  \n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n \n  float a = length(p);\n  vec3 col = vec3(0.0);\n  col += hsv2rgb(vec3(fract(-0.1*TIME+0.125*a+0.5*v.x+0.125*w.x), abs(0.5+tanh_approx(v.y*w.y)), tanh_approx(0.1+abs(v.y-w.y))));\n  col += 0.5*lcol1*pow(ref1, 20.0);\n  col += 0.5*lcol2*pow(ref2, 10.0);\n  col *= hf;\n\n  return col;\n}\n\nvec3 render_iris(vec3 ro, vec3 rd, vec3 nrd) {\n  const vec4 plane = vec4(normalize(vec3(1.0, 0.3, 0.0)), -2.0);\n  const vec3 tnor  = plane.xyz;\n  const vec3 tup   = normalize(vec3(0.0, -1.0, 0.0));\n  const float aa   = 0.001;\n  float t = rayPlane(ro, rd, plane);\n  \n  vec3 tpos = ro + t*rd;\n  vec3 txx = normalize(cross(tnor, tup));\n  vec3 tyy = normalize(cross(tnor, txx));\n  \n  vec2 tpos2 = vec2(dot(txx, tpos), dot(tyy, tpos));\n  \n  vec3 col = iris(tpos2);\n  \n  return col;\n}\n\nvec3 df(vec2 p) {\n  const float iris_outer = 0.622;\n  const float iris_inner = 0.285;\n  \n  float a  = mix(0.0, 1.0, smoothstep(0.995, 1.0, cos(TTIME/PERIOD)));\n  const float w = 1.14;\n  float h = mix(0.48, 0.05, a);\n  \n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  float dt0 = mix(0.0125, -0.0025, t0);\n\n  vec2 p0 = p;\n  float d0 =  vesica(p0, vec2(w, h));\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1 -= iris_center;\n  float d1 = circle(p1, iris_outer);\n  d1 = max(d1,d0+dt0);\n  float d6 = d1;\n\n  vec2 p2 = p;\n  p2 -= vec2(-0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3 -= iris_center;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-1.0*length(p1));\n\n  vec2 p4 = p;\n  p4 -= iris_center;\n  float d4 = circle(p4, iris_inner);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  d0 = abs(d0)-dt0;\n\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return vec3(d, d6, d5);\n}\n\nvec3 render_background(vec3 ro, vec3 rd, vec3 nrd) {\n  rd.xy *= ROT(-PI/2.0+0.6);\n  vec3 srd = toSpherical(rd.xzy);\n  srd.z += 0.025*TIME;\n  vec2 pg  = srd.yz;\n  float f  = sin(pg.x); \n  float lf2= ceil(log(f)/log(2.0)-0.505);\n  float mf = pow(2.0, lf2);\n\n  const float aa = 0.005;\n  const float count = 20.0;\n  const vec2 sz = vec2(2.0*PI/count);\n  vec2 ng = mod2(pg, vec2(mf, 1.0)*sz);\n\n  float dg = min(abs(pg.y)*f, abs(pg.x))-aa*0.0;\n  vec3 lines = grid_color*smoothstep(-aa, aa, -dg)*f*f;\n\n  vec3 sky  = smoothstep(1.0, 0.0, rd.y)*sky1_color+smoothstep(0.5, 0.0, rd.y)*sky0_color;\n\n  vec2 pi = raySphere(ro, rd, planet_sph);\n\n  float lf1 = 1.0;\n  if (pi.x > 0.0) {\n    vec3 ppos = ro+rd*pi.x;\n    float t = 1.0-tanh_approx(1.5*(pi.y - pi.x)/planet_sph.w);\n    sky *= mix(0.5, 1.0, t);\n    lf1 = t;\n  } else {\n    sky += lines;\n  }\n\n  sky += pow(max(dot(rd, light0_dir), 0.0), 800.0)*light0_color; \n  sky += pow(max(dot(rd, light0_dir), 0.0), 80.0)*light1_color*0.1; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 150.0)*light1_color; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 50.0)*light0_color*0.1; \n\n\n  return sky;\n}\n\nvec4 render_body(vec2 p, vec2 q, vec3 dd) {\n//  p -= iris_center;\n  float aa = 2.0/RESOLUTION.y;\n  \n  float a = smoothstep(-aa, aa, -dd.z);\n  float b = smoothstep(0.0, mix(0.075, 0.0025, smoothstep(0.5, 1., abs(p.x))), -dd.z);\n  float c = smoothstep(-aa, aa, -dd.y);\n  float d = smoothstep(0.00, 0.1, -dd.y);\n  \n  //vec3 ro = vec3(1.5, 1.9, -1.85);\n  vec3 ro = vec3(2.0, 0.0, 0.0);\n//  ro.xz *= ROT(TIME);\n  vec3 la = vec3(0.0, 0.0, 0.0); \n\n  vec2 np   = p + vec2(4.0/RESOLUTION.y); \n\n  vec3 ww   = normalize(la - ro);\n  vec3 uu   = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv   = normalize(cross(ww,uu));\n  float rdd = 2.0;\n  vec3 rd   = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd  = normalize(np.x*uu + np.y*vv + rdd*ww);\n  \n  vec4 sph  = vec4(vec3(0.0), 1.0);\n  \n  vec2 si   = raySphere(ro, rd, sph);\n  \n  vec3 pos  = ro + rd*si.x;\n  \n  vec3 nor  = normalize(pos - sph.xyz);\n  \n  vec3 ref  = reflect(rd, nor); \n  vec3 nref = reflect(nrd, nor); \n\n  vec3 refr = refract(rd, nor, 0.9); \n  vec3 nrefr= refract(nrd, nor, 0.9); \n\n  vec3 rbkg = render_background(pos, ref, nref);\n\n  vec3 col = vec3(0.0);\n  col += rbkg;\n  if (d > 0.0) {\n    vec3 riris= render_iris(pos, ref, nref);\n    col += riris*d;\n  }\n  \n  col += mix(vec3(0.0), vec3(0.75), 1.0-c); \n  col.xyz*=b;\n  \n  return vec4(col, a);\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 d   = df(p);\n\n  vec4 dcol = vec4(0.0, 0.0, 0.0, 0.5);\n  dcol.w    = mix(0.0, 0.95, smoothstep(-aa, aa, -d.x));\n  vec4 scol = render_body(p, q, d); \n  \n  vec3 col  = vec3(1.0);\n  col = alphaBlend(col, dcol);\n#ifdef VARIANT  \n  if (fract(TIME/(2.0*PERIOD)) >= 0.5) {\n    col = alphaBlend(col, scol);\n  }\n#else\n  col = alphaBlend(col, scol);\n#endif\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXDr.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[627, 627, 649, 649, 795], [1711, 1711, 1751, 1751, 1910], [1912, 1912, 1952, 1952, 1994], [1996, 1996, 2032, 2032, 2265], [2267, 2267, 2298, 2298, 2324], [2326, 2401, 2432, 2432, 2730], [2732, 2832, 2876, 2876, 3073], [3075, 3175, 3217, 3217, 3264], [3266, 3266, 3294, 3314, 3390], [3392, 3392, 3414, 3414, 3458], [3460, 3460, 3481, 3481, 3522], [3524, 3524, 3550, 3550, 3659], [3661, 3661, 3682, 3682, 3751], [3753, 3785, 3824, 3824, 3949], [3951, 3983, 4019, 4019, 4113], [4115, 4168, 4207, 4207, 4296], [4298, 4298, 4337, 4337, 4366], [4368, 4368, 4398, 4398, 4426], [4471, 4471, 4492, 4492, 4614], [4616, 4667, 4696, 4696, 4948], [4950, 5003, 5047, 5047, 5580], [5582, 5582, 5603, 5603, 5825], [5827, 5827, 5851, 5851, 6131], [6133, 6133, 6152, 6152, 7184], [7186, 7186, 7232, 7232, 7664], [7666, 7666, 7683, 7683, 8655], [8657, 8657, 8709, 8709, 9789], [9791, 9791, 9834, 9856, 11094], [11096, 11096, 11125, 11125, 11525], [11528, 11528, 11583, 11583, 11801]], "test": "error"}
{"id": "NlXXR7", "name": "CutTexByRotation", "author": "wavebbs", "description": "1", "tags": ["1"], "likes": 2, "viewed": 100, "published": "Public", "date": "1625338167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.1415926;\nfloat _ins = 0.25;\n\nfloat Split(vec2 uv, vec2 scale,float time)\n{\n //   time *=10.0;\n\t//vec2 a = vec2(15, 22);\n\tvec2 st = uv * scale;\n\n\tvec2 id = floor(st);\n\n\tst = fract(st) - 0.5;\n    \n\n    ///set random time to start\n    //time +=  fract(sin(id.x *33631.34+id.y * 2312.7)*73312.34);// * 6.283;\n    \n\tfloat y = 0.0;\n    ///set random pos\n    //y += fract(sin(id.x *32161.34+id.y * 23132.7)*71332.34)/3.;\n    st.y += y;\n    \n    \n\tvec2 p1 = vec2(0.0, 0);\n\tvec2 o1 = (st - p1) ;\n\n\t///Circle sqrt(1/2*1/2 + 1/2*1/2)\n\t float d = length(o1)/sqrt(0.5);\n\n\t//Square\n\t//float d = max(abs(o1.x), abs(o1.y))/0.5f;\n    \n    \n\tfloat m1 = 0.0;//1.0*(1.0-d);//  lerp(1, 0.0, d);\n\n    \n\tm1 = step(d, time);\n    \n\n\n\treturn m1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv*2.0 - 1.0;\n\n    float cValue =   ( iTime-floor(iTime)) * 2.0 *PI;//  (sin(iTime)+1.0)*PI;\n     \n    float alpha = 0.0;\n    if(cValue < PI)\n    {\n    \n        vec2 startRot = vec2(1.0,0.0);\n        float angle = dot(startRot,normalize(uv));\n        vec3 c = cross(vec3(startRot.x,startRot.y,0),normalize(vec3(uv.x,uv.y,0)));// normalize(uv));\n\n\n\n        alpha =  step(acos(angle),(cValue));\n\n        if(c.z>0.0 )\n        {\n       \n                alpha = 0.0;\n        }\n\n    }\n    else\n    {\n        vec2 startRot = vec2(-1.0,0.0);\n        float angle = dot(startRot,normalize(uv));\n        vec3 c = cross(vec3(startRot.x,startRot.y,0),normalize(vec3(uv.x,uv.y,0)));// normalize(uv));\n\n\n\n        alpha =  step(acos(angle),(cValue-PI));\n\n        if(c.z>0.0 )\n        {\n                alpha = 1.0;\n        }\n    }\n    \n    \n    \n    fragColor = vec4(alpha,alpha,alpha,alpha);// mix( vec4(.1), texture(iChannel0, fragCoord/iResolution.xy), Distort );\n    \n    \n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 87, 132, 734], [736, 736, 793, 793, 1821]], "test": "valid"}
{"id": "NlXXR8", "name": "BiComplexFractal 1", "author": "bgold", "description": "messing around with bicomplex numbers which I hadn't even heard of until https://www.shadertoy.com/view/NlBGDd\n", "tags": ["fractal", "bicomplex"], "likes": 1, "viewed": 139, "published": "Public API", "date": "1625165012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITER_MAX 255\n#define GAMMA 0.6\n\nvec4 bcSquare( vec4 a ) {\n    return vec4(a.x*a.x - a.y*a.y - a.z*a.z + a.w*a.w,\n                2.0 * (a.x*a.y - a.z*a.t),\n                2.0 * (a.x*a.z - a.y*a.t),\n                2.0 * (a.x*a.t + a.y*a.z));\n}\n\nvec4 bcNorm( vec4 a ) {\n    return vec4(a.x*a.x - a.y*a.y + a.z*a.z - a.w*a.w,\n                2.0 * (a.x*a.y + a.z*a.t),\n                0.0,\n                0.0);\n}\n\nvec3 iterate(vec4 inVec) {\n    vec4 v = inVec;\n    float iterfrac = 0.0;\n    for (int i=0; i<ITER_MAX; i++) {\n        v = bcSquare(v) + inVec;\n        iterfrac = float(i+1)/float(ITER_MAX);\n        if (length(v) > 1000.0) break;\n    }\n    return vec3(bcNorm(v).xy, iterfrac);\n}\n\nvec3 colrot(vec3 c, float th) {\n    vec3 v = c - vec3(0.5);\n    v = mat3(cos(th), 0, -sin(th), 0, 1, 0, sin(th), 0, cos(th)) * v;\n    return v+vec3(0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.0) /iResolution.y;\n    uv *= 2.0;\n\n    vec3 escape = iterate(vec4(uv.x, uv.y, 0.8*sin(iTime/15.7), 0.8*sin(iTime/4.007)));\n    \n    float val = pow(escape.z, GAMMA);\n    float shade = smoothstep(0.1, 10.0, length(escape.xy));\n    float hue = abs(escape.y*10.0);\n    vec3 col = val*colrot(vec3(shade*shade, shade, 1.0), hue);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 65, 65, 252], [254, 254, 277, 277, 420], [422, 422, 448, 448, 699], [701, 701, 732, 732, 856], [858, 858, 915, 915, 1317]], "test": "valid"}
{"id": "NlXXWH", "name": "circle learning shader", "author": "wigglewiggle", "description": "just learning how to use shader toy", "tags": ["circle"], "likes": 2, "viewed": 37, "published": "Public", "date": "1625542555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 circle(vec2 checkPos,vec2 pos,float r,float outline){\n    float d=distance(checkPos,pos)+sin(checkPos.x/10.)*5.+sin(checkPos.y/10.)*5.;\n    if(d<=r){\n    d=1.;\n    }else if(d<=r+outline){\n    d=0.9;\n    }else{\n    d=0.;\n    }\n    return vec3(d,d,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n   \n   vec3 col=circle(fragCoord,vec2(iResolution.x/2.+sin(iTime)*100.,iResolution.y/2.+cos(iTime)*100.),100.,10.);\n    col=clamp(col,0.,1.);\n  \n col-=circle(fragCoord,vec2(iResolution.x/2.+sin(iTime*2.)*100.,iResolution.y/2.+cos(iTime*2.)*100.),100.,0.);\n    col=clamp(col,0.,1.);\n  \n  col+=circle(fragCoord,vec2(iResolution.x/2.+sin(iTime*2.)*100.,iResolution.y/2.+cos(iTime*2.)*100.),50.,10.);\n    col=clamp(col,0.,1.);\n  \n  col*=vec3(abs(sin(iTime)),abs(cos(iTime)),1.-abs(sin(iTime)));\n   // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 256], [258, 258, 315, 365, 984]], "test": "valid"}
{"id": "NlXXWl", "name": "Pattern-WeavedTiles", "author": "aakwewaanaqa", "description": "This is a simulation of fabric pattern.", "tags": ["pattern"], "likes": 0, "viewed": 23, "published": "Public", "date": "1626744568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 colorA = vec4(0.905, 0.445, 0.133, 1.0);\nvec4 colorB = vec4(0.328, 0.209, 0.021, 1.0);\n\nfloat tileSize = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float theta = iTime * 0.05;\n    float x = (floor((uv.x * cos(theta) - uv.y * sin(theta)) / tileSize));\n    float y = (floor((uv.x * sin(theta) + uv.y * cos(theta)) / tileSize));\n    \n    if ((mod((x + y), 4.0)) <= 1.0)\n        fragColor = colorA;\n    else\n        fragColor = colorB;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 174, 226, 559]], "test": "valid"}
{"id": "NlXXWN", "name": "Atmospherical Scattering", "author": "Txoka", "description": "Just an atmosphere scattering light (1 step scattering only)\nUse mouse to move the scene\ntry #define SEE_FROM_INSIDE", "tags": ["raytracing", "sun", "normals", "light", "scattering", "atmosphere", "ssao"], "likes": 9, "viewed": 262, "published": "Public API", "date": "1625669009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TUNING PARAMETERS HAS MADE ME INSANE. PLS APRECIATE THE WORK XD\n\n\n#define R iResolution\n#define time (iTime*0.5)\n\n#define SEE_ATMOSPHERE\n//#define SEE_FROM_INSIDE\n//#define EXPERIMENTAL_PLANET_SHADOW\n//#define CRAPPY_AA\n\n\nstruct ray{\n\tvec3 ro;\n    vec3 rd;\n};\nstruct sph{\n    vec3 c;\n\tfloat r;\n};\n\nconst vec3 center=vec3(0);\n\n#ifdef EXPERIMENTAL_PLANET_SHADOW\nconst int VIEW_SAMPLES=64;\n#else\nconst int VIEW_SAMPLES=25;\n#endif\n\nconst int DEPTH_SAMPLES=8;\n\nconst sph atm=sph(center,1.);\nconst vec3 sunInt=vec3(1.);\nconst sph earth=sph(center,0.5);\nconst vec3 waves=700./vec3(700,510,440);\nconst vec3 RGBScatter=waves*waves*waves*waves;\nconst float scatterStrength=50.;\nconst float densFall=7.;\n\nfloat dot2(vec3 k){return dot(k,k);}\nconst float pi=4.*atan(1.);\n\nfloat phase(float cosTheta) {\n\treturn (1. + cosTheta * cosTheta) / (16.0 * pi);\n}\n\nfloat sphere(ray r, sph s, float n){//sphere ray intersection\n\tvec3 rc = r.ro-s.c;\n\tfloat c = dot(rc, rc) - (s.r*s.r);\n\tfloat b = dot(r.rd, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - n*sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn max(0.,mix(-1., t, st));\n}\n\nfloat suc(ray r,vec3 center,float radius){// sun glare\n    vec3 o=r.ro-center;\n    float a=dot(o,o);\n    float b=dot(r.rd,o);\n    float c=dot(r.rd,r.rd);\n    float k=sqrt(a*c-b*b);\n    float integ=radius*(pi/2.-atan(b,k))/k/3.;\n    integ*=integ;\n    integ*=integ;//not integral anymore but looks great\n    return integ;\n}\n\nfloat density(vec3 p){\n    float l=distance(p,center)-earth.r;\n    l/=atm.r-earth.r;\n    return exp(-l*densFall)*(1.-l);\n}\n\nfloat depth(vec3 s,vec3 e){\n    float d=0.;\n    for(int i=0;i<DEPTH_SAMPLES;i++){\n        vec3 p=s+(e-s)*float(i)/float(DEPTH_SAMPLES);\n        d+=density(p);\n    }\n    return d/float(DEPTH_SAMPLES)*distance(s,e);\n}\n\nvec3 light(ray r,vec3 sunPos,vec3 orig){\n    if(distance(r.ro,center)<atm.r){\n    }else{\n        float d1=sphere(r,atm,1.);\n        if(d1==0.)return orig;\n        r.ro+=r.rd*d1;\n    }\n    float d2=sphere(r,earth,1.);\n    if(d2==0.)d2=sphere(r,atm,-1.);\n    float viewDepth=0.;\n    vec3 l=vec3(0.);\n    for(int i=0;i<VIEW_SAMPLES;i++){\n        vec3 p=r.ro+r.rd*(float(i)+0.5)/float(VIEW_SAMPLES+1)*d2;\n        ray k=ray(p,normalize(sunPos-p));\n        #ifdef EXPERIMENTAL_PLANET_SHADOW\n        if(sphere(k,earth,1.)==0.){\n        #endif\n            float sunDepth=depth(k.ro,k.ro+k.rd*sphere(k,atm,-1.));\n            viewDepth=depth(r.ro,p);\n            vec3 transmitance=exp(-(sunDepth+viewDepth)*RGBScatter);\n        \n        \n            l+=transmitance*density(p)*phase(dot(r.rd,normalize(sunPos-p)));\n        #ifdef EXPERIMENTAL_PLANET_SHADOW\n        }\n        #endif\n    }\n    vec3 origTransmitance=exp(-viewDepth*RGBScatter);\n    return orig*origTransmitance+l/float(VIEW_SAMPLES)*d2*sunInt*RGBScatter*scatterStrength;\n}\n\n\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat starField(vec3 rd){\n    rd*=200.;\n    float col=0.;\n    for(int i=0;i<4;i++){\n        vec3 CellUVs=floor(rd+float(i*1199));\n        vec3 hash=(hash33(CellUVs)*2.-1.)*.8;\n        float hash_magnitude =(1.0-length(hash));\n        vec3 UVgrid=fract(rd)-.5;\n        float radius=clamp(hash_magnitude-.5,0.,1.);\n        float radialGradient=length(UVgrid-hash)/radius;\n        radialGradient=clamp(1.-radialGradient,0.,1.);\n        radialGradient*=radialGradient;\n        col += radialGradient;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n    #ifdef SEE_FROM_INSIDE\n    float uvz=2.;\n    float roz=0.;\n    vec3 pos=vec3(0,0.6,0);\n    #else\n    float uvz=-1.;\n    float roz=-3.;\n    vec3 pos=vec3(0,0,0);\n    #endif\n\n    vec3 uv = vec3((U*2.-R.xy)/R.y,uvz);\n    vec2 m=(iMouse.xy*2.-R.xy)/R.xy;\n    m*=vec2(1,0.5)*pi;\n    //if(iMouse.z<=0.)m=vec2(-iTime/3.,0.05);\n    if(length(iMouse.xy)==0.)m=vec2(0);\n    \n\n    vec3 ro=vec3(0,0,roz);\n    \n    ro.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    ro.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    uv.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    uv.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    \n    \n    O=vec4(0);\n    ray r=ray(ro+pos,normalize(uv-ro));\n    sph sun=sph(vec3(0,10.*vec2(sin(time),cos(time))),1.);\n    O.rgb+=starField(r.rd);\n    //if(sphere(r,sun,1.)>0.)O=vec4(clamp(vec3(0.),vec3(1.),sunInt),1.);\n    O.rgb+=clamp(0.,1000.,suc(r,sun.c,sun.r))*sunInt;\n \n    float d=sphere(r,earth,1.);\n    \n    if(d>0.){\n        vec3 planet;\n        vec3 surf=r.ro+r.rd*d;\n        planet =texture(iChannel0,(surf-center).xz+vec2(0.4,0.1)).rgb*(surf-center).y*(surf-center).y;\n        planet+=texture(iChannel0,(surf-center).xy+vec2(0.1,0.6)).rgb*(surf-center).z*(surf-center).z;\n        planet+=texture(iChannel0,(surf-center).yz+vec2(0.0,0.2)).rgb*(surf-center).x*(surf-center).x;\n        float normal=0.;\n        normal =texture(iChannel1,1.*(surf-center).xz+vec2(0.4,0.1)).r*(surf-center).y*(surf-center).y;\n        normal+=texture(iChannel1,1.*(surf-center).xy+vec2(0.1,0.6)).r*(surf-center).z*(surf-center).z;\n        normal+=texture(iChannel1,1.*(surf-center).yz+vec2(0.0,0.2)).r*(surf-center).x*(surf-center).x;\n        normal*=4.;\n        \n        planet*=4.;\n        planet*=0.03+0.97*smoothstep(-0.1,0.7,(normal*2.-1.)*0.7+dot(normalize(surf-center),normalize(sun.c-surf)));\n        \n        #ifdef CRAPPY_AA\n        //cheap antialiasing\n        float z=length(r.ro-earth.c);\n        float w=z-earth.r;\n        z=sqrt(z*z-earth.r*earth.r);//distance from cam to edge of planet(the point where it aliases)\n        z=(d-z)/(w-z);//1 on the closest point of the sphere to the carmera 0 on the furthest\n        z=smoothstep(10./R.y,90./R.y,z);\n        O.rgb=mix(O.rgb,planet,z);\n        #else\n        O.rgb=planet;\n        #endif\n    }\n    #ifdef SEE_ATMOSPHERE\n    O=vec4(light(r,sun.c,O.rgb),1.);\n    #endif\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 696, 715, 715, 732], [762, 762, 791, 791, 843], [845, 845, 881, 906, 1109], [1111, 1111, 1153, 1165, 1432], [1434, 1434, 1456, 1456, 1556], [1558, 1558, 1585, 1585, 1773], [2804, 2804, 2825, 2825, 2949], [2951, 2951, 2976, 2976, 3470], [3472, 3472, 3512, 3512, 5863]], "test": "error"}
{"id": "NlXXzs", "name": "Box - closest 3D", "author": "iq", "description": "Closest point to a 3D box. Both interior and exterior queries work.  See more primitives here: [url]https://www.shadertoy.com/playlist/wXsSzB[/url]", "tags": ["3d", "sdf", "box", "closest"], "likes": 20, "viewed": 806, "published": "Public API", "date": "1626283334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a 3D box. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\n// Returns the closest point o, a 3D box\n//   p is the point we are at\n//   b is the box radius (3 half side lengths)\n//   The box is axis aligned and centered at the origin. For a box rotated \n//   by M,you need to transform p and the returned point by inverse(M).\nvec3 closestPointToBox( vec3 p, vec3 b )\n{\n    vec3   d = abs(p) - b;\n    float  m = min(0.0,max(d.x,max(d.y,d.z)));\n    return p - vec3(d.x>=m?d.x:0.0,\n                    d.y>=m?d.y:0.0,\n                    d.z>=m?d.z:0.0)*sign(p);\n}\n\n// Alternative implementation\nvec3 closestPointToBox2( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    vec3 s = sign(p);\n\n    // interior\n    vec3 q; float ma;\n                 { q=p; q.x=s.x*b.x; ma=d.x; }\n    if( d.y>ma ) { q=p; q.y=s.y*b.y; ma=d.y; }\n    if( d.z>ma ) { q=p; q.z=s.z*b.z; ma=d.z; }\n    if( ma<0.0 ) return q;\n\n    // exterior\n    return p - s*max(d,0.0);\n}\n\n// If the point is guaranteed to be always outside of the box, you can\n// use closestPointToBoxExterior() instead.\nvec3 closestPointToBoxExterior( vec3 p, vec3 b )\n{\n    return p-sign(p)*max(abs(p)-b,0.0);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//------------------------------------------------------------\n\nvec3 gPoint;\n\nvec2 map( in vec3 pos, bool showSurface )\n{\n    const vec3 box_rad = vec3(1.1,0.5,0.6);\n\n    // compute closest point to gPoint on the surace of the box\n    vec3 closestPoint = closestPointToBox(gPoint, box_rad );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    if( showSurface )\n    {\n    float d = sdBox( pos, box_rad );\n    if( d<res.x ) res =  vec2( d, 3.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n\n    // box edges\n    {\n    float d = sdBoxFrame( pos, box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in bool showSurface )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSurface )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - (1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        gPoint = -sin(time*0.8*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n\n        // make box transparent\n        bool showSurface = ((samp.x+samp.y)&1)==0;\n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXzs.jpg", "access": "shaders20k", "license": "mit", "functions": [[1209, 1475, 1517, 1517, 1710], [1712, 1742, 1785, 1785, 2087], [2089, 2204, 2254, 2254, 2296], [2362, 2433, 2464, 2464, 2555], [2557, 2628, 2675, 2675, 2707], [2709, 2780, 2832, 2832, 2946], [2948, 3019, 3064, 3064, 3352], [3432, 3432, 3475, 3475, 4274], [4276, 4340, 4393, 4393, 4692], [4694, 4756, 4816, 4816, 5189]], "test": "valid"}
{"id": "NlXXzX", "name": "Lighting shader", "author": "tuannt", "description": "Light", "tags": ["shader", "flash"], "likes": 3, "viewed": 91, "published": "Public", "date": "1626145737", "time_retrieved": "2021-10-01T00:00:00", "image_code": " \n#ifdef GL_ES\nprecision lowp float;\n#endif\n// EVEN MORE MODS BY 27\n\n\n\n\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n\nuniform float time;\nuniform vec2 resolution;\n\n\nconst float count = 2.0;\n\n\nfloat Hash( vec2 p, in float s)\n{\n    vec3 p2 = vec3(p.xy,27.0 * abs(sin(s)));\n    return fract(sin(dot(p2,vec3(27.1,61.7, 12.4)))*273758.5453123);\n}\n\n\nfloat noise(in vec2 p, in float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f *= f * (3.0-2.0*f);\n\n\n    return mix(mix(Hash(i + vec2(0.,0.), s), Hash(i + vec2(1.,0.), s),f.x),\n               mix(Hash(i + vec2(0.,1.), s), Hash(i + vec2(1.,1.), s),f.x),\n               f.y) * s;\n}\n\n\nfloat fbm(vec2 p)\n{\n     float v = 0.0;\n     //v += noise(p*1., 0.35);\n     //v += noise(p*2., 0.25);\n     v += noise(p*4., 0.125);\n     v += noise(p*8., 0.0625);\n     return v;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0-1.0;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n  //  uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 finalColor = vec3( 0.0 );\n    for( float i=1.; i < count; ++i )\n    {\n        float t = abs(1.0 / ((uv.x + fbm( uv +iTime +iMouse.x)) * (i*50.0)));\n        finalColor +=  t * vec3( i * 0.075 + 0.9, 0.5, 2.0 );\n    }\n\n    fragColor = vec4( finalColor, 1.0 );\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 223, 223, 339], [342, 342, 378, 378, 631], [634, 634, 653, 653, 813], [817, 817, 874, 924, 1449]], "test": "error"}
{"id": "Nt2SWR", "name": "phase star", "author": "Epromee", "description": "I am new to the shadertoy so it's not one of those cool things but looks funny tho'\nUse the mouse to move it where you want.\nTo reset the star, rollback the time with |< button.", "tags": ["star", "phase"], "likes": 2, "viewed": 35, "published": "Public", "date": "1627462209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat gauss(float x) {\n    return exp(-x * x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 dstCtr = (iMouse.xy / iResolution.xy - vec2(0.5, 0.5));\n    \n    vec2 dst = (iMouse.xy / iResolution.xy - uv);\n    dst.x = -dst.x;\n    \n    dst = (iMouse.xy / iResolution.xy - uv - 1.2 * dstCtr * length(dst));\n    dst.x = -dst.x;\n    \n    float px = acos(dst.x / length(dst)) / PI;\n    \n    float prepx = px;\n    \n    if (dst.y > 0.) px = 2. - px;\n    px = px / 2.;\n    \n    float color;\n    \n    float freq = iTime * 0.3;\n    \n    float superPo;\n    \n    if (floor(freq) == freq)\n        superPo = sin(px * 2. * PI * freq + iTime * 3.20);\n    else\n        superPo =\n            sin(px * 2. * PI * floor(freq) + iTime * 3.20) * (1. - freq + floor(freq))\n            + sin(px * 2. * PI * ceil(freq) + iTime * 3.20) * (freq - floor(freq));\n       \n    \n    \n    color = gauss((5. + 0.2 * sin(iTime * 11.0)) * (1. + superPo * 0.3 - length(dst) * 5.0));\n    \n    //color = abs(1. + superPo * 0.3 - length(dst) * 5.0) < 0.1 ? 1. : 0.;\n    \n    vec2 realColor = vec2(prepx, (1. - prepx));\n    \n    realColor = color * normalize(realColor);\n    \n    fragColor = vec4(realColor.x, realColor.y, 0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2SWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 68, 68, 94], [96, 96, 153, 203, 1354]], "test": "valid"}
{"id": "Nt2SWW", "name": "Spiked Mandelbulb", "author": "lambmeow", "description": "A modified version of the mandelbulb", "tags": ["fractal", "sdf", "mandelbulb", "spike"], "likes": 3, "viewed": 170, "published": "Public API", "date": "1627681493", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nvec2 scene(vec3 p)\n{\n\tfloat po=5.+4.0*(sin(time/30.)+1.);\n\tvec3 z=p;\n\tfloat dr=1.0, r=0.;\n\t//p.xy*=mat2(cos(time),sin(time),-sin(time),cos(time))*p.xz;\n\tfor(int i=0;i<64;i++)\n\t{\n\t\tp.xz*=mat2(cos(time),sin(time),-sin(time),cos(time)) * p.xz;\n\t\tr=length(z);\n\t\tif(r>1.4)break;\n\t\tfloat t=atan(z.z/r), ph = atan(z.y,z.x);\n\t\tdr=pow(r,po-1.)*po*dr+1.;\n\t\tfloat zr=pow(r,po);\n\t\tt*=po;\n\t\tph*=po;\n\t\tz=zr*vec3(sin(t)*cos(ph),sin(ph)*cos(t),cos(t));\n\t\tz+=p;\n\t}\n\treturn vec2(0.5*log(r)*r/dr,r * 25.);\n}\n\nvec4 rc(vec3 ro,vec3 rd) \n{\n\tfloat len=0.;\n\tfor(int i=0;i<255;i++)\n\t{\n\t\tvec3 pos=ro+rd*len;\n\t\tvec2 dist=scene(pos);\n\t\tif(dist.x<0.001) return vec4(pos,dist.y);\n\t\tlen+=dist.x;\n\t\tif(dist.x>100.) break;\n\t}\n\treturn vec4(100);\n}\nvoid mainImage(out vec4 c, in vec2 f)\n{\n\tvec2 r = iResolution.xy, u=((f)*2.- r)/r.y;\n\tvec3 ro=vec3(0,0,-3);\n\tvec3 rd=normalize(vec3(u,2.));\n\tvec4 bulb=rc(ro,rd);\n\tfloat lol=1.-bulb.w+10.;\n\tfloat len=length(bulb.xyz-ro);\n\tc=vec4(bulb.w*0.0052);\n\tc*=1./(len-1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2SWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 40, 40, 508], [510, 510, 537, 537, 733], [734, 734, 773, 773, 996]], "test": "valid"}
{"id": "Nt2Szh", "name": "Winter Glow", "author": "onlinerocker", "description": ":)", "tags": ["sun", "snow"], "likes": 1, "viewed": 60, "published": "Public", "date": "1627081586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TILES 10.0\n#define PI 3.14159265359\n\n//2D random from https://www.shadertoy.com/view/WstGDj\nfloat random (vec2 uv) {\n    return fract(sin(dot(uv, vec2(135., 263.))) * 103.214532);\n}\n\nvec4 drawSnow(vec2 curid, vec2 uv, vec4 fragColor, float r, float c)\n{\n    float maxoff = 2.0 / TILES; //calculate the max offset a particle can have (two tiles)\n\n    //loop through neighboring tiles\n    for(int x=-2; x<=1; x++)\n    {\n        for(int y=-2; y<=0; y++)\n        {\n            float rad = (1.0 / (TILES * 5.0)) * r; //set default radius\n            vec2 id = curid + vec2(x, y); //get the id of the tile we're visiting\n            vec2 pos = id / TILES; //calculate position\n            float xmod = mod(random(pos), maxoff);\n            pos.x += xmod; //add a random x-offset\n            pos.y += mod(random(pos+vec2(4,3)), maxoff); //add a random y-offset\n            rad *= mod(random(pos), 1.0); //vary the radius by multiplying by a random val\n            pos.x += 0.5*(maxoff-xmod)*sin(iTime*r + random(pos)*100.0); //dynamic sin wave x-offset\n            \n            float len = length(uv - pos); //calculate distance from tile's particle\n\n            //if we're inside the particle, draw it\n            float v = smoothstep(0.0, 1.0, (rad - len) / rad*0.75);\n            fragColor = mix(fragColor, vec4(c), v);      \n        }\n    }\n    \n    return fragColor;\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 createRay(vec2 ray, vec2 uv, vec3 col, float delay, float size, float len)\n{\n    vec3 sunCol = vec3(1.0, 0.9, 0.8);\n    float ang = dot(normalize(uv), normalize(ray));\n    ang = 1.0 - ang;\n    ang = ang / size;\n    ang = clamp(ang, 0.0, 1.0);\n    \n    float v = smoothstep(0.0, 1.0, (1.0 - ang)*(1.0 - ang));\n    v *= sin(iTime/2.0 + delay)/2.0 + 0.5;\n    \n    float l = length(uv) * len;\n    l = clamp(l, 0.0, 1.0);\n\n    vec3 o = mix(col, mix(sunCol, col, l), smoothstep(1.0, 4.0, iTime) * v);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.x;\n    uv.y -= 0.3;\n    \n    //uv.x -= 0.6;\n\n    vec3 sunCol = vec3(1.0, 0.9, 0.8);\n    vec3 col = mix(vec3(0.0, 0.45, 0.85), vec3(1), -0.3-uv.y);\n\n    float t = iTime/15.0;\n    mat2 rotTime = mat2( cos(t), sin(t), -sin(t), cos(t) );\n    for(float x=0.0; x < 2.0*PI; x += PI/8.0)\n    {\n        mat2 rot = mat2( cos(x), sin(x), -sin(x), cos(x) );\n        vec2 ray = rotTime * rot * vec2(1.0, 0.0); \n        col = createRay(ray, uv, col, hash11(x*15.0)*10000.0, hash11(x*234.0)*0.04, 2.0+hash11(54.0*x)*2.0);\n    }\n    \n    float l = length(uv)*4.5;\n    l -= 0.2;\n    l = clamp(l, 0.0, 1.0);\n    col = mix(sunCol*1.2, col, smoothstep(0.0, 1.0, l));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    vec4 bg = vec4(.529, .808, .922, 1) * 0.25;\n    vec2 uvNorm = fragCoord.xy / iResolution.xy; //normalized UV coordinate [0, 1]\n    vec2 uvog = fragCoord.xy / iResolution.y; //UV coordinate (will remain static)\n    uv = fragCoord.xy / iResolution.y; //UV coordinate (we'll modify this one)\n    \n    //draw the closest snow layer\n    uv += 0.2*vec2(-iTime, iTime); //move the UV coords based on time\n    vec2 curid = floor(uv * TILES); //calculate the ID associated with the current UV\n    curid += vec2(0.5); //center the ID\n    \n    //if(curid.y > 10.0)\n    {\n    fragColor = drawSnow(curid, uv, fragColor, 1.0, 0.9); //draw closest snow layer\n    \n    //draw the middle snow layer, calculate new UV and ID\n    uv = uvog + 0.1*vec2(-iTime - 100.0, iTime + 100.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.75, 0.45); \n    \n    //draw the far snow layer, calculate new UV and ID\n    uv = uvog + 0.05*vec2(-iTime - 150.0, iTime + 150.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.5, 0.225);\n    \n    fragColor = smoothstep(0.0, 3.0, iTime)*fragColor;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2Szh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 100, 124, 124, 189], [191, 191, 261, 261, 1374], [1376, 1376, 1399, 1399, 1484], [1486, 1486, 1567, 1567, 2001], [2003, 2003, 2060, 2060, 4010]], "test": "valid"}
{"id": "Nt2Szw", "name": "Evolving Snowflake Cube Field", "author": "Pelegefen", "description": "_More options in the defines!_\nA \"Snowflake\" that evolves with time on an hexagonally tilled domain.\nthe cubes are fake shaded, and the wave is achieved by wave manipulation (l:109)", "tags": ["waves", "interactive", "cube", "hexagon", "snowflake", "hexagonal", "tilling"], "likes": 12, "viewed": 219, "published": "Public API", "date": "1627331171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//Made with love by Peleg Gefen <3\n\n\n//#define Time_And_Zoom //Allows you to use the horizontal mouse axis to \"peek into the future\" to see the full evolution of the wave.\n\n\n\n//#define Grass_Like //Animates the cubes in a cool low poly growing grass thing.\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\n\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    //distance to the diagonal line\n    float c = dot(p, normalize(vec2(1., 1.73)));\n\n    // distance to the vertical line\n    c = max(c, p.x);\n    c += sin(iTime + 4000.) *5. +5.;\n    return c;\n  }\n\nvec4 hexCoords(vec2 uv) {\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n\n    vec2 gv;\n    if(length(a) < length(b))\n      gv = a;\n    else\n      gv = b;\n\n    float y = .5 - hexDist(gv);\n    float x = atan(gv.x, gv.y);\n    vec2 id = uv - gv;\n    return vec4(x, y, id.x, id.y);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat iTime = iTime * .25;\n\tiTime += 800.;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)\n\t/iResolution.y;\n    \n    \n     vec4 col = vec4(0.);\n     vec2 uv1 = uv;\n     //uv *= 3.;\n     uv -= 2.;\n     uv *= (sin(iTime * .75)*1.5+1.5) + 3.;\n     uv += vec2(iTime *\t .01);\n\n     #ifdef Time_And_Zoom\n     iTime += iMouse.x * 10.;\n     uv *= iMouse.y * .007;\n     #else\n     uv -= (iMouse.xy / iResolution.xy) * 2. ;\n     #endif\n\n     uv += rot(uv , (cos(iTime)*.5+.5));\n\n \n \n     vec4 uvid = hexCoords(uv * 2.);\n     \n     float t = smoothstep(.5,.5\n \t \t,uvid.y \n \t \t* sin(( length(uvid.zw))\n \t \t * iTime *0.1)*.5+.5);\n   \n    \n\tcol = vec4(\n    t * tan(iTime * .5)*.5+.5 * sin(iTime * 2.5)*.5+.5\n    , t*cos(iTime * .25)*.5+.5* sin(iTime * 5.)*.5+.5\n    , t * sin(iTime * .1275)*.5+.5 * sin(iTime * 10.)*.5+.5\n    ,1.);\n    \n    \n         \n         \n\t//lit face\n\tcol += vec4(smoothstep(.99,.991,uvid.x));\n    \n    \n\t//shading\n\tcol += vec4(smoothstep(-1.,-1.,uvid.x)) * .4;\n\n \t \n \t //hexagons shrinking and expanding, wave form\n \t col *= vec4(smoothstep(.000001,.00001\n \t \t,uvid.y \n        \n        #ifdef Grass_Like\n \t \t* uvid.x\n        #endif\n        * sin(( length(uvid.zw))\n \t \t * iTime *.01)*.5+.5));\n         \n \t \n\tfragColor = vec4( col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2Szw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 357, 384, 384, 459], [463, 463, 486, 486, 701], [703, 703, 728, 728, 1048]], "test": "valid"}
{"id": "Nt2XDR", "name": "Electrocardio(graph)gram", "author": "wildniklin", "description": "Heart go brrr\n60 BPM", "tags": ["graph"], "likes": 4, "viewed": 146, "published": "Public API", "date": "1627441261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float segments = 50.0; // Segments per unit, must be less than (1.0 / thickness), or else will glitch visually, because lines are wider than segments.\nconst float thickness = 0.001; // Line thickness\nconst float gridThickness = 0.01; // Grid line thickness\nconst float scale = 3.0;\n\nfloat sine(float x) {\n    return sin(x * 3.1415);\n}\n\nfloat value(float x) {\n    return pow(sine(((x + iTime) * 0.75) + 0.715), 8.0) * sine((x + iTime) * 6.0 * 0.75);\n}\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nvec2 closestPointLine(vec2 a, vec2 b, vec2 p) {\n    vec2 ab = b - a;\n    float dist = clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n    if(dist <= 0.0) return a;\n    if(dist >= 1.0) return b;\n    return mix(a, b, dist);\n}\n\nfloat distToLine(vec2 a, vec2 b, vec2 p) {\n    return length(p - closestPointLine(a, b, p));\n}\n\nvec2 point(int i, float unit) {\n    float x = (float(i) + 0.5) * unit;\n    return vec2(x, value(x));\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    float un = 1.0 / min(iResolution.x, iResolution.y);\n    \n    un *= scale;\n    \n    vec2 uv = (i - (0.5 * iResolution.xy)) * un;\n    \n    uv *= rot(radians(sin(radians(iTime * 10.0)) * 4.0));\n\n    int ip = int(floor(uv.x * segments));\n    float unit = 1.0 / segments;\n\n    vec2 p0 = point(ip - 2, unit),\n         p1 = point(ip - 1, unit),\n         p2 = point(ip    , unit),\n         p3 = point(ip + 1, unit),\n         p4 = point(ip + 2, unit);\n\n    float dist = min(min(distToLine(p0, p1, uv), distToLine(p1, p2, uv)),\n                     min(distToLine(p2, p3, uv), distToLine(p3, p4, uv))) - thickness;\n\n    vec3 col = vec3(0.1, 0.02, 0.01);\n\n    vec2 f = fract(uv);\n    col = mix(col, vec3(0.4, 0.08, 0.04), min(1.0, smoothstep(un, -un, (1.0 - f.x) - gridThickness) + smoothstep(un, -un, f.x - gridThickness) + smoothstep(un, -un, (1.0 - f.y) - gridThickness) + smoothstep(un, -un, f.y - gridThickness)));\n\n    col = mix(col, vec3(0.8, 0.16, 0.08) * 3.0, smoothstep(un, -un, dist * 0.25));\n\n    col = mix(col, vec3(0.0), smoothstep(0.0, 2.0 * scale, length(uv)));\n    \n    o = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2XDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 289, 310, 310, 340], [342, 342, 364, 364, 456], [458, 458, 477, 477, 543], [545, 545, 592, 592, 767], [769, 769, 811, 811, 863], [969, 969, 1005, 1005, 2107]], "test": "valid"}
{"id": "Nt2XDW", "name": "color bouncyball", "author": "qguv", "description": "simple geometric fragment shader", "tags": ["simple", "geometry"], "likes": 0, "viewed": 27, "published": "Public", "date": "1627692962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define BALL_SIZE .4\n#define BALL_TAPER .09\n#define BALL_LAG 0.1\n\nfloat tri(in float x) {\n    float A = 2.;\n    float P = PI;\n    return (A / P) * (P - abs(mod(x, (2. * P)) - P)) - 1.;\n}\n\nfloat vecmin(in vec2 xy) {\n    return min(xy.x, xy.y);\n}\n\nvec2 pos(in float time) {\n    return vec2(\n        (tri(time) * (1. - BALL_SIZE / 2.)) * (iResolution.x / vecmin(iResolution.xy)),\n        .6 * abs(sin(3. * time)) - .6\n    );\n}\n\nbool ball(in vec2 xy, in int seq) {\n    return length(xy - pos(iTime - BALL_LAG * float(seq))) < BALL_SIZE - BALL_TAPER * float(seq);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 R = iResolution.xy;\n    vec2 p = (2. * fragCoord - R) / vecmin(R);\n\n    fragColor = vec4(\n        float(ball(p, 2)),\n        float(ball(p, 1)),\n        float(ball(p, 0)),\n        1.\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2XDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 111, 111, 208], [210, 210, 236, 236, 266], [268, 268, 293, 293, 445], [447, 447, 482, 482, 582], [584, 584, 639, 639, 839]], "test": "valid"}
{"id": "Nt2XRw", "name": "Raymarching Infinite Blobs", "author": "david_poj", "description": "A classic implementation of raymarching with reflections.", "tags": ["raymarching", "infinity"], "likes": 6, "viewed": 66, "published": "Public", "date": "1627419896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 1000.\n#define SURF_DIST 1e-3\n\nvec4 sdSphere(vec3 p, vec3 bp, float r){\n    p -= bp;\n    float dist = length(p) - r;\n    vec3 color = vec3(1.0, 1.0, 0.0);\n    return vec4(color, dist);\n}\n\nvec4 sdGradCheckPlane(vec3 p, vec3 n, float h){\n    float dist = dot(p, n) + h;\n    vec3 colorA = vec3(1.0,0.0,0.0);\n    vec3 colorB = vec3(0.3, 0.5, 1.0);\n    vec3 AB = mix(colorA, colorB, vec3(abs(p.z/12.)));\n    \n    vec3 q = floor(p);\n    float c = abs(mod((q.x + q.z), 2.0));\n    vec3 color = vec3(c)*AB;\n    return vec4(color, dist);\n}\n\nvec4 sdPlane(vec3 p, vec3 n, float h){\n    float dist = dot(p, n) + h;\n    vec3 color = vec3(1.0,1.0,1.0);\n    return vec4(color, dist);\n}\n\n\n\nvec4 sdInfSphere(vec3 p, vec3 bp, float r, float c){\n    p -= bp;    \n    vec3 q = mod(p+0.5*c, c) - (0.5*c);\n    float dist =  length(q) - r;\n    vec3 color = vec3(0.1, 0.1, .3);\n    float disp = sin(5.0 * p.x) * sin(5.0 * p.y) * cos(5.0 * p.z) * 0.25 * sin(iTime);\n    return vec4(color, dist+disp);\n}\n\nvec4 GetDist(vec3 p){\n    vec4 object;\n    vec4[] objects = vec4[](\n        sdInfSphere(p, vec3(0.,0.,-5), 1., max(3., sin(iTime)*10.0)),\n        sdGradCheckPlane(p, vec3(0,1,0), 1.)\n    );\n    float dist_min = MAX_DIST*MAX_DIST;\n    for (int j = 0; j < objects.length(); j++) {\n        float dist = objects[j].w;\n        if (dist < dist_min) {\n            dist_min = dist;\n            object = objects[j];\n        }\n    }\n\n    return object;\n}\n\n\nvec3 GetNormal(vec3 p){\n    vec2 e = vec2(1e-3, 0.);\n    vec3 n = GetDist(p).w - vec3(\n        GetDist(p - e.xyy).w,\n        GetDist(p - e.yxy).w,\n        GetDist(p - e.yyx).w);\n    return normalize(n);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd){\n    vec4 object;\n    float dist = 0.01;\n    for (int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + dist * rd;\n        object = GetDist(p);\n        dist += object.w;\n        object.w = dist;\n        if (object.w < SURF_DIST || dist > MAX_DIST) break;\n    }\n    return object;\n}\n\nvec4 traceRef(vec3 ro, vec3 rd){\n    vec4 object;\n    float dist = 0.;\n    for (int i = 0; i < (MAX_STEPS/2); i++){\n        vec3 p = ro + dist * rd;\n        object = GetDist(p);\n        dist += object.w;\n        object.w = dist;\n        if (object.w < SURF_DIST || dist > (MAX_DIST/2.)) break;\n    }\n    return object;\n}\n\n//https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = GetDist(ro + rd*t).w;\n        if( h < 0.01)\n            return 0.0;\n        if(h > maxt){\n            return 1.0;\n        }\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        \n    }\n    return res;\n}\n\nvec3 GetLight(vec3 p, vec3 lightPos){\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float diff = clamp(dot(n,l), 0., 1.);\n    \n    float distToLight = length(lightPos - p);\n    float shadow = softshadow(p + (n * 0.015 * 3.), l, 0., min(distToLight,100.), 32.);\n    return vec3(diff*shadow);\n}\n\nvec3 GetRayDir(vec2 uv, vec2 size, float fov){\n    float fovadj = tan(radians(fov) / 2.0);\n    float ar = size.x / size.y;\n    uv.x = (1.0 - (uv.x / size.x)*2.0)* ar * fovadj;\n    uv.y = ((uv.y / size.y)*2.0 - 1.0)* fovadj ;\n    return normalize(vec3(uv, -1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Get Rays\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,2,0);\n    vec3 rd = GetRayDir(fragCoord.xy + 0.5, iResolution.xy, 90.);\n       \n    //First Pass\n    vec4 rm = RayMarch(ro, rd);\n    vec3 p = ro + rm.w * rd;\n    vec3 lightPos = vec3(2,2,-1);\n    vec3 diff = GetLight(p, lightPos)*2.0;\n    col = rm.xyz * diff;\n    \n    //Reflection Pass\n    vec3 norm = GetNormal(p);\n    vec3 rr = reflect(rd, norm);\n    vec3 newp = p + norm*0.1*3.;\n    vec4 refl = RayMarch(newp, rr)*0.9;\n    vec3 diff2 = GetLight(newp + (refl.w * rr), lightPos);\n    col += (refl.xyz * diff2);\n    \n    //Add Fog\n    float fog = smoothstep(0., .95, rm.w / 100.);\n    col = mix(col, vec3(0.3, 0.5, 1.0), fog);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2XRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 109, 109, 224], [226, 226, 273, 273, 567], [569, 569, 607, 607, 707], [711, 711, 763, 763, 1014], [1463, 1463, 1486, 1486, 1667], [1669, 1669, 1701, 1701, 1982], [1984, 1984, 2016, 2016, 2304], [2306, 2372, 2441, 2441, 2838], [2840, 2840, 2877, 2877, 3160], [3162, 3162, 3208, 3208, 3424], [3426, 3426, 3483, 3498, 4229]], "test": "error"}
{"id": "Nt2XW1", "name": "Spiral ,log, arch, ~hyperbolic", "author": "TLC123", "description": "single spiral SDF\nLogarithmic exponent >0\nArchimedes exponent =0\nhyperbolic exponent <0    Bad distance field in center\n \n", "tags": ["2d", "sdf", "spiral", "archimedes", "hyperbolic", "log"], "likes": 6, "viewed": 62, "published": "Public", "date": "1627579810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float  smin( float a, float b,float k )\n{\n    float h =  clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 ) ;\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// handle exponatiated radius\nfloat spiradius(float a,float xpnt)\n{\n float fx = xpnt<0.?\n pow(max(0.,1.-a),1./abs(min(-1.,xpnt-1.) )): pow(max(0.,1.-a),max(1.,xpnt+1.))   ;\n return fx;\n}\n\n//SDF for many types of spiral\nfloat spiral (vec2 p,float radius ,float heigth,float turns ,float xpnt, float start_angle)\n{\n// angle of p \nfloat a0 =mod(1.+atan(p.y,p.x)/6.28318 -start_angle/6.28318 ,1.);\nfloat d=1./0.;\n\n// step trough turns passing angle a0 \n//calculate spiral radius \n//find distande to each crossing\nfor (float i=0.;i<=turns;i++)\n{\n d=min(d , abs(length(p)- spiradius(a0/turns+(i/turns),xpnt)*radius)); \n}\n// spiral outer termination\nd=min(d ,  length(p-vec2(cos(start_angle),sin(start_angle))*radius) ); \n\n// clean center termination in case hyperbolic problems\nd=min(d,length( p));\n// the litte knob at centers\n  d=smin(d,length( p)-radius*0.025,radius*0.1);\nreturn d;\n}\n\n\n\n// sine bob\nfloat sb(float t){\nreturn 1.+sin(iTime*t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p =   (fragCoord*2.0-iResolution.xy)/iResolution.y;\n     \n     \n \n    float d=spiral(p, .1+.5*sb(.1),0.,1.+2.*sb(1./3.),-1.+2.682*sb(.378) ,iTime);\n\n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n \n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2XW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 136], [138, 168, 205, 205, 324], [326, 357, 450, 465, 1019], [1023, 1035, 1053, 1053, 1079], [1081, 1081, 1138, 1174, 1569]], "test": "valid"}
{"id": "Nt2Xzm", "name": "North Star Combiner SDF", "author": "zalo", "description": "Quick Test to see how badly SDF CSG Operations + ellipsoid approximations bastardize the shape of north star combiner.\n\nI primarily focused on the reflecting surfaces; the outline/nose cutout aren't terribly accurate.", "tags": ["sdf", "star", "combiner", "north"], "likes": 0, "viewed": 108, "published": "Public API", "date": "1627351472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Forked from https://www.shadertoy.com/view/tdS3DG\n// Modelled to look like the North Star Combiner Optics\n\n#define AA 2   // make this 3 is you have a fast computer\n\n//------------------------------------------------------------------\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float  k0 = length(p/r);\n    float  k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// prolate ellipsoid defined by two foci and the radius of the minor axis\nfloat sdEllipsoidFoci( in vec3 p, in vec3 f1, in vec3 f2, in float minorAxis ) \n{\n    // Calculate Major Axis\n    float halfLength    = length(f2 - f1) * 0.5;\n    float halfMinorAxis =       minorAxis * 0.5;\n    float halfMajorAxis     = sqrt((halfLength * halfLength) + (halfMinorAxis * halfMinorAxis));\n    vec3  r             = vec3(halfMajorAxis, halfMinorAxis, halfMinorAxis);\n    \n    // Calculate the input point in local space\n    mat3 rotation;\n    rotation[0] = normalize(f1 - f2); // Use Graham-Schmidt to hallucinate y, z bases\n    rotation[1] = normalize(cross(vec3(0,0,1), rotation[0])); // Twist about x doesn't matter  \n    rotation[2] = normalize(cross(rotation[0], rotation[1])); // because Minor Axes are symmetric\n    rotation    = transpose(rotation); // Transpose because GLSL indexes matrices funny\n    rotation    = inverse  (rotation); // Invert to reverse the rotation\n    vec3 localp = (p - ((f1 + f2) * 0.5)) * rotation;\n    \n    return sdEllipsoid(localp , r);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opUnion       ( float d1, float d2 ) { return min( d1,d2); }\nfloat opSubtraction ( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max( d1,d2); }\n\nfloat approxNorthStarCombiner( vec3 p )\n{\n    vec3 lf1 = vec3(-0.02626856, 0.007116468, -0.03609176);\n    vec3 rf1 = vec3( 0.02626856, 0.007116468, -0.03609176);\n    vec3 lf2 = vec3(-0.2060344, 0.05526515, -0.07436727);\n    vec3 rf2 = vec3( 0.2060344, 0.05526515, -0.07436727);\n\n    // Outer and Inner Ellipsoid Surfaces\n    float d11 = sdEllipsoidFoci( p, lf1, lf2, 0.244949 ); // Inner Surfaces\n    float d12 = sdEllipsoidFoci( p, rf1, rf2, 0.244949 );\n    float d31 = d11 - 0.001; // Outer Surfaces\n    float d32 = d12 - 0.001;\n    float d1  = opUnion(d11, d12);\n    float d3  = opUnion(d31, d32);\n    \n    // Subtract inner (reflecting) surface from outer surface\n    d1 = opSubtraction (d1, d3); \n    \n    // Cut out the outer edges of the ellipsoids\n    d1 = opIntersection(d1, sdRoundBox( p + vec3(0.0, 0.015 , -0.11), vec3(0.08, 0.03, 0.075), 0.005 )); \n\n    // Cut out the nose sort of\n    d1 = opSubtraction(     sdRoundBox( p + vec3(0.0, 0.2  ,-0.15), vec3(0.00, 0.2  , 2   ), 0.01 ), d1);\n    \n    // Debug Spheres for Foci\n    //d1 = opUnion(d1, length(p - lf1) - 0.003 );\n    //d1 = opUnion(d1, length(p - lf2) - 0.003 );\n    //d1 = opUnion(d1, length(p - rf1) - 0.003 );\n    //d1 = opUnion(d1, length(p - rf2) - 0.003 );\n    \n    return d1;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 p, int id )\n{\n    // North Star Reflector\n    float d1 = approxNorthStarCombiner(p*0.2); // *0.2 scales it up 5x so it's easier to see\n\n    // Ground Plane\n    float d2 = p.y+0.3;\n    \n    return (d1<d2) ? vec2(d1,1.0) : vec2(d2,2.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, int id )\n{\n    float m = 0.0;\n    float t = 0.0;\n    const float tmax = 100.0;\n    for( int i=0; i<200 && t<tmax; i++ )\n    {\n\t    vec2 h = map( ro+rd*t, id );\n        if( h.x<0.001 ) break;\n        m = h.y;\n        t += h.x;\n    }\n\n    return (t<tmax) ? vec2(t,m) : vec2(0.0);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in int id)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, id ).x;\n        res = min( res, smoothstep(0.0,1.0,8.0*h/t ));\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>5.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in int id )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, id ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, id ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, id ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, id ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int id )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, id).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n \n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, int id )\n{ \n    vec3 col = vec3(0.0);\n    \n    vec2  res = castRay(ro,rd, id);\n\n    if( res.y>0.5 )\n    {\n        float t   = res.x;\n        vec3  pos = ro + t*rd;\n        vec3  nor;\n        float occ;\n\n        // material        \n        if( res.y>1.5 )\n        {\n        \tnor = vec3(0.0,1.0,0.0);\n            col = 0.05*vec3(1.0);\n            col *= 0.7+0.3*checkersGradBox( pos.xz*2.0 );\n            occ = 1.0;\n\n        }\n        else\n        {\n            nor = calcNormal( pos, id );\n            occ = 0.5+0.5*nor.y;\n            col = vec3(0.2);\n        }\n\n        // lighting\n        occ *= calcAO( pos, nor, id );\n\n        vec3  lig = normalize( vec3(-0.5, 1.9, 0.8) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n        float sha = calcSoftshadow( pos, lig, id );\n        sha = sha*sha;\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                    dif * sha *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        //vec3 lin = vec3(0.0);\n        //lin += 2.00*dif*vec3(3.30,2.50,2.00)*sha;\n        //lin += 0.50*amb*vec3(0.30,0.60,1.50)*occ;\n        //lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n        //col = col*lin;\n        //col += 2.00*spe*vec3(3.30,2.50,2.00);\n        \n        col *= 5.0;\n        col *= vec3(0.2,0.3,0.4)*amb*occ + 1.6*vec3(1.0,0.9,0.75)*dif*sha;\n        col += vec3(2.8,2.2,1.8)*spe*3.0;            \n\n\n        \n        //col = mix( col, vec3(0.1), 1.0-exp(-0.03*t) );\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    vec3 ro = vec3( 1.0*cos(0.8*iTime), 0.12, 1.0*sin(0.8*iTime) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv =          ( cross(cu,cw) );\n\n    // scene selection\n    int id = 0;\n\n    // render\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 fc = o + vec2( fragCoord.x, fragCoord.y);\n\t\t#else    \n        vec2 fc = vec2( fragCoord.x, fragCoord.y);\n\t\t#endif\n        vec2 p = (-vec2(iResolution.x,iResolution.y) + 2.0*fc)/iResolution.y;\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd, id );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2Xzm.jpg", "access": "shaders20k", "license": "mit", "functions": [[1317, 1371, 1415, 1415, 1506], [1508, 1582, 1663, 1691, 2573], [2575, 2575, 2620, 2620, 2711], [2713, 2713, 2757, 2757, 2779], [2780, 2780, 2824, 2824, 2846], [2847, 2847, 2891, 2891, 2913], [2915, 2915, 2956, 2956, 4172], [4244, 4244, 4275, 4303, 4498], [4500, 4500, 4548, 4548, 4817], [4820, 4820, 4878, 4878, 5165], [5167, 5167, 5210, 5210, 5434], [5436, 5436, 5489, 5489, 5790], [5793, 5869, 5905, 5926, 6149], [6151, 6151, 6198, 6198, 7890]], "test": "error"}
{"id": "NtBSzR", "name": "Planet Moon System", "author": "napsternxg", "description": "Planet moon system. Moon rotating around planet and planet rotating around a source planet.\nLight source is now external.  \n", "tags": ["space"], "likes": 2, "viewed": 178, "published": "Public API", "date": "1626870781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nfloat sphereDist(vec3 p, vec4 s){\n    float dSphere = length(p - s.xyz) - s.w;\n    return dSphere;\n}\n\n\nfloat getDist(vec3 p){\n    float dO = p.y;\n    float d = dO;\n    \n    vec4 s = vec4(0, 1, 10, 1);\n    //s.xz += vec2(sin(iTime), cos(iTime));\n    dO = sphereDist(p, s);\n    d = min(dO, d);\n    \n    //s = vec4(0, 1, 6, 1);\n    s.xz += 5.*vec2(sin(0.2*iTime), cos(0.2*iTime));\n    s.w = 0.5;\n    dO = sphereDist(p, s);\n    d = min(dO, d);\n    \n    s.xyz += 1.*vec3(-sin(iTime), 0, cos(iTime));\n    //s.xz *= 5.;\n    s.w = 0.3;\n    //s.xz += vec2(sin(iTime), cos(iTime));\n    dO = sphereDist(p, s);\n    d = min(dO, d);\n    \n    \n    \n    return d; \n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + dO*rd;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n\n}\n\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(.01, 0);\n    float d = getDist(p);\n    vec3 n = d - vec3(\n        getDist(p -e.xyy), \n        getDist(p -e.yxy), \n        getDist(p -e.yyx)\n    );\n    return normalize(n);\n}\n\n\nfloat getLight(vec3 p){\n\n    //vec3 lightSource = vec3(10.*sin(iTime), 1., 3.*cos(iTime));\n    vec3 lightSource = vec3(0., 3., 6.);\n    //lightSource.xz += vec2(cos(iTime), sin(iTime));\n    vec3 l = normalize(lightSource - p);\n    vec3 n = getNormal(p);\n    float dif = clamp(dot(l, n), 0., 1.);\n    \n    float d = RayMarch(p + n*SURF_DIST*3., l);\n    if(d < length(p-lightSource)) dif *= 0.1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    //uv -= 0.5; \n    //float aspectRatio = iResolution.x/iResolution.y;\n    //uv.x *= aspectRatio;\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    \n    vec3 p = ro + d*rd;\n    \n    float dif = getLight(p);\n    \n    //col = getNormal(p);\n    //col = vec3(d/6.);\n    col = vec3(dif, dif*dif, dif*dif*dif);\n    //vec3 plane = vec3(uv.x, 0., 0.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 101, 101, 168], [171, 171, 193, 193, 718], [720, 720, 753, 753, 963], [966, 966, 989, 989, 1181], [1184, 1184, 1207, 1274, 1600], [1602, 1602, 1659, 1851, 2411]], "test": "valid"}
{"id": "NtBSzW", "name": "NUS SWS A5T1", "author": "greyishsong", "description": "The task 1 of assignment 5 during summer workshop.", "tags": ["raytracing", "demo"], "likes": 1, "viewed": 70, "published": "Public", "date": "1627142748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//============================================================================\n// PROJECT ID: \n//\n// GROUP NUMBER: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 3;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;\n\n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 0.0, abs(sin(2.0 * iTime)) + 0.7, 0.0 );\n    Sphere[0].radius = 0.7;\n    Sphere[0].materialID = 1;\n\n    // Circling sphere.\n    Sphere[1].center = vec3( 1.5 * cos(iTime), 0.5, 1.5 * sin(iTime) );\n    Sphere[1].radius = 0.5;\n    Sphere[1].materialID = 2;\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    // Transform the ray from world coordinate to the sphere's\n    // object coordinate. To implement this transformation, just\n    // translate the sphere's center to (0, 0, 0), which means to\n    // the translation vector is `-sph.center`. The direction vector\n    // will not change because only translation is involved.\n    vec3 Ro = ray.o - sph.center;\n    vec3 Rd = ray.d;\n\n    // Try to solve the equation ax^2 + bx + c = 0\n    float a = 1.0;\n    float b = 2.0 * dot(Rd, Ro);\n    float c = dot(Ro, Ro) - (sph.radius * sph.radius);\n    float d = b * b - 4.0 * a * c;  // The discriminant.\n    \n    float t0 = tmax + 1.0;\n    if (d < 0.0) {\n        // The equation has no solution, so no intersection.\n        return false;\n    }\n    else if (d == 0.0) {\n        // Only one intersection.\n        t0 = -b / (2.0 * a);\n    }\n    else if (d > 0.0) {\n        // Two intersections. Finally `t0` will be the smaller positive one,\n        // or `tmax+1` if both of them are negitive.\n        float sqrtD = sqrt(d);\n        float t1 = (-b + sqrtD) / (2.0 * a);\n        float t2 = (-b - sqrtD) / (2.0 * a);\n        if (t1 > tmin) t0 = t1;\n        if (t2 > tmin) t0 = min(t0, t2);\n    }\n    if (t0 < tmin || t0 > tmax)\n        return false;\n    \n    // The transformation will not change the t value, so just use `t0` to\n    // compute intersection P in the world space.\n    vec3 p = ray.o + t0 * ray.d;\n    t = t0;\n    hitPos = p;\n    // The normal vector should be computed in the object space, and the\n    // translation does nothing on the normal vector.\n    hitNormal = normalize(p - sph.center);\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 Ro = ray.o - sph.center;\n    vec3 Rd = ray.d;\n\n    float a = 1.0;\n    float b = 2.0 * dot(Rd, Ro);\n    float c = dot(Ro, Ro) - (sph.radius * sph.radius);\n    float d = b * b - 4.0 * a * c;  // The discriminant.\n    \n    float t0 = tmax + 1.0;\n    if (d < 0.0) {\n        return false;\n    }\n    else if (d == 0.0) {\n        t0 = -b / (2.0 * a);\n    }\n    else if (d > 0.0) {\n        float sqrtD = sqrt(d);\n        float t1 = (-b + sqrtD) / (2.0 * a);\n        float t2 = (-b - sqrtD) / (2.0 * a);\n        if (t1 > tmin) t0 = t1;\n        if (t2 > tmin) t0 = min(t0, t2);\n    }\n    if (t0 < tmin || t0 > tmax)\n        return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for (int i = 0; i < NUM_PLANES; ++i) {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit) {\n            hasHitSomething = true;\n            if (temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[i].materialID;\n            }\n        }\n    }\n    for (int i = 0; i < NUM_SPHERES; ++i) {\n        temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit) {\n            hasHitSomething = true;\n            if (temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n        }\n    }\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for (int i = 0; i < NUM_LIGHTS; ++i) {\n        // Make the shadow ray for current light source, the maximum t value represents\n        // the position of light source.\n        Ray_t shadowRay = Ray_t(nearest_hitPos, normalize(Light[i].position - nearest_hitPos));\n        float tmax = distance(Light[i].position, nearest_hitPos);\n        bool inShadow = false;\n        for (int j = 0; j < NUM_PLANES && !inShadow; ++j) {\n            if (IntersectPlane(Plane[j], shadowRay, DEFAULT_TMIN, tmax))\n                inShadow = true;\n        }\n        for (int j = 0; j < NUM_SPHERES && !inShadow; ++j) {\n            if (IntersectSphere(Sphere[j], shadowRay, DEFAULT_TMIN, tmax))\n                inShadow = true;\n        }\n        I_local += PhongLighting(shadowRay.d, nearest_hitNormal, -ray.d, inShadow, Material[nearest_hitMatID], Light[i]);\n    }\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 2.5, 1.0, 2.5 );\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3160, 3342, 3360, 3385, 4970], [4974, 5470, 5624, 5624, 5954], [5958, 6290, 6373, 6373, 6585], [6589, 7107, 7264, 7703, 8996], [9000, 9333, 9418, 9532, 10189], [10193, 10547, 10677, 10677, 11089], [11093, 11882, 11995, 12086, 15990], [15994, 16355, 16412, 16412, 17832]], "test": "valid"}
{"id": "NtBXDz", "name": "Highway to Proxima Centauri", "author": "evvvvil", "description": "Highway to Proxima Centauri - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_\n", "tags": ["tunnel", "demoscene", "glow", "material", "art", "highway", "electricity", "battery", "building", "monumental", "techy", "deco", "nouveau"], "likes": 17, "viewed": 252, "published": "Public", "date": "1627400124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Highway to Proxima Centauri - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"I can smell the pigs around the corner, on the shortness of your breath.\" - Johnny Hobbo and the freight trains\n\nvec2 z,v,e=vec2(.00035,-.00035);float t,tt,b,gg,bb,g,tn=0.,r=1.;vec3 np,bp,pp,op,po,no,al,ld,gr,vp;\nvec4 c=vec4(.85,-3,5,.0);\nfloat bo(vec3 p, vec3 r){ p=abs(p)-r;return max(max(p.x,p.y),p.z); }\nfloat smin(float a,float b,float k){ float h=max(0.,k-abs(a-b));return min(a,b)-0.25*h*h/k;}\nfloat smax(float a,float b,float k){ float h=max(0.,k-abs(-a-b));return max(-a,b)+0.25*h*h/k;}\nvec2 smin( vec2 a, vec2 b,float k ){ float h=clamp(.5+.5*(b.x-a.x)/k,.0,1.);return mix(b,a,h)-k*h*(1.0-h);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p,float ga)\n{\n  p.xy*=r2(sin(p.z*.5)*.2);\n  vec2 h,t=vec2(bo(p,vec3(5,5,20)),1); //MAIN OUTTER BOX  \n  t.x=max(abs(t.x)-.2,abs(abs(p.x)-4.)-1.5); //CUT BOX INTO HOLLOW\n  t.x=max(t.x,-(abs(p.y)-2.)); //CUT MIDDLE OF BOX TO LEAVE JUST CORNERS\n  h=vec2(length(p.xy)-.05,0); //LONG INFINITE THIN CYLINDER ALONG Z AXIS\n  pp=p; //NEW POSTION PP FOR ROTATOR WHICH IS JUST THE CROSS BUILDING THING\n  pp.xy=abs(pp.xy); //SIMETRY CLONE TO GET X cross\n  pp.xy*=r2(-.785);   //GET X CROSS BY ROTATING 45 DEG\n  pp.z=mod(pp.z-tt,10.)-5.;  //INFINITE WHOLE SCENE ALONG Z\n  gr=clamp(cos(pp*15.),-.5,.5)*.01;//GREEBLE\n  float rotator=bo(pp,vec3(.4+gr.y,15,.4+gr.y));  //ROTATOR / CROSS \n  float cut=-(abs(abs(pp.y)-3.)-.5); //CROSS CUT MAIN\n  rotator=max(rotator,cut); //CUT CROSS \n  float cutter=length(pp.xz)-.2+gr.y*2.; \n  rotator=smax(cutter,rotator,.45); //CROSS / ROTATOR CUT CORE\n  vec3 rp=bp=pp;bp.y-=3.; //POSITON FOR LINES ALONG CROSS\n  rp.y=sin(pp.y*7.5)*.2;  //WEIRD SIN REPETITION INSTEAD OF MODULO\n  rp.x=abs(rp.x)-.25;   //REPAET POS ALONG X\n  h.x=min(h.x,.8*max(abs(length(bp)-.7)-.04,-(abs(abs(bp.y)-.15)-.05))); //BLACK SPHERE ENDS\n  rotator=smax(length(rp.xy)-.075,rotator,.05);  //holes in ROTATOR  \n  rp.z=abs(rp.z)-.35;  //REPEAT POS ALONG Z ONCE\n  h.x=smin(h.x,.8*(length(rp.xz-vec2(0,.12+gr.y*5.))-.03),.023); //BLACK GREEBLE LINES  \n  bp=pp;bp.x+=3.;  //BLACK SQUARES ON SIDES AND TOP BOTTOM POSITION\n  float blackSquares=bo(bp-vec3(0,5,0),vec3(1.-gr.z,20,10.)); \n  blackSquares=min(blackSquares,bo(bp-vec3(6.5,0,0),vec3(1.-gr.z,20,10.))); //BLACK SQUARES BOTTOM/TOP AND ON SIDES\n  bp.y=mod(bp.y,.5)-.35;  //CUTTERE POSITION FOR BLACK SQUARES\n  h.x=min(h.x,max(blackSquares,-(abs(bp.y)-.05)));  //CUT BLACK SQUARES OT REVEAL GLOWY CORE INSIDE\n  bp=pp;bp.x=abs(bp.x)-1.; //WHITE BITS OUTTER POSITION\n  bp.z=abs(bp.z)-1.; //REPEAT WHITE BITS ONCE ALONG Z\n  t.x=smin(t.x,.8*max(bo(bp,vec3(.2-gr.y*2.,10,.2+gr.x*3.)),-(abs(bp.x)-.05)),.5); //WHITE BITS OUTTER\n  t.x=smin(rotator,t.x,0.1);  //ADD CROSS / ROTATOR TO WHOLE SCENE\n  t=smin(t,h,.1); //MERGE BOTH MTERIAL IDS TOGETHER WITH SMOOTHMIN VEC2 so not only smin geom but material id too\n  if(length(pp.xz)<.2) tn=texNoise(pp.xy*.5-tt*.3,iChannel0).r*.3; //PERLIN TEXNOISE TO DO ELECTRICTY THING\n  b=sin(pp.y-tt*2.); //SOME DEFORMER\n  bp=pp;bp.xz=abs(bp.xz)-max(0.02,tn-b*.09); //ELECTRICITY POSITION\n  h=vec2(length(bp.xz),2); //GLOW BITS  \n  g+=0.1/(0.1+h.x*h.x*(100.-90.*b))*ga;\n  blackSquares+=.3;  //CHEAP WAY TO GET CORE REUSING THE BLACK SQUARES with distance field offset to push them back\n  g+=0.1/(0.1+blackSquares*blackSquares*30.)*ga; //BLACK SQAURE CORE\n  h.x=min(h.x,blackSquares);\n  vp=mix(vec3(-4.4,1.8,6),vec3(3,-1,6),bb)+cos(tt)*.2; //CAR MOVING POSITON\n  vec3 cap=(p-vp)*4.;//CAR MOVING POSITON\n  cap.z=mod(cap.z+tt*5.,30.)-15.;//CAR MOVING POSITON MADE REPEATED ALONG Z\n  cap.xy*=r2(mix(-.5,-6.5,bb)+cos(tt)); //ROTATE CAR ACCORDINGLY\n  cap.xz*=r2(-cos(tt*.5)*.2);//ROTATE CAR ACCORDINGLY    \n  h.x=min(h.x,max(.7*max(length(rp.xy)-.03+rp.z*.02,abs(pp.z)-max(0.55,0.55+b)),cut)); //WHITE LINES   \n  bp=cap+vec3(0,0,1.);bp.x=abs(bp.x)-.75;  //CAR PIECES POSITION\n  float car=bo(bp,vec3(.2+gr.z*3.,.1-gr.x*5.-gr.z,1.35)); /////////////////////////////CARRRRRR\n  gr=clamp(sin(cap*10.),-.5,.5)*.1; //CAR GREEBLE\n  car=smin(car,bo(cap,vec3(1.+gr.z,.1+gr.z,1)),.5); //CAR PIECE\n  car=smin(car,length(abs(cap)-vec3(0,0,.7))-.6,.5);//CAR PIECE\n  car=smax(length(abs(cap)-vec3(0,0,1.))-.4,car,.5);//CAR CUTTER  \n  float lightTubes=0.7*max(length(bp.xy)-(1.+sin(cap.z*1.5-tt*5.))*.2+(cap.z-1.)*.15,-cap.z+1.1); //CAR GLOW ROCKET ENGINE\n  car=min(car,lightTubes); //CAR GLOW ROCKET ENGINE\n  gg+=0.1/(0.1+lightTubes*lightTubes*(50.+cos(clamp(cap.z,1.,50.)*1.5-tt*5.)*49.))*ga;  //CAR GLOW ROCKET ENGINE ADD GLOW\n  float balls=length(abs(cap)-vec3(0,0,.9))-.4; //BALLS ON FRONT AND BACK OF CAR\n  g+=0.1/(0.1+balls*balls*(50.-sin(abs(cap.z)-tt*5.)*49.))*ga; //GLOW BALLS\n  car=min(car,balls); //GLOW BALLS\n  h.x=min(h.x,car/4.);//ADD CAR TO REST OF SCENE /4. AS IT'S BEEN SCALED DOWN A LOT\n  t=t.x<h.x?t:h;  \n  return t;\n}\nvec2 tr( vec3 ro,vec3 rd)\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x,1.);\n    if(h.x<.0001||t.x>30.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>30.) t.y=-1.;\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);   \n  tt=26.21+mod(iTime,53.);\n  bb=smoothstep(0.,1.,clamp(cos(tt*.35+.3),-.25,.25)*2.+.5);  \n  vec3 ro=mix(vec3(1,-2,10),vec3(-1,1,10),bb),cw=normalize(vec3(cos(tt*.4)*4.,cos(tt*.4)*4.+3.,0)-ro),\n  cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n  co=fo=vec3(.1,.12,.13)-length(uv)*.1-rd.y*.1;\n  ro.xy*=r2(cos(pp.z*.5)*.2);\n  vec3 lp=ro;\n  z=tr(ro,rd);t=z.x;\n  if(z.y>-1.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n    ld=normalize(lp-po);   \n    v=pp.xz*.2;\n    for(int i=0;i<3;i++){\n      v=abs(v)-1.0;\n      v*=r2(ceil(sin(v.y)));\n      v*=2.;\n      r=min(r,ceil(abs(sin(v.x*5.23))-.3));\n    }    \n    al=mix(vec3(.0),vec3(.75)-r,min(1.,z.y));\n    if(z.y>1.) al=vec3(.5);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.),\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.),\n    attn=1.-pow(min(1.,length(lp-po)/10.),4.0);\n    co=attn*mix(sp+al*(a(.1)+.2)*(dif*vec3(1,.86,.7)+s(1.)),fo,min(fr,.5));\n    co=mix(fo,co,exp(-.0003*t*t*t));\n  }\n\tfragColor = vec4(pow(co+g*vec3(1,.5,.1)*.2+gg*.2,vec3(.65)),1);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[442, 442, 467, 467, 510], [511, 511, 547, 547, 603], [604, 604, 640, 640, 698], [699, 699, 735, 735, 806], [807, 807, 824, 824, 867], [868, 868, 906, 906, 1200], [1201, 1201, 1228, 1228, 5300], [5301, 5301, 5328, 5328, 5495], [5591, 5591, 5648, 5648, 6903]], "test": "error"}
{"id": "NtBXWz", "name": "Fake Reflection Shadow Tracer", "author": "lyar_soft", "description": "A ray martcher with volumetric shadows, fogs and ray-tracing-based fake reflections.\n", "tags": ["3d"], "likes": 2, "viewed": 66, "published": "Public", "date": "1627394141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//============================================================================\n// PROJECT ID: SWS3005_ 11\n//\n// GROUP NUMBER: 11\n//\n// STUDENT NAME: Luo Ye'an \n// NUS User ID.: t0922585\n//\n// STUDENT NAME: Wang Xinyu\n// NUS User ID.: t0922507\n//\n// COMMENTS TO GRADER: \n// Implemented ray marching combined with ray tracing to produce soft \n// shadow, volumetric shadow and their reflection images. Ray marching \n// technique for generating shadow and scattering was borrowed from\n// https://www.shadertoy.com/view/XlBSRz.\n//\n// If the frame rate is too low, try to set NUM_ITERATIONS to 1, which\n// will completely disable reflection.\n//\n// Press down arrow or up arrow to add dynamic light sources.\n//\n//============================================================================\n\n\nconst float PI = 3.1415926536;\nconst float FOVY = 50.0 * PI / 180.0;\nconst vec3 BACKGROUND_COLOR = vec3( 0.0, 0.0, 0.0 );\nconst float DEFAULT_TMIN = 10.0e-4;\nconst float DEFAULT_TMAX = 10.0e6;\nconst int NUM_ITERATIONS = 3;\nint lightLimit = 1;\n\n\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel1, vec2(key, 0.5/3.0) ).x > 0.5;\n}\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n    float shadowCasting;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n    float shadowCasting;\n};\n\nstruct SphereFog_t {\n    vec3 center;\n    float radius;\n    float shadowCasting;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n    float strength;\n};\n\nstruct LightingSlot{\n    vec3 texColor;\n    vec3 amb;\n    vec3 krg;\n    vec3 lightAndShadow;\n    vec4 scatter;\n    vec3 hitNormal;\n    int mat_id;\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 7;\nconst int NUM_PLANES = 6;\nconst int NUM_SPHERES = 3;\nconst int NUM_SPHERE_FOGS = 1;\n\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nSphereFog_t SphereFog[NUM_SPHERE_FOGS];\n\n\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    bool intersect = false;\n    float delta = 0.0;\n    float inter = dot(ray.d, ray.o - sph.center);\n    float dirDot = dot(ray.o - sph.center, ray.o - sph.center);\n    float root = 0.0;\n    float t1 = 0.0, t2 = 0.0, minT = DEFAULT_TMAX;\n    float lenSquare = dot(ray.d, ray.d);\n    delta = inter * inter - dirDot + sph.radius * sph.radius;\n    if(delta >= 0.0){\n        root = sqrt(delta);\n        t1 = (-inter - root) / lenSquare;\n        t2 = (-inter + root) / lenSquare;\n        if(tmin < t1 && t1 < tmax && t1 < minT){\n            minT = t1;\n            intersect = true;\n        }\n        if(tmin < t2 && t2 < tmax && t2 < minT){\n            minT = t2;\n            intersect = true;\n        }\n        t = minT;\n        hitPos = ray.o + t * ray.d;\n        hitNormal = normalize(hitPos - sph.center);\n    }\n    else{\n        intersect = false;\n    }\n    return intersect;  // Replace this with your code.\n}\n\n\nvoid InitScene()\n{\n    \n    Plane[0].A = 1.0;\n    Plane[0].B = 0.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 1;\n\n\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = -1.0;\n    Plane[1].D = 0.0;\n    Plane[1].materialID = 0;\n\n    Plane[2].A = 0.0;\n    Plane[2].B = 1.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 0.0;\n    Plane[2].materialID = 6;\n\n    Plane[3].A = 0.0;\n    Plane[3].B = -1.0;\n    Plane[3].C = 0.0;\n    Plane[3].D = 60.0;\n    Plane[3].materialID = 6;\n\n    Plane[4].A = -1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = 50.0;\n    Plane[4].materialID = 3;\n\n    Plane[5].A = 0.0;\n    Plane[5].B = 0.0;\n    Plane[5].C = 1.0;\n    Plane[5].D = -60.0;\n    Plane[5].materialID = 6;\n\n    Sphere[0].center = vec3( 40.0, 20.0 + 10.0 * sin(iTime), -20.0 );\n    Sphere[0].radius = 5.0;\n    Sphere[0].materialID = 4;\n    Sphere[0].shadowCasting = 5.0;\n    if(isKeyPressed(KEY_RIGHT)) Sphere[0].center = vec3( 40.0, 20.0 + 10.0, -20.0 );\n\n    Sphere[1].center = vec3( 10.0, 10.0 + 10.0 * cos(iTime), -20.0 );\n    Sphere[1].radius = 5.0;\n    Sphere[1].materialID = 2;\n    Sphere[1].shadowCasting = 5.0;\n    if(isKeyPressed(KEY_RIGHT)) Sphere[1].center = vec3( 10.0, 10.0 + 10.0, -20.0 );\n\n    Sphere[2].center = vec3( 25.0, 15.0 + 10.0 * sin(iTime), -20.0 );\n    Sphere[2].radius = 5.0;\n    Sphere[2].materialID = 1;\n    Sphere[2].shadowCasting = 5.0;\n    if(isKeyPressed(KEY_RIGHT)) Sphere[2].center = vec3( 25.0, 15.0 + 10.0, -20.0 );\n\n    SphereFog[0].center = vec3(20.0, 32.0, -17.0);\n    SphereFog[0].radius = 5.0;\n    SphereFog[0].shadowCasting = 1.0;\n\n    Material[0].k_d = vec3( 1.0, 0.0, 0.0 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    Material[1].k_d = vec3( 1.0, 1.0, 1.0);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 4.0 * Material[1].k_d;\n    Material[1].n = 64.0;\n\n    Material[2].k_d = vec3( 0.0, 0.0, 1.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    Material[3].k_d = vec3( 0.3, 0.9, 0.3 );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = 2.0 * Material[3].k_d;\n    Material[3].k_rg = 1.5 * Material[3].k_d;\n    Material[3].n = 64.0;\n\n    Material[4].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[4].k_a = 0.2 * Material[4].k_d;\n    Material[4].k_r = 2.0 * Material[4].k_d;\n    Material[4].k_rg = 5.0 * Material[4].k_r;\n    Material[4].n = 64.0;\n\n    Material[5].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[5].k_a = 0.2 * Material[5].k_d;\n    Material[5].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[5].k_rg = 0.5 * Material[5].k_r;\n    Material[5].n = 128.0;\n\n    Material[6].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[6].k_a = 0.2 * Material[6].k_d;\n    Material[6].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[6].k_rg = vec3( 0.0 );\n    Material[6].n = 128.0;\n\n    Light[0].position = vec3( 28.0, 40.0,-20.0);\n    if(isKeyPressed(KEY_DOWN)) Light[0].position = vec3( 28.0, 23.0+ 16.0 * sin(0.5 * iTime),-10.0);\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 0.9, 0.5);\n    Light[0].strength = 600.0;\n\n    Light[1].position = vec3( 20.0+15.0, 15.0+12.0*cos(iTime * 0.4),-20.0 -15.0*sin(iTime * 0.4));\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 0.9, 0.5);\n    Light[1].strength = 300.0;\n}\n\nfloat displacementSimple( vec2 p )\n{\n    float f;\n    f  = 0.5000* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.2500* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.1250* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.0625* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    return f;\n}\n\nvec3 getTexColor(vec3 p, in int material, out vec3 amb)\n{\n\tif(material >= 0){\n        amb = Material[material].k_a;\n        return Material[material].k_d;\n    }\n\t\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 evaluateLight(in vec3 pos, in int lightIndex)\n{\n    vec3 lightPos = Light[lightIndex].position;\n    vec3 lightCol = Light[lightIndex].I_source * Light[lightIndex].strength;\n    vec3 L = lightPos-pos;\n    return lightCol * 1.0/dot(L,L);\n}\n\nvec3 evaluateLight(in vec3 pos, in vec3 normal, in int lightIndex)\n{\n    vec3 lightPos = Light[lightIndex].position;\n    vec3 L = lightPos-pos;\n    float distanceToL = length(L);\n    vec3 Lnorm = L/distanceToL;\n    return max(0.0,dot(normal,Lnorm)) * evaluateLight(pos, lightIndex);\n}\n\nvoid SDFLighting(out float sigmaS, out float sigmaE, in vec3 pos)\n{\n    float heightFog = 7.0 + 3.0 * clamp(displacementSimple(pos.xz*0.005 + iTime*0.01),0.0,1.0);\n    heightFog = 0.3* 4.0 *clamp((heightFog-pos.y)*1.0, 0.0, 1.0);\n    \n    const float fogFactor = 1.0 + 0.0 * 5.0;\n    int i = 0;\n    float sphereShadow = 0.0;\n    float planeShadow = 0.0;\n    for(i = 0; i < NUM_SPHERE_FOGS; ++i){\n        sphereShadow += clamp((SphereFog[i].radius - length(pos-SphereFog[i].center))/SphereFog[i].radius, 0.0,1.0) * SphereFog[i].shadowCasting;\n    }\n    for(i = 0; i < NUM_SPHERES; ++i){\n        sphereShadow += clamp((Sphere[i].radius - length(pos-Sphere[i].center))/Sphere[i].radius, 0.0,1.0) * Sphere[i].shadowCasting;\n    }\n    const float constantFog = 0.005;\n    sigmaS = constantFog + heightFog*fogFactor + sphereShadow + planeShadow;\n    sigmaE = max(0.000000001, sigmaS); \n}\n\n\nfloat phaseFunction()\n{\n    return 1.0/(4.0*PI);\n}\n\nfloat volumetricShadow(in vec3 from, in int lightIndex)\n{\n    const float numStep = 32.0;\n    float shadow = 1.0;\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    vec3 to = Light[lightIndex].position;\n    float dd = length(to-from) / numStep;\n\n    for(float s=0.5; s<(numStep-0.1); s+=1.0)\n    {\n        vec3 pos = from + (to-from)*(s/(numStep));\n        SDFLighting(sigmaS, sigmaE, pos);\n        shadow *= exp(-sigmaE * dd);\n    }\n    return shadow;\n}\n\nvoid traceScene(vec3 camPos, vec3 viewDir, out vec3 clr)\n{\n\tconst int numIter = 800;\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    LightingSlot slots[NUM_ITERATIONS];\n    float transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n    \n\tfloat d = 1.0;\n\tint material = 0;\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n    float dd = 0.0;\n    int j = 0;\n    Ray_t ray;\n    vec3 nextView = normalize(viewDir);\n    vec3 nextPos = camPos;\n    vec3 amb;\n    int rayLevel = 0;\n    vec3 compounded_k_rg = vec3(1.0);\n    vec3 finalPos = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    \n        for (rayLevel = 0; rayLevel < NUM_ITERATIONS; ++rayLevel){\n            ray.o = nextPos;\n            ray.d = nextView;\n            int i = 0;\n\n            bool hasHitSomething = false;\n            float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n            vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n            vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n            int nearest_hitMatID = 0;             // MaterialID of the object at the nearest hit point.\n\n            float temp_t;\n            vec3 temp_hitPos;\n            vec3 temp_hitNormal;\n            bool temp_hasHit;\n\n            for(i = 0; i < NUM_SPHERES; ++i){\n                temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n                if(temp_hasHit && temp_t < nearest_t){\n                    nearest_t = temp_t;\n                    nearest_hitPos = vec3(temp_hitPos);\n                    nearest_hitNormal = vec3(temp_hitNormal);\n                    nearest_hitMatID = Sphere[i].materialID;\n                    hasHitSomething = true;\n                }\n            }\n\n            for(i = 0; i < NUM_PLANES; ++i){\n                temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n                if(temp_hasHit && temp_t < nearest_t){\n                    nearest_t = temp_t;\n                    nearest_hitPos = vec3(temp_hitPos);\n                    nearest_hitNormal = vec3(temp_hitNormal);\n                    nearest_hitMatID = Plane[i].materialID;\n                    hasHitSomething = true;\n                }\n            }\n\n\t        for(i=0; i<numIter;++i)\n\t        {\n\t        \tp = nextPos + d*nextView;\n                vec3 S = vec3(0.0);\n                for(j = 0; j < lightLimit; ++j){\n                    SDFLighting(sigmaS, sigmaE, p);\n                    S += (evaluateLight(p, j))* sigmaE * phaseFunction()* volumetricShadow(p,j);\n                }\n                vec3 Sint = (S - S * exp(-sigmaE * dd)) / sigmaE;\n                scatteredLight += transmittance * Sint;\n                transmittance *= exp(-sigmaE * dd);\n                dd = min(1.0, nearest_t - d);\n                if(dd<0.02 || d >= nearest_t) break; \n\t        \td += dd;\n\t        }\n            finalPos = nextPos + d*nextView;\n            material = -1;\n            slots[rayLevel].texColor = vec3(0.0);\n            slots[rayLevel].amb = vec3(0.1);\n            slots[rayLevel].krg = vec3(0.0);\n            slots[rayLevel].lightAndShadow = vec3(0.0);\n            slots[rayLevel].scatter = vec4(scatteredLight, transmittance);\n            slots[rayLevel].hitNormal = vec3(0.0);\n            slots[rayLevel].mat_id = -1;\n\t        if(hasHitSomething){\n                finalPos = nextPos + nearest_t * normalize(nextView);\n                normal = nearest_hitNormal;\n                material = nearest_hitMatID;\n            }\n            else {\n                break;\n            }\n            vec3 lightL = vec3(0.0), shadowL = vec3(0.0);\n            for(j = 0; j < lightLimit; ++j){\n                lightL += (evaluateLight(finalPos, normal, j));\n                shadowL += volumetricShadow(finalPos,j);\n            }\n            slots[rayLevel].lightAndShadow = lightL * shadowL;\n            slots[rayLevel].hitNormal = normal;\n            slots[rayLevel].krg = Material[material].k_rg;\n            slots[rayLevel].mat_id = material;\n            slots[rayLevel].texColor = getTexColor(finalPos, material, amb);\n            slots[rayLevel].amb = amb;\n            nextPos = finalPos;\n            nextView = normalize(reflect(nextView, normal));\n            d = 0.0;\n            dd = 0.5;\n        }\n        if(NUM_ITERATIONS > 1){\n            for(; rayLevel >= 1; --rayLevel){\n                vec3 color = (slots[rayLevel].texColor / PI) * slots[rayLevel].lightAndShadow;\n                color = color * slots[rayLevel].scatter.w + slots[rayLevel].scatter.xyz;\n                slots[rayLevel - 1].texColor += color * slots[rayLevel - 1].krg;\n            }\n        }\n        \n    \n    clr = (slots[0].texColor / PI) * slots[0].lightAndShadow;\n    clr += slots[0].amb * 0.05;\n    clr = clr * slots[0].scatter.w + slots[0].scatter.xyz;\n    clr = pow(clr, vec3(1.0/2.2));\n}\n\nvec3 camPos = vec3( 20.0, 38.0,-90.0);\nvec3 cam_lookat = vec3( 20.0, 38.0, 0.0 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    if(isKeyPressed(KEY_LEFT)) camPos = vec3( 20.0, 38.0,-60.0);\n\t\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n    vec3 dir = camPos - cam_lookat;\n    if(isKeyPressed(KEY_UP)){\n        lightLimit = 2;\n    }\n    \n    if(iMouse.x+iMouse.y > 0.0){\n        vec3 ms = (vec3(iMouse.x, iMouse.y, 0.0)-vec3(iResolution.xy*0.5, 0.0)) / 300.0;\n        dir = normalize(dir * mat3(cos(ms.x), 0.0, sin(ms.x), 0.0, 1.0, 0.0, sin(ms.x), 0.0, cos(ms.x)));\n        dir = normalize(dir * mat3(1.0, 0.0, 0.0, 0.0, cos(ms.y), sin(ms.y), 0.0, -sin(ms.y), cos(ms.y)));\n        cam_up_vec = normalize(cam_up_vec * mat3(cos(ms.x), 0.0, sin(ms.x), 0.0, 1.0, 0.0, sin(ms.x), 0.0, cos(ms.x)) * mat3(1.0, 0.0, 0.0, 0.0, cos(ms.y), sin(ms.y), 0.0, -sin(ms.y), cos(ms.y)));\n    }\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 cam_z_axis = normalize( dir);\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n\t\n\tvec3 rD = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n    vec3 cl = vec3( 0.0, 0.0, 0.0 );\n    \n    traceScene(camPos, rD, cl);\n\tfragColor = vec4(cl ,1.0);\n}\n\n\n\n\n\n\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1176, 1176, 1206, 1206, 1265], [2780, 2780, 2934, 2934, 3223], [3226, 3226, 3383, 3383, 4294], [4297, 4297, 4315, 4315, 7842], [7844, 7844, 7880, 7880, 8161], [8163, 8163, 8220, 8220, 8356], [8358, 8358, 8410, 8410, 8600], [8602, 8602, 8670, 8670, 8886], [8888, 8888, 8955, 8955, 9769], [9772, 9772, 9795, 9795, 9822], [9824, 9824, 9881, 9881, 10279], [10281, 10281, 10339, 10339, 15210], [15295, 15295, 15352, 15352, 16670]], "test": "error"}
{"id": "NtfSWH", "name": "Mondrian Dreams", "author": "ZenithGD", "description": "A little twist on Piet Mondrian's particular style. ", "tags": ["abstract", "modern"], "likes": 3, "viewed": 193, "published": "Public API", "date": "1625574763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void drawRectangle(vec2 pos, vec2 e1, vec2 e2, float border_width, \n                    vec4 border_color, vec4 fill_color, inout vec4 color)\n{\n    \n    float scr_ratio = iResolution.y / iResolution.x;\n    \n    float exmax = max(e1.x, e2.x);\n    float exmin = min(e1.x, e2.x);\n    float eymax = max(e1.y, e2.y);\n    float eymin = min(e1.y, e2.y);\n    \n    \n    if ( pos.x >= exmin - border_width / 2. * scr_ratio &&\n         pos.x <= exmax + border_width / 2. * scr_ratio && \n         pos.y >= eymin - border_width / 2. && \n         pos.y <= eymax + border_width / 2.)\n    {\n        if ( pos.x > exmin - border_width / 2. * scr_ratio && pos.x < exmin + border_width / 2. * scr_ratio || \n             pos.x > exmax - border_width / 2. * scr_ratio && pos.x < exmax + border_width / 2. * scr_ratio ||\n             pos.y > eymin - border_width / 2. && pos.y < eymin + border_width / 2. || \n             pos.y > eymax - border_width / 2. && pos.y < eymax + border_width / 2.)\n        {\n            color = border_color;\n        }\n        else color = fill_color;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scr_ratio = iResolution.y / iResolution.x;\n    float b_w = 0.02;\n    \n    vec4 mn_w = vec4(vec3(249.) / 255.0, 1.);\n    vec4 mn_y = vec4(vec3(255., 240., 1.) / 255.0, 1.);\n    vec4 mn_b = vec4(vec3(1., 1., 253.) / 255.0, 1.);\n    vec4 mn_r = vec4(vec3(255., 1., 1.) / 255.0, 1.);\n    vec4 mn_g = vec4(vec3(48., 48., 58.) / 255.0, 1.);\n    \n\n    float width = 0.1;\n    vec2 st = fragCoord.xy/iResolution.xy;\n    \n    vec2 p1 = vec2((sin(iTime) / 4.0 + 0.5) * scr_ratio, (cos(iTime) / 4.0 + 0.5));\n    vec2 p2 = vec2(0.0,p1.y);\n    vec2 p3 = vec2((cos(3. * iTime) / 6.0 + 0.5) * p1.x, 1.0);\n    vec2 p4 = vec2(cos(2. * iTime) / 8.0 + 0.8, sin(iTime + 1.) / 4.0 + 0.5); \n    vec2 p5 = vec2(mix(p1.x, p4.x, 0.5), max(p1.y, p4.y));\n    vec2 p6 = vec2(1.0, mix(p5.y, p3.y, 0.3));\n    vec2 p7 = vec2(p5.x, min(p4.y, p5.y));\n    vec2 p8 = vec2(p5.x, p6.y);\n    vec2 p9 = vec2(mix(p5.x, 1.0, 0.5 + cos(iTime +2.) / 4.), 1.);\n    \n    vec4 color = vec4(1.);\n    \n    drawRectangle(st, vec2(0.0, 0.0), p1, b_w, mn_g, mn_y, color);\n    drawRectangle(st, vec2(0.0, p1.y / 3.0), p1, b_w, mn_g, mn_w, color); \n    drawRectangle(st, p2, p3, b_w, mn_g, mn_b, color);\n    drawRectangle(st, vec2(p1.x, 0.0), p4, b_w, mn_g, mn_w, color);\n    drawRectangle(st, vec2(mix(p1.x, p4.x, 0.7), 0.0), p4, b_w, mn_g, mn_r, color);\n    drawRectangle(st, vec2(p1.x, 0.0), vec2(mix(p1.x, p4.x, 0.7), 2. * p4.y / 3. * (cos(2. * iTime + 2.) / 3. + 0.6666)), b_w, mn_g, mn_b, color);\n    drawRectangle(st, p5, p3, b_w, mn_g, mn_w, color);\n    drawRectangle(st, vec2(p3.x, p1.y), vec2(p1.x, p5.y), b_w, mn_g, mn_r, color);\n    drawRectangle(st, p6, p7, b_w, mn_g, mn_w, color);\n    drawRectangle(st, p7, vec2(p1.x, max(p1.y, p4.y)), b_w, mn_g, mn_y, color);\n    drawRectangle(st, p8, p9, b_w, mn_g, mn_y, color);\n    drawRectangle(st, vec2(p9.x, p6.y), vec2(1.), b_w, mn_g, mn_w, color);\n    drawRectangle(st, p4, vec2(1., p4.y / 2.), b_w, mn_g, mn_b, color);\n    drawRectangle(st, vec2(p4.x, p4.y / 2.), vec2(1., 0.), b_w, mn_g, mn_w, color);\n    \n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 143, 143, 1065], [1067, 1067, 1124, 1124, 3178]], "test": "valid"}
{"id": "NtfXDl", "name": "Voxel Tunnel Example", "author": "Yusef28", "description": "First Voxel shader:\n- Branchless DDA\n- Diffuse & Specular Lighting \n\nIt's a pretty barebones example. The coloring is not entirely correct but it'll do for now. [Fixed!]", "tags": ["3d", "raymarching", "raycasting", "voxel"], "likes": 13, "viewed": 127, "published": "Public", "date": "1626759788", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////\n// Voxel Tunnel Example By Yusef28\n// Purpose: Demonstrates Voxel DDA + Voxel Lighting\n// Well commented and fit for some educational purposes\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// 20-07-2021\n\n// Listening to: Com Truise - Diluted (Compilation Mix)\n\nmat2 rot(float a){\n    float si = sin(iTime);\n    float cs = cos(iTime);\n    return mat2(cs,-si,si,cs);\n}\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\t\nfloat hash31( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p.x+p.y+p.z)*43758.5453123);\n}\nfloat g = 0.;\nbool map(vec3 c) {\n\tvec3 p = floor(vec3(c)) + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    float tunnel = (10. - length(p.xy + vec2(sin(p.z/8.)*6., 0.)));\n    d = max(d, tunnel);\n    if(min(d,tunnel) == tunnel){\n        if(hash31(floor(p)) < 0.2){\n            g += 1./pow(d,1.);\n        }\n    }\n    \n\treturn d < 0.0;\n}\n\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n//putting the raycasting in a function so I can use it\n//for other things\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.xy;\n    //We need the same basic things as for ray casting\n    //but in 3d now\n    \n    //cam origin, cam direction\n    vec3 co = vec3(0.,0.,iTime*6.);\n    vec3 cd = vec3(0.,0.,0.8);\n   // cd.x = sin(co.z/16.)/5.;\n    //projection plane origin(not used? and direction 90 deg to cam dir\n    vec3 po = cd;\n    vec3 pd = cd;\n    //here we can't use the simple perpendicular to cd vector\n    //because we are in 3d, so we really need to develope a set of \n    //basis vectors for this one. Nothing fancy\n    //instead of this: pd.*mat2(0.,-1.,1.,0.);\n    //we'll have this:\n    //decide on a up, we'll be cheap and say it's y = 1.\n    vec3 up = vec3(0.,1.,0.);\n    //right will be a vector perpendicular to both our cd and current up\n    vec3 right = cross(up,cd);\n    //up was just a placeholder for a vector in that plane\n    //the actual up is found by crossing to get a new perpendicular\n    //vector in that plane\n    up = cross(right,cd);\n    //good cd,up,right is our basis and we'll use right and up\n    //as our projection plane very soon\n    \n    //ray origin\n    vec3 rayPos = co;\n    //and ray dir which sums the right and up components based on percentage\n    //the current pixel is along that axis from origin\n    //and a focal length which will just be the cd with a scalar maybe\n    vec3 rayDir = right*uv.x + up*uv.y + cd;\n    rayDir = normalize(rayDir);\n\n\t    \n     vec3 deltaDist = abs(1./rayDir + 0.0001);\n    //the starting int positions for every component\n    //pushing away by 0.5 in every direction which we'll correct later\n    //to give us floor/ceil with less hastle as other methods\n    vec3 mapPos = vec3(floor(rayPos) + 0.5);\n    //sign gives us either 1, -1, or 0?\n    //so it's will allow movements by one unit in or require directions\n    vec3 rayStep = sign(rayDir);\n    vec3 sideDist = ((mapPos - rayPos) + 0.5*(sign(rayDir)))*deltaDist*sign(rayDir);\n\tbvec3 mask;\n\tfloat h;\n    \n\tfor (float i = 0.; i < 124.; i++) {\n        //if we hit something break\n\t\tif (map(mapPos)) break;\n            \n            //we haven't so we get our mask which is just\n            //finding which of the 3 components is closest to us so we can\n            //make a step in that direction\n            //the min will give for y=2,z=3,x=1 -> 2, 1, 1\n            //less than will give True,False,False, always just one true\n            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\t\t//we use mask to update side and start in a branchless manner\n            //by masking out what we want to leave unchanged\n            //step in the chosen direction by one unit\n            sideDist += vec3(mask) * deltaDist;\n            //step along the ray for the chosen ray component, by it's delta\n            //with the right direction\n\t\t\tmapPos += vec3(mask) * rayStep;\n            \n            //and this I was using as a sort of faux distance\n            //to set a far plane\n            h++;\n\t}\n\t\n    //The next few lines I found in shanes voxel shader \n    //which apparently came from iq\n    //this first line...\n    vec3 tCube = (mapPos - rayPos - 0.5*sign(rayDir))/rayDir;\n\t//is the calculation for a perpedicular distance from the\n    //projection plane to the closest side on a given voxel\n    //Here is an example from a 2.5 d raycaster:https://lodev.org/cgtutor/raycasting.html\n    //The code is:\n    //if (side == 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;\n    //else perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;\n    //the only difference between that and what we use,\n    //beside it being 3d, is Lode Vandevenne uses branching.\n    float t = max(tCube.x,max(tCube.y,tCube.z));\n    //This is important. Why can't we just use the euclidean distance?\n    //I don't know but we wont. We'll use this.\n    \n    //Now we can do all the texturing, lighting(norm is -mask*sign(rd))\n    //reflections etc that shane does!\n    \n    //this gives us our point in the world after raycasting\n    vec3 vPos = rayPos + t*rayDir;\n    \n    //this gives us a good -0.5 to 0.5 coord for texturing\n    vec3 fVPos = fract(vPos)-0.5;\n   \n    //for texture\n    float scale = 4.;\n    vec3 color;\n    \n    //for box borders\n    float thickness = 0.4;\n    float outLine;\n    vec3 outLineCol = vec3(0.2);\n    \n    //for specific color\n    float id = hash31(mapPos);\n    vec3 idCol = 0.65+0.5*cos(vec3(4.,2.,1.)/4.+ id*10.);\n    \n    //I could have done this branchless\n    \n\tif (mask.x) {\n\t\tcolor = idCol*texture(iChannel0,fVPos.yz/scale).rrr;\n        outLine = smoothstep(0.05,0.07,max(abs(fVPos.y),abs(fVPos.z))-thickness);\n        color = mix(color, outLineCol,outLine);\n\t}\n\tif (mask.y) {\n\t\tcolor = idCol*texture(iChannel0,fVPos.xz/scale).rrr;\n        outLine = smoothstep(0.05,0.07,max(abs(fVPos.x),abs(fVPos.z))-thickness);\n        color = mix(color, outLineCol,outLine);\n\t}\n\tif (mask.z) {\n\t\tcolor = idCol*texture(iChannel0,fVPos.xy/scale).rrr;\n        outLine = smoothstep(0.05,0.07,max(abs(fVPos.x),abs(fVPos.y))-thickness);\n        color = mix(color, outLineCol,outLine);\n\t}\n     \n    //we know what the normal is\n    vec3 norm = -vec3(mask)*sign(rayDir);\n    \n    //The following Lighting calculations\n    //are based on Shane's\n    //let's throw a light it\n    vec3 lightPos = co + vec3(0.,0.,5.);\n    //light direction\n    vec3 lDir = lightPos - vPos;\n    //dist to light for atten\n    float lDist = max(length(lDir), 0.001);\n    lDir/=lDist;\n    //attenuation, one of a few common approximations\n    float attn = 5./(0.2*lDist+ 0.1*lDist);\n    //the diffuse lighting (how much light hit's the normal we are seeing)\n    //(the normal our ray has hit I mean)\n    float diff = max(dot(lDir,norm),0.0);\n    //specular(how much light bounces off the normal surface\n    //in our direction (we flip light direction since it's hitting the \n    //surface here. And -rayDir because it's heading towards us\n    float specPow = 5. + 15.*outLine;\n    float spec = pow(max(dot(reflect(-lDir,norm),-rayDir), 0.), specPow );\n    \n    //add everything together to create the color\n    color = (diff*color*2. + spec*vec3(0.9,0.6,0.3)*1.)*attn;\n    color = mix( clamp(color, 0., 1.), vec3(0.), smoothstep(50., 85., t));\n    \n\tfragColor.rgb = color;\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfXDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[358, 358, 376, 376, 463], [464, 464, 497, 497, 521], [524, 524, 555, 555, 651], [654, 654, 678, 678, 846], [861, 861, 879, 879, 1230], [1233, 1233, 1265, 1265, 1376], [1454, 1454, 1511, 1558, 7798]], "test": "error"}
{"id": "NtfXRB", "name": "Blobby Cavern", "author": "Taron", "description": "Still not brilliant and way too slow, but good fun for some exploration.\n", "tags": ["raymarching", "blobby", "fractalnoise", "volumn"], "likes": 3, "viewed": 91, "published": "Public", "date": "1625916223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCT 3\nfloat hash(vec3 p)\n{\n\tp  = fract(p * .1337);\n    p += dot(p, p.zyx + 37.36);\n    return fract((p.x + p.y) * p.z);\n}\nfloat noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);  \n    vec3 u = smoothstep(0.,1.,f);\n    \n    vec2 oo = vec2(1.,0.);\n    \n    return mix(mix(mix(hash(i+oo.yyy),hash(i+oo.xyy),u.x),\n                   mix(hash(i+oo.yxy),hash(i+oo.xxy),u.x),u.y),\n               mix(mix(hash(i+oo.yyx),hash(i+oo.xyx),u.x),\n                   mix(hash(i+oo.yxx),hash(i+oo.xxx),u.x),u.y),u.z);\n}\n\nfloat turb(vec3 p, float noiseThreshold, float noiseSoftness, int oct, float dist)\n{\n    float r = 0.0,\n          w = 1.0, \n          s = 1.0,\n          d = 0.0;\n    for (int i=0; i<oct; i++)\n    {\n         r += w * noise(p);\n         d += w;\n         w *= 0.573;\n         p *= 1.677;\n     }\n    r = abs(-1.+2.*r/d);\n    return smoothstep(noiseThreshold,noiseSoftness+noiseThreshold,r)+(.1-dist);\n}\n\nfloat march(vec3 cp, vec3 cd){\n\tfloat dO=1.;\n    vec3 p = cp;\n    vec3 sp = cd;\n    float sf = .05;\n    for(int i=0; i<100; i++) {\n    \tp += sp;\n        float dS = turb(p, .01,.5, OCT, min(.1,dO-1.));\n        sf = (1.*dS)*.1+.01;\n        dO += sf;\n        sp = cd*sf;\n        if(dO>6.|| abs(dS)<0.001){\n            p-=sp;\n            sf = 0.001;\n            sp = cd*sf;\n            int cnt = 0;\n            dS = 1.;\n            while(cnt<10 && dS>0.001){\n                cnt++;\n                dO+=0.001;\n                p+=sp;\n                dS = turb(p, .01,.5, OCT, min(.1,dO-1.));\n            }\n            break;\n        }\n    }\n    \n    return dO;\n}\nvec3 norm(vec3 p, float dist){\n    vec2 oo = vec2(.025,0.);\n    float nx = turb(p+oo.xyy, .0,.5, OCT,dist);\n    float ny = turb(p+oo.yxy, .0,.5, OCT,dist);\n    float nz = turb(p-oo.yyx, .0,.5, OCT,dist);\n    return -normalize(vec3(nx,ny,nz));\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fC )\n{\n    vec2 uv = (fC.xy - iResolution.xy*.5)/iResolution.y;\n    vec2 ms = iMouse.xy/iResolution.xy * 6.28;\n\n    vec3 camera = vec3(0.);\n    vec3 target = vec3(uv*(.5+.5*dot(uv,uv)),.25);\n    target.yz *= Rot(-ms.y+sin(iTime*.25));\n    target.xy *= Rot(-ms.x+cos(iTime*.5));\n     \n    vec3 cdir = normalize(camera-target);\n   \n    vec3 p = camera-vec3(0.,0.,iTime*.25);\n    \n    vec3 col = vec3(0.1,0.6,0.8);\n    \n    float depth = march(p,cdir);\n    if(depth<6.){\n        vec3 s = p+cdir*depth;\n        vec3 l = s-p;\n        float fo = max(0.,1.-.25*dot(l,l));\n        float light = 0.;\n        if(fo>0.){\n            vec3 n = norm(s, 0.1);\n            l = normalize(l);\n            light = (.5+.5*dot(n,l))*fo;\n        }\n        col = mix(vec3(light),col,-.5+depth/4.);\n   }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 34, 34, 129], [130, 130, 154, 154, 526], [528, 528, 612, 612, 926], [928, 928, 958, 958, 1584], [1585, 1585, 1615, 1615, 1829], [1830, 1830, 1849, 1849, 1911], [1913, 1913, 1963, 1963, 2770]], "test": "valid"}
{"id": "NtfXWl", "name": "Fractal 61_gaz", "author": "gaz", "description": "inspired \nhttps://twitter.com/zozuar/status/1417242718204465153\nhttps://twitter.com/kamoshika_vrc/status/1412078324545822721", "tags": ["fractal"], "likes": 7, "viewed": 201, "published": "Public API", "date": "1626747708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.5)*.02*exp(-20.*i*i*e)\n    )\n    {\n        p=g*d;\n        p.z-=15.;\n        p=R(p,normalize(vec3(3,2,1)),iTime*.5);        \n        e=s=3.;\n        for(int j=0;j++<10;)\n            p.xz=abs(p.zx),\n            e=min(\n                e,\n                (length(p.zx+length(p)-3.)-.3)/s\n            ),\n            q=R(normalize(vec3(1,2,3)),vec3(.577),iTime*.7),\n            p=R(p,q,iTime*.3),\n            p-=vec3(1,1.2,1.+sin(iTime)*.5),\n            p*=1.2,\n            s*=1.2;\n        g+=e;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 809]], "test": "valid"}
{"id": "NtjSDD", "name": "Simple Gabor", "author": "Nocks_on", "description": "gabor stimuli", "tags": ["gabor"], "likes": 2, "viewed": 83, "published": "Public", "date": "1627709448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0.0);\n    float angle = PI / 4.0;\n    vec2 n = vec2(cos(angle), sin(angle));\n    \n    // cosine part\n    float lambda = 0.01;\n    float c = cos(dot(n, uv)/lambda + iTime * 10.0);\n    \n    // exponential part\n    float sigma = 0.08;\n    float e = exp(-1.0 * dot(uv, uv)/(sigma*sigma));\n    \n    vec3 bgColor = vec3(0.5, 0.5, 0.5);\n    vec3 amp = vec3(0.5, 0.0, 0.0);\n    \n    col = bgColor + amp * c * e;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 621]], "test": "valid"}
{"id": "NtjSWR", "name": "Ball Motion Test", "author": "csklimowski", "description": "A simple shader for performance testing.", "tags": ["simple"], "likes": 1, "viewed": 39, "published": "Public", "date": "1627423847", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float width = max(1.0, iResolution.x/iResolution.y);\n    float height = max(1.0, iResolution.y/iResolution.x);\n    vec2 coords = vec2(gl_FragCoord.x * width, (iResolution.y - gl_FragCoord.y)*height)/iResolution.xy;\n    coords += vec2(cos(iTime*3.0),sin(iTime*2.0))*0.35;\n    vec2 dist = coords - vec2(width/2.0, height/2.0);\n    vec3 color = 1.0 - vec3(smoothstep(0.01, 0.011, dot(dist, dist)));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 492]], "test": "valid"}
{"id": "NtjSz1", "name": "Bittrium", "author": "sk7725", "description": "Simple shader for stuff.", "tags": ["simple", "colorful"], "likes": 2, "viewed": 36, "published": "Public", "date": "1627090966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n \tvec4 color = vec4(1., 1., 1., 1.);\n\n    //vec4 color = texture2D(u_texture, v_texCoords.xy);\n\tvec2 pos = FragCoord.xy - 2. * iMouse.xy;\n\n\tfloat t = clamp((sin(iTime * .01 + pos.x * .01 + pos.y * .005) + 1.) / 2., 0., 1.);\n\tvec3 c = vec3(mix(0., 1., t), mix(.89, .39, t), mix(1., .85, t));\n\n    FragColor = vec4(color.rgb * c.rgb, color.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 401]], "test": "valid"}
{"id": "NtjXzh", "name": "Gyroidal Confusion [livecode]", "author": "Tater", "description": "aaaaaaaaa code messy, fun event. big thanks to Monsieur Soleil for organizing, I'll update with vod when available. \n\nthe fft on shadertoy is a bit messed up, sorry.", "tags": ["3d", "raymarching", "gyroid", "soundcloud", "twitch", "livecode", "shaderjam"], "likes": 5, "viewed": 195, "published": "Public API", "date": "1627080368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define STEPS 164.0\n#define MDIST 200.0\n#define time iTime\n#define pmod(p,x) (mod(p,x)-(x)*0.5)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\nfloat g1 = 0.0;\nfloat anim(){\n  return fract(time*0.15);\n}\nfloat smin(float a, float b, float k){\n  float h = max(0.0,k-abs(a-b));\n  return min(a,b)-h*h*0.25/k;\n}\n\nfloat smax(float a, float b, float k){\n  float h = max(0.0,k-abs(a-b));\n  return max(a,b)-h*h*0.25/k;\n}\n\nfloat gy(vec3 p){\n  return dot(sin(p.xyz),cos(p.yzx));\n}\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec2 map(vec3 p){\n  vec3 po = p;\n  float streamfft = 0.02;\n  float t = mod(time,300.0);\n  vec2 a = vec2(0);\n  vec2 b = vec2(1);\n  //bottom plane gyroid\n  \n  b.x = gy(p*2.0+(t*2.0+5.0*texelFetch( iChannel0, ivec2(64,0), 0 ).x*vec3(1,-1,0)));\n  b.x*=0.55;\n  //bottom plane\n  a.x = p.y+1.0-sin(p.x*2.5+t)*0.15-sin(p.z*2.5+t)*0.05;\n  \n  a.x = max(b.x,a.x);\n  \n  float voff = texelFetch( iChannel0, ivec2(16.0,0), 0 ).x*streamfft*1.5;\n  //voff=clamp(voff,0.0,12.0/800.0);\n  //ball gyriod\n  float ballsize = 2.5;\n  if(anim()>0.5){\n    //p.xz = pmod(p.xz,30.0);\n    ballsize = 3.0+voff*500.0;\n    \n  }\n  ballsize = clamp(ballsize,1.5,15.0);\n  b.x = abs(abs(gy(-p*3.0+t+8.0*streamfft*texelFetch( iChannel0, ivec2(64,0), 0 ).x))-0.6)-0.2;\n  b.x*=0.4;\n  //ball\n  \n  //p.y = pmod(p.y+sin(t)*3.0,10.0);\n  p.xz*=rot(t);\n  //p.yz*=rot(t);\n  float ballcut = box(p-vec3(0,1.0+voff*125.0,0),vec3(ballsize));\n  p = po;\n  ballcut = mix(ballcut, length(p-vec3(0,voff*125.0,0))-ballsize,sin(time*2.0)*0.5+0.5);\n  b.x = smax(b.x,ballcut,0.2);\n  p = po;\n  \n  a = (a.x<b.x)?a:b;\n  t*=0.5;\n  float tt = pow(fract(t),3.0)+floor(t);\n  \n  tt*=pi/2.0;\n  \n  b.y = 2.0;\n  p.xy*=rot(tt);\n  \n  float moddist = 20.0+voff*500.0;\n  p.xz = pmod(p.xz,moddist);\n  b.x = length(p.xz)-1.5-clamp(sin(p.y*1.5),0.0,0.2);\n  a = (a.x<b.x)?a:b;\n  p = po;\n  \n  p.xy*=rot(tt);\n  p.xy = pmod(p.xy,moddist);\n  b.x = length(p.xy)-1.5-clamp(sin(p.z*1.5),0.0,0.2);\n  a = (a.x<b.x)?a:b;\n  \n  p = po;\n  \n  p.xy*=rot(tt);\n  p.yz = pmod(p.yz,moddist);\n  b.x = length(p.yz)-1.5-clamp(sin(p.x*1.5),0.0,0.2);\n  a = (a.x<b.x)?a:b;\n  p = po;\n  t = iTime;\n  \n  p-=vec3(0,t*5.0,0);\n  p=pmod(p,23.0);\n  \n  b.x = length(p)-2.0;\n  g1+=0.01/(0.01+b.x*b.x);\n  a = (a.x<b.x)?a:b;\n  \n  \n  return a;\n}\nvec3 norm(vec3 p){\n  vec2 e = vec2(0.01,0.0);\n  return normalize(map(p).x - vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 col= vec3(0.0);\n  float t = time;\n  vec3 ro = vec3(0,3,-17);\n  vec3 rd = normalize(vec3(uv,1.0));\n  if(anim()>0.5){\n    ro = vec3(0,100,0);\n    uv.xy*=rot(time);\n    rd = normalize(vec3(uv,1.0));\n    rd.yz*=rot(-pi/2.0);\n    \n  }\nelse{\n  rd.yz*=rot(-0.25);\n   ro.xz*=rot(t*0.4);\n  rd.xz*=rot(t*0.4);\n}\n\n  \n  \n \n  float shad,dO;\n  vec2 d;\n  vec3 p = ro;\n  bool hit = false;\n  for(float i = 0.0; i <STEPS; i++){\n    \n    p = ro+rd*dO;\n    d = map(p);\n    d.x = max(-(length(p-vec3(ro))-5.0),d.x);\n    dO+=d.x*.9;\n    \n    if(abs(d.x)<0.01){\n      shad = i/STEPS;\n      hit = true;\n      break;\n    }\n    if(dO>MDIST){\n      break;\n    }\n    if(i == STEPS-1.0){\n      hit = true;\n    }\n  }\n  vec3 al = vec3(0);\n  vec3 n = norm(p);\n  vec3 ld = normalize(vec3(1));\n  vec3 h = normalize(ld-rd);\n  float spec = pow(max(dot(n,h),0.0),20.0);\n  \n  \n  if(hit){\n    if(d.y == 0.0){\n      al = vec3(0.1,0.3,0.9);\n      col+=spec*0.2;\n      shad = 0.8-shad*4.0;\n    }\n    if(d.y == 1.0){\n      al = vec3(0.9,0.1,0.1);\n      col+=spec*0.3;\n      shad = 0.7-shad*4.0;\n    }\n    if(d.y == 2.0){\n      al = vec3(0.7,0.7,0.9)*0.6;\n      shad = 1.0-shad;\n     \n    }\n    \n  col += vec3(1.0-shad)*al;\n  \n  col = pow(col,vec3(0.8));\n     }\n  col+=g1*vec3(0.3,0.3,0.8)*0.3;\n  col = mix(clamp(col,0.0,1.0),vec3(0.4,0.0,0.0),(dO/MDIST));\n  //uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  \n  //col+=texture(texPreviousFrame,uv*0.5+0.5).rgb*0.3;\n\tfragColor = vec4(col,0.0);\n}\n", "image_inputs": [{"id": "ltlSDS", "previewfilepath": "https://soundcloud.com/surrealrecordings/jkuch-innocence", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/surrealrecordings/jkuch-innocence", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 200, 200, 229], [230, 230, 268, 268, 333], [335, 335, 373, 373, 438], [440, 440, 457, 457, 496], [497, 497, 525, 525, 612], [613, 613, 630, 630, 2341], [2342, 2342, 2360, 2360, 2474], [2475, 2475, 2532, 2532, 4155]], "test": "error"}
{"id": "NtlSDs", "name": "Slisesix (2008)", "author": "iq", "description": "A Shader I made in 2008. While not my first raymarched SDF, this was my first SDF based content creation exercise. Lots of the usual SDF techniques are used, although soft shadows and smooth minimum were not fully evolved yet.", "tags": ["procedural", "3d", "raymarching", "distancefield", "sdf", "demoscene"], "likes": 73, "viewed": 2650, "published": "Public API", "date": "1626923274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2021 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// -------------------------------------------------------\n\n// I made this shader in 2008 for the Euskal Party\n// competition in Spain. The original Pouet entry is \n// here: https://www.pouet.net/prod.php?which=51074\n\n// It's a raymarched SDF, and while I had raymarched some\n// fractal SDFs back in 2005, this was the first time I\n// used the technique to produce art-directed content and\n// \"paint with maths\" (as opposed to doing \"mathematical art\").\n\n// This is also the shader where I first used the now\n// popular ambient occlusion estimation. You'll also find\n// my first attemtps at smooth-minumum (used to blend the\n// creature's head and tentacles together), and soft \n// shadows (still not as good as the ones we use today).\n// You'll find most of the other usual Shadertoy/raymarching\n// stuff - domain repetition, Value Noise, box SDFs and of\n// course the raymarching machinery.\n\n// Surprisngly, copying the code from my original project\n// to Shadertoy here required very little modifications.\n\n\n#define AA 1\n\n#define ZERO min(iFrame,0)\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// https://iquilezles.org/www/articles/sfrand/sfrand.htm\nfloat sfrand( inout int mirand )\n{\n    mirand = mirand*0x343fd+0x269ec3;\n    float res = uintBitsToFloat((uint(mirand)>>9)|0x40000000u ); \n    return( res-3.0 );\n}\n\n// hash by Hugo Elias\nuint ihash( uint n )\n{\n\tn = (n << 13) ^ n;\n    n = (n*(n*n*15731u+789221u)+1376312589u)&0x7fffffffu;\n    return n;\n}\n\n// hash by Hugo Elias\nfloat hash( int n )\n{\n\tn = (n << 13) ^ n;\n    n = (n*(n*n*15731+789221)+1376312589)&0x7fffffff;\n    return 1.0 - float(n)*(1.0/1073741824.0);\n}\n\nfloat noise( vec3 p )\n{\n\tivec3 ip = ivec3(floor(p));\n     vec3 fp = fract(p);\n\n    vec3 w = fp*fp*(3.0-2.0*fp);\n    \n    int n = ip.x + ip.y*57 + 113*ip.z;\n\n\treturn mix(mix(mix( hash(n+(0+57*0+113*0)),\n                        hash(n+(1+57*0+113*0)),w.x),\n                   mix( hash(n+(0+57*1+113*0)),\n                        hash(n+(1+57*1+113*0)),w.x),w.y),\n               mix(mix( hash(n+(0+57*0+113*1)),\n                        hash(n+(1+57*0+113*1)),w.x),\n                   mix( hash(n+(0+57*1+113*1)),\n                        hash(n+(1+57*1+113*1)),w.x),w.y),w.z);\n}\n\n// https://iquilezles.org/www/articles/fbm/fbm.htm\nfloat fbm( vec3 p )\n{\n#if 0\n    // original code\n    return 0.5000*noise( p*1.0 ) + \n           0.2500*noise( p*2.0 ) + \n           0.1250*noise( p*4.0 ) +\n           0.0625*noise( p*8.0 );\n#else\n    // equivalent code, but compiles MUCH faster\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        f += s*noise( p );\n        s *= 0.5;\n        p *= 2.0;\n    }\n    return f;\n#endif\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat udSqBox( vec3 p, vec3 b )\n{\n\tfloat di = 0.0;\n\tfloat dx = abs(p.x)-b.x; if( dx>0.0 ) di+=dx*dx;\n    float dy = abs(p.y)-b.y; if( dy>0.0 ) di+=dy*dy;\n    float dz = abs(p.z)-b.z; if( dz>0.0 ) di+=dz*dz;\n    return di;\n}\n\n//-------------------------------------------------------------------------------\n\nfloat columna( vec3 pos, float offx )\n{\n    float x = pos.x;\n    float y = pos.y;\n    float z = pos.z;\n    \n\tfloat y2=y-0.40;\n    float y3=y-0.35;\n    float y4=y-1.00;\n\n    float di =    udSqBox( vec3(x, y , z), vec3(0.10, 1.00, 0.10) );\n    di = min( di, udSqBox( vec3(x, y , z), vec3(0.12, 0.40, 0.12) ) );\n    di = min( di, udSqBox( vec3(x, y , z), vec3(0.05, 0.35, 0.14) ) );\n    di = min( di, udSqBox( vec3(x, y , z), vec3(0.14, 0.35, 0.05) ) );\n    di = min( di, udSqBox( vec3(x, y4, z), vec3(0.14, 0.02, 0.14) ) );\n    di = min( di, udSqBox( vec3((x-y2)*0.7071, (y2+x)*0.7071, z), vec3(0.10*0.7071,  0.10*0.7071, 0.12) ) );\n    di = min( di, udSqBox( vec3(x, (y2+z)*0.7071, (z-y2)*0.7071), vec3(0.12,  0.10*0.7071, 0.1*0.7071) ) );\n    di = min( di, udSqBox( vec3((x-y3)*0.7071, (y3+x)*0.7071, z), vec3(0.10*0.7071,  0.10*0.7071, 0.14) ) );\n    di = min( di, udSqBox( vec3(x, (y3+z)*0.7071, (z-y3)*0.7071), vec3(0.14,  0.10*0.7071, 0.10*0.7071) ) );\n\n    #if 1\n    float fb = fbm(vec3(10.1*x+offx,10.1*y,10.1*z));\n    if( fb>0.0 )\n        di = di + 0.00000003*fb;\n    #endif\n\n    return sqrt(di);\n}\n\nfloat bicho( vec3 pos, float mindist )\n{\n    pos -= vec3(0.64,0.50,1.5);\n    \n    float r2 = dot2(pos);\n\n\tfloat sa = smoothstep(0.0,0.5,r2);\n    pos *= vec3(0.75,0.80,0.75) + sa*vec3(0.25,0.20,0.25);\n    r2 = dot2(pos);\n\n    if( r2>5.0 ) return mindist;\n    if( pos.y >0.5 ) return mindist;\n\tif( pos.y>-0.2 && dot(pos.xz,pos.xz)>0.6 ) return mindist;\n    if( r2>(1.7+mindist)*(1.7+mindist)  ) return mindist;\t// algo ayuda, poco, pero algo oiga\n\n\tfloat r = sqrt(r2);\n\n\tif( r<0.75 )\n    {\n\tfloat a1 = 1.0-smoothstep( 0.0, 0.75, r );\n\ta1 *= 0.6;\n\tvec2 sico = vec2( sin(a1), cos(a1) );\n\tfloat nx = pos.x;\n\tfloat ny = pos.y;\n\tpos.x = nx*sico.y - ny*sico.x;\n\tpos.y = nx*sico.x + ny*sico.y;\n    }\n\t#define TENTACURA 0.045\n\tfloat mindist2 = 100000.0;\n    vec3  p = pos;\n\tfloat rr = 0.05+length(pos.xz);\n\tfloat ca = (0.5-TENTACURA*0.75) -6.0*rr*exp2(-10.0*rr);\n    for( int j=1+ZERO; j<7; j++ )\n\t{\n\t\tfloat an = (6.2831/7.0) * float(j);\n\t\tfloat aa = an + 0.40*rr*noise(vec3(4.0*rr, 2.5, an)) + 0.29;\n\t\tfloat rc = cos(aa);\n        float rs = sin(aa);\n\t\tvec3 q = vec3( p.x*rc-p.z*rs, p.y+ca, p.x*rs+p.z*rc );\n\t\tfloat dd = dot(q.yz,q.yz);\n\t\tif( q.x>0.0 && q.x<1.5 && dd<mindist2 ) mindist2=dd;\n\t}\n\tfloat dtentacles = sqrt(mindist2) - TENTACURA;\n\n    // proto-smooth-minimum\n\tfloat dhead = r-0.15;\n\n    float h = clamp( r*3.0, 0.0, 1.0 );\n    return mix(dhead-0.15,dtentacles,h);\n}\n\nfloat techo2( float x, float y, float z )\n{\n    y = 1.0 - y;\n    x = x - 0.5;\n    z = z - 0.5;\n    return 0.4 - sqrt(y*y+min(x*x,z*z) );\n}\n\nfloat map( vec3 pos, out uint sid, out uint submat )\n{\n    submat = 0u;\n    float mindist;\n    \n    //-----------------------\n    // suelo\n    //-----------------------\n    {\n\tfloat dis = pos.y;\n\t\n\tfloat ax = 128.0 + (pos.x+pos.z)*6.0;\n\tfloat az = 128.0 + (pos.x-pos.z)*6.0;\n    uint ix = uint(floor(ax));\n    uint iz = uint(floor(az));\n    submat = ihash(ix+53u*iz);\n    bool ba = ( ((submat>>10)&7u)>6u );\n    float peld = max(fract(ax),fract(az));\n    peld = smoothstep( 0.975, 1.0, peld );\n    if( ba ) peld = 1.0;\n    dis += 0.005*peld;\n\tmindist = dis;\n    if( peld>0.0000001 ) sid = 2u; else sid = 0u;\n    }\n    \n    //-----------------------\n    // techo\n    //-----------------------\n\tif( pos.y>1.0 ) \n    {\n        float dis = techo2( fract(pos.x), pos.y, fract(pos.z) );\n        if( dis<mindist )\n        {\n            mindist = dis;\n            sid = 5u;\n        }\n    }\n\n    //-----------------------\n    // columnas\n    //-----------------------\n    {\n\tvec3 fc = vec3(fract( pos.x+0.5 )-0.5, pos.y,\n\t               fract( pos.z+0.5 )-0.5);\n    float bb = udSqBox( fc, vec3(0.14, 1.0, 0.14) );\n    if( bb < mindist*mindist )\n    {\n        float dis = columna( fc, 13.1*floor(pos.x)+17.7*floor(pos.z) );\n        if( dis<mindist )\n        {\n            mindist = dis;\n            sid = 1u;\n        }\n    }\n    }\n    \n    //-----------------------\n    // bicho\n    //-----------------------\n    //if( length( pos-vec3(0.64,-2.1,1.5) ) - 2.8 < mindist )\n    if( dot2( pos-vec3(0.64,-2.1,1.5) ) < (mindist+2.8)*(mindist+2.8) )\n    {\n    float dis = bicho( pos, mindist );\n    if( dis<mindist )\n    {   \n        mindist = dis;\n        sid = 4u;\n    }\n    }\n\n    //-----------------------\n    // baldosas\n    //-----------------------\n    if( pos.y-0.02 < mindist )\n\t{\n\tint kkr = 65535;\n    for( int i=ZERO; i<10; i++ )\n    {\n        float a = 3.14*sfrand(kkr);\n        float co = cos(a);\n        float si = sin(a);\n        float xc = pos.x - (0.5 + 1.5*sfrand(kkr));\n        float zc = pos.z - (1.0 + 1.0*sfrand(kkr));\n        float xo = xc*co-si*zc;\n        float zo = zc*co+si*xc;\n        float dis = sdBox( vec3(xo, pos.y-0.008, zo), vec3(0.07, 0.008, 0.07) );\n        if( dis < mindist ) \n        {\n            mindist = dis;\n            sid = 1u;\n        }\n    }\n\t}\n    \n    return mindist;\n}\n\nvoid raycast( vec3 ro, vec3 rd, float to, float tMax, out float resT, out vec3 resPos, out uint resSurface, out uint submat )\n{\n    float t = to;\n    for( int i=ZERO; i<256; i++ )\n\t{\n        resPos = ro + t*rd;\n\t\tfloat h = map( resPos, resSurface, submat );\n\t\tif( h<0.0001 )\n\t\t{\n\t\t    resT = t;\n\t\t\treturn;\n\t\t}\n        t += h*0.75;\n        if( t>tMax ) break;\n\t}\n    resSurface = 666u;\n}\n\nvec3 calcNormal( vec3 pos )\n{\n#if 0\n    // original code\n    const float eps = 0.0002;\n    uint kk, kk2;\n    vec3 nor = vec3(\n      map( pos.x+eps, pos.y, pos.z, kk, kk2 ) - map( pos.x-eps, pos.y, pos.z, kk, kk2 ),\n      map( pos.x, pos.y+eps, pos.z, kk, kk2 ) - map( pos.x, pos.y-eps, pos.z, kk, kk2 ),\n      map( pos.x, pos.y, pos.z+eps, kk, kk2 ) - map( pos.x, pos.y, pos.z-eps, kk, kk2 ));\n    return normalize(nor);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        uint kk, kk2;\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0002*e, kk, kk2);\n        if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 shade( vec3 pos, vec3 rd, uint matID, uint subMatID, float dis )\n{\n    if( matID==666u ) return vec3(0.0,0.0,0.0);\n\n    vec3 col = vec3(0.1*dis);\n\n    // calc normal\n    vec3 nor = calcNormal( pos );\n\n    // bump mapping\n    #if 1\n    const float kke = 0.0001;\n    float bumpa = 0.0075;\n\tif( matID!=5u ) bumpa *= 0.75;\n    if( matID==4u ) bumpa *= 0.50;\n    bumpa /= kke;\n    float kk = fbm( 32.0*pos );\n    nor.x += bumpa*(fbm( 32.0*vec3(pos.x+kke, pos.y, pos.z) )-kk);\n    nor.y += bumpa*(fbm( 32.0*vec3(pos.x, pos.y+kke, pos.z) )-kk);\n    nor.z += bumpa*(fbm( 32.0*vec3(pos.x, pos.y, pos.z+kke) )-kk);\n    nor = normalize(nor);\n    #endif\n\n\n    // light\n\tfloat spe = 0.0;\n    vec3 lig = vec3( 0.5, 0.8, 1.5 ) - pos;\n    float llig = dot2(lig);\n    float im = 1.0/sqrt(llig);\n    lig *= im;\n    float dif = dot( nor, lig ); \n    if( matID==4u )\n        dif = 0.5+0.5*dif;\n    else\n        dif = 0.10+0.90*dif;\n    dif = max( dif, 0.0 );\n\tdif *= 2.5*exp2( -1.75*llig );\n\tfloat dif2 = (nor.x+nor.y)*0.075;\n\n    // materials\n    if( matID==0u )\n    {\n        float xoff = 13.1 * float(subMatID&255u);\n        float fb = fbm( 16.0*vec3(pos.x+xoff, pos.y, pos.z) );\n\n        col = 0.7 + vec3(0.20,0.22,0.25)*fb;\n\n        float baldscale = float((subMatID>>9)&15u)/14.0;\n        baldscale = 0.51 + 0.34*baldscale;\n        col *= baldscale;\n        float fx = 1.0;\n        if( (subMatID&256u)!=0u ) fx = -1.0;\n        float m = sin( 64.0*pos.z*fx +  64.0*pos.x + 4.0*fb );\n        m = smoothstep( 0.25, 0.5, m ) - smoothstep( 0.5, 0.75, m );\n\n        col += m*0.15;\n    }\n    else if( matID==2u )\n    {\n        col = vec3(0.0,0.0,0.0);\n    }\n    else if( matID==1u )\n    {\n        float fb = fbm( 16.0*pos );\n        float m = sin( 64.0*pos.z +  64.0*pos.x + 4.0*fb );\n        m = smoothstep( 0.3, 0.5, m ) - smoothstep( 0.5, 0.7, m );\n        col = 0.59 + fb*vec3(0.17,0.18,0.21) + m*0.15 + dif2;\n    }   \n    else if( matID==4u )\n    {\n        float ft = fbm( 16.0*pos );\n        col = vec3(0.82,0.73,0.65) + ft*vec3(0.10,0.10,0.15);\n        float fs = 0.90+0.10*fbm( 32.0*pos );\n        col *= fs;\n\n        float fre = -dot( nor, rd );\n        if( fre<0.0 ) fre=0.0;\n        fre = fre*fre*0.45;\n        col -= fre;\n\n\t\tspe = (nor.y-nor.z)*0.707;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe *= 0.20;\n     }   \n    // techo\n    else //if( matID==5 )\n    {\n        float fb = fbm( 16.0*pos );\n        col = vec3(0.64,0.61,0.59) + fb*vec3(0.21,0.19,0.19) + dif2;\n    }   \n\n    // AO\n    float ao;\n    #if 1\n    float totao = 0.0;\n    float sca = 10.0;\n    for( int aoi=ZERO; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.015*float(aoi*aoi);\n        vec3 aopos = pos + hr*nor;\n        uint kk, kk2;\n        float dd = map( aopos, kk, kk2 );\n        ao = -(dd-hr);\n        totao += ao*sca;\n        sca *= 0.5;\n        //if( totao>1000.0+sin(iTime) ) break;\n    }\n    ao = 1.0 - clamp( totao, 0.0, 1.0 );\n    #else\n    ao = 1.0;\n    #endif\n\n    // shadow\n    #if 1\n    float so = 0.0;\n\tfor( int i=ZERO; i<6; i++ )\n    {\n\t\tfloat h = float(i)/6.0;\n        float hr = 0.01 + 1.0*h;\n        vec3 aopos = pos + hr*lig;\n        uint kk, kk2;\n        float dd = map( aopos, kk, kk2 );\n        so += (1.0-h)*dd*20.0/6.0;\n        //if( so>1000.0+iTime ) break;\n    }\n    dif *= clamp( (so-0.40)*1.5, 0.0, 1.0 );\n    #endif\n\n    // shade\n\tfloat ao2 = 0.05 + 0.95*ao;\n    col *= vec3(0.25,0.30,0.35)*ao + dif*ao2*vec3(1.95,1.65,1.05);\n    col += spe;\n    col *= exp2( -0.40*pos.z );\n\n    return col;\n}\n\nvec3 post( vec3 col, vec2 p )\n{\n    // flare\n\tfloat rr = (p.x+0.10)*(p.x+0.10) + (p.y-0.40)*(p.y-0.40);\n    col += vec3( 1.0, 0.95, 0.90 )*0.75*exp2( -64.0*rr );\n\n    // color correct\n    col = sqrt(col)*0.3 + 0.7*col;\n    col *= vec3(0.83,1.00,0.83);\n\n    // vignetting\n    col *= 0.25 + 0.75*clamp( 0.60*abs(p.x-1.77)*abs(p.x+1.77), 0.0, 1.0 );\n    \n    return clamp( col, 0.0, 1.0 );\n}\n\nvec3 computePixel( vec2 p, vec2 res, float time )\n{\n    vec2 s = (2.0*p-res)/res.y;\n    \n    // fisheye distortion\n    float r2 = s.x*s.x*0.32 + s.y*s.y;\n\tfloat tt = (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n\n    // create camera and ray\n    vec2 d = s*tt;\n#if 0\n    vec3 ro = vec3( 0.195, 0.5, 0.0 );\n\tvec3 rd = normalize( vec3( d.x*0.955336 + 0.29552, d.y, 0.955336 - d.x*0.29552 ) );\n#else\n    float an = 4.4 + 0.2*sin(0.4*time);\n    vec3 ta = vec3(0.64,0.50,1.5);\n    vec3 ro = ta + 1.55*vec3( cos(an), 0.0, sin(an));\n    vec3 ww = normalize( ta-ro );\n    vec3 vv = vec3(0.0,1.0,0.0);\n    vec3 uu = normalize(cross(vv,ww));\n    vec3 rd = normalize( uu*d.x + vv*d.y + 1.0*ww );\n#endif\n\tfloat t;\n\tuint matID, sumMatID;\n\tvec3 xyz;\n    \n    // raycast\n\traycast( ro, rd, 0.5, 24.0, t, xyz, matID, sumMatID );\n    \n    // shade\n\tvec3 col = shade(  xyz, rd, matID, sumMatID, t  );\n    \n    // postprocess\n\tcol = post( col, s );\n\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if AA<2    \n    vec3 col = computePixel(fragCoord, iResolution.xy, iTime );\n#else\n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 of = vec2(i,j)/float(AA);\n        float time = iTime + (0.5/30.0)*float(j*AA+i)/float(AA*AA);\n        col += computePixel(fragCoord+of, iResolution.xy, time );\n    }\n    col /= float(AA*AA);\n#endif\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlSDs.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[1694, 1694, 1719, 1719, 1738], [1740, 1797, 1831, 1831, 1960], [1962, 1984, 2006, 2006, 2100], [2102, 2124, 2145, 2145, 2267], [2269, 2269, 2292, 2292, 2843], [2845, 2896, 2917, 2917, 3308], [3310, 3380, 3418, 3418, 3509], [3511, 3581, 3614, 3614, 3804], [3889, 3889, 3928, 3928, 4994], [4996, 4996, 5036, 5036, 6364], [6366, 6366, 6409, 6409, 6504], [6506, 6506, 6560, 6560, 8809], [8811, 8811, 8938, 8938, 9197], [9199, 9199, 9228, 9228, 10006], [10008, 10008, 10079, 10079, 13579], [13581, 13581, 13612, 13625, 13969], [13971, 13971, 14022, 14022, 14904], [14907, 14907, 14964, 14964, 15383]], "test": "valid"}
{"id": "NtlSWN", "name": "Koch Space Glow", "author": "conceptblend", "description": "Folding glow lights over space again and again.", "tags": ["light", "kifs"], "likes": 5, "viewed": 78, "published": "Public", "date": "1625719300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Modified based on KIFS learnings from Art of Code on YouTube.\n * https://youtu.be/il_Qg9AqQkE\n **/\n#define PI 3.14159\n\nfloat sdfLine(vec2 P, vec2 A, vec2 B, float r) {\n    vec2 pa = P-A, ba = B-A;\n    float h = min(1.0,\n              max(0.0,\n                  dot(pa, ba)/\n                  dot(ba, ba)));\n    return length(pa-ba*h) - r;\n}\n\nvec3 lightSpace(vec2 uv) {\n    \n    vec2 A = vec2(-1., -1.);\n        A.y += sin(iTime * .8) * .85;\n\n    vec2 B = vec2(1., 1.);\n       B.y += sin(iTime * .7) * .45;\n    \n    //uv.y = abs(uv.y);\n    \n    vec3 col = vec3(0.);\n    \n    A.x -= 0.5;\n    B.x -= 0.5;\n\n    float strokeWidth = 3. * 1./iResolution.x; // Scale by N units of the X resolution\n    float line1 = sdfLine(uv, A, B, strokeWidth);\n\n    /* BLUE */\n    //line1 = smoothstep(.0, .03, line1);\n    col += (1.-line1) * vec3(.25, .55, 1.);\n    \n    A.x *= -.7;\n    B.x *= -.8;\n\n    /* GREEN */\n    float line2 = sdfLine(uv, A, B, strokeWidth);\n    //col = mix(col, vec3(.0, .95, .33), line2);\n    //line2 = smoothstep(.0, .03, line2);\n    col += (1.-line2) * vec3(.0, .95, .33);\n\n    //A.x -= .5;\n    A.y *= -1.;\n    //B.x -= 1.3;\n    B.y *= -.5;\n\n    /* PINK */\n    float line3 = sdfLine(uv, A, B, strokeWidth);\n    //col = mix(col, vec3(.8, .05, .4), line3);\n    //line3 = smoothstep(.0, .03, line3);\n    col += (1.-line3) * vec3(.8, .05, .4);\n\n    // Output to screen\n    return col * .6;\n}\n\n\nvec2 N(float angle) {\n    return vec2(abs(sin(angle)), cos(angle));\n}\n\nvec3 foldSpace( vec2 uv ) {\n\n    // Reflection angle changes over time\n    float angle = 6./7.*PI;\n    vec2 n = N(angle);\n    float recip = 1./iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    // Reflect x across y\n    uv.x = abs(uv.x);\n    // Move up to adjust for reflection angle `n`\n    uv.y += tan(angle) * .5;\n    \n    //uv.y = abs(uv.y);\n \n    \n    // Move the reflection origin to the right\n    float d = dot(uv - vec2(0.5, 0), n);\n    \n    // Calculate the distance from `uv` to the reflection line\n    uv -= n * max(0., d) * 2.;\n    \n    // Offset X to counter the increment in the first\n    // iteration of the loop.\n    uv.x += .5;\n    \n    n = N(-iTime * 0.26 * PI + PI);\n        \n    float scale = 1.;\n    for (int i=0; i<5; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;  \n\n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        uv -= n * min(0., dot(uv, n)) * 2.;\n        \n        // paint the fold lines\n        //col.rgb += .1 * smoothstep(2.*recip, .0, abs(dot(uv,n))/scale);\n        col += .25 * clamp(lightSpace(uv), .0, .7);\n    }\n \n    // Paint the Koch line\n    //d = length(uv - vec2(clamp(uv.x, -1., 1.), 0.));\n    //col += .5 * smoothstep(4.*recip, .0, d/scale);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n\n    // Initial zoom\n    uv *= .95; //1.05\n    \n    // Fun vertical offset\n    uv.y += .25;\n    \n    // Reflectomatic\n    uv.y = abs(uv.y);\n    \n    // Paint the background\n    col += lightSpace(uv);\n    \n    // Fold and paint more!\n    col += foldSpace(vec2(uv.x, uv.y-.25));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlSWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 174, 174, 347], [349, 349, 375, 375, 1402], [1405, 1405, 1426, 1426, 1474], [1476, 1476, 1503, 1546, 2706], [2708, 2708, 2765, 2765, 3194]], "test": "valid"}
{"id": "NtlSz7", "name": "Endless Tunnel", "author": "EzaExponential", "description": "endless 3d tunnel of circles", "tags": ["circles", "colors", "endless", "spinning", "colours"], "likes": 2, "viewed": 113, "published": "Public", "date": "1625363473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rotate(vec3 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c,-s, s, c);\n\treturn vec3(m * v.xy, v.z);\n}\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) { \n    return length(cross(p-ro, rd))/length(rd);\n} \n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p) { \n    float d = DistLine(ro, rd, p); \n    d = smoothstep(.06, .05, d); \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float t = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; \n    //make 0,0 centre\n    uv -= 0.5;  \n    //correct aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n\n    //camera stuff \n    vec3 camPos = vec3(sin(iTime)/5., cos(iTime)/5., iTime*2.); \n    vec3 ro = camPos; \n    vec3 lookat = vec3(camPos.xy, 1.); \n    float zoom = 1.;\n    vec3 f = normalize(lookat-ro); \n    vec3 r = cross(rotate(vec3(0., 1., 0.), -iTime/4.), f); \n    vec3 u = cross(f, r);     \n    vec3 c = ro + f*zoom; \n    vec3 i = c + uv.x*r + uv.y*u;    \n    vec3 rd = i - ro; \n   \n   \n    float d = 0.;     \n    //8 cube points\n    { \n    for(float i = (floor(camPos.z)) + 1.; i<(floor(camPos.z)) + 100.; i+=0.5){\n    d+= DrawPoint(ro, rd, rotate(vec3(-0.5, -0.5, float(i)), float(i)/2.));  \n    d+= DrawPoint(ro, rd, rotate(vec3(-0.5, 0.5, float(i)), float(i)/2.)); \n    d+= DrawPoint(ro, rd, rotate(vec3(0.5, 0.5, float(i)), float(i)/2.)); \n    d+= DrawPoint(ro, rd, rotate(vec3(0.5, -0.5, float(i)), float(i)/2.));  \n    }\n    } \n    \n    //colour: \n    vec3 col = vec3(abs(sin(iTime + uv.x)), abs(cos(iTime+ uv.y)), abs(sin(iTime*2.3 + uv.x))*2.0);\n    \n    // Output to screen \n    fragColor = vec4(vec3(d) * col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlSz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 127], [129, 129, 171, 171, 221], [224, 224, 267, 267, 354], [356, 356, 413, 413, 1668]], "test": "valid"}
{"id": "NtlXDH", "name": "fft color sphere", "author": "schobbejack", "description": "modulate sphere radius by fft", "tags": ["fft", "polar", "ycbcr"], "likes": 1, "viewed": 101, "published": "Public API", "date": "1625608657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = acos(-1.);\n\nfloat fft(float x)\n{\n\n    float f = texture(iChannel0,vec2(pow(x,1.5)*(1.-pow(cos(x*pi*2.)*.5+.5,30.)),0)).x;\n    float cutoff = 0.25;\n    f = (clamp(f,cutoff,1.0)-cutoff)/(1.-cutoff);\n    return f;\n}\n\nfloat r(vec2 uv)\n{\n    float a = clamp(atan(uv.x,uv.y)/(pi*2.)+.5,0.,1.);\n    float f = clamp(pow(fft(mod(a+.5,1.)),2.)+.15,.1,1.);\n    return 1.-smoothstep(f*.3,f+.05,length(uv)*.75);\n}\n\nvec3 to_rgb(vec3 ycbcr)\n{\n    // full range bt709 matrix\n    const mat3 c709=mat3(1.0000000000, 1.0000000000, 1.0000000000,\n                      0.0000000000, -0.1873242729, 1.8556000000,\n                      1.5748000000, -0.4681242729, 0.0000000000);\n    return c709 * ycbcr;\n}\n\nvec2 rot(vec2 uv, float r)\n{\n    float s=sin(r);\n    float c=cos(r);\n    \n    return vec2(uv.x*c-uv.y*s,uv.x*s+uv.y*c);\n}\n\nvec2 vsphere(float x)\n{\n    return vec2(sin(x*pi),cos(x*pi));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.xy;\n    uv+=vec2(cos(iTime),sin(iTime)+.5)*.2;\n\n\n    float m = r(uv);\n    \n    uv=rot(uv,iTime*pi*.5);\n    float inv = 1./length(uv);\n    uv*=inv;    \n    \n    vec2 cbcr=vsphere(uv.x+iTime)*.3;\n\n    vec3 col=vec3(to_rgb(vec3(inv*.1,cbcr)))*m;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "MlfXDB", "previewfilepath": "https://soundcloud.com/scene_music/unreal-ii", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/scene_music/unreal-ii", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlXDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 49, 49, 229], [231, 231, 249, 249, 417], [419, 419, 444, 475, 700], [702, 702, 730, 730, 823], [825, 825, 848, 848, 888], [890, 890, 939, 939, 1263]], "test": "error"}
{"id": "NtlXWn", "name": "time warp single pass", "author": "teadrinker", "description": "https://www.reddit.com/r/shaders/comments/o7n3x5/is_there_any_possibility_to_make_this_shader_work/\n\nSame shader, but with sine offset: https://www.shadertoy.com/view/ftsSDn", "tags": ["timewarp", "singlepass"], "likes": 2, "viewed": 221, "published": "Public API", "date": "1625468344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float waitPixelRows = 200.;\n    int speed = 1; // higher values will reduce quality\n    int width = 3; \n    vec4 scanColor = vec4(0.4, 1., 0.85,1.);\n    \n    int scanPos = int(mod(float(iFrame * speed), iResolution.y + waitPixelRows));\n    if(int(fragCoord.y) > int(iResolution.y) - scanPos)\n        discard;\n    else if(abs(int(fragCoord.y) + speed*width - (int(iResolution.y) - scanPos)) < width)\n        fragColor = scanColor;\n    else\n        fragColor = texture(iChannel0, vec2(iResolution.x - fragCoord.x, fragCoord.y) / iResolution.xy);\n}\n\n\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlXWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "NtlXzf", "name": "Zi7ar21's KIFS", "author": "Zi7ar21", "description": "This shader looks really good and runs pretty fast!", "tags": ["raymarching", "fractal", "ray", "raymarch", "raymarched", "raymarcher", "kifs", "march"], "likes": 7, "viewed": 241, "published": "Public API", "date": "1626233430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ####### Zi7ar21's KIFS #######\n// Made by Jacob Bingham (Zi7ar21) on July 13th, 2021\n\n// Last Updated on July 13th, 2021 at 21:20 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/NtlXzf\n\n// \"License\":\n// You can use this code in any way you want, as long as you keep credits to things that aren't mine\n// e.g. Triple32: https://nullprogram.com/blog/2018/07/31/\n// We are programmers, not lawyers! :)\n\n/*\nIt's crazy just how simple a KIFS fractal is!\n\nFeatures:\n- KIFS Fractal\n- Ray-Marching\n- Soft Shadows\n- Glow\n- Orbit Trap Colors\n- Animation\n*/\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n// peabrainiac\n// https://www.shadertoy.com/user/peabrainiac\n\n// ##### Parameters #####\n\n// Camera Field of View\n#define camfov 1.0\n\n// Tonemap Exposure\n#define exposure 1.0\n\n// Maximum Ray-Marching Steps\n#define maxStep 128\n\n// Distance Considered a Collision\n#define hitDist 1E-3\n\n// Maximum Ray-Marching Distance\n#define maxDist 4.0\n\n// Maximum Shadow Ray Distance\n#define shadowDist 2.0\n\n// ##### Preprocessor #####\n\n// I don't know if I am using these properly so I will leave them disabled by default\n//#pragma optimize(on)\n//#pragma debug(off)\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.141592653589793\n\n// Traditional Uniform Identifiers\n#define resolution iResolution\n#define frame iFrame\n#define time iTime\n//#define time (float(frame)/60.0)\n//#define time 0.0\n\n// ##### Rendering #####\n\n// Rotate a 3-Component Vector\nvec3 rotate(vec3 vec, vec3 rot)\n{\n    vec3 s = sin(rot), c = cos(rot);\n\n    mat3 rotx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n    mat3 roty = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n    mat3 rotz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    mat3 rotmat = rotx*roty*rotz;\n\n    /*\n    rotmat[0] = normalize(rotmat[0]);\n    rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n    */\n\n    return (vec.x*rotmat[0])+(vec.y*rotmat[1])+(vec.z*rotmat[2]);\n}\n\n// Root Object SDF\nfloat SDF(vec3 pos)\n{\n    // Sphere\n    //return length(pos)-1.0;\n\n    // Cube\n    //pos = abs(pos);\n    return max(max(pos.x, pos.y), pos.z)-1.0;\n}\n\n// Zi7ar21's KIFS SDF: https://www.shadertoy.com/view/NtlXzf\nfloat DE(in vec3 pos, out vec3 orbitTrap)\n{\n    // Fractal Parameters\n    vec3 rot = mod(vec3(time*pi*0.05, -0.5+(time*pi*0.023), 0.3+(time*pi*0.03)), 2.0);\n    //const vec3 rot = vec3(-0.6, -0.5, 0.3);\n    const vec3 translate = vec3(-0.1, -0.23, -0.17);\n    const float scale = 1.3;\n\n    // Set-Up Variables\n    orbitTrap = vec3(10.0);\n    float t = 1.0;\n\n    // Iterate the Fractal\n    for(int i = 0; i < 16; i++)\n    {\n        // Scale\n        pos *= scale;\n        t *= scale;\n\n        // Rotate\n        pos = rotate(pos, rot*pi);\n\n        // Mirror\n        pos = abs(pos);\n\n        // Orbit Trap\n        orbitTrap = min(pos, orbitTrap);\n\n        // Translate\n        pos += translate;\n    }\n\n    // Return the Distance Estimate\n    return SDF(pos)/t;\n}\n\n// SDF Tetrahedron Numerical Normals\nvec3 sampleNormal(vec3 pos)\n{\n    const vec2 k = vec2(-1.0, 1.0);\n    vec3 n;\n    return normalize(\n    k.xxx*DE(pos+k.xxx*hitDist, n)+\n    k.xyy*DE(pos+k.xyy*hitDist, n)+\n    k.yxy*DE(pos+k.yxy*hitDist, n)+\n    k.yyx*DE(pos+k.yyx*hitDist, n));\n}\n\n// Distance Estimator Soft Shadows\nfloat sampleLight(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    float ph = 1E4;\n    vec3 n;\n    for(int i = 0; i < maxStep; i++)\n    {\n        float h = DE(ro+rd*t, n);\n        float y = i == 0 ? 0.0 : h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n\n        res = min(res, 10.0*d/max(0.0, t-y));\n\n        t += h;\n\n        if(res < hitDist || t > shadowDist){break;}\n    }\n\n    res = clamp(res, 0.0, 1.0);\n\n    return res*res*(3.0-2.0*res);\n}\n\n// Intersection Structure\nstruct intersection {\n    float tMin;\n    float tMax;\n    bool hit;\n    bool expire;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emission;\n};\n\n// Ray-Marching\nintersection trace(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    float t = 0.0;\n    vec3 emission = vec3(0.0);\n    vec3 color = vec3(0.0);\n\n    // Ray-Marching\n    for(int i = 0; i < maxStep; i++)\n    {\n        // Check if the Ray \"Hit\" the Background\n        if(t > maxDist)\n        {\n            // Return the Intersection Data\n            return intersection(-1.0, -1.0, false, false, vec3(0.0), vec3(1.0, 0.0, 1.0), emission);\n        }\n\n        float td = DE(ro+rd*t, color);\n\n        // Check if the Ray Hit the Scene\n        if(td < hitDist)\n        {\n            // Return the Intersection Data\n            return intersection(t, -1.0, true, false, sampleNormal(ro+rd*t), clamp(color*10.0, 0.0, 1.0), emission);\n        }\n\n        // Add to Glow\n        emission += max(exp(-td*10.0), 0.0)*0.03;\n\n        // \"March\" the Ray\n        t += td;\n    }\n\n    // Ray Expired (Increase maxStep!)\n    return intersection(-1.0, -1.0, false, true, vec3(0.0), vec3(1.0, 0.0, 1.0), vec3(0.0));\n}\n\n// Rendering\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Compute the Intersection\n    intersection t = trace(ro, rd);\n\n    // If the Ray expired, output Debug Magenta color\n    if(t.expire)\n    {\n        // Magenta/Cyan Pattern\n        //return int(gl_FragCoord.x+gl_FragCoord.y)/4 % 2 == 0 ? vec3(10.000, 00.000, 10.000) : vec3(00.000, 10.000, 10.000);\n\n        // Magenta\n        return vec3(100.0, 0.0, 100.0);\n    }\n\n    // If the Ray never hit anything, output the background color\n    if(!t.hit)\n    {\n        return vec3(0.000, 0.000, 0.000)+t.emission;\n    }\n\n    // Light Direction\n    const vec3 lightDirection = vec3(0.577350269189626, 0.577350269189626, 0.577350269189626);\n\n    // Compute Lighting\n    float lighting0 = sampleLight(ro+rd*t.tMin, lightDirection);\n    float lighting1 = max(dot(t.normal, lightDirection), 0.0)*0.95;\n    float lighting2 = max(dot(t.normal,-lightDirection), 0.0)*0.15;\n\n    // Output the Final Color\n    return t.albedo*lighting0*(lighting1+lighting2+0.05)+t.emission;\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(gl_FragCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Set-Up Camera\n    const vec3 ro = vec3(0.0, 0.0, 2.0);\n    const mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 rd = normalize(vec3(camfov*uv, -1.0)*rotmat);\n\n    // Render the Frame\n    vec3 color = radiance(ro, rd);\n\n    // HDR Tonemapping\n    color = clamp(1.0-exp(-max(color, 0.0)*exposure), 0.0, 1.0);\n\n    // Output the Rendered Frame\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1761, 1792, 1825, 1825, 2336], [2338, 2357, 2378, 2457, 2505], [2507, 2568, 2611, 2637, 3326], [3328, 3365, 3394, 3394, 3611], [3613, 3648, 3685, 3685, 4107], [4277, 4293, 4331, 4355, 5284], [5286, 5299, 5332, 5364, 6296], [6298, 6329, 6384, 6413, 6912]], "test": "valid"}
{"id": "NtsSD7", "name": "AntiPod - Icarus", "author": "Flopine", "description": "A shader made as a loop for a track from ThronoCrigger, check out his album!!! \nhttps://thronocrigger.bandcamp.com/album/simulacra", "tags": ["2d", "lines", "animation", "mograph"], "likes": 9, "viewed": 109, "published": "Public", "date": "1625825718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.283185\n\n#define BPM (150./60.)\n#define time iTime\n#define dt(speed,offset) fract(time*speed+offset)\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.07,fwidth(val-thre)))\n#define square(puv,s) (max(abs(uv.x),abs(uv.y))-s)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define mo(puv,d) puv=abs(puv)-d;if(puv.y>puv.x) puv=puv.yx\n\nfloat line (vec2 uv, vec2 a, vec2 b, float r)\n{\n    vec2 pa = uv - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r*h;\n}\n\nfloat parallelepipede (vec2 uv, float animoffset)\n{\n    float thickness = 0.03;\n    vec2 a = vec2(-.8,1.5);\n    vec2 anima = mix(vec2(-.8,-.5),a,dt(0.5,animoffset));\n    vec2 b = vec2(.8,0.5);\n    vec2 animb = mix(a,b,dt(0.5,animoffset));\n    vec2 c = vec2(.8,-1.5);\n    vec2 animc = mix(b,c,dt(0.5,animoffset));\n    vec2 d = vec2(-.8,-.5);\n    vec2 animd = mix(c,d,dt(0.5,animoffset));\n    \n    float lab = AAstep(0.005,line(uv, a, animb, thickness));\n    float lbc =  AAstep(0.005,line(uv, b, animc, thickness));\n    float lcd =  AAstep(0.005,line(uv, c, animd, thickness));\n    float lda =  AAstep(0.005,line(uv, d, anima, thickness));\n    \n    return lab * lbc * lcd * lda;\n}\n\nfloat frame (vec2 uv)\n{\n    float f = 1.;\n    float off = -0.2;\n    float aoff = 0.;\n    for (int i=0; i<8; i++)\n    {\n        f *= parallelepipede((uv+off)*2.,aoff);\n        off += 0.05;\n        aoff -= 0.1;\n    }\n    \n    float size = 0.4;\n    uv *= rot(PI/15.);\n    mo(uv,vec2(1.1+dt(BPM/1.5,0.),0.3-dt(BPM/2.,1.)));\n    uv.y += 0.4;\n    uv *= rot(PI/4.);\n    for (int i=0; i<4; i++)\n    {\n        f *= clamp(AAstep(0.01, abs(square(uv,size)))+0.65,0.,1.);\n        size -= 0.07;\n    }\n    \n    return f;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(frame(uv));\n    \n    fragColor = vec4(1.-col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsSD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[743, 743, 790, 790, 920], [922, 922, 973, 973, 1601], [1603, 1603, 1626, 1626, 2111], [2115, 2115, 2172, 2172, 2308]], "test": "valid"}
{"id": "NtsSDf", "name": "Circle Drawing with sin", "author": "Trospy", "description": "Sin study", "tags": ["sinstudy"], "likes": 1, "viewed": 26, "published": "Public", "date": "1626708823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float cx = iResolution.x/(2.0+0.65*sin(3.14*0.75*iTime));\n    float cy = iResolution.y/(2.0+0.43*cos(3.14*0.51*iTime));\n    \n     // float x = 1.0/fragCoord.x;\n     // float y = 1.0/fragCoord.y;\n    \n      \n    float dist = sqrt((fragCoord.x-cx)*(fragCoord.x-cx)+(fragCoord.y-cy)*(fragCoord.y-cy));\n    float pattern =sin(iTime)*sin(3.14*dist*iTimeDelta)+cos(dist+iTime);\n\n\n    // Output to screen\n    fragColor = vec4(sin(iTime)*pattern,cos(1.75*iTimeDelta)*pattern,sin(3.0*iTime)*pattern,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsSDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 654]], "test": "valid"}
{"id": "NtsSRr", "name": "Raymarching Diffuse Lighting", "author": "RossBorchers", "description": "You know it!\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE", "tags": ["newbie", "basicraymarching", "artofcode"], "likes": 6, "viewed": 56, "published": "Public", "date": "1625098889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.003\n\n\n//From https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opSubtraction( float d1, float d2 ) \n{\n    return max(-d1,d2); \n}\n\nfloat GetDist(vec3 p)\n{\n    //Distance to plane. flat on ground.\n    float dPlaneBottom = p.y;\n    float dPlaneTop = 12.0 - p.y;\n    \n    //Distance to sphere.\n    //distance of camera to sphere position minus radius\n    //xyz, radius\n    vec4 sphere= vec4(-1, 1.7, 6, 1);\n    float dSphere = length(p-sphere.xyz)-sphere.w;\n    \n     vec4 sphere2 = vec4(1, 1.2, 6.5, 0.9);\n    float dSphere2 = length(p-sphere2.xyz)-sphere2.w;\n    \n      vec4 sphere3 = vec4(0, 0, 7.3, 3.2);\n    float dSphere3 = length(p-sphere3.xyz)-sphere3.w;\n    float dFloorBottom = opSubtraction(dSphere3, dPlaneBottom);\n    \n    vec3 boxPos = vec3(3, 1, 5);\n    float dBox = sdRoundBox(p -boxPos , vec3(0.25,2,0.25), 0.02);\n    \n    vec3 box2Pos = vec3(3, 1, 10);\n    float dBox2 = sdRoundBox(p -box2Pos , vec3(0.25,2,0.25), 0.02);\n    \n    vec3 box3Pos = vec3(-3, 1, 10);\n    float dBox3 = sdRoundBox(p -box3Pos , vec3(0.25,2,0.25), 0.02);\n    \n    vec3 box4Pos = vec3(-3, 1, 5);\n    float dBox4 = sdRoundBox(p -box4Pos , vec3(0.25,2,0.25), 0.02);\n    \n    float dMarch = opSmoothUnion(dSphere2, dSphere, 0.7);\n    dMarch = min(dMarch, dFloorBottom);\n    dMarch = min(dMarch, dPlaneTop);\n    dMarch = opSmoothUnion(dMarch, dBox, 0.1);\n    dMarch = opSmoothUnion(dMarch, dBox2, 0.1);\n    dMarch = opSmoothUnion(dMarch, dBox3, 0.1);\n    dMarch = opSmoothUnion(dMarch, dBox4, 0.1);\n    return dMarch;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    //Distance from origin.\n    float dO = 0.0;\n    \n    //Delimit max steps to avoid infinate loop\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        //new point to evaluate. camera origin + current distance from origin * ray direction \n        vec3 p = ro+(dO*rd);\n        \n        //Get current distance to scene (sphere trace)\n        float dS = GetDist(p);\n        \n        //increment distnace for next iteration\n        dO += dS;\n        \n        //exit if we are close to surface or we are too far away from camera.\n        if(dS<SURFACE_DIST || dO > MAX_DIST)\n        {\n            break;\n        }\n    }\n    \n    //return the distance that we either exited early or at scene object.\n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    \n    // create vec2 so we can swizzle between small value and nothing\n    vec2 e = vec2(0.01, 0);\n\n    //get distance on every axis, a little bit offset from the point being evaluated.\n    vec3 offsetDistance = vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n    \n    //get normal by comparing distances between 2 close points\n    vec3 n = d-offsetDistance;\n    \n    return normalize(n);\n        \n}\n\nfloat GetLight(vec3 p)\n{\n    const float ambientLight = 0.0;\n    \n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    \n    vec3 l = normalize(lightPos -p);\n    vec3 n = GetNormal(p);\n    \n    //raymarch to light to see if we are in shadow\n    float d = RayMarch(p+n*SURFACE_DIST*2.0, l);\n    \n    float dif = dot(n, l);\n    dif = clamp(dif, 0.0, 1.0);\n    \n    //if in shadow\n    if(d<length(lightPos-p))\n    {\n        dif *= 0.1f;\n    }\n    \n    return dif + ambientLight;\n}\n\n\nvec3 applyFog(in float d)\n{\n    float fogAmount = 1.0 - exp( -d *0.01);\n    return mix( vec3(0), vec3(1), fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1). Center on middle of screen.\n    vec2 uv = (fragCoord-0.5f*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    // Basic camera model.\n    vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    //get closest point in scene... move forward to that point. Iterativley find distance.\n \n    float d = RayMarch(ro, rd);\n    \n    col = applyFog(d);\n    \n    //get hit point\n    vec3 p = ro + rd * d;\n    \n    //diffuse lighting\n    float dif = GetLight(p);\n    col = vec3(dif) + col;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 153, 206, 206, 306], [308, 308, 353, 353, 444], [446, 446, 490, 490, 517], [519, 519, 542, 583, 1892], [1894, 1894, 1928, 1956, 2640], [2642, 2642, 2666, 2666, 3107], [3109, 3109, 3133, 3133, 3626], [3629, 3629, 3656, 3656, 3749], [3751, 3751, 3808, 3887, 4429]], "test": "valid"}
{"id": "NtSSRw", "name": "ms Audio Visualizer", "author": "momie", "description": "My 2nd audio visualizer.", "tags": ["audio"], "likes": 2, "viewed": 53, "published": "Public", "date": "1627339898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    \n\n    float theta = mod( (atan(uv.y,uv.x)+PI)/(2.*PI), .3);\n    vec4 spect = texture(iChannel0, vec2(theta,0.0));\n    vec4 col;\n    vec3 circle;\n    for (float i=0.; i<150.; i+=8.){\n        circle = vec3(mod(.5*iTime+i*.01, 3.5) , mod(.5*iTime+(i*.01+.03), 3.5), mod(.5*iTime+(i*.01+.04), 3.5)) + 1.3*spect.x - log(length(uv*17.));\n        col += vec4( vec3(.031/circle), 0) ;\n    } \n    \n    fragColor = col;\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSSRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 124, 585]], "test": "error"}
{"id": "NtsSW8", "name": "Feathers Wind Tutorial", "author": "deliaev", "description": "made while following this tutorial https://www.youtube.com/watch?v=68IFmCCy_AM", "tags": ["feather"], "likes": 4, "viewed": 73, "published": "Public", "date": "1626632841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep\n#define T (iTime)\n\nmat2 Rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 Transform(vec3 p, float a) {\n    p.xz *= Rot(a);\n    p.xy *= Rot(a*.7);\n    return p;\n}\n\nfloat Feather(vec2 p) {\n    float d = length(p-vec2(0,clamp(p.y,-.3, .3)));\n    float r = mix(.1, .01, S(-.3, .3, p.y));\n    float m = S(.001, .0, d-r);\n    \n    float side = sign(p.x);\n    float x = abs(p.x)/r;\n    float wave = (1.-x)*sqrt(x) + x*(1.-sqrt(1.-x));\n    float y = (p.y-wave*.2)*80.+side*56.;\n    float id = floor(y+20.);\n    float n = fract(sin(id*564.32)*763.); // random shade per strand\n    float shade = mix(.5, 1., n);\n    float strandLength = mix(.7, 1.,fract(n*10.));\n    \n    float strand = S(.1, .0, abs(fract(y)-.5)-.3);\n    strand *= S(.1, -.2, x - strandLength);\n    d = length(p-vec2(0,clamp(p.y,-.45, .1)));\n    float stem = S(.01,0.,d+p.y*.025);\n    return max(strand*m*shade, stem);\n}\n\nvec4 FeatherBall(vec3 ro, vec3 rd, vec3 pos, float angle) {\n    \n    float t = dot(pos-ro, rd);\n    vec3 p = ro + rd * t;\n    float y = length(pos-p);\n    \n    if(y<1.) {\n        float x = sqrt(1.-y);\n        vec3 pF = ro + rd * (t-x) - pos; //front intersection\n        pF = Transform(pF, angle);\n        vec2 uvF = vec2(atan(pF.x, pF.z), pF.y);\n        uvF *= vec2(.25,.5);\n        float f = Feather(uvF);\n        vec4 front = vec4(vec3(f), S(0., .1, f));\n        \n        vec3 pB = ro + rd * (t+x) - pos; //back intersection\n        pB = Transform(pB, angle);\n        vec2 uvB = vec2(atan(pB.x, pB.z), pB.y);\n        uvB *= vec2(.25,.5);\n        float b = Feather(uvB);\n        vec4 back = vec4(vec3(b), S(0., .1, b));\n        \n        return mix(back, front, front.a);\n    }\n\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = iMouse.xy/iResolution.xy - .5;\n    vec3 bg = vec3(.2, .2, .7)*(uv.y+.5);\n    bg += vec3(.9,.5,1.)*(-uv.y+.5);\n    vec4 col = vec4(bg, 0);\n    \n    // col += Feather(uv);\n    \n    vec3 ro = vec3(0,0,-3);\n    vec3 rd = normalize(vec3(uv, 1));\n            \n    for (float i = 0.; i < 1.; i+=1./50.) {\n    \n        float x = mix(-10.,10., fract(i+T*.1)) + M.x;\n        float y = mix(-2.,2.,fract(sin(i*587.43)*4579.34)) + M.y;\n        float z = mix(5.,-2.,i);\n        float a = T+i*534.4;\n        vec4 feather = FeatherBall(ro, rd, vec3(x, y, z), a);\n        \n        feather.rgb = mix(bg, feather.rgb, mix(.5, .9, i));\n        //feather.rgb = sqrt(feather.rgb);\n        feather.rgb *= feather.rgb;\n        col = mix(col, feather, feather.a);\n    }\n    \n    \n    \n    col = pow(col, vec4(.4545)); //gamma correction\n    \n    fragColor = col;\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsSW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 58, 58, 124], [126, 126, 159, 159, 218], [220, 220, 243, 243, 935], [937, 937, 996, 996, 1723], [1725, 1725, 1782, 1782, 2704]], "test": "error"}
{"id": "NtsSzf", "name": "Aliasing zoom", "author": "Alexwing", "description": "Explore the cosine aliasing with the mouse.", "tags": ["mouse"], "likes": 2, "viewed": 144, "published": "Public API", "date": "1626636504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define VELOCITY    500.0\n#define ANTI_ALIASING_FACTOR    0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy; //We obtain our coordinates for the current pixel\n    \n\n    xy.x = xy.x / (iResolution.x-iMouse.x); //We divide the coordinates by the screen size \n    xy.y = xy.y / (iResolution.y-iMouse.y);\n    \n    // Now x is 0 for the leftmost pixel, and 1 for the rightmost pixel\n    vec4 solidRed = vec4(0,0.0,0.0,0.0); //This is actually black right now\n    \n\tif(iMouse.z>0.0 ) { // button is down\n     fragCoord -= 0.5*(fragColor.xy=(iMouse.xy*2.0));\n    }else{\n     fragCoord -= 0.5*(fragColor.xy=(iResolution.xy));\n    }\n    \n    // inversion\n    fragCoord = cos(iTime*  fragCoord*VELOCITY* xy /dot(fragCoord,fragCoord)) ;\n        \n    // anti-aliasing and color post\n\tsolidRed += ANTI_ALIASING_FACTOR-  fragCoord.x / fwidth(fragCoord.x  -fragColor );      \n    \n    //solidRed.x += ANTI_ALIASING_FACTOR-  fragCoord.x / fwidth(fragCoord  -xy ).x;       \n   // solidRed.y += ANTI_ALIASING_FACTOR-  fragCoord.x / fwidth(fragCoord  -xy ).y;      \n   // solidRed.z += ANTI_ALIASING_FACTOR-  fragCoord.x / fwidth(fragCoord  -xy ).x;  \n    \n\n    fragColor = solidRed;\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 120, 120, 1216]], "test": "valid"}
{"id": "NtSSzw", "name": "SWS3005_12", "author": "lyfzero", "description": "real-time ray tracing on GPU, assignment 5 task 2, group 12.", "tags": ["raytracer"], "likes": 0, "viewed": 25, "published": "Public", "date": "1627366373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//============================================================================\n// PROJECT ID: 12\n//\n// GROUP NUMBER: \n//\n// STUDENT NAME: YAO PENG(å§é¹)\n// NUS User ID.: t0922555\n//\n// STUDENT NAME: LI YIFAN(æä¸å¸)\n// NUS User ID.: t0922558\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 4;\nconst int NUM_MATERIALS = 7;\nconst int NUM_PLANES = 4;\nconst int NUM_SPHERES = 8 + 6;\nconst int NUM_CONES = 2;\nconst int NUM_BOXS = 1;\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Cone_t {\n\tfloat cosa;  // Half angle\n\tfloat h;  // Height\n\tvec3 c;  // Tip position\n\tvec3 v;  // Axis\n\tint materialID;\n};\n\nstruct Box_t {\n\tvec3 rad;\n    vec3 center;\n\tint materialID;\n\tmat4 M;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCone_t Cone[NUM_CONES];\nBox_t Box[NUM_BOXS];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // far plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 10.0;\n    Plane[1].materialID = 6;\n        \n    // left plane\n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 10.0;\n    Plane[2].materialID = 3;\n    \n    // right plane\n    Plane[3].A = -1.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 0.0;\n    Plane[3].D = 10.0;\n    Plane[3].materialID = 3;\n    \n    // box\n    Box[0].rad = vec3(3.0,1.0,3.0);\n\tBox[0].center = vec3(0.0,0.0,-3.0);\n\tBox[0].materialID = 4;\n\tBox[0].M = mat4 (vec4(cos(315.0 / 180.0 * PI ),0,sin(315.0 / 180.0 * PI ),0),\n    vec4(0,1,0,0),\n    vec4(-sin(315.0 / 180.0 * PI ),0,cos(315.0 / 180.0 * PI ),0),\n    vec4(0,0,0,1))*mat4 (vec4(1,0,0,0),vec4(0,1,0,0),vec4(0,0,1,0),vec4(-Box[0].center,1));\n\n\n    float sec = mod(iTime, 1.);\n    float spI = floor(mod(iTime, 8.0));\n    \n    if(mod(floor(iTime / 8.0), 2.0) == 0.0) {\n        Sphere[0].center = vec3(0.0 * 2.0 - 1.0, 0.0 * 2.0 + 3.0, 0.0 * 2.0 - 3.0);\n    } else {\n        Sphere[0].center = vec3(0.0, 3.0, -5.0);\n    }\n    Sphere[0].radius = 0.7 + float(mod(iTime, 8.0) >= 0.0) * 0.1 * sin(sec * 50.) / sqrt(sec) * ( 1.-sqrt(sec));\n    Sphere[0].materialID = mod(iTime, 8.0) >= 0.0 ? 0 : 3;\n    \n    if(mod(floor(iTime / 8.0), 2.0) == 0.0) {\n        Sphere[1].center = vec3(1.0 * 2.0 - 1.0, 0.0 * 2.0 + 3.0, 0.0 * 2.0 - 3.0);\n    } else {\n        Sphere[1].center = Sphere[0].center + vec3(1.5, 0, 1.5);\n    }        \n    Sphere[1].radius = 0.7 + float(mod(iTime, 8.0) >= 1.0) * 0.1 * sin(sec * 50.) / sqrt(sec) * ( 1.-sqrt(sec));\n    Sphere[1].materialID = mod(iTime, 8.0) >= 1.0 ? 0 : 3;\n\n    if(mod(floor(iTime / 8.0), 2.0) == 0.0) {\n        Sphere[2].center = vec3(0.0 * 2.0 - 1.0, 1.0 * 2.0 + 3.0, 0.0 * 2.0 - 3.0);\n    } else {\n        Sphere[2].center = Sphere[1].center + vec3(1.5, 0, 1.5);\n    }\n    Sphere[2].radius = 0.7 + float(mod(iTime, 8.0) >= 2.0) * 0.1 * sin(sec*50.) / sqrt(sec) * ( 1.-sqrt(sec));\n    Sphere[2].materialID = mod(iTime, 8.0) >= 2.0 ? 0 : 3;\n\n    if(mod(floor(iTime / 8.0), 2.0) == 0.0) {\n    Sphere[3].center = vec3(1.0 * 2.0 - 1.0, 1.0 * 2.0 + 3.0, 0.0 * 2.0 - 3.0);\n    } else {\n        Sphere[3].center = Sphere[0].center + vec3(-1.5, 0, 1.5);\n    }\n    Sphere[3].radius = 0.7 + float(mod(iTime, 8.0) >= 3.0) * 0.1 * sin(sec*50.) / sqrt(sec) * ( 1.-sqrt(sec));\n    Sphere[3].materialID = mod(iTime, 8.0) >= 3.0 ? 0 : 3;\n    \n    if(mod(floor(iTime / 8.0), 2.0) == 0.0) {    \n    Sphere[4].center = vec3(0.0 * 2.0 - 1.0, 0.0 * 2.0 + 3.0, 1.0 * 2.0 - 3.0);\n    } else {\n        Sphere[4].center = Sphere[3].center + vec3(-1.5, 0, 1.5);\n    }\n    Sphere[4].radius = 0.7 + float(mod(iTime, 8.0) >= 4.0) * 0.1 * sin(sec*50.) / sqrt(sec) * ( 1.-sqrt(sec));\n    Sphere[4].materialID = mod(iTime, 8.0) >= 4.0 ? 0 : 3;\n\n    if(mod(floor(iTime / 8.0), 2.0) == 0.0) {\n    Sphere[5].center = vec3(1.0 * 2.0 - 1.0, 0.0 * 2.0 + 3.0,  1.0 * 2.0 - 3.0);\n    } else {\n        Sphere[5].center = Sphere[4].center + vec3(1.5, 0, 1.5);\n    }\n    Sphere[5].radius = 0.7 + float(mod(iTime, 8.0) >= 5.0) * 0.1 * sin(sec*50.) / sqrt(sec) * ( 1.-sqrt(sec));\n    Sphere[5].materialID = mod(iTime, 8.0) >= 5.0 ? 0 : 3;\n\n    if(mod(floor(iTime / 8.0), 2.0) == 0.0) {\n    Sphere[6].center = vec3(0.0 * 2.0 - 1.0, 1.0 * 2.0 + 3.0, 1.0 * 2.0 - 3.0);\n    } else {\n        Sphere[6].center = Sphere[5].center + vec3(1.5, 0, 1.5);\n    }\n    Sphere[6].radius = 0.7 + float(mod(iTime, 8.0) >= 6.0) * 0.1 * sin(sec*50.) / sqrt(sec) * ( 1.-sqrt(sec));\n    Sphere[6].materialID = mod(iTime, 8.0) >= 6.0 ? 0 : 3;\n\n    if(mod(floor(iTime / 8.0), 2.0) == 0.0) {\n    Sphere[7].center = vec3(1.0 * 2.0 - 1.0, 1.0 * 2.0 + 3.0, 1.0 * 2.0 - 3.0);\n    } else {\n        Sphere[7].center = Sphere[2].center + vec3(-1.5, 0, 1.5);\n    }\n    Sphere[7].radius = 0.7 + float(mod(iTime, 8.0) >= 7.0) * 0.1 * sin(sec*50.) / sqrt(sec) * ( 1.-sqrt(sec));\n    Sphere[7].materialID = mod(iTime, 8.0) >= 7.0 ? 0 : 3;\n   \n    \n    \n    // Center bouncing sphere.\n    Sphere[8].center = vec3( 5.0, (mod(iTime, 3.0) + 0.2) * abs(sin(2.0 * PI * iTime)) + 0.7, 2.0 );\n    Sphere[8].radius = 0.7;\n    Sphere[8].materialID = 1;\n    \n    Sphere[9].center = vec3( -5.0, (mod(iTime, 3.0) + 0.2) * abs(sin(2.0 * PI * iTime)) + 0.7, 2.0 );\n    Sphere[9].radius = 0.7;\n    Sphere[9].materialID = 1;\n    \n    Sphere[10].center = vec3( 5.0, (mod(iTime + 1.0, 3.0) + 0.5) * abs(sin(2.0 * PI * iTime)) + 0.7, -6.0 );\n    Sphere[10].radius = 0.7;\n    Sphere[10].materialID = 1;\n    \n    Sphere[11].center = vec3(-5.0, (mod(iTime + 1.0, 3.0) + 0.5) * abs(sin(2.0 * PI * iTime)) + 0.7, -6.0 );\n    Sphere[11].radius = 0.7;\n    Sphere[11].materialID = 1;\n    \n    Sphere[12].center = vec3( 7.0, (mod(iTime + 2.0, 3.0) + 0.8) * abs(sin(2.0 * PI * iTime)) + 0.7, -2.0 );\n    Sphere[12].radius = 0.7;\n    Sphere[12].materialID = 1;\n    \n    Sphere[13].center = vec3( -7.0, (mod(iTime + 2.0, 3.0) + 0.8) * abs(sin(2.0 * PI * iTime)) + 0.7, -2.0 );\n    Sphere[13].radius = 0.7;\n    Sphere[13].materialID = 1;\n\n    // Cone\n    Cone[0].cosa = 0.95;\n    Cone[0].h = 10.0;\n    Cone[0].c = vec3(9.9, 10.0, -9.9);\n    Cone[0].v = vec3(0.0, -1.0, 0.0);\n    Cone[0].materialID = 4;\n    \n    Cone[1].cosa = 0.95;\n    Cone[1].h = 10.0;\n    Cone[1].c = vec3(-9.9, 10.0, -9.9);\n    Cone[1].v = vec3(0.0, -1.0, 0.0);\n    Cone[1].materialID = 4;\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 32.0;\n    \n    // plastic material.\n\tMaterial[3].k_d = vec3( 0.5, 0.3, 0.5 );\n    Material[3].k_a = 0.9 * Material[3].k_d;\n    Material[3].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[3].k_rg = 0.1 * Material[3].k_r;\n    Material[3].n = 64.0;\n\n\t// plastic material.\n\tMaterial[4].k_d = vec3( 0.8, 0.2, 0.1 );\n    Material[4].k_a = 0.9 * Material[4].k_d;\n    Material[4].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[4].k_rg = 0.2 * Material[4].k_r;\n    Material[4].n = 32.0;\n\n\t// plastic material.\n    Material[5].k_d = vec3( 0.8, 0.2, 0.8 );\n    Material[5].k_a = 0.9 * Material[5].k_d;\n    Material[5].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[5].k_rg = 0.2 * Material[5].k_r;\n    Material[5].n = 32.0;\n    \n\t// plastic material.\n    Material[6].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[6].k_a = 0.9 * Material[6].k_d;\n    Material[6].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[6].k_rg = 0.2 * Material[6].k_r;\n    Material[6].n = 32.0;\n    \n    \n\n    // Light 0.\n    Light[0].position = vec3( 9.9, 12.0, -9.9 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 0.8*abs(sin(0.2*PI*iTime)), 0.8*abs(cos(0.2*PI*iTime)), 0.8*abs(sin(1.2*PI*iTime)) );\n\n    // Light 1.\n    Light[1].position = vec3( -9.9, 12.0, -9.9 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 0.6*abs(sin(0.2*PI*iTime)), 0.6*abs(cos(0.1*PI*iTime)), 0.6*abs(sin(1.4*PI*iTime)) );\n    \n    // Light 2\n    Light[2].position = vec3( 9.9, 12.0, 9.9 );\n    Light[2].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[2].I_source = vec3( 0.8*abs(sin(0.2*PI*iTime)), 0.8*abs(cos(0.4*PI*iTime)), 0.8*abs(sin(1.3*PI*iTime)) );\n\n    // Light 3.\n    Light[3].position = vec3( -9.9, 12.0, 9.9 );\n    Light[3].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[3].I_source = vec3( 0.6*abs(sin(0.1*PI*iTime)), 0.6*abs(cos(0.3*PI*iTime)), 0.6*abs(sin(1.1*PI*iTime)) );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n        // Compute a vector from center to ray origin\n    // represent the distance\n    vec3 D = ray.o-sph.center;\n    // d = b*b-4*a*c\n    float a = dot(ray.d,ray.d);\n    float b = 2.0*dot(D,ray.d);\n    float c = dot(D,D)-sph.radius*sph.radius;\n    float discr = b*b - 4.0*a*c;\n\n    // no intersection\n    if(discr<0.0)\n        return false;\n    \n    // compute intersection\n    float sqrt_discr = sqrt(discr);\n    // two intersection: t1>=t2\n    float t1 = (-b + sqrt_discr) / 2.0 / a;\n\tfloat t2 = (-b - sqrt_discr) / 2.0 / a;\n    // we only want the positive one\n\tif (t1 <= 0.0)\n\t\treturn false;\n    \n    // output\n    // choose the closet positive one\n    t = (t2 > 0.0) ? t2 : t1;\n    hitPos = ray.o + t * ray.d;\n    hitNormal = (hitPos-sph.center)/sph.radius;\n\n    if ( t < tmin || t > tmax ) return false;\n    return true;\n    /////////////////////////////////\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n        // Compute a vector from center to ray origin\n    // represent the distance\n    vec3 D = ray.o-sph.center;\n    // d = b*b-4*a*c\n    float a = dot(ray.d,ray.d);\n    float b = 2.0*dot(D,ray.d);\n    float c = dot(D,D)-sph.radius*sph.radius;\n    float discr = b*b - 4.0*a*c;\n\n    // no intersection\n    if(discr<0.0)\n        return false;\n    \n    // compute intersection\n    float sqrt_discr = sqrt(discr);\n    // two intersection: t1>=t2\n    float t1 = (-b + sqrt_discr) / 2.0 / a;\n\tfloat t2 = (-b - sqrt_discr) / 2.0 / a;\n    // we only want the positive one\n\tif (t1 <= 0.0)\n\t\treturn false;\n    \n    float t = (t2 > 0.0) ? t2 : t1;\n    if ( t < tmin || t > tmax ) return false;\n    return true;\n    /////////////////////////////////\n\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a cone and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectCone( in Cone_t cone, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 co = ray.o - cone.c;\n\n    float a = dot(ray.d, cone.v)*dot(ray.d, cone.v) - cone.cosa * cone.cosa;\n    float b = 2. * (dot(ray.d, cone.v) * dot(co, cone.v) - dot(ray.d, co) * cone.cosa * cone.cosa);\n    float c = dot(co, cone.v) * dot(co, cone.v) - dot(co, co) * cone.cosa * cone.cosa;\n\n    float det = b * b - 4. * a * c;\n    if (det < 0.) return false;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / 2.0/ a;\n    float t2 = (-b + det) / 2.0/ a;\n\n    t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return false;\n\n    vec3 cp = ray.o + t * ray.d - cone.c;\n    float h = dot(cp, cone.v);\n    if (h < 0. || h > cone.h) return false;\n\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize(cp * dot(cone.v, cp) / dot(cp, cp) - cone.v);\n\n    return (t >= tmin && t<= tmax);\n}\n\n// Computes intersection between a cone and a ray for shadow ray intersection.\nbool IntersectCone( in Cone_t cone, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 co = ray.o - cone.c;\n\n    float a = dot(ray.d, cone.v)*dot(ray.d, cone.v) - cone.cosa * cone.cosa;\n    float b = 2. * (dot(ray.d, cone.v) * dot(co, cone.v) - dot(ray.d, co) * cone.cosa * cone.cosa);\n    float c = dot(co, cone.v) * dot(co, cone.v) - dot(co, co) * cone.cosa * cone.cosa;\n\n    float det = b * b - 4. * a * c;\n    if (det < 0.) return false;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / 2.0/ a;\n    float t2 = (-b + det) / 2.0/ a;\n\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return false;\n    vec3 cp = ray.o + t * ray.d - cone.c;\n    float h = dot(cp, cone.v);\n    if (h < 0. || h > cone.h) return false;\n\n    return (t >= tmin && t<= tmax);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal)\n{\n\tvec3 sco = (box.M * vec4(ray.o,1.0)).xyz;\n\tvec3 scd = normalize((transpose(inverse(box.M))*vec4(ray.d,1.0)).xyz);\n    vec3 m = 1.0/scd;\n    vec3 n = m * sco;\n    vec3 k = abs(m) * box.rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max( max( t1.y, t1.z ), t1.x );\n    float tF = min( min( t2.y, t2.z ), t2.x );\n\t\n    if( tN>tF || tF<0.0) return false;\n\tif ( tN < tmin || tN > tmax ) return false;\n\tt = tN;\n\thitPos = (inverse(box.M) * vec4((sco + t * scd),1.0)).xyz;\n\thitNormal = (transpose(inverse(box.M)) * vec4((-sign(ray.d)*step(t1.zxy,t1.xyz)*step(t1.yzx,t1.xyz)),1.0)).xyz;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax )\n{\n\n\tvec3 sco = (box.M * vec4(ray.o,1.0)).xyz;\n\tvec3 scd = normalize((transpose(inverse(box.M))*vec4(ray.d,1.0)).xyz);\n    vec3 m = 1.0/scd;\n    vec3 n = m * sco;\n    vec3 k = abs(m) * box.rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.y, t1.z ), t1.x );\n    float tF = min( min( t2.y, t2.z ), t2.x );\n\t\n    if( tN>tF || tF<0.0) return false;\n\tif ( tN < tmin || tN > tmax ) return false;\n    return true;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    // Try intersect with spheres\n    for(int i = 0; i < NUM_SPHERES; i++){\n        temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n\n        // record the front-most (nearest) interesection\n        if (temp_hasHit && temp_t < nearest_t) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Sphere[i].materialID;\n    \t}\n    }\n    // Try intersect with planes\n    // use the recorded above nearest_t to decide whether write in new intersection\n    for (int i = 0; i < NUM_PLANES; i++ ){\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n\n        // record the front-most (nearest) interesection\n        if (temp_hasHit && temp_t < nearest_t ) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Plane[i].materialID;\n    \t}\n    }\n\n    // Try intersect with cones\n    // use the recorded above nearest_t to decide whether write in new intersection\n    for (int i = 0; i < NUM_CONES; i++ ) {\n    \ttemp_hasHit = IntersectCone(Cone[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal);\n\n        // record the front-most (nearest) interesection    \t\n        if (temp_hasHit && temp_t < nearest_t ) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Cone[i].materialID;\n    \t}\n    \t\n    }\n    for(int i = 0; i < NUM_BOXS; i++){\n        temp_hasHit = IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n\n        // record the front-most (nearest) interesection\n        if (temp_hasHit && temp_t < nearest_t) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Box[i].materialID;\n    \t}\n    }\n    /////////////////////////////////\n\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n    \n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    // Accumulate lighting\n    Ray_t ShadowRay[NUM_LIGHTS];\n    bool inshadow[NUM_LIGHTS];\n    for(int i = 0; i < NUM_LIGHTS; i++){\n        // create shadow ray->Light1,2\n        ShadowRay[i].o = nearest_hitPos;\n    \tShadowRay[i].d = normalize(Light[i].position - ShadowRay[i].o);\n\n        // consider intersecting with spheres\n        for (int j = 0; j < NUM_SPHERES; j++ ) {\n    \t\tif(!inshadow[i]) {\n    \t\t// The point is in shadow if the shadow ray intersects with anything\n    \t\tinshadow[i] = IntersectSphere(Sphere[j], ShadowRay[i], DEFAULT_TMIN, \n    \t\t\tdistance(nearest_hitPos, Light[i].position));\n    \t\t}\n    \t}\n        // consider intersection with planes\n    \tif (!inshadow[i]) {\n    \t\tfor(int j = 0; j < NUM_PLANES; j++ ) {\n    \t\t\tif(!inshadow[i]) {\n    \t\t\t\tinshadow[i] = IntersectPlane(Plane[j], ShadowRay[i], DEFAULT_TMIN, \n    \t\t\t\t    distance(nearest_hitPos, Light[i].position));\n    \t\t\t}\n    \t\t}\n    \t}\n        // consider intersection with cones\n        if (!inshadow[i]) {\n    \t\tfor(int j = 0; j < NUM_CONES; j++ ) {\n    \t\t\t// If already in shadow, inshadow[i] becomes inaccessible\n    \t\t\tif(!inshadow[i]) {\n    \t\t\t\tinshadow[i] = IntersectCone(Cone[j], ShadowRay[i], DEFAULT_TMIN, \n    \t\t\t\tdistance(nearest_hitPos, Light[i].position));\n    \t\t\t}\n    \t\t}\n    \t}\n\n        // call PhongLighting() to compute lighting for this light source\n        I_local += PhongLighting( ShadowRay[i].d, nearest_hitNormal, - ray.d, inshadow[i], Material[nearest_hitMatID], Light[i] );\n    }\n    /////////////////////////////////\n\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n    \n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float an = 0.3*iTime - 7.0*m.x;\n    // Position the camera.\n    vec3 cam_pos = vec3( 3.5*sin(an), 10.0, 3.5*cos(an)+8.0 );\n    vec3 cam_lookat = vec3( 0, 4.0, -1.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3513, 3695, 3713, 3738, 11725], [11729, 12225, 12379, 12379, 12709], [12713, 13045, 13128, 13128, 13340], [13344, 13862, 14019, 14179, 14965], [14969, 15302, 15387, 15547, 16206], [16209, 16540, 16694, 16694, 17502], [17504, 17583, 17665, 17665, 18373], [18375, 18870, 18997, 18997, 19617], [19621, 19951, 20029, 20029, 20464], [20467, 20821, 20951, 20951, 21363], [21365, 22154, 22267, 22358, 28052], [28056, 28417, 28474, 28474, 29992]], "test": "error"}
{"id": "NtXSWS", "name": "AntiPod - Simulacra", "author": "Flopine", "description": "A shader made as a loop for a track from ThronoCrigger, check out his album!!! \nhttps://thronocrigger.bandcamp.com/album/simulacra", "tags": ["3d", "raymarching", "animation", "mograph", "flatshading"], "likes": 7, "viewed": 83, "published": "Public", "date": "1626384836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define TAU 6.283183\n#define PI acos(-1.)\n#define ITER 64. \n\n#define BPM (160./60.)\n#define dt(sp,off) fract((iTime+off)*sp)\n#define easeout(s,of) easeOutExpo(abs(-1.+2.*dt(s,of)))\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define crep(puv,c,l) puv=(puv-c*clamp(round(puv/c),-l,l))\n#define pal(t,c,d) (vec3(0.5)+vec3(0.5)*cos(TAU*(c*t+d)))\n\n#define od(puv,d) (dot(puv,normalize(sign(puv)))-d)\n#define sphe(puv,d) (length(puv)-d) \n\nfloat hash21(vec2 x)\n{return fract(sin(dot(x,vec2(13.4,43.4)))*124.4);}\n\nfloat easeOutExpo (float x)\n{return x == 1. ? 1. : 1. - exp2(-10. * x);}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n  return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat candy; vec2 cid;\nfloat SDF (vec3 p)\n{\n  p.yz *= rot(-atan(1./sqrt(2.)));\n  p.xz *= rot(PI/4.);\n\n  vec2 per = vec2(2.);\n\n  vec3 ppp = p;\n  cid=round(ppp.xy/per); \n  crep(ppp.xy,per,3.);\n  float size = easeout(BPM/2.,(cid.x+cid.y)*0.03)*0.5+0.5;\n  ppp *= size;\n  candy = mix(od(ppp,0.3),box(ppp,vec3(.4)), 0.5);\n\n  vec2 id = round(p.xy/per);\n  p.z = abs(p.z)-mix(0.01,4.,clamp(easeout(BPM/4.,length(id*0.02))*2.-1.,0.001,1.));\n  vec3 pp = p; \n\n  vec2 bid=round(p.xy/per); \n  crep(p.xy,per,3.); \n  float d = max(dot(pp,normalize(vec3(0.,0.,-1.))),abs(mix(od(p,0.5),box(p,vec3(.6)), 0.5))-0.04);\n\n  return min(d,candy);\n}\n\nvec3 getnorm (vec3 p, vec2 eps)\n{return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n  vec3 ro = vec3(uv*10.,-500.), \n  rd=vec3(0.,0.,1.), \n  p=ro, \n  col=vec3(0.95,0.99,1.), \n  l=vec3(1.,-1.5,-2.);\n\n  bool hit = false; float d=0.;\n  for (float i=0.; i<ITER; i++)\n  {\n    d = SDF(p);\n    if (d<0.01)\n    {\n      hit = true;\n      break;\n    }\n    p += d*rd*0.9;\n  }\n\n  if (hit)\n  {\n    if (d==candy) col = vec3(0.8,hash21(cid),2.) ;\n    vec3 n = getnorm(p,vec2(0.01,0.));\n    float light = max(dot(n,normalize(l)),0.);\n    col *= mix(vec3(0.5,0.3,0.5),vec3(0.4,0.7,0.9),light);\n  }\n  \n  fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[801, 801, 823, 823, 872], [874, 874, 903, 903, 946], [948, 948, 976, 976, 1059], [1084, 1084, 1104, 1104, 1684], [1686, 1686, 1719, 1719, 1796], [1798, 1798, 1854, 1854, 2451]], "test": "valid"}
{"id": "NtXSzl", "name": "Moving without travelling", "author": "mrange", "description": "License CC0: Moving without travelling", "tags": ["warpedfbm"], "likes": 17, "viewed": 353, "published": "Public API", "date": "1626261436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Moving without travelling\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define TTIME           (TAU*TIME)\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define BPERIOD         5.6\n#define PCOS(x)         (0.5+ 0.5*cos(x))\n#define BPM             150.0\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 std_gamma        = vec3(2.2);\n\nfloat g_th = 0.0;\nfloat g_hf = 0.0;\n\nvec2 g_vx = vec2(0.0);\nvec2 g_vy = vec2(0.0);\n\nvec2 g_wx = vec2(0.0);\nvec2 g_wy = vec2(0.0);\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(-a, a, k);\n}\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// Based on: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\nfloat outerEye(vec2 p, float th) {\n  float a  = mix(0.0, 1.0, smoothstep(0.995, 1.0, cos(th+TTIME/BPERIOD)));\n  const float w = 1.14;\n  float h = mix(0.48, 0.05, a);\n  float d0 =  vesica(p, vec2(w, h));\n  return d0;\n}\n\nconst vec2 iris_center = vec2(0.0, 0.28);\nvec4 completeEye(vec2 p, float th) {\n  const float iris_outer = 0.622;\n  const float iris_inner = 0.285;\n  \n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  float dt0 = mix(0.0125, -0.0025, t0);\n\n  vec2 p0 = p;\n  float d0 = outerEye(p, th);\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1 -= iris_center;\n  float d1 = circle(p1, iris_outer);\n  d1 = max(d1,d0+dt0);\n  float d6 = d1;\n\n  vec2 p2 = p;\n  p2 -= vec2(0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3 -= iris_center;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-1.0*length(p1));\n\n  vec2 p4 = p;\n  p4 -= iris_center;\n  float d4 = circle(p4, iris_inner);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  d0 = abs(d0)-dt0;\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return vec4(d, d6, d5, max(d4, d6));\n}\n\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.1*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\n// https://iquilezles.org/www/articles/fbm/fbm.htm\nfloat fbm(vec2 p, float aa) {\n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); \n    p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= aa;\n  }\n  return f/s;\n}\n\n// https://iquilezles.org/www/articles/warp/warp.htm\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\n  const float r  = 0.5;\n  const float rr = 0.25;\n  float l2 = length(p);\n  float f  = 1.0;\n\n  f = smoothstep(-0.1, 0.15, completeEye(p, g_th).x);\n  const float rep = 50.0;\n  const float sm = 0.125*0.5*60.0/rep;\n  float  n = smoothKaleidoscope(p, sm, rep);\n  p.y += TIME*0.125+1.5*g_th;\n\n  g_hf = f;\n  vec2 pp = p;\n\n  vec2 vx = g_vx;\n  vec2 vy = g_vy;\n\n  vec2 wx = g_wx;\n  vec2 wy = g_wy;\n\n\n  //float aa = mix(0.95, 0.25, tanh_approx(pp.x));\n  float aa = 0.5;\n\n  v = vec2(fbm(p + vx, aa), fbm(p + vy, aa))*f;\n  w = vec2(fbm(p + 3.0*v + wx, aa), fbm(p + 3.0*v + wy, aa))*f;\n  \n  return -tanh_approx(fbm(p + 2.25*w, aa)*f);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvoid compute_globals() {\n\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vx *= ROT(TTIME/1000.0);\n  vy *= ROT(TTIME/900.0);\n\n  wx *= ROT(TTIME/800.0);\n  wy *= ROT(TTIME/700.0);\n  \n  g_vx = vx;\n  g_vy = vy;\n  \n  g_wx = wx;\n  g_wy = wy;\n}\n\nvec3 weird(vec2 p) {\n  const vec3 up  = vec3(0.0, 1.0, 0.0);\n  const vec3 lp1 = 1.0*vec3(1.0, 1.25, 1.0);\n  const vec3 lp2 = 1.0*vec3(-1.0, 2.5, 1.0);\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec2 v;\n  vec2 w;\n \n  float h  = warp(p, v, w);\n  float hf = g_hf;\n  vec3  n  = normal(p);\n\n  vec3 lcol1 = hsv2rgb(vec3(0.7, 0.5, 1.0)); \n  vec3 lcol2 = hsv2rgb(vec3(0.4, 0.5, 1.0));\n  vec3 po  = vec3(p.x, 0.0, p.y);\n  vec3 rd  = normalize(po - ro);\n  \n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 col1 = vec3(0.1, 0.7, 0.8).xzy;\n  const vec3 col2 = vec3(0.7, 0.3, 0.5).zyx;\n  \n  float a = length(p);\n  vec3 col = vec3(0.0);\n//  col -= 0.5*hsv2rgb(vec3(fract(0.3*TIME+0.25*a+0.5*v.x), 0.85, abs(tanh_approx(v.y))));\n//  col -= 0.5*hsv2rgb(vec3(fract(-0.5*TIME+0.25*a+0.125*w.x), 0.85, abs(tanh_approx(w.y))));\n  col += hsv2rgb(vec3(fract(-0.1*TIME+0.125*a+0.5*v.x+0.125*w.x), abs(0.5+tanh_approx(v.y*w.y)), tanh_approx(0.1+abs(v.y-w.y))));\n  col -= 0.5*(length(v)*col1 + length(w)*col2*1.0);\n  /*\n  col += 0.25*diff1;\n  col += 0.25*diff2;\n  */\n  col += 0.5*lcol1*pow(ref1, 20.0);\n  col += 0.5*lcol2*pow(ref2, 10.0);\n  col *= hf;\n\n  return col;\n}\n\nvec4 plane3(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h = hash(n+1234.4);\n  float th = TAU*h;\n  g_th = th;\n  float s = 1.*mix(0.2, 0.3, h);\n\n  vec3 hn;\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(0.2*mix(-1.0, 1.0, h));\n  p /= s;\n  float lp = length(p); \n  p -= -iris_center;\n  const float lw = 0.005;\n  vec4 de = completeEye(p, th)*s;\n  float ax = smoothstep(-aa, aa, de.x);\n  float ay = smoothstep(-aa, aa, de.y);\n  float az = smoothstep(-aa, aa, -de.z);\n  float aw = smoothstep(-aa, aa, 0.0125*(de.w+0.025));\n\n  float df = 1.0-tanh_approx(0.5*lp);\n  vec3 acol = vec3(df);\n  vec3 icol = weird(p);\n  vec3 ecol = mix(vec3(0.0), vec3(1.0), ax);\n  vec3 bcol = mix(icol, ecol, az*0.5*df);\n  vec4 col = vec4(bcol, aw);\n\n  return col;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  return plane3(ro, rd, pp, off, aa, n);\n}\n\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  vec3 baseCol = 1.0*vec3(2.0, 1.0, 3.0)*(pow(ld, 100.0));\n  return vec3(baseCol);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  const float per = 10.0;\n  float rdd = (1.0+0.5*lp*tanh_approx(lp+0.9*PCOS(per*p.x)*PCOS(per*p.y)));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.0;\n  const int furthest = 4;\n  const int fadeFrom = max(furthest-3, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  // Steps from nearest to furthest plane and accumulates the color\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n  \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  compute_globals();\n  \n  float tm  = TIME*0.5*BPM/60.0;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col += smoothstep(3.0, 0.0, TIME);\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "4tlSWB", "previewfilepath": "https://soundcloud.com/jezbuddha/astral-traveller", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/jezbuddha/astral-traveller", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXSzl.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[436, 436, 458, 458, 604], [980, 1037, 1076, 1076, 1165], [1167, 1167, 1206, 1206, 1235], [1237, 1237, 1267, 1267, 1295], [1297, 1297, 1319, 1319, 1367], [1369, 1369, 1409, 1409, 1568], [1570, 1570, 1610, 1610, 1652], [1654, 1654, 1682, 1702, 1778], [1780, 1812, 1851, 1851, 1976], [1978, 1978, 2000, 2000, 2044], [2046, 2046, 2067, 2067, 2112], [2114, 2114, 2159, 2159, 2313], [2315, 2315, 2376, 2376, 2589], [2591, 2591, 2622, 2622, 2648], [2650, 2735, 2766, 2766, 3064], [3066, 3066, 3100, 3100, 3283], [3327, 3327, 3363, 3363, 4208], [4211, 4232, 4254, 4254, 4386], [4388, 4467, 4490, 4490, 4565], [4567, 4637, 4661, 4661, 4740], [4742, 4742, 4763, 4763, 4885], [4887, 4938, 4967, 4967, 5219], [5221, 5274, 5318, 5318, 5941], [5943, 5943, 5964, 5964, 6186], [6188, 6188, 6212, 6212, 6493], [6495, 6495, 6515, 6515, 7894], [7896, 7896, 7965, 7965, 8662], [8664, 8664, 8732, 8732, 8775], [8778, 8778, 8811, 8811, 8949], [8951, 8951, 9007, 9007, 10545], [10547, 10574, 10610, 10610, 10843], [10845, 10845, 10874, 10874, 11204], [11206, 11206, 11261, 11261, 11485]], "test": "error"}
{"id": "NtXXRS", "name": "Truchet Lines", "author": "wildniklin", "description": "bon truchetit", "tags": ["sdf", "morph"], "likes": 6, "viewed": 181, "published": "Public API", "date": "1625880160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 100;\nconst float MAX_DIST = 50.0;\nconst float MIN_DIST = 0.001;\nconst float PI = 3.1415;\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat rand1(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 42.1581))) * 43758.5453123);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    vec3 m = abs(p) - s;\n    return length(max(m, 0.0)) + min(max(m.x, max(m.y, m.z)), 0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec3 closestPointLine(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n    float d = clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n    if(d < 0.0) return a; if(d > 1.0) return b; return mix(a, b, d);\n}\n\nfloat sdLine(vec3 p, vec3 a, vec3 b, float r) { return length(p - closestPointLine(p, a, b)) - r; }\n\nfloat sdTruchet(vec3 p, float r) {\n    r *= 2.0;\n    float d = min(min(min(sdSphere(p + vec3(0.5, 0.0, 0.0), r), sdSphere(p - vec3(0.5, 0.0, 0.0), r)), min(sdSphere(p + vec3(0.0, 0.5, 0.0), r), sdSphere(p - vec3(0.0, 0.5, 0.0), r))), min(sdSphere(p + vec3(0.0, 0.0, 0.5), r), sdSphere(p - vec3(0.0, 0.0, 0.5), r)));\n    r *= 0.5;\n    d = min(d, sdLine(p, vec3(0.0, 0.5, 0.0), vec3(0.0, 0.0, 0.5), r));\n    d = min(d, sdLine(p, vec3(0.0, -0.5, 0.0), vec3(0.5, 0.0, 0.0), r));\n    d = min(d, sdLine(p, vec3(-0.5, 0.0, 0.0), vec3(0.0, 0.0, -0.5), r));\n    return d;\n}\n\nfloat map(vec3 p) {\n    vec3 i = floor(p);\n    vec3 m = p - i - 0.5;\n    m.xz *= rot(floor(rand1(i) * 4.0) * PI * 0.5);\n    m.xy *= rot(floor(rand1(i + 62.0) * 4.0) * PI * 0.5);\n    m.yz *= rot(floor(rand1(i + 25.0) * 4.0) * PI * 0.5);\n    return sdTruchet(m, 0.05);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float ds = map(ro + (rd * d));\n        d += ds;\n        if(d > MAX_DIST) return MAX_DIST;\n        if(abs(ds) <= MIN_DIST) return d;\n    }\n    return MAX_DIST;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(MIN_DIST, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvec4 getCol(vec3 ro, vec3 rd, out float d, out vec3 p, out vec3 n) {\n    d = march(ro, rd);\n    p = ro + (rd * d);\n    n = normal(p);\n\n    vec3 col = vec3(sin(p * PI * 0.25) * 0.5 + 0.5);\n    \n    vec3 light = vec3(0.0);\n    \n    light += 1.4 * clamp(dot(n, normalize(vec3(0.7, 1.0, -0.5))), 0.0, 1.0);\n    light += 0.2;\n\n    col *= light;\n    col = mix(col, vec3(0.2, 0.2, 0.2), smoothstep(0.0, MAX_DIST, d));\n\n    return vec4(col, 1.0);\n}\n\nvec4 image(vec2 i, float t) {\n    vec2 uv = (i.xy - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(0., 0.0, iTime * 0.5);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    rd.yz *= rot(sin(iTime * PI * 0.05) * PI * 0.125);\n    rd.xz *= rot(cos(iTime * PI * 0.05) * PI * 0.125);\n\n    vec4 col = vec4(0.0);\n\n    float factor = 1.0;\n    \n    for(int i = 0; i < 3; i++) {\n        if(factor < 0.001) break;\n        \n        float d; vec3 p, n;\n        vec4 tc = getCol(ro, rd, d, p, n);\n        \n        col = mix(col, tc, factor);\n        \n        factor *= 0.2;\n        \n        ro = p + (n * MIN_DIST * 2.0);\n        rd = reflect(rd, n);\n    }\n    \n    col *= smoothstep(2.2, -0.5, length(uv));\n\n    return col;\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    o = image(i, iTime);\n}", "image_inputs": [{"id": "MtXXDB", "previewfilepath": "https://soundcloud.com/tonymakesmusic/flowing-with-the-wind", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/tonymakesmusic/flowing-with-the-wind", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXXRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 131, 131, 197], [199, 199, 220, 220, 301], [303, 303, 332, 332, 427], [429, 429, 462, 462, 490], [492, 492, 539, 539, 692], [694, 694, 741, 741, 793], [795, 795, 829, 829, 1359], [1361, 1361, 1380, 1380, 1629], [1631, 1631, 1662, 1662, 1891], [1893, 1893, 1914, 1914, 2107], [2109, 2109, 2177, 2177, 2549], [2551, 2551, 2580, 2580, 3295], [3297, 3297, 3333, 3333, 3360]], "test": "valid"}
{"id": "NtXXWj", "name": "Rotating light house/spotlight", "author": "napsternxg", "description": "If you need to shoot a video like girls like you by Maroon 5, you would need a spotlight rotating around the subject (black dot) like this. Now you can also imagine a bouncing effect for the spotlight\n", "tags": ["introduction"], "likes": 1, "viewed": 135, "published": "Public API", "date": "1626502074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 center = vec2(0.5, 0.5);\n    float tr = 0.2;\n    vec2 time_offset = vec2(tr*cos(iTime), tr*sin(iTime));\n    \n    vec2 tcenter = center + time_offset;\n    \n    vec2 tuv = uv - tcenter;\n    \n    \n    float dist = length(tuv);\n    float tlen = length(time_offset);\n    float tproj = dot(tuv, time_offset)/(dist*tlen);\n    \n    \n    vec3 col = vec3(0.8, 0.5, 0.1);\n    float alpha = 1.0;\n    \n    if(dist > 0.1*abs(cos(iTime))){\n        //col = vec3(abs(time_offset/tr)*0.5, 0.2*abs(cos(iTime)));\n        col = vec3(0.2*abs(cos(iTime)), 0.5*abs(cos(iTime)), 0.5*abs(cos(iTime)));\n    }\n    \n    if(tproj < (-0.99 -0.01*sin(iTime/2.0)) && tproj >= -1.0){\n        col = vec3(0.9, 0.9, 0.5);\n        alpha = 0.2;\n    }\n    \n    \n    if(dist < 0.01){\n        col = vec3(1, 1, 0.2);\n        alpha = 1.0;\n    }\n    \n    if(distance(uv, center) < 0.01){\n        col = vec3(0.2, 0.2, 0.2);\n        alpha = 1.0;\n    }\n    \n\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1228]], "test": "valid"}
{"id": "sl2SRW", "name": "Simple Planets", "author": "AshutoshR", "description": "Simple Planets rotating around a star", "tags": ["circle", "circlerotation"], "likes": 1, "viewed": 28, "published": "Public", "date": "1627227959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Circle {\n    vec2 position;\n    float radius;\n};\n\nCircle planets[5];\n\nvoid setUpScene() {\n\n    planets[0] = Circle(vec2(300,300), 40.0);\n\n    planets[1] = Circle(vec2(20 , 20), 4.0);\n    \n    planets[2] = Circle(vec2(0 , 0), 9.0);\n    \n    planets[3] = Circle(vec2(0 , 0), 10.0);\n    \n    planets[4] = Circle(vec2(0 , 0), 3.0);\n}\n\nvec3 getPColor(vec2 cord) {\n    for(int i = 0; i < 5; i++) {\n        float dist = distance(cord, planets[i].position);\n        if (dist < planets[i].radius) {\n            if (i == 0) {\n                return vec3(1.0 , 1.0, 0.0);\n            }\n            else if (i == 1) {\n                return vec3(1.0, 0.5, 0.0);\n            } \n            else if (i == 2) {\n                return vec3(0.4, 0.4, 0.0);\n            }\n            else if (i == 3) {\n                return vec3(0.0, 0.0, 1.0);\n            }\n            else if (i == 4) {\n                return vec3(0.5, 0.5, 0.5);\n            }\n            else {\n                return vec3(0.8, 0.5 , 1.0);\n            }\n        }\n    }\n    \n    return vec3(0.0 , 0.0 , 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setUpScene();\n    \n    planets[0].position = vec2(iResolution.x / 2.0, iResolution.y / 2.0);\n    \n    planets[1].position.x = sin(iTime / 5.0) * 60.0 + planets[0].position.x;\n    planets[1].position.y = cos(iTime / 5.0) * 60.0 + planets[0].position.y;\n    \n    planets[2].position.x = sin(iTime / 8.0) * 90.0 + planets[0].position.x;\n    planets[2].position.y = cos(iTime / 8.0) * 90.0 + planets[0].position.y;\n    \n    planets[3].position.x = sin((iTime / 8.0) + 150.0) * 150.0 + planets[0].position.x;\n    planets[3].position.y = cos((iTime / 8.0) + 150.0) * 150.0 + planets[0].position.y;\n    \n    planets[4].position.x = sin(iTime / 2.0) * 20.0 + planets[3].position.x;\n    planets[4].position.y = cos(iTime / 2.0) * 20.0 + planets[3].position.y;\n    \n    vec3 col = getPColor(fragCoord);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2SRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 96, 96, 336], [338, 338, 365, 365, 1073], [1075, 1075, 1132, 1132, 1986]], "test": "valid"}
{"id": "sl2XDD", "name": "COLORBURST", "author": "jj99", "description": "some colours", "tags": ["fbm", "colour"], "likes": 6, "viewed": 165, "published": "Public API", "date": "1627751484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*758.5453)*2.;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    //f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n            mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02+0.15;\n    f -= 0.25000*noise( p ); p = p*2.03+0.15;\n    f += 0.12500*noise( p ); p = p*2.01+0.15;\n    f += 0.06250*noise( p ); p = p*2.04+0.15;\n    f -= 0.03125*noise( p );\n    return f/0.984375;\n}\n\nfloat cloud(vec3 p)\n{\n    p-=fbm(vec3(p.x,p.y,0.0)*0.5)*0.7;\n    \n    float a =0.0;\n    a-=fbm(p*3.0)*2.2-1.1;\n    if (a<0.0) a=0.0;\n    a=a*a;\n    return a;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n\tvec2 position = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat ss = sin(length(position*3.0)+time*0.125);\n\tss+=5.0;\n    \n    \n   \tvec2 coord = ss*position;\n        coord*=rot(ss*0.1+time*0.037);\n    \n    \n    coord+=fbm(sin(vec3(coord*8.0,time*0.001)))*0.08;\n    coord+=time*0.0171;\n    float q = cloud((vec3(coord*1.0,0.222)));\n    coord+=time*0.0171;\n    q += cloud((vec3(coord*0.6,0.722)));\n    coord+=time*0.0171;\n    q += cloud(vec3(coord*0.3,.722));\n    coord+=time*0.1171;\n    q += cloud((vec3(coord*0.1,0.722)));\n    \n    \n\tfloat vv1 = sin(time+ss+coord.x)*0.3;\n\tfloat vv2 = sin(time*0.9+ss+coord.y)*0.2;\n\nvec3    col = vec3(1.7-vv2,1.7,1.7+vv1) + vec3(q*vec3(0.7+vv1,0.5,0.3+vv2*1.15));\n\tcol = pow(col,vec3(2.2));\n\t\n\tfloat dd = length(col*.48)+vv1;\n\t\n\tfloat nn = 0.5+sin(ss*.7+position.x*.41+time*0.9)*0.5;\n\t\n\tcol = mix(col,vec3(dd),nn);\n\t\n    fragColor = vec4( col*0.08, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2XDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 63], [65, 65, 91, 91, 440], [442, 442, 461, 461, 718], [720, 720, 741, 741, 879], [881, 881, 902, 902, 970], [972, 972, 1029, 1029, 1964]], "test": "valid"}
{"id": "slBSRz", "name": "1d noise(1)", "author": "SteelFlame", "description": "stratched by y noise in one dimension with offset in time", "tags": ["noise", "1d"], "likes": 2, "viewed": 29, "published": "Public", "date": "1626905859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smoot(float x) {\n    return -2.0*x*x*x+3.0*x*x;\n}\nfloat lerp(float a, float b, float t) {\n    return a+(b-a)*t;\n}\nfloat frac(float x) {\n    return x-floor(x);\n}\nfloat random(vec2 uv) {\n    return frac(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat noise(float x) {\n    float xInEdge = floor(x);\n    \n    float anchor0 = random(vec2(xInEdge,0));\n    float anchor1 = random(vec2(xInEdge+1.0,0));\n    \n    return lerp(anchor0,anchor1,smoot(frac(x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    fragColor = vec4(noise(uv.x+iTime));\n    fragColor = vec4(noise(uv.x+(uv.y)*iResolution.x/20.0+iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 55], [56, 56, 95, 95, 119], [120, 120, 141, 141, 166], [167, 167, 190, 190, 258], [259, 259, 281, 281, 466], [468, 468, 525, 525, 681]], "test": "valid"}
{"id": "slBSWR", "name": "water shader with perlin noise!", "author": "garrisonhh", "description": "perlin noise implementation", "tags": ["noise"], "likes": 2, "viewed": 58, "published": "Public", "date": "1627409485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 gradients3[] = vec3[](\n    vec3( 0,  1,  1),\n    vec3( 0,  1, -1),\n    vec3( 0, -1,  1),\n    vec3( 0, -1, -1),\n    vec3( 1,  1,  0),\n    vec3( 1, -1,  0),\n    vec3(-1,  1,  0),\n    vec3(-1, -1,  0),\n    vec3( 1,  0,  1),\n    vec3( 1,  0, -1),\n    vec3(-1,  0,  1),\n    vec3(-1,  0, -1)\n);\n\nconst int perm[256] = int[](\n    0xB6, 0xE8, 0x33, 0x0F, 0x37, 0x77, 0x07, 0x6B, 0xE6, 0xE3, 0x06, 0x22, 0xD8, 0x3D, 0xB7, 0x24,\n    0x28, 0x86, 0x4A, 0x2D, 0x9D, 0x4E, 0x51, 0x72, 0x91, 0x09, 0xD1, 0xBD, 0x93, 0x3A, 0x7E, 0x00,\n    0xF0, 0xA9, 0xE4, 0xEB, 0x43, 0xC6, 0x48, 0x40, 0x58, 0x62, 0x81, 0xC2, 0x63, 0x47, 0x1E, 0x7F,\n    0x12, 0x96, 0x9B, 0xB3, 0x84, 0x3E, 0x74, 0xC8, 0xFB, 0xB2, 0x20, 0x8C, 0x82, 0x8B, 0xFA, 0x1A,\n    0x97, 0xCB, 0x6A, 0x7B, 0x35, 0xFF, 0x4B, 0xFE, 0x56, 0xEA, 0xDF, 0x13, 0xC7, 0xF4, 0xF1, 0x01,\n    0xAC, 0x46, 0x18, 0x61, 0xC4, 0x0A, 0x5A, 0xF6, 0xFC, 0x44, 0x54, 0xA1, 0xEC, 0xCD, 0x50, 0x5B,\n    0xE9, 0xE1, 0xA4, 0xD9, 0xEF, 0xDC, 0x14, 0x2E, 0xCC, 0x23, 0x1F, 0xAF, 0x9A, 0x11, 0x85, 0x75,\n    0x49, 0xE0, 0x7D, 0x41, 0x4D, 0xAD, 0x03, 0x02, 0xF2, 0xDD, 0x78, 0xDA, 0x38, 0xBE, 0xA6, 0x0B,\n    0x8A, 0xD0, 0xE7, 0x32, 0x87, 0x6D, 0xD5, 0xBB, 0x98, 0xC9, 0x2F, 0xA8, 0xB9, 0xBA, 0xA7, 0xA5,\n    0x66, 0x99, 0x9C, 0x31, 0xCA, 0x45, 0xC3, 0x5C, 0x15, 0xE5, 0x3F, 0x68, 0xC5, 0x88, 0x94, 0x5E,\n    0xAB, 0x5D, 0x3B, 0x95, 0x17, 0x90, 0xA0, 0x39, 0x4C, 0x8D, 0x60, 0x9E, 0xA3, 0xDB, 0xED, 0x71,\n    0xCE, 0xB5, 0x70, 0x6F, 0xBF, 0x89, 0xCF, 0xD7, 0x0D, 0x53, 0xEE, 0xF9, 0x64, 0x83, 0x76, 0xF3,\n    0xA2, 0xF8, 0x2B, 0x42, 0xE2, 0x1B, 0xD3, 0x5F, 0xD6, 0x69, 0x6C, 0x65, 0xAA, 0x80, 0xD2, 0x57,\n    0x26, 0x2C, 0xAE, 0xBC, 0xB0, 0x27, 0x0E, 0x8F, 0x9F, 0x10, 0x7C, 0xDE, 0x21, 0xF7, 0x25, 0xF5,\n    0x08, 0x04, 0x16, 0x52, 0x6E, 0xB4, 0xB8, 0x0C, 0x19, 0x05, 0xC1, 0x29, 0x55, 0xB1, 0xC0, 0xFD,\n    0x4F, 0x1D, 0x73, 0x67, 0x8E, 0x92, 0x34, 0x30, 0x59, 0x36, 0x79, 0xD4, 0x7A, 0x3C, 0x1C, 0x2A\n);\n\nconst int num_water_colors = 4;\nconst vec3 water_colors[num_water_colors] = vec3[](\n    //vec3(75, 91, 171),\n    vec3(71, 119, 201),\n    vec3(77, 155, 219),\n    vec3(127, 193, 220),\n    vec3(174, 221, 202)\n    //vec3(237, 250, 241)\n);\n\nfloat perlin(vec3 pos) {\n    // get coordinate of cell and coordinate within cell\n    ivec3 grid_cell = ivec3(floor(pos)) & 0xFF;\n    vec3 cell_pos = fract(pos);\n    \n    // get 8 corner ivec3s\n    ivec3 corners[8];\n    \n    for (int i = 0; i < 8; i++)\n        corners[i] = ivec3((i >> 2) & 1, (i >> 1) & 1, i & 1);\n    \n    // calculate gradient indices through hash grid\n    int grid_indices[8];\n    \n    for (int i = 0; i < 8; i++) {\n        grid_indices[i] = perm[grid_cell.z + corners[i].z];\n        grid_indices[i] = perm[grid_cell.y + corners[i].y + grid_indices[i]];\n        grid_indices[i] = perm[grid_cell.x + corners[i].x + grid_indices[i]];\n        grid_indices[i] %= 12;\n    }\n    \n    // calculate noise contribution from each corner\n    float vals[8];\n    \n    for (int i = 0; i < 8; i++)\n        vals[i] = dot(gradients3[grid_indices[i]], cell_pos - vec3(corners[i]));\n\n    // interpolate\n    float interp2[4];\n    float interp1[2];\n    cell_pos = smoothstep(vec3(0.0), vec3(1.0), cell_pos);\n    \n    for (int i = 0; i < 4; i++)\n        interp2[i] = mix(vals[i], vals[i + 4], cell_pos.x);\n    \n    for (int i = 0; i < 2; i++)\n        interp1[i] = mix(interp2[i], interp2[i + 2], cell_pos.y);\n    \n    return mix(interp1[0], interp1[1], cell_pos.z);\n}\n\nvec3 pick_color(float noise_val) {\n    return water_colors[int(noise_val * float(num_water_colors))] / 255.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float SCALE = 10.0;\n    const vec2 PIXELS = vec2(320, 180);\n    \n    const vec3 BLUE = vec3(0.0, 0.5, 0.7);\n    const vec3 FOAM = vec3(0.7, 0.7, 0.7);\n\n    vec3 pos;\n    \n    pos.xy = (fragCoord / iResolution.xy);\n    pos.xy = floor(pos.xy * PIXELS) / PIXELS;\n    pos.xy *= SCALE;\n    \n    pos.z = iTime * 0.25;\n    \n    float v = perlin(pos);\n    \n    v = sqrt(abs(v));\n\n    fragColor = vec4(pick_color(v), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2169, 2169, 2193, 2250, 3435], [3437, 3437, 3471, 3471, 3548], [3550, 3550, 3605, 3605, 4031]], "test": "error"}
{"id": "slBSzh", "name": "CLIP+CPPN MATRIX | DOGE THIS!", "author": "atara", "description": "In theis CPPN and CLIP based, auto generated sahader code we see trinity taking down an agent in the Matrix`s iconic rooftop scene.", "tags": ["clipcppnmatrixtrinitydodgethisaigeneratedcodeneuralrendering"], "likes": 4, "viewed": 82, "published": "Public", "date": "1627048811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#define N_HIDDEN 20\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(0.310, -0.223, -0.021, 0.399) + mat4(vec4(0.887, -0.800, -0.029, 0.362), vec4(-0.023, -0.152, -1.400, -1.217), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[1] = vec4(0.384, 0.303, -0.053, -0.156) + mat4(vec4(1.262, -0.562, -0.221, 0.668), vec4(0.202, -0.349, 1.058, -0.689), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[2] = vec4(-0.384, 0.017, -0.092, -0.011) + mat4(vec4(-1.187, 0.054, -0.179, -0.529), vec4(-0.192, -0.618, -0.088, -0.065), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[3] = vec4(-0.173, 0.193, 0.269, -0.410) + mat4(vec4(-0.570, 0.150, 0.790, 0.265), vec4(0.648, 0.931, -0.846, 0.584), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[4] = vec4(0.423, -0.245, -0.162, -0.282) + mat4(vec4(-0.322, -0.123, -0.149, 0.843), vec4(0.834, 0.455, -0.183, 0.349), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(-0.214, -0.151, -0.261, 0.193) + mat4(vec4(-0.109, 0.041, -0.217, 0.259), vec4(-0.064, -0.190, -0.110, -0.023), vec4(-0.080, 0.114, 0.170, 0.135), vec4(0.298, 0.308, 0.150, -0.024)) * bufB[0] + mat4(vec4(0.189, 0.057, -0.147, 0.224), vec4(-0.131, 0.086, 0.014, -0.012), vec4(-0.067, -0.211, 0.234, 0.025), vec4(0.122, 0.513, 0.073, 0.178)) * bufB[1] + mat4(vec4(0.015, -0.164, -0.194, -0.253), vec4(-0.025, 0.118, -0.100, -0.056), vec4(-0.180, -0.216, 0.029, -0.094), vec4(0.217, -0.083, -0.090, -0.268)) * bufB[2] + mat4(vec4(0.091, -0.042, -0.183, 0.011), vec4(-0.133, -0.137, 0.121, -0.129), vec4(-0.043, 0.044, 0.152, 0.145), vec4(0.244, 0.058, -0.054, -0.232)) * bufB[3] + mat4(vec4(-0.000, -0.129, 0.071, 0.130), vec4(-0.271, -0.181, -0.151, -0.081), vec4(-0.102, -0.136, -0.153, 0.016), vec4(-0.174, -0.019, -0.079, 0.160)) * bufB[4] + mat4(vec4(-0.011, 0.080, -0.143, 0.129), vec4(-0.220, 0.045, -0.116, 0.020), vec4(0.330, -0.043, 0.022, -0.190), vec4(-0.092, -0.213, -0.188, -0.013)) * bufB[5] + mat4(vec4(0.102, 0.264, 0.000, 0.291), vec4(-0.307, -0.284, 0.055, -0.036), vec4(0.076, -0.346, -0.043, -0.395), vec4(0.041, 0.247, -0.044, -0.111)) * bufB[6] + mat4(vec4(-0.100, 0.155, 0.125, 0.275), vec4(0.040, -0.204, -0.077, -0.054), vec4(0.184, -0.040, -0.058, -0.018), vec4(-0.143, 0.103, 0.083, 0.029)) * bufB[7] + mat4(vec4(0.131, 0.013, -0.132, -0.046), vec4(-0.244, 0.076, -0.088, 0.219), vec4(0.112, 0.221, -0.077, -0.069), vec4(0.284, -0.040, 0.151, -0.268)) * bufB[8] + mat4(vec4(-0.311, 0.092, -0.362, 0.071), vec4(-0.050, -0.194, -0.088, 0.013), vec4(-0.049, -0.049, -0.151, 0.040), vec4(-0.037, 0.109, -0.384, 0.001)) * bufB[9];\nbufA[1] = vec4(-0.274, -0.357, -0.195, 0.345) + mat4(vec4(-0.088, -0.089, -0.057, -0.068), vec4(0.114, 0.041, 0.061, 0.032), vec4(0.224, 0.071, -0.039, 0.177), vec4(0.172, -0.131, -0.163, 0.149)) * bufB[0] + mat4(vec4(0.111, -0.238, -0.085, 0.059), vec4(0.140, -0.033, -0.104, -0.071), vec4(-0.176, 0.120, 0.054, -0.391), vec4(0.224, 0.189, -0.276, 0.253)) * bufB[1] + mat4(vec4(0.135, 0.337, 0.039, -0.175), vec4(0.160, 0.081, 0.108, 0.100), vec4(0.116, 0.114, -0.163, -0.035), vec4(0.150, 0.322, -0.171, -0.026)) * bufB[2] + mat4(vec4(-0.390, 0.072, 0.281, -0.349), vec4(-0.178, -0.331, 0.330, -0.491), vec4(-0.010, 0.117, -0.111, 0.098), vec4(-0.418, -0.201, -0.042, -0.088)) * bufB[3] + mat4(vec4(-0.190, 0.346, 0.255, 0.055), vec4(-0.049, 0.174, 0.199, -0.052), vec4(0.287, 0.083, 0.011, -0.181), vec4(-0.053, -0.413, 0.300, -0.072)) * bufB[4] + mat4(vec4(-0.003, -0.210, -0.164, 0.299), vec4(0.247, -0.029, -0.009, 0.115), vec4(-0.040, 0.127, -0.171, -0.090), vec4(0.012, 0.240, -0.127, 0.098)) * bufB[5] + mat4(vec4(-0.167, -0.029, -0.524, 0.307), vec4(0.198, -0.054, 0.043, 0.129), vec4(0.130, 0.344, -0.031, -0.299), vec4(-0.290, 0.120, -0.115, -0.070)) * bufB[6] + mat4(vec4(0.137, -0.082, 0.021, 0.034), vec4(0.042, -0.092, -0.034, 0.033), vec4(0.396, 0.257, -0.127, -0.227), vec4(0.143, -0.066, -0.185, 0.147)) * bufB[7] + mat4(vec4(-0.053, 0.312, -0.024, -0.154), vec4(-0.180, 0.228, -0.015, -0.374), vec4(0.061, -0.160, 0.164, -0.321), vec4(-0.179, 0.152, -0.147, -0.010)) * bufB[8] + mat4(vec4(-0.396, -0.033, 0.044, -0.327), vec4(0.236, 0.107, -0.141, 0.143), vec4(-0.066, 0.058, -0.134, -0.168), vec4(-0.304, 0.143, -0.064, -0.119)) * bufB[9];\nbufA[2] = vec4(-0.317, -0.336, -0.249, 0.425) + mat4(vec4(0.177, -0.031, -0.112, 0.196), vec4(-0.116, 0.096, 0.210, -0.243), vec4(-0.029, 0.100, -0.065, 0.004), vec4(0.054, -0.285, -0.224, 0.040)) * bufB[0] + mat4(vec4(0.049, 0.118, -0.232, 0.043), vec4(-0.213, 0.060, 0.146, -0.167), vec4(-0.209, 0.023, -0.085, -0.131), vec4(0.293, -0.304, -0.115, 0.085)) * bufB[1] + mat4(vec4(0.090, -0.110, 0.033, -0.283), vec4(-0.017, -0.164, 0.123, -0.023), vec4(-0.168, -0.042, 0.153, 0.022), vec4(-0.030, 0.085, 0.498, 0.023)) * bufB[2] + mat4(vec4(-0.209, -0.014, -0.009, -0.013), vec4(0.108, 0.005, 0.145, 0.165), vec4(0.210, 0.008, -0.232, 0.241), vec4(0.125, 0.052, -0.133, 0.137)) * bufB[3] + mat4(vec4(0.013, 0.238, 0.006, -0.037), vec4(0.022, -0.139, -0.060, 0.085), vec4(0.070, 0.257, -0.156, -0.301), vec4(0.292, 0.173, 0.093, 0.115)) * bufB[4] + mat4(vec4(-0.093, -0.205, -0.038, 0.092), vec4(0.139, -0.027, -0.093, -0.227), vec4(0.003, -0.113, 0.289, -0.203), vec4(-0.158, -0.338, 0.200, -0.126)) * bufB[5] + mat4(vec4(-0.287, -0.077, -0.134, -0.043), vec4(-0.122, -0.080, 0.150, -0.077), vec4(-0.188, 0.010, 0.084, -0.030), vec4(-0.298, -0.114, 0.107, 0.017)) * bufB[6] + mat4(vec4(0.486, -0.047, -0.268, 0.030), vec4(-0.022, 0.004, 0.206, 0.129), vec4(-0.005, -0.027, 0.090, 0.068), vec4(-0.041, -0.072, -0.257, -0.018)) * bufB[7] + mat4(vec4(-0.100, -0.214, -0.052, -0.039), vec4(-0.013, -0.050, 0.014, -0.033), vec4(0.219, -0.156, -0.122, -0.143), vec4(0.029, 0.020, 0.048, -0.060)) * bufB[8] + mat4(vec4(-0.018, 0.016, -0.020, -0.103), vec4(0.080, -0.068, 0.032, -0.048), vec4(-0.110, -0.008, -0.189, 0.088), vec4(-0.078, 0.151, 0.032, 0.081)) * bufB[9];\nbufA[3] = vec4(-0.408, 0.311, -0.091, 0.336) + mat4(vec4(0.052, 0.060, -0.095, -0.211), vec4(-0.238, -0.317, 0.126, 0.185), vec4(-0.168, 0.002, 0.156, -0.191), vec4(0.058, 0.222, 0.076, -0.131)) * bufB[0] + mat4(vec4(-0.170, 0.127, -0.095, -0.250), vec4(-0.060, -0.051, 0.273, 0.024), vec4(0.296, -0.039, -0.115, 0.094), vec4(-0.057, -0.077, -0.130, -0.047)) * bufB[1] + mat4(vec4(-0.152, -0.069, 0.307, 0.208), vec4(-0.004, 0.016, -0.183, 0.070), vec4(-0.195, -0.002, 0.018, 0.114), vec4(-0.299, -0.141, 0.259, -0.017)) * bufB[2] + mat4(vec4(-0.167, -0.138, -0.016, 0.166), vec4(0.047, 0.267, -0.178, 0.028), vec4(-0.008, 0.262, -0.134, -0.227), vec4(0.169, 0.130, -0.081, 0.033)) * bufB[3] + mat4(vec4(-0.270, 0.139, -0.044, 0.255), vec4(0.260, 0.118, -0.066, 0.101), vec4(-0.046, -0.042, 0.063, 0.084), vec4(0.226, 0.300, -0.077, -0.095)) * bufB[4] + mat4(vec4(0.341, 0.241, -0.274, 0.090), vec4(-0.010, 0.144, 0.026, 0.083), vec4(-0.139, -0.245, 0.074, 0.260), vec4(-0.112, -0.197, -0.107, -0.005)) * bufB[5] + mat4(vec4(0.060, -0.048, -0.112, 0.090), vec4(0.088, -0.041, -0.016, -0.115), vec4(0.010, -0.290, 0.145, -0.012), vec4(-0.120, -0.086, 0.217, 0.328)) * bufB[6] + mat4(vec4(-0.065, -0.163, -0.251, -0.123), vec4(0.173, 0.012, -0.027, 0.081), vec4(0.217, 0.018, 0.044, 0.167), vec4(0.366, -0.036, -0.213, 0.037)) * bufB[7] + mat4(vec4(0.038, 0.024, -0.244, 0.192), vec4(-0.217, 0.237, 0.033, 0.163), vec4(0.146, -0.057, 0.114, -0.081), vec4(-0.043, 0.012, -0.030, 0.059)) * bufB[8] + mat4(vec4(-0.198, -0.383, 0.088, 0.309), vec4(-0.268, 0.030, -0.049, 0.078), vec4(0.373, -0.171, 0.222, 0.146), vec4(-0.035, -0.165, -0.074, -0.098)) * bufB[9];\nbufA[4] = vec4(-0.236, 0.207, -0.335, -0.461) + mat4(vec4(0.186, -0.091, -0.044, 0.067), vec4(-0.263, 0.072, 0.019, 0.008), vec4(0.105, 0.069, 0.278, 0.062), vec4(0.136, -0.071, 0.146, 0.018)) * bufB[0] + mat4(vec4(0.245, 0.227, -0.036, -0.045), vec4(0.047, 0.031, 0.298, -0.274), vec4(0.111, -0.127, 0.013, 0.013), vec4(-0.220, 0.114, 0.015, 0.120)) * bufB[1] + mat4(vec4(0.100, 0.252, 0.120, -0.324), vec4(-0.299, -0.156, 0.182, 0.002), vec4(-0.407, -0.130, 0.188, 0.282), vec4(0.149, -0.053, -0.141, -0.356)) * bufB[2] + mat4(vec4(-0.109, -0.236, -0.090, -0.093), vec4(0.183, -0.024, 0.069, -0.007), vec4(0.215, 0.041, -0.059, 0.212), vec4(0.193, -0.132, -0.104, -0.053)) * bufB[3] + mat4(vec4(0.070, 0.192, 0.019, 0.114), vec4(0.003, -0.109, -0.148, 0.255), vec4(-0.030, -0.189, 0.423, -0.020), vec4(0.025, 0.006, -0.018, 0.207)) * bufB[4] + mat4(vec4(-0.320, 0.025, 0.059, -0.161), vec4(0.152, -0.223, 0.128, 0.081), vec4(-0.141, -0.003, 0.149, -0.185), vec4(-0.344, 0.222, 0.242, -0.007)) * bufB[5] + mat4(vec4(-0.148, -0.220, 0.121, -0.039), vec4(-0.115, -0.087, -0.021, -0.195), vec4(0.002, -0.053, 0.021, -0.139), vec4(0.050, 0.021, 0.167, -0.001)) * bufB[6] + mat4(vec4(0.255, -0.103, 0.024, -0.001), vec4(0.172, -0.086, 0.065, 0.002), vec4(0.054, 0.169, -0.086, 0.121), vec4(0.047, -0.075, -0.128, 0.331)) * bufB[7] + mat4(vec4(-0.021, -0.029, -0.015, -0.142), vec4(0.204, -0.180, -0.056, 0.042), vec4(0.007, -0.160, 0.282, -0.277), vec4(0.210, 0.073, -0.052, -0.281)) * bufB[8] + mat4(vec4(0.261, -0.074, 0.213, 0.160), vec4(0.024, 0.045, -0.237, -0.103), vec4(0.092, 0.121, 0.239, 0.265), vec4(-0.256, 0.044, 0.079, 0.120)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(0.346, -0.151, -0.146, 0.130) + mat4(vec4(0.029, -0.067, -0.101, 0.227), vec4(0.133, -0.128, -0.363, -0.094), vec4(0.145, -0.077, -0.097, 0.247), vec4(0.034, 0.223, -0.059, 0.186)) * bufB[0] + mat4(vec4(0.102, -0.213, -0.403, -0.317), vec4(-0.066, 0.149, -0.160, -0.146), vec4(0.005, -0.041, 0.265, -0.043), vec4(0.107, 0.203, 0.062, 0.052)) * bufB[1] + mat4(vec4(-0.125, 0.008, -0.007, -0.268), vec4(-0.010, -0.039, 0.451, 0.108), vec4(-0.004, -0.148, -0.073, -0.095), vec4(0.322, -0.130, 0.055, -0.283)) * bufB[2] + mat4(vec4(0.149, 0.256, 0.013, 0.021), vec4(-0.064, 0.012, 0.101, 0.003), vec4(-0.053, 0.019, 0.065, -0.166), vec4(-0.126, 0.083, 0.148, 0.199)) * bufB[3] + mat4(vec4(-0.219, 0.049, 0.005, -0.081), vec4(0.269, 0.023, -0.013, 0.074), vec4(0.125, 0.158, -0.091, 0.177), vec4(-0.003, -0.021, -0.012, -0.045)) * bufB[4] + mat4(vec4(-0.109, -0.013, -0.138, -0.008), vec4(-0.251, 0.106, -0.127, 0.092), vec4(-0.128, 0.192, -0.018, 0.164), vec4(0.064, -0.221, -0.182, 0.036)) * bufB[5] + mat4(vec4(-0.154, 0.040, 0.177, -0.101), vec4(0.369, -0.255, 0.119, 0.243), vec4(0.317, 0.081, 0.175, 0.059), vec4(-0.129, 0.250, -0.206, 0.104)) * bufB[6] + mat4(vec4(-0.492, -0.092, -0.000, -0.024), vec4(-0.008, 0.097, 0.248, -0.124), vec4(-0.051, 0.043, -0.030, 0.052), vec4(0.049, -0.033, -0.044, -0.177)) * bufB[7] + mat4(vec4(-0.181, -0.039, -0.202, 0.098), vec4(0.246, 0.153, 0.080, 0.058), vec4(-0.104, -0.188, -0.160, -0.014), vec4(0.046, -0.306, -0.216, -0.158)) * bufB[8] + mat4(vec4(0.051, 0.035, -0.114, 0.145), vec4(0.157, 0.134, -0.098, -0.078), vec4(0.071, -0.067, 0.368, -0.082), vec4(-0.229, -0.086, -0.259, 0.081)) * bufB[9];\nbufA[1] = vec4(-0.197, -0.077, 0.194, 0.300) + mat4(vec4(0.191, 0.217, -0.109, 0.020), vec4(-0.057, 0.172, 0.112, -0.191), vec4(-0.012, 0.129, -0.158, 0.213), vec4(0.042, 0.292, -0.068, -0.140)) * bufB[0] + mat4(vec4(-0.053, 0.028, -0.205, 0.095), vec4(-0.141, -0.349, -0.313, -0.000), vec4(-0.095, 0.111, -0.019, -0.072), vec4(0.379, 0.061, -0.140, 0.009)) * bufB[1] + mat4(vec4(-0.345, 0.222, 0.158, 0.255), vec4(0.221, 0.358, 0.210, 0.092), vec4(-0.053, -0.173, -0.090, -0.326), vec4(-0.205, 0.226, 0.181, -0.154)) * bufB[2] + mat4(vec4(-0.004, -0.036, 0.025, 0.042), vec4(-0.173, 0.129, 0.191, 0.112), vec4(-0.146, -0.341, 0.011, -0.216), vec4(0.110, -0.050, -0.116, 0.062)) * bufB[3] + mat4(vec4(0.219, -0.141, 0.041, 0.061), vec4(-0.261, 0.091, -0.080, -0.012), vec4(-0.102, -0.108, 0.136, -0.075), vec4(0.016, 0.125, 0.190, 0.125)) * bufB[4] + mat4(vec4(-0.111, 0.004, -0.102, 0.062), vec4(0.060, -0.166, -0.030, 0.120), vec4(-0.127, -0.017, -0.092, 0.054), vec4(-0.083, 0.036, 0.341, 0.009)) * bufB[5] + mat4(vec4(0.089, -0.050, -0.001, 0.052), vec4(0.053, 0.211, 0.128, 0.328), vec4(0.036, -0.319, -0.043, -0.087), vec4(0.012, -0.170, -0.370, -0.184)) * bufB[6] + mat4(vec4(0.147, -0.217, 0.033, 0.006), vec4(-0.040, 0.081, -0.120, 0.029), vec4(0.329, 0.189, 0.044, -0.144), vec4(-0.013, 0.196, -0.043, 0.228)) * bufB[7] + mat4(vec4(-0.026, -0.031, -0.214, -0.241), vec4(-0.088, 0.510, 0.094, 0.235), vec4(0.018, -0.074, 0.064, 0.176), vec4(0.275, 0.174, -0.011, -0.083)) * bufB[8] + mat4(vec4(0.211, -0.055, -0.154, 0.080), vec4(-0.054, 0.100, -0.075, -0.145), vec4(-0.211, -0.016, 0.069, -0.007), vec4(-0.017, -0.236, 0.065, -0.089)) * bufB[9];\nbufA[2] = vec4(-0.162, -0.058, 0.409, 0.299) + mat4(vec4(-0.080, 0.225, -0.121, -0.030), vec4(0.161, -0.164, -0.005, -0.221), vec4(0.263, -0.084, 0.081, -0.040), vec4(0.209, -0.251, 0.091, -0.351)) * bufB[0] + mat4(vec4(-0.047, 0.163, -0.226, -0.022), vec4(-0.060, -0.001, 0.021, 0.030), vec4(-0.051, -0.168, 0.044, 0.022), vec4(0.198, 0.052, 0.151, -0.171)) * bufB[1] + mat4(vec4(0.206, 0.002, 0.165, 0.110), vec4(0.081, 0.013, 0.093, 0.295), vec4(-0.376, 0.011, -0.451, 0.097), vec4(0.188, -0.005, 0.296, 0.041)) * bufB[2] + mat4(vec4(-0.096, -0.138, -0.178, 0.006), vec4(0.141, 0.025, 0.252, 0.216), vec4(0.251, 0.021, -0.119, 0.059), vec4(-0.269, 0.084, -0.133, -0.133)) * bufB[3] + mat4(vec4(-0.082, 0.049, 0.042, -0.048), vec4(0.004, 0.103, -0.080, 0.315), vec4(0.022, 0.057, -0.162, 0.154), vec4(-0.103, -0.006, -0.253, 0.071)) * bufB[4] + mat4(vec4(-0.261, -0.017, -0.123, 0.124), vec4(0.035, 0.063, -0.054, -0.239), vec4(0.312, -0.109, -0.015, 0.026), vec4(0.171, -0.156, -0.008, -0.186)) * bufB[5] + mat4(vec4(-0.007, 0.230, -0.454, 0.196), vec4(0.116, -0.045, 0.020, 0.066), vec4(-0.046, -0.005, -0.013, 0.315), vec4(-0.233, -0.164, -0.148, -0.262)) * bufB[6] + mat4(vec4(-0.211, -0.030, -0.020, -0.181), vec4(-0.172, -0.110, -0.168, 0.242), vec4(-0.383, 0.162, 0.117, -0.310), vec4(-0.070, 0.197, 0.193, -0.034)) * bufB[7] + mat4(vec4(0.005, -0.081, -0.227, 0.051), vec4(-0.025, -0.100, -0.013, -0.143), vec4(0.218, 0.069, -0.069, 0.152), vec4(0.128, -0.264, 0.112, -0.218)) * bufB[8] + mat4(vec4(-0.010, 0.247, 0.050, -0.072), vec4(0.062, -0.044, 0.261, 0.018), vec4(0.293, -0.003, 0.006, -0.012), vec4(0.137, -0.058, 0.137, -0.065)) * bufB[9];\nbufA[3] = vec4(-0.317, 0.091, -0.251, -0.034) + mat4(vec4(-0.062, 0.037, 0.025, 0.084), vec4(0.161, -0.097, -0.094, 0.020), vec4(0.013, -0.383, -0.088, -0.014), vec4(0.114, -0.309, -0.098, 0.015)) * bufB[0] + mat4(vec4(-0.208, 0.124, 0.095, 0.273), vec4(0.083, 0.091, 0.045, -0.075), vec4(-0.087, -0.033, 0.231, 0.017), vec4(0.356, -0.033, -0.040, 0.077)) * bufB[1] + mat4(vec4(0.111, 0.171, -0.037, 0.226), vec4(-0.099, -0.175, 0.115, 0.147), vec4(-0.114, 0.039, 0.010, 0.007), vec4(0.028, -0.057, -0.150, -0.064)) * bufB[2] + mat4(vec4(-0.194, 0.320, -0.094, -0.102), vec4(-0.005, -0.247, 0.007, 0.029), vec4(-0.114, 0.139, 0.084, -0.001), vec4(-0.051, 0.148, -0.193, -0.034)) * bufB[3] + mat4(vec4(-0.078, 0.095, -0.014, -0.133), vec4(-0.138, 0.049, -0.082, 0.230), vec4(-0.026, 0.158, 0.040, -0.021), vec4(0.165, 0.293, 0.064, 0.107)) * bufB[4] + mat4(vec4(0.020, -0.016, -0.067, -0.065), vec4(-0.013, -0.031, -0.146, -0.092), vec4(0.033, -0.121, 0.208, -0.024), vec4(0.033, 0.173, -0.176, 0.138)) * bufB[5] + mat4(vec4(0.063, 0.027, -0.092, -0.291), vec4(-0.030, -0.257, -0.089, -0.006), vec4(0.112, -0.068, 0.091, 0.078), vec4(-0.132, -0.279, -0.202, 0.229)) * bufB[6] + mat4(vec4(0.047, 0.061, -0.165, -0.083), vec4(0.086, -0.144, 0.224, -0.082), vec4(-0.016, 0.297, -0.186, -0.020), vec4(0.115, 0.181, 0.136, 0.102)) * bufB[7] + mat4(vec4(0.260, -0.189, -0.049, -0.320), vec4(0.305, 0.134, -0.187, -0.053), vec4(-0.056, 0.230, -0.122, 0.227), vec4(-0.082, 0.170, 0.143, 0.163)) * bufB[8] + mat4(vec4(0.055, 0.178, -0.035, -0.133), vec4(-0.182, -0.119, 0.006, -0.003), vec4(0.070, 0.130, 0.453, -0.089), vec4(-0.026, 0.069, 0.111, 0.031)) * bufB[9];\nbufA[4] = vec4(0.413, -0.204, 0.372, 0.007) + mat4(vec4(0.151, 0.168, -0.041, 0.016), vec4(0.130, 0.016, -0.024, 0.026), vec4(0.314, 0.107, 0.110, -0.257), vec4(-0.004, 0.104, 0.081, 0.053)) * bufB[0] + mat4(vec4(-0.038, 0.161, -0.158, -0.202), vec4(-0.105, -0.165, 0.205, -0.086), vec4(0.032, -0.048, 0.052, -0.009), vec4(0.098, -0.009, -0.084, 0.031)) * bufB[1] + mat4(vec4(-0.040, -0.280, -0.137, -0.139), vec4(-0.168, 0.314, -0.073, -0.065), vec4(-0.285, 0.132, 0.036, -0.022), vec4(0.090, 0.347, 0.156, -0.254)) * bufB[2] + mat4(vec4(-0.113, 0.059, -0.050, 0.125), vec4(0.158, 0.037, 0.089, -0.255), vec4(-0.162, 0.019, 0.277, -0.077), vec4(-0.042, 0.193, -0.149, -0.174)) * bufB[3] + mat4(vec4(0.093, -0.086, 0.074, 0.230), vec4(-0.175, -0.179, -0.090, -0.002), vec4(-0.011, 0.308, 0.485, -0.075), vec4(0.113, 0.126, -0.151, 0.273)) * bufB[4] + mat4(vec4(0.167, 0.132, -0.109, -0.052), vec4(0.041, 0.103, -0.309, 0.026), vec4(0.331, -0.110, -0.148, 0.079), vec4(0.176, -0.411, -0.231, 0.109)) * bufB[5] + mat4(vec4(0.165, -0.280, 0.226, 0.136), vec4(0.480, -0.150, 0.280, 0.229), vec4(-0.027, 0.018, -0.040, 0.181), vec4(-0.294, -0.271, -0.175, -0.260)) * bufB[6] + mat4(vec4(-0.030, 0.146, -0.069, 0.041), vec4(0.132, -0.093, 0.072, -0.171), vec4(0.088, -0.055, -0.267, -0.020), vec4(0.184, -0.084, -0.224, 0.084)) * bufB[7] + mat4(vec4(-0.318, -0.039, -0.082, -0.222), vec4(0.019, 0.195, -0.107, -0.107), vec4(-0.025, -0.041, -0.229, -0.100), vec4(-0.089, 0.091, -0.253, -0.141)) * bufB[8] + mat4(vec4(-0.115, -0.101, 0.151, -0.091), vec4(-0.117, 0.220, -0.233, -0.061), vec4(0.118, 0.049, 0.126, 0.202), vec4(-0.083, -0.141, 0.092, -0.036)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(-0.097, -0.496, 0.163, -0.388) + mat4(vec4(0.479, -0.189, 0.227, -0.174), vec4(-0.361, -0.020, -0.154, 0.175), vec4(0.121, -0.002, 0.073, 0.312), vec4(-0.002, -0.212, 0.127, 0.068)) * bufB[0] + mat4(vec4(-0.127, -0.075, -0.056, 0.025), vec4(-0.201, -0.156, -0.112, -0.017), vec4(-0.212, 0.016, 0.170, 0.105), vec4(-0.062, -0.068, -0.114, 0.177)) * bufB[1] + mat4(vec4(-0.011, -0.079, -0.032, -0.005), vec4(-0.379, 0.082, -0.239, 0.120), vec4(0.300, 0.077, 0.084, -0.063), vec4(0.267, -0.029, -0.024, 0.124)) * bufB[2] + mat4(vec4(0.020, 0.013, 0.113, 0.137), vec4(-0.067, 0.106, 0.008, 0.138), vec4(0.091, 0.125, -0.183, 0.214), vec4(0.090, 0.070, -0.131, -0.290)) * bufB[3] + mat4(vec4(0.086, -0.234, 0.163, 0.061), vec4(-0.053, -0.235, -0.098, 0.228), vec4(-0.028, -0.172, 0.436, 0.190), vec4(-0.005, -0.016, 0.071, 0.205)) * bufB[4] + mat4(vec4(-0.015, 0.347, 0.025, 0.186), vec4(-0.288, 0.078, -0.240, 0.128), vec4(0.107, -0.084, -0.079, 0.164), vec4(-0.057, 0.043, 0.189, 0.021)) * bufB[5] + mat4(vec4(-0.115, 0.146, 0.024, 0.022), vec4(0.057, -0.114, -0.046, -0.030), vec4(0.107, -0.229, 0.053, 0.076), vec4(-0.098, 0.323, -0.088, 0.147)) * bufB[6] + mat4(vec4(-0.004, -0.073, -0.039, 0.023), vec4(-0.143, 0.227, 0.117, 0.017), vec4(-0.130, -0.062, 0.214, 0.033), vec4(-0.492, -0.097, -0.166, 0.141)) * bufB[7] + mat4(vec4(0.195, -0.183, -0.122, -0.050), vec4(0.061, 0.054, 0.110, -0.159), vec4(-0.237, -0.054, 0.229, 0.071), vec4(-0.247, 0.043, -0.059, -0.107)) * bufB[8] + mat4(vec4(0.097, -0.119, 0.199, -0.079), vec4(0.018, -0.061, 0.115, 0.144), vec4(-0.301, -0.234, 0.272, 0.101), vec4(0.154, 0.123, -0.053, -0.032)) * bufB[9] + in0;\nbufA[1] = vec4(0.276, 0.397, -0.305, -0.070) + mat4(vec4(0.108, 0.021, -0.047, -0.151), vec4(0.095, 0.241, 0.072, -0.083), vec4(0.047, -0.331, -0.122, -0.248), vec4(-0.152, 0.122, 0.202, 0.225)) * bufB[0] + mat4(vec4(0.027, -0.131, -0.018, -0.130), vec4(0.045, -0.172, -0.159, 0.005), vec4(-0.318, -0.017, 0.128, 0.065), vec4(0.107, 0.278, -0.071, -0.113)) * bufB[1] + mat4(vec4(0.194, 0.157, -0.094, -0.235), vec4(0.005, 0.108, -0.170, -0.080), vec4(0.066, 0.005, -0.159, 0.185), vec4(-0.021, 0.520, -0.037, -0.237)) * bufB[2] + mat4(vec4(-0.242, -0.010, 0.182, 0.082), vec4(0.031, 0.234, -0.086, -0.067), vec4(0.031, 0.115, 0.033, -0.037), vec4(0.192, -0.018, -0.206, 0.312)) * bufB[3] + mat4(vec4(-0.044, 0.004, 0.106, 0.021), vec4(-0.195, -0.115, -0.063, -0.243), vec4(0.034, 0.140, 0.135, -0.092), vec4(-0.166, -0.013, -0.056, -0.243)) * bufB[4] + mat4(vec4(-0.229, 0.120, 0.121, 0.012), vec4(0.109, 0.103, 0.160, -0.053), vec4(0.021, 0.448, -0.057, -0.239), vec4(0.204, -0.049, -0.141, -0.015)) * bufB[5] + mat4(vec4(-0.018, 0.013, 0.081, -0.017), vec4(-0.134, 0.092, -0.068, 0.200), vec4(0.124, 0.180, 0.209, 0.075), vec4(0.031, 0.169, -0.180, -0.150)) * bufB[6] + mat4(vec4(-0.097, -0.029, 0.197, -0.012), vec4(0.008, 0.047, 0.025, -0.088), vec4(-0.230, -0.143, 0.035, -0.073), vec4(-0.292, 0.135, 0.076, -0.198)) * bufB[7] + mat4(vec4(-0.005, 0.198, 0.183, 0.098), vec4(0.001, -0.008, 0.163, -0.090), vec4(-0.226, 0.202, -0.100, -0.103), vec4(0.030, 0.048, -0.187, 0.281)) * bufB[8] + mat4(vec4(-0.130, 0.049, 0.144, -0.049), vec4(-0.201, -0.023, -0.376, -0.016), vec4(-0.080, 0.059, -0.009, 0.010), vec4(0.020, -0.148, -0.164, 0.172)) * bufB[9] + in1;\nbufA[2] = vec4(-0.056, -0.153, 0.309, -0.078) + mat4(vec4(0.202, -0.231, 0.082, -0.077), vec4(-0.101, 0.041, -0.094, -0.282), vec4(-0.017, -0.118, -0.284, 0.027), vec4(0.009, 0.121, 0.047, -0.029)) * bufB[0] + mat4(vec4(0.268, 0.064, -0.204, 0.043), vec4(-0.084, -0.078, -0.149, 0.292), vec4(-0.018, -0.021, 0.164, -0.024), vec4(0.088, 0.012, 0.010, 0.018)) * bufB[1] + mat4(vec4(-0.010, 0.179, 0.045, 0.175), vec4(-0.000, 0.211, -0.081, 0.159), vec4(-0.132, 0.074, -0.197, 0.008), vec4(-0.036, -0.121, 0.193, 0.191)) * bufB[2] + mat4(vec4(0.007, -0.024, -0.032, 0.022), vec4(0.176, 0.123, -0.223, -0.014), vec4(-0.282, -0.118, -0.037, -0.013), vec4(0.152, -0.167, -0.076, 0.290)) * bufB[3] + mat4(vec4(-0.015, -0.190, 0.010, 0.169), vec4(0.042, 0.259, -0.004, 0.060), vec4(0.064, 0.026, 0.378, 0.118), vec4(0.090, -0.139, -0.052, -0.077)) * bufB[4] + mat4(vec4(-0.344, 0.027, 0.052, 0.296), vec4(0.018, 0.180, -0.006, -0.107), vec4(0.335, 0.132, 0.172, 0.126), vec4(-0.050, -0.088, -0.151, 0.064)) * bufB[5] + mat4(vec4(0.112, 0.168, 0.150, 0.106), vec4(-0.155, 0.139, -0.153, 0.035), vec4(0.133, 0.112, -0.158, 0.021), vec4(0.154, 0.093, -0.337, -0.046)) * bufB[6] + mat4(vec4(-0.056, -0.008, 0.409, 0.090), vec4(0.133, -0.058, -0.235, -0.029), vec4(0.006, -0.048, 0.048, -0.074), vec4(0.071, -0.157, -0.064, -0.152)) * bufB[7] + mat4(vec4(0.035, 0.031, -0.073, -0.220), vec4(-0.117, -0.164, 0.092, 0.074), vec4(0.020, 0.175, 0.040, 0.025), vec4(0.013, -0.012, -0.178, 0.174)) * bufB[8] + mat4(vec4(0.264, -0.047, 0.206, 0.157), vec4(0.070, 0.191, -0.182, 0.010), vec4(-0.009, 0.037, -0.292, -0.156), vec4(0.364, -0.138, 0.176, 0.205)) * bufB[9] + in2;\nbufA[3] = vec4(0.019, -0.093, 0.384, -0.040) + mat4(vec4(0.052, 0.118, -0.095, 0.078), vec4(0.023, -0.128, 0.141, 0.078), vec4(0.135, 0.095, 0.223, 0.206), vec4(0.154, -0.082, -0.119, -0.070)) * bufB[0] + mat4(vec4(-0.188, -0.078, 0.065, -0.090), vec4(0.185, 0.259, -0.134, 0.540), vec4(0.186, -0.200, 0.076, 0.120), vec4(0.059, 0.171, 0.191, 0.195)) * bufB[1] + mat4(vec4(0.061, -0.080, -0.112, 0.075), vec4(-0.013, -0.229, 0.026, -0.199), vec4(0.152, 0.114, 0.039, 0.048), vec4(-0.412, -0.158, -0.065, -0.119)) * bufB[2] + mat4(vec4(0.164, 0.286, -0.082, -0.129), vec4(0.179, 0.038, -0.160, -0.096), vec4(0.066, 0.128, 0.059, -0.122), vec4(-0.139, 0.131, 0.046, 0.078)) * bufB[3] + mat4(vec4(0.141, -0.002, 0.005, 0.248), vec4(-0.009, 0.081, 0.118, -0.107), vec4(-0.041, -0.204, -0.094, -0.116), vec4(-0.181, -0.134, 0.131, 0.272)) * bufB[4] + mat4(vec4(0.148, 0.236, 0.219, 0.147), vec4(0.226, -0.064, 0.106, 0.108), vec4(-0.564, 0.047, -0.121, -0.146), vec4(-0.193, -0.003, 0.001, -0.037)) * bufB[5] + mat4(vec4(-0.059, -0.045, -0.017, 0.051), vec4(0.128, -0.135, 0.090, 0.081), vec4(-0.075, -0.206, 0.100, -0.177), vec4(0.126, -0.588, -0.094, -0.025)) * bufB[6] + mat4(vec4(0.145, -0.115, 0.174, 0.293), vec4(0.116, 0.294, 0.233, 0.199), vec4(0.276, 0.173, 0.166, 0.204), vec4(-0.140, -0.065, 0.296, 0.140)) * bufB[7] + mat4(vec4(-0.001, 0.013, 0.125, 0.007), vec4(0.044, 0.062, -0.199, -0.148), vec4(-0.019, -0.252, 0.198, 0.125), vec4(-0.123, -0.188, -0.130, 0.121)) * bufB[8] + mat4(vec4(0.068, 0.108, 0.011, 0.149), vec4(-0.013, -0.303, 0.076, -0.235), vec4(-0.244, -0.394, 0.052, -0.189), vec4(-0.096, -0.103, -0.120, -0.271)) * bufB[9] + in3;\nbufA[4] = vec4(-0.347, -0.324, 0.325, -0.432) + mat4(vec4(-0.025, 0.008, -0.108, 0.068), vec4(-0.078, -0.012, 0.184, 0.212), vec4(-0.160, 0.322, 0.141, -0.167), vec4(0.012, -0.196, -0.108, 0.114)) * bufB[0] + mat4(vec4(-0.002, -0.071, 0.041, -0.012), vec4(-0.188, -0.086, -0.205, 0.008), vec4(0.127, 0.233, 0.017, 0.110), vec4(-0.101, 0.186, -0.264, -0.050)) * bufB[1] + mat4(vec4(-0.162, -0.115, 0.017, 0.191), vec4(0.158, 0.129, 0.150, -0.000), vec4(-0.003, 0.126, -0.151, 0.171), vec4(0.078, 0.150, -0.136, 0.092)) * bufB[2] + mat4(vec4(0.067, 0.026, -0.223, 0.151), vec4(0.105, 0.143, -0.158, 0.241), vec4(-0.343, 0.177, -0.003, 0.010), vec4(-0.266, 0.094, -0.029, 0.045)) * bufB[3] + mat4(vec4(0.082, -0.124, -0.033, 0.074), vec4(-0.311, 0.053, -0.164, 0.101), vec4(0.286, -0.335, -0.178, 0.243), vec4(-0.103, 0.144, -0.109, 0.020)) * bufB[4] + mat4(vec4(-0.095, 0.186, 0.136, 0.016), vec4(-0.003, 0.027, 0.049, 0.027), vec4(0.292, -0.173, 0.246, -0.366), vec4(0.001, 0.090, -0.069, 0.035)) * bufB[5] + mat4(vec4(-0.078, -0.119, -0.022, 0.038), vec4(0.236, 0.049, -0.101, 0.278), vec4(0.233, 0.192, -0.243, -0.020), vec4(0.297, 0.233, -0.037, -0.062)) * bufB[6] + mat4(vec4(0.053, -0.081, -0.104, -0.226), vec4(-0.219, 0.194, -0.055, 0.145), vec4(-0.194, -0.169, -0.113, 0.106), vec4(0.281, -0.284, 0.043, -0.115)) * bufB[7] + mat4(vec4(0.259, 0.084, 0.023, 0.082), vec4(-0.007, -0.151, -0.072, -0.068), vec4(0.089, -0.384, -0.106, -0.064), vec4(0.097, 0.081, -0.071, 0.034)) * bufB[8] + mat4(vec4(0.132, 0.023, 0.079, 0.173), vec4(0.135, 0.225, -0.141, -0.028), vec4(0.093, -0.021, -0.229, -0.076), vec4(-0.028, -0.131, 0.096, -0.167)) * bufB[9] + in0;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(-0.396, 0.228, -0.116, 0.281) + mat4(vec4(-0.158, 0.021, -0.258, -0.043), vec4(0.056, -0.080, 0.021, 0.123), vec4(0.123, -0.036, -0.072, -0.084), vec4(-0.078, 0.134, -0.273, 0.018)) * bufB[0] + mat4(vec4(-0.289, 0.007, 0.055, 0.352), vec4(0.245, 0.296, 0.033, 0.195), vec4(-0.224, -0.054, -0.110, 0.036), vec4(-0.218, -0.146, 0.209, -0.087)) * bufB[1] + mat4(vec4(-0.226, -0.225, -0.081, -0.210), vec4(-0.021, -0.079, 0.312, 0.035), vec4(0.038, 0.154, -0.089, 0.084), vec4(0.336, 0.222, 0.152, -0.486)) * bufB[2] + mat4(vec4(0.277, -0.191, 0.232, -0.102), vec4(0.239, 0.233, 0.338, -0.112), vec4(0.071, -0.067, -0.096, 0.140), vec4(0.063, 0.069, 0.074, -0.153)) * bufB[3] + mat4(vec4(0.197, -0.039, -0.189, 0.161), vec4(-0.015, -0.103, -0.110, 0.131), vec4(0.103, -0.301, 0.013, -0.033), vec4(-0.188, -0.054, 0.087, 0.183)) * bufB[4] + mat4(vec4(-0.507, 0.043, 0.329, 0.390), vec4(0.279, 0.164, -0.135, 0.022), vec4(-0.052, -0.079, -0.053, 0.010), vec4(-0.323, -0.076, 0.085, 0.045)) * bufB[5] + mat4(vec4(-0.066, 0.002, 0.044, -0.093), vec4(-0.101, -0.078, -0.087, -0.040), vec4(0.140, -0.008, -0.186, -0.091), vec4(0.159, -0.036, -0.177, -0.108)) * bufB[6] + mat4(vec4(-0.132, 0.183, 0.050, -0.125), vec4(0.121, -0.194, 0.119, -0.098), vec4(-0.047, 0.077, -0.252, -0.048), vec4(0.043, -0.072, -0.138, 0.080)) * bufB[7] + mat4(vec4(0.050, -0.094, 0.032, 0.179), vec4(-0.280, 0.167, 0.298, 0.050), vec4(0.024, -0.020, -0.021, -0.091), vec4(0.069, 0.015, 0.504, -0.011)) * bufB[8] + mat4(vec4(-0.339, 0.137, 0.038, 0.155), vec4(0.233, -0.164, 0.062, -0.186), vec4(-0.103, -0.112, 0.063, 0.006), vec4(-0.100, -0.200, -0.264, 0.103)) * bufB[9];\nbufA[1] = vec4(0.174, -0.116, -0.003, 0.018) + mat4(vec4(0.060, -0.205, 0.047, 0.171), vec4(-0.016, -0.038, -0.026, 0.089), vec4(-0.030, -0.010, 0.084, -0.022), vec4(0.112, -0.085, -0.042, 0.112)) * bufB[0] + mat4(vec4(0.158, -0.047, -0.056, -0.217), vec4(0.008, 0.177, -0.018, 0.145), vec4(0.162, 0.360, 0.083, 0.074), vec4(-0.062, -0.279, -0.163, -0.212)) * bufB[1] + mat4(vec4(-0.464, 0.049, -0.341, 0.219), vec4(-0.177, 0.134, -0.205, -0.045), vec4(-0.027, -0.158, 0.183, -0.415), vec4(0.070, 0.200, 0.075, 0.251)) * bufB[2] + mat4(vec4(-0.166, -0.016, 0.063, 0.099), vec4(0.218, -0.316, 0.175, 0.270), vec4(-0.019, 0.137, -0.282, 0.260), vec4(0.171, 0.099, 0.089, 0.174)) * bufB[3] + mat4(vec4(-0.228, 0.514, -0.201, 0.175), vec4(-0.255, -0.095, 0.055, 0.299), vec4(0.002, 0.031, -0.113, -0.004), vec4(-0.145, 0.226, 0.075, -0.052)) * bufB[4] + mat4(vec4(0.244, 0.091, 0.136, -0.079), vec4(-0.036, 0.106, -0.022, 0.221), vec4(-0.130, 0.163, 0.026, -0.104), vec4(0.202, 0.144, 0.168, -0.090)) * bufB[5] + mat4(vec4(-0.140, 0.045, -0.354, -0.137), vec4(0.003, 0.048, -0.094, -0.038), vec4(-0.004, -0.064, -0.232, 0.004), vec4(0.115, -0.104, 0.106, -0.172)) * bufB[6] + mat4(vec4(0.185, -0.246, -0.188, -0.136), vec4(0.040, -0.140, -0.006, -0.145), vec4(0.165, -0.018, 0.111, 0.142), vec4(0.130, -0.067, -0.205, -0.209)) * bufB[7] + mat4(vec4(-0.023, -0.064, 0.165, -0.210), vec4(-0.088, -0.081, -0.009, 0.068), vec4(-0.103, 0.228, 0.024, -0.098), vec4(0.030, 0.222, -0.219, 0.243)) * bufB[8] + mat4(vec4(0.004, -0.170, -0.252, -0.331), vec4(0.034, -0.256, -0.024, 0.258), vec4(-0.070, 0.179, -0.275, -0.032), vec4(0.064, -0.117, 0.072, -0.073)) * bufB[9];\nbufA[2] = vec4(0.016, -0.364, -0.039, -0.002) + mat4(vec4(-0.175, -0.216, 0.170, 0.129), vec4(0.115, 0.170, -0.216, 0.156), vec4(0.084, 0.054, 0.127, 0.309), vec4(-0.258, -0.160, -0.243, -0.047)) * bufB[0] + mat4(vec4(0.075, -0.113, -0.014, 0.016), vec4(0.033, -0.235, -0.064, -0.354), vec4(0.111, 0.090, 0.302, 0.253), vec4(0.031, -0.055, 0.477, -0.041)) * bufB[1] + mat4(vec4(-0.072, -0.068, -0.068, -0.108), vec4(-0.220, 0.274, -0.170, 0.114), vec4(0.168, -0.464, -0.098, -0.032), vec4(-0.125, -0.351, 0.048, -0.045)) * bufB[2] + mat4(vec4(-0.036, -0.500, 0.071, 0.428), vec4(-0.207, -0.139, 0.303, 0.107), vec4(0.100, 0.291, -0.177, 0.164), vec4(0.011, 0.100, 0.081, -0.103)) * bufB[3] + mat4(vec4(0.029, -0.003, -0.283, 0.017), vec4(-0.165, 0.258, -0.071, 0.138), vec4(0.266, 0.139, 0.008, -0.144), vec4(0.028, 0.154, -0.005, 0.128)) * bufB[4] + mat4(vec4(-0.373, -0.136, -0.046, 0.105), vec4(-0.074, 0.165, -0.210, -0.049), vec4(-0.055, -0.119, 0.169, 0.042), vec4(0.391, 0.013, -0.091, -0.075)) * bufB[5] + mat4(vec4(-0.234, -0.097, -0.115, -0.033), vec4(-0.168, -0.047, -0.175, -0.119), vec4(-0.132, -0.079, -0.117, -0.049), vec4(0.148, 0.177, 0.025, -0.091)) * bufB[6] + mat4(vec4(-0.216, 0.065, -0.032, 0.026), vec4(-0.156, 0.022, -0.101, 0.034), vec4(-0.144, 0.005, -0.069, -0.311), vec4(-0.070, -0.098, 0.251, 0.261)) * bufB[7] + mat4(vec4(0.052, 0.384, 0.162, 0.200), vec4(0.055, -0.066, -0.027, 0.091), vec4(-0.202, 0.144, -0.228, 0.060), vec4(-0.249, 0.138, -0.081, -0.165)) * bufB[8] + mat4(vec4(-0.036, 0.030, -0.085, 0.191), vec4(0.089, -0.161, -0.033, -0.264), vec4(0.133, 0.119, -0.074, 0.133), vec4(0.059, 0.014, -0.195, 0.030)) * bufB[9];\nbufA[3] = vec4(0.146, -0.431, -0.154, -0.503) + mat4(vec4(0.248, -0.133, 0.151, 0.007), vec4(-0.288, -0.241, -0.086, -0.218), vec4(0.144, 0.140, 0.069, 0.174), vec4(0.403, 0.052, -0.002, 0.253)) * bufB[0] + mat4(vec4(0.114, -0.034, -0.081, 0.099), vec4(-0.407, 0.111, -0.188, -0.090), vec4(0.110, -0.008, -0.047, 0.287), vec4(0.118, -0.047, 0.100, -0.071)) * bufB[1] + mat4(vec4(0.094, -0.039, 0.008, -0.265), vec4(0.041, 0.221, -0.114, 0.106), vec4(0.107, -0.092, 0.151, 0.012), vec4(-0.154, -0.271, 0.218, 0.071)) * bufB[2] + mat4(vec4(-0.182, -0.135, -0.232, -0.131), vec4(0.361, 0.267, 0.071, 0.199), vec4(-0.220, 0.082, 0.149, 0.136), vec4(-0.249, 0.331, 0.100, -0.049)) * bufB[3] + mat4(vec4(-0.085, 0.162, 0.137, -0.248), vec4(-0.011, -0.302, 0.265, -0.093), vec4(-0.017, -0.091, -0.267, 0.149), vec4(0.134, 0.060, 0.220, 0.153)) * bufB[4] + mat4(vec4(-0.145, 0.246, -0.134, -0.268), vec4(0.080, -0.151, 0.063, -0.100), vec4(-0.182, -0.250, 0.018, -0.305), vec4(0.110, -0.156, 0.247, -0.034)) * bufB[5] + mat4(vec4(0.092, 0.129, 0.098, 0.001), vec4(0.057, -0.176, 0.211, -0.155), vec4(-0.133, -0.047, 0.198, -0.104), vec4(0.156, -0.106, 0.042, 0.260)) * bufB[6] + mat4(vec4(-0.099, -0.186, -0.029, 0.084), vec4(-0.117, -0.110, -0.087, -0.031), vec4(-0.300, 0.000, -0.064, 0.171), vec4(0.033, -0.188, -0.083, -0.078)) * bufB[7] + mat4(vec4(-0.099, -0.271, -0.160, -0.029), vec4(0.025, 0.245, -0.233, 0.003), vec4(-0.158, 0.019, 0.093, 0.061), vec4(0.058, -0.110, -0.108, 0.006)) * bufB[8] + mat4(vec4(-0.048, -0.065, -0.027, -0.187), vec4(-0.062, 0.092, -0.276, -0.003), vec4(0.051, 0.124, -0.084, -0.076), vec4(0.009, 0.031, 0.187, -0.069)) * bufB[9];\nbufA[4] = vec4(-0.363, 0.377, 0.212, -0.089) + mat4(vec4(-0.275, -0.252, 0.217, -0.183), vec4(-0.107, -0.004, 0.110, 0.093), vec4(-0.274, 0.049, 0.138, -0.330), vec4(-0.087, -0.377, 0.061, 0.171)) * bufB[0] + mat4(vec4(0.115, 0.071, -0.220, 0.251), vec4(-0.186, -0.026, 0.051, 0.038), vec4(0.116, -0.133, -0.120, 0.040), vec4(0.225, -0.035, -0.166, -0.104)) * bufB[1] + mat4(vec4(-0.030, -0.109, 0.180, 0.290), vec4(0.017, -0.023, 0.035, 0.170), vec4(-0.298, -0.015, 0.020, -0.054), vec4(0.147, -0.042, -0.123, 0.062)) * bufB[2] + mat4(vec4(0.075, 0.027, -0.047, -0.178), vec4(0.033, 0.250, -0.026, -0.115), vec4(0.301, 0.086, 0.042, -0.069), vec4(0.105, 0.135, 0.021, -0.234)) * bufB[3] + mat4(vec4(-0.470, -0.189, 0.258, 0.146), vec4(-0.094, -0.054, -0.020, -0.035), vec4(-0.233, -0.005, -0.069, 0.311), vec4(0.023, -0.035, -0.018, -0.000)) * bufB[4] + mat4(vec4(0.000, -0.188, -0.124, 0.234), vec4(0.038, 0.105, 0.088, 0.129), vec4(-0.141, 0.120, -0.138, 0.160), vec4(0.067, 0.355, 0.259, 0.109)) * bufB[5] + mat4(vec4(-0.163, 0.049, -0.113, 0.246), vec4(-0.053, 0.104, -0.000, 0.092), vec4(-0.224, 0.012, 0.020, 0.258), vec4(0.275, 0.184, -0.082, 0.032)) * bufB[6] + mat4(vec4(-0.238, -0.229, 0.006, 0.306), vec4(-0.053, 0.127, -0.256, -0.174), vec4(-0.350, -0.104, -0.083, 0.315), vec4(0.014, 0.092, 0.004, 0.043)) * bufB[7] + mat4(vec4(0.179, -0.233, -0.110, -0.443), vec4(-0.015, -0.166, -0.081, -0.170), vec4(-0.006, -0.165, -0.006, 0.137), vec4(0.004, -0.049, 0.243, 0.021)) * bufB[8] + mat4(vec4(-0.068, -0.243, 0.071, -0.031), vec4(-0.018, 0.022, 0.065, 0.051), vec4(-0.131, -0.024, -0.018, 0.100), vec4(-0.134, 0.242, 0.050, 0.033)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(0.032, 0.345, -0.092, 0.149) + mat4(vec4(0.157, 0.121, -0.392, 0.246), vec4(-0.033, 0.131, -0.093, -0.021), vec4(-0.124, 0.218, 0.145, 0.167), vec4(-0.003, 0.302, -0.057, -0.164)) * bufB[0] + mat4(vec4(-0.012, 0.022, 0.055, 0.133), vec4(-0.189, -0.077, -0.002, 0.035), vec4(0.408, -0.120, 0.332, -0.079), vec4(0.102, -0.014, -0.169, 0.299)) * bufB[1] + mat4(vec4(0.134, 0.063, 0.041, 0.287), vec4(-0.246, 0.049, -0.294, 0.098), vec4(-0.211, 0.078, 0.257, 0.170), vec4(0.205, 0.078, 0.179, 0.119)) * bufB[2] + mat4(vec4(0.008, -0.010, -0.056, 0.132), vec4(-0.190, -0.162, 0.337, 0.234), vec4(0.126, -0.171, -0.275, 0.148), vec4(0.019, -0.430, 0.084, 0.027)) * bufB[3] + mat4(vec4(0.159, -0.082, 0.187, 0.283), vec4(0.168, -0.009, -0.019, 0.330), vec4(-0.042, 0.060, -0.319, 0.084), vec4(-0.153, -0.123, -0.034, -0.149)) * bufB[4] + mat4(vec4(0.005, 0.045, 0.143, -0.319), vec4(0.100, 0.084, 0.109, -0.053), vec4(-0.046, 0.073, 0.341, -0.022), vec4(-0.053, -0.010, -0.163, 0.170)) * bufB[5] + mat4(vec4(-0.456, -0.088, 0.018, -0.032), vec4(-0.054, 0.106, 0.059, -0.319), vec4(-0.353, -0.325, 0.154, -0.130), vec4(0.051, 0.171, 0.047, 0.017)) * bufB[6] + mat4(vec4(-0.046, 0.028, 0.125, 0.031), vec4(0.249, 0.191, -0.264, -0.190), vec4(-0.283, 0.031, -0.111, 0.045), vec4(0.123, 0.051, -0.061, -0.049)) * bufB[7] + mat4(vec4(-0.048, 0.108, 0.087, -0.242), vec4(-0.075, -0.119, 0.034, 0.083), vec4(-0.033, -0.115, -0.040, 0.138), vec4(-0.015, -0.048, -0.025, -0.080)) * bufB[8] + mat4(vec4(0.167, -0.156, -0.074, 0.062), vec4(-0.121, -0.169, 0.013, 0.010), vec4(-0.134, -0.228, -0.028, -0.102), vec4(0.010, 0.273, 0.094, -0.135)) * bufB[9];\nbufA[1] = vec4(-0.382, 0.017, -0.300, 0.554) + mat4(vec4(0.040, -0.197, -0.054, 0.248), vec4(0.079, 0.044, -0.013, 0.001), vec4(-0.133, 0.062, 0.122, -0.097), vec4(0.123, 0.117, -0.079, -0.075)) * bufB[0] + mat4(vec4(-0.099, 0.023, -0.166, -0.064), vec4(0.364, -0.096, -0.053, -0.065), vec4(-0.115, -0.053, -0.026, -0.077), vec4(0.066, -0.153, -0.298, 0.066)) * bufB[1] + mat4(vec4(-0.364, 0.282, 0.109, -0.083), vec4(0.313, 0.106, 0.023, 0.021), vec4(0.024, -0.049, -0.274, -0.009), vec4(0.520, 0.171, 0.085, 0.212)) * bufB[2] + mat4(vec4(-0.136, 0.221, 0.291, 0.047), vec4(0.001, -0.131, 0.112, -0.231), vec4(0.127, -0.164, -0.018, 0.037), vec4(0.077, -0.237, 0.069, 0.277)) * bufB[3] + mat4(vec4(0.123, 0.097, 0.184, -0.193), vec4(-0.056, -0.252, 0.119, 0.164), vec4(0.059, 0.280, 0.076, -0.375), vec4(0.113, 0.046, 0.334, 0.068)) * bufB[4] + mat4(vec4(-0.329, -0.261, -0.295, 0.440), vec4(-0.036, -0.075, -0.168, -0.114), vec4(0.011, -0.089, 0.008, -0.114), vec4(-0.141, -0.054, -0.031, -0.032)) * bufB[5] + mat4(vec4(-0.325, -0.042, 0.202, 0.421), vec4(-0.045, -0.234, -0.151, -0.236), vec4(-0.064, -0.194, 0.056, -0.160), vec4(-0.182, 0.433, 0.102, 0.112)) * bufB[6] + mat4(vec4(-0.014, -0.126, -0.033, -0.143), vec4(-0.069, -0.002, 0.035, -0.085), vec4(0.038, 0.020, 0.052, -0.119), vec4(-0.088, 0.277, -0.054, -0.143)) * bufB[7] + mat4(vec4(-0.046, 0.017, 0.186, 0.029), vec4(0.177, 0.136, 0.005, 0.038), vec4(0.099, 0.145, -0.206, -0.054), vec4(0.399, 0.036, -0.074, -0.281)) * bufB[8] + mat4(vec4(0.039, 0.083, 0.089, 0.174), vec4(-0.065, 0.018, 0.087, -0.302), vec4(-0.014, -0.013, -0.018, -0.221), vec4(0.059, -0.009, -0.245, 0.234)) * bufB[9];\nbufA[2] = vec4(0.144, -0.366, -0.284, 0.194) + mat4(vec4(-0.153, 0.291, 0.066, -0.100), vec4(0.160, 0.002, 0.113, -0.050), vec4(-0.035, 0.224, -0.024, 0.188), vec4(0.312, 0.025, -0.189, 0.045)) * bufB[0] + mat4(vec4(0.062, 0.036, 0.002, 0.114), vec4(-0.330, -0.020, -0.028, 0.187), vec4(-0.004, -0.047, -0.111, -0.291), vec4(-0.262, 0.341, -0.165, 0.063)) * bufB[1] + mat4(vec4(0.049, -0.304, -0.072, -0.091), vec4(-0.005, 0.214, -0.045, 0.075), vec4(-0.115, 0.210, -0.317, -0.110), vec4(0.035, 0.092, -0.044, 0.158)) * bufB[2] + mat4(vec4(-0.054, -0.146, -0.165, -0.150), vec4(0.172, -0.110, 0.339, 0.052), vec4(-0.126, 0.052, -0.053, -0.035), vec4(-0.180, -0.257, 0.235, 0.131)) * bufB[3] + mat4(vec4(-0.256, -0.197, -0.376, -0.190), vec4(-0.266, 0.167, 0.025, 0.111), vec4(-0.123, 0.069, -0.126, 0.044), vec4(0.303, -0.130, 0.200, 0.084)) * bufB[4] + mat4(vec4(0.115, -0.040, 0.099, -0.228), vec4(-0.133, 0.052, 0.235, -0.057), vec4(-0.215, -0.117, -0.137, -0.088), vec4(0.049, -0.061, 0.451, -0.187)) * bufB[5] + mat4(vec4(0.312, 0.034, 0.016, -0.241), vec4(0.212, -0.203, -0.082, 0.210), vec4(0.031, -0.324, 0.191, -0.014), vec4(-0.032, -0.012, 0.015, 0.323)) * bufB[6] + mat4(vec4(-0.017, 0.145, 0.223, 0.097), vec4(0.020, 0.053, -0.013, 0.038), vec4(-0.155, 0.175, -0.107, -0.067), vec4(0.014, -0.020, -0.079, -0.223)) * bufB[7] + mat4(vec4(-0.025, 0.119, 0.020, 0.021), vec4(0.029, -0.094, 0.177, 0.012), vec4(-0.021, -0.041, -0.018, -0.001), vec4(-0.187, -0.093, -0.050, 0.516)) * bufB[8] + mat4(vec4(0.023, 0.091, 0.101, -0.106), vec4(-0.312, -0.164, 0.100, -0.076), vec4(-0.097, -0.125, 0.207, 0.043), vec4(-0.450, 0.173, -0.334, 0.183)) * bufB[9];\nbufA[3] = vec4(0.393, 0.389, 0.386, -0.111) + mat4(vec4(-0.271, 0.013, 0.046, -0.246), vec4(-0.218, -0.044, 0.030, 0.091), vec4(-0.216, 0.194, -0.155, -0.116), vec4(0.383, -0.015, 0.304, 0.340)) * bufB[0] + mat4(vec4(0.220, -0.047, -0.186, 0.160), vec4(-0.123, 0.065, 0.449, -0.258), vec4(0.112, -0.055, -0.102, -0.343), vec4(-0.050, 0.221, -0.133, -0.236)) * bufB[1] + mat4(vec4(-0.056, -0.008, 0.196, -0.165), vec4(0.146, -0.179, -0.198, 0.011), vec4(-0.357, 0.236, -0.023, -0.218), vec4(-0.362, -0.028, 0.019, -0.070)) * bufB[2] + mat4(vec4(0.032, 0.078, -0.191, -0.181), vec4(-0.096, 0.026, -0.139, -0.207), vec4(-0.187, 0.001, -0.079, -0.075), vec4(-0.026, -0.098, 0.057, -0.116)) * bufB[3] + mat4(vec4(0.053, -0.015, 0.290, -0.096), vec4(-0.033, -0.222, -0.071, -0.191), vec4(-0.125, 0.117, -0.019, 0.039), vec4(0.200, 0.118, -0.141, -0.100)) * bufB[4] + mat4(vec4(0.034, -0.041, -0.210, -0.199), vec4(0.144, 0.246, -0.134, 0.092), vec4(-0.205, -0.138, 0.322, -0.137), vec4(-0.006, 0.222, 0.087, -0.292)) * bufB[5] + mat4(vec4(0.045, 0.324, -0.141, 0.058), vec4(-0.002, 0.473, 0.287, 0.103), vec4(-0.043, 0.167, 0.022, 0.164), vec4(0.078, 0.202, -0.247, 0.233)) * bufB[6] + mat4(vec4(0.179, 0.007, -0.165, 0.135), vec4(0.179, 0.312, -0.305, 0.274), vec4(-0.049, 0.005, -0.009, -0.210), vec4(0.113, -0.567, -0.401, -0.037)) * bufB[7] + mat4(vec4(0.089, 0.037, 0.049, -0.082), vec4(-0.170, 0.036, -0.163, 0.009), vec4(0.039, 0.263, 0.173, -0.004), vec4(-0.195, -0.080, -0.095, -0.207)) * bufB[8] + mat4(vec4(0.081, 0.073, 0.236, 0.157), vec4(-0.418, -0.158, -0.042, -0.088), vec4(-0.029, 0.061, -0.229, -0.090), vec4(0.046, -0.182, -0.156, -0.242)) * bufB[9];\nbufA[4] = vec4(0.362, -0.010, 0.033, 0.475) + mat4(vec4(0.069, 0.044, -0.034, -0.063), vec4(-0.005, 0.052, 0.091, 0.165), vec4(0.183, -0.058, 0.181, 0.010), vec4(-0.102, -0.095, -0.042, -0.150)) * bufB[0] + mat4(vec4(-0.128, -0.100, -0.061, 0.170), vec4(0.128, 0.231, 0.158, 0.321), vec4(-0.299, -0.184, -0.008, -0.031), vec4(0.384, 0.010, 0.051, 0.092)) * bufB[1] + mat4(vec4(-0.060, 0.058, -0.307, -0.333), vec4(0.268, 0.006, -0.309, 0.188), vec4(-0.458, -0.086, 0.215, 0.041), vec4(-0.083, -0.011, -0.217, 0.147)) * bufB[2] + mat4(vec4(-0.002, 0.059, -0.174, -0.206), vec4(0.069, 0.030, -0.016, -0.079), vec4(-0.048, -0.233, -0.293, 0.162), vec4(0.112, -0.071, 0.032, -0.148)) * bufB[3] + mat4(vec4(-0.397, 0.329, 0.030, -0.366), vec4(-0.428, -0.037, 0.160, -0.102), vec4(0.070, -0.024, 0.105, -0.029), vec4(0.405, 0.123, -0.078, 0.189)) * bufB[4] + mat4(vec4(-0.083, 0.055, 0.087, 0.202), vec4(0.032, -0.202, 0.004, -0.205), vec4(-0.249, 0.190, 0.129, 0.205), vec4(-0.094, -0.003, -0.049, -0.341)) * bufB[5] + mat4(vec4(-0.286, -0.020, 0.030, -0.113), vec4(-0.014, -0.416, 0.016, 0.084), vec4(0.066, 0.133, -0.010, -0.050), vec4(0.152, -0.255, 0.014, -0.023)) * bufB[6] + mat4(vec4(0.370, 0.010, -0.212, 0.219), vec4(-0.190, -0.276, 0.141, -0.310), vec4(0.077, 0.190, -0.120, 0.024), vec4(0.213, -0.194, 0.256, 0.437)) * bufB[7] + mat4(vec4(0.046, 0.025, 0.136, 0.152), vec4(-0.029, -0.001, -0.143, 0.004), vec4(-0.001, 0.122, -0.319, -0.361), vec4(0.132, -0.393, 0.012, 0.260)) * bufB[8] + mat4(vec4(0.218, 0.099, 0.061, 0.129), vec4(0.031, 0.333, 0.211, -0.143), vec4(-0.021, -0.086, -0.185, 0.003), vec4(-0.139, 0.163, 0.095, 0.064)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(0.360, 0.020, -0.206, 0.413) + mat4(vec4(0.016, -0.006, -0.148, -0.412), vec4(0.265, 0.030, 0.054, 0.034), vec4(-0.073, -0.152, -0.028, 0.115), vec4(0.109, 0.297, -0.111, -0.274)) * bufB[0] + mat4(vec4(-0.083, -0.145, -0.019, -0.032), vec4(-0.199, 0.184, 0.054, -0.143), vec4(-0.173, -0.331, -0.011, -0.137), vec4(0.432, -0.229, 0.309, 0.128)) * bufB[1] + mat4(vec4(-0.206, -0.321, -0.096, -0.247), vec4(-0.293, 0.011, -0.035, 0.102), vec4(0.295, 0.380, 0.063, -0.147), vec4(-0.267, 0.156, -0.283, -0.030)) * bufB[2] + mat4(vec4(0.021, 0.112, 0.188, 0.070), vec4(0.345, 0.112, 0.003, -0.202), vec4(0.294, -0.214, -0.192, -0.328), vec4(-0.167, 0.162, 0.076, 0.110)) * bufB[3] + mat4(vec4(-0.007, -0.128, -0.297, -0.017), vec4(0.119, 0.203, -0.027, 0.240), vec4(0.259, -0.104, -0.282, -0.006), vec4(0.167, -0.206, -0.081, 0.153)) * bufB[4] + mat4(vec4(0.160, -0.113, -0.164, 0.046), vec4(-0.170, -0.188, -0.344, 0.119), vec4(-0.063, -0.110, 0.106, -0.301), vec4(0.070, 0.065, 0.077, 0.051)) * bufB[5] + mat4(vec4(-0.322, -0.068, 0.214, -0.050), vec4(0.173, -0.055, -0.153, -0.062), vec4(0.094, -0.044, 0.178, -0.051), vec4(-0.018, -0.079, -0.105, 0.240)) * bufB[6] + mat4(vec4(-0.149, 0.101, -0.056, 0.065), vec4(0.216, -0.179, -0.065, 0.072), vec4(-0.059, 0.238, -0.000, 0.215), vec4(0.008, -0.238, 0.082, 0.024)) * bufB[7] + mat4(vec4(0.062, 0.122, -0.065, -0.018), vec4(-0.312, 0.199, 0.528, 0.088), vec4(0.093, -0.330, -0.354, -0.346), vec4(0.029, -0.055, -0.125, -0.052)) * bufB[8] + mat4(vec4(0.137, 0.179, 0.110, 0.006), vec4(-0.300, -0.036, 0.003, -0.166), vec4(0.005, 0.216, -0.154, 0.128), vec4(0.134, -0.203, -0.303, 0.325)) * bufB[9];\nbufA[1] = vec4(-0.523, -0.258, 0.372, 0.244) + mat4(vec4(-0.129, -0.037, -0.014, 0.234), vec4(-0.164, -0.089, 0.325, -0.061), vec4(0.434, 0.084, 0.004, -0.109), vec4(0.372, -0.001, 0.074, -0.046)) * bufB[0] + mat4(vec4(0.218, -0.277, 0.109, 0.144), vec4(-0.343, 0.131, -0.190, 0.154), vec4(-0.345, -0.020, 0.002, -0.020), vec4(0.096, -0.116, -0.204, -0.005)) * bufB[1] + mat4(vec4(-0.187, -0.008, -0.017, -0.309), vec4(0.050, -0.255, 0.323, -0.138), vec4(-0.178, 0.025, -0.024, 0.308), vec4(0.005, -0.146, 0.081, -0.033)) * bufB[2] + mat4(vec4(-0.255, 0.064, -0.164, 0.165), vec4(0.068, 0.015, 0.111, -0.051), vec4(0.013, -0.276, 0.363, -0.183), vec4(0.070, 0.059, -0.203, -0.339)) * bufB[3] + mat4(vec4(0.088, -0.128, 0.160, 0.055), vec4(0.167, -0.315, 0.182, 0.255), vec4(-0.139, 0.362, 0.259, 0.081), vec4(-0.280, 0.252, 0.107, 0.005)) * bufB[4] + mat4(vec4(-0.091, 0.111, -0.008, 0.118), vec4(-0.030, 0.128, -0.035, -0.145), vec4(-0.249, -0.051, 0.261, -0.205), vec4(0.180, 0.089, -0.425, 0.026)) * bufB[5] + mat4(vec4(-0.085, 0.252, -0.117, -0.088), vec4(0.125, -0.036, 0.163, 0.364), vec4(0.158, -0.149, 0.126, -0.094), vec4(-0.022, -0.093, -0.132, -0.105)) * bufB[6] + mat4(vec4(-0.119, -0.044, -0.148, -0.033), vec4(0.171, -0.220, 0.247, -0.144), vec4(0.181, -0.353, 0.186, 0.234), vec4(0.120, 0.123, -0.121, 0.213)) * bufB[7] + mat4(vec4(-0.110, -0.140, -0.213, 0.026), vec4(0.338, -0.248, 0.311, -0.089), vec4(0.111, 0.037, 0.019, -0.118), vec4(-0.008, 0.014, 0.184, -0.159)) * bufB[8] + mat4(vec4(0.008, -0.232, 0.361, -0.127), vec4(0.035, -0.212, 0.106, -0.112), vec4(-0.120, 0.166, 0.042, 0.099), vec4(0.241, -0.271, -0.096, 0.194)) * bufB[9];\nbufA[2] = vec4(0.205, 0.176, 0.276, -0.286) + mat4(vec4(-0.065, 0.029, -0.179, -0.072), vec4(0.036, 0.065, 0.110, -0.230), vec4(-0.042, 0.128, 0.122, 0.231), vec4(-0.263, -0.145, 0.278, 0.355)) * bufB[0] + mat4(vec4(0.034, -0.004, -0.416, 0.068), vec4(-0.011, -0.082, -0.077, -0.104), vec4(0.250, 0.265, -0.222, -0.240), vec4(-0.308, -0.054, -0.080, 0.247)) * bufB[1] + mat4(vec4(-0.199, 0.094, 0.258, -0.020), vec4(-0.200, 0.137, 0.014, -0.060), vec4(-0.196, -0.057, -0.054, 0.012), vec4(-0.149, 0.128, -0.632, -0.032)) * bufB[2] + mat4(vec4(-0.178, 0.213, -0.120, -0.256), vec4(0.246, -0.170, 0.306, 0.004), vec4(0.110, 0.037, 0.116, -0.271), vec4(0.165, 0.184, -0.120, -0.032)) * bufB[3] + mat4(vec4(0.147, -0.449, -0.031, 0.005), vec4(-0.067, 0.082, -0.029, 0.121), vec4(-0.094, 0.039, 0.023, -0.112), vec4(-0.147, 0.043, 0.058, -0.102)) * bufB[4] + mat4(vec4(0.033, -0.023, -0.160, 0.040), vec4(0.223, 0.254, 0.067, 0.116), vec4(-0.186, 0.054, -0.302, 0.181), vec4(0.140, 0.370, -0.044, -0.393)) * bufB[5] + mat4(vec4(-0.142, -0.073, 0.304, -0.021), vec4(-0.242, 0.078, -0.026, -0.088), vec4(-0.023, -0.029, 0.037, 0.174), vec4(0.038, -0.186, 0.321, -0.211)) * bufB[6] + mat4(vec4(0.142, 0.047, 0.165, 0.070), vec4(-0.164, -0.011, -0.027, 0.232), vec4(-0.188, -0.086, 0.057, 0.329), vec4(0.505, 0.048, -0.232, -0.048)) * bufB[7] + mat4(vec4(-0.083, -0.230, 0.421, -0.321), vec4(0.079, 0.109, -0.183, -0.188), vec4(-0.034, -0.022, 0.181, -0.049), vec4(0.026, -0.091, -0.160, -0.091)) * bufB[8] + mat4(vec4(0.293, 0.308, 0.080, -0.050), vec4(0.069, 0.116, -0.074, -0.114), vec4(-0.155, -0.023, -0.059, -0.210), vec4(0.071, -0.284, -0.196, 0.250)) * bufB[9];\nbufA[3] = vec4(0.375, -0.132, -0.359, 0.186) + mat4(vec4(-0.059, 0.170, 0.052, 0.234), vec4(-0.077, 0.252, 0.203, 0.011), vec4(0.333, 0.063, -0.147, -0.456), vec4(-0.173, 0.017, -0.112, 0.344)) * bufB[0] + mat4(vec4(-0.014, -0.137, -0.297, 0.025), vec4(0.159, 0.293, -0.112, 0.096), vec4(0.048, 0.152, -0.121, -0.085), vec4(-0.215, -0.059, 0.053, 0.051)) * bufB[1] + mat4(vec4(-0.026, 0.072, 0.008, 0.054), vec4(-0.360, 0.072, 0.005, 0.195), vec4(0.228, -0.302, 0.413, -0.071), vec4(0.038, 0.088, 0.057, 0.108)) * bufB[2] + mat4(vec4(0.063, -0.003, -0.107, -0.269), vec4(0.018, -0.183, 0.179, -0.198), vec4(-0.149, -0.053, -0.290, -0.021), vec4(-0.099, 0.222, -0.313, -0.233)) * bufB[3] + mat4(vec4(-0.165, -0.363, -0.177, 0.240), vec4(0.006, -0.034, 0.139, 0.160), vec4(-0.064, -0.020, 0.058, 0.004), vec4(0.039, 0.194, -0.194, -0.200)) * bufB[4] + mat4(vec4(0.311, -0.180, 0.033, -0.202), vec4(0.089, 0.211, -0.146, -0.071), vec4(0.121, -0.136, -0.304, -0.051), vec4(0.158, -0.235, -0.219, -0.163)) * bufB[5] + mat4(vec4(-0.017, 0.144, 0.216, -0.308), vec4(0.016, -0.397, -0.030, 0.182), vec4(-0.142, 0.209, -0.171, 0.031), vec4(0.020, -0.186, 0.225, 0.079)) * bufB[6] + mat4(vec4(-0.142, 0.287, -0.049, 0.210), vec4(-0.119, -0.026, 0.180, 0.202), vec4(0.020, -0.177, -0.078, -0.086), vec4(0.218, -0.045, -0.198, 0.092)) * bufB[7] + mat4(vec4(-0.211, 0.304, 0.065, 0.177), vec4(-0.009, -0.461, -0.276, -0.075), vec4(-0.008, -0.267, 0.247, -0.022), vec4(-0.150, 0.285, 0.115, 0.343)) * bufB[8] + mat4(vec4(0.173, 0.103, 0.244, -0.193), vec4(-0.268, 0.011, -0.165, 0.205), vec4(-0.006, -0.051, 0.082, 0.015), vec4(0.159, -0.129, -0.073, -0.011)) * bufB[9];\nbufA[4] = vec4(0.031, -0.321, 0.330, 0.186) + mat4(vec4(-0.065, -0.130, 0.072, -0.072), vec4(0.037, -0.060, -0.168, 0.133), vec4(0.067, -0.052, -0.037, -0.073), vec4(0.016, 0.106, -0.233, 0.202)) * bufB[0] + mat4(vec4(0.037, -0.109, -0.102, -0.171), vec4(0.021, 0.215, 0.050, 0.075), vec4(-0.070, 0.186, -0.022, -0.059), vec4(0.032, 0.130, -0.056, 0.163)) * bufB[1] + mat4(vec4(-0.197, -0.129, 0.251, 0.217), vec4(0.217, 0.016, -0.033, 0.375), vec4(-0.159, -0.306, -0.013, 0.010), vec4(0.098, 0.092, -0.122, -0.173)) * bufB[2] + mat4(vec4(0.089, 0.012, -0.061, 0.083), vec4(-0.021, -0.248, 0.059, 0.084), vec4(-0.357, 0.163, -0.057, 0.364), vec4(0.086, 0.143, 0.196, -0.093)) * bufB[3] + mat4(vec4(-0.208, 0.137, -0.029, 0.027), vec4(-0.160, -0.133, -0.278, 0.130), vec4(-0.116, 0.214, 0.117, 0.186), vec4(-0.240, -0.092, -0.063, -0.299)) * bufB[4] + mat4(vec4(0.070, 0.254, -0.011, -0.138), vec4(0.054, 0.006, 0.080, -0.072), vec4(0.096, 0.169, 0.063, -0.208), vec4(0.162, 0.229, 0.072, 0.014)) * bufB[5] + mat4(vec4(-0.183, -0.166, 0.141, 0.227), vec4(-0.014, 0.250, 0.079, 0.156), vec4(-0.193, -0.126, -0.281, -0.241), vec4(0.004, 0.376, 0.223, 0.310)) * bufB[6] + mat4(vec4(-0.156, -0.036, -0.120, 0.052), vec4(0.036, -0.176, 0.029, -0.353), vec4(-0.117, -0.046, -0.250, -0.005), vec4(-0.076, 0.007, 0.026, -0.204)) * bufB[7] + mat4(vec4(-0.094, -0.225, 0.017, 0.584), vec4(0.110, -0.085, -0.206, -0.174), vec4(-0.394, 0.283, -0.302, 0.227), vec4(0.168, 0.030, 0.091, 0.016)) * bufB[8] + mat4(vec4(0.137, 0.097, -0.108, 0.222), vec4(-0.040, 0.088, -0.222, 0.111), vec4(-0.151, -0.067, 0.037, 0.051), vec4(-0.044, -0.179, -0.026, -0.404)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(-0.027, 0.418, 0.034, 0.372) + mat4(vec4(0.055, -0.118, -0.126, -0.123), vec4(-0.192, -0.405, 0.021, -0.073), vec4(0.197, -0.193, -0.146, -0.097), vec4(-0.040, -0.024, -0.514, 0.368)) * bufB[0] + mat4(vec4(0.005, -0.090, -0.038, -0.076), vec4(-0.094, 0.208, -0.119, -0.170), vec4(-0.312, -0.574, 0.129, 0.374), vec4(-0.275, -0.117, 0.231, -0.062)) * bufB[1] + mat4(vec4(-0.061, 0.296, -0.374, -0.503), vec4(0.133, 0.111, -0.212, -0.059), vec4(0.223, 0.157, -0.017, 0.224), vec4(-0.147, -0.063, 0.057, 0.246)) * bufB[2] + mat4(vec4(-0.186, 0.208, 0.113, 0.120), vec4(0.297, -0.369, -0.213, 0.118), vec4(-0.001, 0.080, 0.037, -0.039), vec4(0.127, 0.079, 0.013, 0.236)) * bufB[3] + mat4(vec4(0.133, 0.006, 0.041, -0.205), vec4(0.037, 0.139, 0.259, -0.243), vec4(-0.034, 0.034, 0.230, -0.121), vec4(0.293, 0.062, 0.227, -0.317)) * bufB[4] + mat4(vec4(-0.226, 0.062, 0.092, 0.110), vec4(-0.068, 0.110, -0.128, -0.091), vec4(0.292, 0.159, -0.197, -0.277), vec4(-0.153, -0.112, 0.133, 0.457)) * bufB[5] + mat4(vec4(-0.061, -0.023, 0.178, -0.158), vec4(-0.362, -0.027, 0.293, -0.036), vec4(-0.107, -0.124, -0.078, 0.030), vec4(0.036, 0.363, -0.126, 0.051)) * bufB[6] + mat4(vec4(0.118, 0.134, 0.278, -0.145), vec4(0.329, 0.186, -0.329, -0.197), vec4(0.136, -0.109, -0.173, -0.483), vec4(0.074, 0.113, -0.277, -0.094)) * bufB[7] + mat4(vec4(-0.475, 0.291, 0.154, -0.166), vec4(-0.177, -0.011, -0.003, -0.026), vec4(0.011, -0.024, 0.048, -0.154), vec4(-0.245, 0.166, 0.126, 0.054)) * bufB[8] + mat4(vec4(0.324, 0.127, 0.149, -0.049), vec4(-0.182, -0.245, -0.344, -0.056), vec4(0.084, 0.034, -0.123, 0.046), vec4(0.197, -0.028, -0.335, -0.701)) * bufB[9];\nbufA[1] = vec4(0.214, 0.277, -0.294, 0.567) + mat4(vec4(-0.320, 0.047, -0.141, -0.035), vec4(0.249, 0.005, -0.299, 0.003), vec4(0.092, 0.124, 0.176, 0.177), vec4(0.030, 0.184, -0.037, 0.032)) * bufB[0] + mat4(vec4(-0.141, 0.314, -0.226, -0.142), vec4(-0.086, -0.342, -0.012, 0.151), vec4(0.172, -0.271, -0.137, 0.035), vec4(0.416, 0.366, 0.057, -0.151)) * bufB[1] + mat4(vec4(-0.161, -0.026, -0.101, 0.148), vec4(-0.114, -0.157, 0.204, -0.068), vec4(0.123, 0.339, 0.100, 0.136), vec4(0.479, 0.462, 0.138, -0.292)) * bufB[2] + mat4(vec4(0.167, 0.103, 0.271, 0.006), vec4(-0.150, -0.255, 0.160, 0.060), vec4(0.131, 0.035, -0.072, 0.078), vec4(0.083, -0.099, -0.012, -0.249)) * bufB[3] + mat4(vec4(0.097, -0.068, -0.127, 0.099), vec4(-0.160, -0.178, 0.032, -0.203), vec4(0.049, -0.202, -0.258, 0.231), vec4(0.262, 0.024, 0.027, -0.144)) * bufB[4] + mat4(vec4(0.049, -0.076, -0.348, -0.244), vec4(0.088, 0.025, 0.009, -0.271), vec4(0.022, 0.022, -0.305, 0.352), vec4(0.035, -0.140, -0.297, 0.031)) * bufB[5] + mat4(vec4(-0.447, -0.156, -0.096, 0.288), vec4(-0.326, -0.370, 0.023, -0.004), vec4(-0.194, 0.023, -0.119, 0.174), vec4(0.166, 0.174, 0.051, -0.393)) * bufB[6] + mat4(vec4(0.154, 0.239, -0.117, 0.046), vec4(0.074, 0.418, 0.116, 0.066), vec4(-0.021, -0.090, 0.077, 0.017), vec4(0.199, 0.080, 0.095, 0.010)) * bufB[7] + mat4(vec4(0.051, 0.012, 0.034, -0.546), vec4(0.052, -0.238, 0.093, -0.059), vec4(0.151, -0.184, 0.032, 0.090), vec4(-0.146, 0.098, 0.142, -0.286)) * bufB[8] + mat4(vec4(-0.019, 0.161, 0.078, -0.027), vec4(0.105, -0.099, 0.073, 0.015), vec4(-0.099, 0.101, -0.002, -0.196), vec4(-0.298, -0.200, -0.674, 0.038)) * bufB[9];\nbufA[2] = vec4(0.485, -0.529, 0.287, 0.183) + mat4(vec4(0.006, -0.265, 0.167, -0.147), vec4(0.236, 0.181, -0.073, -0.136), vec4(-0.079, -0.051, -0.359, -0.082), vec4(-0.202, -0.017, 0.068, 0.144)) * bufB[0] + mat4(vec4(-0.277, 0.128, 0.127, 0.046), vec4(0.098, -0.186, -0.139, -0.057), vec4(0.196, -0.150, 0.116, 0.026), vec4(-0.073, -0.012, -0.234, 0.509)) * bufB[1] + mat4(vec4(0.210, -0.074, -0.130, -0.037), vec4(-0.228, -0.086, 0.114, -0.353), vec4(-0.248, -0.030, -0.184, -0.307), vec4(-0.333, 0.008, -0.093, 0.158)) * bufB[2] + mat4(vec4(0.013, 0.045, -0.036, 0.197), vec4(0.159, 0.489, 0.426, -0.316), vec4(-0.288, -0.269, -0.459, -0.024), vec4(0.102, 0.150, 0.295, 0.166)) * bufB[3] + mat4(vec4(-0.401, 0.079, -0.447, -0.110), vec4(0.064, -0.096, 0.179, 0.169), vec4(-0.062, 0.020, 0.114, 0.163), vec4(0.032, 0.147, -0.109, -0.134)) * bufB[4] + mat4(vec4(-0.087, -0.146, 0.321, 0.208), vec4(-0.164, -0.163, -0.103, 0.078), vec4(-0.295, -0.085, 0.679, -0.003), vec4(-0.459, -0.070, -0.140, 0.175)) * bufB[5] + mat4(vec4(-0.024, 0.204, 0.306, -0.075), vec4(0.051, 0.070, 0.079, -0.186), vec4(-0.354, -0.105, -0.026, -0.005), vec4(-0.039, 0.021, -0.063, 0.288)) * bufB[6] + mat4(vec4(-0.038, -0.045, -0.120, -0.167), vec4(-0.081, -0.244, -0.046, 0.391), vec4(0.340, -0.236, -0.340, -0.036), vec4(-0.003, -0.067, 0.252, -0.063)) * bufB[7] + mat4(vec4(-0.278, 0.204, -0.102, -0.120), vec4(0.046, -0.257, -0.172, -0.242), vec4(0.397, 0.050, -0.320, 0.101), vec4(-0.155, 0.122, -0.032, 0.286)) * bufB[8] + mat4(vec4(0.048, -0.199, 0.218, 0.147), vec4(-0.185, 0.105, -0.036, -0.132), vec4(-0.212, 0.453, 0.070, 0.045), vec4(0.412, -0.058, -0.128, -0.357)) * bufB[9];\nbufA[3] = vec4(-0.663, 0.321, -0.295, -0.066) + mat4(vec4(-0.125, -0.240, -0.260, -0.064), vec4(-0.227, 0.285, 0.154, -0.002), vec4(-0.184, -0.013, -0.200, 0.053), vec4(-0.085, -0.029, 0.074, 0.016)) * bufB[0] + mat4(vec4(-0.007, -0.040, -0.068, -0.155), vec4(-0.075, -0.074, 0.169, -0.249), vec4(-0.216, 0.226, 0.100, 0.244), vec4(0.071, -0.173, 0.087, 0.002)) * bufB[1] + mat4(vec4(-0.391, 0.227, -0.190, 0.143), vec4(0.181, -0.092, -0.432, 0.045), vec4(-0.215, 0.212, -0.040, -0.040), vec4(0.335, 0.009, -0.189, 0.140)) * bufB[2] + mat4(vec4(-0.120, -0.060, -0.009, -0.280), vec4(-0.024, 0.376, -0.194, -0.101), vec4(-0.110, -0.050, -0.185, -0.154), vec4(0.018, 0.113, 0.202, 0.184)) * bufB[3] + mat4(vec4(-0.190, -0.208, -0.533, 0.104), vec4(-0.006, -0.066, 0.172, -0.121), vec4(0.100, -0.168, 0.151, -0.038), vec4(-0.095, 0.304, -0.245, -0.065)) * bufB[4] + mat4(vec4(0.341, -0.262, -0.084, -0.018), vec4(-0.167, -0.195, 0.111, -0.098), vec4(0.261, -0.333, 0.219, -0.011), vec4(-0.099, -0.019, 0.104, -0.150)) * bufB[5] + mat4(vec4(-0.131, 0.016, 0.039, 0.115), vec4(0.074, 0.128, -0.178, -0.032), vec4(0.138, 0.131, -0.262, -0.412), vec4(0.335, -0.281, 0.071, 0.016)) * bufB[6] + mat4(vec4(-0.089, 0.243, 0.132, 0.309), vec4(0.176, -0.786, -0.534, -0.130), vec4(-0.016, 0.105, -0.457, 0.140), vec4(-0.021, 0.106, 0.243, -0.254)) * bufB[7] + mat4(vec4(-0.063, -0.294, 0.178, -0.570), vec4(-0.349, 0.049, 0.172, -0.017), vec4(0.130, 0.016, -0.130, 0.496), vec4(-0.106, -0.338, -0.091, -0.286)) * bufB[8] + mat4(vec4(0.397, 0.105, -0.148, -0.088), vec4(-0.018, -0.108, 0.127, 0.021), vec4(0.084, -0.135, -0.221, -0.156), vec4(-0.154, 0.170, 0.017, 0.149)) * bufB[9];\nbufA[4] = vec4(0.013, -0.107, 0.049, 0.118) + mat4(vec4(0.553, 0.069, 0.070, -0.375), vec4(0.112, -0.250, -0.202, -0.163), vec4(-0.052, -0.175, 0.047, -0.034), vec4(0.013, -0.096, 0.182, 0.083)) * bufB[0] + mat4(vec4(0.108, 0.068, 0.219, -0.036), vec4(-0.199, 0.321, -0.073, 0.145), vec4(0.364, 0.054, -0.139, -0.078), vec4(0.082, 0.103, 0.080, 0.284)) * bufB[1] + mat4(vec4(0.188, 0.181, -0.182, -0.024), vec4(0.180, 0.182, 0.187, -0.295), vec4(0.114, -0.059, 0.165, -0.024), vec4(-0.078, 0.004, 0.163, 0.052)) * bufB[2] + mat4(vec4(-0.125, 0.454, 0.054, 0.039), vec4(-0.172, 0.402, 0.085, -0.119), vec4(0.287, 0.043, -0.165, -0.238), vec4(0.169, -0.268, 0.355, -0.148)) * bufB[3] + mat4(vec4(0.105, -0.174, -0.000, 0.086), vec4(0.057, 0.137, -0.165, 0.099), vec4(-0.092, -0.064, -0.082, -0.038), vec4(0.021, -0.030, 0.008, -0.222)) * bufB[4] + mat4(vec4(0.208, 0.244, 0.030, -0.230), vec4(-0.037, -0.365, 0.177, 0.253), vec4(-0.331, 0.111, -0.303, 0.298), vec4(0.087, 0.070, 0.205, 0.018)) * bufB[5] + mat4(vec4(0.040, -0.315, 0.108, -0.265), vec4(0.110, -0.023, 0.044, -0.144), vec4(-0.045, -0.021, -0.090, -0.448), vec4(-0.130, -0.167, -0.216, 0.040)) * bufB[6] + mat4(vec4(-0.248, -0.130, -0.192, 0.075), vec4(0.284, -0.123, -0.335, 0.285), vec4(0.034, -0.143, 0.093, -0.162), vec4(-0.049, -0.272, -0.441, 0.134)) * bufB[7] + mat4(vec4(0.394, 0.121, -0.065, -0.026), vec4(0.282, -0.288, 0.029, 0.099), vec4(-0.199, 0.451, 0.026, -0.177), vec4(0.081, -0.277, -0.026, -0.088)) * bufB[8] + mat4(vec4(0.117, -0.394, -0.086, 0.285), vec4(-0.387, -0.229, 0.325, 0.015), vec4(-0.052, -0.014, 0.184, 0.032), vec4(0.335, -0.163, 0.153, -0.269)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(-0.204, 0.464, -0.216, -0.349) + mat4(vec4(-0.160, -0.147, 0.074, 0.278), vec4(-0.010, -0.109, 0.100, 0.080), vec4(-0.007, 0.194, -0.180, -0.071), vec4(-0.084, 0.418, -0.233, 0.071)) * bufB[0] + mat4(vec4(-0.101, 0.145, 0.235, -0.200), vec4(0.190, 0.126, 0.128, -0.058), vec4(-0.094, -0.067, -0.053, -0.025), vec4(-0.272, 0.141, -0.406, 0.350)) * bufB[1] + mat4(vec4(-0.103, 0.378, -0.213, -0.085), vec4(0.248, -0.152, -0.062, -0.276), vec4(-0.479, 0.145, 0.043, -0.073), vec4(0.100, 0.134, 0.372, 0.245)) * bufB[2] + mat4(vec4(0.104, -0.071, 0.115, -0.012), vec4(0.344, 0.456, -0.664, -0.545), vec4(0.219, -0.175, 0.195, 0.008), vec4(-0.201, 0.226, 0.083, -0.008)) * bufB[3] + mat4(vec4(-0.124, 0.039, 0.016, -0.199), vec4(-0.325, 0.006, 0.116, -0.165), vec4(-0.298, 0.170, 0.031, -0.219), vec4(-0.056, -0.037, 0.305, -0.041)) * bufB[4] + mat4(vec4(0.576, -0.491, 0.091, 0.100), vec4(0.191, 0.329, 0.155, 0.052), vec4(-0.200, 0.098, -0.149, 0.034), vec4(-0.471, 0.130, 0.054, -0.007)) * bufB[5] + mat4(vec4(-0.206, -0.230, -0.024, 0.224), vec4(-0.060, 0.177, -0.176, 0.178), vec4(0.217, 0.028, -0.091, 0.115), vec4(-0.198, 0.007, 0.080, -0.112)) * bufB[6] + mat4(vec4(-0.255, -0.142, 0.051, -0.141), vec4(-0.011, 0.231, 0.141, 0.171), vec4(-0.415, 0.308, -0.047, -0.050), vec4(-0.043, -0.256, 0.148, 0.010)) * bufB[7] + mat4(vec4(0.458, 0.016, 0.072, -0.070), vec4(-0.200, 0.211, 0.579, -0.367), vec4(-0.173, 0.052, 0.089, 0.107), vec4(-0.303, -0.216, -0.073, -0.168)) * bufB[8] + mat4(vec4(0.402, 0.040, -0.172, -0.230), vec4(0.149, -0.144, -0.071, -0.069), vec4(0.335, -0.149, -0.058, 0.117), vec4(0.346, -0.239, -0.194, -0.216)) * bufB[9];\nbufA[1] = vec4(0.383, -0.357, 0.673, -0.101) + mat4(vec4(-0.036, -0.020, -0.261, -0.118), vec4(0.091, 0.389, -0.069, -0.526), vec4(-0.060, -0.005, 0.020, -0.056), vec4(0.184, 0.174, 0.014, 0.088)) * bufB[0] + mat4(vec4(-0.181, 0.185, 0.021, -0.048), vec4(-0.262, 0.097, -0.284, -0.188), vec4(0.186, 0.213, -0.024, -0.105), vec4(0.027, -0.018, 0.004, 0.266)) * bufB[1] + mat4(vec4(0.025, -0.488, -0.014, 0.192), vec4(0.133, 0.171, -0.393, -0.137), vec4(0.287, -0.139, -0.198, 0.205), vec4(-0.233, 0.271, -0.514, -0.008)) * bufB[2] + mat4(vec4(-0.081, 0.235, -0.336, -0.042), vec4(-0.007, -0.141, -0.160, 0.254), vec4(0.008, -0.168, -0.023, 0.333), vec4(-0.076, -0.113, -0.276, 0.250)) * bufB[3] + mat4(vec4(-0.208, 0.109, 0.140, 0.036), vec4(-0.111, 0.062, -0.214, -0.060), vec4(0.336, -0.149, 0.336, -0.174), vec4(0.035, 0.074, -0.025, -0.160)) * bufB[4] + mat4(vec4(0.005, -0.383, 0.070, -0.042), vec4(-0.264, 0.097, 0.190, -0.335), vec4(-0.244, 0.013, 0.110, -0.282), vec4(0.207, 0.479, 0.025, -0.302)) * bufB[5] + mat4(vec4(0.141, 0.192, 0.096, 0.160), vec4(-0.037, 0.140, 0.185, 0.229), vec4(-0.077, 0.037, -0.021, -0.000), vec4(-0.005, 0.392, 0.190, -0.079)) * bufB[6] + mat4(vec4(-0.008, -0.130, 0.137, 0.059), vec4(0.025, -0.295, 0.113, -0.091), vec4(-0.014, -0.346, 0.102, 0.153), vec4(-0.089, 0.014, -0.201, -0.335)) * bufB[7] + mat4(vec4(0.117, -0.092, 0.306, -0.090), vec4(0.074, 0.029, 0.509, -0.358), vec4(0.092, 0.421, -0.068, 0.055), vec4(-0.281, 0.273, 0.101, 0.002)) * bufB[8] + mat4(vec4(-0.033, 0.047, -0.111, -0.112), vec4(0.032, -0.136, 0.263, 0.279), vec4(0.242, 0.233, -0.238, -0.175), vec4(0.079, 0.135, -0.164, 0.156)) * bufB[9];\nbufA[2] = vec4(-0.426, -0.178, 0.660, 0.021) + mat4(vec4(0.073, -0.175, -0.239, -0.034), vec4(0.498, 0.015, 0.330, 0.136), vec4(0.117, 0.052, 0.182, 0.232), vec4(0.174, 0.137, -0.265, -0.177)) * bufB[0] + mat4(vec4(0.094, -0.074, 0.160, -0.003), vec4(0.088, 0.126, 0.085, -0.145), vec4(0.078, 0.068, 0.150, 0.037), vec4(-0.021, 0.127, -0.102, 0.319)) * bufB[1] + mat4(vec4(0.141, -0.168, 0.115, 0.447), vec4(-0.142, 0.060, 0.002, -0.164), vec4(0.047, 0.077, 0.277, -0.010), vec4(-0.017, 0.395, -0.315, 0.003)) * bufB[2] + mat4(vec4(0.377, 0.046, -0.239, -0.067), vec4(-0.470, -0.342, -0.088, 0.157), vec4(-0.015, -0.020, -0.219, 0.213), vec4(-0.032, 0.433, -0.148, -0.105)) * bufB[3] + mat4(vec4(0.110, 0.110, 0.119, 0.054), vec4(-0.163, 0.170, 0.151, -0.081), vec4(-0.162, 0.066, -0.292, -0.352), vec4(0.327, 0.081, 0.277, -0.142)) * bufB[4] + mat4(vec4(0.165, -0.155, 0.146, -0.022), vec4(0.157, 0.077, -0.225, -0.051), vec4(-0.096, 0.129, -0.115, -0.094), vec4(0.196, 0.100, 0.005, -0.285)) * bufB[5] + mat4(vec4(0.055, 0.095, 0.055, 0.068), vec4(0.028, -0.009, -0.186, 0.515), vec4(-0.333, 0.230, 0.113, -0.338), vec4(0.237, 0.195, 0.152, -0.241)) * bufB[6] + mat4(vec4(0.141, 0.086, 0.143, 0.007), vec4(-0.059, -0.131, -0.021, 0.203), vec4(-0.258, 0.064, -0.183, 0.077), vec4(0.117, 0.040, 0.058, -0.173)) * bufB[7] + mat4(vec4(-0.229, -0.053, 0.276, -0.153), vec4(0.697, -0.054, 0.364, -0.842), vec4(0.099, -0.288, 0.158, -0.201), vec4(0.365, 0.284, 0.165, 0.392)) * bufB[8] + mat4(vec4(-0.133, -0.206, 0.193, -0.029), vec4(0.109, -0.373, 0.404, 0.022), vec4(-0.115, 0.049, -0.278, -0.382), vec4(-0.151, -0.181, -0.109, 0.013)) * bufB[9];\nbufA[3] = vec4(-0.485, -0.590, 0.172, 0.379) + mat4(vec4(-0.131, -0.196, 0.088, 0.272), vec4(-0.191, -0.247, 0.038, 0.269), vec4(0.073, 0.152, -0.031, 0.115), vec4(0.027, 0.081, 0.031, 0.427)) * bufB[0] + mat4(vec4(-0.118, 0.119, 0.016, -0.009), vec4(0.050, 0.067, -0.178, 0.313), vec4(0.093, 0.029, -0.079, 0.153), vec4(-0.113, 0.160, -0.033, 0.142)) * bufB[1] + mat4(vec4(0.131, -0.528, -0.021, -0.328), vec4(0.171, 0.201, 0.422, -0.441), vec4(0.074, 0.184, 0.146, -0.136), vec4(-0.169, -0.469, 0.124, 0.167)) * bufB[2] + mat4(vec4(-0.051, 0.010, 0.127, 0.149), vec4(0.529, 0.226, 0.028, -0.296), vec4(0.167, -0.048, 0.435, 0.237), vec4(-0.034, 0.386, 0.344, 0.037)) * bufB[3] + mat4(vec4(-0.092, -0.010, -0.570, 0.328), vec4(-0.181, -0.104, 0.519, 0.036), vec4(0.233, 0.317, -0.154, 0.233), vec4(0.180, -0.022, 0.232, 0.270)) * bufB[4] + mat4(vec4(-0.179, -0.169, -0.394, -0.163), vec4(-0.125, -0.139, 0.236, 0.252), vec4(-0.197, -0.048, -0.213, -0.204), vec4(-0.062, -0.185, -0.166, 0.540)) * bufB[5] + mat4(vec4(-0.218, 0.148, 0.095, 0.193), vec4(-0.119, -0.249, -0.020, -0.101), vec4(0.120, 0.094, 0.183, -0.351), vec4(0.070, -0.472, 0.395, -0.021)) * bufB[6] + mat4(vec4(-0.213, -0.080, -0.125, -0.096), vec4(-0.123, 0.235, -0.420, 0.023), vec4(0.218, 0.154, 0.159, -0.298), vec4(-0.120, -0.163, -0.225, -0.043)) * bufB[7] + mat4(vec4(0.252, 0.153, 0.016, -0.144), vec4(-0.054, 0.022, -0.157, 0.101), vec4(0.006, 0.193, -0.110, 0.173), vec4(-0.327, 0.082, 0.239, -0.159)) * bufB[8] + mat4(vec4(0.077, -0.250, -0.566, 0.253), vec4(-0.043, 0.137, -0.232, 0.398), vec4(0.290, 0.183, -0.096, -0.187), vec4(0.264, 0.045, -0.268, 0.165)) * bufB[9];\nbufA[4] = vec4(-0.536, 0.561, 0.145, -0.143) + mat4(vec4(0.229, -0.507, 0.448, -0.293), vec4(0.220, -0.008, 0.040, -0.184), vec4(0.056, -0.449, 0.167, -0.340), vec4(-0.071, 0.253, -0.254, 0.174)) * bufB[0] + mat4(vec4(0.001, -0.204, -0.169, -0.056), vec4(0.408, 0.185, -0.079, 0.111), vec4(0.206, -0.090, 0.087, 0.120), vec4(-0.316, 0.099, -0.322, 0.207)) * bufB[1] + mat4(vec4(-0.147, -0.223, 0.349, -0.097), vec4(0.016, -0.226, -0.000, -0.060), vec4(0.273, 0.209, 0.041, -0.316), vec4(0.213, 0.246, 0.065, -0.379)) * bufB[2] + mat4(vec4(-0.247, -0.138, 0.037, -0.016), vec4(-0.021, -0.170, 0.054, 0.394), vec4(-0.328, -0.256, -0.101, -0.069), vec4(-0.099, -0.108, -0.090, 0.169)) * bufB[3] + mat4(vec4(-0.163, -0.067, -0.029, -0.238), vec4(0.138, 0.006, -0.237, 0.150), vec4(-0.034, 0.447, 0.037, 0.244), vec4(-0.153, -0.057, 0.077, -0.102)) * bufB[4] + mat4(vec4(0.020, -0.138, -0.216, -0.071), vec4(0.049, 0.164, -0.512, 0.104), vec4(0.337, 0.198, 0.110, 0.142), vec4(0.010, -0.126, -0.105, 0.368)) * bufB[5] + mat4(vec4(0.102, -0.005, 0.148, -0.419), vec4(0.057, 0.079, 0.169, -0.134), vec4(-0.122, 0.026, 0.070, -0.022), vec4(0.141, 0.136, 0.177, -0.129)) * bufB[6] + mat4(vec4(-0.135, -0.051, -0.256, 0.133), vec4(-0.093, -0.043, 0.223, -0.136), vec4(-0.262, 0.058, 0.007, -0.186), vec4(0.196, -0.004, 0.110, -0.075)) * bufB[7] + mat4(vec4(0.127, -0.060, -0.290, 0.014), vec4(-0.278, 0.246, -0.077, -0.246), vec4(0.327, 0.160, -0.221, 0.013), vec4(0.109, 0.148, 0.141, 0.065)) * bufB[8] + mat4(vec4(0.200, -0.026, 0.134, -0.450), vec4(-0.146, -0.003, -0.071, -0.205), vec4(0.191, -0.020, -0.221, -0.061), vec4(0.099, 0.105, 0.070, 0.239)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 9 \nbufA[0] = vec4(0.025, -0.250, -0.536, 0.000) + mat4(vec4(0.131, -0.042, -0.075, 0.000), vec4(-0.001, -0.058, -0.110, 0.000), vec4(-0.590, 0.609, 0.487, 0.000), vec4(-0.151, -0.020, 0.023, 0.000)) * bufB[0] + mat4(vec4(-0.176, -0.041, -0.159, 0.000), vec4(0.407, 0.421, 0.365, 0.000), vec4(-0.352, -0.139, -0.014, 0.000), vec4(-0.150, -0.196, -0.129, 0.000)) * bufB[1] + mat4(vec4(-0.407, 0.233, 0.173, 0.000), vec4(-0.156, 0.150, 0.195, 0.000), vec4(-0.424, -0.169, -0.133, 0.000), vec4(-0.181, -0.595, -0.463, 0.000)) * bufB[2] + mat4(vec4(0.128, -0.463, -0.253, 0.000), vec4(0.373, 0.043, 0.017, 0.000), vec4(0.417, 0.189, 0.044, 0.000), vec4(0.083, 0.204, 0.148, 0.000)) * bufB[3] + mat4(vec4(0.367, 0.122, 0.034, 0.000), vec4(-0.233, 0.247, 0.069, 0.000), vec4(-0.006, -0.198, -0.160, 0.000), vec4(0.297, 0.113, 0.003, 0.000)) * bufB[4] + mat4(vec4(-0.190, -0.216, -0.209, 0.000), vec4(-0.172, -0.195, -0.183, 0.000), vec4(-0.424, 0.204, 0.126, 0.000), vec4(-0.070, -0.174, -0.177, 0.000)) * bufB[5] + mat4(vec4(0.218, -0.030, -0.128, 0.000), vec4(-0.366, -0.402, -0.302, 0.000), vec4(-0.150, -0.129, -0.035, 0.000), vec4(-0.121, 0.070, 0.048, 0.000)) * bufB[6] + mat4(vec4(0.069, 0.368, 0.250, 0.000), vec4(-0.211, -0.254, -0.141, 0.000), vec4(-0.174, -0.123, -0.118, 0.000), vec4(0.354, 0.434, 0.280, 0.000)) * bufB[7] + mat4(vec4(0.227, 0.496, 0.397, 0.000), vec4(-0.012, -0.085, -0.100, 0.000), vec4(-0.300, -0.241, -0.186, 0.000), vec4(0.203, 0.250, 0.239, 0.000)) * bufB[8] + mat4(vec4(0.093, -0.028, -0.050, 0.000), vec4(0.053, 0.110, 0.062, 0.000), vec4(0.263, 0.203, 0.130, 0.000), vec4(0.230, 0.296, 0.194, 0.000)) * bufB[9];\n\n return vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.23*sin(iTime), 0.32*sin(0.69*iTime), 0.32*sin(0.44*iTime), 0.23*sin(1.23*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 185, 185, 72877], [72879, 72879, 72936, 72986, 73434]], "test": "valid"}
{"id": "slBXDW", "name": "pointy", "author": "flimshaw", "description": "sharp", "tags": ["pointy"], "likes": 2, "viewed": 35, "published": "Public", "date": "1627664809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv = abs(uv);\n    float t = iTime*.33;\n    \n    uv *= sin(t*.25)*4.;\n    // Time varying pixel color\n    \n\n    // Output to screen\n    fragColor = vec4(\n        fract(t+distance(uv.x,abs(uv.y))*3.),\n        fract(-.43*t+distance(sin(uv.x*2.+t),abs(uv.y))*1.3),\n        fract(-.8*t+distance(uv.x,abs(uv.y))*2.1),\n        1.\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 497]], "test": "valid"}
{"id": "slBXWD", "name": "XOR Towers in Rain V3", "author": "GregRostami", "description": "Another variation of KilledByAPixel's Voxel Fractal:\n[url]https://www.shadertoy.com/view/NlB3Rz[/url]\nRain code from P_Malin's SmallStars\n[url]https://www.shadertoy.com/view/Ml2XDt[/code]", "tags": ["3d", "voxel", "fog", "rain", "city", "lights"], "likes": 12, "viewed": 265, "published": "Public API", "date": "1627671898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"XOR Towers in Fog & Rain\" by GregRostami. https://shadertoy.com/view/7lsXR2\n// Thanks to P_Malin's SmallStars code for the rain.\n// Place a \"//\" in front of each line with a \"*\" in the comments to turn that feature off. \n\nvoid mainImage(out vec4 o, vec2 u)\n{\n     vec2 R = iResolution.xy;\n    ivec4 b = ivec4(o -= o);                   // Initialize b=0\n    float t = .1*iTime, B, h, z, i=0.;\n     vec4 g;\n            \n    u =\n        (2. + cos(t)) *                        // * Camera push in/out \n        (u+u-R)/R.y                            //   Center coordinates\n        * mat2( cos( vec4(0,33,55,0) - .1*t))  // * Rotate camera\n        ;\n        \n    z = (h = cos(B = ceil(atan(u.x, u.y) * 2e2))) / dot(u,u);  //Variables for Rain\n    \n    for (;i<3.;)\n    g += pow(texture(iChannel2,.5*u + .1*sin(t/.1+(i+=.04)+3.*u) ),g-g+8.); // Ground ghosts\n            \n    for (; (b.x^b.y^b.z)%99 > b.z-8 ; )        // The XOR function for towers!!\n        b = ivec4(u * o.a + 2e2\n                + vec2(7,30)*t                 // * Move camera (x,y)\n                , o+=.1 );                     // Increment layer\n                \n    o =\n        o.a < 8.1 ? .1+sin(t/.1)*vec4(b%32 & b.x%9 & b.z%9) :  // * Blinking lights\n        o/80. - .02 *                                          // * Distance fog\n        vec4(b%3)                                              // * Building colors\n        + .2*(o.a > 17. ? vec4( int(.5+sin(float(b.x/2 + b.y + 2*b.z))) & b.x & b.y & int(.5+sin(4.*o.a-3.4)) ) : g-g) // * Windows\n        + (o.a > 50. ? g*vec4(.15,.4,1,0) : g-g)               // * Ground ghosts\n        + .06*texture( iChannel1, .02*u - .03*t ).r            // * Moving fog\n        + .01*max(exp(fract(h * B - z + t+t) * -1e2) / z,0.)   // * Rain\n        ;\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "XlXSWj", "previewfilepath": "https://soundcloud.com/hanangobran/violin-crying-rain", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/hanangobran/violin-crying-rain", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 234, 270, 270, 1778]], "test": "error"}
{"id": "slBXWz", "name": "Squiggly noise thingy very cool", "author": "SnoopethDuckDuck", "description": "Forked from iq, playing around with a few things", "tags": ["procedural", "2d", "noise", "perlin"], "likes": 4, "viewed": 52, "published": "Public", "date": "1627416724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\nconst float tau = 2. * 3.14159;\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec4 colorMap(vec3 a, vec3 b, vec3 c, vec3 d, float t) {\nvec3 col = a + b * vec3(cos(tau * (c.r * t + d.r)),\n                        cos(tau * (c.g * t + d.g)),\n                        cos(tau * (c.b * t + d.b)));\n\nreturn vec4(col.r, col.g, col.b, 1.);\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\t\n\tfloat f = 0.0;\n\n\t\tuv = uv * 3.0 + 100.;\n        mat2 m = (1. + 0.005 * noise(uv + 0.04 * iTime)) * mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.800*noise( uv ); uv = m*uv;\n\t\tf += 0.100*noise( uv ); uv = m*uv;\n\t\tf += 0.050*noise( uv ); uv = m*uv;\n\t\tf += 0.025*noise( uv ); uv = m*uv;\n        \n\tf = cos(3.14159 * 2. * (1. + cos(0.3 * iTime)) * f * (1.-f));\n    \nvec3 h = vec3(0.5, 0.5, 0.5);\nfloat t = 0.1 * iTime;\nfloat b1 = 0.25 * (1. + cos(t));\nfloat b2 = 0.25 * (1. + cos(t + tau / 3.));\nfloat b3 = 0.25 * (1. + cos(t + 2. * tau / 3.));\nfragColor = colorMap(h, h, vec3(b1,b2,b3), vec3(b2, b3, b1), f);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBXWz.jpg", "access": "shaders20k", "license": "mit", "functions": [[2053, 2053, 2110, 2110, 2225], [2227, 2227, 2253, 2253, 2732], [2734, 2734, 2790, 2790, 2988], [3042, 3042, 3099, 3099, 3814]], "test": "valid"}
{"id": "slBXzw", "name": "my first tesseract", "author": "xertrov", "description": "first glimpse of a tesseract. very experimental rendering method. click and drag to find a good angle. the fuzzier it is, the more of the shape is not well aligned along w. obvs there's a lot of room for improvement, but I'm pretty excited!", "tags": ["raymarching", "4d", "learning", "tesseract", "hypercube"], "likes": 3, "viewed": 211, "published": "Public API", "date": "1627305704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define S(a, b, t)smoothstep(a, b, t)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n#define GROW_SHRINK 0.3\n#define ROTATE_IDLE 0.2\n#define BASE_TWINKLE 99.0\n#define STAR_RARITY 0.95\n// set to 5k+ for a hyperspace bungee; curious noise patterns at 2000.\n#define BG_SCALE 100.0\n\n/* lib/util stuff */\n\nfloat N21b(vec2 p) {  // from an art of code video i think\n  vec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n  a += dot(a, a.yzx + 79.76);\n  return fract((a.x + a.y) * a.z);\n}\n\n\nfloat sdBox(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.z, max(d.x, d.y)), 0.0);\n}\n\n\nvec2 best2(vec3 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\nfloat minOf(vec3 v) {\n  return min(minOf(v.xy), v.z);\n}\nfloat minOf(vec4 v) {\n  return min(minOf(v.xyz), v.w);\n}\n\nvec2 sinCos(in vec2 ab) {\n  return vec2(sin(ab.x), cos(ab.y));\n}\n\n// roll from XY to XZ or YZ (0 no roll, 1=XZ, 2=YZ)\nmat3 rot3XY(float angle, int roll) {\n  float s = sin(angle), c = cos(angle);\n  mat3 r = mat3(c, - s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n  if (roll == 1) {\n    r = mat3(r[0].xzy, r[2].xzy, r[1].xzy);\n  } else if (roll == 2) {\n    r = mat3(r[2].zxy, r[0].zxy, r[1].zxy);\n  }\n  return r;\n}\n\n\n// warning, this is mostly untested -- written by me for this. fyi if you copy paste.\nmat4 rot4(float angle, int axis) {\n  float s = sin(angle), c = cos(angle);\n  mat4 r = mat4(\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  // XY, XZ, XW\n  return axis == 0 ? r\n    : axis == 1 ? mat4(r[0].xzyw, r[2].xzyw, r[1].xzyw, r[3].xzyw)\n    : axis == 2 ? mat4(r[0].xwzy, r[3].xwzy, r[2].xwzy, r[1].xwzy)\n    // YZ, YW\n    : axis == 3 ? mat4(r[3].wxyz, r[0].wxyz, r[1].wxyz, r[2].wxyz)\n    : axis == 4 ? mat4(r[3].wxzy, r[0].wxzy, r[1].wxzy, r[2].wxzy)\n    // ZW\n    : axis == 5 ? mat4(r[3].wzxy, r[2].wzxy, r[0].wzxy, r[1].wzxy) : mat4(0.);\n}\n    /* Ahh! That bug isn't going to make sensible rotations. */\n    //axis == 5 ? mat4(r[2].wzxy, r[3].wzxy, r[1].wzxy, r[2].wzxy)\n\n\n\nvec3 best3(vec4 p) {\n  vec2 zw = vec2(max(p.z, p.w), min(p.z, p.w));\n  // p.z > p.w ? vec2(p.z, p.w) : vec2(p.w, p.z);\n  vec2 xy = vec2(max(p.x, p.y), min(p.x, p.y));\n  if (xy.y > zw.x) {return vec3(xy, zw.x);} // testme\n  if (zw.y > xy.x) {return vec3(zw, xy.x);}\n  return vec3(max(xy.x, zw.x), min(xy.x, zw.x), max(xy.y, zw.y));\n\n  /* tests\n  col = best2(zoth.xyz) == vec2(2., 1.) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.zywx) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxzy) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxyz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.xywz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  */\n}\n\nvec3 rainbow(vec2 uv, float time) {\n  return sin(vec3(time) + uv.xyx * vec3(1.0, 1.0, 1.0) + vec3(0, 2, 4)) * 0.49 + 0.5;\n}\n\n\nfloat sdBoxEdge(in vec3 p, in vec3 b) {\n  return length(best2(abs(p) - b));\n}\n\n// purely a guess based on the one for a cube\nfloat sdTesseractEdge(in vec4 p, in vec4 b) {\n  vec4 d = abs(p) - b;\n  //d.w /= 5.;\n  vec3 db = best3(d);\n  return length(db);\n}\n\nvec4 getIDGV(vec2 uv, float scale) {\n  vec2 id = floor(uv * scale);\n  vec2 gv = fract(uv * scale) - 0.5;\n  return vec4(id, gv);\n}\n\nfloat mkNoise(vec2 uv, float t, float minDS) {\n  float scale = fwidth(uv.x) * 100.0 * BG_SCALE;\n  vec4 idgv = getIDGV(uv, scale);\n  vec2 id = idgv.xy;\n  vec2 gv = idgv.zw;\n  float n = N21b(id);\n  float transFreq = BASE_TWINKLE * n + 0.01;\n  t -= 3877.627 * n;\n  float transProgress = fract(t * transFreq);\n  float transId = floor(t * transFreq);\n  float lastIdOffset = N21b(vec2(n, transId - 1.0));\n  float idOffset = N21b(vec2(n, transId));\n  float nextIdOffset = N21b(vec2(n, transId + 1.0));\n  float noiseThresh = STAR_RARITY;\n  float noise = S(1.0, 0.0, transProgress) * S(noiseThresh, 1.0, N21b(id + lastIdOffset));\n  noise += S(noiseThresh, 1.0, N21b(id + idOffset));\n  noise += S(0.0, 1.0, transProgress) * S(noiseThresh, 1.0, N21b(id + nextIdOffset));\n  return S(0.0, 0.2, minOf(0.5 - abs(gv))) * (noise * S(0.1, 2.0, minDS));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (gl_FragCoord.xy - .5 * u_resolution.xy) / u_resolution.y;\n  vec2 mouse = (u_mouse.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  float t = u_time / 9.0;\n  vec3 col = BLACK;\n  uv *= 4.0;\n\n  float fw = max(fwidth(uv.x), fwidth(uv.y));\n\n  float grow_shrink = GROW_SHRINK * sin(t * PI) * 0.1 + 0.9;\n\n  vec4 s = vec4(1.0, 1.0, 1.0, 1.0) * grow_shrink;\n\n  vec4 p = vec4(uv, - 4.0, N21b(uv) * 4. - 2.);\n\n  mat4 boxTrans = rot4(mouse.x * TAU / 2.0 + .347856, 1) * rot4(mouse.y * TAU / 2.0 + .37465, 4);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE + PI / 3.0, 1) * rot4(t * 13.0 / 11.0 * ROTATE_IDLE - 17.0 * PI / 7.0, 2);\n  boxTrans *= rot4(t * 11.0 / 17.0 * ROTATE_IDLE + PI / 3.0, 2) * rot4(t * 13.0 / 11.0 * ROTATE_IDLE - 17.0 * PI / 7.0, 3);\n  boxTrans *= rot4(t * 12.0 / 17.0 * ROTATE_IDLE + PI / 3.0, 4);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE, 5);\n\n  // raymarch over the orthogonal scene\n  vec2 sc = sinCos(vec2(t));\n  vec4 rd = normalize(vec4(0.0, 0.0, 1.0, 0.0));\n  float d = 0.0, dS = 999.0, minDS = 999.0, ed;\n  float steps = 0.0;\n  for(int i = 0; i < 50; i ++ ) {\n    ed = 999.;\n    steps ++ ;\n    float w = 0.0;\n    for (float w = -1.3; w < 1.3; w += .1) {\n        //if (w < minOf(s * boxTrans)) continue;\n        vec4 p_ = vec4(p.xyz, p.w + w) * boxTrans;\n        ed = min(ed, sdTesseractEdge(p_, s) - 0.01);\n    }\n    \n    dS = ed;\n    // dS = min(edgeDist, sdBox(p*boxTrans, s));\n    minDS = min(minDS, dS);\n    p = p + dS * rd * .5;\n    d += dS;\n    if (dS < 0.0001 || d > 100.0)break;\n  }\n\n\n  float noise = mkNoise(uv * grow_shrink, t, 1.);\n  col += noise;\n  col += S(0.01, 0.0, dS) * WHITE;\n  col += S(0.023, 0.005, minDS) * rainbow(uv, u_time + 2.0);\n  //col = minDS == 0. ? WHITE : RED;\n  \n  vec4 idgv = getIDGV(uv, 1.0);\n  vec2 id = idgv.xy, gv = idgv.zw;\n\n\n  gl_FragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 486, 524, 656], [659, 659, 694, 694, 785], [788, 788, 808, 808, 964], [966, 966, 987, 987, 1013], [1014, 1014, 1035, 1035, 1069], [1070, 1070, 1091, 1091, 1126], [1128, 1128, 1153, 1153, 1192], [1194, 1246, 1282, 1282, 1529], [1532, 1618, 1652, 1652, 2190], [2325, 2325, 2345, 2345, 3102], [3104, 3104, 3139, 3139, 3227], [3230, 3230, 3269, 3269, 3307], [3309, 3355, 3400, 3400, 3483], [3485, 3485, 3521, 3521, 3614], [3616, 3616, 3662, 3662, 4452], [4454, 4454, 4509, 4509, 6346]], "test": "valid"}
{"id": "slfSD2", "name": "Cel Shaded Noise ", "author": "ethann", "description": "Using Raymarching to render 3D noise with a cel shaded palette", "tags": ["raymarching"], "likes": 1, "viewed": 55, "published": "Public", "date": "1626555791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Define some constants\nconst int steps = 100; // This is the maximum amount a ray can march.\nconst float smallNumber = 0.001;\nconst float maxDist = 15.; // This is the maximum distance a ray can travel.\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n \nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat scene(vec3 position){\n    // So this is different from the sphere equation above in that I am\n    // splitting the position into its three different positions\n    // and adding a 10th of a cos wave to the x position so it oscillates left \n    // to right and a (positive) sin wave to the z position\n    // so it will go back and forth.\n    float sphere = noise(\n        vec3(\n            position.x + sin(iTime*.1), \n            position.y + cos(iTime*.5), \n            position.z + iTime*.5+1.0)\n        ) - sin(iTime*.4)*.05-.2;\n    \n    // This is different from the ground equation because the UV is only \n    // between -1 and 1 we want more than 1/2pi of a wave per length of the \n    // screen so we multiply the position by a factor of 10 inside the trig \n    // functions. Since sin and cos oscillate between -1 and 1, that would be \n    // the entire height of the screen so we divide by a factor of 10.\n    //float ground = position.y + sin(position.x * 5.) / 10. \n    //                          + cos(position.z * 10.) / 10. + 1.0;\n    \n    // We want to return whichever one is closest to the ray, so we return the \n    // minimum distance.\n    return sphere;\n}\n \n // Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.0*3.1415/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.0)) c = abs(c);\n    return c;\n}\n\n \nvec4 trace (vec3 origin, vec3 direction){\n    \n    float dist = 0.;\n    float totalDistance = 0.;\n    vec3 positionOnRay = origin;\n    \n    for(int i = 0 ; i < steps; i++){\n        \n        dist = scene(positionOnRay);\n        \n        // Advance along the ray trajectory the amount that we know the ray\n        // can travel without going through an object.\n        positionOnRay += dist * direction;\n        \n        // Total distance is keeping track of how much the ray has traveled\n        // thus far.\n        totalDistance += dist;\n        \n        // If we hit an object or are close enough to an object,\n        if (dist < smallNumber){\n            // return the distance the ray had to travel normalized so be white\n            // at the front and black in the back.\n            return 1.0 - vec4(totalDistance / maxDist);\n \n        }\n        \n        if (totalDistance > maxDist){\n \n            return vec4(0.); // Background color.\n        }\n    }\n    \n    return vec4(0.);// Background color.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 pos = fragCoord/iResolution.xy-vec2(.5,.5);\n    \n    //pModPolar(pos,4.0);\n    \n    vec3 camOrigin = vec3(0,0,-1);\n\tvec3 rayOrigin = vec3(pos + camOrigin.xy, camOrigin.z + 1.0);\n\tvec3 dir = rayOrigin - camOrigin;\n\t\n\tvec4 dist = trace(rayOrigin,dir);\n    //palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n    vec4 color = vec4(0);\n    if(dist.z < .3){\n        color = vec4(dist.z*5.0,0,dist.x*1.0-.5,0);\n    }\n    if(dist.z < .4){\n        color = vec4(dist.z*4.0,0,dist.x*2.0-.5,0);\n    }\n    else if(dist.z < .6){\n        color = vec4(dist.z*3.0,0,dist.x*3.0-.5,0);\n    }\n    else if(dist.z < .9){\n        color = vec4(dist.z*2.0,0,dist.x*4.0-.5,0);\n    }\n    else{\n        color = vec4(dist.z*1.0,0,dist.x*5.0-.5,0);\n    }\n    //vec4 color = vec4(palette(dist.x*2.0, vec3(.5),vec3(.5),vec3(1.0),vec3(0.0,.33,.67)), dist.yzw);\n    \n    fragColor = color;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 245, 317, 317, 360], [363, 363, 420, 420, 515], [517, 517, 543, 543, 1017], [1019, 1019, 1046, 1360, 2200], [2204, 2317, 2367, 2367, 2793], [2797, 2797, 2838, 2838, 3804], [3806, 3806, 3863, 3863, 4757]], "test": "valid"}
{"id": "slfSDN", "name": "UpArrow", "author": "ayaha401", "description": "I wanted to do live coding, so I tried to practice, but it was difficult.\nI made this shader in 20 minutes.", "tags": ["abs"], "likes": 3, "viewed": 55, "published": "Public", "date": "1625707136", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv.x = abs(uv.x);\n    uv.y -= (fract(iTime / 5.) * 2. - 1.) * 5.;\n    uv.y = mod(uv.y, 1.);\n    \n    float c = dot(uv, normalize(vec2(1., 1.)));\n    c = step(c, .7) - step(c + .1, .7);\n    \n    fragColor = vec4(c ,c, c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 388]], "test": "valid"}
{"id": "slfSR7", "name": "CineShader Demo", "author": "jhancock532", "description": "This has been adapted from the book of shaders (https://thebookofshaders.com/edit.php#10/ikeda-03.frag) to be displayed on cineshader.com", "tags": ["cineshader"], "likes": 6, "viewed": 966, "published": "Public API", "date": "1625335154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat pattern(vec2 st, vec2 v, float t) {\n    vec2 p = floor(st+v);\n    return step(t, random(8.+p*.000001)+random(p.x)*0.5 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    vec2 grid = vec2(100.0,50.);\n    st *= grid;\n\n    vec2 ipos = floor(st);  // integer\n    vec2 fpos = fract(st);  // fraction\n\n    vec2 vel = vec2(iTime*1.*max(grid.x,grid.y)); // time\n    vel *= vec2(-1.,0.0) * random(1.0+ipos.y); // direction\n\n    // Assign a random value base on the integer coord\n    vec2 offset = vec2(0.1,0.);\n\n    vec3 color = vec3(0.);\n    color.r = pattern(st+offset,vel,0.5);\n    color.g = pattern(st,vel,0.5);\n    color.b = pattern(st-offset,vel,0.5);\n\n    // Margins\n    color *= step(0.2,fpos.y);\n\n    fragColor = vec4(color,1.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"CineShader Demo\",\n\t\"description\": \"Adapted from Book of Shaders\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 59], [61, 61, 88, 88, 162], [164, 164, 205, 205, 292], [294, 294, 351, 351, 1004]], "test": "valid"}
{"id": "slfSRH", "name": "Five Metallic Tetrahedra", "author": "dr2", "description": "Five interlocking tetrahedral frames ('Compound of Five Tetrahedra')", "tags": ["reflect", "symmetry", "polyhedron", "sculpture"], "likes": 13, "viewed": 213, "published": "Public API", "date": "1625128360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Five Metallic Tetrahedra\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// (Based on \"Ten Intersecting Tetrahedra\")\n\n#define AA  1\n\nfloat PrSphDf (vec3 p, float r);\nfloat Maxv2 (vec2 p);\nmat3 VToRMat (vec3 v, float a);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir;\nfloat tCur, dstFar;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat TetFrameDf (vec3 p, float w)\n{\n  vec3 q;\n  q = p;\n  p = abs (p);\n  q = mix (q, q.yzx, step (Maxv2 (p.yz), p.x));\n  q = mix (q, q.zxy, step (Maxv2 (p.zx), p.y));\n  q = mix (q, vec3 (q.x, - q.yz).yxz, step (q.z, 0.)) - vec3 (-1., 1., 1.) / sqrt (3.);\n  return length (vec2 (0.5 * (q.x + q.y), q.z)) - w;\n}\n\nfloat ObjDf (vec3 p)\n{\n  mat3 m;\n  vec3 q;\n  float dMin, d, a;\n  dMin = dstFar;\n  p.y -= 0.86;\n  q = p;\n  d = PrSphDf (q, 1.1);\n  if (d < 0.1) {\n    a = atan (2. / (sqrt (5.) + 1.));\n    m = VToRMat (vec3 (0., sin (a + vec2 (0.5 * pi, 0.))), 2. * pi / 5.);\n    q.yz = Rot2D (q.yz, a);\n    for (int k = 0; k < 5; k ++) {\n      d = TetFrameDf (q, 0.05);\n      dMin = min (dMin, d);\n      q = m * q;\n    }\n    dMin = max (dMin, PrSphDf (p, 1.05));\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, dstGrnd, sh;\n  bool isBg;\n  const int nRefl = 1;\n  isBg = false;\n  dstGrnd = dstFar;\n  for (int k = VAR_ZERO; k <= nRefl; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (k < nRefl && dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n  } else {\n    isBg = true;\n    col = SkyBgCol (ro, rd);\n  }\n  if (! isBg) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    if (dstObj < dstFar) {\n      col = vec3 (0.4, 0.5, 0.9) * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         0.2 * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    } else {\n      col = 0.5 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n         0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)));\n      vn = VaryNf (16. * ro, vec3 (0., 1., 0.), 1. - smoothstep (0.5, 0.8, dstGrnd / dstFar));\n      col *= (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n      col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -6.);\n  ro.y += 0.8;\n  zmFac = 5.;\n  dstFar = 30.;\n  sunDir = normalize (vec3 (0., 2., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.02 * pi * tCur);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2, bp, bm;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.xzy * v.yxz;\n  b2 = - cs.y * v.zyx;\n  bp = b1 + b2;\n  bm = b1 - b2;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[0][1] = bp.x;  m[1][0] = bm.x;\n  m[2][0] = bp.y;  m[0][2] = bm.y;\n  m[1][2] = bp.z;  m[2][1] = bm.z;\n  return m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfSRH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[524, 524, 560, 560, 833], [835, 835, 857, 857, 1327], [1329, 1329, 1362, 1362, 1609], [1611, 1611, 1632, 1632, 1887], [1889, 1889, 1926, 1926, 2169], [2171, 2171, 2205, 2205, 2962], [2964, 2964, 2999, 2999, 4255], [4257, 4257, 4313, 4313, 5358], [5360, 5360, 5382, 5382, 5409], [5411, 5411, 5444, 5444, 5471], [5473, 5473, 5505, 5505, 5883], [5885, 5885, 5921, 5921, 6127], [6129, 6129, 6159, 6159, 6272], [6306, 6306, 6330, 6330, 6383], [6385, 6385, 6409, 6409, 6521], [6523, 6523, 6548, 6548, 6694], [6696, 6696, 6721, 6721, 6907], [6909, 6909, 6931, 6931, 7085], [7087, 7087, 7108, 7108, 7263], [7265, 7265, 7294, 7294, 7506], [7508, 7508, 7547, 7547, 7799]], "test": "error"}
{"id": "slfSWr", "name": "Sin Lines V2", "author": "Vinicius_Jesus", "description": "Just playing with the code. Getting used to this new world.", "tags": ["lines", "sin"], "likes": 3, "viewed": 55, "published": "Public", "date": "1625779849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= 5.;\n    uv.x += iTime*.5;\n    \n    vec3 color = vec3(0.);\n    \n    for( float i = 0.; i < 150.; ++i )\n    {\n        float t = iTime;\n        uv.y += cos(uv.x + i)*vec2(sin(t), cos(t)).x;\n        float fTemp = abs(1. / uv.y / 100.);\n        color += vec3(fTemp*(10.-i)/10., fTemp/10., vec2(fTemp)*1.5);\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfSWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 470]], "test": "valid"}
{"id": "slfXzs", "name": "Mandelbrot - 001", "author": "EricHuang", "description": "Mandelbrot", "tags": ["mandelbrot"], "likes": 1, "viewed": 62, "published": "Public", "date": "1626311724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float loop = 20.;\n\nvec3 colorFn2(float n,float iter){\n\tfloat r=n==iter?0.:n*n*n;\n\tfloat g=n==iter?0.:n*n;\n\tfloat b=n==iter?0.:n;\n\treturn vec3(r,g,b)/iter;\n}\n\nvec2 complexNPower(vec2 z,float n){\n    float r = length(z);\n    float nr = pow(r,n);\n    float theta = atan(z.y,z.x) * n;\n    return vec2(nr * cos(theta),nr * sin(theta));\n}\n\nfloat escapeTime(float iter,vec2 z,vec2 c){\n\tfloat i;\n    float n = loop/2. - cos(iTime/10.) * (loop/2. -1.);\n\tfor(i=0.;i<iter;i++){\n        z = complexNPower(z,n) + c; // zÂ² + c\n\t\tif(dot(z,z)> 4.){\n\t\t\tbreak;\n\t\t}\n\t}\n    return i-log2(log2(dot(z,z))) + 4.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float uScale = 2.5;\n    vec2 uPos = vec2(-3.,-1.25);\n    float uIter = 100.;\n    \n\tvec2 p=vec2(uv.x*iResolution.x/iResolution.y,uv.y)*uScale;\n\tvec2 c=p+uPos;\n\tvec2 z=vec2(0.);\n    float i = escapeTime(uIter,z,c);\n\tvec3 color=colorFn2(i,uIter);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 59, 59, 162], [164, 164, 199, 199, 338], [340, 340, 383, 383, 598], [600, 600, 657, 657, 1005]], "test": "valid"}
{"id": "sljSz1", "name": "Primitives dance", "author": "noocar", "description": "Some SDF practice.", "tags": ["sdf"], "likes": 1, "viewed": 49, "published": "Public", "date": "1627124330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.835, 1, 1);\nconst vec3 LIGHT_POSITION = vec3(0.);\n\n\nstruct Material {\n    uint id;\n    vec3 color;\n};\n\nstruct Surface {\n    float dist;\n    Material material;\n};\n\n\n// Random\nvec3 hash3( uint n ) {\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n// ----------\n\n\n// Transforms\nmat4 scale(vec3 s)\n{\n    return mat4(\n        vec4(s.x, 0, 0, 0),\n        vec4(0, s.y, 0, 0),\n        vec4(0, 0, s.z, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotation(vec3 r)\n{\n    float cx = cos(r.x);\n    float sx = sin(r.x);\n    float cy = cos(r.y);\n    float sy = sin(r.y);\n    float cz = cos(r.z);\n    float sz = sin(r.z);\n    return mat4(\n        vec4(cy*cz, -cy*sz, sy, 0),\n        vec4(sx*sy*cz+cx*sz, -sx*sy*sz+cx*cz, -sx*cy, 0),\n        vec4(-cx*sy*cz+sx*sz, cx*sy*sz+sx*cz, cx*cy, 0),\n        vec4(0, 0, 0, 1)\n    );     \n}\n\nmat4 translation(vec3 t)\n{\n    return mat4(\n        vec4(1, 0, 0, t.x),\n        vec4(0, 1, 0, t.y),\n        vec4(0, 0, 1, t.z),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 identity() {\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 loockAt(vec3 pos, vec3 target) {\n\tvec3 dir = normalize(target - pos);\n\tvec3 right = normalize(cross(vec3(0., 1., 0.), dir));\n\tvec3 uu = normalize(cross(dir, right));\n\t\n\treturn mat4(\n        vec4(-right, 0.), \n        vec4(uu, 0.),\n        vec4(-dir, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n}\n\nvec3 applyPoint(mat4 m, vec3 v)\n{\n    vec4 v4 = vec4(v, 1.);\n    v4 = v4 * m;\n    return v4.xyz / v4.w;\n}\n\nvec3 applyVector(mat4 m, vec3 v)\n{\n    vec4 v4 = vec4(v, 0.);\n    v4 = v4 * m;\n    return v4.xyz;\n}\n// ----------\n\n\n// Signed Distance Functions\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nSurface sdSphere(vec3 p, float s, Material material)\n{\n    float d = length(p)-s;\n    return Surface(d, material);\n}\n\nSurface sdBox(vec3 p, vec3 b, Material material)\n{\n    vec3 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    return Surface(d, material);\n}\n\nSurface sdTorus(vec3 p, vec2 t, Material material)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    return Surface(d, material);\n}\n\nSurface sdCone(vec3 p, vec2 c, float h, Material material)\n{\n    float q = length(p.xz);\n    float d = max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n    return Surface(d, material);\n}\n\nSurface sdTriPrism(vec3 p, vec2 h, Material material)\n{\n    vec3 q = abs(p);\n    float d = max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n    return Surface(d, material);\n}\n\nSurface sdCappedCylinder(vec3 p, float h, float r, Material material)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    float di = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    return Surface(di, material);\n}\n\nSurface sdSolidAngle(vec3 p, vec2 c, float ra, Material material)\n{\n  // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xz), p.y );\n    float l = length(q) - ra;\n    float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    float d = max(l,m*sign(c.y*q.x-c.x*q.y));\n    return Surface(d, material);\n}\n\nSurface sdUnion(Surface obj1, Surface obj2) {\n    if (obj2.dist < obj1.dist) return obj2;\n    return obj1;\n}\n// ----------\n\n\nmat4 randomOrbitRotation(uint seed)\n{\n    vec3 rnd = hash3(seed);\n    float radius = mix(10., 30., rnd.x);\n    float ors = mix(.1, .4, rnd.z); // orbit rotation speed\n    float lrs = mix(.3, .6, rnd.y); // local rotation speed\n    mat4 rt = translation(vec3(0., 0., 1.) * radius);  // radius translation\n    mat4 o = rt * rotation(rnd * PI2);  // orbit\n    vec3 wp = applyPoint(o, vec3(0., 0., 1.)); // position World Space\n    mat4 or = rotation(vec3(0., iTime * PI2 * ors, 0.)); // orbit rotation\n    mat4 lr = rotation(rnd * iTime * PI2 * lrs); // local rotation\n    mat4 m = loockAt(wp, vec3(0.)) * or * rt * lr; // result matrix\n\n    return m;\n}\n\n\nSurface sdScene(vec3 p) {\n    Material mt = Material(0U, vec3(0.));\n    Surface s = Surface(MAX_DIST, mt);\n    s = sdUnion(s, sdSphere(p, 1.5, mt)); // center\n\n    // Boxes\n    mt = Material(1U, vec3(.9, .3, .1));\n    for (int i = 1; i <= 10; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface box = sdBox(applyPoint(m, p), vec3(1), mt);\n        s = sdUnion(s, box);\n    }\n    \n    // Toruses\n    mt = Material(2U, vec3(.2, .4, .1));\n    for (int i = 11; i <= 20; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface torus = sdTorus(applyPoint(m, p), vec2(1., .3), mt);\n        s = sdUnion(s, torus);\n    }\n    \n    // Cones\n    mt = Material(3U, vec3(.1, .2, .6));\n    for (int i = 21; i <= 30; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface cone = sdCone(applyPoint(m, p), vec2( .5, .2), 3., mt);\n        s = sdUnion(s, cone);\n    }\n    \n    // Prisms\n    mt = Material(4U, vec3(.4, .2, .3));\n    for (int i = 41; i <= 50; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface prism = sdTriPrism(applyPoint(m, p), vec2(1., 1.4), mt);\n        s = sdUnion(s, prism);\n    }\n    \n    // Cylinders\n    mt = Material(5U, vec3(.7, .2, .6));\n    for (int i = 51; i <= 60; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface cylinder = sdCappedCylinder(applyPoint(m, p), .7, 1., mt);\n        s = sdUnion(s, cylinder);\n    }\n    \n    // Angles\n    mt = Material(6U, vec3(.5, .9, .9));\n    for (int i = 61; i <= 70; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface angle = sdSolidAngle(applyPoint(m, p), vec2(3,4)/5.0, 2.5, mt);\n        s = sdUnion(s, angle);\n    }\n    \n    return s;\n}\n\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    Surface co; // closest object\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        depth += co.dist;\n        if (co.dist < PRECISION || depth > end) break;\n    }\n\n    co.dist = depth;\n\n    return co;\n}\n\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n        e.xyy * sdScene(p + e.xyy).dist +\n        e.yyx * sdScene(p + e.yyx).dist +\n        e.yxy * sdScene(p + e.yxy).dist +\n        e.xxx * sdScene(p + e.xxx).dist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 0, 50); // ray origin that represents camera position\n    vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n    if (co.dist > MAX_DIST) {\n        col = BACKGROUND_COLOR;\n    }\n    else {\n        vec3 p = ro + rd * co.dist; // point on the surface we discovered from ray marching\n        vec3 normal = calcNormal(p);\n        vec3 lightDirection = normalize(LIGHT_POSITION - p);\n\n        float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n\n        col = dif * co.material.color + BACKGROUND_COLOR * .2; // Add a bit of background color to the diffuse color\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 403, 425, 468, 651], [668, 682, 702, 702, 837], [839, 839, 862, 862, 1219], [1221, 1221, 1247, 1247, 1382], [1384, 1384, 1401, 1401, 1530], [1532, 1532, 1569, 1569, 1829], [1831, 1831, 1864, 1864, 1936], [1938, 1938, 1972, 1972, 2037], [2054, 2154, 2208, 2208, 2270], [2272, 2272, 2322, 2322, 2449], [2451, 2451, 2503, 2503, 2608], [2610, 2610, 2670, 2670, 2782], [2784, 2784, 2839, 2839, 2962], [2964, 2964, 3035, 3035, 3184], [3186, 3186, 3253, 3288, 3492], [3494, 3494, 3539, 3539, 3602], [3619, 3619, 3656, 3656, 4269], [4272, 4272, 4297, 4297, 5963], [5966, 5966, 6026, 6026, 6323], [6326, 6326, 6354, 6354, 6596], [6599, 6599, 6656, 6656, 7463]], "test": "valid"}
{"id": "sljXz1", "name": "Gyroid Sphere", "author": "Kamoshika", "description": "Gyroid.", "tags": ["raymarching", "gyroid"], "likes": 26, "viewed": 266, "published": "Public", "date": "1627131242", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://twitter.com/kamoshika_vrc/status/1418594024475136002\n\n#define D(p) abs(dot(sin(p), cos(p.yzx)))\n\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nvec3 hsv(float h, float s, float v) {\n    vec4 a = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + a.xyz) * 6.0 - vec3(a.w));\n    return v * mix(vec3(a.x), clamp(p - vec3(a.x), 0.0, 1.0), s);\n}\n\nfloat map(vec3 p) {\n    float d = length(p) - .8;\n    p *= 10.;\n    d = max(d, (D(p) - .03) / 10.);\n    p *= 10.;\n    d = max(d, (D(p) - .3) / 100.);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) /min(iResolution.x, iResolution.y);\n    vec3 col = vec3(0);\n    \n    mat3 cRot = rotate3D(iTime, vec3(1, 1, 1));\n    vec3 cPos = vec3(0, 0, 2) * cRot;\n    vec3 cDir = normalize(-cPos);\n    vec3 cSide = normalize(cross(cDir, vec3(0, 1, 0) * cRot));\n    vec3 cUp = normalize(cross(cSide, cDir));\n    vec3 ray = normalize(uv.x*cSide + uv.y*cUp + cDir*2.);\n    \n    vec3 rPos = cPos;\n    float d = 0.;\n    float c = 0.;\n    for(int i=0; i<99; i++) {\n        d = map(rPos);\n        if(d < 1e-4) {\n            break;\n        }\n        rPos += ray * d * .6;\n        c++;\n    }\n    col += hsv(.3 - length(rPos), .7, 20./c);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 146, 146, 555], [557, 557, 594, 594, 773], [775, 775, 794, 794, 940], [942, 942, 999, 999, 1702]], "test": "valid"}
{"id": "sllSDS", "name": "Ready Player One", "author": "dean_the_coder", "description": "After just finishing the Ready Player One book, and watching the film a couple of times, I was inspired\nto try to make a scene inspired by it.\nHope you like it!\n", "tags": ["3d", "raymarching", "glow", "vr", "movie", "cineshader"], "likes": 35, "viewed": 1095, "published": "Public API", "date": "1626467598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Ready Player One' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/sllSDS (YouTube: https://youtu.be/jUx2yGj3pGo)\n//\n// \"It's not about winning, it's about playing.\"\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// After just finishing the Ready Player One book,\n// and watching the film a couple of times, I was inspired\n// to try to make a scene inspired by it.\n//\n// Hope you like it!\n//\n// Tricks to get the performance:\n//\n// A relatively straight-forward ray-marching scene, but to keep\n// the performance up I've tried to avoid adding noise into the SDF\n// as much as possible - The finer detail on the terrain is applied\n// when calculating the material color.\n//\n// The Iron Giant only has one real arm and leg - I've used mirroring\n// on the X axis to duplicate the other side.\n// The arm and leg SDF is generated from the same function, parameterized\n// to slightly adjust appearance.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c) smoothstep(a, b, c)\n\nfloat t, g;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n#define HASH\tp = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\n\nvec4 h44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(h44(h), h44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\n#define minH(a)\tif (a.d < h.d) h = a\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat hex(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.8660254, .5, .57735);\n\tp = abs(p);\n\tp.xy -= 2. * min(dot(k.xy, p.xy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.z - h.y);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat pod(vec3 p, float s) { return hex(p.xzy, vec2(.5 - (p.y > 0. ? p.y * .3 : 0.), 1) * s); }\n\nfloat limb(inout vec3 p, float a1, float a2, float s) {\n\tfloat f, d,\n\t      oy = p.y;\n\tp.yz *= rot(a1);\n\tf = max(max(length(p.zy) - .45, p.x - p.y), -p.x);\n\td = min(cyl(p, vec2(.5, .1)), f);\n\tf = p.y;\n\tp.y = abs(p.y + .7) - .7;\n\td = min(d, length(p) - .35 + .1 * step(oy, -.3));\n\tp.y = f + 1.2;\n\td = min(d, cap(p, 1., .2));\n\tp.y += .2;\n\tp.yz *= rot(a2);\n\tp.y += .1 + s;\n\treturn min(d, pod(p, s));\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit map(vec3 p, bool shield) {\n\tvec3 pp, op,\n\t     rp = p;\n\trp.xz *= rot(S(-1., 1., 1.5 * sin(cos(t * .5))) - .5);\n\tpp = rp;\n\tpp.z += .05;\n\tfloat bd, bdd, eye, mx, lxz, d,\n\t      chin = max(cap(pp, .6, .5), -pp.z - .45);\n\tchin = max(chin, rp.y - .6);\n\tpp.y -= 1.3 + pp.z * .2;\n\tpp.z += 1.1;\n\tbd = max(min(cap(rp, .7, .45), max(chin, -box(pp, vec3(1)))), .15 - rp.y + rp.z * .5);\n\tpp = rp;\n\tpp.x = abs(pp.x) - .2;\n\tpp.yz = rp.yz - vec2(.6, -.4);\n\top = pp;\n\tbd = min(max(bd, .12 - length(pp)), cyl(rp - vec3(0, .7, 0), vec2(.5, .02)));\n\teye = max(length(pp - vec3(0, 0, .1)) - .1, abs(pp.y) - S(1., .8, sin(t * .9)) + .05);\n\tg += 1e-4 / (.001 + eye * eye);\n\tHit orb,\n\t    h = Hit(eye, 3, rp);\n\tmx = abs(p.x);\n\tpp.x = mx - .2;\n\tpp.yz = p.yz - vec2(.6, -.4);\n\tlxz = length(p.xz);\n\td = .25 + .35 * step(p.y, -1.) * mix(.8, 1., sat(2. * abs(sin(p.y * 10.))));\n\tbdd = max(max(lxz - d, p.y - 1.), -p.y - 2.5);\n\td = max(max(max(length(p.xz * vec2(.5, .9)) - (p.y + 6.2) * .12, p.y + 1.), -p.y - 2.), -box(pp + vec3(0, 2.4, 0), vec3(-pp.y * .18, .3, 1)));\n\tbd = min(bd, d);\n\tpp.x -= .4;\n\tpp.y += 1.4;\n\tpp.xz *= rot(.4);\n\tpp.xy *= rot(-.1);\n\tbd = min(bd, .9 * box(pp, vec3(.8, .5 + pp.z * .4, .25)));\n\tpp = p;\n\tpp.x = mx - 1.58;\n\tpp.xy *= rot(.1);\n\tpp.y += .8;\n\tbd = min(bd, limb(pp, -.2, .4, .7));\n\td = box(pp + vec3(-.1, .9, 0), vec3(0, .2, .2));\n\tpp.xy *= rot(-.7 - sin(t) * .025);\n\tbd = min(bd, min(d, box(pp + vec3(-.8, 1, 0), vec3(0, .2, .2))) - .1 + .03 * abs(sin(pp.z * 20.75)));\n\tpp = p;\n\tpp.y += 3.2;\n\tpp.x = floor(mx * 5.) / 5.;\n\tminH(Hit(min(bdd, cap(pp, 1., .3)), 2, p));\n\tbd = min(bd, max(length(pp.zy) - .15, lxz - 1.));\n\tpp.x = mx - 1.;\n\tbd = min(bd, limb(pp, .2, -.2, 1.));\n\tpp.y += 1.4;\n\tbd = min(bd, max(max(hex(pp, vec2(.4, 1.2)), -pp.y), pp.z - .3));\n\tminH(Hit(bd, 1, p));\n\top = p - vec3(10, -7, 30);\n\torb = Hit(length(op) - 25., 0, op);\n\tg += .01 / (orb.d * orb.d * .1 + 1.);\n\tif (shield) minH(orb);\n\tpp = p - vec3(p.y + 74.875 + sin(p.y * 15.) * .05, n21(pp.xy * .5) * .2, -11.22);\n\td = n21(pp.xz * .2);\n\tminH(Hit(pp.y - 2. * pow(d, 10.) + 7.1, 4, vec3(pp.xz, d)));\n\top.xz *= rot(1.);\n\tp = op;\n\top.xz = abs(op.xz) - 8.;\n\tpp = op;\n\top.xz *= rot(op.y / 12.7348);\n\td = 4. - 2.8 * pow(sin(.5 * pow(op.y * .39, .65) + .2), 1.8);\n\td = min(max(box(op, vec3(d, 20, d)) - .1, box(pp, vec3(3.25, 20, 3.25))), box(p, vec3(12, .3, 12)) - .2);\n\tminH(Hit(d, 5, op));\n\td = cyl(p.yxz, vec2(.7 - p.y * 0.12, 4.0)) - .5;\n\tminH(Hit(d, 2, op));\n\tp.y -= 5.;\n\torb = Hit(length(p) - .7 + n31(p * 3. + t) * .4, 0, op);\n\tg += .01 / (orb.d * orb.d * .1 + 1.);\n\tminH(orb);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h, false).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\tfloat i, h,\n\t      s = 1.,\n\t      t = .1;\n\tfor (i = Z0; i < 20.; i++) {\n\t\th = map(t * ld + p, false).d;\n\t\ts = min(s, 30. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 20.) break;\n\t}\n\n\treturn sat(s);\n}\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tif (h.id == 3) return vec3(1);\n\tvec3 n, c,\n\t     ld = normalize(vec3(2, 20, 15) - p);\n\tif (h.id == 0) {\n\t\tn = normalize(h.uv);\n\t\tfloat ns,\n\t\t      f = sat(.2 + .8 * dot(ld * vec3(-1, 1, 1), n));\n\t\tvec2 k = (n.xy * rot(t * .1) - vec2(.3, .1)) * rot(t * -.3) + vec2(.1, .2);\n\t\tfor (float i = 0.; i < 2.; i++) {\n\t\t\tfloat l = length(k + i * .1);\n\t\t\tf += (.4 + .2 * sin(l * 60. - t * 2.)) * (.003 + S(.5, 0., l) * S(0., .5, l));\n\t\t\tt += 32.;\n\t\t}\n\n\t\tns = n31(n * 19. + vec3(0, 0, t * 2.)) * .7 + n31(n * 39. + vec3(0, t * 2., 0)) * .3;\n\t\tf *= .5 + .5 * S(.2, .8, ns);\n\t\treturn vec3(1, 1.1, 1.7) * f;\n\t}\n\n\tn = N(p, d);\n\tif (h.id == 1) c = vec3(.2);\n\telse if (h.id == 2) c = vec3(.01);\n\telse if (h.id == 4) {\n\t\tc = vec3(.55);\n\t\tn.xz += 4. * (h.uv.z * .5 + n21(p.xz) * .125 - .5 + (n21(p.xz * 2.) + n21(p.zx * 32.1)) * .05);\n\t\tn = normalize(n);\n\t}\n\telse if (h.id == 5) c = mix(vec3(-.05), vec3(2. * pow(sat(sin(t + p.y * .2)), 10.), 0, 0), step(.8, fract(p.y)) * step(-7., p.y));\n\n\tfloat gg = g,\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (.2 + .8 * shadow(p, ld)),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3 + pow(sat(dot(rd, reflect(ld, n))), 10.),\n\t      fre = 1. - S(.7, 1., 1. + dot(rd, n)) * .5;\n\tg = gg;\n\treturn (l1 + l2) * fre * c * vec3(.4, .32, .3);\n}\n\nvec3 sky(vec3 rd) {\n\tfloat f = pow(1. - sat(rd.y / .5), 3.);\n\treturn vec3(.16, .18, .24) * f + vec3((1. - f) * S(-.2, -.7, rd.x) * step(.96, n31(rd * 2e2)) * .5 * (.01 + .99 * n31(rd * 40. - t * .5)));\n}\n\nvec3 march(inout vec3 p, vec3 rd) {\n\tfloat i,\n\t      d = .01;\n\tbool addOrb = true;\n\tHit h, orb;\n\tvec3 orbP, c;\n\tg = 0.;\n\tfor (i = Z0; i < 128.; i++) {\n\t\th = map(p, addOrb);\n\t\tif (abs(h.d) < .0015) {\n\t\t\tif (h.id == 0) {\n\t\t\t\torb = h;\n\t\t\t\torbP = p;\n\t\t\t\taddOrb = false;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\td += h.d;\n\t\tif (d > 64.) break;\n\t\tp += h.d * rd;\n\t}\n\n\tc = (d < 64. ? lights(p, rd, d, h) : sky(rd)) + g;\n\tif (!addOrb) c += lights(orbP, rd, d, orb);\n\treturn c;\n}\n\n#define R\tiResolution\n\nvec3 render(vec3 ro, vec3 rd) {\n\tt = mod(iTime, 30.);\n\treturn pow(max(vec3(0), march(ro, rd)), vec3(.45)) * sat(iTime);\n}\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\trd.xz *= rot(-1.57);\n\tfragColor = vec4(render(vec3(-2, -4, -5), rd), 0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tif (abs(uv.y) > .4) {\n\t\tfragColor = vec4(0);\n\t\treturn;\n\t}\n\n\tt = mod(iTime, 30.);\n\tfloat p = S(1., 15., t);\n\tvec3 lookAt = vec3(3, -3, 0) * p,\n\t     ro = mix(vec3(0, 0, -5), vec3(6, -5, -11), p);\n\tfragColor = vec4(vig(render(ro, rayDir(ro, lookAt, uv)), fc), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSDS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1456, 1456, 1475, 1475, 1720], [1722, 1722, 1741, 1741, 1767], [1807, 1807, 1826, 1826, 1893], [1895, 1895, 1922, 1922, 2188], [2190, 2190, 2217, 2217, 2304], [2306, 2306, 2334, 2334, 2434], [2436, 2436, 2473, 2473, 2525], [2527, 2527, 2555, 2555, 2622], [2624, 2624, 2679, 2679, 3022], [3024, 3024, 3068, 3068, 3204], [3206, 3206, 3236, 3236, 5776], [5778, 5778, 5803, 5803, 6029], [6031, 6031, 6062, 6062, 6260], [6262, 6262, 6289, 6289, 6404], [6406, 6406, 6452, 6452, 7721], [7723, 7723, 7742, 7742, 7926], [7928, 7928, 7963, 7963, 8383], [8408, 8408, 8439, 8439, 8529], [8531, 8531, 8591, 8591, 8667], [8669, 8669, 8714, 8714, 9014]], "test": "valid"}
{"id": "sllSWX", "name": "Domain expansion:Unlimited Void ", "author": "yasuo", "description": "jujutsu kaisen", "tags": ["cubemap", "reproduction"], "likes": 2, "viewed": 149, "published": "Public API", "date": "1626716365", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define USE_MOUSE 0\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise2d( in vec2 p ){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    \n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\nfloat fbm(vec2 uv){\n    float f;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2d( uv ); uv = m*uv;\n    f += 0.2500*noise2d( uv ); uv = m*uv;\n    f += 0.1250*noise2d( uv ); uv = m*uv;\n    f += 0.0625*noise2d( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n    return f;\n}\n\nvec3 tex(in vec2 p)\n{\n    vec2 prevP = p;\n    p+=iTime*0.15;\n    \n    float n = fbm(p*2.7)*0.6;\n    vec3 col = vec3(0.0,0.0,0.2)+n*0.7;\n    \n    p = prevP;\n    float d = length(p)-0.35;\n    \n    d = length(p)-0.35;\n    col = mix(col,vec3(1.2),S(abs(d*(n*3.0))-0.15,-0.3));\n    \n    d = length(p)-0.35;\n    col = mix(col,vec3(0.7),S(abs(d)-0.07,-0.2));\n    \n    p = prevP;\n    p.y=-abs(p.y);\n    col = mix(col,vec3(1,0.9,0.6),S(abs(d)-0.01+sin(p.y*3.0)*0.02,-0.05));\n    \n    p = prevP;\n    p*=Rot(radians(iTime*30.0));\n    p.y=abs(p.y);\n    col = mix(col,vec3(1),S(abs(d)-0.005+sin(p.y*3.0)*0.005,-0.005));\n    \n    p = prevP;\n    p*=Rot(radians(iTime*25.0));\n    p.x+=iTime*0.1;\n    float n2 = fbm(p*4.0)*0.15;\n    p = prevP;\n    d = length(p)-0.16;\n    col = mix(col,vec3(1.0),S(d*n2*0.3,0.0));\n    \n    p = prevP;\n    d = length(p)-0.15;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    p+=iTime*0.1;\n    \n    float n1 = noise2d(p*0.6)+fbm(p*5.5);\n    col = mix(col,col*vec3(2.7),S(n1,0.0));\n    col = mix(col,col*vec3(1.5),S(abs(n1)-0.01,0.0));\n    p-=vec2(0.8);\n    n1 = noise2d(p*0.7)+fbm(p*7.5);\n    col = mix(col,col*vec3(2.85),S(n1,0.0));\n    col = mix(col,col*vec3(1.5),S(abs(n1)-0.01,0.0));\n    p+=vec2(2.8);\n    n1 = noise2d(p*0.8)+fbm(p*9.5);\n    col = mix(col,col*vec3(2.675),S(n1,0.0));\n    col = mix(col,col*vec3(1.5),S(abs(n1)-0.01,0.0));\n    \n    p = prevP;\n    p*=20.0;\n    vec2 grid = abs(fract(p - 0.5) - 0.5) / fwidth(p);\n    float line = min(grid.x, grid.y);\n    float gridd = 1.0 - min(line, 1.0);\n    col = mix(col,col*vec3(0.675),S(gridd,0.0));\n\n    return col;\n}\n\n// cube mapping technique from @nimitz https://www.shadertoy.com/view/4sjXW1\nvec3 cubeproj(in vec3 p)\n{\n    vec3 x = tex(p.zy/p.x);\n    vec3 y = tex(p.xz/p.y);\n    vec3 z = tex(p.xy/p.z);\n    \n    //select face\n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return x;\n    else if (p.y > p.x && p.y > p.z) return y;\n    else return z;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \n    vec3 ro = vec3(0, 0, -1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(sin(-iTime*.2)*0.3);\n    ro.xz *= Rot(-iTime*.3+1.0);\n    #endif\n   \n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.0);\n    vec3 col = cubeproj(rd);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 328, 348, 348, 482], [483, 483, 510, 510, 1013], [1014, 1014, 1033, 1033, 1295], [1297, 1297, 1318, 1318, 2905], [2907, 2984, 3010, 3010, 3243], [3245, 3245, 3287, 3287, 3482], [3484, 3484, 3541, 3541, 3967]], "test": "valid"}
{"id": "sllSzB", "name": "Fork Fork psych toby80 785", "author": "toby80", "description": "Another play on IQ's tunnel", "tags": ["tunnel"], "likes": 1, "viewed": 145, "published": "Public API", "date": "1625998815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"psychedelic tunnel\" by None. https://shadertoy.com/view/-1\n// 2021-07-11 09:06:41\n\n// Fork of \"psychedelic tunnel\" by None. https://shadertoy.com/view/-1\n// 2021-07-11 08:51:50\n\n// Fork of \"psychedelic tunnel\" by StanRee. https://shadertoy.com/view/4lX3W7\n// 2021-07-11 07:56:38\n\n\n// Deform - square tunnel : REDUX\n// Modifications by Stanley Hayes\n// Original Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Hsv conversion from http://ploobs.com.br/?p=1499\n\nvec3 Hue(float a){\nvec3 K = vec3(3,2,1)/3.;\nreturn clamp(abs(fract(vec3(a)+K)*6. - vec3(3.)) - K.xxx, 0., 1.);\n}\n\n\n#define Time (iTime * .06) \n\nvec3 HSVtoRGB(vec3 HSV)\n{\n    return vec3(((Hue(HSV.x) - 1.0) * HSV.y + 1.0) * HSV.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized coordinates (-1 to 1 vertically)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    // angle of each pixel to the center of the screen\n    \n    \n    // modified distance metric. Usually distance = (xÃÂ² + yÃÂ²)^(1/2). By replacing all the \"2\" numbers\n    // by 32 in that formula we can create distance metrics other than the euclidean. The higher the\n    // exponent, then more square the metric becomes. More information here:\n    \n    // http://en.wikipedia.org/wiki/Minkowski_distance\n    \n    float exp = 1.0;\n    float crayStationsCoef = 1.01; \n    p.x +=  sin(pow(Time,.5))*crayStationsCoef*2.0;\n   //p.y +=  cos(Time)*crayStationsCoef*10.0;\n    float a = atan(p.y,p.x) + Time * sin(Time)*.002 + iMouse.x * .0001;\n    float r = pow( pow(p.x*p.x,exp) + pow(p.y*p.y,exp), 1.0/(exp * 2.0) ) + sin(Time)*crayStationsCoef;\n    a += pow(r,.50); \n    \n       \n    // index texture by angle and radious, and animate along radius    \n    vec2 uv = vec2( 0.5/r + 0.5*Time + iMouse.y,                    a/3.1416 );\n\n    r -= sin(Time)*.05;\n    // fecth color and darken in the center\n    vec3 col =  texture( iChannel0, uv ).xyz * r;\n    col = HSVtoRGB(vec3(col.r, 1.0, 1.0)); \n\t\n    col.r *= (sin(uv.x*5.0)*.7 + 1.0) * .9;\n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSzB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[547, 547, 565, 565, 659], [691, 691, 716, 716, 779], [782, 782, 839, 890, 2140]], "test": "error"}
{"id": "sllXDf", "name": "Snowfall through terrain", "author": "Azorlogh", "description": "Fun little valley :)\nThe rendering is done with layers and parallax.\n\nFalling snowflakes by Emil: https://www.shadertoy.com/view/Mdt3Df", "tags": ["snow", "layers", "valley"], "likes": 1, "viewed": 74, "published": "Public", "date": "1626781894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////-- CONFIGURATION --//////\n\nconst vec3 nord0 = vec3(46, 52, 64)/255.0;\nconst vec3 nord1 = vec3(59, 66, 82)/255.0;\nconst vec3 nord2 = vec3(67, 76, 94)/255.0;\nconst vec3 nord3 = vec3(76, 86, 106)/255.0;\nconst vec3 nord4 = vec3(216, 222, 233)/255.0;\nconst vec3 nord5 = vec3(229, 233, 240)/255.0;\nconst vec3 nord6 = vec3(236, 239, 244)/255.0;\n\nconst float SPEED = 0.5;\nconst float WIND = 3.0;\nconst float MAX_DEPTH = 2.0;\nconst float DEPTH_STEP = 0.2;\nconst float TIME_OFFSET = 0.0;\n\n//////-- END OF CONFIGURATION --//////\n\nconst float TAU = 6.2831853071796;\n\nfloat hash(vec2 co) {\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    float va = hash( i + vec2(0.0,0.0) );\n    float vb = hash( i + vec2(1.0,0.0) );\n    float vc = hash( i + vec2(0.0,1.0) );\n    float vd = hash( i + vec2(1.0,1.0) );\n    \n    float k0 = va;\n    float k1 = vb - va;\n    float k2 = vc - va;\n    float k4 = va - vb - vc + vd;\n\n    return va+(vb-va)*u.x+(vc-va)*u.y+(va-vb-vc+vd)*u.x*u.y;\n}\n\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    float va = hash( i + vec2(0.0,0.0) );\n    float vb = hash( i + vec2(1.0,0.0) );\n    float vc = hash( i + vec2(0.0,1.0) );\n    float vd = hash( i + vec2(1.0,1.0) );\n    \n    float k0 = va;\n    float k1 = vb - va;\n    float k2 = vc - va;\n    float k4 = va - vb - vc + vd;\n\n    return vec3( va+(vb-va)*u.x+(vc-va)*u.y+(va-vb-vc+vd)*u.x*u.y, // value\n                 du*(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va) );     // derivative                \n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// credit: Emil https://www.shadertoy.com/view/Mdt3Df                          //\nfloat snow(vec2 coord, float depth, float time, float speed) {\n    float snow = 0.0;\n    float gradient = (1.0-float(coord.y / iResolution.x))*0.4;\n    float random = fract(sin(dot(coord.xy,vec2(12.9898,78.233)))* 43758.5453);\n    for(int k=0;k<6;k++){\n        for(int i=0;i<20 && i<int(depth*4.0);i++){\n            float cellSize = 2.0 + (float(i)*3.0);\n\t\t\tfloat downSpeed = 0.3+(sin(time*0.4+float(k+i*20))+1.0)*0.00008;\n            vec2 uv = (coord.xy / iResolution.x)+vec2(0.01*sin((time+float(k*6185))*0.6+float(i))*(5.0/float(i))+time*speed*0.3,downSpeed*(time+float(k*1352))*(1.0/float(i)));\n            vec2 uvStep = (ceil((uv)*cellSize-vec2(0.5,0.5))/cellSize);\n            float x = fract(sin(dot(uvStep.xy,vec2(12.9898+float(k)*12.0,78.233+float(k)*315.156)))* 43758.5453+float(k)*12.0)-0.5;\n            float y = fract(sin(dot(uvStep.xy,vec2(62.2364+float(k)*23.0,94.674+float(k)*95.0)))* 62159.8432+float(k)*12.0)-0.5;\n            float randomMagnitude1 = sin(time*2.5)*0.7/cellSize;\n            float randomMagnitude2 = cos(time*2.5)*0.7/cellSize;\n            float d = 5.0*distance((uvStep.xy + vec2(x*sin(y),y)*randomMagnitude1 + vec2(y,x)*randomMagnitude2),uv.xy);\n            float omiVal = fract(sin(dot(uvStep.xy,vec2(32.4691,94.615)))* 31572.1684);\n            if(omiVal<0.08?true:false){\n                float newd = (x+1.0)*0.4*clamp(1.2-d*(15.0+(x*6.3))*(cellSize/1.4),0.0,1.0);\n                snow += newd / float(i)*4.0;\n            }\n        }\n    }\n\n    return snow*noise(coord/iResolution.y*10.0 + iTime);\n}                                                                              //\n/////////////////////////////////////////////////////////////////////////////////\n\nconst int OCTAVES = 9;\n\nvoid fbmd(in vec2 st, float h, float dist, out float value, out vec2 grad) {\n    const float gain = 0.5;\n    const float gaind = 0.4;\n    const float lacunarity = 2.0;\n    float scale = (1.0-pow(gain, float(OCTAVES)))/(1.0-gain);\n    float scaled = (1.0-gaind)/(1.0-pow(gaind, float(OCTAVES)));\n    value = 0.0;\n    grad = vec2(0);\n    float amplitude = 1.0;\n    float amplituded = 1.0;\n    float frequency = 1.;\n    float remaining_amp = scale;\n    for (int i = 0; i < OCTAVES+int(log2(1.0/dist)); i++) {\n        vec3 n = noised(st * frequency + vec2(i));\n        value += amplitude * n.r;\n        grad += amplituded * frequency * n.gb;\n        remaining_amp -= amplitude;\n        if (h > value + remaining_amp) {\n            value = 0.0;\n            return;\n        }\n        frequency *= lacunarity;\n        amplitude *= gain;\n        amplituded *= gaind;\n    }\n    value /= scale;\n    grad *= scaled;\n}\n\nvoid terraind(vec2 pos, float h, float dist, out float value, out vec2 grad) {\n    const float a = 0.2;\n    const float b = 0.05;\n    float c = -0.5-0.5*pos.y*b + pos.y*a + a*b*pos.y*pos.y;\n    float d = (1.0+pos.y*b);\n    fbmd(pos*0.4, (h-c)/d, dist, value, grad); // [0; 1]\n    value = d*value + c;\n    grad *= 0.4;\n    grad.x = (b*pos.y + 1.0)*grad.x;\n    grad.y = (b*pos.y + 1.0)*grad.y + b*value + 2.0*a*b*pos.y + a - 0.5*b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = (fragCoord.xy - iResolution.xy/2.0) / (iResolution.y/2.0);\n\n    pos.y -= 0.5;\n\n    float depth = 1000.0;\n\n    float time = (iTime+TIME_OFFSET)*SPEED;\n    float terr;\n    vec2 grad;\n    int iter = 0;\n\n    vec3 col = mix(nord6, nord6, smoothstep(-0.5, 1.0, pos.y));\n    for (float z=0.0; z<=MAX_DEPTH; z+=DEPTH_STEP) {\n        vec2 p = vec2(pos.x + time/(1.0+z), z)*(1.0+z);\n        terraind(p, pos.y+1.2, 1.0+z, terr, grad);\n        if (pos.y+1.2 < terr) {\n            float terrtrue;\n            terraind(p+vec2(0, (pos.y+1.0)-terr)*(1.0+z), -10.0, 1.0+z, terrtrue, grad);\n            float flatness = smoothstep(0.6, 0.5, length(grad));\n            vec3 ground = mix(nord3, nord6, flatness*0.7);\n\n            #if defined(AMBIENT_OCCLUSION) || defined(SHADING)\n            vec3 normal = normalize(-vec3(grad.x, -1.0, grad.y));\n            #endif\n\n            #ifdef AMBIENT_OCCLUSION\n            float ao = 1.0/abs(terraind(p+normal.xz).r-(terr+normal.y));\n            ground *= clamp(1.0 - ao*0.2 + 0.15, 0.0, 1.0);\n            #endif\n            #ifdef SHADING\n            ground *= max(0.0, min(1.0, 0.3+max(0.0, dot(normalize(vec3(-1, 1.5, 0.5)), normal))));\n            #endif\n            col = mix(ground, col, min(z/MAX_DEPTH*0.95, 1.0));\n            //col = ground;\n            // col = mix(ground, col, min((z*z)/MAX_DEPTH*0.6, 1.0));\n            //col = normal;\n            depth = 1.0 + z*2.5;\n            break;\n        }\n    }\n\n    col = mix(col, nord6, noise(pos+vec2(time*SPEED*WIND, 0))*0.4);\n\n    float snow = snow(gl_FragCoord.xy, depth, time/SPEED, SPEED*WIND)*10.0;\n    col = mix(col, nord6, min(1.0, snow));\n    col += snow*(pos.y+1.0)*0.1;\n\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[561, 561, 582, 582, 651], [653, 653, 679, 679, 1119], [1121, 1121, 1147, 1147, 1736], [3627, 3627, 3703, 3703, 4533], [4535, 4535, 4613, 4613, 4966], [4968, 4968, 5025, 5025, 6732]], "test": "valid"}
{"id": "sllXDj", "name": "melon blobz", "author": "zevanrosser", "description": "some blobs", "tags": ["cineshader"], "likes": 3, "viewed": 838, "published": "Public API", "date": "1626619962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM 8 \n        \n  float rand(vec2 co){ \n    return fract(sin(dot(co.xy, vec2(12.9891,78.233))) * 43754.6453);\n  }\n\n  float ting(float i, vec2 uv, vec2 loc){\n    return smoothstep(0.1, 0.7 + i / 20.0, 1. - atan(distance(uv, loc + vec2(0.2, 0.0))) * 3.);\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv.y /= iResolution.x / iResolution.y;\n\n    uv.y -= max(0.0,(iResolution.y - iResolution.x) / iResolution.y);\n\n    float cl = 0.0;\n    float dl = 0.0;\n    float v = 2. - smoothstep(0.0, 1.0, 1.0 - (distance(uv, vec2(0.5, 0.5)))) * 2.;\n\n    float t = cos(iTime);\n\n    for (int i = 0; i < NUM; i++){\n      float fi = float(i);\n      float ty = rand(vec2(fi, 0.9));\n      float tx = 0.1 * fi - 0.1 + 0.03 * cos(iTime + fi);\n      float tcos = cos(iTime * float(i - NUM / 2) * 0.3);\n      float tin = ting(fi * 1.2 * tcos, uv, vec2(tx, ty));\n\n      if (tin > cl) {\n        cl += smoothstep(cl, 1.2, tin);\n      }\n\n      tin = ting(fi * 1.1 * tcos, uv, vec2(tx + 0.01, ty + 0.01));\n\n      if (tin > dl) {\n        dl += smoothstep(dl, 1.1, tin);\n      }\n    }\n\n\n    cl = sin(acos(cl - 0.2));\n    dl = sin(acos(dl - 0.2));\n\n    float j = sin(5.0 * smoothstep(0.3, 1.2, dl));\n\n    cl = max(cl , j * 1.2);\n    cl += rand(fragCoord.xy + iTime) * 0.14;\n    cl -= v * 0.6;\n\n    fragColor = vec4(cl * 1.44, (cl + dl) / 2.3, cl * 0.9, 1.0);\n  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 46, 46, 121], [125, 125, 164, 164, 264], [268, 268, 325, 325, 1406]], "test": "valid"}
{"id": "sllXRM", "name": "A few colors", "author": "schobbejack", "description": "modulating chroma plane", "tags": ["rgb", "ycbcr"], "likes": 7, "viewed": 81, "published": "Public", "date": "1625384769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 to_rgb(vec3 ycbcr)\n{\n    // full range bt709 matrix\n    const mat3 c709=mat3(1.0000000000, 1.0000000000, 1.0000000000,\n                      0.0000000000, -0.1873242729, 1.8556000000,\n                      1.5748000000, -0.4681242729, 0.0000000000);\n    return c709 * ycbcr;\n}\n\nconst float pi = acos(-1.);\n\nvec2 rot(vec2 uv, float r)\n{\n    float s=sin(r);\n    float c=cos(r);\n    \n    return vec2(uv.x*c-uv.y*s,uv.x*s+uv.y*c);\n}\n\nvec2 vsphere(float x)\n{\n    return vec2(sin(x*pi),cos(x*pi));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    uv=rot(uv,iTime*pi*.5);\n    float inv = 1./length(uv);\n    uv*=inv;    \n    \n    vec2 cbcr=vsphere(uv.x+iTime)*sin(iTime*.5)*.5;\n\n    vec3 col = to_rgb(vec3(inv*.3,cbcr))*inv*.5;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 56, 281], [312, 312, 340, 340, 433], [435, 435, 458, 458, 498], [500, 500, 557, 557, 837]], "test": "error"}
{"id": "sllXRN", "name": "Dancing Julia Spheres", "author": "golinad", "description": "Animated Juliaset rendered using min distance to origin.", "tags": ["fractal"], "likes": 2, "viewed": 147, "published": "Public API", "date": "1625922787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Click in image to change pattern.\n*/\n#define SPHERES\n\nconst int maxIt = 16;\n \nvec2 cSqr(vec2 c){\n    return vec2(c.x*c.x - c.y*c.y, 2.0*c.x*c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y*4.0;\n    int it = 0;\n    vec2 z = uv;\n    vec2 c = (iMouse.xy-iResolution.xy*0.5)/iResolution.y*4.0;\n    float minD = length(z);\n    c = vec2(sin(iTime), cos(iTime))*(length(c)+abs(sin(iTime*3.14)*0.25));\n    for(int i=0; i< maxIt;i++){\n        z = cSqr(z) + c;\n        if(length(z) > 50.0) break;\n        it++;\n        minD = min(length(z), minD);\n    }\n    // Time varying pixel color\n#ifdef SPHERES\n    vec3 col = 1.0-vec3(1,iMouse.x/iResolution.x,iMouse.y/iResolution.y)*minD;\n#else\n    vec3 col = vec3(1.0)*float(it)/float(maxIt);\n#endif\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 103, 103, 154], [156, 156, 213, 263, 922]], "test": "valid"}
{"id": "sllXWl", "name": "rainbow wave sine", "author": "mikeken", "description": "learn", "tags": ["wave"], "likes": 0, "viewed": 26, "published": "Public", "date": "1626935041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 uv = fragCoord / iResolution.xy;\n\t\n    float amplitude = 0.05;\n    \n    float angularVelocity = 10.0;\n    \n    float frequency = 10.0;\n    \n    float offset = 0.5;\n    \n    // y = Asin(Ïx Â± Ï) + k\n    float y = amplitude * sin((angularVelocity * uv.x) + (frequency * iTime)) + offset;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec4 color = uv.y > y ? vec4(0.0, 0.0, 0.0, 1.0) : vec4(col,1.0);\n\t\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 555]], "test": "valid"}
{"id": "sllXzH", "name": "Maxnorm Distance to Parabola", "author": "oneshade", "description": "Maxnorm distance to a parabola.", "tags": ["2d", "sdf", "distance", "parabola", "maxnorm", "linf"], "likes": 4, "viewed": 66, "published": "Public", "date": "1625178388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdParabola(in vec2 p, in float h) {\n    float x = sqrt(0.25 + max(0.0, abs(p.x * h) + p.y * h)) - 0.5;\n    return (x * x / h - p.y) * sign(h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 0.5;\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.5, 0.5 * sin(time)) * cos(time);\n\n    float a = sin(0.25 * iTime) * 16.0;\n    float b = cos(0.25 * iTime);\n    float c = 0.25 * sin(0.5 * iTime);\n    vec2 vertex =  vec2(-0.5 * b / a, c - 0.25 * b * b / a);\n\n    float d = sdParabola(uv - vertex, a);\n    d *= 2.0; // Shrink isolines\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    float mDist = abs(sdParabola(mouse - vertex, a));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - mouse) - 0.008));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(max(abs(uv.x - mouse.x), abs(uv.y - mouse.y)) - mDist) - 0.001));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 150], [152, 152, 207, 226, 1367]], "test": "valid"}
{"id": "sllXzs", "name": "Capped Cylinder - Closest 3D Y28", "author": "Yusef28", "description": "Following Iq's trend. This is forked from a fork of one of his submissions.\nI've commented my thought process.", "tags": ["3d", "sdf", "cylinder", "capped", "closest"], "likes": 3, "viewed": 46, "published": "Public", "date": "1626560765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a sphere. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\nvec3 closestPointToCyl( vec3 p, vec3 cen, float h)\n{\n    //For sphere we get the normalized vector\n    //from center to point, scale it by radius and add that vector\n    //to center\n    //return cen + rad*normalize(p-cen);\n   \n    //So for cyl we can do the same thing but with one less dimention\n    //Since a cylinder is an extruded circle, whereever we end up \n    //on the missing axis with our p point, we can use that same value\n    //for the missing axis for our center\n    //otherwise it's the same\n    //here cen.z is radius\n    \n    //If it's capped though then we just need to make sure to take the min\n    //of the capped axis height and that component of the point vector.\n\n    //ALSO we need to make sure we have access to all points within the\n    //radiu not just on the surface\n    \n    //the min here makes sure we get all points withint the radius of xy\n    //the sign ajusts for using abs, and I used abs so we could get \"Min\"\n    //in the first place,otherwise min woudl be all the negative xy points\n    //and that would suck\n    vec2 xy = min(abs(cen.xy + cen.z*normalize(p.xy-cen.xy)),\n            abs(p.xy))*sign(p.xy);\n            \n    //this is the z portion (the capped axis)\n    //abs p.z is length of that component\n    //I clip when it's greater than the defined height \"h\"\n    //then I use sign so we have both sides.\n    float z = min(abs(p.z),h)*sign(p.z);\n    return vec3(xy,z);\n    //then we have\n    \n    }\n    \n\n//------------------------------------------------------------\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, vec3 cen, float rad)\n{\n    \n\n    return length(p-cen)-rad;\n    \n}\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec3 cen, float h)\n{\n    //I've reduced the Cylinder to this\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(cen.z,h);\n   // return length(max(d,0.));\n    \n    // and it can be expaned to\n    float dx = length(p.xy) - cen.z;\n    float dy = abs(p.z)  - h;\n    return min(max(dx,dy),0.0) + length(max(vec2(dx,dy),0.));\n    \n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n//------------------------------------------------------------\n\nvec3 gPoint;\n\nvec2 map( in vec3 pos, bool showCylinder )\n{\n    const float rad = 0.9;\n\n    // compute closest point to gPoint on the surace of the sphere\n    vec3 closestPoint = closestPointToCyl(gPoint, vec3(0.0,0.,0.4),0.5);\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    //if( ((samp.x+samp.y)&1)==0 )\n    \n    if( showCylinder )\n    {\n    float d = sdCylinder( pos, vec3(0.,0.,0.4),0.5);\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in bool showSphere )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSphere ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSphere ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSphere ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSphere ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow(vec3 ro, vec3 rd, bool showSphere )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSphere).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - (1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // make sphere transparent\n        bool showCylinder = (texelFetch(iChannel0,samp&7,0).x>0.25);\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        gPoint = vec3(sin(iTime),sin(iTime*8.)*.2,sin(iTime+2.));\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showCylinder);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showCylinder);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(1.9,1.5,.5)*2. );\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showCylinder);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXzs.jpg", "access": "shaders20k", "license": "mit", "functions": [[1209, 1209, 1261, 2256, 2652], [2659, 2793, 2839, 2839, 2882], [2883, 2954, 3000, 3040, 3303], [3305, 3376, 3428, 3428, 3542], [3622, 3622, 3666, 3666, 4401], [4403, 4467, 4519, 4519, 4814], [4816, 4878, 4936, 4936, 5308]], "test": "error"}
{"id": "slsSDM", "name": "Ð§ÐµÐ±ÑÑÐµÐ»Ð»Ð¾ ÑÐ½Ð¾Ð²Ð° Ð² Ð±Ð¾Ñ !!!", "author": "shkolota", "description": "Ð¨ÐºÐ¾Ð»Ð¾ÑÐ° + ÑÐµÐ±ÑÑÐµÐ»Ñ = Ð·Ð°Ð´Ð¾Ð»Ð±Ð°Ð»Ð¸ ! ", "tags": ["dancing", "cheburello"], "likes": 3, "viewed": 45, "published": "Public", "date": "1625843975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ð¾ÑÑÐµÐ½ÐºÐ¸ Ð·Ð°Ð»Ð¸Ð²ÐºÐ¸\nvec3 brown1 () { return vec3(0.3961, 0.2627, 0.1294);}\nvec3 brown2 () { return vec3(0.495, 0.37, 0.22);}\nvec3 brown3 () { return vec3(0.3, 0.2, 0.1);}\nvec3 white () {return vec3(0.9, 0.9, 0.7);}\nvec3 black () {return vec3(0.0, 0.0, 0.0);}\nvec3 red () {return vec3(0.590, 0.117, 0.106);}\n\n// ÑÑÐ½ÐºÑÐ¸Ñ, Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÑÑÐ°Ñ ÐºÐ²Ð°Ð´ÑÐ°Ñ ÑÐ¸ÑÐ»Ð°\nfloat sq(float x) {return x*x;}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = 1.0 - 2.0 * fragCoord.xy/iResolution.xy;\n     float x = p.x;\n     float y = p.y+0.1*sin(iTime*9.); \n    \n    vec3 col = vec3(.3, .5, .7);\n    \n    // Ð³Ð¾Ð»Ð¾Ð²Ð°, Ð¾ÑÐ½Ð¾Ð²Ð½Ð°Ñ ÑÐ°ÑÑÑ\n    if (sq(x + 0.0) + 1.75*sq(y + 0.2) < 0.075) col=brown1();   \n    // ÑÑÐºÐ¸, Ð¾ÑÐ½Ð¾Ð²Ð½Ð°Ñ ÑÐ°ÑÑÑ\n    if (sq(x + 0.02*sin(iTime*8.)+0.325) + sq(y+0.05*cos(iTime*8.) + 0.225) < 0.025) col=brown1();\n    if (sq(x -0.02*cos(iTime*8.) -0.325) + sq(y+0.05*sin(iTime*8.) + 0.225) < 0.025) col=brown1();  \n    // ÑÐµÐ»Ð¾, Ð¾ÑÐ½Ð¾Ð²Ð½Ð°Ñ ÑÐ°ÑÑÑ \n    if (1.65*sq(x + 0.0) + sq(y - 0.23) < 0.08) col=brown1();\n    // Ð½Ð¾Ð¶ÐºÐ¸ Ð¾ÑÐ½Ð¾Ð²Ð½Ð°Ñ ÑÐ°ÑÑÑ    \n    if (sq(x + 0.17+0.03*sin(iTime*8.)) + 1.77*sq(y - 0.46+.1*sin(iTime*10.)) < 0.0145) col=brown1();\n    if (sq(x - 0.17-0.03*cos(iTime*8.)) + 1.77*sq(y - 0.46+.1*cos(iTime*10.)) < 0.0145) col=brown1(); \n    // ÑÑÑÐºÐ¸ \n    if (sq(x + 0.2+0.05*sin(iTime*9.)) + 1.75*sq(y - 0.1) < 0.014) col=brown1();\n    if (sq(x - 0.2-0.05*sin(iTime*7.)) + 1.75*sq(y - 0.1) < 0.014) col=brown1(); \n     // Ð³Ð¾Ð»Ð¾Ð²Ð°, ÑÐ²ÐµÑÐ»Ð°Ñ ÑÐ°ÑÑÑ\n     if (sq(x + 0.0) + 1.75*sq(y + 0.18) < 0.04) col=brown2();\n     // ÑÐµÐ»Ð¾, ÑÐ²ÐµÑÐ»Ð°Ñ ÑÐ°ÑÑÑ\n     if (1.1*sq(x + 0.0) + sq(y+0.03*sin(iTime*9.) - 0.1745) < 0.015) col=brown2();\n     // Ð½Ð¾Ð¶ÐºÐ¸ ÑÐ²ÐµÑÐ»Ð°Ñ ÑÐ°ÑÑÑ\n     if (sq(x+0.03*sin(iTime*8.) + 0.19) + 1.77*sq(y - 0.461+.1*sin(iTime*10.)) < 0.0045) col=brown2();\n     if (sq(x-0.03*cos(iTime*8.) - 0.19) + 1.77*sq(y - 0.461+.1*cos(iTime*10.)) < 0.0045) col=brown2();   \n     // ÑÑÐºÐ¸, ÑÑÐ¼Ð½Ð°Ñ ÑÐ°ÑÑÑ\n     if (sq(x+0.02*sin(iTime*8.) + 0.325) + sq(y +0.02*cos(iTime*8.)+ 0.225) < 0.0125) col=brown3();\n     if (sq(x-0.02*cos(iTime*8.) - 0.325) + sq(y +0.02*sin(iTime*8.)+ 0.225) < 0.0125) col=brown3();    \n      // Ð³Ð»Ð°Ð·Ð°, Ð±ÐµÐ»ÐºÐ¸ \n      if (sq(x + 0.1) + sq(y + 0.2) < 0.00125) col=white();\n      if (sq(x - 0.1) + sq(y + 0.2) < 0.00125) col=white();       \n       // Ð³Ð»Ð°Ð·Ð°, Ð·ÑÐ°ÑÐºÐ¸\n       if (sq(x + 0.10 + 0.0102*sin(iTime*8.)) + sq(y + 0.2 + 0.0102*cos(iTime*8.) ) < 0.0006) col=black();\n       if (sq(x - 0.10 + 0.0102*sin(iTime*8.)) + sq(y + 0.2 - 0.0102*cos(iTime*8.)) < 0.0006) col=black();         \n      // Ð±ÑÐ¾Ð²ÐºÐ¸ \n      if (sq(x + 0.1) + 2.5*sq(y + 0.275) < 0.001) col=brown3();\n      if (sq(x - 0.1) + 2.5*sq(y + 0.275) < 0.001) col=brown3();   \n      // Ð³ÑÐ±Ñ \n      if (0.55*abs(x) + abs(y + 0.02*cos(iTime*11.)+0.093) < 0.032) col=red();\n      //  if (0.45*sq(x) + sq(y + 0.11) < 0.00055) col=brown2(); \n      // Ð½Ð¾ÑÐ¸Ðº\n      if (0.9*abs(x) + abs(y +0.01*cos(iTime*9.)+ 0.155) < 0.0322) col=black();    \n       if (1.1*sq(x) + sq(y +0.01*cos(iTime*9.)+ 0.135) < 0.00057) col=brown2(); \n    \n    \n       // ÐÑÐ²Ð¾Ð´ Ð½Ð° ÑÐºÑÐ°Ð½\n       fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsSDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 49, 49, 87], [88, 88, 104, 104, 137], [138, 138, 154, 154, 183], [184, 184, 199, 199, 227], [228, 228, 243, 243, 271], [272, 272, 285, 285, 319], [321, 391, 410, 410, 422], [425, 425, 481, 531, 3342]], "test": "valid"}
{"id": "slSSRm", "name": "rgb semi-transparent cube", "author": "CyanMARgh", "description": "A semi-transparent colored cube that counts as O (1) color due to a previously solved differential equation.", "tags": ["cube", "rgb"], "likes": 4, "viewed": 52, "published": "Public", "date": "1627313026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 camPos = vec3(0., 0., -2.2);\n\nvec2 intSphere(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b*b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\nvec2 intBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) {\n    vec3 m = 1. / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if(tN > tF || tF < 0.) return vec2(-1.);\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return vec2(tN, tF);\n}\n\nvec3 getDir(vec2 fc) {\n    vec2 r = iResolution.xy;\n    fc /= r;\n    fc -= .5;\n    fc.x *= r.x / r.y;\n    return normalize(vec3(fc.xy, 1.2));\n}\nvec3 calcG(vec3 G_l, vec3 p0, vec3 p1, vec3 color, float alpha) {\n    float beta = 1. - alpha; \n    float leng = length(p1 - p0);\n    vec3 a = log(beta) * color;\n    float b = -log(beta);\n    vec3 c = (a + b * G_l) * exp(-leng * b);\n    vec3 G_0 = (c - a) / b;\n    return G_0;\n}\nvec3 calcG_(vec3 G_l, vec3 p0, vec3 p1, vec3 pivot, vec3 size, float alpha) {\n    float beta = 1. - alpha; \n    vec3 dir = normalize(p1 - p0);\n    float leng = length(p1 - p0);\n    vec3 K = dir / size;\n    vec3 B = (p0 - pivot) / size;\n    vec3 a = log(beta) * K;\n    vec3 b = log(beta) * B;\n    vec3 c = vec3(-log(beta));\n    vec3 d = (a + c * (a * leng + b + c * G_l)) / exp(leng * c);\n    vec3 G_0 = ((d - a) / c - b) / c;\n    return G_0;\n}\n\nmat2 rot(float angle) {\n    return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\nfloat part(vec2 z) {\n    float l = z.x + z.y;\n    return l < .5 ? 0. : l < 1. ? 1. : l < 1.5 ? 0. : 1.;\n}\nvec3 houndstooth(vec2 z) {\n    z /= iResolution.y;\n    z = mod(z * 10., 2.);\n    return vec3(z.x < 1. ? (z.y < 1. ? part(z) : (0.)) : (z.y < 1. ? (1.) : 1.-part(z-1.)));\n}\n\nvoid mainImage(out vec4 col, in vec2 fc) {\n    vec3 background = houndstooth(fc);\n    float angle = .2 * iTime;\n    vec3 camPos_ = camPos;\n    camPos_.zy *= rot(.57);\n    camPos_.xz *= rot(angle);\n\n    vec3 dir = getDir(fc);    \n    dir.zy *= rot(.6);\n    dir.xz *= rot(angle);\n    \n    vec3 norm;\n    vec2 i0 = intBox(camPos_, dir, vec3(.5, .5, .5), norm);\n    if(i0.x < 0.) {\n        col = vec4(background, 1.);\n    } else {\n        vec3 p0 = camPos_ + dir * i0.x;\n        vec3 p1 = camPos_ + dir * i0.y;\n        \n        //col = vec4(calcG(background, p0, p1, vec3(1., 0., 0.), .9), 1.);\n        vec3 col_ = calcG_(background, p0, p1, vec3(-.5), vec3(1.), .6 + sin(iTime * 2.) * .399);\n        col = vec4(col_, 1.);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 94, 94, 291], [292, 292, 357, 357, 706], [708, 708, 730, 730, 851], [852, 852, 917, 917, 1130], [1131, 1131, 1208, 1208, 1574], [1576, 1576, 1599, 1599, 1667], [1668, 1668, 1688, 1688, 1773], [1774, 1774, 1800, 1800, 1945], [1947, 1947, 1989, 1989, 2673]], "test": "valid"}
{"id": "slsSRN", "name": "Flame light dance", "author": "conceptblend", "description": "Exploration of color and symmetry over time.", "tags": ["time", "color", "lights"], "likes": 2, "viewed": 40, "published": "Public", "date": "1625288700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    // Scale the space\n    uv *= 4.;\n    \n    float fork = smoothstep(0.0, 1.75, abs(uv.y+1.25));\n    float taper = mix(0.04, 1.8, fork);\n    float offset = 0.5 + (.5+.5*sin(iTime * 2.));\n    float flame = abs(abs(uv.x) - offset - fork * (.5+.5*sin(iTime * 2.5)));\n    \n    float c = smoothstep(taper, 0., flame);\n    col += c;\n    \n    // Partially undo the scaling\n    uv /= 2.;\n    col *= abs(abs(0.7*uv.xyx * vec3(1,2,4)) - (.5+.5*sin(iTime*3.)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsSRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 659]], "test": "valid"}
{"id": "slsSWn", "name": "Union Jack Flag - @The_ArtOfCode", "author": "ShotgunSeat", "description": "A union jack flag based off of the work of Martijn @The_ArtOfCode\n\nIt's not perfectly proportioned but it's my first go at writing something in shadertoy", "tags": ["flag", "uk", "artofcoding", "unionjack"], "likes": 8, "viewed": 101, "published": "Public", "date": "1625494549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 WHITE = vec3(1);\nvec3 RED = vec3(200, 16, 46)/255.;\nvec3 BLUE = vec3(1, 33, 105)/255.;\n\nfloat PI = 3.1415;\n\nfloat Stripes(vec2 uv, float width) {\n\n    float y = abs(uv.x) - width * 0.5;\n    float w = fwidth(y);\n    float yStripe = smoothstep(-w, w, y);\n    \n    float x = abs(uv.y) - width * iResolution.y/iResolution.x;\n    w = fwidth(x);\n    float xStripe = smoothstep(-w, w, x);\n    \n    return min(yStripe, xStripe);\n}\n\nvec2 RotateUV(vec2 uv, float angle) {\n    return vec2(\n        cos(angle) * uv.x + sin(angle) * uv.y,\n        cos(angle) * uv.y - sin(angle) * uv.x\n    );\n}\n\nvec3 Flag(vec2 uv) {\n    \n    float diagScale = 6./8.;\n    float diagOffset = 0.015;\n    \n    vec2 st = RotateUV(uv, PI/4.);\n\n    vec3 col = mix(WHITE, BLUE, Stripes(st, 0.166*diagScale));\n    col = mix(RED, col, Stripes(st + diagOffset * sign(-uv), 0.05*diagScale)); \n\n    col = mix(WHITE, col, Stripes(uv, 0.166));\n    col = mix(RED, col, Stripes(uv, 0.1)); \n   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n\n    float t = uv.x*7.-2.*iTime+uv.y*3.;\n    uv.y += sin(t)*.05 * (uv.x + 0.5); //Multiply by uv.x to wave less on the left\n    \n    vec3 col = Flag(uv);\n    \n    col *= mix(1., .7+cos(t)*.3, (uv.x + 0.5)); //mix with uv.x to shade less on the left\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 150, 150, 427], [429, 429, 466, 466, 585], [587, 587, 607, 607, 969], [971, 971, 1028, 1028, 1362]], "test": "valid"}
{"id": "slSSzW", "name": "Raytracing - Tom .R", "author": "KrankerApfel", "description": "Goal :\n- white dwarf with a satellite\n- water under horizon\n- reflexion in water\n- rim light on satellite according to light from the white dwarf\n- chromatic aberration on white dwarf\n- god ray on satellite according to light from the white dwarf\n\n", "tags": ["raytracing"], "likes": 2, "viewed": 39, "published": "Public", "date": "1627377737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n   author : Tom Rakotomanampison\n   date : july 2021\n   purpose : learning raytracing\n   TODO :\n   - color water\n   - color planets with beautiful effect\n   - god ray from center planet\n   - chromatic aberation ?\n   - Rime light fresnel\n\n*/\n#define COUNT 2\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material mat;\n};\n\n\n\nstruct hit_record\n{\n    float t; // distance from ray origin\n    vec3 normal;\n    vec3 uv;\n    Material mat;\n    \n};\n\nvec3 sky(vec2 uv)\n{\n  \n  \n  return vec3(0,0.5f,.7f)*smoothstep(0.3,-0.2,uv.y) + 0.12;\n}\n\n\n\nbool hit_sphere(Ray r, Sphere s, inout hit_record hit)\n{\n  float a = dot(r.direction, r.direction);\n  float b = dot(r.origin - s.center, r.direction);\n  float c = dot(r.origin - s.center, r.origin - s.center) - s.radius* s.radius;\n  \n  float delta = b*b - a*c;\n  if(delta < 0.0)\n    return false;\n  \n  float t0 = (-b - sqrt(delta)) / a;\n  float t1 = (-b +  sqrt(delta)) / a;\n  float t = min(t0,t1);\n  if(t<0.) return false;\n    \n  hit.t = t;\n  hit.mat = s.mat;\n  hit.normal = (r.origin + t*r.direction) - s.center;\n    \n  return true;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5);\n   uv.x *= iResolution.x / iResolution.y;\n   \n   float t = 1./0.;\n   \n   float displace = texture(iChannel2, uv).r / .5;\n   \n   float should = smoothstep(0.05,-0.2,uv.y); \n   \n   float waveLength = uv.y *0.12;\n   \n   uv.x +=displace*(sin(iTime+(3./uv.y))*waveLength)*should;\n   \n\n   \n   Sphere spheres[] = Sphere[COUNT]\n    (\n        Sphere(vec3(0,0,-5.f), 1.f, Material(vec3(1.,0.98,0.80),0.5f, 0.5f) ),\n        Sphere(vec3(cos(iTime)*2.0,0,-5.+sin(iTime)), .5f, Material(vec3(.0,0.25,0.25),0.5f, 0.5f) )\n   \n    );\n\n   \n   Ray ray = Ray(vec3(0), normalize(vec3(uv.x, uv.y, -1.0)));\n   vec4 col = vec4(sky(uv),1.f)*texture(iChannel0, uv);\n\n   hit_record hit = hit_record(0., vec3(0), vec3(0), Material(vec3(0.),0.5f, 0.5f)); \n   \n   vec3 lightDir = vec3(1.,1.,0);\n   vec3 lightColor = vec3(1.0);\n\n   for(int i = 0; i < COUNT; i++)\n   {\n      if( hit_sphere(ray, spheres[i], hit) )\n      {\n           if(hit.t < t)\n       {\n           t = hit.t;\n           float fresnel = clamp(.5+.9*dot(.5-hit.normal, -ray.direction),.5,1.);\n\n         //  col =fresnel*vec4(hit.mat.color*lightColor*dot(lightDir, hit.normal),1.f);\n           col = fresnel*vec4(hit.mat.color,1.);\n           \n       }\n      }\n   }\n   \n    \n    \n\n   \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[586, 586, 605, 605, 673], [677, 677, 733, 733, 1213], [1216, 1216, 1273, 1323, 2645]], "test": "error"}
{"id": "slsXR4", "name": "Experiment 1001", "author": "kibitz9", "description": "More experimentation with using a mandelbox for surface textures.", "tags": ["fractal", "mandelbox"], "likes": 11, "viewed": 93, "published": "Public", "date": "1625281840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//***************************************************************//\n// More Fractal Surface Experiments by CMiller (kibitz9)\n// I am experimenting with using fractals for surface detail (greebles). \n// This one I think hides the underlying mandelbox fractal rather well.\n//***************************************************************// \n\nconst float GLOBAL_EPSILON = .0005;\nconst vec2 GLOBAL_PN = vec2(1,-1);\nconst vec3 GLOBAL_PN_XYY=GLOBAL_PN.xyy;\nconst vec3 GLOBAL_PN_YYX=GLOBAL_PN.yyx;\nconst vec3 GLOBAL_PN_YXY=GLOBAL_PN.yxy;\nconst vec3 GLOBAL_PN_XXX=GLOBAL_PN.xxx;\n\nconst vec3 GLOBAL_PN_XYY_EPS=GLOBAL_PN_XYY*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_YYX_EPS=GLOBAL_PN_YYX*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_YXY_EPS=GLOBAL_PN_YXY*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_XXX_EPS=GLOBAL_PN_XXX*GLOBAL_EPSILON;\nconst float MAX_DIST = 10.0;\n\n\n\n\nfloat map7(vec3 p){\n\n\tfloat scale1=3.0;\n\tvec3 sp1=p/scale1;\n\tfloat rp1=4.000400010000001;\n\tfloat r1=2.0;\n\tfloat d1;\n\tif (length(sp1)>rp1){\n\t\td1=length(sp1)-r1;\n\t}\n\telse{\n\t\tfloat sectorSize1=0.31415926536;\n\t\tfloat sectorNumber1=round(atan(sp1.y,sp1.x)/sectorSize1);\n\t\tfloat angleOffset1=-sectorNumber1*sectorSize1;\n\t\tfloat cos1=cos(angleOffset1);\n\t\tfloat sin1=sin(angleOffset1);\n\t\tvec3 q1=vec3(\n\t\t\tsp1.x*cos1-sp1.y*sin1,\n\t\t\tsp1.y*cos1+sp1.x*sin1,\n\t\t\tsp1.z\n\t\t);\n\t\t//float sectorSize2=0.31415926536;\n\t\tfloat sectorNumber2=round(atan(q1.x,q1.z)/sectorSize1);\n\t\tfloat angleOffset2=-sectorNumber2*sectorSize1;\n\t\tfloat cos2=cos(angleOffset2);\n\t\tfloat sin2=sin(angleOffset2);\n\t\tvec3 q2=vec3(\n\t\t\tq1.x*cos2+q1.z*sin2,\n\t\tq1.y,\n\t\t\tq1.z*cos2-q1.x*sin2\n\t\t);\n\t\t//float sectorSize3=0.31415926536;\n\t\tfloat sectorNumber3=round(atan(q2.y,q2.x)/sectorSize1);\n\t\tfloat angleOffset3=-sectorNumber3*sectorSize1;\n\t\tfloat cos3=cos(angleOffset3);\n\t\tfloat sin3=sin(angleOffset3);\n\t\tvec3 q3=vec3(\n\t\t\tq2.x*cos3-q2.y*sin3,\n\t\t\tq2.y*cos3+q2.x*sin3,\n\t\t\tq2.z\n\t\t);\n\t\tfloat cosTheta1=0.70710677;\n\t\tfloat sinTheta1=0.70710677;\n\t\tvec3 rot1=vec3(q3.x,q3.y*cosTheta1+q3.z*sinTheta1,q3.z*cosTheta1+q3.y*-sinTheta1);\n\t\tfloat scale2=0.75;\n\t\tvec3 sp2=rot1/scale2;\n\t\tvec4 q4=vec4(sp2,1.0);\n\t\tvec4 c1=vec4(sp2,1.0);\n\t\tfloat s1=-2.5;//+sin(iTime/7.)*2.;\n\t\tfloat r2=0.5+sin(iTime/3.)*.5;\n\t\tint itr1=10;\n\t\tfloat f1=1.0;\n\t\tfor (int a1=0;a1<itr1;a1++){\n\t\t\tq4.xyz=f1*(clamp(q4.xyz,-1.0,1.0)*2.0-q4.xyz);\n\t\t\tq4 *=s1/clamp(dot(q4.xyz,q4.xyz),r2,1.0);\n\t\t\tq4 +=c1;\n\t\t}\n\t\td1=(length(q4.xyz)/abs(q4.w))*scale2;\n\t}\n\t//Sphere1\n\tfloat radius1 =1.97;\n\tfloat unionleft1=d1;\n\tfloat unionRight1=length(sp1)-radius1;\n\treturn (min(unionleft1,unionRight1))*scale1;\n}\n\nfloat map(in vec3 q){\n\n    float time = iTime/8.5;\n    //return 1.0;\n    vec3 p=q;\n\n    float lookDown=.2;\n    float cosld=cos(lookDown);\n    float sinld=sin(lookDown);\n    p=vec3(p.x,p.y*cosld+p.z*-sinld,p.z*cosld+p.y*sinld);\n    p =vec3(\n        p.x*cos(time)+p.z*-sin(time),\n        p.y\n        ,p.z*cos(time)+p.x*sin(time)\n    );\n    p=p+vec3(0.,-2.+sin(time*2.)*.125,0.);\n    \n    float ang2 = sin(iTime/4.)*.25;\n    p = vec3(p.x*cos(ang2)-p.y*sin(ang2),p.y*cos(ang2)+p.x*sin(ang2),p.z);\n\n    float m;\n    float mb=0.;\n\n    bool bound = false;\n    //float outer = (length(vec3(p.x,p.y*5.,p.z))-1.90);\n   // float t=.008;\n    //if (outer>2.*t){\n\n    //    m=outer-t;\n    //}\n    //else{\n        m= map7(p*5.);\n        m/=5.;\n    //}\n   \n   \n    //m=max(m,outer);\n\n    //float inner=length(vec3(p.x,p.y*6.,p.z))-1.890;\n    //float sub = length(p)-1.4;\n    //sub = abs(sub)-.15;\n    \n    //inner = max(inner,-sub);\n    \n    //inner +=mb/10.;\n    \n  \n    \n    //m=min(m,inner);\n    \n   \n    \n    m/=4.;\n    //float n=m;\n \n    m=min(m,q.y-.1);\n    m=min(m,-q.z+3.);\n   \n    \n    return m;\n }\n    \n    \n    \n \n    \n\n\nvec3 getSurfaceNormal( in vec3 p, float epsilon ) // for function f(p)\n{\n  \n    return normalize(\n        GLOBAL_PN_XYY*map(p+GLOBAL_PN_XYY_EPS) +\n        GLOBAL_PN_YYX*map(p+GLOBAL_PN_YYX_EPS) +\n        GLOBAL_PN_YXY*map(p+GLOBAL_PN_YXY_EPS) +\n        GLOBAL_PN_XXX*map(p+GLOBAL_PN_XXX_EPS) \n    \n    );\n}\n\n\nvoid rayMarch(\n    in vec3 origin, \n    in vec3 ray, \n    in float epsilon,\n    in float maxSteps,\n   \n    out vec3 marchPoint,\n    out float marchPointDist,\n    out float stepsTaken\n\n\n){\n    \n  \n    \n    stepsTaken = 0.0;\n    marchPoint=origin;\n    float h = map(marchPoint);\n    while (h>epsilon&&stepsTaken++<maxSteps&&h<MAX_DIST){\n        marchPoint+=ray*h;       \n        h=map(marchPoint);\n    }   \n    marchPointDist=h;\n}\n\nfloat softShadowBalanced(vec3 surface, vec3 light, float radius, float maxDist){\n   \n    \n  \n    vec3 surfaceToLight = light-surface;\n    float distanceToLight=length(surfaceToLight);\n    float maxDist2 = min(maxDist,distanceToLight);\n    vec3 ray =normalize(surfaceToLight);\n    float artifactCompensation = 1.0;\n    float minDist = 0.2;//think about this.\n    \n    float travelled = minDist;\n    float xx=1.0;\n    while (travelled < maxDist2){\n    \n        float ratioTravelled=travelled/distanceToLight;\n        \n       \n        float relativeRadius=ratioTravelled*radius;\n        \n        float dist=map(surface+ray*travelled);\n         \n        if (dist<-relativeRadius){\n            return 0.0;\n        }\n        float relativeDiameter=relativeRadius*2.0;\n        \n        float dist2=dist+relativeRadius;\n        xx = min(xx,dist2/relativeDiameter);\n        \n       \n        float artifatCompensation2 = artifactCompensation*clamp(relativeRadius/dist,0.,1.);\n        travelled +=max(abs(dist/artifactCompensation),minDist);\n        \n        \n    }\n       \n   return xx;\n    \n\n    \n}\n\nvec3 power(vec3 vec, float power){\n    return vec3(pow(vec.x,power),pow(vec.y,power),pow(vec.z,power));\n}\n\n\n\nvoid calcLight(\n    in vec3 surfacePoint, \n    in float shineAtPosition,\n    in vec3 lightPosition,\n    in vec3 observationPosition,\n    in vec3 lightColor,\n    in float lightBrightness,\n    in vec3 surfaceNormal,\n    in float epsilon,\n    in float lightRadius,\n    out vec3 diffuse, \n    out vec3 specular){\n    \n \n     \n    vec3 col0 = lightColor;\n    \n    \n    vec3 surfaceToLight=lightPosition-surfacePoint;\n    vec3 normalToLight=normalize(surfaceToLight);\n    \n    float oneOverDistToLightSquared = lightBrightness/dot(surfaceToLight,surfaceToLight);\n    \n    \n    \n    float dp = dot(normalToLight,surfaceNormal);\n \n    dp=max(dp,0.0);\n\n    \n    diffuse=dp*lightColor*oneOverDistToLightSquared;\n    \n    \n    vec3 rayToObs=normalize(observationPosition-surfacePoint);\n    vec3 avg = normalize(normalToLight+rayToObs);\n    float spec = dot(avg,surfaceNormal);\n    spec = max(spec,0.0);\n    \n    spec = pow(spec,shineAtPosition);\n\n    specular=lightColor*spec*oneOverDistToLightSquared;\n    \n    float shadowAdjust = 1.0;\n    \n\n    if (true){\n        float s = softShadowBalanced(surfacePoint,lightPosition,lightRadius, 500.); \n        diffuse*=s*shadowAdjust;\n        specular*=s*shadowAdjust;\n    }\n \n}\n\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec3 eye = vec3(0.0,0.0,-.5);\n    vec3 lense = vec3(0.0,0.0,.5);\n    float xxx = 0.;\n    vec3 cameraPosition = vec3(0.,2.,-(5.+xxx)+sin(iTime/10.)*xxx);\n    float specAmt = 0.0;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float epsilon1 = .002;\n    \n   \n    vec3 objColor=vec3(1,1,1);\n  \n    vec2 ar = (fragCoord/iResolution.x)\n        -vec2(.5,iResolution.y/(2.0*iResolution.x));\n    vec3 lenseIntersection = vec3(ar,lense.z);\n    \n    vec3 ray = normalize(lenseIntersection-eye);\n   \n    \n    float stepsTaken;\n    vec3 finalPosition;\n    float finalDistance;\n\n    float maxSteps = 4000.0;\n    \n    rayMarch(eye+cameraPosition,ray,epsilon1,maxSteps,finalPosition,finalDistance,stepsTaken);\n    \n  \n    \n    float objectShine=14.;\n    \n    \n    vec3 diffuse1;\n    vec3 specular1;\n\n    vec3 diffuse2;\n    vec3 specular2;\n\n    vec3 diffuse3;\n    vec3 specular3;\n\n    vec3 diffuse4;\n    vec3 specular4;\n    if (finalDistance<epsilon1){\n    \n\n        finalPosition = finalPosition+(ray*epsilon1*-2.0);\n        vec3 normal = getSurfaceNormal(finalPosition,epsilon1);\n        \n       \n        \n        float lightBrightness = 1400.;\n        float specMult = 2.0;\n        \n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(30.0,40.0,-40.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(.25,.25,1.),//light color\n            lightBrightness*1.55,//light bright\n       \n            normal,\n            epsilon1,\n            1.,\n            diffuse1,\n            specular1\n        );\n        \n        \n         calcLight(\n            finalPosition,\n            objectShine,\n            vec3(-30.0,40.0,-40.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.7,.325,0.)*.5,//light color\n            lightBrightness*1.5,//light bright\n            normal,\n            epsilon1,\n            1.,\n            diffuse2,\n            specular2\n        );\n        \n        \n        \n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(0.0,30.0,-40.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(.25,.9,.1)*.5,//light color\n            lightBrightness*.75,//light bright\n            normal,\n            epsilon1,\n            .5,\n            diffuse3,\n            specular3\n        );\n        \n        /*\n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(130.0,30.0,-480.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.,.9,.3)*.5,//light color\n            lightBrightness*5.,//light bright\n            normal,\n            epsilon1,\n            diffuse3,\n            specular3\n        );\n        */\n        \n        \n        /*\n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(0.0,10.0,-5.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.,.8,.5)*.5,//light color\n            lightBrightness/20000.,//light bright\n            normal,\n            epsilon1,\n            diffuse4,\n            specular4\n        );\n    */\n    \n    \n        \n    \n        vec3 col1=objColor*max(diffuse1,0.0);\n        col1+=specular1*specMult;\n        \n        vec3 col2=objColor*max(diffuse2,0.0);\n        col2+=specular2*specMult;\n        \n        vec3 col3=objColor*max(diffuse3,0.0);\n        col3+=specular3*specMult;\n        \n        //vec3 col4=objColor*max(diffuse4,0.0);\n        //col4+=specular4*specMult;\n        \n        \n      \n       \n        \n        //vec3 colFinal = min(col1+col2,1.0);\n        //vec3 colFinal = min(col1+col2+col3+col4,1.);\n        vec3 colFinal = min(col1+col2+col3,1.);\n        colFinal=power(colFinal,.9);\n        \n     \n        \n        colFinal = pow(colFinal,vec3(.75,.74,.73));\n        \n        fragColor = vec4(colFinal,1.0);\n        \n    }\n    else{\n        fragColor = vec4(.2,0,0,1.0);\n\n    }\n    \n\n    \n    \n}\n\nvoid AntiAlias3( out vec4 fragColor, in vec2 fragCoord, float aaLevel){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float subPixel = 1.0/aaLevel;\n    vec4 result = vec4(0,0,0,1);\n    for (float x=fragCoord.x;x<fragCoord.x+1.0;x+=subPixel){\n        for (float y=fragCoord.y;y<fragCoord.y+1.0;y+=subPixel){\n            vec4 temp;\n            mainImage1(temp,vec2(x,y));\n            result+=temp;\n        }\n    }\n    \n    //vec3 r = vec3(0);\n    //vec3 x = vec3(1);\n    //vec3 t = clamp(r,x,x);\n    \n    \n    fragColor = result/(aaLevel*aaLevel);\n   \n    \n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord){\n    if (false){\n        AntiAlias3(fragColor, fragCoord,2.);\n    }\n    else{\n        vec4 result = vec4(0,0,0,1);\n        mainImage1(result,fragCoord);\n        fragColor=result;\n    }\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[842, 842, 861, 861, 2539], [2541, 2541, 2562, 2562, 3632], [3657, 3657, 3729, 3729, 3963], [3966, 3966, 4153, 4153, 4394], [4396, 4396, 4476, 4476, 5485], [5487, 5487, 5521, 5521, 5592], [5596, 5596, 5904, 5904, 6805], [6808, 6808, 6866, 6866, 10846], [10848, 10848, 10919, 10919, 11407], [11409, 11409, 11465, 11465, 11652]], "test": "valid"}
{"id": "slsXRM", "name": "Linear Best Fit", "author": "oneshade", "description": "Analytical solution to the best linear fit of a set of points. I'm planning to extend this to continuous curves (bezier curves in particular).", "tags": ["2d", "linear", "regression", "fitting"], "likes": 8, "viewed": 94, "published": "Public", "date": "1625388988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Desmos graph: https://www.desmos.com/calculator/rpdsgju4tl\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// Number of points\n#define N 50\n\n// Minimizing Î£(p[n].y - (a*p[n].x + b))Â² wrt a and b\nvec2 bestFitLinear(in vec2[N] p) {\n    vec4 w = vec4(0.0);\n    for (int n=0; n < N; n++) w += vec4(p[n], p[n] * p[n].xx);\n    float b = (w.y * w.z - w.x * w.w) / (float(N) * w.z - w.x * w.x);\n    return vec2((w.w - w.x * b) / w.z, b);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 getOffset(in float id) {\n    float freq = Hash11(id * 393.84 + 673.48) * 10.0 - 5.0;\n    float phase = Hash11(id * 348.46 + 183.37);\n    float amp = Hash11(id * 275.35 + 741.69);\n    float ang = iTime * freq + phase;\n    return vec2(cos(ang), sin(ang)) * amp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec4 mouse = (abs(iMouse) - center.xyxy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec4(-2.0, cos(iTime), 2.0, sin(iTime));\n\n    // Grid\n    drawSDF(abs(mod(uv.x + 0.25, 0.5) - 0.25), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(mod(uv.y + 0.25, 0.5) - 0.25), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    drawSDF(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Line drawn by the mouse\n    vec2 p1 = mouse.zw, p2 = mouse.xy;\n    float a = (p2.y - p1.y) / (p2.x - p1.x);\n    float b = p1.y - a * p1.x;\n\n    // Generate random points distributed on a line\n    vec2[N] points;\n    for (int n=0; n < N; n++) {\n        float x = float(n) / float(N) * 4.0 - 2.0;\n        points[n] = vec2(x, a * x + b) + getOffset(float(n));\n        drawSDF(length(uv - points[n]) - 0.05, vec3(0.0));\n    }\n\n    // Draw the mouse line\n    //drawSDF(abs(uv.y - (a * uv.x + b)) / sqrt(1.0 + a * a), vec3(0.0, 1.0, 0.0));\n\n    // Draw best linear fit\n    vec2 fit = bestFitLinear(points);\n    drawSDF(abs(uv.y - (fit.x * uv.x + fit.y)) / sqrt(1.0 + fit.x * fit.x), vec3(1.0, 0.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[485, 526, 552, 552, 638], [640, 640, 669, 669, 906]], "test": "valid"}
{"id": "slsXWB", "name": "Ursuppe", "author": "joeydee", "description": "experimental FrÃ¼hstÃ¼cksmÃ¼sli @ t_verdauung(0.5f)\n(a quick'n'dirty hack and proof of concept how to create some organic procedural patterns)", "tags": ["procedural", "noise", "perlin", "organic", "microscope", "hangover"], "likes": 3, "viewed": 60, "published": "Public", "date": "1626481011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//just experimenting ...\n//gtz joeydee\n\n\n//std 2d noise\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\n//std 2d interpolated noise\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n    float res = mix(\n        mix(rand(ip), rand(ip + vec2(1.0, 0.0)), u.x),\n        mix(rand(ip + vec2(0.0, 1.0)), rand(ip + vec2(1.0, 1.0)), u.x), u.y);\n    return res;\n}\n\n//std 3d noise\nfloat rand(vec3 n) {\n    return fract(sin(dot(n, vec3(12.9898, 4.1414,7.5531))) * 43758.5453);\n}\n\n//std 3d interpolated noise\nfloat noise(vec3 p){\n    vec3 ip = floor(p);\n    vec3 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n    float a0=rand(ip);\n    float a1=rand(ip + vec3(1.0, 0.0, 0.0));\n    float a2=rand(ip + vec3(0.0, 1.0, 0.0));\n    float a3=rand(ip + vec3(1.0, 1.0, 0.0));\n    float ares = mix(\n        mix(a0, a1, u.x),\n        mix(a2, a3, u.x), u.y);\n    float b0=rand(ip + vec3(0.0, 0.0, 1.0));\n    float b1=rand(ip + vec3(1.0, 0.0, 1.0));\n    float b2=rand(ip + vec3(0.0, 1.0, 1.0));\n    float b3=rand(ip + vec3(1.0, 1.0, 1.0));\n    float bres = mix(\n        mix(b0, b1, u.x),\n        mix(b2, b3, u.x), u.y);\n    return mix(ares,bres,u.z);\n}\n\n//somewhat perlin noise\nfloat perlin(vec2 p){\n    int numOctaves=8;\n    float H=1.2;\n    float t = 0.0;\n    for (int i = 0; i < numOctaves; i++)\n    {\n        float f = pow(2.0, float(i));\n        float a = pow(f, -H);\n        t += a * noise(f * p);\n    }\n    return t; \n}\n\n          \n//organic dots\nfloat dotNoise(vec2 p, float d){\n    float res=noise(p*50.0+100.0)*d;\n    res*=noise(p*70.0+10.0)*d;\n    res*=noise(p*90.0+50.0)*d;\n    res=1.0-res*res*res*res;\n    return clamp(res,0.0,1.0);\n}\n\nfloat dotNoise(vec3 p, float d){\n    float res=noise(p*50.0+100.0)*d;\n    res*=noise(p*70.0+10.0)*d;\n    res*=noise(p*90.0+50.0)*d;\n    res=1.0-res*res*res*res;\n    return clamp(res,0.0,1.0);\n}\n\n//turbulence lookup vector\nvec2 turbulence(vec2 p, float s, float w){\n    return vec2(p.x+perlin(p*s+12345.0)*w,p.y+perlin(p*s+67890.0)*w);\n}\n\n//a simple gradient lookup\nfloat grad1(float f, float k){\n     return 1.0-pow( 4.0*f*(1.0-f), k ); \n}\n\n//a simple color lookup\nvec3 colmap(float h, float t, float g){\n     return vec3(h+t,h*(1.0+g),h-t); \n}\n\n\n//experimenteller statischer Flockenbrei\nfloat organicShice(vec2 p){\n    float hue=0.7;\n    hue*=dotNoise(p*0.3+300.0, 1.4)*0.3+0.7;                      //large dots\n    hue*=dotNoise(turbulence(p,20.0,0.2)*0.3+300.0, 1.3)*0.5+0.5; //turbulence dots\n    hue*=perlin(turbulence(p, 10.0, 0.5)*20.0)*0.3+0.7;           //turbulence perlin\n    hue*=grad1(dotNoise(p*0.5, 1.3), 10.0)*0.6+0.4;               //hollow dots\n    hue*=dotNoise(p, 1.2)*0.7+0.3;                                //small dots\n    hue*=(perlin(p*15.0))*0.4+0.6;                                //perlin\n    return hue;\n}\n\n//FrÃ¼hstÃ¼cksmÃ¼sli @ t_verdauung(0.5f)\nfloat movingOrganicShice(vec2 p){\n    float hue=0.7;\n    vec3 p3=vec3(p,iTime*0.003);//depth offset\n    vec2 o=vec2(sin(iTime*0.3)*0.4+iMouse.x*0.01,iTime*0.2+iMouse.y*0.01);//moving\n    vec3 o3=vec3(o,0);\n    hue*=dotNoise(((p3+o3*0.1)*2.0)*0.3+300.0, 1.4)*0.3+0.7;                        //large dots\n    hue*=dotNoise(iTime*0.005+turbulence(p+o*0.134,20.0,0.2)*0.2+300.0, 1.3)*0.5+0.5; //turbulence dots\n    hue*=perlin(iTime+turbulence(p+o*0.12, 10.0, 0.5)*20.0)*0.3+0.7;                //turbulence perlin\n    hue*=grad1(dotNoise((p3+o3*0.13)*0.5, 1.3), 10.0)*0.6+0.4;                      //hollow dots\n    hue*=dotNoise((p+o*0.11), 1.2)*0.7+0.3;                                         //small dots\n    hue*=dotNoise((p+o*0.12)+1000.0, 1.3)*0.6+0.4;                                   //more dots\n    hue*=(perlin((p+o*0.05)*15.0))*0.4+0.6;                                         //perlin\n    return hue;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2 p = fragCoord/iResolution.xx;\n\n    // Output to screen\n    //fragColor = vec4(colmap(organicShice(p),-0.2,0.4), 1.0);                                      //static example\n    fragColor = vec4(colmap(movingOrganicShice(p),-cos(iTime*0.1+0.9)*0.3,sin(iTime*0.007+0.5)*0.5), 1.0);  //dynamic example\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsXWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 56, 76, 76, 145], [148, 176, 196, 196, 448], [450, 465, 485, 485, 561], [563, 591, 611, 611, 1222], [1224, 1248, 1269, 1269, 1496], [1509, 1524, 1556, 1556, 1717], [1719, 1719, 1751, 1751, 1912], [1914, 1941, 1983, 1983, 2055], [2057, 2084, 2114, 2114, 2158], [2160, 2184, 2223, 2223, 2263], [2266, 2307, 2334, 2334, 2854], [2856, 2897, 2930, 2930, 3810], [3813, 3813, 3870, 3895, 4204]], "test": "valid"}
{"id": "slXSDN", "name": "Flag - Jamaica", "author": "Eggy42", "description": "Flag of Jamaica. Based on BigWIngs tutorial. Note I'm not from Jamaica, only admiring their flag. :) ", "tags": ["flag", "jamaica"], "likes": 2, "viewed": 33, "published": "Public", "date": "1625712494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\n// Flag of Jamaica\n// Based on BigWIngs flag tutorial\n// https://www.shadertoy.com/view/flsXRM\n\nfloat PI = 3.14159;\nvec3 GOLD = vec3(254, 209, 0)/255.; // PANTONE 115 \nvec3 GREEN = vec3(0, 155, 58)/255.; // PANTONE 355\nvec3 BLACK = vec3(0.1); // A little grey so we can see the shading\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Wavy uv\n    float t = uv.x*2.-2.*iTime+uv.y*3.;\n    uv.y += sin(t)*.05;\n  \n    // Default color\n    vec3 col = BLACK;\n    \n    // Pixel width\n    float w = fwidth(uv.x);\n    \n    // Triangles\n    float tri = dot(abs(uv), vec2(-tan(PI/6.), 1.));\n    tri = S(-w, w, tri);\n    col = mix(BLACK, GREEN, tri);\n    \n    // Saltaire\n    float stripe = abs(dot(abs(uv), vec2(-tan(PI/6.), 1.)));\n    float swidth = 1./12.; // Saltaire should be one sixth of the length of the hoist\n    stripe = S(swidth-w, swidth+w, stripe);\n    col = mix(GOLD, col, stripe);\n    \n    // Shading \n    col *= .7+cos(t)*.3;\n\n    // Clip top and bottom\n    col *= S(w, .0, abs(uv.y)-.5);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 327, 384, 435, 1220]], "test": "valid"}
{"id": "slXSzB", "name": "Checkerworld", "author": "golinad", "description": "* added cylinder and octahedron sdf\n* shadow casting\n* checkerboard 3d texture\n* uv texturing\n* assign materials\n* phong shading", "tags": ["sdf", "texture", "shadow", "light"], "likes": 2, "viewed": 179, "published": "Public API", "date": "1626474057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Uncomment for debug rendering\n//#define COMPLEXITY\n//#define ISOLINES\n\nconst float pi = 3.1415926535897932384626433832795;\n\nfloat delta = 0.001;\nfloat maxT = 20.0;\nconst int maxIt = 100;\nvec4 ambientColor = vec4(0.20,0.20,0.3,1.0);\nvec4 lightColor = vec4(1.0,1.0,0.7,1.0);\n\n// Material types\nconst int matDefault = 0;\nconst int matChecker = 1;\nconst int matRed = 2;\nconst int matGreen = 3;\nconst int matUVCyan = 4;\nconst int matUVMagenta = 5;\n\nstruct SpotInfo {\n    float d;\n    vec3 pos;\n    vec2 uv;\n    int m;\n};\n\n// SDF primitives\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdBox(in vec3 p,in vec3 ext) {\n    vec3 q = abs(p) - ext/2.0;\n    return length(max(q,0.0)) + min(max(max(q.x, q.y),q.z),0.0);\n}\nfloat sdTorus(in vec3 p, float r1, float r2) {\n    vec3 c = vec3(normalize(p.xy)*r1, 0.0);\n    return distance(p, c) - r2;\n}\nfloat sdCylinder(in vec3 p, in float r, in float h) {\n    p = abs(p);\n    vec3 q = normalize(vec3(p.x, 0.0, p.z))*r + vec3(0,min(p.y, h/2.0),0);\n    q = abs(p) - q;\n    return length(max(q, 0.0)) + min(max(p.y-h/2.0, length(p.xz)-r), 0.0);\n}\n// simple version, not compatible with rounding\nfloat sdOctahedron(in vec3 p, in float r) {\n    p = abs(p);\n    // basically a plane\n//    vec3 n = normalize(vec3(1,1,1));\n//    float ri =  r*(pow(3.0, 0.5)/3.0);\n//    return  dot(n,p) - ri;\n\n    // the same, but fast and cryptic\n    return (p.x + p.y + p.z - r) * 0.57735026;\n}\n\nSpotInfo sdTorusUV(in vec3 p, in float r1, in float r2) {\n    vec3 c = vec3(normalize(p.xy)*r1, 0.0);\n    return SpotInfo(distance(p, c) - r2, p,\n                    vec2(-atan(p.x, p.y)/2.0/pi+0.5, -atan(p.z, distance(p.xy, c.xy))/2.0/pi+0.5), 0);\n}\n\nSpotInfo sdSphereUV(in vec3 p, in float r) {\n    return SpotInfo(length(p) - r, p,\n                vec2(atan(p.x, p.z)/2.0/pi+0.5, -atan(p.y, length(p.xz))/pi+0.5), 0);\n}\n\n// SDF operations\nfloat sdUnion(float a, float b) {return min(a,b);}\nfloat sdIntersect( float a, float b) {return max(a,b);}\nfloat sdSubstract(float a, float b) {return max(a, -b);}\n\n// SDF operations including spot info\nSpotInfo sdUnion(in SpotInfo a, in SpotInfo b) {\n    if(a.d<b.d)\n        return a;\n    else\n        return b;\n}\nSpotInfo sdIntersect(in SpotInfo a, in SpotInfo b) {\n    if(a.d>b.d)\n        return a;\n    else\n        return b;\n}\nSpotInfo sdSubstract(in SpotInfo a, in SpotInfo b) {\n    if (a.d>-b.d)\n        return a;\n    else\n        return SpotInfo(-b.d, b.pos, b.uv, b.m);\n}\n\nfloat checkerBoard(in vec2 uv, in float w) {\n    float cx = mod(uv.x, w)>w*0.5?1.0:0.0;\n    float cy = mod(uv.y, w)>w*0.5?1.0:0.0;\n    \n    // XOR: (a || b) && !( a && b) ->  (a+b)*(1-a*b)\n    return (cx+cy)*(1.0 - cx*cy);\n}\n\n// XOR: (a || b) && !( a && b) ->  (a+b)*(1-a*b)\nfloat xor(float a, float b) {\n    return (a+b)*(1.0 - a*b);\n}\n\nfloat checkerBoard(in vec3 p, float w) {\n    float cx = mod(p.x, w)>w*0.5?1.0:0.0;\n    float cy = mod(p.y, w)>w*0.5?1.0:0.0;\n    float cz = mod(p.z, w)>w*0.5?1.0:0.0;\n    \n    return xor(xor(cx, cy),cz);\n}\n\nfloat isoLines(float d, float seg) {\n    return mod(d, seg) > seg*0.95 ^^ d < 0.0?1.0:0.0;\n}\n\n// sdf only, used for marching\nfloat map(in vec3 p) {\n    float dBox = sdBox(p-vec3(0,-2,0), vec3(40,0.1,40));\n    float dTorus = sdTorus((p - vec3(sin(iTime),1,-3.0+cos(iTime))).xzy, 1.5, 0.2);\n    float dSphere = sdSphere(p - vec3(cos(iTime),0,-3.0+sin(iTime)), 0.5);\n    float d3 = sdUnion(dSphere, dTorus);\n    float d = sdUnion(d3,dBox);\n    d = sdUnion(d, sdCylinder(p - vec3(0,0,-3), 0.2, 4.0)-0.1);\n    d = sdUnion(d, sdOctahedron(p - vec3(-2,-1,-5), 1.0));\n    return d;\n}\n\n// spot info, expensive, only used on surfac hit\nSpotInfo mapSI(in vec3 p) {\n    SpotInfo siBox = SpotInfo(sdBox(p-vec3(0,-2,0), vec3(40,0.1,40)),p,vec2(0,0), matChecker);\n    SpotInfo siTorus = sdTorusUV((p - vec3(sin(iTime),1,-3.0+cos(iTime))).xzy, 1.5, 0.2);\n    siTorus.m = matUVMagenta;\n    SpotInfo siSphere = sdSphereUV(p - vec3(cos(iTime),0,-3.0+sin(iTime)), 0.5);\n    siSphere.m = matUVCyan;\n    SpotInfo si3 = sdUnion(siSphere, siTorus);\n    SpotInfo si = sdUnion(si3,siBox);\n    SpotInfo siCyl = SpotInfo(sdCylinder(p - vec3(0,0,-3), 0.2, 4.0)-0.1, p, vec2(0), matRed);\n    si = sdUnion(si, siCyl);\n    SpotInfo siOct = SpotInfo(sdOctahedron(p - vec3(-2,-1,-5), 1.0), p, vec2(0), matGreen);\n    si = sdUnion(si, siOct);\n    return si;\n}\n\nvec3 tex(in SpotInfo si, in int matID) {\n    // switch case not working on gl es ... so use if else\n    if (matID == matChecker) {\n        return vec3(1.0)*(checkerBoard(si.pos, 1.0)*0.5+0.5);\n    } else if (matID == matRed) {\n        return vec3(1,0,0)*(checkerBoard(si.pos, 1.0)*0.5+0.5);\n    } else if (matID == matGreen) {\n        return vec3(0,1,0)*(checkerBoard(si.pos, 1.0)*0.5+0.5);\n    } else if (matID == matUVCyan) {\n        return vec3(0,1,1)*(checkerBoard(si.uv*vec2(2,1), 0.1)*0.5+0.5);\n    } else if (matID == matUVMagenta) { // uv checkerboard\n        return vec3(1,0,1)*(checkerBoard(si.uv*vec2(2,1), 0.1)*0.5+0.5);\n    } else {\n        return vec3(1.0);\n    }\n}\n\n// calculate normal based on simplified(3 vs. 6 samples) gradient around pos\n// Note: when we are marching solids, d is almost 0 on surface (varying due to marching)\nvec3 calcNormal(in vec3 p, in float d) {\n    float dx = map(p + vec3(delta,0,0));\n    float dy = map(p + vec3(0,delta,0));\n    float dz = map(p + vec3(0,0,delta));\n    \n    return normalize(vec3(dx-d, dy-d, dz-d));\n}\n\n// return distance\nfloat march(in vec3 ro, in vec3 rd, inout int j, out float d) {\n    float t = 0.0;\n    \n    for(int i = 0; i < maxIt; i++) {\n        if (t > maxT) {\n            return t;\n        }\n        \n        d = map(ro+t*rd);\n        if(d < delta || i == 99) {\n            return t;\n        } else {\n            t += d;\n        }\n        j++;\n    }\n}\n\nvec3 lightDirection() {\n    return normalize(vec3(sin(iTime*0.123),0.5,cos(iTime*0.123)));\n}\n\nvec4 bgColor(in vec3 rd) {\n    return ambientColor*cos(rd.y) + pow(max(dot(lightDirection(), rd),0.0),100.0);\n}\n\nvoid shade(out vec4 fragColor, in vec3 p, in vec3 n,in vec3 rd, in float t, inout int j) {\n    // ambient light\n    vec3 light = ambientColor.xyz;\n\n    // direct light\n    vec3 ld = lightDirection();\n    float d;\n    bool shadowed = march(p + n*delta, ld, j, d) < maxT;\n    vec3 lightSpec = vec3(0,0,0);\n    if(!shadowed)  {\n        light += max(dot(n, ld), 0.0)*lightColor.xyz; // diffuse\n        vec3 r = rd-2.0*n*dot(n, rd); // reflection ray\n        float n = 6.0;// exoonent\n        lightSpec = pow(max(dot(r,ld), 0.0),n)*((n+2.0)/2.0/pi)*lightColor.xyz;// specular\n    }\n\n\n    SpotInfo si = mapSI(p);\n    fragColor = vec4(tex(si, si.m)*light + lightSpec, 1.0);\n\n    // fade to bg (fog)\n    fragColor = mix(fragColor, bgColor(rd), t/maxT);\n}\n\nvoid render(out vec4 fragColor, in vec3 ro, in vec3 rd) {\n\n    int j = 0;\n    float d;\n    float t = march(ro, rd, j, d);\n    \n    if (t >= maxT) { // background\n        fragColor = bgColor(rd);\n    } else { // hit something\n        vec3 p = vec3(ro+t*rd);\n        vec3 n = calcNormal(p, d);\n        \n        shade(fragColor, p, n, rd, t, j);\n\n    }\n\n\n#ifdef COMPLEXITY\n    // marching complexity heatmap\n    fragColor = mix(vec4(0,0,1,1), vec4(1,0,0,1), float(j)/float(maxIt*2));\n#endif\n}\n\nvoid debugRender(out vec4 fragColor, in vec2 uv) {\n    float d = map(vec3(uv,0));\n    vec3  n = calcNormal(vec3(uv, 0), d);\n    float l = isoLines(d, 0.1);\n\n    // colored\n    //fragColor = vec4((n*0.5+0.5)*l,1.0);\n    \n    // monochrome\n    fragColor = vec4(l,l,l,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y*2.0;\n    \n#ifdef ISOLINES\n    debugRender(fragColor, uv);\n    //fragColor = vec4(mod(uv, 1.0), 0,1);\n#else\n    vec3 ro = vec3(0,0,2);\n    vec3 rd = normalize(vec3(uv.xy, 0) - ro);\n    render(fragColor, ro , rd);\n#endif\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n\n    render(fragColor, fragRayOri, fragRayDir);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXSzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 538, 571, 571, 599], [600, 600, 636, 636, 734], [735, 735, 781, 781, 859], [860, 860, 913, 913, 1101], [1102, 1150, 1193, 1193, 1431], [1433, 1433, 1490, 1490, 1683], [1685, 1685, 1729, 1729, 1855], [1857, 1875, 1908, 1908, 1925], [1926, 1926, 1964, 1964, 1981], [1982, 1982, 2019, 2019, 2038], [2040, 2078, 2126, 2126, 2189], [2190, 2190, 2242, 2242, 2305], [2306, 2306, 2358, 2358, 2454], [2456, 2456, 2500, 2500, 2680], [2682, 2731, 2760, 2760, 2792], [2794, 2794, 2834, 2834, 2999], [3095, 3126, 3148, 3148, 3576], [3578, 3627, 3654, 3654, 4325], [4327, 4327, 4367, 4426, 5006], [5008, 5174, 5214, 5214, 5390], [5392, 5411, 5474, 5474, 5751], [5753, 5753, 5776, 5776, 5845], [5847, 5847, 5873, 5873, 5958], [5960, 5960, 6050, 6071, 6706], [6708, 6708, 6765, 6765, 7197], [7199, 7199, 7249, 7249, 7471], [7473, 7473, 7530, 7580, 7860], [7863, 7863, 7957, 7957, 8007]], "test": "error"}
{"id": "slXXWH", "name": "{3,3,n}", "author": "calimops", "description": "a normal mapped version of the poincare view of a cell of the {3,3,n} tesselations", "tags": ["mathsmathtetrahedronsdf"], "likes": 4, "viewed": 74, "published": "Public", "date": "1625583208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// {3,3,6}\n//const float radius = 2.8284;\n//const float center = 1.7321;\n\n// {3,3,7}\nconst float radius = 2.1436;\nconst float center = 1.3656;\n\n// {3,3,8}\n// const float radius = 1.8887;\n// const float center = 1.2339;\n\n// {3,3,9}\n//const float radius = 1.7554;\n//const float center = 1.1664;\n\n// {3,3,10}\n//const float radius = 1.6742;\n//const float center = 1.1259;\n\n// {3,3,11}\n//const float radius = 1.6202;\n//const float center = 1.0993;\n\n// {3,3,12}\n//const float radius = 1.5821;\n//const float center = 1.0806;\n\n//float sdf(vec3 p) {\n//    return max(max(max(\n//    length( p ) - 1.0,\n//    radius - length( p - vec3(center , center, -center))),\n//    radius - length( p - vec3(center , -center, center))),\n//    radius - length( p - vec3(-center , center, center)));\n//}\n\n\nvec3 rotateX ( in vec3 p, float thetax ) {\n    \n    float ct = cos( thetax );\n    float st = sin( thetax );\n    \n    return vec3(p.x, ct * p.y - st * p.z, st * p.y + ct * p.z);\n}\n\nvec3 rotateY ( in vec3 p, float thetay ) {\n    \n    float ct = cos( thetay );\n    float st = sin( thetay );\n    \n    return vec3(ct * p.x - st * p.z, p.y, st * p.x + ct * p.z);\n}\n\nvec3 rotateZ ( in vec3 p, float thetaz ) {\n    \n    float ct = cos( thetaz );\n    float st = sin( thetaz );\n    \n    return vec3(ct * p.x - st * p.y, st * p.x + ct * p.y, p.z);\n}\n\n\nfloat sdf(vec3 p) {\n\n    p = mod(p, 4.)-vec3(2.0);\n    p = rotateY(p, 0.1 * 3.141 * sin(iTime) );\n    p = rotateZ(p, 0.1 * 3.141 * sin(iTime+3.0) );\n    p = rotateX(p, 0.1 * 3.141 * cos(iTime+3.0) );\n\n    \n    return max(max(max(max(\n    length( p ) - 1.0,\n    radius - length( p - vec3(center , center, -center))),\n    radius - length( p - vec3(center , -center, center))),\n    radius - length( p - vec3(-center , center, center))),\n    radius - length( p - vec3(-center , -center, -center)));\n}\n\n\n\n//float sdf(vec3 p) {\n    //return min(length(p-vec3(0.5, 0.0, 0.0)) - 1.0, length(p-vec3(-0.5, 0.0, 0.0))-1.0);\n//    return length(p-vec3(0.0, 0.0, 0.0))-1.0;\n//}\n\n//vec4 sky_sample(vec3 ray)\n//{\n//    return texture(iChannel0, ray);\n//}\n\nconst float eta = 0.67;\nconst float FresnelFactor = 5.0;\n\n\nconst float F = ((1.0-eta)*(1.0-eta))/((1.0+eta)*(1.0+eta));\n\n\nvec3 calcNormal( in vec3 p ) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize( k.xyy * sdf( p + k.xyy * h ) + \n                      k.yyx * sdf( p + k.yyx * h ) + \n                      k.yxy * sdf( p + k.yxy * h ) + \n                      k.xxx * sdf( p + k.xxx * h ) );\n}\n\n\nconst int numberOfIterations = 100;\n\nvec2 marchRay(vec3 pos, vec3 dir){\n\n    vec3 ip;\n    float t = 0.0;\n    int visible = 0;\n    \n    for( int i = 0; i < numberOfIterations; i++) {\n        \n        ip = pos + dir * t;\n        float temp = sdf( ip );\n\n        if( abs(temp) < 0.0001 ) {\n            visible = i;\n            break;\n        }\n        \n        t += abs(temp);\n\n    }\n    \n    return vec2(t, visible);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t//vec3 pos = rotateX(rotateY(vec3( 0.0, 0.0, -2.0), 0.2 * iTime ), sin(0.2*iTime));\n\t//vec3 dir = rotateX(rotateY(normalize( vec3(uv, 1.0) ), 0.2 * iTime ), sin(0.2*iTime));\n    \n    vec3 pos = vec3(2.0, 2.0, 0.5);\n\tvec3 dir = normalize( vec3(uv, 1.0));\n    \n    vec2 intersect = marchRay( pos, dir );\n    \n    if( intersect.y > 0.0 && intersect.x < 30.0) {\n        vec3 inter =  pos + dir * intersect.x;\n        vec3 n = calcNormal( inter );\n    \n        float light = pow(( abs(n.y) + 1.0) / 2.0, 1.0 + 1.0 / (1.0 + intersect.x));\n        \n        //float distToCenter = distance(vec3(0.0),inter);\n        \n        float factor = 1.0 / cosh(0.1*intersect.x);\n        \n        //vec3 a = mix(vec3(.01,.01,.1),vec3(0,1,1), 0.5);\n        \n        vec3 b = mix(vec3(0,0,0),vec3(2.0,sin(iTime*.4)+1.0,cos(iTime*.4)+1.0),light);\n        \n        fragColor.rgb = 0.5*factor*b;\n        \n        //fragColor = vec4(normalize( calcNormal( pos + dir * intersect.x ) * 0.5 + 0.5 ), 1.0);\n       \n   //     vec3 hit = pos + dir * intersect.x;\n     //   vec3 norm = normalize( calcNormal(hit) );\n//        \n //       vec3 Reflect = reflect( dir, norm );\n  //      \n   //     vec3 dir2 = refract( dir, norm, eta );\n    //    \n     //   hit -= 0.05 * norm;\n      //  \n       // vec2 intersect2 = marchRay(hit, dir2);\n        \n       // vec3 hit2 = hit + dir2 * intersect2.x;\n        \n//        vec3 norm2 = normalize( calcNormal( hit2 ) );\n        \n  //      vec3 dir3 = refract( normalize(dir2), -norm2, 1.0 / eta);\n        \n    //    vec3 dir5 = vec3(0.0,0.0,0.0);\n        \n      //  if(1.0 - dot(normalize(dir2), norm2) * dot(normalize(dir2), norm2)  > (eta * eta)) {\n        \n        //    vec3 dir4 = reflect (normalize(dir2), -norm2);\n          //  vec2 intersect3 = marchRay(hit2 - 0.05 * norm2, dir4);\n        \n            //vec3 hit3 = hit2 + dir4 * intersect3.x;\n        \n   //         vec3 norm3 = normalize( calcNormal( hit3 ) );\n     ///       \n        //    dir5 = refract( normalize(dir4), -norm3, 1.0 / eta);\n            \n          //  if(1.0 - dot(normalize(dir5), norm3) * dot(normalize(dir5), norm3)  > (eta*eta)) {\n                \n            //    dir5 = dir4;\n            \n           // }\n            \n        \n       // }\n        \n      //  float ratio = F + (1.0 - F) * pow( 1.0 - dot( -dir, norm ), FresnelFactor );\n        \n        //fragColor = mix(sky_sample(dir3+dir5), sky_sample(Reflect), ratio);\n        \n        //fragColor = sky_sample(dir2);\n        \n        //fragColor -= vec4(0.1, 0.15, 0.1, 0.0);\n    } else {\n        fragColor = vec4(0.8, 0.8, 0.8, 1.0);\n        //fragColor = sky_sample(dir);\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[781, 781, 823, 823, 959], [961, 961, 1003, 1003, 1139], [1141, 1141, 1183, 1183, 1319], [1322, 1322, 1341, 1341, 1818], [2185, 2185, 2215, 2215, 2493], [2533, 2533, 2567, 2567, 2912], [2915, 2915, 2972, 2972, 5703]], "test": "valid"}
{"id": "st2SD1", "name": "effin around", "author": "femalefaust", "description": "default tweaked like a black box experiment.", "tags": ["simple"], "likes": 0, "viewed": 114, "published": "Public API", "date": "1627626493", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = iResolution.xy/fragCoord;\n\n    // Time varying pixel color\n    vec3 col = tan(tan(tan(tan(tan(tan(tan(tan(tan(uv.xyx))))))))) + tan(tan(tan(tan(tan(tan(tan(tan(tan(iTime+uv.xyx+vec3(2,9,3))))))))));\n  \n    // Output to screen\n    fragColor = vec4(col,.1);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2SD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 383]], "test": "valid"}
{"id": "st2SR1", "name": "neuron gearbox ", "author": "mstrow", "description": "ancient scripture", "tags": ["spiral"], "likes": 2, "viewed": 34, "published": "Public", "date": "1627117329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\n\nfloat Map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat Smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv.x +=1.0;\n    \n    float sine = sin(iTime*1.3);\n    float sineMap1 = Map(sine, -1.0, 1.0, 1.0, 5.0); \n    float sineMap2 = Map(sine, -1.0, 1.0, 0.2, 0.1);\n    \n    float dist = sqrt((uv.x*uv.x) + (uv.y*uv.y));\n    float arctan = Map(atan(uv.y, uv.x), -PI, PI, 0.0, 1.0);\n    \n    float smoothmin = Smin(dist, arctan, sineMap1);\n    \n    float modulo = mod(smoothmin, sineMap2);\n    \n    float norm = Map(modulo, 0.0, sineMap2, 0.0, 1.0);\n    \n    float thresh = norm > 0.5f ? 0.0 : 1.0;\n    \n    //fragColor = vec4(vec3(thresh), 1.0);\n    fragColor = vec4(vec3(norm*1.3, norm-0.3, norm+0.5), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2SR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 99, 99, 165], [167, 167, 206, 206, 297], [299, 299, 356, 356, 1022]], "test": "valid"}
{"id": "st2SW1", "name": "wave line", "author": "HanShaoqiu", "description": "2d line", "tags": ["wave"], "likes": 1, "viewed": 123, "published": "Public API", "date": "1627612419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 final_color = vec3(1.0);\n\tvec3 bg_color = vec3(0.0);\n\tvec3 wave_color = vec3(0.0);\n\t\n\tfloat wave_width = 0.01;\n\tuv  = -1.0 + 2.0 * uv;\n\tuv.y += 0.1;\n\t\n\tuv.y += (0.2 * sin(uv.x + iTime));\n\twave_width = abs(1.0 / (50.0 * uv.y));\n\twave_color += vec3(wave_width * 3.1*sin(iTime), wave_width , wave_width * 1.5*sin(iTime));\n\t\n\tfinal_color = bg_color + wave_color;\n\t\n\t\n\tfragColor = vec4(final_color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2SW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 530]], "test": "valid"}
{"id": "st2XDW", "name": "Psychedelic tunnel", "author": "SnoopethDuckDuck", "description": "Forked from iq,", "tags": ["procedural", "2d", "noise", "perlin"], "likes": 1, "viewed": 50, "published": "Public", "date": "1627738469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\nconst float tau = 2. * 3.14159;\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec4 colorMap(vec3 a, vec3 b, vec3 c, vec3 d, float t) {\nvec3 col = a + b * vec3(cos(tau * (c.r * t + d.r)),\n                        cos(tau * (c.g * t + d.g)),\n                        cos(tau * (c.b * t + d.b)));\n\nreturn vec4(col.r, col.g, col.b, 1.);\n}\n\nfloat myLength(vec2 uv) {\nreturn max(abs(uv.x),abs(uv.y));\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p* vec2(iResolution.x/iResolution.y,1. + 0.05 * cos(0.1 * iTime)) + iTime*0.0001;\n\tfloat b = 0.5 * (1. + cos(0.25 * iTime));\n    float time = 0.2 * iTime;\n    vec2 uvShift = uv - 0.5 - 0.0001 *iTime;\n    mat2 ma = (4. * iTime + 1.) * mat2( 1.6,  1.2 , -1.2,  1.6 ) \n    * mat2(cos(time),-sin(time),sin(time),cos(time));\n    mat2 ma2 =  (4. * iTime + 30.) * mat2( 1.6,  -1.2, 1.2,  1.6 );\n    uv /= b * myLength(ma * uvShift) + (1.-b) * length(ma * uvShift);\n\tfloat f = 0.0;\n\n\t\tuv = uv * 3.0 + 100.;\n        mat2 m = (1. + 0.01 * noise(uv + 0.04 * iTime) + 0.005 * noise(uv + 0.03 * iTime)) * mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.800*noise( uv / length(uv) ); uv = m*uv;\n\t\tf += 0.100*noise( uv ); uv = m*uv;\n\t\tf += 0.050*noise( uv ); uv = m*uv;\n\t\tf += 0.025*noise( uv ); uv = m*uv;\n        \n     // 0.5 * pow(iTime,10.) -> iTime (or something probably works better)\n\tf = (4. + cos(2. * iTime) * noise(0.001*vec2(iTime,uv.y * uv.x)) *  0.25 * iTime) * f * (1.-f) * f * (1.-f);\n   // f *= length(0.1 * uv);\nvec3 h = vec3(0.5, 0.5, 0.5);\nfloat t = 0.1 * iTime;\nfloat b1 = 0.25 * (1. + cos(t));\nfloat b2 = 0.25 * (1. + cos(t + tau / 3.));\nfloat b3 = 0.25 * (1. + cos(t + 2. * tau / 3.));\nfragColor = colorMap(h, h, h,  vec3(0.4,0.2,0.), f);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2XDW.jpg", "access": "shaders20k", "license": "mit", "functions": [[2053, 2053, 2110, 2110, 2225], [2227, 2227, 2253, 2253, 2732], [2734, 2734, 2790, 2790, 2988], [2990, 2990, 3015, 3015, 3050], [3104, 3104, 3161, 3161, 4459]], "test": "valid"}
{"id": "stB3Rd", "name": "SDF-Develop", "author": "golinad", "description": "For learning and testing sdf rendering", "tags": ["sdf"], "likes": 4, "viewed": 194, "published": "Public API", "date": "1625174799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Uncomment for debug rendering\n//#define COMPLEXITY\n//#define ISOLINES\n//#define CURVATURE\n\nfloat delta = 0.0001;\nfloat delta2 = 0.1;\nfloat maxT = 20.0;\n//vec4 bgColor = vec4(0.25,0.5,0.8,1.0);\nvec4 bgColor = vec4(1.0,1.0,1.0,1.0);\n\n// SDF primitives\n// giving primitives a position makes them easy to use\n// but more complex in calculation and difficult to use with manipulations like extrude\nfloat sdSphere(vec3 pos, float r, in vec3 p) {\n    return distance(p, pos) - r;\n}\nfloat sdBox(vec3 pos, vec3 ext, in vec3 p) {\n// ok for inner part, but sharp outside and too long distance at corners\n// works, but incompatible with rounding\n/*    return max(max(abs(p.x - pos.x) - ext.x/2.0, \n                   abs(p.y - pos.y) - ext.y/2.0),\n                   abs(p.z - pos.z) - ext.z/2.0);*/\n    vec3 q = abs(p-pos) - ext/2.0;\n    return length(max(q,0.0)) + min(max(max(q.x, q.y),q.z),0.0);\n}\nfloat sdTorus(in vec3 p, float r1, float r2) {\n    vec3 c = vec3(normalize(p.xy)*r1, 0.0);\n    return distance(p, c) - r2;\n}\n\n// SDF operations\nfloat sdUnion(float a, float b) {return min(a,b);}\nfloat sdIntersect( float a, float b) {return max(a,b);}\nfloat sdSubstract(float a, float b) {return max(a, -b);}\n\nfloat sdShell(float d, float t) {return abs(d)-t;}\n\nvec3 sdExtrude(vec3 pos, vec3 dir) {\n    return pos - clamp(pos, -0.5*dir, 0.5*dir);\n}\nvec3 sdArray(vec3 pos, vec3 step) {\n    // we dont want the break in the center\n    // the repeaded block should be centered at origin\n    return mod(pos +0.5*step, step) - 0.5*step;\n}\nvec3 sdMirror(vec3 pos) {\n    return abs(pos);\n}\n\nfloat isoLines(float d, float seg) {\n    return mod(d, seg) > seg*0.95 ^^ d < 0.0?1.0:0.0;\n}\n\nfloat map(in vec3 p) {\n    float d1 = sdShell(sdSphere(vec3(0,0,0), 0.5, sdExtrude(sdArray(p-vec3(sin(iTime), cos(iTime), 0.0), vec3(2,2,2)), vec3(0,1,0))), 0.1);\n    float d2 = sdBox(vec3(cos(iTime), sin(iTime), sin(iTime)), vec3(8.0,2.0,12), p) - 1.0;\n    float d = sdSubstract(d1,d2);\n    //d = sdUnion(d, sdTorus(sdMirror(p - vec3(cos(iTime), sin(iTime), sin(iTime)-5.0)) - vec3(3,0,1), 2.0, 1.0));\n    \n    return d;\n}\n\n// calculate normal based on simplified(3 vs. 6 samples) gradient around pos\n// Note: when we are marching solids, d is 0 on surface\nvec3 calcNormal(in vec3 p, in float d) {\n    float dx = map(p + vec3(delta,0,0));\n    float dy = map(p + vec3(0,delta,0));\n    float dz = map(p + vec3(0,0,delta));\n    \n    return normalize(vec3(dx-d, dy-d, dz-d));\n}\n\nfloat calcCurvature(in vec3 p, in float d) {\n    float dx = map(p + vec3(delta2,0,0));\n    float dy = map(p + vec3(0,delta2,0));\n    float dz = map(p + vec3(0,0,delta2));\n    \n    float ndx = map(p + vec3(-delta2,0,0));\n    float ndy = map(p + vec3(0,-delta2,0));\n    float ndz = map(p + vec3(0,0,-delta2));\n    \n    \n    return clamp((dx+dy+dz+ndx+ndy+ndz-6.0*d)/delta2/4.0,-1.0,1.0);\n}\n\nvoid render(out vec4 fragColor, in vec3 ro, in vec3 rd) {\n    float t = 0.0;\n    \n    int j = 0;\n    for(int i = 0; i < 100; i++) {\n        if (t > maxT) {\n            fragColor = bgColor;\n            break;\n        }\n        \n        float d = map(ro+t*rd);\n        if(d < delta || i == 99) {\n            vec3 n = calcNormal(ro+t*rd, d);\n            fragColor = vec4((n*0.5+0.5)*min(calcCurvature(ro+t*rd, d)+1.0, 1.0),1.0);\n#ifdef CURVATURE\n    fragColor = mix(vec4(0,0,1,1), vec4(1,0,0,1), calcCurvature(ro+t*rd, d) *0.5 + 0.5);\n#endif\n            break;\n        } else {\n            t += d;\n        }\n        j++;\n    }\n    // fade to bg (fog)\n    fragColor = mix(fragColor, bgColor, t/maxT);\n    \n#ifdef COMPLEXITY //marching complexity\n    fragColor = mix(vec4(0,0,1,1), vec4(1,0,0,1), float(j)/100.0);\n#endif\n}\n\nvoid debugRender(out vec4 fragColor, in vec2 uv) {\n    float d = map(vec3(uv,0));\n    vec3  n = calcNormal(vec3(uv, 0), d);\n    float l = isoLines(d, 0.1);\n\n    // colored\n    //fragColor = vec4((n*0.5+0.5)*l,1.0);\n    \n    // monochrome\n    fragColor = vec4(l,l,l,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y*2.0;\n    \n#ifdef ISOLINES\n    debugRender(fragColor, uv);\n    //fragColor = vec4(mod(uv, 1.0), 0,1);\n#else\n    vec3 ro = vec3(0,0,1);\n    vec3 rd = normalize(vec3(uv.xy, 0) - ro);\n    render(fragColor, ro , rd);\n#endif\n\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n\n    render(fragColor, fragRayOri, fragRayDir);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stB3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 396, 442, 442, 477], [478, 478, 522, 790, 892], [893, 893, 939, 939, 1017], [1019, 1037, 1070, 1070, 1087], [1088, 1088, 1126, 1126, 1143], [1144, 1144, 1181, 1181, 1200], [1202, 1202, 1235, 1235, 1252], [1254, 1254, 1290, 1290, 1340], [1341, 1341, 1376, 1475, 1525], [1526, 1526, 1551, 1551, 1574], [1670, 1670, 1692, 1692, 2093], [2095, 2228, 2268, 2268, 2444], [2446, 2446, 2490, 2490, 2833], [2835, 2835, 2892, 2892, 3652], [3654, 3654, 3704, 3704, 3926], [3928, 3928, 3985, 4035, 4317], [4319, 4319, 4413, 4413, 4463]], "test": "valid"}
{"id": "stBSRw", "name": "China Pavilion", "author": "greyishsong", "description": "The simplified version of China Pavilion in Shanghai World Expo. This animation roughly shows the pavillion's structure.", "tags": ["3d", "raytracing", "building"], "likes": 3, "viewed": 56, "published": "Public", "date": "1627297477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926536;\nconst float E = 2.7182818285;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 1;\nconst int NUM_MATERIALS = 2;\nconst int NUM_PLANES = 1;\nconst int NUM_PILLARS = 4;\nconst int NUM_BEAMS = 8 * 3;\nconst int NUM_BOXES = NUM_PILLARS * 5 + NUM_BEAMS;\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Box_t {\n    // The maximum point and the minimum point.\n    vec3 maxp, minp;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nBox_t Box[NUM_BOXES];\n\n//============================================================================\n// Constants for constructing the scene.\n//============================================================================\nconst float pillarBias = 0.1;\nconst float pillarWidth = 1.0;\nconst float maxPillarHeight = 3.0;\n\nconst float beamBottomPlane = 2.0;\nconst float beamWidth = 0.3;\nconst float beamLengthBase = 3.0;\nconst float beamLengthInc = 1.2;\nconst float beamCornerRatio = 3.0;\nconst float middleBeamAt[8] = float[8](\n    0.4, 0.3, 0.7, 0.6, 0.5, 0.5, 0.8, 0.4\n);\n\nconst float lightCircleRadius = 8.0;\n\n// A pillar consists of 5 boxes, one silver box inside and four red ones outside.\nvoid makePillar(inout int boxCnt, in vec3 minp, in float height)\n{\n    // The centeral silver box.\n    Box[boxCnt].minp = minp;\n    Box[boxCnt].maxp = vec3(minp.x + pillarWidth, minp.y + height, minp.z + pillarWidth);\n    Box[boxCnt++].materialID = 0;\n\n    // Four surrrounding red boxes.\n    float subWidth = pillarWidth * 0.5;\n    float subTop = minp.y + height + pillarBias;\n    Box[boxCnt].minp = vec3(minp.x - pillarBias, minp.y, minp.z - pillarBias);\n    Box[boxCnt].maxp = vec3(Box[boxCnt].minp.x + subWidth, subTop, Box[boxCnt].minp.z + subWidth);\n    Box[boxCnt++].materialID = 1;\n    Box[boxCnt].minp = vec3(minp.x + subWidth + pillarBias, minp.y, minp.z - pillarBias);\n    Box[boxCnt].maxp = vec3(Box[boxCnt].minp.x + subWidth, subTop, Box[boxCnt].minp.z + subWidth);\n    Box[boxCnt++].materialID = 1;\n    Box[boxCnt].minp = vec3(minp.x - pillarBias, minp.y, minp.z + subWidth + pillarBias);\n    Box[boxCnt].maxp = vec3(Box[boxCnt].minp.x + subWidth, subTop, Box[boxCnt].minp.z + subWidth);\n    Box[boxCnt++].materialID = 1;\n    Box[boxCnt].minp = vec3(minp.x + subWidth + pillarBias, minp.y, minp.z + subWidth + pillarBias);\n    Box[boxCnt].maxp = vec3(Box[boxCnt].minp.x + subWidth, subTop, Box[boxCnt].minp.z + subWidth);\n    Box[boxCnt++].materialID = 1;\n}\n\nvoid makeBeam(inout int boxCnt, in vec3 minp, in float len, in bool alignX)\n{\n    float deltax = alignX? len : beamWidth;\n    float deltaz = alignX? beamWidth : len;\n    Box[boxCnt].minp = minp;\n    Box[boxCnt].maxp = vec3(minp.x + deltax, minp.y + beamWidth, minp.z + deltaz);\n    Box[boxCnt++].materialID = 1;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    float timeBase = 0.5 * (sin(iTime * 0.5) + 1.0);\n    int boxCnt = 0;\n\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Four pillars.\n    float pillarHeight = log(1.0 + timeBase * (E-1.0)) * maxPillarHeight;   // Smooth the movement.\n    makePillar(boxCnt, vec3(-1.5, 0.0, 0.5), pillarHeight);\n    makePillar(boxCnt, vec3(-1.5, 0.0, -1.5), pillarHeight);\n    makePillar(boxCnt, vec3(0.5, 0.0, -1.5), pillarHeight);\n    makePillar(boxCnt, vec3(0.5, 0.0, 0.5), pillarHeight);\n\n    // CrossBeams.\n    // CrossBeams are placed at 8 planes, the `lenBase` is a square on the current\n    // plane used as a reference, the true length of a beam is `len`.\n    // Four beanms are placed around the reference square, with their inside faces\n    // aligned to the square's edge. They are divided into two groups, one aligned\n    // to x axis and another alinged to z axis. The second group is longer.\n    float c = beamCornerRatio;\n    float lenBase = beamLengthBase;\n    float bottom, len;\n    float halfLen = lenBase * 0.5;\n    for (int i = 0; i < 4; ++i) {\n        // The movement of crossbeams are controlled by a cubed sin function,\n        // which slows down the movement when combined with pillars and speeds\n        // up when rising up.\n        bottom = pow(1.0-timeBase, 3.0) * float(i*2) * 1.5 + beamBottomPlane + float(i*2) * beamWidth;\n        lenBase *= beamLengthInc;\n        halfLen = lenBase * 0.5;\n        len = lenBase + beamCornerRatio * beamWidth;\n        c *= 0.5;\n        makeBeam(boxCnt, vec3(-halfLen - c*beamWidth, bottom, -halfLen - beamWidth), len, true);\n        makeBeam(boxCnt, vec3(-halfLen - c*beamWidth, bottom, halfLen), len, true);\n        makeBeam(boxCnt, vec3(-halfLen - c*beamWidth, bottom, -halfLen + middleBeamAt[i*2]*lenBase), len, true);\n\n        bottom = pow(1.0-timeBase, 3.0) * float(i*2+1) * 1.5 + beamBottomPlane + float(i*2+1) * beamWidth;\n        len += beamCornerRatio * beamWidth;\n        c *= 2.0;\n        makeBeam(boxCnt, vec3(-halfLen - beamWidth, bottom, -halfLen - c*beamWidth), len, false);\n        makeBeam(boxCnt, vec3(halfLen, bottom, -halfLen - c*beamWidth), len, false);\n        makeBeam(boxCnt, vec3(-halfLen + middleBeamAt[i*2+1]*lenBase, bottom, -halfLen - c*beamWidth), len, false);\n    }\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Red material.\n    Material[1].k_d = vec3( 0.87, 0.13, 0.13 );\n    Material[1].k_a = 0.6 * Material[1].k_d;\n    Material[1].k_r = 0.6 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 32.0;\n\n    // Light 0.\n    Light[0].position = vec3( lightCircleRadius * cos(iTime*0.1), abs(lightCircleRadius * sin(iTime*0.1)) + 1.0, -3.0 );\n    Light[0].I_a = vec3( 0.2, 0.2, 0.2 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a axis-aligned box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// The normal vector at the intersection will always point outside the box.\n// This functino may work incorrectly when the ray's origin is in the box.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax,\n                  out float t, out vec3 hitPos, out vec3 hitNormal)\n{\n    float tnear, tfar;\n    float t1, t2;\n    vec3 temp_hitNormal;\n    float tnearmax = -tmax - 1.0;\n    float tfarmin = tmax + 1.0;\n    \n    t1 = (box.minp.x - ray.o.x) / ray.d.x;\n    t2 = (box.maxp.x - ray.o.x) / ray.d.x;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n        temp_hitNormal = (t1 < t2)? vec3(-1.0, 0.0, 0.0) : vec3(1.0, 0.0, 0.0);\n    }\n    t1 = (box.minp.y - ray.o.y) / ray.d.y;\n    t2 = (box.maxp.y - ray.o.y) / ray.d.y;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n        temp_hitNormal = (t1 < t2)? vec3(0.0, -1.0, 0.0) : vec3(0.0, 1.0, 0.0);\n    }\n    t1 = (box.minp.z - ray.o.z) / ray.d.z;\n    t2 = (box.maxp.z - ray.o.z) / ray.d.z;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n        temp_hitNormal = (t1 < t2)? vec3(0.0, 0.0, -1.0) : vec3(0.0, 0.0, 1.0);\n    }\n    if (tnearmax < tmin || tnearmax > tmax)\n        return false;\n\n    if (tnearmax < tfarmin) {\n        t = tnearmax;\n        hitPos = ray.o + tnearmax * ray.d;\n        hitNormal = temp_hitNormal;\n        return true;\n    }\n    else\n        return false;\n}\n\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax)\n{\n    float tnear, tfar;\n    float t1, t2;\n    float tnearmax = -tmax - 1.0;\n    float tfarmin = tmax + 1.0;\n    \n    t1 = (box.minp.x - ray.o.x) / ray.d.x;\n    t2 = (box.maxp.x - ray.o.x) / ray.d.x;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n    }\n    t1 = (box.minp.y - ray.o.y) / ray.d.y;\n    t2 = (box.maxp.y - ray.o.y) / ray.d.y;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n    }\n    t1 = (box.minp.z - ray.o.z) / ray.d.z;\n    t2 = (box.maxp.z - ray.o.z) / ray.d.z;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n    }\n    if (tnearmax < tmin || tnearmax > tmax)\n        return false;\n\n    if (tnearmax < tfarmin)\n        return true;\n    else\n        return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from smaxpace point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n        // return vec3(1.0);\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for (int i = 0; i < NUM_PLANES; ++i) {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit) {\n            hasHitSomething = true;\n            if (temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[i].materialID;\n            }\n        }\n    }\n    for (int i = 0; i < NUM_BOXES; ++i) {\n        temp_hasHit = IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit) {\n            hasHitSomething = true;\n            if (temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Box[i].materialID;\n            }\n        }\n    }\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    for (int i = 0; i < NUM_LIGHTS; ++i) {\n        // Make the shadow ray for current light source, the maximum t value represents\n        // the position of light source.\n        Ray_t shadowRay = Ray_t(nearest_hitPos, normalize(Light[i].position - nearest_hitPos));\n        float tmax = distance(Light[i].position, nearest_hitPos);\n        bool inShadow = false;\n        for (int j = 0; j < NUM_PLANES && !inShadow; ++j) {\n            if (IntersectPlane(Plane[j], shadowRay, DEFAULT_TMIN, tmax))\n                inShadow = true;\n        }\n        for (int j = 0; j < NUM_BOXES && !inShadow; ++j) {\n            if (IntersectBox(Box[j], shadowRay, DEFAULT_TMIN, tmax))\n                inShadow = true;\n        }\n        I_local += PhongLighting(shadowRay.d, nearest_hitNormal, -ray.d, inShadow, Material[nearest_hitMatID], Light[i]);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 12.0*sin(iTime*0.2), 4.0, 12.0*cos(iTime*0.2) );\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBSRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3130, 3212, 3278, 3310, 4483], [4485, 4485, 4562, 4562, 4798], [4801, 4983, 5001, 5001, 8043], [8045, 8541, 8695, 8695, 9025], [9027, 9359, 9442, 9442, 9654], [9656, 10150, 10295, 10295, 11617], [11619, 11619, 11696, 11696, 12644], [12646, 13001, 13131, 13131, 13572], [13574, 14363, 14476, 14567, 18324], [18328, 18689, 18746, 18746, 20198]], "test": "valid"}
{"id": "stBSRz", "name": "AntiPod - You Smell Like Cherry", "author": "Flopine", "description": "A shader made as a loop for a track from ThronoCrigger, check out his album!!! \nhttps://thronocrigger.bandcamp.com/album/simulacra", "tags": ["3d", "raymarching", "animation", "isometric"], "likes": 6, "viewed": 100, "published": "Public", "date": "1626904893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.283185\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define BPM (130./60.)\n#define dt(sp,off) fract((iTime+off)*sp)\n#define bouncy(sp,off) sqrt(sin(dt(sp,off)*PI))\n#define animcirc(sp,off) easeInOutCirc(dt(sp,off))\n#define cucubspeed (BPM/2.)\n\nstruct obj\n{\n    float d;\n    vec3 color;\n};\n\nobj min_struct (obj a, obj b)\n{\n    if (a.d<b.d) return a;\n    else return b;\n}\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat easeInOutCirc(float x)\n{\n    return x < 0.5\n        ? (1. - sqrt(1. - pow(2. * x, 2.))) / 2.\n        : (sqrt(1. - pow(-2. * x + 2., 2.)) + 1.) / 2.;\n}\n\nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nobj cucube (vec3 p)\n{\n    float size = 1.,speed = BPM/2.;\n\n    p.xz += 3.;   \n    p.x = abs(p.x)-size*1.1;\n    p.y -= bouncy(speed,0.);\n    p.yz *= rot(animcirc(speed,0.)*PI/2.); \n    float d = box(p,vec3(size));\n    \n    return obj(d,vec3(0.1,0.5,0.9));\n}\n\nobj ground (vec3 p)\n{\n    p.z += (floor(iTime*cucubspeed)+animcirc(cucubspeed,0.))*1.6;\n    p.y += 1.;\n    p.y += sin(p.x*(PI/8.)) * sin(p.x*(PI/6.))*0.8;\n    p.y += cos(p.z*(PI/4.)) * sin(p.z*(PI))*0.1;\n    float dsand = abs(p.y)-0.5;\n    vec3 csand = mix(vec3(0.75,0.8,0.65),vec3(0.6,0.5,0.4),pow(texture(iChannel0,p.xz*0.08).r,7.));\n    obj sand = obj(dsand,clamp(csand,0.,1.));\n    \n    return sand;\n}\n\nobj water (vec3 p)\n{\n    vec3 offset = vec3(-15.+sin(p.z+dt(BPM/4.,0.)*TAU)*0.2,0.,0.); \n    float d = max(abs(p.y)-.5,box(p+offset,vec3(10.,10.,1e10)));\n    return obj(d,vec3(0.4,0.8,0.9));\n}\n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    return min_struct(water(p),min_struct(cucube(p),ground(p)));\n}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv += texNoise(uv*0.05-dt(0.05,0.)).r*0.1;\n\n    vec3 ro = vec3(uv*5.,-30.),rd=vec3(0.,0.,1.),p=ro,col=vec3(0.),l=normalize(vec3(-1.,2.,1.));\n    \n    obj O;\n    for (float i=0.;i<64.;i++)\n    {\n        O = SDF(p);\n        if (O.d<0.01)\n        {\n            break;\n        }\n        p += O.d*rd;\n    }\n    \n    col = mix(vec3(0.8,0.5,0.4),O.color,dot(getnorm(p),l)*.5+.5);\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[692, 692, 723, 723, 771], [773, 900, 924, 924, 1162], [1164, 1164, 1194, 1194, 1320], [1322, 1322, 1350, 1350, 1383], [1385, 1385, 1406, 1406, 1641], [1643, 1643, 1664, 1664, 2048], [2050, 2050, 2070, 2070, 2242], [2244, 2244, 2262, 2262, 2395], [2397, 2397, 2419, 2419, 2541], [2543, 2543, 2600, 2600, 3076]], "test": "error"}
{"id": "stBXRm", "name": "NUS ray tracing", "author": "ShmilyQi", "description": "shanghai", "tags": ["shmilyqi"], "likes": 0, "viewed": 63, "published": "Public", "date": "1627308068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926536;\nconst float E = 2.7182818285;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 1;\nconst int NUM_MATERIALS = 2;\nconst int NUM_PLANES = 1;\nconst int NUM_PILLARS = 4;\nconst int NUM_BEAMS = 8 * 3;\nconst int NUM_BOXES = NUM_PILLARS * 5 + NUM_BEAMS;\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Box_t {\n    // The maximum point and the minimum point.\n    vec3 maxp, minp;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nBox_t Box[NUM_BOXES];\n\n//============================================================================\n// Constants for constructing the scene.\n//============================================================================\nconst float pillarBias = 0.1;\nconst float pillarWidth = 1.0;\nconst float maxPillarHeight = 3.0;\n\nconst float beamBottomPlane = 2.0;\nconst float beamWidth = 0.3;\nconst float beamLengthBase = 3.0;\nconst float beamLengthInc = 1.2;\nconst float beamCornerRatio = 3.0;\nconst float middleBeamAt[8] = float[8](\n    0.4, 0.3, 0.7, 0.6, 0.5, 0.5, 0.8, 0.4\n);\n\nconst float lightCircleRadius = 8.0;\n\n// A pillar consists of 5 boxes, one silver box inside and four red ones outside.\nvoid makePillar(inout int boxCnt, in vec3 minp, in float height)\n{\n    // The centeral silver box.\n    Box[boxCnt].minp = minp;\n    Box[boxCnt].maxp = vec3(minp.x + pillarWidth, minp.y + height, minp.z + pillarWidth);\n    Box[boxCnt++].materialID = 0;\n\n    // Four surrrounding red boxes.\n    float subWidth = pillarWidth * 0.5;\n    float subTop = minp.y + height + pillarBias;\n    Box[boxCnt].minp = vec3(minp.x - pillarBias, minp.y, minp.z - pillarBias);\n    Box[boxCnt].maxp = vec3(Box[boxCnt].minp.x + subWidth, subTop, Box[boxCnt].minp.z + subWidth);\n    Box[boxCnt++].materialID = 1;\n    Box[boxCnt].minp = vec3(minp.x + subWidth + pillarBias, minp.y, minp.z - pillarBias);\n    Box[boxCnt].maxp = vec3(Box[boxCnt].minp.x + subWidth, subTop, Box[boxCnt].minp.z + subWidth);\n    Box[boxCnt++].materialID = 1;\n    Box[boxCnt].minp = vec3(minp.x - pillarBias, minp.y, minp.z + subWidth + pillarBias);\n    Box[boxCnt].maxp = vec3(Box[boxCnt].minp.x + subWidth, subTop, Box[boxCnt].minp.z + subWidth);\n    Box[boxCnt++].materialID = 1;\n    Box[boxCnt].minp = vec3(minp.x + subWidth + pillarBias, minp.y, minp.z + subWidth + pillarBias);\n    Box[boxCnt].maxp = vec3(Box[boxCnt].minp.x + subWidth, subTop, Box[boxCnt].minp.z + subWidth);\n    Box[boxCnt++].materialID = 1;\n}\n\nvoid makeBeam(inout int boxCnt, in vec3 minp, in float len, in bool alignX)\n{\n    float deltax = alignX? len : beamWidth;\n    float deltaz = alignX? beamWidth : len;\n    Box[boxCnt].minp = minp;\n    Box[boxCnt].maxp = vec3(minp.x + deltax, minp.y + beamWidth, minp.z + deltaz);\n    Box[boxCnt++].materialID = 1;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    float timeBase = 0.5 * (sin(iTime * 0.5) + 1.0);\n    int boxCnt = 0;\n\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Four pillars.\n    float pillarHeight = log(1.0 + timeBase * (E-1.0)) * maxPillarHeight;   // Smooth the movement.\n    makePillar(boxCnt, vec3(-1.5, 0.0, 0.5), pillarHeight);\n    makePillar(boxCnt, vec3(-1.5, 0.0, -1.5), pillarHeight);\n    makePillar(boxCnt, vec3(0.5, 0.0, -1.5), pillarHeight);\n    makePillar(boxCnt, vec3(0.5, 0.0, 0.5), pillarHeight);\n\n    // CrossBeams.\n    // CrossBeams are placed at 8 planes, the `lenBase` is a square on the current\n    // plane used as a reference, the true length of a beam is `len`.\n    // Four beanms are placed around the reference square, with their inside faces\n    // aligned to the square's edge. They are divided into two groups, one aligned\n    // to x axis and another alinged to z axis. The second group is longer.\n    float c = beamCornerRatio;\n    float lenBase = beamLengthBase;\n    float bottom, len;\n    float halfLen = lenBase * 0.5;\n    for (int i = 0; i < 4; ++i) {\n        // The movement of crossbeams are controlled by a cubed sin function,\n        // which slows down the movement when combined with pillars and speeds\n        // up when rising up.\n        bottom = pow(1.0-timeBase, 3.0) * float(i*2) * 1.5 + beamBottomPlane + float(i*2) * beamWidth;\n        lenBase *= beamLengthInc;\n        halfLen = lenBase * 0.5;\n        len = lenBase + beamCornerRatio * beamWidth;\n        c *= 0.5;\n        makeBeam(boxCnt, vec3(-halfLen - c*beamWidth, bottom, -halfLen - beamWidth), len, true);\n        makeBeam(boxCnt, vec3(-halfLen - c*beamWidth, bottom, halfLen), len, true);\n        makeBeam(boxCnt, vec3(-halfLen - c*beamWidth, bottom, -halfLen + middleBeamAt[i*2]*lenBase), len, true);\n\n        bottom = pow(1.0-timeBase, 3.0) * float(i*2+1) * 1.5 + beamBottomPlane + float(i*2+1) * beamWidth;\n        len += beamCornerRatio * beamWidth;\n        c *= 2.0;\n        makeBeam(boxCnt, vec3(-halfLen - beamWidth, bottom, -halfLen - c*beamWidth), len, false);\n        makeBeam(boxCnt, vec3(halfLen, bottom, -halfLen - c*beamWidth), len, false);\n        makeBeam(boxCnt, vec3(-halfLen + middleBeamAt[i*2+1]*lenBase, bottom, -halfLen - c*beamWidth), len, false);\n    }\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Red material.\n    Material[1].k_d = vec3( 0.87, 0.13, 0.13 );\n    Material[1].k_a = 0.6 * Material[1].k_d;\n    Material[1].k_r = 0.6 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 32.0;\n\n    // Light 0.\n    Light[0].position = vec3( lightCircleRadius * cos(iTime*0.1), abs(lightCircleRadius * sin(iTime*0.1)) + 1.0, -3.0 );\n    Light[0].I_a = vec3( 0.2, 0.2, 0.2 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a axis-aligned box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// The normal vector at the intersection will always point outside the box.\n// This functino may work incorrectly when the ray's origin is in the box.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax,\n                  out float t, out vec3 hitPos, out vec3 hitNormal)\n{\n    float tnear, tfar;\n    float t1, t2;\n    vec3 temp_hitNormal;\n    float tnearmax = -tmax - 1.0;\n    float tfarmin = tmax + 1.0;\n    \n    t1 = (box.minp.x - ray.o.x) / ray.d.x;\n    t2 = (box.maxp.x - ray.o.x) / ray.d.x;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n        temp_hitNormal = (t1 < t2)? vec3(-1.0, 0.0, 0.0) : vec3(1.0, 0.0, 0.0);\n    }\n    t1 = (box.minp.y - ray.o.y) / ray.d.y;\n    t2 = (box.maxp.y - ray.o.y) / ray.d.y;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n        temp_hitNormal = (t1 < t2)? vec3(0.0, -1.0, 0.0) : vec3(0.0, 1.0, 0.0);\n    }\n    t1 = (box.minp.z - ray.o.z) / ray.d.z;\n    t2 = (box.maxp.z - ray.o.z) / ray.d.z;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n        temp_hitNormal = (t1 < t2)? vec3(0.0, 0.0, -1.0) : vec3(0.0, 0.0, 1.0);\n    }\n    if (tnearmax < tmin || tnearmax > tmax)\n        return false;\n\n    if (tnearmax < tfarmin) {\n        t = tnearmax;\n        hitPos = ray.o + tnearmax * ray.d;\n        hitNormal = temp_hitNormal;\n        return true;\n    }\n    else\n        return false;\n}\n\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax)\n{\n    float tnear, tfar;\n    float t1, t2;\n    float tnearmax = -tmax - 1.0;\n    float tfarmin = tmax + 1.0;\n    \n    t1 = (box.minp.x - ray.o.x) / ray.d.x;\n    t2 = (box.maxp.x - ray.o.x) / ray.d.x;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n    }\n    t1 = (box.minp.y - ray.o.y) / ray.d.y;\n    t2 = (box.maxp.y - ray.o.y) / ray.d.y;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n    }\n    t1 = (box.minp.z - ray.o.z) / ray.d.z;\n    t2 = (box.maxp.z - ray.o.z) / ray.d.z;\n    tnear = min(t1, t2);\n    tfar = max(t1, t2);\n    tfarmin = min(tfarmin, tfar);\n    if (tnear > tnearmax) {\n        tnearmax = tnear;\n    }\n    if (tnearmax < tmin || tnearmax > tmax)\n        return false;\n\n    if (tnearmax < tfarmin)\n        return true;\n    else\n        return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from smaxpace point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n        // return vec3(1.0);\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for (int i = 0; i < NUM_PLANES; ++i) {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit) {\n            hasHitSomething = true;\n            if (temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[i].materialID;\n            }\n        }\n    }\n    for (int i = 0; i < NUM_BOXES; ++i) {\n        temp_hasHit = IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit) {\n            hasHitSomething = true;\n            if (temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Box[i].materialID;\n            }\n        }\n    }\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    for (int i = 0; i < NUM_LIGHTS; ++i) {\n        // Make the shadow ray for current light source, the maximum t value represents\n        // the position of light source.\n        Ray_t shadowRay = Ray_t(nearest_hitPos, normalize(Light[i].position - nearest_hitPos));\n        float tmax = distance(Light[i].position, nearest_hitPos);\n        bool inShadow = false;\n        for (int j = 0; j < NUM_PLANES && !inShadow; ++j) {\n            if (IntersectPlane(Plane[j], shadowRay, DEFAULT_TMIN, tmax))\n                inShadow = true;\n        }\n        for (int j = 0; j < NUM_BOXES && !inShadow; ++j) {\n            if (IntersectBox(Box[j], shadowRay, DEFAULT_TMIN, tmax))\n                inShadow = true;\n        }\n        I_local += PhongLighting(shadowRay.d, nearest_hitNormal, -ray.d, inShadow, Material[nearest_hitMatID], Light[i]);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 12.0*sin(iTime*0.2), 4.0, 12.0*cos(iTime*0.2) );\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3130, 3212, 3278, 3310, 4483], [4485, 4485, 4562, 4562, 4798], [4801, 4983, 5001, 5001, 8043], [8045, 8541, 8695, 8695, 9025], [9027, 9359, 9442, 9442, 9654], [9656, 10150, 10295, 10295, 11617], [11619, 11619, 11696, 11696, 12644], [12646, 13001, 13131, 13131, 13572], [13574, 14363, 14476, 14567, 18324], [18328, 18689, 18746, 18746, 20198]], "test": "valid"}
{"id": "stBXRz", "name": "Noise2d (1)", "author": "SteelFlame", "description": "noise in two dimensions", "tags": ["2d", "noise"], "likes": 1, "viewed": 33, "published": "Public", "date": "1626909220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smoothh(float x) {\n    return x*x*x*(x*(x*6.0-15.0)+10.0);\n    return -2.0*x*x*x+3.0*x*x;\n}\nfloat lerp1d(float a, float b, float t) {\n    return a+(b-a)*t;\n}\nvec2 lerp(vec2 a, vec2 b, float t) {\n    return a+(b-a)*t;\n}\nfloat clamp01(float x) {\n    if (x>1.0) return 1.0;\n    if (x<0.0) return 0.0;\n    return x;\n}\nfloat frac(float x) {\n    return x-floor(x);\n}\nfloat random(vec2 uv) {\n    return frac(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453123);\n}\nvec2 getVector(vec2 x) {\n    return normalize(vec2(-1.0+random(x)*2.0,-1.0+random(x*100.0)*2.0));\n    int index = int(round(random(x)*3.0));\n    switch (index) {\n        case 0:\n            return vec2(1,0);\n        case 1:\n            return vec2(0,1);\n        case 2:\n            return vec2(-1,0);\n        case 3:\n            return vec2(0,-1);\n    }\n}\nfloat noise(vec2 x) {\n    vec2 xInEdge = floor(x);\n    vec2 localX = vec2(frac(x.x),frac(x.y));\n    \n    vec2 leftTopSide = vec2(xInEdge+vec2(0,0));\n    vec2 rightTopSide = vec2(xInEdge+vec2(1,0));\n    vec2 leftBottomSide = vec2(xInEdge+vec2(0,1));\n    vec2 rightBottomSide = vec2(xInEdge+vec2(1,1));\n    \n    vec2 leftTopVector = getVector(leftTopSide);\n    vec2 rightTopVector = getVector(rightTopSide);\n    vec2 leftBottomVector = getVector(leftBottomSide);\n    vec2 rightBottomVector = getVector(rightBottomSide);\n    \n    vec2 dirToLeftTop = x-leftTopSide;\n    vec2 dirToRightTop = x-rightTopSide;\n    vec2 dirToLeftBottom = x-leftBottomSide;\n    vec2 dirToRightBottom = x-rightBottomSide;\n    \n    float dot1 = dot(dirToLeftTop,(leftTopVector));\n    float dot2 = dot(dirToRightTop,(rightTopVector));\n    float dot3 = dot(dirToLeftBottom,(leftBottomVector));\n    float dot4 = dot(dirToRightBottom,(rightBottomVector));\n    \n    localX.x = smoothh(localX.x);\n    localX.y = smoothh(localX.y);\n    \n    return lerp1d(lerp1d(dot1,dot2,localX.x),lerp1d(dot3,dot4,localX.x),localX.y);\n}\n\nfloat fbm(vec2 uv, float startFrequency, float startIntensity, int octavesCount, float persistance) {\n    float freq = startFrequency;\n    float intens = startIntensity;\n    float v = 0.;\n    for (int i = 0; i < octavesCount; i++) {\n        v += noise(uv*freq)*intens;\n        freq *= 2.;\n        intens *= persistance;\n    }\n    return v/float(octavesCount);\n}\n\nvec2 offset = vec2(0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    offset += iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float v = fbm(uv+offset+vec2(iTime*.1,0),15.,1.,1,1.2);//noise(uv*6.0+vec2(iTime*5.0,0));\n    fragColor = vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 97], [98, 98, 139, 139, 163], [164, 164, 200, 200, 224], [225, 225, 249, 249, 319], [320, 320, 341, 341, 366], [367, 367, 390, 390, 458], [459, 459, 483, 483, 814], [815, 815, 836, 836, 1901], [1903, 1903, 2004, 2004, 2264], [2289, 2289, 2346, 2346, 2548]], "test": "valid"}
{"id": "stBXzD", "name": "Fractal 67_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 4, "viewed": 190, "published": "Public API", "date": "1627189804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,a=normalize(vec3(1,2,3)),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.8;\n        ++i<100.;\n        O.xyz+=mix(vec3(1),H(cos(log(s)))*.5,.8)*.05*exp(-.5*e*i*i)\n    )\n    {\n        p=g*d;\n        p.z+=iTime*.5;\n        s=4.;\n        vec4 q=vec4(p,.05);\n        q.xyw=R(q.xyw,a,2.+iTime*.05);\n        q.xzw=R(q.xzw,a,.5+cos(iTime*.05));\n        q.zyw=R(q.zyw,a,1.+sin(iTime*.05));\n        \n        for(int i;i++<8;)\n            q=mod(q-1.,2.)-1.,\n            s*=e=1.2/dot(q,q)-.04,\n            q*=e;\n        g+=e=length(q-clamp(q,-.5,.5))/s+5e-4;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 760]], "test": "valid"}
{"id": "stBXzw", "name": "Triple Gyroid", "author": "Kamoshika", "description": "I combined three gyroids.\nThis is also an exercise in lighting for me.", "tags": ["raymarching", "reflection", "gyroid"], "likes": 12, "viewed": 216, "published": "Public", "date": "1627463706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 lightDir = normalize(vec3(-1, 2, 4));\nconst float lightPower = 20.0;\nconst vec3 lightColor = vec3(1, 1, 1) * lightPower;\nconst vec3 ambColor = vec3(1, 1, 1) * 0.2;\nconst float fogDensity = 0.05;\nconst float metal = 0.8;\nconst float f0 = 0.8;\nconst float fov = 80.;\n\nconst float PI = acos(-1.0);\nconst float PI2 = acos(-1.0) * 2.0;\n\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nfloat sdGyroid(vec3 p) {\n    return dot(sin(p), cos(p.yzx)) + 1.3;\n}\n\nfloat map(vec3 p) {\n    float d = sdGyroid(p);\n    d = min(d, sdGyroid(p + vec3(PI, 0, 0)));\n    d = min(d, sdGyroid(p + vec3(PI, PI, 0)));\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                          map(p+e.yxy)-map(p-e.yxy),\n                          map(p+e.yyx)-map(p-e.yyx)\n                          ));\n}\n\nfloat calcAO(vec3 rPos, vec3 ray) {\n    float totao = 0.;\n    float sca = 1.;\n    for(int i=0; i<10; i++) {\n        float hr = 0.01 + 0.02 * float(i*i);\n        vec3 aoPos = rPos + ray * hr;\n        float dd = map(aoPos);\n        float ao = clamp(hr - dd, 0., 1.);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n    const float aoCoef = 0.5;\n    return 1. - clamp(aoCoef * totao, 0., 1.);\n}\n\nfloat calcShadow(vec3 rPos, vec3 ray) {\n    float h = 0.;\n    float c = 0.001;\n    float r = 1.;\n    float shadowCoef = 0.5;\n    for(int t = 0; t<10; t++) {\n        h = map(rPos + ray * c);\n        if(h < 0.001) {\n            return shadowCoef;\n        }\n        r = min(r, h*16.0/c);\n        c += h;\n    }\n    return 1.0 - shadowCoef + r * shadowCoef;\n}\n\nvec3 objColor(vec3 p) {\n    vec3 col = vec3(0);\n    float th = 0.5;\n    if(sdGyroid(p) < th) {\n        col = vec3(1.0, 0.1, 0.1);\n    } else if(sdGyroid(p + vec3(PI, 0, 0)) < th) {\n        col = vec3(0.1, 1.0, 0.1);\n    } else if(sdGyroid(p + vec3(PI, PI, 0)) < th) {\n        col = vec3(0.1, 0.1, 1.0);\n    }\n    return col;\n}\n\nfloat fresnelSchlick(float f0, float cosTheta) {\n    return f0 + (1. - f0) * pow(1. - cosTheta, 5.);\n}\n\nfloat exp2InvFog(float dist, float density) {\n    float s = dist * density;\n    return exp(-s*s);\n}\n\nvec3 acesFilm(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0., 1.);\n}\n\nvec3 raymarching(inout vec3 rPos, inout vec3 ray, in int itr, inout bool hit, inout vec3 refAtt) {\n    vec3 col = vec3(0);\n    hit = false;\n    float d = 0.;\n    \n    vec3 rPos0 = rPos;\n    for(int i=0; i<100; i++) {\n        if(i >= itr) break;\n        d = map(rPos);\n        if(abs(d) < 1e-4) {\n            hit = true;\n            break;\n        }\n        rPos += ray * d;\n    }\n    \n    vec3 albedo = objColor(rPos);\n    vec3 normal = calcNormal(rPos);\n    vec3 ref = reflect(ray, normal);\n    float diff = max(dot(normal, lightDir), 0.);\n    float spec = pow(max(dot(reflect(lightDir, normal), ray), 0.), 10.);\n    float ao = calcAO(rPos, normal);\n    float shadow = calcShadow(rPos + normal * 0.005, lightDir); // memo: No shadow.\n\n    col += albedo * diff * shadow * (1. - metal) * lightColor;\n    col += albedo * spec * shadow * metal * lightColor;\n    col += albedo * ao * ambColor;\n\n    float invFog = exp2InvFog(distance(rPos0, rPos), fogDensity);\n    col = mix(vec3(1), col, invFog);\n\n    refAtt *= albedo * fresnelSchlick(f0, dot(ref, normal)) * invFog;\n    rPos += 0.01 * normal;\n    ray = ref;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 col = vec3(0);\n    \n    vec3 cPos = vec3(0, 0, -fract(iTime/PI2)*PI2);\n    vec3 cDir = normalize(vec3(0, 0, -1));\n    vec3 cSide = normalize(cross(cDir, vec3(0, 1, 0)));\n    vec3 cUp = normalize(cross(cSide, cDir));\n    \n    vec3 ray = normalize(uv.x*cSide + uv.y*cUp + cDir/tan(fov / 360. * PI));\n    ray *= rotate3D(iTime * 0.07 * PI, vec3(5,3,1));\n    \n    vec3 rPos = cPos;\n    bool hit = false;\n    vec3 refAtt = vec3(1);\n    \n    col += raymarching(rPos, ray, 100, hit, refAtt);\n    \n    for(int i=0; i<2; i++) {\n        //if(!hit) break;\n        col += refAtt * raymarching(rPos, ray, 50, hit, refAtt);\n    }\n    \n    col = acesFilm(col * 0.8);\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 343, 381, 381, 790], [792, 792, 816, 816, 860], [862, 862, 881, 881, 1017], [1019, 1019, 1044, 1044, 1263], [1265, 1265, 1300, 1300, 1662], [1664, 1664, 1703, 1703, 2018], [2020, 2020, 2043, 2043, 2346], [2348, 2348, 2396, 2396, 2450], [2452, 2452, 2497, 2497, 2551], [2553, 2553, 2576, 2576, 2777], [2779, 2779, 2877, 2877, 3908], [3910, 3910, 3967, 3967, 4786]], "test": "error"}
{"id": "stfSR7", "name": "Cubic Bezier Analytic OBB (2D)", "author": "fizzer", "description": "Finding an oriented bounding box for a cubic Bezier curve using Principle Component Analysis - the eigenvectors of the covariance of the Bezier curve point coordinates are used as axes for the bounding box (without actually sampling the Bezier curve).", "tags": ["2d", "bezier", "cubic", "boundingbox", "obb", "oriented"], "likes": 19, "viewed": 398, "published": "Public", "date": "1625350996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// An attempt to use Principle Component Analysis to analytically calculate an oriented bounding box for\n// a cubic Bezier curve.\n\n// It's not the minimal-area OBB but it seems to generally have lower area than an AABB.\n// The circle indicator in the lower-left of the frame shows green when the OBB has less area\n// than the AABB and otherwise shows red.\n\n// The main reason this is suboptimal is probably that the moments are computed directly from the curve\n// parameterised by t, rather than by length.\n\n\nfloat binomialCoefficient(int n, int k)\n{\n    // Using the multiplicative formula\n    // https://en.wikipedia.org/wiki/Binomial_coefficient#Multiplicative_formula\n    float c = 1.;\n    for(int i = 1; i <= k; ++i)\n        c *= float(n + 1 - i) / float(i);\n    return c;\n}\n\n// https://en.wikipedia.org/wiki/B%C3%A9zier_curve\nvec2 explicitBezier(in vec2 control_points[4], float t)\n{\n    vec2 sum = vec2(0);\n    for(int i = 0; i <= 3; ++i)\n    {\n        sum += float(binomialCoefficient(3, i)) *\n            \tpow(1. - t, float(3 - i)) * pow(t, float(i)) * control_points[i];\n    }\n\n    return sum;\n}\n\n// Exact BBox to a cubic bezier\n// From IQ: https://www.shadertoy.com/view/XdVBWd\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    // extremes\n    vec2 mi = min(p0,p3);\n    vec2 ma = max(p0,p3);\n\n    vec2 k0 = -1.0*p0 + 1.0*p1;\n    vec2 k1 =  1.0*p0 - 2.0*p1 + 1.0*p2;\n    vec2 k2 = -1.0*p0 + 3.0*p1 - 3.0*p2 + 1.0*p3;\n\n    vec2 h = k1*k1 - k0*k2;\n\n    if( h.x>0.0 )\n    {\n        h.x = sqrt(h.x);\n        //float t = (-k1.x - h.x)/k2.x;\n        float t = k0.x/(-k1.x-h.x);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;\n            mi.x = min(mi.x,q);\n            ma.x = max(ma.x,q);\n        }\n        //t = (-k1.x + h.x)/k2.x;\n        t = k0.x/(-k1.x+h.x);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;\n            mi.x = min(mi.x,q);\n            ma.x = max(ma.x,q);\n        }\n    }\n\n    if( h.y>0.0)\n    {\n        h.y = sqrt(h.y);\n        //float t = (-k1.y - h.y)/k2.y;\n        float t = k0.y/(-k1.y-h.y);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;\n            mi.y = min(mi.y,q);\n            ma.y = max(ma.y,q);\n        }\n        //t = (-k1.y + h.y)/k2.y;\n        t = k0.y/(-k1.y+h.y);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;\n            mi.y = min(mi.y,q);\n            ma.y = max(ma.y,q);\n        }\n    }\n   \n    return vec4( mi, ma );\n}\n\nbool computeTransformation(in vec2 control_points[4], out vec2 translation, out mat2 rotation)\n{\n    // Set p0 to zero, to simplify computation\n    vec2 p1 = control_points[1] - control_points[0];\n    vec2 p2 = control_points[2] - control_points[0];\n    vec2 p3 = control_points[3] - control_points[0];\n    \n    // Polynomial coefficients of Bezier curve B(t)\n    vec2 a = 3. * (p1 - p2) + p3;\n    vec2 c = 3. * p1;\n    vec2 b = 3. * p2 - 2. * c;\n   \n    // Expected value, E[B] = mean of points along Bezier curve\n    vec2 mu = a / 4. + b / 3. + c / 2.;\n\n    // Polynomial coefficients of Bx(t)By(t)\n    float axy = a.x * a.y;\n    float bxy = a.x * b.y + b.x * a.y;\n    float cxy = a.x * c.y + b.x * b.y + c.x * a.y;\n    float dxy = b.x * c.y + c.x * b.y;\n    float exy = c.x * c.y;\n    \n    // Polynomial coefficients of Bx(t)Bx(t) and By(t)By(t)\n    vec2 aB = a * a;\n    vec2 bB = a * b * 2.;\n    vec2 cB = a * c * 2. + b * b;\n    vec2 dB = b * c * 2.;\n    vec2 eB = c * c;\n    \n    // Definite integrals of polynomials p(1) - p(0)\n    float xy =  axy / 7. +  bxy / 6. +  cxy / 5. +  dxy / 4. +  exy / 3.; // E[BxBy]\n    \n    float xx = aB.x / 7. + bB.x / 6. + cB.x / 5. + dB.x / 4. + eB.x / 3.; // E[BxBx]\n    float yy = aB.y / 7. + bB.y / 6. + cB.y / 5. + dB.y / 4. + eB.y / 3.; // E[ByBy]\n\n    // Covariance matrix\n    mat2 covariance;\n    covariance[1][0] = covariance[0][1] = xy - mu.x * mu.y;\n    covariance[0][0] = xx - mu.x * mu.x;\n    covariance[1][1] = yy - mu.y * mu.y;\n    \n    // Characteristic polynomial of covariance matrix\n    float eigen_a = 1.;\n    float eigen_b = -(covariance[0][0] + covariance[1][1]);\n    float eigen_c = covariance[0][0] * covariance[1][1] - covariance[1][0] * covariance[0][1];\n \n    float discr = eigen_b * eigen_b - 4. * eigen_a * eigen_c;\n    \n    if(discr > 0.)\n    {\n        float sqrt_discr = sqrt(discr);\n        \n        // Eigenvalues of covariance matrix\n        float lambda0 = (-eigen_b - sqrt_discr) / (2. * eigen_a);\n        float lambda1 = (-eigen_b + sqrt_discr) / (2. * eigen_a);\n\n        // Eigenvectors of covariance matrix\n        vec2 eigenvector0 = vec2(covariance[1][0], lambda0 - covariance[0][0]);\n        vec2 eigenvector1 = vec2(covariance[1][0], lambda1 - covariance[0][0]);\n\n        rotation[0] = normalize(eigenvector0);\n        rotation[1] = normalize(eigenvector1);        \n\n        translation = mu + control_points[0];\n        return true;\n    }\n    \n    return false;\n}\n\nbool getCubicBezierOBB(in vec2 control_points[4], out vec2 box_points[4])\n{\n    vec2 translation;\n    mat2 rotation;\n    \n    bool res = computeTransformation(control_points, translation, rotation);\n    \n    if(!res)\n        return false;\n        \n    // Transform the Bezier control points into the local space of the OBB\n    vec2 control_points_xfrm[4];\n    for(int i = 0; i <= 3; ++i)\n    {\n        control_points_xfrm[i] = control_points[i] - translation;\n        control_points_xfrm[i] = transpose(rotation) * control_points_xfrm[i];\n    }\n    \n    // Get axis-aligned bounding box in local space\n    vec4 b2_xfrm = bboxBezier(control_points_xfrm[0], control_points_xfrm[1],\n                              control_points_xfrm[2], control_points_xfrm[3]);\n    \n    // Transform AABB back to worldspace\n    box_points[0] = b2_xfrm.xy;\n    box_points[1] = vec2(b2_xfrm.x, b2_xfrm.w);\n    box_points[2] = b2_xfrm.zw;\n    box_points[3] = vec2(b2_xfrm.z, b2_xfrm.y);\n    \n    for(int i = 0; i < 4; ++i)\n        box_points[i] = rotation * box_points[i] + translation;\n    \n    return true;\n}\n\n\n// Distance to line segment\nfloat segment(vec2 p, vec2 a, vec2 b)\n{\n    return distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a, b - a), 0., 1.)));\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    return (m.x > 0.0) ? length(q) : m.y; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * 2.;\n\n    // Control points\n    vec2 control_points[4];\n    \n    // Generate control points\n    // Control points animation from: https://www.shadertoy.com/view/XdVBWd\n    {\n        float time = iTime*0.5 - 0.7;\n        vec2 p0 = 0.8*sin( time*0.7 + vec2(3.0,1.0) );\n        vec2 p1 = 0.8*sin( time*1.1 + vec2(0.0,6.0) );\n        vec2 p2 = 0.8*sin( time*1.3 + vec2(4.0,2.0) );\n        vec2 p3 = 0.8*sin( time*1.5 + vec2(1.0,5.0) );\n\n        control_points[0] = p0;\n        control_points[1] = p1;\n        control_points[2] = p2;\n        control_points[3] = p3;\n    }\n    \n    // Get the Bezier AABB\n    vec4 aabb = bboxBezier( control_points[0], control_points[1],\n                            control_points[2], control_points[3]);\n\n    float aabb_area = (aabb.z - aabb.x) * (aabb.w - aabb.y);\n\n    vec2 obb_points[4];\n    \n    // Get the Bezier OBB\n    getCubicBezierOBB(control_points, obb_points);\n\n    float obb_area = distance(obb_points[1], obb_points[0]) *\n                     distance(obb_points[1], obb_points[2]);\n\n\n    vec4 col = vec4(0);\n\n    col = vec4(.07, .07, .07, 1.);\n    \n    const int m = 32;\n    \n    float dist = 1e4;\n    \n    // Basic and slow method of evaluating distance to Bezier.\n    {\n        vec2 prevp;\n        for(int i = 0; i <= m; ++i)\n        {\n            float t = float(i) / float(m);\n            vec2 p;\n\n            p = explicitBezier(control_points, t);\n\n            if(i > 0)\n                dist = min(dist, segment(uv, prevp, p));\n\n            prevp = p;\n        }\n    }\n        \n    // Draw control edges\n    for(int i = 0; i < 3; ++i)\n    {\n        col = mix(vec4(.25, .25, .25, 1), col, smoothstep(.002, .004,\n                segment(uv, control_points[i], control_points[i + 1])));\n    }\n    \n    // Draw Bezier curve\n\tcol = mix(vec4(1, .2, .2, .2), col, smoothstep(.004, .006, dist));\n    \n    // Draw AABB\n    float d = sdBox( uv-(aabb.xy+aabb.zw)*0.5, (aabb.zw-aabb.xy)*0.5 );\n    col = mix( col, vec4(0.1,0.3,1.0,1), 1.0-smoothstep(0.003,0.005,abs(d)) );\n    \n    // Draw control points\n    for(int i = 0; i <= 3; ++i)\n       col = mix(vec4(1), col, smoothstep(.02, .023, distance(uv, control_points[i])));\n    \n    // Draw area indicator\n    col = mix((obb_area < aabb_area) ? vec4(0,1,0,1) : vec4(1,0,0,1), col,\n                    smoothstep(.1, .11, distance(uv, vec2(-1.5,-.7))));\n\n#if 0\n    // Enable this code to see a brute-force calculated minimal OBB.\n    {\n        vec2 translation;\n        mat2 rotation;\n\n        bool res = computeTransformation(control_points, translation, rotation);\n\n        vec2 box_points_bf[4];\n        float min_area = 1e9;\n        int n = 512;\n        for(int i = 0; i < n; ++i)\n        {\n            vec2 box_points[4];\n            \n            float th = float(i) / float(n) * 3.14159265359 * 2.;\n            rotation[0] = vec2(cos(th), sin(th));\n            rotation[1] = rotation[0].yx * vec2(-1, 1);\n            \n            // Transform the Bezier control points into the local space of the OBB\n            vec2 control_points_xfrm[4];\n            for(int i = 0; i <= 3; ++i)\n            {\n                control_points_xfrm[i] = control_points[i] - translation;\n                control_points_xfrm[i] = rotation * control_points_xfrm[i];\n            }\n\n            // Get axis-aligned bounding box in local space\n            vec4 b2_xfrm = bboxBezier(control_points_xfrm[0], control_points_xfrm[1],\n                                      control_points_xfrm[2], control_points_xfrm[3]);\n\n            // Transform AABB back to worldspace\n            box_points[0] = b2_xfrm.xy;\n            box_points[1] = vec2(b2_xfrm.x, b2_xfrm.w);\n            box_points[2] = b2_xfrm.zw;\n            box_points[3] = vec2(b2_xfrm.z, b2_xfrm.y);\n\n            for(int i = 0; i < 4; ++i)\n                box_points[i] = transpose(rotation) * box_points[i] + translation;\n                \n            float box_area = distance(box_points[1], box_points[0]) *\n                             distance(box_points[1], box_points[2]);\n                             \n            if(box_area < min_area)\n            {\n                min_area = box_area;\n                box_points_bf = box_points;\n            }\n        }\n        \n        // Draw brute-force OBB\n        col = mix(vec4(1,1,0,1), col, smoothstep(.004, .006, segment(uv, box_points_bf[0], box_points_bf[1])));\n        col = mix(vec4(1,1,0,1), col, smoothstep(.004, .006, segment(uv, box_points_bf[1], box_points_bf[2])));\n        col = mix(vec4(1,1,0,1), col, smoothstep(.004, .006, segment(uv, box_points_bf[2], box_points_bf[3])));\n        col = mix(vec4(1,1,0,1), col, smoothstep(.004, .006, segment(uv, box_points_bf[3], box_points_bf[0])));\n\n    }\n#endif\n\n    // Draw OBB\n    col = mix(vec4(1,0,1,1), col, smoothstep(.004, .006, segment(uv, obb_points[0], obb_points[1])));\n    col = mix(vec4(1,0,1,1), col, smoothstep(.004, .006, segment(uv, obb_points[1], obb_points[2])));\n    col = mix(vec4(1,0,1,1), col, smoothstep(.004, .006, segment(uv, obb_points[2], obb_points[3])));\n    col = mix(vec4(1,0,1,1), col, smoothstep(.004, .006, segment(uv, obb_points[3], obb_points[0])));\n\n    fragColor = vec4(sqrt(col.rgb), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[510, 510, 551, 672, 780], [782, 833, 890, 890, 1106], [1108, 1190, 1256, 1272, 2793], [2795, 2795, 2891, 2938, 5243], [5245, 5245, 5320, 5320, 6333], [6336, 6364, 6403, 6403, 6494], [6496, 6496, 6534, 6534, 6653], [6655, 6655, 6712, 6712, 11941]], "test": "valid"}
{"id": "stfSWN", "name": "ð´ Circular ð´", "author": "icylavah", "description": "A bunch of rotating arcs\nRendered: https://twitter.com/icylavah/status/1413845208052031493", "tags": ["raymarching"], "likes": 6, "viewed": 223, "published": "Public API", "date": "1625922030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON (0.001)\n#define MAX_DEPTH (1000.0)\n#define MIN_DEPTH (EPSILON * 2.0)\n#define RINGS (20)\n#define PI (3.14159265359)\n#define TAU (PI * 2.0)\n#define LINE_THICKNESS (0.012)\n\nvec3 rgb2lab(vec3 c);\nvec3 lab2rgb(vec3 c);\n\n// https://gist.github.com/onedayitwillmake/3288507\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nvec3 pointMultiply(vec3 point, mat4 matrix) {\n    return (matrix * vec4(point, 0.0)).xyz;\n}\n\nfloat sphereSDF(vec3 point) {\n    return length(point) - 0.2;\n}\n\nfloat arcSDF(vec3 point, float radius, float angle1, float angle2) {\n    point = pointMultiply(point, rotationX(radians(30.0)));\n    float sizeD = LINE_THICKNESS;\n    float angle = mod(atan(point.z, point.x), TAU);\n    if(angle1 > angle2) angle2 += TAU;\n    if(angle1 > angle) angle += TAU;\n    if(angle >= angle1 && angle <= angle2) {\n        return min(\n            length(vec3(cos(angle1), 0.0, sin(angle1)) * radius - point) - sizeD,\n            length(vec3(cos(angle2), 0.0, sin(angle2)) * radius - point) - sizeD\n        );\n    }\n    float r = radius;\n    return length(normalize(vec3(point.x, 0.0, point.z)) * r - point) - sizeD;\n}\n\nfloat sceneSDF(vec3 point) {\n    float dist = MAX_DEPTH;\n    \n    for(int i = 0; i < RINGS; i++) {\n        float angle1 = fract(iTime * 1.0 - float(i) / float(RINGS) * 2.0) * TAU;\n        float angle2 = mod(angle1 + PI * 0.75, TAU);\n        dist = min(dist, arcSDF(point, 1.0 + float(i) / 10.0, angle1, angle2));\n    }\n    \n    point = pointMultiply(point, rotationX(radians(30.0)));\n    point = pointMultiply(point, rotationY(-TAU * iTime / 32.0));\n    point = (fract(point * 0.05) / 0.05) - 10.0;\n    dist = min(dist, sphereSDF(point));\n    \n    return dist;\n}\n\n#define C1 (rgb2lab(vec3(0.3, 0.7, 0.8)))\n#define C2 (rgb2lab(vec3(0.9, 0.2, 0.4)))\n#define C3 (rgb2lab(vec3(0.3, 0.5, 0.6)))\nvec3 colorField(vec3 point) {\n    float lerp = length(pointMultiply(point, rotationX(radians(30.0))).xz);\n    lerp = (lerp - 1.0) / (float(RINGS - 1) / 10.0);\n    lerp = max(0.0, lerp);\n    if(lerp > 1.1) return lab2rgb(C3);\n    lerp = pow(lerp, 1.0);\n    return lab2rgb(C1 * (1.0 - lerp) + C2 * lerp);\n}\n\nfloat march(vec3 from, vec3 dir) {\n    float depth = MIN_DEPTH;\n    for(int i = 0; i < 256; i++) {\n        float nearest = sceneSDF(from + dir * depth);\n        if(nearest < EPSILON) return depth;\n        depth += nearest;\n        if(depth > MAX_DEPTH) return MAX_DEPTH;\n    }\n    return depth;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = vec3(0.0, -0.35, 10.0);\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float depth = march(pos, dir);\n    float upness = smoothstep(-0.3, 0.3, dot(dir, vec3(0.0, 1.0, 0.0)));\n    vec3 background = vec3(0.1, 0.0, 0.2);\n    if(depth > MAX_DEPTH - EPSILON) {\n        fragColor = vec4(pow(background, vec3(2.2)), 1.0);\n        return;\n    }\n    vec3 hitPos = pos + dir * depth;\n    //vec3 lightPos = vec3(cos(iTime * 6.28 / 2.0) * 4.5, sin(iTime * 6.28 / 2.0) * 4.5, 1.0);\n    //vec3 color = background * 0.5;\n    //color += vec3(0.98, 0.1, 0.4);\n    vec3 color = colorField(hitPos);\n    fragColor = vec4(pow(color, vec3(2.2)), 1.0);\n}\n\n\n//CIE L*a*b* (CIELAB, L* for lightness, a* from green to red, b* from blue to yellow)\n//Source: https://gist.github.com/mattatz/44f081cac87e2f7c8980 (HLSL)\nvec3 rgb2xyz(vec3 c){\n\tvec3 tmp=vec3(\n\t\t(c.r>.04045)?pow((c.r+.055)/1.055,2.4):c.r/12.92,\n\t\t(c.g>.04045)?pow((c.g+.055)/1.055,2.4):c.g/12.92,\n\t\t(c.b>.04045)?pow((c.b+.055)/1.055,2.4):c.b/12.92\n\t);\n\tmat3 mat=mat3(\n\t\t.4124,.3576,.1805,\n\t\t.2126,.7152,.0722,\n\t\t.0193,.1192,.9505\n\t);\n\treturn 100.*(tmp*mat);\n}\nvec3 xyz2lab(vec3 c){\n\tvec3 n=c/vec3(95.047,100.,108.883),\n\t     v=vec3(\n\t\t(n.x>.008856)?pow(n.x,1./3.):(7.787*n.x)+(16./116.),\n\t\t(n.y>.008856)?pow(n.y,1./3.):(7.787*n.y)+(16./116.),\n\t\t(n.z>.008856)?pow(n.z,1./3.):(7.787*n.z)+(16./116.)\n\t);\n\treturn vec3((116.*v.y)-16.,500.*(v.x-v.y),200.*(v.y-v.z));\n}\nvec3 rgb2lab(vec3 c){\n\tvec3 lab=xyz2lab(rgb2xyz(c));\n\treturn vec3(lab.x/100.,.5+.5*(lab.y/127.),.5+.5*(lab.z/127.));\n}\nvec3 lab2xyz(vec3 c){\n\tfloat fy=(c.x+16.)/116.,\n\t      fx=c.y/500.+fy,\n\t      fz=fy-c.z/200.;\n\treturn vec3(\n\t\t 95.047*((fx>.206897)?fx*fx*fx:(fx-16./116.)/7.787),\n\t\t100.   *((fy>.206897)?fy*fy*fy:(fy-16./116.)/7.787),\n\t\t108.883*((fz>.206897)?fz*fz*fz:(fz-16./116.)/7.787)\n\t);\n}\nvec3 xyz2rgb(vec3 c){\n\tmat3 mat=mat3(\n\t\t3.2406,-1.5372,-.4986,\n\t\t-.9689, 1.8758, .0415,\n\t\t .0557, -.2040,1.0570\n\t);\n\tvec3 v=(c/100.0)*mat,\n\t     r=vec3(\n\t\t(v.r>.0031308)?((1.055*pow(v.r,(1./2.4)))-.055):12.92*v.r,\n\t\t(v.g>.0031308)?((1.055*pow(v.g,(1./2.4)))-.055):12.92*v.g,\n\t\t(v.b>.0031308)?((1.055*pow(v.b,(1./2.4)))-.055):12.92*v.b\n\t);\n\treturn r;\n}\nvec3 lab2rgb(vec3 c){return xyz2rgb(lab2xyz(vec3(100.*c.x,2.*127.*(c.y-.5),2.*127.*(c.z-.5))));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfSWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 283, 317, 317, 456], [458, 458, 492, 492, 628], [630, 630, 664, 664, 797], [799, 799, 844, 844, 890], [892, 892, 921, 921, 955], [957, 957, 1025, 1025, 1595], [1597, 1597, 1625, 1625, 2159], [2593, 2593, 2627, 2627, 2889], [2891, 2891, 2920, 2920, 3230], [3232, 3232, 3297, 3297, 3429], [3431, 3431, 3488, 3488, 4154], [4157, 4313, 4334, 4334, 4617], [4618, 4618, 4639, 4639, 4920], [4921, 4921, 4942, 4942, 5039], [5040, 5040, 5061, 5061, 5317], [5318, 5318, 5339, 5339, 5669], [5670, 5670, 5691, 5691, 5766]], "test": "error"}
{"id": "stfSWS", "name": "Voronoi Archipelago", "author": "Hamish", "description": "Voronoi and Simplex noise used to create a simple ocean and islands scene.", "tags": ["voronoi", "simplex"], "likes": 1, "viewed": 22, "published": "Public", "date": "1626410899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Simplex noise\n// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nhttps://www.shadertoy.com/view/Msf3WH\n\nVoronoi noise\n@patriciogv\n\nthebookofshaders.com helped me a lot!\n\n*/\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404;\n    const float K2 = 0.211324865;\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 translate = vec2(iTime*-0.4,iTime*0.25);\n    p += translate*.1;\n\tvec2 st = p*vec2(iResolution.x/iResolution.y,1.0);\n\tfloat f1 = 0.0;\n    float f2 = 0.0;\n    f1 = noise( st );\n    f2 = noise( vec2(100.,100.)*st*f1*f1);\n\tf1 = 0.5 + 0.5*f1;\n    f2 = 0.5 + 0.5*f2;\n    vec3 color = vec3(0.0);\n    st += translate*0.05;\n    st *= 15.0;\n    vec2 i_st = floor(st); vec2 f_st = fract(st);    \n    \n    float m_dist = 10.;\n    vec2 m_point;       \n\n    for (int j=-1; j<=1; j++ ) {\n        for (int i=-1; i<=1; i++ ) {\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.5 + 0.4*sin(iTime + 10.*point);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n\n            if( dist < m_dist) {\n                m_dist = dist;\n                m_point = point;\n            }\n        }\n    }\n    vec3 colorbackground = vec3(0.);\n   \tcolorbackground.r += dot(m_point,vec2(.1,.1));\n  \tcolorbackground.g += dot(m_point,vec2(.3,.3));   \n    float color1 = dot(m_point,vec2(.7,.3));\n    float color2 = dot(m_point,vec2(.4,.3));\n    float pct = abs(sin(iTime*.02));\n    colorbackground.b = mix(color1, color2, pct);\n    vec3 colortemp = vec3(1.,0.95,0.);\n    if (f1 < 0.35 + m_dist*m_dist*0.003) {\n    color = vec3(.93,.81,.51);\n        if (f1 < 0.3) {\n        color = vec3(.65,.84,.52);\n        }\n    }\n    else {\n    color.b = mix(colortemp.b,colorbackground.b,f1*2.);\n\n    color.r = colorbackground.r;\n    color.g = colorbackground.g;\n    }\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfSWS.jpg", "access": "shaders20k", "license": "mit", "functions": [[1203, 1203, 1224, 1224, 1339], [1340, 1340, 1366, 1366, 1808], [1809, 1809, 1833, 1833, 1926], [1927, 1927, 1984, 1984, 3599]], "test": "valid"}
{"id": "stfXRX", "name": "åè½®ç¼", "author": "Satenkai", "description": "1", "tags": ["1"], "likes": 2, "viewed": 65, "published": "Public", "date": "1626168392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv,vec2 center,float radius,float blur)\n{\n    float d = length(uv-center);\n    float c = smoothstep(radius,radius - blur,d);\n    return c;\n}\n\nvec3 xielunyan(vec2 uv,vec2 offset,float size)\n{\n    \n    vec3 c1 = vec3(Circle(uv + offset,vec2(0.0,0.0),0.1 * size,0.01));\n    vec3 c2 = vec3(Circle(uv + offset,vec2(size * 0.1,0.0),0.2 * size,0.01));\n    vec3 c3 = vec3(Circle(uv + offset,vec2(size * 0.15,0.05 * size),0.16 * size,0.01));\n    \n    vec3 cmix = max(c1, mix(c2 - c3,vec3(0.0),step((uv + offset).y,0.0)));\n    return cmix;\n}\n\nvec2 rot(vec2 uv,float angle)\n{\n    //uv = uv - vec2(0.5);\n    float s = sin(angle);\n    float c = cos(angle);\n    uv = mat2(c,-s,s,c) * uv;\n    //uv = uv + vec2(0.5);\n    return uv;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv-= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\n    vec2 offset1 = vec2(0.0,0.0); \n\n    vec3 c1 = 1.0 - xielunyan(rot(rot(uv,iTime * 0.1 +  0.0) + vec2(0.0,0.33),2.1),offset1,0.8);\n    vec3 c2 = 1.0 - xielunyan(rot(rot(uv,iTime * 0.1 +  2.0) + vec2(0.0,0.33),2.1),offset1,0.8);\n    vec3 c3 = 1.0 - xielunyan(rot(rot(uv,iTime * 0.1 +  4.2) + vec2(0.0,0.33),2.1),offset1,0.8);\n    vec3 center = 1.0 - vec3(Circle(uv,vec2(0.0),0.1,0.01));\n    vec3 cmix = min(min(min(c1,c2),c3),center);\n    \n    vec3 bg = vec3(Circle(uv,vec2(0.0,0.0),0.5,0.01)) \n    * vec3(1.0,0.0,0.0) * smoothstep(0.2,1.2,1.0-length(uv));\n    \n    bg = mix(vec3(0.25),bg,Circle(uv,vec2(0.0,0.0),0.525,0.01));\n    \n    \n    vec3 incircle = 1.0 - (vec3(Circle(uv,vec2(0.0,0.0),0.35,0.01) - Circle(uv,vec2(0.0,0.0),0.34,0.01)));\n    \n    bg = min(bg,incircle);\n   \n    vec3 col = min(cmix,bg);//mix(bg,1.0 - clamp(cmix + 0.75,0.0,1.0),c3);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 158], [160, 160, 208, 208, 549], [551, 551, 582, 609, 736], [737, 737, 794, 844, 1860]], "test": "valid"}
{"id": "stfXWM", "name": "Gyroidal Morphoma R", "author": "Taron", "description": "BigWIngs incredible tutorial on gyroids and demo code here made me goof around a little and end up with this organic weirdness.\nHere's his gyroid example: https://www.shadertoy.com/view/WtKSRz\nHere's his template: https://www.shadertoy.com/view/WtGXDD", "tags": ["raymarching", "gyroid"], "likes": 17, "viewed": 126, "published": "Public", "date": "1625783490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Gyroidal Morphoma\" \n// Based on Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// https://www.shadertoy.com/view/WtKSRz\n//\n// I feel a little funny, almost just adjusting a shader, but this one's too much fun!\n// I've added some simple gloss and reflection, besides the organic wobbles.\n// If you want to truly learn something, check out his amazing tutorials on youtube (The Art of Code)!\n// And, Martijn, if you read this: I'm a fan and bow before your excellence, especially your teaching style.\n// Technically I may know much of it for almost 30 years, but the finesse and virtuosity of you is a pleasure \n// to watch and utterly inspiring!\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat Gyroid(vec3 p, float offset, float scale){\n    p *=scale;\n    offset +=.025*p.y;\n    return (dot(sin(p),cos(p.zxy))+offset)/scale;\n}\n\nfloat getGyroids(vec3 p){\n    p.z -=iTime*.25;\n    float gyroid = Gyroid(p,1.2,10.);\n    gyroid -= 0.5*Gyroid(p+vec3(0.15,0.,-0.05),1.2,19.79);\n    gyroid += 0.25*Gyroid(p+vec3(7.15+iTime*.1,0.,-0.05*gyroid),1.,29.39);\n    gyroid += 0.125*Gyroid(p+vec3(-2.15,0.3-gyroid,0.05),.9,49.99);\n    gyroid += 0.065*Gyroid(p+vec3(-0.05,0.1,7.15+gyroid),0.95,79.99);\n    return gyroid;\n\n}\n\nfloat GetDist(vec3 p) {\n    float box = sdBox(p, vec3(2.));\n    p.xy *= Rot(p.z*.73);\n    float gyroid = getGyroids(p);\n    \n    \n    float d = max(gyroid*0.6, box);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0., 0., -1.);\n    ro.yz *= Rot(-m.y*3.14+0.15);\n    ro.xz *= Rot(-m.x*6.2831-3.15);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        float dif = n.y*.5+.5;\n        col = vec3(dif);\n        \n        // gloss and pseudo reflections below 0.5y\n        if(p.y<0.5){\n            vec3 r = reflect(rd, n);\n            float refl = 0.;\n            float m = RayMarch(p-n*.005, r);\n            if(m<MAX_DIST){\n                vec3 rn = GetNormal(ro+r*m);\n                refl = rn.y*.5+.5;\n            }\n\n            vec3 spec = pow(max(0.,dot(vec3(0.,1.,0.),r)),53.3)*.5+min(1.,refl)*vec3(0.02,0.15,0.21);\n            col +=spec *max(0.,min(1.,0.5-p.y*2.5));\n        }\n     }\n    \n    col = pow(col, vec3(0.4545,1.0545,1.4545));\t// colored gamma correction\n    col = mix(col, mix(vec3(0.1,0.15,0.3),vec3(0.1,0.15,0.3)*10.,rd.y*.3),min(1.0,d*.5)); // fog\n    col = mix(col, vec3(0.24,0.03,0.02),length(uv)); // vignette\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfXWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[765, 765, 784, 784, 846], [848, 848, 877, 877, 958], [960, 960, 1008, 1008, 1098], [1100, 1100, 1125, 1125, 1478], [1480, 1480, 1503, 1503, 1661], [1663, 1663, 1697, 1697, 1908], [1910, 1910, 1934, 1934, 2124], [2126, 2126, 2176, 2176, 2367], [2369, 2369, 2426, 2426, 3648]], "test": "valid"}
{"id": "stj3Wc", "name": "Fork Toy1 ArthMax 463", "author": "ArthMax", "description": "This is Toy2 for my followers-students. Make your own Toy!/", "tags": ["toy1forfollowers"], "likes": 0, "viewed": 39, "published": "Public", "date": "1625120135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float _(float a, float b, float c){\n                  return max(a,max(b,c));\n        }\n             \n        float L(vec2 p, vec2 P0, vec2 P1){\n                float a = -(P1.y-P0.y);\n                float b =  (P1.x-P0.x);\n                float d =  P0.x*P1.y- P0.y*P1.x; \n                float x = p.x;\n                float y = p.y;\n                \n                 return a*x + b*y + d;\n        }\n    \n    float T(vec2 p, vec2 P0, vec2 P1, vec2 P2){\n          return  _(\n                     L(p, P0, P1),\n                     L(p, P1, P2), \n                     L(p, P2, P0)\n                   );   \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//  digitalized Pi profile                      \n vec2 P[40];\n       P[ 0] = vec2(-0.74687 ,    0.21562);\n       P[ 1] = vec2(-0.7375  ,    0.38437);\n       P[ 2] = vec2(-0.63125 ,    0.54375);\n       P[ 3] = vec2(-0.47813 ,    0.63437);\n       P[ 4] = vec2(-0.30937 ,    0.66562);\n       P[ 5] = vec2(-0.053125,    0.66250);\n       P[ 6] = vec2( 0.28125  ,   0.66250);\n       P[ 7] = vec2( 0.64063  ,   0.66562);\n       P[ 8] = vec2( 0.7125   ,   0.66875);\n       P[ 9] = vec2( 0.64375  ,   0.54062);\n       P[10] = vec2( 0.51563  ,   0.46562);\n       P[11] = vec2( 0.37188  ,   0.44688);\n       P[12] = vec2( 0.24063  ,  -0.39688);\n       P[13] = vec2( 0.3375   ,  -0.51875);\n       P[14] = vec2( 0.45     ,  -0.52813);\n       P[15] = vec2( 0.65625  ,  -0.40313);\n       P[16] = vec2( 0.62188  ,  -0.54375);\n       P[17] = vec2( 0.50313  ,  -0.65938);\n       P[18] = vec2( 0.2625   ,  -0.70938);\n       P[19] = vec2( 0.096875 ,  -0.55000);\n       P[20] = vec2( 0.05     ,  -0.25938);\n       P[21] = vec2( 0.09375  ,   0.04375);\n       P[22] = vec2( 0.19688  ,   0.44688);\n       P[23] = vec2(-0.20937 ,    0.45625);\n       P[24] = vec2(-0.25937 ,   -0.10000);\n       P[25] = vec2(-0.3375  ,   -0.48438);\n       P[26] = vec2(-0.51875 ,   -0.68438);\n       P[27] = vec2(-0.64063 ,   -0.69688);\n       P[28] = vec2(-0.68125 ,   -0.60625);\n       P[29] = vec2(-0.54688 ,   -0.40625);\n       P[30] = vec2(-0.44688 ,   -0.12187);\n       P[31] = vec2(-0.35938 ,    0.27187);\n       P[32] = vec2(-0.34687 ,    0.45625);\n       P[33] = vec2(-0.49375 ,    0.40625);\n       P[34] = vec2(-0.6375  ,    0.30937);\n       P[35] = vec2(-0.7375  ,    0.21875);\n       P[36] = vec2(-0.74687 ,    0.21562);   \n       P[37] = vec2(-0.7375  ,    0.38437);\n       P[38] = vec2(-0.63125 ,    0.54375);\n       P[39] = vec2(-0.47813 ,    0.63437);\n   \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = 1.0 - 2.0* fragCoord/iResolution.xy;\n    vec2 m = 1.0 - 2.0* iMouse.xy/iResolution.xy;\n\n     float x = p.x * iResolution.x/iResolution.y;\n     float y = p.y ;\n     \n     float mx = m.x * iResolution.x/iResolution.y;\n     float my = m.y ;\n           \n            x/=mx;\n            y/=my;\n            \n            p.x=x;\n            p.y=y;\n   \n\n      float  z = 1.0e25; //infinity?\n              for(int i=0;i<40-4;i++)\n                z = min(z, T(p,  P[i],P[i+1], P[i+3]) );   \n       float     f = 1.25/z; \n\n    // Time varying pixel color\n               vec3 col = vec3(1.0, 1.0, 1.0);\n                if(f >= 0.0)col.g = sin(iTime/10.0);\n                   else     col.r = f;\n                \n\n    // Output to screen\n                 fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stj3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 87], [110, 110, 144, 144, 402], [412, 412, 455, 455, 612], [614, 614, 671, 720, 3333]], "test": "valid"}
{"id": "stjGDd", "name": "Fork Cubic Bezi brickmaker 655", "author": "brickmaker", "description": "Computing the exact bounding box to a cubic Bezier curve. Yellow: naive bbox of the 4 control points. Blue: exact/analytic bbox. Since the bezier is cubic, the bbox can be compute with a quadratic equation.", "tags": ["2d", "bezier", "cubic", "boundingbox", "bbox"], "likes": 3, "viewed": 188, "published": "Public API", "date": "1626145746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computes the exact bounding box to a cubic Bezier curve. Since the bezier is cubic,\n// the bbox can be compute with a quadratic equation:\n//\n//   Yellow: naive bbox of the 4 control points\n//   Blue: exact bbox\n//\n// More info here: http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm\n//    \n// Related Shaders:\n//     Quadratic Bezier - 3D      : https://www.shadertoy.com/view/ldj3Wh\n//     Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n//     Cubic     Bezier - 3D BBox : https://www.shadertoy.com/view/MdKBWt\n//     Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n//     Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/tsBfRD\n\n\n\n//---------------------------------------------------------------------------------------\n\n\nfloat length2( in vec2 v ) { return dot(v,v); }\n\nfloat sdSegmentSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\treturn sqrt(sdSegmentSq(p,a,b));\n}\n\n// slow, do not use in production. Can probably do better than\n// tesselation in linear segments.\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, vec2 pos)\n{   \n    const int kNum = 50;\n    vec2 res = vec2(1e10,0.0);\n    vec2 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        float s = 1.0-t;\n        vec2 b = p0*s*s*s + p1*3.0*s*s*t + p2*3.0*s*t*t + p3*t*t*t;\n        float d = sdSegmentSq( pos, a, b );\n        if( d<res.x ) res = vec2(d,t);\n        a = b;\n    }\n    \n    return vec2(sqrt(res.x),res.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //--------\n    // animate\n    //--------\n    float time = iTime*0.5 - 0.7;\n    vec2 p0 = 0.8*sin( time*0.7 + vec2(3.0,1.0) );\n    vec2 p1 = 0.8*sin( time*1.1 + vec2(0.0,6.0) );\n    vec2 p2 = 0.8*sin( time*1.3 + vec2(4.0,2.0) );\n    vec2 p3 = 0.8*sin( time*1.5 + vec2(1.0,5.0) );\n\n\t//-------------\n    // compute bbox\n\t//-------------\n    // vec4 b1 = bboxBezierSimple(p0,p1,p2,p3);\n    // vec4 b2 = bboxBezier(p0,p1,p2,p3);\n    \n    //--------\n    // render\n    //--------\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    p *= 2.0;\n    px *= 2.0;\n    // background\n    vec3 col = vec3(0.15);\n    float be = udBezier( p0, p1, p2, p3, p ).x;\n\t// col += 0.03*sin(be*150.0);\n    // col *= 1.0 - 0.3*length(p);\n    \n    float d;\n    \n    \n    // control cage\n    d = sdSegment( p, p0, p1 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p1, p2 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p2, p3 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n\n    // bezier\n    d = be;\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.003,0.003+px*1.5,d) );\n         \n    // control points\n    d = length(p0-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p1-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p2-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p3-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjGDd.jpg", "access": "shaders20k", "license": "mit", "functions": [[1869, 1869, 1897, 1897, 1916], [1918, 1918, 1972, 1972, 2083], [2085, 2085, 2137, 2137, 2173], [2175, 2273, 2337, 2337, 2733], [2735, 2735, 2792, 2837, 4400]], "test": "valid"}
{"id": "stjSWh", "name": "Magic Doormat Dispenser", "author": "Tater", "description": "This is another shader for Sableraph's weekly creative coding challenge, the theme was \"textile\". \n\nAt first I felt a bit disappointed a different prompt wasn't picked but in the end I really like how this one turned out. ", "tags": ["3d", "raymarching"], "likes": 17, "viewed": 231, "published": "Public API", "date": "1627622177", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 128.0\n#define MDIST 40.0\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a));\n\n//box sdf\nfloat box(vec3 p, vec3 s){\n    vec3 d = abs(p)-s;\n    return max(d.x,max(d.y,d.z));\n}\n//iq's color palette function\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n//An interpolated sinwave with variable sample rate to give the carpets a low poly look\nfloat psin(float x, float b){\n    return sin(floor(b*x)/b)+(sin(floor(b*x+1.0)/b)-sin(floor(b*x)/b))*mod(b*x,1.0);\n}\n\nvec3 map(vec3 p){\n    vec3 a = vec3(0);\n    \n    float t = mod(iTime,9999.0);\n    \n    //scroll the y axis up all the time \n    p.y-=t-0.25;\n    \n    //id of y axis domain repition\n    float id = floor(p.y/1.0)+0.5;\n    \n    //x value to offset carpets so they fly left and right\n    float xoff =max(0.0,(id+t)*2.0);\n    xoff = xoff*xoff*sign(sin(id*pi));;\n    \n    //domain repition in the y axis\n    p.y = pmod(p.y,1.0);\n\n    //Add some low poly waves to the carpets\n    float sb = .7;\n    float wscl = 0.06;\n    p.y+=psin(p.x*4.0+id,sb)*wscl;\n    p.y-=psin(p.z*4.0+id,sb)*wscl;\n\n    //calculate box sdf\n    a.x = box(p-vec3(xoff,0,0),vec3(2,0.025,2));\n    \n    //pass some info to coloring code\n    a.y = id;\n    a.z = xoff;\n    \n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n//mirror function\nvoid mo(inout vec2 p){\n  if(p.y>p.x) p = p.yx;\n}\nvec2 kifs(vec2 uv,float id){\n    //some kifs and abs() duplication code\n    for(float i = 0.0; i< 9.0; i++){\n        uv = abs(uv)-0.7*i*(vec2((sin(id*0.15)),0.2*(cos(id*0.22))));\n        //Adjusting this rotation value gives some cool alternate designs\n        uv*=rot(pi/(2.0));\n        mo(uv);\n    }\n    uv = abs(uv)-0.5;\n    uv = abs(uv)-0.5;\n    uv = abs(uv)-0.5;\n    return uv;\n}\nfloat getRug(vec2 uv, float id){\n    vec3 col = vec3(0);\n    float a =0.0;\n    \n    //sometimes the result of the kifs will not give any pattern on the carpet\n    //to fix this I run the kifs 8 times with different initial conditions and xor\n    //all the patterns so you can't really tell when there are gaps.\n    //someone who is better at kifs could probably just fix the problem\n    \n    for(float i = 0.0; i <8.0; i++){\n        a = mix(a,1.0-a,smoothstep(0.21,0.19,box(vec3(kifs(uv,id+i*pi),0),vec3(0.2)))); \n    }\n    return float(a);\n}\n//radial mod (stole a flopine shader)\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2 (cos(a),sin(a))*l;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    float aa = 1.0/iResolution.y;\n    vec3 ro = vec3(0,3,-7);\n    vec3 rd = normalize(vec3(uv,1.0));\n    rd.yz*=rot(-0.4 );\n    vec3 p = ro;\n    vec3 d;\n    bool hit = false;\n    float dO;\n    //raymarch loop\n    for(float i = 0.0; i<STEPS; i++){\n        d = map(p);\n        dO+=min(0.75,d.x*0.8);\n        p = ro+rd*dO;\n        \n        if(abs(d.x)<0.001){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){break;}\n    }\n    \n    //if ray marcher hits something color it\n    if(hit){ \n        vec3 palc = 0.9*pal(d.y/3.0, vec3(0.3),vec3(0.5),vec3(1.7),vec3(0,0.33,0.66) );\n        float bright = mix(1.,1.,sin(d.y*pi)*0.5+0.5);\n        vec3 al = mix(palc,vec3(bright),getRug(vec2(p.x-d.z,p.z),d.y));\n\n        vec3 n = norm(p);\n        vec3 ld = normalize(vec3(0.2,1,1));\n        vec3 h = normalize(ld-rd);\n        float spec = pow(max(dot(n,h),0.0),20.0);\n        float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n        float diff = max(dot(n, ld),0.);\n        \n\n        //some hacky soft shadows\n        float shadow = 1.0;\n        float md = 1.0;\n        vec3 sp = p + n * 0.5;\n        for(int i=0; i<10; ++i) {\n        \n          float d=map(sp).x;\n          \n          if(d>3.0) break; \n          sp+=min(d,0.4)*ld;\n          md = min(md, d);\n          if(md<0.5) shadow = md+0.5;\n          \n        }\n        //I still have no idea what I am doing with these lighting mixes\n        shadow = pow(shadow,1.75);\n        col = al;\n        col+=spec*0.3*shadow*vec3(1.000,0.831,0.439);\n        col+=fres*0.175*shadow*vec3(1.000,0.957,0.824);\n        col*=clamp(diff*vec3(1.000,0.957,0.824),0.2,1.0);\n        col*=clamp(shadow,0.0,1.0);\n    }\n    //if ray marcher didn't hit then render the background\n    else{\n        vec2 uvo = uv;\n        uv.y-=0.5;\n        uv.x-=0.7;\n\n        //orange/purple gradient\n        col = mix(vec3(0.976,0.502,0.243),vec3(0.420,0.259,1.000),min(length(uv)-0.4,1.2));\n\n        //big sun circle\n        float sun =smoothstep(length(uv)-aa,length(uv)+aa,0.3);\n        uv*=rot((floor(length(uv)/0.1)+0.5)-t*0.025);\n\n        //lots of little tiny rings\n        uv = moda(uv,0.3);\n        uv.x = pmod(uv.x,0.1);\n        float rs = 0.035/2.0;\n        sun += (smoothstep(length(uv)-aa,length(uv)+aa,rs)\n        -smoothstep(length(uv)-aa,length(uv)+aa,rs*0.5));\n        col+=min(sun,1.0);\n        \n        //Some sand dune thingys\n        uv = uvo;\n        uv.y+=sin(uv.x*12.0-t*0.4+5.0)*0.015;\n        col=mix(col,vec3(1.000,0.655,0.275),smoothstep(uv.y-aa,uv.y+aa,-0.25));\n        uv = uvo;\n        uv.y+=sin(uv.x*12.0-t+2.5)*0.015;\n        col=mix(col,vec3(0.957,0.584,0.357),smoothstep(uv.y-aa,uv.y+aa,-0.325));\n        uv = uvo;\n        uv.y+=sin(uv.x*12.0-t*1.8)*0.015;\n        col=mix(col,vec3(0.894,0.871,0.353),smoothstep(uv.y-aa,uv.y+aa,-0.4));\n        \n    }\n    //Gamma\n    col =sqrt(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 162, 188, 188, 247], [248, 278, 345, 345, 388], [389, 477, 506, 506, 593], [595, 595, 612, 612, 1343], [1345, 1345, 1363, 1363, 1490], [1491, 1509, 1531, 1531, 1557], [1558, 1558, 1586, 1629, 1942], [1943, 1943, 1975, 1975, 2485], [2486, 2524, 2555, 2555, 2680], [2681, 2681, 2738, 2738, 5729]], "test": "valid"}
{"id": "stjXDz", "name": "Forever Loading.", "author": "dreamraster", "description": "Just getting started with a test shader based on https://www.shadertoy.com/view/Xd3cR8", "tags": ["loading"], "likes": 4, "viewed": 48, "published": "Public", "date": "1627482596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/Xd3cR8\n#define PI 3.14159\n#define SPEED 4.0\n#define WIDTH 0.008\n#define RADIUS 0.04\n\n#define aa 2.0 / min(iResolution.x,iResolution.y)\n\nvec2 remap(vec2 coord) \n{\n\treturn coord / min(iResolution.x,iResolution.y);\n}\n\nfloat circle(vec2 uv, vec2 pos, float rad) \n{\n\treturn 1.0 - smoothstep(rad,rad+0.005,length(uv-pos));\n}\n\nfloat ring(vec2 uv, vec2 pos, float innerRad, float outerRad)\n{\n\treturn (1.0 - smoothstep(outerRad,outerRad+aa,length(uv-pos))) * smoothstep(innerRad-aa,innerRad,length(uv-pos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = remap(fragCoord.xy);\n    uv -= vec2(0.94 / iResolution.y * iResolution.x,0.10);\n    \n    float geo = ring(uv,vec2(0.0),RADIUS-WIDTH,RADIUS);\n    float rot = -iTime * SPEED;\n    uv *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));\n    float a = atan(uv.x,uv.y)*PI*0.05 + 0.5;\n    a = max(a,circle(uv,vec2(0.0,-RADIUS+WIDTH/2.0),WIDTH/2.0));\n    fragColor = vec4(0, a*geo, a*geo, a*geo);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 204, 204, 256], [258, 258, 303, 303, 361], [363, 363, 426, 426, 543], [545, 545, 602, 602, 1004]], "test": "valid"}
{"id": "stlSDr", "name": "Jalur Gemilang - Malaysia", "author": "mziskandar", "description": "Greetings from Kuala Lumpur, Malaysia.\nMZIskandar | Radnaksizm", "tags": ["flag", "malaysia", "malaysian"], "likes": 11, "viewed": 564, "published": "Public", "date": "1625512258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"The MALAYSIAN Flag\"\n// by MZIskandar, Kuala Lumpur, Malaysia.\n// Blog: http://digitalspine.blogspot.com\n// Twitter: @mziskandar\n// learned form Martijn Steinrucken aka The Art of Code/BigWings - 2020 [https://www.shadertoy.com/view/flsXRM]\n// and jjovanovski [https://www.shadertoy.com/view/ftlSDr]\n// ..and FabriceNeyret2 tips.\n\n#define PI 3.14159265359\n#define TAU (2. * PI)\n#define BlueHeight (1.0 - ((1.0 / 14.0) * 8.0))\n\nvec3 RED = vec3(204.0/255.0, 0.0, 0.0);\nvec3 WHITE = vec3(1.0);\nvec3 BLUE = vec3(0.0, 0.0, 102.0/255.0);\nvec3 YELLOW = vec3(254.0/255.0, 204.0/255.0, 0.0);\n\nfloat drawCircle (vec2 uv, vec2 pos, float radius){\n    return float(smoothstep(radius, radius - 0.002, length(uv - pos)));\n}\n\nfloat Star14(vec2 uv, float size) {\n    float a = mod( atan(uv.x,uv.y)*14.,TAU ) / TAU -PI/TAU,\n      angle = PI*.73,\n          d = length(uv)*  sin(angle+abs(a)),\n          w = fwidth(d);\n    return length(uv)>.4 ? 0. : smoothstep(size + w, size - w, d);\n}\n\nvec2 Remap(vec2 p, float b, float l, float t, float r) {\n    return vec2( (p.x-l) / (r-l), (p.y-b) / (t-b));\n}\n\nvec3 Flag(vec2 uv) {\n\n    float y = sin(uv.y*PI*14.);\n    float w = fwidth(y);\n    float stripes = smoothstep(-w, w, y);\n    vec3 col = mix(RED, WHITE, stripes);\n\n    vec2 st = Remap(uv, BlueHeight, 0.0, 1.0, 0.5);\n    if(st.x>0. && st.x<1. && st.y>0. && st.y<1.) {\n        col = BLUE;\n        vec2 stM = Remap(uv, 0.15, 0.11, 0.795, 0.48);\n        float Moon = clamp( drawCircle(stM, vec2(0.27,0.88), 0.31)-drawCircle(stM, vec2(0.33,0.88), 0.28) ,0.0,1.0);\n        vec2 stS = Remap(uv, 0.715, 0.33, 1.4, 0.73);\n        float Star = Star14(stS.xy, 0.08);\n        col += vec3(abs((Moon + Star))) * YELLOW;\n    }\n\n    if (uv.y < .0 || uv.y > 1.0) col = col * vec3(0.);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = uv.x*7.-2.*iTime+uv.y*3.;\n    uv.y += sin(t)*.05;\n    \n    vec3 col = Flag(uv);\n    \n    col *= .7+cos(t)*.3;\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlSDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[587, 587, 638, 638, 712], [714, 714, 749, 749, 971], [973, 973, 1029, 1029, 1083], [1085, 1085, 1105, 1105, 1769], [1772, 1772, 1828, 1828, 2026]], "test": "valid"}
{"id": "stlSRs", "name": "SED4906 - Other Mandelbrot sets", "author": "sed4906", "description": "Another example of the Mandelbrot set.", "tags": ["mandelbrot"], "likes": 1, "viewed": 33, "published": "Public", "date": "1626371152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 complexpow( vec2 z, float N )\n{\n    float theta = atan(z.y / z.x);\n    float r = sqrt(z.x*z.x+z.y*z.y);\n    return vec2(pow(r, N) * cos(N * theta), pow(r, N) * sin(N * theta));\n}\n\nvec3 mandelbrot( vec2 c )\n{\n    vec2 z = vec2(0.0, 0.0);\n    float i;\n    for (i = 0.0; i < 1.0; i += 0.005) {\n        z = complexpow(z, iTime) + c;\n\n        if (length(z) > 4.0) {\n            break;\n        }\n    }\n\n    return vec3(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col =  mandelbrot(vec2((uv.x-0.5)*5.0,((uv.y-0.5)/ar)*5.0));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlSRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 183], [185, 185, 212, 212, 423], [425, 425, 482, 532, 777]], "test": "valid"}
{"id": "stlSWX", "name": "Egg Alone reproduced", "author": "pini", "description": "eggalone.com as a shader", "tags": ["egg"], "likes": 1, "viewed": 32, "published": "Public", "date": "1626715565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Pini Grigio\n// Title: Recreation (eggalone.com)\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n\n\n\n\nfloat egg(float radius, float a, float b, vec2 location) {\n    float smoothing = 0.001;\n    // Eggify\n    location.y *= sqrt((1.0 - a) - b*(location.x));\n    return smoothstep(\n            radius + smoothing, \n            radius, \n            distance(location, vec2(0.0))\n    \t);\n}\n\nfloat yolk(float size, vec2 location) {\n    float smoothing = 0.001;\n    return smoothstep(\n        \tsize + smoothing,\n        \tsize, \n        \tdistance(location, vec2(0.0))\n    \t);\n}\n\nmat2 rotate(float angle){\n    return mat2(\n        \t\tcos(angle), -sin(angle),\n                sin(angle),  cos(angle)\n    \t\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\nvec2 u_resolution = iResolution.xy;\nfloat u_time = iTime;\n\n    // Normalize coordinates\n    vec2 st = fragCoord.xy / u_resolution.xy;\n\n    // Center \n    st -= 0.5;\n    \n    // Fix aspect ratio\n    if (u_resolution.y > u_resolution.x) {\n    \tst.y *= u_resolution.y/u_resolution.x;\n    } else {\n        st.x *= u_resolution.x/u_resolution.y;\n    }\n    \n    // Constants\n\tfloat margin = 0.03;\n    float rotation = mod(u_time/2.0, 180.0);\n    \n    float egg_radius = 0.5;\n    float egg_width = -1.172;\n    float off_center = 2.188;\n    \n    float yolk_radius = (\n                            egg_radius/3.0) * \n                            (1.0 + sin(u_time) \n                             / 100.0\n                        );\n    vec2 yolk_center_offset = vec2(\n                                    (egg_radius / off_center) - 0.340,\n                                    0.0\n    \t\t\t\t\t\t\t  );\n    vec2 yolk_independant_offset = vec2(-0.01,0.005) * rotate(rotation); // Counter rotation of yolk\n    \n    // Draw the egg\n\tvec3 egg_white = mix(\n                            vec3(0.0),\n                            vec3(1.0),\n                            egg(\n                                    egg_radius * (0.99 + sin(u_time)/50.0) - margin,\n                                    egg_width * (0.9 + sin(u_time)/5.0),\n                                    off_center * (0.9 + sin(u_time)/5.0), \n                                    st*rotate(rotation)\n                                )\n                   \t\t);\n    \n    // Invert yolk color to later AND it with the egg white\n    vec3 yolk_yellow = 1.0 - mix(\n                            vec3(0.0),\n                            1.0 - vec3(1.990,1.838,0.030),\n                            yolk(\n                                    yolk_radius,\n                                    (st+yolk_independant_offset) * rotate(rotation) + \n                                    yolk_center_offset\n                                )\n    \t\t\t\t\t);\n    \n    fragColor = vec4(egg_white * yolk_yellow, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlSWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 169, 169, 393], [395, 395, 434, 434, 578], [580, 580, 605, 605, 708], [710, 710, 766, 766, 2782]], "test": "valid"}
{"id": "stlXWH", "name": "Square minus Circle - distance", "author": "rodolphito", "description": "Exact distance to a square minus a circle. This produces correct exteriors everywhere, unlike using SDF operators to subtract a circle from a square.", "tags": ["2d", "sdf", "square", "distance", "primitive"], "likes": 2, "viewed": 43, "published": "Public", "date": "1625638385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2021 Rodol Phito\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a square minus a circle\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat sdSquareMinusCircle( in vec2 p, in float b ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    if (p.y<b*min(p.x,1.0)) return length(p-vec2(1.,b));\n    return max(length(max(p-1.,0.0)) + min(p.x-1.,0.0),sqrt(b*b+1.)-length(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 1.5*(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = 1.5*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    \n    // corner radius\n    float ra = 0.5*sin(iTime*1.2) + .5;\n\n    \n\tfloat d = sdSquareMinusCircle( p, ra );\n\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdSquareMinusCircle(m, ra );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlXWH.jpg", "access": "shaders20k", "license": "mit", "functions": [[1281, 1281, 1334, 1334, 1518], [1520, 1520, 1577, 1577, 2300]], "test": "valid"}
{"id": "stlXWM", "name": "camouflage depth", "author": "Taron", "description": "Unintentional ...but fun and oddly mesmerizing.", "tags": ["raymarching", "fractalnoise", "camouflage"], "likes": 4, "viewed": 60, "published": "Public", "date": "1625851189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash12(vec2 p) {\n    float h = dot(p,vec2(127.1,311.7)); \n    return fract(sin(h)*43758.5453123);\n}\nfloat noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);  \n    vec3 u = smoothstep(0.,1.,f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n    float b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n    float d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n    b = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n    d = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat turb(vec3 p, float noiseThreshold, float noiseSoftness, int oct)\n{\n    float r = 0.0,\n          w = 1.0, \n          s = 1.0,\n          d = 0.0;\n    for (int i=0; i<oct; i++)\n    {\n        r += w * noise(p);\n        w *= 0.673;\n        p *= 1.877;\n        d +=w;\n    }\n    r = abs(-1.+2.*r/d);\n    return smoothstep(noiseThreshold,noiseSoftness+noiseThreshold,r);\n}\n\nfloat march(vec3 cp, vec3 cd){\n\tfloat dO=1.;\n    \n    for(int i=0; i<20; i++) {\n    \tvec3 p = cp + cd*dO;\n        float dS = turb(p, .25,1., 3);\n        dO += .5;\n        if(dO>100.|| abs(dS)<0.0001){\n            break;\n        }\n    }\n    \n    return dO*.05;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fC )\n{\n    vec2 uv = (fC.xy - iResolution.xy*.5)/iResolution.y;\n    vec2 ms = iMouse.xy/iResolution.xy * 6.28;\n\n    vec3 camera = vec3(0.);\n    vec3 target = vec3(vec2(sin(iTime*.25),cos(iTime*.5))+uv,1.);\n    target.yz *= Rot(-ms.y);\n    target.xz *= Rot(-ms.x);\n     \n    vec3 cdir = normalize(camera-target);\n   \n    vec3 p = camera-vec3(0.,0.,iTime*.25);\n    \n    vec3 col = mix(vec3(0.05,0.02,0.01),vec3(0.65,0.76,0.45),march(p,cdir));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlXWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 105], [106, 106, 130, 130, 771], [773, 773, 845, 845, 1143], [1145, 1145, 1175, 1175, 1406], [1408, 1408, 1427, 1427, 1489], [1491, 1491, 1541, 1541, 2009]], "test": "valid"}
{"id": "stlXzM", "name": "Spherical iris", "author": "mrange", "description": "License CC0: Spherical iris\nResult of more tinkering around eye designs", "tags": ["2d"], "likes": 6, "viewed": 178, "published": "Public API", "date": "1625395615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define TIME          iTime\n#define RESOLUTION    iResolution\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3  grid_color    = HSV2RGB(vec3(0.6, 0.3, 1.0)); \nconst vec3  light0_color  = 16.0*HSV2RGB(vec3(0.6, 0.5, 1.0)); \nconst vec3  light1_color  = 8.0*HSV2RGB(vec3(0.9, 0.25, 1.0)); \nconst vec3  sky0_color    = HSV2RGB(vec3(0.05, 0.65, -0.25)); \nconst vec3  sky1_color    = HSV2RGB(vec3(0.6, 0.5, 0.25)); \nconst vec3  light0_pos    = vec3(5.0, 4.0, 4.0);\nconst vec3  light1_pos    = vec3(3.0, -1.0, -8.0);\nconst vec3  light0_dir    = normalize(light0_pos);\nconst vec3  light1_dir    = normalize(light1_pos);\nconst vec4  planet_sph    = vec4(50.0*normalize(light1_dir+vec3(0.025, -0.025, 0.0)), 10.0);\nconst vec2   iris_center  = vec2(0.0, 0.28);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat vesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r*r-d*d);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// IQ's ray sphere intersect: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec2 df(vec2 p) {\n  const float iris_outer = 0.622;\n  const float iris_inner = 0.285;\n  \n  float a  = mix(0.0, 0.85, smoothstep(0.995, 1.0, cos(TAU*TIME/5.0)));\n  const float b = 4.0;\n  float rr = mix(1.6, b, a);\n  float dd = mix(1.12, b, a);\n  \n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  float dt0 = mix(0.0125, -0.0025, t0);\n\n  vec2 p0 = p;\n  p0 = p0.yx;\n  float d0 =  vesica(p0, rr, dd);\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1 -= iris_center;\n  float d1 = circle(p1, iris_outer);\n  d1 = max(d1,d0+dt0);\n  float d6 = d1;\n\n  vec2 p2 = p;\n  p2 -= vec2(-0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3 -= iris_center;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-1.0*length(p1));\n\n  vec2 p4 = p;\n  p4 -= iris_center;\n  float d4 = circle(p4, iris_inner);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  d0 = abs(d0)-dt0;\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return vec2(d, d6);\n}\n\nvec3 render_background(vec3 ro, vec3 rd, vec3 nrd) {\n  vec3 srd = toSpherical(rd.xzy);\n  srd.z += 0.02*TIME;\n  vec2 pg  = srd.yz;\n  float f  = sin(pg.x); \n  float lf2= ceil(log(f)/log(2.0)-0.505);\n  float mf = pow(2.0, lf2);\n\n  const float aa = 0.005;\n  const float count = 20.0;\n  const vec2 sz = vec2(2.0*PI/count);\n  vec2 ng = mod2(pg, vec2(mf, 1.0)*sz);\n\n  float dg = min(abs(pg.y)*f, abs(pg.x))-aa*0.0;\n  vec3 lines = grid_color*smoothstep(-aa, aa, -dg)*f*f;\n\n  vec3 sky  = smoothstep(1.0, 0.0, rd.y)*sky1_color+smoothstep(0.5, 0.0, rd.y)*sky0_color;\n\n  vec2 pi = raySphere(ro, rd, planet_sph);\n\n  float lf1 = 1.0;\n  if (pi.x > 0.0) {\n    vec3 ppos = ro+rd*pi.x;\n    float t = 1.0-tanh_approx(1.5*(pi.y - pi.x)/planet_sph.w);\n    sky *= mix(0.5, 1.0, t);\n    lf1 = t;\n  } else {\n    sky += lines;\n  }\n\n  sky += pow(max(dot(rd, light0_dir), 0.0), 800.0)*light0_color; \n  sky += pow(max(dot(rd, light0_dir), 0.0), 80.0)*light1_color*0.1; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 150.0)*light1_color; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 50.0)*light0_color*0.1; \n\n\n  return sky;\n}\n\nvec4 render_iris(vec2 p, vec2 q, float d) {\n  p -= iris_center;\n  float aa = 2.0/RESOLUTION.y;\n  \n  float a = smoothstep(-aa, aa, -d);\n  float b = smoothstep(0.0, 0.125, -d);\n  \n  vec3 ro = 1.0*vec3(2.0, 4.0, -1.0);\n  vec3 la = vec3(0.0, 0.0, 0.0); \n\n  vec2 np   = p + vec2(4.0/RESOLUTION.y); \n\n  vec3 ww   = normalize(la - ro);\n  vec3 uu   = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv   = normalize(cross(ww,uu));\n  float rdd = 2.0;\n  vec3 rd   = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd  = normalize(np.x*uu + np.y*vv + rdd*ww);\n  \n  vec4 sph  = vec4(vec3(0.0), 1.78);\n  \n  vec2 si   = raySphere(ro, rd, sph);\n  \n  vec3 pos  = ro + rd*si.x;\n  \n  vec3 nor  = normalize(pos - sph.xyz);\n  \n  vec3 ref  = reflect(rd, nor); \n  vec3 nref = reflect(nrd, nor); \n\n  vec3 rbkg = render_background(pos, ref, nref); \n\n  vec4 col = vec4(rbkg, 1.0);\n  \n  col.xyz*=b;\n  col.w = a;\n  \n  \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 d   = df(p);\n\n  vec4 dcol = vec4(0.0, 0.0, 0.0, 0.5);\n  dcol.w    = mix(0.0, 0.95, smoothstep(-aa, aa, -d.x));\n  vec4 scol = render_iris(p, q, d.y); \n  \n  vec3 col  = vec3(1.0);\n  col = alphaBlend(col, dcol);\n  col = alphaBlend(col, scol);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1121, 1121, 1149, 1169, 1245], [1247, 1247, 1287, 1287, 1329], [1331, 1331, 1367, 1367, 1600], [1602, 1602, 1633, 1633, 1659], [1661, 1661, 1701, 1701, 1850], [1852, 1952, 1996, 1996, 2193], [2195, 2195, 2217, 2217, 2261], [2263, 2263, 2289, 2289, 2398], [2400, 2400, 2439, 2439, 2564], [2566, 2566, 2602, 2602, 2696], [2698, 2698, 2737, 2737, 2826], [2828, 2828, 2867, 2867, 2896], [2898, 2898, 2915, 2915, 3919], [3921, 3921, 3973, 3973, 5023], [5025, 5025, 5068, 5068, 5929], [5931, 5931, 5960, 5960, 6254], [6256, 6256, 6311, 6311, 6529]], "test": "error"}
{"id": "stSSRw", "name": "NUS sws3005-Ray tracing demo", "author": "uestcwzyyyyy", "description": "NUS sws3005 last assignment ", "tags": ["raytracing"], "likes": 11, "viewed": 206, "published": "Public API", "date": "1627295449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 6;\nconst int NUM_PLANES = 3;\nconst int NUM_SPHERES = 3;\n\n\nconst float initPosx=2.5;\nconst float initPosy=1.0;\nconst float initPosz=2.5;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec3 pos=vec3(initPosx,initPosy,initPosz);\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Cube_t\n{\n    vec3 leftBottom;\n    vec3 rightTop;\n    int materialID;\n};\n\n\nstruct Cone_t {\n\tfloat cosa;\n\tfloat h;\n\tvec3 c;\n\tvec3 v;\n\tint materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nCube_t cube;\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 3;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = -1.0;\n    Plane[1].C = 5.0;\n    Plane[1].D = 30.0;\n    Plane[1].materialID = 4;\n    \n    Plane[2].A = 5.0;\n    Plane[2].B = -1.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 30.0;\n    Plane[2].materialID = 5;\n\n    cube.leftBottom=vec3(-1.0,0,0);\n    cube.rightTop=vec3(-2,2.0,1.0);\n    cube.materialID=0;\n\n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 1.0, abs(sin(2.0 * iTime)) + 0.7, -1.0 );\n    Sphere[0].radius = 0.7;\n    Sphere[0].materialID = 1;\n\n    // Circling sphere.\n    Sphere[1].center = vec3( -1.5 + 1.0 * cos(iTime), 1.0 + 0.6 * sin(3.0 * iTime), 0.5 + 1.0 * sin(iTime) );\n    Sphere[1].radius = 0.2;\n    Sphere[1].materialID = 2;\n    \n    Sphere[2].center = vec3( 1.0 + cos(2.0 * iTime) , 1.7 + sin(2.0 * iTime), -1.0);\n    Sphere[2].radius = 0.1;\n    Sphere[2].materialID = 4;\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.9, 0.5, 0.3 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.5, 0.8, 0.3 );\n    Material[2].k_a = 0.4 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.3 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    Material[3].k_d = vec3( 0.3, 0.2, 0.2 );\n    Material[3].k_a = 0.4 * Material[3].k_d;\n    Material[3].k_r = 3.0 * Material[3].k_d;\n    Material[3].k_rg = 0.2 * Material[3].k_r;\n    Material[3].n = 64.0;\n\n    Material[4].k_d = vec3( 0.7, 0.9, 0.8 );\n    Material[4].k_a = 0.2 * Material[4].k_d;\n    Material[4].k_r = 2.0 * Material[4].k_d;\n    Material[4].k_rg = 0.5 * Material[4].k_r;\n    Material[4].n = 64.0;\n    \n    Material[5].k_d = vec3( 0.4, 0.4, 0.4);\n    Material[5].k_a = 0.2 * Material[5].k_d;\n    Material[5].k_r = 2.0 * Material[5].k_d;\n    Material[5].k_rg = 0.6 * Material[5].k_r;\n    Material[5].n = 128.0;\n    \n    // Light 0.\n    Light[0].position = vec3( 8.0* cos(iTime), 5.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( 1.0* cos(iTime)+5.0, 16.0, 1.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n\n    if (DdotV <= 0.0) {\n    \t// When the ray shoots towards the sphere\n    \tfloat discr = DdotV * DdotV - a0;\n    \tif (discr >= 0.0) {\n    \t\t// Smaller intersection point\n    \t\tt = -DdotV - sqrt(discr);\n    \t\thitPos = ray.o + t * ray.d;\n    \t\thitNormal = normalize(hitPos - sph.center);\n    \t\treturn (t >= tmin && t<= tmax);\n    \t}\n    }\n\treturn false;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n\n    if (DdotV <= 0.0) {\n    \t// When the ray shoots towards the sphere\n    \tfloat discr = DdotV * DdotV - a0;\n    \tif (discr >= 0.0) {\n    \t\t// Need to compare both intersection points\n    \t\tfloat t1 = -DdotV - sqrt(discr);\n    \t\tfloat t2 = -DdotV + sqrt(discr);\n    \t\treturn ((t1 >= tmin && t1<= tmax) || (t2 >= tmin && t2 <= tmax));\n    \t}\n    }\n\treturn false;\n}\n\n\nbool inPlane(vec3 pos,vec3 leftBottom,vec3 rightTop)\n{\n    bool x1=(pos.x<=leftBottom.x+DEFAULT_TMIN)&&(pos.x>=rightTop.x-DEFAULT_TMIN);\n    bool x2=(pos.y>=leftBottom.y-DEFAULT_TMIN)&&(pos.y<=rightTop.y+DEFAULT_TMIN);\n    bool x3=(pos.z>=leftBottom.z-DEFAULT_TMIN)&&(pos.z<=rightTop.z+DEFAULT_TMIN);\n    return x1&&x2&&x3;\n}\n\n\nbool IntersectCube_t( in Cube_t cubic, in Ray_t ray, in float tmin, in float tmax)\n{\n\n    vec3 leftBottom=cubic.leftBottom;\n    vec3 rightTop=cubic.rightTop;\n    Plane_t p;\n    float t1;\n    float tNow=tmax;\n    vec3 hitPos1;\n    vec3 hitNormal1;\n    vec3 hitNormalNow;\n    //compute X plane intersection\n    p.A=1.0;\n    p.B=0.0;\n    p.C=0.0;\n    p.D=-cubic.leftBottom.x;\n    \n    bool i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow &&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    p.A=1.0;\n    p.B=0.0;\n    p.C=0.0;\n    p.D=-cubic.rightTop.x;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    //compute Y plane intersection\n    p.A=0.0;\n    p.B=1.0;\n    p.C=0.0;\n    p.D=-cubic.leftBottom.y;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    p.A=0.0;\n    p.B=1.0;\n    p.C=0.0;\n    p.D=-cubic.rightTop.y;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    //compute Z plane intersection\n    p.A=0.0;\n    p.B=0.0;\n    p.C=1.0;\n    p.D=-cubic.leftBottom.z;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n\n    p.A=0.0;\n    p.B=0.0;\n    p.C=1.0;\n    p.D=-cubic.rightTop.z;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    if(tNow!=tmax&& tNow>tmin)\n    {\n        return true;\n    }\n    return false;\n}\n\n\n\n\nbool IntersectCube_t( in Cube_t cubic, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 leftBottom=cubic.leftBottom;\n    vec3 rightTop=cubic.rightTop;\n    Plane_t p;\n    float t1;\n    float tNow=tmax; //the min t in six planes\n    vec3 hitPos1;\n    vec3 hitNormal1;\n    vec3 hitNormalNow;\n    //compute X plane intersection\n    p.A=1.0;\n    p.B=0.0;\n    p.C=0.0;\n    p.D=-leftBottom.x;\n    \n    bool i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow &&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    p.A=1.0;\n    p.B=0.0;\n    p.C=0.0;\n    p.D=-rightTop.x;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    //compute Y plane intersection\n    p.A=0.0;\n    p.B=1.0;\n    p.C=0.0;\n    p.D=-cubic.leftBottom.y;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    p.A=0.0;\n    p.B=1.0;\n    p.C=0.0;\n    p.D=-cubic.rightTop.y;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    //compute Z plane intersection\n    p.A=0.0;\n    p.B=0.0;\n    p.C=1.0;\n    p.D=-cubic.leftBottom.z;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n\n    p.A=0.0;\n    p.B=0.0;\n    p.C=1.0;\n    p.D=-cubic.rightTop.z;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    if(tNow!=tmax&& tNow>tmin)\n    {\n        t=tNow;\n        hitPos = ray.o + t * ray.d;\n        hitNormal=hitNormalNow;\n        return true;\n    }\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n\n    for (int i = 0; i < NUM_SPHERES; i++ ) {\n    \ttemp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n    \tif (temp_hasHit && temp_t < nearest_t) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Sphere[i].materialID;\n    \t}\n    \t\n    }\n\n        temp_hasHit=IntersectCube_t(cube,ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t, temp_hitPos, temp_hitNormal);\n        \tif (temp_hasHit && temp_t < nearest_t) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = cube.materialID;\n    \t}\n\n\n    for (int i = 0; i < NUM_PLANES; i++ ) {\n    \ttemp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n\n    \tif (temp_hasHit && temp_t < nearest_t ) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Plane[i].materialID;\n    \t}\n    \t\n    }\n    \n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    // Compute lighting for each lights\n    Ray_t ShadowRay[NUM_LIGHTS];\n    bool L_shadow[NUM_LIGHTS];\n    for (int i = 0; i < NUM_LIGHTS; i++ ) {\n    \tShadowRay[i].o = nearest_hitPos;\n    \tShadowRay[i].d = normalize(Light[i].position - ShadowRay[i].o);\n\n    \tfor (int j = 0; j < NUM_SPHERES; j++ )\n    \t\tif(!L_shadow[i])\n    \t\tL_shadow[i] = IntersectSphere(Sphere[j], ShadowRay[i], DEFAULT_TMIN, distance(nearest_hitPos, Light[i].position));\n\n    \tif (!L_shadow[i])\n    \t\tfor(int j = 0; j < NUM_PLANES; j++ )\n    \t\t\tif(!L_shadow[i])\n    \t\t\t\tL_shadow[i] = IntersectPlane(Plane[j], ShadowRay[i], DEFAULT_TMIN, distance(nearest_hitPos, Light[i].position));\n\n        if(!L_shadow[i])\n    \t    L_shadow[i] = IntersectCube_t(cube, ShadowRay[i], DEFAULT_TMIN, distance(nearest_hitPos, Light[i].position));\n\n    \tI_local += PhongLighting( ShadowRay[i].d, nearest_hitNormal, - ray.d, L_shadow[i], Material[nearest_hitMatID], Light[i] );\n    }\n\n    \n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\nvec2 getKeyBoard()\n{\n\n    float x1=texelFetch( iChannel0, ivec2(KEY_LEFT,0), 0 ).x;\n    float x2=texelFetch( iChannel0, ivec2(KEY_RIGHT,0), 0 ).x;\n    float y1=texelFetch( iChannel0, ivec2(KEY_UP,0), 0 ).x;\n    float y2=texelFetch( iChannel0, ivec2(KEY_DOWN,0), 0 ).x;\n    return 5.0*vec2(x2-x1,y1-y2);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n\n    pos+=vec3(getKeyBoard(),0);\n    \n    \n    // Position the camera.\n    vec3 cam_pos = pos + vec3( 4.0 * cos(iTime / 1.5) + 1., 0.2 + 1.0 * sin(iTime / 3.0), 1.0 * sin(iTime / 2.0));\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSSRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2749, 2931, 2949, 2974, 5628], [5632, 6129, 6284, 6284, 6614], [6618, 6950, 7033, 7033, 7245], [7249, 7769, 7927, 8041, 8515], [8519, 8852, 8937, 9051, 9535], [9538, 9538, 9592, 9592, 9863], [9866, 9866, 9950, 9950, 12239], [12244, 12244, 12402, 12402, 14788], [14790, 15144, 15275, 15275, 15688], [15691, 16480, 16595, 16687, 20872], [20874, 20874, 20894, 20894, 21178], [21180, 21541, 21598, 21598, 23135]], "test": "error"}
{"id": "stSSWW", "name": "Fractal 71_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 7, "viewed": 205, "published": "Public API", "date": "1627656494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    O-=O;\n    vec3 r=iResolution,\n    p=vec3((C.xy-.5*r.xy)/r.y,0)-iTime*.05;\n    p=asin(sin(p*3.));\n    float s=1.,e;\n    for(int i=0;i<7;i++)\n        p=abs(p)-1.2,\n        s*=e=3./clamp(dot(p,p),.8,2.),\n        p=p*e-3.;\n        O.xyz+=mix(vec3(1),H(log(s)*.5),.7)*3e-3/abs(p.z/s);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 88, 88, 374]], "test": "valid"}
{"id": "stsXDl", "name": "Fractal 62_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 11, "viewed": 256, "published": "Public API", "date": "1626850961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        p=g*d;\n        p.z+=iTime*1.5;\n        a=10.;\n        p=mod(p-a,a*2.)-a;\n        s=6.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.4+sin(iTime*.1)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n         g+=e=length(p.yz)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 825]], "test": "valid"}
{"id": "stSXDR", "name": "data flowing animation", "author": "yasuo", "description": "data flowing", "tags": ["animation"], "likes": 4, "viewed": 256, "published": "Public API", "date": "1627408283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nvec3 randomPlot(vec2 p, vec3 col, float t){\n    p*=20.0;\n    p.x+=t;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n    gv.y = id.y;\n    \n    float n = Hash21(id);\n    float w = clamp(0.25*(n*2.0),0.1,1.0);\n    float d = B(gv,vec2(w,0.02));\n    float cn = clamp(n,0.5,1.0);\n    col = mix(col,vec3(cn,cn,cn),S(d,0.0));\n    return col;\n}\n\nconst float speeds[14] = float[](2., 3., 6., 3.5, 5., 7., 4.5, 7.5, 8.0, 9., 2.5, 6.5,10.0,5.3);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    float index = 0.07;\n    for(int i = 0; i<14; i++){\n        vec2 pos = uv+vec2(index,-0.5+(index));\n        col = randomPlot(pos, col, iTime*speeds[i]);\n        index+=0.07;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 177, 177, 267], [269, 269, 312, 312, 609], [708, 708, 765, 765, 1074]], "test": "valid"}
{"id": "stsXRB", "name": "Marching Bands", "author": "Taron", "description": "Sampling into a noise volume can yield rather beautiful mistakes...\nUse Mouse to look around!", "tags": ["raymarching", "bad", "fractalnoise", "volumn", "lousy"], "likes": 3, "viewed": 93, "published": "Public", "date": "1626005473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCT 2\n#define DEPTH 8.\nfloat hash(vec3 p)\n{\n\tp  = fract(p * .1337);\n    p += dot(p, p.zyx + 37.36);\n    return fract((p.x + p.y) * p.z);\n}\nfloat noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);  \n    vec3 u = smoothstep(0.,1.,f);\n    \n    vec2 oo = vec2(1.,0.);\n    \n    return mix(mix(mix(hash(i+oo.yyy),hash(i+oo.xyy),u.x),\n                   mix(hash(i+oo.yxy),hash(i+oo.xxy),u.x),u.y),\n               mix(mix(hash(i+oo.yyx),hash(i+oo.xyx),u.x),\n                   mix(hash(i+oo.yxx),hash(i+oo.xxx),u.x),u.y),u.z);\n}\n\nfloat turb(vec3 p, float noiseThreshold, float noiseSoftness, int oct, float dist)\n{\n    float r = 0.0,\n          w = 1.0, \n          s = 1.0,\n          d = 0.0;\n    for (int i=0; i<oct; i++)\n    {\n         r += w * noise(p);\n         d += w;\n         w *= 0.573;\n         p *= 1.677;\n     }\n    r = abs(-1.+2.*r/d);\n    return smoothstep(noiseThreshold,noiseSoftness+noiseThreshold,r)+(.1-dist);\n}\n\nfloat march(vec3 cp, vec3 cd){\n\tfloat dp=.25;\n    vec3 sp = cd*dp;\n    vec3 p = cp+sp;\n    float d = 1.;\n    float r = 1.;\n    int cnt = 0;\n    while(cnt<20 && d<DEPTH){\n        r = turb(p, .001, .125, OCT, min(.1,d-1.));\n        d +=r*dp+.1;\n        p +=r*sp+.1;\n        if(r<0.01){\n            d+=r/0.01 *2.;\n            break;\n        }\n\n        cnt++;\n    } \n    return d;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fC )\n{\n    vec2 uv = (fC.xy - iResolution.xy*.5)/iResolution.y;\n    vec2 ms = iMouse.xy/iResolution.xy * 6.28;\n\n    vec3 camera = vec3(0.);\n    vec3 target = vec3(uv*(.5+.5*dot(uv,uv)),.25);\n    target.yz *= Rot(-ms.y+sin(iTime*.25));\n    target.xy *= Rot(-ms.x+cos(iTime*.5));\n     \n    vec3 cdir = normalize(camera-target);\n   \n    vec3 p = camera-vec3(0.,0.,iTime*.25);\n    \n    float slow = iTime*.25;\n    vec3 kal = vec3(sin(slow+3.14),sin(slow*.91+1.95),sin(slow*.87+.45));\n    vec3 col = mix(vec3(1.85*turb(target, .417, .02, OCT+1,.1)),.5+.5*kal,march(p,cdir)/DEPTH*1.5);\n\n    col *=mix(vec3(1.),vec3(.75,.15,.01), dot(uv, uv));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 51, 51, 146], [147, 147, 171, 171, 543], [545, 545, 629, 629, 943], [945, 945, 975, 975, 1323], [1325, 1325, 1344, 1344, 1406], [1408, 1408, 1458, 1458, 2122]], "test": "valid"}
{"id": "stXSDs", "name": "Suborbital Flight", "author": "dr2", "description": "High flyer (guess who's not inside) with alternating inverted flight (mouseable - click in lower-right corner to override inversion)", "tags": ["space", "rocket", "aircraft"], "likes": 10, "viewed": 174, "published": "Public API", "date": "1626805528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Suborbital Flight\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // (= 0/1) optional antialiasing\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h);\nfloat PrAnConCylDf (vec3 p, vec2 cs, float r, float w, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat BumpFbm3 (vec3 p);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 rollCs;\nfloat tCur, dstFar, szFac, flRad, flLen;\nint idObj;\nbool invFly;\nconst int idFus = 1, idWng = 2, idEng = 3;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, w, s, dy;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  p.xy = Rot2Cs (p.xy, rollCs);\n  q = p;\n  w = 1.2;\n  dy = 0.;\n  if (q.z < -1.5) {\n    s = (q.z + 1.5) * (q.z + 1.5);\n    w *= 1. - 0.025 * s;\n  } else if (q.z > 2.) {\n    s = (q.z - 2.) * (q.z - 2.);\n    w *= 1. - 0.025 * s;\n    dy = -0.01 * s;\n  }\n  d = max (PrCapsDf (q - vec3 (0., dy, 0.), w, 7.5), - q.z - 6.);\n  DMINQ (idFus);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (1.7, -4.2);\n  d = max (max (- q.z - 1.6, dot (vec2 (q.y, dot (q.xz, sin (0.15 * pi + vec2 (0., 0.5 * pi)))),\n     sin (0.1 * pi + vec2 (0., 0.5 * pi))) - 1.6), q.y - 0.6);\n  d = max (d, - min (abs (PrBox2Df (q.xz - vec2 (2.6, -1.5), vec2 (1., 0.2))),\n     abs (PrBox2Df (q.yz - vec2 (-0.2, -1.5), vec2 (0.5, 0.2)))));\n  d = SmoothMax (d, abs (PrRoundBox2Df (q.xy, vec2 (4., 1.), 0.7)) - 0.04, 0.05);\n  DMINQ (idWng);\n  q = p;\n  q.z += 6.05;\n  d = PrCylDf (q, 0.4, 0.15);\n  q.z += 0.5;\n  d = min (d, PrAnConCylDf (q, sin (0.07 * pi + vec2 (0.5 * pi, 0.)), 0.45, 0.03, 0.35));\n  DMINQ (idEng);\n  return 0.5 * szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 240; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 CapsHit (vec3 ro, vec3 rd, float cRad, float cLen)\n{\n  float dIn, dOut, d, a, b, bs, w, s, ws, roz;\n  dIn = dstFar;\n  dOut = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - cRad * cRad);\n  if (w > 0. && a > 0.) {\n    ws = sqrt (w);\n    d = - (b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (d > 0. && abs (s) < cLen) dIn = d;\n    else {\n      roz = ro.z;\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) {\n        d = - bs - sqrt (w);\n        if (d > 0.) dIn = d;\n      }\n      ro.z = roz;\n    }\n  }\n  if (dIn < dstFar) {\n    d = (- b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (abs (s) < cLen) dOut = d;\n    else {\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) dOut = - bs + sqrt (w);\n    }\n  }\n  return vec2 (dIn, dOut);\n}\n\nfloat FlmDens (vec3 p)\n{ // (from \"Flaming Asteroids\")\n  float c;\n  c = max (0., 1.3 * BumpFbm3 (0.2 * vec3 (p.xy / flRad, 0.5 * p.z + 16. * tCur)) - 0.2 +\n     0.4 * smoothstep (-0.5 * flRad, 0.1 * flRad, p.z));\n  return c * (1. - smoothstep (-0.3 * flRad, 0., length (vec3 (p.xy,\n     p.z - clamp (p.z, - 2. * flLen, 0.))) - flRad * (1. + 0.8 * p.z / (2. * flLen)))) *\n     smoothstep (0., flRad, p.z + 2. * flLen);\n}\n\nvec4 FlmCol (vec3 ro, vec3 rd, vec2 dCyl2, float dstObj)\n{\n  vec4 col4;\n  vec3 q, c;\n  float s, ds, f, fn, r;\n  const float sMax = 50.;\n  ds = min (2. * flRad, dCyl2.y - dCyl2.x) / sMax;\n  s = dCyl2.x;\n  ro.z -= flLen;\n  q = ro + s * rd;\n  r = length (q.xy) / flRad;\n  q.xy = Rot2D (q.xy, 0.8 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n  fn = FlmDens (q);\n  col4 = vec4 (0.);\n  for (float j = float (VAR_ZERO); j < sMax; j ++) {\n    f = fn;\n    s += ds;\n    q = ro + (s + ds * Hashfv3 (16. * rd)) * rd;\n    r = length (q.xy) / flRad;\n    q.xy = Rot2D (q.xy, 0.8 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n    fn = FlmDens (q);\n    c = mix (mix (vec3 (1., 0.3, 0.1), vec3 (1., 1., 0.2), clamp ((0.3 / ds) * (f - fn), 0., 1.)),\n       vec3 (0.9, 0.8, 0.3), smoothstep (-0.5 * flRad, 0.2 * flRad, q.z)) *\n       (1. - smoothstep (-0.1, 0.1, s - dstObj));\n    col4 = col4 + (1. - col4.a) * vec4 (c, 1.) * f / sMax;\n    if (s > dstObj || col4.a > 1.) break;\n  }\n  return clamp (col4, 0., 1.);\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nvec3 StarPat (vec3 rd, float scl) \n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 8. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, dSph4, c;\n  vec3 col, vn, vnh, roo, rdo, q, stCol;\n  vec2 dCyl2;\n  float dstObj, dstGrnd, dstCld, s, spRad, h, clDens;\n  bool doRefl;\n  szFac = 0.5;\n  roo = ro;\n  rdo = rd;\n  doRefl = false;\n  dstGrnd = dstFar;\n  col = vec3 (0.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = vec4 (0.84, 0.84, 0.85, 0.3);\n    if (idObj == idFus) {\n      q = qHit;\n      q.z -= 1.;\n      s = 0.;\n      if (abs (q.z) < 3.6) {\n        q *= 0.6;\n        q.z = fract (q.z) - 0.5;\n        s = max (step (length (q.yz + vec2 (-0.2, 0.)), 0.22), step (0., q.y) *\n           step (length (q.xz), 0.22));\n      }\n      s = max (s, step (SmoothMax (PrRoundBox2Df (vec2 (abs (qHit.x) - 0.55, qHit.z) - vec2 (0., 5.6),\n         vec2 (0.3, 0.6), 0.1), - qHit.y + 0.2, 0.1), 0.));\n      if (s > 0.) {\n        doRefl = true;\n        col4 = vec4 (0.);\n      }\n      if (qHit.z < -5.9) col4 *= 0.5 + 0.5 * smoothstep (0.4, 0.45,\n         mod (16. * (atan (qHit.y, qHit.x) / (2. * pi) + 0.5), 1.));\n      if (qHit.y < 0.) {\n        col4 *= 0.7 + 0.3 * smoothstep (0., 0.02,\n           min (abs (PrBox2Df (vec2 (abs (qHit.x), qHit.z) - vec2 (0.35, -0.5), vec2 (0.35, 1.5))),\n           abs (PrBox2Df (vec2 (abs (qHit.x), qHit.z) - vec2 (0.15, 4.5), vec2 (0.15, 0.4)))) - 0.01);\n      }\n      col4.rgb = mix (col4.rgb, vec3 (0.3, 0.8, 0.8), smoothstep (0., 0.02, qHit.z - 7.5));\n    } else if (idObj == idWng) {\n      col4.rgb = mix (vec3 (0.3, 0.8, 0.8), col4.rgb, smoothstep (0., 0.02,\n         abs (length (qHit.xz - vec2 (2.5, -0.2)) - 0.5) - 0.1));\n    } else if (idObj == idEng) {\n      col4 = (PrConCylDf (qHit, sin (0.07 * pi + vec2 (0.5 * pi, 0.)), 0.45, 0.35) > 0.) ?\n         vec4 (0.7, 0.3, 0.3, 0.) * (0.8 + 0.2 * sin (16. * pi * qHit.z)) : vec4 (1., 0., 0., -1.);\n    }\n    col = col4.rgb;\n    if (col4.a >= 0.) col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n       col4.a * vec3 (1., 1., 0.9) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 64.);\n    else col *= 0.5 + 0.5 * max (- dot (rd, vn), 0.);\n  }\n  if (doRefl) {\n    rd = reflect (rd, vn);\n    col = vec3 (0.);\n    dstObj = dstFar;\n  }\n  if (dstObj >= dstFar) {\n    ro = roo;\n    spRad = 200.;\n    dSph4 = SphHit (ro - vec3 (0., - spRad - 5., 0.), rd, spRad);\n    dstGrnd = dSph4.x;\n    if (dstGrnd < dstFar && dstGrnd > 0.) {\n      ro += dstGrnd * rd;\n      vnh = dSph4.yzw;\n      ro.xz += vec2 (0., 0.5 * tCur);\n      h = Fbm2 (vec2 (0.23, 0.2) * ro.xz);\n      vn = VaryNf ((4. - 2. * step (0.45, h)) * ro, vnh, (0.1 + 2.9 * max (h - 0.45, 0.)) *\n         smoothstep (0.03, 0.1, - dot (vnh, rd)));\n      s = Noisefv2 (32. * ro.xz);\n      col4 = vec4 (0., 0.2, 1., 0.3) * (1. - 0.2 * s);\n      col4 = mix (col4, vec4 (0.8, 0.5, 0.2, 0.1) * (1. - 0.1 * s), step (0.45, h));\n      col4 = mix (col4, vec4 (0.4, 0.8, 0.4, 0.1) * (1. - 0.1 * s), smoothstep (0.46, 0.54, h));\n      col4 = mix (col4, vec4 (0.5, 0.7, 0.5, 0.1) * (1. - 0.2 * s), smoothstep (0.6, 0.7, h));\n      col4 = mix (col4, vec4 (1., 1., 1., 0.3) * (1. - 0.2 * s), smoothstep (0.75, 0.8, h));\n      col4.rgb = mix (col4.rgb, vec3 (1., 1., 0.8), 0.2);\n      col4 = mix (vec4 (0.6, 0.6, 0.9, 0.), col4, smoothstep (0.03, 0.1, - dot (vnh, rd)));\n      col4 = mix (vec4 (0.05, 0.05, 0.05, 0.), col4, smoothstep (0., 0.03, - dot (vnh, rd)));\n      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         col4.a * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 8.);\n      ro.xz += 0.1 * atan (sunDir.xz, sunDir.yy);\n      clDens = clamp (1.6 * Fbm2 (vec2 (0.4, 0.7) * ro.xz) - 0.4, 0., 1.);\n      col *= 1. - 0.3 * clDens;\n    }\n    ro = roo;\n    spRad = 250.;\n    dSph4 = SphHit (ro - vec3 (0., - spRad - 5., 0.), rd, spRad);\n    dstCld = dSph4.x;\n    if (dstCld < dstFar && dstCld > 0.) {\n      ro += dstCld * rd;\n      vnh = dSph4.yzw;\n      ro.xz += vec2 (0., 0.5 * tCur);\n      clDens = clamp (1.6 * Fbm2 (vec2 (0.4, 0.7) * ro.xz) - 0.4, 0., 1.);\n      col = mix (col, vec3 (1.) * (0.2 + 0.8 * max (dot (vnh, sunDir), 0.)), clDens *\n         smoothstep (0.11, 0.14, - dot (vnh, rd)));\n    }\n  }\n  ro = roo;\n  rd = rdo;\n  if (! doRefl) {\n    flRad = 0.4;\n    flLen = 20.;\n    ro.z += flLen + 7.4 * szFac;\n    dCyl2 = CapsHit (ro, rd, flRad, flLen);\n    if (dCyl2.x < min (min (dstObj, dstGrnd), dstFar)) {\n      c = FlmCol (ro, rd, dCyl2, dstObj);\n      col = mix (col, 3. * c.rgb, clamp (8. * c.a * c.a, 0., 1.));\n    }\n  }\n  stCol = StarPat (rd, 16.);\n  if (length (col) < 0.03) col = mix (col, stCol, step (Maxv3 (col), 0.4 * Maxv3 (stCol)));\n  if (doRefl && length (col) < 0.03) col += vec3 (0.15, 0.1, 0.);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  invFly = (mod (0.025 * tCur, 1.) > 0.5);\n  if (mPtr.z > 0. && mPtr.x > 0.4 && mPtr.y < -0.4) invFly = ! invFly;\n  rollCs = sin (0.1 * pi * sin (0.1 * pi * tCur) + (invFly ? pi : 0.) + vec2 (0.5 * pi, 0.));\n  if (invFly) uv *= -1.;\n  az = pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0. && ! (mPtr.x > 0.4 && mPtr.y < -0.4)) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.9 * pi * sin (0.01 * pi * tCur);\n    el -= 0.05 * pi * sin (0.012 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.01 * pi);\n  az = clamp (az, 0.1 * pi, 1.9 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -15.);\n  zmFac = 4.;\n  dstFar = 300.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  if (invFly) sunDir.xz *= -1.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h)\n{\n  return max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n}\n\nfloat PrAnConCylDf (vec3 p, vec2 cs, float r, float w, float h)\n{\n  return max (abs (dot (vec2 (length (p.xy) - r, p.z), cs)) - w, abs (p.z) - h);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat PerBumpf (float p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 PerBumpv3 (vec3 p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nfloat BumpFbm3 (vec3 p)\n{\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += PerBumpv3 (q + PerBumpv3 (q).yzx);\n    p *= 1.5;\n    f += a * (PerBumpf (p.z + PerBumpf (p.x + PerBumpf (p.y))));\n    q = 2. * q + 1.;\n    a *= 0.75;\n  }\n  return f;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXSDs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1077, 1077, 1099, 1099, 2175], [2177, 2177, 2210, 2210, 2393], [2395, 2395, 2416, 2416, 2671], [2673, 2673, 2730, 2730, 3605], [3607, 3607, 3631, 3661, 4026], [4028, 4028, 4086, 4086, 5033], [5035, 5035, 5078, 5078, 5279], [5281, 5281, 5317, 5317, 5770], [5772, 5772, 5807, 5807, 10448], [10450, 10450, 10506, 10506, 11943], [11945, 11945, 11978, 11978, 12067], [12069, 12069, 12116, 12116, 12163], [12165, 12165, 12207, 12207, 12258], [12260, 12260, 12303, 12303, 12367], [12369, 12369, 12423, 12423, 12496], [12498, 12498, 12563, 12563, 12646], [12648, 12648, 12670, 12670, 12708], [12710, 12710, 12755, 12755, 12847], [12849, 12849, 12894, 12894, 12932], [12934, 12934, 12964, 12964, 13077], [13079, 13079, 13110, 13110, 13174], [13176, 13176, 13212, 13212, 13418], [13420, 13420, 13446, 13446, 13508], [13510, 13510, 13535, 13535, 13597], [13599, 13599, 13624, 13624, 13887], [13921, 13921, 13945, 13945, 14010], [14012, 14012, 14036, 14036, 14148], [14150, 14150, 14175, 14175, 14361], [14363, 14363, 14384, 14384, 14539], [14541, 14541, 14570, 14570, 14782], [14784, 14784, 14823, 14823, 15075]], "test": "error"}
{"id": "stXSz8", "name": "folding Julia set", "author": "Shellderr", "description": "Julia set with distorted input coordinates. Use the mouse to change C.", "tags": ["fractal", "julia"], "likes": 2, "viewed": 139, "published": "Public API", "date": "1625114164", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define res iResolution\n#define thresh 20.\n#define stop 200\n\nvec3 rgb(float a){\n    a *=8.;\n    return(cos(4.+a+vec3(0.,2.,4.)*.7)*.5+.5);\n}\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2){\n    float a = (v1.x*v2.x+v1.y*v2.y)/(v2.x*v2.x+v2.y*v2.y);\n    float b = (v1.y*v2.x-v1.x*v2.y)/(v2.x*v2.x+v2.y*v2.y);\n    return vec2(a,b);\n}\n\nvec2 cexp(vec2 z){\n    return exp(z.x)*vec2(cos(z.y),sin(z.y));\n}\n\nvec2 clog(vec2 z){\n    return vec2(log(length(z)),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z, float c){\n    return cexp(c*clog(z));\n}\n\n\nvec2 clerp(vec2 a, vec2 b, float m){\n    m = clamp(m,0.,1.);\n    return cmul(vec2(1.-m),a)+cmul(vec2(m),b);\n}\n\n\nvec2 rot(vec2 v, float t){\n    float a = (1.*atan(v.x,v.y))+t;\n    return vec2(cos(a),sin(a))*length(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 z = .8*(2.*fragCoord.xy-res.xy)/res.y;\n    // z = rot(z,time);\n    //vec2 zz = vec2(0);\n    z = clerp(.3*clog(vec2(2)+z), (cdiv(vec2(.5),z)), .1);\n    // z = cexp(cmul(z,vec2(.4)));\n    z=rot(z,iTime*.3);\n    vec2 mouse = .5*iMouse.xy/res.xy;\n    vec2 c = mouse.xy==vec2(0)? vec2(-.77,-.22)/*vec2(cos(iTime*.4)-.3,-.66)*/: (2.*mouse.xy-1.);\n    int i = 0;\n    for(i; i < stop; i++){\n        z = cmul(z,z)+c;\n        if(length(z) > thresh)\n            break;\n    }\n    vec3 col = rgb(log(.9+float(i)/380.)*2.);\n    fragColor = vec4(col, 1.0 );\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXSz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 79, 79, 140], [142, 142, 168, 168, 225], [227, 227, 255, 255, 397], [399, 399, 417, 417, 464], [466, 466, 484, 484, 533], [535, 535, 562, 562, 592], [595, 595, 631, 631, 704], [707, 707, 733, 733, 813], [815, 815, 870, 870, 1424]], "test": "valid"}
{"id": "stXXRs", "name": "Sommarhack warped fbm", "author": "mrange", "description": "License CC0: Sommarhack warped fbm\nMore warped FBM stuff + sommarhack phoenix", "tags": ["fbm", "warp"], "likes": 5, "viewed": 207, "published": "Public API", "date": "1626296430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Sommarhack warped fbm\n//  More warped FBM stuff + sommarhack phoenix\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define TTIME           (TIME*TAU)\n#define DOT2(x)         dot(x, x)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n\nvec2 g_qx = vec2(0.0);\nvec2 g_qy = vec2(0.0);\n\nvec2 g_rx = vec2(0.0);\nvec2 g_ry = vec2(0.0);\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat noise(vec2 p) {\n  p /= pow(1.1 + 0.25*(0.5 + 0.5*sin(0.1*(p.x + p.y) + TTIME/10.0)), 1.15);\n  float a = sin(p.x);\n  float b = cos(p.y);\n  float c = sin(p.x + p.y);\n  float d = mix(a, b, c);\n  return tanh_approx(d);\n\n}\n\n// https://iquilezles.org/www/articles/fbm/fbm.htm\nfloat fbm(vec2 p) {    \n  const float A = 0.57;\n  const float F = 2.1;\n  const int numOctaves = 4;\n  const mat2 rots[numOctaves] = mat2[](F*ROT(0.0/float(numOctaves)), F*ROT(1.0/float(numOctaves)), F*ROT(2.0/float(numOctaves)), F*ROT(3.0/float(numOctaves)));\n\n  float t = 0.0;\n  float f = 1.0;\n  float a = 1.0;\n  for(int i = 0; i<numOctaves; ++i) {\n    t += a*noise(f*p);\n    p *= rots[i];\n    a *= A;\n  }\n\n  return tanh_approx(0.3+t);\n}\n\nconst float scale1 = 1.4;\nconst float scale2 = 0.2; \n\nvoid compute_globals(vec2 p) {\n  const vec2 qx = vec2(1.0,3.0)*scale2;\n  const vec2 qy = vec2(5.0,2.0)*scale2;\n\n  const vec2 rx = vec2(2.0,9.0)*scale2;\n  const vec2 ry = vec2(8.0,3.0)*scale2;\n  \n  g_qx = qx*ROT(TTIME/100.0);\n  g_qy = qy*ROT(TTIME/90.0);\n\n  g_rx = rx*ROT(TTIME/80.0);\n  g_ry = ry*ROT(TTIME/70.0);\n}\n\n// https://iquilezles.org/www/articles/warp/warp.htm\nvec3 warp(in vec2 p, float d) {\n  float lp = length(p);\n  p *= ROT(-TTIME/100.0 + 0.125*length(p));\n  \n  vec2 qx = g_qx;\n  vec2 qy = g_qy;\n\n  vec2 rx = g_rx;\n  vec2 ry = g_ry;\n\n  vec2 q = vec2(fbm(p + qx),\n                fbm(p + qy));\n\n  vec2 r = vec2(fbm(0.25*p + scale1*q + rx),\n                fbm(0.5*p + scale1*q + ry));\n\n  float f = fbm(0.75*p + scale1*r);\n \n  const vec3 col1 = vec3(0.1, 0.3, 0.8);\n  const vec3 col2 = vec3(0.7, 0.3, 0.5);\n\n  float scaleIt = 1.5*(pow(abs((p.x + p.y)), 0.7));\n\n  float pp= mix(0.7, 0.35, 1.5*tanh_approx(length(p)));\n\n  float fi = tanh_approx(pow(scaleIt, pp)*d / (f - d*scaleIt));\n  vec3 col =  abs(fi + 0.1)*(+0.3 + length(q)*col1 + length(r)*col2);\n  return pow(col, vec3(2.0, 1.5, 1.5)*tanh_approx(0.25*lp));\n}\n\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// Distance fields from: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))                         : length(p-vec2(-d,0.0))-r;\n}\n\nfloat moon(vec2 p, float d, float ra, float rb ) {\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n// Imprecise faster version\nfloat fastMoon(vec2 p, float d, float ra, float rb) {\n  float d0 = length(p) - ra;\n  float d1 = length(p-vec2(d, 0.0)) - rb;\n  return max(d0, -d1);\n}\n\nfloat roundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h); // k should be const at modeling time\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(DOT2(p-vec2(1,k)))  :\n           sqrt(min(DOT2(p-vec2(0,h)),\n                    DOT2(p-vec2(1,0))));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n \nfloat plane(vec2 p, vec3 pp) {\n  return dot(p, pp.xy) + pp.z;\n}\n \nfloat summerhack(vec2 p) {\n  // As the moon shapes are mostly used for cut-outs I think there is less need for exact\n  //  moon distance and therefore rely on fastMoon instead\n  vec2 op = p;\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0 -= vec2(0.0, 0.385);\n  float d0 = circle(p0, 0.605);\n  vec2 p1 = p;\n  p1 -= vec2(0.0, -0.375);  \n  float d1 = vesica(p1, vec2(0.04, 0.569))-(mix(0.005, 0.035, smoothstep(0.1, 0.2, p1.y)));\n  \n  vec2 p2 = p;\n  p2 -= vec2(0.0, 0.4);\n  p2 = -p2.yx;\n  float d2 = fastMoon(p2, 0.075, 0.33, 0.275);\n  \n  vec2 p3 = p;\n  p3 -= vec2(0.0, 0.65);\n  float d3 = circle(p3, 0.367);\n  \n  vec2 p4 = p;\n  p4 -= vec2(0.0, 0.43);\n  float d4 = circle(p4, 0.29);\n  \n  vec2 p5 = p;\n  p5 -= vec2(-0.185, 0.12);\n  float d5 = circle(p5, 0.30);\n  \n  vec2 p6 = p;\n  p6 -= vec2(0.12, -0.19);\n  p6 *= ROT(0.65);\n  float d6 = vesica(p6, vec2(0.15, 0.024))-0.0175;\n  \n  vec2 p7 = p;\n  p7 -= vec2(0.0, 0.735);\n  p7 = -p7.yx;\n  float d7 = fastMoon(p7, 0.13, 0.68, 0.595);\n  \n  vec2 p8 = p;\n  p8 -= vec2(0.0, 0.7);\n  p8 = -p8.yx;\n  float d8 = fastMoon(p8, 0.1, 0.477, 0.4676);\n\n  vec2 p9 = p;\n  p9 -= vec2(0.25, 0.72);\n  p9.x = -p9.x;\n  float d9 = fastMoon(p9, 0.188, 0.73, 0.775);\n\n  vec2 p10 = op;\n  p10 -= vec2(0.0, 0.28);\n  p10 = p10.yx;\n  p10.x *= sign(op.x);\n  p10.x += (-sign(op.x)+1.0)*-0.0775;\n  float d10 = moon(p10, 0.045, 0.105, 0.095);\n\n  vec2 p11 = p;\n  p11 -= vec2(0.0, -0.78);\n  p11 = p11.yx;\n  float d11 = roundedCross(p11, 0.55);\n  \n  vec2 p12 = p;\n  float d12 = plane(p12, vec3(normalize(vec2(-4.0, 1.0)), 0.315));\n  \n  vec2 p13 = p;\n  p13 -= vec2(-0.05, -0.805);\n  float d13 = circle(p13, 0.175);\n\n  vec2 p14 = p;\n  p14 -= vec2(0.0, -0.88);\n  float d14 = p14.y;\n  \n  vec2 p15 = p;\n  p15 -= vec2(0.45, -0.4);\n  p15 = p15.yx;\n  float d15 = fastMoon(p15, 0.14, 0.4, 0.4);\n\n  vec2 p16 = op;\n  p16 -= vec2(-0.095, 0.323);\n  // Cheat to remove discontinuity in distance field due to hacking on d10\n  float d16 = length(p16); \n    \n  d11 = max(d11, -d13);\n  d11 = max(d11, -d14);\n  d11 = max(d11, -d15);\n  d11 = pmax(d11, -d12, 0.0125);\n\n  float dn = d3;\n  dn = min(dn, d4);\n  dn = min(dn, d2);\n  dn = min(dn, d5);\n  dn = min(dn, d6);\n  dn = min(dn, d7);\n  dn = min(dn, d8);\n  dn = min(dn, d9);\n\n  float d = d0;\n  d = max(d, -dn);\n  d = min(d, d1);\n  d = min(d, d10);\n  d = min(d, d11);\n  d = min(d, d16);\n  \n  \n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  compute_globals(p);\n  float aa = 2.0 / RESOLUTION.y;\n \n  vec3 col = vec3(0.0);  \n  float d = summerhack(p);\n  vec2 c = vec2(0.0, 0.385);\n  \n  const vec3 lcol2 = vec3(1.2, 1.3, 2.0)*1.5;\n  col = warp(p*6.0, d-0.05);\n  col = mix(2.0, 0.5, smoothstep(0.605, 1.5, length(p-c)))*col;\n  col = col;\n\n  col += lcol2*exp(-40.0*max(abs(d-mix(-0.05, -0.01, q.y)), 0.0));\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));\n  col = mix(col, vec3(0.25*(lcol2*lcol2)*smoothstep(0.56, 0.8, q.y)), smoothstep(-aa, aa, -(d+aa*2.5)));\n  return col.zyx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  \n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXXRs.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[487, 544, 583, 583, 672], [674, 674, 713, 713, 742], [744, 744, 772, 792, 868], [870, 870, 891, 891, 1093], [1639, 1639, 1669, 1669, 1953], [1955, 2008, 2039, 2039, 2763], [2766, 2766, 2797, 2797, 2823], [2825, 2922, 2953, 2953, 3248], [3250, 3250, 3300, 3300, 3577], [3579, 3607, 3660, 3660, 3756], [3758, 3758, 3803, 3803, 4055], [4057, 4057, 4084, 4084, 4164], [4167, 4167, 4197, 4197, 4230], [4233, 4233, 4259, 4408, 6566], [6568, 6568, 6604, 6604, 6837], [6839, 6839, 6868, 6868, 7409], [7411, 7411, 7468, 7468, 7659]], "test": "error"}
{"id": "stXXzS", "name": "AntiPod - Heliolite", "author": "Flopine", "description": "A shader made as a loop for a track from ThronoCrigger, check out his album!!! \nhttps://thronocrigger.bandcamp.com/album/simulacra", "tags": ["2d", "noise", "animation", "pastel", "mograph"], "likes": 9, "viewed": 132, "published": "Public", "date": "1625933749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n#define TAU 6.283185\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define BPM (95./60.)\n#define dt(sp,off) fract((iTime+off)*sp)\n#define animCirc(speed,off) easeInOutCirc(time(speed,off))\n\n// UE Documentation for blend references\n// https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/Functions/Reference/Blends/index.html\n#define bright_calc(color) (0.2126*color.x + 0.7152*color.g + 0.0722*color.b)\n\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat background (vec2 uv)\n{\n    float rep = 256.;\n    uv.x += dt(1./(rep*1.5),0.)*rep;\n    return min(\n        \t\tlength(uv-0.5)-(.5-texNoise(uv*vec2(0.1,.5)).x),\n        \t\t\tmin(\n        \t\t \t\tlength(uv+vec2(0.9,0.5))-(.8-texNoise(uv*vec2(0.1,.5)).y),\n                        length(uv+vec2(-0.1,0.2))-(.4-texNoise(uv*vec2(0.1,.3)).x)\n                        )\n                     );\n}\n\nfloat foreground (vec2 uv)\n{\n    float rep = 256.;\n    uv.x -= dt(1./(rep*1.5),0.)*rep;\n    return min(\n        \t\tlength(uv-0.5)-(.5-texNoise(uv*vec2(0.1,.5)).x),\n        \t\t\tmin(\n        \t\t \t\tlength(uv+vec2(0.9,0.5))-(.8-texNoise(uv*vec2(0.1,.5)).y),\n                        length(uv+vec2(-0.1,0.2))-(.4-texNoise(uv*vec2(0.1,.3)).x)\n                        )\n                     );\n}\n\nvec3 palette (float t,vec3 d)\n{return vec3(0.7)+vec3(0.4)*cos(TAU*(vec3(1.)*t+d));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 backuv = vec2(uv.x * texNoise(uv*0.2).x*0.6, uv.y);\n    vec2 foreuv = backuv*rot(PI/4.);\n       \n    vec3 col1 = clamp(palette(background(backuv),vec3(0.9,0.7,0.5)),0.,1.);\n    vec3 col2 = clamp(palette(foreground(foreuv),vec3(0.7,0.8,0.4)),0.,1.);\n    \n    // to get brightness of a color\n    float b1 = bright_calc(col1);\n    float b2 = bright_calc(col2);\n    \n    // blend lighten\n    vec3 col = (b1<b2)? col2:col1;\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[800, 927, 951, 951, 1189], [1191, 1191, 1219, 1219, 1576], [1578, 1578, 1606, 1606, 1963], [1965, 1965, 1996, 1996, 2048], [2050, 2050, 2107, 2107, 2639]], "test": "error"}
{"id": "wlX3Rr", "name": "UFO? (Apr 16 2019)", "author": "hmaon", "description": "old WIP prototype for the \"Party Ship\" 4k intro, released to a collective yawn from the audience at Revision 2019\nIt implements simple raymarched volumetric lighting.\n", "tags": ["raymarching"], "likes": 10, "viewed": 75, "published": "Public", "date": "1625280959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// 7/3/21 - tweaked some raymarching limits for slight performance improvements\n\nvec4 Ls[3];\nvec3 colors[3];\nfloat outer_radius=50.0;\n\nvec3 ufoPos;\n\nconst int NUM_LS=2;\nconst float MAX_DISTANCE=160.0;\n\nconst float PI=3.14159;\nconst float PI2=PI*2.;\nconst float modVal=13.;\nconst float stepbias=0.05;\n\nvec4 bgA=vec4(.1,.2,.9,1.0);\nvec4 bgB=vec4(.1,.5,.1,1.);\n\nvec3 origin;\nvec3 ray;\nfloat fresnel;\nfloat trav;\n\nstruct Detc\n{\n    float d;\n    vec4 c;\n} df;\n\n    \nDetc opU(Detc a,Detc b)\n{\n    if (a.d<=b.d) return a;\n    else return b;\n}\n\nDetc opI(Detc a,Detc b)\n{\n    if (a.d >=b.d) return a;\n    else return b;\n}\n\nDetc opSub(Detc a,Detc b)\n{\n    b.d*=-1.;\n    b.c=a.c;\n    if (a.d >b.d) return a;\n    else return b;\n}\n\n\nvec2 texUV;\n\n// primitives mainly copied from iq's codes\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n}\n\nDetc deBox(vec3 p,vec3 b,vec4 col)\n{\n    return Detc(sdBox(p,b),col);\n}\n\nDetc deSphere(vec3 p,float r,vec4 col)\n{\n    return Detc(length(p)-r,col);\n}\n\nDetc deTorus(vec3 p, vec2 t, vec4 col)\n{\n    return Detc(length( vec2(length(p.xy)-t.x,p.z) )-t.y, col);\n}\n\n\n// ping-pong function\nfloat pp(float x,float lim)\n{\n    return abs(mod(x,lim*2.)-lim);\n}\n\n// vec2 ping-pong function!\nvec2 pp(vec2 a,float lim)\n{\n    return abs(mod(a,vec2(lim*2.))-lim);\n}\n    \nDetc mapEtc(in vec3 point);\nfloat map(in vec3 point)\n{\n    return mapEtc(point).d;\n}\n\n// also from iq somewhere\nvec3 rayDirection(float fieldOfView,vec2 size,vec2 fragCoord) {\n    vec2 xy=fragCoord-size / 2.0;\n    float z=size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy,-z));\n}\n\n// so's this, from iq that is\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e=vec2(1.0,-1.0)*0.5773*0.0005;\n\n    return normalize(e.xyy*map(pos+e.xyy)+\n                      e.yyx*map(pos+e.yyx)+\n                      e.yxy*map(pos+e.yxy)+\n                      e.xxx*map(pos+e.xxx));\n}\n\n\nvec3 doLRay(vec3 origin,vec3 normal,int shadowLimit,float absorption)\n{    \n    vec3 diffuse=vec3(0.);\n    \n    for (int i=0; i<NUM_LS; i++)\n    {    \n        \n        vec3 p=origin;\n        vec3 Ldir=(Ls[i].xyz+texture(iChannel0,(p.xy+p.zz)*.005).rgb*.75)-p;\n        float LDD=dot(Ldir,Ldir);\n        float LD=sqrt(LDD); // magnitude of Ldir\n        float lum=Ls[i].a / LDD;\n        Ldir=Ldir / LD; // normalize(Ldir)\n        float nld=dot(normal,Ldir);\n        \n        nld=normal.x<1.5 ? 1. : nld;\n        \n        if (nld >0.99)\n        {             \n            float strav=0.;\n            vec3 ray=Ldir;\n            p+=normal*0.08;\n            for (int j=0; j<=shadowLimit; j++)\n            {\n               float shadowd=map(p);\n\n               p+=ray*(shadowd+stepbias);\n               strav+=shadowd+stepbias;\n                \n               if (strav >LD)\n               {         \n                   diffuse+=colors[i]*nld*lum*mix(1.,1./strav,absorption); \n                   break;\n               }\n\n               if (shadowd<stepbias)\n               {\n                   \n                   break;\n               }\n            }\n        }\n    }    \n    \n    return diffuse;\n}\n\n\n\nvec4 doRay(int limit,int shadowLimit)\n{   \n\n    trav=.0;\n    float d;\n    vec3 diffuse=vec3(0.);\n    vec3 vol=vec3(0.);\n    \n    vec3 p=origin; \n    vec3 prevp=p;\n    float debug=0.;\n        \n    df=Detc(9999.,vec4(0.));\n    \n    for (int i=0; i<=limit;++i) \n    {\n        df=mapEtc(p);\n        d=df.d;\n\n        if (trav >MAX_DISTANCE || i ==limit)\n        {\n            return vec4(sqrt(vol),0.); // sometimes you just have to sqrt() a value for the look\n        }\n        \n        if (d<stepbias)\n        {\n            break;\n        }\n        \n        \n        vol+=doLRay((prevp+p)*.5,vec3(-2.,0.,0.),12,.4)*.2*length(prevp-p); // comment this out for great fps\n        \n        d=min(d,.85);\n                \n        prevp=p;\n        p=p+ray*(d+stepbias);\n        trav+=d+stepbias;\n    }\n    \n    vec3 normal=calcNormal(p);\n    \n    float c1=-dot(normal,ray);\n    vec3 R1=ray+(2.0*normal*c1);\n    fresnel=1.25-.5* abs(c1);\n    origin=p;\n        \n\n    texUV=normal.xz+p.yy*.001;\n    vec4 tex=vec4(1.0);\n    tex*=df.c;\n            \n    vec3 amb=vec3(0.2,0.1,0.1);    \n\n    diffuse=doLRay(p,normal,shadowLimit,0.);\n    \n    ray=R1;\n    \n    vec4 color=vec4(sqrt(vol)+tex.rgb*(amb+diffuse),tex.a);\n    \n    return color;\n}\n\n\nvec4 doFragment(in vec2 fragCoord)\n{\n    origin=vec3(0.0,0.0,1.0);\n    \n    ray=rayDirection(60.0,iResolution.xy,fragCoord);\n\n    vec4 baseColor=doRay(108,24);\n    \n    vec4 reflection=vec4(0.);\n    \n     \n    if (trav<MAX_DISTANCE)\n    {\n        origin+=ray*0.2;\n        reflection=doRay(64,16)*fresnel; // reflections also hit FPS and aren't needed to demonstate the volumetric lighting effect\n    }\n        \n    vec3 c=max(baseColor,(reflection*0.7)*baseColor.a).rgb; // a bit of a hack here\n    return vec4(c,1.0);        \n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    colors[0]=vec3(.1,.2,.9);\n    colors[1]=vec3(.1,.5,.1);\n    colors[2]=vec3(.1,.1,.7);\n    ufoPos=vec3(cos(iTime*.5)*7.,sin(iTime)*3.,-30.);\n    Ls[1]=vec4(ufoPos+vec3(sin(iTime*5.),0.0,cos(iTime*3.))*.3,33.0);\n    \n    Ls[0]=Ls[1]+vec4(cos(iTime)*9., sin(iTime)*9.,cos(iTime*2.3)*9.,0.0);\n    Ls[0].a=6.0;\n   \n    fragColor=doFragment(fragCoord);\n}\n \n\nDetc mapEtc(in vec3 p)\n{    \n    const vec4 red=vec4(1.0,.2,.2,.35);\n    const vec4 green=vec4(.2,1.0,.2,.35);\n    const vec4 blue=vec4(.2,.2,1.0,.35);\n\n    float mt=mod(iTime,PI2);\n    \n    vec3 pos=ufoPos;\n    \n    Detc df=Detc(9999.,vec4(0));    \n    \n    df=opU(df,deSphere(p-pos+vec3(0.,6.,0.),10.,red+green));  // UFO\n    df=opI(df,deSphere(p-pos-vec3(0.,6.,0.),10.,blue+green)); // UFO\n\n    const float r=4.0;\n    const float y=-1.6;\n    const float sr=2.;\n    \n    // portholes?\n    for (int i=0; i<4; i++)\n    {\n        float th=float(i)*PI*.5+mt;\n        df=opSub(df,deSphere(p-pos-vec3(cos(th)*r,y /* +sin(th+iTime*3.22) */,sin(th)*r),sr,red));\n    }\n        \n    df=opSub(df,deSphere(p-pos-vec3(0.,-.55,0.),2.7,red)); // internal cavity\n    \n    df=opSub(df,deSphere(p-pos-vec3(0.,4.,0.),2.3,red)); // top window\n\n    float s=sin(iTime*.3), c=cos(iTime*.3);\n    vec3 ppp = p-Ls[0].rgb;\n    vec3 pppp;    \n    pppp.x = c * ppp.x + s * ppp.y;\n    pppp.y = -s * ppp.x + c * ppp.y;\n    pppp.z = ppp.z;\n    \n    //df=opU(df, deTorus(pppp, vec2(2., .5), green));  // unfinished framerate-killing donut thing\n    \n    return df;\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlX3Rr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 487, 487, 536], [538, 538, 563, 563, 613], [615, 615, 642, 642, 718], [734, 778, 806, 806, 891], [893, 893, 929, 929, 964], [966, 966, 1006, 1006, 1042], [1044, 1044, 1084, 1084, 1150], [1153, 1175, 1204, 1204, 1241], [1243, 1271, 1298, 1298, 1341], [1375, 1375, 1401, 1401, 1431], [1433, 1459, 1522, 1522, 1647], [1649, 1679, 1709, 1709, 1929], [1932, 1932, 2003, 2003, 3122], [3126, 3126, 3165, 3165, 4349], [4352, 4352, 4388, 4388, 4880], [4882, 4882, 4936, 4936, 5289], [5293, 5293, 5317, 5317, 6428]], "test": "error"}
{"id": "wsdXzl", "name": "HypnotoadEye", "author": "bryan_smyth", "description": "Can I make the Hypnotoad's eye?", "tags": ["learning"], "likes": 1, "viewed": 54, "published": "Public", "date": "1625846187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.14159;\n\nfloat midpupil(vec2 uv, float time, float lr_split)\n{\n    // Time varying pixel color\n    uv.y += sin(time*10.0+lr_split)*0.06;\n    uv.y *= 1.1 + (cos(time*3.0)*0.25);\n    uv.x += sin(time*4.0+(pi*lr_split))*0.03;\n    float iris = smoothstep(0.0, 0.38, length(uv));\n    uv.x *= 0.6;\n    float sidemove = cos(time*3.33+uv.x*(lr_split-0.5))*0.12;\n    uv.x -= sidemove;\n    float liris = smoothstep(0.0, 0.17, length(uv));\n    uv.x += sidemove*2.0;\n    uv.y += sin(time*(11.0*(lr_split-0.5)))*0.022;\n    float riris = smoothstep(0.0, 0.17, length(uv));\n    return iris * liris * riris;\n    \n}\n\nfloat roundeye(vec2 uv)\n{\n \treturn smoothstep(0.0, 0.7, length(uv));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float lr_split = step(uv.x, 0.5);\n    uv.x *= (iResolution.x/iResolution.y);\n    uv.x = fract(uv.x);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv.x += 0.2;\n    \n    vec3 skin = vec3(0.3, 0.25, 0.07);\n    vec3 iris = vec3(0.6, 0.58, 0.03);\n    vec3 yellow = vec3(1.0, 0.88, 0.1);\n    vec3 red = vec3(1.0, 0.0, 0.0);\n    \n    float pupil = midpupil(uv, iTime, lr_split);\n    float pupil_max = 1.0 - step(pupil, 0.9);\n    float pupil_mid = 1.0 - step(pupil, 0.75);\n    float pupil_min = 1.0 - step(pupil, 0.45);\n    \n    float eye = roundeye(uv);\n    float eye_big_circle = 1.0 - step(eye, 0.99);\n    float eye_small_circle = step(eye, 0.986);\n    skin *= eye_big_circle;\n    skin += iris * eye_small_circle * pupil_max;\n    float flicker = 1.0 - ((sin(iTime*30.0) + (pi*0.5)) / (pi*2.0));\n    skin += yellow * (1.0 - pupil_max) * flicker;\n    skin *= pupil_mid;\n    skin += red * (1.0 - pupil_mid) * flicker;\n    skin *= pupil_min;\n\n    // Output to screen\n    fragColor = vec4(skin, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdXzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 74, 106, 610], [612, 612, 637, 637, 682], [685, 685, 742, 792, 1818]], "test": "valid"}
{"id": "XsBfWd", "name": "SinWave", "author": "johannesCmayer", "description": "Wave", "tags": ["sin"], "likes": 0, "viewed": 123, "published": "Public API", "date": "1625659993", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime * 5.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color;\n    \n    if(uv.y*(3. + sin(t)) >= sin(uv.x*(20. + sin(t)) + -t) + 1.5 && uv.y*(3. + sin(t)) <= sin(uv.x*(20. + sin(t)) + -t) + 1.6)\n    \tcolor = vec4(1.,0.,0.,1.);\n    else\n    \tcolor = vec4(0.,0.,0.,1.);\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBfWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 374]], "test": "valid"}
