{"id": "4dlSDB", "name": "Sound Viz Experiment", "author": "xbe", "description": "Kinda old-school sound visualization experiment. From spectrum data, simply adding increasing frequency sinusoidal patterns. Plus some distortion to polish final rendering. Still need improvement on coloration. Click to visualize without distortion.", "tags": ["2d", "sound", "oldschool"], "likes": 6, "viewed": 302, "published": "Public", "date": "1406454507", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////\n// XBE\n// Sound Visualization Experiment\n///\n\n#define FULLCOLOR\n#define COLORCYCLING\n\n// Noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404;\n\tconst float K2 = 0.211324865;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat T = iTime;\n\tfloat T2 = 2.*iTime;\n\tfloat T3 = 3.*iTime;\n\tfloat T_20 = iTime/20.;\n\t//\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = 2.*uv-1.;\n\tq.y *= iResolution.y/iResolution.x;\n\n\tif (iMouse.w<=0.)\n\t{\n\t\t// Synchronized rotation\n\t\tfloat a = 2. * ( texture(iChannel0, vec2(0.1,0.)).x + noise(vec2(0., T_20)) );\n\t\tmat2 rotmat = mat2(cos(a), -sin(a), sin(a), cos(a));\n\t\tq = rotmat*q;\n\t\t// Synchronized Zoom/Distortion\n\t\tq *= .5 + 3.* (texture(iChannel0, vec2(0.75,0.)).x) + noise(vec2(q.x, T_20));\n\t\t// Synchronized translation\n\t\tq += 2.*vec2( texture(iChannel0, vec2(0.35,0.)).x, texture(iChannel0, vec2(0.95,0.)).x);\n\t}\n\t\n\t// Summing the sinusoid\n\tvec3 col = vec3(0.);\n\tfloat inc = 1./32.;\n\tfloat f=0.;\n\tfloat t=0.;\n\tfloat d=0.;\n\tfor (int i=0; i<32; i++)\n\t{\n\t\tf = 3.14159*32.*(inc+t);\n#ifdef COLORCYCLING\n\t\td = fract( texture(iChannel0, vec2(t,0.)).x + T );\n#else\n\t\td = fract( texture(iChannel0, vec2(t,0.)).x );\n#endif\n#ifdef FULLCOLOR\n\t\tcol += sin(f*q.x) * sin(f*q.y) * hsv2rgb(vec3(d,1.,0.5));\n#else\n\t\tcol += d * sin(f*q.x) * sin(f*q.y) * vec3(1.);\n#endif\n\t\tt += inc;\n\t}\n\tcol = clamp(sqrt(col), 0., 1.);\n\t// Vignetting\n\tvec2 r = -1.0 + 2.0*(uv);\n\tfloat b = max(abs(r.x), abs(r.y));\n\tcol *= (0.15 + 0.85*(1.0-exp(-(1.0-b)*30.0)));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 146, 167, 167, 286], [288, 288, 314, 314, 736], [738, 797, 819, 819, 979], [981, 981, 1038, 1038, 2311]], "test": "error"}
{"id": "4dlSRX", "name": "For the love of polygons", "author": "mi_ku", "description": "Shader that will take you back in time to the low-poly era", "tags": ["3d", "raytracing", "raymarching", "triangles", "polygons", "lowpoly"], "likes": 63, "viewed": 2405, "published": "Public", "date": "1405028248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// mi-ku / altair\n\n#define STEPS 50\n#define EPSILON 0.001\n//#define FLAT_SHADING\n#define BORDER_LINES\n#define BORDER_THICKNESS 1.0\n//#define FLAT_GROUND\n#define TRIANGLE_BG\n\n// iq's sSqdSegment and sdTriangle functions from: https://www.shadertoy.com/view/XsXSz4\n// squared distance to a segment (and orientation)\nvec2 sSqdSegment( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot( pa-ba*h, pa-ba*h ), pa.x*ba.y-pa.y*ba.x );\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 v1, in vec2 v2, in vec2 v3, in vec2 p )\n{\n\tvec2 d = min( min( sSqdSegment( v1, v2, p ), \n\t\t\t\t\t   sSqdSegment( v2, v3, p )), \n\t\t\t\t       sSqdSegment( v3, v1, p ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// background\nvec3 shadeBG( vec2 uv, float sp )\n{\n\tfloat sp2 = texture( iChannel0, vec2( 0.25, 0.0 ) ).r;\n\t// TRIANGLE BG\n#ifdef TRIANGLE_BG\n\tvec2 v2 = vec2( -0.12, 0.1 );\n\tvec2 v1 = vec2( 0.12, 0.1 );\n\tvec2 v3 = vec2( 0.0,  0.4 );\n\tfloat vadd1 = sp * 0.1;\n\tfloat vadd2 = sp2;\n\tfloat triDist1 = min( 1.0, ( 300.0 * \n\t\t\t\t\t\tsdTriangle( v1 + vec2( vadd1, -vadd1 ), v2 + vec2( -vadd1, -vadd1 ), v3 + vec2( 0.0, vadd1 ), uv ) ) );\n\tif ( triDist1 < 0.0 ) // todo: optimize branch\n\t{\n\t\ttriDist1 = pow( smoothstep( 0.0, 1.0, abs( triDist1 * 0.05 ) ), 0.1 );\n\t}\n\ttriDist1 = max( 0.6, triDist1 );\n\treturn vec3( triDist1 ) * \n\t\tvec3( 1.0, 0.95, 0.975 );\n#else\n\t// SPHERE BG\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y -= 0.25;\n\t\n\tvec3 color = vec3( 1.0, 1.0, 1.0 );\n\t\n\tfloat l1 = pow( max( 0.0, min( 1.0, length( uv ) * 4.0 * ( 1.0 + sp  ) ) ), 10.0 );\n\tfloat l2 = pow( max( 0.0, min( 1.0, length( uv ) * 6.0 * ( 1.0 + sp2 ) ) ), 10.0 );\n\treturn color * ( max( 1.0 - l1, l2 ) );\n#endif\n}\nint triIsect( const vec3   V1,  // Triangle vertices\n\t\t\t  const vec3   V2,\n\t\t\t  const vec3   V3,\n\t\t\t  const vec3    O,  //Ray origin\n\t\t\t  const vec3    D,  //Ray direction\n\t\t\t  out float res )\n{\n  vec3 e1, e2;  //Edge1, Edge2\n  vec3 P, Q, T;\n  float det, inv_det, u, v;\n  float t;\n \n  e1 = V2 - V1;\n  e2 = V3 - V1;\n\n  P = cross( D, e2 );\n  det = dot( e1, P );\n  if(det > -EPSILON && det < EPSILON) return 0;\n  inv_det = 1.0 / det;\n \n  T = O - V1;\n \n  u = dot(T, P) * inv_det;\n  if(u < 0. || u > 1.) return 0;\n \n  Q = cross( T, e1 );\n \n  v = dot(D, Q) * inv_det;\n  if(v < 0. || u + v  > 1.) return 0;\n \n  t = dot(e2, Q) * inv_det;\n \n  if(t > EPSILON) { //ray intersection\n    res = t;\n    return 1;\n  }\n \n  return 0;\n}\nint triIsectNC( const vec3   V1,  // Triangle vertices\n\t\t\t const vec3   V2,\n\t\t\t const vec3   V3,\n\t\t\t const vec3    O,  //Ray origin\n\t\t\t const vec3    D,  //Ray direction\n\t\t\t out float res )\n{\n  vec3 e1, e2;  //Edge1, Edge2\n  vec3 P, Q, T;\n  float det, inv_det, u, v;\n  float t;\n \n  e1 = V2 - V1;\n  e2 = V3 - V1;\n\n  P = cross( D, e2 );\n  det = dot( e1, P );\n  if(det > -EPSILON && det < EPSILON) return 0;\n  inv_det = 1.0 / det;\n \n  T = O - V1;\n \n  u = dot(T, P) * inv_det;\n \n  Q = cross( T, e1 );\n \n  v = dot(D, Q) * inv_det;\n \n  t = dot(e2, Q) * inv_det;\n \n  if(t > EPSILON) { //ray intersection\n    res = t;\n    return 1;\n  }\n \n  return 0;\n}\n\nvec3 polygonalGround( vec3 pos, float zshift, float sp )\n{\n\tfloat gridSize = 1.0;\n\tpos.z += zshift;\n\tvec2 uv1 = floor( pos.xz );\n\tvec2 uv2 = uv1 + vec2( gridSize, gridSize );\n\tfloat um = 0.002;\n\tfloat tm = 20.0;\n\tfloat gtm = 5.0;\n\n#ifdef FLAT_GROUND\n\tfloat h1 = 0.0;\n\tfloat h2 = 0.0;\n\tfloat h3 = 0.0;\n\tfloat h4 = 0.0;\n#else\n\tfloat h1 = sin( gtm * iTime + tm * texture( iChannel1, um * uv1 ).r );\n\tfloat h2 = sin( gtm * iTime + tm * texture( iChannel1, um * vec2( uv2.x, uv1.y ) ).r );\n\tfloat h3 = sin( gtm * iTime + tm * texture( iChannel1, um * uv2 ).r );\n\tfloat h4 = sin( gtm * iTime + tm * texture( iChannel1, um * vec2( uv1.x, uv2.y ) ).r );\n#endif\n\t\n\tfloat hm = 0.7 * max( 0.3, min( 1.0, -( uv1.y - 26.0 ) * 0.05 ) );\n\tvec3 v1 = vec3( uv1.x, h1 * hm, uv1.y );\n\tvec3 v2 = vec3( uv2.x, h2 * hm, uv1.y );\n\tvec3 v3 = vec3( uv2.x, h3 * hm, uv2.y );\n\tvec3 v4 = vec3( uv1.x, h4 * hm, uv2.y );\n\tfloat t1, t2, border1, border2;\n\tvec3 ro = pos + vec3( 0.0, 100.0, 0.0 );\n\tvec3 rd = vec3( 0.0, -1.0, 0.0 );\n\tint tri1res = triIsect( v1, v2, v3, ro, rd, t1 );\n\tint tri2res = triIsectNC( v1, v3, v4, ro, rd, t2 );\n\t\t\t\t\t\t \n\tfloat h = 0.0;\n\tif ( tri1res == 1 )\n\t{\n\t\tvec3 pt = ro + rd * t1;\n\t\treturn ( pt );\n\t}\n\tvec3 pt = ro + rd * t2;\n\treturn pt;\n}\n\nvec3 mapGround( vec3 pos, float sp, float zshift )\n{\n\tvec3 res = polygonalGround( pos, zshift, sp );\n\tfloat h = res.y;\n\n\treturn vec3( pos.x, h * 1.5 - 4.0, pos.z );\n}\n\nfloat rayMarchGround( vec3 ro, vec3 rd, float sp, float zshift )\n{\n\tfloat t = 0.0;\n\tfor( int i = 0; i < STEPS; i++ )\n\t{\n\t\tvec3 pt = ro + rd * t;\n\t\tfloat h = abs( pt.y - mapGround( pt, sp, zshift ).y );\n\t\tif ( h < 0.05 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt += 0.3 * h;\n\t}\n\treturn t;\n}\n\nfloat intersectZPlane( vec3 ro, vec3 rd, float planeZ )\n{\n\treturn ( -ro.z + planeZ ) / rd.z;\n}\n\n\n// ground\nvec3 shadeGround( vec3 eye, vec3 pt, vec3 norm, vec3 normReflection, vec3 light, float mult, float sp )\n{\n#ifdef FLAT_SHADING\n\tpt.xz = pt.xz - mod( pt.xz, 1.0 ); // flat shading\n#endif\n\tvec3 r = normalize( reflect( light, norm ) );\n\tvec3 eyeDir = normalize( pt - eye );\n\tfloat dotR = dot( r, eyeDir );\n\tfloat diffuseColor = max( 0.0, dotR );\n\tfloat ambientColor = 0.7;\n\tvec3 groundColor = vec3( diffuseColor + ambientColor );\n\t\n\tvec3 rd = normalize( reflect( -eyeDir, normReflection ) );\n\tfloat t = intersectZPlane( pt, rd, 10.0 );\n\tvec3 bgPos = pt + rd * t;\n\t\n\tfloat mixv = max( 0.0, dotR * 2.0 );\n\tvec3 bgColor = shadeBG( abs( bgPos.xy ) * vec2( 0.1, -0.2 ) + vec2( 0.0,2.0 ), sp );\n\treturn groundColor * mixv + bgColor * ( 1.0 - mixv );\n}\n\nvec3 colorize( vec2 uv )\n{\n\tvec3 ro = vec3( 0.0, 7.0, 0.0 );\n\tvec3 rd = vec3( uv.x, uv.y - 0.4, 1.0 );\n\trd = normalize( rd );\n\n\tfloat sp = texture( iChannel0, vec2( 0.0, 0.0 ) ).r; // sound\n\n\tfloat zshift = iTime * 0.0;\n\t\n\tfloat t = rayMarchGround( ro, rd, sp, zshift );\n\t\n\t// directional light\n\tvec3 lightDir = vec3( sin( iTime ), 0.6, 0.0 ); \n\tlightDir = normalize( lightDir );\n\n\tvec3 color;\n\t{\n\t\tvec3 pt = ro + rd * t;\n\n\t\tfloat eps = 0.001;\n\t\tvec3 norm1 = vec3( mapGround( pt + vec3( eps, 0.0, 0.0 ), sp, zshift ).y - \n\t\t\t\t\t\t   mapGround( pt, sp, zshift ).y,\n\t\t\t\t\t\t   0.005,\n\t\t\t\t\t\t   mapGround( pt + vec3( 0.0, 0.0, eps ), sp, zshift ).y - \n\t\t\t\t\t\t   mapGround( pt, sp, zshift ).y );\n\t\tnorm1 = normalize( norm1 );\n\t\tvec3 norm2 = normalize( norm1 + vec3(0.0,8.0,0.0) );\n\t\t\n\t\t// border calculation\n\t\tfloat modx = abs( mod( pt.x, 1.0 ) );\n\t\tfloat modz = abs( mod( pt.z + zshift, 1.0 ) );\n\t\tfloat power = 60.0;\n#ifdef BORDER_LINES\n\t\tfloat border = pow(     modx, power )\t\t\t\t // x axis border \n\t\t\t         + pow( 1.0-modx, power )\n\t\t\t         + pow(     modz, power )\t\t\t\t // z axis border\n\t\t\t         + pow( 1.0-modz, power )\t\t\t\t //\n\t\t\t\t\t + pow( 1.0-abs( modx - modz ), power ); // cross border\n\t\tborder = max( 0.0, min( 1.0, border * BORDER_THICKNESS * sp ) );\n#else\n\t\tfloat border = 0.0;\n#endif\n\t\t\n\t\tvec3 diffuseColor = vec3( 1.0, 0.95, 0.90 );\n\t\t//vec3 diffuseColor = vec3( 1.0, 0.98, .95 );\n\t\tvec3 color1 = shadeBG( uv, sp ) * diffuseColor;\n\t\tvec3 color2 = shadeGround( ro, pt, norm1, norm2, lightDir, -1.0, sp ) * diffuseColor * ( 1.0 - border ) + vec3( .5, .5, .5 ) * border;\n\t\tfloat mixv = pow( min( min( 1.0, max( 0.0, -abs( pt.x ) + 7.0 ) ), min( 1.0, max( 0.0, -abs( pt.z ) + 25.0 ) ) ), 2.0 );\n\t\tcolor = color1 * ( 1.0 - mixv ) + color2 * mixv;\n\t}\n\n\treturn color;\n}\n\nvec3 noiseGrain( vec2 uv )\n{\n\treturn vec3(\n\t\ttexture( iChannel1, uv * 20.0 + vec2( iTime * 100.678, iTime * 100.317 ) ).r\n\t) * 0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= vec2( 0.5, 0.5 );\n\tfloat dist = ( 1.0 - length( uv - vec2( 0.0, 0.25 ) ) * .5) * 1.0;\n\tvec3 color = colorize( uv ) * dist - noiseGrain( uv );\n\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 314, 367, 367, 520], [522, 558, 625, 625, 779], [781, 795, 830, 830, 1759], [1760, 1760, 1954, 1954, 2477], [2478, 2478, 2669, 2669, 3121], [3123, 3123, 3181, 3181, 4360], [4362, 4362, 4414, 4414, 4528], [4530, 4530, 4596, 4596, 4799], [4801, 4801, 4858, 4858, 4895], [4898, 4908, 5013, 5013, 5649], [5651, 5651, 5677, 5677, 7424], [7426, 7426, 7454, 7454, 7559], [7561, 7561, 7618, 7618, 7842]], "test": "error"}
{"id": "4dlXRf", "name": "iq Smiley", "author": "Passion", "description": "This is iq's smilie face shader live coding example that I watched on his youtube and tried to follow along and learn from. Thank you iq for making videos and sharing your knowledge :)", "tags": ["iq", "practice", "justlearning"], "likes": 1, "viewed": 154, "published": "Public", "date": "1405154129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//float segm( float a, float b, float c, float x );\nfloat segm( float a, float b, float c, float x )\n{\n    return smoothstep(a-c,a,x) - smoothstep(b,b+c,x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 reso = iResolution.xy;\n\t\n\treso.x -= 185.0;\n\t\n\tvec3 col = vec3(1.0);\n\tvec2 uv = fragCoord.xy / reso;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n\tuv.x -= .3;\n\tvec2 position =  (uv - 0.5) + 0.2*vec2(cos(iTime), sin(iTime)) ;\n\t\n\tvec2 z = position;\n\t\n\tfloat r = length(z);\n\tfloat a = atan(z.x, z.y);\n\tfloat s = 0.5 + 0.5*sin(a*13.0 + iTime);\n\tfloat d = 0.4 + 0.1*pow(s,3.5);\n\tfloat f = (r<d)?1.0:0.0;\n\t\n\tfloat b = 0.5 + 0.5*sin(4.0+(iTime*2.3));\n\tvec2 e = vec2(abs(z.x)-0.15, (z.y-0.1)*(1.0+10.0*b));\n\tfloat g = 1.0 - segm (0.05, 0.1, 0.01, length(e)*step(0.0,e.y));\n\t\n\t\n\tfloat k = 0.5 + 0.5*sin(20.0*iTime/1.5);\n\tvec2 m = vec2( z.x, (z.y+0.1)*2.0*(1.0+10.0*k));\n\tg *= 1.0-segm(0.06, 0.1, 0.01, length(m));\n\t\n\t\n\tcol = mix( vec3(1.0), vec3(0.9, 0.8, 0.0)*g, f);\n\t\n\tfragColor = vec4(col,1.0);\n\t\n\t\n\t//col = mix( vec3(1.0), vec3(0.9, 0.8, 0.0), f);\n\t\n\t\n\t\n\t\n            \t//if(length(z) > 0.3){\n            \t\t//fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n            \t//}\n            \t\n\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlXRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 102, 102, 158], [160, 160, 217, 217, 1204]], "test": "valid"}
{"id": "4dlXRs", "name": "Pretty Warped", "author": "davertron", "description": "Based off inigo's awesome warped tutorial here: http://www.iquilezles.org/www/articles/warp/warp.htm", "tags": ["warped"], "likes": 5, "viewed": 226, "published": "Public", "date": "1405824417", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat pattern( in vec2 p, out vec2 q, out vec2 r )\n  {\n      q.x = fbm( p * sin(iTime/30.0) + vec2(0.0,0.0) );\n      q.y = fbm( p + vec2(5.2,1.3) );\n\n      r.x = fbm( p * cos(iTime / 4.0) + 4.0*q + vec2(1.7,9.2) );\n      r.y = fbm( p + 4.0*q + vec2(8.3,2.8) );\n\n      return fbm( p + 4.0*r );\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 q;\n\tvec2 r;\n\t\n\tfloat c = pattern(p*3.5, q, r);\n\tvec3 col = vec3(1.0);\n\n\tcol = mix(col, vec3(0.8, 0.2, 0.9), length(q)/1.5);\n\tcol = mix(col, vec3(0.3, 0.4, 0.55), length(r));\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 63, 63, 100], [102, 102, 123, 123, 319], [321, 321, 375, 375, 617], [619, 619, 676, 676, 929]], "test": "valid"}
{"id": "4dsSDB", "name": "See Yaw (Yet Another Warping)", "author": "xbe", "description": "Yet another warping. Nearly same formula as in my Weird Warp shader, only tune a little bit more and presented in a more quiet way.", "tags": ["2d", "warping"], "likes": 46, "viewed": 1708, "published": "Public", "date": "1406494188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////\n// XBE\n// See Yaw (Yet Another Warping)\n//\n\n// Simplex Noise by IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat fbm6( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); p = m*p*2.04;\n    f += 0.031250*noise( p ); p = m*p*2.01;\n    f += 0.015625*noise( p );\n    return f;\n}\n\nfloat turb4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*abs(noise(p)); p = m*p*2.02;\n    f += 0.2500*abs(noise(p)); p = m*p*2.03;\n    f += 0.1250*abs(noise(p)); p = m*p*2.01;\n    f += 0.0625*abs(noise(p));\n    return f;\n}\n\nfloat turb6( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*abs(noise(p)); p = m*p*2.02;\n    f += 0.2500*abs(noise(p)); p = m*p*2.03;\n    f += 0.1250*abs(noise(p)); p = m*p*2.01;\n    f += 0.0625*abs(noise(p)); p = m*p*2.04;\n    f += 0.031250*abs(noise(p)); p = m*p*2.01;\n    f += 0.015625*abs(noise(p));\n    return f;\n}\n\nfloat marble(in vec2 p)\n{\n\treturn cos(p.x+fbm4(p));\n}\n\nfloat wood(in vec2 p)\n{\n\tfloat n = noise(p);\n\treturn n-floor(n);\n}\n\nfloat dowarp ( in vec2 q, out vec2 a, out vec2 b )\n{\n\tfloat ang=0.;\n\tang = 1.2345 * sin (0.015*iTime);\n\tmat2 m1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 0.2345 * sin (0.021*iTime);\n\tmat2 m2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\ta = vec2( marble(m1*q), marble(m2*q+vec2(1.12,0.654)) );\n\n\tang = 0.543 * cos (0.011*iTime);\n\tm1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 1.128 * cos (0.018*iTime);\n\tm2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\tb = vec2( marble( m2*(q + a)), marble( m1*(q + a) ) );\n\t\n\treturn marble( q + b +vec2(0.32,1.654));\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = 2.*uv-1.;\n\tq.y *= iResolution.y/iResolution.x;\n\t\n\tfloat Time = 0.1*iTime;\n\tq += vec2( 4.0*sin(Time), 0.);\n\tq *= 1.625;\n\t\n\tvec2 a = vec2(0.);\n\tvec2 b = vec2(0.);\n\tfloat f = dowarp(q, a, b);\n\tf = 0.5+0.5*f;\n\t\n\tvec3 col = vec3(f);\n\tfloat c = 0.;\n\tc = f;\n\tcol = vec3(c, c*c, c*c*c);\n\tc = abs(a.x);\n\tcol -= vec3(c*c, c, c*c*c);\n\tc = abs(b.x);\n\tcol += vec3(c*c*c, c*c, c);\n\tcol *= 0.7;\n\tcol.x = pow(col.x, 2.18);\n//\tcol.y = pow(col.y, 1.58);\n\tcol.z = pow(col.z, 1.88);\n\tcol = smoothstep(0., 1., col);\n\tcol = sqrt(col);\n\tcol = clamp(col, 0., 1.);\n\t\n\t// Vignetting\n\tvec2 r = -1.0 + 2.0*(uv);\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.15 + 0.85*(1.0-exp(-(1.0-vb)*30.0)));\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 118, 139, 139, 260], [262, 262, 288, 288, 823], [876, 876, 901, 901, 1090], [1092, 1092, 1117, 1117, 1394], [1396, 1396, 1422, 1422, 1623], [1625, 1625, 1651, 1651, 1946], [1948, 1948, 1973, 1973, 2001], [2003, 2003, 2026, 2026, 2069], [2071, 2071, 2123, 2123, 2661], [2663, 2715, 2772, 2772, 3528]], "test": "valid"}
{"id": "4dsSzs", "name": "Subpixel Rendering", "author": "HLorenzi", "description": "Shows three modes of rasterization smoothing of vector graphics: none (aliased), grayscale antialiasing, and subpixel antialiasing (aka ClearType; sharper vertical lines). Added gamma correction after 7 years!", "tags": ["2d", "antialiasing", "font", "rasterization", "subpixel"], "likes": 46, "viewed": 2375, "published": "Public", "date": "1405907036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 uvmap(vec2 pixels)\n{\n\tvec2 uv = pixels / iResolution.xy;\n\tuv = uv * 2.0 - vec2(1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\treturn uv;\n}\n\nfloat f(vec2 pixels)\n{\n\tvec2 uv = uvmap(pixels);\n\tfloat len = length(uv);\n\tif (len < 0.8 && mod(len, 0.1) < 0.0075) return 1.0;\n\telse return 0.0;\n}\n\nvec4 sampleAliased(vec2 pixels)\n{\n\tif (f(pixels) != 0.0) return vec4(0, 0, 0, 1);\n\telse return vec4(1, 1, 1, 1);\n}\n\nvec4 sampleAntialiased(vec2 pixels)\n{\n\tconst int size = 4; \n\tfloat disp = 1.0 / (float(size) + 2.0);\n\tfloat contrb = 0.0;\n\tfloat maxContrb = 0.0;\n\t\n\tfor (int j = -size; j <= size; j++)\n\t{\n\t\tfor (int i = -size; i <= size; i++)\n\t\t{\n\t\t\tcontrb += f(pixels + vec2(float(i) * disp, float(j) * disp));\n\t\t\tmaxContrb += 1.0;\n\t\t}\n\t}\n\t\n\tfloat c = 1.0 - (contrb / maxContrb);\n\treturn vec4(c, c, c, 1);\n}\n\nfloat sampleSubpixel(vec2 pixels)\n{\n\tconst int size = 8; \n\tfloat disp = 1.0 / (float(size) + 2.0);\n\tfloat contrb = 0.0;\n\tfloat maxContrb = 0.0;\n\t\n\tfor (int j = -size; j <= size; j++)\n\t{\n\t\tfor (int i = -size; i <= size; i++)\n\t\t{\n\t\t\tcontrb += f(pixels + vec2(float(i) * (disp / 3.0), float(j) * disp));\n\t\t\tmaxContrb += 1.0;\n\t\t}\n\t}\n\t\n\treturn 1.0 - (contrb / maxContrb);\n}\n\nvec4 sampleAntialiasedSubpixel(vec2 pixels)\n{\n\treturn vec4(sampleSubpixel(pixels - vec2(1.0 / 3.0, 0)),\n\t\t\t\tsampleSubpixel(pixels),\n\t\t\t\tsampleSubpixel(pixels + vec2(1.0 / 3.0, 0)),\n\t\t\t\t1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat timer = mod(iTime + 1.5, 6.0);\n\tfloat kind = 0.0;\n\tif (timer < 2.0) kind = 0.0;\n\telse if (timer < 4.0) kind = 1.0;\n\telse kind = 2.0;\n\t\t\n\tvec2 p = fragCoord.xy + vec2(cos(iTime + fragCoord.y * 0.1) * 5.0, 0.0);\n\t\n\tif (length(vec2(-0.7 + 0.7 * kind, 0.9) - uvmap(fragCoord.xy)) < 0.05)\n\t\tfragColor = vec4(1, 0, 0, 1);\n\telse if (kind == 0.0)\n\t\tfragColor = pow(sampleAliased(p), vec4(1.0/2.2));\n\telse if (kind == 1.0)\n\t\tfragColor = pow(sampleAntialiased(p), vec4(1.0/2.2));\n\telse\n\t\tfragColor = pow(sampleAntialiasedSubpixel(p), vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsSzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 143], [145, 145, 167, 167, 292], [294, 294, 327, 327, 408], [410, 410, 447, 447, 801], [803, 803, 838, 838, 1171], [1173, 1173, 1218, 1218, 1363], [1365, 1365, 1422, 1422, 1971]], "test": "valid"}
{"id": "4dsXRX", "name": "Neon Spades", "author": "Amarcoli", "description": "My first Shadertoy!  Playing around with different methods, learning about shaders in general.  I tried to use smoothstep to achieve an antialiased effect, but I'm not sure if that is really the right way to go about doing that, but it looks nice anyway!", "tags": ["circlecolorsinsmoothspades"], "likes": 41, "viewed": 1329, "published": "Public", "date": "1405077878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define CONST_SIZE\n#ifdef CONST_SIZE\n#define lines 5.0\n#define gradLength (1.0 / lines)\n#endif\n#define PI 3.14159\n\nvec4 sampleImg(vec2 fragCoord, float dt){\n    \t\n#ifndef CONST_SIZE\n\tfloat lines = sin((iTime + dt) / 2.2 + 1.0) * 20.0 + 21.0;\n\tfloat gradLength = (1.0 / lines);\n#endif\n\t\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tvec2 delta = uv - center;\n\tdelta.x = abs(delta.x);\n\t\n\tfloat len = length(delta);\n\tfloat gradStep = floor(len * 0.005 * lines) / lines;\n\tfloat gradSmooth = len * 0.005;\n\tfloat gradCenter = gradStep + (gradLength * 0.5);\n\tfloat percentFromCenter = abs(gradSmooth - gradCenter) / (gradLength * 0.5);\n\tfloat interpLength = 0.01 * lines;\n\tfloat s = 1.0 - smoothstep(0.5 - interpLength, 0.5 + interpLength, percentFromCenter);\n\t\n\tfloat index = gradStep / gradLength;\n\tvec4 color = vec4(sin(index*0.55), sin(index*0.2), sin(index*0.3), 1)*0.5 + vec4(0.5, 0.5, 0.5, 0);\n\t\n\tfloat angle = atan(delta.x, delta.y);\n\tfloat worldAngle = sin(gradStep * 4.0 + (iTime + dt)) * PI * 0.5 + PI * 0.5;\n\t\n    vec4 finalColor;\n    \n\tif(angle < worldAngle){\n\t\tvec2 tip = vec2(sin(worldAngle), cos(worldAngle)) * gradCenter * 200.0;\n\t\t\n\t\tfloat tipDist = length(delta - tip);\n\t\t\n\t\tfloat rad = 50.0 / lines;\n\t\tfloat tipC = 1.0 - smoothstep(rad - 1.0, rad + 1.0, tipDist);\n\t\t\n\t\tfinalColor = vec4(tipC,tipC,tipC,1);\t\n\t}else{\n\t\tfinalColor = vec4(s,s,s,1);\n\t}\n\tfinalColor *= color;\n    \n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 ag = vec4(0,0,0,0);\n    for(float t = 0.0; t<0.05; t+=0.0025){\n        ag += sampleImg(fragCoord.xy, t);\n    }\n\tfragColor = ag / 20.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 117, 158, 158, 1431], [1433, 1433, 1489, 1489, 1635]], "test": "valid"}
{"id": "4dsXzj", "name": "Procedural Ordering", "author": "nimitz", "description": "I needed that behavior for a shader and I realized that this isn't as straightforward as I thought it would be, so here's a quickie illustrating the technique.\n\nOrdered by size here. Which allows for ordered transparency among other things.", "tags": ["procedural", "2d", "transparency", "sorting", "order", "ordering"], "likes": 14, "viewed": 843, "published": "Public", "date": "1404274647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Procedural Ordering by nimitz (twitter: @stormoid)\n\n/*\t\n\tDemonstration of a simple way to have multiple objects ordered\n\tby an arbitrary function, in this case depth. The nice thing about\n\tthis algorithm is that the \"sorting\" is completely parametric\n\tso the complexity doesn't increase with the number of objects at all.\n\n\tThere might be some way to make the algorithm more general?\n*/\n\n\n//Number of objects to order\n#define NUM_OBJ 11.\n\n//If defined, the darkest layer is the one on top\n//and so on, with the bottom being lightest.\n//#define COLOR_BY_LAYER\n\n//Fixed alpha value (otherwise modulated by time)\n//#define ALPHA 0.5\n\n\n\n#define time iTime\nmat2 mm2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\n\n//the function which defines the ordering\nfloat f (const in float x)\n{\n\treturn mod(time-x,NUM_OBJ);\n}\n\nvec4 star(in vec2 p, const in float x, const in float num)\n{\n\tp.x+=sin(num*1.)*.25+sin(time*0.4+num*3.)*0.3;\n\tp.y+=sin(num*2.)*0.1+cos(time*0.5)*0.09;\n\tp = p/exp(x*.4-3.);\n\t\n\tp *= mm2(time*0.6+num*2.);\n\t\n\t//I knew i would find a use for my pentagon function at some point :)\n\t//two subtracted inverted pentagons -> 5 pointed star\n\tvec2 q = abs(p);\n\tfloat pen1 = max(max(q.x*1.176-p.y*0.385, q.x*0.727+p.y), -p.y*1.237);\n\tfloat pen2 = max(max(q.x*1.176+p.y*0.385, q.x*0.727-p.y), p.y*1.237)*0.619;\n\tfloat a = (pen1-pen2)*4.;\n\t\n\t//animation of the \"send to back\"\n\tfloat mx = clamp(0.1+1./x*0.05,0.,10.);\n\ta = 1.-smoothstep(0.1,mx,a);\n\t\n\tvec3 col = a*(sin((vec3(.19,5.,2.)*(num+1.04)*8.01))*0.5+0.6);\n\treturn vec4(col,a);\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//setup coordinates\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec3 col = vec3(1);\n\tfloat r = length(p);\n\t\n\tfor(float i = 0.;i<NUM_OBJ;i++)\n\t{\n\t\t//sart by getting an integer value for the current item placement\n\t\tfloat num = floor(f(i));\n\t\t\n\t\t//call the ordering function again to process based on newly defined order\n\t\tfloat x = f(num);\n\t\t\n\t\t//draw stuff\n\t\tvec4 nw = star(p,x,num);\n\t\t\n\t\t//blend\n\t\t#ifdef COLOR_BY_LAYER\n\t\tcol = col*(1.-smoothstep(0.,1.,nw.a))+vec3(0.1,0.2,0.3);\n\t\t#else\n\t\t#ifdef ALPHA\n\t\tcol = mix(col,nw.rgb,nw.a*ALPHA);\n\t\t#else\n\t\tcol = mix(col,nw.rgb,nw.a*(sin(time*0.22)*0.4+0.55));\n\t\t#endif\n\t\t#endif\n\t}\n\t\n\tcol = clamp(col,0.,1.);\n\t//vignetting\n\tcol *= 1.-smoothstep(.4,1.8,r);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[562, 654, 679, 679, 744], [746, 788, 816, 816, 847], [849, 849, 909, 909, 1569], [1572, 1572, 1629, 1650, 2397]], "test": "error"}
{"id": "4dXSWB", "name": "DistanceFieldToy", "author": "Sekhat", "description": "Just playing around with rendering procedurally generated distance fields using ray-marching.", "tags": ["3d", "distancefield", "procedual"], "likes": 3, "viewed": 173, "published": "Public", "date": "1406118893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265358979323846264;\nconst float MaxSteps = 128.0;\nconst float Epsilon = 0.0001;\n\nfloat distanceToSphere(vec3 p, vec3 o, float r) {\n\treturn length(o - p) - r;\n}\n\nfloat distanceFromPlane(vec3 p, vec3 n, float d) {\n\treturn dot(p, n) - d;\n}\n\n\nfloat mixDistanceField(vec3 p, float d1, float d2) {\n\tfloat b = smoothstep(length(p), 0.0, 1.0);\n\treturn mix(d1, d2, b);\n}\n\nfloat distanceFromDistanceField(vec3 p) {\n\t// Construct our distance field\n\t\n\t// Rotation and position calculation for the\n\t// orbiting sphere\n\tfloat orbitDistance = 14.0;\n\tfloat lsxa = cos(2.0 * PI * (iTime * 0.20));\n\tfloat lsza = sin(2.0 * PI * (iTime * 0.20));\n\tvec3 lspos = vec3(.0 + (lsxa * orbitDistance), 0.0, 30.0 + (lsza * orbitDistance));\n\t\n\t// in order to combine the distance fields of each object\n\t// we need to figure out the minimum distance of all fields\n\treturn min(distanceFromPlane(p, vec3(0, 1, 0), -5.0),\n\t\tmin(distanceToSphere(p, lspos, 3.0),\n\t\t\tdistanceToSphere(p, vec3(0, 0, 30), 10.0)));\t\t\t\t\n}\n\n\n\nfloat distanceStep(vec3 o, vec3 dir) {\n\t// Marches the ray\n\tfloat d = 0.0;\n\tfor (float i = 0.0; i < MaxSteps; i++) {\n\t\td = distanceFromDistanceField(o);\n\t\tif (d <= Epsilon) {\n\t\t\treturn i / MaxSteps;\n\t\t\t\n\t\t}\n\t\to += (dir * d);\t\t\n\t}\n\treturn MaxSteps;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 p = vec3(0,0,0);\n\t\t\n\t// Aspect ratio\n\tfloat ar = iResolution.x / iResolution.y;\n\t\n\t// Calculate our direction vector based of\n\t// frag coordinate.\n\tvec2 transPoint = vec2(\n\t\t(((fragCoord.x / iResolution.x) - 0.5) * ar),\n\t\t(fragCoord.y / iResolution.y) - 0.5);\n    \n\tvec3 dir = normalize(vec3(transPoint, 1));\n\t\n\t// Sends out the ray\n\tfloat pos = 1.0 - distanceStep(p, dir);\n    \n\t// Colour the result\n\tfragColor = vec4(pos, pos, pos, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXSWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 154, 154, 183], [185, 185, 235, 235, 260], [263, 263, 315, 315, 385], [387, 387, 428, 529, 1005], [1009, 1009, 1047, 1067, 1258], [1260, 1260, 1317, 1317, 1765]], "test": "valid"}
{"id": "4sfSRX", "name": "CGAtunnel", "author": "cyanux", "description": "Sunday it's cool :)", "tags": ["noise"], "likes": 2, "viewed": 118, "published": "Public", "date": "1404672889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// vincent francois - cyanux/2014\n\n#define T sin(iTime)\n\nfloat noise(vec2 p, float m)\n{\n\treturn fract(mod(m, length(p)));\n}\n\nfloat render(vec2 p)\n{\n\treturn noise(p - 0.5, 3.0 + 0.4 * T);\n}\n\n#define D (0.005)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\t\n\tfloat m = (\n\t\trender(p) +\n\t\trender(p + vec2( D,    0.0)) +\n\t\trender(p + vec2(-D,    0.0)) +\n\t\trender(p + vec2( 0.0,  D  )) +\n\t\trender(p + vec2( 0.0, -D  ))\n\t\t) * 0.2;\n\t\n\tfragColor = vec4(0.0, m, 0.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 87, 87, 123], [125, 125, 147, 147, 188], [209, 209, 266, 266, 518]], "test": "valid"}
{"id": "4sfSWS", "name": "Raymarcing Capsule Test", "author": "Dipper_168", "description": "My first scene with raymarching.\nIt's very difficult for me to understand... but really interesting :)\nI borrowed some code from sites below.\nhttp://www.demoscene.jp/?p=811\nhttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm", "tags": ["3d", "raymarcing", "capsule"], "likes": 2, "viewed": 184, "published": "Public", "date": "1406147584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 color1 = vec3(1.0,1.0,1.0);\nvec3 color2 = vec3(0.8,0.25,0.25);\nfloat shadow = 0.75;\nfloat reflection = 0.5;\n\nfloat movespeed = 10.0;\n\nvec3 trans(vec3 p)\n{\n\treturn mod(p, 4.0)-2.0;\n}\n \nfloat distanceFunction(vec3 pos)\n{\n\tvec3 p = trans(pos);\n\tvec3 a = vec3(-0.5,0.0,0.0);\n\tvec3 b = vec3(0.5,0.0,0.0);\n\tfloat r = 0.5;\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n \nvec3 getNormal(vec3 p)\n{\n\tconst float d = 0.0001;\n\treturn\n\tnormalize\n\t(\n\t\tvec3\n\t\t(\n\t\t\tdistanceFunction(p+vec3(d,0.0,0.0))-distanceFunction(p+vec3(-d,0.0,0.0)),\n\t\t\tdistanceFunction(p+vec3(0.0,d,0.0))-distanceFunction(p+vec3(0.0,-d,0.0)),\n\t\t\tdistanceFunction(p+vec3(0.0,0.0,d))-distanceFunction(p+vec3(0.0,0.0,-d))\n\t\t)\n\t);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = (fragCoord.xy*2.0 -iResolution.xy) / iResolution.y;\n \n\tvec2 mousepos = (iMouse.xy*2.0 - iResolution.xy) / iResolution.y;\n\t\n\tvec3 camPos = vec3(0.0, 0.0, -iTime*movespeed);\n\tvec3 camDir = normalize(vec3(mousepos.xy, -1.0));\n\tvec3 camUp = vec3(0.0, 1.0, 0.0);\n\tvec3 camSide = cross(camDir, camUp);\n\tfloat focus = 1.8;\n \n\tvec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir*focus);\n \n\tfloat t = 0.0, d;\n\tvec3 posOnRay = camPos;\n \n\tfor(int i=0; i<80; ++i)\n\t{\n\t\td = distanceFunction(posOnRay);\n\t\tt += d;\n\t\tposOnRay = camPos + t*rayDir;\n\t\tif(abs(d)<0.0005) break;\n\t}\n\t\n\t\n\tvec3 normal = getNormal(posOnRay);\n\t\n\tvec3 color;\n\t\t\n\tif(mod(posOnRay.x,4.0)>2.0){\n\t\tcolor = color1;\t\n\t}else{\n\t\tcolor = color2;\t\n\t}\n\t\n\tcolor *= (max(normal.y,0.0)*shadow)+(1.0-shadow);\n\t\n\tcolor = vec3(1.0)-(vec3(1.0)-color)*(vec3(1.0)-vec3(1.0-dot(-rayDir,normal))*reflection);\n\t\n\tfloat dist = length(posOnRay-camPos);\n\n\tcolor = mix(vec3(1.0),color,1.0/(dist*0.25+1.0));\n  \n\tif(abs(d) < 0.001)\n\t{\n\t\tfragColor = vec4(color, 1.0);\n\t}else{\n\t\tfragColor = vec4(1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 159, 159, 186], [189, 189, 223, 223, 438], [441, 441, 465, 465, 763], [766, 766, 823, 823, 1877]], "test": "valid"}
{"id": "4slSzj", "name": "Glass Polyhedron", "author": "Nrx", "description": "Forked from: https://www.shadertoy.com/view/ldfXzn\n\nThis is a simplification of my \"diamond\", to check about refraction and reflection...", "tags": ["raymarching", "glass"], "likes": 65, "viewed": 3007, "published": "Public API", "date": "1404201285", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Forked from: https://www.shadertoy.com/view/ldfXzn\n\n#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t7\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t100\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define REFRACT_FACTOR\t\t0.6\n#define REFRACT_INDEX\t\t1.6\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n#define FADE_POWER\t\t\t1.0\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n#define GLOW_FACTOR\t\t\t1.5\n#define LUMINOSITY_FACTOR\t2.0\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\nvec3 k;\nfloat getDistance (in vec3 p) {\n\tfloat repeat = 20.0;\n\tvec3 q = p + repeat * 0.5;\n\tk = floor (q / repeat);\n\tq -= repeat * (k + 0.5);\n\tp = mRotate (k) * q;\n\n\tfloat top = p.y - 3.0;\n\tfloat angleStep = M_PI / max (2.0, abs (k.x + 2.0 * k.y + 4.0 * k.z));\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\n\tfloat side = cos (angle) * p.z + sin (angle) * p.x - 2.0;\n\tfloat bottom = -p.y - 3.0;\n\n\treturn max (top, max (side, bottom));\n}\n\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\n\tvec3 lightDirection = normalize (LIGHT);\n\tvec2 delta = vec2 (DELTA, 0.0);\n\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\n\tfloat intensity = 1.0;\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n\n\t\t// Ray marching\n\t\tfloat dist = RAY_LENGTH_MAX;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tdist = distanceFactor * getDistance (origin);\n\t\t\tfloat distMin = max (dist, DELTA);\n\t\t\trayLength += distMin;\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * distMin;\n\t\t\t++rayStepCount;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\n\t\tif (dist >= 0.0) {\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\n\n\t\t// Basic lighting\n\t\tvec3 reflection = reflect (direction, normal);\n\t\tif (distanceFactor > 0.0) {\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\n\t\t\tlocalColor = mix (backColor, localColor, fade);\n\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\n\t\t\tintensity *= REFRACT_FACTOR;\n\t\t}\n\n\t\t// Next ray...\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflection;\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t}\n\t\telse {\n\t\t\tdirection = refraction;\n\t\t\tdistanceFactor = -distanceFactor;\n\t\t\trefractionRatio = 1.0 / refractionRatio;\n\t\t}\n\t}\n\n\t// Return the fragment color\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Set the fragment color\n\tfragColor = vec4 (getFragmentColor (origin, direction), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slSzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 464, 494, 494, 821], [831, 831, 862, 862, 1283], [1285, 1285, 1344, 1344, 3645], [3647, 3647, 3703, 3754, 4346]], "test": "valid"}
{"id": "4slXz2", "name": "Burn burn burn!", "author": "TylerGlaiel", "description": "FIRE!", "tags": ["fire"], "likes": 7, "viewed": 758, "published": "Public", "date": "1404425238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float triangle(float t){\n\treturn (fract(t)-.5) * sign(fract(t / 2.0)-.5);\n}\n\nvec3 grad(float t){\n\tvec3 p1 = max(vec3(0), (t-.5)*2.0*vec3(0, 1.2, 1));\n\tvec3 p2 = max(vec3(0), (t+.2)*1.3*vec3(.8, .2, 0));\n\t\n\treturn p1+p2;\n}\n\nvec2 warp(vec2 uv){\n\tuv.x += (sin(uv.x/10.0-iTime*10.0 + uv.y*10.0 * (sin(uv.x*20.0 + iTime*.5)*.3+1.0))+1.0)*.03;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = warp(fragCoord.xy / iResolution.xy);\n\tfloat t = uv.x * 10.0;\n\tfloat Tt = abs(triangle(t));\n\t\n\t\n\tfloat v  = -((uv.y-.8)*2.0 - pow(Tt, 1.5)*sin(t+sin(iTime)*-2.0))* ((sin(t*5.0+iTime)+1.0) * .2 + .8);\n\tfragColor = vec4(grad(v*.8), 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slXz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 75], [77, 77, 96, 96, 221], [223, 223, 242, 242, 351], [353, 353, 410, 410, 658]], "test": "valid"}
{"id": "4ssSRl", "name": "Antialias / filtering", "author": "iq", "description": "Used filter width (fwidth) to antialias edges (no supersampling). See the jagged edges in the left side of the screen vs the smooth edges in the right side. Both pre and post gamma filtering are implemented (move mouse to change the areas)", "tags": ["2d", "antialias", "filtering"], "likes": 73, "viewed": 8920, "published": "Public API", "date": "1405671704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n// distance to a line (can't get simpler than this)\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.yy;\n\tvec2 q = p;\n\t\n\tvec2 c = vec2(0.0);\n\tif( iMouse.z>0.0 ) c=(-iResolution.xy + 2.0*iMouse.xy) / iResolution.yy;\n\t\n    // background\t\n\tvec3 col = vec3(0.5,0.85,0.9)*(1.0-0.2*length(p));\n\tif( q.x>c.x && q.y>c.y ) col = pow(col,vec3(2.2));\n\n    // zoom in and out\t\n\tp *= 1.0 + 0.2*sin(iTime*0.4);\n\t\n\t\n\t// compute distance to a set of lines\n    float d = 1e20;\t\n\tfor( int i=0; i<7; i++ )\n\t{\n        float anA = 6.2831*float(i+0)/7.0 + 0.15*iTime;\n        float anB = 6.2831*float(i+3)/7.0 + 0.20*iTime;\n\t\tvec2 pA = 0.95*vec2( cos(anA), sin(anA) );\t\t\n        vec2 pB = 0.95*vec2( cos(anB), sin(anB) );\t\t\n\t\tfloat h = line( pA, pB, p );\n\t\td = min( d, h );\n\t}\n\n    // lines/start, left side of screen\t: not filtered\n\tif( q.x<c.x )\n\t{\n\t\tif( d<0.12 ) col = vec3(0.0,0.0,0.0); // black \n\t\tif( d<0.04 ) col = vec3(1.0,0.6,0.0); // orange\n\t}\n    // lines/start, right side of the screen: filtered\n\telse\n\t{\n\t\tfloat w = 0.5*fwidth(d); \n\t\tw *= 1.5; // extra blur\n\t\t\n\t\tif( q.y<c.y )\n\t\t{\n\t\tcol = mix( vec3(0.0,0.0,0.0), col, smoothstep(-w,w,d-0.12) ); // black\n\t\tcol = mix( vec3(1.0,0.6,0.0), col, smoothstep(-w,w,d-0.04) ); // orange\n\t\t}\n\t\telse\n\t\t{\n\t\tcol = mix( pow(vec3(0.0,0.0,0.0),vec3(2.2)), col, smoothstep(-w,w,d-0.12) ); // black\n\t\tcol = mix( pow(vec3(1.0,0.6,0.0),vec3(2.2)), col, smoothstep(-w,w,d-0.04) ); // orange\n\t\t}\n\t}\n\t\n\n\tif( q.x>c.x && q.y>c.y )\n\t\tcol = pow( col, vec3(1.0/2.2) );\n\t\n    // draw left/right separating line\n\tcol = mix( vec3(0.0), col, smoothstep(0.007,0.008,abs(q.x-c.x)) );\n\tcol = mix( col, vec3(0.0), (1.0-smoothstep(0.007,0.008,abs(q.y-c.y)))*step(0.0,q.x-c.x) );\n\t\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssSRl.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1196, 1243, 1243, 1363], [1365, 1365, 1422, 1422, 3103]], "test": "valid"}
{"id": "4ssSzf", "name": "x0rn01s3", "author": "cyanux", "description": "Simple xor noise - saturday is cool :$", "tags": ["noise", "xor"], "likes": 3, "viewed": 154, "published": "Public", "date": "1405176723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// vincent francois - cyanux/2014\n// xor noise\n\n#define BITS 8.0\n\nfloat xor(vec2 p)\n{\n\tfloat ret = 0.0;\n\n\tfor(float i = BITS; i > 1.0; i--)\n\t{\n\t\tfloat j = exp2(i);\n\n\t\tif((j < p.x)  ^^ (j < p.y))\n\t\t\tret += j;\n\n\t\tif(j < p.x)\n\t\t\tp.x -= j;\n\n\t\tif(j < p.y)\n\t\t\tp.y -= j;\n\t}\n\n\treturn ret;\n}\n\nfloat noise(vec2 p, float z)\n{\n\treturn fract(xor(p) / z);\n}\n\n// hsv2rgb - iq / https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 512.0;\n\t\n\tfloat h = (sin(2.0 * iTime + fragCoord.y / iResolution.y) + 1.0) * 0.2 + 0.2;\n\tfloat v = noise(uv, ceil(mod(iTime * 32.0, 512.0)));\n\tfragColor.rgb = hsv2rgb(vec3(h, 1.0, v));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 85, 85, 282], [284, 284, 314, 314, 343], [345, 401, 428, 428, 554], [556, 556, 613, 613, 845]], "test": "valid"}
{"id": "4ssSzj", "name": "Blissful Waves", "author": "TomoAlien", "description": "Full screen it, lay back and relax. Hope you like it :)", "tags": ["2d", "waves", "wave", "plasma", "ambient", "relax", "relaxing"], "likes": 13, "viewed": 460, "published": "Public", "date": "1404209973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat n = iTime/2.0;\n\tfloat x = uv.x/4.0+n/12.0;\n\tfloat y = uv.y/4.0-sin(n/10.0);\n\t\n\tfloat plas=(y*32.0+n*1.5+sin(x*16.0+n*(0.7)-cos(y*22.0-n*1.5+sin(x*12.0+y*22.0+n*1.1-sin(x*32.0))+cos(x*32.0)+n)+cos(x*16.0-n*1.27)*2.0)*8.0-n+sin(x*2.0-n*1.0)*16.0);\n\t\n\tfloat final = abs(cos((plas+n-sin(y+n*2.0)*cos(x+n*0.2)*2.0)/28.0));\n\tfragColor = vec4(final,final*1.1,final*1.2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssSzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 476]], "test": "valid"}
{"id": "4ssXRX", "name": "noise distributions", "author": "hornet", "description": "left to right:\n- uniform noise\n- triangular noise\n- gaussianish noise\n- moar gaussianish noise :)\n\nUsed in relation to http://www.loopit.dk/banding_in_games.pdf", "tags": ["noise", "random", "gaussian", "rnd", "rand", "distribution", "gauss", "triangular"], "likes": 193, "viewed": 14577, "published": "Public API", "date": "1405072299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_BUCKETS = 32;\nconst int ITER_PER_BUCKET = 1024;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\n\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat truncf( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\nfloat n2rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\nfloat n3rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\treturn (nrnd0+nrnd1+nrnd2) / 3.0;\n}\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n}\n\nfloat n8rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    \n    float nrnd4 = nrand( n + 0.19*t );\n    float nrnd5 = nrand( n + 0.23*t );\n    float nrnd6 = nrand( n + 0.29*t );\n    float nrnd7 = nrand( n + 0.31*t );\n    \n\treturn (nrnd0+nrnd1+nrnd2+nrnd3 +nrnd4+nrnd5+nrnd6+nrnd7) / 8.0;\n}\n\nfloat n4rand_inv( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    float nrnd4 = nrand( n + 0.19*t );\n\tfloat v1 = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n    float v2 = 0.5 * remap( 0.0, 0.5, v1 ) + 0.5;\n    float v3 = 0.5 * remap( 0.5, 1.0, v1 );\n    return (nrnd4<0.5) ? v2 : v3;\n}\n\n//alternative Gaussian,\n//thanks to @self_shadow\n//see http://www.dspguide.com/ch2/6.htm\n//note: see also https://www.shadertoy.com/view/MlVSzw for version by @stubbe\nfloat n4rand_ss( vec2 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07*fract( iTime ) );\n\tfloat nrnd1 = nrand( n + 0.11*fract( iTime + 0.573953 ) );\t\n\treturn 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;\n}\n\n/*\n//Mouse Y give you a curve distribution of ^1 to ^8\n//thanks to Trisomie21\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\t\n\tfloat p = 1. / (1. + iMouse.y * 8. / iResolution.y);\n\tnrnd0 -= .5;\n\tnrnd0 *= 2.;\n\tif(nrnd0<0.)\n\t\tnrnd0 = pow(1.+nrnd0, p)*.5;\n\telse\n\t\tnrnd0 = 1.-pow(nrnd0, p)*.5;\n\treturn nrnd0; \n}\n*/\n\nfloat histogram( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( truncf(t,NUM_BUCKETS_F), truncf(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)/ITER_PER_BUCKET_F;\n\t\t\n\t\tfloat r;\n\t\tif ( iter < 2 )\n\t\t\tr = n1rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<3 )\n\t\t\tr = n2rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<4 )\n\t\t\tr = n4rand( vec2(uv.x,0.5) + seed );\n\t\telse\n\t\t\tr = n8rand( vec2(uv.x,0.5) + seed );\n\t\t\n\t\tbucketval += step(bucket.x,r) * step(r,bucket.y);\n\t}\n\tbucketval /= ITER_PER_BUCKET_F;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y / height, bucketval );\n    float v1 = step( (uv.y-1.0/iResolution.y) / height, bucketval );\n    float v2 = step( (uv.y+1.0/iResolution.y) / height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat o;\n    int idx;\n    vec2 uvrange;\n\tif ( uv.x < 1.0/4.0 )\n\t{\n\t\to = n1rand( uv );\n        idx = 1;\n        uvrange = vec2( 0.0/4.0, 1.0/4.0 );\n\t}\n\telse if ( uv.x < 2.0 / 4.0 )\n\t{\n\t\to = n2rand( uv );\n        idx = 2;\n        uvrange = vec2( 1.0/4.0, 2.0/4.0 );\n\t}\n\telse if ( uv.x < 3.0 / 4.0 )\n\t{\n\t\to = n4rand( uv );\n        idx = 3;\n        uvrange = vec2( 2.0/4.0, 3.0/4.0 );\n\t}\n\telse\n\t{\n\t\to = n8rand( uv );\n        idx = 4;\n        uvrange = vec2( 3.0/4.0, 4.0/4.0 );\n\t}\n\n    //display histogram\n    if ( uv.y < 1.0 / 4.0 )\n\t\to = 0.125 + histogram( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );\n    \n\t//display lines\n\tif ( abs(uv.x - 1.0/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 2.0/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 3.0/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.y - 1.0/4.0) < 0.002 ) o = 0.0;\n\n\t\n\tfragColor = vec4( vec3(o), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 253, 276, 276, 344], [345, 389, 431, 431, 475], [476, 506, 540, 540, 564], [566, 566, 590, 590, 670], [671, 671, 695, 695, 825], [826, 826, 850, 850, 1022], [1023, 1023, 1047, 1047, 1262], [1264, 1264, 1288, 1288, 1694], [1696, 1696, 1724, 1724, 2110], [2112, 2279, 2306, 2306, 2486], [2488, 2842, 2922, 2922, 3743], [3745, 3745, 3802, 3802, 4685]], "test": "valid"}
{"id": "4ssXzs", "name": "Limbo", "author": "Amarcoli", "description": "Was inspired to make a shader effect that replicated the look and feel of the game Limbo.  I think it turned out pretty good!  Still lots of optimization and documentation to be done, everything is terrible right now.  ", "tags": ["limbogameblureffectgrass"], "likes": 26, "viewed": 667, "published": "Public", "date": "1405943451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define BACKGROUND_BLUR_ITER 4.0\n#define BACKGROUND_BLUR_SIZE 5.0\n#define FOREGROUND_BLUR_ITER 4.0\n#define FOREGROUND_BLUR_SIZE 10.0\n\n\n#define WATER_LEVEL 0.2\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash1( float n ){\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat terrainHeight(float x){\n\tfloat lowF = sin(x+sin(x*3.5)) * 0.60;\n\tfloat medF = sin(x*10.0+cos(x*7.7)) * 0.05;\n\tfloat highF = sin(x*20.0 + sin(x*70.5)) * 0.015;\n\treturn (lowF + medF + highF) / 4.0 + 0.26;\n}\n\nfloat vignette(vec2 uv){\t\n\tvec2 delta = uv - vec2(iResolution.x / iResolution.y / 2.0, 0.5);\n    delta.y *= 3.0;\n\treturn 1.0 - dot(delta,delta) * 0.4;\n}\n\nfloat getBlade(vec2 xy, float seed, float spread, float height){\n\tfloat nearestBlade = (floor(xy.x * spread)) / spread;\n\tfloat offset = hash1(nearestBlade * seed);\n\tfloat base = nearestBlade + offset / spread / 2.0 + 0.25 / spread;\n\t\n\tfloat distFromCenter = abs(xy.x - base - 50.0 * xy.y * (nearestBlade + 0.5 / spread - base));\n\tfloat sm = 1.0 - pow(1.0 - smoothstep(0.000, 0.011, distFromCenter), 5.0);\n\treturn mix(pow(clamp((height - xy.y) / height, 0.0, 1.0), 2.0), 0.0, sm);\n}\n\nfloat getTree(vec2 xy, float seed, float fade, float spread){\n\tfloat nearestBlade = (floor(xy.x * spread)) / spread;\n\tfloat offset = (hash1(nearestBlade * seed) - 0.5) * 0.5 / spread + 0.5 / spread;\n\tfloat base = nearestBlade + offset;\n\t\n\tfloat distFromCenter = abs(xy.x - base);\n    float width = 0.15 + (0.02 / (xy.y + 0.1));\n    return 1.0 - smoothstep(width - fade, width, distFromCenter * spread * 2.0);\n}\n\nfloat backgroundTerrainSample(vec2 uv){\n\tfloat globalX1 = (uv.x + iTime / 12.0 + 100.0);\n\tfloat height1 = terrainHeight(globalX1) + 0.3;\n\tfloat globalX2 = (uv.x + iTime / 17.0 + 50.0);\n\tfloat height2 = terrainHeight(globalX2) + 0.05;\n    \n    float tree1 = getTree(vec2(uv.x + iTime / 12.0, height1), 59.0, 0.07, 1.8);\n    float tree2 = getTree(vec2(uv.x + iTime / 17.0, height2), 23.0, 0.07, 1.2);\n    \n    float back0 = mix(0.5, 1.0, clamp(-tree2 + smoothstep(height2, height2 + 0.15, uv.y), 0.0, 1.0));\n    float back1 = mix(0.2, back0, clamp(-tree1 + smoothstep(height2, height2 + 0.15, uv.y), 0.0, 1.0));\n    \n    return back1;\n}\n\nfloat background(vec2 uv){\n\tfloat sum = 0.0;\n\tfor(float dx = -BACKGROUND_BLUR_ITER; dx <= BACKGROUND_BLUR_ITER; dx++){\n\t\tsum += backgroundTerrainSample(uv + vec2(dx, 0) * BACKGROUND_BLUR_SIZE / iResolution.y);\n\t}\n\tsum /= BACKGROUND_BLUR_ITER*2.0 + 1.0;\n\t\n\tfloat color = sum;\n\t\n\tfloat globalX = (uv.x + iTime / 10.0);\n\tfloat waterSurface = clamp(sin(uv.y * 500.0 + 5.0 * sin(globalX * 3.0)) / 2.0 + 0.5, 0.0, 1.0) / 4.0;\n\tcolor += mix(waterSurface, 0.0, clamp(abs(uv.y - WATER_LEVEL) * 80.0, 0.0, 1.0));\n\tcolor += (1.0 - smoothstep(WATER_LEVEL - 0.01, WATER_LEVEL + 0.01, uv.y)) * 0.12;\n\tcolor = mix(0.0, color, smoothstep(0.04, WATER_LEVEL, uv.y));\n\t\n\treturn color * vignette(uv);\n}\n\n\nvec2 terrain(vec2 uv){\n\tfloat globalX = uv.x + iTime / 10.0;\n\tfloat height = terrainHeight(globalX);\n\t\n\tfloat grassHeight = (sin(globalX * 8.0 + 5.0 * sin(globalX * 2.0)) - 0.3) * 0.05;\n\tgrassHeight = mix(-0.11, grassHeight, smoothstep(-0.1, 0.1, height - WATER_LEVEL));\n\t\n\t\n\tfloat grassAlpha = 0.0;\n\tvec2 bladeUV = vec2(globalX, uv.y - height);\n\t\n\tif(uv.y < grassHeight + height + 0.1){\n\t\tif(uv.y > height){\n\t\t\tgrassAlpha += getBlade(bladeUV, 9.0,  30.0, max(0.0, grassHeight + 0.08));\n\t\t\tgrassAlpha += getBlade(bladeUV, 99.0, 295.0, max(0.0, grassHeight + 0.07));\n\t\t\tgrassAlpha += getBlade(bladeUV, 33.0, 40.0, max(0.0, grassHeight + 0.06));\n\t\t\tgrassAlpha += getBlade(bladeUV, 44.0, 45.0, max(0.0, grassHeight + 0.05));\n\t\t\tgrassAlpha += getBlade(bladeUV, 5.0,  50.0, max(0.0, grassHeight + 0.09));\n\t\t\tgrassAlpha += getBlade(bladeUV, 6.0,  55.0, max(0.0, grassHeight + 0.07));\n\t\t\tgrassAlpha += getBlade(bladeUV, 7.0,  60.0, max(0.0, grassHeight + 0.06));\n\t\t\tgrassAlpha += getBlade(bladeUV, 8.0,  65.0, max(0.0, grassHeight + 0.10));\n\t\t\tgrassAlpha = clamp(grassAlpha, 0.0, 1.0);\n\t\t}\n\t}\n\t\n\tfloat terrainAlpha = 1.0 - smoothstep(height, height + 0.007, uv.y);\n    \n    grassAlpha += getTree(bladeUV, 22.0, 0.05, 0.7);\n\t\n\treturn vec2(0.0, clamp(grassAlpha + terrainAlpha, 0.0, 1.0));\n}\n\nvec2 foregroundTerrainSample(vec2 uv){\n\tfloat globalX = (uv.x + iTime / 2.0 + 23.0);\n\tfloat height = terrainHeight(globalX) - 0.5;\n    \n\treturn vec2(0.5, 0.3 - smoothstep(height, height + 1.0, uv.y) * 0.3);\n}\n\nvec2 foreground(vec2 uv){\n\tvec2 sum = vec2(0.0, 0.0);\n\tfor(float dx = -FOREGROUND_BLUR_ITER; dx <= FOREGROUND_BLUR_ITER; dx++){\n\t\tsum += foregroundTerrainSample(uv + vec2(dx, 0) * FOREGROUND_BLUR_SIZE / iResolution.y);\n\t}\n\tsum /= FOREGROUND_BLUR_ITER*2.0 + 1.0;\n\t\n    sum.y = clamp(sum.y, 0.0, 0.8);\n    \n\treturn sum;\n}\n\nfloat scene(vec2 uv){\n\tfloat color = background(uv);\n\tvec2 terrainColor = terrain(uv);\n\tcolor = mix(color, terrainColor.x, terrainColor.y);\n\tvec2 foregroundColor = foreground(uv);\n\tcolor = mix(color, foregroundColor.x, foregroundColor.y);\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tfloat color = scene(uv) + rand(uv * iTime) * 0.06;\n\tcolor *= smoothstep(0.0, 7.0, iTime);\n\tfragColor = vec4(color, color, color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 181, 181, 251], [253, 253, 276, 276, 318], [320, 320, 349, 349, 530], [532, 532, 556, 556, 684], [686, 686, 750, 750, 1167], [1169, 1169, 1230, 1230, 1579], [1581, 1581, 1620, 1620, 2215], [2217, 2217, 2243, 2243, 2899], [2902, 2902, 2924, 2924, 4184], [4186, 4186, 4224, 4224, 4394], [4396, 4396, 4421, 4421, 4715], [4717, 4717, 4738, 4738, 4972], [4975, 4975, 5031, 5031, 5208]], "test": "valid"}
{"id": "4ssXzX", "name": "Fast 2D Hash Function for WebGL", "author": "victor_shepardson", "description": "a pretty fast, pretty good looking function for hashing 2D integer coordinates to random 4-vectors, useful for grid based noises\n\nsee https://www.shadertoy.com/view/4tfyW4 for a webgl2 version with bitwise operations", "tags": ["procedural", "2d", "noise", "random", "hash"], "likes": 32, "viewed": 1228, "published": "Public", "date": "1405135003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//fast vec2 -> vec4 hash function for webgl\n//github.com/victor-shepardson\n\n//hash based on Blum, Blum & Shub 1986\n//and Sharpe http://briansharpe.wordpress.com/2011/10/01/gpu-texture-free-noise/\nfloat pi = 3.14159265359;\nfloat bbsm = 1739.;\nvec2 bbsopt(in vec2 a){\n\treturn fract(a*a*(1./bbsm))*bbsm;\n}\nvec2 mod1024(in vec2 a){\n\treturn fract(a*(1./1024.))*1024.;\t\n}\nvec4 hash(in vec2 pos){\n\tvec2 a0 = mod1024(pos*pi);\n\tvec2 a1 = bbsopt(a0);\n\tvec2 a2 = a1.yx + bbsopt(a1);\n\tvec2 a3 = a2.yx + bbsopt(a2);\n\treturn fract((a2.xyxy + a3.xxyy + a1.xyyx)*(1./bbsm));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst vec2 vel = vec2(60., 60.); //animation speed\n    const vec2 scale = vec2(1., 1.);\n\tconst int num = 1; //average multiple instances\n\t\n\tvec2 p = scale*floor(fragCoord.xy-vel*iTime);\n\t\n\tvec4 c = vec4(0.);\n\tfor(int i=0; i<num; i++)\n\t\tc+= hash(p+float(i*1024));\n\tc*=1./float(num);\n\t\n\tfragColor = vec4(c.x,c.y,c.z,c.w);\n\t\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 242, 265, 265, 302], [303, 303, 327, 327, 365], [366, 366, 389, 389, 560], [562, 562, 619, 619, 945]], "test": "valid"}
{"id": "4sXSRX", "name": "Big Nose", "author": "Lanza", "description": "Shader toy :p Use mouse to play.\n\nStill some work I want to do, and lots of approximations. But before I clean the code and go on, I'd like to now if it runs everywhere, as my previous try did not. (OS X hackintosh on Intel HD Graphics 4600 her).", "tags": ["raymarching", "shading", "shadows", "materials"], "likes": 1, "viewed": 266, "published": "Public", "date": "1404679913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Lanza 2014\n// Default CC of Shadertoy\n\n#define EPSILON 0.0001\n#define PI 3.14159265359\n\n// Primitives by iq\nfloat sphere( vec3 p, float radius ) {\n    return length(p) - radius;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// polynomial smin by iq (very powerful)\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// eye and eye lids are repeated, hence the funcs\nfloat eyeLid( vec3 p) {\n\t// up lid is a sphere cut by a bounding box\n\tfloat up = max(sphere(p, 0.2), box(p - vec3(0.0, -0.1, 0.0), vec3(0.2, 0.1,0.2)));\n\tfloat down = sphere(p, 0.18);\n\t\n\t// blink every 3 secs;\n\tif(mod( iTime, 3.0) > 0.15)\n\t\tdown =  max(sphere(p, 0.18), sphere( p + vec3( 0.0, -0.2, 0.1), 0.17));\n\treturn min( up, down);\n}\n\nfloat eye( vec3 p) {\n\treturn sphere( p, 0.16 );\n}\n\n\n// returns vec 2 : x is the distance, y the material.\nvec2 scene( vec3 p )\n{\n\tfloat crane = sphere(p, 0.6);\n\tfloat eyeLids = min(eyeLid(p - vec3(0.25, -0.1, 0.5)), eyeLid(p + vec3(0.25,0.1,-0.5)));\n    float head = smin(crane, eyeLids, 0.07);\n\thead = max( head, -box( p + vec3(0.0, -0.45, -0.65), vec3(1.0, 0.2, 0.3)));\n\tfloat nose = sphere(p - vec3(0.0, 0.1, 0.6), 0.2);\n\tfloat skin = smin(head, nose, 0.09);\n\tfloat eyes = min( eye(p - vec3(0.25, -0.1, 0.5)), eye(p + vec3(0.25,0.1,-0.5)));\n\t\n\tif( min(skin, eyes) == eyes ) // hit eyes ? switch material.\n\t\treturn vec2( eyes, 1.0);\n\t\n\treturn vec2(skin, 0.0);\n\t\n}\n\n// Get normal of a point.\nvec3 normal( vec3 p )\n{\n    vec2 n = vec2( EPSILON, 0.0 );\n    return normalize( vec3 (\n        scene( p + n.xyy ).x - scene( p - n.xyy ).x,\n        scene( p + n.yxy ).x - scene( p - n.yxy ).x,\n        scene( p + n.yyx ).x - scene( p - n.yyx ).x\n        )\n    );\n}\n\n\n// \"shadowing\" would be more accurate. Based on iq's...\nfloat lighting( vec3 p, vec3 light )\n{\n\t// march from pos to light\n\tvec3 ldir = normalize( light - p );\n\tfloat dist = scene(p).x;\n\tfloat t = dist;\n\tfloat maxt = length(light - p);\n\t\n\tfloat res = 1.0;\n\tfor(int i = 0; i < 500; i++)\n\t{\n\t\tif( t >= maxt )\n\t\t\tbreak;\n\t\t\n\t\tvec3 cp = p + ldir * t;\n\t\tdist = scene(cp).x;\n\t\t\n\t\t // has to be way less than than main march's EPSILON, otherwise I get artifacts.\n\t\tif( dist < EPSILON/1000. )\n\t\t\treturn 0.0;\n\t\t\n\t\tres = min( res, 8. * dist/t );\n\n\t\tt += dist;\n\t}\n\t\n\treturn res;\n}\n\n// TODO : clean this mess.\nvec4 march( vec3 cam, vec3 dir, vec2 crmouse )\n{\n\n    float t = scene(cam).x;\n    vec3 light = vec3(3.0 * -sin(iTime), 0.2, 1.4  * cos(iTime));\n    vec3 light2 = vec3( 0.0, 3.0, 2.0 );\n    \n\tvec4 color = vec4( 0.2, 0.2, 0.2, 1.0 );\n\t\n    for(int i=0; i < 50; i++)\n    {\n        vec3 p = cam + dir * t;\n\t\tvec2 res = scene(p);\n        float dist = res.x;\n        if( dist < EPSILON )\n        {\n            vec3 nml = normal(p);\n\t\t\tfloat shadows = lighting(p, light);\n            float l = (dot(nml, normalize(light)) * shadows) /length(p - light);\n            float l2 = dot(nml, normalize(light2));\n\n\t\t\tif( res.y < 0.5 ) {\n\t\t\t\t// material 1\n\t\t\t\tfloat red = clamp(l * 2.0, 0.0, 1.0);\n\t\t\t\tfloat green = clamp( l * 2.0, 1.0, 2.0) - 1.0;\n\t\t\t\tfloat blue = clamp( l2, 0.0, 1.0);\n\t\t\t\tcolor = vec4( red, green, blue, 1.0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// material 2\n\t\t\t\tvec4 c = vec4(l2 + 0.2);\n\t\t\t\tvec3 eyeDir = normalize(vec3(crmouse.x - 0.5, -crmouse.y + 0.7, 3.0-cam.z*1.2)-p);\n\t\t\t\tfloat iris = dot( nml, eyeDir);\n\t\t\t\tvec2 centerToIris = (eyeDir - nml).xy; // awful approx... Good enough for the job.\n\t\t\t\t\t\n\t\t\t\tif( iris > 0.95 )\n\t\t\t\t\tc = vec4(0.0);\n\t\t\t\telse if( iris > 0.81 )\n\t\t\t\t\tc = vec4(0.9 * 7.0 * (iris - 0.81),0.7,0.3,1.0) * texture(iChannel0, vec2(\n\t\t\t\t\t\tatan(centerToIris.x, centerToIris.y)/PI, iris/6.0)).r * l2;\n\t\t\t\telse if( iris > 0.78 )\n\t\t\t\t\tc = vec4(0.0);\n\t\t\t\t\t\n\t\t\t\tfloat specl = max(0.0, dot(reflect(normalize(light),nml), dir));\n\t\t\t\tfloat specl2 = max(0.0, dot(reflect(normalize(light2),nml), dir));\n\t\t\t\tc += 5.0 *\n\t\t\t\t\tpow(specl, 190.0)  * shadows + pow(specl2, 190.0);\n\t\t\t\tc.rg *= 0.6 + 0.4 * l; \n\t\t\t\tcolor = c;\n\t\t\t}\n\t\t\t\n            return color;\n\t\t} \n\t\t// Very simple edge detection.\n\t\telse if(dist > EPSILON && dist < 0.01 ) \n\t\t{\n\t\t    color = vec4(0.0);\n\t\t}\n        \n        t += dist;\n        \n    }\n\treturn color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\t// face the camera until mouse moved. \n\t// Better for preview thumbnail. Marketing's everywhere.\n\tvec2 crmouse = vec2(0.5, 0.67);\n\tif( iTime > 0.0 && (iMouse.x != 0.0 || iMouse.y != 0.0))\n\t\tcrmouse = iMouse.xy/iResolution.xy;\n\t\n\t// Move the cam around the scene, with a nice ellipse, to get a bigger nose when we apporach it.\n    vec3 cam = vec3( 3.0 * cos(PI/3.0*((crmouse.x)+1.0) ), 0.0, 1.5 * sin(PI/3.0*((crmouse)+1.0)));\n    vec3 camTarget = vec3(0.0);\n\t\n\tvec2 targetFragment = vec2(             \n       fragCoord.x*2.0/iResolution.x - 1.0,\n       (fragCoord.y*2.0/iResolution.y - 1.0) * iResolution.y / iResolution.x\n\t);\n\t\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross( camTarget - cam, up));\n\t\n    // Spent some time before realizing why this is needed ^^ (and why I got silly deformation). \n\t// At this point, up is world related, not cam related.\n\tup = normalize(cross(camTarget - cam, right));\n    vec3 dir = normalize(camTarget - cam + targetFragment.x * right + targetFragment.y * up);\n    \n    fragColor =  march( cam, dir, crmouse );\n\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 111, 149, 149, 182], [184, 184, 213, 213, 298], [300, 341, 382, 382, 475], [477, 527, 550, 595, 865], [867, 867, 887, 887, 916], [919, 973, 995, 995, 1532], [1534, 1560, 1583, 1583, 1824], [1827, 1883, 1921, 1949, 2395], [2397, 2424, 2472, 2472, 4249], [4254, 4254, 4311, 4411, 5387]], "test": "error"}
{"id": "ldfSDj", "name": "Procedural Rounded Edged Quad", "author": "ShadyBen", "description": "A rectangle with antialiased corners of some given radius. I wanted to see how hard it would be to implement rounded corners on a quad without using the typical 9-box/polygonal method. Using this shader you can get the same effect using one quad prim", "tags": ["procedural", "2d", "edge", "ui", "rounded"], "likes": 12, "viewed": 4895, "published": "Public", "date": "1406793351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n    \n// from http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat udRoundBox( vec2 p, vec2 b, float r )\n{\n    return length(max(abs(p)-b+r,0.0))-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup\n    float t = 0.2 + 0.2 * sin(mod(iTime, 2.0 * PI) - 0.5 * PI);\n    float iRadius = min(iResolution.x, iResolution.y) * (0.05 + t);\n    vec2 halfRes = 0.5 * iResolution.xy;\n\n    // compute box\n    float b = udRoundBox( fragCoord.xy - halfRes, halfRes, iRadius );\n    \n    // colorize (red / black )\n\tvec3 c = mix( vec3(1.0,0.0,0.0), vec3(0.0,0.0,0.0), smoothstep(0.0,1.0,b) );\n        \n    fragColor = vec4( c, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 113, 158, 158, 202], [204, 204, 261, 274, 694]], "test": "valid"}
{"id": "ldfXW2", "name": "Distance function with normals", "author": "hughes", "description": "This time, we calculate the surface normals!\n\nAlso experimenting with subtractive functions. The edges of the cut region of the box require many more iterations (100) than the previous example (16)!", "tags": ["raytracing", "distance"], "likes": 1, "viewed": 331, "published": "Public", "date": "1406840688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 100;\nconst vec3 BOX = vec3(1.0);\nconst float SPHERE = 1.2;\n\nconst float THRESHOLD = 0.01;\nconst vec3 DX = vec3(THRESHOLD, 0.0, 0.0);\nconst vec3 DY = vec3(0.0, THRESHOLD, 0.0);\nconst vec3 DZ = vec3(0.0, 0.0, THRESHOLD);\n\nfloat udBox(vec3 p, vec3 b) {\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p)-s;\n}\n\nstruct Ray {\n    vec3 position;\n    vec3 direction;\n    bool hit;\n};\n    \nfloat D(vec3 p) {\n    /* Distance function */\n    float dBox = udBox(p, BOX);\n    float dSphere = sdSphere(p, SPHERE);\n    \n    return max(-dSphere, dBox);\n}\n\n\nRay intersect(Ray ray) {\n    for (int i=0; i<MAX_STEPS; i++) {\n        float dist = D(ray.position);\n        if (dist < THRESHOLD) {\n            ray.hit = true;\n            return ray;\n        }\n        ray.position += ray.direction * dist;\n    }\n    return ray;\n}\n\nRay backstep(Ray ray) {\n    ray.position -= THRESHOLD * ray.direction;\n    return ray;\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(D(p+DX)-D(p-DX),\n                          D(p+DY)-D(p-DY),\n                          D(p+DZ)-D(p-DZ)));\n}\n\nvec3 Rx(vec3 vector, float angle) {\n    float rx = vector.x * cos(angle) + vector.z * sin(angle);\n    float rz = vector.z * cos(angle) - vector.x * sin(angle);\n    return vec3(rx, vector.y, rz);\n}\n\nvec3 render(Ray ray) { \n    ray = backstep(ray);\n    if (ray.hit) {\n        return normal(ray.position);\n    } else {\n        return vec3(1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (uv - vec2(0.5)) * vec2(aspect_ratio, 1.0);\n    \n    float angle = iTime;\n    \n    if (iMouse.z > 0.0) {\n    \tangle = iMouse.x / iResolution.x * 6.0 + 0.5;\n    }\n        \n    vec3 camera_loc = 6.0 * vec3(-sin(angle), 0.0, -cos(angle));\n    vec3 camera_dir = vec3(sin(angle), 0.0, cos(angle));\n    \n    Ray ray;\n    ray.position = camera_loc;\n    ray.direction = Rx(normalize(vec3(p, 1.0)), angle);\n    ray.hit = false;\n    \n    ray = intersect(ray);\n    \n    vec3 col = render(ray);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfXW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 271, 271, 314], [316, 316, 349, 349, 375], [451, 451, 468, 496, 608], [611, 611, 635, 635, 875], [877, 877, 900, 900, 965], [967, 967, 988, 988, 1121], [1123, 1123, 1158, 1158, 1319], [1321, 1321, 1343, 1343, 1472], [1474, 1474, 1531, 1531, 2167]], "test": "valid"}
{"id": "ldfXzf", "name": "warping with fbm", "author": "antonOTI", "description": "I've found the wrap tutorial and I wanted to try it by myself\nhttp://www.iquilezles.org/www/articles/warp/warp.htm\nI was also inspired by this shader\nhttps://www.shadertoy.com/view/ldX3Wn", "tags": ["fbm", "warp"], "likes": 11, "viewed": 435, "published": "Public", "date": "1405010660", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\nfloat beat = 0.;\n\nfloat pattern(vec2 p,out vec2 q,out vec2 r,out vec2 s)\n{\n\tfloat ct = 0.;\n\t/*if ((ct > 8.0 && ct < 33.5)\n\t|| (ct > 38.0 && ct < 88.5)\n\t|| (ct > 93.0 && ct < 194.5))\n\t\tbeat = pow(sin(ct*3.1416*3.78+1.9)*0.5+0.5,15.0)*.1;*/\n\t\n\tfloat time = (iTime + sin(beat * 3.1416))*.7 ;\n\tq = vec2(fbm(p-vec2(.5)),fbm(p+vec2(4.  ,2.8765 )));\n\t\n\tr = vec2( fbm( p + 4.0*q + vec2(1.7 - time*.6,9.2 -  + time*.6 ) ),\n\t\t\t\t  fbm( p + 4.0*q + vec2(8.3 - time*.6,2.8 + time*.6) ) );\n\t\n\ts = vec2( fbm( r + 4.0*r + vec2(2.4 - time*.6 , 15.01 + time*.6) ),\n\t\t\t\t   fbm( r + 4.0*r + vec2(21.3 + time, 1.03 -time) ) );\n\t\n\treturn fbm(p + 4. * r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy *3.;\n\tvec2 q,r,s;\n\tfloat f = pattern(uv,q,r,s);\n\tvec3 col = mix(vec3(0.,0.,0.),vec3(0.,0.,1.),f);\n\tcol = mix(col,vec3(.0,1.,0.),length(r)*.0);\n\tcol = mix(col,vec3(1.,1.,1.),s.y*1.0);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 68, 68, 107], [110, 110, 136, 136, 383], [385, 385, 406, 406, 653], [673, 673, 729, 729, 1289], [1291, 1291, 1348, 1348, 1602]], "test": "valid"}
{"id": "ldlSRs", "name": "adventures in noise", "author": "dydx", "description": "thanks jordan", "tags": ["noise"], "likes": 5, "viewed": 213, "published": "Public", "date": "1405999565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D noise code from\n// https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\t\n\nfloat turbulence(vec2 position, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float scale = 1.0;\n    float totalGain = 1.0;\n\tconst int octaves = 2;\n    for (int i = 0; i < octaves; ++i)\n    {\n        sum += totalGain * snoise(position*scale);\n        scale *= lacunarity;\n        totalGain *= gain;\n    }\n    return abs(sum);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tfloat q = turbulence(p, 2.0, 0.5);\n\t\n\tvec3 col = vec3( 1.0, 0.9, 0.0 );\n\n\tfloat r = snoise( vec2(iTime*1.8 + q*4.0, 1.0) );\n\tcol *= smoothstep( r, r+0.1*sin(iTime - p.x*6.0), 0.3*snoise( p ));\n\t\n\tfragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlSRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 93, 114, 114, 163], [165, 165, 186, 186, 235], [237, 237, 259, 259, 296], [298, 298, 322, 322, 1828], [1832, 1832, 1895, 1895, 2170], [2173, 2173, 2230, 2230, 2498]], "test": "valid"}
{"id": "ldlSzX", "name": "synthetic aperture", "author": "FabriceNeyret2", "description": "Synthetic aperture tunes sources phase so as to concentrate interferences on a target (emit or ear). ex:MIMO\nTarget: mouse.  S or SPACE:  linear/circular sources distrib.   R: random spacing.    P: dist fading or not\nW: display waves instead of energy. ", "tags": ["waves", "optics", "correlation", "interferences", "signal", "speckle"], "likes": 139, "viewed": 16284, "published": "Public API", "date": "1405250870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 23    \t// number of sources\n\nint MODE = 5;\t\t// source distrib\nfloat POW = 1.;\t\t// fading with distance\n\n\nconst float k = 2.*3.14159/.04,  // 2 Pi / wavelenght\n\t        c = 0.1;\t\t\t // wavespeed\n\n#define t iTime\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nfloat rnd(float i) {\n\treturn mod(4000.*sin(23464.345*i+45.345),1.);\n}\nfloat srnd(float i) { return 2.*rnd(i)-1.; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy,\n        uv = (2.*fragCoord - R ) / R.y;\n\n\t// --- controls\n\n\tvec2 mouse = (2.*iMouse.xy - R ) / R.y;\n\tif (iMouse.z<=0.) \n\t\t\tmouse = vec2(1.5*cos(.2345*t)-.7*sin(t),sin(.3214*t)+.5*cos(1.234*t))/1.5;\n\n\tbool DISPLAY = keyToggle(64+23);  \t\t\t\t\t// waves vs energy\n\tbool RND = keyToggle(64+18);\t\t\t\t\t\t// even vs random source distrib\n\tMODE = ( (keyToggle(32)||keyToggle(64+19)) ? 1 : 3 ) + ( (RND) ?0:1); \t// line or circle source\n\tPOW = (keyToggle(64+16)) ? 0. : 1.; \t\t\t\t// 1/r decrease or not\n\t\t\n\t// --- calc sources contribs\n\t\n\tfloat x = -.75, y=-.7, \n\t\t  xt = x  +((keyToggle(64+20))?.03*t:0.);\n\tconst float stp = 1.54/float(N);\n\t\n\tfloat Phi[N],D2[N];\n\tfor (int i=0; i<N; i++) {\n\t\tvec2 P;\t// generates sources distribution\n\t\tif \t\t(MODE==1) { P = vec2(x,-.9); x+= stp;}\n\t\telse if (MODE==2) { P = vec2(x,-.9); x+= stp*(1.+srnd(float(i))); }\n\t\telse if (MODE==3) { P = .99*vec2(sin(4.*xt),-cos(4.*xt)); xt+= stp;}\n\t\telse if (MODE==4) { P = .99*vec2(sin(4.*xt),-cos(4.*xt)); xt+= stp*(1.+.7*srnd(float(i)));}\n\t\telse if (MODE==5) { P = vec2(2.*x,y); x+= 1.4*sqrt(stp); \n\t\t\t\t\t\t    if (x>.7) { x=-.7; y+=sqrt(1.4*stp);} }\n\t\t// the key: wave's phase pixel to source calibrated by wave phase mouse to source\n\t\tfloat dm = length(mouse-P),\tphim = dm, //   -c*t,\n\t\t\t  d  = length(uv-P),\tphi  = d -c*t;\n\t\tPhi[i] = k*(phi-phim);  // stores wave attributes\n\t\tD2[i] = pow(d,POW);\n\n\t\tif (d<0.01) { fragColor = vec4(0,0,1,0); return; }\n\t}\n\t\n\t// --- combines waves or energy\n\t\n\tfloat v = 0.;\n\tif (DISPLAY)   \t\t\t\t// waves \t\t\n\t\tfor (int i=0; i<N; i++)\n\t\t\tv += cos(Phi[i])/D2[i];\n\n\t\telse {\t\t\t\t\t\t// energy . is int_t{ ( sum_i{waves(i,x,t)} )^2 }\n#if 1\n\t\t\tfor (int i=0; i<N; i++) {\n\t\t\t\tfor (int j=0; j<N; j++) \n\t\t\t\t\tv += cos(Phi[j]-Phi[i]) / (D2[i]*D2[j]);\t\t\t\n\t\t\t\t//\tif (j<i) v += 2.*cos(Phi[j]-Phi[i]) / (D2[i]*D2[j]); // not faster !\n\t\t\t\t//v += 1./ (D2[i]*D2[i]);\n\t\t\t}\n#else\n\t\tfor (int i=0; i<N; i++)\n\t\t\tv += 1./ (D2[i]*D2[i]);\n\t\tint i=0, j=N-1;\n\t\tfor (int k=0; k<N*(N-1)/2; k++) {\n\t\t\tif (i>=j) { i=0; j--; }\n\t\t\tv += 2.*cos(Phi[j]-Phi[i]) / (D2[i]*D2[j]);\n\t\t}\t\t\n#endif\t\t\t\n\t\tv = sqrt(v/2.);\n\t}\n\tv = v*4.5/float(N);\n\tfragColor = v* vec4(1,.5,.25, 1);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlSzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 221, 248, 248, 321], [323, 323, 343, 343, 392], [393, 393, 414, 414, 437], [439, 439, 496, 496, 2646]], "test": "error"}
{"id": "ldsSWS", "name": "Weird Warp", "author": "xbe", "description": "Playing with domain warp to produce weird anim with audio.", "tags": ["2d", "warp"], "likes": 6, "viewed": 270, "published": "Public", "date": "1406491771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////\n// XBE\n// Weird Warp\n// Playing with domain warp to produce weird anim.\n\n// Simplex Noise by IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat fbm6( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); p = m*p*2.04;\n    f += 0.031250*noise( p ); p = m*p*2.01;\n    f += 0.015625*noise( p );\n    return f;\n}\n\nfloat turb4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*abs(noise(p)); p = m*p*2.02;\n    f += 0.2500*abs(noise(p)); p = m*p*2.03;\n    f += 0.1250*abs(noise(p)); p = m*p*2.01;\n    f += 0.0625*abs(noise(p));\n    return f;\n}\n\nfloat turb6( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*abs(noise(p)); p = m*p*2.02;\n    f += 0.2500*abs(noise(p)); p = m*p*2.03;\n    f += 0.1250*abs(noise(p)); p = m*p*2.01;\n    f += 0.0625*abs(noise(p)); p = m*p*2.04;\n    f += 0.031250*abs(noise(p)); p = m*p*2.01;\n    f += 0.015625*abs(noise(p));\n    return f;\n}\n\nfloat marble(in vec2 p)\n{\n\treturn cos(p.x+fbm4(p));\n}\n\nfloat wood(in vec2 p)\n{\n\tfloat n = noise(p);\n\treturn n-floor(n);\n}\n\nfloat dowarp ( in vec2 q, out vec2 a, out vec2 b )\n{\n\tfloat ang = 1.5*texture(iChannel0, vec2(0.2, 0.)).x;\n\tmat2 rotmat = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\ta = vec2( marble(q), marble(q) );\n\n\tang = 1.5*texture(iChannel0, vec2(0.6, 0.)).x;\n\trotmat = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tb = vec2( marble( rotmat*(q + a)), marble( rotmat*(q + a) ) );\n\t\n\tvec2 offset;\n\toffset.x = texture(iChannel0, vec2(0.1, 0.)).x;\n\toffset.y = texture(iChannel0, vec2(0.5, 0.)).x;\n\treturn marble( q + b + 2.*offset);\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = 2.*uv-1.;\n\tq.y *= iResolution.y/iResolution.x;\n\t\n\tfloat Time = 0.25*(15.0 + iTime) - 1.*texture(iChannel0, vec2(0.65, 0.)).x;\n\tq += vec2( 4.0*cos(Time+45.), 2.0*sin(Time) );\n\tq *= .625 + 3.*texture(iChannel0, vec2(0.35, 0.)).x;\n\t\n\tvec2 a = vec2(0.);\n\tvec2 b = vec2(0.);\n\tfloat f = dowarp(q, a, b);\n\tf = 0.5+0.5*f;\n\t\n\tvec3 col = vec3(f);\n\tfloat c = 0.;\n\tc = f;\n\tcol = vec3(c, c*c, c*c*c);\n\tc = fract(abs(a.x));\n\tcol -= vec3(c*c, c, c*c*c);\n\tc = fract(abs(b.x));\n\tcol += vec3(c*c*c, c*c, c);\n\tcol *= 0.7;\n\tcol.x = pow(col.x, 2.18);\n\tcol.z = pow(col.z, 1.88);\n\tcol = smoothstep(0., 1., col);\n\tcol = sqrt(col);\n\tcol = clamp(col, 0.,1.);\n\t\n\t// Vignetting\n\tvec2 r = -1.0 + 2.0*(uv);\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.15 + 0.85*(1.0-exp(-(1.0-vb)*30.0)));\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 147, 168, 168, 289], [291, 291, 317, 317, 852], [905, 905, 930, 930, 1119], [1121, 1121, 1146, 1146, 1423], [1425, 1425, 1451, 1451, 1652], [1654, 1654, 1680, 1680, 1975], [1977, 1977, 2002, 2002, 2030], [2032, 2032, 2055, 2055, 2098], [2100, 2100, 2152, 2152, 2625], [2627, 2679, 2736, 2736, 3585]], "test": "error"}
{"id": "ldXSDj", "name": "RayTracer Learning", "author": "twitchingace", "description": "Building my first ray tracer.", "tags": ["phong", "lighting", "sphere", "raytrace"], "likes": 2, "viewed": 261, "published": "Public", "date": "1406775356", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n    \nstruct Material{\n\tfloat specular;\n\tfloat diffuse;\n\tfloat ambient;\n\tfloat shininess;\n    float reflectivity;\n    float transparency;\n};\n    \nstruct Sphere{\n\tvec3 position;\n\tvec3 colour;\n\tfloat radius;\n    Material mat;\n};\n   \nstruct Plane{\n\tvec3 position;\n    vec3 colour;\n    vec3 normal;\n    Material mat;\n};\n\t\nstruct PointLight{\n\tvec3 position;\n\tvec3 colour;\n};\n\n\nstruct Output{\n\tvec3 origin;\n\tvec3 normal;\n\tfloat dis;\n\tMaterial material;\n    vec3 colour;\n};\n    \n#define numSphere 6\nSphere sphere[numSphere];\n\n#define numPlane 3\nPlane plane[numPlane];\n\n#define numLight 6\nPointLight pointlight[numLight];\n\n#define numMaterial 8\nMaterial material[numMaterial];\n\n#define PI 3.14159\nvec3 backgroundColour = vec3(0.0, 0.0, 0.7);\nvec3 eye;\n\nRay castRay(vec3 lookat){\n\tvec2 uv = (gl_FragCoord.xy * 2.1 - iResolution.xy) / iResolution.xx;\n\n\tvec3 forward = normalize(lookat - eye);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\t\n\tvec3 right = cross(up, forward);\n\tup = cross(forward, right);\n\t\n\tRay ray;\n\t\n\tray.origin = eye;\n\tray.direction = normalize(right * uv.x + up * uv.y + forward);\n\t\n\teye = ray.origin;\n\t\n\treturn ray;\n}\n\n\nvoid sphereIntersect(const Sphere sphere, const Ray ray, inout Output o) {\n\tvec3 d = ray.origin - sphere.position;\n\t\n\tfloat a = dot(ray.direction, ray.direction);\n\tfloat b = dot(ray.direction, d);\n\tfloat c = dot(d, d) - sphere.radius * sphere.radius;\n\t\n\tfloat g = b*b - a*c;\n\t\n\tif(g > 0.0) {\n\t\tfloat dis = (-sqrt(g) - b) / a;\n\t\tif(dis > 0.0 && dis < o.dis) {\n\t\t\to.dis = dis;\n\t\t\to.origin = ray.origin + ray.direction * dis;\n\t\t\to.normal = (o.origin - sphere.position) / sphere.radius;\n            o.colour = sphere.colour;\n\t\t\to.material = sphere.mat;\n\t\t}\n\t}\n}\n\nvoid planeIntersect(const Plane plane, const Ray ray, inout Output o){\n    float denom = dot(ray.direction, plane.normal);\n    if (denom <= 0.0001){\n    \treturn;\n    }\n    \n    vec3 p0l0 = plane.position - ray.origin;\n    float t = dot(p0l0, plane.normal) / denom;\n    vec3 newOrigin = ray.origin + t * ray.direction;\n    float dis = length(t * ray.direction);\n    if (dis > 0.0 && dis < o.dis){\n    \to.dis = dis;\n        o.origin = newOrigin;\n        o.normal = plane.normal;\n        o.material = plane.mat;\n        o.colour = plane.colour;\n    }\n}\n\nSphere makeSphere(float offset, Material mat){\n    float t = iTime + offset;\n    float x = cos(t);\n    float y = sin(t * 1.5);\n\tfloat z = sin(t * 2.0) * 3.5;\n\treturn Sphere(vec3(x, y, z),\n\t\t\t\t  vec3(sin(offset) + 1.0 / 2.0, cos(offset) + 1.0 / 2.0, 0.2),\n\t\t\t\t  0.5,\n                 mat);\n}\n\nvoid makeScene(){\n\t\n    material[0] = Material(0.1, 0.6, 0.1, 0.0, 0.2, 0.0);\n    material[1] = Material(0.0, 0.8, 0.0, 0.0, 0.1, 0.0);\n    material[2] = Material(0.2, 0.6, 0.5, 0.0, 0.7, 0.0);\n    material[3] = Material(0.1, 0.6, 0.1, 1.0, 0.3, 0.0);\n    material[4] = Material(0.1, 0.6, 0.7, 0.0, 0.2, 0.0);\n    material[5] = Material(0.0, 0.8, 0.0, 0.0, 0.1, 0.0);\n    material[6] = Material(0.2, 0.6, 0.5, 0.0, 0.7, 0.0);\n    material[7] = Material(0.1, 0.6, 0.1, 1.0, 0.3, 0.0);\n    \n\tfor (int i = 0; i < numSphere; i++){\n\t\tsphere[i] = makeSphere(float(i), material[i]);\n\t}\n    \n    plane[0] = Plane(vec3(0.0, 2.0, 0.0), vec3(1.1, 1.0, 1.0), vec3(0.0,1.0,0.1), material[1]);\n    plane[1] = Plane(vec3(0.0, -1.3, 0.0), vec3(1.1, 1.0, 1.1), vec3(0.0,-1.0,0.0), material[1]);\n    plane[2] = Plane(vec3(0.0, 0.0, 5.5), vec3(0.0), vec3(1.0,1.0,1.0), material[2]);\n\t\n    float r = 4.0;\n\tfloat y = 0.0;\n\t\n\tfloat t0 = -iTime + PI * 0.0;\n\tpointlight[0].position = vec3(cos(t0) * r, y, sin(t0) * r);\n\tpointlight[0].colour = vec3(0.5, 0.0, 0.0);\n\tfloat t1 = -iTime + PI * 0.333333;\n\tpointlight[1].position = vec3(cos(t1) * r, y, sin(t1) * r);\n\tpointlight[1].colour = vec3(0.4, 0.4, 0.0);\n\n\tfloat t2 = -iTime + PI * 0.666666;\n\tpointlight[2].position = vec3(cos(t2) * r, y, sin(t2) * r);\n\tpointlight[2].colour = vec3(0.75, 0.75, 0.75);\n\n\tfloat t3 = -iTime + PI * 1.0;\n\tpointlight[3].position = vec3(cos(t3) * r, y, sin(t3) * r);\n\tpointlight[3].colour = vec3(0.0, 0.4, 0.4);\n\n\tfloat t4 = -iTime + PI * 1.333333;\n\tpointlight[4].position = vec3(cos(t4) * r, y, sin(t4) * r);\n\tpointlight[4].colour = vec3(0.0, 0.0, 0.5);\n\n\tfloat t5 = -iTime + PI * 1.666666;\n\tpointlight[5].position = vec3(cos(t5) * r, y, sin(t5) * r);\n\tpointlight[5].colour = vec3(0.4, 0.0, 0.4);\n    \n\t//pointlight[0] = PointLight(vec3(-4.0, 4.0, -8.0), vec3(0.5, 0.5, 0.5));\n\t//pointlight[1] = PointLight(vec3(4.0, -4.0, 5.0), vec3(0.5, 0.5, 0.5));\n    //pointlight[2] = PointLight(vec3(2.0, 5.0, 0.0), vec3(1.0, 0.0, 1.0));\n\n}\n\nvec3 illuminatePointLight(PointLight light, Output o){\n    vec3 brightness = vec3(0.0);\n    \n\tvec3 pointToLight = o.origin - light.position;\n    for (int j = 0; j < 3; j++){\n\t\tbrightness[j] += light.colour[j] * o.material.diffuse * dot(normalize(pointToLight), normalize(o.normal));\n\t\tbrightness[j] += light.colour[j] * o.material.specular * dot(normalize(2.0 * dot(normalize(pointToLight), normalize(o.normal))\n\t\t\t\t\t\t\t\t\t\t\t\t * normalize(o.normal) - normalize(pointToLight)),\n\t\t\t\t\t\t\t\t\t   eye - o.origin);\n    }\n    return brightness;\n}\n\nvec3 shade(Output o){\n    vec3 brightness = vec3(o.material.ambient);\n\t\n\tfor (int i = 0; i < numLight; i++){\n\t\tbrightness += illuminatePointLight(pointlight[i], o);\n\t}\n\tbrightness[0] = clamp(brightness[0], 0.0, 1.0);\n    brightness[1] = clamp(brightness[1], 0.0, 1.0);\n    brightness[2] = clamp(brightness[2], 0.0, 1.0);\n\t\n    float dis = length(eye - o.origin);\n\t\n\tdis -= 10.0;\n\tdis *= 0.07;\n\tdis = clamp(dis, 0.0, 1.0);\n    brightness *= o.colour;\n\treturn brightness * (1.0 - dis);\n}\n\nOutput traceStep(in Ray ray){\n    Output o  = Output(vec3(0.0), \n                       vec3(0.0, 0.0, 0.1), \n                       1.0e4,\n                       Material(\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t \t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n                        0.0),\n                       vec3(0.0));\n                      \n\tvec3 colour = vec3(0.0);\n\tfor (int i = 0; i < numSphere; i++){\n\t\tsphereIntersect(sphere[i], ray, o);\n    }\n    \n    for (int i = 0; i < numPlane; i++){\n    \tplaneIntersect(plane[i], ray, o);\n    }\n    \n    return o;\n}\n\nvec3 trace(in Ray ray){\n\tvec3 colour = vec3(0.0);\n    float reflectivity = 1.0;\n    Output o;\n    \n    for (int i = 0; i < 2; i++){\n    \to = traceStep(ray);\n        \n        if (o.dis > 1.0e3) break;\n        \n        colour += shade(o) * reflectivity;\n        \n        reflectivity *= o.material.reflectivity;\n        \n        float l = length(ray.origin - o.origin) + 0.0001;\n\t\tcolour -= 0.02 / l;\n\n\t\treflectivity *= o.material.reflectivity;\n        \n\t\tif(reflectivity < 0.05) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tray = Ray(o.origin + o.normal * 0.0001, reflect(normalize(o.origin - ray.origin), o.normal));\n    }\n    return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmakeScene();\n\t//eye = vec3(5.0, 1.0, -2.0);\n    eye = vec3(sin(iTime) * 4.0, cos(iTime), -4.0);\n    Ray ray = castRay(vec3(0.0));\n\t\n\tvec3 color = trace(ray);\n\tfragColor = vec4(color, 1.0);\n\t\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[790, 790, 815, 815, 1159], [1162, 1162, 1236, 1236, 1719], [1721, 1721, 1791, 1791, 2270], [2272, 2272, 2318, 2318, 2562], [2564, 2564, 2581, 2581, 4548], [4550, 4550, 4604, 4604, 5084], [5086, 5086, 5107, 5107, 5571], [5573, 5573, 5602, 5602, 6108], [6110, 6110, 6133, 6133, 6729], [6731, 6731, 6788, 6788, 6982]], "test": "valid"}
{"id": "ldXSWj", "name": "3D Distance Function Test", "author": "hughes", "description": "distance function test. Renders a simple cube.", "tags": ["raytracing", "distance"], "likes": 10, "viewed": 562, "published": "Public", "date": "1406833193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 16;\nconst vec3 BOX = vec3(1.0);\nconst float THRESHOLD = 0.01;\n\nfloat udBox(vec3 p, vec3 b) {\n\treturn length(max(abs(p) - b, 0.0));\n}\n\nstruct Ray {\n    vec3 position;\n    vec3 direction;\n    bool hit;\n};\n\nRay intersect(Ray ray) {\n\tfor (int i=0; i<MAX_STEPS; i++) {\n\t\tfloat dist = udBox(ray.position, BOX);\n\t\tif (dist < THRESHOLD) {\n            ray.hit = true;\n            return ray;\n\t\t}\n\t\tray.position += ray.direction * dist;\n\t}\n    return ray;\n}\n\nvec3 Rx(vec3 vector, float angle) {\n    float rx = vector.x * cos(angle) + vector.z * sin(angle);\n    float rz = vector.z * cos(angle) - vector.x * sin(angle);\n    return vec3(rx, vector.y, rz);\n}\n\nvec3 render(Ray ray) {   \n    if (ray.hit) {\n        return (ray.position + BOX) / (2.0 * BOX);\n    } else {\n\t\treturn vec3(1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = (uv - vec2(0.5)) * vec2(aspect_ratio, 1.0);\n    \n    float angle = iTime;\n    \n    if (iMouse.z > 0.0) {\n    \tangle = iMouse.x / iResolution.x * 6.0 + 0.5;\n    }\n    \t\n    vec3 camera_loc = 6.0 * vec3(-sin(angle), 0.0, -cos(angle));\n    vec3 camera_dir = vec3(sin(angle), 0.0, cos(angle));\n    \n    Ray ray;\n    ray.position = camera_loc;\n    ray.direction = Rx(normalize(vec3(p, 1.0)), angle);\n    ray.hit = false;\n\t\n\tray = intersect(ray);\n    \n    vec3 col = render(ray);\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 114, 114, 154], [226, 226, 250, 250, 469], [471, 471, 506, 506, 667], [669, 669, 691, 691, 805], [807, 807, 864, 864, 1479]], "test": "valid"}
{"id": "lsfXzf", "name": "GreenLoop", "author": "henrydm", "description": "This is my first shader, very simple but proud! :)", "tags": ["firstshader"], "likes": 3, "viewed": 134, "published": "Public", "date": "1405023580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 center;\n\tcenter = iResolution.xy/2.0;\n\n\tfloat distan = distance(center,fragCoord.xy);\n\tfloat factor = ((distan/center[0])+(distan/center[1]));\t\n\t\n\tfloat offset = sin(iTime);\n\tfloat final = 1.0-(offset+factor)/1.2;\n\n\tfragColor = vec4(0.0,final,0.0,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 320]], "test": "valid"}
{"id": "lslSDS", "name": "Galaxy Trip", "author": "xbe", "description": "Remix of the Start Tunnel shader by P_Malin adding background nebulea and different stars colors. May still need to modify stars shapes for something less regular.", "tags": ["3d", "galaxy", "warp", "starfield", "nebulae"], "likes": 70, "viewed": 6082, "published": "Public", "date": "1406559481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////\n// Xavier Benech\n// Galaxy Trip\n// Inspired by \"Star Tunnel\" shader from P_Malin\n// https://www.shadertoy.com/view/MdlXWr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n\n// Increase pass count for a denser effect\n#define PASS_COUNT 4\n\nfloat fBrightness = 2.5;\n\n// Number of angular segments\nfloat fSteps = 121.0;\n\nfloat fParticleSize = 0.015;\nfloat fParticleLength = 0.5 / 60.0;\n\n// Min and Max star position radius. Min must be present to prevent stars too near camera\nfloat fMinDist = 0.8;\nfloat fMaxDist = 5.0;\n\nfloat fRepeatMin = 1.0;\nfloat fRepeatMax = 2.0;\n\n// fog density\nfloat fDepthFade = 0.8;\n\nfloat Random(float x)\n{\n\treturn fract(sin(x * 123.456) * 23.4567 + sin(x * 345.678) * 45.6789 + sin(x * 456.789) * 56.789);\n}\n\nvec3 GetParticleColour( const in vec3 vParticlePos, const in float fParticleSize, const in vec3 vRayDir )\n{\t\t\n\tvec2 vNormDir = normalize(vRayDir.xy);\n\tfloat d1 = dot(vParticlePos.xy, vNormDir.xy) / length(vRayDir.xy);\n\tvec3 vClosest2d = vRayDir * d1;\n\t\n\tvec3 vClampedPos = vParticlePos;\n\t\n\tvClampedPos.z = clamp(vClosest2d.z, vParticlePos.z - fParticleLength, vParticlePos.z + fParticleLength);\n\t\n\tfloat d = dot(vClampedPos, vRayDir);\n\t\n\tvec3 vClosestPos = vRayDir * d;\n\t\n\tvec3 vDeltaPos = vClampedPos - vClosestPos;\t\n\t\t\n\tfloat fClosestDist = length(vDeltaPos) / fParticleSize;\n\tfloat fShade = clamp(1.0 - fClosestDist, 0.0, 1.0);\n\t\n\tif (d<3.0)\n\t{\n\t\tfClosestDist = max(abs(vDeltaPos.x),abs(vDeltaPos.y)) / fParticleSize;\n\t\tfloat f = clamp(1.0 - 0.8*fClosestDist, 0.0, 1.0);\n\t\tfShade += f*f*f*f;\n\t\tfShade *= fShade;\n\t}\n\t\n\tfShade = fShade * exp2(-d * fDepthFade) * fBrightness;\n\treturn vec3(fShade);\n}\n\nvec3 GetParticlePos( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\n\tfloat fAngle = atan(vRayDir.x, vRayDir.y);\n\tfloat fAngleFraction = fract(fAngle / (3.14 * 2.0));\n\t\n\tfloat fSegment = floor(fAngleFraction * fSteps + fSeed) + 0.5 - fSeed;\n\tfloat fParticleAngle = fSegment / fSteps * (3.14 * 2.0);\n\n\tfloat fSegmentPos = fSegment / fSteps;\n\tfloat fRadius = fMinDist + Random(fSegmentPos + fSeed) * (fMaxDist - fMinDist);\n\t\n\tfloat tunnelZ = vRayDir.z / length(vRayDir.xy / fRadius);\n\t\n\ttunnelZ += fZPos;\n\t\n\tfloat fRepeat = fRepeatMin + Random(fSegmentPos + 0.1 + fSeed) * (fRepeatMax - fRepeatMin);\n\t\n\tfloat fParticleZ = (ceil(tunnelZ / fRepeat) - 0.5) * fRepeat - fZPos;\n\t\n\treturn vec3( sin(fParticleAngle) * fRadius, cos(fParticleAngle) * fRadius, fParticleZ );\n}\n\nvec3 Starfield( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\t\n\tvec3 vParticlePos = GetParticlePos(vRayDir, fZPos, fSeed);\n\t\n\treturn GetParticleColour(vParticlePos, fParticleSize, vRayDir);\t\n}\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n}\n\n// Simplex Noise by IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat marble(in vec2 p)\n{\n\treturn cos(p.x+fbm4(p));\n}\n\nfloat dowarp ( in vec2 q, out vec2 a, out vec2 b )\n{\n\tfloat ang=0.;\n\tang = 1.2345 * sin (33.33); //0.015*iTime);\n\tmat2 m1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 0.2345 * sin (66.66); //0.021*iTime);\n\tmat2 m2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\ta = vec2( marble(m1*q), marble(m2*q+vec2(1.12,0.654)) );\n\n\tang = 0.543 * cos (13.33); //0.011*iTime);\n\tm1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 1.128 * cos (53.33); //0.018*iTime);\n\tm2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\tb = vec2( marble( m2*(q + a)), marble( m1*(q + a) ) );\n\t\n\treturn marble( q + b +vec2(0.32,1.654));\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = 2.*uv-1.;\n\tq.y *= iResolution.y/iResolution.x;\n\t\n\t// camera\t\n\tvec3 rd = normalize(vec3( q.x, q.y, 1. ));\n\tvec3 euler = vec3(\n\t\tsin(iTime * 0.2) * 0.625,\n\t\tcos(iTime * 0.1) * 0.625,\n\t\tiTime * 0.1 + sin(iTime * 0.3) * 0.5);\n\n\tif(iMouse.z > 0.0)\n\t{\n\t\teuler.x = -((iMouse.y / iResolution.y) * 2.0 - 1.0);\n\t\teuler.y = -((iMouse.x / iResolution.x) * 2.0 - 1.0);\n\t\teuler.z = 0.0;\n\t}\n\trd = RotateX(rd, euler.x);\n\trd = RotateY(rd, euler.y);\n\trd = RotateZ(rd, euler.z);\n\t\n\t// Nebulae Background\n\tfloat pi = 3.141592654;\n\tq.x = 0.5 + atan(rd.z, rd.x)/(2.*pi);\n\tq.y = 0.5 - asin(rd.y)/pi + 0.512 + 0.001*iTime;\n\tq *= 2.34;\n\t\n\tvec2 wa = vec2(0.);\n\tvec2 wb = vec2(0.);\n\tfloat f = dowarp(q, wa, wb);\n\tf = 0.5+0.5*f;\n\t\n\tvec3 col = vec3(f);\n\tfloat wc = 0.;\n\twc = f;\n\tcol = vec3(wc, wc*wc, wc*wc*wc);\n\twc = abs(wa.x);\n\tcol -= vec3(wc*wc, wc, wc*wc*wc);\n\twc = abs(wb.x);\n\tcol += vec3(wc*wc*wc, wc*wc, wc);\n\tcol *= 0.7;\n\tcol.x = pow(col.x, 2.18);\n\tcol.z = pow(col.z, 1.88);\n\tcol = smoothstep(0., 1., col);\n\tcol = 0.5 - (1.4*col-0.7)*(1.4*col-0.7);\n\tcol = 0.75*sqrt(col);\n\tcol *= 1. - 0.5*fbm4(8.*q);\n\tcol = clamp(col, 0., 1.);\n\t\n\t// StarField\n\tfloat fShade = 0.0;\n\tfloat a = 0.2;\n\tfloat b = 10.0;\n\tfloat c = 1.0;\n\tfloat fZPos = 5.0;// + iTime * c + sin(iTime * a) * b;\n\tfloat fSpeed = 0.; //c + a * b * cos(a * iTime);\n\t\n\tfParticleLength = 0.25 * fSpeed / 60.0;\n\t\n\tfloat fSeed = 0.0;\n\t\n\tvec3 vResult = vec3(0.);\n\t\n\tvec3 red = vec3(0.7,0.4,0.3);\n\tvec3 blue = vec3(0.3,0.4,0.7);\n\tvec3 tint = vec3(0.);\n\tfloat ti = 1./float(PASS_COUNT-1);\n\tfloat t = 0.;\n\tfor(int i=0; i<PASS_COUNT; i++)\n\t{\n\t\ttint = mix(red,blue,t);\n\t\tvResult += 1.1*tint*Starfield(rd, fZPos, fSeed);\n\t\tt += ti;\n\t\tfSeed += 1.234;\n\t\trd = RotateX(rd, 0.25*euler.x);\n\t}\n\t\n\tcol += sqrt(vResult);\n\t\n\t// Vignetting\n\tvec2 r = -1.0 + 2.0*(uv);\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.15 + 0.85*(1.0-exp(-(1.0-vb)*30.0)));\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslSDS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[659, 699, 722, 722, 824], [826, 826, 933, 933, 1725], [1727, 1727, 1817, 1817, 2513], [2515, 2515, 2600, 2600, 2731], [2733, 2733, 2792, 2792, 2921], [2923, 2923, 2982, 2982, 3111], [3113, 3113, 3172, 3172, 3301], [3303, 3326, 3347, 3347, 3468], [3470, 3470, 3496, 3496, 4031], [4084, 4084, 4109, 4109, 4298], [4300, 4300, 4325, 4325, 4353], [4355, 4355, 4407, 4407, 4985], [4987, 5039, 5096, 5096, 7047]], "test": "error"}
{"id": "lslSRj", "name": "Plasmatron", "author": "danbarber", "description": "An attempt to replicate an old school plasma demo effect. Also, my first shader!", "tags": ["2d"], "likes": 0, "viewed": 137, "published": "Public", "date": "1404478718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n\nfloat time = iTime *0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tfloat xSin1_mult = 120.0;\n\tfloat xSin2_mult = 142.3;\n\t\n\tfloat ySin1_mult = 90.0;\n\tfloat ySin2_mult = 150.3;\n\n\tfloat xVal1 = sin(fragCoord.x / xSin1_mult + sin(time * 1.1) * 5.0);\n\tfloat xVal2 = sin(fragCoord.x / xSin2_mult + sin(time / 1.2) * 6.0);\n\t\t\n\tfloat yVal1 = sin(fragCoord.y / ySin1_mult + sin(time * 1.25) * 2.6);\n\tfloat yVal2 = sin(fragCoord.y / ySin2_mult + sin(time / 1.05) * 5.5);\n\t\n\tfloat red   = (xVal1 + xVal2 + yVal1 + yVal2 + 1.0) / 4.0;\n\tfloat green = (xVal1 + xVal2 + yVal1 + yVal2 + 1.0) / 3.0;\n\tfloat blue  = 0.0 - (xVal1 + xVal2 + yVal1 + yVal2 - 1.0) / 4.0;\n\n\tfragColor = vec4(red, green, blue, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 113, 113, 740]], "test": "valid"}
{"id": "lslXRj", "name": "Wax (fake subsurface)", "author": "TekF", "description": "Another fake lighting trick with distance fields.>\nPress: D - dark scene, S - toggle sub-surface, A,R - toggle occlusion, L - lens effects>\nMouse drag: move camera", "tags": ["distancefields", "subsurfacescattering"], "likes": 108, "viewed": 6494, "published": "Public API", "date": "1404836685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// artefacts from noise texture interpolation\n//#define FAST\n\n// keys\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n// TOGGLES:\n\nconst int kAmbientOcclusion = kA;\nconst int kReflectionOcclusion = kR;\nconst int kSubsurface = kS;\nconst int kLensFX = kL;\nconst int kDarkScene = kD;\n\n\n// consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\n// globals\nvec3 envBrightness = vec3(1);\nconst vec3 darkEnvBrightness = vec3(.02,.03,.05);\n\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\nbool Toggle( int val )\n{\n\treturn !ReadKey( val, true );\n}\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\n#ifdef FAST\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n#else\n\t// high precision interpolation, if needed\n\tvec4 rg = mix( mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(1,0)+0.5)/256.0, 0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(0,1)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+1.5)/256.0, 0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n#endif\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\nfloat Sphere( vec3 p, vec3 c, float r )\n{\n\treturn length(p-c)-r;\n}\n\nfloat Tet( vec3 p, vec3 c, float r )\n{\n\tp -= c;\n\tvec2 s = -vec2(1,-1)/sqrt(3.0);\n\treturn max(max(max(\n\t\t\tdot(p,s.xxx),dot(p,s.yyx)),\n\t\t\tdot(p,s.yxy)),dot(p,s.xyy)) - r*mix(1.0,1.0/sqrt(3.0),1.0);\n}\n\nfloat Oct( vec3 p, vec3 c, float r )\n{\n\tp -= c;\n\tvec2 s = vec2(1,-1)/sqrt(3.0);\n\treturn max(max(max(\n\t\t\tabs(dot(p,s.xxx)),abs(dot(p,s.yyx))),\n\t\t\tabs(dot(p,s.yxy))),abs(dot(p,s.xyy))) - r*mix(1.0,1.0/sqrt(3.0),.5);\n}\n\nfloat Cube( vec3 p, vec3 c, float r )\n{\n\tp -= c;\n\treturn max(max(abs(p.x),abs(p.y)),abs(p.z))-r*mix(1.0,1.0/sqrt(3.0),.5);\n}\n\nfloat CubeFrame( vec3 p, vec3 c, float r )\n{\n\tr = r*mix(1.0,1.0/sqrt(3.0),.5);\n\tp -= c;\n\tp = abs(p);\n\tfloat rr = r*.1;\n\tp -= vec3(r-rr);\n\t// whichever axis is most negative should be clamped to 0\n\tif ( p.x < p.z ) p = p.zyx;\n\tif ( p.y < p.z ) p = p.xzy;\n\tp.z = max(0.0,p.z);\n\treturn length(p)-rr;\n}\n\nfloat DistanceField( vec3 p, float t )\n{\n\treturn\n\t\t\tmin(min(min(\n\t\t\t\tSphere(p,vec3(0,.48,0),.1),\n\t\t\t\tOct(p,vec3(0,.2,0),.2)),\n\t\t\t\tCubeFrame(p,vec3(0,-.05,0),.3)),\n\t\t\t\tSphere(p,vec3(0,-.6,0),.4));\n\n\t// spiral candle\n/*\tp.xz = p.xz*cos(p.y*4.0)+vec2(1,-1)*p.zx*sin(p.y*4.0);\n\treturn max(\n\t\t\t\tmax( p.y-.5, -p.y-1.),\n\t\t\t\t(min(\n\t\t\t\t\tmax(abs(p.x),abs(p.z)),\n\t\t\t\t\tmax(abs(p.x+p.z),abs(p.z-p.x))/sqrt(2.0)\n\t\t\t\t)-.15)*.8);*/\n}\n\nfloat DistanceField( vec3 p )\n{\n\treturn DistanceField( p, 0.0 );\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn envBrightness*mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir1, vec3 lightDir2, vec3 lightCol1, vec3 lightCol2, float shadowMask1, float shadowMask2, float distance )\n{\n\tvec3 ambient = envBrightness*mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); // ambient\n//\t\tambient = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); // ambient\n\t// ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = distance/20.0;\n\t\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )/aoRange ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n\tif ( Toggle(kAmbientOcclusion) )\n\t\tambient *= occlusion*.8+.2; // reduce occlusion to imply indirect sub surface scattering\n\n\tfloat ndotl1 = max(.0,dot(normal,lightDir1));\n\tfloat ndotl2 = max(.0,dot(normal,lightDir2));\n\tfloat lightCut1 = smoothstep(.0,.1,ndotl1);//pow(ndotl,2.0);\n\tfloat lightCut2 = smoothstep(.0,.1,ndotl2);//pow(ndotl,2.0);\n\n\tvec3 light = vec3(0);\n//\tif ( Toggle(kDirectLight,3) )\n\tlight += lightCol1*shadowMask1*ndotl1;\n\tlight += lightCol2*shadowMask2*ndotl2;\n\n\n\t// And sub surface scattering too! Because, why not?\n\tfloat transmissionRange = distance/10.0; // this really should be constant... right?\n\tfloat transmission1 = DistanceField( pos + lightDir1*transmissionRange )/transmissionRange;\n\tfloat transmission2 = DistanceField( pos + lightDir2*transmissionRange )/transmissionRange;\n\tvec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);\n\tvec3 subsurface = vec3(1,.8,.5) * sslight;\n\n\n\tfloat specularity = Noise(pos/vec3(.05,.2,.05)).x;\n\t\n\tvec3 h1 = normalize(lightDir1-ray);\n\tvec3 h2 = normalize(lightDir2-ray);\n\tfloat specPower = exp2(3.0+5.0*specularity);\n\tvec3 specular1 = lightCol1*shadowMask1*pow(max(.0,dot(normal,h1))*lightCut1, specPower)*specPower/32.0;\n\tvec3 specular2 = lightCol2*shadowMask2*pow(max(.0,dot(normal,h2))*lightCut2, specPower)*specPower/32.0;\n\t\n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t\n\t// specular occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )/(aoRange*max(.01,dot(rray,normal))) ); // can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); // tweak the curve\n\t\n\t// prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\tif ( Toggle(kReflectionOcclusion) )\n\t\treflection *= specOcclusion; // could fire an additional ray for more accurate results\n\t\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .01, specularity ), mix( .4, 1.0, specularity ), fresnel );\n\t\n\n//\tvec3 albedo = vec3(1,.95,.9);\n\tvec3 albedo = vec3(.7,.5,1);\n//\tvec3 albedo = vec3(.5,.3,.13);\n\t\n\tvec3 result = vec3(0);\n\n\t// comment these out to toggle various parts of the effect\n\tlight += ambient;\n\n\tif ( Toggle(kSubsurface) )\n\t\tlight += subsurface;\n\t\n\tresult = light*albedo;\n\n\tresult = mix( result, reflection, fresnel );\n\t\n\tresult += specular1 + specular2;\n\n\treturn result;\n}\n\n\n\n\n// Isosurface Renderer\n#ifdef FAST\nconst int traceLimit=40;\nconst float traceSize=.005;\n#else\nconst int traceLimit=60;\nconst float traceSize=.002;\n#endif\t\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray, t );\n\t\tif ( h < traceSize || t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )//|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat TraceMin( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat Min = traceEnd;\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray, t );\n\t\tMin = min(h,Min);\n\t\tif ( /*h < .001 ||*/ t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+max(h,.1);\n\t}\n\t\n\treturn Min;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float t )\n{\n\t// in theory we should be able to get a good gradient using just 4 points\n\n\tfloat pitch = .2 * t / iResolution.x;\n#ifdef FAST\n\t// don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0,t);\n\tfloat f1 = DistanceField(p1,t);\n\tfloat f2 = DistanceField(p2,t);\n\tfloat f3 = DistanceField(p3,t);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\n\t// prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n// Camera\n\nvec3 Ray( float zoom, in vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\t// would love to get some disperson on this, but that means more rays\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 lightCol, vec3 light, float lightVisible, float sky, vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = (dot(light,ray)*.5+.5);\n\t\n\treturn (\n\t\t\t((pow(l,30.0)+.05)*dirt*.1\n\t\t\t+ 1.0*pow(l,200.0))*lightVisible + sky*1.0*pow(l,5000.0)\n\t\t   )*lightCol\n\t\t   + 5.0*pow(smoothstep(.9999,1.0,l),20.0) * smoothstep(.5,1.0,lightVisible) * normalize(lightCol);\n}\n\n\nfloat SmoothMax( float a, float b, float smoothing )\n{\n\treturn a-sqrt(smoothing*smoothing+pow(max(.0,a-b),2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif ( !Toggle(kDarkScene) )\n\t\tenvBrightness = darkEnvBrightness;\n\t\n\tvec3 ray = Ray(1.0,fragCoord);\n\t\n\tif ( Toggle(kLensFX) )\n\t\tBarrelDistortion( ray, .5 );\n\t\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n\tvec2 mouse = vec2(0);\n\t//if ( iMouse.z > 0.0 )\n\t\tmouse = .5-iMouse.yx/iResolution.yx;\n\t\t\n\tfloat T = iTime*.1;\n\tvec3 pos = 3.0*Rotate( ray, vec2(.2,1.0-T)+vec2(-1.0,-6.3)*mouse );\n\t//pos += vec3(0,.3,0) + T*vec3(0,0,-1);\n\t\n\tvec3 col;\n\n\tvec3 lightDir1 = normalize(vec3(3,1,-2));\n\tfloat lt = iTime;\n\tvec3 lightPos = vec3(cos(lt*.9),sin(lt/phi),sin(lt))*vec3(.6,1.2,.6);\n\t\n\tvec3 lightCol1 = vec3(1.1,1,.9)*.7*envBrightness;\n\tvec3 lightCol2 = vec3(.8,.4,.2)*1.0;\n\t\n\tfloat lightRange2 = .4; // distance of intensity = 1.0\n\t\n\tfloat traceStart = .5;\n\tfloat traceEnd = 40.0;\n\t\n\tfloat t = Trace( pos, ray, traceStart, traceEnd );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t// shadow test\n\t\tvec3 lightDir2 = lightPos-p;\n\t\tfloat lightIntensity2 = length(lightDir2);\n\t\tlightDir2 /= lightIntensity2;\n\t\tlightIntensity2 = lightRange2/(.1+lightIntensity2*lightIntensity2);\n\t\t\n\t\tfloat s1 = 0.0;\n\t\ts1 = Trace( p, lightDir1, .05, 2.0 );\n\t\tfloat s2 = 0.0;\n\t\ts2 = Trace( p, lightDir2, .05, 2.0 );\n\t\t\n\t\tvec3 n = Normal(p, ray, t);\n\t\tcol = Shade( p, ray, n, lightDir1, lightDir2,\n\t\t\t\t\tlightCol1, lightCol2*lightIntensity2,\n\t\t\t\t\t(s1>.0)?0.0:1.0, (s2>.0)?0.0:1.0, t );\n\t\t\n\t\t// fog\n\t\tfloat f = 200.0;\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\tif ( Toggle(kLensFX) )\n\t{\n\t\tvec3 lightDir2 = lightPos-pos;\n\t\tfloat lightIntensity2 = length(lightDir2);\n\t\tlightDir2 /= lightIntensity2;\n\t\tlightIntensity2 = lightRange2/(.1+lightIntensity2*lightIntensity2);\n\n\t\t// lens flare\n\t\tfloat s1 = TraceMin( pos, lightDir1, .5, 40.0 );\n\t\tfloat s2 = TraceMin( pos, lightDir2, .5, 40.0 );\n\t\tcol += LensFlare( ray, lightCol1, lightDir1, smoothstep(-.04,.1,s1), step(t,.0), fragCoord );\n\t\tcol += LensFlare( ray, lightCol2*lightIntensity2, lightDir2, smoothstep(-.04,.1,s2), step(t,.0), fragCoord );\n\t\n\t\t// vignetting:\n\t\tcol *= smoothstep( .5, .0, dot(localRay.xy,localRay.xy) );\n\t\n\t\t// compress bright colours, ( because bloom vanishes in vignette )\n\t\tvec3 c = (col-1.0);\n\t\tc = sqrt(c*c+.05); // soft abs\n\t\tcol = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\t\n\t\t// grain\n\t\tvec2 grainuv = fragCoord.xy + floor(iTime*60.0)*vec2(37,41);\n\t\tvec2 filmNoise = texture( iChannel0, .5*grainuv/iChannelResolution[0].xy ).rb;\n\t\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\t}\n\t\n\t// compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));//dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); // prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2/l;\n\t\n\tfragColor = vec4(pow(col,vec3(1.0/2.2)),1);\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslXRj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[808, 894, 932, 932, 1061], [1064, 1064, 1088, 1088, 1121], [1124, 1124, 1149, 1149, 1770], [1773, 1773, 1814, 1814, 1839], [1841, 1841, 1879, 1879, 2038], [2040, 2040, 2078, 2078, 2255], [2257, 2257, 2296, 2296, 2381], [2383, 2383, 2427, 2427, 2681], [2683, 2683, 2723, 2723, 3100], [3102, 3102, 3133, 3133, 3168], [3171, 3171, 3193, 3193, 3288], [3291, 3291, 3456, 3456, 6336], [6341, 6497, 6566, 6566, 6806], [6808, 6808, 6880, 6880, 7120], [7122, 7122, 7166, 7241, 7897], [7900, 7911, 7954, 7954, 8024], [8026, 8026, 8063, 8063, 8278], [8281, 8300, 8355, 8426, 8533], [8535, 8535, 8637, 8637, 8991], [8994, 8994, 9048, 9048, 9108], [9110, 9110, 9167, 9167, 11971]], "test": "error"}
{"id": "lslXWS", "name": "mystery box 3", "author": "dydx", "description": "raymarching", "tags": ["raymarching"], "likes": 7, "viewed": 166, "published": "Public", "date": "1406518749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reference:\n// https://www.shadertoy.com/view/Xds3zN\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nvec3 opRep( vec3 p )\n{\n\tvec3 c = vec3( 2.0, 1.0, 1.0 );\n\treturn mod(p,c)-0.5*c;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opS( float d1, float d2 )\n{\n\treturn max(-d1,d2);\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(00.1*p.z + iTime*0.2);\n    float  s = sin(00.1*p.z + iTime*0.2);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 map( in vec3 pos )\n{\n\t//float box = sdBox( pos-vec3( 0.0,0.1, 0.0), vec3(0.29, 0.09, 0.29) );\n\tfloat box = sdBox( opRep( opTwist(pos-vec3(0.0, 0.0, 0.0)) ), vec3(0.29, 0.09, 0.29) );\n\t//float innerbox = sdBox( pos-vec3( 0.0, 0.1, 0.0), vec3(0.17, 0.1, 0.17) );\n\tfloat innerbox = sdBox( opRep( opTwist(pos-vec3( 0.0, 0.0, 0.0)) ), vec3(0.17, 0.2, 0.17) );\n\t\n\tfloat logo = opS( innerbox, box );\n\t\n\t//res = opU( res, vec2( logo, 14.0 ) );\n\tvec2 res = vec2( logo, 0.0 );\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n  \tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n  \tvec3 nor = vec3(\n      \t  map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n      \t  map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n      \t  map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n    float precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    \tvec3 col = vec3(0.0);\n    \tvec2 res = castRay(ro,rd,20.0);\n    \tfloat t = res.x;\n    \tfloat m = res.y;\n\n    \tvec3 pos = ro + t*rd;\n    \tvec3 nor = calcNormal( pos );\n\n    \tcol = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\n\t\tvec3 lig = normalize( vec3(0.0, 1.0, 0.0) );\n    \tfloat dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\n    \tcol = col*dif;\n\n    \tcol *= exp( -0.01*t*t );\n\n\n    \treturn vec3( clamp(col,0.0,1.0) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\t// camera \n\t// vec3 ro = vec3( -0.5+1.5*cos(0.1*time), 1.0, 0.5 + 1.5*sin(0.1*time) );\n\tvec3 ro = vec3( 1.0*cos(0.2*iTime), 0.3, 1.0*sin(0.1*iTime) );\n\t//vec3 ro = vec3( 0.8, 1.0, -0.8 );\n\t//vec3 ta = vec3( -0.5, -0.4, 0.5 );\n\tvec3 ta = vec3( 0.0, 0.2, 0.0 );\n    \n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n\n  \n\tvec3 col = render( ro, rd );\n\n\tcol = sqrt(sqrt( col ) );\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 130, 152, 152, 211], [213, 213, 243, 243, 276], [278, 278, 311, 311, 334], [336, 336, 360, 360, 506], [509, 509, 540, 540, 625], [627, 627, 652, 725, 1113], [1115, 1115, 1147, 1147, 1384], [1387, 1387, 1442, 1442, 1769], [1772, 1772, 1811, 1811, 2245], [2248, 2248, 2305, 2305, 2971]], "test": "valid"}
{"id": "lssSDB", "name": "Distance Function Torus", "author": "sed", "description": "Stolen from http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm", "tags": ["raycasting", "distancefunction"], "likes": 1, "viewed": 932, "published": "Public", "date": "1406592131", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 opCheapBend(vec3 p)\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nfloat displacement(in vec3 p)\n{\n\tfloat ret = sin(20.0 * p.x) * sin(20.0 * p.y) * sin(20.0 * p.z);\n\t\n\treturn ret;\n}\n\nfloat opDisplace(vec3 p, float d1)\n{\n    float d2 = displacement(p);\n    return d1 + d2;\n}\n\nfloat length2(in vec2 p, in float n)                                                                      \n{                                                                               \n    return pow(pow(p.x, n) + pow(p.y, n), 1.0/n);                               \n}\n\nfloat opU(in float d1, in float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opS(in float d1, in float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat opI(in float d1, in float d2)\n{\n    return max(d1, d2);\n}\n\nfloat sphere(in vec3 p, in float r)\n{\n    return length(p) - r;  \n}\n\nfloat rbox(in vec3 p, in vec3 b, in float r)\n{\n    return length(max(abs(p)-b, 0.0)) - r;  \n}\n\nfloat torus(in vec3 p, in vec2 t, in float n1, in float n2)\n{\n    vec2 q = vec2(length2(p.xz, n1) - t.x, p.y);                              \n    return length2(q, n2) - t.y;                                         \n}\n\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec2 map(in vec3 p)                                                             \n{                                   \n    //float d = torus(p, vec2(0.5, 0.2), \n    //              2.0 + 8.0 * (1.0 + sin(iTime)), \n    //              2.0 + 8.0 * (1.0 + sin(iTime)));\n    \n    float d1 = torus(p, vec2(0.5, 0.2), 2.0, 2.0);\n\tfloat d = d1;\n\t\n    vec2 res = vec2(d, 1.0);                                                     \n                                                                                \n    return res;                                                                  \n}                                                                               \n                                                                                \nvec3 calcNormal(in vec3 p)                                                      \n{                                                                               \n    vec3 e = vec3(0.001, 0.0, 0.0);                                             \n    vec3 n;                                                                     \n                                                                                \n    n.x = map(p + e.xyy).x - map(p - e.xyy).x;                                  \n    n.y = map(p + e.yxy).x - map(p - e.yxy).x;                                  \n    n.z = map(p + e.yyx).x - map(p - e.yyx).x;                                  \n                                                                                \n    return normalize(n);                                                        \n}                                                                               \n                                                                                \nvec2 intersect(in vec3 ro, in vec3 rd)                                          \n{                                                                               \n    float t = 0.0;                                                              \n                                                                                \n    for (int i=0; i<1000; i++)                                                  \n    {                                                                           \n        vec2 h = map(ro + t * rd);                                              \n                                                                                \n        if (h.x < 0.001) return vec2(t, h.y);                                   \n                                                                                \n        t += h.x;                                                               \n                                                                                \n        if (t >= 6.0) break;                                                    \n    }                                                                           \n                                                                                \n    return vec2(0.0);                                                           \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )                                                                 \n{                                                                               \n    // the coordinate of the current fragment                                   \n    vec2 uv = fragCoord.xy / iResolution.xy;                                 \n    // adjustment for aspect ratio                                              \n    vec2 p = (-1.0 + 2.0 * uv) * vec2(iResolution.x/iResolution.y, 1.0);        \n                                                                                \n    // origin of ray                                                            \n    vec3 ro = 1.5 * vec3(cos(0.2 * iTime), 1.0, sin(0.2 * iTime));  \n    // direction of ray                                                         \n    vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);                              \n    vec3 uu = normalize(cross(vec3(00, 1.0, 0.0), ww));                         \n    vec3 vv = normalize(cross(ww, uu));                                         \n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);                        \n                                                                                \n    // the light source                                                         \n    vec3 lig = normalize(vec3(1.0, 0.8, 0.6)); \n    vec3 lig2 = vec3(-lig.x, lig.y, -lig.z);\n                                                                                \n    // the base color                                                           \n    vec3 col = vec3(0.2);                                                       \n                                                                                \n    // calculate intersections with scene                                       \n    vec2 t = intersect(ro, rd);                                                 \n       \n    // if an intersection has occurred\n    if (t.y > 0.0)                                                              \n    {                                 \n        // calculate position of intersection\n        vec3 pos = ro + t.x * rd;            \n        // calculate normal of that point\n        vec3 nor = calcNormal(pos);    \n        // calculate reflected vector\n        vec3 ref = reflect(rd, nor);\n                     \n        // create ambiant, diffuse and specular light values\n        float con = 1.0;\n        float amb = 0.5 + 0.5 * nor.y;                                          \n        float dif = max(0.0, dot(nor, lig));                \n        float spe = pow(clamp(dot(lig,ref), 0.0, 1.0), 8.0);\n        float rim = pow(1.0 + dot(nor, rd), 2.5);\n        float bac = max(0.0, 0.2 + 0.8 * dot(nor, lig2));\n                        \n        //col  = con * vec3(0.1, 0.15, 0.2);\n        col  = amb * vec3(0.1, 0.15, 0.2);                                      \n        col += dif * vec3(0.85, 0.97, 0.0); \n        col += bac * vec3(0.25, 0.37, 0.5);\n        \n        col += 0.3 * rim * amb; \n        col += 0.3 * spe * amb;\n        \n    }             \n                                                                                \n    fragColor = vec4(col,1.0);                                               \n}  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 27, 27, 163], [165, 165, 196, 196, 279], [281, 281, 317, 317, 371], [373, 373, 481, 481, 643], [645, 645, 682, 682, 708], [710, 710, 747, 747, 774], [776, 776, 813, 813, 839], [841, 841, 878, 878, 908], [910, 910, 956, 956, 1003], [1005, 1005, 1066, 1066, 1221], [1223, 1223, 1257, 1257, 1302], [1304, 1304, 1386, 1569, 1889], [2050, 2050, 2132, 2132, 2861], [3022, 3022, 3104, 3104, 4319], [4321, 4321, 4443, 4603, 7558]], "test": "valid"}
{"id": "lssSRX", "name": "FractalMorph", "author": "Passion", "description": "Animated morphing Mandelbrot fractal.  :)", "tags": ["fractal", "animated", "morph"], "likes": 2, "viewed": 137, "published": "Public", "date": "1405203602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\t\n\tvec2 reso = iResolution.xy;\n\t\n\treso.x -= 250.0;\n\treso.y -= 55.0;\n\t\n\tvec2 uv = fragCoord.xy / reso;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t\n\tuv.x += 0.2;\n\tuv.y += 0.8;\n\t\n\tvec2 position = uv - 1.0;\n\tvec2 z = position;\n\t\n\t\tfor(int i = 0; i < 20; i++)\n\t\t{ \t\n\t\t\tposition.y *= sin(iTime*-0.3);  \t\t\t\t\t\n\t\t\tposition.x *= cos(iTime*-0.6);\n\t\t\t\n\t\t\tz = position + vec2(\n            \t\tz.x*z.x-z.y*z.y,\n            \t\t2.0*z.x*z.y);\n            \tif(length(z) > 1.5){\n            \t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n            \t}\n            }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 604]], "test": "valid"}
{"id": "MdfSRs", "name": "Cellphone", "author": "EvilRyu", "description": "It's my cellphone... but can't add more buttons on it because the shader starts to take too long to compile.", "tags": ["raymarching"], "likes": 18, "viewed": 1052, "published": "Public API", "date": "1405849602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// It's my cellphone, created by EvilRyu 2014\n\n#define PI 3.14159265\n#define screen_h 1.6\n#define screen_w 0.9\n#define DIFFUSE 0\n#define REFL 1\n#define EMI 2\n#define MTL_NUM 6\n\n\nfloat stime, ctime;\n\nstruct material_typ{\n  vec3 color;\n  float r0;\n  float smoothness;\n  int type;\n};\n\nmaterial_typ mtl;\n\n\nfloat roundbox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat sphere(vec3 p, float r) {\n    return length(p)-r;\n}\nfloat plane(vec3 p, float y) {\n    return length(vec3(p.x, y, p.z) - p);\n}\n\nfloat expstep(float x, float k, float n)\n{\n    return exp(-k*pow(x,n));\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 cellphonebody( vec3 p, vec3 b, float r )\n{\n    float screen = 0.0;\n    float m = 0.0;\n    vec3 tmp = vec3(-1.75, 0.15, -0.0);\n    \n    if(p.y < 0.0) {\n      // curve of backside\n      b =  vec3(b.x*1.0/(0.1*p.z*p.z+1.0), \n          b.y*1.0*cos(p.z)*1.0*cos(p.x*0.1)-pow(p.x*p.z*p.x*p.z,2.0)*0.0071,  \n          b.z);\n    \n    }else {\n        // screen\n        if(p.x > -screen_h && p.x < screen_h && p.z > -screen_w && p.z < screen_w) {\n            screen = 1.0;\n            b.y -= 0.02;\n        }\n    \n        // slop at both sides\n        float sl1 = -p.z*p.z*0.1 + 1.75;\n        float sl2 = sl1 + 0.25;\n        float by = b.y;\n        if(p.x > sl1) {\n            b.y = by * expstep((p.x - sl1)/(sl2 - sl1), 2.0, 4.0);\n        }\n      \tsl1 += 0.15;\n      \tsl2 = sl1 + 0.25;\n        if(p.x < -sl1) {\n          b.y = b.y * expstep((-p.x - sl1)/(sl2 - sl1), 1.0, 1.5);\n      \t}\n\t\t\n\t\t\n\t\tif(abs(p.x-tmp.x) < 0.03 && abs(p.z-tmp.z) < 0.08){\n\t\t\tb.y -= 0.01;\n\t\t\tscreen = 1.0;\n\t\t}\n    \n\t\ttmp = vec3(-1.75, 0.15, -0.3);\n      if(dot(p - tmp, p - tmp) < 0.002) {\n        b.y -= 0.02;\n        screen = 1.0;\n      }\n\t\ttmp.z -= 0.15;\n\t\tif(dot(p - tmp, p - tmp) < 0.006) {\n\t\t\tb.y -= 0.02;\n\t\t\tscreen = 1.0;\n\t\t}\n\t\ttmp.z -= 0.15;\n\t\tif(dot(p - tmp, p - tmp) < 0.002) {\n\t\t\tb.y -= 0.02;\n\t\t\tscreen = 1.0;\n\t\t}\n\t\ttmp.z -= 0.15;\n\t\tif(dot(p - tmp, p - tmp) < 0.002) {\n\t\t\tb.y -= 0.02;\n\t\t\tscreen = 1.0;\n\t\t}\n\t\ttmp = vec3(1.85, 0.15, 0.6);\n\t\tif(dot(p - tmp, p - tmp) < 0.001) {\n\t\t\tb.y -= 0.02;\n\t\t\tscreen = 1.0;\n\t\t}\n\t\ttmp = vec3(0.7, 0.12, 1.12);\n\t\tif(dot(p - tmp, p - tmp) < 0.001) {\n\t\t\tb.y -= 0.02;\n\t\t\tscreen = 1.0;\n\t\t}\n    \n       b = vec3(b.x*1.0/(0.1*p.z*p.z+1.0), b.y, b.z);\n    }\n    float body = (length(max(abs(p)-b,0.0))-r) * 0.5;\n    \n    float d = 1e10;\n  \n     // buttons\n    //float d8 = cylinder(vec3(p.x + 0.7, p.z + 1.12, p.y - 0.03), vec2(0.03, 0.1));\n\t//float d6 = cylinder(vec3(p.x + 1.0, p.z + 0.95, p.y - 0.03), vec2(0.07, 0.1));\n    //float d7 = cylinder(vec3(p.x - 1.0, p.z + 0.95, p.y - 0.03), vec2(0.07, 0.1));\n    \n    // if(d > d8) {d = d8; m = 3.;}\n    if(-d < body){d = body; m = 1.+screen;} else {d = -d; m = 1.0;}\n    \n    //if(d > d6) {d = d6; m = 1.;}\n    //if(d > d7) {d = d7; m = 1.;}\n    return vec2(d,m);\n}\n\nmaterial_typ getmtl(float m) {\n\tmaterial_typ mtl;\n  \tmtl.type = DIFFUSE;\n  \tmtl.r0 = 0.1;\n  \tmtl.smoothness = 0.3;\n  \tmtl.color = vec3(1.0);\n  \tif(m < 2.0) {\n    \tmtl.color = vec3(1.0); // body\n    \tmtl.type = DIFFUSE;\n    \tmtl.r0 = 0.21;\n    \tmtl.smoothness = 0.6;\n  \t} else if( m < 3.0) {\n   \t \tmtl.color = vec3(0.05);  // screen\n    \tmtl.type = REFL;\n    \tmtl.r0 = 0.01;\n    \tmtl.smoothness = 1.0;\n  \t} else if(m < 4.0) {   \n\t\tmtl.color = vec3(0.0, 2.0, 0.0);  // power\n\t\tmtl.type = EMI;\n\t\tmtl.r0 = 0.2;\n\t\tmtl.smoothness = 0.1;\n\t}\n\treturn mtl;\n}\n\n vec2 f(vec3 p){ \n   //ry(p, stime);\n    float m = 0.;\n    float d = 1e10;\n    vec2 dc = cellphonebody(p, vec3(2.0, 0.15, 1.0), 0.03);\n    float d0 = plane(vec3(p.x, p.y + 0.23, p.z), 0.0);  \n   \n\n    if(d > dc.x) {d = dc.x; m = dc.y;}\n    if(d > d0) {d = d0; m = 4.;}\n        \n    return vec2(d, m); \n } \n\n\n float softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 70; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*max(h, 0.0)/t); \n     t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n } \n\n vec3 nor(vec3 p){ \n    vec3 e=vec3(0.001,0.0,0.0); \n    return normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n                      f(p+e.yxy).x-f(p-e.yxy).x, \n                          f(p+e.yyx).x-f(p-e.yyx).x)); \n } \n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n  \tfloat t = 0.0;\n    vec2 res = vec2(-1.0);\n    vec2 h = vec2(1.0);\n    for( int i=0; i<64; i++ )\n    {\n      if( h.x<0.0005 || t>20.0 ) continue;\n        h = f(ro + rd*t);\n        res = vec2(t,h.y);\n        t += h.x;\n    }\n    if( t>20.0 ) res=vec2(-1.0);\n    return res;\n}\n\n\nfloat phong(vec3 light, vec3 incident, vec3 normal, float smoothness) {\n  \tfloat specpower = exp2(2.0 + 2.0 * smoothness);\n    return max(0.0, pow(clamp(dot(light, reflect(incident, normal)), 0.0, 1.0), specpower)); \n}\n\n\n\nvec3 lighting(vec3 n, vec3 rd, vec3 p, material_typ mtl) {\n  \tvec3 l0_dir = vec3(1.0, 1.0, 0.5);\n    vec3 l0_col = vec3(1.1,1.0,0.9);\n    vec3 ambi_col = vec3(1.0, 1.0, 1.0); \n    vec3 diffuse, specular, lin;\n  \n    float shadow = softshadow(p, l0_dir, 10.0 );\n  \n  \tfloat diff = max(0.0, dot(n, l0_dir));\n  \tfloat spec = phong(l0_dir, rd, n, mtl.smoothness);\n  \tfloat ambi = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n    float back = max(0.3 + 0.7 * dot(vec3(-l0_dir.x, -1.0, -l0_dir.z), n), 0.0); \n  \n     \n    diffuse = 3.8 * diff * shadow * l0_col;\n  \tdiffuse += 0.6 * ambi * ambi_col;\n  \tdiffuse += 0.5 * back * l0_col;\n  \tdiffuse *= mtl.color;\n  \tspecular = 3.0 * spec * l0_col;\n\n  \tlin = diffuse + specular;\n     \n    float be = 0.05;// black edge for the screen\n    if(p.y>0.0 && p.x>-screen_h+be && p.x<screen_h-be && p.z>-screen_w+be && p.z<screen_w-be)\n        lin += 5.*texture(iChannel0, vec2((p.x+screen_h-be) / (2.0*(screen_h+be)),\n                              1.0-(p.z+screen_w-be) / (2.0*(screen_w+be)))).xyz;\n\n  return lin;\n\n}\nvec3 banzai(vec3 ro, vec3 rd, inout float t) {\n  \n    vec3 col;\n    vec3 p=ro; \n   \n    vec2 res = intersect(ro, rd);\n    t = res.x;\n   \n    if(t > -0.5){\n        p = ro + t * rd;\n        material_typ mtl = getmtl(res.y);\n        vec3 n=nor(p); \n    \n      if(mtl.type == EMI) {\n          col = vec3(0.0,1.0,0.0);\n      } else {\n       \n          col = lighting(n, rd, p, mtl);\n          vec3 ground = texture(iChannel1, p.xz).xxx;\n            if(int(res.y+0.1) == 4)col *= ground;\n            col *= 0.2;\n      }\n    \n    } \n  return col;\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n    vec2 uv = -1.0 + 2.0*q; \n    uv.x*=iResolution.x/iResolution.y; \n    // camera\n    stime=sin(iTime*0.2); \n    ctime=cos(iTime*0.2); \n\n    vec3 ta=vec3(0.0,0.0,0.0); \n    vec3 ro=vec3(2.0*stime,2.5, 4.5 + 0.5*ctime); \n\n    vec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n    vec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 bg = exp(uv.y-2.0)*vec3(0.1, 0.1, 0.1);\n    vec3 col;\n    float t;\n   \n    col = banzai(ro, rd, t);\n    if(t <= 0.0) col = bg;\n    col=mix(col,bg, 1.0-exp(-0.01*t*t)); \n    \n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n    fragColor=vec4(col.x,col.y,col.z,1.0); \n }", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfSRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 303, 346, 346, 386], [387, 387, 418, 418, 444], [445, 445, 475, 475, 519], [521, 521, 563, 563, 594], [596, 596, 628, 628, 731], [733, 733, 780, 780, 2953], [2955, 2955, 2985, 2985, 3503], [3506, 3506, 3521, 3541, 3809], [3814, 3814, 3859, 3859, 4104], [4108, 4108, 4125, 4125, 4322], [4325, 4325, 4367, 4367, 4643], [4646, 4646, 4717, 4717, 4864], [4868, 4868, 4926, 4926, 5923], [5924, 5924, 5970, 5970, 6465], [6468, 6468, 6527, 6527, 7433]], "test": "error"}
{"id": "MdfXWB", "name": "Infinite KIFS Zoom 2", "author": "andyalias", "description": "Another simulated zoom into a Kaleidoscopic IFS fractal. The original: https://www.shadertoy.com/view/4sS3WV", "tags": ["zoom", "kifs"], "likes": 24, "viewed": 1301, "published": "Public", "date": "1406239564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @acaudwell\n// 2014\n\n#define MAX_RAY_STEPS 48\n#define KIFS_ITERATIONS 16\n\n// uncomment to see how it works ...\n//#define DEBUG\n\n// enable ray sphere intersection test\n#define INTERSECTION_TEST\n\n#define COLOUR vec3(0.75, 1.0, 1.75)\n\n#ifdef DEBUG\nvec3 col1 = vec3(1.0, 0.0, 0.0);\nvec3 col2 = vec3(0.0, 1.0, 0.0);\nvec3 col3 = vec3(0.0, 0.0, 1.0);\nvec3 col4 = vec3(1.0, 0.0, 1.0);\nvec3 col5 = vec3(0.0, 1.0, 1.0);\n#else\nvec3 col  = COLOUR;\nvec3 col1 = COLOUR;\nvec3 col2 = COLOUR;\nvec3 col3 = COLOUR;\nvec3 col4 = COLOUR;\nvec3 col5 = COLOUR;\n#endif\n\nmat4 calc_transform(vec3 offset, vec3 axis, float angle, float scale) {\n\n    angle *= radians(1.0);\n\n    float c = cos(angle);\n    float s = sin(angle);\n\n    vec3 t = (1.0-c) * axis;\n\n    return mat4(\n        vec4(c + t.x * axis.x, t.y * axis.x - s * axis.z, t.z * axis.x + s * axis.y, 0.0) * scale,\n        vec4(t.x * axis.y + s * axis.z, (c + t.y * axis.y), t.z * axis.y - s * axis.x, 0.0) * scale,\n        vec4(t.x * axis.z - s * axis.y, t.y * axis.z + s * axis.x, c + t.z * axis.z, 0.0) * scale,\n        vec4(offset, 1.0)\n    );\n}\n\nmat4 M;\n\nfloat KIFS(vec3 p, float s) {\n        \n        p /= s;\n        \n        for(int i=0;i<KIFS_ITERATIONS;i++) {\n                \n                p = abs(p);\n                \n                // apply transform\n                p = (M * vec4(p, 1.0)).xyz;\n        }\n        \n        // divide by scale preserve correct distance\n        return ((length(p)-1.0) * (pow(1.5, -float(KIFS_ITERATIONS))))*s;\n}\n\nvec3 dir;\n\nbool intersect(vec3 p, float r) {\n\n    float b = 2.0 * dot(dir, p);\n    float c = dot(p, p) - r*r;\n\n    float sq = sqrt(b*b - 4.0*c);\n\n    float t1 = (-b + sq) * 0.5;\n    float t2 = (-b - sq) * 0.5;\n\n    float near = min(t1, t2);\n    float far  = max(t1, t2);\n\n    return near < far && far > 0.0;\n}\n\n\nvoid combineKIFS(vec3 p, float s, vec3 c, inout vec4 o) {\n\n#ifdef INTERSECTION_TEST\n    if(intersect(p, s*1.75)) {\n#endif\n                float d = KIFS(p,s);\n                if(d<o.x) o = vec4(d,c);\n#ifdef INTERSECTION_TEST\n        }\n#endif\n}\n\n#define SF 0.2\n\nvec3 sp = normalize(vec3(-0.5,0.55,-0.5));\n\nvec4 scene(vec3 p) {\n\n        vec3 p1 = p - (sp + sp*SF);\n        vec3 p2 = p - (sp + sp*SF*2.0 + sp*SF*SF);\n        vec3 p3 = p - (sp + sp*SF*2.0 + sp*SF*SF*2.0 + sp*SF*SF*SF);\n        vec3 p4 = p - (sp + sp*SF*2.0 + sp*SF*SF*2.0 + sp*SF*SF*SF*2.0 + sp*SF*SF*SF*SF);\n        vec3 p5 = p - (sp + sp*SF*2.0 + sp*SF*SF*2.0 + sp*SF*SF*SF*2.0 + sp*SF*SF*SF*SF*2.0 + sp*SF*SF*SF*SF*SF);\n\n        vec4 o = vec4(10000.0,vec3(0.0));\n\n        combineKIFS(p1,SF,             col1, o);\n        combineKIFS(p2,SF*SF,          col2, o);\n        combineKIFS(p3,SF*SF*SF,       col3, o);\n        combineKIFS(p4,SF*SF*SF*SF,    col4, o);\n        combineKIFS(p5,SF*SF*SF*SF*SF, col5, o);\n        \n        return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    M = calc_transform(vec3(-0.4,-0.4,-0.4),normalize(vec3(1.0, 1.0, 1.0)), 40.0, 1.5);\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n        uv.x = -uv.x;\n        \n        dir = normalize(vec3(uv.x, uv.y * (iResolution.y/iResolution.x), 0.8));\n        \n        \n        float t = log(1.0 + 4.0*fract(iTime/2.0)) / log(5.0);\n        \n        float ratio = iResolution.y/iResolution.x;\n        \n        vec3 start = vec3(-0.01,0.175*ratio,-SF*1.5);\n        //start.y += sin(fract(iTime/2.0)*radians(360.0)) * SF * 0.01;\n        //start.x -= cos(fract(iTime/2.0)*radians(360.0)) * SF* 0.01;\n        \n        vec3 t1 = sp + sp*SF + start;\n        vec3 t2 = sp + sp*SF*2.0 + sp*SF*SF + start * SF;\n        \n        vec3 cam = t1 + (t2-t1) * t;\n        \n        float d = 1.0;\n        float ray_length = 0.0;\n        \n        int steps = 0;\n        \n        vec3 bg = vec3(0.0,2.0,2.0);\n        \n        vec3 c = bg * pow(length(vec2(uv.x,uv.y)*0.45),3.0);\n        \n        vec4 s = vec4(0.0);\n        \n        float lod = 0.56 /max(iResolution.x,iResolution.y);\n        \n        for(int i=0; i<MAX_RAY_STEPS; i++) {\n                if(d<ray_length*lod) continue;\n                s = scene(cam);\n                d = s.x;\n                cam += d * dir;\n                ray_length += d;\n                steps++;\n        }\n        \n        if(ray_length<1.0) {\n                c = s.yzw;\n                \n                float cost = float(steps)/float(MAX_RAY_STEPS+1);\n                \n                // cost based shading\n                \n                c *= pow(1.0 - cost,3.0);\n                \n                c /= 1.0- pow(1.0 - cost,27.0);\n                \n                c = clamp(c,0.0,1.0);\n                \n                c *= c;\n                \n                c += cost*0.05 * bg;\n        }\n        \n        c *= 1.0+min(0.0,uv.y);\n        \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfXWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 546, 617, 617, 1080], [1091, 1091, 1120, 1120, 1488], [1501, 1501, 1534, 1534, 1799]], "test": "valid"}
{"id": "MdlXRj", "name": "AMERICA", "author": "TylerGlaiel", "description": "Happy 4th!", "tags": ["flag"], "likes": 1, "viewed": 407, "published": "Public", "date": "1404506534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define antialias 8.0\n\n//official colors from http://en.wikipedia.org/wiki/Flag_of_the_United_States#Colors\n#define white 1.0, 1.0, 1.0\n#define red   .698, .132, .203\n#define blue  .234, .233, .430\n\n#define sky    0.086,  0.662, 0.788\n\nvec4 star(vec2 uv){\n\tuv -= vec2(.5, .5);\n\tuv *= .65;\n\tuv.x *= 2.0;\n\tvec2 polar = vec2(atan(uv.x, uv.y), length(uv));\n\tpolar.x /= 2.0*3.141592;\n\t\n\tpolar.x += .5;\n\t\n\tfloat triangle = polar.y*3.1415*2.0*(fract(polar.x*10.0)-.5) * -sign(fract(polar.x*5.0)-.5);\n\t\n\t//triangle = cos(polar.x*5.0*2.0*3.1415);\n\t\n\treturn polar.y > (triangle*.6+1.0)*.2 ? vec4(blue,1) : vec4(white,1);\n}\n\nvec2 warp(vec2 uv){\n\tuv.y += sin(-iTime*5.0 + uv.x*uv.x*10.0)*.2*uv.x - uv.x*.3;\n\tuv.x += uv.y*.05;\n\treturn uv;\n}\n\nvec4 fsample(vec2 coord){\n\tvec2 uv = coord / iResolution.xy;\n\tuv *= vec2(1.05, 1.2);\n\tuv -= vec2(0.05, 0.025);\n\t\n\tuv = warp(uv);\n\t\n\tvec4 color = vec4(white, 1);\n\t\n\tif(uv.x < .4 && uv.y > 6.0/13.0){\n\t\tcolor = vec4(blue, 1);\n\t\t\n\t\t//stars\n\t\tvec2 uv_star = (uv+vec2(0.0, 6.0/13.0)) / vec2(.4, 6.0/13.0);\n\t\t\n\t\t\n\t\tfloat indexxmax = 6.0;\n\t\tfloat indexxmin = 0.0;\n\t\t\n\t\tif(fract(uv_star.y*9.0*.5) < .5){\n\t\t\tuv_star.x += .5/6.0;\n\t\t\tindexxmin = 5.0;\n\t\t\tindexxmin = 1.0;\n\t\t}\n\t\t\n\t\tfloat indexy = floor(uv_star.y*9.0);\n\t\tfloat indexx = uv_star.x*6.0;\n\t\t\n\t\t\n\t\tuv_star.y -= floor(uv_star.y*9.0)/9.0;\n\t\tuv_star.y *= 9.0;\n\t\t\n\t\t\n\t\tuv_star.x -= floor(uv_star.x*6.0)/6.0;\n\t\tuv_star.x *= 6.0;\n\t\t\n\t\t\n\t\tif(indexx > indexxmin && indexx < indexxmax && indexy > 18.0 && indexy < 28.0){\n\t\t\tcolor = star(uv_star);\n\t\t}\n\t} else {\n\t\t//stripes\n\t\tif(fract(uv.y*6.5) < .5){\n\t\t\tcolor = vec4(red, 1);\n\t\t}\n\t\t\n\t}\n\t\n\tif(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0){\n\t\tcolor = vec4(sky,1);\n\t}\n\t\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t//do anti alias\n\tvec4 accum = vec4(0,0,0,0);\n\t\n\tfloat ct = 0.0;\n\n\tfor(float x = -.5+.5/antialias; x <= .5-.25/antialias; x += 1.0/antialias){\n\t\tfor(float y = -.5+.5/antialias; y <= .5-.25/antialias; y += 1.0/antialias){\n\t\t\tvec2 off = vec2(x, y);\n\t\t\taccum += fsample(fragCoord.xy + off);\n\t\t\tct += 1.0;\n\t\t}\n\t}\n\n\tfragColor = accum/ct;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 236, 255, 255, 612], [614, 614, 633, 633, 727], [729, 729, 754, 754, 1710], [1712, 1712, 1768, 1787, 2105]], "test": "valid"}
{"id": "MdlXzj", "name": "vilder_square", "author": "amaurel", "description": "vilder_square", "tags": ["square"], "likes": 0, "viewed": 124, "published": "Public", "date": "1404560763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define POS0 vec4(10.0, 30.0, 10.0, 2.0)\n#define FREQ vec4(1.0, 0.8, 0.7, 1.0)\n \n#define NCOLS 250.0\n\n#define BLACK_COLOR vec4(0.0,0.0,0.0,1.0)\n\n#define COLOR1 vec4(0.0,1.0,0.0,1.0)\n#define COLOR2 vec4(0.0,0.0,1.0,1.0)\n#define COLOR3 vec4(0.0,0.8,0.0,1.0)\n#define COLOR4 vec4(0.0,0.0,0.8,1.0)\n\n#define WHITE_COLOR vec4(1.0,1.0,1.0,1.0)\n \n  \n float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\t\n\tfloat patterWidth = iResolution.x / NCOLS;\n\t\n\tfloat nRows = float(int(iResolution.y / patterWidth)) + 1.0;\n\t\n\tfloat patterHeight = iResolution.y / nRows;\n\t \n\tint iCol = int(fragCoord.x / patterWidth);\n\tint iRow = int(fragCoord.y / patterHeight);\n\t\n\tvec2 coord = vec2(float(iCol),float(iRow));\n\t\n\tfloat i = float(iCol) + (float(iRow) * NCOLS);\n\t//float si = rand(vec2(float(iCol+1),float(iRow+1)));\n\t//float si = (1.0 + sin(i) + cos(2.0*i)) / 3.0;\n \t//float si = 0.5;\n\t//float si = i / (nRows * NCOLS);\n\t\n\tvec2 center = vec2(NCOLS/2.0, nRows / 2.0);\n\tfloat si =   distance(center,coord) / distance(center,vec2(0.0,0.0));\n\t\n\t//float si = degrees(acos((coord.x-center.x)/ distance(center,coord))) / 180.0;\n\t \n\tfloat si2 = (si + (0.05*sin(0.2*iTime))) / 1.05;\n\t \n\t//si2 = si;\n \n\tvec4 timePattern = POS0 * si + (iTime * (FREQ * si2 + 1.5));\n\t\n\tvec4 pattern_cell_pos = vec4(float(iCol) , (float(iRow)), float(iRow)+0.5, (float(iCol) + 0.5));\n  \n\tvec4 patternSize = vec4(patterWidth, patterHeight, patterHeight, patterWidth);\n\t  \n\tvec4 movingEdge = (pattern_cell_pos * patternSize) + ((patternSize / 4.0) * (1.0 + sin(timePattern)));\n\t\n\tfloat ym = patterHeight * (float(iRow) + 0.5);\n\tfloat xm = patterWidth * (float(iCol) + 0.5);\n\t\n\tvec4 cc = vec4(0.6,0.8,0.9,0.0);\n\t vec4 color = (1.0 + sin(cc * iTime)) / 2.0;\n \n\t\n\tvec4 color1 = color;\n\tvec4 color2 = color1;\n\tvec4 color3 = color1;\n\tvec4 color4 = color1;\n\t\n\t/*\n\tvec4 color1 = COLOR1;\n\tvec4 color2 = COLOR2;\n\tvec4 color3 = COLOR3;\n\tvec4 color4 = COLOR4;\n\t  */\n\t\n\tif (fragCoord.x < movingEdge.x && fragCoord.y > ym ){\n\t\tfragColor = color1;\n\t} else if (fragCoord.y < movingEdge.y  && fragCoord.x < xm ){\n\t\tfragColor = color2;\n\t} else if (fragCoord.x > movingEdge.w && fragCoord.y < ym){\n\t\tfragColor = color3;\n\t} else if (fragCoord.y > movingEdge.z && fragCoord.x > xm){\n\t\tfragColor = color4;\n\t} else {\n\t\tfragColor = WHITE_COLOR;\n\t}\n\t \n}\n \n\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[342, 342, 362, 362, 434], [436, 436, 493, 493, 2377]], "test": "valid"}
{"id": "MdsSDS", "name": "Mandelbrot, yet another.", "author": "Lanza", "description": "My first encounter with Mandelbrot set.\nAlready seen thousand times, but I had to do this one.", "tags": ["2d", "fractal", "mandelbrotset"], "likes": 3, "viewed": 165, "published": "Public", "date": "1406575775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXITER 200\n#define PI 3.14159265359\n\nvec2 complexMul(vec2 a, vec2 b)\n{\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nint mandel(vec2 p) {\n\tvec2 p2 = p;\n\tint it = 0;\n\tfor(int i = 0; i < MAXITER; i++) {\n\t\tp = complexMul(p, p) + p2; it = i;\n\t\tif(length(p) >= 2.0) break;\n\t}\n\t\t\n\treturn it;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// 4.0 x 4.0 canvas\n\tvec2 uv = 4.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// center at 0.0\n\tuv -= 2.0;\n\t\n\t// fix aspect ratio\n\tuv.y *= iResolution.y / iResolution.x; \n\t\n\tvec3 c = vec3(1.0 - float(mandel(uv))/(31.0 + sin((iTime - PI/2.0)) * 30.0));\n\tfragColor = vec4( c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsSDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 79, 79, 141], [143, 143, 163, 163, 313], [315, 315, 372, 393, 648]], "test": "valid"}
{"id": "MdsSRj", "name": "Plasmatron 4", "author": "danbarber", "description": "Final Plasmatron!", "tags": ["2d", "plasma", "demoscene"], "likes": 7, "viewed": 288, "published": "Public", "date": "1404482344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float width = iResolution.x;\n    float height = iResolution.y;\n\n    float scale = width / 1.25;\n\n    float time = iTime * 0.3;\n\n    // calculate the centre of the circular sines\n\tvec2 center = vec2((width / 2.0) + sin(time) * (width / 1.5),\n\t\t\t\t\t   (height / 2.0) + cos(time) * (height / 1.5));\n\t\n\tfloat distance = length(fragCoord.xy - center);\n\t\n\t// circular plasmas sines\n\tfloat circ = (sin(distance / (scale / 7.6) + sin(time * 1.1) * 5.0) + 1.25)\n\t\t\t   + (sin(distance / (scale / 11.5) - sin(time * 1.1) * 6.0) + 1.25);\n\t\n\t// x and y plasma sines\n\tfloat xval = (sin(fragCoord.x / (scale / 6.5) + sin(time * 1.1) * 4.5) + 1.25)\n\t\t\t   + (sin(fragCoord.x / (scale / 9.2) - sin(time * 1.1) * 5.5) + 1.25);\n\t\n\tfloat yval = (sin(fragCoord.y / (scale / 6.8) + sin(time * 1.1) * 4.75) + 1.25)\n\t\t\t   + (sin(fragCoord.y / (scale / 12.5) - sin(time * 1.1) * 5.75) + 1.25);\n\n\t// add the values together for the pixel\n\tfloat tval = circ + xval + yval / 3.0;\n\t\n\t// work out the colour\n\tvec3 color = vec3((cos(PI * tval / 4.0 + time * 3.0) + 1.0) / 2.0,\n\t\t\t\t\t  (sin(PI * tval / 3.5 + time * 3.0) + 1.0) / 2.5,\n\t\t\t\t\t  (sin(PI * tval / 2.0 + time * 3.0) + 2.0) / 8.0);\n\t\n\t// set the fragment colour\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 88, 88, 1313]], "test": "valid"}
{"id": "MdsSRl", "name": "Hypnotic Disco", "author": "xbe", "description": "A simple shader, just putting together some stuff from different parts and tweaking them into something funny... There is still plenty of room for optimization so far.", "tags": ["2d", "oldschool", "spiral"], "likes": 22, "viewed": 1966, "published": "Public", "date": "1405963418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////\n// Hypnotic Disco\n\n// Noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404;\n\tconst float K2 = 0.211324865;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Adapted from lensflare by Musk \nvec3 spotLight(vec2 uv,vec2 pos)\n{\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat ang = atan(main.x/main.y);\n\tfloat dist=length(main); dist = pow(dist,.1);\n\t\n\tfloat f0 = 1.0/(length(main)*16.0+1.0);\n\tf0 = f0 + f0 * (sin(noise(vec2(0.,(pos.x+pos.y)*2.2+ang*4.0+5.954)*2.0))*.1+dist*.1+.8);\n\t\n\tvec3 c = - vec3(length(uvd)*.05);\n\tc+=vec3(f0);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat T = iTime;\n\tfloat T2 = 2.*iTime;\n\tfloat T3 = 3.*iTime;\n\tfloat T_20 = iTime/20.;\n\t//\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = 2.*uv-1.;\n\tq.y *= iResolution.y/iResolution.x;\n\t//\n\tfloat a = 360. * noise( vec2(0., T_20) );\n\tmat2 rotmat = mat2(cos(a), -sin(a), sin(a), cos(a));\n\tq = rotmat*q;\n\t//\n\tvec3 tint = vec3(fract(a),1.,1.);\n\t//\n\tconst float nbc = 128.;\n\tfloat st = sin(T_20);\n\tvec2 c = vec2(0.,0.);\n\tvec3 col = vec3(0.,0.,0.);\n\tfloat inc = 3.14159*cos(0.1*T);\n\tfloat d = 0.;\n\tfor(float i=0.; i<nbc; i+=1.)\n\t{\n\t\tc.x = cos(i*inc);\n\t\tc.y = sin(i*inc);\n\t\tc *= i/nbc;\n\t\td = length(q-c);\n\t\ttint.y = fract(T2);\n\t\ttint.z = fract(i/nbc*st+T);\n\t\tcol += clamp(exp(-64.*d),0.,1.) * hsv2rgb(tint);\n\t}\n\t// Spots\n\tvec2 pos;\n\tpos.x=sin(T2)*.5;\n\tpos.y=sin(T2*.913)*.5;\n\tvec3 colf = tint * (spotLight(q,pos) + spotLight(q,-pos));\n\t//\n\tcol = clamp(col+colf,0.,1.);\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsSRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 55, 76, 76, 195], [197, 197, 223, 223, 645], [647, 706, 728, 728, 888], [890, 925, 959, 959, 1289], [1291, 1291, 1348, 1348, 2247]], "test": "valid"}
{"id": "MdsSzf", "name": "Sunset 9:25", "author": "sepych", "description": "My first shader. Thx iq for a great tutorial.", "tags": ["procedural", "2d", "waves", "drawing"], "likes": 74, "viewed": 2454, "published": "Public", "date": "1405448321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 toGLColor(vec3 color) \n{\n\treturn color * 0.00392156862;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n\tfloat smoothness = 0.002;\n\t\n\tvec2 p = vec2(0.5, 0.5*iResolution.y/iResolution.x);\n\t\n\tvec3 col1 = toGLColor(vec3(203, 136, 180));\n\tvec3 col2 = toGLColor(vec3(149, 165, 166));\n\tvec3 col3 = toGLColor(vec3(52, 152, 219));\n\tvec3 col4 = toGLColor(vec3(22, 160, 133));\n\tvec3 col5 = toGLColor(vec3(14, 122, 160));\n\tvec3 col6 = toGLColor(vec3(14, 12, 60));\n\tvec3 col7 = toGLColor(vec3(241, 200, 165));\n\tvec3 col8 = vec3(1., 1., 1.);\n\tvec3 col9 = vec3(1., 1., 1.);\n\n\tvec3 col = col2;\n\t\t\n\n\t// shadow shape\n\tvec2 q = p - uv;\n\tq *= vec2(0.5, 2.5); // scale\n\tq += vec2(0.0, -0.6); // translate\n\tfloat shape = 1. - smoothstep(0., 0.15, length(q));\n\tcol = col + col9*0.3*shape;\n\t\n\t// object shape\n\tq = p - uv;\n\tfloat qLen = length(q);\n\tfloat sfunc = 0.2 + 0.01*exp(sin(atan(q.y, q.x)*4.)*0.9);\n\tshape = 1. - smoothstep(sfunc, sfunc + smoothness, qLen);\n\tcol = mix(col, col1, shape);\n\t\n\tfloat gradShape = 1. - smoothstep(sfunc-0.05, sfunc, qLen);\n\tfloat rayShape = shape;\n\tfloat waveShape1 = shape;\n\tfloat waveShape2 = shape;\n\t\n\t// rays and sun\n\tsfunc = 0.05 + 0.01*exp(sin(atan(q.y, q.x)*10.)*0.5);\n\trayShape *= 1. - smoothstep(sfunc, sfunc + 0.2, qLen);\n\tfloat spec = 40. + 3.*sin(iTime) + sin(iTime*0.8);\n\tcol7 += pow(1.-qLen, spec);\n\tcol = mix(col, col7, rayShape);\n\n\t// wave 1\n\tfloat waveFunc = 0.3 + (0.01*sin(uv.x * 35. + iTime*2.)) \n\t\t+ (0.005*sin(uv.x * 20. + iTime*0.5));\n\twaveShape1 *= 1. - smoothstep(waveFunc, waveFunc + smoothness, uv.y);\n\tcol = mix(col, col3, waveShape1);\n\t\n\t// wave 2\n\twaveFunc = 0.3 + (0.02*sin(uv.x * 20. + iTime*2.)) \n\t\t+ (0.005*sin(uv.x * 30. + iTime*0.7));\n\twaveShape2 *= 1. - smoothstep(waveFunc, waveFunc + smoothness, uv.y);\n\tfloat waveTop = 1. - smoothstep(waveFunc-0.005, waveFunc, uv.y);\n\tcol5 = mix(col6, col5, 0.5+uv.y*1.7);\n\tcol4 = mix(col3, col5, waveTop);\n\tcol = mix(col, col4, waveShape2);\n\t\n\t// inner shadow\n\tcol8 *= gradShape;\n\tcol = col + col8*0.05;\n\t\n\t\n\t// highlight\n\tq += vec2(-0.2, 0.15);\n\tshape = 1. - smoothstep(0., 0.2, length(q));\n\tcol = col + col8*0.6*shape;\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 62], [64, 64, 121, 121, 2198]], "test": "valid"}
{"id": "MdsSzj", "name": "mandelbulbs", "author": "EvilRyu", "description": "http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/", "tags": ["raymarching", "fractal"], "likes": 12, "viewed": 529, "published": "Public", "date": "1404655812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n   Different distance estimations from:http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n\n * z = r*(sin(theta)cos(phi) + i cos(theta) + j sin(theta)sin(phi)\n * zn+1 = zn^8 +c\n * z^8 = r^8 * (sin(8*theta)*cos(8*phi) + i cos(8*theta) + j sin(8*theta)*sin(8*theta)\n * zn+1' = 8 * zn^7 * zn' + 1\n\n\n*/\n\nfloat stime, ctime;\nbool is_julia = true;\nvec3 julia = vec3(-0.6,-0.8,0.7);\n\nvec3 gradient;\n\n#define EPS 0.0001\n\nvoid ry(inout vec3 p, float a){  \n    float c,s;vec3 q=p;  \n    c = cos(a); s = sin(a);  \n    p.x = c * q.x + s * q.z;  \n    p.z = -s * q.x + c * q.z; \n}  \n\nvoid rx(inout vec3 p, float a){  \n    float c,s;vec3 q=p;  \n    c = cos(a); s = sin(a);  \n    p.y = c * q.y - s * q.z;  \n    p.z = s * q.y + c * q.z; \n}  \n\nvec3 hash3(float n){\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123, 22578.1459123, 19642.3490423));\n}\n\nfloat hash(vec2 p){\n    float h=dot(p,vec2(127.1, 311.7));\n    return -1.0+2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec2 p){\n   vec2 i=floor(p);\n   vec2 f=fract(p);\n   vec2 u=f*f*(3.0-2.0*f);\n   return mix(mix(hash(i+vec2(0.0,0.0)), hash(i+vec2(1.0,0.0)), u.x),\n              mix(hash(i+vec2(0.0,1.0)), hash(i+vec2(1.0,1.0)), u.x),\n              u.y);\n}\n\t\nfloat plane(vec3 p, float y) { return distance(p, vec3(p.x, y, p.z)); }\n\nvec3 bulb_power(vec3 z, float power) {\n    float r = length(z);\n\n    float theta = acos(z.y / r) * power;\n    float phi = atan(z.z, z.x) * power;\n\n    return pow(r, power) * vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi));\n}\n\n\n/* method 1: the potential gradient approximation -------------------------------------------*/ \n// use gradient.\nfloat _sinh(float x) {\n    return 0.5 * (exp(x) - exp(-x));\n}\n\nvec3 potential(vec3 p) {\n    vec3 z = p;\n    float power = 8.0;\n    float t0 = 1.0;\n    float r;\n    float iter = 0.0;\n\tvec3 c = p;\n\tif(is_julia)\n\t\tc = julia;\n\tjulia.y = stime;\n\tjulia.x = ctime;\n\n    for(int i = 1; i < 8; ++i) {\n        z = bulb_power(z, power) + c;\n        r = length(z);\n\t\try(z, stime);\n        // orbit trap to mimic ao\n        t0 = min(t0, r);\n\n        if(r > 2.0) {\n            iter = float(i);\n            break;\n        }\n    }\n    return vec3(log(r) / pow(power, iter), t0, 0.0);\n}\n\nvec3 mb_p(vec3 p) {\n    vec3 pt = potential(p);\n    if(pt.x == 0.0) return vec3(0.0);\n    vec3 e=vec3(EPS,0.0,0.0); \n    gradient = (vec3(potential(p+e.xyy).x, \n                potential(p+e.yxy).x, \n                potential(p+e.yyx).x) \n            - pt.x) / e.x; \n    return vec3((0.5 / exp(pt.x)) * _sinh(pt.x) / length(gradient), pt.y, pt.z); /* syntopia method */\n    /*return vec3((0.5 * pt.x) / length(gradient), pt.y, pt.z);*/  /* quilez method */\n}\n/* the potential gradient approximation -------------------------------------------*/ \n\n\n\n\n/* method 2: the scalar distance estimator------------------------------------------------*/\n/* the normal is calculated by central difference */\nvec3 mb_s(vec3 p) {\n    /*p.xyz=p.xzy;*/\n    vec3 z = p;\n    float power = 8.0;\n    float r, theta, phi;\n    float dr = 1.0;\n\tvec3 c = p;\n\tif(is_julia)\n\t\tc = julia;\n    float t0 = 1.0;\n\tjulia.y = stime;\n\tjulia.x = ctime;\n\tjulia.z = 0.5*cos(stime);\n\n    for(int i = 0; i < 7; ++i) {\n        r = length(z);\n        if(r > 2.0) continue;\n\n        dr = pow(r, power - 1.0) * dr * power + 1.0; \n\n        theta = acos(z.y / r) * power;\n        phi = atan(z.z, z.x) * power;\n        r = pow(r, power);\n        z = r * vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi)) + c;\n        ry(z, stime);\n\n        // the Positive-z variation\n        /*theta = atan(z.y, z.x) * power;*/\n        /*phi = asin(z.z/ r) * power;*/\n        /*r = pow(r, power);*/\n        /*z = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;*/\n        t0 = min(t0, length(z));\n    }\n    return vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n/* the scalar distance estimator------------------------------------------------*/\n\n\n\n\n/* method 3: the escape length approximation -------------------------------------------*/ \n/* reffered to as Makin/Buddhi 4-point Delta-DE formula */\nint last = 0; // global to ensure evaluating the escape length at the same iteration each time\nvec3 escape_length(vec3 p) {\n    vec3 z = p;\n    float power = 8.0, r;\n    float t0 = 1.0;\n\tvec3 c = p;\n\tif(is_julia)\n\t\tc = julia;\n\n    for(int i = 1; i < 8; ++i) {\n        z = bulb_power(z, power) + c;\n        r = length(z);\n        t0 = min(t0, r);\n        \n        if ((r > 2.0 && last == 0) || (i == last))\n        {\n            last = i;\n            return vec3(r, t0, 0.0);\n        }\n    }\n    return vec3(length(z), 0.0, 0.0);\n}\n\nvec3 mb_e(vec3 p) {\n    last = 0;\n    vec3 el = escape_length(p);\n    if(el.x * el.x < 2.0) return vec3(0.0);\n    vec3 e=vec3(EPS,0.0,0.0); \n    gradient = (vec3(escape_length(p+e.xyy).x, escape_length(p+e.yxy).x, escape_length(p+e.yyx).x) - el.x) / e.x; \n    return vec3(0.5 * el.x * log(el.x) / length(gradient), el.y, el.z); \n}\n/* the escape length approximation -------------------------------------------*/ \n\n\nvec3 f(vec3 p){ \n    vec2 uv=p.xz*1.0;\n\tfloat noi = noise(uv);\n\tnoi = 0.5 + 0.5 * noi;\n  \n   float a=plane(vec3(p.x, p.y + noi * 0.2, p.z), -0.71);\n\t\n\t\n\t//ry(p, stime * 0.5);\n\tp.yz = p.zy;\n    \n\t//p.x = mod(p.x, 3.0) - 1.5;\n\tp.y = mod(p.y, 2.0) - 1.0;\n\t//p.xz = mod(p.xz, 8.0) - 4.0;\n\t\n\t//p.yz = -p.zy;\n    vec3 b = mb_s(p);\n\tvec3 res = vec3(a, 0.8, 1.0);\n\tif(a > b.x)\n\t\tres = b;\n\treturn res;\n\n}\n\n\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n    float akuma=1.0,h=0.0; \n    float t = 0.01;\n    for(int i=0; i < 32; ++i){ \n        h=f(ro+rd*t).x; \n        if(h<0.001)return 0.02; \n        akuma=min(akuma, k*h/t); \n        t+=clamp(h,0.01,2.0); \n    } \n    return akuma; \n} \nvec3 nor(vec3 p){ \n    vec3 e=vec3(EPS,0.0,0.0); \n    return normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n                f(p+e.yxy).x-f(p-e.yxy).x, \n                f(p+e.yyx).x-f(p-e.yyx).x)); \n} \n\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 res = vec3(-1.0);\n    vec3 h = vec3(1.0);\n    for( int i=0; i<196; i++ )\n    {\n\t\t// To avoid compiler bug\n        if( h.x<0.0006 || t>20.0 ) {\n           \n        }\n\t\telse{\n        \th = f(ro + rd*t);\n        \tres = vec3(t,h.yz);\n        \tt += h.x;  // marching\n\t\t}\n    }\n    if( t>20.0 ) res=vec3(-1.0);\n    return res;\n}\n\nvec3 lighting(in vec3 p, in vec3 n, in vec3 rd, in float ao) {\n\tvec3 l1_pos = normalize(vec3(0.0, 0.8, 1.8)) * 11.0;\n\tvec3 l1_dir = normalize(l1_pos - p);\n    vec3 l1_col = vec3(1.37, 0.99, 0.79);\n\t\n    vec3 l2_dir = normalize(vec3(0.0, -0.8, -1.8));\n    vec3 l2_col = vec3(1.19, 0.99, 1.0); \n    \n    float shadow = softshadow(p, l1_dir, 10.0 );\n\n    float dif1 = max(0.0, dot(n, l1_col));\n    float dif2 = max(0.0, dot(n, l2_col));\n    float bac1 = max(0.3 + 0.7 * dot(vec3(-l1_dir.x, -1.0, -l1_dir.z), n), 0.0);\n    float bac2 = max(0.2 + 0.8 * dot(vec3(-l2_dir.x, -1.0, -l2_dir.z), n), 0.0);\n    float spe = max(0.0, pow(clamp(dot(l1_dir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n    vec3 col = 2.3 * l1_col * dif1 * shadow;\n    col += 1.4 * l2_col * dif2 * ao;\n    col += 0.7 * bac1 * l1_col * ao;\n    col += 0.7 * bac2 * l2_col * ao; \n    col += 6.0 * spe * vec3(1.0, 0.84313, 0.0); \n    \n\tao = pow(clamp(ao, 0.0, 1.0), 2.55);\n\tvec3 tc0 = 0.5 + 0.5 * sin(3.0 + 3.7 * ao + vec3(1.4, 0.0, 0.0));\n\tvec3 tc1 = 0.5 + 0.5 * sin(3.0 + 3.9 * ao + vec3(1.0, 0.84313, 0.0));\n\tcol *= 0.2 * tc0 * tc1;\n\t\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    vec2 q=fragCoord.xy/iResolution.xy; \n    vec2 uv = -1.0 + 2.0*q; \n    uv.x*=iResolution.x/iResolution.y; \n    // camera\n    stime=sin(iTime*0.2); \n    ctime=cos(iTime*0.2); \n\n    vec3 ta=vec3(0.0,0.3-0.3*ctime,-4.0); \n\t//vec3 ta = vec3(0.0);\n    vec3 ro = vec3(5.0 * stime, 2.0, 1.0 * ctime);\n\n    vec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n    vec3 rd = normalize(uv.x*cs + uv.y*cu + 7.8*cf);  // transform from view to world\n\n    vec3 bg = vec3(0.0, 0.0, 0.0);\n\n    float halo=clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0); \n    vec3 col=bg+vec3(0.3, 0.0, 0.0) * pow(halo,9.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n    float normal_back_step = 1.0;\n\n\n    vec3 res = intersect(ro, rd);\n\tfloat ao = res.y;\n\t\n    if(res.x > 0.5){\n        p = ro + res.x * rd;\n        vec3 n=nor(p);   // for mb_s\n\t\t//vec3 n = normalize(gradient);  // for mb_p and mb_e\n       \tcol = lighting(p, n, rd, ao);\n        col=mix(col,bg, 1.0-exp(-0.01*res.x*res.x)); \n    }\n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n    fragColor=vec4(col.x,col.y,col.z,1.0); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsSzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 488, 519, 519, 641], [645, 645, 676, 676, 797], [801, 801, 821, 821, 917], [919, 919, 938, 938, 1028], [1030, 1030, 1050, 1050, 1279], [1282, 1282, 1312, 1312, 1353], [1355, 1355, 1393, 1393, 1590], [1593, 1707, 1729, 1729, 1768], [1770, 1770, 1794, 1794, 2276], [2278, 2278, 2297, 2297, 2736], [2828, 2974, 2993, 3014, 3894], [3982, 4228, 4256, 4256, 4663], [4665, 4665, 4684, 4684, 4995], [4996, 5080, 5095, 5095, 5475], [5478, 5478, 5523, 5523, 5755], [5757, 5757, 5774, 5774, 5952], [5956, 5956, 5998, 5998, 6348], [6350, 6350, 6412, 6412, 7462], [7464, 7464, 7522, 7522, 8873]], "test": "valid"}
{"id": "MdsXRj", "name": "Ray marched something", "author": "Tsarpf", "description": "simple test in ray marching ", "tags": ["distancefield", "raymarch"], "likes": 3, "viewed": 110, "published": "Public", "date": "1404512681", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0, 0, -5);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    float epsilon = 0.001;\n    float maxDistance = 100.0;\n\n    //vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t\n\t\n    float focalLength = 2.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    vec3 rayDirection = normalize(pImagePlane - eye);\n\n    vec4 color = vec4(0,0.5*(sin(iTime*2.0) + 1.5),0,1); // Sky color\n\n    float t = 0.0;\n    const float maxSteps = 16.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n        //float d = length(p) - 0.5; // Distance to sphere of radius 0.5\n        float d = sdSphere(p, 1.0 + sin(iTime));\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\tcolor = vec4(i*0.1+0.1,0.2,0.5,0);\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 59], [61, 61, 92, 92, 188], [190, 190, 247, 247, 1440]], "test": "valid"}
{"id": "MdXSzX", "name": "Marble Sculpture", "author": "TekF", "description": "My wax shader with a slightly more complex scene & material.\nPress: D - day/night, S - toggle sub-surface, A,R - toggle occlusion, L - lens effects\nMouse drag: move camera", "tags": ["subsurfacescattering"], "likes": 75, "viewed": 6095, "published": "Public API", "date": "1404914796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// control range of SSS\n// .3 - exaggerated / realistic for a small object\n// .05 - realistic for human-scale (I think)\n#define TRANSMISSION_RANGE .15\n\t\n//#define FAST\n\n// keys\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n// TOGGLES:\n\nconst int kAmbientOcclusion = kA;\nconst int kReflectionOcclusion = kR;\nconst int kSubsurface = kS;\nconst int kLensFX = kL;\nconst int kDarkScene = kD;\n\n\n// consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\n// globals\nvec3 envBrightness = vec3(1);\nconst vec3 darkEnvBrightness = vec3(.02,.03,.05);\n\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\nbool Toggle( int val )\n{\n\treturn !ReadKey( val, true );\n}\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\n#ifdef FAST\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n#else\n\t// high precision interpolation, if needed\n\tvec4 rg = mix( mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(1,0)+0.5)/256.0, 0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(0,1)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+1.5)/256.0, 0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n#endif\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\nfloat Sphere( vec3 p, vec3 c, float r )\n{\n\treturn length(p-c)-r;\n}\n\nfloat Tet( vec3 p, vec3 c, float r )\n{\n\tp -= c;\n\tvec2 s = -vec2(1,-1)/sqrt(3.0);\n\treturn max(max(max(\n\t\t\tdot(p,s.xxx),dot(p,s.yyx)),\n\t\t\tdot(p,s.yxy)),dot(p,s.xyy)) - r*mix(1.0,1.0/sqrt(3.0),1.0);\n}\n\nfloat Oct( vec3 p, vec3 c, float r )\n{\n\tp -= c;\n\tvec2 s = vec2(1,-1)/sqrt(3.0);\n\treturn max(max(max(\n\t\t\tabs(dot(p,s.xxx)),abs(dot(p,s.yyx))),\n\t\t\tabs(dot(p,s.yxy))),abs(dot(p,s.xyy))) - r*mix(1.0,1.0/sqrt(3.0),.5);\n}\n\nfloat Cube( vec3 p, vec3 c, float r )\n{\n\tp -= c;\n\treturn max(max(abs(p.x),abs(p.y)),abs(p.z))-r*mix(1.0,1.0/sqrt(3.0),.5);\n}\n\nfloat CubeFrame( vec3 p, vec3 c, float r )\n{\n\tr = r*mix(1.0,1.0/sqrt(3.0),.5);\n\tp -= c;\n\tp = abs(p);\n\tfloat rr = r*.1;\n\tp -= vec3(r-rr);\n\t// whichever axis is most negative should be clamped to 0\n\tif ( p.x < p.z ) p = p.zyx;\n\tif ( p.y < p.z ) p = p.xzy;\n\tp.z = max(0.0,p.z);\n\treturn length(p)-rr;\n}\n\nfloat DistanceField( vec3 p, float t )\n{\n\treturn\n\t\t\tmin(min(min(min(min(min(min(min(\n\t\t\t\tSphere(p,vec3(0,.48,0),.1),\n\t\t\t\tOct(p,vec3(0,.2,0),.2)),\n\t\t\t\tCubeFrame(p,vec3(0,-.05,0),.3)),\n\t\t\t\tSphere(p,vec3(0,-.6,0),.4)),\n\t\t\t\tCube(p,vec3(0,-1.7,0),1.0)),\n\t\t\t\tCube(p,vec3(0,-2.9,0),2.0)),\n\t\t\t\tCube(p,vec3(0,-8.0,0),8.0)),\n\t\t\t\tCube(p,vec3(0,3,-11),8.0)),\n\t\t\t\tCubeFrame(p,vec3(0),4.0));\n\n\t// spiral candle\n/*\tp.xz = p.xz*cos(p.y*4.0)+vec2(1,-1)*p.zx*sin(p.y*4.0);\n\treturn max(\n\t\t\t\tmax( p.y-.5, -p.y-1.),\n\t\t\t\t(min(\n\t\t\t\t\tmax(abs(p.x),abs(p.z)),\n\t\t\t\t\tmax(abs(p.x+p.z),abs(p.z-p.x))/sqrt(2.0)\n\t\t\t\t)-.15)*.8);*/\n}\n\nfloat DistanceField( vec3 p )\n{\n\treturn DistanceField( p, 0.0 );\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn envBrightness*mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir1, vec3 lightDir2, vec3 lightCol1, vec3 lightCol2, float shadowMask1, float shadowMask2, float distance )\n{\n\t// checker pattern\n\tvec3 albedoMain;\t\n\tvec3 albedoVein;\n\tvec3 marbleAxis;\n\tvec3 check = fract((pos-vec3(0,-.18,0))*.5/1.5-.25)-.5;\n\tif ( check.x*check.y*check.z > .0 )\n\t{\n\t\talbedoMain = vec3(.3,.04,.02);\n\t\talbedoVein = vec3(1,.8,.5);\n\t\tmarbleAxis = normalize(vec3(1,-3,2));\n\t}\n\telse\n\t{\n\t\talbedoMain = vec3(.8,.85,.9);\n\t\talbedoVein = vec3(.1,0,0);\n\t\tmarbleAxis = normalize(vec3(1,2,3));\n\t}\n\n\t// marble pattern\n/*\tfloat marble = dot(pos,marbleAxis); // orientation (perp to seams)\n\n\t// multi-fractal noise\n\tvec3 mfp = pos*4.0; // noise frequency\n\tvec2 mfNoise = vec2(0);\n\tmfNoise += Noise(mfp);\n\tmfNoise += Noise(mfp*2.0)/2.0;\n\tmfNoise += Noise(mfp*4.0)/4.0;\n\tmarble += mfNoise.x*.5; // noise amplitude\n\t\n\tmarble *= 3.0; // adjust frequancy\n\n//\tvec3 albedo = vec3(1,.95,.9);\n//\tvec3 albedo = vec3(.7,.5,1);\n//\tvec3 albedo = vec3(.5,.3,.13);\n\n\tmarble = abs(1.0-2.0*fract(marble)); // triangle wave\n\tmarble = pow(smoothstep( 0.0, 1.0, marble ),20.0); // curve to thin the veins\n*/\n\n\t// better marble\n\tvec3 mfp = (pos + dot(pos,marbleAxis)*marbleAxis*2.0)*2.0;\n\tfloat marble = 0.0;\n\tmarble += abs(Noise(mfp).x-.5);\n\tmarble += abs(Noise(mfp*2.0).x-.5)/2.0;\n\tmarble += abs(Noise(mfp*4.0).x-.5)/4.0;\n\tmarble += abs(Noise(mfp*8.0).x-.5)/8.0;\n\tmarble /= 1.0-1.0/8.0;\n\tmarble = pow( 1.0-marble,10.0); // curve to thin the veins\n\t\n\tvec3 albedo = mix( albedoMain, albedoVein, marble );\n\n\n\tvec3 ambient = envBrightness*mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); // ambient\n//\t\tambient = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); // ambient\n\t// ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = distance/20.0;\n\t\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )/aoRange ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n\tif ( Toggle(kAmbientOcclusion) )\n\t\tambient *= occlusion*.8+.2; // reduce occlusion to imply indirect sub surface scattering\n\n\tfloat ndotl1 = max(.0,dot(normal,lightDir1));\n\tfloat ndotl2 = max(.0,dot(normal,lightDir2));\n\tfloat lightCut1 = smoothstep(.0,.1,ndotl1);//pow(ndotl,2.0);\n\tfloat lightCut2 = smoothstep(.0,.1,ndotl2);//pow(ndotl,2.0);\n\n\tvec3 light = vec3(0);\n//\tif ( Toggle(kDirectLight,3) )\n\tlight += lightCol1*shadowMask1*ndotl1;\n\tlight += lightCol2*shadowMask2*ndotl2;\n\n\n\t// And sub surface scattering too! Because, why not?\n\tfloat transmissionRange = TRANSMISSION_RANGE;//iMouse.x/iResolution.x;//distance/10.0; // this really should be constant... right?\n\tfloat transmission1 = DistanceField( pos + lightDir1*transmissionRange )/transmissionRange;\n\tfloat transmission2 = DistanceField( pos + lightDir2*transmissionRange )/transmissionRange;\n\tvec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);\n\tvec3 subsurface = vec3(1,.8,.5) * sslight;\n\n\n\tfloat specularity = 1.0-marble;\n\t//specularity = mix( specularity, Noise(pos/.02).x, .1 ); // add some noise\n\t\n\tvec3 h1 = normalize(lightDir1-ray);\n\tvec3 h2 = normalize(lightDir2-ray);\n\tfloat specPower = exp2(mix(5.0,12.0,specularity));\n\tvec3 specular1 = lightCol1*shadowMask1*pow(max(.0,dot(normal,h1))*lightCut1, specPower)*specPower/32.0;\n\tvec3 specular2 = lightCol2*shadowMask2*pow(max(.0,dot(normal,h2))*lightCut2, specPower)*specPower/32.0;\n\t\n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t\n\t// specular occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )/(aoRange*max(.01,dot(rray,normal))) ); // can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); // tweak the curve\n\t\n\t// prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\tif ( Toggle(kReflectionOcclusion) )\n\t\treflection *= specOcclusion; // could fire an additional ray for more accurate results\n\t\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .01, specularity ), mix( .4, 1.0, specularity ), fresnel );\n\t\n\tvec3 result = vec3(0);\n\n\t// comment these out to toggle various parts of the effect\n\tlight += ambient;\n\n\tif ( Toggle(kSubsurface) )\n\t\tlight = mix( light, subsurface, .5 );//iMouse.y/iResolution.y );\n\t\n\tresult = light*albedo;\n\n\tresult = mix( result, reflection, fresnel );\n\t\n\tresult += specular1 + specular2;\n\n\treturn result;\n}\n\n\n\n\n// Isosurface Renderer\n#ifdef FAST\nconst int traceLimit=40;\nconst float traceSize=.005;\n#else\nconst int traceLimit=60;\nconst float traceSize=.002;\n#endif\t\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray, t );\n\t\tif ( h < traceSize || t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )//|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat TraceMin( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat Min = traceEnd;\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray, t );\n\t\tif ( h < .001 || t > traceEnd )\n\t\t\tbreak;\n\t\tMin = min(h,Min);\n\t\tt = t+max(h,.1);\n\t}\n\t\n\tif ( h < .001 )\n\t\treturn 0.0;\n\t\n\treturn Min;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float t )\n{\n\t// in theory we should be able to get a good gradient using just 4 points\n\n\tfloat pitch = .2 * t / iResolution.x;\n#ifdef FAST\n\t// don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0,t);\n\tfloat f1 = DistanceField(p1,t);\n\tfloat f2 = DistanceField(p2,t);\n\tfloat f3 = DistanceField(p3,t);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\n\t// prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n// Camera\n\nvec3 Ray( float zoom, vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\t// would love to get some disperson on this, but that means more rays\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 lightCol, vec3 light, float lightVisible, float sky, vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = (dot(light,ray)*.5+.5);\n\t\n\treturn (\n\t\t\t((pow(l,30.0)+.05)*dirt*.1\n\t\t\t+ 1.0*pow(l,200.0))*lightVisible + sky*1.0*pow(l,5000.0)\n\t\t   )*lightCol\n\t\t   + 5.0*pow(smoothstep(.9999,1.0,l),20.0) * lightVisible * normalize(lightCol);\n}\n\n\nfloat SmoothMax( float a, float b, float smoothing )\n{\n\treturn a-sqrt(smoothing*smoothing+pow(max(.0,a-b),2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif ( Toggle(kDarkScene) )\n\t\tenvBrightness = darkEnvBrightness;\n\t\n\tvec3 ray = Ray(.7,fragCoord);\n\t\n\tif ( Toggle(kLensFX) )\n\t\tBarrelDistortion( ray, .5 );\n\t\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n\tvec2 mouse = vec2(.2,.5);\n\tif ( iMouse.z > .0 )\n\t\tmouse = vec2(.5)-iMouse.yx/iResolution.yx;\n\t\t\n\tfloat T = iTime*.1;\n\tvec3 pos = 3.0*Rotate( ray, vec2(.2,0.0-T)+vec2(-1.0,-6.3)*mouse );\n\t//pos += vec3(0,.3,0) + T*vec3(0,0,-1);\n\t\n\tvec3 col;\n\n\tvec3 lightDir1 = normalize(vec3(3,1,-2));\n\tfloat lt = iTime;\n\tvec3 lightPos = vec3(cos(lt*.9),sin(lt/phi),sin(lt))*vec3(.6,1.0,.6)+vec3(0,.2,0);\n\t\n\tvec3 lightCol1 = vec3(1.1,1,.9)*1.4*envBrightness;\n\tvec3 lightCol2 = vec3(.8,.4,.2)*2.0;\n\t\n\tfloat lightRange2 = .4; // distance of intensity = 1.0\n\t\n\tfloat traceStart = .5;\n\tfloat traceEnd = 40.0;\n\t\n\tfloat t = Trace( pos, ray, traceStart, traceEnd );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t// shadow test\n\t\tvec3 lightDir2 = lightPos-p;\n\t\tfloat lightIntensity2 = length(lightDir2);\n\t\tlightDir2 /= lightIntensity2;\n\t\tlightIntensity2 = lightRange2/(.1+lightIntensity2*lightIntensity2);\n\t\t\n\t\tfloat s1 = 0.0;\n\t\ts1 = Trace( p, lightDir1, .05, 20.0 );\n\t\tfloat s2 = 0.0;\n\t\ts2 = Trace( p, lightDir2, .05, length(lightPos-p) );\n\t\t\n\t\tvec3 n = Normal(p, ray, t);\n\t\tcol = Shade( p, ray, n, lightDir1, lightDir2,\n\t\t\t\t\tlightCol1, lightCol2*lightIntensity2,\n\t\t\t\t\t(s1>.0)?0.0:1.0, (s2>.0)?0.0:1.0, t );\n\t\t\n\t\t// fog\n\t\tfloat f = 200.0;\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\tif ( Toggle(kLensFX) )\n\t{\n\t\tvec3 lightDir2 = lightPos-pos;\n\t\tfloat lightIntensity2 = length(lightDir2);\n\t\tlightDir2 /= lightIntensity2;\n\t\tlightIntensity2 = lightRange2/(.1+lightIntensity2*lightIntensity2);\n\n\t\t// lens flare\n\t\tfloat s1 = TraceMin( pos, lightDir1, .5, 40.0 );\n\t\tfloat s2 = TraceMin( pos, lightDir2, .5, length(lightPos-pos) );\n\t\tcol += LensFlare( ray, lightCol1, lightDir1, smoothstep(.01,.1,s1), step(t,.0),fragCoord );\n\t\tcol += LensFlare( ray, lightCol2*lightIntensity2, lightDir2, smoothstep(.01,.1,s2), step(t,.0),fragCoord );\n\t\n\t\t// vignetting:\n\t\tcol *= smoothstep( .7, .0, dot(localRay.xy,localRay.xy) );\n\t\n\t\t// compress bright colours, ( because bloom vanishes in vignette )\n\t\tvec3 c = (col-1.0);\n\t\tc = sqrt(c*c+.05); // soft abs\n\t\tcol = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\t\n\t\t// grain\n\t\tvec2 grainuv = fragCoord.xy + floor(iTime*60.0)*vec2(37,41);\n\t\tvec2 filmNoise = texture( iChannel0, .5*grainuv/iChannelResolution[0].xy ).rb;\n\t\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\t}\n\t\n\t// compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));//dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); // prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2/l;\n\t\n\tfragColor = vec4(pow(col,vec3(1.0/2.2)),1);\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXSzX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[915, 1001, 1039, 1039, 1168], [1171, 1171, 1195, 1195, 1228], [1231, 1231, 1256, 1256, 1877], [1880, 1880, 1921, 1921, 1946], [1948, 1948, 1986, 1986, 2145], [2147, 2147, 2185, 2185, 2362], [2364, 2364, 2403, 2403, 2488], [2490, 2490, 2534, 2534, 2788], [2790, 2790, 2830, 2830, 3389], [3391, 3391, 3422, 3422, 3457], [3460, 3460, 3482, 3482, 3577], [3580, 3580, 3745, 3765, 8055], [8060, 8216, 8285, 8285, 8525], [8527, 8527, 8599, 8599, 8868], [8870, 8870, 8914, 8989, 9645], [9648, 9659, 9699, 9699, 9769], [9771, 9771, 9808, 9808, 10023], [10026, 10045, 10100, 10171, 10278], [10280, 10280, 10382, 10382, 10717], [10720, 10720, 10774, 10774, 10834], [10836, 10836, 10893, 10893, 13744]], "test": "error"}
{"id": "MdXXDB", "name": "Superformula test", "author": "mickdermack", "description": "A little example feeding varying values into the Superformula and plotting the result.", "tags": ["2d"], "likes": 4, "viewed": 354, "published": "Public", "date": "1406251135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Variables to be fed into the formula\n\tfloat a = 1.0 + 0.5 * cos(iTime/16.0);\n\tfloat b = 1.0 + 0.1 * cos(iTime/8.0);\n\tfloat m = 15.0 + 7.5 * cos(iTime/4.0);\n\tfloat n1 = 5.0 + 2.0 * cos(iTime/2.0);\n\tfloat n2 = 6.0 + 2.0 * cos(iTime);\n\tfloat n3 = 24.0 + 10.0 * sin(iTime);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// As the center is assumed to be 0,0 we'll shift the uv vector accordingly\n\tvec2 sf = uv - 0.5;\n\n\t// r of the current point\n\tfloat pr = sqrt(sf.x*sf.x + sf.y*sf.y);\n\t// Angle (Phi) of the current point\n\tfloat f = atan(sf.y/sf.x);\n\n\t// The formula itself. Division by 10.0 added to scale the result down a bit.\n\tfloat r = pow((pow(abs(cos(m*f/4.0)/a),n2) + pow(abs(sin(m*f/4.0)/b), n3)), -(1.0/n1)) / 10.0;\n\n\t// Output with coloring by relative radius\n\tfragColor = (pr <= r) ? vec4(1.0-pr/r, 1.0-(pr/r/2.0), 1.0-pr/r, 1.0) : vec4(0.1, 0.1, 0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 98, 929]], "test": "valid"}
{"id": "MsfXDS", "name": "Edge AA", "author": "Trisomie21", "description": "WIP : Proof of concept of edge AA, via pixel coverage computation in raymarching loop\nA - Toggle Anti-Aliasing\nT - Toggle Color and Opacity channel", "tags": ["raymarching", "antialiasing"], "likes": 33, "viewed": 1113, "published": "Public", "date": "1406672550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// Tweaked by T21 to enable single pass distance based Anti-aliasing.\nconst float KEY_A  = 65.5/256.0;\nconst float KEY_T  = 84.5/256.0;\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\nvec2 opU( vec2 d1, vec2 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\n\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 646.9 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.3, 1.0), vec3(0.15), 0.1 ), 541.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 425.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.20,-0.1), vec3(-1.0,0.20,0.2), 0.1  ), 331.9 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),250.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),143.0 ) );\n\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<30; i++ )\n    {\n\t\tif( t>maxt ) break;\n\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += 0.02;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 GetColor(in vec3 ro, in vec3 rd, in float t, float m)\n{\n       vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n\n\t\t//col = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\tvec3 col = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        float ao = calcAO( pos, nor );\n\n\t\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tfloat sh = 1.0;\n\t\tif( dif>0.02 ) { sh = softshadow( pos, lig, 0.02, 10.0, 7.0 ); dif *= sh; }\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.20*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = sh*pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\treturn col*brdf + vec3(1.0)*col*spe + 0.2*fre*(0.5+0.5*col);\t\n}\n\nvec4 Blend(in vec4 fg, in vec4 bg) {\n\tfloat a = 1.- fg.a;\n\treturn fg + bg * a;\n}\n\nvec3 castRay(in vec3 ro, in vec3 rd, in float maxd, in float aa)\n{\n\tvec4 col = vec4(0.0);\t// Forground (pre-multiplied)\n\tfloat c = 1.;\t\t\t// Keep track if we are moving closer or away from a surface\n\t\n\tfloat precis = 0.001;\n    float h = 0.0, mh = 1e20;\n    float t = 0.0, mt = 0.0;\n    float m = -1.0, mm = -1.0;\n\t\n    for(int i=0; i<100; i++ )\n    {\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n\t\t\n\t\tif(abs(h)<precis || t>maxd ) break;\n\t\t\n\t\tif(h < mh) { // closer\n\t\t\tc = 1.0;\n\t\t\tmh = h;\n\t\t\tmt = t;\n\t\t\tmm = m;\n\t\t} else if(c > 0.0) { // away\n\t\t\tc = 0.0;\n\t\t\tfloat s = (mt+1.0)/iResolution.y;\n\t\t\tif(mh < s) {\n\t\t\t\tfloat a = 1. - (mh / s);\n\t\t\t\tvec3 rgb = GetColor(ro, rd, mt, mm);\n\t\t\t\tcol = Blend(col, vec4(rgb*a, a));\n\t\t\t}\n\t\t}\n    }\n\t\n\tif(texture(iChannel3, vec2(KEY_A,0.75)).x > 0.) {\n \t\tcol = vec4(0.0);\n\t}\n\t\n\tif(texture(iChannel3, vec2(KEY_T,0.75)).x > 0.) {\n\t\tif(m > 1.) col.a = 1.;\n\t\treturn vec3(pow(col.a, 2.2));\n\t}\n\t\n\tcol = Blend(col, vec4(GetColor(ro, rd, t, m), 1.));\n\t\n\tcol.rgb /= col.a;\t\n\tcol.rgb *= exp( -0.01*t*t );\n\t\n    return col.rgb;\n}\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = castRay(ro,rd,20.0, 1. - iMouse.z);\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t\n    vec3 col = render( ro, rd );\n\n\tcol = sqrt( col );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfXDS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[378, 515, 540, 540, 555], [557, 557, 592, 592, 618], [620, 620, 665, 665, 705], [707, 707, 740, 740, 805], [807, 807, 859, 859, 985], [987, 987, 1012, 1012, 1049], [1051, 1051, 1076, 1076, 1134], [1136, 1136, 1161, 1161, 1226], [1228, 1228, 1263, 1263, 1330], [1332, 1332, 1367, 1367, 1434], [1436, 1436, 1473, 1473, 1524], [1526, 1599, 1629, 1629, 1661], [1664, 1738, 1763, 1763, 2388], [2390, 2390, 2476, 2476, 2701], [2703, 2703, 2735, 2735, 2956], [2958, 2958, 3000, 3000, 3305], [3307, 3307, 3367, 3367, 4357], [4359, 4359, 4395, 4395, 4439], [4441, 4441, 4507, 4507, 5527], [5531, 5531, 5570, 5570, 5660], [5662, 5662, 5719, 5719, 6346]], "test": "error"}
{"id": "MslSDS", "name": "See Yaw 2 (Yet Yet Another Warpi", "author": "xbe", "description": "Yet yet another warping. Same formula as in my See Yaw shader,with a modified more vivid coloring.", "tags": ["2d", "noise", "warping"], "likes": 19, "viewed": 588, "published": "Public", "date": "1406551899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////\n// XBE\n// See Yaw 2 (Yet Yet Another Warping)\n// More colorfull version\n\n// Simplex Noise by IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat fbm6( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); p = m*p*2.04;\n    f += 0.031250*noise( p ); p = m*p*2.01;\n    f += 0.015625*noise( p );\n    return f;\n}\n\nfloat turb4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*abs(noise(p)); p = m*p*2.02;\n    f += 0.2500*abs(noise(p)); p = m*p*2.03;\n    f += 0.1250*abs(noise(p)); p = m*p*2.01;\n    f += 0.0625*abs(noise(p));\n    return f;\n}\n\nfloat turb6( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*abs(noise(p)); p = m*p*2.02;\n    f += 0.2500*abs(noise(p)); p = m*p*2.03;\n    f += 0.1250*abs(noise(p)); p = m*p*2.01;\n    f += 0.0625*abs(noise(p)); p = m*p*2.04;\n    f += 0.031250*abs(noise(p)); p = m*p*2.01;\n    f += 0.015625*abs(noise(p));\n    return f;\n}\n\nfloat marble(in vec2 p)\n{\n\treturn cos(p.x+fbm4(p));\n}\n\nfloat wood(in vec2 p)\n{\n\tfloat n = noise(p);\n\treturn n-floor(n);\n}\n\nfloat dowarp ( in vec2 q, out vec2 a, out vec2 b )\n{\n\tfloat ang=0.;\n\tang = 1.2345 * sin (0.015*iTime);\n\tmat2 m1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 0.2345 * sin (0.021*iTime);\n\tmat2 m2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\ta = vec2( marble(m1*q), marble(m2*q+vec2(1.12,0.654)) );\n\n\tang = 0.543 * cos (0.011*iTime);\n\tm1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 1.128 * cos (0.018*iTime);\n\tm2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\tb = vec2( marble( m2*(q + a)), marble( m1*(q + a) ) );\n\t\n\treturn marble( q + b +vec2(0.32,1.654));\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = 2.*uv-1.;\n\tq.y *= iResolution.y/iResolution.x;\n\t\n\tfloat Time = 0.1*iTime;\n\tq += vec2( 4.0*sin(Time), 0.);\n\tq *= 1.725;\n\t\n\tvec2 a = vec2(0.);\n\tvec2 b = vec2(0.);\n\tfloat f = dowarp(q, a, b);\n\tf = 0.5+0.5*f;\n\t\n\tvec3 col = vec3(f);\n\tfloat c = 0.;\n\tc = f;\n\tcol = vec3(c, c*c, c*c*c);\n\tc = abs(a.x);\n\tcol -= vec3(c*c, c, c*c*c);\n\tc = abs(b.x);\n\tcol += vec3(c*c*c, c*c, c);\n\tcol *= 0.7;\n\tcol.x = pow(col.x, 2.18);\n//\tcol.y = pow(col.y, 1.58);\n\tcol.z = pow(col.z, 1.88);\n\tcol = smoothstep(0., 1., col);\n\tcol = 0.5 - (1.4*col-0.7)*(1.4*col-0.7);\n\tcol = 1.25*sqrt(col);\n\tcol = clamp(col, 0., 1.);\n\t\n\t// Vignetting\n\tvec2 r = -1.0 + 2.0*(uv);\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.15 + 0.85*(1.0-exp(-(1.0-vb)*30.0)));\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslSDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 147, 168, 168, 289], [291, 291, 317, 317, 852], [905, 905, 930, 930, 1119], [1121, 1121, 1146, 1146, 1423], [1425, 1425, 1451, 1451, 1652], [1654, 1654, 1680, 1680, 1975], [1977, 1977, 2002, 2002, 2030], [2032, 2032, 2055, 2055, 2098], [2100, 2100, 2152, 2152, 2690], [2692, 2744, 2801, 2801, 3604]], "test": "valid"}
{"id": "MssSDB", "name": "SimpleVoxels", "author": "sed", "description": "No occlusion...", "tags": ["voxels"], "likes": 7, "viewed": 256, "published": "Public", "date": "1406592268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float line2(vec2 a, vec2 b, vec2 pos, float t)\n{\n    vec2 n = normalize(a - b);\n    vec2 an = a-pos - n * dot(a-pos, n);\n    \n    if (length(a-pos) > length(a-b) || length(b-pos) > length(a-b))\n        return -1.0;\n    \n    return t/iResolution.y - length(an);\n}\n\nfloat line3(vec3 a, vec3 b, vec3 ro, vec3 rd, float t)\n{\n    vec3 ad = normalize(a - b);\n    \n    float at = length(a - b) / length(ad);\n    \n    vec3 pn = cross(ad, rd);\n    float pnl = length(pn);\n    \n    return 0.0;\n}\n\nfloat point(vec3 p,vec3 ro, vec3 rd, float r)\n{\n    vec3 a = ro-p - rd * dot(ro-p, rd);\n    \n    //if (length(a-pos) > length(a-b) || length(b-pos) > length(a-b))\n    //    return -1.0;\n    \n    return r/iResolution.y - length(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (-1.0 + 2.0 * uv) * vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 m = (-1.0 + 2.0 * iMouse.xy/iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n\n    vec3 ro = 3.8 * vec3(cos(0.2 * iTime), 1.0, sin(0.2 * iTime));\n    \n    vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n\n\n    vec3 col = vec3(1.0);\n    \n    vec2 a = vec2(0.0, 0.0);\n    vec3 a3 = vec3(-0.5, -0.1, 0.0);\n    vec3 b3 = vec3(0.5, 0.1, -1.0);\n    \n    \n    for (float i=0.0; i<20.0; i+=1.0)\n    {\n        if (point(vec3(cos(iTime*4.0+i)/4.0, sin(iTime*4.0+i)/4.0, i/4.0- 2.5), ro, rd, 50.0) > 0.0)\n        {\n            float cr = sin(iTime+i)/4.0;\n            float cg = sin(iTime+i+1.0)/4.0;\n            float cb = sin(iTime+i+2.0)/4.0;\n            col = vec3(0.5+cr, 0.5+cg, 0.5+cb);\n        }\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 262], [264, 264, 320, 320, 485], [487, 487, 534, 534, 719], [721, 721, 778, 778, 1797]], "test": "valid"}
{"id": "MssXRX", "name": "FractalArt", "author": "Passion", "description": "Can programming be art? :)\n\n*Update* - fixed the fractal from going offscreen", "tags": ["2d", "fractal", "animation"], "likes": 3, "viewed": 135, "published": "Public", "date": "1405241781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\t\n\tvec2 reso = iResolution.xy;\n\t\n\treso.x += 0.0;\n\treso.y += 235.0;\n\t\n\tvec2 uv = fragCoord.xy / reso;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t\n\tuv.x += 0.3;\n\tuv.y += 0.3;\n\t\n\tvec2 position =  -1.5 + 2.5 * uv;\n\tvec2 z = position;\n\t\n\t\tfor(int i = 0; i < 20; i++)\n\t\t{ \t\n\t\t\tposition.y *= cos(iTime*-0.43);  \t\t\t\t\t\n\t\t\tposition.x *= sin(iTime*-0.57);\n\t\t\t\n\t\t\t//z.x -= sin(iTime*atan(0.33,8.0));\n\t\t\tz.x -= sin((iTime/10.0)*atan(0.33,8.0));\n\t\t\t\n\t\t\t//z.x -= atan(iTime,sin(5.5));\n\t\t\t\n\t\t\tz.y *= atan(iTime,atan(-16.03,iTime));\n\t\t\t\n\t\t\tz = position + vec2(\n            \t\tz.x*z.x-z.y*z.y,\n            \t\t2.0*z.x*z.y);\n            \tif(length(z) > 1.5){\n            \t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n            \t}\n            }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 784]], "test": "valid"}
{"id": "XdfSDB", "name": "Deformed", "author": "xbe", "description": "Deformed raymarched sphere and plane. I was going somewhere else but ended up with that. Simple and quite good looking IMHO.\nDeformation synchronized on sound channel.", "tags": ["procedural", "3d", "raymarching", "noise"], "likes": 53, "viewed": 2640, "published": "Public", "date": "1406144429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////\n// XBE\n// Deformed\n// Sphere + Plane + Noise\n//\n\nvec4 spect;\n\n// Value Noise by IQ\n#define USE_PROCEDURAL\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel1, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\nfloat fbm(vec3 uv)\n{\n\tfloat f;\n\tmat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\tf  = 0.5000*noise( uv ); uv = m*uv*2.01;\n\tf += 0.2500*noise( uv ); uv = m*uv*2.02;\n\tf += 0.1250*noise( uv ); uv = m*uv*2.03;\n\tf += 0.0625*noise( uv ); uv = m*uv*2.01;\n//\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\n// Distance Functions for Raymarching\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nfloat map( in vec3 pos )\n{\n\tfloat deform = spect.x*fbm( pos + spect.y*fbm((spect.z+5.)*pos));\n\tfloat d = opU( sdPlane(pos+vec3(0.,0.5,0.)) + 3.14*deform,\n\t\tsdSphere( pos, 0.35 ) - deform);\n    return d;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n\t\tmap(pos+eps.xyy) - map(pos-eps.xyy),\n\t\tmap(pos+eps.yxy) - map(pos-eps.yxy),\n\t\tmap(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\n// Raymarching\nbool raymarch(vec3 origin, vec3 dir, out float dist, out vec3 norm)\n{\n\tfloat epsilon = 0.003;\n\tfloat maxdist = 10.0;\n\tfloat marched = 0.0;\n\tfloat delta = 2.*epsilon;\n\tdist = -1.0;\n\tfor (int steps=0; steps < 60; steps++)\n\t{\n\t\tif ( ( abs(delta) < epsilon ) || (marched > maxdist) ) continue;\n\t\tmarched += delta;\n\t\tdelta = map(origin + marched * dir);\n\t}\n\tbool res = false;\n\tif (marched < maxdist)\n\t{\n\t\tnorm = calcNormal(origin + marched * dir);\n\t\tdist = marched;\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n\tfloat dist = 0.;\n\tvec3 nor = vec3(0.,0.,0.);\n\t//\n\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\tvec3 sky = vec3(0.32,0.36,0.4) - rd.y*0.4;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tsky += vec3(1.0,0.8,0.4)*0.5*pow( sun, 10.0 );\n\tsky *= 0.9;\n\t//\n    if ( raymarch(ro, rd, dist, nor) )\n    {\n        vec3 pos = ro + dist*rd;\n\n\t\tcol = vec3(0.75);\n\t\t\n        float ao = calcAO( pos, nor );\n\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tvec3 brdf = vec3(0.0);\n//\t\tbrdf += 2.20*amb*vec3(0.20,0.22,0.26)*ao;\n\t\tbrdf += 1.20*amb*vec3(0.20,0.22,0.26)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.00*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf + vec3(0.8)*vec3(1.00,0.70,0.60)*spe + 0.2*fre*(0.5+0.5*col);\n\t\tcol = mix( col, sky, 1.0-exp(-0.0025*dist*dist*dist) );\n\t}\n\telse\n\t{\n\t\tcol = sky;\n\t}\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tspect.x = 1.5*(texture(iChannel0, vec2(0.0,.0)).x+texture(iChannel0, vec2(0.1,.0)).x+texture(iChannel0, vec2(0.2,.0)).x)/3.0;\n\tspect.y = 1.*texture(iChannel0, vec2(0.5,.0)).x;\n\tspect.z = 1.5*texture(iChannel0, vec2(0.75,.0)).x;\n\tspect.w = texture(iChannel0, vec2(0.5,.0)).x;\n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\tfloat Time = 0.45*(15.0 + iTime) - 2.*spect.w;\n\n\t// camera\t\n\tvec3 ro = vec3( 4.0*cos(Time+45.), 0.5, 2.0*sin(Time) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = render( ro, rd );\n\tcol = sqrt(col);\n\t\n\tfragColor=vec4( clamp(col,0.,1.), 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 871, 891, 891, 1222], [1224, 1262, 1297, 1297, 1323], [1325, 1325, 1350, 1350, 1365], [1367, 1367, 1400, 1400, 1429], [1431, 1431, 1457, 1457, 1635], [1637, 1637, 1669, 1669, 1850], [1852, 1867, 1936, 1936, 2359], [2361, 2361, 2403, 2403, 2706], [2708, 2708, 2747, 2747, 3953], [3955, 3955, 4012, 4012, 4852]], "test": "error"}
{"id": "XdfXRX", "name": "musk's lens flare mod", "author": "Icecool", "description": "A little modification of musk's lense flare shader. The f0 part here looks reasonably better.", "tags": ["2d", "lensflare"], "likes": 40, "viewed": 3255, "published": "Public", "date": "1404679340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// musk's lense flare, modified by icecool.\n// See the original at: https://www.shadertoy.com/view/4sX3Rs \n\nfloat noise(float t)\n{\n\treturn texture(iChannel0,vec2(t, 0.0) / iChannelResolution[0].xy).x;\n}\nfloat noise(vec2 t)\n{\n\treturn texture(iChannel0,(t + vec2(iTime)) / iChannelResolution[0].xy).x;\n}\n\nvec3 lensflare(vec2 uv,vec2 pos)\n{\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat ang = atan(main.y, main.x);\n\tfloat dist=length(main); dist = pow(dist,.1);\n\tfloat n = noise(vec2((ang-iTime/9.0)*16.0,dist*32.0));\n\t\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\n\t\n\tf0 = f0+f0*(sin((ang+iTime/18.0 + noise(abs(ang)+n/2.0)*2.0)*12.0)*.1+dist*.1+.8);\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tuvx = mix(uv,uvd,-.4);\n\t\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n\t\n\tuvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\n\tc+=vec3(f0);\n\t\n\treturn c;\n}\n\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tif (iMouse.z<.5)\n\t{\n\t\tmouse.x=sin(iTime)*.5;\n\t\tmouse.y=sin(iTime*.913)*.5;\n\t}\n\t\n\tvec3 color = vec3(1.4,1.2,1.0)*lensflare(uv,mouse.xy);\n\tcolor = cc(color,.5,.1);\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 108, 130, 130, 202], [203, 203, 224, 224, 301], [303, 303, 337, 337, 1623], [1625, 1625, 1692, 1692, 1775], [1777, 1777, 1834, 1834, 2258]], "test": "error"}
{"id": "XdsXRf", "name": "Simple Radar", "author": "henrydm", "description": "A radar, with a circular moving line and a motion blur", "tags": ["2d", "simple"], "likes": 17, "viewed": 1217, "published": "Public", "date": "1405190208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat LineToPointDistance2D( vec2 a, vec2 b, vec2 p)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\n    return length( pa - ba*h );\n}\n\n\nvec2 rotatePoint(vec2 center,float angle,vec2 p)\n{\n  float s = sin(angle);\n  float c = cos(angle);\n\n  // translate point back to origin:\n  p.x -= center.x;\n  p.y -= center.y;\n\n  // rotate point\n  float xnew = p.x * c - p.y * s;\n  float ynew = p.x * s + p.y * c;\n\n  // translate point back:\n  p.x = xnew + center.x;\n  p.y = ynew + center.y;\n  return p;\n}\n\n\nvoid getBlips(float radius, out vec2[1] blipsOut)\n{\t\n\tvec2 cen = iResolution.xy/2.0;\n\tfloat sec = iDate[3];\n\tfloat mdl = mod(sec,10.0);\n\t\n\t//From 1 to 6 \n\tfloat cstepRot = ((sec-mdl)/10.0)+1.0;\n\tfloat factorRot = cstepRot/6.0;\n\t\n\tfloat factorLen = sin(factorRot)/2.0;\n\tfloat len = radius*factorLen;//0.5;);\n\tvec2 targetP = vec2(cen.x,cen.y+len);\t\n\tfloat ang  =  PI*factorRot*2.0;\n\ttargetP = rotatePoint(cen,ang,targetP);\n\t\n\tblipsOut[0] = targetP;\t\t\n}\n\nfloat angleVec(vec2 a_, vec2 b_) \n{\n    vec3 a = vec3(a_, 0);\n    vec3 b = vec3(b_, 0);\n     float dotProd = dot(a,b); \n     vec3 crossprod = cross(a,b);\n     float crossprod_l = length(crossprod);\n     float lenProd = length(a)*length(b);\n     float cosa = dotProd/lenProd;\n     float sina = crossprod_l/lenProd;\n     float angle = atan(sina, cosa);\n    \n     if(dot(vec3(0,0,1), crossprod) < 0.0) \n        angle=90.0;\n     return (angle * (180.0 / PI));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 center =iResolution.xy/2.0;\n\tfloat minRes = min(center.x,center.y);\n\tfloat radius =minRes-minRes*0.1;\n\tfloat circleWitdh = radius*0.02;\n\tfloat lineWitdh = circleWitdh*0.8;\n\tfloat angleStela = 180.0;\t\n\tvec2 lineEnd =  vec2(center.x,center.y+radius);\n\n\tfloat blue =0.0;\n\tfloat green =0.0;\n\t\n\tfloat distanceToCenter = distance(center,fragCoord.xy);\t\n\tfloat disPointToCircle=abs(distanceToCenter-radius);\n\t\t\t\t\t\t\t\n\t//Draw Circle\n\tif (disPointToCircle<circleWitdh)\n\t{\n\t\tgreen= 1.0-(disPointToCircle/circleWitdh);\n\t}\n\t\n\t//Rotate Line\n\tfloat angle = (-iTime*1.2);\n\tlineEnd = rotatePoint(center,angle,lineEnd);\n\t\n\t//Draw Line\t\n\tfloat distPointToLine = LineToPointDistance2D(center,lineEnd,fragCoord.xy);\n\tif (distPointToLine<lineWitdh)\n\t{ \n\t\tfloat val = 1.0-distPointToLine/lineWitdh;\n\t\tif (val>green)\n\t\t\tgreen=val;\n\t}\n\t\n\t\n\t//Draw Stela\n\tfloat angleStelaToApply = angleVec(normalize(lineEnd-center),normalize(fragCoord.xy-center));\n\tif (angleStelaToApply<angleStela && distanceToCenter<radius-circleWitdh/2.0+1.0)\n\t{\n\t\tfloat factorAngle = 1.0-angleStelaToApply/angleStela;\n\t\t\n\t\tfloat finalFactorAngle = (factorAngle*0.5)-0.15;\n\t\t\n\t\t\n\t\tif (finalFactorAngle>green)\n\t\t\tgreen=finalFactorAngle;\n\t\t\n\n\t\t\t\n\t\t//DrawBlips\n\t\tvec2 blips[1];\n\t\tfloat angles[1];\n\t\tgetBlips(radius,blips);\n\n\t\t\n\t\tfloat distToBlip = distance(fragCoord.xy,blips[0]);//blips[0]);\n\t\t\t\n\t\tif (distToBlip<15.0)\n\t\t{\n\t\t\tfloat blipFactor = 1.0-distToBlip/15.0;\n\t\t\tfloat toSubtract = 1.0-factorAngle;\n\t\t\tfloat final = blipFactor-toSubtract;\n\t\t\tif (final>green)\n\t\t\tgreen = final;\n\t\t}\t\t\t\n\t}\n\n\tfragColor = vec4(0.0,green,blue,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsXRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 100, 100, 233], [236, 236, 286, 286, 589], [592, 592, 643, 643, 1042], [1044, 1044, 1079, 1079, 1501], [1503, 1503, 1560, 1560, 3144]], "test": "valid"}
{"id": "XdXXRX", "name": "CGAplanes", "author": "cyanux", "description": "Sunday it's cool :)", "tags": ["noise"], "likes": 0, "viewed": 122, "published": "Public", "date": "1404676731", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// vincent francois - cyanux/2014\n\nfloat T = sin(iTime);\n\nfloat noise(vec2 p, float m)\n{\n\treturn fract(mod(m, pow(p.x+p.y, 0.5)));\n}\n\nfloat render(vec2 p)\n{\n\treturn noise(p - 0.5, 3.0 + 0.4 * T);\n}\n\n#define D (0.005)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\t\n\tfloat m = (\n\t\trender(p) +\n\t\trender(p + vec2( D,    0.0)) +\n\t\trender(p + vec2(-D,    0.0)) +\n\t\trender(p + vec2( 0.0,  D  )) +\n\t\trender(p + vec2( 0.0, -D  ))\n\t\t) * 0.2;\n\t\n\tfragColor = vec4(0.0, m, 0.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 58, 88, 88, 132], [134, 134, 156, 156, 197], [218, 218, 275, 275, 527]], "test": "valid"}
{"id": "XdXXW2", "name": "TSDF of Triangles", "author": "gltracy", "description": "samples for truncated signed distance field of triangles. green is outside, blue is inside, white line is zero surface.", "tags": ["tsdf"], "likes": 8, "viewed": 350, "published": "Public", "date": "1406712250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Written by GLtracy\n\nfloat tri( vec2 p0, vec2 p1, vec2 p2, vec2 v ) {\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\t\n\tfloat len0 = length( e0 );\n\tfloat len1 = length( e1 );\n\tfloat len2 = length( e2 );\n\t\n\te0 /= len0;\n\te1 /= len1;\n\te2 /= len2;\n\t\n\tp0 = v - p0;\n\tp1 = v - p1;\n\tp2 = v - p2;\n\t\n\tfloat h0 = dot( p0, vec2( e0.y, -e0.x ) );\n\tfloat h1 = dot( p1, vec2( e1.y, -e1.x ) );\n\tfloat h2 = dot( p2, vec2( e2.y, -e2.x ) );\n\t\n\t// cw\n\tif ( e0.x * e1.y - e0.y * e1.x < 0.0 ) {\n\t\th0 = -h0;\n\t\th1 = -h1;\n\t\th2 = -h2;\n\t}\n\t\n\t// inside\n\tfloat m = max( max( h0, h1 ), h2 );\n\tif ( m <= 0.0 ) {\n\t\treturn m;\n\t}\n\t\n\t// side\n\tvec3 t = vec3( dot( p0, e0 ), dot( p1, e1 ), dot( p2, e2 ) );\n\t\n\tvec3 s = step( 0.0, t ) * step( t, vec3( len0, len1, len2 ) );\n\t\n\th0 *= s.x;\n\th1 *= s.y;\n\th2 *= s.z;\n\t\n\tfloat n = max( max( h0, h1 ), h2 );\n\tif ( n > 0.0 ) {\n\t\treturn n;\n\t}\n\t\n\t// corner\n\tfloat d0 = length( p0 );\n\tfloat d1 = length( p1 );\n\tfloat d2 = length( p2 );\n\treturn min( min( d0, d1 ), d2 );\n}\n\n// math\nmat2 rot2( float angle ) {\n\tfloat c = cos( angle );\n\tfloat s = sin( angle );\n\t\n\treturn mat2(\n\t\t c, s,\n\t\t-s, c\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = ( fragCoord.xy * 2.0 - iResolution.xy ) / min( iResolution.x, iResolution.y );\n\t\n\tmat2 r = rot2( sin( iTime * 0.5 ) * 3.14 );\n\t\n\tvec2 p0 = r * vec2( -1.3, -0.76 );\n\tvec2 p1 = r * vec2(  0.0,  0.73 );\n\tvec2 p2 = r * vec2(  1.3,  0.03 );\n\t\n\tvec2 p3 = vec2( -1.4,  0.76 ) * r;\n\tvec2 p4 = vec2(  0.6,  0.63 ) * r;\n\tvec2 p5 = vec2(  0.8, -0.58 ) * r;\n\t\n\tfloat d1 = tri( p0, p1, p2, v );\n\tfloat d2 = tri( p3, p4, p5, v );\n\t\n\tfloat d = max( d1, -d2 );\n\tconst float band = 0.2;\n\t\n\td = clamp( d / band, -1.0, +1.0 );\n\t\n\tfragColor =\n\t\tvec4( 0.5, 0.7, 0.3, 0.0 ) * max( d, 0.0) +\n\t\tvec4( 0.2, 0.4, 0.7, 0.0 ) * max(-d, 0.0) +\n\t\tvec4( 1.0, 1.0, 1.0, 0.0 ) * ( 1.0 - smoothstep( 0.0, 0.04, abs( d ) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXXW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 71, 71, 987], [989, 997, 1023, 1023, 1112], [1114, 1114, 1171, 1171, 1874]], "test": "valid"}
{"id": "XdXXzf", "name": "Radial UV", "author": "bytewave", "description": "A simple radial uv mapping", "tags": ["uv", "gradient", "mapping", "tilling"], "likes": 5, "viewed": 669, "published": "Public", "date": "1404839780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy  ;uv -= 0.5;uv.x *= (iResolution.x /iResolution.y);\n    \n    vec2 RadUv = vec2(0.,0.);    \n\tRadUv.x = ((atan(uv.x,uv.y) * 0.15915494309189533576888376337251 /*OneOverTau*/) ) +0.5;\n    RadUv.y = length(uv);\n    \n    \n \t//fragColor = texture(iChannel0,RadUv);\n\tfragColor = mix(vec4(RadUv.xy,0.,1.),texture(iChannel0,RadUv + vec2(00.,iTime)),(sin(iTime) + 0.5) * 0.5);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 467]], "test": "error"}
{"id": "XsfXRl", "name": "simple polka dots", "author": "villain749", "description": "leaning about basic patterns", "tags": ["dots", "squares", "polka"], "likes": 2, "viewed": 175, "published": "Public", "date": "1405409703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float t = iTime * 0.3;\nconst float rad = 0.25;\nconst vec2 mid = vec2(0.5);\nconst ivec2 reps = ivec2(8, 8);\nconst float angle = 45.0;\nconst float RADIANS = angle * 0.0174532;\n// rotation matrix\nmat2 rot = mat2(vec2(cos(RADIANS), -sin(RADIANS)), vec2(sin(RADIANS), cos(RADIANS)));\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// the uv.. we are calling it p for pixel\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\t// account for non square image aspect\n\tp.y *= float(iResolution.y )/ float(iResolution.x);\n\t//rotating the whole scene\t\n\tp *= rot;\n\t\n\t\n\t// q is just an offset - .5\n\tvec2 q = p - vec2(0.5, 0.5);\n\t\n\t\n\t//=====================\n\t// wave\n\t//=====================\n\t// distorting with sin, cos\n\tq +=  vec2(cos(p.y + t * 4.55) * 0.05, cos(p.x + t * 2.55) * 0.05);\n\t\n\t// creates a repeating 0-1 range\n\tvec2 repeat = vec2(fract(q.x * float(reps.x)), fract(q.y * float(reps.y)) );\t\n\t\n\t// holds the color\n\tvec3 col = vec3(1.0, 1.0, 1.0);\n\t\n\tvec2 distFromMid = repeat - mid;\n\t\n\t// drawing circles based on distance from center of each cell\n\tfloat circ = length(distFromMid) < rad ? 1.0 : 0.0;\n\n\t\n\t// diamonds\n\tmat2 rot2 = mat2(vec2(cos(t), -sin(t)), vec2(sin(t), cos(t)));\n\tfloat diamond = smoothstep(.5, .45, (abs((rot2 * distFromMid).x) + abs((rot2 * distFromMid).y)) );\n\t\n\t\t\n\t// distance\n\tfloat dist = length((distFromMid * rot2));\n\tfloat bands = smoothstep(.25, .125, fract(dist * 12.0));\n\t\n\tcol *= vec3(diamond * 0.66, bands, circ);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 281, 337, 380, 1477]], "test": "valid"}
{"id": "XsfXzs", "name": "Curvature average", "author": "nimitz", "description": "Click and drag to move a bit.\nMostly based on Jussi HÃÂ¤rkÃÂ¶nen's paper: http://jussiharkonen.com/files/on_fractal_coloring_techniques(lo-res).pdf", "tags": ["2d", "fractal", "mandelbrot", "curvatureaverage"], "likes": 54, "viewed": 2674, "published": "Public", "date": "1405529758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Curvature average by nimitz (stormoid.com) (twitter: @stormoid)\n\n/*\n\tThis is a somewhat old technique of coloring fractals, according to the paper\n\t(http://jussiharkonen.com/files/on_fractal_coloring_techniques(lo-res).pdf)\n\tthe technique was devised by Damien Jones in 1999, the idea is to color based\n\tthe sum of the angles of z as it's being iterated.  I am also using a sinus function\n\tin the loop to greate a more \"hairy\" look.\n\n\tI should be converting to hsv to do color blending, but it looks good enough that way.\n*/\n\n#define ITR 80.\n#define BAILOUT 1e10\n\n#define R .35\n#define G .2\n#define B .15\n\n#define time iTime\nmat2 mm2(const in float a){float c=cos(a), s=sin(a);return mat2(c,-s,s,c);}\n\n//lerp between 3 colors\n//usage: 0=a | 0.33=b | 0.66=c | 1=a\nvec3 wheel(in vec3 a, in vec3 b, in vec3 c, in float delta)\n{\n\treturn mix(mix(mix( a,b,clamp((delta-0.000)*3., 0., 1.)),\n\t\t\t\t\t\t  c,clamp((delta-0.333)*3., 0., 1.)),\n\t\t\t\t\t\t  a,clamp((delta-0.666)*3., 0., 1.));\n}\n\n//Reinhard based tone mapping (https://www.shadertoy.com/view/lslGzl)\nvec3 tone(vec3 color, float gamma)\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec2 render(in vec2 p)\n{\n    //init vars\n\tvec2 c = p, z = p;\n\tvec2 oldz1 = vec2(1);\n\tvec2 oldz2 = vec2(1);\n\tfloat curv = 0.;\n\tfloat rz = 1., rz2 = 0.;\n\tfloat numitr = 0.;\n    \n    for( int i=0; i<int(ITR); i++ )\n\t{\n\t\tif (dot(z,z)<BAILOUT)\n\t\t{\n\t\t\tz = vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y)+c;\n\t\t\tvec2 tmp = vec2(1);\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\ttmp = (z-oldz1)/(oldz1-oldz2);\n\t\t\t}\n\t\t\tcurv = abs(atan(tmp.y,tmp.x));\n\t\t\tcurv = sin(curv*5.)*0.5+0.5;\n\t\t\t\n\t\t\toldz2 = oldz1;\n\t\t\toldz1 = z;\n\t\t\trz2 = rz;\n\t\t\trz += (.95-curv);\n\t\t\tnumitr += 1.;\n\t\t}\n\t}\n\t\n\t//Thanks to iq for the proper smoothing formula\n\tfloat f = 1.-log2( (log(dot(z,z))/log(BAILOUT)) );\n\tf = smoothstep(0.,1.,f);\n\t\n\t//linear interpolation\n\trz = rz / numitr;\n\trz2 = rz2 / (numitr-1.);\n\trz = mix(rz2,rz,f);\n    return vec2(rz,rz2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//setup coords and mouse\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tfloat zoom = sin(time*.1+2.)*0.025+0.027;\n    p*= zoom;\n\tvec2 um = iMouse.xy==vec2(0)?vec2(0):(iMouse.xy / iResolution.xy)-0.5;\n\tum.x *= iResolution.x/iResolution.y;\n\tp += um*0.03+vec2(-.483,0.6255);\n\t\n    float px=.75/iResolution.x*zoom;\n    vec2 rz = vec2(0);\n    for (float i=0.; i<4.; i++) \n    {\n        vec2  of = floor(vec2(i/2.,mod(i,2.)));\n\t\trz += render(p+ of*px);\n\t}\n    rz /= 4.;\n    \n\t//coloring\t\n\trz.y = smoothstep(0.,1.2,rz.x);\n\tvec3 col = (sin(vec3(R,G,B)+6.*rz.y+2.9)*.5+0.51)*1.4;\n\tvec3 col2 = vec3(R*(sin(rz.x*5.+1.2)),G*sin(rz.x*5.+4.1),B*sin(rz.x*5.+4.4));\n\tcol2= clamp(col2,0.,1.);\n    vec3 col3 = vec3(R,G,B)*smoothstep(0.5,1.,1.-rz.x);\n    col3 = pow(col3,vec3(1.2))*2.6;\n\tcol3= clamp(col3,0.,1.);\n\tcol = wheel(col,col2,col3,fract((time-20.)*0.015));\n\tcol = tone(col,.8)*3.5;\n    \n\tfragColor = vec4(col,1.);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 627, 654, 654, 702], [704, 765, 826, 826, 975], [977, 1047, 1083, 1083, 1321], [1323, 1323, 1347, 1363, 2098], [2100, 2100, 2157, 2183, 3099]], "test": "error"}
{"id": "XslSWB", "name": "parabolic", "author": "dirkadirkadan", "description": "what is it?", "tags": ["antialiased", "parabola"], "likes": 0, "viewed": 130, "published": "Public", "date": "1406783426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    uv = 3.*uv-1.;\t\n\t\n\tfloat c=.5,x=3.8,xx=-7.6;\n\tx = 3.8*sin(4.*iTime);\n\txx = -2.*x;\n\tfloat s=xx*uv.x*uv.x/2.+ x*uv.x + c;\n\tvec3 col=vec3(0.);\n\tfloat fac = 1.-min(1.,40.*abs(s-uv.y)-.3);\n\t\t\n\tcol+=vec3(0.,0.,.4)*sin(3.*uv.x+2.*uv.y-iTime);\n\t\n\tfloat sf = clamp(5.*(uv.y-.07),0.,1.);\n\tvec3 u=vec3(.75,.75,.6);\n\tcol+=sf*vec3(6.,.54,.54);\n\tcol+=sf*vec3(.9,.7,.1)*(max(1.-(length(u.xy-uv)-u.z),0.));\n\tfloat dx = max(1.-abs(uv.x-u.x),0.);\n\tcol+=(1.-sf)*vec3(.3,.4,1.);\n\tcol+=max(1.-sf,0.)*dx*dx;\n\n\tif (fac > 0.05)\n\t\tcol = vec3(0.);\n\t\n\tfragColor = vec4(col,1.);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslSWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 660]], "test": "valid"}
{"id": "XsXXDB", "name": "Cook-Torrance", "author": "xbe", "description": "Classic raytracing using Cook-Torrance shading model. It supports reflection (4 levels) and refraction, hard shadow are supported but enabled only for the ground balls.", "tags": ["3d", "raytracing", "cooktorrance"], "likes": 18, "viewed": 886, "published": "Public", "date": "1406206039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////\n// Classic raytracing\n// Cook-Torrance shading \n//\n// The shaders displays 3 series of balls with different materials:\n// - Ground: Basic (no reflection, no refraction), roughness and density varying foreach ball.\n// - Along blue wall: Reflective materials, roughness and density varying foreach ball.\n// - Along orange wall: Refractive materials,roughness and density varying foreach ball.\n// - Center: the ball at the center is both reflective and refractive.\n//\n// Hard shadow are supported but enabled only for the ground balls.\n//\n\nstruct Material {\n\tvec3  color;\t\t// diffuse color\n\tbool reflection;\t// has reflection \n\tbool refraction;\t// has refraction\n\tfloat n;\t\t\t// refraction index\n\tfloat roughness;\t// Cook-Torrance roughness\n\tfloat fresnel;\t\t// Cook-Torrance fresnel reflectance\n\tfloat density;\t\t// Cook-Torrance color density i.e. fraction of diffuse reflection\n};\n\nstruct Light {\n\tvec3 pos;\n\tvec3 color;\n};\n\n//////////////////////////////////////\n/// Ray-Primitive intersections\n/// fast version test the existence of \n/// an intersection\n\nstruct Inter {\n\tvec3 p;\t\t//pos\n\tvec3 n; \t//normal\n\tvec3 vd;\t// viewdir\n\tfloat d;\t//distance\n\tbool inside; // inside object\n\tMaterial mat; // object material\n};\n\nfloat fastintSphere(vec3 ro, vec3 rd, vec3 p, float r)\n{\n\tfloat dist = -1.;\n\tvec3 v = ro-p;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - r*r;\n\tfloat d = b*b-c;\n\tif (d>0.)\n\t{\n\t\tfloat t1 = (-b-sqrt(d));\n\t\tfloat t2 = (-b+sqrt(d));\n\t\tif (t2>0.)\n\t\t\tdist = t1>0.?t1:t2;\n\t}\n\treturn dist;\n}\n\nvoid intSphere(vec3 ro, vec3 rd, vec3 p, float r, Material mat, inout Inter i)\n{\n\tfloat dist = -1.;\n\tvec3 v = ro-p;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - r*r;\n\tfloat d = b*b-c;\n\tif (d>0.)\n\t{\n\t\tfloat t1 = (-b-sqrt(d));\n\t\tfloat t2 = (-b+sqrt(d));\n\t\tif (t2>0.)\n\t\t{\n\t\t\tdist = t1>0.?t1:t2;\n\t\t\tif ((dist<i.d)||(i.d<0.))\n\t\t\t{\n\t\t\t\ti.p = ro+dist*rd;\n\t\t\t\ti.n = normalize(i.p-p);\n\t\t\t\ti.d = dist;\n\t\t\t\ti.vd = -rd;\n\t\t\t\ti.inside = t1<0.;\n\t\t\t\tif (i.inside)\n\t\t\t\t\ti.n *= -1.; //invert the normal when hitting inside during refraction\n\t\t\t\ti.mat = mat;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfloat fastintPlane(vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n\tfloat res = -1.;\n\tfloat dpn = dot(rd,n);\n\tif (abs(dpn)>0.00001)\n\t\tres = (-(dot(n, p) + dot(n,ro)) / dpn);\n\treturn res;\n}\n\nbool intPlane(vec3 ro, vec3 rd, vec3 p, vec3 n, Material mat, inout Inter i)\n{\n\tfloat d = -1.;\n\tfloat dpn = dot(rd,n);\n\tif (abs(dpn)>0.00001)\n\t{\n\t\td = -(dot(n, p) + dot(n,ro)) / dpn;\n\t\tif ((d>0.)&&((d<i.d)||(i.d<0.)))\n\t\t{\n\t\t\ti.p = ro+d*rd;\n\t\t\ti.n = n;\n\t\t\ti.d = d;\n\t\t\ti.vd = -rd;\n\t\t\ti.inside = false;\n\t\t\ti.mat = mat;\n\t\t}\n\t}\n\treturn (i.d==d);\n}\n\n//////////////////////////////////////\n/// Shading functions\nvec3 shadeBlinnPhong( Inter i, vec3 lp )\n{\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.4;\n\t\n\tvec3 res = vec3(0.);\n\tvec3 ld = normalize(lp-i.p);\n\tres = i.mat.color*diffuse*dot(i.n,ld);\n\tvec3 h = normalize(i.vd+ld);\n\tres += specular*pow(dot(i.n,h), 16.);\n\treturn res;\n}\n\nvec3 shadePhong( Inter i, vec3 lp )\n{\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.4;\n\t\n\tvec3 res = vec3(0.);\n\tvec3 ld = normalize(lp-i.p);\n\tres = i.mat.color*diffuse*dot(i.n,ld);\n\tres += specular*pow( clamp(dot(reflect(i.vd,i.n),ld),0.,1.), 16.);\n\treturn res;\n}\n\n/// References:\n/// http://content.gpwiki.org/index.php/D3DBook:%28Lighting%29_Cook-Torrance\n/// http://ruh.li/GraphicsCookTorrance.html\nvec3 shadeCookTorrance( Inter i, Light lig )\n{\n\tfloat roughness = i.mat.roughness;\n\tfloat F0 = i.mat.fresnel;\n\tfloat K = i.mat.density;\n\t//\n\tvec3 ld = normalize(lig.pos-i.p);\n\tvec3 h = normalize(i.vd+ld);\n\tfloat NdotL = clamp( dot( i.n, ld ),0.,1. );\n\tfloat NdotH = clamp( dot( i.n, h ),0.,1. );\n\tfloat NdotV = clamp( dot( i.n, i.vd ),0.,1. );\n\tfloat VdotH = clamp( dot( h, i.vd ),0.,1. );\n\tfloat rsq = roughness * roughness;\n\t\n\t// Geometric Attenuation\n\tfloat NH2   = 2. * NdotH / VdotH;\n\tfloat geo_b = (NH2 * NdotV );\n\tfloat geo_c = (NH2 * NdotL );\n\tfloat geo   = min( 1., min( geo_b, geo_c ) );\n\t\n\t// Roughness\n\t// Beckmann distribution function\n\tfloat r1 = 1. / ( 4. * rsq * pow(NdotH, 4.));\n\tfloat r2 = (NdotH * NdotH - 1.) / (rsq * NdotH * NdotH);\n\tfloat rough = r1 * exp(r2);\n\t\n\t// Fresnel\t\t\t\n\tfloat fres = pow( 1.0 - VdotH, 5. );\n\tfres *= ( 1.0 - F0 );\n\tfres += F0;\n\t\n\tvec3 spec = (NdotV * NdotL==0.) ? vec3(0.) : vec3 ( fres * geo * rough ) / ( NdotV * NdotL );\n\tvec3 res = NdotL * ( (1.-K)*spec + K*i.mat.color ) * lig.color;// * exp(-0.001*length(lig.pos-i.p));\n\treturn res;\n}\n\n////////////////////////////////////\n// Raytracing\n\nfloat hidden( Inter i, vec3 lp)\n{\n\tvec3 ro = i.p;\n\tfloat dmax = length(lp-ro);\n\tvec3 rd = normalize(lp-ro);\n\tro += 0.001*rd;\n\t//\n\tfloat hit = -1.;\n\tvec3 p = vec3(0.,0.,0.);\n\tvec3 n = vec3(0.,1.,0.);\n\thit = fastintPlane( ro, rd, p, n);\n\thit = hit>dmax?-1.:hit;\n\t//\n\tif (hit<0.)\n\t{\n\t\tfloat pi = 1.25;\n\t\tp = vec3(-2.5,0.5,-2.5);\n\t\tfor (int k=0; k<5; ++k)\n\t\t{\n\t\t\tp.z = -2.5;\n\t\t\tfor (int l=0;l<5;++l)\n\t\t\t{\n\t\t\t\thit = fastintSphere( ro, rd, p, 0.5);\n\t\t\t\tif ((hit>0.) && (hit<dmax)) break;\n\t\t\t\tp.z += pi;\n\t\t\t}\n\t\t\tif (hit>0.) break;\n\t\t\tp.x += pi;\n\t\t}\n\t}\n\treturn hit;\n}\n\nvec3 raytraceRay( vec3 ro, vec3 rd, inout Inter i)\n{\n\tMaterial mat;\n\tmat.color = vec3(0.75);\n\tmat.reflection = false;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 1.;\n\tmat.density = 1.;\n\tvec3 p = vec3(0.,0.,0.);\n\tvec3 n = vec3(0.,1.,0.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.75)*mod(floor(i.p.x)+floor(i.p.z),2.)+0.25;\n\t}\n\t//\n\tp = vec3(-8.,0.,0.);\n\tn = vec3(-1.,0.,0.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.95,0.35,0.)*mod(floor(i.p.y)+floor(i.p.z),2.)+0.25;\n\t}\n\t//\n\tp = vec3(0.,0.,8.);\n\tn = vec3(0.,0.,1.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.35,0.65,0.95)*mod(floor(i.p.x)+floor(i.p.y),2.)+0.25;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = false;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.1;\n\tmat.density = 0.95;\n\tfloat pi = 1.25;\n\tfloat ri = 0.2;\n\tp = vec3(-2.5,0.5,-2.5);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.roughness = 0.1;\n\t\tp.z = -2.5;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.roughness += ri;\n\t\t\tp.z += pi;\n\t\t}\n\t\tmat.density -= ri;\n\t\tp.x += pi;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = true;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.1;\n\tmat.density = 0.95;\n\tpi = 1.25;\n\tri = 0.2;\n\tp = vec3(-2.5,1.,-4.);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.roughness = 0.1;\n\t\tp.y = 1.;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.roughness += ri;\n\t\t\tp.y += pi;\n\t\t}\n\t\tmat.density -= ri;\n\t\tp.x += pi;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = false;\n\tmat.refraction = true;\n\tmat.n = 1.16;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.9;\n\tmat.density = 0.15;\n\tpi = 1.25;\n\tri = 0.2;\n\tp = vec3(4.,1.,2.5);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.density = 0.15;\n\t\tp.y = 1.;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.density += ri;\n\t\t\tp.y += pi;\n\t\t}\n\t\tmat.roughness -= ri;\n\t\tp.z -= pi;\n\t}\n\t//\n\tmat.color = vec3(0.0,1.0,1.0);\n\tmat.reflection = true;\n\tmat.refraction = true;\n\tmat.n = 1.33;\n\tmat.fresnel = 0.8;\n\tmat.roughness = .1;\n\tmat.density = 0.5;\n\tp = vec3(0.,4.0,0.);\n\tintSphere( ro, rd, p, 1.5, mat, i);\n\t//\n\tvec3 col = vec3(0.1,0.1,0.1);\n\tif (i.d>0.)\n\t{\n\t\t// ambiant\n\t\tfloat ambiant = 0.1;\n\t\tcol = ambiant*i.mat.color;\n\t\t\n\t\tif (!i.inside)\n\t\t{\n\t\t\t// lighting\n\t\t\tLight lig;\n\t\t\tlig.color = vec3(1.,1.,1.);\n\t\t\tlig.pos = vec3(0., 6., 0.);\n\t\t\tif (hidden(i,lig.pos)<0.)\n\t\t\t\tcol += 0.5*shadeCookTorrance(i, lig);\n\t\t\tlig.pos = vec3(-4., 6., -4.);\n\t\t\tif (hidden(i,lig.pos)<0.)\n\t\t\t\tcol += 0.5*shadeCookTorrance(i, lig);\n\t\t}\n\t}\n\treturn clamp(col,0.,1.);\n}\n\nvec3 raytrace( vec3 ro, vec3 rd)\n{\n\tInter i;\n\ti.p = vec3(0.,0.,0.);\n\ti.n = vec3(0.,0.,0.);\n\ti.d = -1.;\n\ti.vd = vec3(0.,0.,0.);\n\ti.inside = false;\n\t//\n\tvec3 accum = vec3(0.);\n\tvec3 col = vec3(0.);\n\tfloat refl = 1.;\n\tfloat refr = 1.;\n\tcol = raytraceRay(ro, rd, i);\n\taccum += col; // * exp(-0.0005*i.d*i.d);\n\tif (i.mat.reflection)\n\t{\n\t\tInter li = i;\n\t\tvec3 lro = ro;\n\t\tvec3 lrd = rd;\n\t\tlro = li.p;\n\t\tlrd = reflect(-li.vd,li.n);\n\t\tlro += 0.0001*lrd;\n\t\tfor (int k=1; k<4; ++k)\n\t\t{\n\t\t\tli.d = -1.;\n\t\t\trefl *= 1.-i.mat.density;\n\t\t\t//\n\t\t\tcol = raytraceRay(lro, lrd, li);\n\t\t\t//\n\t\t\taccum += col * refl; // * exp(-0.005*i.d*i.d);\n\t\t\tif ((li.d<.0)||(!li.mat.reflection)) break;\n\t\t\tlro = li.p;\n\t\t\tlrd = reflect(-li.vd,li.n);\n\t\t\tlro += 0.0001*lrd;\n\t\t}\n\t}\n\tif (i.mat.refraction)\n\t{\n\t\tInter li = i;\n\t\tvec3 lro = ro;\n\t\tvec3 lrd = rd;\n\t\tfloat n = 1./li.mat.n;\n\t\tfloat cosI = -dot(li.n,li.vd);\n\t\tfloat cost2 = 1.-n*n*(1.-cosI*cosI);\n\t\tif (cost2>0.)\n\t\t{\n\t\t\tlro = li.p;\n\t\t\tlrd = normalize(-li.vd*n+li.n*(n*cosI - sqrt(cost2)));\n\t\t\tlro += 0.0001*lrd;\n\t\t\tfor (int k=1; k<4; ++k)\n\t\t\t{\n\t\t\t\tli.d = -1.;\n\t\t\t\trefr *= 1.-li.mat.density;\n\t\t\t\t//\n\t\t\t\tcol = raytraceRay(lro, lrd, li);\n\t\t\t\t//\n\t\t\t\taccum += col * refr; //* exp(-0.005*i.d*i.d);\n\t\t\t\tif ((li.d<.0)||(!li.mat.refraction)) break;\n\t\t\t\tif (li.inside)\n\t\t\t\t\tn = li.mat.n;\n\t\t\t\telse\n\t\t\t\t\tn = 1./li.mat.n;\n\t\t\t\tcosI = -dot(li.n,li.vd);\n\t\t\t\tcost2 = 1.-n*n*(1.-cosI*cosI);\n\t\t\t\tif (cost2<=0.) break;\n\t\t\t\tlro = li.p;\n\t\t\t\tlrd = normalize(-li.vd*n+li.n*(n*cosI - sqrt(cost2)));\n\t\t\t\tlro += 0.0001*lrd;\n\t\t\t}\n\t\t}\n\t}\n\treturn clamp(accum,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\tfloat Time = 0.45*(15.0 + iTime);\n\t// camera\t\n\tvec3 ro = vec3( 8.0*cos(Time), 6.0, 8.0*sin(Time) );\n//\tvec3 ro = vec3( -8.0, 6.0, 8.0 );\n\tvec3 ta = vec3( 0.0, 2.5, 0. );\n\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tif( iMouse.z>0.0 )\n\t{\n\t\tfloat hd = -m.x * 14.0 + 3.14159;\n\t\tfloat elv = m.y * 3.14159 * 0.4 - 3.14159 * 0.25;\n\t\tro = vec3(sin(hd) * cos(elv), sin(elv), cos(hd) * cos(elv));\n\t\tro = ro * 8.0 + vec3(0.0, 6.0, 0.0);\n\t}\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = raytrace( ro, rd );\n\t\n\tfragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[963, 1256, 1312, 1312, 1537], [1539, 1539, 1619, 1619, 2091], [2093, 2093, 2147, 2147, 2269], [2271, 2271, 2349, 2349, 2613], [2615, 2676, 2718, 2718, 2941], [2943, 2943, 2980, 2980, 3202], [3204, 3341, 3387, 3387, 4428], [4430, 4482, 4515, 4515, 5041], [5043, 5043, 5095, 5095, 7763], [7765, 7765, 7799, 7799, 9319], [9321, 9321, 9378, 9378, 10185]], "test": "valid"}
{"id": "XsXXWS", "name": "Mandelbulb Deconstructed", "author": "morgan3d", "description": "This is a fractal distance estimator implementation of Mandelbulb power-8 designed for readability. Set FAST to 1 for a ~6x speedup. Thanks to emin for https://www.shadertoy.com/view/XsfGR8 which introduced me to the fractal.", "tags": ["fractal", "raymarch", "mandelbulb", "comments"], "likes": 47, "viewed": 3467, "published": "Public", "date": "1406088283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mandelbulb Explained\n// open source under the http://opensource.org/licenses/BSD-2-Clause license\n// by Morgan McGuire, http://graphics-codex.com\n\n// Set to 1 to lower quality and increase speed\n#define FAST 0\n\n#define Color4 vec4\n#define Color3 vec3\n#define Point3 vec3\n#define Vector3 vec3\n\n////////////////////////////////////////////////////////////\n// Scene configuration:\n\n// = normalize(+1, +1, -1)\nconst Vector3 lightDirection = Point3(0.57735026919, 0.57735026919, -0.57735026919);\n\nconst Color3 keyLightColor  = Color3(1.0, 1.0, 1.0);\nconst Color3 fillLightColor = Color3(0.0, 0.2, 0.7);\n\nconst Color3 backgroundGradientCenterColor = Color3(0.9, 0.9, 0.9);\nconst Color3 backgroundGradientRimColor = Color3(0.5, 0.3, 0.1);\n\nconst float cameraDistance = 5.0;\n\n////////////////////////////////////////////////////////////\n// Algorithm options:\n\n// A point this close to the surface is considered to be on the surface.\n// Larger numbers lead to faster convergence but \"blur\" out the shape\nconst float minimumDistanceToSurface = 0.0003;\n\n// Higher is more complex and fills holes\nconst int ITERATIONS = \n#\tif FAST\n\t\t10;\n#\telse\n\t\t16;\n#\tendif\n\n// Larger is slower but more accurate and fills holes\nconst int RAY_MARCH_ITERATIONS = \n#\tif FAST\n\t\t100;\n#\telse\n\t\t150;\n#\tendif\n\n// Different values give different shapes; 8.0 is the \"standard\" bulb\nconst float power = 8.0;\n\n// A small step, used for computing the surface normal\n// by numerical differentiation. A scaled up version of\n// this is also used for computing a low-frequency gradient.\nconst Vector3 eps = Vector3(minimumDistanceToSurface * 5.0, 0.0, 0.0);\n\n// Orientation of the object\nmat3 rotation;\n\n////////////////////////////////////////////////////////////\n\n// AO = scale surface brightness by this value. 0 = deep valley, 1 = high ridge\nfloat distanceToSurface(Point3 P, out float AO) {\n\t// Rotate the query point into the reference frame of the function\n\tP = rotation * P;\n\tAO = 1.0;\n\t\n\t// Sample distance function for a sphere:\n\t// return length(P) - 1.0;\n\t\n\t// Unit rounded box (http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm)\n\t//return length(max(abs(P) - 1.0, 0.0)) - 0.1;\t\n\t\n\t// This is a 3D analog of the 2D Mandelbrot set. Altering the mandlebulbExponent\n\t// affects the shape.\n\t// See the equation at\n\t// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\t\n\tPoint3 Q = P;\n\t\n\t// Put the whole shape in a bounding sphere to \n\t// speed up distant ray marching. This is necessary\n\t// to ensure that we don't expend all ray march iterations\n\t// before even approaching the surface\n\t{\n\t\tconst float externalBoundingRadius = 1.2;\n\t\tfloat r = length(P) - externalBoundingRadius;\n\t\t// If we're more than 1 unit away from the\n\t\t// surface, return that distance\n\t\tif (r > 1.0) { return r; }\n\t}\n\n\t// Embed a sphere within the fractal to fill in holes under low iteration counts\n\tconst float internalBoundingRadius = 0.72;\n\n\t// Used to smooth discrete iterations into continuous distance field\n\t// (similar to the trick used for coloring the Mandelbrot set)\t\n\tfloat derivative = 1.0;\n\t\n\tfor (int i = 0; i < ITERATIONS; ++i) {\n\t\t// Darken as we go deeper\n\t\tAO *= 0.725;\n\t\tfloat r = length(Q);\n\t\t\n\t\tif (r > 2.0) {\t\n\t\t\t// The point escaped. Remap AO for more brightness and return\n\t\t\tAO = min((AO + 0.075) * 4.1, 1.0);\n\t\t\treturn min(length(P) - internalBoundingRadius, 0.5 * log(r) * r / derivative);\n\t\t} else {\t\t\n\t\t\t// Convert to polar coordinates and then rotate by the power\n\t\t\tfloat theta = acos(Q.z / r) * power;\n\t\t\tfloat phi   = atan(Q.y, Q.x) * power;\t\t\t\n\t\t\t\n\t\t\t// Update the derivative\n\t\t\tderivative = pow(r, power - 1.0) * power * derivative + 1.0;\n\t\t\t\n\t\t\t// Convert back to Cartesian coordinates and \n\t\t\t// offset by the original point (which we're orbiting)\n\t\t\tfloat sinTheta = sin(theta);\n\t\t\t\n\t\t\tQ = Vector3(sinTheta * cos(phi),\n\t\t\t\t\t    sinTheta * sin(phi),\n\t\t\t\t\t    cos(theta)) * pow(r, power) + P;\n\t\t}\t\t\t\n\t}\n\t\n\t// Never escaped, so either already in the set...or a complete miss\n\treturn minimumDistanceToSurface;\n}\n\n\nfloat distanceToSurface(Point3 P) {\n\tfloat ignore;\n\treturn distanceToSurface(P, ignore);\n}\n\n\nColor3 trace(vec2 coord) {\n\tfloat zoom = pow(200.0, -cos(iTime * 0.2) + 1.0);\n\t\n\tPoint3 rayOrigin = Point3(2.0 * coord / iResolution.xy - 1.0, -cameraDistance);\n\n\t// Correct for aspect ratio\n\trayOrigin.x *= iResolution.x / iResolution.y;\n\t\n\tVector3 rayDirection = normalize(normalize(Point3(0.0, 0.0, 1.0) - rayOrigin) + 0.2 * Point3(rayOrigin.xy, 0.0) / zoom);\n\n\t// Distance from ray origin to hit point\n\tfloat t = 0.0;\n\t\n\t// Point on (technically, near) the surface of the Mandelbulb\n\tPoint3 X;\n\n\tbool hit = false;\n\tfloat d;\n\n\t// March along the ray, detecting when we are very close to the surface\n\tfor (int i = 0; i < RAY_MARCH_ITERATIONS; ++i) {\t\t\t\t\t\t\n\t\tX = rayOrigin + rayDirection * t;\n\t\t\n\t\td = distanceToSurface(X);\n\t\thit = (d < minimumDistanceToSurface);\n\t\tif (hit) { break; }\n\t\t\n\t\t// Advance along the ray by the worst-case distance to the\n\t\t// surface in any direction\n\t\tt += d;\n\t}\n\n\tColor3 color;\t\n\tif (hit) {\n\t\t// Compute AO term\n\t\tfloat AO;\n\t\tdistanceToSurface(X, AO);\n\t\t\t\t\n\t\t// Back away from the surface a bit before computing the gradient\n\t\tX -= rayDirection * eps.x;\n\t\t\t\t\n\t\t// Accurate micro-normal\n  \t\tVector3 n = normalize(\n\t\t\tVector3(d - distanceToSurface(X - eps.xyz),\n\t  \t\t        d - distanceToSurface(X - eps.yxz),\n\t  \t\t\t    d - distanceToSurface(X - eps.zyx)));\n\t\t\n\t\t// Broad scale normal to large shape\n  \t\tVector3 n2 = normalize(\n\t\t\tVector3(d - distanceToSurface(X - eps.xyz * 50.0),\n\t  \t\t        d - distanceToSurface(X - eps.yxz * 50.0),\n\t  \t\t\t    d - distanceToSurface(X - eps.zyx * 50.0)));\n\n\t\t// Bend the local surface normal by the\n\t\t// gross local shape normal and the bounding sphere\n\t\t// normal to avoid the hyper-detailed look\n\t\tn = normalize(n + n2 + normalize(X));\n\n\t\t// Fade between the key and fill light based on the normal (Gooch-style wrap shading).\n\t\t// Also darken the surface in cracks (on top of the AO term)\n\t\treturn AO * mix(fillLightColor, keyLightColor, AO * clamp(0.7 * dot(lightDirection, n) + 0.6, 0.0, 1.0)) +\n   \t\t\t   // Give the feel of blowing out the highlights with a yellow tint\n\t\t\t   AO * pow(max(dot(lightDirection, n2), 0.0), 5.0) * Color3(1.3, 1.2, 0.0);\n\t} else {\n\t\t// No hit: return the background gradient\t\t\n\t\treturn mix(backgroundGradientCenterColor, backgroundGradientRimColor, sqrt(length((coord / iResolution.xy - vec2(0.66, 0.66)) * 2.5)));\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// Euler-angle animated rotation\t\n\tfloat pitch = sin(iTime * 0.2);\n\tfloat yaw   = cos(iTime * 0.3);\n\trotation    = mat3(1.0, 0.0, 0.0, 0.0, cos(pitch), -sin(pitch), 0.0, sin(pitch), cos(pitch)) *\n\t              mat3(cos(yaw), 0.0, sin(yaw), 0.0, 1.0, 0.0, -sin(yaw), 0.0, cos(yaw));\n\n\tColor3 color = \n#\t\tif FAST\n\t\t\t// Single sample for speed\n\t\t\ttrace(fragCoord.xy);\n#\t\telse\n         \t// 4x rotated-grid SSAA for antialiasing\n\t\t\t(trace(fragCoord.xy + vec2(-0.125, -0.375)) + \n\t\t\t trace(fragCoord.xy + vec2(+0.375, -0.125)) + \n\t\t\t trace(fragCoord.xy + vec2(+0.125, +0.375)) +\n\t\t\t trace(fragCoord.xy + vec2(-0.375, +0.125))) / 4.0;\n#\t\tendif\n\t\n\t// Coarse RGB->sRGB encoding via sqrt\n\tcolor = sqrt(color);\n\t\n\t// Vignetting (from iq https://www.shadertoy.com/view/MdX3Rr)\n\tvec2 xy = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n\tcolor *= 0.5 + 0.5*pow((xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.2);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXXWS.jpg", "access": "shaders20k", "license": "bsd-simplified", "functions": [[1725, 1805, 1854, 1922, 4086], [4089, 4089, 4124, 4124, 4179], [4182, 4182, 4208, 4208, 6502], [6505, 6505, 6562, 6597, 7495]], "test": "valid"}
