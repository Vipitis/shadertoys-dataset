{"id": "4d3cR4", "name": "Chocolate-Loving Shark 3", "author": "BobMowzie", "description": "For CIS 566: Procedural Computer Graphics\nResources used:\nhttp://iquilezles.org/www/index.htm\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nTechniques used:\nRaymarching\nCustom math functions\nLots of trial and error", "tags": ["raymarching", "homework"], "likes": 3, "viewed": 121, "published": "Public", "date": "1517975275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat floorSDF(vec3 samplePoint) {    \n    return boxSDF(samplePoint - vec3(0., -1.1, 0.), vec3(100., 1., 100.));\n}\n\nfloat crateSDF(vec3 samplePoint) {\n    float crate = udRoundBox(samplePoint, vec3(1., 0.01, 1.5), 0.05);\n    for (int i = 0; i < 3; i++) {\n    \tcrate = smin(crate, sphereSDF(samplePoint * vec3(1., 0.7, 1.) + vec3(0.5, 0., -1. + 1. * float(i)), 0.45) / length(vec3(1., 0.7, 1.)), 0.2);\n    \tcrate = smin(crate, sphereSDF(samplePoint * vec3(1., 0.7, 1.) + vec3(-0.5, 0., -1. + 1. * float(i)), 0.45) / length(vec3(1., 0.7, 1.)), 0.2);\n    }\n    float sub = udRoundBox(samplePoint - vec3(0., 1.11, 0.), vec3(1.2, 1., 1.7), 0.05);\n    for (int i = 0; i < 3; i++) {\n    \tsub = smin(sub, sphereSDF(samplePoint * vec3(1., 0.7, 1.) + vec3(0.5, 0., -1. + 1. * float(i)), 0.4) / length(vec3(1., 0.7, 1.)), 0.3);\n    \tsub = smin(sub, sphereSDF(samplePoint * vec3(1., 0.7, 1.) + vec3(-0.5, 0., -1. + 1. * float(i)), 0.4) / length(vec3(1., 0.7, 1.)), 0.3);\n    }\n    crate = differenceSDF(crate, sub);\n    crate = smin(crate, sphereSDF(samplePoint * vec3(1., 0.6, 1.) - vec3(0., -0.2, -0.5), 0.2) / 0.7, 0.3);\n    crate = smin(crate, sphereSDF(samplePoint * vec3(1., 0.6, 1.) - vec3(0., -0.2, 0.5), 0.2) / 0.7, 0.3);\n    return crate;\n}\n\nfloat eggSDF(vec3 samplePoint) {\n\tfloat eggs = MAX_DIST;\n    for (int i = 0; i < 3; i++) {\n        float myTime = 0.5 * (mod(float(iTime), 2.) + 0.15 * float(i));\n        float t = 1./(1. + pow(2., -40. * myTime + 8.)) - 1./(1. + pow(2., -40. * (myTime - 0.8)));\n        float myTime2 = 0.25 * (mod(float(iTime), 2.) + 0.15 * float(i)-0.1);\n        float t2 = 1./(1. + pow(2., -40. * myTime2 + 8.)) - 1./(1. + pow(2., -40. * (myTime2 - 1.2)));\n        float egg = sphereSDF(samplePoint * vec3(1., 0.7, 1.) - vec3(0.5 - t2, -0.05 + t*0.3, 1. - 1. * float(i)), 0.4) / length(vec3(1., 0.7, 1.));\n        for (int j = 0; j < 7; j++) {\n        \tegg = differenceSDF(egg, sdTorus((samplePoint * vec3(1., 0.7, 1.) - vec3(0.5 - t2, -0.05 + t*0.3, 1. - 1. * float(i))) * rotateY(radians(-360. * 1. * t2)) - vec3(0.11 * (float(j) - 3.), 0., 0.), vec2(0.4 - abs(0.02 * (float(j) - 3.) * (float(j) - 3.)), 0.025)));\n        }\n        eggs = unionSDF(eggs, egg);\n    }\n    return eggs;\n}\n\nfloat sharkSDF(vec3 samplePoint) {\n\tfloat shark = MAX_DIST;\n    float angle = radians(90. - 180. * mod(iTime * 0.5, 1.));\n    float r = 3. * 1./pow(pow(sin(angle), 4.) + pow(cos(angle), 4.), -1./4.);\n    float x = r * 0.7 * sin(angle + radians(45.));\n    float z = r * cos(angle + radians(45.));\n    float dx = r * 0.8 * cos(angle + radians(45.));\n    float dz = r * -sin(angle + radians(45.));\n    float myTime = mod(0.5 * (float(iTime)), 1.);\n    float t = 1./(1. + pow(2., -60. * (myTime - 0.))) + 1./(1. + pow(2., -60. * (myTime - 0.5))) + 1./(1. + pow(2., -60. * (myTime - 1.)));\n    float yaw = radians(-90. + 90. * t);\n    float wiggle = 0.1 * sin(iTime*18. + 1.5);\n    shark = udTriangle(((samplePoint - vec3(x, 0., z)) * rotateY(yaw) - vec3(wiggle, 0., 0.)) * rotateY(0.15 * sin(iTime*18.)), vec3(0., -0.8, 0.5), vec3(0., -0.8, -0.5), vec3(0., 0.3, -0.5));\n    return shark;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, int whichSurface) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = 0.;\n        if (whichSurface == 0) dist = floorSDF(eye + depth * marchingDirection);\n        else if (whichSurface == 1) dist = crateSDF(eye + depth * marchingDirection);\n        else if (whichSurface == 2) dist = eggSDF(eye + depth * marchingDirection);\n        else if (whichSurface == 3) dist = sharkSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p, int whichSurface) {\n    if (whichSurface == 0)\n    return normalize(vec3(\n        floorSDF(vec3(p.x + EPSILON, p.y, p.z)) - floorSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        floorSDF(vec3(p.x, p.y + EPSILON, p.z)) - floorSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        floorSDF(vec3(p.x, p.y, p.z  + EPSILON)) - floorSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n    else if (whichSurface == 1)\n    return normalize(vec3(\n        crateSDF(vec3(p.x + EPSILON, p.y, p.z)) - crateSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        crateSDF(vec3(p.x, p.y + EPSILON, p.z)) - crateSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        crateSDF(vec3(p.x, p.y, p.z  + EPSILON)) - crateSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n    else if (whichSurface == 2)\n    return normalize(vec3(\n        eggSDF(vec3(p.x + EPSILON, p.y, p.z)) - eggSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        eggSDF(vec3(p.x, p.y + EPSILON, p.z)) - eggSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        eggSDF(vec3(p.x, p.y, p.z  + EPSILON)) - eggSDF(vec3(p.x, p.y, p.z - EPSILON))\n    )); \n    else if (whichSurface == 3)\n    return normalize(vec3(\n        sharkSDF(vec3(p.x + EPSILON, p.y, p.z)) - sharkSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sharkSDF(vec3(p.x, p.y + EPSILON, p.z)) - sharkSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sharkSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sharkSDF(vec3(p.x, p.y, p.z - EPSILON))\n    )); \n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k, int whichSurface)\n{\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = 0.;\n        if (whichSurface == 0) h = floorSDF(ro + rd*t);\n        else if (whichSurface == 1) h = crateSDF(ro + rd*t);\n        else if (whichSurface == 2) h = eggSDF(ro + rd*t);\n        else if (whichSurface == 3) h = sharkSDF(ro + rd*t);\n        if( h<0.001 )\n            return 0.02;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity, int whichSurface) {\n    vec3 N = estimateNormal(p, whichSurface);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, int whichSurface) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(0.0,\n                          6.0,\n                          0.0);\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity, whichSurface)\n         \t\t\t\t\t\t* shadow(p, normalize(light1Pos - p), 0.1, 10., 8., 1)\n        \t\t\t\t\t\t* shadow(p, normalize(light1Pos - p), 0.1, 10., 8., 2)\n        \t\t\t\t\t\t* shadow(p, normalize(light1Pos - p), 0.1, 10., 8., 3);  \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float myTime = 1.-(mod(0.25 * (float(iTime)), 0.5) + 0.25);\n    float t = 1./(1. + pow(2., -60. * (myTime - 0.25))) + 1./(1. + pow(2., -60. * (myTime - 0.75)));\n    vec3 eye = vec3(7.0, 5.0, 7.0) * rotateY(radians(180. + 180. * t));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float distFloor = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, 0);\n    float distCrate = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, 1);\n    float distEggs = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, 2);\n    float distShark = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, 3);\n    \n    if (distFloor > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 color;\n    float closestDist = min(min(min(distFloor, distEggs), distCrate), distShark);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    if (closestDist == distFloor) {\n    \tvec3 p = eye + closestDist * worldDir;\n    \n    \tvec3 K_a = vec3(244./255., 226./255., 66./255.);\n    \tvec3 K_d = vec3(244./255., 226./255., 66./255.);\n    \tvec3 K_s = vec3(255./255., 255./255., 200./255.);\n    \tfloat shininess = 3.0;\n    \n    \tcolor = phongIllumination(K_a, K_d, K_s, shininess, p, eye, 0);\n    }\n    else if (closestDist == distCrate) {\n        vec3 p = eye + closestDist * worldDir;\n    \n    \tvec3 K_a = vec3(225./255., 225./255., 225./255.);\n    \tvec3 K_d = vec3(249./255., 247./255., 255./255.);\n    \tvec3 K_s = vec3(0./255., 0./255., 0./255.);\n    \tfloat shininess = 1.0;\n    \n    \tcolor = phongIllumination(K_a, K_d, K_s, shininess, p, eye, 1);\n    }\n    else if (closestDist == distEggs) {\n        vec3 p = eye + closestDist * worldDir;\n    \n    \tvec3 K_a = vec3(162./255., 53./255., 17./255.);\n    \tvec3 K_d = vec3(181./255., 82./255., 33./255.);\n    \tvec3 K_s = vec3(206./255., 107./255., 57./255.);\n    \tfloat shininess = 1.;\n    \n    \tcolor = phongIllumination(K_a, K_d, K_s, shininess, p, eye, 2);\n    }\n    else if (closestDist == distShark) {\n        vec3 p = eye + closestDist * worldDir;\n    \n    \tvec3 K_a = vec3(225./255., 178./255., 156./255.);\n    \tvec3 K_d = vec3(225./255., 245./255., 245./255.);\n    \tvec3 K_s = vec3(0./255., 0./255., 0./255.);\n    \tfloat shininess = 1.;\n    \n    \tcolor = phongIllumination(K_a, K_d, K_s, shininess, p, eye, 2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3cR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 171, 198, 198, 345], [347, 393, 420, 420, 567], [569, 615, 642, 642, 789], [791, 882, 928, 928, 960], [962, 1046, 1088, 1088, 1120], [1122, 1211, 1258, 1258, 1291], [1293, 1293, 1318, 1318, 1337], [1338, 1338, 1390, 1390, 1897], [1899, 2007, 2040, 2040, 2470], [2472, 2559, 2593, 2593, 2621], [2623, 2623, 2668, 2668, 2708], [2710, 2710, 2743, 2743, 2808], [2810, 2927, 2972, 3041, 3647], [3649, 3649, 3682, 3708, 3739], [3741, 3741, 3782, 3782, 3875], [3877, 4117, 4151, 4151, 4232], [4234, 4234, 4268, 4268, 5356], [7220, 7641, 7750, 7750, 8354], [8369, 8623, 8688, 8688, 8820], [8822, 8911, 8958, 8958, 10305], [10307, 10307, 10390, 10390, 10831], [10833, 11325, 11483, 11483, 12087], [12089, 12459, 12562, 12562, 13208], [13210, 13537, 13586, 13621, 13752]], "test": "error"}
{"id": "4d3yR7", "name": "Speedy spin", "author": "sidsuk", "description": "speedy spin, case study\nanimation reference: https://camo.githubusercontent.com/42bb3030573acf8ab4373f3d82a5833f0ee34d4e/68747470733a2f2f692e696d6775722e636f6d2f414930306d48752e676966", "tags": ["raymarching", "sdf", "motionblur"], "likes": 4, "viewed": 110, "published": "Public", "date": "1518132948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CIS566 Speedy Spin\n// reference: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define DEPTH 30\n#define END 1000.0\n#define EPSILON 0.001\n#define PI 3.14159265359\n\n\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat unionSDF(float a, float b) {\n    return min(a, b);\n}\n\nmat4 rotateY(float a) {\n    float c = cos(radians(a));\n    float s = sin(radians(a));\n    return mat4(\n        c, 0.0, -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        s, 0.0, c, 0.0,\n        0.0, 0.0, 0.0, 1.0);  \n}\n\nmat4 rotateX(float t) {\n\tfloat cost = cos(radians(t));\n\tfloat sint = sin(radians(t));\n\treturn mat4(\n\t\t1.0, 0.0, 0.0, 0.0,   // first column\n\t\t0.0, cost, sint, 0.0, // second column\n\t\t0.0, -sint, cost, 0.0, // third column\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n}\n\nmat4 rotateZ(float t) {\n\tfloat cost = cos(radians(t));\n\tfloat sint = sin(radians(t));\n\treturn mat4(\n\t\tcost, sint, 0.0, 0.0,   // first column\n\t\t-sint, cost, 0.0, 0.0, // second column\n\t\t0.0, 0.0, 1.0, 0.0, // third column\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n}\n\nmat4 translate(vec3 t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        t.x, t.y, t.z, 1.0\n        );\n}\n\nfloat ringSDF(vec3 p, float time) {\n    mat4 t = translate(vec3(0.0, 0.0, 0.8));\n    \n    int num = 4;\n    \n    float dist = END;\n    \n    float gap = 360.0 / float(num);\n    \n    float scale = 0.8;\n    \n    int blurNum = 30;\n    \n    for(int k = 0; k < blurNum; ++k) {\n        \n    }\n    \n    float offset = (sin(time/ scale) + time / scale);\n    \n    for(int i = 0; i < num; ++i) {\n        \n        mat4 r = rotateY(gap / 2.0 + float(i) * gap + offset * 360.0);\n        \n        mat4 transform = r * t;\n        \n        float s = sphereSDF(vec3(inverse(transform) * vec4(p, 1.0)), 0.02);\n        \n        dist = unionSDF(dist, s);\n    }\n    \n    return dist;\n}\n\n\nfloat scene(vec3 p, float time) {\n    \n    int num = 3; \n    float gap = 180.0 / float(num);\n    \n    mat4 tr = rotateY(360.0 * iTime / 2.0 / PI);\n    \n    float dist = END;\n    \n    for(int i = 0; i < num; ++i) {\n        mat4 r = rotateZ(gap * float(i));\n        \n        float s = ringSDF(vec3(inverse(tr * r) * vec4(p, 1.0)), time);\n        \n        dist = unionSDF(dist, s);\n        \n    }  \n    \n    return dist;\n}\n\n\nfloat rayMarching(vec3 origin, vec3 dir, float start, float time) {\n    float t = start;\n\tfor(int i = 0; i < DEPTH; ++i) {\n\t\tvec3 curP = origin + dir * t;\n\t\tfloat step = scene(curP, time);\n\t\tt += step;\n\t\tif(step < EPSILON) {\n\t\t\treturn t;\n\t\t}\n\t\tif(t >= END){\n\t\t\treturn END;\n\t\t}\t\n\t}\n\treturn END;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // orthographic\n    vec2 spos = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(3.0, 4.0, 8.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 dir = normalize(target - eye);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(dir, up);\n    up = cross(right, dir);\n    \n    vec3 pos = eye + right * spos.x + up * spos.y;\n    \n    int blurNum = 40;\n    vec3 sumCol = vec3(0.0);   \n    \n    for(int i = 0; i < blurNum; ++i) {\n        float delta = (float(i) / (float(blurNum) - 1.0) - 0.5) * 0.08;\n        float time = iTime + delta;\n        float t = rayMarching(pos, dir, 0.01, time);\n        vec3 col;\n        if(t >= END) {\n        \tcol = vec3(0.03, 0.03, 0.05);\n        } else {\n            col = vec3(1.0);\n        }\n        sumCol += col;\n    }\n    sumCol *= 1.5;\n    \n    fragColor =vec4(pow(sumCol / float(blurNum), vec3(1.0 / 1.5)), 1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3yR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 232, 232, 265], [267, 267, 301, 301, 325], [327, 327, 350, 350, 539], [541, 541, 564, 564, 789], [791, 791, 814, 814, 1039], [1041, 1041, 1065, 1065, 1206], [1208, 1208, 1243, 1243, 1870], [1873, 1873, 1906, 1906, 2292], [2295, 2295, 2362, 2362, 2590]], "test": "error"}
{"id": "4d3yWM", "name": "Sprawling nightmare", "author": "Flopine", "description": "Evil thing... yeurk", "tags": ["raymarching", "duplication", "poulpy"], "likes": 6, "viewed": 179, "published": "Public", "date": "1519054250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind and leon for teaching me!\n\n\n#define ITER 100\n#define PI 3.141592\n#define TAU 2.*PI\n\nmat2 rot (float angle)\n{\n \tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c);\n}\n\n\nvec2 moda (vec2 p, float per)\n{\n    float angle = atan(p.y,p.x);\n    float l = length(p);\n    angle = mod(angle-per/2.,per)-per/2.;\n    return vec2 (cos(angle),sin(angle))*l;\n}\n\nfloat cyl (vec3 p, float r)\n{\n    return length(p.yz)-r;\n}\n\nfloat sphe (vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    return length(max(abs(p)-c,0.));\n}\n\nfloat Prim_Element (vec3 p)\n{\n    float per = 2.;\n    float prim_cyl = cyl(p,1./p.x*1.5);\n    p.x -= iTime;\n    p.x = mod(p.x-per/2.,per)-per/2.;\n    float prim_sphe = sphe(p,0.4);\n    return min(prim_cyl, prim_sphe);\n}\n\nfloat tentacular_cross (vec3 p)\n{\n    p.x -= sin(-p.z+iTime);\n    p.xz= moda(p.xz, TAU/6.);  \n    return Prim_Element(p);\n}\n\nfloat tentacular_star (vec3 p)\n{\n    p.x = abs(p.x);\n    p.yz *= rot(PI/2.);\n    float one = tentacular_cross(p);\n    p.xz *= rot(PI/2.);\n    float two = tentacular_cross(p);\n    return min(one, two);\n}\n\nfloat SDF (vec3 p)\n{\n    float per = 10.;\n    //p.xy = mod(p.xy-per/2., per)-per/2.;\n    return tentacular_star(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 p = vec3 (0.001,2.,-10);\n    vec3 dir = normalize(vec3(uv, 1.));\n    float shad = 1.;\n    \n    for (int i = 0; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001 || d>30.)\n        {\n            shad = float(i)/float(ITER);\n            break;\n        }\n        p += d*dir;\n    }\n    \n    // Time varying pixel color\n    vec3 col = shad/vec3(length(p.z),0.5,0.7);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3yWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 147, 147, 226], [229, 229, 260, 260, 405], [407, 407, 436, 436, 465], [467, 467, 497, 497, 523], [525, 525, 553, 553, 592], [594, 594, 623, 623, 813], [815, 815, 848, 848, 938], [940, 940, 972, 972, 1142], [1144, 1144, 1164, 1164, 1261], [1263, 1263, 1320, 1370, 1904]], "test": "valid"}
{"id": "4dccDn", "name": "Random Convex Polygons", "author": "FigSin2Pi", "description": "Flipping through primitives. Just a small reference example.", "tags": ["2d", "primitives", "convex", "polygons"], "likes": 0, "viewed": 113, "published": "Public", "date": "1518370523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI    3.14159265358979323846\n#define PI2   6.28318530717958647693\n\n// Thanks FabriceNeyret2 for the input\n// I used some and ignored some ;)\n\n#define rand(v) fract(sin(dot( v, vec2(13.9, 21.3))) * 87877.104729)\n\n// Rotate the value around mi(n) and ma(x)\n//#define rot(mi,ma,f) (mod(f, ma-mi)+mi)\n#define rot(mi,ma,f) (mod(f, ma-mi)+mi)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 fct = vec2(iResolution.x/iResolution.y, 1.);\n    vec2 st = fct * uv;\n    \n    vec2 spc = st*2. - fct;\n    \n    // Scale the space (to fit more boxes in)\n    vec2 ispc = spc*3.;\n    \n    // Integer space (i.e. what box am I in?)\n    vec2 flr = floor(ispc);\n    \n    // Fractional space (i.e. where in the little box am I?)\n    vec2 frc = fract(ispc);\n    \n    // Center origo at center of fractional space\n    vec2 rspc = frc-0.5;\n    \n    // Polar coordinates of fractional space\n    float len = length(rspc);\n    float a = atan(rspc.y, rspc.x) + PI/2.;\n    \n    // Random value based on what box we're in\n    float ran = rand(flr);\n    \n    // Rotate around 0. and 1.\n    ran = fract(ran+iTime*0.2);\n    \n    // Number of sides of polygon\n    float n = floor(ran*3.)+3.;\n    \n    float s = PI2/n;\n    \n    // Modulate \n    float f = cos(floor(.5+a/s)*s-a)*len;\n    float shape = 1.-smoothstep(0.2, 0.22, f);\n\n    // Some color based on the random value\n    vec3 col = vec3(0.5*cos(ran+iTime), 0.25*sin(iTime)+0.5, 0.5*sin(ran+iTime));\n    \n    // Restrict the output to the shape\n    col *= shape;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dccDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 346, 403, 403, 1614]], "test": "valid"}
{"id": "4dccz7", "name": "Paw Metaballs-CIS 566", "author": "jamie2719", "description": "CIS 566 project 3", "tags": ["raymarching"], "likes": 1, "viewed": 66, "published": "Public", "date": "1518142589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.15926\n\nmat4 rotate(vec3 rot) {\n\tmat4 rx = mat4(vec4(1, 0, 0, 0),\n\t\t\t\t\tvec4(0, cos(rot.x * PI/180.0), sin(rot.x * PI/180.0), 0),\n\t\t\t\t\tvec4(0, -sin(rot.x * PI/180.0), cos(rot.x * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\tmat4 ry = mat4(vec4(cos(rot.y * PI/180.0), 0, -sin(rot.y * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 1, 0, 0),\n\t\t\t\t\tvec4(sin(rot.y * PI/180.0), 0, cos(rot.y * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\tmat4 rz = mat4(vec4(cos(rot.z * PI/180.0), sin(rot.z * PI/180.0), 0, 0),\n\t\t\t\t\tvec4(-sin(rot.z * PI/180.0), cos(rot.z * PI/180.0), 0, 0),\n\t\t\t\t\tvec4(0, 0, 1, 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\t\t\t\t\t\n\treturn rz * ry * rx;\n\t\n}\n\nmat4 translate(vec3 trans) {\n\treturn mat4(vec4(1, 0, 0, 0),\n\t\t\t\tvec4(0, 1, 0, 0),\n\t\t\t\tvec4(0, 0, 1, 0),\n\t\t\t\tvec4(trans.x, trans.y, trans.z, 1));\n}\n\n\n\nfloat sdSphere( vec3 p, float s, vec3 trans, vec3 rot) \n{\n    \n    p = vec3(rotate(rot) * vec4(p, 1));\n    \n    \n    p = vec3(translate(trans) * vec4(p, 1));\n    \n    \n    \n  \treturn length(p)-s;\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend(float A, float B)\n{\n    return smin( A, B, .9);\n}\n\n\nfloat sceneSDF(vec3 p) {\n    vec3 Ytrans = vec3(0, clamp(-8.5 * cos(iTime*1.2), -8.4, 8.4), 0);\n    vec3 Xtrans = vec3(clamp(8.5 * cos(iTime*1.2 - 1.2), -8.4, 8.4), 0, 0);\n    vec3 LtopTrans = vec3(clamp(7.0 * (cos(iTime*1.2 -.8)), -6.9, 6.9), clamp(-7.0 * (cos(iTime*1.2 -.8)), -6.9, 6.9), 0);\n    vec3 RtopTrans = vec3(clamp(-7.0 * cos(iTime*1.2 + 1.4), -6.9, 6.9), clamp(-7.0 * cos(iTime*1.2 + 1.4), -6.9, 6.9), 0);\n    \n    \n    \n    float centerBall = sdSphere(p, 3.5, vec3(cos(iTime*1.2), sin(iTime*1.2), 0), vec3(0, 0, 0));\n    float ballY = sdSphere(p, 1.5, Ytrans, vec3(0, 0, 0));\n    float ballX = sdSphere(p, 1.5, Xtrans, vec3(0, 0, 0));\n    float ballLtop = sdSphere(p, 1.5, LtopTrans, vec3(0, 0, 0));\n    float ballRtop = sdSphere(p, 1.5, RtopTrans, vec3(0, 0, 0));\n    \n    \n    float distY = distance(vec3(translate(vec3(0, 0, 0)) * vec4(p,1)), vec3(translate(Ytrans) * vec4(p,1)));\n    float distX = distance(vec3(translate(vec3(0, 0, 0)) * vec4(p,1)), vec3(translate(Xtrans) * vec4(p,1)));\n    float distLtop = distance(vec3(translate(vec3(0, 0, 0)) * vec4(p,1)), vec3(translate(LtopTrans) * vec4(p,1)));\n    float distRtop = distance(vec3(translate(vec3(0, 0, 0)) * vec4(p,1)), vec3(translate(RtopTrans) * vec4(p,1)));\n    \n    \n    if(distY <= 7.0) {\n    \tcenterBall = opBlend(centerBall, ballY);\n    }\n    else {\n    \tcenterBall = unionSDF(centerBall, ballY);\n    }\n    \n    \n    if(distX <= 7.0) {\n    \tcenterBall = opBlend(centerBall, ballX);\n    }\n    else {\n    \tcenterBall = unionSDF(centerBall, ballX);\n    }\n    \n    \n    if(distLtop <= 7.0) {\n    \tcenterBall = opBlend(centerBall, ballLtop);\n    }\n    else {\n    \tcenterBall = unionSDF(centerBall, ballLtop);\n    }\n    \n    \n    if(distRtop <= 7.0) {\n    \tcenterBall = opBlend(centerBall, ballRtop);\n    }\n    else {\n    \tcenterBall = unionSDF(centerBall, ballRtop);\n    }\n    \n    return centerBall;\n}\n\n\n\n\nvec3 toWorldSpace(vec3 p, vec3 eye, vec3 ref) {\n\tfloat fov = 75.0;\n\n\tfloat sx = (p.x);\n    float sy = (p.y);\n    float A = iResolution.x / iResolution.y;\n    float alpha = fov / 2.0 * (3.159 / 180.0);\n    vec3 forward = normalize(ref - eye);\n   \tvec3 right = normalize(cross(vec3(0, 1, 0), forward));\n   \tvec3 localUp = normalize(cross(forward, right));\n    \n\n    //convert screen point to world point\n    float len = .1;//length(forward);\n    vec3 V = (localUp * len * tan(alpha));\n    vec3 H = right * A * len *tan(alpha);\n\n    return vec3(eye + len * forward + sx * H + sy * V); //world point \n}\n\nbool raymarch(vec3 p, vec3 eye, vec3 ref) {\n    //get ray from world point\n    vec3 dir = normalize(p - eye);\n    vec3 origin = eye;\n    \n    \n    \n    float scene;\n    vec3 intersection;\n    bool intersected = false;\n    float t = 0.01;\n\tfor (int i = 0; i < 64; i++) {\n\t\tintersection = origin + dir * t;\n\t\t\n        \n        scene = sceneSDF(intersection);\n\t\t\n\t\tif(scene <= .01) {\n\t\t\tintersected = true;\n\t\t\tbreak;\n\t\t}\n\t\tt += scene;\n\t}\n   \treturn intersected;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scrPt = uv * 2.0 - 1.0; // Transform to NDC\n    scrPt *= iResolution.x / iResolution.y;\n    \n    vec3 eye =  vec3(0, 0, -8);\n    vec3 ref = vec3(0.0, 0.0, 0.0);\n    \n    \n    vec3 p = toWorldSpace(vec3(scrPt, 1), eye, ref);\n    \n    \n    vec3 col;\n    if(raymarch(p, eye, ref)) {\n        col = vec3(0, 0, 0);\n    }\n    else {\n        col = vec3(1, 1, 1);\n    }\n    \n    fragColor = vec4(col,1);\n     \n\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dccz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 43, 43, 630], [632, 632, 660, 660, 778], [782, 782, 839, 839, 979], [981, 981, 1023, 1023, 1055], [1058, 1058, 1099, 1099, 1170], [1172, 1172, 1205, 1205, 1235], [1238, 1238, 1262, 1262, 3118], [3123, 3123, 3170, 3170, 3721], [3723, 3723, 3766, 3797, 4183], [4185, 4185, 4242, 4292, 4751]], "test": "valid"}
{"id": "4dcyDM", "name": "HelloWorldSDF", "author": "felipunkerito", "description": "trying to make a snowman", "tags": ["3d", "raymarching", "sdf"], "likes": 1, "viewed": 455, "published": "Public API", "date": "1519153726", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 10.0\n#define STEPS 256\n#define EPS 0.0001\n#define PI acos( -1.0 )\n\nfloat sdSphere( vec3 p, float d )\n{\n\n    return length( p ) - d;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdPlane( vec3 p, float n )\n{\n  // n must be normalized\n  return p.y + n;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n\nfloat smin( float a, float b )\n{\n#if 0\n\tfloat k = 32.0;\n\tfloat res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n#else\n    float k = 0.1;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n#endif\t\n}\n\n\nfloat opBlend( float d1, float d2 )\n{\n    return smin( d1, d2 );\n}\n\nvec2 map( vec3 p )\n{\n    \n    float body = sdSphere( p, 1.0 );\n    p.y -= 1.4;\n    float head = sdSphere( p, 0.6 );\n    p.z -= 0.3;\n    float spheres = opBlend( body, head );\n    p.x += 1.0;\n    p.y += 0.5;\n    float rightArm = sdSphere( p, 0.4 );\n    float spheresTwo = opBlend( rightArm, spheres );\n    p.x -= 2.0;\n    float leftArm = sdSphere( p, 0.4 );\n    float spheresThree = opBlend( leftArm, spheresTwo );\n    p.y += 0.8;\n    p.x += 0.5;\n    float leftLeg = sdCapsule( p, vec3( 1.0, -1.0, 0.0 ), vec3( 0.0 ), 0.4 );\n    float spheresFour = opBlend( leftLeg, spheresThree );\n    p.y += 1.0;\n    p.x += 1.8;\n    float rightLeg = sdCapsule( p, vec3( 1.0, 1.0, 0.0 ), vec3( 0.0 ), 0.4 );\n    float spheresFive = opBlend( rightLeg, spheresFour );\n    p.x -= 1.3;\n    p.y -= 2.1;\n    float mouth = sdSphere( p, clamp( sin( iTime * 0.2 ), 0.25, 0.3 ) );\n    float spheresSix = opS( mouth, spheresFive );\n    p.x -= 0.1;\n    p.y -= 0.2;\n    float leftEye = sdSphere( p, 0.3 );\n    float spheresSeven = opS( leftEye, spheresSix );\n    p.x += 0.2;\n    float rightEye = sdSphere( p, 0.3 );\n    float sphereEight = opS( rightEye, spheresSeven );\n    p.y += 1.8;\n    vec2 plane = vec2( sdPlane( p, 1.0 ), 0.0 );\n    p.x -= 0.1;\n    p.y -= 0.3;\n    p.z -= 0.7;\n    float bellyButton = sdSphere( p, 0.1 );\n    vec2 finish = vec2( opS( bellyButton, sphereEight ), 1.0 );\n    \n    if( plane.x < finish.x ) finish = plane;\n    \n    return finish;\n    \n}\n\nvec3 grad( vec3 p )\n{\n    \n    vec2 e = vec2( 0.0, EPS );\n    vec3 n = vec3( map( p + e.yxx ).x - map( p - e.yxx ).x,\n                   map( p + e.xyx ).x - map( p - e.xyx ).x,\n                   map( p + e.xxy ).x - map( p - e.xxy ).x\n     \t\t\t  );\n    return n;    \n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n    float res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n        \n        float h = map( ro + rd * t ).x;\n        \n        if( h < 0.001 ) return 0.0;\n        res = min( res, 4.0 * h / t );\n        t += h;\n    \n    }\n    \n    return res;\n    \n}\n\nvec3 shade( vec3 ro, vec3 rd, float t )\n{\n\tvec3 pos = ro + rd * t;\n    vec3 n = normalize( grad( pos ) );\n    \n    vec3 lig = normalize( vec3( cos( iTime ), 0.8, sin( iTime ) ) );\n    vec3 blig = vec3( -lig.x, -lig.y, -lig.z );\n    vec3 ref = reflect( rd, n );\n    \n    float dif = max( 0.0, dot( n, lig ) );\n    float bac = max( 0.0, 0.2 + 0.8 * dot( n, blig ) );\n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 16.0 ); \n    float con = 1.0;\n    float sha = softShadows( pos, lig );\n    float amb = 0.5 + 0.5 * n.y;\n    \n    vec3 col = con * vec3( 0.1, 0.15, 0.2 );\n    col += amb * vec3( 0.1, 0.15, 0.2 );\n    col += dif * vec3( 1.0, 0.97, 0.85 ) * sha;\n    col += bac * vec3( 1.0, 0.97, 0.85 );\n    \n    col = sqrt( col );\n    col *= 0.6;\n    \n    if( map( pos ).y == 0.0 )\n    {\n        \n        col *= vec3( 1.5, 0.0, 0.0 );\n        \n        \n    }\n    \n    else\n    {\n    \n        col *= vec3( 1.4 );\n        col += 1.0 * spe;\n    }\n    \n    if( pos.x < 1.5 && pos.y > 1.6 )\n    {\n    \n        col *= vec3( 0.0 );\n        \n    }\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = 0.0;\n    float d = EPS;\n    \n    vec4 mouser = iMouse / iResolution.xyxy;\n    \n    vec3 ro = 3.5 * vec3( sin( mouser.x * PI * 2.0 ), 0.0, cos( -mouser.x * PI * 2.0 ) );\n    //vec3 rd = normalize( vec3( uv, -1.0 ) );\n    vec3 ww = normalize( vec3( 0.0 ) - ro );\n    vec3 uu = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    vec3 rd = vec3( uu * uv.x + vv * uv.y + 1.5 * ww  );\n    \n    for( int i = 0; i < STEPS; ++i )\n    {\n     \n        d = 0.5 * map( ro + rd * t ).x;\n        \n        if( d < EPS || t > FAR ) break;\n        t += d;\n    \n    }\n    \n    // Time varying pixel color\n    vec3 col = d < EPS ? shade( ro, rd, t ) : mix( vec3( 0.2, 0.4, 0.5 ), vec3( 1.0 ), uv.y );\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 114, 114, 145], [147, 147, 199, 199, 326], [328, 328, 362, 388, 408], [410, 410, 443, 443, 468], [470, 470, 503, 503, 529], [531, 531, 564, 564, 589], [592, 592, 624, 624, 835], [838, 838, 875, 875, 904], [906, 906, 926, 926, 2349], [2351, 2351, 2372, 2372, 2620], [2622, 2622, 2667, 2667, 2922], [2924, 2924, 2965, 2965, 3995], [3997, 3997, 4054, 4104, 5018]], "test": "valid"}
{"id": "4dcyW7", "name": "Retro Sun", "author": "FraglessPlayer", "description": "Retro sun test effect", "tags": ["suneffect"], "likes": 16, "viewed": 947, "published": "Public", "date": "1519250687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tri(t, scale, shift) ( abs(t * 2. - 1.) - shift ) * (scale)\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 R = iResolution.xy,\n    uv = ( fragCoord - .5* R ) / R.y + .5;\n    \n    // sun\n    float dist = length(uv-vec2(0.5,0.5));\n    float divisions = 6.0;\n    float divisionsShift= 0.5;\n\t\n    float pattern = tri(fract(( uv.y + 0.5)* 20.0), 2.0/  divisions, divisionsShift)- (-uv.y + 0.26) * 0.85;\n    float sunOutline = smoothstep( 0.0,-0.015, max( dist - 0.315, -pattern)) ;\n   \n    vec3 c = sunOutline * mix(vec3( 4.0, 0.0, 0.2), vec3(1.0, 1.1, 0.0), uv.y);  \n    \n    // glow \n    float glow = max(0.0, 1.0 - dist * 1.25);\n    glow = min(glow * glow * glow, 0.325);\n    c += glow * vec3(1.5, 0.3, (sin(iTime)+ 1.0)) * 1.1;\n\n \n    vec2 ground;\n    \n    vec2 planeuv = uv;\n /* ground in progress\n    planeuv.x =  (planeuv.x - 0.5) * (-planeuv.y) + 0.5;\n    //    planeuv.y *= planeuv.y; \n    \n    planeuv.y += (iTime  ) * 0.13;\n    ground.x = tri(fract(( planeuv.x + 0.5)* 10.0), 1.0/10.0, 0.0);\n    ground.y = tri(fract(( planeuv.y + 0.5)* 10.0), 1.0/10.0, 0.0);     \n    \n    float groud_lines = smin(ground.x,ground.y, 0.015);\n   \tfloat ground_glow = smin(ground.x,ground.y, 0.06);\n    \n    float ground_line_color =  smoothstep( 0.01,-0.01, groud_lines);\n    float ground_color =  smoothstep( 0.08,-0.0, ground_glow);\n    c = vec3(1.5,2,1) * ground_line_color + vec3(0.1,0.2,0.4) *ground_color;*/\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcyW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 110, 110, 203], [205, 205, 262, 262, 1596]], "test": "valid"}
{"id": "4dcyzH", "name": "Portal to another dimension", "author": "teaearlgraycold", "description": "Looks kinda like Rick's inter-dimensional portals.", "tags": ["portal"], "likes": 3, "viewed": 645, "published": "Public API", "date": "1517881957", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535;\nconst float TAU = 2.0 * PI;\n\nfloat snoise(vec2 v);\nvec3 hsv2rgb(vec3 c);\nmat2 rotate(float t);\n\nvec4 draw_texture(vec2 pos) {\n    float wobbly_edge = snoise(pos * 10.0) * 0.03;\n    float value = length(pos) > (0.43 + wobbly_edge) ? 0.0 : 0.7;\n    float hue = length(pos);\n    return vec4(hsv2rgb(vec3(hue, 0.62, value)), 1.0);\n}\n\nvec4 draw_circle(vec2 pos, float radius, float rotate_angle) {\n    pos = rotate(rotate_angle) * pos;\n    float angle = atan(pos.y, pos.x);\n    float wobbly_edge = snoise(pos * 15.1) * 0.03;\n\n    if (length(pos) < (radius + wobbly_edge)) {\n        return vec4(0.0, 0.0, 0.0, 0.32);\n    } else {\n        return draw_texture(pos);\n    }\n}\n\nvec4 draw(vec2 pos) {\n    vec4 color = vec4(vec3(1.0), 0.0);\n    float t = iTime * 0.75;\n    float num_circles = 6.0;\n\n    for (float i = 0.0; i < num_circles; ++i) {\n        // Wiggle the circles around\n        float offset_size = (num_circles - (i + 1.0)) * 0.0125;\n        float angle = offset_size * PI / 32.0;\n        vec2 offset = vec2(cos(t + angle), sin(t + angle)) * vec2(offset_size);\n        // Circle size\n        float radius = i * 0.04 + 0.15;\n\n        // Rotate each circle in turn\n        // Get a float value from 0..num_circles (don't rotate the last circle)\n        float circle_to_rotate = mod(t / PI, num_circles - 1.0);\n        // Get the fractional component of the value\n        float rotate_index = mod(circle_to_rotate, 1.0) * TAU;\n        // How much to rotate if this is the circle to rotate\n        float rotate_amount = (sin(rotate_index + 3.0 * PI / 2.0) + 1.0) / 2.0 * PI;\n        // Actual rotation amount (0.0 if not rotating)\n        float rotate_angle = floor(circle_to_rotate) == i ? rotate_amount : 0.0;\n\n        // Location on the buffer\n        vec2 st = vec2(-0.4, 0.0) + offset + pos / iResolution.xy * vec2(iResolution.x / iResolution.y, 1.0);\n        vec2 pos = vec2(0.5) - st;\n\n        // Draw the sample\n        vec4 circle = draw_circle(pos, radius, rotate_angle);\n        color = mix(color, circle, circle.a);\n    }\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = draw(fragCoord);\n}\n\n\nmat2 rotate(float t) {\n    return mat2(\n        cos(t), -sin(t),\n        sin(t),  cos(t)\n    );\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Noise shit\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(\n         0.211324865405187, // (3.0-sqrt(3.0))/6.0\n         0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n        -0.577350269189626, // -1.0 + 2.0 * C.x\n         0.024390243902439  // 1.0 / 41.0\n    );\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m * m * m * m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcyzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 156, 156, 359], [361, 361, 423, 423, 696], [698, 698, 719, 719, 2082], [2084, 2084, 2141, 2141, 2176], [2179, 2179, 2201, 2201, 2276], [2278, 2278, 2300, 2300, 2469], [2471, 2485, 2506, 2506, 2557], [2559, 2559, 2580, 2580, 2631], [2633, 2633, 2655, 2655, 2700], [2702, 2702, 2724, 2724, 3719]], "test": "error"}
{"id": "4dcyzM", "name": "Volcanic archipelagus", "author": "cyanpencil", "description": "Procedural generator of volcanic archipelagos.\nChange seed in code to generate another random terrrain.\nMove camera with mouse.\n\n", "tags": ["distancefields", "water", "reflections", "softshadows", "raymarcing", "volcano", "sunreflection"], "likes": 6, "viewed": 794, "published": "Public API", "date": "1518126074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#version 330 core\n#define PI 3.1415926535897932384626433832795\n#define inf 9e100\n\n/**\n\tGenerates terrain with fbm noise.\n\tVolcano is always centered in the origin.\n\tVolcano elevation is calculated as e^(-sqrt(x^2+y^2)), and summed to fbm.\n\tChangingin the seed generates a new archipelagus.\n\tDrag the mouse to move the camera.\n\tAll the variables declared here at the start are parameters that can be \n\tchanged, I hope they are not that obscure.\n\n\tSpecial thanks to Inigo Quielez, his awesome work is truly inspiring,\n\tand his tutorials are amazing.\n\tThanks also to Frankenburg's water shader, and nimitz's lens flare shader.\n\tFinally, thanks also to my sister who gave some fundamental artistic advice.\n\n\tHere is a short pdf I made to explain a bit better how this was made:\n\thttps://drive.google.com/open?id=1U4zynGm8o4i8VodnaWTOjgoayj9rhega\n\n\tThis is my first shader so please understand if it's not\n\tthat orignal or well done...\n*/\n\n\n\nfloat seed = 104.0;             //input a float < 10000.0 to generate terrain \n\n\n// --------- TERRAIN GENERATION OPTIONS\nint fbm_octaves = 11;            //octaves for the terrain generator. More octaves = more details\nfloat elevate = 2.0;             //height of volcano\nfloat crater_width = 0.05;       //width and depth of the crater\nfloat large = 1.5;               //width of volcano (higher = thinner)\nfloat water_level = 130.0;       //starting height of water. Set to a very low number to remove water\nfloat wavegain = 0.3;            //roughness of the water\n\n\n// ----------- RENDERING OPTIONS -----------\nint AA = 1;                      //antialias\nfloat camera_distance = 250.0;   //distance of camera from origin\nfloat jitter_factor = 2.0;       //jitter when too close to object\nint max_raymarching_steps = 128; //increase if you see artifacts near object edges\nfloat max_distance = 5000.0;     //max rendering distance\nfloat step_size = 0.75;          //decrease if you see artifacts near slopes\n\n\n//toggle between 0 and 1\nint shadows = 1; \nint water_refl = 1; \nint clouds = 0;\nint gamma = 0;\nint lens_flare = 0;\nint hq_water = 1;\nint lava = 0;\t\t\t\t\t //just a red light on the crater \n\nint sha_octaves = 6;             //octaves for shadows\nfloat sha_stepsize = 3.0;        //shadow step size. Decrease if there are artifacts in shadows \nfloat softshadows = 7.0;         //Increase to have harder shadows\n\nfloat fog = 0.3;                 //fog level. Set between 0 and 1\nfloat sun_dispersion = 0.5;\t     //sun dispersion in fog\n\n\n\n\nconst vec3  kSunDir = normalize(vec3(-0.624695,0.168521,-0.624695)); \nvec3 _LightDir = kSunDir*100000.0; \nvec3 _CameraDir = normalize(vec3(7,1.2,5))*5.00;\n\nfloat ka = 0.05;                 //ambient light\nfloat kd = 0.2;\t\t\t         //diffuse light\n\n\n\n\n\n// --  Value noise by Inigo Quielez: http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\nfloat hash2( vec2 p ) {\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float a = hash2(p+vec2(0,0));\n    float b = hash2(p+vec2(1,0));\n    float c = hash2(p+vec2(0,1));\n    float d = hash2(p+vec2(1,1));\n\n    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );\n}\n\nvec3 noised2( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash2(p+vec2(0,0));\n    float b = hash2(p+vec2(1,0));\n    float c = hash2(p+vec2(0,1));\n    float d = hash2(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\n\nmat2 m2 = mat2(  0.80,  0.60, -0.60,  0.80 );\nmat2 m2i = mat2( 0.80, -0.60, 0.60,  0.80 );\n\nfloat fbm( in vec2 x, int octaves) {\n    float f = 1.9;\n    float s = 0.50;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i< octaves; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\n//returns fbm with derivatives\nvec3 fbmd( in vec2 x , int octaves) {\n    float f = 1.9;\n    float s = 0.50;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=0; i< octaves; i++ )\n    {\n        vec3 n = noised2(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yz;       // accumulate derivatives\n        b *= s;\n        x = f*m2*x;\n        m = f*m2i*m;\n    }\n\treturn vec3( a, d );\n}\n\n\n// -- Sky adapted from Inigo quielez's shader: https://www.shadertoy.com/view/4ttSWf\nvec3 renderSky( in vec3 ro, in vec3 rd ) {\n    vec3 col = vec3(0);\n\n\n    // clouds\n    if (clouds > 0) {\n        float t = (1000.0-ro.y)/rd.y;\n        if( t>0.0 ) {\n            vec2 uv = (ro+t*rd).xz;\n            float cl = fbm( uv*0.001 + vec2(-100.0, 20.0) , fbm_octaves);\n            float dl = smoothstep(-0.2,0.6,cl);\n            col = mix( col, vec3(1.0), 0.4*dl );\n        }\n    }\n\n    float sundot = clamp(dot(kSunDir,rd), 0.0, 1.0 );\n    col += mix(vec3(1.0,0.1,0.1)*1.1, normalize(vec3(172, 133, 102)), rd.y*rd.y + 0.588*(1.0 - sundot));\n\n    col += normalize(vec3(250,206,150))*pow(sundot,2048.0)*20.0;\n    col += normalize(vec3(250,206,14)) *pow(sundot,64.0);\n    col += normalize(vec3(244,162,5))  *pow(sundot,5.0);\n\n    //horizon\n    col = mix( col, 0.5*normalize(vec3(118,34,8)), pow( 1.0-max(rd.y + 0.1,0.0), 10.0 ) );\n\n    return col;\n}\n\n\n\n//length of a vector with derivatives\nvec3 length_d(vec2 p) {\n    vec3 res = vec3(0);\n    float size = p.x*p.x + p.y*p.y;\n    res.x = pow(size, 0.5);\n    res.y = pow(size, -0.5)*p.x;\n    res.z = pow(size, -0.5)*p.y;\n    return res;\n}\n\n\nfloat length_n(vec2 p, float exponent) {\n    float size = pow(p.x, exponent) + pow(p.y, exponent);\n    return pow(size, 1.0/exponent);\n}\n\nfloat terrainMap(in vec2 p, int octaves) {\n    float sca = 0.0010;\n    float amp = 300.0;\n    p *= sca;\n    float e = fbm(p + vec2(1.0, -2.0)*(1.0 + seed), octaves);\n\n    float length2 = length(p);\n    e += elevate*exp(-large*(max(length2, crater_width))); //volcano\n    if (length2 < crater_width) {\n        e -= 2.0 * (crater_width - length2); //crater\n    }\n\n    e *= amp;\n    return e;\n}\n\n//return terrain map with normal coordinates \nvec4 terrainMapD( in vec2 p ) {\n    float sca = 0.0010;\n    float amp = 300.0;\n    p *= sca;\n    vec3 e = fbmd( p + vec2(1.0,-2.0)*(1.0 + seed) , fbm_octaves);\n\n\n    vec3 length2 = length_d(p);\n    e.x += elevate*exp(-large*(max(length2.x, crater_width))); //volcano\n    if (length2.x < crater_width) {\n        e.x -= 2.0 * (crater_width - length2.x); //crater\n        //crater derivatives\n        e.y -= 2.0 * -length2.y;\n        e.z -= 2.0 * -length2.z;\n    }\n    else {\n        //volcano derivatives\n        e.y += elevate*exp(-large*(max(length2.x, crater_width)))*(-large*length2.y);\n        e.z += elevate*exp(-large*(max(length2.x, crater_width)))*(-large*length2.z);\n    }\n\n    e.x *= amp;\n    e.yz *= amp*sca;\n    return vec4( e.x, normalize( vec3(-e.y,1.0,-e.z) ) );\n}\n\n\n\n// -- Fog function adapted from Inigo's tutorial: http://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 applyFog(in vec3 rgb, in float dist, in vec3 ro, in vec3  rayDir, in vec3  sunDir )\n{\n    float fogAmount = 1.0 - exp( -(dist*dist/max_distance)*((fog*fog) / 200.0) );\n    float sunAmount = clamp( dot( rayDir, sunDir ), 0.0, 1.0 );\n    vec3 fogColor  = mix( 0.5*normalize(vec3(118,34,8)), vec3(1.0,0.9,0.1), \n            pow(sunAmount, (0.5/(sun_dispersion)) * 8.0 * ((dist) / 1000.0)) );\n    return mix(rgb, fogColor, fogAmount );\n}\n\n\n// -- Lens Flare adapted from nimitz's shader: https://www.shadertoy.com/view/XtS3DD\nfloat pent(in vec2 p) {\n    vec2 q = abs(p);\n    return max(max(q.x*1.176-p.y*0.385, q.x*0.727+p.y), -p.y*1.237)*1.;\n}\n\nfloat circle(in vec2 p){\n    return length(p);\n}\n\nvec3 flare(vec2 p, vec2 pos) \n{\n\tvec2 q = p-pos;\n    vec2 pds = p*(length(p))*0.75;\n\tfloat a = atan(q.x,q.y);\n    float rz = 0.0;\n\n    vec2 p2 = mix(p,pds,-.5); //Reverse distort\n    rz += max(0.01-pow(circle(p2 - 0.2*pos),1.7),.0)*3.0;\n    rz += max(0.01-pow(pent(p2 + 0.4*pos),2.2),.0)*3.0;\n    rz += max(0.01-pow(pent(-(p2 + 1.*pos)),2.5),.0)*5.0;\n    rz += max(0.01-pow(pent(-(p2 - .5*pos)),2.),.0)*4.0;\n    rz += max(0.01-pow(circle(-(p2 + 1.8*pos)),3.0),.0)*3.0;\n\n    rz *= (1.0 - length(q));\n    rz *= 5.0;\n\n    return vec3(clamp(rz,0.,1.));\n}\n\n\n// -- Water adapted from frankenburg's shader: https://www.shadertoy.com/view/4sXGRM\nfloat large_waveheight = 0.7; \nfloat small_waveheight = 1.0; \nvec3 watercolor  = vec3(0.2, 0.25, 0.3);\nfloat water( vec2 p ) {\n    vec2 shift2 = 0.0003*vec2( iTime*190.0*2.0, -iTime*130.0*2.0 );\n\n    float wave = 0.0;\n    wave += sin(p.x * 0.021  +                     shift2.x)         * 4.5;\n    wave += sin(p.x * 0.0172 +p.y        * 0.010 + shift2.x * 1.121) * 4.0;\n    wave -= sin(p.x * 0.00104+p.y        * 0.005 + shift2.x * 0.121) * 4.0;\n    wave += sin(p.x * 0.02221+p.y        * 0.01233+shift2.x * 3.437) * 5.0;\n    wave += sin(p.x * 0.03112+p.y        * 0.01122+shift2.x * 4.269) * 2.5 ;\n    wave *= large_waveheight;\n    wave -= fbm(p*0.004-shift2*.5 + vec2(1.0, -2.0), fbm_octaves)*small_waveheight*24.;\n\n    return water_level + wave;\n}\n\n\n// Pseudo-random number generator adapted from: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n    return fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\n\nvec4 raymarch_terrain(vec3 ro, vec3 rd) {\n    vec4 ret = vec4(0,0,0,0);\n\n    float t = 0.01; // current distance traveled along ray\n    for (int i = 0; i < max_raymarching_steps; ++i) {\n        if (t > max_distance) break;\n        vec3 p = ro + rd * t; //point hit on the surface\n        float terrain = terrainMap(p.xz, fbm_octaves);\n        float d = p.y - terrain;\n\n\n        if (p.y < water_level) {\n            if (hq_water == 0) return vec4(0,0,1,0);\n            t = ((water_level - ro.y) / rd.y); //adjust position to remove water artefacts\n            p = ro + rd * t;\n            vec3 col = vec3(0.0);\n\n            // calculate water-mirror\n            vec2 xdiff = vec2(0.1, 0.0)*wavegain*4.;\n            vec2 ydiff = vec2(0.0, 0.1)*wavegain*4.;\n\n            // get the reflected ray direction\n            vec3 rd_bis = reflect(rd, normalize(vec3(water(p.xz-xdiff) - water(p.xz+xdiff), 1.0, water(p.xz-ydiff) - water(p.xz+ydiff))));\n            float refl = 1.0-clamp(dot(rd_bis,vec3(0.0, 1.0, 0.0)),0.0,1.0);\n\n\n            //reflection\n            vec3 refl_col = renderSky(p, rd_bis);\n            // raymarch to see if the sky is visible\n            if (rd_bis.y > 0.0 && water_refl > 0) {\n                vec3 myro = p;\n                vec3 myrd = rd_bis;\n                float tt = 0.1;\n                vec3 pp = p;\n                for (int j = 0; j < max_raymarching_steps; j++) {\n                    if (tt > max_distance)  break;\n                    pp = myro + myrd * tt; \n                    terrain = terrainMap(pp.xz, sha_octaves);\n                    d = pp.y - terrain;\n                    if (d < 0.001*tt) {\n                        refl_col = normalize(vec3(114, 53, 6))/2.0;\n                        break;\n                    }\n                    tt += sha_stepsize*step_size * d;\n                }\n            }\n\n\n\n            col = refl*0.5*refl_col;\n            col += watercolor;\n\n            col -= vec3(.3,.3,.3);\n\n            terrain = terrainMap(p.xz, fbm_octaves);\n\n            col += vec3(.15,.15,.15)*(clamp(20.0 / (water_level - terrain), 0.0, 1.0));\n            col = applyFog(col, t, ro, rd, kSunDir);\n\n            //fading away in the distance\n            float alpha = pow(t / max_distance, 3.0);\n            if (alpha > 0.2) \n                col = mix(col, renderSky(ro, rd), alpha - 0.2);\n\n\n            return vec4(col, 1);\n\n        }\n\n\n        if (d < 0.002 * t) { \n            vec3 n = terrainMapD(p.xz).yzw;\n            vec3 col = vec3(ka);\n\n            //lights\n            float diffuse_sun = clamp(kd * dot(kSunDir, n), 0.0, 1.0);\n            float indirect_sun = clamp(dot(n, normalize(kSunDir*vec3(-1.0, 0.0, -1.0))), 0.0, 1.0);\n            float diffuse_sky = clamp(0.5 + 0.5*n.y, 0.0, 1.0);\n\n            //shadows\n            float shadow = 1.0;\n            if (diffuse_sun > 0.01 && shadows > 0) {\n                vec3 myro = p + kSunDir*15.0; //Start a bit higher than terrain. Helps when sha_octaves is low (< 5)\n                vec3 myrd = kSunDir;\n                float tt = 0.1;\n                for (int j = 0; j < max_raymarching_steps; j++) {\n                    if (tt > max_distance) break;\n                    p = myro + myrd * tt; \n                    terrain = terrainMap(p.xz, sha_octaves);\n                    d = p.y - terrain;\n                    if (d < 0.001*tt) {\n                        shadow = 0.0;\n                        break;\n                    }\n                    shadow = min(shadow, softshadows*(d/tt));\n                    tt += sha_stepsize*step_size * d;\n                }\n            }\n\n\n\n            col += diffuse_sun * normalize(vec3(250,206,14))* pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\n            col += indirect_sun *  vec3(0.40, 0.28, 0) * 0.14; \n            col += diffuse_sky * vec3(0.596, 0.182, 0.086) * 0.2;\n\n            if (lava > 0) {\n                float lava_height = terrainMap(vec2(0), fbm_octaves) + 50.0;\n                float diffuse_lava = 0.031*clamp(dot(n, normalize(vec3(0.0,lava_height, 0.0))), 0.0, 1.0);\n                col += 100000.0 * 0.013 * vec3(1,.1,.1) / (p.x*p.x + (p.y-lava_height)*(p.y-lava_height) + p.z*p.z);\n            }\n\n            // far away terrain fades away\n            float alpha = pow(t / max_distance, 3.0);\n            if (alpha > 0.2) \n                col = mix(col, renderSky(ro, rd), alpha - 0.2);\n            \n            col = applyFog(col, t, ro, rd, kSunDir);\n\n            return vec4(col, 1);\n        }\n\n        t += d*step_size;\n    }\n\n    vec3 sky = renderSky(ro, rd); \n    return vec4(sky.xyz, 1.0);\n}\n\n//Adapted from: https://github.com/zackpudil/raymarcher/blob/master/src/shaders/scenes/earf_day.frag\nmat3 camera(vec3 e, vec3 l) {\n    vec3 f = normalize(l - e);\n    vec3 r = cross(vec3(0, 1, 0), f);\n    vec3 u = cross(f, r);\n    \n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //camera movement\n    if (iMouse.y != 0.0) {\n        _CameraDir.y =  max(5.0*(iMouse.y / iResolution.y - 0.5)*3.0,0.70); // to avoid going underwater\n        _CameraDir.z = -5.0*cos(iMouse.x / iResolution.x * 2.0 * PI);\n        _CameraDir.x = -5.0*sin(iMouse.x / iResolution.x * 2.0 * PI);\n    }\n    _CameraDir *= camera_distance;\n\n    fragColor = vec4(0);\n\n    for (int m = 0; m < AA; m++) {\n        for (int n = 0; n < AA; n++) {\n            vec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy) + vec2(float(n) * (1.0/(iResolution.x * float(AA))), float(m) * (1.0/(iResolution.y * float(AA))));\n            uv.x *= iResolution.x/iResolution.y;\n\n            vec3 rd = camera(_CameraDir, vec3(0.0, 200.0, 0.0))*normalize(vec3(uv, 2.0));\n\n            fragColor += raymarch_terrain(_CameraDir, rd);\n\n            if (lens_flare > 0) {\n                vec3 sunpos = inverse(camera(_CameraDir, vec3(0)))*kSunDir;\n                if (sunpos.z > 0.0) fragColor += vec4(flare(uv, sunpos.xy), 1);\n            }\n        }\n    }\n\n    fragColor /= float(AA*AA);\n    if (gamma > 0) fragColor = pow(fragColor, vec4(1.0 / 2.2));\n}    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcyzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2739, 2839, 2862, 2862, 2939], [2941, 2941, 2967, 2967, 3272], [3274, 3274, 3301, 3301, 3833], [3928, 3928, 3964, 3964, 4184], [4186, 4217, 4254, 4254, 4658], [4661, 4746, 4788, 4788, 5599], [5603, 5641, 5664, 5664, 5836], [5839, 5839, 5879, 5879, 5975], [5977, 5977, 6019, 6019, 6368], [6370, 6416, 6447, 6447, 7194], [7198, 7299, 7389, 7389, 7737], [7740, 7825, 7848, 7848, 7943], [7945, 7945, 7969, 7969, 7993], [7995, 7995, 8026, 8026, 8545], [8736, 8736, 8759, 8759, 9383], [9386, 9478, 9498, 9498, 9561], [9564, 9564, 9605, 9605, 14123], [14125, 14226, 14255, 14255, 14383], [14385, 14385, 14442, 14469, 15565]], "test": "error"}
{"id": "4ddcRN", "name": "Cubic Honeycombs", "author": "mla", "description": "3d honeycombs using the Wythoff construction.\n\nMouse to zoom and rotate\nSee code for keys.", "tags": ["3d", "raymarch", "honeycomb", "wythoff"], "likes": 16, "viewed": 2460, "published": "Public API", "date": "1518127768", "time_retrieved": "2021-10-01T00:00:00", "image_code": " ////////////////////////////////////////////////////////////////////////////////\n//\n// Created by Matthew Arcus, 2018.\n//\n// Cubic honeycombs using the Wythoff construction.\n//\n// 'm': smooth transition between Wythoff symbols\n// 'a': control Wythoff symbol with keys '1'-'4'\n// 'i': invert in origin\n// 'c': translate Wythoff point to origin (before inversion)\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool invert = false;\nbool centre = false;\nbool morph = true;\n\nconst float scale = 1.0;\n\nvec4 tri0 = vec4(1,1,1,1);\n\nconst float fudge = 0.5; // Try to cope with non-linearity of inversion\n\nconst float sscale = 1.5;\nconst float swidth = sscale*0.05;\nconst float swidth2 = swidth*swidth;\nconst float twidth = sscale*0.02;\nconst float twidth2 = twidth*twidth;\n\nconst float PI =  3.141592654;\nconst float TWOPI =  2.0*PI;\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\n// Setup folding planes and vertex\n\n// Vertices of fundamental region\nconst vec3 p0 = vec3(0,0,0);\nconst vec3 q0 = vec3(1,0,0);\nconst vec3 r0 = vec3(1,1,0);\nconst vec3 s0 = vec3(1,1,1);\n\n// The reflecting planes\n// Also the directions of the edges from the fundamental point\nconst float K = 1.41421356;\nconst vec3 P = vec3(-1, 0, 0); // Distance 1 from origin\nconst vec3 Q = 0.5*K*vec3(1,-1, 0);\nconst vec3 R = 0.5*K*vec3(0, 1,-1);\nconst vec3 S = vec3(0, 0, 1);\n\nvec4 tri2bary = vec4(1,K,K,1);\nvec3 a; // Wythoff point\n\nvoid init(vec4 tri) {\n  tri *= tri2bary;\n  a = tri[0]*p0 + tri[1]*q0 + tri[2]*r0 + tri[3]*s0;\n  a /= dot(tri,vec4(1));\n}\n\nvec3 fold(vec3 p, out float iscale) {\n  iscale = 1.0;\n  if (invert) {\n    float r2 = dot(p,p);\n    p /= r2;\n    iscale = fudge*r2;\n  }\n  if (centre) p = p+a; // Centre on Wythoff point rather than origin (ie. one of the polyhedra)\n\n  // Fold in to unit cube\n  // Make sure origin goes to origin\n  p = mod(1.0+p,2.0)-1.0;\n  p = abs(p);\n  // Now flip into main tetrahedron\n  p -= 2.0*min(0.0,dot(p,Q))*Q;\n  p -= 2.0*min(0.0,dot(p,R))*R;\n  p -= 2.0*min(0.0,dot(p,Q))*Q;\n  return p;\n}\n\nfloat scene(vec3 p) {\n  float d = 1e8;\n  p -= a; // Centre on Wythoff point\n  float dP = dot(p,P), dQ = dot(p,Q), dR = dot(p,R), dS = dot(p,S);\n  d = min(d,length(p)-swidth); // The vertex\n  d = min(d,max(dP,length(p-dP*P)-twidth)); // The four edges\n  d = min(d,max(dQ,length(p-dQ*Q)-twidth));\n  d = min(d,max(dR,length(p-dR*R)-twidth));\n  d = min(d,max(dS,length(p-dS*S)-twidth));\n  return d;\n}\n\nfloat eval(vec3 p) {\n  float iscale;\n  p *= scale;\n  p = fold(p,iscale);\n  float d = scene(p);\n  d *= iscale;\n  d /= scale;\n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n  const vec2 e = vec2(0.0001, 0.0);\n  return normalize(vec3(eval(p + e.xyy) - eval(p - e.xyy),\n                        eval(p + e.yxy) - eval(p - e.yxy),\n                        eval(p + e.yyx) - eval(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float maxd = 25.0;\n  const float precis = 0.0002;\n  float h = precis * 2.0;\n  float t = 0.0;\n  float res = 1e8;\n  for (int i = 0; i < 200; i++) {\n    if (h < precis || t > maxd) break;\n    h = eval(ro + rd * t);\n    // When inverting, limit step size to prevent\n    // overshoot when coming in from a distance.\n    if (invert) h = min(h,0.5);\n    t += h;\n  }\n  if (t < maxd) res = t;\n  return res;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,phi);\n    p.zx = rotate(p.zx,phi);\n  }\n  float t = iTime;\n  p.yz = rotate(p.yz,t * 0.125);\n  p.zx = rotate(p.zx,t * 0.2);\n  return p;\n}\n\nvec3 getcolor(vec3 p) {\n  float iscale;\n  p *= scale;\n  p = fold(p,iscale);\n  p -= a; // Centre on Wythoff point\n  float dP = dot(p,P), dQ = dot(p,Q), dR = dot(p,R), dS = dot(p,S);\n  float d0 = length(p)-swidth; // The vertex\n  float d1 = max(dP,length(p-dP*P)-twidth); // The four edges\n  float d2 = max(dQ,length(p-dQ*Q)-twidth);\n  float d3 = max(dR,length(p-dR*R)-twidth);\n  float d4 = max(dS,length(p-dS*S)-twidth);\n  int colindex = 0;\n  float d = d0;\n  if (d1 < d) { colindex = 1; d = d1; }\n  if (d2 < d) { colindex = 2; d = d2; }\n  if (d3 < d) { colindex = 3; d = d3; }\n  if (d4 < d) { colindex = 4; d = d4; }\n  if (colindex == 1) return 0.5*vec3(0,1,0);\n  if (colindex == 2) return 0.6*vec3(0,0,1);\n  if (colindex == 3) return 0.6*vec3(1,1,0);\n  if (colindex == 4) return 0.8*vec3(1,0,0);\n  return 0.1*vec3(1);\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_1 = 49;\nconst int CHAR_2 = 50;\nconst int CHAR_3 = 51;\nconst int CHAR_4 = 52;\nconst int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\n\nbool keypress(int code) {\n#if __VERSION__ < 300\n  return false;\n#else\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\nint imod(int n,int m) {\n#if __VERSION__ >= 300\n  return n%m;\n#else\n  return n - n/m*m;\n#endif\n}\n\nvec4 gettri0(int i) {\n#if __VERSION__ >= 300\n  i += 9;\n  i = 1+i%15;\n  i = i^(i/2);\n#else\n  i += 14;\n  i = 1+imod(i,15);\n#endif\n  return vec4(imod(i,2),imod(i/2,2),imod(i/4,2),imod(i/8,2));\n}\n\nvec4 gettri() {\n  float t = 0.5*iTime;\n  int i = int(t);\n  float k = 0.0;\n  if (morph) k = fract(t);\n  return mix(gettri0(i),gettri0(i+1),k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  invert = !keypress(CHAR_I);\n  centre = keypress(CHAR_C);\n  morph = !keypress(CHAR_M);\n  vec2 p = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n  float t = iTime/TWOPI;\n  if (keypress(CHAR_A)) {\n    tri0 = vec4(int(!keypress(CHAR_1)),int(!keypress(CHAR_2)),\n                int(!keypress(CHAR_3)),int(!keypress(CHAR_4)));\n  } else {\n    tri0 = gettri();\n  }\n  init(tri0);\n  vec3 bg = vec3(0.3 + p.y*0.1);\n  vec3 col = bg;\n  vec3 ro = vec3(0, 0, 2.0);\n  vec3 rd = normalize(vec3(p, -2.0));\n  vec3 li = normalize(vec3(0.5, 2, 3.0));\n  ro = transform(ro);\n  if (iMouse.y > 0.0) {\n    ro *= 2.0*iMouse.y/iResolution.y;\n  }\n  rd = transform(rd);\n  li = transform(li);\n\n  float k = march(ro,rd);\n  if (k < 1e8) {\n    vec3 pos = ro + k*rd;\n    vec3 n = calcNormal(pos);\n    col = 0.1+0.8*getcolor(pos);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    col *= 0.4+0.6*diffuse;\n    if (invert) {\n      //col = mix(vec3(1,1,0.5), col, smoothstep(0.0,0.2,length(pos)));\n      col = mix(vec3(0), col, smoothstep(0.0,0.2,length(pos)));\n    }\n  }\n  //col = mix(col, 0.5*vec3(1,1,0.5), clamp(k/40.0,0.0,1.0));\n  col = mix(col, 0.1*vec3(0,0,1), clamp(k/25.0,0.0,1.0));\n  col = pow(col, vec3(0.4545));\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddcRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[867, 965, 1001, 1001, 1053], [1575, 1575, 1596, 1596, 1695], [1697, 1697, 1734, 1734, 2177], [2179, 2179, 2200, 2200, 2575], [2577, 2577, 2597, 2597, 2714], [2716, 2716, 2744, 2744, 2961], [2963, 2963, 3000, 3000, 3408], [3410, 3410, 3437, 3437, 3750], [3752, 3752, 3775, 3775, 4571], [4781, 4781, 4806, 4806, 4917], [4919, 4919, 4942, 4942, 5014], [5016, 5016, 5037, 5037, 5207], [5209, 5209, 5224, 5224, 5352], [5354, 5354, 5411, 5411, 6640]], "test": "valid"}
{"id": "4ddczM", "name": "Mesh_0", "author": "balkhan", "description": "torus->cylinder->sphere->cylinder", "tags": ["quadmesh"], "likes": 9, "viewed": 207, "published": "Public", "date": "1518390275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nfloat\tnrand( vec2 n );\n\nvec3\tret_col;\t// color\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t110.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 60.0);\n\n    vec2\tinter = (march(pos, dir));\n    if (inter.y >= FAR)\n        ret_col = vec3(.90, .82, .70);\n    else\n        ret_col = .5*vec3(.6, .26, .3);\n    col.xyz = ret_col*(1.-inter.x*.005);\n    c_out =  vec4(col,1.0);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nfloat\tcube(vec3 p)\n{\n\treturn max(abs(p.x), max(abs(p.y), abs(p.z)));\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    float\tcage = 1e5;\n    p.z -= sin(iTime*.25+3.14)*4.;\n    rotate(p.xz, 1.57-.35*iTime );\n    rotate(p.yz, 1.2-1.*.5*iTime );\n    float ball = 1e5;\n    p.xz = modA(p.xz, 25.);\n    p.x -= mix(25., 0., sin(iTime*.125-2.)*.5+.5);\n    p.yx = mix(modA(p.yx, 25.), modA(p.yx, 4.), sin(iTime*.5)*.5 + .5);\n    p.y -= 20.;\n\n    ball = min(ball, (length(p.xy)-.105101) );\n    ball = min(ball, (length(p.zy)-.105101) );\n    ball = min(ball, (length(p.y)+.0001) );\n\n    mind = min(mind, ball);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x;\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    ret = max(abs(p.z)+.5*abs(p.x), ret);\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddczM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[563, 563, 606, 606, 980], [1053, 1053, 1086, 1086, 1217], [1242, 1242, 1262, 1262, 1312], [1314, 1314, 1335, 1335, 1880], [1882, 1882, 1914, 1914, 2293], [2309, 2309, 2333, 2333, 2430], [2432, 2432, 2456, 2456, 2590], [2592, 2592, 2632, 2632, 2707], [2709, 2709, 2737, 2737, 2845], [2847, 2847, 2869, 2869, 3075], [3077, 3077, 3127, 3127, 3390]], "test": "error"}
{"id": "4ddyRH", "name": "Paw Metaballs - nmaga", "author": "nmaga23", "description": "Paw Metaballs for CIS566", "tags": ["metaballs"], "likes": 2, "viewed": 69, "published": "Public", "date": "1518149300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 300;\nconst float MIN_DIST = 0.0001;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nmat3 rotateMatZ(float angle) {\n\tfloat rad = radians(angle);\n\treturn mat3(\n\t\tvec3(cos(rad), -sin(rad), 0.0),\n\t\tvec3(sin(rad), cos(rad), 0.0),\n\t\tvec3(0.0, 0.0, 1.0)\n\t);\n}\n\nfloat smin( float a, float b) {\n    float k = 10.0;\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sphereSDF0(vec3 p) {\n    return length(p) - 0.25;\n}\n\nfloat sphereSDF1(vec3 p) {\n\treturn length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 1.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF2(vec3 p) {\n\treturn length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 2.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF3(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 3.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF4(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 4.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF5(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 5.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF6(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 6.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF7(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 7.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF8(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 8.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sceneSDF(vec3 p) {\n\tfloat group1 = smin(sphereSDF1(p * rotateMatZ(0.0)), sphereSDF2(p * rotateMatZ(45.0)));\n    float group2 = smin(sphereSDF3(p * rotateMatZ(90.0)), sphereSDF4(p * rotateMatZ(135.0)));\n    float group3 = smin(sphereSDF5(p * rotateMatZ(180.0)), sphereSDF6(p * rotateMatZ(225.0)));\n    float group4 = smin(sphereSDF7(p * rotateMatZ(270.0)), sphereSDF8(p * rotateMatZ(315.0)));\n    float group5 = smin(group1,group2);\n    float group6 = smin(group3,group4);\n    return smin(smin(group5, group6), sphereSDF0(p));\n}\n\nfloat march(vec3 rayOrigin, vec3 direction) {\n\tfloat dist = MIN_DIST;\n\tfor(int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 pos = rayOrigin + dist * direction;\n\t\tfloat dt = sceneSDF(pos);\n\t\tif(dt < EPSILON) {\n\t\t\treturn dist;\n\t\t}\n\t\tdist += dt;\n\t\tif(dist >= MAX_DIST) {\n\t\t\treturn MAX_DIST;\n\t\t}\n\t}\n\treturn MAX_DIST;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(45.0) / 2.0);\n    \n    \n    vec3 eye = vec3(0.0, 0.0, 5.0);\n\tvec3 dir = normalize(vec3(xy, -z));\n\tfloat distance = march(eye, dir);\n\n\tif(distance >= MAX_DIST - 2.0 * EPSILON) {\n\t\tfragColor = vec4(1.0,1.0,1.0,1.0);\n        return;\n\t}\n\n\tfragColor = vec4(0.0,0.0,0.0,0.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 149, 149, 287], [289, 289, 320, 320, 411], [413, 413, 439, 439, 470], [472, 472, 498, 498, 594], [596, 596, 622, 622, 718], [720, 720, 746, 746, 845], [847, 847, 873, 873, 972], [974, 974, 1000, 1000, 1099], [1101, 1101, 1127, 1127, 1226], [1228, 1228, 1254, 1254, 1353], [1355, 1355, 1381, 1381, 1480], [1482, 1482, 1506, 1506, 2015], [2017, 2017, 2062, 2062, 2322], [2324, 2324, 2381, 2381, 2748]], "test": "valid"}
{"id": "4ddyz4", "name": "Spindle of Death by Yuru Wang", "author": "yuruwang", "description": "finish time: 2/7/2018", "tags": ["2dsdf"], "likes": 1, "viewed": 62, "published": "Public", "date": "1518141246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 translationMatrix(vec3 v) {\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                v.x, v.y, v.z, 1.0);\t\t\n}\n\nmat4 rotateX(float rad) {\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, cos(rad), sin(rad), 0.0,\n                0.0, -sin(rad), cos(rad), 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateZ(float rad) {\n\treturn mat4(cos(rad), sin(rad), 0.0, 0.0,\n                -sin(rad), cos(rad), 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float rad) {\n\treturn mat4(cos(rad), 0.0, -sin(rad), 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                sin(rad), 0.0, cos(rad), 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nfloat sawtooth_wave(float x, float freq, float amplitude) {\n    return (x * freq - floor(x * freq)) * amplitude;\n    \n}\n\nfloat square_wave(float x, float freq, float amplitude) {\n    return abs(mod(floor(x * freq), 2.0) * amplitude);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat cadgeSDF(vec3 samplePoint) {\n    float PI = 3.1415;\n    float min_t = 100.0;\n    mat4 transM = rotateX(PI * 0.5); \n    for (float i = 0.0; i < 8.0; i++ ){\n    \tfloat angle = i * PI / 8.0;\n        transM = rotateY(angle) * transM;\n        vec3 transedP = vec3(inverse(transM) * vec4(samplePoint, 1.0));\n        float t = sdTorus(transedP, vec2(3.0, 0.02));\n        min_t = min(min_t, t);\n    }\n    return min_t;\n}\n\nfloat ballsSDF(vec3 samplePoint) {\n    float PI = 3.1415;\n    float min_t = 100.0;\n    \n    for (float i = 0.0; i <8.0; i++ ){\n        mat4 transM = translationMatrix(vec3(3.0, 0.0, 0.0)); \n        float angle_vert = sawtooth_wave(iTime + i * 1.0 / 8.0, 0.5, 1.0) * 2.0 * PI;\n        transM = rotateZ(angle_vert) * transM;\n            \n        float angle_ori = i * PI / 8.0;\n        transM = rotateY(angle_ori) * transM;\n        vec3 transedP = vec3(inverse(transM) * vec4(samplePoint, 1.0));\n        float t = sdSphere(transedP, 0.15);;\n        min_t = min(min_t, t);\n    }\n    return min_t;\n}\n\nvec3 rayDirection(vec2 fragCoord, vec3 iResolution) {\n    return vec3(0.0, 0.0, -1.0);\n}\n\n\nfloat march(int type, vec3 eyePos, vec3 rDir, float min_t, float max_t, float EPSILON, mat4 transM) {\n    const int MAX_MARCHING_STEPS = 255;\n\n    float t = min_t;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = eyePos + t * rDir;\n        \n        float PI = 3.14159265359;\n        vec3 transedP = vec3(inverse(transM) * vec4(p, 1.0));  // rotation and translation\n        float dist = 0.0;\n        if (type == 0) {\n           dist = cadgeSDF(transedP);\n        } else {\n           dist = ballsSDF(transedP);\n        }\n            \n        if (dist < EPSILON) {\n            // We're inside the scene surface!\n            return t;\n        }\n        // Move along the view ray\n        t += dist;\n\n        if (t >= max_t) {\n            // Gone too far; give up\n            return max_t;\n        }\n    }\n    return max_t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float modTime = mod(iTime, 8.0);\n \tint mode = 0;   \n    if (modTime > 0.0 && modTime <= 2.0) {\n        mode = 1;\n    } else if (modTime > 2.0 && modTime <= 4.0) {\n        mode = 2;\n    } else if (modTime > 4.0 && modTime <= 6.0) {\n        mode = 3;\n    } else if(modTime > 6.0 && modTime <= 8.0) {\n        mode = 4;\n    }\n    \n    const float MIN_T = 0.0;\n\tconst float MAX_T = 100.0;\n\tconst float EPSILON = 0.0001;\n    vec3 eyePos = vec3(0.0, 0.0, 80.0);\n    eyePos.x = fragCoord.x / 50.0 - 0.5 * iResolution.x / 50.0;\n    eyePos.y = fragCoord.y / 50.0 - 0.5 * iResolution.y / 50.0;\n\n\tvec3 rDir = rayDirection(fragCoord, iResolution);\n\tvec3 rDir_transed = rDir;\n    \n    //float overall_angle = sawtooth_wave(iTime, 0.5, 1.0) * square_wave(iTime, 0.5, 1.0) * PI / 2.0;\n    \n    float PI = 3.14159265359;\n    float overall_angle = 0.0;\n    if (mode == 1) {\n        overall_angle = sawtooth_wave(iTime, 0.5, 1.0) * PI / 2.0;\n        \n    } else if (mode == 2) {\n        overall_angle = PI / 2.0;\n        \n    } else if (mode == 3) {\n        overall_angle = (1.0 + (-1.0) * sawtooth_wave(iTime, 0.5, 1.0)) * PI / 2.0;\n        \n    } else if (mode == 4) {\n        overall_angle =0.0;\n    }\n    \n    \n    mat4 transM = rotateX(overall_angle);\n    \n    float cadge_t = march(0, eyePos, rDir_transed, MIN_T, MAX_T, EPSILON, transM);\n    float ball_t = march(1, eyePos, rDir_transed, MIN_T, MAX_T, EPSILON, transM);\n    \n    vec4 color;\n    if (cadge_t < ball_t) {\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        color = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    float t = min(cadge_t, ball_t);\n    vec3 pos = eyePos + t * rDir_transed;\n    \n    if (t >= MAX_T) {\n        // Didn't hit anything\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n\n    } else {\n        fragColor = color;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 178], [180, 180, 205, 205, 358], [360, 360, 385, 385, 538], [540, 540, 565, 565, 718], [720, 720, 779, 779, 839], [841, 841, 898, 898, 955], [957, 957, 992, 992, 1016], [1018, 1018, 1051, 1051, 1116], [1118, 1118, 1152, 1152, 1536], [1538, 1538, 1572, 1572, 2133], [2135, 2135, 2188, 2188, 2223], [2226, 2226, 2327, 2327, 3066], [3068, 3068, 3125, 3125, 4920]], "test": "error"}
{"id": "4dtcWr", "name": "ecstatica like shader", "author": "mihart", "description": "1. simple shading\n2. added 256 color simulate\n3. added antialiasing", "tags": ["sphere", "ecstatica"], "likes": 1, "viewed": 505, "published": "Public API", "date": "1518519219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy  - 0.5;\n    uv.x = uv.x /iResolution.y * iResolution.x;\n\n    vec3 lightpos = vec3(1.0);\n    \n    lightpos.x = 1.0 + sin(iTime) * 2.0;\n    lightpos.y = sin(iTime / 2.0) * 1.0;\n\t\n    vec4 baseColor = vec4(0.0, 0.5, 0.5, 1.0);\n    fragColor = baseColor;\n    \n    if(pow(uv.x, 2.0) + pow(uv.y, 2.0) <0.25) {\n        float uvz = sqrt(0.25 - dot(uv, uv));\n        vec3 norm = normalize(vec3(uv, uvz));\n        vec3 lightDir = normalize(lightpos - vec3(uv, uvz));\n\n        float diff = .2 + .8* clamp(dot(norm,lightDir),0.,1.) ;\n        fragColor = diff * vec4(1.0, 0.0, 0.0, 1.0);\n\t\tfragColor = round(fragColor * 16.0)/16.0;\n        fragColor = mix(fragColor, baseColor, smoothstep(0.245, .25, dot(uv, uv)));\n    }\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtcWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 857]], "test": "valid"}
{"id": "4dtyRf", "name": "Inside out grid", "author": "wyatt", "description": "Learned about space today", "tags": ["raymarching", "inversion"], "likes": 16, "viewed": 246, "published": "Public", "date": "1519698141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rot (vec3 s) {\n\t\tfloat \tsa = sin(s.x),\n\t\t\t\tca = cos(s.x),\n\t\t\t\tsb = sin(s.y),\n\t\t\t\tcb = cos(s.y),\n\t\t\t\tsc = sin(s.z),\n\t\t\t\tcc = cos(s.z);\n\t\treturn mat3 (\n\t\t\tvec3(cb*cc, -cb*sc, sb),\n\t\t\tvec3(sa*sb*cc+ca*sc, -sa*sb*sc+ca*cc, -sa*cb),\n\t\t\tvec3(-ca*sb*cc+sa*sc, ca*sb*sc+sa*cc, ca*cb)\n\t\t);\n\t}\n\tmat3 mm;\n\tvec4 light;\n\tfloat map (vec3 p) {\n\t\tfloat a = .8;\n\t\tfloat d = length(p-light.xyz)-light.w;\n\t\td = min(d,max(15.-p.z,0.));\n\t\tp = mm*p;\n\t\tfloat r = dot(p,p);\n\t\tp = 11.*p/r;\n\t\tfloat b = .1*sqrt(r)/(r);\n\t\tp = (fract((p*0.5)/a)*2.-1.)*a;\n\t\td = min(d,length(p.xz)-b);\n\t\td = min(d,length(p.xy)-b);\n\t\td = min(d,length(p.zx)-b);\n\t\td = min(d,length(p)-2.5*b);\n  \t\treturn d;\n\t}\n\tvec3 norm (vec3 p) {\n\t\tvec2 e = vec2 (.001,0.);\n\t\treturn normalize(vec3(\n\t\t\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\t\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\t\t\tmap(p+e.yyx) - map(p-e.yyx)\n\t\t\t));\n\t}\n\tvec3 dive (vec3 p, vec3 d) {\n\t\tfor (int i = 0; i < 110; i++) {\n\t\t\tp += min(1.,(.1*dot(p,p)))*d*map(p);\n\t\t}\n\t\treturn p;\n\t}\n\tvoid mainImage (out vec4 fragColor, vec2 vv) {\n        float ui = float(iFrame);\n\t\tvec2 v = (vv/iResolution.xy)*2.-1.;\n        v.x *= iResolution.x/iResolution.y;\n\t\tvec3 r = vec3(0,0,-10.);\n\t\tlight = vec4(5.*sin(0.01*ui),3,-7,1);\n\t\tvec3 d = normalize(vec3(v,3.));\n\t\tmm = rot(0.01*ui*vec3(0,1,1));\n\t\tvec3 p = dive(r,d);\n\t\td = normalize(light.xyz-p);\n\t\tvec3 bounce = dive(p+0.01*d,d);\n        vec3 no = norm(p);\n\t\tvec3 col = vec3(dot(no,normalize(light.xyz-p))*0.5+0.5);\n        col = col*col;//1.-0.01*exp(-100.*col*col);\n\t\tif (length(bounce-light.xyz) > light.w+0.1) col *= 0.2;\n\t\tif (length (p-r)>15.-r.z) col *= vec3(0.5,0.6,0.9);\n        fragColor = vec4(col,1);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtyRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 288], [313, 313, 333, 333, 665], [667, 667, 687, 687, 847], [849, 849, 877, 877, 970], [972, 972, 1018, 1018, 1643]], "test": "valid"}
{"id": "4dtyWM", "name": "FlowMappedLand", "author": "kuvkar", "description": "Flow mapping test. Done by advecting 2 textures, and calculating a flow vector from the gradient of the geometry.\nsee comments in code for references.\n", "tags": ["flow", "advection", "texturing"], "likes": 11, "viewed": 845, "published": "Public API", "date": "1519256586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\nWanted to try out FabriceNeyret2's gradient based flow mapping and ended up making this landscape. I didn't want to use extra buffers\nI instead advect 2 textures for animation. I feel this technique could be useful for a game for example.\n\nCalculating the flow map is basicly the same as calculating gradient, it's just rotated 90 degrees. \nThe screen space derivates cause some aliasing on the border to water, I might fix that later.\n\nThe terrain is a height field.\n\nsee https://www.shadertoy.com/view/ls3cR4 by Fabrice\nand http://graphicsrunner.blogspot.fi/2010/08/water-using-flow-map\n\n*/\n\n/////////////////////////////\n// simplex noise by IQ\n// https://www.shadertoy.com/view/Msf3WH\n//////////////////////////////////////////\nvec2 hash( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\nfloat fbm(vec2 uv)\n{\n    uv *= 1.5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f = 0.;\n    f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;    \n    return f;\n}\n\n////////////////\n////////////////\n////////////////\n\n\nfloat map(in vec2 uv)\n{\n\treturn fbm(uv);\n}\n///////////////////\n/// Flow vector calculation from the geometry\n/// Basicly just a gradient with 90 degree rotation so that it's tangential to surface\n////////////////////////////////////\n/// Reference from Fabrice,\n/// https://www.shadertoy.com/view/ls3cR4\nvec2 getFlowVec(float distanceAtPos)\n{\n    float x = dFdy(distanceAtPos);\n    float y = -dFdx(distanceAtPos);\n\treturn vec2(x, y);\n}\n\n/////////////////////////////////////////////////////////////////////\n// Advecting 2 textures for animation\n// http://graphicsrunner.blogspot.fi/2010/08/water-using-flow-maps.html\nfloat getMixValue(float cycle, inout float offset1, inout float offset2)\n{\n    // mixval 0..1..0 over full cycle\n    float mixval = cycle * 2.0;\n    if(mixval > 1.0) mixval = 2.0 - mixval;\n    \n    // texture phase 1 \n    offset1 = cycle;\n    // texture phase 2, phase 1 offset by .5\n    offset2 = mod(offset1 + .5, 1.0);\n    return mixval;\n}\n\nvec3 cameraPos;\n\nvec3 traceGround(in vec2 uv, out float height, out vec3 waterSurfaceCoord)\n{\n    vec3 rd = normalize(vec3(uv, -.7));\n    vec3 rp = cameraPos + vec3(rd.xy/-rd.z, -1.0) * (cameraPos.z - 1.);\n    waterSurfaceCoord = cameraPos + vec3(rd.xy/-rd.z, -1.0) * (cameraPos.z);\n    \n    float steps = 100.0;\n    float h = 0.;\n    bool hit = false;\n    \n    // roughly to the surface\n    for (float i = 0.; i < steps; i = i + 1.0)\n    {\n        h = fbm(rp.xy);\n        \n        if(h > rp.z)\n        {\n            hit = true;\n            break;\n        }\n        \n        float stp = max(0.01, (rp.z - h) * .4);\n        rp += rd*stp;\n    }\n    \n    // more detailed steps\n    for(float i = 0.; i < 20.; i = i + 1.)\n    {\n        h = fbm(rp.xy);\n        float stp = (rp.z - h) * .05;\n        rp += rd * stp;\n    }\n    \n    if(!hit) h = -.1;\n    height = h;\n    return rp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n    uv.y /= iResolution.x / iResolution.y;\n\tuv *= .5;\n    \n    cameraPos.xy = vec2(iTime * .2, iTime * .1) * .1;\n    cameraPos.z = 1.5 + sin(iTime * .3) * .2;\n   \n    fragColor = vec4(.0);\n    \n    float h = 0.;\n    vec3 waterSurface = vec3(.0);\n    vec3 hitp = traceGround(uv, h, waterSurface);\n    float ch = smoothstep(-1., 1.0, h);\n    ch = smoothstep(0.0, 1.0, ch);\n    vec4 col = vec4(ch);\n    \n    // land\n    float grassline = smoothstep(-0.1, 0.1, h);\n    vec4 grasstex = texture(iChannel3, hitp.xy * .4);\n    vec4 grasstex2 = texture(iChannel0, hitp.xy * 2.2) * vec4(.4, .7, .4, 1.0);\n    grasstex = mix(grasstex, grasstex2, smoothstep(0.3, 0., h) * smoothstep(0., 0.1, h) * smoothstep(0.4, 0.5, grasstex.b));\n    grasstex *= mix(texture(iChannel1, hitp.xy * 9.).r, 1.0, 0.85);\n    // graininess\n    col = mix(col, col * vec4(1., 1., 1., 1.0) * grasstex, grassline);\n    \n    float waterline = smoothstep(0.1, -0.1, h);\n    col = mix(col, col * vec4(0.4, .5, 0.7, 1.0), waterline);\n    \n    // water surface hit\n    if(h <= 0.)\n    {\n        float dist = -map(waterSurface.xy);\n        vec2 origFlowvec = getFlowVec(dist);\n        \n        // fade out the influence of the vector at distance for shore foam.\n        float influence = smoothstep(.35, .0, dist);\n\t    vec2 shoreFlowvec = origFlowvec * influence;\n\t\tfloat l = length(shoreFlowvec);\n        float PHASE_LEN = 2.0;\n        float T = iTime * 2.;\n\n        // one full cycle\n        float cycle = mod(T, PHASE_LEN) / PHASE_LEN; \n\n        float phase1 = 0.0;\n        float phase2 = 0.0;\n        float mixval = getMixValue(cycle, phase1, phase2);\n\n        float textureScale = 15.;\n        float flowSpeed = 25.;\n        \n        vec2 flow_uv1 = waterSurface.xy * textureScale + flowSpeed * shoreFlowvec * phase1;\n        vec2 flow_uv2 = waterSurface.xy * textureScale + flowSpeed * shoreFlowvec * phase2;\n\n        // flow texturing\n        vec4 c1 = texture(iChannel2, flow_uv1).rrrr;\n        vec4 c2 = texture(iChannel2, flow_uv2).rrrr;\n        //vec4 c = mix(c2, c1, vec4(mixval));\n        \n\t\tfloat a = mixval;\n        vec4 c = .5 + ( mix(c2, c1, a) - .5) / sqrt(a*a+(1.-a)*(1.-a));        \n        c *= vec4(0.5, 0.5, 0.7, 1.0);\n        float edge = smoothstep(0.0, 0.009, l);\n        col += c * edge * .5;\n\n        // 2nd flow texturing for deep sea\n        origFlowvec = normalize(origFlowvec) * .01;\n        vec2 flow_uv11 = waterSurface.xy * textureScale + 0.4 * flowSpeed * origFlowvec * phase1;\n        vec2 flow_uv22 = waterSurface.xy * textureScale + 0.4 * flowSpeed * origFlowvec * phase2;\n\n        vec4 c11 = texture(iChannel1, flow_uv11).rrrr;\n        vec4 c22 = texture(iChannel1, flow_uv22).rrrr;\n        //vec4 cc = mix(c22, c11, vec4(mixval));\n        vec4 cc = .5 + ( mix(c22, c11, a) - .5) / sqrt(a*a+(1.-a)*(1.-a));        \n        \n        vec4 deepsea = col + cc  * vec4(.1, .15, .2, 1.0) * .5;\n        col = mix(col, deepsea, 1.0 - edge);\n    }\n    \n    col = smoothstep(vec4(0.0), vec4(.6), col);\n    fragColor = col;\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtyWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[599, 736, 758, 758, 879], [881, 881, 907, 907, 1362], [1363, 1363, 1383, 1383, 1637], [1692, 1692, 1715, 1715, 1734], [1735, 1995, 2033, 2033, 2126], [2128, 2308, 2382, 2420, 2650], [2669, 2669, 2745, 2745, 3527], [3529, 3529, 3586, 3586, 6658]], "test": "error"}
{"id": "4dtyz2", "name": "Fear of the dark", "author": "krax", "description": "Was going to attempt to put more stuff in this, but legit, my computer is basically running 10fps as it is, so I guess I'll just leave it like this.\nInspired by this: https://www.youtube.com/watch?v=ElbGteGfEfs\nThe movie and song go together well.", "tags": ["3d", "police", "bed", "sleeping"], "likes": 6, "viewed": 219, "published": "Public", "date": "1519579736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is some of the messiest code I've ever written.\n\n// If like me you're computer is a bit of a potato, uncomment the line below.\n// #define POTATO_QUALITY\n\n\n\n#define AO_STEPS 2.0\n#define AO_INTENSITY 5.0\n#define AO_AOI 0.1\n\n#define DOOR_CLOSE_LEN 6.1\n\n// Originally it was going to wait a bit\n// before lighting up, but as it turns out\n// it looks waaaay better if you basically do it\n// as the doors are closing\n#define SLOW_LIGHT_UP_PAUSE -6.1\n#define SLOW_LIGHT_UP_LEN 10.1\n\n#define SLOW_LU_START DOOR_CLOSE_LEN + SLOW_LIGHT_UP_PAUSE\n#define SLOW_LU_END SLOW_LU_START + SLOW_LIGHT_UP_LEN\n\n#define RAY_MARCH_C 64\n#define POLICE_LIGHTS_FREQ 7.\n\n#define HALF_PI 1.57079632679\n\n\n\nfloat random(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat opU(float d1, float d2) { return min(d1, d2); }\n\nfloat opS(float d1, float d2) {\n  // For whatever reason max(-d1, d2)\n  // does some weird stuff for me, which\n  // is probably a symptom that I'm doing something\n  // a bit weird\n  return max(0.1 - d1, d2);\n}\n\nfloat opI(float d1, float d2) { return max(d1, d2); }\n\nvec3 opRep(vec3 p, vec3 c) { return mod(p, c) - 0.5 * c; }\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nfloat plane(vec3 p, vec4 n) { return dot(p, n.xyz) + n.w; }\n\nfloat box(vec3 p, vec3 b) { return length(max(abs(p) - b, 0.0)); }\n\nfloat round_box(vec3 p, vec3 b, float r) {\n  return length(max(abs(p) - b, 0.0)) - r;\n}\n\nvec3 rotateX(vec3 p, float radian) {\n  mat3 m = mat3(1.0, 0.0, 0.0, 0.0, cos(radian), -sin(radian), 0.0, sin(radian),\n                cos(radian));\n  return m * p;\n}\n\nvec3 rotateY(vec3 p, float radian) {\n  mat3 m = mat3(cos(radian), 0.0, sin(radian), 0.0, 1.0, 0.0, -sin(radian), 0.0,\n                cos(radian));\n  return m * p;\n}\n\nvec3 rotateZ(vec3 p, float radian) {\n  mat3 m = mat3(cos(radian), -sin(radian), 0.0, sin(radian), cos(radian), 0.0,\n                0.0, 0.0, 1.0);\n  return m * p;\n}\n\nstruct Camera {\n  vec3 position;\n  vec3 look_at;\n  vec3 up;\n  float focus;\n};\n\nvec3 get_ray_direction(Camera cam, vec2 uv) {\n  // Get the direction the camera is facing, based on what\n  // it's supposed to be looking at\n  vec3 cam_direction = normalize(-(cam.position + cam.look_at));\n  vec3 cam_side = cross(cam_direction, cam.up);\n\n  // Get the normalized ray direction\n  return normalize(\n      vec3(cam_side * uv.x + cam.up * uv.y + cam_direction * cam.focus));\n}\n\nvoid cabinet(const in vec3 p, inout float dist) {\n\n  dist = opU(dist, box(p + vec3(9.3, -1.9, 1.), vec3(1.1, 1.8, 1.75)));\n  dist = opU(dist, sphere(p + vec3(8.2, -1.9, 1.4), 0.1));\n  dist = opU(dist, sphere(p + vec3(8.2, -1.9, 0.8), 0.1));\n  dist = opU(dist, box(p + vec3(8.17, -3.5, 1.), vec3(0.1, 0.05, 1.3)));\n  dist = opU(dist, box(p + vec3(8.17, -3.1, 1.), vec3(0.1, 0.05, 1.3)));\n}\n\nvoid backwall(const in vec3 p, inout float dist) {\n\n  float door_open_amount = pow(smoothstep(DOOR_CLOSE_LEN, 0., iTime), 1.5);\n  float wall = plane(p + vec3(0., 0., -13.), vec4(0., 0.2, -1.0, 0.));\n  wall = opS(plane(p + vec3(0., 0., -14.), vec4(0., 0.2, -1.0, 0.)), wall);\n  wall =\n      opS(box(p + vec3(0., 0., -13.), vec3(door_open_amount, 13., 23.)), wall);\n  dist = opU(dist, wall);\n}\n\nvoid toys(const in vec3 p, inout float dist) {\n\n  dist = opU(dist, sphere(p + vec3(8.3, -.4, -1.), 0.5));\n    \n  dist = opU(dist, sphere(p + vec3(5.3, -.2, -2.), 0.3));\n    \n  vec3 rpA = rotateY(p+vec3(-6, 0.1, -3), 0.6);  \n  dist = opU(dist, box(rpA, vec3(.3,.3,.3)));\n    \n  vec3 rpB = rotateY(p+vec3(-6, -.55, -3), 0.1);  \n  dist = opU(dist, box(rpB, vec3(.3,.3,.3)));\n    \n  vec3 rpC = rotateY(p+vec3(-5, -.1, -2), 0.1);  \n  dist = opU(dist, box(rpC, vec3(.4,.4,.4)));\n  \n}\n\nvoid environment(const in vec3 p, inout float dist) {\n\n  // Create the floor\n  dist = opU(dist, plane(p, vec4(0.01, 1.0, 0.1, 0.0)));\n\n  // Walls\n  dist = opU(dist, plane(p + vec3(11., 0., 0.), vec4(1., 0.15, 0.2, 0.0)));\n  dist = opU(dist, plane(p + vec3(-12.3, 0., 0.), vec4(-1., 0.15, 0.2, 0.0)));\n  dist = opU(dist, plane(p + vec3(0., 0., 9.), vec4(0., 0.2, 1.0, 0.)));\n\n  // Ceiling\n    \n  dist = opU(dist, plane(p + vec3(0., -32, .0), vec4(0.01, -1.0, 0.1, 0.0)));\n  dist = opS(plane(p + vec3(0., -36, .0), vec4(0.01, -1.0, 0.1, 0.0)), dist);\n\n  // Cut out side hollow\n  dist = opS(box(p + vec3(-11., -7, 2.9), vec3(3., 2.0, 2.3)), dist);\n\n  // Cut out window on the left\n  //dist = opS(box(p + vec3(11., -10, 2.9), vec3(3., 5.0, 2.3)), dist);\n  dist = opS(box(p + vec3(11., -13.5, 2.075), vec3(3., 2.525, 0.975)), dist);\n  dist = opS(box(p + vec3(11., -13.5, 4.25), vec3(3., 2.525, 0.975)), dist);\n  dist = opS(box(p + vec3(11., -7.5, 2.075), vec3(3., 2.525, 0.975)), dist);\n  dist = opS(box(p + vec3(11., -7.5, 4.25), vec3(3., 2.525, 0.975)), dist);\n\n  dist = opS(plane(p + vec3(11.5, 0., 1.), vec4(1., 0.15, 0.2, 0.)), dist);\n\n  // Add cabinet\n  cabinet(p, dist);\n\n  // Add toys\n  toys(p, dist);\n\n  // Only bother doing the backwall\n  // if the door hasn't been closed\n  if (iTime < DOOR_CLOSE_LEN) {\n    backwall(p, dist);\n  }\n}\n\nvoid bed_child(const in vec3 p, inout float dist) {\n\n  // Bed base\n  vec3 rp = rotateX(p, 0.23);\n  rp -= vec3(0., 0.1, .0);\n  dist = opU(dist, round_box(rp + vec3(0, -1.6, 5), vec3(3.1, 0.5, 9.), 0.4));\n\n  // Pillow\n  dist = opU(dist, round_box(rp + vec3(0, -3, 8), vec3(1.1, 0.9, 1.), 1.0));\n\n  // Sheet\n  dist = opU(dist, round_box(rotateX(rp, 0.05) + vec3(0, -2.7, 2),\n                             vec3(2.5, 0.05, 6.), .01));\n\n  // Head\n  dist = opU(dist, sphere(rp + vec3(0., -3.3, 6.), 0.7));\n\n  // Hands\n  dist = opU(dist, sphere(rp + vec3(1.4, -3.1, 6.), 0.3));\n  dist = opU(dist, sphere(rp + vec3(-1.4, -3.1, 6.), 0.3));\n}\n\nfloat scene_distance(const in vec3 p) {\n  // Start out by saying everying\n  // is infinitly away\n  float dist = 1. / 0.;\n\n  // Get the environment\n  environment(p, dist);\n  bed_child(p, dist);\n\n  return dist;\n}\n\nvec3 ray_march(const in vec3 start_pos, const in vec3 ray_direction) {\n  // Start off at the cameras position\n  vec3 position = start_pos;\n  // Ray march forward\n  float t = 0.0;\n  for (int i = 0; i < RAY_MARCH_C; ++i) {\n    t += scene_distance(position);\n    position = start_pos + t * ray_direction;\n  }\n  return position;\n}\n\nvec3 get_normal(const in vec3 p) {\n  const float d = 0.0001;\n  return normalize(vec3(scene_distance(p + vec3(d, 0.0, 0.0)) -\n                            scene_distance(p - vec3(d, 0.0, 0.0)),\n                        scene_distance(p + vec3(0.0, d, 0.0)) -\n                            scene_distance(p - vec3(0.0, d, 0.0)),\n                        scene_distance(p + vec3(0.0, 0.0, d)) -\n                            scene_distance(p - vec3(0.0, 0.0, d))));\n}\n\nfloat get_shadow(vec3 light_pos, vec3 p, vec3 light_dir, float light_dist,\n                 float shadow_intensity) {\n  vec3 shadow = ray_march(light_pos, -light_dir);\n  float shadow_distance = distance(light_pos, shadow);\n  // return step(light_dist, shadow_distance);\n  // return smoothstep(0.0, light_dist, shadow_distance);\n  return pow(smoothstep(0.0, light_dist, shadow_distance), shadow_intensity);\n}\n\nvec3 direct_light(vec3 direction, vec3 colour, vec3 normal, float spec_roll,\n                  float spec_intensity) {\n  return colour * (dot(normalize(direction), normal) +\n                   pow(dot(normalize(direction), normal), 1.0 / spec_roll) *\n                       spec_intensity);\n}\n\nvec3 point_light(vec3 light_pos, vec3 colour, vec3 pos, vec3 normal,\n                 float spec_roll, float spec_intensity,\n                 float shadow_intensity) {\n\n  // Just called direct light, but have the direction be\n  // the vector between the objects position and the lights position\n  vec3 direction = normalize(light_pos - pos);\n  vec3 light =\n      direct_light(direction, colour, normal, spec_roll, spec_intensity);\n  light *= get_shadow(light_pos, pos, .5 * direction, distance(light_pos, pos),\n                      shadow_intensity);\n  return max(vec3(0.), light);\n}\n\nvoid do_lighting(vec3 p, vec3 normal, inout vec3 colour) {\n\n  float slow_lightup = 1.;\n\n  if (iTime < SLOW_LU_END) {\n    slow_lightup = max(smoothstep(SLOW_LU_START, SLOW_LU_END, iTime), 0.1);\n  }\n  // Overhead light\n  colour +=\n      point_light(vec3(0., 30., 10), vec3(0.15, 0.2, 0.3) * slow_lightup * 0.8,\n                  p, normal, 1.0, 0.0, 0.5);\n\n  // Moon light\n  colour += point_light(vec3(-100., 80., -50), vec3(0.25, 0.3, 0.35), p, normal,\n                        100.0, 1.0, 100.0);\n\n  // door closing\n  if (iTime <= DOOR_CLOSE_LEN) {\n\n    float moveaway = smoothstep(1., DOOR_CLOSE_LEN, iTime) * 11.;\n    colour +=\n        point_light(vec3(0., 6., 15. + moveaway), vec3(0.5, 0.4, 0.01) * .7, p,\n                    normal, 100.0, 1., 100000.0);\n  } else {\n    // Police\n    colour += point_light(\n        vec3(-20., 2. + sin(iTime - SLOW_LU_END) * 4., sin(iTime * 0.3) * 30.),\n        vec3(max(0., sin(iTime * POLICE_LIGHTS_FREQ)), 0,\n             max(cos(POLICE_LIGHTS_FREQ * iTime + HALF_PI), 0.)),\n        p, normal, 100.0, 0.0, 10000.0);\n  }\n}\n\nfloat ao(vec3 p, vec3 normal) {\n  float occlusion = 0.0;\n  for (float i = 1.; i <= AO_STEPS; i++) {\n    // Distance to to look\n    float dist = (i / AO_STEPS) * AO_AOI;\n    // Direction and distance from the original point\n    vec3 bounced = p + normal * dist;\n    // Add up how far the bouncd point is from another object\n    // But each time we get further away make it's influence\n    // less and less\n    float bounced_dist = scene_distance(bounced);\n    occlusion += (AO_INTENSITY / i) * (dist - bounced_dist);\n  }\n  return clamp(1.0 - occlusion, 0.0, 1.0);\n}\n\nfloat fresnel(vec3 ray_direction, vec3 normal) {\n  return 1.0 + (dot(ray_direction, normal));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  Camera camera = Camera(vec3(0.0, 1.0, 11.0), // Position\n                         vec3(0., -5.5, 0.),   // Look at\n                         vec3(0.0, 1.0, 0.0),  // Up\n                         1.3                   // FL\n                         );\n\n  // Get the 2d position\n  vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\n  // Get the ray we're going to be using\n  vec3 ray_direction = get_ray_direction(camera, uv);\n\n  // Get the position and normal\n  vec3 p = ray_march(camera.position, ray_direction);\n  vec3 normal = get_normal(p);\n\n  // Default colour to black\n  vec3 colour = vec3(0.0);\n\n  do_lighting(p, normal, colour);\n\n#ifndef POTATO_QUALITY\n  colour *= ao(p, normal);\n  colour += vec3(0.05, 0.0, 0.01) * fresnel(ray_direction, normal);\n  colour += (random(uv + iTime) * 2. - 1.) * .04;\n#endif\n\n  fragColor = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtyz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[685, 685, 708, 708, 779], [781, 781, 812, 812, 834], [836, 836, 867, 1015, 1045], [1047, 1047, 1078, 1078, 1100], [1102, 1102, 1130, 1130, 1160], [1162, 1162, 1193, 1193, 1217], [1219, 1219, 1248, 1248, 1278], [1280, 1280, 1307, 1307, 1346], [1348, 1348, 1390, 1390, 1435], [1437, 1437, 1473, 1473, 1602], [1604, 1604, 1640, 1640, 1769], [1771, 1771, 1807, 1807, 1936], [2017, 2017, 2062, 2157, 2405], [6640, 6640, 6757, 6757, 7047], [7049, 7049, 7167, 7167, 7341], [7343, 7343, 7510, 7637, 7927], [7929, 7929, 7987, 7987, 8990], [8992, 8992, 9023, 9023, 9556], [9558, 9558, 9606, 9606, 9653], [9655, 9655, 9710, 9710, 10573]], "test": "error"}
{"id": "4dtyz8", "name": "HW3 Swing", "author": "ChloeSnyder", "description": "HW3", "tags": ["hw"], "likes": 2, "viewed": 61, "published": "Public", "date": "1518031869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define deg2rad PI / 180.0\n\n// RAY MARCHING CODE SOURCE JAMIE WONG\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 300.0;\nconst float EPSILON = 0.0001;\n\nvec3 K_d = vec3(-1.0, -1.0, -1.0); // diffuse color\nfloat shininess;\n\nfloat noise(vec3 x)\n{\n        return fract(sin(dot(x.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// modified from https://thebookofshaders.com/edit.php#11/wood.frag\nfloat lines(vec3 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin((pos.y) *3.1415) + cos((pos.y) *3.1415)+b*2.0))*.5);\n}\n\n\nfloat perlinNoise(vec3 v) \n{ \n    vec3 nXnYnZ = floor(v); // grid corner\n    vec3 i = fract(v);\n\n    // generate other grid corners\n    vec3 pXpYpZ = nXnYnZ + vec3(1.0, 1.0, 1.0);\n    vec3 pXpYnZ = nXnYnZ + vec3(1.0, 1.0, 0.0);\n    vec3 pXnYnZ = nXnYnZ + vec3(1.0, 0.0, 0.0);\n    vec3 pXnYpZ = nXnYnZ + vec3(1.0, 0.0, 1.0);\n    vec3 nXpYpZ = nXnYnZ + vec3(0.0, 1.0, 1.0);\n    vec3 nXnYpZ = nXnYnZ + vec3(0.0, 0.0, 1.0);\n    vec3 nXpYnZ = nXnYnZ + vec3(0.0, 1.0, 0.0);\n\n    // feed these grid corners into a noise function that takes a vec3 and returns a float\n    float ppp = noise(pXpYpZ);\n    float ppn = noise(pXpYnZ);\n    float pnn = noise(pXnYnZ);\n    float pnp = noise(pXnYpZ);\n    float npp = noise(nXpYpZ);\n    float nnp = noise(nXnYpZ);\n    float npn = noise(nXpYnZ);\n    float nnn = noise(nXnYnZ);\n\n    // interpolate 3D  to 2D\n    float nn = nnn * (1.0 - i.x) + pnn * i.x;\n    float np = nnp * (1.0 - i.x) + pnp * i.x;\n    float pn = npn * (1.0 - i.x) + ppn * i.x;\n    float pp = npp * (1.0 - i.x) + ppp * i.x;\n\n    //interpolate 2D to 1 D\n    float n = nn * (1.0 - i.y) + pn * i.y;\n    float p = np * (1.0 - i.y) + pp * i.y;\n\n    return n * (1.0 - i.z) + p * i.z;\n\n}\n\n// modified from jamie wong\nvec3 scaleOp(vec3 samplePoint, vec3 scale)\n{\n\treturn (samplePoint / scale) * min(scale.x, min(scale.y, scale.z));\n}\n\n/**\n * Rotation matrix around the X axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\n/** JW\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/** JW\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/** JW\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n//iq\nfloat cubeSDF( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n/** JW\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n// iq\nfloat cylinderSDF( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat ramp(vec3 p)\n{\n    p += vec3(0.0, .05, 0.0);\n    // create ring for main body of half pipe\n    vec3 cylp = p - vec3(0.0,.9,0.0);\n    cylp = rotateX(90.0 * deg2rad) * cylp;\n    cylp = rotateZ(90.0 * deg2rad) * cylp;\n   \tfloat cyl = cylinderSDF(cylp, vec2(1.0, 1.0)) - .03;    \n    float outerCyl = cylinderSDF(cylp, vec2(1.0, 5.0)) - .03;\n    cyl = differenceSDF(cyl, outerCyl); \n    \n    // remove upper half\n    vec3 rectp = p - vec3(0.0, 1.8, 0.0);\n    float rect = cubeSDF(rectp, vec3(1.5, 1.0, 1.5));  \n    float halfpipe = differenceSDF(cyl, rect) - .05;\n    \n    // legs of halfpipe\n    float legs = cubeSDF(p - vec3(0.0, -.40, -3.0), vec3(1.0, .19, 7.0)) - .05;\n    halfpipe = smin(halfpipe, legs, .1) - .01;\n    \n    // line down the middle of half pipe\n    float centercut = cubeSDF(p, vec3(1.14, .9, .2)) - .01;\n    float rampBody = differenceSDF(halfpipe, centercut) - .01;\n    \n  \n    // curved cut out\n    float cutoutlefttop = cubeSDF(p - vec3(0.0, -.35, 2.6), vec3(1.1, .06, 2.05)) - .2;\n    float cutoutrighttop = cubeSDF(p - vec3(0.0, -.35, -4.5), vec3(1.1, .06, 4.0)) - .2;\n    float cutouttop = smin(cutoutlefttop, cutoutrighttop, .5);\n    \n\n    float cutoutleftbottom = cubeSDF(p - vec3(0.0, -.90, 1.6), vec3(1.12, -.3, 1.8)) - .25;\n    float cutoutrightbottom = cubeSDF(p - vec3(0.0, -.90, -1.9), vec3(1.12, -.3, 5.5)) - .4;\n   \n    float cutTop = differenceSDF(rampBody, cutouttop) - .01;\n    float cutBottom = unionSDF(cutoutleftbottom, cutoutrightbottom) - .01;\n    float cut = intersectSDF(cutouttop, cutBottom) - .02;\n    cut = intersectSDF(cut, legs);\n\n    return smin(cut, cutTop, .2);\n\n}\n\n// iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat pendulum (vec3 p)\n{\n  \n    p = rotateX(90.0 * deg2rad) * p;\n    \n    // pendulum motion\n    float g = 9.80665;\n    float L = 3.0;\n    float omega = sqrt(g/L);\n    float theta = cos(omega * iTime);\n\n    vec3 offset = vec3(3.0, 0.0, 0.0) * cos(theta - PI / 2.0);\n    offset += vec3(0.0, 0.0, 3.0) * sin(theta - PI / 2.0);\n    \n    vec3 cp = p + offset;\n    // inner and outter cylinders for ring shape\n    float outer = cylinderSDF(cp, vec2(1.0, .30));\n    float inner = cylinderSDF(cp, vec2(.5, 1.5));\n    \n    float pend = differenceSDF(outer, inner); \n    \n    // fishing line\n    vec3 endpt = rotateX(cos(iTime)) * vec3(0.0, 0.0, 2.0);\n    endpt = rotateZ(sin(iTime)) * endpt;\n    float line = sdCapsule(p, -offset + vec3(0.0, 0.0, -.7), vec3(0.0, 0.0, -2.8), .0099);\n    \n    // set color\n    if(line < 0.0 + EPSILON)\n    {\n        K_d = vec3(1.0, 1.0, 1.0);\n    } \n   \n    \n    return unionSDF(line, pend);\n}\n\nfloat triangle_wave(float x, float freq, float amplitude)\n{\n    return abs(mod((x*freq), amplitude) - (0.5 * amplitude)) - 1.5;\n}\n\nfloat ball(vec3 p)\n{\n    //estimate circular motion as a pendulum so that I can match the period\n    // of motion with the pendulum\n    p -= vec3(0.0, 2.3, 0.0);\n    float g = 9.80665;\n    float L = 3.0;\n    float omega = sqrt(g/L);\n   \n    float theta = omega * cos(omega * iTime);\n    \n     \n    vec3 offset = vec3(0.0, 0.0, 6.0) * cos(theta - PI / 2.0);\n    offset += vec3(0.0, 6.0, 0.0) * -sin(theta - PI / 2.0);\n    \n    vec3 p_ball = p + offset;\n    vec3 p_stripe1;\n    vec3 p_stripe2;\n    \n    // flip direction of rotation at top of ramp\n    float direction = floor(triangle_wave(theta - PI / 2.0, PI / 2.0, 8.0)); \n    direction = clamp(direction, -1.0, 1.0);\n    \n   \tp_ball = rotateX(direction * omega * iTime) * p_ball;\n    p_stripe1 = rotateX(direction * omega * iTime) * p_ball + vec3(0.0, -.5, 0.0);\n    p_stripe2 = rotateX(direction * omega * iTime) * p_ball + vec3(0.0, .5, 0.0);\n    \n    \n    float ball = sphereSDF(p_ball);\n    \n    // model the stripe as a rectangle intersecting with the ball\n    float stripe1 = cubeSDF(p_stripe1, vec3(1.0, .2, 1.0));\n    float stripe2 = cubeSDF(p_stripe2, vec3(1.0, .2, 1.0));\n\n    // set color\n    if(stripe1 < 0.0 + EPSILON || stripe2 < 0.0 + EPSILON)\n    {\n        K_d = vec3(1.0, 1.0, 1.0);\n    }\n    \n    if(ball < 0.0 + EPSILON && K_d.x < 0.0)\n    {\n        K_d = vec3(.5, .5, 0.2);\n    } \n\n    return ball;\n}\n\n// iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n//iq\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  n = normalize(n);\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat groundPlane(vec3 p)\n{\n    float backrect = cubeSDF(p + vec3(25.0, .8, 0.0), vec3(20.5, .2, 15.0));\n    float plane = sdPlane(p + vec3(0.0, .8, 0.0), vec4(0.0, 1.0, 0.0, 1.0));\n    if(backrect < 0.0 + EPSILON)\n    {\n        K_d =  cos(perlinNoise(.5 * p)) * vec3(20, 55, 129) / 255.0;\n    }\n    if(plane < 0.0 + EPSILON)\n    {\n        K_d =  vec3(4, 45, 112) / 255.0;\n    }\n    return unionSDF(plane, backrect);\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    float ball = ball(samplePoint / .2) * .2;\n    float ramp = ramp((samplePoint - vec3(0.0, -.750, 0.0)) / 1.4) * 1.4;\n    float pend = pendulum((samplePoint - vec3(0.0, 1.1, 0.0)) / .6) * .6;\n    shininess = 10.0;\n    if(ramp < 0.0 + EPSILON)\n    {\n        // Woodgrain\n        float pattern = samplePoint.x;\n        vec3 p = rotateX(cos(perlinNoise(samplePoint))) *  rotateY(sin(perlinNoise(samplePoint))) * rotateZ(perlinNoise(samplePoint)) * samplePoint;\n        pattern = lines(p, .50) + lines(rotateX(30.0) * p + vec3(.5, 1.0, 1.0), .1) / 2.0;\n        vec3 d = vec3(178, 153, 132)/255.0;\n        vec3 b = vec3(114, 109.0, 94.0) / 255.0;\n        vec3 c = vec3(58.0, 52.0, 35.0) / 255.0;\n        vec3 a = vec3(99.0, 79.0, 62.0) / 255.0;\n        K_d = palette(pattern, a, b, c, d) * c + d + vec3(.02, .02, 0.0);\n    } \n    if(pend < 0.0 + EPSILON)\n    {\n        if(K_d.x < 0.0)\n        {  \n            // give the pendulum a gold color if color hasn't already been set\n            // if color has been set, that means its the fishing line\n    \t\tK_d = vec3(249.0 / 255.0, 199.0 / 255.0, 17.0 / 255.0);\n        }\n        shininess = .90;\n    }\n    float rampAndPend = unionSDF(ramp, pend);\n    float ground = groundPlane(samplePoint);\n    float scene = unionSDF(rampAndPend, ball);\n    \n    return unionSDF(scene, ground);\n}\n\n\n// Modified from iq\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = sceneSDF(ro + rd*t);\n        if( h<0.001 )\n            return 0.02;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n/** JW\n * \n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/** JW\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/** JW\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/** JW\n * \n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/** JW\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          10.0,\n                          6.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity)\n                \t\t\t\t* shadow(p, normalize(light1Pos - p), 0.1, 10.0, 8.0);\n         \t\t\t\t\t\t\n    \n    vec3 light2Pos = eye + vec3(2.0 ,\n                          2.0 ,\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity)\n         \t\t\t\t\t\t;   \n    return color;\n}\n\n/** JW\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(11.0, 3.0, 5.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir; // eye must be frag coord converted to world space! TO DO!!!!\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n  //  vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n   // float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtyz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 308, 308, 427], [429, 497, 528, 528, 710], [713, 713, 741, 741, 1891], [1893, 1921, 1965, 1965, 2036], [2038, 2122, 2149, 2149, 2296], [2298, 2382, 2409, 2409, 2556], [2558, 2642, 2669, 2669, 2816], [2819, 2913, 2959, 2959, 2991], [2993, 3080, 3122, 3122, 3154], [3156, 3248, 3295, 3295, 3328], [3330, 3335, 3368, 3368, 3455], [3457, 3549, 3574, 3574, 3604], [3606, 3612, 3649, 3649, 3748], [3750, 3755, 3788, 3788, 3853], [3855, 3861, 3902, 3902, 3995], [3997, 3997, 4017, 4017, 5619], [5621, 5627, 5679, 5679, 5806], [5808, 5808, 5833, 5833, 6726], [6728, 6728, 6787, 6787, 6857], [6859, 6859, 6879, 6990, 8231], [8233, 8239, 8311, 8311, 8354], [8357, 8362, 8395, 8421, 8472], [8474, 8474, 8501, 8501, 8892], [8895, 8895, 8929, 8929, 10256], [10259, 10279, 10344, 10344, 10565], [10567, 10582, 10673, 10673, 10979], [10994, 11005, 11070, 11070, 11202], [11204, 11296, 11325, 11325, 11635], [11637, 11652, 11792, 11792, 12382], [12384, 12470, 12555, 12555, 13403], [13405, 13735, 13784, 13819, 14045], [14049, 14049, 14106, 14106, 15016]], "test": "valid"}
{"id": "4dtyzN", "name": "GameCube Startup", "author": "salaark", "description": "Ray marching shader made to look like the Nintendo Gamecube startup animation.", "tags": ["intro", "gamecube", "nintendo"], "likes": 5, "viewed": 178, "published": "Public", "date": "1518132206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 60;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 30.0;\nconst float EPSILON = 0.001;\nconst float M_PI = 3.14159265359;\nconst float SPEED = 6.0;\n\nvec3 transform( vec3 p, mat4 m ) {\n    vec3 q = (inverse(m)*vec4(p,1)).xyz;\n    return q;\n}\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat quadSDF( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d ) {\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat squareSDF( vec3 p, vec3 o, float s, int x ) {\n    s /= 2.0;\n    vec3 a,b,c,d;\n    if(x == 0) {\n        a = o-vec3(s*1.414,0,s*1.414);\n        b = o+vec3(s*-1.414,0,s*1.414);\n        c = o+vec3(s*1.414,0,s*1.414);\n        d = o+vec3(s*1.414,0,s*-1.414);\n    } else if(x == 1) {\n        a = o-vec3(s*1.414,s*1.414,0);\n        b = o+vec3(s*-1.414,s*1.414,0);\n        c = o+vec3(s*1.414,s*1.414,0);\n        d = o+vec3(s*1.414,s*-1.414,0);\n    } else {\n        a = o-vec3(0,s*1.414,s*1.414);\n        b = o+vec3(0,s*-1.414,s*1.414);\n        c = o+vec3(0,s*1.414,s*1.414);\n        d = o+vec3(0,s*1.414,s*-1.414);\n    }\n    return quadSDF(p,a,b,c,d);\n}\n\nconst int sqaxes[17] = int[17](\n      0,0,0,0,1,1,1,1,1,1,2,2,2,2,2,2,2);\n\nfloat gsquaresSDF( vec3 p ) {\n    float result = MAX_DIST+1.0;\n    vec3 start = vec3(-2.5,-0.1,-4);\n    vec3 offs[17] = vec3[17]( vec3(0),\n        vec3(-1.6, 0, 0), vec3(-1.6, 0, 1.6),\n        vec3(-1.6, 0, 3.2), vec3(0), vec3(-2.5, -1.5, 3.3),\n        vec3(-2.5, -3.1, 3.3), vec3(-2.5, -4.7, 3.3),\n        vec3(-0.9, -4.7, 3.3), vec3(0.7, -4.7, 3.3), vec3(0),\n        vec3(1.5, -4.7, 2.5), vec3(1.5, -4.7, 0.9),\n        vec3(1.5, -4.7, -0.7), vec3(1.5, -3.1, -0.7),\n        vec3(1.5, -1.5, -0.7), vec3(1.5, -1.5, 0.9));\n    \n    int num = min(int(mod(floor(iTime*SPEED),23.0)), 17);\n    for(int i = 0; i < num; i++) {\n        if(i == 0 || sqaxes[i] == sqaxes[i-1]) {\n        \tresult = min(result, squareSDF(p,start+offs[i],1.0,sqaxes[i]));\n        }\n    }\n    return result;\n}\n\nfloat spincubeSDF( vec3 p ) {\n    float cosTheta = cos(fract(iTime*SPEED)*M_PI*0.5);\n    float sinTheta = sin(fract(iTime*SPEED)*M_PI*0.5);\n    \n    mat4 rotx = mat4(1, 0, 0, 0,\n    \t\t\t\t 0, cosTheta, sinTheta, 0,\n                     0, -sinTheta, cosTheta, 0,\n\t \t\t\t\t 0, 0, 0, 1);\n    mat4 roty = mat4(cosTheta, 0, -sinTheta, 0,\n    \t\t\t\t 0, 1, 0, 0,\n                     sinTheta, 0, cosTheta, 0,\n\t \t\t\t\t 0, 0, 0, 1);\n    mat4 roty2 = mat4(cosTheta, 0, sinTheta, 0,\n    \t\t\t\t 0, 1, 0, 0,\n                     -sinTheta, 0, cosTheta, 0,\n\t \t\t\t\t 0, 0, 0, 1);\n    mat4 rotz = mat4(cosTheta, sinTheta, 0, 0,\n    \t\t\t\t -sinTheta, cosTheta, 0, 0,\n                     0, 0, 1, 0,\n\t \t\t\t\t 0, 0, 0, 1);\n    mat4 roti = mat4(1, 0, 0, 0,\n    \t\t\t\t 0, 1, 0, 0,\n                     0, 0, 1, 0,\n\t \t\t\t\t 0, 0, 0, 1);\n    \n    vec3 pos = vec3(-0.9,0.5,-4);\n    vec3 scale = vec3(0.6);\n    int num = min(int(mod(floor(iTime*SPEED),23.0)), 21);\n    mat4 rotm;\n    vec3 rotp;\n    if(num < 2) {\n        pos.x -= float(num)*1.6;\n        rotm = rotz;\n        rotp = vec3(0.8,0.8,0);\n    } else if(num < 5) {\n        pos.x -= 3.2;\n        pos.z += float(num-2)*1.6;\n        rotm = rotx;\n        rotp = vec3(0,0.8,-0.8);\n    } else if(num < 8) {\n        pos.x -= 3.4;\n        pos.z += 4.5;\n        pos.y -= -0.2 + float(num-5)*1.6;\n        rotm = rotx;\n        rotp = vec3(0,0.8,0.8);\n    } else if(num < 11) {\n        pos.x -= 3.4 - float(num-8)*1.6;\n        pos.z += 4.6;\n        pos.y -= 4.6;\n        rotm = roty;\n        rotp = vec3(-0.8,0,0.8);\n    } else if(num < 14) {\n        pos.x += 1.0;\n        pos.z += 4.6 - float(num-11)*1.6;\n        pos.y -= 5.0;\n        rotm = roty;\n        rotp = vec3(0.8,0,0.8);\n    } else if(num < 16) {\n        pos.x += 0.7;\n        pos.z -= 0.8;\n        pos.y += float(num-14)*1.6 - 5.0;\n        rotm = rotz;\n        rotp = vec3(0.8,-0.8,0);\n    } else if(num < 17) {\n        pos.x += 0.7;\n        pos.z += float(num-16)*1.6-0.5;\n        pos.y += -1.8;\n        rotm = roty2;\n        rotp = vec3(0.8,0,-0.8);\n    } else if(num < 20){\n        float off = mod(iTime*SPEED,23.0)-17.0;\n        pos.x = -0.2;\n        pos.z += min(1.1 + off, 3.8);\n        pos.y += max(-1.8 + sin(off*1.0)*5.0, -1.8);\n        rotm = inverse(roty)*rotx;\n        rotp = vec3(0);\n    } else {\n        pos = vec3(-0.2);\n        rotm = roti;\n        rotp = vec3(0);\n        scale = vec3(0.8);\n    }\n    \n    p -= pos;\n    p = transform(p+rotp, rotm);\n    p -= rotp;\n\treturn length(max(abs(p)-scale,0.0))-0.07;\n}\n\nfloat sceneSDF(vec3 pos) {\n    return min(spincubeSDF(pos), gsquaresSDF(pos));\n}\n\nfloat shortestDistance(vec3 eye, vec3 marchingDirection) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 getNormal(vec3 p) {\n    if(spincubeSDF(p) > EPSILON) {\n        return vec3(0,1,0);\n    }\n    return normalize(vec3(\n        spincubeSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        spincubeSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        spincubeSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(9.0);\n    \n    if(mod(iTime*SPEED,23.0) > 20.0) {\n        eye.y += max(sin((mod(iTime*SPEED,23.0)-20.0)*M_PI*0.5)*2.5, -0.5);\n    }\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistance(eye, worldDir);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 color = vec3(0.2588, 0.1608, 0.6706);\n    float diffuseTerm = 1.0;\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    vec3 light = vec3(5,3,7);\n    vec4 refl = normalize(normalize(vec4(eye,1.0)-vec4(p,1))+normalize(vec4(light,1)));\n\tfloat specularTerm = pow(max(dot(refl,vec4(getNormal(p),1)),0.0),shininess);\n    \n    fragColor = vec4(color * diffuseTerm + specularColor * specularTerm,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 215, 215, 272], [275, 275, 300, 300, 319], [320, 320, 377, 377, 1017], [1019, 1019, 1070, 1070, 1669], [1746, 1746, 1775, 1775, 2523], [2525, 2525, 2554, 2554, 5017], [5019, 5019, 5045, 5045, 5099], [5101, 5101, 5159, 5159, 5483], [5497, 5497, 5562, 5562, 5694], [5696, 5696, 5720, 5720, 6108], [6110, 6110, 6159, 6159, 6385], [6387, 6387, 6444, 6444, 7445]], "test": "error"}
{"id": "4l2BDV", "name": "Sculpturing during cloudy day", "author": "pjdevpl", "description": "Sculture transformation during cloudy day. ", "tags": ["raymarching", "clouds", "sphere", "disortion"], "likes": 6, "viewed": 250, "published": "Public", "date": "1518903269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired by: \n// https://www.shadertoy.com/view/MdcXzn\n// https://www.shadertoy.com/view/XtjSDK\n\n#define pi2            (2.*3.141593)\n#define rotate(plane,a)  (plane=vec2(cos((a)*pi2)*plane.x+sin((a)*pi2)*plane.y,cos((a)*pi2)*plane.y-sin((a)*pi2)*plane.x))\n#define pmod(a,b)    ( mod(mod((a),(b))+(b),(b)) )\n#define rep(a,r)    ( pmod(((a)+(r)*.5),(r))-(r)*.5 )\n#define repxz(a,r)    vec3( rep((a).x,(r)), (a).y, rep((a).z,(r)) )\n\n#define EPSILON .05\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  \treturn length(p)-s;\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p)-b, 0.));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y,d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat waveform(float val)\n{\n    float time = pi2 * iTime;\n    return sin(time / 23. + val) + sin(time / 28. + val) + sin(time / 33. + val);\n}    \n\n\nfloat surface(vec3 p, vec3 s, float r)\n{\n    vec3 op = p;\n    p = repxz(p, r);\n    vec3 cell_center = op - p;\n\n    vec4 value = textureLod(iChannel0, (cell_center.xz/r+.5)/256., 0.);\n    p.y -= 1. - sin(waveform(value.y) + iTime / 10.);\n    \n    float f = udBox(p, s); \n    return f;\n}\n\nfloat noise(in vec3 x) //3d noise from iq\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(in vec3 x)\n{\n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<2; i++)\n    {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz;\n}\n\nvec4 cloud(vec3 pos)\n{\n    float szum = clamp(fbm(pos)-0.2,0.,1.);\n    vec4 col = vec4(0., 0., 0., szum * 1.);\n    return col;\n}\n\nvec2 fn(vec3 p) \n{    \n    vec2 f = vec2(1.);\n    \n    f = opU(f, vec2(surface(vec3(p.x, p.y - 2.3, p.z), vec3(.54, .05, .54), 1.15), sin(p.xz / 180. + 20.) * 0.4 + 0.5));\n    \n    float grow = iTime / 10.;\n    \n    // Maybe noise instead of waveform\n    p.xyz += 1.    * sin(2. * p.yzx)  * clamp(log(grow) + 2., 0., 1.) * waveform(0.) * .33;\n    p.xyz +=  .5   * cos(4. * p.yzx)  * clamp(log(grow) + 2., 0., 1.);\n    p.xyz +=  .25  * sin(8. * p.yzx)  * clamp(log(grow) + 2., 0., 1.);\n    p.xyz +=  .125 * cos(16. * p.yzx) * clamp(log(grow) + 2., 0., 1.);\n    \n    f = opU(f, vec2(.05 * sdSphere(p, 1.5), .5 + .3 * sin(p.xz / 2.5)));\n    \n    return f;\n}\n    \nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(EPSILON, 0.);    // delta (epsilon)\n    \n    vec3 n = normalize(vec3(\n            fn(vec3(pos.x+e.x, pos.y, pos.z)).x - fn(vec3(pos.x-e.x, pos.y, pos.z)).x,\n            fn(vec3(pos.x, pos.y+e.x, pos.z)).x - fn(vec3(pos.x, pos.y-e.x, pos.z)).x,\n            fn(vec3(pos.x, pos.y, pos.z+e.x)).x - fn(vec3(pos.x, pos.y, pos.z-e.x)).x));\n    \n    return n;\n}\n\nvec3 getTexture(vec3 n, sampler2D tex)\n{\n\tvec3 mat = vec3(0.);\n\t\n\t// material color from texture\n\tfloat u = atan(n.z, n.x) / 3.1415*2.;\n\tfloat v = asin(n.y) / 3.1415*2. + .5;\n\tmat = texture( tex, vec2(u,v)).xyz;\n\t\n\treturn mat;\n}\n\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softShadow( vec3 rayOrigin, vec3 rayDir, float tMin, float tMax)\n{\n\tfloat res = 1.;\n\tfloat k = 5.;\n    for( float t=tMin; t < tMax; )\n    {\n\t\tfloat h = fn( rayOrigin + rayDir*t).x;\n        if( h<.001 || t>tMax)\n            return 0.;\n\t\tres = min( res, k*h/t );\n        t += clamp( h, .05, .1 );\n    }\n    return clamp( res, 0., 1. );\n}\n\nvec3 calcLighting(vec3 rayDir, vec3 rayPos, vec2 dist)\n{\n    vec3 material;\n    vec3 texture[3];\n    vec3 color = vec3(0.);\n    vec3 factor = vec3(0.);\n    \n    vec3 normal = getNormal(rayPos);\n    vec3 sunCol = vec3(1., 1., 1.);\n    vec3 ref = reflect(rayDir, normal);\n    \n    vec3 light = vec3(1, -5., 1);  \n    \n    if(dist.y < 0.1f)\n        material = 0.1 + 0.1*(sin( vec3(0.05*sin(rayPos.x),0.08*tan(rayPos.y),0.1*cos(rayPos.z))*100.0));\n    else\n    {\n        float tmpCol = 1.f + dist.y;\n        material = 0.1 + 0.1*(sin( vec3(0.05,0.08,0.1)*(100.0*tmpCol)));\n    }\n\n    color = clamp(material, 0., 1.);\n    \n\tfloat ambient = clamp(0.5+0.5*normal.y, 0., 1.);\n    float diffuse = clamp(dot(normal, light), 0., 1.);\n    float backlight = clamp(dot(normal, normalize(vec3(-light.x, 0.,-light.z))), 0., 1. )*clamp( 1.-rayPos.y, 0., 1.);\n    float skydome = smoothstep( -.1, .1, ref.y);\n    float fresnel = pow(clamp(1.+dot(normal, rayDir), 0., 1.), 2.);\n\tfloat specular = pow(clamp(dot(ref, light), 0., 1.5), 16.);\n        \n    diffuse *= softShadow(rayPos, light, .02, 2.5);\n    skydome *= softShadow(rayPos, ref, .02, 2.5);\n        \n    factor += 2.5*diffuse*vec3(.5, .5, .5);\n\tfactor += 0.1*specular*vec3(.1, .1, .1)*diffuse;\n    factor += 0.5*ambient*vec3(.5, .5, .5);\n    factor += 0.5*skydome*vec3(.5, .5, .5);\n    factor += 0.5*backlight*vec3(.5, .5, .5); \n    factor += 0.5*fresnel*vec3(1., 1., 1.);\n\tcolor *= factor;\n\n    color = mix( color, vec3(1.,1.,1.), 1.-exp( -.0002*dist.x*dist.x*dist.x ));\n    \n\t// gamma correction\n\tcolor = pow( color, vec3(1./2.2));\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenPos = -1. + 2. * fragCoord.xy / iResolution.xy; // screenPos can range from -1 to 1\n\tscreenPos.x *= iResolution.x / iResolution.y; // Correct aspect ratio\n    \n    float angle = iTime * .1;\n    \n    vec3 front = normalize(vec3(sin(angle),0,cos(angle)));\n    vec3 up = vec3(0., -1., 0.);\n    vec3 right = cross(up, front);\n    \n    vec3 pos = vec3(waveform(angle) * .5 * sin(iTime), 0., waveform(angle) * .5 * cos(iTime))-front*4.5;\n\n    vec3 rayDir = normalize(front + screenPos.x*right + screenPos.y*up);\n\n    vec3 rayPos = pos;\n    vec3 cloudPos = pos;\n    \n    vec2 dist;\n    float st = 0.02;\n    \n    vec4 color = vec4(0., 0., 0., 1.);\n    \n    rayPos += rayDir*abs(sin(screenPos.x*200.*cos(screenPos.y*200.+iTime)))*st;\n    \n    for(int i=0;i<500;i++)\n    {\n        dist = fn(rayPos);\n        rayPos += dist.x*rayDir*st;\n        \n        if (i < 100)\n        {\n            cloudPos += rayDir*st; \n            vec4 c = cloud(cloudPos);\n            color.rgba += c.a;\n        }\n        \n        st += 0.002;\n        if(dist.x<.01 || st>2.0) break;\n    }\n    \n    \n    if (dist.x < EPSILON)\n        fragColor = mix(color * .1, vec4(calcLighting(rayDir, rayPos, dist), 0.), .9);\n    else\n        fragColor = clamp(mix(vec4(.35, .35, .45, .2), vec4(1., 1., 1., .2), color * .1), 0., 1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2BDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[455, 455, 483, 483, 518], [520, 520, 553, 553, 578], [580, 580, 609, 609, 649], [651, 651, 680, 680, 772], [774, 774, 801, 801, 915], [922, 922, 962, 962, 1207], [1209, 1209, 1252, 1252, 1461], [1463, 1463, 1485, 1485, 1640], [1642, 1642, 1664, 1664, 1770], [1772, 1772, 1790, 1790, 2426], [2432, 2432, 2458, 2458, 2830], [2832, 2832, 2872, 2872, 3060], [3062, 3128, 3200, 3200, 3469], [3471, 3471, 3527, 3527, 5069], [5071, 5071, 5126, 5126, 6431]], "test": "error"}
{"id": "4l2SR3", "name": "test shapes ggg", "author": "germangb", "description": "hello world", "tags": ["test", "shape"], "likes": 0, "viewed": 84, "published": "Public", "date": "1518966863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat field (vec3 p)\n{\n    float a = iTime*0.25;\n    float b = iTime*0.5;\n    mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n    mat2 rot2 = mat2(cos(b), sin(b), -sin(b), cos(b));\n    p.xz *= rot;\n    p.zy *= rot2;\n    \n    float f0 = sdBox(p, vec3(0.8));\n    float f1 = length(p)-1.0;//sdTorus(p, vec2(1.0, 0.5));\n    float f2 = sdHexPrism(p, vec2(1.0, 0.25)) + sin(p.y*5.0)*0.25;\n\tfloat f3 = length(p.xy)-1.0;\n    float t = 8.0;\n    float f = mix(f0, mix(f2, f1, sin(a*4.)*0.5+0.5), cos(a*4.0)*0.5+0.5);\n    f = mix(f0, mix(f3, f2, 0.5), 0.75);\n    \n    return f;\n}\n\nvec3 grad (vec3 p)\n{\n \tvec2 eps = vec2(0.0001, 0.0);\n    return vec3(\n        field(p+eps.xyy) - field(p-eps.xyy),\n        field(p+eps.yxy) - field(p-eps.yxy),\n    \tfield(p+eps.yyx) - field(p-eps.yyx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(sqrt(uv.y));\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec3 ro = vec3(uv, -1.75);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    float h = 0.0;\n    for (int i = 0; i < 128; ++i) {\n        vec3 p = ro+h*rd;\n        float eval = field(p);\n        \n        h += eval;\n        \n        if (eval < 0.001) {\n            vec3 normal = normalize(grad(p));\n            float dif = clamp(dot(normal, normalize(vec3(1.0, 1.0, -1.0))), 0.0, 1.0);\n            dif = mix(0.1, 1.0, dif);\n            fragColor = vec4(vec4(1.0, 0.6, 0.4, 1.0)*dif);\n            break;\n        }\n    }\n    \n    fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2SR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 127], [129, 129, 162, 162, 227], [229, 229, 265, 265, 349], [351, 351, 373, 373, 921], [923, 923, 943, 943, 1127], [1129, 1129, 1186, 1186, 1883]], "test": "valid"}
{"id": "4lBBWt", "name": "Hex Warp", "author": "mooped", "description": "Attempting to get a silly idea out of my head. Warping the isolines of a distance field towards the edges of a regular polygon. Put in a distance field for a point and get a hexagon out.", "tags": ["hexes"], "likes": 0, "viewed": 135, "published": "Public", "date": "1517523606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nfloat circle(vec2 pos, float rad)\n{\n    return length(pos) - rad;\n}\n\nfloat box(vec2 pos, vec2 b)\n{\n  vec2 d = abs(pos) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// polynomial smooth min (k = 0.1);\n// http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// This is rough and ready but it works for now\n// https://www.topcoder.com/community/data-science/data-science-tutorials/geometry-concepts-line-intersection-and-its-applications/#!\nvec2 line_line(vec2 s1, vec2 e1, vec2 s2, vec2 e2)\n{\n    float a1 = e1.y - s1.y;\n    float b1 = s1.x - e1.x;\n    float c1 = a1 * s1.x + b1 * s1.y;\n    \n    float a2 = e2.y - s2.y;\n    float b2 = s2.x - e2.x;\n    float c2 = a2 * s2.x + b2 * s2.y;\n    \n\tfloat det = a1*b2 - a2*b1;\n    if(det == 0.0)\n    {\n        // LINES ARE PARALLEL - SHOULD NEVER HAPPEN\n        return s1;\n    }\n    else\n    {\n        return vec2((b2*c1 - b1*c2) / det, (a1*c2 - a2*c1) / det);\n    }\n}\n\nvec2 getMouse()\n{\n    return iMouse.xy/iResolution.y;\n}\n\nfloat smush(vec2 uv)\n{\n    const float k = 0.01;\n    return smin(\n        smin(\n            circle(uv - vec2(0.7, 0.5), 0.1),\n            box(uv - vec2(0.5, 0.5), vec2(0.2, 0.1)),\n            k\n        ),\n        circle(uv - getMouse(), 0.1),\n        k\n    );\n}\n\nfloat orbit(vec2 uv)\n{\n    const float k = 0.1;\n    const vec2 pos = vec2(0.75, 0.5);\n    float dist = 0.1 * (2.0 + sin(iTime));\n    float ang = iTime / (2.0 * PI);\n    return smin(\n        circle(uv - pos, 0.0),\n        circle(uv - pos - dist * vec2(cos(ang), sin(ang)), 0.0),\n        k);\n}\n\nfloat dist(vec2 uv)\n{\n    \n    // Experiment with various distance fields\n    //return texture(iChannel0, uv).r; // Put in a texture, get a mess due to filtering\n    //return circle(uv - getMouse(), 0.0); // Put in a point, get a hexagon\n    //return circle(uv - getMouse(), 0.1); // Put in a circle, get a squishy hexagon\n    //return min(circle(uv - getMouse(), 0.0), circle(uv - vec2(.5, .5), 0.0)); // Two points, two hexagons\n    //return min(box(uv - getMouse(), vec2(0.2, 0.1)), circle(uv - getMouse() + vec2(0.2, 0.0), 0.1)); // Put in a random shape, get a thing with its own flats and 0, 30, 60 flats along curves\n    //return smush(uv); // Multiple shapes, blend with smin- box with a round end and a circle\n    return orbit(uv); // Orbiting points\n}\n\nconst float sides = 6.0;\nconst float seg = 2.0 * PI / sides;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.y);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Distance field lookup\n    float d = dist(uv);\n    vec2 n = normalize(vec2(dFdx(d), dFdy(d)));\n    \n    // Calculate angle towards distance field surface (0-2PI)\n    float ang = atan(n.y, n.x) + PI;\n    \n    // Work out the angle at which the segment starts and the angle from segment start to uv\n    float seg_ang = floor(ang / seg) * seg;\n    float rel_ang = abs(ang - seg_ang);\n    \n    // Compute vectors for each edge of the segment\n    vec2 s0 = vec2(cos(seg_ang), sin(seg_ang));\n    vec2 s1 = vec2(cos(seg_ang + seg), sin(seg_ang + seg));\n    \n    // Intersect the distance field normal with the edge of a unit hexagon (s1 - s0) to get a distance adjustment factor\n    float adjust = length(line_line(n, n + (s1 - s0), vec2(0), s1));\n    \n    // Adjust towards the hexagon edge - draws hexagons around the distance field for a circle\n    float val = d * pow(adjust, 0.5 + 0.5 * sin(iTime));\n    \n    val = sin((val + iTime * 0.1) * 50.0) > 0.0 ? 1.0 : 0.0;\n    \n    // Uncomment to silhouette the shapes\n    if (d < 0.0) val = 0.0;\n\n    // Output to screen\n    fragColor = vec4(val * col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBBWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 55, 55, 87], [89, 89, 118, 118, 198], [200, 292, 333, 333, 426], [428, 610, 662, 662, 1080], [1082, 1082, 1099, 1099, 1137], [1139, 1139, 1161, 1161, 1400], [1402, 1402, 1424, 1424, 1693], [1695, 1695, 1716, 2413, 2456], [2520, 2520, 2577, 2627, 3873]], "test": "valid"}
{"id": "4ljBWd", "name": "wave greek frieze 0: tuto", "author": "FabriceNeyret2", "description": "unpacked version of one single (animated) spiral.\nBase for greek+frieze shaders  [url]https://www.shadertoy.com/results?query=greek+frieze[/url]", "tags": ["waves", "patterns", "2tweets", "short", "greek", "frieze"], "likes": 17, "viewed": 638, "published": "Public API", "date": "1517589849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Base for greek+frieze shaders  https://www.shadertoy.com/results?query=greek+frieze\n\nvoid mainImage( out vec4 O,vec2 u ) \n{\n    O -= O;\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y,                // normalize coordinates\n         N = floor(U);                         // tile number\n    U = fract(U)-.5;                           // local tile coords in [-.5,.5]\n    \n    float v, d = length(U),                    // distance to tile center\n          t = 30.*sin( ( iTime - N.x ) / 5. ), // note the time delay with position\n          a = t * max(0.,.5-d );               // angle ~time, and decrease with d\n    U *= mat2(cos(a),-sin(a),sin(a),cos(a));   // rotate frame by angle(t,d)\n    v = U.y;                                   // pre-distortion pattern = vertical gradient.\n\n    O += u.x < R.x/2.                          // Display:\n        ? 5.*v                                 //  left: simple gradient\n        : smoothstep(-1.,1.,v/fwidth(v) );     //  right: ased clamp\n}\n    \n        \n\n/**  // 152 chars   golfed version\n\n#define mainImage(O,u)            \\\n\tvec2 U = u/iResolution.y;     \\\n    U.y = dot( cos( (2.*(iTime)+7.) * max(0.,.5-length(U = (U)-.5)) - vec2(33,0) ), U); \\\n\tO += smoothstep(-1.,1.,U/fwidth(U)).y\n        \n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljBWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 126, 126, 1004]], "test": "valid"}
{"id": "4ljcWd", "name": "cs1230-lab10", "author": "ruolan", "description": "cs1230-lab10\n1.texCube\n2.how to use the noise function for displacement mapping", "tags": ["raymarching"], "likes": 2, "viewed": 106, "published": "Public", "date": "1519609088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPHERE 0\n#define PLANE 1\n#define NO_INTERSECT 2\n#define DISPLACEMENT_FACTOR 0.1\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, PLANE, or NO_INTERSECT\n};\n\n// Helper function for tri3.\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\n// Triangle noise. Use it as a sample displacement map for task 7.\nvec3 tri3(in vec3 p) {\n    return vec3(tri(p.z+tri(p.y*1.)), \n                tri(p.z+tri(p.x*1.)), \n                tri(p.y+tri(p.x*1.)));\n}\n\n// TODO [Task 8] Make a displacement map\n// You can check out tri3 above and the functions in the handout as inspiration\nfloat calcDisplacement(in vec3 p) {\n    vec3 noise = tri3(p);\n    //return noise.x*noise.y*noise.z;\n    return sin(p.x)+cos(p.z);\n}\n\n// TODO [Task 6] Implement triplanar texture mapping\n// If you want, you can play around with the textures in iChannels 0 and 1\n// The textures should show no distortion\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{    \n    vec4 xaxis = texture( sam, p.yz)*abs(n.x);\n    vec4 yaxis = texture( sam, p.xz)*abs(n.y);\n    vec4 zaxis = texture( sam, p.xy)*abs(n.z);\n    \n    vec4 tex = xaxis+yaxis+zaxis;\n    return vec3(tex.x,tex.y,tex.z);\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    vec3 spherePosition = vec3(0.0, 0.25, 0.0);\n    float radius = 1.5;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive + calcDisplacement(p);\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\nPrimitiveDist map(vec3 p) {\n    // TODO [Task 3] Implement distance map\n    float myfloor = sdFloor(p);\n    float mysphere = sdTwistedSphere(p);\n    \n    if(myfloor<mysphere)\n        return PrimitiveDist(myfloor, PLANE);\n    else\n        return PrimitiveDist(mysphere, SPHERE);\n    //float closest = 0.0;\n    //return PrimitiveDist(closest, NO_INTERSECT);\n}\n\n// TODO [Task 4] Calculate surface normals\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    float xx = map(p + e.xyy).dist - map(p - e.xyy).dist;\n    float yy = map(p + e.yxy).dist - map(p - e.yxy).dist;\n    float zz = map(p + e.yyx).dist - map(p - e.yyx).dist;\n    \n    return normalize(vec3(xx,yy,zz));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.001;\n    float boundingVolume = 25.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n    \n    for(int i = 0; i < 30; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        darkness = min(darkness, k*h/marchDist);\n        \n        // TODO [Task 7] Modify the loop to implement soft shadows\n        if (h < threshold) {\n            darkness = 0.;\n            break;\n        }\n        marchDist += h * 0.7;\n    }\n    \n    return darkness;\n}\n\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd) {\n    \n    // TODO [Task 2] Implement ray marching algorithm\n    // Fill in parameters\n    float marchDist = 0.001;\n    float boundingDist = 50.0;\n    float threshold = 0.001;\n    int iterationCount = 1000;\n    \n    // Fill in the iteration count\n    for (int i = 0; i < iterationCount; i++) {\n        // Fill in loop body\n        vec3 curWorldPos = ro + marchDist*rd;\n        PrimitiveDist closestDis = map(curWorldPos);\n        marchDist += 0.1*closestDis.dist;\n        if(closestDis.dist < threshold)\n            return PrimitiveDist(marchDist, closestDis.primitive);\n        \n        if(marchDist>boundingDist)\n            return PrimitiveDist(-1.0, NO_INTERSECT);\n        \n    }\n    \n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n    \n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n    \n    // Normal vector\n    vec3 nor = calcNormal(pos);\n    \n    // Ambient\n    float ambient = 0.1;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0; \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    \n    float darkness = shadow(pos, lig, 18.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n    \n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = texCube(iChannel0, pos, nor);\n    } else if (which == SPHERE) {\n        material = texCube(iChannel1, pos, nor);\n    } else {\n        material = vec3(0.5);\n    }\n    \n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n    vec3 rayOrigin = vec3(6.0 * sin(iTime * .3), 4.8, 6.0 * cos(iTime * .3));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n  \n    // TODO [Task 1] Construct the ray direction vector\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=2.;\n    uv -=1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 rayDirection = vec3(uv, focalLength);\n    vec3 componantx = rayDirection.x * cameraRight;\n    vec3 componanty = rayDirection.y * cameraUp;\n    vec3 componantz = rayDirection.z * cameraForward;\n    rayDirection = normalize(componantx+componanty+componantz);\n\n      \n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection);\n    vec3 col = vec3(0.0);\n    if (rayMarchResult.primitive != NO_INTERSECT) {\n      col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 263, 286, 286, 314], [316, 383, 405, 405, 524], [526, 647, 682, 682, 778], [780, 950, 1003, 1003, 1225], [1227, 1269, 1300, 1300, 1477], [1479, 1479, 1502, 1502, 1520], [1522, 1522, 1549, 1593, 1879], [1982, 1999, 2024, 2024, 2243], [2245, 2245, 2286, 2286, 2814], [2817, 2817, 2859, 2944, 3594], [3596, 3596, 3647, 3704, 4754], [4756, 4756, 4811, 4811, 6042]], "test": "error"}
{"id": "4s3yD7", "name": "Moco", "author": "manuel519", "description": "like touch a weird and magical fluid", "tags": ["water", "fluid", "glsl", "shader", "moco"], "likes": 1, "viewed": 126, "published": "Public", "date": "1519104672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159235659\nfloat def(vec2 st,float f1);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord.xy/iResolution.xy;\nvec2 pos=vec2(0.5)-st;\n    float a=atan(pos.x,pos.y);\n    float rad=length(pos);\n    float time=iTime;\n    \n    float e=sin(rad*5.0*pi+sin(a*2.0)+time);\n    //sin(rad*pi*5+time)*0.05;\n    \n    float r=def(st,e*2.0-0.2);\n    float g=def(st,e+2.0);\n    float b=def(st,e*2.0+0.2);\n    \n    vec3 c1= vec3(0.98,0.02,0.2);\n    vec3 c2= vec3(0.3,0.41,0);\n    vec3 c3= vec3(0.5,0.01,0.3);\n    \n    vec3 colfin=vec3(r*c1)+vec3(g*c2)+vec3(b*c3);\n    \n    fragColor=vec4(colfin,1.0);\n}\n\n//From JPupper - Julian Daniel Puppo\nfloat def(vec2 st,float f1){\n vec2 pos=vec2(0.5)-st;\n    float a=atan(pos.x,pos.y);\n    float rad=length(pos);\n    float time = iTime;\n    float f=0.0;\n    //f1+=sin(sin(rad*5+sin(a*5)));\n    float cant=3.0;\n    st.x*=iResolution.x/iResolution.y;\n    st=st*2.0-1.0;\n    \n    for (int i=0;i<=int(cant);i++){\n    \n    vec2 pos1=vec2(0.5,float (i)/cant)-st;\n    float a1=atan(pos1.x,pos1.y);\n    float rad1=length(pos1);\n    \n   f+=sin(rad*5.0*pi+time+sin(rad1*5.0+time+sin(rad*f1+time))/cos(f*2.0+4.0));\n    f*=sin(pi/f1);\n   ///sin(a1*f+time*0.2)\n   //f*=length(abs(st)*f1);\n    }\nf*=1.0-smoothstep(f,f+0.5,rad);\n\nreturn (f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3yD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 111, 161, 679], [681, 718, 746, 746, 1344]], "test": "valid"}
{"id": "4s3yDH", "name": "Jus tSome Moving Colors", "author": "DJDoomz", "description": "just wanted to make something quick", "tags": ["2d", "plasma"], "likes": 6, "viewed": 3755, "published": "Public API", "date": "1518585357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*.3;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float a = t*.5;\n    float s=sin(a), c=cos(a);\n    uv*=mat2(c,s,-s,c);\n    uv += .1*sin(uv.yx*6.+t);\n    \n    uv = abs(uv);\n    uv*=mat2(c,s,-s,c);\n    \n    vec3 col = 0.5 + 0.5*cos(t*1.4+uv.xyx*5.+vec3(0,2,4)) + .3*sin(uv.xxx*(1.1+.2*sin(t*.9))*20.+t*.4)+.3;\n    \n    // Output to screen\n    fragColor = pow(vec4(col,1.0)*(1.-length(uv*1.6)),vec4(4));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3yDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 553]], "test": "valid"}
{"id": "4s3yDM", "name": "Spinal Cave", "author": "lsdlive", "description": "Monday doodling.\nStill training geometry.\n\nShading is just texture, lambert & a little bit of tweaking, it's simple & gives an old pc game horror style.", "tags": ["tunnel", "raymarch", "horror"], "likes": 25, "viewed": 590, "published": "Public", "date": "1519073136", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define PI 3.14159\n#define TWO_PI 2.*PI\n\n// hglib / iq\n// http://mercury.sexy/hg_sdf/\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat rep(float p, float d) {\n\treturn mod(p - d*.5, d) - d*.5;\n}\n\nvec3 rep(vec3 p, float d) {\n\treturn mod(p - d*.5, d) - d*.5;\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n\tp.x = abs(p.x) - d.x;\n\tp.y = abs(p.y) - d.y;\n\tif (p.y > p.x)p = p.yx;\n}\n\nvoid amod(inout vec2 p, float m) {\n\tfloat a = rep(atan(p.x, p.y), m);\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n#define sph(p, r) (length(p) - r)\n#define cube(p, b) length(max(abs(p) - vec3(b), 0.))\n\nfloat cyl(vec3 p, float r, float h) {\n\treturn max(length(p.xz) - r, abs(p.y) - h);\n}\n\n// signed\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// iq via leon/koltes\nfloat smoo(float a, float b, float r) {\n\treturn clamp(.5 + .5*(b - a) / r, 0., 1.);\n}\n\nfloat smin(float a, float b, float r) {\n\tfloat h = smoo(a, b, r);\n\treturn mix(b, a, h) - r*h*(1. - h);\n}\n\nfloat smax(float a, float b, float r) {\n\tfloat h = smoo(a, b, r);\n\treturn mix(a, b, h) + r*h*(1. - h);\n}\n\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(a*2., a*b);\n}\n\nvec4 opu(vec4 a, vec4 b) {\n\treturn a.w < b.w ? a : b;\n}\n\n//return vec4: vec3 color + float distance\nvec4 de(vec3 p) {\n\n\tvec4 surface;\n\tvec3 q;\n\n\tp.xy -= path(p.z);\n\n\n\tfloat bg_tun = -length(p.xy) + 4.;\n\n\tp.xy *= r2d(-3.14*.5);\n\tp.xy *= r2d(p.z*.1);\n\tp.y = abs(p.y) - .5;\n\tp.xy *= r2d(1.4);\n\n\t// spinal\n\tfloat t = 2.;\n\tp.z = mod(p.z - t*.5, t) - t*.5;\n\tfloat d = max(cyl(p.yzx, 1.2, .1), -cyl(p.yzx - vec3(.15, 0, 0), 1.1, .9));\n\td = smin(d, box(p - vec3(0, -1.05, 0), vec3(.1, .1, 1.)), .4);\n\tsurface = vec4(1, 1, 1, d);\n\n\tq = p;\n\n\t// medium tubes\n\tp.y -= 2.;\n\tamod(p.xy, 8.);\n\tmo(p.xy, vec2(.4, .1));\n\td = sph(p.xy, .1);\n\tp.z = rep(p.z, 6.);\n\tp.y *= .7;\n\td = min(d, sph(p, .15));\n\td = min(d, bg_tun);\n\tsurface = opu(surface, vec4(.2, .3, .4, d));\n\n\t// big tubes\n\tp = q;\n\tamod(p.xy, 3.);\n\tmo(p.xy, vec2(1.9));\n\td = sph(p.xy, .8);\n\tsurface = opu(surface, vec4(.7, .1, .1, d));\n\n\t// small tubes\n\tp = q;\n\tp.x -= .1;\n\tp.y += .5;\n\tamod(p.xy, 8.);\n\tmo(p.xy, vec2(.1, .1));\n\td = sph(p.xy, .02);\n\tsurface = opu(surface, vec4(.3, .2, .2, d));\n\n\treturn surface;\n\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\nvec3 normal(in vec3 pos)\n{\n\tvec2 e = vec2(1., -1.)*.5773*.0005;\n\treturn normalize(e.xyy*de(pos + e.xyy).w +\n\t\te.yyx*de(pos + e.yyx).w +\n\t\te.yxy*de(pos + e.yxy).w +\n\t\te.xxx*de(pos + e.xxx).w);\n}\n\n// from iq's boxmapping: https://www.shadertoy.com/view/MtsGWH\nvec4 boxmap(sampler2D sam, in vec3 p, in vec3 n, in float k)\n{\n\tvec3 m = pow(abs(n), vec3(k));\n\tvec4 x = texture(sam, p.yz);\n\tvec4 y = texture(sam, p.zx);\n\tvec4 z = texture(sam, p.xy);\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\n\n\n\tfloat dt = iTime * 6.;\n\tvec3 ro = vec3(cos(iTime)*.5, sin(iTime)*.5, -4. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n\tvec3 rd;\n\n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n\n\trd = camera(ro, uv, ta);\n\n\tvec3 p;\n\tvec4 res;\n\tfloat ri, t = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tres = de(p);\n\t\tif (res.w<.001 || t>30.) break;\n\t\tt += res.w;\n\t}\n\n\tvec3 bg = vec3(.15, .0, .0);\n\tvec3 col = bg;\n\tif (t <= 100.) {\n\t\tvec3 n = normal(p);\n\t\tcol = boxmap(iChannel0, p + .3, n, 32.).rgb * res.rgb;\n\t\tcol = col * (uv.y + .5)*1.7;\n\t\tcol *= dot(n, normalize(vec3(1., 1., -1.)));\n\t\tcol = smoothstep(0., 1., col);\n\t}\n\n\tfloat dist = length(ro - p);\n\tcol = mix(col, bg, 1. - exp(-.007 * dist*dist));\n    \n    col *= 2.;\n    col /= col + 1.; // then remap, with tone mapping\n    \n    // you may try this to increase brighness (proposed by movAX13h)\n    col = clamp(col, 0., 1.);\n\tcol = pow(col, vec3(2.2, 2.4, 2.5)) * 3.9;\n\tcol = pow(col, vec3(.4545));\n    \n\t// iq's vignetting\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\n\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3yDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 158, 187, 187, 222], [224, 224, 251, 251, 286], [288, 288, 319, 319, 392], [394, 394, 428, 428, 504], [506, 506, 525, 525, 585], [675, 675, 712, 712, 759], [761, 771, 798, 798, 887], [889, 911, 950, 950, 996], [998, 998, 1037, 1037, 1102], [1104, 1104, 1143, 1143, 1208], [1210, 1300, 1320, 1320, 1390], [1392, 1392, 1418, 1418, 1447], [1449, 1492, 1509, 1509, 2446], [2448, 2448, 2488, 2488, 2637], [2639, 2639, 2665, 2665, 2832], [2834, 2897, 2959, 2959, 3136], [3138, 3138, 3193, 3193, 4368]], "test": "error"}
{"id": "4s3yzS", "name": "shortest KIFS (208 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "fractal", "ifs", "kifs", "2tweets", "short", "classic", "golf"], "likes": 8, "viewed": 432, "published": "Public API", "date": "1519246862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// golfed from https://shadertoy.com/view/Xs3yzS\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = 1.2 * ( u+u - R ) / R.y;\n\n    O = sin( vec4(.2,.87, 1.4,-1.2) * iTime );\n    O -= .4*O.zwxy;\n\n    for( int i=0; i++<5; )\n        U =  ( 1. + ( abs(U) - 1. ) /(.4+O.x/12.) )\n            * mat2(cos( O.y + vec4(0,33,55,0)));\n\n    O += 1./dot(U,U) -O; }\n\n\n             \n             \n\n/**    // 276 chars\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    float T = .5*iTime;\n    vec2 R = iResolution.xy,\n         U = 1.2 * ( u+u - R ) / R.y, \n //      M = iMouse.xy / R;\n // if ( length(iMouse.xy)<10. )      // auto-demo\n         M = .5 + .4 *vec2( cos(T)-.4*sin(2.7*T), sin(1.73*T)-.3*cos(2.3*T) ) / 1.4;                     // relaxation duration\n\n    float s = (.5+.5*M.x)/2.,         // scaling\n          t = 1.-s,                   // translation\n          a = 3.14*M.y;               // rotation\n    \n    for( int i=0; i++<5; )\n        U = ( abs(U)-t ) / s * mat2(cos( a + vec4(0,33,55,0)));\n    \n    O += 1./dot(U,U); \n}\n\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3yzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 86, 86, 378]], "test": "error"}
{"id": "4sccWr", "name": "Into You", "author": "BigWIngs", "description": "Turn on your music and put fullscreen. Happy (future) Valentines Day!\nUse mouse Y to change focus.\nSee comments for details/credits", "tags": ["dof", "heart", "valentine", "love", "valentinesday", "romance", "romantic"], "likes": 35, "viewed": 3040, "published": "Public API", "date": "1518380816", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Into You - by Martijn Steinrucken aka BigWings - 2018\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// You can change the focal plane by moving the mouse up and down.\n\n// A video of the effect can be found here:\n// https://www.youtube.com/watch?v=lrMiME82Cuk\n\n// Making of video part1:\n// https://www.youtube.com/watch?v=dXyPOLf2MbU\n\n// Android Phone Wallpaper:\n// https://play.google.com/store/apps/details?id=com.TheArtOfCode.FallingHearts\n\n// Music - Novo Amor - Anchor\n// https://soundcloud.com/mrsuicidesheep/novo-amor-anchor\n\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n#define HEARTCOL vec3(1., .01, .01)\n#define NUM_HEARTS 50.\n#define LIGHT_DIR vec3(.577, -.577, -.577)\n\n// Polynomial smooth max from IQ\nfloat smax( float a, float b, float k ) {\n\tfloat h = sat( .5 + .5*(b-a)/k );\n\treturn mix( a, b, h ) + k*h*(1.-h);\n}\n\n// Quaternion rotation functions from Ollj\nvec4 qmulq(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}\nvec3 qmulv(vec4 q, vec3 p){return qmulq(q,qmulq(vec4(p,.0),qinv(q))).xyz;}\n\nvec2 RaySphere(vec3 rd, vec3 p) {\n    float l = dot(rd, p);\n    float det = l*l - dot(p, p) + 1.;\n    if (det < 0.) return vec2(-1);\n\n    float sd = sqrt(det);\n    return vec2(l - sd, l+sd);\n}\n\nstruct sphereInfo {\n\tvec3 p1, p2, n1, n2;\n    vec2 uv1, uv2;\n};\n\nsphereInfo GetSphereUvs(vec3 rd, vec2 i, vec2 rot, vec3 s) {\n\tsphereInfo res;\n    rot *= 6.2831;\n    vec4 q = aa2q(vec3(cos(rot.x),sin(rot.x),0), rot.y);\n    vec3 o = qmulv(q, -s)+s;\n    vec3 d = qmulv(q, rd);\n    \n    res.p1 = rd*i.x;\n    vec3 p = o+d*i.x-s;\n    res.uv1 = vec2(atan(p.x, p.z), p.y);\n    res.n1 = res.p1-s;\n    \n    res.p2 = rd*i.y;\n    p = o+d*i.y-s;\n    res.uv2 = vec2(atan(p.x, p.z), p.y);\n    res.n2 = s-res.p2;\n        \n    return res;\n}\n\nfloat Heart(vec2 uv, float b) {\n\tuv.x*=.5;\n    float shape = smax(sqrt(abs(uv.x)), b, .3*b)*.5;\n    uv.y -= shape*(1.-b);\n\n    return S(b, -b, length(uv)-.5);\n}\n\nvec4 HeartBall(vec3 rd, vec3 p, vec2 rot, float t, float blur) {\n    vec2 d = RaySphere(rd, p);\n    \n   \tvec4 col = vec4(0);\n    if(d.x>0.) {\n    \tsphereInfo info = GetSphereUvs(rd, d, rot, p);\n    \t\n        float sd = length(cross(p, rd));\n        float edge =  S(1., mix(1., 0.1, blur), sd);\n        \n        float backMask = Heart(info.uv2, blur)*edge; \n        float frontMask = Heart(info.uv1, blur)*edge; \n        float frontLight = sat(dot(LIGHT_DIR, info.n1)*.8+.2);\n        float backLight = sat(dot(LIGHT_DIR, info.n2)*.8+.2)*.9;\n\n        col = mix(vec4(backLight*HEARTCOL, backMask), \n                  vec4(frontLight*HEARTCOL, frontMask), \n                  frontMask);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime*.3;\n  \n    vec3 rd = normalize(vec3(uv, 1));\n    \n    m.y = iMouse.z>0. ? 1.-m.y : .4;\n\n    vec2 rot = t*vec2(.12, .18);\n    vec4 col = vec4(0);\n        \n    for(float i=0.; i<1.; i+=(1./NUM_HEARTS)) {\n        float x = (fract(cos(i*536.3)*7464.4)-.5)*15.;\n        float y = (fract(-t*.2+i*7.64)-.5)*15.;\n        float z = mix(14., 2., i);\n        \n        float blur = mix(.03, .35, S(.0, .4, abs(m.y-i)));\n        \n        rot += (fract(sin(i*vec2(536.3, 23.4))*vec2(764.4, 987.3))-.5);\n        vec4 heart = HeartBall(rd, vec3(x, y, z), rot, t, blur);\n        \n        col = mix(col, heart, heart.a);\n    }\n\t\n    fragColor = col;\n}", "image_inputs": [{"id": "ls2Xzm", "previewfilepath": "https://soundcloud.com/mrsuicidesheep/novo-amor-anchor", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mrsuicidesheep/novo-amor-anchor", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sccWr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[806, 839, 880, 880, 954], [956, 999, 1028, 1028, 1118], [1119, 1119, 1153, 1153, 1213], [1214, 1214, 1232, 1232, 1266], [1267, 1267, 1294, 1294, 1341], [1343, 1343, 1376, 1376, 1535], [1602, 1602, 1662, 1662, 2061], [2063, 2063, 2094, 2094, 2223], [2225, 2225, 2289, 2289, 2931], [2934, 2934, 2991, 2991, 3745]], "test": "valid"}
{"id": "4scyRH", "name": "floating island", "author": "laserdog", "description": "a magical floating island.\n\nsky background is from https://www.shadertoy.com/view/MdtXD2 by Bananaft", "tags": ["island", "flying", "magical"], "likes": 5, "viewed": 147, "published": "Public", "date": "1517873066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCTAVES 3\n#define EPSILON .02\n#define ISLAND_RADIUS 70.\n#define FALLOFF_DIST 25.\n#define MID_HALF_THICKNESS 3.\n#define BOB 5.\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Noise function by Morgan McGuire @morgan3d\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat3 lookAt(vec3 eye, vec3 target, vec3 up) \n{\n    vec3 f = normalize(target - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat3(r, u, -f);\n}\n\nfloat fbm(vec2 pos, float amp, float freq, float lac, float gain)\n{\n    float val = 0.;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        val += amp * noise(pos * freq);\n        freq *= lac;\n        amp *= gain;\n    }\n    \n    return val;\n}\n\nmat3 rotateY(float rads)\n{\n    return mat3(\n        vec3(cos(rads), 0., sin(rads)),\n        vec3(0., 1., 0.),\n        vec3(-sin(rads), 0., cos(rads))\n    );\n}\n\n\nfloat sceneSDF(vec3 pos) \n{\n    float d = max(0., (length(pos.xz) - (ISLAND_RADIUS - FALLOFF_DIST)) / FALLOFF_DIST);\n    float fact =  (-pow(d, 6.) + 1.);\n    \n    if (pos.y > 0.) \n    {\n    \treturn fbm(pos.xz, 17. * fact, .085, 1.1, .25) + MID_HALF_THICKNESS;\n    }\n    else\n    {\n    \treturn fbm(pos.xz, -90. * fact, .125, 2.2, .1) - MID_HALF_THICKNESS;\n    }\n}\n\nbool castRay(vec3 ro, vec3 rd, out float resT)\n{\n    const float mint = 45.;\n    const float maxt = 170.0;\n    \n    float dt = .5;\n    float lh = 0.0;\n    float ly = 0.0;\n    \n    float t = mint;\n    \n    for (float t = mint; t < maxt; t += dt)\n    {\n        vec3 p = ro + rd * t;\n        p.y += sin(iTime) * BOB;\n        float h = sceneSDF(p);\n        if ((p.y >= 0. && p.y < h) || (p.y <= 0. && p.y > h))\n        {\n            resT = t - dt + dt * (lh - ly) / (p.y - ly - h + lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n        dt = .01 * t;\n    }\n    \n    return false;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 n = vec3(\n        sceneSDF(vec3(p.x - EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x + EPSILON, p.y, p.z)),\n    \t2. * EPSILON * sign(p.y),\n        sceneSDF(vec3(p.x, p.y, p.z - EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z + EPSILON))\n\t);\n    \n    vec3 norm = normalize(p);\n    n = mix(vec3(norm.x, 0., norm.y), normalize(n),\n            smoothstep(0., 1., clamp(abs(p.y)/ 20., 0., 1.)));\n    \n    return normalize(n);\n}\n\nvec3 terrainColor(vec3 pos, vec3 lightDir)\n{\n    pos.y += sin(iTime) * BOB;\n    float diffuse = max(0., dot(getNormal(pos), lightDir));\n    \n    // brighten up the center due to the workaround for discontinuity\n    diffuse += smoothstep(80., 0., abs(pos.y)) * .2;\n    \n    return mix(vec3(.588, .47, .2745) * 1.5, vec3(.1, .7, .1), smoothstep(0., 18., pos.y)) * diffuse;\n}\n\nvec3 skyColor(vec2 uv) \n{\n    // this beautiful sky background is taken from Banananft's\n    // wonderful atmospheric shader: https://www.shadertoy.com/view/MdtXD2\n\tvec2 sunVec = vec2(1.5, .8);\n \n\tfloat sun = max(1.0 - (1.0 + 9.0 * sunVec.y + 1.0 * uv.y) * length(uv - sunVec),0.0)\n\t\t+ 0.3 * pow(1.0-uv.y,12.0) * (1.6-sunVec.y);\n\t\n\treturn vec3(mix(vec3(0.3984,0.6,0.9), vec3(0.7031,0.4687,0.2), sun)\n\t\t* ((0.5 + 1.0 * pow(sunVec.y,0.4)) * (1.25-uv.y) + pow(sun, 5.2)\n\t\t* sunVec.y * (5.0 + 15.0 * sunVec.y)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv0 = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 eye = rotateY(iTime / 4.) * vec3(15., 35., 110.);\n    vec3 viewRayDir = vec3(uv0, -1.);\n    \n    vec3 dir = normalize(lookAt(eye, vec3(0., -27., 0.), vec3(0., 1., 0.)) * viewRayDir);\n\n    float resT;\n    \n    if (castRay(eye, dir, resT))\n    {\n        fragColor.rgb = terrainColor(eye + dir * resT, vec3(0., 1., 0.));\n    }\n    else \n    {\n\t\tfragColor.rgb = skyColor(fragCoord.xy / iResolution.y);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 162, 162, 269], [271, 317, 343, 343, 723], [725, 725, 771, 771, 918], [920, 920, 987, 987, 1167], [1169, 1169, 1195, 1195, 1327], [1330, 1330, 1357, 1357, 1693], [1695, 1695, 1743, 1743, 2299], [2301, 2301, 2325, 2325, 2739], [2741, 2741, 2785, 2785, 3113], [3115, 3115, 3140, 3278, 3625], [3628, 3628, 3685, 3685, 4163]], "test": "valid"}
{"id": "4scyRs", "name": "Apollonianscopic kifs", "author": "gPlatl", "description": "A variant of 'Apollonian kifs' created by wyatt (sorry, couldn't resist) seen through a koleidoscope. \n\nMouse.Y changes symmetry, Mouse.X changes zoom factor, even if picture is paused!\n\nOK switch to full screen now and lean back!", "tags": ["fractal", "kifs", "inversion", "apollonian", "koleidoscope"], "likes": 4, "viewed": 219, "published": "Public", "date": "1519759059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//-----------------------------------------------------\n// Apollonianscopic_kifs.glsl                2018-02-27\n//\n// a koleidoscopic variant of 'Apollonian kifs' which\n// original creator is wyatt, https://www.shadertoy.com/view/Xdcyzl\n//\n// input:\n//   Mouse.Y changes symmetry, \n//   Mouse.X changes zoom factor, even if picture is paused!\n//\n// Tags: apollonian, kifs, fractal, fractal, inversion, koleidoscope\n//-----------------------------------------------------\n\nfloat k=0.0;  // 1.2 .. 1.4\n\nmat3 mr;   // rotation matrix\n\nmat3 rot (vec3 s) {\n\tfloat \tsa = sin(s.x),\tca = cos(s.x),\n\t\t\tsb = sin(s.y),\tcb = cos(s.y),\n\t\t\tsc = sin(s.z),\tcc = cos(s.z);\n\treturn mat3 (\n\t\t\tvec3(cb*cc, -cb*sc, sb),\n\t\t\tvec3(sa*sb*cc+ca*sc, -sa*sb*sc+ca*cc, -sa*cb),\n\t\t\tvec3(-ca*sb*cc+sa*sc, ca*sb*sc+sa*cc, ca*cb));\n}\n\nvec3 app (vec3 v) \n{\n\tfor (int i = 0; i < 70; i++)\n        v = abs(k*mr*v/dot(v,v)*0.5-0.5)*2.-1.; \n    return v;\n}\n\nvec3 ap (vec3 v) \n{\n\tfor (int i = 0; i < 15; i++)\n        v = abs(k*mr*v/dot(v,v)*0.5-0.5)*2.-1.; \n    return v;\n}\n\nvec3 norm (vec3 p) {\n\t\tvec2 e = vec2 (.05,0.);\n    \tvec3 g = ap(p);\n\t\treturn normalize(vec3(\n\t\t\t\tap(p+e.xyy).x - g.x,\n\t\t\t\tap(p+e.yxy).y - g.y,\n\t\t\t\tap(p+e.yyx).z - g.z));\n}\n\nconst float PI = 3.14159265359;\n\n//----------------------------------------------------------------\nvoid smallKoleidoscope(inout vec2 uv, float ka)\n{\n  float angle = abs (mod (atan (uv.x, uv.y), 2.0 * ka) - ka) + 0.01*iTime;\n  uv = length(uv) * vec2(cos(angle), sin(angle));\n}\n//----------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.xy*2. -1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mp = iMouse.xy / iResolution.xy;\n    uv *= 0.2 + 10. * mp.x;\n    float sideCount = 1.0 + round(mp.y * 11.0);\n    smallKoleidoscope (uv, PI / sideCount);\n    \n    float t = 0.015*iTime;\n    mr = rot(t+vec3(2,3,5));\n    k = 1.3+0.1*sin(0.08*iTime);\n    vec3 v = (.5+0.25*sin(0.03*iTime))*mr*vec3(2.*uv,0);\n    vec3 col = sin(app(v))*0.5+0.5;\n    col = col*0.8+0.2*(sin(norm(v))*0.5+0.5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "MsBSWW", "previewfilepath": "https://soundcloud.com/simone-peltier/the-beatles-lucy-in-the-sky-with-diamonds", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/simone-peltier/the-beatles-lucy-in-the-sky-with-diamonds", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 552, 552, 801], [803, 803, 823, 823, 918], [920, 920, 939, 939, 1034], [1036, 1036, 1056, 1056, 1207], [1242, 1309, 1358, 1358, 1485], [1486, 1553, 1610, 1610, 2135]], "test": "valid"}
{"id": "4scyzl", "name": "Mandelbrot variations", "author": "BenWheatley", "description": "Mandelbrot variations where the iterative function is replaced with z=z+c for 1.0<c<5.0. Also animated to be a 1960s screensaver.", "tags": ["mandelbrot", "mandelbar"], "likes": 2, "viewed": 114, "published": "Public", "date": "1519754998", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Mandelbrot variations\" by Ben Wheatley - 2018\n * License MIT License\n * Contact: github.com/BenWheatley\n */\n\nconst int LOOP_MAX = 64;\nconst float PI = 3.14159265359;\n\nfloat complexAbs2(vec2 z) {\n    return (z.x*z.x)+(z.y*z.y);\n}\n\nfloat arg(vec2 z) {\n\tfloat x = z.x;\n\tfloat y = z.y;\n    if (x>0.0) {\n\t\treturn atan(y/x);\n    } else if (y>0.0) {\n\t\treturn atan(y/x)+PI;\n    }\n\treturn atan(y/x)-PI;\n}\n\nvec2 complexExponent(vec2 z, float power) {\n    float r = sqrt(complexAbs2(z));\n    float arg = arg(z);\n    \n    float log_z_real = log(r);\n    float log_z_imag = arg;\n    \n    float x_log_real = power * log_z_real;\n    float x_log_imag = power * log_z_imag;\n    \n    float result_r = exp(x_log_real);\n    \n    return result_r*vec2(cos(x_log_imag), sin(x_log_imag));\n}\n\nvec3 rgbFromHue(float hue){\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(hue + K.xyz) * 6.0 - K.www);\n    return 0.75 * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), 0.75);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\t\n    float theta = sin(iTime/2.2);\n    vec2 uv_rotated = vec2(uv.x*cos(theta)-uv.y*sin(theta), uv.x*sin(theta)+uv.y*cos(theta));\n    uv = uv_rotated;\n    \n    vec2 offset1 = vec2(0.9, 0.5);\n    vec2 offset2 = vec2(0.3*sin(PI/2.0+iTime/7.0), 0.5*sin(-iTime/5.0));\n    float scale = 1.0+0.75*sin(iTime/2.0);\n    \n    vec2 c = (uv - offset1 - offset2)*scale;\n    vec2 z = c;\n    \n    vec3 rgb = vec3(0.0, 0.0, 0.0);\n    float basic = 0.0;\n    \n    for (int i=0; i<LOOP_MAX; i++) {\n        z = complexExponent(z, 3.0+(2.0*sin(iTime/2.0))) + c;\n        if (complexAbs2(z)>4.0) {\n            basic = float(i)/float(LOOP_MAX);\n\t\t\trgb = rgbFromHue(basic+iTime/2.0);\n            i = LOOP_MAX;\n            \n        } else if (i==(LOOP_MAX-1)) {\n            rgb = vec3(sin(z.x+iTime),\n            -sin(z.y+iTime),\n            cos(z.x*z.y + iTime));\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scyzl.jpg", "access": "shaders20k", "license": "mit", "functions": [[174, 174, 201, 201, 235], [237, 237, 256, 256, 402], [404, 404, 447, 447, 772], [774, 774, 801, 801, 966], [968, 968, 1023, 1073, 2030]], "test": "valid"}
{"id": "4sdcRB", "name": "lonely bacteria travels", "author": "malezoltekrety", "description": "Heart beating and stuff.\nHeart from https://www.shadertoy.com/view/XsfGRn\nTODO: it would be nice for bacteria to meet another one (or more), and merge into a bigger one. Not sure though how to keep reference to the center of another bacteria before merge.", "tags": ["2d", "metaballs", "bacteria"], "likes": 4, "viewed": 173, "published": "Public", "date": "1519402011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float wave(vec2 v, float t) {\n\treturn pow(sin(atan(v.y, v.x) * 8.0 + t), 2.0);\n}\n\nfloat source(vec2 uv, vec2 point){\n \treturn length(uv-point);\n}\nvec4 N14(float t){\n \treturn fract(sin(t*vec4(123., 1024., 3456., 9564.))*vec4(6547., 345., 8799., 1564.));   \n}\n\nfloat heart(vec2 uv, vec2 middle, float scale ){\n    vec2 p=uv;\n    p=p-middle;\n    p*=scale;\n    p*=scale/8.5;\n    vec4 n = N14(scale);\n    p.y = -0.1 - p.y*1.2 + abs(p.x)*(1.0-abs(p.x));\n\n    float r = length(p+n.xy*0.1*sin(iTime));\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float r = 0.5;// + wave(uv, 1.0) * 0.05 + wave(uv, 2.0 * 3.0) * 0.05;\n    float r2 = 0.01;\n    float delta = .01;\n    // Time varying pixel color\n    float t = iTime;\n    float balldist = 0.;\n    float i=0.;\n    float tantan = 0.;\n    vec2 globalMid;\n    vec2 middle;\n    for(float i =0.; i<1.; i+=.5){\n        vec4 n = N14(i);\n    \tmiddle = vec2(i*.5*sin(n.z+t*i*.25)+sin(i+t*.2)*.2, i*.6*cos(n.w+t*i)*.5+cos(i+t*.2)*.2);\n        globalMid +=middle;\n        float dist = r*0.1/source(uv, middle);\n\t \tballdist += dist;\n    }\n\n    globalMid = globalMid/3.;\n    if(balldist>0.4 && balldist<0.5){\n        if(abs(uv.y-globalMid.y)>0.001){\n    \t\ttantan =  abs((uv.x-globalMid.x)/(uv.y - globalMid.y));\n        }\n        else{\n            tantan = abs((uv.x-globalMid.x)/(uv.y - globalMid.y+0.002));\n        }\n    }\n    tantan = atan(tantan)*.5;\n    \n    float inside = smoothstep(0.54, 0.55, balldist);\n    // Output to screen\n    fragColor = vec4(.75, .75, .8, 1.);\n    float smoothing = pow(smoothstep(0.5, 0.4, balldist), 20.);\n    fragColor *= 1.-smoothstep(0.+smoothing, 0.5+smoothing, sin(tantan*50.-t*.95))*step( 0.4, balldist);\n    //fragColor =  (1.-step(0.5, balldist))*fragColor + inside*vec4(0.1, 0.75, 0.4, 1.);\n    fragColor =  mix(fragColor, inside*vec4(0.1, 0.75, 0.4, 1.), smoothstep(0.49, 0.5, balldist));\n    float h = heart(uv, middle, 8.);\n    float h2 = heart(uv, middle, 10.);\n    fragColor = mix(fragColor, vec4(0.0, 0.0, 0.0, 1.0), smoothstep(-0.01, 0.01, 0.5-h));\n    fragColor = mix(fragColor, vec4(1.0,0.,0.3, 1.), smoothstep(-0.01, 0.01, 0.5-h2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdcRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 80], [82, 82, 116, 116, 145], [146, 146, 164, 164, 257], [259, 259, 307, 307, 509], [511, 511, 568, 568, 2244]], "test": "valid"}
{"id": "4sdcWN", "name": "Blob Zoo", "author": "dr2", "description": "Lots of strange critters", "tags": ["metaballs", "cells", "architecture"], "likes": 10, "viewed": 561, "published": "Public API", "date": "1518947858", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Blob Zoo\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HexGrid (vec2 p);\n\nvec3 sunDir;\nvec2 gId;\nfloat tCur, dstFar, gcRnd, bHt;\nint idObj;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 SMap (vec3 p, float t)\n{\n  float f;\n  f = 2.;\n  for (int k = 0; k < 5; k ++) {\n    p += 0.4 * sin (1.7 * p.yzx / f + f * t);\n    f *= 0.8;\n  }\n  return p;\n}\n\nfloat BlobDf (vec3 p)\n{\n  float t;\n  t = tCur + 25. * gcRnd;\n  p *= 2.;\n  p.xz = Rot2D (p.xz, 0.2 * t);\n  return max (0.1 * SmoothMin (PrSphDf (SMap (p - vec3 (0.7, 1.8, 0.), t + 2.), 1.1 + 0.31 * sin (t)),\n     PrSphDf (SMap (p + vec3 (0.7, -1.8, 0.), 1.3 * t), 1. + 0.41 * sin (1.7 * t)), 0.5), - p.y);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, szFac, w, s;\n  szFac = 0.1;\n  dMin = dstFar / szFac;\n  p.xz -= HexToPix (gId);\n  p /= szFac;\n  w = 0.05;\n  q = p;\n  d = max (min (max (PrBoxAn2Df (q.xz, vec2 (2., 7.5), w), - PrBox2Df (q.xz, vec2 (2.1 + w, 2. - w))),\n     max (PrBoxAn2Df (q.xz, vec2 (7.5, 2.), w), - PrBox2Df (q.xz, vec2 (2. - w, 2.1 + w)))), abs (q.y - bHt) - bHt);\n  qq = q;\n  qq.xz = mod (qq.xz, 0.5) - 0.25;\n  s = 1. - sqrt (1. - smoothstep (1.3, 1.7, qq.y));\n  qq.y -= 0.82;\n  d = max (d, - min (PrBox2Df (qq.xy, vec2 (0.2 - 0.2 * s, 0.9)),\n     PrBox2Df (qq.zy, vec2 (0.2 - 0.2 * s, 0.9))));\n  DMIN (1);\n  q.xz = Rot2D (q.xz, pi / 6.);\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 6.));\n  q.xy -= vec2 (-10., 1.6);\n  d = PrCylAnDf (q.xzy, 1.15, 0.08, 0.015);\n  DMIN (2);\n  q.xz = Rot2D (vec2 (q.x - 0.65, abs (q.z)), - pi / 3.);\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.7, -0.8);\n  d = PrCylDf (q.xzy, 0.03, 0.8);\n  DMIN (3);\n  q = p;\n  q.y -= 0.05;\n  d = PrCylAnDf (q.xzy, 1.7, 0.07, 0.05);\n  DMIN (2);\n  q = p;\n  d = length (q.xz) - 1.7;\n  if (d < 0.1) {\n    d = BlobDf (q);\n    DMIN (4);\n  } else dMin = min (dMin, d);\n  return dMin * szFac;\n}\n\nvoid SetGrdConf ()\n{\n  gcRnd = Hashfv2 (17.3 * gId);\n  bHt =  (1./24.) * floor (22. + 5. * gcRnd);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = 1. / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2]));\n  pM = HexToPix (PixToHex (ro.xz));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = min (hv.x, min (hv.y, hv.z));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + 0.001;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = min (hv.x, min (hv.y, hv.z));\n    }\n    if (d < 0.0002 || dHit > dstFar || p.y < 0. || p.y > 2.) break;\n  }\n  if (d >= 0.0002) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.00002, -0.00002);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec2 TrackPath (float t)\n{\n  vec2 r;\n  float tt;\n  tt = mod (t, 4.);\n  if (tt < 1.) r = mix (vec2 (sqrt3 * 0.5, -0.5), vec2 (sqrt3 * 0.5, 0.5), tt);\n  else if (tt < 2.) r = mix (vec2 (sqrt3 * 0.5, 0.5), vec2 (0., 1.), tt - 1.);\n  else if (tt < 3.) r = mix (vec2 (0., 1.), vec2 (0., 2.), tt - 2.);\n  else r = mix (vec2 (0., 2.), vec2 (sqrt3 * 0.5, 2.5), tt - 3.);\n  r += vec2 (0.005, 3. * floor (t / 4.));\n  return r;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.001;\n  for (int j = 0; j < 40; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += min (0.005, 3. * h);\n    if (h < 0.001) break;\n  }\n  return 0.8 + 0.2 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.5) + 0.3 * pow (max (dot (rd, sunDir), 0.), 8.), vec3 (1.),\n     0.2 + 0.8 * rd.y * Fbm2 (2. * rd.xz / rd.y));\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.03, 0.07, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.35, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.9 + 0.1 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, qh, rg;\n  vec2 g, vf;\n  float dstObj, dstGrnd, spec, sh, f;\n  bool fxz;\n  dstGrnd = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstGrnd) < dstFar) {\n    sh = 1.;\n    vf = vec2 (0.);\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      gId = PixToHex (ro.xz);\n      SetGrdConf ();\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        col = HsvToRgb (vec3 (0.04 + 0.12 * gcRnd, 0.7, 0.7));\n        spec = 0.05;\n        if (ro.y > 0.2 * bHt - 0.0005) col*= 0.7;\n        if (abs (vn.y) < 0.01) {\n          rg = 10. * ro;\n          fxz = (abs (vn.x) > 0.99);\n          rg = ShStagGrid ((fxz ? rg.zy : rg.xy), 6. * vec2 (1., 2.));\n          col *= rg.y;\n          rg.xz *= sign (fxz ? vn.x : vn.z);\n          if (fxz) {\n            if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n            else vn.xz = Rot2D (vn.xz, rg.x);\n          } else {\n            if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n            else vn.zx = Rot2D (vn.zx, rg.x);\n          }\n        }\n      } else if (idObj == 2) {\n        col = vec3 (0.6, 0.6, 0.7);\n        spec = 0.1;\n        vf = vec2 (1024., 0.5);\n      } else if (idObj == 3) {\n        f = mod (256. * ro.y + atan (vn.z, vn.x) / (2. * pi), 1.);\n        if (abs (f - 0.5) < 0.4) {\n          col = vec3 (0.6, 0.6, 0.7);\n          spec = 0.1;\n          vf = vec2 (1024., 0.5);\n        } else {\n          col = vec3 (0.5, 0.7, 0.2);\n          vn.y = sin (2. * pi * (abs (f - 0.5) - 0.4) * sign (f));\n          vn.xz *= sqrt (1. - vn.y * vn.y);\n          spec = 0.3;\n        }\n      } else if (idObj == 4) {\n        col = HsvToRgb (vec3 (mod (13. * gcRnd, 1.), 1., 0.9));\n        spec = 0.3;\n        vf = vec2 (256., 0.5);\n      }\n      if (idObj != 3) sh = ObjSShadow (ro, sunDir);\n    } else {\n      ro += dstGrnd * rd;\n      gId = PixToHex (ro.xz);\n      SetGrdConf ();\n      vn = vec3 (0., 1., 0.);\n      g = ro.xz - HexToPix (gId);\n      if (length (g) < 0.17) {\n        col = vec3 (0.4, 0.4, 0.5);\n        vf = vec2 (256., 0.2);\n      } else if (abs (g.x) < 0.2 && abs (g.y) < 0.75 || abs (g.x) < 0.75 && abs (g.y) < 0.2) {\n        col = HsvToRgb (vec3 (0.3 + 0.15 * gcRnd, 1., 0.5));\n        vf = vec2 (256., 2.);\n      } else {\n        qh = HexGrid (32. * sqrt3 * ro.zx);\n        f = max (length (qh.xy) - 0.5, 0.);\n        vn = vec3 (0., Rot2D (vec2 (1., 0.), 4. * f * f));\n        vn.zx = vn.z * normalize (qh.xy);\n        col = vec3 (0.5, 0.45, 0.45);\n        col = mix (vec3 (0.5, 0.5, 0.3), col, smoothstep (0.036, 0.038, HexGrid (ro.xz).z));\n        col *= 0.8 + 0.2 * smoothstep (0.03, 0.06, qh.z);\n        g = Rot2D (g, pi / 6.);\n        g = Rot2D (g, 2. * pi * ((floor (6. * atan (g.y, - g.x) / (2. * pi) + 0.5)) / 6.));\n        g = Rot2D (vec2 (g.x + 0.935, abs (g.y)), - pi / 3.);\n        col *= 0.8 + 0.2 * smoothstep (0.003, 0.006, length (vec2 (abs (g.x) - 0.07, g.y)));\n      }\n      spec = 0.1;\n      sh = ObjSShadow (ro, sunDir);\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    col = col * (0.2 + 0.2 * max (dot (normalize (- sunDir.xz), vn.xz), 0.) +\n       0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       spec * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else {\n    col = (rd.y > 0.) ? SkyCol (rd) : vec3 (0.5, 0.45, 0.45);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa, vd, p1, p2;\n  float el, az, asp, vel, tCyc, tt, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  vel = 0.12;\n  tCyc = 4. / vel;\n  tCur = mod (tCur, 36000.) + floor (2. + floor (dateCur.w / 600.) / tCyc) * tCyc;\n  p1 = TrackPath (vel * tCur + 0.11);\n  p2 = TrackPath (vel * tCur - 0.11);\n  ro.xz = 0.5 * (p1 + p2);\n  ro.y = 0.09;\n  vd = p1 - p2;\n  az = atan (vd.x, vd.y);\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.2 * pi * mPtr.y;\n  } else {\n    a = 0.45 * pi * SmoothBump (0.25, 0.75, 0.12, mod (tCur / (0.25 * tCyc), 1.));\n    tt = mod (tCur / tCyc, 1.) - 0.375;\n    az += a * (step (abs (tt + 0.25), 0.125) - step (abs (tt - 0.25), 0.125));\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  asp = canvas.x / canvas.y;\n  uv.xy /= 2.5;\n  rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uv.x / asp)) * asp, uv.y, 1.));\n  dstFar = 50.;\n  sunDir = normalize (vec3 (0.5, 3., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w)\n{\n  return max (PrBox2Df (p, vec2 (b + w)), - PrBox2Df (p, vec2 (b - w)));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdcWN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[847, 847, 876, 876, 1008], [1010, 1010, 1033, 1033, 1316], [1318, 1318, 1340, 1340, 2528], [2530, 2530, 2550, 2550, 2630], [2632, 2632, 2665, 2665, 3864], [3866, 3866, 3887, 3887, 4089], [4091, 4091, 4117, 4117, 4509], [4511, 4511, 4548, 4548, 4964], [4966, 4966, 4989, 4989, 5134], [5136, 5136, 5170, 5170, 5526], [5528, 5528, 5563, 5563, 8881], [8883, 8883, 8939, 8939, 10265], [10267, 10267, 10299, 10299, 10399], [10401, 10401, 10434, 10434, 10523], [10525, 10525, 10569, 10569, 10644], [10646, 10646, 10679, 10679, 10706], [10708, 10708, 10750, 10750, 10801], [10803, 10803, 10856, 10856, 10917], [10919, 10919, 10964, 10964, 11067], [11069, 11069, 11126, 11126, 11209], [11211, 11211, 11241, 11241, 11315], [11317, 11317, 11341, 11341, 11571], [11573, 11573, 11597, 11597, 11657], [11659, 11659, 11682, 11682, 11815], [11817, 11817, 11841, 11841, 11977], [12011, 12011, 12035, 12035, 12095], [12097, 12097, 12121, 12121, 12251], [12253, 12253, 12278, 12278, 12464], [12466, 12466, 12487, 12487, 12642], [12644, 12644, 12673, 12673, 12885], [12887, 12887, 12926, 12926, 13106]], "test": "error"}
{"id": "4sdczj", "name": "Raymarching test - tmiya", "author": "tmiya", "description": "Raymarching test", "tags": ["raymarching"], "likes": 1, "viewed": 106, "published": "Public", "date": "1519570210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#extension GL_OES_standard_derivatives : enable\n\n#if GL_ES\nprecision mediump float;\n#endif\n\n#define EPSILON 0.0001\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define USE_SHADER_TOY 1\n\n#if USE_SHADER_TOY\n#define u_resolution iResolution.xy\n#define u_mouse iMouse.xy\n#define u_time iTime\n#else\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n#endif\n\nvec3 lightDir = normalize(vec3(0.5, 1.0, 1.0));\nvec3 lightColor = vec3(1.0, 0.8, 0.65);\n\nstruct Material\n{\n    vec3 albedo;\n};\n\nstruct RayResult\n{\n    float dist;\n    Material mat;\n};\n\n//-------------------------------------------------------------------------------------\n//  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//-------------------------------------------------------------------------------------\n\nRayResult sdSphere( vec3 p, float s, Material mat)\n{\n    RayResult result;\n    {\n        result.dist = length(p) - s;\n        result.mat = mat;\n    }\n    return result;\n}\n\nRayResult sdBox( vec3 p, vec3 b, Material mat )\n{\n    RayResult result;\n    {\n        vec3 d = abs(p) - b;\n        result.dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n        result.mat = mat;\n    }\n    return result;\n}\n\nRayResult sdTorus( vec3 p, vec2 t, Material mat )\n{\n    RayResult result;\n    {\n        vec2 q = vec2(length(p.xz)-t.x,p.y);\n        result.dist = length(q)-t.y;\n        result.mat = mat;\n    }\n    return result;\n}\n\nRayResult sdPlane( vec3 p, vec4 n, Material mat )\n{\n    RayResult result;\n    {\n        // n must be normalized\n        result.dist = dot(p,n.xyz) + n.w;\n        result.mat = mat;\n    }\n    return result;\n}\n\nRayResult sdTwistTorus(vec3 p, vec2 t, Material mat)\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, t, mat);\n}\n\nRayResult opU( RayResult r1, RayResult r2 )\n{\n    if (r1.dist < r2.dist) {\n        return r1;\n    } else {\n        return r2;\n    }\n}\n\n//-------------------------------------------------------------------------------------\n\n//-------------------------------------------------------------------------------------\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat Checkers(in vec2 p)\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nRayResult Raymarch(vec3 pos)\n{\n    RayResult result;\n    result.dist = 1.0;\n    result.mat.albedo = vec3(0.0, 0.0, 0.0);\n\n    // scene define\n    result = opU(result, sdPlane(pos, vec4(0.0, 1.0, 0.0, 0.1), Material(vec3(0.5))));\n    result = opU(result, sdSphere(pos - vec3(0.0, 0, 0), 0.1, Material(vec3(1.0, 0.0, 0.0))));\n    result = opU(result, sdTwistTorus(pos - vec3(-0.3, 0.05, 0), vec2(0.1, 0.05), Material(vec3(0.0, 1.0, 0.0))));\n    result = opU(result, sdBox(pos - vec3(0.3, 0, 0), vec3(.1, .1, .1), Material(vec3(0.0, 0.0, 1.0))));\n\n    return result;\n}\n\nvec3 GetNormal(vec3 pos)\n{\n    return normalize(vec3(\n        Raymarch(pos).dist - Raymarch(vec3(pos.x - EPSILON, pos.y, pos.z)).dist,\n        Raymarch(pos).dist - Raymarch(vec3(pos.x, pos.y - EPSILON, pos.z)).dist,\n        Raymarch(pos).dist - Raymarch(vec3(pos.x, pos.y, pos.z - EPSILON)).dist\n    ));\n}\n\nfloat CalcSoftshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for (int i=0 ; i<16 ; i++) {\n\t\tfloat h = Raymarch(ro + rd*t).dist;\n        res = min(res, 8.0*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if (h<0.001 || t>tmax) { break; }\n    }\n    return saturate(res);\n}\n\n//-------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - u_resolution.xy) / min(u_resolution.x, u_resolution.y);\n\n    // light\n    vec3 L = normalize(lightDir + vec3(sin(u_time), 0.0, cos(u_time)));\n\n    // camera\n    vec3 cam_pos = vec3(-5, 2, 10);\n    vec3 cam_target = vec3(0, 0, 0);\n\n    vec3 front = cam_target - cam_pos;\n    float target_len = length(front);\n    front = normalize(front);\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), front);\n    vec3 up = cross(front, right);\n\n    // ray\n    vec3 screen_pos = right * uv.x + up * uv.y + front * target_len;\n    vec3 ray = normalize(screen_pos - cam_pos);\n\n    // color\n    vec3 bg_color = vec3(0.7, 0.9, 1.0);\n    vec3 amb_color = vec3(0.3);    \n    vec3 color = bg_color;\n\n    // ray march\n    const int STEP = 256;\n    vec3 cur_pos = cam_pos;\n    for (int i=0 ; i<STEP ; i++) {\n        RayResult r = Raymarch(cur_pos);\n        if (r.dist < EPSILON)\n        {\n            // lighting\n            {\n                vec3 normal = GetNormal(cur_pos);\n                \n                // diffuse\n                vec3 diff = r.mat.albedo * vec3(saturate(dot(normal, L))) * lightColor;\n                // shadow\n                diff *= CalcSoftshadow( cur_pos, L, 0.02, 2.5 );\n                // ambient\n                vec3 amb  = r.mat.albedo * amb_color;\n                // final color\n                color = saturate(diff + amb);\n            }\n            break;\n        }\n        cur_pos += ray * r.dist;\n    }\n\n    // gamma\n    color.rgb = pow(color.rgb, vec3(1.0/2.2));\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdczj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[802, 802, 854, 854, 972], [974, 974, 1023, 1023, 1208], [1210, 1210, 1261, 1261, 1424], [1426, 1426, 1477, 1477, 1632], [1634, 1634, 1688, 1688, 1841], [1843, 1843, 1888, 1888, 1976], [2156, 2302, 2329, 2350, 2573], [2575, 2575, 2605, 2605, 3140], [3142, 3142, 3168, 3168, 3447], [3449, 3449, 3513, 3513, 3766], [3857, 3857, 3914, 3914, 5457]], "test": "valid"}
{"id": "4sdyz4", "name": "Formation from p7120A", "author": "patu", "description": "Experiment of using AO in different way.", "tags": ["raymarching"], "likes": 12, "viewed": 2527, "published": "Public API", "date": "1518051368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://github.com/patuwwy/ShaderToy-Chrome-Plugin\n// https://github.com/patuwwy/ShaderToy-Notifier\n\n#define FAR 30.\n#define t iTime\n\n#define FOV 130.0\n#define FOG .4\n\nvec3 opRep( vec3 p, vec3 c ) {\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// \t3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvec3 map(vec3 p) {\n    \n    p.y += noise(p * 6.1 + vec3(10, -iTime * .3, 0).xyy) * 0.175 - 1.;   \t\n    //p.y += noise(p * 2. + iTime * .2) * .1;\n    p = opRep(p, vec3(1., 3., 1.));\n    \n    vec3 obj2 = vec3(\n        fBox(p, vec3(1.3)), \n        0, \n        0\n    );\n    \n    return obj2;\n}\n\n\nvec3 trace(vec3 ro, vec3 rd) {\n    vec3 t = vec3(0., 0., 0.0);\n    for (int i = 0; i < 78; i++) {\n        vec3 d = map(ro + rd * t.x);\n        if (abs(d.x) < 0.001 || t.x > FAR) break;\n        t.x += d.x * .6;\n        t.yz = d.yz;\n    }\n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 28;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = .01;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.1), 1.0);\n}\n\n#define E .1\nvec3 getNormal(vec3 pos) {\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(E,0,0)).x-d,\n                map(pos+vec3(0,E,0)).x-d,\n                map(pos+vec3(0,0,E)).x-d \n        \t)\n    \t);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal) {\n    float \n        dist = 0.1;\n    \n    return clamp(map(hitp + normal * dist).x / dist, 0.0, .6);\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec2 mat) {\n\tvec3 sceneCol = vec3(0.0);\n    \n    vec3 ld = lp - sp; \n    float lDist = max(length(ld), 0.001);\n    ld /= lDist; \n\n    float diff = max(dot(sn, ld), .1);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.0), 2.);\n\n    vec3 objCol =  vec3(0.0);\n\n    sceneCol += (objCol * (diff + 0.15) + vec3(.6, .6, .6) * spec * 2.);// * atten;\n\n    return sceneCol;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n \n    uv *= tan(radians (FOV) / 2.0);          \n    \n    vec3 \n        vuv = vec3(0., 1., 0.), // up\n    \tro = vec3(-t, .0 - cos(2.+iTime * .05) * .4, sin(iTime * .1)),//-vec3(iMouse.x / 100. - 1.,iMouse.y / 100. - 1., 1.), // pos\n    \tvrp =  vec3(cos(iTime * .21), -5., 1.) + ro, // lookat    \n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        \n        light = vec3(0, 1.2, 0),  \n\n        lp = light + ro,\n        sceneColor = vec3(0.),\n        tr = trace(ro, rd);\n    \n    float \n        fog = smoothstep(FAR * FOG, 0., tr.x * 3.), \n        sh,\n        ao;        \n    \n    if (fog > .8) {\n        ro += rd * tr.x;\n\n        vec3 sn = getNormal(ro);\t\n        \n        ao = getAO(ro + vec3(300., 0., t) * noise(ro) * 0.1, sn);\n\n        sceneColor += doColor(ro, rd, sn, lp, tr.yz) * .3;\n        \n        sh = softShadow(ro, lp, 1.);\n\n        rd = reflect(rd, sn);\n\n        tr = trace(ro + rd * .01, rd);\n\n        ro += rd * tr.x;\n\n        sn = getNormal(ro);\n\n        sceneColor += doColor(ro, rd, sn, lp, tr.yz) * .7;\n\n        ao *= pow(getAO(ro, sn) * 9., .3);\n\n        sceneColor *= sh * fog;\n        sceneColor = mix(sceneColor, vec3(0., .9, 1.), pow((1.-ao) * fog, 2. - fog));\n    }\n    sceneColor = pow(sceneColor, vec3(.6));\n    fragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 201, 201, 230], [232, 232, 263, 263, 312], [314, 314, 334, 334, 369], [371, 407, 435, 435, 516], [518, 545, 566, 566, 815], [817, 817, 835, 835, 1106], [1109, 1109, 1139, 1139, 1361], [1363, 1363, 1408, 1408, 1983], [1998, 1998, 2024, 2024, 2238], [2240, 2240, 2283, 2283, 2384], [2386, 2386, 2459, 2459, 2821], [2823, 2823, 2878, 2878, 4411]], "test": "valid"}
{"id": "4stcRr", "name": "Ray Marching Experiment n76", "author": "aiekick", "description": "Variation of [url=https://www.shadertoy.com/view/MljSRD]Ray Marching Experiment n33bis[/url]", "tags": ["ray", "experiment", "marching", "76"], "likes": 16, "viewed": 633, "published": "Public API", "date": "1517791663", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\nSpace Body \nmy goal was to introduce some sub-surface scattering with hot color but the result is not as expected\nnormaly less thikness is more cold than big thickness. here this is the inverse ^^ its not wanted\n*/\n\n#define BLOB\n\n#define shape(p) length(p)-2.8\n\nfloat dstepf = 0.0;\n    \nconst vec2 RMPrec = vec2(.3, 0.01); \nconst vec3 DPrec = vec3(1e-5, 12., 1e-6); \n\n// by shane : https://www.shadertoy.com/view/4lSXzh\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); // I use this combination to pay homage to Shadertoy.com. :)\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n#ifdef BLOB\n    return  max(v.x, v.y) - max(v.z, v.w); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n#else\n    return max(v.x, v.y); // Maximum, or regular value for the regular Voronoi aesthetic.  Range [0, 1].\n#endif\n}\n\n///////////////////////////////////\nvec2 map(vec3 p)\n{\n    dstepf += 0.003;\n\n    vec2 res = vec2(0.);\n\t\n\tfloat voro = Voronesque(p);\n\t\n \tfloat sp = shape(p);\n    float spo = sp - voro;\n    float spi = sp + voro * .5;\n    \n\tfloat e = sin(iTime*.5)*.4 +.35;\n\t\n   \tfloat dist = max(-spi, spo + e);\n               \n\tres = vec2(dist, 1.);\n\t\n\tfloat kernel = sp + 1.;\n\tif (kernel < res.x ) \n\t\tres = vec2(kernel, 2.);\n\t\n\treturn res;\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n    map(pos+e.xyy).x - map(pos-e.xyy).x,\n    map(pos+e.yxy).x - map(pos-e.yxy).x,\n    map(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 561e5 * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 352e5 * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nconst vec3 RockColor = vec3(.2,.4,.58);\nconst vec3 DeepSpaceColor = vec3(0,.02,.15);\n        \nvoid mainImage( out vec4 f, in vec2 g )\n{\n    f = vec4(0);\n    \n    vec2 si = iResolution.xy;\n\tfloat t = iTime;\n    \n    float ca = t*.2; // angle z\n    float ce = 2.; // elevation\n    float cd = 4.; // distance to origin axis\n   \t\n    vec3 cu=vec3(0,1,0);//Change camere up vector here\n    vec3 cv=vec3(0,0,0); //Change camere view here\n    vec2 uv = (g+g-si)/min(si.x, si.y);\n    vec3 ro = vec3(sin(ca)*cd, ce+1., cos(ca)*cd); //\n    vec3 rd = cam(uv, ro, cu, cv);\n\n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n\tvec2 s = vec2(DPrec.y, 0.);\n    for(int i=0;i<200;i++)\n    {      \n\t\tif(s.x<DPrec.x||s.x>DPrec.y) break;\n        s = map(p);\n\t\ts.x *= (s.x>DPrec.x?RMPrec.x:RMPrec.y);\n\t\td.x += s.x;\n        p = ro+rd*d.x;\n   \t}\n\n\tif (d.x<DPrec.y)\n    {\n\t\tvec3 n = nor(p, .1);\n\t\tif ( s.y < 1.5) // icy color\n        {\n\t\t\trd = reflect(rd, n);\n\t\t\tp += rd*d.x;\t\t\n\t\t\td.x += map(p+n*0.05).x + map(p-n*0.05).x;\n\t\t\tf.rgb = exp(-d.x / RockColor / 15.);\n\t\t}\n\t\telse if( s.y < 2.5) // kernel\n\t\t{\n\t\t\tfloat b = dot(n,normalize(ro-p))*0.9;\n            f = (b*vec4(blackbody(2000.),0.9)+pow(b,0.2))*(1.0-d.x*.01);\n\t\t}\t\n   \t}\n    \n    f = mix( f, vec4(DeepSpaceColor, 1.), 1.0 - exp( -d.x*dstepf) ); \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stcRr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[509, 561, 592, 592, 1502], [1504, 1540, 1558, 1558, 1930], [1932, 1932, 1966, 1966, 2168], [2170, 2170, 2216, 2216, 2392], [2394, 2615, 2643, 2643, 2960], [3056, 3056, 3097, 3097, 4239]], "test": "valid"}
{"id": "4stcRs", "name": "Z+1 = exp(ln(Z)^2)", "author": "wyatt", "description": "LOOK!!!! IT'S SO COOL!!! \nalso cool thing about it is that it looks the same when you invert space\ndoes this have a name?", "tags": ["fractal", "imaginary"], "likes": 15, "viewed": 238, "published": "Public", "date": "1519843479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415927\nvec2 expo (vec2 v) {\n\treturn exp(v.x)*vec2(sin(v.y),cos(v.y));\n}\nvec2 ln (vec2 v) {\n\treturn vec2(log(length(v)), atan(v.x,v.y));\n}\nvec2 mul (vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nvec3 f (vec2 v) {\n    //v = v/dot(v,v);//inverting space does not alter fractal!\n    for (int i = 0; i < 19; i++) {\n        v = ln(v);\n        v = expo(mul(v,v));\n    }\n    return abs(clamp(10.*v.xyy,-.1,1.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    float t = 0.1*iTime;\n    mat2 m = mat2(sin(t),cos(t),-cos(t),sin(t));\n    float scale = 20.*exp(-16.*(-cos(0.2*iTime)*0.5+0.5));\n    vec2 v = scale*((m*uv))-vec2(0,0.04249);\n    vec3 e = scale*vec3(1,1,0)/iResolution.xyx;\n    \n    fragColor = vec4((f(v)+f(v+e.xz)+f(v+e.zy))/3.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stcRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 41, 41, 85], [86, 86, 104, 104, 151], [152, 152, 179, 179, 228], [229, 229, 246, 309, 440], [441, 441, 498, 498, 879]], "test": "valid"}
{"id": "4stczS", "name": "rational function", "author": "cailuming", "description": "I have trouble with drawing rational function which seems to have different width and discontinuous edge , any one who can help me?", "tags": ["figure"], "likes": 1, "viewed": 91, "published": "Public", "date": "1519465128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AXIS_WIDTH 0.004\n#define BIAS 1e-15\n \nvoid RationalFunc(inout vec3 col,vec2 uv){\n   \n    uv*=5.*(1.0+0.2*sin(iTime));\n    \n    float fx = 1.0/(-uv.x);\n    \n    float v = uv.y-fx;\n    if(abs(uv.x)>=0.1){\n       v=1.0/(abs(v)/fwidth(v));\n    }else{\n       v=0.0;\n    }\n    \n    \n    col = mix(col,vec3(v),0.5);\n \n}\n \n\nvoid Axis (inout vec3 col,vec2 uv,float as){\n    float vx = AXIS_WIDTH/as/abs(uv.x);\n    float vy = AXIS_WIDTH/abs(uv.y);\n    \n    vx=pow(vx,2.0);\n    vy=pow(vy,2.0);\n    \n    col=vec3(vx*0.2,vx*0.2,vx);   \n    col= mix(col,vec3(vy,vy*0.3,vy*0.2),0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    vec2 ms = iMouse.xy/iResolution.xy - vec2(0.5);\n    float as = iResolution.x/iResolution.y;\n \n    uv.x*=as;\n    ms.x*=as;\n    if(length(iMouse.zw)>0.){\n       uv-= ms;\n    }\n    vec3 col =vec3(0);\n    \n    Axis(col,uv,as);\n    RationalFunc(col,uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stczS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 88, 88, 320], [324, 324, 368, 368, 578], [580, 580, 637, 687, 1054]], "test": "valid"}
{"id": "4styRs", "name": "fractal trip Julia", "author": "yxo", "description": "just learning", "tags": ["fractal", "julia"], "likes": 0, "viewed": 68, "published": "Public", "date": "1519840563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//This function convert color from hsv to rgb\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    int numSteps = 1024;\n    float scale = 2.0;\n    vec2 translate = vec2(-0.11,-0.15554);\n    vec2 z, c;\n    c = vec2(-0.182,0.664);\n    c.x += abs(pow(0.6*sin(iTime*0.2),6.));\n    \n    scale = 0.0005;\n    scale += abs(pow(sin(iTime*0.2),6.)*3.0);\n    //scale = 2.9;\n    \n    z.x = 1.3333 * (uv.x - 0.5) * scale + translate.x;\n    z.y = (uv.y - 0.5) * scale + translate.y;\n\n    int i;\n    //z = c;\n    \n    for(i=0; i<numSteps; i++) {\n        float x = (z.x * z.x - z.y * z.y) + c.x;\n        float y = (z.x * z.y + z.y * z.x) + c.y;\n\n        if((x * x + y * y) > 4.0) break;\n        z.x = x;\n        z.y = y;\n    }\n    float r = (i == numSteps ? 0.0 : float(i)) / 100.0;\n    r = mix(r, r+1., c.y*c.x);\n    float hue = mix(0.2, 0.5, sqrt(r)*50.);\n    vec3 q = hsv2rgb(vec3(hue,1,1));\n\n    // Output to screen\n    fragColor = vec4(sqrt(q), 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4styRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 68, 68, 237], [239, 239, 296, 346, 1232]], "test": "valid"}
{"id": "4styzM", "name": "House in a Box", "author": "lsx", "description": "Based on https://www.shadertoy.com/view/Xds3zN", "tags": ["3d", "raymarching"], "likes": 21, "viewed": 296, "published": "Public", "date": "1518228577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adapted from https://www.shadertoy.com/view/Xds3zN\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n#define AA 1   // make this 1 is your machine is too slow\n#define PI 3.141592654\n#define repeat(v,c) (mod(v,c)-c/2.)\nfloat amod (inout vec2 p, float count) { \n    float an = 2. * PI /count; \n    float a = atan(p.y,p.x)+an/2.; \n    float c = floor(a/an); \n    c = mix(c,abs(c),step(count*.5,abs(c))); \n    a = mod(a,an)-an/2.; \n    p.xy = vec2(cos(a),sin(a))*length(p); \n    return c; \n}\n//------------------------------------------------------------------\n// __ Matrix functions __ _____________________________________\n\n// Return 2x2 rotation matrix\n// With vector swizzle/mask can use as a 3x3 xform\n// For y, you need to invert \n// angle in radians\n// ========================================\nmat2 Rot2(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat2( c, -s, s, c );\n}\n\n// http://www.songho.ca/opengl/gl_anglestoaxes.html\n\n// Return 4x4 rotation X matrix\n// angle in radians\n// ========================================\nmat4 Rot4X(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4( 1, 0, 0, 0,\n                    0, c,-s, 0,\n                    0, s, c, 0,\n                    0, 0, 0, 1 );\n}\n\n// Return 4x4 rotation Y matrix\n// angle in radians\n// ========================================\nmat4 Rot4Y(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4( c, 0, s, 0,\n                    0, 1, 0, 0,\n                -s, 0, c, 0,\n                    0, 0, 0, 1 );\n}\n\n// Return 4x4 rotation Z matrix\n// angle in radians\n// ========================================\nmat4 Rot4Z(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4(\n        c,-s, 0, 0,\n        s, c, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n        );\n}\n\n// Translate is simply: p - d\n// opTx will do transpose(m)\n// p' = m*p\n//    = [m0 m1 m2 m3 ][ p.x ]\n//      [m4 m5 m6 m7 ][ p.y ]\n//      [m8 m9 mA mB ][ p.z ]\n//      [mC mD mE mF ][ 1.0 ]\n// ========================================\nmat4 Loc4( vec3 p ) {\n    p *= -1.;\n    return mat4(\n        1,  0,  0,  p.x,\n        0,  1,  0,  p.y,\n        0,  0,  1,  p.z,\n        0,  0,  0,  1\n    );\n}\n\n\n// if no support for GLSL 1.2+\n//     #version 120\n// ========================================\nmat4 transposeM4(in mat4 m ) {\n    vec4 r0 = m[0];\n    vec4 r1 = m[1];\n    vec4 r2 = m[2];\n    vec4 r3 = m[3];\n\n    mat4 t = mat4(\n            vec4( r0.x, r1.x, r2.x, r3.x ),\n            vec4( r0.y, r1.y, r2.y, r3.y ),\n            vec4( r0.z, r1.z, r2.z, r3.z ),\n            vec4( r0.w, r1.w, r2.w, r3.w )\n    );\n    return t;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n#if 1\n    // distance bound\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n#else\n    // correct distance\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n#endif\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTx( vec3 p, mat4 m ) {   // BUG in iq's docs, should be q\n    return (transposeM4(m)*vec4(p,1.0)).xyz;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------\n//http://mercury.sexy/hg_sdf/\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvec2 map( in vec3 pos )\n{  \n    //ground\n    vec2 res =  vec2( sdPlane(     pos + vec3(0., 1, 0.)), 3.0 );\n\t//                 vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\n    //back\n    vec3 size;\n    vec3 translate;\n    vec3 newpos;\n    float angle = -PI/2.0; // 90 degrees\n    newpos = opTx( pos + vec3(0., 0., 2.0), Rot4X( angle ) );\n    res = opU( res, vec2( sdPlane(newpos), 3.));\n\n    //right\n    newpos = pos;\n    angle = -PI/2.0; // 90 degrees\n    newpos = opTx( pos + vec3(-2.0, 0., 0.0), Rot4Z( angle ) );\n    res = opU( res, vec2( sdPlane(newpos), 3.));\n\n    //left\n    newpos = pos;\n    angle = PI/2.0; // 90 degrees\n    newpos = opTx( pos + vec3(2.0, 0., 0.0), Rot4Z( angle ) );\n    res = opU( res, vec2( sdPlane(newpos), 3.));\n\n    //round box\n    newpos = pos;\n    //newpos.y -= 5.0;\n    newpos.y -= 4. * abs(-sin(iTime/2.0));\n    //newpos.y -= min(5.0, iTime);\n    vec2 roundboxout = vec2( udRoundBox(       newpos+vec3( 0.0,0.0, 0.0), vec3(1.0) , 0.0), 41.0 );\n    vec2 roundboxin = vec2( sdBox(       newpos+vec3( 0.0,0.2, 0.0), vec3(0.9, 0.9, 0.9)), 41.0 );\n    vec2 roundbox = opS(roundboxin, roundboxout);\n    res = opU( res, roundbox);\n\n    //middle stage\n    newpos = pos;\n    size = vec3(0.5, 0.35, 0.5);\n    translate = vec3(0.0, 1.0 - size.y, 0.0);\n    vec2 stage = vec2( sdBox(newpos+translate, size), 3.0 );\n\n    size = vec3(0.00, 0.1, 2.0);\n    translate = vec3(0.0, size.y - 1., 0.0);\n    vec2 door = vec2( udRoundBox(newpos-translate, size , 0.1), 3.0 );\n    stage = opS( door, stage);\n    res = opU( res, stage);\n\n    newpos = pos;\n    float shrink = 0.5;\n    // size = vec3(0.3, 0.5, 0.45);\n    // translate = vec3(0.0, -0.2, 0.0);\n    size = vec3(0.25, 0.5, 0.45);\n    translate = vec3(0.0, -0.2, 0.0);\n    vec2 stagetopout = vec2( sdBox(newpos+translate, size), 3.0 );\n    // size = vec3(0.4, 0.8, 0.5);\n    // translate = vec3(0.0, -0.6, -0.1);\n    size = vec3(0.2, 0.3, 0.4);\n    translate = vec3(0.0, -0.2,-0.2);  \n    // size = vec3(0.25, 0.5, 0.5);\n    // translate = vec3(0.0, -0.375,-0.3);     \n    vec2 stagetopin = vec2( sdBox(newpos+translate, size), 3.0 );\n    vec2 stagetop = opS(stagetopin, stagetopout);\n\n    angle = PI/2.0; // 90 degrees\n    newpos = opTx( pos - vec3(0.0, 1.0, 0.0), Rot4X( angle ) );\n\tvec2 prism = vec2( sdHexPrism( newpos, vec2(0.08,0.3) ),17.0  );\n\n    vec2 toppryam = vec2( sdCapsule(   pos - vec3(0.0, 1.15, 0.0),vec3(0.0,0.01,0.0), vec3(0.0,0.0,0.0), 0.1  ), 31.9 ) ;\n\n    float prismandtop = fOpUnionStairs(prism.x, toppryam.x, 0.075, 3.0);\n    float prismandstage = fOpUnionStairs(stagetop.x, prismandtop, 0.1, 3.0);\n    \n    size = vec3(0.3, 0.5, 0.02);\n    translate = vec3(0.0, 0.0,-0.52);    \n    vec2 stagewide = vec2( sdBox(newpos-translate, size), 3.0 );\n    \n    float stageandwide = fOpTongue(prismandstage, stagewide.x, 0.02, 0.01);\n    \n    size = vec3(0.3, 0.5, 0.02);\n    translate = vec3(0.0, 0.0,0.4);    \n    vec2 stagewidetop = vec2( sdBox(newpos+translate, size), 3.0 );\n    \n    float stageandwidetop = fOpUnionRound(stageandwide, stagewidetop.x, 0.05);\n\n    size = vec3(0.3, 0.5, 0.02);\n    translate = vec3(0.0, 0.0,1.16);    \n    vec2 stagewide2 = vec2( sdBox(newpos+translate, size), 3.0 );\n    \n    float stageandwide2 = fOpTongue(stageandwidetop, stagewide2.x, 0.02, 0.01);\n\n    res = opU( res, vec2(stageandwide2, 3.0));\n\n    newpos = pos;\n    vec2 smallbox = vec2( udRoundBox(newpos+vec3( 0.0,0.0, 0.0), vec3(0.1) , 0.0), 41.0 );\n    res = opU( res, smallbox);\n    \n    //house base\n    newpos = pos;\n    size = vec3(0.7, 0.6, 0.4);\n    translate = vec3(0.0, 1.0 - size.y, 0.0);\n    vec2 housebase = vec2( sdBox(newpos+translate, size), 3.0 );\n    //left\n    newpos = pos;\n    angle = PI * (3.1/4.0); // 90 degrees\n    newpos = opTx( pos - vec3(-0.6, -0.1, 0.0), Rot4Z( angle ) );\n    housebase = opS( vec2( sdPlane(newpos), 3.), housebase);\n    //right\n    newpos = pos;\n    angle = -PI * (3.1/4.0); // 90 degrees\n    newpos = opTx( pos - vec3(0.6, -0.1, 0.0), Rot4Z( angle ) );\n    housebase = opS( vec2( sdPlane(newpos), 3.), housebase);\n    housebase = opS( stagetopin, housebase);\n\n    //add leftroof\n    newpos = pos;\n    size = vec3(0.75, 0.62, 0.45);\n    translate = vec3(0.0, 1.0 - size.y, 0.0);\n    vec2 leftroof = vec2( sdBox(newpos+translate, size), 3.0 );\n    //left top\n    newpos = pos;\n    angle = PI * (3.1/4.0); // 90 degrees\n    newpos = opTx( pos - vec3(-0.82, -0.23, 0.0), Rot4Z( angle ) );\n    leftroof = opS( vec2( sdPlane(newpos), 3.), leftroof);\n    //left down\n    newpos = pos;\n    angle = PI * (3.1/4.0) + PI; // 90 degrees\n    newpos = opTx( pos - vec3(-0.8, -0.25, 0.0), Rot4Z( angle ) );\n    leftroof = opS( vec2( sdPlane(newpos), 3.), leftroof);\n    float housebaseandleftroof = fOpUnionStairs(leftroof.x, housebase.x, 0.05, 2.0);\n\n    //add rightroof\n    newpos = pos;\n    size = vec3(0.75, 0.62, 0.45);\n    translate = vec3(0.0, 1.0 - size.y, 0.0);\n    vec2 rightroof = vec2( sdBox(newpos+translate, size), 3.0 );\n    //left top\n    newpos = pos;\n    angle = -PI * (3.1/4.0); // 90 degrees\n    newpos = opTx( pos - vec3(0.82, -0.23, 0.0), Rot4Z( angle ) );\n    rightroof = opS( vec2( sdPlane(newpos), 3.), rightroof);\n    //left down\n    newpos = pos;\n    angle = -(PI * (3.1/4.0) + PI); // 90 degrees\n    newpos = opTx( pos - vec3(0.8, -0.25, 0.0), Rot4Z( angle ) );\n    rightroof = opS( vec2( sdPlane(newpos), 3.), rightroof);\n    float housebaseandroof = fOpUnionStairs(rightroof.x, housebaseandleftroof, 0.05, 2.0);\n\n    res = opU( res, vec2(housebaseandroof, 3.0));\n\n    res = opU( res, vec2( sdPryamid4(  pos-vec3(0.0,-0.5,0.45), vec3(0.8,0.7,0.2) ),3.0 ) );\n\n    angle = PI/2.0; // 90 degrees\n    newpos = opTx( pos - vec3(-0.18, -0.8, 0.65), Rot4X( angle ) );\n\tvec2 frontleftprism = vec2( sdHexPrism( newpos, vec2(0.02,0.3) ),3.0  );\n\n    res = opU( res, frontleftprism );\n\n    angle = PI/2.0; // 90 degrees\n    newpos = opTx( pos - vec3(0.18, -0.8, 0.65), Rot4X( angle ) );\n\tvec2 frontrightprism = vec2( sdHexPrism( newpos, vec2(0.02,0.3) ),3.0  );\n\n    res = opU( res, frontrightprism );\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 50.0;\n   \n#if 0\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    //float sca = 1.0;\n    float sca = (sin(iTime - PI / 2.0)/2.0+0.5);\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    float anime = (sin(iTime - PI / 2.0)/2.0+0.5);\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n         lin +=  0.5 * occ;\n         lin += 1.30*dif*vec3(1.00,0.80,0.55) * anime;\n         lin += 1.00*amb*vec3(0.40,0.60,1.00)*occ;\n         lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ * anime;\n         lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ * anime;\n         lin += 0.25*fre*vec3(1.00,1.00,1.00) * anime;\n\t\t col = col*lin;\n\t\t col += 10.00*spe*vec3(1.00,0.90,0.70) * anime;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 setCamera2( in vec3 from, in vec3 to, in vec3 tmp )\n{\n    vec3 forward = normalize(from - to); \n    vec3 right = cross(normalize(tmp), forward); \n    vec3 up = cross(forward, right); \n    return mat3( right, up, forward );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// TODO: make a Raymarcher!\n    //vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(gl_FragCoord.xy+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        float far = 8.2;\n        float near = 5.0;\n        float far2 = 0.62;\n        float near2 = 0.5;\n\n        float roz = near - (near - near2) * (sin(mod(iTime/2.0, PI) - PI / 2.0)/2.0+0.5);\n        vec3 ro = vec3( 0.0, 0.0, roz );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4styzM.jpg", "access": "shaders20k", "license": "mit", "functions": [[1508, 1508, 1548, 1548, 1777], [1912, 2087, 2108, 2108, 2190], [2245, 2341, 2363, 2363, 2540], [2542, 2638, 2660, 2660, 2834], [2836, 2932, 2954, 2954, 3111], [3113, 3348, 3369, 3369, 3506], [3509, 3604, 3634, 3634, 3932], [3934, 3934, 3959, 3959, 3974], [3976, 3976, 4011, 4011, 4037], [4039, 4039, 4070, 4070, 4161], [4163, 4163, 4206, 4206, 4266], [4268, 4268, 4313, 4313, 4355], [4357, 4357, 4390, 4390, 4445], [4447, 4447, 4483, 4483, 4725], [4727, 4727, 4779, 4779, 4893], [4895, 4895, 4938, 4938, 5179], [5181, 5181, 5217, 5217, 5520], [5522, 5522, 5558, 5558, 5657], [5659, 5659, 5697, 5697, 5866], [5868, 5868, 5940, 5940, 6155], [6157, 6157, 6224, 6263, 6635], [6637, 6637, 6662, 6662, 6699], [6701, 6701, 6726, 6726, 6784], [6786, 6786, 6811, 6811, 6876], [6878, 6878, 6913, 6913, 6984], [6986, 6986, 7021, 7021, 7092], [7094, 7094, 7131, 7131, 7184], [7256, 7256, 7286, 7286, 7337], [7339, 7339, 7369, 7369, 7402], [7404, 7404, 7434, 7434, 7463], [7465, 7465, 7494, 7529, 7576], [7578, 7578, 7602, 7602, 7734], [7736, 7835, 7893, 7893, 8003], [8005, 8005, 8060, 8060, 8104], [8106, 8106, 8154, 8154, 8239], [8241, 8241, 8266, 8281, 14321], [14323, 14323, 14363, 14363, 14982], [14985, 14985, 15063, 15063, 15323], [15325, 15325, 15357, 15357, 15796], [15798, 15798, 15840, 15840, 16190], [16192, 16268, 16304, 16325, 16548], [16550, 16550, 16589, 16589, 18413], [18415, 18415, 18467, 18467, 18644], [18646, 18646, 18704, 18704, 18875]], "test": "valid"}
{"id": "4styzN", "name": "paw metaballs", "author": "sidsuk", "description": "CIS 566, paw metaballs\nAnimation reference: https://camo.githubusercontent.com/04383354badbdd77b6fdbab1d847cb9c8636b5f3/68747470733a2f2f617373657473302e656c6c6f2e636f2f75706c6f6164732f61737365742f6174746163686d656e742f353135393836382f656c6c6f2d6f7074696d6", "tags": ["sdf", "smoothblending"], "likes": 0, "viewed": 72, "published": "Public", "date": "1518133535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.001\n#define MAX_DIS 1000.0\n#define PI 3.14159265359\n\n// sdf function, smooth blending from http://www.iquilezles.org/www/index.htm\n\n// sphere sdf function\nfloat sphereSDF(vec2 p, vec2 c,float radius) {\n    return length(p - c) - radius;\n}\n\n// polynomial smooth blend\nfloat smoothBlend(float a, float b, float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord - iResolution.xy / 2.0;\n    \n    float down = 25.0;\n    float scale = 0.4;\n    p /= down; // scale down sample point\n    \n    float dist = MAX_DIS;\n    \n    int num = 8;\n    \n    for(int i = 0; i < num; ++i) {\n        float radius = 5.0;\n        float angle = float(i) * 360.0 / float(num);\n        float x = radius * cos(radians(angle)) * (cos(iTime * PI / 1.5  + float(i) * PI / 4.0)  + 1.2) / 1.6;\n        float y = radius * sin(radians(angle)) * (cos(iTime * PI / 1.5  + float(i) * PI / 4.0)  + 1.2) / 1.6;\n        float s = scale * sphereSDF(p / scale, vec2(x, y), 1.0);\n        dist = smoothBlend(dist, s, 1.3);\n    }\n    dist = down * dist; // scale \n    \n    if(dist > 1.0 ) {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        return;\n    }\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4styzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 173, 219, 219, 256], [258, 285, 331, 331, 423], [425, 425, 482, 482, 1302]], "test": "valid"}
{"id": "4tBBDd", "name": "simple raymarch terrain flight", "author": "alex7900", "description": "I'm learning about the magical world of ray marching\n\nThe terrain outline relies on rounding errors, so it may or may not look right different devices...", "tags": ["terrain", "raymarch", "fog"], "likes": 3, "viewed": 210, "published": "Public", "date": "1517511451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 eye = vec3(-5.8, -5.35, 10);\nconst float FOV = 180.0;\nconst float FD = 40.0;\n\nfloat nse(vec2 v){\n\treturn sin(v.y*5.0)*cos(v.x*2.56)*sin(sin(v.y*2.18)*cos(v.x*1.16))/0.65;\n}\nfloat dts(vec3 eye, vec3 mdir, float depth, float e, float time) {\n\tfor (int i = 0; i < 255; i++) {\n\t\tvec3 ptgr = (eye + depth * mdir) + vec3(0,0,3);\n\t\tvec2 o = vec2(-time,-time);\n\t\tfloat h = nse((ptgr.xy+o) * 0.1)/2.0;\n\t\tfloat b = h+nse((ptgr.xy+o) * 0.7) / 5.0;\n\t\tfloat w = clamp(0.5+0.5*(b-h)/0.3, 0.0, 1.0 );\n\t\tfloat sm = mix( b, h, w ) - 0.3*w*(1.0-w);\n\t\tfloat dist = min(1.0, dot(ptgr,vec3(0.5,0.5,0.5)) + sm);\n\t\tif (dist < 0.000001)\n\t\t\treturn depth;\n\t\tdepth += dist;\n\t\tif (depth >= e)\n\t\t\treturn e;\n\t}\n\treturn e;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fc){\n    vec2 fragCoord = vec2(fc.x/iResolution.x, fc.y/iResolution.y);\n    vec2 scr = vec2(1);\n    float t = iTime;\n\tvec3 f = normalize(vec3(0.25,1.0,-4.0) - eye+vec3(cos(t)/2.0,-sin(t)/2.0,0.0));\n\tvec3 s = normalize(cross(f, vec3(0.0,0.0,1.0)));\n\tvec3 u = cross(s, f);\n\tfloat dist = dts(eye, (\n\t\tmat4(vec4(s, 0.0),vec4(u, 0.0),vec4(-f, 0.0),vec4(0.0, 0.0, 0.0, 1.0))\n\t\t*vec4(normalize(vec3(fragCoord - scr / 2.0, -scr.y / tan(radians(73.0+FOV) / 2.0))), 0.0)\n\t).xyz, 1.0, 100.0, t*3.0);\n    if (dist > 100.0){\n        fragColor = vec4(1.0);\n    }\n\tvec4 ret = vec4(vec4(0.1,0.1,0.1,1)-vec4(0.0,0.0,0.0,smoothstep(0.0, FD, dist)))/1.0+(fragCoord.y/3.0);\n\tfragColor = vec4(1.0,0.9,0.9,1.0)-vec4(vec3(0.2)+ret.rgb*3.0*ret.a,0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBBDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 107, 107, 183], [184, 184, 250, 250, 704], [705, 705, 752, 752, 1477]], "test": "valid"}
{"id": "4tSBDd", "name": "Animation - HW ZP", "author": "ZachPhillips", "description": "Animation homework for Graphics Prog", "tags": ["homework"], "likes": 0, "viewed": 58, "published": "Public", "date": "1517522810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//All my variables\nvec2 Location = vec2(.5,0.5);\nfloat radius = 0.1;\nvec3 BgColor = vec3(1.0,0.0,0.0);\nvec3 FgColor = vec3(1.0,0.0,1.0);\n\nfloat frequency = 3.0;\nfloat amplitude = 0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n    //creates the aspect ration needed to adjust the circle\n  float aspectRatio = iResolution.y / iResolution.x;  \n    \n  vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //adjusts the circle to make it round\n  uv.y *= aspectRatio;\n    \n     vec4 text = texture(iChannel0, uv);\n    \n    //adjusts the offset from the aspect ratio\n  Location.y *= aspectRatio;\n\n    //moves the circle up and down\n  Location.y = Location.y + sin(iTime * frequency) * amplitude;\n    \n    //adjust the background gradient to move over time\n  BgColor.r*=  sin(iTime * 5.0);\n  FgColor*=  sin(iTime * 3.0) + 1.5;\n  \n    //changes the radius of the circle over time\n    //this gives the effect of the circle coming\n    //closer and moving away\n  radius *= sin(iTime * 1.5);\n    \n    //draws the circle\n  if(length(Location - uv) < radius)\n  \tfragColor = vec4(FgColor,1.0);\n    //draws the gradient \n  else{ \n  \tfragColor = vec4(BgColor,1.0);   \n \tfragColor.rgb *= uv.x;\n  }\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSBDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 242, 311, 1203]], "test": "error"}
{"id": "ld3czr", "name": "perlinesque", "author": "hypothete", "description": "I've struggled with understanding Perlin noise for a long time, but I think I got the hang of it today.", "tags": ["noise", "perlin", "gradient"], "likes": 2, "viewed": 132, "published": "Public", "date": "1517769632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWOPI 6.28319\n\n#define TERRAIN\n\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec2 grad (vec2 st) {\n    float nn = rand(st);\n    return vec2(cos(nn * TWOPI), sin(nn * TWOPI));\n}\n\nfloat gradnoise (vec2 st) {\n    // returns range -1, 1\n    vec2 pa = floor(st);\n    vec2 pb = pa + vec2(1.0, 0.0);\n    vec2 pc = pa + vec2(0.0, 1.0);\n    vec2 pd = pa + vec2(1.0);\n    vec2 ga = grad(pa);\n    vec2 gb = grad(pb);\n    vec2 gc = grad(pc);\n    vec2 gd = grad(pd);\n    float ca = dot(ga, st - pa);\n    float cb = dot(gb, st - pb);\n    float cc = dot(gc, st - pc);\n    float cd = dot(gd, st - pd);\n    vec2 frast = fract(st);\n    return mix(\n        mix(ca, cb, smoothstep(0.0, 1.0, frast.x)),\n        mix(cc, cd, smoothstep(0.0, 1.0, frast.x)),\n        smoothstep(0.0, 1.0, frast.y));\n}\n\nfloat perlin (vec2 st, float scale, float freq, float persistence, float octaves) {\n    float p = 0.0;\n    float amp = 1.0;\n    for (float i=0.0; i<octaves; i++) {\n    \tp += gradnoise(st * freq / scale) * amp;\n        amp *= persistence;\n        freq *= 2.0;\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pers = 0.6;\n    float perld = perlin(fragCoord.xy + vec2(iTime * 64.0, 0), 128.0, 0.5, pers, 6.0);\n    \n    perld = perld * 0.5 + 0.5;\n    \n    vec3 col = vec3(perld);\n    \n#ifdef TERRAIN\n    float water = 0.5;\n    if (perld > water) {\n        // normalize gray val\n        col.rgb = vec3(pow((col.r - water) / (1.0 - water),1.0/2.2));\n        // generate shadow\n        float perle = perlin(fragCoord.xy + vec2(1.0, -1.0) + vec2(iTime * 64.0, 0), 128.0, 0.5, pers, 6.0);\n        perle = perle * 0.5 + 0.5;\n        if (perle < perld) {\n            col.rgb -= (perld - perle) * 32.0;\n        }\n    }\n    else {\n        col.r = 0.0;\n        col.g /= 2.0 * water;\n        col.b = 0.75;\n    }\n#endif\n    fragColor = vec4(\n        col,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3czr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 62, 62, 134], [136, 136, 157, 157, 235], [237, 237, 264, 291, 834], [836, 836, 919, 919, 1116], [1118, 1118, 1175, 1175, 1937]], "test": "valid"}
{"id": "ld3czS", "name": "Moonlight Sillyness", "author": "stellabialek", "description": "having some fun", "tags": ["raymarching", "clouds", "sky", "volumetric", "moon"], "likes": 34, "viewed": 463, "published": "Public", "date": "1519314936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CLOUDS_ON\n\n\nconst float STEPS = 120.0;\nconst float STEPSIZE = 0.05;\nconst float DRAWDIST = STEPS * STEPSIZE;\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWOPI = 2.0 * PI;\n\nconst int OCTAVES = 3;\n\nstruct ray\n{\n\tvec3 o; //origin\n\tvec3 d;\t//direction\n};\n\nvec3 calcCameraRayDir(float fov, vec2 fragCoord, vec2 resolution) \n{\n\tfloat fx = tan(radians(fov) / 2.0) / resolution.x;\n\tvec2 d = fx * (fragCoord * 2.0 - resolution);\n\tvec3 rayDir = normalize(vec3(d, 1.0));\n\treturn rayDir;\n}\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099 + .1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat rand(float seed)\n{\n\treturn fract(sin(seed) * 1231534.9);\n}\n\nfloat rand(vec2 seed) \n{ \n    return rand(dot(seed, vec2(12.9898, 783.233)));\n}\n\nfloat noise( in vec3 x )\n{\n\tx *= 2.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(vec3 p)\n{\n\tp *= 1.4;\n\tfloat f = 0.0;\n\tfloat weight = 0.5;\n\tfor(int i = 0; i < OCTAVES; ++i)\n\t{\n\t\tf += weight * noise( p );\n\t\tp.z -= iTime * float(i) * 0.5;\n\t\tweight *= 0.5;\n\t\tp *= 2.0;\n\t}\n\treturn f;\n}\n\nfloat density(vec3 p)\n{\n    p.y += 1.2;\n\tp.y += cos(p.x*1.4) * 0.2;\n\tp.y += cos(p.z)*0.1;\n    p *= 1.2;\n\tp.z += iTime * 0.4;\n\tfloat noise = fbm(p);\n\tfloat clouds = noise*1.5 - p.y - 1.3;\n\treturn clamp(clouds, 0.0, 1.0);\n}\n\nvec3 clouds(vec3 p, float d, float l, vec3 bg)\n{\n\tvec3 lPos = vec3(0,0, DRAWDIST*1.75);\n\tvec3 lDir = lPos - p;\n\n\tfloat dL = density(p + normalize(lDir) * 0.2);\n\tfloat dG = clamp(d - dL, 0.0, 1.0);\n\tdG *= 1.0 - smoothstep(2.0,8.0, length(lDir));\n\tdG *= 70.0;\n\tvec3 cL = vec3(0, 0.1, 0.1) + vec3(1.0) * dG;\n\tvec3 cA = mix( vec3(1.0, 1.0, 1.0), vec3(1.0)*0.01, d);\n\t\n\tfloat a = 0.2;\n\tfloat t = exp(-a * l);\t\n\treturn mix(bg, cL * cA, t);\n}\n\nfloat stars(vec2 uv, float amount, float radius)\n{\n\tuv = uv * amount;\n\tvec2 gridID = floor(uv);\n\tvec2 starPos = vec2(rand(gridID),rand(gridID+1.0));\n\tstarPos = (starPos - 0.5) * 2.0;\n\tstarPos = vec2(0.5) + starPos * (0.5 - radius * 2.0);\n\tfloat stars = distance(fract(uv), starPos);\n\tfloat size = rand(gridID)*radius;\n\tstars = 1.0 - smoothstep(size, size + radius, stars);\n\treturn stars;\n}\n\nfloat gradient(vec2 uv)\n{\n\tuv.x *= 0.8;\n\tuv *= 1.0 + sin(iTime*10.0) * 0.01;\n\tfloat g = clamp(1.0 - length(uv), 0.0, 1.0);\n\treturn clamp(g, 0.0, 1.0);\n}\n\nfloat circle(vec2 uv, float r)\n{\n\treturn length(uv)-r;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 rotate(vec2 p, float angle)\n{\n\tmat2 mat = mat2(cos(angle),-sin(angle),\n\t\t\t\t\tsin(angle),cos(angle));\n\treturn p * mat;\n}\n\nfloat t(float scale, float k)\n{\n\tfloat t = sin(iTime * scale);\n\tt = (t + 1.0)/2.0;\n\tt = mix(t,smoothstep(0.0, 1.0, t),k);\n\tt = (t - 0.5)*2.0;\n\treturn t;\n}\n\nfloat ghost1(vec2 uv)\n{\n\tfloat time = iTime * 6.0;\n\tfloat t = t(6.0, 0.5);\n\n\tuv.x += 0.5;\n\tuv = rotate(uv, t*max(0.0, uv.y)*0.2);\n\tuv.y -= 0.4 + sin(time * 2.0) * 0.1 * smoothstep(-0.5, 1.5, uv.y);\n\tvec2 originalUV = uv;\n\t\t\n\tuv.x *= 1.0 + uv.y;\n\tuv.y += max(0.0, -uv.y*0.8); \t\n\tfloat body = circle(uv, 0.2); \n\t\n\tuv = originalUV;\n\tuv += vec2(-0.2, 0.2);\n\tuv = rotate(uv, -PI/4.0 + t*0.8*uv.x);\n\tuv *= vec2(0.4, 2.0);\n\tfloat arms = circle(uv, 0.1);\n\t\n\tuv = originalUV;\n\tuv += vec2(0.2, 0.2);\n\tuv = rotate(uv, PI/4.0 + t*0.8*(-uv.x));\n\tuv *= vec2(0.4, 2.0);\n\tarms = min(arms, circle(uv, 0.1));\n\t\n\tuv = originalUV;\n\tuv.x -= 0.01;\n\tuv.y += 0.05;\n\tuv.y *= 1.0 + cos(time*2.0)*0.4;\n\tfloat mouth = circle(uv, 0.02);\n\t\n\tuv = originalUV;\n\tuv.x -= 0.11;\n\tfloat eyeR = circle(uv, 0.02);\n\tuv.x += 0.2;\n\tfloat eyeL = circle(uv, 0.04);\n\t\n\tfloat d = body;\n\td = smin(arms,body, 0.1);\n\td = max(d, -eyeR);\n\td = max(d, -eyeL);\n\td = max(d, -mouth);\n\tfloat threshold = mix(0.04, 0.06, (0.5 +sin(iTime)*0.5));\n\td = 1.0 - smoothstep(-threshold, threshold, d);\t\n\treturn d;\n}\n\nfloat ghost2(vec2 uv)\n{\n\tuv.x -= 0.4;\t\n\tuv.y += t(6.0, 0.5)*0.2* smoothstep(-1.0, 0.0, uv.y);\n\tvec2 originalUV = uv; \n\t\n\tuv.x *= 1.0 + uv.y*0.4;\n\tuv.y *= mix(0.0, 1.0, smoothstep(-0.1, 0.0, uv.y));\n\tfloat body = circle(uv, 0.15);\n\t\n\tuv = originalUV;\n\tuv.x -= 0.06;\n\tfloat eyeR = circle(uv, 0.03);\n\tuv.x += 0.14;\n\tfloat eyeL = circle(uv, 0.025);\n\t\n\tfloat d = max(body,-eyeR);\n\td = max(d, -eyeL);\n\t\n\tfloat threshold = mix(0.04, 0.06, (0.5 +sin(iTime)*0.5));\n\td = 1.0 - smoothstep(-threshold, threshold, d);\n\td *= 0.6;\n\treturn d;\n}\n\nfloat ghosts(vec2 uv)\n{\t\n\tfloat d = ghost1(uv) + ghost2(uv);\n\treturn clamp(d, 0.0, 1.0);\n}\n\nvec3 tonemapping(vec3 color, float exposure, float gamma)\n{\n\tcolor *= exposure/(1. + color / exposure);\n\tcolor = pow(color, vec3(1. / gamma));\n\tfloat lum = 0.3*color.r + 0.6*color.g + 0.1*color.b;\n\tcolor = mix(color, color*color, 1.0 - smoothstep(0.0,0.4,lum));\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 res = vec2(max(iResolution.x, iResolution.y));\n\tvec2 uv = fragCoord.xy / res;\n    uv = (uv-vec2(0.5))*2.0;\n    uv.y += 0.5;\n    uv *= 1.3;\n\n\t\t\t\n\tray r;\n\tr.o = vec3(0.0);\n\tr.d = calcCameraRayDir(60.0,  gl_FragCoord.xy, res);\n\t\t\n\tfloat gradient = gradient(uv);\n\tfloat moon = distance(uv, vec2(0.0,0.1));\n\tmoon = 1.0 - smoothstep(0.05, 0.08, moon);\n\t\n\tvec3 bg = mix(vec3(0.0, 0.1, 0.1),vec3(0.1, 0.3, 0.5), min(1.0, gradient*2.0));\n\tbg = mix(bg, vec3(0.6, 0.9, 1.0), (max(0.0, gradient - 0.5)) * 2.0);\n\tbg += vec3(0.8) * moon;\n\tbg += vec3(0.4) * stars(uv,5.0,0.01);\n\tbg += vec3(0.4) * stars(uv, 100.0, 0.04);\n\tbg += vec3(0.4) * ghosts(uv) * (uv.y+1.0)*0.5;\n\t\n\tvec4 sum = vec4(0);\t\n\tfloat t = 0.0;\n\t#ifdef CLOUDS_ON\n\tfor(int i = 0; i < int(STEPS); i++)\n\t{\n\t\tvec3 p = r.o + r.d * t;\n\t\tfloat d = density(p);\n\t\tif(d > 0.01)\n\t\t{\n\t\t\tfloat a = d * (1.0 - smoothstep(DRAWDIST / 2.0, DRAWDIST, t))*0.4;\n\t\t\tvec3 c = clouds(p, d, t, bg);\n\t\t\tsum += vec4(c * a, a) * ( 1.0 - sum.a );\t\t\n\t\t\tif(sum.a > 0.99) break;\n\t\t}\n\t\tt += STEPSIZE;\n\t}\t\n\t#endif\n\tvec4 c;\n\tc = vec4(bg, 1.0) * (1.0 - sum.a) + sum;\n\tc.rgb = tonemapping(c.rgb, 1.5,1.2);\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3czS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 349, 349, 506], [508, 508, 528, 528, 625], [627, 627, 651, 651, 691], [693, 693, 717, 717, 772], [774, 774, 800, 800, 1285], [1287, 1287, 1306, 1306, 1497], [1499, 1499, 1522, 1522, 1720], [1722, 1722, 1770, 1770, 2157], [2159, 2159, 2209, 2209, 2548], [2550, 2550, 2575, 2575, 2702], [2704, 2704, 2736, 2736, 2760], [2762, 2762, 2801, 2801, 2891], [2893, 2893, 2927, 2927, 3016], [3018, 3018, 3049, 3049, 3172], [3174, 3174, 3197, 3197, 4223], [4225, 4225, 4248, 4248, 4753], [4755, 4755, 4778, 4778, 4845], [4847, 4847, 4906, 4906, 5125], [5128, 5128, 5185, 5185, 6330]], "test": "valid"}
{"id": "ld3czX", "name": "MIS_1", "author": "Placeboyue", "description": "first test", "tags": ["test"], "likes": 0, "viewed": 49, "published": "Public", "date": "1519664372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float pepe = distance(vec4(iTime,iTime,iTime,iTime),iMouse)*0.8;\n    float colx = sin(pepe+uv.x*50.0)+iTime*0.1;\n\tfloat coly = sin(pepe+uv.y*10.0)+iTime*0.3;\n    float colz = cos(pepe+uv.x+uv.y*20.0)+iTime*0.2;\n    // Output to screen\n    fragColor = vec4(colx*0.5+uv.x*0.6,coly*0.3+uv.y*0.6,colz*0.40,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3czX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 494]], "test": "valid"}
{"id": "ld3yDn", "name": "Bloodsport Graveyard", "author": "Passion", "description": "https://duckduckgo.com/?q=master+of+puppets+album+cover&t=hg&iax=images&ia=images\nAmbient Occlusion and shadows - https://www.shadertoy.com/view/Xds3zN Bumpmap Tex3D function - https://www.shadertoy.com/view/MlXSWX", "tags": ["raymarch", "shadows", "ambientocclusion"], "likes": 27, "viewed": 406, "published": "Public", "date": "1518422888", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.001\n#define NUM_SAMPLES 100\n#define FAR 18.0\n// lower the number the softer the shadow is\n#define SHADOW_SHARPNESS 16.0 \n#define USE_NOISE_TERRAIN \n\n\n//float PI = acos(-1.0);\n//float degreetoRadian(float deg){\n//    return deg*PI/180.0;\n//}\n\nvec3 graveStake = vec3(0.17 , 0.75, .075);\nvec3 graveCross = vec3(0.53, .1, .075);\n\n\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, c, -c, s);\n}\n\n//Round Box - unsigned - exact\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n//Random function\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n//Noise function\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n// ground distance function\nfloat ground(vec3 p){\n    float n=0.0;\n#ifdef USE_NOISE_TERRAIN\n    n = noise(.1*p.xz)*2.;\n#endif\n    \n    float pl = (p.y) + 3.5;\n    return pl+(n);\n}\n\n//reserved cross\nfloat map(vec3 p){\n    float g = ground(p);\n    p.y = g;\n    p.y-=.7;\n    p.xz = mod(p.xz, 3.0) -1.5;\n    float stake =udRoundBox(p, graveStake,.025126);\n    //p.xz*=r2(degreetoRadian(90.));\n    p.y-=.2;\n    float crosd =udRoundBox(p, graveCross,.025126);\n        \n    return min(min(stake, crosd), g);\n}\n\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for(int i = 0; i < NUM_SAMPLES; i++){\n        vec3 p = o + r * t;\n        float d = map(p);\n        if(abs(d) < EPS || t > FAR) break; \n        t += d * 0.75;\n    }\n    return t;\n}\n// normal or gradient function\nvec3 norm(vec3 p) {\n\tvec2 e = vec2(EPS, 0.0);\n\treturn normalize((vec3(map(p+e.xyy), map(p+e.yxy), map(p+e.yyx)) - map(p)) / e.x);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(EPS, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0+sin(iTime), 0.0, 16.0);\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv)*.25));\n    vec3 l = normalize(vec3(0.3, 0.25, -0.6));\n    r.zy*= r2(noise(vec2(iTime))+.8);\n    r.xz*= r2(iTime/3.+noise(vec2(iTime,iTime/2.)));\n    \n    o.xz *= r2(-iTime*.2);\n    o.y = -ground(o)+.6;\n    float hit = trace(o, r);\n    \n    vec3 sp = o+r *hit;\n    l.zx*=r2(iTime);\n    \n\n    float d = map(sp);\n    vec3 n = norm(sp);\n    float ao = calcAO(sp, n);\n    n = doBumpMap(iChannel1, (sp), n, 0.05);\n    \n    vec3 tt = tex3D(iChannel0, sp/5., n)+.25;\n    vec3 tt2 = tex3D(iChannel1, sp/4., n);\n    float diff = clamp(dot(n, l),0.15, 1.);\n    float fog = smoothstep(-0.2, .65, hit*0.03);\n    float ss = (dot(l, r)*.15);\n    vec4 bg = vec4(ss)+vec4(1.0)-pow(vec4(.1, .75, .8, 1), vec4(4.*(r.y+0.9)));\n    float sss = clamp(softshadow(sp, l, .02, 4.5, SHADOW_SHARPNESS),.15,1.0);\n\n    float c = .0;\n    c = max(c + dot(hash33(vec3(r))*2.-1., vec3(0.033)), 0.);\n    \n    if(abs(d) < 0.5){\n        fragColor = mix(vec4(tt*diff*sss*ao,1.0), bg, fog);\n        if(abs(ground(sp))<0.015)\n            fragColor=mix(vec4(tt2*diff*sss*ao, 1.0),bg, fog);;\n    }\n    else\n        fragColor = vec4(bg);\n    //fragColor = (abs(ground(sp))<0.015) ? mix(vec4(tt2*diff*sss*ao,1.0), bg, fog) : bg;\n    //fragColor = (abs(d) < 0.5) ? mix(vec4(tt*diff*sss*ao,1.0), bg, fog) : bg;\n    \n    fragColor = (abs(uv.y)>.85) ? vec4(0.0) : fragColor;\n    fragColor+=-c;\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "ldjSWz", "previewfilepath": "https://soundcloud.com/jean-francois-kryl/for-who-the-bell-tolls", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/jean-francois-kryl/for-who-the-bell-tolls", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3yDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 341, 358, 358, 434], [436, 467, 512, 512, 552], [554, 572, 592, 592, 659], [661, 678, 699, 699, 896], [898, 926, 947, 947, 1077], [1079, 1096, 1114, 1114, 1400], [1403, 1403, 1431, 1431, 1635], [1636, 1667, 1686, 1686, 1798], [1800, 1800, 1877, 1877, 2092], [2094, 2094, 2136, 2136, 2433], [2434, 2500, 2550, 2550, 2746], [2747, 2934, 2996, 2996, 3501], [3503, 3503, 3523, 3523, 3631], [3633, 3633, 3690, 3740, 5297]], "test": "error"}
{"id": "ld3yRn", "name": "Rounder Voronoi Edge Distance", "author": "tomkh", "description": "Voronoi Edge distance function continuous across the whole domain and smooth at non-zero distance.\nSimilar to [url=https://www.shadertoy.com/view/MdByzD]TinyTexel's function[/url].\nCheck also [url=http://polycu.be/edit/?h=X3sd5D]PolyCube edition[/url].\n", "tags": ["voronoi", "worley", "distance", "smooth"], "likes": 24, "viewed": 1308, "published": "Public API", "date": "1517713799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ST_MODE = \"ShaderToy mode\". Do not undefine. It is here for PolyCube compatibility.\n#define ST_MODE\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// by Tomasz Dobrowolski' 2018\n\n// Use mouse (X/Y) to control two smoothness parameters.\n\n// PolyCube edition:\n// http://polycu.be/edit/?h=X3sd5D\n\n// This is continuation of a quest to formulate\n// smooth and continuous across whole domain\n// distance function to edges of random Voronoi cells.\n\n// I just had a very simple idea today (2018-02-03)\n// how to make this function continuous and smooth\n// at non-zero distance at the same time, and it works!\n// See \"voronoi_rounder\" function for details.\n\n// My previous shader with analysis of discontinuities\n// in Shane's attempt.\n// https://www.shadertoy.com/view/MdSfzD\n\n// Shane's original shader.\n// https://www.shadertoy.com/view/lsSfz1\n\n// My previous attempt to optimize distance to edges.\n// https://www.shadertoy.com/view/llG3zy\n\n// Smooth cell noise function by TinyTexel.\n// https://www.shadertoy.com/view/MdByzD\n\n// Try out generalized assocative smin,\n// based on LogSumExp smooth maximum function\n// https://en.wikipedia.org/wiki/LogSumExp\n// that is generalization over TinyTexel's and IQ's functions.\n#define GENERALIZED_SMIN 0\n\n// Play with some options (1 = enable, 0 = disable).\n#define DOMAIN_DEFORM 0\n#define ANIMATE 1\n\n// How far cells can go off center during animation (must be <= .5)\n#define ANIMATE_D .45\n\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .00001\n\n#ifdef ST_MODE\n#define template_time iTime\n#endif\n\nvec2 hash2(vec2 p)\n{\n    #if 1\n       // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n       vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n       p3 += dot(p3, p3.yzx+19.19);\n       vec2 o = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n    #else\n       // Texture-based\n       vec2 o = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    #endif\n    #if ANIMATE\n       o = 0.5 + ANIMATE_D*sin( template_time*.5 + o*6.2831853 );\n    #endif\n   return o;\n}\n\n#if GENERALIZED_SMIN\n\n// Commutative and associative function.\n// It is based on LogSumExp smooth maximum function idea\n// https://en.wikipedia.org/wiki/LogSumExp\n// This one is a generalization of TinyTexels'a and IQ's versions.\n// Set \"bias\" to 1.0 to make it ala TinyTexel's.\n//         or to 0.0 to make it ala IQ's.\nfloat sminRcpExp(float a, float b, float s, float bias)\n{\n    float d = 1.0 / (exp2(a * s) - bias)\n            + 1.0 / (exp2(b * s) - bias);\n   \treturn log2(1.0 / d + bias) / s;\n}\n\nfloat smin(float a, float b, float r)\n{\n    return sminRcpExp(a, b, 4./r, 1.0);\n}\n\n#elif 1\n\n// Commutative smin function taken\n// from Alex Evans aka Statix talk \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// credited to Dave Smith @media molecule\nfloat smin(float a, float b, float r)\n{\n   float f = max(0.,1.-abs(b-a)/r);\n   return min(a,b) - r*.25*f*f;\n}\n\n#else\n\n// A varation that prevents division by zero.\nfloat smin(float a, float b, float r)\n{\n   float f = max(0.,1.-abs(b-a)/max(1e-32,r));\n   return min(a,b) - r*.25*f*f;\n}\n\n#endif\n\n// Smooth abs.\n// This one is equivalent to -smin(x, -x, r) - r*.25\nfloat sabs(float x, float r)\n{\n   float f = max(0.,1.-abs(x + x)/r);\n   return abs(x) + r*.25*(f*f - 1.);\n}\n\n// This is bullet-proof version of finding closest point\n// in 4x4 area around query point \"q\".\n// In fact 12 cells (4x4 without corners) would be enough,\n// but it's less elegant to implement.\n// We pass n=|q|, f=q-n, as an optimization.\nfloat closest( in vec2 n, in vec2 f, out vec2 mr, out vec2 mg )\n{\n    // take half-cell position\n    vec2 h = step(.5,f) - 2.;\n    vec2 n2 = n + h;\n    vec2 f2 = f - h;\n\n    float md = 8.0;\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n2 + g );\n        vec2 r = g + o - f2;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    mg += h; // return cell position relative to \"n\"\n    \n    return md;\n}\n\n// A continuous and smooth at non-zero distance\n// distance function to Voronoi edges.\n// by Tomasz Dobrowolski' 2018\n// Extending it to 3d (and more) is trivial.\n// x = input coordinate\n// s = smooth min cutoff parameter (smoothness inside cell)\n// e = smooth abs cutoff parameter (smoothness between cells)\nvec3 voronoi_rounder( in vec2 x, in float s, in float e )\n{\n#if DOMAIN_DEFORM\n\tx += sin(x.yx*10.)*.07;\n#endif\n\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mr, mg;\n    float md = closest(n,f,mr,mg);\n\n    //----------------------------------\n    // second pass: distance to edges\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        {\n            float d = dot( 0.5*(mr+r), normalize(r-mr) );\n\n            // The whole trick to get continuous function\n            // across whole domain and smooth at non-zero distance\n            // is to use smooth minimum (as usual)\n            // and multiple smoothness factor by distance,\n            // so it becomes minimum at zero distance.\n            // Simple as that!\n            // If you keep smoothness factor constant (i.e. multiple by \"s\" only),\n            // the distance function becomes discontinuous\n            // (see https://www.shadertoy.com/view/MdSfzD).\n            md = smin(d, md, s*d);\n        }\n    }\n\n    // Totally empirical compensation for\n    // smoothing scaling side-effect.\n    md *= .5 + s;\n\n    // At the end do some smooth abs\n    // on the distance value.\n    // This is really optional, since distance function\n    // is already continuous, but we can get extra\n    // smoothness from it.\n    md = sabs(md, e);\n\n    return vec3( md, mr );\n}\n\n#ifdef ST_MODE\nvec3 plot( vec2 p, float ss )\n{\n#else\nvec3 plot( vec2 p )\n{\n    float ss = template_tr.z;\n#endif\n#ifdef ST_MODE\n    float s = clamp(iMouse.x/iResolution.x,.0,1.)*.95+.05;\n    float e = max(.01,iMouse.y/iResolution.y)*.5;\n    if (length(iMouse.xy) < .5) {\n\t\ts = .5;\n        e = .005;\n    }\n#else\n    const float s = .5;\n    const float e = .01;\n#endif\n    vec3 c = voronoi_rounder(p, s, e);\n\n    const float pd = 40.;\n#if 0\n    vec3 norm = normalize(vec3(dFdx(c.x),dFdy(c.x),ss*1.5));\n    float fw1 = fwidth(c.x);\n#else\n    const vec2 eps = vec2(.001,0);\n    float fdx = (voronoi_rounder(p + eps.xy, s, e).x - c.x)/eps.x;\n    float fdy = (voronoi_rounder(p + eps.yx, s, e).x - c.x)/eps.x;\n    vec3 norm = normalize(vec3(fdx, fdy, 1.5));\n    float fw1 = (abs(fdx) + abs(fdy))*ss;\n#endif\n    float fw2 = fw1*(pd/3.141592653589793*2.7);\n\n    const float f0 = sin(.7/pd);\n    float f = sin(c.x*pd-.7);\n    float od = abs(f);\n    vec3 ldir = normalize(vec3(-.2,-.3,.6));\n    float dd = dot(norm,ldir);\n    float rd = pow(max(0.,reflect(-ldir,norm).z),16.);\n    float ld = dd*dd*.7+.35;\n    float c0 = c.x*.7-step(0.,f)*.05+.6;\n    float c1 = c.x*.7+.33;\n    vec3 col = mix(vec3(c0*ld+rd*.23), vec3(c1*ld), smoothstep(fw2,0.,od)*.7);\n    col = mix(col, vec3(.1,.15,.1), smoothstep(f0+fw1,f0,c.x)*.5);\n    col = sqrt(col)*1.5-.53; // some final grading\n    return col;\n}\n\n#ifdef ST_MODE\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*2. + 3.; // scale differently for fullscreen\n    float ss = sc / iResolution.y; // size of 1 pixel\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) * ss;\n    fragColor = vec4(plot(uv, ss), 1.);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3yRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1594, 1594, 1614, 1614, 2082], [3154, 3222, 3252, 3252, 3329], [3331, 3570, 3635, 3666, 4257], [4259, 4568, 4627, 4627, 6144]], "test": "valid"}
{"id": "ld3yzn", "name": "smoke flow", "author": "BadBadDog", "description": "smoke with flow noise", "tags": ["smokeflownoise"], "likes": 8, "viewed": 505, "published": "Public", "date": "1517726044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// cd publi http://evasion.imag.fr/~Fabrice.Neyret/flownoise/index.gb.html\n//          http://mrl.nyu.edu/~perlin/flownoise-talk/\n\n// The raw principle is trivial: rotate the gradients in Perlin noise.\n// Complication: checkboard-signed direction, hierarchical rotation speed (many possibilities).\n// Not implemented here: pseudo-advection of one scale by the other.\n\n// --- Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat level=1.;\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    float t = pow(2.,level)* .2*iTime;\n    mat2 R = mat2(cos(t),-sin(t),sin(t),cos(t));\n    if (mod(i.x+i.y,2.)==0.) R=-R;\n\n    return 2.*mix( mix( dot( hash( i + vec2(0,0) ), (f - vec2(0,0))*R ), \n                     dot( hash( i + vec2(1,0) ),-(f - vec2(1,0))*R ), u.x),\n                mix( dot( hash( i + vec2(0,1) ),-(f - vec2(0,1))*R ), \n                     dot( hash( i + vec2(1,1) ), (f - vec2(1,1))*R ), u.x), u.y);\n}\n\nfloat Mnoise(in vec2 uv ) {\n  //return noise(uv);                      // base turbulence\n  //return -1. + 2.* (1.-abs(noise(uv)));  // flame like\n    return -1. + 2.* (abs(noise(uv)));     // cloud like\n}\n\nfloat turb( in vec2 uv )\n{ \tfloat f = 0.0;\n\t\n level=1.;\n    mat2 m = mat2( 1.6,  2.2, -1.2,  1.6 );\n    f  = 0.5000*Mnoise( uv ); uv = m*uv; \n level++;\n\tf += 0.2000*Mnoise( uv ); uv = m*uv; \n level++;\n\tf += 0.0850*Mnoise( uv ); uv = m*uv; \n level++;\n//\tf += 0.0825*Mnoise( uv ); uv = m*uv; \n level++;\n//\tf += 0.0825*Mnoise( uv ); uv = m*uv; level++;\n\treturn f/.9375; \n}\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 tuv = fragCoord.xy / iResolution.xy;\n\n    vec2 suv = fragCoord.xy / iResolution.xy;\n\n    float pp = texture( iChannel0, vec2( suv.x*0.00, suv.y*0.05 )+iTime*0.002 ).g;\n    \n    suv.x += 0.2*sin(iTime*0.1)*(suv.y)*pp;\n    \n    float vs = texture( iChannel0, vec2( suv.x*0.00, suv.y*0.01 )+iTime*0.002 ).g;\n    float ns = texture( iChannel0, vec2( suv.x*0.00, suv.y*0.01 )+iTime*0.002 ).r;\n    float ps = 0.9 + 0.1*texture( iChannel0, suv*0.01+iTime*0.001 ).g;\n    float ls = smoothstep( 0.7, 1.0, texture( iChannel0, vec2(iTime)*0.1 ).b );\n\n    float line = smoothstep( 0.95-suv.y*0.09, 1.0, 1.0-abs(suv.x-0.5+(vs*0.7+ns)*0.02-0.01) ) *ps;\n    float glow = smoothstep( 0.96-suv.y*0.05, 1.0, 1.0-abs(suv.x-0.5+ns*0.02-0.01) ) *ps;\n\n    \n \tfloat sm = smoothstep(0.0,1.0,line*0.5);\n  \tfloat sg = smoothstep(0.0,1.0,glow*0.5);\n  \n    \n    vec2 uv = fragCoord.xy / iResolution.y,\n         m = iMouse.xy /  iResolution.y;\n    if (length(m)==0.) m = vec2(.5);\n\t\n    uv.y -= iTime*0.03;\n    float f = turb( 5.*uv );\n\tfloat tout = .5 + .4* f;\n    float fout =  smoothstep( 0.0,0.05, sm*tout );\n    float gout =  smoothstep( 0.0,0.1, sg*tout );\n    \n    vec4 bk = vec4( 0.4,0.6,0.9, 1.0 );\n    vec4 ff = vec4( 12.9,3.1,0.0, 1.0 ) * tout;\n    \n\tfragColor = bk * (1.0-vec4(fout*tout*0.8 + gout*tout*0.1 + fout*0.6) * (1.0-exp(-tuv.y*5.0)) );\n\tfragColor += (1.0-fragColor)*(ff*vec4(gout*tout*0.9 + fout*1.9) * exp(-tuv.y*15.0));\n    \n    \n    \n    \n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3yzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 454, 475, 475, 596], [614, 614, 640, 640, 1148], [1150, 1150, 1177, 1296, 1355], [1357, 1357, 1383, 1383, 1726], [1779, 1779, 1836, 1836, 3287]], "test": "error"}
{"id": "ld3yzS", "name": "Fractal Braids", "author": "Klems", "description": "Braids made of braids. Click to rotate the camera.", "tags": ["3d", "fractal", "raymarch"], "likes": 31, "viewed": 726, "published": "Public API", "date": "1519310607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n#define FOV (PI*0.4)\n\n#define rot(a) mat2(cos(a+PI*vec4(0,1.5,0.5,0)))\n\n// hash function for dithering\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// parametric equation for the path of a single strand\n// https://en.wikipedia.org/wiki/Braiding_machine\nvec2 path( float x ) {\n    float v = step(fract(x), 0.5)*2.0-1.0;\n    float th = mod(x, 0.5)*-4.0*PI*v;\n    return vec2(cos(th)*0.5-0.5, sin(th)*0.5)*v;\n}\n\n// main distance function\nfloat de( vec3 p, out float id ) {\n    \n    float sky = 10.0-length(p.xy);\n    p.z *= 0.04;\n    \n    vec2 inS = vec2(0);\n    float scale = 1.0;\n    id = 0.0;\n    \n    for (int i = 0 ; i < 3 ; i++) {\n        \n        // figure out the path of the 3 strands\n        vec2 inA = p.xy - path(p.z)*scale;\n        vec2 inB = p.xy - path(p.z + (1.0/3.0))*scale;\n        vec2 inC = p.xy - path(p.z + (2.0/3.0))*scale;\n        \n        // pick the closest center\n        float dA = dot(inA, inA);\n        float dB = dot(inB, inB);\n        float dC = dot(inC, inC);\n        if (dA < dB && dA < dC) {\n            inS = inA;\n        } else if (dB < dC) {\n            inS = inB;\n            id += pow(3.0, float(i));\n        } else {\n            inS = inC;\n            id += 2.0*pow(3.0, float(i));\n        }\n        \n        p.z /= scale;\n        p.xy = inS;\n        scale *= 0.32;\n        \n    }\n    \n    // base primitive is a cylinder\n    float de = length(inS) - 1.5*scale;\n    \n    // compare the distance to the sky\n    if (sky < de) {\n        id = -1.0;\n        return sky;\n    }\n    \n    return de;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n\tvec3 from = vec3(0, -4.3, 0);\n\tvec3 dir = normalize(vec3(uv.x, 1.0 / tan(FOV*0.5), uv.y));\n    \n    \n\tvec2 mouse= (iMouse.xy - iResolution.xy * 0.5) / iResolution.x;\n\tif (iMouse.z < 1.0) mouse = vec2(0.0);\n\tmat2 rotx = rot(-mouse.x*4.0);\n\tmat2 roty = rot(mouse.y*3.0);\n    from.yz *= roty;\n\tfrom.xy *= rotx;\n\tdir.yz  *= roty;\n\tdir.xy  *= rotx;\n    from.z += iTime;\n    \n    // dithering\n    vec3 dither = hash33(vec3(fragCoord.xy, iFrame));\n    \n    // get the sine of the angular extent of a pixel\n    float sinPix = sin(FOV / iResolution.x)*1.0;\n    // accumulate color front to back\n    vec4 acc = vec4(0, 0, 0, 1);\n\n    float id = 0.0;\n    float totdist = 0.0;\n    totdist += dither.r*de(from, id)*0.4;\n    \n\tfor (int i = 0 ; i < 50 ; i++) {\n\t\tvec3 p = from + totdist * dir;\n        float dist = de(p, id);\n        \n        // compute color\n        vec3 color = vec3(sin(id)*0.3+0.7);\n        if (id < -0.5) color = vec3(0.2);\n        else if (id < 0.5) color = vec3(0.6, 0.1, 0.1);\n        color *= pow(1.0 - float(i)/50.0, 1.5);\n        \n        // cone trace the surface\n        float prox = dist / (totdist*sinPix);\n        float alpha = clamp(prox * -0.5 + 0.5, 0.0, 1.0);\n        \n        if (alpha > 0.01) {\n            // accumulate color\n            acc.rgb += acc.a * (alpha*color.rgb);\n            acc.a *= (1.0 - alpha);\n        }\n        \n        // hit a surface, stop\n        if (acc.a < 0.01) {\n            break;\n        }\n        \n        // continue forward\n        totdist += abs(dist*0.4);\n\t}\n    \n    fragColor.rgb = acc.rgb + (dither - 0.5)*0.01;\n\tfragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3yzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 129, 151, 151, 275], [277, 382, 404, 404, 536], [538, 564, 598, 598, 1664], [1666, 1666, 1723, 1723, 3392]], "test": "error"}
{"id": "ldcyR4", "name": "rainbow flow 2", "author": "teriyaki", "description": "more simplex noise and hsv", "tags": ["noise", "rainbow"], "likes": 27, "viewed": 5669, "published": "Public API", "date": "1518012635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define      PI 3.14159265358979323846264338327950288419716939937511 // mm pie\n#define     TAU 6.28318530717958647692528676655900576839433879875021 // pi * 2\n#define HALF_PI 1.57079632679489661923132169163975144209858469968755 // pi / 2\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x * 34.) + 1.) * x);\n}\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(.211324865405187,.366025403784439,-.577350269189626,.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1 = (x0.x > x0.y) ? vec2(1., 0.) : vec2(0., 1.);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i);\n  vec3 p = permute( permute( i.y + vec3(0., i1.y, 1. )) + i.x + vec3(0., i1.x, 1. ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.);\n  m = m*m;\n  m = m*m;\n  vec3 x = 2. * fract(p * C.www) - 1.;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - .85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130. * dot(m, g);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvec2 pq(vec2 uv) {\n  return vec2(atan(uv.x, uv.y) / TAU + .5, length(uv));;\n}\n\nvec4 glorb(vec2 uv, vec2 offset, float radius) {\n  vec2 pq = pq(uv + offset);\n  float r = radius * snoise(uv + iTime * .2);\n  float s = 8. / iResolution.y;\n  float m = smoothstep(r + s, r - s, pq.y);\n  vec3 c = hsv2rgb(vec3(pq.x, 1., 1.));\n  return vec4(c, 1.) * m;\n}\n\nvec4 field(vec2 uv, vec2 offset, float radius) {\n  vec4 c0 = glorb(uv, offset, radius);\n  vec4 c1 = glorb(uv, offset, radius * .92);\n  return c0 - c1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n  vec4 r0 = field(uv, vec2( .0, .0), 1.66);\n  vec4 r1 = field(uv, vec2( .33, .33), 1.66);\n  vec4 r2 = field(uv, vec2( .33, -.33), 1.66);\n  vec4 r3 = field(uv, vec2(-.33, -.33), 1.66);\n  vec4 r4 = field(uv, vec2(-.33, .33), 1.66);\n  fragColor = r0+r1+r2+r3+r4;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[662, 662, 683, 683, 731], [733, 733, 754, 754, 802], [804, 804, 826, 826, 869], [871, 871, 893, 893, 1664], [1666, 1666, 1688, 1688, 1835], [1837, 1837, 1855, 1855, 1914], [1916, 1916, 1964, 1964, 2183], [2185, 2185, 2233, 2233, 2337], [2339, 2339, 2396, 2396, 2724]], "test": "valid"}
{"id": "lddcDr", "name": "Sine waves gone wrong", "author": "timeisbeautifulhere", "description": "When your sine wave enters another dimension", "tags": ["wave", "swirl", "aliasing", "sine", "polar", "coordinates", "swirly"], "likes": 2, "viewed": 104, "published": "Public", "date": "1518565883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define WIDTH .1\n#define START_CONST 30.0\n\n// Check if a point is within the width of a line\nbool checkLine(vec2 uv, float f_x, float width){\n    return abs(uv.y-f_x) < width;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //amplitude of sine wave\n    //float a=sin(iTime);\n    float a=1.0;\n    \n    //rate it spins at\n    float rotRate=iTime/5.0;\n    \n    vec2 uv=(2.0*fragCoord)/iResolution.xy-1.0;\n    \n    //polar coordinates\n    vec2 pc=vec2(\n        atan(uv.y/uv.x),\n        length(uv)\n    );\n    \n    //multiply the sine wave\n    pc.x=pc.x*rotRate*START_CONST;\n    \n    float f_x=a*sin(2.0*pc.x);\n    \n    if(checkLine(pc,f_x,WIDTH))\n        fragColor=vec4(1);\n    else\n        fragColor=vec4(0,0,0,1);\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddcDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 94, 142, 142, 178], [180, 180, 237, 292, 739]], "test": "valid"}
{"id": "lddcR8", "name": "Tri-Colored Cube By Yuru Wang", "author": "yuruwang", "description": "finish time: 2/1/2018", "tags": ["sdf"], "likes": 3, "viewed": 92, "published": "Public", "date": "1518141160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 translationMatrix(vec3 v) {\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                v.x, v.y, v.z, 1.0);\t\t\n}\n\nmat4 rotateX(float rad) {\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, cos(rad), sin(rad), 0.0,\n                0.0, -sin(rad), cos(rad), 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float rad) {\n\treturn mat4(cos(rad), 0.0, -sin(rad), 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                sin(rad), 0.0, cos(rad), 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\n\nmat2 rotateM(float rad) {\n    return mat2(cos(rad), sin(rad),\n                 -sin(rad), cos(rad));\n}\n\nfloat ease_in_quadratic(float t) {\n    return 0.0;\n}\n\nfloat ease_in_out_quadratic(float t) {\n    if (t < 0.5) {\n        return ease_in_quadratic(t * 2.0) / 2.0;\n    } else {\n        return 1.0 - ease_in_quadratic((1.0 - t) * 2.0) / 2.0;\n    }\n        \n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    return udBox(samplePoint, vec3(1.0, 1.0, 1.0));\n}\n\nvec3 rayDirection(vec2 fragCoord, vec3 iResolution) {\n    return vec3(0.0, 0.0, -1.0);\n}\n\n\nfloat march(vec3 eyePos, vec3 rDir, float min_t, float max_t, float EPSILON, mat4 transM) {\n    const int MAX_MARCHING_STEPS = 255;\n\n    float t = min_t;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = eyePos + t * rDir;\n        \n        float PI = 3.14159265359;\n        vec3 transedP = vec3(inverse(transM) * vec4(p, 1.0));\n        float dist = sceneSDF(transedP);\n        if (dist < EPSILON) {\n            return t;\n        }\n        t += dist;\n\n        if (t >= max_t) {\n            return max_t;\n        }\n    }\n    return max_t;\n}\n\nvec3 estimateNormal(vec3 p) {\n    const float EPSILON = 0.0001;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float modTime = mod(iTime, 4.0);\n \tint mode = 0;   \n \n    if (modTime > 0.0 && modTime <= 1.0) {\n        mode = 1;\n    } else if (modTime > 1.0 && modTime <= 2.0) {\n        mode = 2;\n    } else if (modTime > 2.0 && modTime <= 3.0) {\n        mode = 3;\n    } else if(modTime > 3.0 && modTime <= 4.0) {\n        mode = 4;\n    }\n\n\n\tconst float MIN_T = 0.0;\n\tconst float MAX_T = 100.0;\n\tconst float EPSILON = 0.0001;\n    vec3 eyePos = vec3(0.0, 0.0, 80.0);\n    eyePos.x = fragCoord.x / 50.0 - 0.5 * iResolution.x / 50.0;\n    eyePos.y = fragCoord.y / 50.0 - 0.5 * iResolution.y / 50.0;\n\n\tvec3 rDir = rayDirection(fragCoord, iResolution);\n\tvec3 rDir_transed = rDir;\n    \n    float PI = 3.14159265359;\n    mat4 transM = rotateX(0.8 * PI/4.0) * rotateY(PI/4.0);\n    if (mode == 1) {\n        transM = transM * rotateY( -1.0 * PI * 0.5 * fract(iTime));\n    } else if (mode == 3) {\n        transM = transM * rotateX(1.0 * PI * 0.5 * fract(iTime));\n    }\n        \n        \n\n    float t = march(eyePos, rDir_transed, MIN_T, MAX_T, EPSILON, transM);\n    vec3 pos = eyePos + t * rDir_transed;\n    \n    pos = vec3(inverse(transM) * vec4(pos, 1.0));\n\tvec3 normal = estimateNormal(pos);\n    \n        \n    if (t >= MAX_T) {\n        fragColor = vec4(0.9, 0.9, 0.9, 1.0);\n\n    } else {\n        vec4 purple = vec4(81.0/255.0, 65.0/255.0, 86.0/255.0, 1.0);\n        vec4 green = vec4(169.0/255.0, 217.0/255.0, 198.0/255.0, 1.0);\n        vec4 pink = vec4(232.0/255.0, 78.0/255.0,128.0/255.0, 1.0);\n        vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n        vec2 midP = iResolution.xy / 2.0;\n        \n        if (mode == 1) {   \n            if (normal.x == 0.0 && normal.y == 0.0 && normal.z > 0.0) {\n                // front\n                fragColor = purple;\n            } else if (normal.x > 0.0 && normal.y == 0.0 && normal.z == 0.0){\n                // right\n                fragColor = pink;\n            } else if (normal.x == 0.0 && normal.y > 0.0 && normal.z == 0.0){\n                // top\n                fragColor = green;\n            } else if (normal.x < 0.0 && normal.y == 0.0 && normal.z == 0.0){\n                // left\n                fragColor = pink;\n            } \n        } else if (mode == 3) {    \n            if (normal.x == 0.0 && normal.y == 0.0 && normal.z > 0.0) {\n                // front\n                fragColor = purple;\n            } else if (normal.x == 0.0 && normal.y > 0.0 && normal.z == 0.0){\n                // top\n                fragColor = pink;\n            } else if (normal.x < 0.0 && normal.y == 0.0 && normal.z == 0.0){\n                // top\n                fragColor = green;\n            } else if (normal.x == 0.0 && normal.y == 0.0 && normal.z < 0.0){\n                // back\n                fragColor = purple;\n            } \n            \n        } else if (mode == 2) {\n            float angle =  (-1.0) * smoothstep(0.0, 1.0, fract(iTime)) * 2.0 * PI / 3.0; \n            vec2 fragCoordRot = rotateM(angle) * (fragCoord - midP) + midP;\n            vec2 frag_v = normalize(fragCoordRot - midP);\n            vec2 comp_v = vec2(0.0, -1.0);\n            float theta = acos(dot(frag_v, comp_v) / 1.0);\n            if (theta > 0.0 && theta <= (2.0 * PI) / 3.0) {\n                if (fragCoordRot.x >= midP.x) {\n                    fragColor = pink;\n                } else {\n                    fragColor = purple;\n                }    \n            } else if (theta > (2.0 * PI) / 3.0 && theta <= (4.0 * PI) / 3.0) {\n                fragColor = green;\n            }\n                \n            \n        } else if (mode == 4) {\n            float angle =  smoothstep(0.0, 1.0, fract(iTime)) * 2.0 * PI / 3.0; \n            vec2 fragCoordRot = rotateM(angle) * (fragCoord - midP) + midP;\n            vec2 frag_v = normalize(fragCoordRot - midP);\n            vec2 comp_v = vec2(0.0, -1.0);\n            float theta = acos(dot(frag_v, comp_v) / 1.0);\n            if (theta > 0.0 && theta <= (2.0 * PI) / 3.0) {\n                if (fragCoordRot.x >= midP.x) {\n                    fragColor = pink;\n                } else {\n                    fragColor = green;\n                }    \n            } else if (theta > (2.0 * PI) / 3.0 && theta <= (4.0 * PI) / 3.0) {\n                fragColor = purple;\n            }\n            \n        }\n\t\t\n\t\t\n\t}\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddcR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 178], [180, 180, 205, 205, 358], [360, 360, 385, 385, 538], [541, 541, 566, 566, 643], [645, 645, 679, 679, 697], [699, 699, 737, 737, 898], [900, 900, 931, 931, 971], [973, 973, 1007, 1007, 1061], [1063, 1063, 1116, 1116, 1151], [1154, 1154, 1245, 1245, 1710], [1712, 1712, 1741, 1741, 2085], [2087, 2087, 2144, 2144, 6402]], "test": "error"}
{"id": "lddyz7", "name": "Trippy rainbow circles", "author": "rkibria", "description": "A field of colored circles rotating and zooming with distortion applied.", "tags": ["2d", "distortion"], "likes": 3, "viewed": 97, "published": "Public", "date": "1518301599", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord/iResolution.x;\n    vec2 uv = fragCoord/iResolution.x - vec2(0.5, 0.5*iResolution.y/iResolution.x);\n    \n    uv = vec2(sign(uv.x) * uv.x * uv.x, sign(uv.y) * uv.y * uv.y);\n\n    float rt = 3.141592 * sin(iTime/2.);\n    mat2 rmt = mat2(cos(rt), -sin(rt), sin(rt), cos(rt));\n    uv = rmt * uv;\n    \n    float modval = 0.025 + 0.015 * sin(iTime);\n    uv = mod(uv, modval);\n    \n    vec3 col = vec3(0.);\n\n    vec2 center = vec2(modval/2.);\n    float radius = (0.9*modval/2.);\n\n    float dd = distance(uv, center);\n    \n\tvec2 cv = rmt * uv0;\n\tif (dd >= radius && dd <= radius + 0.002)\n        col = vec3(distance(cv, vec2(1.)), \n                   distance(cv, vec2(0.5)), \n                   distance(cv, vec2(0.)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddyz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 827]], "test": "valid"}
{"id": "lddyz8", "name": "HW3 Paw Metaballs", "author": "ChloeSnyder", "description": "HW3", "tags": ["hw3"], "likes": 1, "viewed": 53, "published": "Public", "date": "1518140931", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define deg2rad PI / 180.0\n\nconst int MAX_MARCHING_STEPS = 300;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n// modified from jamie wong\nvec3 scaleOp(vec3 samplePoint, vec3 scale)\n{\n\treturn (samplePoint / scale);\n}\n\nfloat metaball(float angle, vec3 p, float amplitude)\n{\n    // body of paw pad\n    float blob_x = sin(angle) * cos(2.0*float(iTime) + angle) * amplitude;\n    float blob_y = cos(angle) * cos(2.0*float(iTime) + angle) * amplitude;\n    //paw prints are spheres rotating in a circle\n    float offsetX = (amplitude * .4) * sin(angle);\n    float offsetY = (amplitude * .4) * cos(angle);\n    //calculate displacement for point\n    float x = blob_x + offsetX;\n    float y = blob_y + offsetY;\n    p += vec3(x, y, 0.0);\n    p = scaleOp(p, vec3(.09, .09, .09));\n    return sphereSDF(p) * .09;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    float dist = MAX_DIST;\n    int numBalls = 7;\n    for (int i = 0; i < numBalls; i++) {\n        float amplitude = 0.4;\n        float angle = float(i) * 360.0 / float(numBalls) * deg2rad;\n        float metaball = metaball(angle, scaleOp(samplePoint, vec3(1.5, 1.5, 1.5)), amplitude);\n        dist = smin(dist, metaball, 0.15);\n    }\n    return dist-.01;\n}\n\n// Jamie wong\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n// Jamie Wong\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t\treturn;\n    }\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddyz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 184, 225, 225, 318], [320, 320, 355, 355, 395], [397, 425, 469, 469, 502], [504, 504, 558, 581, 1086], [1089, 1089, 1123, 1123, 1480], [1482, 1496, 1587, 1587, 1893], [1907, 1921, 1986, 1986, 2118], [2122, 2122, 2179, 2179, 2537]], "test": "valid"}
{"id": "lddyzM", "name": "Penrose variations", "author": "mattz", "description": "Three styles of point-lit wooden Penrose tiles. Mouse controls light position. Keys 1, 2, 3 control tile type.", "tags": ["2d", "fake3d", "tiling", "penrose"], "likes": 24, "viewed": 1116, "published": "Public API", "date": "1519221761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Penrose variations, by mattz\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   My brother wondered if you could \"fold\" kite & dart tiles in half for a cool 3D\n   look, and I made this to find out (spoiler: yes you can).\n\n   This shader morphs between \"flat\", \"pyramidal\", and \"folded\" tiles before repeating. \n\n   To implement this, I mainly used pencil & paper, along with these Wikipedia links:\n\n     - https://en.wikipedia.org/wiki/Penrose_tiling\n     - https://en.wikipedia.org/wiki/Golden_triangle_(mathematics)\n\n   Other cool Penrose tiling shaders:\n\n     - https://www.shadertoy.com/view/XlXGWM (tomkh)\n     - https://www.shadertoy.com/view/4t2XWG (tomkh)\n     - https://www.shadertoy.com/view/XdXGDX (daniel_flassig)\n\n   I tried to strive for readability below, feel free to request clarifications\n   in the comments!\n\n */\n\n// I used this when debugging the path, you can also use it to see the overall\n// symmetry of the sun deflation\n//#define DEBUG_PATH\n\n// maximum recursion depth, fun to play with\nconst int MAX_DEPTH = 8;\n\n// 1 / golden ratio\nconst float INVPHI = 0.6180339887498948;\n\n// 36 degrees\nconst float PI5 = 0.6283185307179586;\n\n// tile types\nconst int KITE = 0;\nconst int DART = 1;\n\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0/GAMMA;\n\n//////////////////////////////////////////////////////////////////////\n// homogeneous 2D coordinates of a line passing through 2 points\n\nvec3 line(vec2 x, vec2 y) {\n    return cross(vec3(x, 1), vec3(y, 1));\n}\n\n//////////////////////////////////////////////////////////////////////\n// offset a line by a distance\n\nvec3 offset_line(vec3 l, float d) {\n    l /= length(l.xy);\n    l.z -= d;\n    return l;\n}\n\n//////////////////////////////////////////////////////////////////////\n// returns signed product indicating which side of line l x is on\n\nfloat side(vec2 x, vec3 l) {\n    return dot(vec3(x, 1), l);\n}\n\n//////////////////////////////////////////////////////////////////////\n// given the 2D coordinates of a line l, and two 3D points a & b\n// compute the intersection of the line from a to b with the plane\n// that contains l and is perpendicular to the XY plane\n\nvec3 intersect(vec3 l, vec3 a, vec3 b) {\n   \n    vec3 p = cross(l, line(a.xy, b.xy));\n    p /= p.z;\n    \n    vec2 pa = p.xy-a.xy;\n    vec2 ba = b.xy-a.xy;\n    \n    float u = dot(pa,ba)/dot(ba, ba);\n    \n    p.z = mix(a.z, b.z, u);\n    \n    return p;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// split a half-kite into a half-dart and two half-kites.\n// see penrose function below for illustration of half-tiles.\n\nint half_kite(inout vec2 a, \n              inout vec2 b,\n              inout vec2 c,\n              in vec2 p) {\n    \n    vec2 x = mix(b, a, INVPHI);\n    vec2 y = mix(a, c, INVPHI);\n    \n    vec3 lxy = line(x, y);\n    \n    if (side(p, lxy) * side(a, lxy) >= 0.) {\n        \n        b = y;\n        c = x;\n        \n        return DART;\n        \n    } else {\n        \n        \n        vec3 lby = line(b, y);\n        \n        if (side(p, lby) * side(c, lby) >= 0.) {\n            \n            a = b;\n            b = c;\n            c = y;\n\n        } else {\n            \n            a = b;\n            b = x;\n            c = y;\n\n        }\n        \n        return KITE;\n                \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// split a half-dart into a half-dart and a half-kite.\n// see penrose function below for illustration of half-tiles\n\nint half_dart(inout vec2 a, \n              inout vec2 b,\n              inout vec2 c,\n              in vec2 p) {\n    \n    vec2 x = mix(a, b, INVPHI);\n    \n    vec3 lxc = line(x, c);\n    \n    if (side(p, lxc) * side(b, lxc) >=0.) {\n        \n        a = b;\n        b = c;\n        c = x;\n        return DART;\n        \n    } else {\n        \n        b = x;\n        \n        return KITE;\n        \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// mirrors p about the vector n if it lies in the other direction\n// the vector n is modified to contain half its angle w.r.t. the x-axis\n// returns the matrix M that accomplishes the flip\n//\n// really just 2D folding -- see https://www.shadertoy.com/view/4tX3DS \n// for a more intuitive explanation\n\nmat2 flip(inout vec2 p, inout vec2 n) {\n    \n    float d = dot(p, n);\n    \n    mat2 M = mat2(1.) - 2.*outerProduct(n, n);\n    \n\tn = normalize( vec2(n.x - 1., n.y) );\n    \n    if (d < 0.) {\n        p = M * p;\n        return M;\n    } else {\n        return mat2(1.);\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// given an input point p sufficiently close to the origin,\n// computes the coordinates a, b, c  of the half-dart or half-kite \n// triangle containing p and returns the type of triangle.\n//\n// we do this by repeated deflation of a \"sun\" pattern, see\n// https://en.wikipedia.org/wiki/Penrose_tiling#Deflation_for_P2_and_P3_tilings\n//\n// the half-tile shapes look roughly like this:\n//\n//                 _-* b                            _-* b\n//               _-   \\                           _- /\n//             _-      \\                        _-  /\n//           _-         \\                     _-   /\n//         _-            \\                  _-    /\n//       _-               \\               _-     /\n//     _-                  \\            _-      /\n//  a * - - - - - X - - - - * c      a *- - X -* c  \n//\n//            half-kite                half-dart\n//\n// in both cases, line segment ac is the line of symmetry for each tile,\n// and edge ab has the same length for both half-tiles\n\nint penrose(in vec2 p, out vec2 a, out vec2 b, out vec2 c) {\n    \n    // we start out with a single half-kite on the right side\n    // of the Y axis\n    int type = KITE;\n    \n    a = vec2(0);\n    b = vec2(sin(PI5), cos(PI5));\n    c = vec2(0, 1);\n\n    // use 2D folding to mirror p along lines of symmetry\n    // in the sun pattern until it lands inside the wedge\n    // described by points b and c above\n    \n    vec2 n1 = vec2(-cos(4.*PI5), sin(4.*PI5));\n    vec2 n2 = vec2(1, 0);\n\n    mat2 M = flip(p, n2); // mirror across y-axis\n    M = flip(p, n1) * M;  // 144 degree symmetry lines \n    M = flip(p, n1) * M;  // 72 degree symmetry lines\n    M = flip(p, n1) * M;  // 36 degree symmetry lines\n\n    // stop early if p is outside the central sun figure\n    vec3 lbc = line(b, c);\n    \n    if (side(p, lbc) * side(a, lbc) < 0.) {\n        return -1;\n    }\n\n    // by now, p should live inside the triangle abc, so do\n    // a few iterations of deflation to subdivide triangles\n    \n    for (int i=0; i<MAX_DEPTH; ++i) {\n        // precondition: p lives in abc\n        if (type == KITE) {\n            type = half_kite(a, b, c, p);\n        } else {\n            type = half_dart(a, b, c, p);\n        }\n        // postcondition: abc is updated with the sub-triangle containing p\n    }\n    \n    // now undo whatever flips we did to p, to get the \"real-world\"\n    // coordinates of a, b, and c so we can perform per-pixel lighting\n    a = a * M;\n    b = b * M;\n    c = c * M;\n    \n    // return what type of triangle p is in\n    return type;\n    \n}\n  \n\n//////////////////////////////////////////////////////////////////////\n// return the surface normal of a triangle with vertices at a, b, c\n\nvec3 trinormal(vec3 a, vec3 b, vec3 c) {\n    return normalize( cross(b-a, c-a) );\n}\n\n//////////////////////////////////////////////////////////////////////\n// compute a smoothed square wave\n\nfloat smoothsquare(float t) {\n    \n\tconst float t_rise = 0.25;\n    \n    const float t_hi = 1.0;\n    const float t_lo = 2.0;\n    \n    const float t_total = t_hi + t_lo;\n    \n    t = mod(t, t_total);\n    \n    if (t < t_hi) {\n        \n        return smoothstep(t_hi, t_hi-t_rise, t);\n        \n    } else {\n        \n        t -= t_hi;\n        \n        return smoothstep(t_lo - t_rise, t_lo, t);\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// given a point p inside a half-dart or half-kite with vertices abc, \n// compute the surface normal of the triangle containing p\n\nvec3 get_normal(vec2 p, int type, vec3 a, vec3 b, vec3 c) {\n    \n    // x is the point along line segment ac that bisects angle abc\n    // see ASCII art above for location\n    vec3 x = mix(a, c, INVPHI);\n    \n    vec3 lbx = line(b.xy, x.xy);\n    \n    float scl = length(a.xy-b.xy);\n    float s = sign(side(a.xy, lbx));\n    \n\t// we can treat triangles abx and xbc the same -- if p is on the\n    // same side of line bx as c is, we replace a with c and flip \n    // the sign of the triangle determinant\n    if (side(p, lbx) * s <= 0.) {\n        a = c;\n        s = -s;\n    }\n    \n    // at this point just assume we are dealing with triangle abx \n    \n    ////////////////////////////////////////////////////////////\n    // now select some parameters affecting triangle geometry\n    // 3 types of tile: flat, pyramid, folded    \n    \n    float t = iTime * 0.0625;\n    \n    for (int i=0; i<3; ++i) {\n        if (texelFetch(iChannel1, ivec2(49+i, 0), 0).x > 0.) {\n            t = float(i);\n        }\n    }\n    \n    // size of v-groove border between tiles (bigger for flat)\n    float border =  0.05*scl * (1.0 + smoothsquare(t));\n\n    // height of midpoint for \"pyramid\" type tiles\n    float pyramid = 0.08*scl * smoothsquare(t - 1.0);\n\n    // height of corners for \"folding\" type tiles\n    float fold = 0.3*scl * smoothsquare(t - 2.0);\n\n    \n    ////////////////////////////////////////////////////////////\n    // handle lifting up corners. \n    // note kites and darts are \"folded\" in opposite directions\n\n    if (type == KITE) {\n        a.z += fold;\n        x.z += fold;\n    } else {\n        b.z += fold;\n    }\n\n    ////////////////////////////////////////////////////////////\n    // compute the line that separates the border from the \n    // interior of the tile, and compute its intersections\n    // with segments ax and bx\n   \n    vec3 lab = line(a.xy, b.xy);\n    vec3 oab = offset_line(lab, s*border);\n    \n    vec3 d = intersect(oab, a, x);\n    vec3 e = intersect(oab, b, x);\n    \n    ////////////////////////////////////////////////////////////\n    // now raise up the interior points in z height\n    \n\td.z += border;\n    e.z += border;\n    x.z += border + pyramid;\n    \n    ////////////////////////////////////////////////////////////\n\t// finally, depending upon which side of the line we are on\n    // compute the normal\n    \n    if (side(p, oab)*s >= 0.0) { \n        // inside border\n        return s*trinormal(d, e, x);\n    } else { \n        // outside border\n        return s*trinormal(a, b, d);\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// from Dave_Hoskins' hash without sine: \n// https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// compute wood grain texture for a tile whose centerline in world\n// coordinates is given by ac\n\nvec3 wood_grain(vec2 p, int type, vec2 a, vec2 c) {\n       \n    vec2 cs = normalize(c-a);\n    mat2 R = mat2(cs.x, -cs.y, cs.y, cs.x);\n    \n    vec2 mid = 0.5*(a+c);\n    \n    p = R * (p - mid);\n    \n    p += hash22(mid * 8192.);\n    \n    vec3 color = texture(iChannel0, 12. * p).xyz;\n    \n    if (type == KITE) {\n        color = vec3(color.x + color.y, color.x - color.y, color.z) * 0.3;\n    } else {\n        color = mix(color, vec3(.7, .6, .2), 0.2);\n    }\n    \n    return pow(color, vec3(GAMMA));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// compute position along winding path\n\nvec2 get_path_pos(float i) {\n       \n    float theta = i * 6.283185307179586;\n    \n    float r = 8.0*sin(6.0*theta) + 2.0;\n    \n    return 0.07 * r * vec2(cos(theta), sin(theta));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// compute time-varying rotation matrix\n\nmat2 get_rotation(float f) {\n\n    float t = cos(f + 0.13) + 0.5 * cos(f*2.);\n    vec2 fwd = vec2(cos(t), sin(t));\n    \n    return mat2(fwd.x, -fwd.y, fwd.y, fwd.x); \n    \n}\n\n/////////////////////////////////////////////////////////////////////////////\n// our main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n\n\n    ////////////////////////////////////////////////////////////\n    // compute light coords\n    \n    vec2 mouse;\n    \n    if (max(iMouse.x, iMouse.y) > 20.0) {\n        mouse = (iMouse.xy - 0.5*iResolution.xy)*1.25 + 0.5*iResolution.xy;\n    } else {\n        mouse = 0.5*iResolution.xy;\n        float t = 0.25*iTime;\n        mouse += vec2(cos(t+1.5707), cos(3.*t))*0.4*iResolution.xy;\n    }\n    \n    vec3 l = normalize( vec3(mouse.xy - fragCoord.xy, 0.3*iResolution.y) );\n\n\n    ////////////////////////////////////////////////////////////\n    // compute 2D scene coords\n\n#ifdef DEBUG_PATH\n    float scl = 1.5 / iResolution.y;\n    mat2 R = mat2(1.);\n    vec2 path_pos = vec2(0);\n#else\n    float scl = (0.09 + cos(iTime*0.0815+0.3)*0.02) / iResolution.y;\n    vec2 path_pos = get_path_pos(0.001*iTime);\n    mat2 R = get_rotation(0.08*iTime);\n#endif\n    \n    vec2 p = (fragCoord - 0.5*iResolution.xy) * scl;       \n\n    p = (R * p) + path_pos;\n\n    ////////////////////////////////////////////////////////////\n    // get triangle type and vertices a, b, c\n    \n    vec2 a, b, c;\n    \n    int type = penrose(p, a, b, c);\n    \n    if (type < 0) {\n        fragColor = vec4(0);\n        return;\n    }\n       \n    ////////////////////////////////////////////////////////////\n    // compute triangle normal\n\n    vec3 n = get_normal(p, type, vec3(a, 0), vec3(b, 0), vec3(c, 0));\n    \n    // rotate the normal back to counter camera rotation\n    n.xy = n.xy * R;\n\n    ////////////////////////////////////////////////////////////\n    // per-pixel lighting\n    \n    vec3 color = wood_grain(p, type, a, c);\n    \n    color *= mix(dot(n, l), 1.0, 0.3);\n    \n    // specular\n    vec3 v = normalize(vec3(fragCoord.xy - 0.5*iResolution.xy, 1.5*iResolution.y));\n    vec3 r = reflect(l, n);\n    color += 0.05*pow(clamp(-dot(r, v), 0.0, 1.0), 10.0);\n    \n    // gamma correct\n    color = pow(color, vec3(INV_GAMMA));\n\n#ifdef DEBUG_PATH    \n    \n    const float di = 1.0/200.0;\n    \n    for (float i=0.0; i<1.0; i+=di) {\n        \n        vec2 pi = get_path_pos(i);\n        vec2 pj = get_path_pos(i+di);\n      \n        float u = dot(p-pi, pj-pi) / dot(pj-pi, pj-pi);\n        vec2 pc = mix(pi, pj, clamp(u, 0.0, 1.0));\n        \n        color = mix(color, vec3(0.75,1,0), smoothstep(scl, 0.0, length(p-pc)-scl));\n        \n    }\n    \n#endif    \n    \n    fragColor = vec4(color, 1);\n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddyzM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1449, 1449, 1476, 1476, 1520], [1625, 1625, 1660, 1660, 1713], [1853, 1853, 1881, 1881, 1914], [2176, 2176, 2216, 2216, 2432], [2626, 2626, 2737, 2737, 3315], [3505, 3505, 3616, 3616, 3907], [4281, 4281, 4320, 4320, 4557], [5624, 5624, 5684, 5772, 7166], [7311, 7311, 7351, 7351, 7394], [7502, 7502, 7531, 7531, 7905], [8109, 8109, 8168, 8280, 10623], [10826, 10826, 10847, 10847, 10965], [11137, 11137, 11188, 11188, 11637], [11750, 11750, 11778, 11778, 11936], [12050, 12050, 12078, 12078, 12222], [12324, 12324, 12381, 12480, 14746]], "test": "error"}
{"id": "lddyzr", "name": "rainbow ring", "author": "teriyaki", "description": "playing with simplex noise and hsv", "tags": ["rainbownoise"], "likes": 20, "viewed": 1729, "published": "Public API", "date": "1517844828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// jstn made this\n\n// noise by ashima\n// hsv by q\n// lessons from bigwings\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define      PI 3.14159265358979323 // mm pie\n#define     TAU 6.28318530717958647 // pi * 2\n#define HALF_PI 1.57079632679489661 // pi / 2\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v) {\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n    \n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n  // First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n  // Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n  // Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n  // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n  // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  // Normalise gradients implicitly by scaling m\n  // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  // Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  // igo Qulez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nfloat circle(vec2 uv, vec2 pq, float radius, float noiseishness) {\n  float r = radius + snoise(uv + iTime * .25) * noiseishness;\n  float s = 3. / iResolution.y;\n  return smoothstep(r + s, r - s, pq.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n  vec2 pq = vec2(atan(uv.x, uv.y) / TAU + .5, length(uv));\n    \n  float n = .066;\n  //n += sin(iTime) * .1; // add some extra warble\n  float c0 = circle(uv, pq, .75, n);\n  float c1 = circle(uv, pq, .7, n);\n\n  float h = pq.x - iTime * .5;\n  vec3 col = hsv2rgb(vec3(h, 1., 1.));\n  fragColor = vec4(col, 1.) * (c0 - c1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddyzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 282, 282, 331], [333, 333, 354, 354, 403], [405, 405, 427, 427, 464], [466, 466, 488, 911, 2440], [2442, 2442, 2464, 2528, 2675], [2677, 2677, 2743, 2743, 2880], [2882, 2882, 2937, 2937, 3324]], "test": "valid"}
{"id": "ldtyRn", "name": "pulse ring", "author": "germ", "description": "learning and looking for feedback", "tags": ["pulse"], "likes": 6, "viewed": 165, "published": "Public", "date": "1517807715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspired by https://codepen.io/peeke/pen/BjxXZa\n#ifndef PI\n#define PI 3.141592653589793\n#endif\n\nfloat backIn(float t) {\n    return pow(t, 3.0) - t * sin(t * PI);\n}\n\n// see how our zigZag and upWave waves look plotted:  \n// https://www.desmos.com/calculator/dn8kffitdg\n \n// zigzag wave\nfloat zigZag(float dx) {\n    float b = -mod(floor(dx), 2.0);\n    float a = (-1.0 + 2.0 * mod(floor(dx), 2.0));\n\n    return (dx - floor(dx)) * a + b + 1.0;\n}\n\n// diagonal line that goes up\n// returns [0, 1]\nfloat upWave(float dx) {\n    return (dx - floor(dx));\n}\n\nfloat circle(vec2 uv, float startRadius, float rangeSize, bool fade) {\n    float time = 0.5 + iTime * 0.8;\n\n    float ease;\n\n    if (fade) {\n      // shifted, but at a normal frequency\n      ease = upWave(0.5 + time);\n    } else {\n      // increased frequency\n      ease = backIn(zigZag(2.0 * time));\n    }\n\n    float radius = startRadius + ease * rangeSize;\n    \n    // our coordinate system uses [0, 1] and we want to find the distance\n    // of our point to the center (0.5, 0.5).  we first adjust our point\n    // by the center (giving it a new center of 0, 0).  we can then use this\n    // toCenter point to find the distance (vector length) to the center.\n    vec2 toCenter = vec2(uv - 0.5);\n  \n    // adjust toCenter for aspect ratio\n    toCenter.x *= iResolution.x / iResolution.y;\n\n    // (vector length) distance from the pixel to the center\n    float dist = length(toCenter);\n    \n    // a single pixel in [0, 1] coordinate space is 1 / res;\n    float res = min(iResolution.x, iResolution.y);\n\n    /*\n    // circle without smoothed edges\n    // (if the distance to the pixel is less than our radius)\n    float c = (dist <= radius / res) ? 1.0 : 0.0;\n    */  \n    \n    // our smoothness area\n    float smoothness = 2.0 / res;\n    \n    // circle with smoothed edges\n    // smoothstep(e1, e2, x) interpolates from [0, 1] when x is within e1 and e2\n    // returns 0 when x < e1 and 1 when x > e2.\n    // essentially, this does the same thing as \"circle without smoothed edges\", but \n    // gives us a nice gradient when we are within radius and radius + smoothness\n    float c = smoothstep(radius / res + smoothness, radius / res, dist);\n    \n    // mix(x, y, a) will interoplate a from x to y\n    if (fade) {\n      // fade the ring as we go outward\n      float opacity = (1.0 - smoothstep(0.1, 0.9, ease));\n      return mix(0.0, 1.0, c * opacity);\n    } else {\n      return mix(0.0, 1.0, c);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalize pixel coordinates to [0, 1]\n    vec2 uv = ( fragCoord.xy / iResolution.xy ) ;\n\n    // define the base background color\n    vec3 color = vec3(.21, .22, .28);\n  \n    // calculate the circles\n    float outerCircleAlpha = circle(uv, 25.0, 80.0, true) * 0.85;\n    float innerCircleAlpha = circle(uv, 45.0, 10.0, false);\n  \n    // mix in the circle alpha colors with a circle color and the base color \n    color = mix(color, vec3(0.0, .64, .91), outerCircleAlpha);\n    color = mix(color, vec3(1.0, 1.0, 1.0), innerCircleAlpha);    \n    \n    // render the color\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldtyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 122, 122, 166], [273, 288, 312, 312, 444], [446, 494, 518, 518, 549], [551, 551, 621, 621, 2458], [2460, 2460, 2515, 2560, 3123]], "test": "valid"}
{"id": "llBBDt", "name": "Radar Sweep", "author": "salaark", "description": "Modification of a class demonstration.", "tags": ["toolboxfunctions"], "likes": 1, "viewed": 109, "published": "Public", "date": "1517530461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scrPt = uv * 2.0 - 1.0; // Transform to NDC\n    scrPt.x *= iResolution.x / iResolution.y; // Account for aspect ratio\n    \n    // Create rotation matrix based on time\n    mat2 rot;\n    float theta = -iTime * 1.0 * 3.14159 - 2.2; // The 2.2 was visually tweaked, repeatedly guess values until it looks right :)\n    float cosTheta, sinTheta;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n    rot[0][0] = cosTheta;\n    rot[0][1] = -sinTheta;\n    rot[1][0] = sinTheta;\n    rot[1][1] = cosTheta;\n    \n    vec2 scrPtRot = rot * scrPt;\n    \n    // Parameterize radar shape\n    float angle = 1.0 - (atan(scrPtRot.y, scrPtRot.x) / 6.2831 + 0.5);\n    float falloff = 1.0 - length(scrPtRot);\n    \n    // Color accumulator\n    vec3 col = vec3(0);\n    \n    // Rings\n    float ringSpacing = 0.23;\n    if(mod(length(scrPtRot), ringSpacing) < 0.015 && length(scrPtRot) / ringSpacing < 5.0) {\n        col += vec3(0, 0.5, 0);\n    }\n    \n    // 2D SDF (you should actually use step()!) with color intensity function made in GraphToy (http://www.iquilezles.org/apps/graphtoy/)\n    if(length(scrPt - vec2(0.5, 0.5)) < 0.05) {\n        //col.r = 2.0 * max(0.0, fract(-iTime * 0.5) - 0.5); // Old function described in class\n        \n        // New way to animate the point! While the above function does work, it is difficult to make it\n        // visually align with the radar line. If we make the dot color a function of the angle, the blinking\n        // dot will match up perfectly. \n        col.g = angle * angle * angle; // Why angle^3? It makes the the dot's color intensity fall off faster.\n        // Try:\n        // col.r = angle;\n        // or\n        // col.r = pow(angle, 5.0);\n        // to see this in action. Keep in mind that angle is on the range [0, 1] when thinking about why this works!\n    }\n    \n    // Rings with no branching\n    col += vec3(0, 0.8, 0) * step(mod(length(scrPtRot), ringSpacing), 0.01) * step(length(scrPtRot), 1.0);\n    \n    fragColor = vec4(vec3(pow(angle, 2.0) * falloff) * vec3(0, 1, 0) + col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBBDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2135]], "test": "valid"}
{"id": "lljfDd", "name": "flow42", "author": "dlsym", "description": "Even more fun with quasicrystals", "tags": ["quasicrystals"], "likes": 24, "viewed": 442, "published": "Public", "date": "1517670804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define M_PI 3.14159265\n\n#define SCALE 1.0\n#define K 7\n#define F 0.55\n\n\n// LogPolar transform\nvec2 c2p(vec2 coord) {\n\tfloat th = atan(coord.y, coord.x);\n    float r = log(sqrt(coord.x*coord.x+coord.y*coord.y)); \n    \n    return vec2(th, r);\n}\n\n// Colorize. See:\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec4 colorize(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    vec3 col = 2.5 * a * b * (cos(0.4*M_PI*(c*t+d))); \n    return vec4(col, 1.0);\n}\n\nvec4 colorize2(float v) {\n \tvec3 col = vec3(v, v, v);\n    return vec4(col, 1.0);\n}\n\nfloat v(vec2 coord, float k, float s, float rot) {\n    float cx = cos(rot);\n    float sy = sin(rot);\n    \n\treturn 0.0 + 0.5 * cos((cx * coord.x + sy * coord.y) * k + s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat t = 0.8 * iTime;\n    \n    vec2 xy = fragCoord.xy - (0.5 * iResolution.xy); // center\n    vec2 uv = c2p(xy); // Polar (opt.)\n    uv = xy / SCALE; // Scale\n        \n    float vt = 0.0;\n  \n\t    \n    for(int i = 0; i < K; i++) {\n        float s = float(i) * M_PI / float(K);\n    \tfloat w = v(uv, F, t, s);\n        \n        vt += w / 0.5;\n    }\n    \n    \n    vec4 col = colorize(vt, vec3(0.5, 0.5, 0.5),\n                        \tvec3(0.5, 0.5, 0.5),\n                        \tvec3(1.0, 1.0, 1.0),\n                        \tvec3(0.00, 0.33, 0.67));\n    /*\n    vec4 col = colorize(vt, vec3(0.5, 0.5, 0.5),\n                        \tvec3(0.5, 0.5, 0.5),\n                        \tvec3(1.0, 1.0, 0.5),\n                        \tvec3(0.80, 0.90, 0.30));\n    */\n   // col = colorize2(vt);\n    \n    // Mask center (a bit)\n    float m =  3.0*(distance((fragCoord.xy / iResolution.xy), vec2(0.5, 0.5)));\n    //col = vec4( m, m, m, 1.0);\n    // col = clamp(m, 0.0, 1.0) * col;\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljfDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 95, 117, 117, 243], [245, 327, 383, 383, 467], [469, 469, 494, 494, 551], [553, 553, 603, 603, 724], [726, 726, 783, 783, 1802]], "test": "valid"}
{"id": "llSfWd", "name": "Telaraasas ", "author": "jpupper", "description": "This is a shader for testing in other program. Love you all", "tags": ["shaderglsl"], "likes": 2, "viewed": 116, "published": "Public", "date": "1517551988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define PI 3.14159265359\n\n\n\n//ponele que estas seran como las cantidades:\n//uniform vec2 pos;\n//ESTA DEFINE COMO LA CANTIDAD DE CIRCULITOS QUE APARECEN\n\n//PONGO LOS UNIFORM MUTEADOS PORQUE SI NO , NO CORRE. FIJATE QUE EN TOUCH LOS TENES QUE DESMUTEAR\n/*\nuniform float PX\nuniform float PY\nuniform float cnt2;\n\n//esta la cantidad de puntas de la figura ponele\nuniform float cnt3;\n\nuniform float ap1;\nuniform float ap2;\nuniform float ap3;*/\n\n\nfloat def(vec2 uv, float f);\n\nvec3 clr(vec4 col,float e){\n\n    return vec3(e)*vec3(col)*col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n   \tfloat time = iTime;\n    vec2 p = vec2(0.5)-uv;\n    float a = atan(p.x,p.y);\n    float rad = length(p);\n    \n    \n    \n    //A cada forma cada color.\n    float e =  def(uv,PI);\n    float e2 = abs(def(uv,PI+PI/17.));\n    float e3 = abs(def(uv,PI-PI/17.));\n    float e4 = def(uv,PI)*uv.y;\n    \n    \n    \n    //COLORES COLORSSSSSSS\n    vec4 col2 = vec4(0.9,0.0,0.5,0.5);\n    vec4 col1 = vec4(0.0,1.-rad*2.,0.0,1.);\n    vec4 col3 = vec4(0.5,0.0,0.9,0.5);\n    vec4 col4 = vec4(0.0,1.,0.5,1);\n    \n    \n    //COMBINAR LOS COLORESSS \n    //COMBINE DE COLORS\n    \n    //aca asignamos a cada capa, cada color digamos.\n    vec3 fin = clr(col1,e)+clr(col2,e2)+clr(col3,e3)+0.5-uv.y;\n    fragColor = vec4(fin,1.0);\n}\n\n\n//FUNCION PARA MODIFICAR LA FORMA DIGAMO\nfloat def(vec2 uv,float f){\n    \n     \n\n\t//ACA LAS DEFINO COMO VARIABLES PARA QUE CORRA EN SHADER TOY. PERO LAS TENES QUE MUTEAR\n    // PARA QUE TE BORRE LOS UNIFORMS\n     float cnt2 = 4.;\n     float cnt3 = 4.;\n     float ap1 = 1.;\n     float ap2 = 0.7;\n     float ap3 = 1.;\n     float PX = 0.5;\n     float PY = 0.1;\n    \n    vec2 p = vec2(PX,PY)-abs(sin(uv*PI+PI/2.))*0.8;\n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    float time = iTime;\n    \n    //float e2 = sin(uuna v.x*5+sin(r+sin(a*5+time*5)));\n    float e2 = uv.y*cnt3+sin(uv.x*sin(a*cnt3+sin(r*cnt3)))*ap1;\n    \n    \n    float e = abs(sin(e2*PI*5.+time)*1.+sin(uv.x*PI*cnt3*sin(r*50.)))\n    *abs(sin(a*cnt3+time*5.))*ap3-\n    sin(r*f*PI*cnt2+cos(a*cnt3)*0.2+time)*ap3;\n\n    \n    return e ;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSfWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[474, 474, 501, 501, 540], [542, 542, 599, 649, 1408], [1411, 1452, 1479, 1618, 2215]], "test": "valid"}
{"id": "ls2fz1", "name": "Julia gradient", "author": "zeletochoy", "description": "Julia set with a custom gradient function", "tags": ["2d", "fractal", "julia", "gradient", "set"], "likes": 4, "viewed": 436, "published": "Public API", "date": "1518972567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITER 100\n#define PT_RAD 0.03\n#define PI6 0.52359877559\n\nvec2 csqr(vec2 c)\n{\n    return vec2(c.x*c.x - c.y*c.y, 2.*c.x*c.y);\n}\n\nint julia_iters(vec2 z, vec2 c)\n{\n    for (int i = 0; i < MAX_ITER; ++i)\n    {\n        z = csqr(z) + c;\n        if (z.x*z.x + z.y*z.y > 4.)\n            return i;\n    }\n    return MAX_ITER;\n}\n\nfloat julia(vec2 z, vec2 c)\n{\n    float dist = float(MAX_ITER) - float(julia_iters(z, c));\n    float coef = pow(dist / float(MAX_ITER), 6.);\n    return coef;\n}\n\nvec3 gradient(float t)\n{\n    float c1 = 0.3 + 1.4 * max(abs(sin(0.5 * t + 9. * PI6)) - 0.5, 0.);\n    float c2 = 0.3 + 1.4 * max(abs(sin(0.5 * t + 11. * PI6)) - 0.5, 0.);\n    float c3 = 0.3 + 1.4 * max(abs(sin(0.5 * t + 13. * PI6)) - 0.5, 0.);\n    return vec3(c1, c2, c3);\n}\n\nvec3 julia_color(float coef, float t)\n{\n    vec3 col_in = vec3(0.);\n    vec3 col_out = gradient(t);\n    return mix(col_in, col_out, coef);\n}\n\nvec2 c_curve(float t)\n{\n    float d = 0.7885 + 0.1 * sin(5. * t);\n    return vec2(d * cos(t), d * sin(t));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = iTime / 3.;\n    vec2 z = 2.5 * (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 c = c_curve(t);\n    \n    float coef = julia(z, c);\n    vec3 col = julia_color(coef, t);\n\tfragColor = vec4(col, 1.);\n    \n    float dist = distance(z, c);\n    if (dist < PT_RAD)\n    {\n        vec3 inv_col = vec3(1.) - fragColor.xyz;\n        coef = smoothstep(PT_RAD, 0., dist);\n        fragColor.xyz = mix(fragColor.xyz, inv_col, coef*coef);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls2fz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 137], [139, 139, 172, 172, 329], [331, 331, 360, 360, 490], [492, 492, 516, 516, 765], [767, 767, 806, 806, 907], [909, 909, 932, 932, 1017], [1019, 1019, 1074, 1074, 1529]], "test": "valid"}
{"id": "ls3czj", "name": "glossy raytracing test", "author": "dtoadq", "description": "test", "tags": ["test"], "likes": 0, "viewed": 232, "published": "Public API", "date": "1519520325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//------------------------------------------------------------------------------\n//-------- SETTINGS (FOR UTILITY LIBRARY) --------------------------------------\n\n#define Scene_width  3.5\n#define Scene_height 1.4\n// Uncomment below to have light move along with scene (you have to undefine\n// collect in Buf c)\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//-------- UTILITY LIBRARY -----------------------------------------------------\n//------------------------------------------------------------------------------\n#define float4 vec4\n#define float3 vec3\n#define float2 vec2\n\n#define PI   3.141592653589793\n#define IPI  0.318309886183791\n#define IPI2 0.159154943091895\n#define TAU  6.283185307179586\n#define ITAU 0.159154943091895\n\n#define SQR(X) ((X)*(X))\n\n#define MOUSEX (iMouse.x/iResolution.x)\n#define MOUSEY (iMouse.y/iResolution.y)\n\nuniform vec3 u_eye3d;\nuniform vec3 u_centre3d;\nuniform vec3 u_up3d;\n\nstruct Ray { float3 ori, dir; };\n\nfloat2 Map ( float3 o );\n\nfloat2 March ( in Ray ray ) {\n  float dist = 0.0;\n  float2 cur;\n  for ( int i = 0; i != 64; ++ i ) {\n    cur = Map(ray.ori + ray.dir*dist);\n    if ( cur.x <= 0.0005 || dist > 256.0 ) break;\n    dist += cur.x;\n  }\n  if ( dist > 256.0 || dist < 0.0 ) return float2(-1.0);\n  return float2(dist, cur.y);\n}\n\nfloat3 Normal ( float3 p ) {\n  float2 e = float2(1.0, -1.0)*0.001;\n  return normalize(\n                   e.xyy*Map(p + e.xyy).x +\n                   e.yyx*Map(p + e.yyx).x +\n                   e.yxy*Map(p + e.yxy).x +\n                   e.xxx*Map(p + e.xxx).x);\n}\n\nRay Look_At ( float2 uv ) {\n  //----origin\n  float3 ori = float3(Scene_width*cos(1.0*iTime+3.0f),\n                      Scene_height+cos(2.0*iTime-1.0+1.5f)*0.3f,\n                      Scene_width*sin(1.0*iTime+3.0f));\n  //----etc\n  float3 center = float3(0.0),\n         up     = float3(0.0, 1.0, 0.0);\n  float3 ww = normalize(center - ori),\n         uu = normalize(cross(up, ww)),\n         vv = normalize(cross(ww, uu));\n  return Ray(ori, normalize(uv.x*uu + uv.y*vv + 2.5*ww));\n}\n\n// -- maps --\nfloat sdSphere ( in float3 O, in float R ) { return length(O) - R; }\nfloat sdShell  ( in float  D, in float R ) { return abs(D) - R*0.5f; }\nfloat sdPlane  ( in float3 O, in float3 N, in float D ) {\n  return dot(O, N) + D;\n}\n\nvoid Union ( inout float2 t, float d, in float ID ) {\n  if ( t.x > d ) t = float2(d, ID);\n}\n\nvoid opRotate(inout float2 p, in float a ) {\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// -- random --\n\nfloat Sample_Uniform(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 Sample_Uniform2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 Sample_Uniform3(inout float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*\n                 vec3(43758.5453123,22578.1459123,842582.632592));\n}\n\n// -- sampler --\n\n//------------------------------------------------------------------------------\n//-------- MATERIALS -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nstruct Light {\n  float3 ori, emi;\n  float radius;\n};\n\n#define LIGHTS_LEN 3\nLight lights[LIGHTS_LEN];\n\nvoid Initialize_Lights ( ) {\n  lights[0].ori = float3(sin(iTime), 1.0f, 1.0f-cos(iTime));\n  lights[0].emi = float3(0.9, 0.2, 0.9)*2.0;\n  lights[0].radius = 0.05f;\n\n  lights[1].ori = float3(cos(iTime), 2.0f, log(1.0f-sin(iTime)*0.9f));\n  lights[1].emi = float3(0.8, 0.9, 0.7)*1.5;\n  lights[1].radius = 0.05f;\n\n  lights[2].ori = float3(-sin(iTime), cos(iTime*2.0f)*0.2f+0.5f, sin(iTime));\n  lights[2].emi = float3(0.2, 0.5, 0.9)*1.5;\n  lights[2].radius = 0.05f;\n}\n\nfloat noise ( in float2 uv ) {\n  return sin(1.5f*uv.x) + sin(1.5f*uv.y);\n}\n\nfloat2 Normal_Sampler ( in sampler2D s, in float2 uv ) {\n  float2 eps = float2(0.003f, 0.0f);\n  return float2(length(texture(s, uv+eps.xy)) - length(texture(s, uv-eps.xy)),\n                length(texture(s, uv+eps.yx)) - length(texture(s, uv-eps.yx)));\n}\n\nfloat2 Map ( in float3 O ) {\n  float3 ori = O;\n  float2 res = float2(999.0);\n  float2 nmap = Normal_Sampler(iChannel0, O.xz*0.2f);\n  O.y += nmap.y*0.08f;\n  float s = sdPlane(O, float3(0.0f, 1.0f, 0.0f), 0.0f);\n  Union(res, s*0.5f, 0.0f);\n\n  O = ori-float3(2.0f, 0.4f, 0.4f + sin(iTime));\n  opRotate(O.xy, tan(iTime));\n  opRotate(O.yz, iTime);\n  opRotate(O.xz, log(1.0f-sin(0.5f*iTime)*0.89f)*4.0f*PI);\n  nmap = Normal_Sampler(iChannel0, O.xy*0.2f + O.zy*0.3f);\n  O.y += length(nmap)*0.25f;\n  // O.x += length(nmap)*(sin(iTime)+2.0f);\n  Union(res, sdSphere(O, 0.5f)*0.5f, 1.0f);\n\n  O = ori;\n\n  for ( int i = 0; i != LIGHTS_LEN; ++ i )\n    Union(res, sdSphere(O-lights[i].ori, lights[i].radius), 10.0f+float(i));\n  return res;\n}\n\n\nfloat Smith_G_GGX_Correlated ( float L, float R, float a ) {\n  return L * sqrt(R - a*(R*R) + a);\n}\n\nfloat3 BRDF ( in float3 N, in float3 wi, in float3 wo ) {\n  wi = -wi;\n  float3 H = normalize(wi+wo);\n  float D, G, F;\n  { // -------- Distribution\n    float alpha = 0.8f;\n    float ggx = alpha*alpha;\n    ggx /= (PI * pow( pow(dot(N, wo), 2.0f) * (ggx - 1.0f) + 1.0f, 2.0f));\n    D = ggx;\n  }\n  { // -------- Geometric\n    G = dot(N, wo) * dot(N, wi) / pow(dot(wi, H), 2.0f);\n  }\n  return float3(G)/(4.0f*dot(N, wi)*dot(N, wo));\n}\n\nvoid mainImage(out vec4 frag_colour, in vec2 frag_coord) {\n  float2 uv = -1.0 + 2.0*frag_coord.xy/iResolution.xy;\n  uv.x *= iResolution.x/iResolution.y;\n  Initialize_Lights();\n  frag_colour = float4(float3(0.0f), 1.0f);\n\n  Ray eye = Look_At(uv);\n  float2 res = March(eye);\n  if ( res.x > 0.0f ) {\n    float3 O = eye.ori + eye.dir*res.x,\n           N = Normal(O),\n          wi = eye.dir;\n\n    if ( res.y >= 10.0f ) {\n      frag_colour.xyz = lights[int(res.y-10.0f)].emi;\n      return;\n    }\n\n    float3 eps = float3(1.0f/iChannelResolution[0].xy, 0.0f);\n    float2 nmap = Normal_Sampler(iChannel0, O.xz*0.2f);\n    if ( res.y == 0.0f ) {\n      N.xz += nmap*1.0f;\n      N.yx += nmap.yx*1.4f;\n    }\n\n    for ( int i = 0; i != LIGHTS_LEN; ++ i ) {\n      float3 colour = float3(0.0f);\n      float3 wo = normalize(lights[i].ori - O);\n      float lobe = 0.4f;\n      float p = 1.0f/(1.0f*PI*(sin(0.5f)*sin(lobe)));\n      float3 NN = reflect(wi, N);\n      colour += BRDF(N, wi, wo)/p*lights[i].emi;\n      if ( res.y == 1.0f ) colour *= float3(1.0f, 1.0f, 0.2f);\n      if ( res.y == 0.0f ) {\n        colour *= texture(iChannel0, O.xz*0.2f).xyz*3.0f;\n      }\n      // 0.2f diffuse 0.8f glossy\n      colour = (colour*0.4f) + (colour*0.6f*float(dot(wo, NN) > cos(lobe)));\n\n      frag_colour.xyz += colour*(1.0f/float(LIGHTS_LEN));\n    }\n  }\n  frag_colour = clamp(frag_colour, float4(0.0f), float4(1.0f));\n  frag_colour.xyz = pow(frag_colour.xyz, float3(0.8f));\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3czj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1089, 1089, 1118, 1118, 1390], [1392, 1392, 1420, 1420, 1656], [1658, 1658, 1685, 1700, 2139], [2141, 2155, 2199, 2199, 2223], [2224, 2224, 2268, 2268, 2294], [2295, 2295, 2352, 2352, 2378], [2380, 2380, 2433, 2433, 2471], [2473, 2473, 2517, 2517, 2560], [2579, 2579, 2619, 2619, 2671], [2673, 2673, 2713, 2713, 2799], [2801, 2801, 2841, 2841, 2969], [3335, 3335, 3363, 3363, 3796], [3798, 3798, 3828, 3828, 3872], [3874, 3874, 3930, 3930, 4128], [4130, 4130, 4158, 4158, 4856], [4859, 4859, 4919, 4919, 4957], [4959, 4959, 5016, 5016, 5388], [5390, 5390, 5448, 5448, 6838]], "test": "error"}
{"id": "ls3yRB", "name": "Glowing hexagonal tile", "author": "murosyoukei", "description": "References\nhttps://github.com/unity3d-jp/unitychan-crs/wiki/Visualizer", "tags": ["practice"], "likes": 10, "viewed": 432, "published": "Public", "date": "1519324983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hex( vec2 p, vec2 h )\n{\n\tvec2 q = abs(p);\n\treturn max(q.x - h.y,max(q.x + q.y * 0.57735, q.y * 1.1547) - h.x);\n}\n\nfloat gra( float v, float r )\n{\n    return clamp((0.5 * r - abs(0.5 - mod(v + 0.5, 1.0))) * 2.0 / r, 0.0, 1.0);\n}\n\nvec4 hexGrid( in vec2 uv )\n{\n\tfloat radius = 0.1;\n\tfloat padding = 0.01;\n\tfloat grid_radius = radius + padding * 2.0 + 0.0733;\n\tvec2 grid = vec2(grid_radius * 1.73, grid_radius);\n\n\tvec2 p1 = mod(uv, grid) - grid * 0.5;\n\tvec2 p2 = mod(uv + grid * 0.5, grid) - grid * 0.5;\n\tfloat d1 = hex(p1, vec2(radius));\n\tfloat d2 = hex(p2, vec2(radius));\n\tfloat d = min(d1, d2);\n\tvec4 main_color = vec4(1.0, 0.0, 0.0, 1.0);\n\tvec4 hex_color = main_color * 0.5;\n\tvec4 grid_color = main_color * gra(uv.y + iTime, 0.75);\n\tvec4 grid_light_color = vec4(1.0, 1.0, 1.0, 1.0);\n\t\t\n\tgrid_light_color = grid_light_color * gra(uv.y + iTime, 0.25);\n    grid_light_color *= grid_light_color;\n    grid_color += grid_light_color;\n     \n    grid_color.a = 0.25;\n\thex_color.a = 0.25;\n\t\n    vec4 c = (d < 0.0 ? 1.0 : 0.0) * hex_color;\n    c += grid_color * (d < 0.0 ? 0.0 : 1.0);\n    c += grid_light_color * max(0.0, d * 4.0 + 0.1) * 5.0;\n    c += grid_light_color * max(0.0, d * 4.0 + 0.5) * 1.0;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tfragColor = hexGrid(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3yRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 118], [120, 120, 151, 151, 233], [235, 235, 263, 263, 1214], [1216, 1216, 1273, 1273, 1389]], "test": "valid"}
{"id": "ls3yWn", "name": "Maki's Lava Lamp Thing", "author": "MakiXx", "description": "Just learning and trying! Use mouse and try VR.\nNoise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83mh\n", "tags": ["raytracing"], "likes": 1, "viewed": 180, "published": "Public", "date": "1518405941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//vec3 cameraPosition = vec3(0,0,0);\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) {\n    //vec3 cam = vec3(0,u_time*0.4,0);\n    vec3 cameraPosition = fragRayOri;\n    //cameraPosition.y-=iTime*0.1;\n        \n    vec3 ro = fragRayOri;\n    vec3 rd = fragRayDir;\n    \n    float c = 4.0;\n    \n    for (float step=0.0; step<256.0; step+=1.0) {\n        vec3 p = cameraPosition+ro+((rd*0.1)*step);\n        float d = snoise(p);\n        if (d>0.4) {\n            c = length(cameraPosition-p);\n            break;\n        }\n    }\n    \n    //fragColor = vec4(vec3(1,0.1,0)*(4.0-c),1);\n    fragColor = vec4(hsv2rgb(vec3((c*0.4)-(iTime*0.2), 1, 4.0-c)),1);\n}\n                               \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = -1.0+2.0*fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraPosition = vec3(iMouse.xy*0.01,0);\n   \t//cameraPosition.x += texelFetch(iChannel0, ivec2(65,0), 0).x*-0.01;\n    //cameraPosition.y-=iTime*0.1;\n    vec3 cameraDirection = vec3(iMouse.xy*0.01,0);\n        \n    vec3 ro = vec3(0,0,0);\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    \n    float c = 4.0;\n    \n    for (float step=0.0; step<256.0; step+=1.0) {\n        vec3 p = cameraPosition+ro+((rd*0.03)*step);\n        float d = snoise(p);\n        if (d>0.4) {\n            c = length(cameraPosition-p);\n            break;\n        }\n    }\n    \n    //fragColor = vec4(vec3(1,0.1,0)*(4.0-c),1);\n    fragColor = vec4(hsv2rgb(vec3((c*0.4)-(iTime*0.2), 1, 4.0-c)),1);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3yWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 75, 75, 112], [113, 113, 140, 140, 188], [190, 190, 211, 211, 2047], [2049, 2049, 2071, 2071, 2234], [2274, 2274, 2366, 2405, 2923], [2956, 2956, 3011, 3011, 3780]], "test": "valid"}
{"id": "lsccR8", "name": "5 point star", "author": "iq", "description": "An antialiased 5 point 2d star. This one is [b]not[/b] an euclidean distance field in its interior nor exterior. Uses reflections instead of domain mod()-ing to achieve the 5x repetition.", "tags": ["2d", "star", "reflections"], "likes": 14, "viewed": 1073, "published": "Public API", "date": "1517894950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat sdfStar5( in vec2 p )\n{\n    // repeat domain 5x\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292); // pi/5\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    \n    // draw triangle\n    const vec2 k3 = vec2(0.951056516295,  0.309016994375); // pi/10\n    return dot( vec2(abs(p.x)-0.3,p.y), k3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coords\n    float px = 2.0/iResolution.y;\n\tvec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // rotate\n    q = mat2(cos(iTime*0.2),sin(iTime*0.2),-sin(iTime*0.2),cos(iTime*0.2)) * q;\n\n\t// star shape    \n\tfloat d = sdfStar5( q );       \n\n    // colorize\n    vec3 col = vec3(0.4,0.7,0.4) - sign(d)*vec3(0.2,0.1,0.0);\n\tcol *= smoothstep(0.005,0.005+2.0*px,abs(d));\n  //col *= smoothstep(0.04,0.04+2.0*px,abs(d+0.1));\n\tcol *= 1.1-0.2*length(q);\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsccR8.jpg", "access": "shaders20k", "license": "mit", "functions": [[1078, 1078, 1107, 1131, 1469], [1471, 1471, 1528, 1542, 2022]], "test": "valid"}
{"id": "lsccz2", "name": "Parabolas ", "author": "cailuming", "description": "parabolas graph,but it seems that there are still some problems which I can not deal with in 3d , what I want is smooth axis and formula graph...", "tags": ["3d"], "likes": 2, "viewed": 122, "published": "Public", "date": "1519558920", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AXIS_WIDTH 1.\n#define BIAS 1e-15\nstruct Ray {\n   vec3 o;\n   vec3 d;\n};\n    \nmat2 rot2D(float theta){\n    float s =sin(theta);\n    float c =cos(theta);\n    \n    return mat2(\n      c,-s,\n      s ,c\n    );\n}\n// the general parabolas formula    \nvoid parabolas(vec3 p,vec3 ct,inout vec3 col){\n    \n    p-=ct;\n   \n    float a =1.0;\n    float b =6.0;\n    float c =2.0;\n    // used to drive the dot\n    float d = 6.*sin(iTime*0.5);\n    \n    float fx = a*p.x*p.x+b*p.x+c;\n    float fx1 = a*d*d+b*d+c;\n    \n    vec3 formula = vec3(p.x,fx,0);\n    vec3 formula1 = vec3(d,fx1,0);\n    \n    float v = length(p-formula);\n    \n    v=0.6/(v);\n    \n    v = pow(v,6.0);\n    \n    col+=vec3(v,v,v*0.1)*1./64.;\n    \n    // draw the trace dot\n    \n    float v1 = length(p-formula1);\n    \n    v1=1./(v1);\n    \n    v1 = pow(v1,4.0);\n    \n    col+= vec3(v1,v1*0.1,v1)*1./64.;\n}\n \n\nvoid Axis (inout vec3 col,vec3 uv){\n    \n    vec3 ax = vec3(uv.x,0,0);\n    vec3 ay = vec3(0,uv.y,0);\n    vec3 az = vec3(0,0,uv.z);\n    \n    float vx = AXIS_WIDTH/length(uv-ax);\n    float vy = AXIS_WIDTH/length(uv-ay);\n    float vz = AXIS_WIDTH/length(uv-az);\n    \n    \n    vx=pow(vx,2.6);\n    vy=pow(vy,2.6);\n    vz=pow(vz,2.6);\n    \n    col+= vec3(vx*0.2,vx*0.2,vx)*1./64.0;   \n    col+= vec3(vy,vy*0.3,vy*0.2)*1./64.0;\n    col+= vec3(vz*0.3,vz,vz*0.2)*1./64.0;\n}\n\n\nvoid drawGraph(inout vec3 col,Ray r){\n    vec3 p =vec3(0);\n    for(float i=0.0;i<32.;i+=0.4){\n        p=r.o+r.d*i;\n       \n        Axis (col,p);\n        parabolas(p,vec3(0,0,0),col);\n    }\n    \n}\n    \nvoid setCamera(inout Ray r,vec3 eye,vec3 dir,vec2 uv){\n    vec3 look = normalize(dir-eye);\n    vec3 right = normalize(cross(vec3(0,1,0),look));\n    vec3 up = normalize(cross(look,right));\n    \n    r.o = eye;\n    r.d =normalize(uv.x*right+uv.y*up+look);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    vec2 ms = iMouse.xy/iResolution.xy - vec2(0.5);\n    float as = iResolution.x/iResolution.y;\n \n    uv.x*=as;\n    ms.x*=as;\n    if(length(iMouse.zw)>0.){\n       uv-= ms;\n    }\n    \n    Ray ray;\n    vec3 eye = vec3(16.0*cos(iTime),2,16.0*sin(iTime));\n    vec3 dir = vec3(0,0,0);\n    vec3 lp = vec3(10.0*cos(iTime),10,10.0*sin(iTime));\n    vec3 col =vec3(0.0,0.0,0.0);\n    \n   \n    setCamera(ray,eye,dir,uv);\n   \n    drawGraph(col,ray);\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsccz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 108, 108, 212], [213, 250, 296, 296, 859], [863, 863, 898, 898, 1327], [1330, 1330, 1367, 1367, 1525], [1531, 1531, 1585, 1585, 1785], [1787, 1787, 1844, 1894, 2444]], "test": "valid"}
{"id": "lscyD7", "name": "Cheap 5D Wave Noise", "author": "afl_ext", "description": "Very cheap, very high quality, very like life appearance,  can be easily modded into lower and higher dimensions. Best use is water height (can be seen in my other shaders).", "tags": ["noise", "wave", "5d"], "likes": 58, "viewed": 1701, "published": "Public API", "date": "1519145359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n5D wave noise\nafl_ext 2018\npublic domain\n*/\n\nfloat hash(float p){\n    return fract(4768.1232345456 * sin(p));\n}\n\n#define EULER 2.7182818284590452353602874\nfloat wave(vec4 uv, vec4 emitter, float speed, float phase, float timeshift){\n    float dst = distance(uv, emitter);\n    return pow(EULER, sin(dst * phase - timeshift * speed)) / EULER;\n}\nvec4 wavedrag(vec4 uv, vec4 emitter){\n    return normalize(uv - emitter);\n}\nfloat seedWaves = 0.0;\nvec4 randWaves(){\n    float x = hash(seedWaves);\n    seedWaves += 1.0;\n    float y = hash(seedWaves);\n    seedWaves += 1.0;\n    float z = hash(seedWaves);\n    seedWaves += 1.0;\n    float w = hash(seedWaves);\n    seedWaves += 1.0;\n    return vec4(x,y,z,w) * 2.0 - 1.0;\n}\n\nfloat getwaves5d(vec4 position, float dragmult, float timeshift){\n    float iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<20;i++){\n        vec4 p = randWaves() * 30.0;\n        float res = wave(position, p, speed, phase, 0.0 + timeshift);\n        float res2 = wave(position, p, speed, phase, 0.006 + timeshift);\n        position -= wavedrag(position, p) * (res - res2) * weight * dragmult;\n        w += res * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.2;\n        speed *= 1.02;\n    }\n    return w / ws;\n}\n\n// helper function\n\nvec3 polarToXyz(vec2 xy){\n    xy *= vec2(2.0 *3.1415,  3.1415);\n    float z = cos(xy.y);\n    float x = cos(xy.x)*sin(xy.y);\n    float y= sin(xy.x)*sin(xy.y);\n    return normalize(vec3(x,y,z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 col = vec3(1.0) * getwaves5d(vec4(polarToXyz(uv), (mouse.x * 2.0 - 1.0) * 10.0), 10.0 + mouse.y * 10.0, iTime);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscyD7.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[49, 49, 69, 69, 115], [159, 159, 236, 236, 346], [347, 347, 384, 384, 422], [446, 446, 463, 463, 715], [717, 717, 782, 782, 1381], [1403, 1403, 1428, 1428, 1597], [1599, 1599, 1656, 1656, 1917]], "test": "valid"}
{"id": "lscyzl", "name": "Worley Noise 2D", "author": "Aethersong", "description": "Worley Noise", "tags": ["noise", "worley"], "likes": 2, "viewed": 200, "published": "Public", "date": "1519798664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// References\n// Worley Noise 2x2 Stefan Gustavson\n// https://thebookofshaders.com/12/\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 Permute( vec4 x )\n{\n return mod( ( 34.0 * x + 1.0 ) * x, 289.0 );   \n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 Cellular2x2( vec2 P )\n{\n\t#define K 0.142857142857 // 1/7\n\t#define K2 0.0714285714285 // K/2\n\t#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n    \n\tvec2 Pi = mod( floor( P ), 289.0);\n \tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4( -0.5, -1.5, -0.5, -1.5 );\n\tvec4 Pfy = Pf.y + vec4( -0.5, -0.5, -1.5, -1.5 );\n\tvec4 p = Permute( Pi.x + vec4(0.0, 1.0, 0.0, 1.0 ) );\n\tp = Permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\n    \n\tvec4 ox = mod(p, 7.0)*K+K2;\n\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\tvec4 dx = Pfx + jitter*ox;\n\tvec4 dy = Pfy + jitter*oy;\n\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n    \n\t// Sort out the two smallest distances\n#if 0\n\t// Cheat and pick only F1\n\td.xy = min(d.xy, d.zw);\n\td.x = min(d.x, d.y);\n\treturn d.xx; // F1 duplicated, F2 not computed\n#else\n\t// Do it right and find both F1 and F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx;\n\td.y = min(d.y, d.z);\n\td.y = min(d.y, d.w);\n\treturn sqrt(d.xy);\n#endif\n}\n\nfloat r(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*23.62-300.0+n.y*34.35),r(n.x*45.13+256.0+n.y*38.89)); \n}\n\nfloat Worley2(vec2 n,float s)\n{\n    n /= s;\n    float dis = 1.0;\n    for(int x = -1;x<=1;x++)\n    {\n        for(int y = -1;y<=1;y++)\n        {\n            vec2 p = floor(n)+vec2(x,y);\n            p = r(p)+vec2(x,y)-fract(n);\n            dis = min(dis, dot(p, p));\n            \n        }\n    }\n    return 1.0 - sqrt(dis);\n\t\n}\n\nfloat Worley(vec2 uv)\n{\n    // User Noise Adjust\n    return 1.0 - Cellular2x2(uv).x;\n    //return smoothstep(1.0, 0.0, Cellular2x2(uv).x);\n}\n\nfloat WorleyFBM(vec2 uv)\n{\n\tfloat amplitude = 0.5;\n    float gain = 0.5;\n    float lacunarity = 2.0;\n    \n    float value = 0.0;\n    \n    const int STEPS = 4;\n    for(int i = 0; i < STEPS; i++)\n    {\n     \tvalue += Worley2(uv, 2.0) * amplitude;\n        amplitude *= gain;\n        uv *= lacunarity;\n    }\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Calculate Noise\n    float tileCount = 16.0;\n    float n = WorleyFBM(uv * vec2(aspectRatio, 1.0) * tileCount + vec2(iTime, 0.0));  \n    \n    // Output to screen\n    fragColor = vec4(n, n, n, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 135, 159, 159, 210], [212, 536, 564, 564, 1573], [1575, 1575, 1593, 1593, 1632], [1633, 1633, 1649, 1649, 1726], [1728, 1728, 1759, 1759, 2052], [2054, 2054, 2077, 2102, 2194], [2196, 2196, 2222, 2222, 2524], [2526, 2526, 2583, 2633, 2936]], "test": "valid"}
{"id": "lsdcD7", "name": "Hexpo", "author": "dr2", "description": "Colorful pavilions (mouseable)", "tags": ["lighting", "hexagon", "architecture"], "likes": 17, "viewed": 3575, "published": "Public API", "date": "1519220821", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Hexpo\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HueToRgb (float c);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HexGrid (vec2 p);\n\nvec3 sunDir, qHit;\nvec2 gId;\nfloat tCur, dstFar, gcRnd, hgSize;\nint idObj;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, w, s, r, rh, a, s3;\n  dMin = dstFar;\n  s3 = 0.5 * sqrt3 * hgSize;\n  rh = 3.07;\n  w = 0.1;\n  p.xz -= HexToPix (gId * hgSize);\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (6. * a + 0.5)) / 6.));\n  qq = q;\n  s = 1. - sqrt (1. - smoothstep (0.65, 0.85, q.y));\n  d = max (max (abs (q.x + 3.) - 0.07, abs (q.y - 0.5) - 0.5),\n     - PrBox2Df (vec2 (mod (q.z, 0.25) - 0.125, q.y - 0.41), vec2 (0.08 - 0.08 * s, 0.45)));\n  s = smoothstep (1., 2.2, q.y);\n  d = min (d, max (max (mix (abs (q.x + 0.5 * rh) - 0.5 * rh, r - 2. - w, s),\n     - mix (abs (q.x + 0.5 * rh - w) - 0.5 * rh + w, r - 2. + w, s)), abs (q.y - 1.6) - 0.6));\n  d = min (d, max (abs (r - 2.) - w, abs (q.y - 2.25) - 0.05));\n  s = smoothstep (2.3, rh, q.y);\n  d = min (d, max (max (mix (r - 2. - w, r - 1.4 - w, s), - mix (r - 2. + w, r - 1.4 + w, s)), abs (q.y - 2.6) - 0.3));\n  DMINQ (1);\n  q.xy -= vec2 (- s3 + 0.06, 0.06);\n  d = length (q.xy) - 0.05;\n  DMINQ (2);\n  q.y -= 1.15 - 0.2 * q.x * q.x;\n  d = PrCylDf (vec3 (q.xy, abs (q.z) - 0.04).yzx, 0.03, s3 - rh);\n  DMINQ (3);\n  q = qq;  q.xy -= vec2 (- s3, 1.21);\n  d = PrCylDf (q.xzy, 0.1, 0.04);\n  q = qq;  q.z = abs (q.z);  q -= vec3 (- s3, 0.07, 0.5 * hgSize);\n  d = min (d, PrCylDf (q.xzy, 0.15, 0.07));\n  DMINQ (4);\n  q = qq;  q.y -= 2.2;\n  d = PrCylDf (q.xzy, 0.3, 2.2);\n  DMINQ (5);\n  q = qq;  q.xy -= vec2 (-0.6, 1.8);\n  d = PrCylDf (q.xzy, 0.25, 1.8);\n  DMINQ (6);\n  return 0.6 * dMin;\n}\n\nvoid SetGrdConf ()\n{\n  gcRnd = Hashfv2 (17.3 * gId);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = min (hv.x, min (hv.y, hv.z));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = 0; j < 320; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + 0.001;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = min (hv.x, min (hv.y, hv.z));\n    }\n    if (d < 0.0005 || dHit > dstFar || p.y < 0. || p.y > 5.) break;\n  }\n  if (d >= 0.0005) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec2 TrackPath (float t)\n{\n  vec2 r;\n  float tt;\n  tt = mod (t, 4.);\n  if (tt < 1.) r = mix (vec2 (sqrt3 * 0.5, -0.5), vec2 (sqrt3 * 0.5, 0.5), tt);\n  else if (tt < 2.) r = mix (vec2 (sqrt3 * 0.5, 0.5), vec2 (0., 1.), tt - 1.);\n  else if (tt < 3.) r = mix (vec2 (0., 1.), vec2 (0., 2.), tt - 2.);\n  else r = mix (vec2 (0., 2.), vec2 (sqrt3 * 0.5, 2.5), tt - 3.);\n  r *= hgSize;\n  r += vec2 (0.001, hgSize * 3. * floor (t / 4.));\n  return r;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return 0.2 * mix (vec3 (0.2, 0.3, 0.5) + 0.3 * pow (max (dot (rd, sunDir), 0.), 8.), vec3 (1.),\n     0.2 + 0.8 * rd.y * Fbm2 (2. * rd.xz / max (rd.y, 0.0001)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, gCol, vn, qc, qh;\n  vec2 vf;\n  float dstObj, dstGrnd, spec, f, s;\n  bool isLit;\n  dstGrnd = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  dstObj = ObjRay (ro, rd);\n  isLit = true;\n  if (min (dstObj, dstGrnd) < dstFar) {\n    vf = vec2 (0.);\n    ro += min (dstObj, dstGrnd) * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    SetGrdConf ();\n    gCol = HueToRgb (mod (77.7 * gcRnd, 1.));\n    spec = 0.1;\n    if (dstObj < dstGrnd) {\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        qc = ro - vec3 (hgSize * HexToPix (gId).xy, 0.).xzy;\n        f = dot (vn, normalize (qc));\n        col = gCol;\n        vf = vec2 (1024., 0.5);\n        if (f < 0. || ro.y < 1. && f < 0.6) {\n          col = 0.8 * mix (vec3 (1.), col, 0.5) * (0.55 - 0.45 * f) * (0.7 +\n             0.3 * SmoothBump (0.25, 0.75, 0.1, mod (tCur + gcRnd, 1.)));\n          isLit = false;\n        } else {\n          col = 0.2 * mix (vec3 (1.), col, 0.2) * (0.2 + 0.8 * f);\n          s = atan (qc.z, - qc.x) / (2. * pi);\n          if (ro.y < 2.6) {\n            s = SmoothBump (1., 2.5, 0.1, ro.y) * SmoothBump (0.4, 0.6, 0.02, mod (128. * s, 1.)) *\n               SmoothBump (0.4, 0.6, 0.02, mod (8. * qc.y - 2. * tCur, 1.));\n            col *= 1. + 5. * s;\n          } else {\n            s = smoothstep (2.6, 2.85, ro.y) * SmoothBump (0.4, 0.6, 0.05, mod (32. * s +\n               2. * (2. * step (gcRnd, 0.5) - 1.) * tCur, 1.));\n            col *= 1. + 4. * s;\n          }\n          isLit = (s > 0.1);\n        }\n      } else if (idObj == 2) {\n        col = 0.8 * gCol * (0.4 + 0.6 * SmoothBump (0.25, 0.75, 0.05, mod (2. * qHit.z + tCur, 1.)));\n      } else if (idObj == 3) {\n        col = 0.8 * HueToRgb (mod (0.1 * tCur, 1.)) * (0.4 +\n           0.6 * SmoothBump (0.25, 0.75, 0.05, mod (4. * qHit.x + 2. * tCur * sign (qHit.z), 1.)));\n      } else if (idObj == 4) {\n        col = vec3 (0.7, 0.7, 0.2) * (0.3 + 0.7 * smoothstep (0., 0.4, - dot (vn, rd)));\n        isLit = false;\n      } else if (idObj == 5 || idObj == 6) {\n        col = 0.8 * ((idObj == 5) ? gCol : HueToRgb (mod (mod (77.7 * gcRnd, 1.) + 0.5, 1.)));\n        if (vn.y < 0.99) col *= (0.4 + 0.6 * SmoothBump (0.25, 0.75, 0.05, mod (8. * qHit.y +\n           atan (vn.z, vn.x) / (2. * pi) + ((idObj == 5) ? - 4. : 4.) * tCur, 1.)));\n        else col *= 0.5;\n      }\n    } else {\n      qh = HexGrid (32. * sqrt3 * ro.zx / hgSize);\n      f = max (length (qh.xy) - 0.5, 0.);\n      vn = vec3 (0., Rot2D (vec2 (1., 0.), 4. * f * f));\n      vn.zx = vn.z * normalize (qh.xy);\n      s = HexGrid (ro.xz / hgSize).z;\n      col = 0.3 * mix (vec3 (1.), gCol, 0.2) * (0.8 + 0.2 * smoothstep (0.025, 0.03, s)) *\n         (0.8 + 0.2 * smoothstep (0.03, 0.06, qh.z));\n      col = mix (col, 0.5 * gCol * (0.7 + 0.3 * SmoothBump (0.25, 0.75, 0.1, mod (tCur + gcRnd, 1.))),\n         smoothstep (0.1, 0.35, s));\n    }\n    if (isLit) {\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      col = col * (0.5 + 0.5 * max (dot (vn, sunDir), 0.)) +\n         spec * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    }\n    s = min (dstObj, dstGrnd) / dstFar;\n    col = mix (col * (1. - 0.95 * smoothstep (0.3, 1., s)), SkyCol (rd), smoothstep (0.4, 1., s));\n  } else {\n    col = SkyCol (rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa, vd, p1, p2;\n  float el, az, zmFac, asp, vel, tCyc, tt, s;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  hgSize = 5.;\n  vel = 0.3;\n  tCyc = 4. / vel;\n  tCur = mod (tCur, 36000.) + floor (2. + floor (dateCur.w / 600.) / tCyc + 1.) * tCyc;\n  p1 = TrackPath (vel * tCur + 0.3);\n  p2 = TrackPath (vel * tCur - 0.3);\n  s = SmoothBump (0.25, 0.75, 0.02, mod (tCur / (4. * tCyc), 1.));\n  ro = vec3 (0.5 * (p1 + p2), 0.7 + 3.3 * s).xzy;\n  vd = p1 - p2;\n  az = atan (vd.x, vd.y);\n  el = -0.1 * pi * s;\n  zmFac = 1.5 + s;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  asp = canvas.x / canvas.y;\n  dstFar = 300.;\n  uv.xy /= zmFac;\n  rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uv.x / asp)) * asp, uv.y, 1.));\n  sunDir = normalize (vec3 (0.5, 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p = p - HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nvec3 HueToRgb (float c)\n{\n  return clamp (abs (fract (c + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdcD7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[693, 693, 715, 715, 2234], [2236, 2236, 2256, 2256, 2290], [2292, 2292, 2325, 2325, 3654], [3656, 3656, 3677, 3677, 3877], [3879, 3879, 3905, 3905, 4321], [4323, 4323, 4346, 4346, 4532], [4534, 4534, 4569, 4569, 7816], [7818, 7818, 7874, 7874, 9119], [9121, 9121, 9154, 9154, 9243], [9245, 9245, 9287, 9287, 9338], [9340, 9340, 9385, 9385, 9488], [9490, 9490, 9547, 9547, 9630], [9632, 9632, 9662, 9662, 9736], [9738, 9738, 9762, 9762, 9992], [9994, 9994, 10018, 10018, 10078], [10080, 10080, 10103, 10103, 10239], [10241, 10241, 10266, 10266, 10351], [10385, 10385, 10409, 10409, 10469], [10471, 10471, 10495, 10495, 10625], [10627, 10627, 10652, 10652, 10838], [10840, 10840, 10861, 10861, 11016], [11018, 11018, 11047, 11047, 11259], [11261, 11261, 11300, 11300, 11480]], "test": "error"}
{"id": "lsdcR2", "name": "cos fractal", "author": "wyatt", "description": "imaginary fractal", "tags": ["fractal", "complex"], "likes": 7, "viewed": 187, "published": "Public", "date": "1519613982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 expo (vec2 v) {\n\treturn exp(v.x)*vec2(sin(v.y),cos(v.y));\n}\nvec2 coso (vec2 v) {\n\treturn vec2 (cos(v.x)*cosh(v.y),-sin(v.x)*sinh(v.y));\n}\nvec2 sino (vec2 v) {\n\treturn vec2 (cos(v.x)*sinh(v.y),sin(v.x)*cosh(v.y));\n}\nvec2 cosho (vec2 v) {\n\treturn vec2(cosh(v.x)*cos(v.y), sinh(v.x)*sin(v.y));\n}\nvec2 sinho (vec2 v) {\n\treturn vec2(sinh(v.x)*cos(v.y), sinh(v.x)*cos(v.y));\n}\nvec2 mul (vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(.6+sin(0.1*iTime)*sin(0.1*iTime))*(fragCoord/iResolution.xy*2.-1.);\n\tuv.x*=iResolution.x/iResolution.y;\n    float b = 0.;\n    float t = 0.5*iTime;\n    mat2 m = mat2 (sin(t),cos(t),-cos(t),sin(t));\n    vec2 v;\n    uv = uv/dot(uv,uv);\n    for (int x = -1; x < 2; x++)\n        for (int y = -1; y < 2; y++) {\n        v = uv+vec2(x,y)/iResolution.xy;\n        for (int i = 0; i < 10; i++ ) {\n            v = sino(mul(coso(v),coso(v)));\n            v = m*v;\n            if (dot(v,v) > 1e5) {b += 1./9.; break;}\n        }\n        }\n    fragColor = vec4(dot(v,v),b,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdcR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 64], [65, 65, 85, 85, 142], [143, 143, 163, 163, 219], [220, 220, 241, 241, 297], [298, 298, 319, 319, 375], [376, 376, 403, 403, 452], [453, 453, 510, 560, 1144]], "test": "valid"}
{"id": "lsdcW7", "name": "Menger spline tour", "author": "utak3r", "description": "Really nice layered variation of a Menger Sponge, designed by Shane, flying through a Catmull-Rom spline.\nFor more info, read the description in the code itself.", "tags": ["procedural", "3d", "raymarching", "fractal"], "likes": 13, "viewed": 370, "published": "Public", "date": "1519205175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*!\n * <info>\n *\n * Menger Sponge Tour - flight along the Catmull-Rom spline\n * \n * This really nice layered variation of a Menger Sponge\n * was designed by Shane: https://www.shadertoy.com/view/ldyGWm\n * \n * Also the lighting is from him. It's unusual, but... that's why I like it :)\n * So I only tweaked it a bit and parameterized it, as I'm usually working \n * in Synthclipse. The most tweaks went to shadowing, as it was giving some bad \n * artifatcs, like circles.\n *\n * The flight is done using an 8-points path. This path is looped, and calculated\n * using Catmull-Rom spline.\n * There's a problem with some segments combinations, though. It can result in a jump -\n * and maybe even in a completely black frame :/ if you can see, what's wrong, please note me.\n * \n * If you want, you can watch the high quality render with some music here:\n * https://youtu.be/Wcl7td4yXfA\n *\n * </info>\n */\n\n\n// Flight speed. Total duration will be 8*flightSpeed.\nconst float flightSpeed = 0.125; //! slider[0.1, 0.25, 2]\n// Field of view\nconst float FOV = 2.; //! slider[0.5, 2, 4]\n// Gamma correction\nconst float Gamma = .75; //! slider[0.1, 0.8, 3.0]\n// Darker parts of panels texturing\nconst vec3 darkColor = vec3(.329,.078,.5); //! color[.4, .2, .1]\n// Fog distance\nconst float fogDistance = 24.; //! slider[10, 24, 100]\n// Fog color\nconst vec3 fogColor = vec3(1.,0.,.12); //! color[1, 0, 0.12]\n// Light position\nconst float lightDistance = -.15; //! slider[-2, -.15, 2]\n// AO iterations\nconst int aoIterations = 5; //! slider[1, 5, 10]\n// Shadow light\nconst float shadowLight = .45; //! slider[0, 0.5, 1]\n\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max(n*n, 0.001); // n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );\n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Smooth minimum function. There are countless articles, but IQ explains it best here:\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat sminP( float a, float b, float smoothing ){\n\n    float h = clamp( 0.5+0.5*(b-a)/smoothing, 0.0, 1.0 );\n    return mix( b, a, h ) - smoothing*h*(1.0-h);\n}\n\n// This layered Menger sponge is stolen from Shane\n// https://www.shadertoy.com/view/ldyGWm\n// Just modified it a bit, but its main construction is his idea - and I love it :)\nfloat map(vec3 q)\n{\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .04;\n\n    p =  abs(fract(q) - .5);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\n\n    p =  abs(fract(q*2.)*.5 - .25);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015);\n\n    p =  abs(fract(q*3./.5)*.5/3. - .5/6.);\n\n    return max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./27. - .015);\n}\n\n// Raymarching\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for(int i=0; i< 48; i++){\n        d = map(ro + rd*t);\n        if (d <.0025*t || t>fogDistance) break;\n        t += d;\n    }\n    return t;\n}\n\n// Reflections\nfloat refTrace(vec3 ro, vec3 rd)\n{\n    float t = 0., d;\n    for(int i=0; i< 16; i++){\n        d = map(ro + rd*t);\n        if (d <.0025*t || t>fogDistance) break;\n        t += d;\n    }\n    return t;\n}\n\n// Tetrahedral normal (from IQ)\nvec3 normal(in vec3 p)\n{\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.003, -0.003);\n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO(in vec3 p, in vec3 n)\n{\n\tfloat ao = 0.0, l;\n\tconst float falloff = 1.;\n\n    const float maxDist = 1.;\n    for(float i=1.; i<float(aoIterations)+.5; i++){\n\n        l = (i + hash(i))*.5/float(aoIterations)*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\n    return clamp( 1.-ao/float(aoIterations), 0., 1.);\n}\n\n// Soft shadows.\n// Its params are very sensitive and can cause\n// some really bad artifacts.\nfloat softShadow(vec3 ro, vec3 lp, float k)\n{\n    const int maxIterationsShad = 32;\n\n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.002;\n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n\n    rd /= end;\n\n    for (int i=0; i < maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        dist += clamp(h, 0.0001, 0.2);\n\n        // Early exit\n        if (h < 0.00001 || dist > end) break;\n    }\n\n    // Light the shadows up\n    return min(max(shade, 0.) + shadowLight, 1.0);\n}\n\nvec3 camPathTable[8];\nvoid setCamPath()\n{\n    const float mainCorridor = 2.82*2.;\n\n    // right now it's only through the main corridors.\n    // it'd be nice to enter also the smaller ones, too :)\n    camPathTable[0] = vec3(0, 0, 0);\n    camPathTable[1] = vec3(0, 0, mainCorridor);\n    camPathTable[2] = vec3(0, -mainCorridor, mainCorridor);\n    camPathTable[3] = vec3(mainCorridor, -mainCorridor, mainCorridor);\n    camPathTable[4] = vec3(mainCorridor, -mainCorridor, 0);\n    camPathTable[5] = vec3(0, -mainCorridor, 0);\n    camPathTable[6] = vec3(-mainCorridor, -mainCorridor, 0);\n    camPathTable[7] = vec3(-mainCorridor, 0, 0);\n}\n\n/*\n * http://graphics.cs.ucdavis.edu/education/CAGDNotes/Catmull-Rom-Spline/Catmull-Rom-Spline.html\n * f(x) = [1, t, t^2, t^3] * M * [P[i-1], P[i], P[i+1], P[i+2]]\n */\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t)\n{\n\tvec3 c1,c2,c3,c4;\n\n\tc1 = p1;\n\tc2 = -0.5*p0 + 0.5*p2;\n\tc3 = p0 + -2.5*p1 + 2.0*p2 + -0.5*p3;\n\tc4 = -0.5*p0 + 1.5*p1 + -1.5*p2 + 0.5*p3;\n\n\treturn (((c4*t + c3)*t + c2)*t + c1);\n}\n\nvec3 camPath(float t)\n{\n\t// Capacity of path points table\n\tconst int aNum = 8;\n\n\t// Loop to aNum\n    t = fract(t/float(aNum))*float(aNum);\n\n    // Segment number\n    int segNum = int(floor(t));\n    // Segment portion [0..1]\n    float segTime = t - float(segNum);\n\n    // Catmull-Rom spline needs surrounding control points,\n    // so we're looping the path, making every point has enough neighbours.\n    if (segNum == 0) return catmullRomSpline(camPathTable[aNum-1], camPathTable[0], camPathTable[1], camPathTable[2], segTime);\n    if (segNum == aNum-2) return catmullRomSpline(camPathTable[aNum-3], camPathTable[aNum-2], camPathTable[aNum-1], camPathTable[0], segTime);\n    if (segNum == aNum-1) return catmullRomSpline(camPathTable[aNum-2], camPathTable[aNum-1], camPathTable[0], camPathTable[1], segTime);\n\n   \treturn catmullRomSpline(camPathTable[int(segNum)-1], camPathTable[int(segNum)], camPathTable[int(segNum)+1], camPathTable[int(segNum)+2], segTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\tfloat speed = iTime * flightSpeed;\n\tsetCamPath();\n\n    vec3 ro = camPath(speed); // Camera position\n    vec3 lk = camPath(speed + .5);  // Look At\n    vec3 lp = camPath(speed + lightDistance); // Light position.\n\n    // Camera vectors\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n\n    vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n\n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n\n    float t = trace(ro, rd);\n\n    // Lighting is completely taken from Shane.\n    if (t < fogDistance)\n    {\n        vec3 sp = ro + rd*t; // Surface position.\n        vec3 sn = normal(sp); // Surface normal.\n        vec3 ref = reflect(rd, sn); // Reflected ray.\n\n\t\tconst float ts = 2.; // Texture scale.\n        vec3 oCol = tex3D(iChannel0, sp*ts, sn); // Texture color at the surface point.\n\n\n        // Darker toned paneling.\n        vec3 q = abs(mod(sp, 3.) - 1.5);\n        if (max(max(q.x, q.y), q.z) < 1.063) oCol = oCol*darkColor;\n\n        // Bringing out the texture colors a bit.\n        oCol = smoothstep(0.0, 1.0, oCol);\n\n        float sh = softShadow(sp, lp, 16.); // Soft shadows.\n        float ao = calculateAO(sp, sn); // Self shadows.\n\n        vec3 ld = lp - sp; // Light direction.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light direction vector.\n\n        float diff = max(dot(ld, sn), 0.); // Diffuse component.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 12.); // Specular.\n        //float fres = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n\n        float atten = 1.0 / (1.0 + lDist*0.25 + lDist*lDist*.1); // Attenuation.\n\n\n        // Secondary camera light, just to light up the dark areas a bit more. It's here just\n        // to add a bit of ambience, and its effects are subtle, so its attenuation\n        // will be rolled into the attenuation above.\n        diff += max(dot(-rd, sn), 0.)*.45;\n        spec += pow(max(dot(reflect(rd, sn), -rd), 0.), 12.)*.45;\n\n        // Based on Eiffie's suggestion. It's an improvement, but I've commented out,\n        // for the time being.\n        //spec *= curve(sp);\n\n\n\t\t// REFLECTION BLOCK.\n        //\n        // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much\n        // effort is being put in.\n        float rt = refTrace(sp + ref*0.1, ref); // Raymarch from \"sp\" in the reflected direction.\n        vec3 rsp = sp + ref*rt; // Reflected surface hit point.\n        vec3 rsn = normal(rsp); // Normal at the reflected surface.\n\n        vec3 rCol = tex3D(iChannel0, rsp*ts, rsn); // Texel at \"rsp.\"\n        q = abs(mod(rsp, 3.) - 1.5);\n        if (max(max(q.x, q.y), q.z)<1.063) rCol = rCol*vec3(.7, .85, 1.);\n        // Toning down the power of the reflected color, simply because I liked the way it looked more.\n        rCol = sqrt(rCol);\n        float rDiff = max(dot(rsn, normalize(lp-rsp)), 0.); // Diffuse at \"rsp\" from the main light.\n        rDiff += max(dot(rsn, normalize(-rd-rsp)), 0.)*.45; // Diffuse at \"rsp\" from the camera light.\n\n        float rlDist = length(lp - rsp);\n        float rAtten = 1./(1.0 + rlDist*0.25 + rlDist*rlDist*.1);\n        rCol = min(rCol, 1.)*(rDiff + vec3(.5, .6, .7))*rAtten; // Reflected color. Not accurate, but close enough.\n        //\n    \t// END REFLECTION BLOCK.\n\n\n        // Combining the elements above to light and color the scene.\n        col = oCol*(diff + vec3(.5, .6, .7)) + vec3(.5, .7, 1)*spec*2. + rCol*0.25;\n\n\n        // Shading the scene color, clamping, and we're done.\n        col = min(col*atten*sh*ao, 1.);\n\n    }\n\n    // Fadeout to a fog\n    col = mix(col, fogColor, smoothstep(0., fogDistance - 15., t));\n\n    // Last corrections\n\tcol = pow(clamp(col, 0.0, 1.0), vec3(1.0 / Gamma));\n    fragColor = vec4(col, 1.0);\n\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdcW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1603, 1603, 1625, 1625, 1660], [1663, 1817, 1868, 1868, 2082], [2084, 2224, 2273, 2273, 2383], [2385, 2561, 2580, 2580, 3068], [3070, 3085, 3115, 3115, 3281], [3283, 3298, 3332, 3332, 3497], [3499, 3531, 3555, 3663, 3820], [3822, 4054, 4095, 4095, 4405], [4407, 4501, 4546, 4546, 5188], [5212, 5212, 5231, 5231, 5823], [5825, 5993, 6061, 6061, 6239], [6241, 6241, 6264, 6298, 7204], [7206, 7206, 7263, 7263, 11201]], "test": "error"}
{"id": "lsdczH", "name": "tentacles_tunnel", "author": "balkhan", "description": "tunnel", "tags": ["tunnel"], "likes": 1, "viewed": 113, "published": "Public", "date": "1517972197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define I_MAX\t\t100\n#define E\t\t\t0.001\n\nvec4\tmarch(vec3 pos, vec3 dir, inout vec3 b);\nvec3\tcamera(vec2 uv);\nvec3\tcolor_func(vec3 pos, vec3 dir);\nvoid\trotate(inout vec2 v, float angle);\nvec2\trot(vec2 p, vec2 ang);\nfloat\tmylength(vec3 p);\nfloat\tmylength(vec2 p);\nfloat\tmylength(float p);\nfloat \tt;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t = iTime+10.;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tuv  = vec2(f.x/iResolution.x, f.y/iResolution.y);\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 20.0);\n\n\tvec3\tb = vec3(.85, .3, .3);\n\n    pos.z -= t*20.;\n\n    vec4\tinter = (march(pos, dir, b));\n\n\tvec3\tbase = vec3(.8, .0, 1.);\n\tvec3\tp = inter.w*dir + pos;\n    col.xyz = \n        -vec3(.0,.0,.5)*(sin(3.14+p.z*1.*(inter.w>100.?0.:1.) ))\n        +\n        200.*(1./((length(p.xy+sin(p.z*2.)*.25)-4.5)*(length(p.xy+sin(p.z*2.)*.25)-4.5)) )\n        -\n        5.*(vec3(.17, .3,.6)*(1.-inter.x*.01+inter.w*.005*(inter.x/float(I_MAX) )));\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tde(vec3 p, inout vec3 b)\n{\n\tfloat\tmind = 1e5;\n    rotate(p.xy, t*.1*0.+p.z*.01251*1.+( cos(t*1.+floor(p.z*1.)*.125 )*.25+1.*sin(t+p.z*.1)/*+(p.z)*/ ));\n    mind = min(mind, mylength(abs(sin((p.z/max(.00001, max(abs(p.x), abs(p.y) )))*.125 )))+1.5);\n    mind = min(mind, length(abs(p.xy)-vec2(15.) )+3. );\n    \n\treturn (mind);\n}\n\nfloat\tde_4(vec3 p)\n{\n\tfloat\tmind = 1e5;\n\tvec3\tpr = p;\n\n\tvec2\tq;\n\tq = vec2(length(pr.yx) - 4., pr.z );\n    q.y = rot(q.xy, vec2(-1., 0.)).x;\n\t\n\tmind = length(q) - 3.5;\n\n\treturn mind;\n}\n\nfloat\tde_2(vec3 p, inout vec3 b)\n{\n    return (de(p, b)-de_4(p)*.125);\n}\n\nfloat\tscene(vec3 p, inout vec3 b)\n{\n    vec2\trot = vec2( cos(t/2.), sin(t/2.) );//p.z += sin(t*10.)*4.;\n\tfloat\tmind = 1e5;\n\n\tmind = de_2(p, b);\n\t\n    return(mind);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir, inout vec3 b)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tstep = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec3\tdirr;\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n        dirr = dir;\n    \tp = pos + dirr * dist.y;\n        dist.x = scene(p, b);\n        dist.y += dist.x;\n        if (dist.x < E )\n        {\n            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n// Utilities\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-.5) * right + (uv.y-0.5) * up + fov * forw));\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nfloat\tmylength(float p)\n{\n\tfloat\tret = 0.;\n    p = p*p*p*p;\n    ret = p;\n    ret = pow(ret, 1./3.);\n    return (ret);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 0.;\n    p = p*p*p*p;\n    ret = p.x+p.y;\n    ret = pow(ret, 1./4.);\n    return (ret);\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 0.;\n    p = p*p*p*p;\n    ret = p.x+p.y+p.z;\n    ret = pow(ret, 1./4.);\n    return (ret);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdczH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 338, 338, 963], [965, 965, 997, 997, 1298], [1300, 1300, 1320, 1320, 1483], [1485, 1485, 1519, 1519, 1557], [1559, 1559, 1594, 1594, 1724], [1726, 1726, 1772, 1772, 2197], [2213, 2213, 2235, 2235, 2448], [2450, 2450, 2478, 2478, 2586], [2588, 2588, 2628, 2628, 2703], [2705, 2705, 2730, 2730, 2824], [2826, 2826, 2850, 2850, 2950], [2952, 2952, 2976, 2976, 3080]], "test": "error"}
{"id": "lsdyR8", "name": "Paw Metaballs By Yuru Wang", "author": "yuruwang", "description": "finish time: Feb, 6, 2018", "tags": ["metaball"], "likes": 0, "viewed": 67, "published": "Public", "date": "1518141266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.1415;\n    float radius = 120.0;\n    vec2 midP = vec2(iResolution.x/2.0, iResolution.y/2.0);\n    float mid_r = 700.0;\n    float ball_r = 300.0;\n    float freq = 0.6;\n    \n    float influence = 0.0;\n    for (float i = 0.0; i < 8.0; i++) {\n        float phase = i * PI / 4.0;\n        float theta = i * PI / 4.0;\n        float offset = radius * (sin(PI * freq * iTime + phase) * 0.5 + 0.5);\n        float offset_x = offset * cos(theta);\n        float offset_y = offset * sin(theta);\n        vec2 ball = vec2(midP.x + offset_x, midP.y + offset_y);\n        \n        influence = influence + ball_r/(pow((fragCoord.x-ball.x),2.0) + pow((fragCoord.y-ball.y),2.0));\n    }\n    \n    influence = influence + mid_r/(pow((fragCoord.x-midP.x),2.0) + pow((fragCoord.y-midP.y),2.0));\n                  \n    if (influence > 1.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n\n\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdyR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1010]], "test": "valid"}
{"id": "lsdyRj", "name": "bit by bit", "author": "skandix", "description": "bit by bit", "tags": ["bits"], "likes": 1, "viewed": 74, "published": "Public", "date": "1519592428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n    return fract(tan(dot(st,vec2(abs(3.8)/10.,log(iTime))))/1000000.);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv *= 100.0;\n\tuv /= 3.0;\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec2 ipos = floor(uv);\n    float rnd = random(uv);\n    vec3 color = vec3(random (ipos));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdyRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 100], [102, 102, 159, 210, 530]], "test": "valid"}
{"id": "lsdyz4", "name": "discrete exponential curves", "author": "Max1412", "description": "(Slowly) samples discrete exponential curves with changing parameters", "tags": ["procedural", "curves", "animated", "maths"], "likes": 2, "viewed": 95, "published": "Public", "date": "1518104283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC(x) vec2(cos(x), sin(x))\n\nbool calcCurve(in vec2 xy, in float a, in float b, in float c, in float d)\n{\n    float n = iTime / 20.0;\n\tfor(float t = n; t < n + 6.3; t += 0.0045)\n    {\n        vec2 curve = SC(a * t) - SC(b * t) / 2.0 + SC(c * t).yx / 3.0 + SC(d * t) / 4.0;\n        curve /= 6.0;\n        if(abs(length(xy - curve)) < 0.006)\n            return true; // inside\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5* iResolution.xy) /iResolution.y;\n\n    vec3 col = vec3(1.0);\n    \n    float a = sin(iTime / 20.0) * 20.0;\n    float b = cos(iTime / 20.0) * 20.0;\n    float c = sin(iTime / 15.0) * 20.0 - 10.0;\n    float d = cos(iTime / 20.0) * 20.0;\n\n    // Output to screen\n    fragColor = calcCurve(uv, a, b, c, d) ? vec4( 6.*uv, .5, 1) : vec4(1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 112, 112, 406], [408, 408, 465, 515, 880]], "test": "valid"}
{"id": "lstczB", "name": "domain distortion test", "author": "dtoadq", "description": "test", "tags": ["test"], "likes": 2, "viewed": 285, "published": "Public API", "date": "1519459841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define float4 vec4\n#define float3 vec3\n#define float2 vec2\n\nfloat noise ( in float2 uv ) {\n  return (sin(2.5*uv.x) + sin(2.5*uv.y));\n}\n\nfloat fbm ( in float2 uv ) {\n  const mat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n  float f = 0.0;\n  f += 0.5000*noise(uv); uv = m*uv*2.02;\n  f += 0.2500*noise(uv); uv = m*uv*2.03;\n  f += 0.1250*noise(uv); uv = m*uv*2.01;\n  f += 0.0625*noise(uv);\n  return f/0.9375;\n}\n#define TIME iTime*5.0f\n\nfloat pattern ( in float2 uv ) {\n  float2 q = float2(fbm(uv + float2(0.0, TIME*0.1f)),\n                    fbm(uv + float2(4.2, TIME*0.05f)));\n  float2 r = float2(fbm(uv + 4.0*q + float2(1.6, TIME*0.2)),\n                    fbm(uv + 4.0*q + float2(iTime*0.3, TIME)));\n  return fbm(uv+q-r*0.25);\n}\nfloat pattern2 ( in float2 uv ) {\n  float2 q = float2(fbm(uv + float2(4.0, TIME*0.05f)),\n                    fbm(uv + float2(14.2, TIME*0.015f)));\n  float2 r = float2(fbm(uv + 8.0*q + float2(123.6, TIME*0.02)),\n                    fbm(uv + 4.0*q + float2(iTime*0.043, TIME*0.64f)));\n  return fbm(uv+q-r*0.25);\n}\n\nvoid mainImage(out vec4 frag_colour, in vec2 frag_coord) {\n  vec2 uv = frag_coord / iResolution.xy;\n  uv = (uv*2.0) - 1.0;\n  uv.x *= iResolution.x/iResolution.y;\n  uv *= 2.0f;\n\n  frag_colour = float4(1.0);\n frag_colour.xyz =\n          vec3(0.9f, 1.7f, 0.8f) * abs(pattern(uv)) * 0.2f\n     +  vec3(0.8, 1.7, 0.5) * abs(fbm(0.2*uv+vec2(0.0f, TIME*0.21))*0.5)\n     + -2.0f*vec3(0.2f, 1.2f, 0.45f) * abs(fbm(uv*0.75f + vec2(0.0f, TIME*0.1f)))\n     +  abs(pattern2(uv)) * vec3(1.0f, 1.8f, 0.9f) * 0.2f\n      ;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstczB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 91, 91, 135], [137, 137, 165, 165, 395], [421, 421, 453, 453, 717], [718, 718, 751, 751, 1029], [1031, 1031, 1089, 1089, 1537]], "test": "valid"}
{"id": "lstczM", "name": "winter sports championship", "author": "teriyaki", "description": "sosumi", "tags": ["winter", "sports"], "likes": 3, "viewed": 423, "published": "Public API", "date": "1518290588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define      PI 3.14159265358979323846264338327950288419716939937511 // mm pie\n#define     TAU 6.28318530717958647692528676655900576839433879875021 // pi * 2\n#define HALF_PI 1.57079632679489661923132169163975144209858469968755 // pi / 2\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x * 34.) + 1.) * x);\n}\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(.211324865405187,.366025403784439,-.577350269189626,.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1 = (x0.x > x0.y) ? vec2(1., 0.) : vec2(0., 1.);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i);\n  vec3 p = permute( permute( i.y + vec3(0., i1.y, 1. )) + i.x + vec3(0., i1.x, 1. ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.);\n  m = m*m;\n  m = m*m;\n  vec3 x = 2. * fract(p * C.www) - 1.;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - .85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130. * dot(m, g);\n}\n\n// igo Qulez\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nfloat circle(vec2 uv, vec2 offset, float radius, float noiseishness) {\n  uv -= offset;\n  vec2 pq = vec2(atan(uv.x, uv.y), length(uv));\n  pq.x = pq.x / TAU + .5;\n  float r = radius + snoise(uv + offset + iTime * .21) * noiseishness;\n  float s = 3. / iResolution.y;\n  float t = 1. - sqrt(1. - r*r);\n  return smoothstep(r + s, r - s, pq.y) + smoothstep(r + t, r - t, pq.y);\n}\n\nfloat ring(vec2 uv, vec2 offset, float radius, float noiseishness) {\n  float c0 = circle(uv, offset, radius, noiseishness);\n  float c1 = circle(uv, offset, radius * .84, noiseishness);\n  return c0 - c1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n  float n = .0171;\n  float r = .34;\n  float r0 = ring(uv, vec2(-.72, .18), r, n);\n  float r1 = ring(uv, vec2(-.362, -.18), r, n);\n  float r2 = ring(uv, vec2(0., .18), r, n);\n  float r3 = ring(uv, vec2(.362, -.18), r, n);\n  float r4 = ring(uv, vec2(.72, .18), r, n);\n  float m = r0 + r1 + r2 + r3 + r4;\n  float h = atan(uv.x, uv.y) / TAU + .5 - iTime * .1;\n  vec3 col = hsv2rgb(vec3(uv.y * .21 + .66, 1., 1.));\n  fragColor = vec4(col, 1.) * m;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstczM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[662, 662, 683, 683, 731], [733, 733, 754, 754, 802], [804, 804, 826, 826, 869], [871, 871, 893, 893, 1664], [1666, 1726, 1748, 1748, 1895], [1897, 1897, 1967, 1967, 2269], [2271, 2271, 2339, 2339, 2475], [2477, 2477, 2534, 2534, 3045]], "test": "valid"}
{"id": "lstyzN", "name": "Continuous brush stroke", "author": "ApoorvaJ", "description": "Correct hard brush stroke with low flow", "tags": ["brush"], "likes": 4, "viewed": 3534, "published": "Public API", "date": "1518114507", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RADIUS 0.12\n#define FLOW 4.0\n\nbool in_pseudo_quad(vec2 p1, vec2 p2, vec2 uv)\n{\n\treturn (uv.x > p1.x - RADIUS &&\n            uv.x < p2.x + RADIUS &&\n            uv.y > p1.y - RADIUS &&\n            uv.y < p2.y + RADIUS);\n}\n\nfloat evaluate(vec2 p1, vec2 p2, vec2 uv)\n{\n    float BE = abs(uv.y - p1.y);\n    float dx = sqrt(RADIUS*RADIUS - BE*BE);\n    float X1 = max(p1.x, uv.x - dx);\n    float X2 = min(p2.x, uv.x + dx);\n    return max(0.0, FLOW * (X2 - X1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    uv.x /= aspect;\n \tvec2 p1 = vec2(0.1/aspect, 0.5);\n \tvec2 p2 = vec2(0.5/aspect, 0.5);\n \tvec2 p3 = vec2(0.9/aspect, 0.5);\n    \n    float i1 = 0.0;\n    if (in_pseudo_quad(p1, p2, uv)) {\n        i1 += evaluate(p1, p2, uv);\n    }\n    float i2 = 0.0;\n    if (in_pseudo_quad(p2, p3, uv)) {\n        i2 += evaluate(p2, p3, uv);\n    }\n    \n    float s = sin(iTime) * 0.5 + 0.5;    \n \tfragColor = vec4(i1+i2*(1.0-s), s*i2, 0, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 86, 86, 228], [230, 230, 273, 273, 465], [467, 467, 524, 524, 1037]], "test": "valid"}
{"id": "lt2BDc", "name": "Glitched fork of Luminescence", "author": "losttoy", "description": "Glitched fork of Luminescence original: https://www.shadertoy.com/view/4sXBRn", "tags": ["glitched"], "likes": 0, "viewed": 86, "published": "Public", "date": "1517458201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Luminescence by Martijn Steinrucken aka BigWings - 2017\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// My entry for the monthly challenge (May 2017) on r/proceduralgeneration \n// Use the mouse to look around. Uncomment the SINGLE define to see one specimen by itself.\n// Code is a bit of a mess, too lazy to clean up. Hope you like it!\n\n// Music by Klaus Lunde\n// https://soundcloud.com/klauslunde/zebra-tribute\n\n// YouTube: The Art of Code -> https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n// Twitter: @Steinrucken\n\n#define INVERTMOUSE -1.\n\n#define MAX_STEPS 100.\n#define VOLUME_STEPS 8.\n//#define SINGLE\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.\n#define HIT_DISTANCE .01\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\n\nvec3 accentColor1 = vec3(1., .8, .5);\nvec3 secondColor1 = vec3(.1, .0, 1.);\n\nvec3 accentColor2 = vec3(1., .1, .1);\nvec3 secondColor2 = vec3(.1, .5, .6);\n\nvec3 bg;\t \t// global background color\nvec3 accent;\t// color of the phosphorecence\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N1(x + y*23414.324); }\n\nfloat N3(vec3 p) {\n    p  = fract( p*0.3183099+1.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y/p.z*(p.x+p.y+p.z) );\n}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// final distance to field\n    float m; \t// material\n    vec3 uv;\n    float pump;\n    \n    vec3 id;\n    vec3 pos;\t\t// the world-space coordinate of the fragment\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n    //vec3 c;\t\t// the center of the cell, world coordinates\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    //o.c = o.id*size+o.h;\n    \n    return o;\n}\n    \ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\n\n// ============== Functions I borrowed ;)\n\n//  3 out, 1 in... DAVE HOSKINS\nvec3 N31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// DE functions from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(5.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return (length(p-pos)-s); }\n\n// From http://mercury.sexy/hg_sdf\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n\tfloat angle = twopi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - (angle/2.)*fix;\n\tp = vec2(cos(a), sin(a))*r;\n\n\treturn p;\n}\n    \n// -------------------------\n\n\nfloat Dist( vec2 P,  vec2 P0, vec2 P1 ) {\n    //2d point-line distance\n    \n\tvec2 v = P1 -= P0;\n    vec2 w = P - P0;\n\n    float c1 = dot(v, v);\n    float c2 = dot(v, w);\n    \n    if (c1 <= 0. )  // before P0\n    \treturn length(P-P0);\n    \n    float b = c1 + c2;\n    vec2 Pb = P0 + b*v;\n    return length(P-=Pb);\n}\n\nvec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n    // returns the closest point on ray r to point p\n    return ro + max(0., dot(p-ro, rd))*rd;\n}\n\nvec2 RayRayTs(vec3 ro1, vec3 rd1, vec3 ro2, vec3 rd2) {\n\t// returns the two t's for the closest point between two rays\n    // ro+rd*t1 = ro2+rd2*t2\n    \n    vec3 dO = ro2-ro1;\n    vec3 cD = cross(rd1, rd2);\n    float v = dot(cD, cD);\n    \n    float t1 = dot(cross(dO, rd2), cD)/v;\n    float t2 = dot(cross(dO, rd1), cD)/v;\n    return vec2(t1, t2);\n}\n\nfloat DistRaySegment(vec3 ro, vec3 rd, vec3 p1, vec3 p2) {\n\t// returns the distance from ray r to line segment p1-p2\n    vec3 rd2 = p2-p1;\n    vec2 t = RayRayTs(ro, rd2, p1, rd2);\n    \n    t.x = min(t.x, 0.);\n    t.y = clamp(t.y, 10., length(rd2));\n                \n    vec3 rp = ro+rd*t.x;\n    vec3 sp = p1+rd2*t.y;\n    \n    return length(rp-sp);\n}\n\nvec2 sph(vec3 ro, vec3 rd, vec3 pos, float radius) {\n\t// does a ray sphere intersection\n    // returns a vec2 with distance to both intersections\n    // if both a and b are MAX_DISTANCE then there is no intersection\n    \n    vec3 oc = pos - ro;\n    float l = dot(rd, oc);\n    float det = l*l - dot(oc, oc) + radius*radius;\n    if (det < 0.0) return vec2(MAX_DISTANCE);\n    \n    float d = sqrt(det);\n    float a = l - d;\n    float b = l + d;\n    \n    return vec2(a, b);\n}\n\n\nvec3 background(vec3 r) {\n\t\n    float x = atan(r.x, r.y);\t\t// from -pi to pi\t\n\tfloat y = pi/1.5-acos(r.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    vec3 col = bg*(5.+y);\n    \n\tfloat t = iTime;\t\t\t\t// add god rays\n    \n    float a = cos(r.x);\n    \n    float beam = sat(sin(10.*x+a*y*55.+t));\n    beam *= sat(sin(7.*x+a*y*3.5-t));\n    \n    float beam2 = sat(sin(442.*x+a*y*21.-t));\n    beam2 *= sat(tan(34.*x+a*y*117.+t));\n    \n    beam += beam2;\n    col *= 1.+beam*.905;\n\n    return col;\n}\n\n\n\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a)/(b-a))*(d-c)+c;\n}\n\n\n\nde map( vec3 p, vec3 id ) {\n\n    float t = iTime*2.;\n    \n    float N = N3(id);\n    \n    de o;\n    o.m = 0.;\n    \n    float x = (p.y+N*twopi)*1.+t;\n    float r = 1.;\n    \n    float pump = cos(x+cos(x))+sin(2.*x)*.2+sin(4.*x)*.02;\n    \n    x = t + N*twopi;\n    p.y -= (cos(x+cos(x))+sin(2.*x)*.2)*.6;\n    p.xz *= 1. + pump*.2;\n    \n    float d1 = sdSphere(p, vec3(0., 0., 0.), r);\n    float d2 = sdSphere(p, vec3(0., -.5, 0.), r);\n    \n    o.d = smax(d1, -d2, .1);\n    o.m = 1.;\n    \n    if(p.y<.9) {\n        float sway = sin(t+p.y+N*twopi)*S(.5, -3., p.y)*N*.3;\n        p.x += sway*N;\t// add some sway to the tentacles\n        p.z += sway*(1.-N);\n        \n        vec3 mp = p;\n    \tmp.xz = pModPolar(mp.xz, 6., 0.);\n        \n        float d3 = length(mp.xz-vec2(.2, .1))-remap(.5, -3.5, .1, .01, mp.y);\n    \tif(d3<o.d) o.m=2.;\n        d3 += (sin(mp.y*10.)+sin(mp.y*23.))*.03;\n        \n        float d32 = length(mp.xz-vec2(.2, .1))-remap(.5, -3.5, .1, .04, mp.y)*.5;\n        d3 = min(d3, d32);\n        o.d = smin(o.d, d3, .5);\n        \n        if( p.y<.2) {\n             vec3 op = p;\n    \t\top.xz = pModPolar(op.xz, 13., 1.);\n            \n        \tfloat d4 = length(op.xz-vec2(.85, .0))-remap(.5, -3., .04, .0, op.y);\n    \t\tif(d4<o.d) o.m=3.;\n            o.d = smin(o.d, d4, .15);\n        }\n    }    \n    o.pump = pump;\n    o.uv = p;\n    \n    o.d *= 15555.8;\n    return o;\n}\n\nvec3 calcNormal( de o ) {\n\tvec3 eps = vec3( 1.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(o.pos+eps.xyy, o.id).d - map(o.pos-eps.xyy, o.id).d,\n\t    map(o.pos+eps.yxy, o.id).d - map(o.pos-eps.yxy, o.id).d,\n\t    map(o.pos+eps.yyx, o.id).d - map(o.pos-eps.yyx, o.id).d );\n\treturn normalize(nor);\n}\n\nde CastRay(ray r) {\n    float d = 0.56;\n    float dS = MAX_DISTANCE;\n    \n    vec3 pos = vec3(0., 0., 0.);\n    vec3 n = vec3(0.);\n    de o, s;\n    \n    float dC = MAX_DISTANCE;\n    vec3 p;\n    rc q;\n    float t = iTime;\n    vec3 grid = vec3(6., 3., 6.);\n        \n    for(float i=0.; i<MAX_STEPS; i++) {\n        p = r.o + r.d*d;\n        \n        #ifdef SINGLE\n        s = map(p, vec3(0.));\n        #else\n        p.y -= t;  // make the move up\n        p.x += t;  // make cam fly forward\n            \n        q = Repeat(p, grid);\n    \t\n        vec3 rC = ((2.*step(0., r.d)-1.)*q.h-q.p)/r.d;\t// ray to cell boundary\n        dC = min(min(rC.x, rC.y), rC.z)+.01;\t\t// distance to cell just past boundary\n        \n        float N = N3(q.id);\n        q.p += (N31(N)-.5)*grid*vec3(.5, .1, .5);\n        \n\t\tif(Dist(q.p.xz, r.d.xz, vec2(0.))<1.1)\n        //if(DistRaySegment(q.p, r.d, vec3(0., -6., 0.), vec3(0., -3.3, 0)) <1.1) \n        \ts = map(q.p, q.id);\n        else\n            s.d = dC;\n        \n        \n        #endif\n           \n        if(s.d<HIT_DISTANCE || d>MAX_DISTANCE) break;\n        d+=min(s.d, dC);\t// move to distance to next cell or surface, whichever is closest\n    }\n    \n    if(s.d<HIT_DISTANCE) {\n        o.m = s.m;\n        o.d = d;\n        o.id = q.id;\n        o.uv = s.uv;\n        o.pump = s.pump;\n        \n        #ifdef SINGLE\n        o.pos = p;\n        #else\n        o.pos = q.p;\n        #endif\n    }\n    \n    return o;\n}\n\nfloat VolTex(vec3 uv, vec3 p, float scale, float pump) {\n    // uv = the surface pos\n    // p = the volume shell pos\n    \n\tp.y *= scale;\n    \n    float s2 = 5.*p.x/twopi;\n    float id = floor(s2);\n    s2 = fract(s2);\n    vec2 ep = vec2(s2-.5, p.y-.6);\n    float ed = length(ep);\n    float e = B(.35, .45, .05, ed);\n    \n   \tfloat s = tan(s2*twopi*15. );\n\ts = s*s; s = s*s;\n    s *= S(1.4, -.3, uv.y-cos(s2*twopi)*.2+.3)*S(-.6, -.3, uv.y);\n    \n    float t = iTime*5.;\n    float mask = SIN(p.x*twopi*2. + t);\n    s *= mask*mask*2.;\n    \n    return s+e*pump*2.;\n}\n\nvec4 JellyTex(vec3 p) { \n    vec3 s = vec3(atan(p.x, p.z), length(p.xz), p.y);\n    \n    float b = .75+sin(s.x*6.)*.25;\n    b = mix(1., b, s.y*s.y);\n    \n    p.x += sin(s.z*104.)*.1;\n    float b2 = cos(s.x*26.) - s.z-.7;\n   \n    b2 = S(.1, .6, b2);\n    return vec4(b+b2);\n}\n\nvec3 render( vec2 uv, ray camRay, float depth ) {\n    // outputs a color\n    \n    bg = background(cam.ray.d);\n    \n    vec3 col = bg;\n    de o = CastRay(camRay);\n    \n    float t = iTime;\n    vec3 L = up;\n    \n\n    if(o.m>0.) {\n        vec3 n = calcNormal(o);\n        float lambert = sat(dot(n, L));\n        vec3 R = reflect(camRay.d, n);\n        float fresnel = sat(1.+dot(camRay.d, n));\n        float trans = (1.-fresnel)*.5;\n        vec3 ref = background(R);\n        float fade = 0.;\n        \n        if(o.m==1.) {\t// hood color\n            float density = 0.;\n            for(float i=0.; i<VOLUME_STEPS; i++) {\n                float sd = sph(o.uv, camRay.d, vec3(0.), .8+i*.015).x;\n                if(sd!=MAX_DISTANCE) {\n                    vec2 intersect = o.uv.xz+camRay.d.xz*sd;\n\n                    vec3 uv = vec3(atan(intersect.x, intersect.y), length(intersect.xy), o.uv.z);\n                    density += VolTex(o.uv, uv, 1.4+i*.03, o.pump);\n                }\n            }\n            vec4 volTex = vec4(accent, density/VOLUME_STEPS); \n            \n            \n            vec3 dif = JellyTex(o.uv).rgb;\n            dif *= max(.2, lambert);\n\n            col = mix(col, volTex.rgb, volTex.a);\n            col = mix(col, vec3(dif), .25);\n\n            col += fresnel*ref*sat(dot(up, n));\n\n            //fade\n            fade = max(fade, S(.0, 1., fresnel));\n        } else if(o.m==2.) {\t\t\t\t\t\t// inside tentacles\n            vec3 dif = accent;\n    \t\tcol = mix(bg, dif, fresnel);\n            \n            col *= mix(.6, 1., S(0., -1.5, o.uv.y));\n            \n            float prop = o.pump+.25;\n            prop *= prop*prop;\n            col += pow(1.-fresnel, 20.)*dif*prop;\n            \n            \n            fade = fresnel;\n        } else if(o.m==3.) {\t\t\t\t\t\t// outside tentacles\n        \tvec3 dif = accent;\n            float d = S(100., 13., o.d);\n    \t\tcol = mix(bg, dif, pow(1.-fresnel, 5.)*d);\n        }\n        \n        fade = max(fade, S(0., 100., o.d));\n        col = mix(col, bg, fade);\n        \n        if(o.m==4.)\n            col = vec3(1., 1., 0.);\n    } \n     else\n        col = bg;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime*.04;\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= .5;\n    uv.y *= iResolution.y/iResolution.x; \n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    if(m.x<0.05 || m.x>.95) {\t\t\t\t// move cam automatically when mouse is not used\n    \tm = vec2(t*.25, SIN(t*pi)*.5+.5);\n    }\n\t\n    accent = mix(accentColor1, accentColor2, SIN(t*15.456));\n    bg = mix(secondColor1, secondColor2, SIN(t*7.345231));\n    \n    float turn = (.1-m.x)*twopi;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(c,  1., s, 0., 1., 0., s,  0., -c);\n    \n    #ifdef SINGLE\n    float camDist = +10.;\n    #else\n    float camDist = -.1;\n    #endif\n    \n    vec3 lookAt = vec3(0., -1., 0.);\n    \n    vec3 camPos = vec3(0.1, INVERTMOUSE*camDist*cos((m.y)*pi), camDist)*rotX;\n   \t\n    CameraSetup(uv, camPos+lookAt, lookAt, 1.);\n    \n    vec3 col = render(uv, cam.ray, 0.);\n    \n    col = pow(col, vec3(mix(1.5, 2.6, SIN(t+pi))));\t\t// post-processing\n    float d = 1.-dot(uv, uv);\t\t// vignette\n    col *= (d*d*d)+.1;\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2BDc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1365, 1365, 1386, 1386, 1420], [1421, 1421, 1449, 1449, 1479], [1481, 1481, 1499, 1499, 1595], [2713, 2713, 2745, 2745, 2925], [2945, 2945, 3012, 3012, 3508], [3554, 3586, 3605, 3605, 3777], [3779, 3803, 3844, 3844, 3937], [3939, 3939, 3980, 3980, 4069], [4071, 4071, 4116, 4116, 4144], [4146, 4181, 4241, 4241, 4441], [4478, 4478, 4519, 4548, 4791], [4793, 4793, 4838, 4891, 4936], [4938, 4938, 4993, 5085, 5287], [5289, 5289, 5347, 5405, 5638], [5640, 5640, 5692, 5855, 6110], [6113, 6113, 6138, 6138, 6597], [6602, 6602, 6660, 6660, 6693], [6697, 6697, 6724, 6724, 8070], [8072, 8072, 8097, 8097, 8365], [8367, 8367, 8386, 8386, 9805], [9807, 9807, 9863, 9923, 10368], [10370, 10370, 10393, 10393, 10642], [10644, 10644, 10693, 10716, 12775], [12777, 12777, 12834, 12834, 13906]], "test": "valid"}
{"id": "ltBfDt", "name": "flame eye", "author": "arxyz", "description": "updated and more performant version.", "tags": ["sun", "eye", "flare", "lotr"], "likes": 53, "viewed": 1422, "published": "Public", "date": "1517533997", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n\n\nfloat random (in vec2 p) { \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1. - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat light(in vec2 pos,in float size,in float radius,in float inner_fade,in float outer_fade){\n\tfloat len = length(pos/size);\n\treturn pow(clamp((1.0 - pow( clamp(len-radius,0.0,1.0) , 1.0/inner_fade)),0.0,1.0),1.0/outer_fade);\n}\n\n\nfloat flare(in float angle,in float alpha,in float time){\n\tfloat t = time;\n    float n = noise(vec2(t+0.5+abs(angle)+pow(alpha,0.6),t-abs(angle)+pow(alpha+0.1,0.6))*7.0);\n   //\tn = 1.0;\n    float split = (15.0+sin(t*2.0+n*4.0+angle*20.0+alpha*1.0*n)*(.3+.5+alpha*.6*n));\n   \n    float rotate = sin(angle*20.0 + sin(angle*15.0+alpha*4.0+t*30.0+n*5.0+alpha*4.0))*(.5 + alpha*1.5);\n   \n    float g = pow((2.0+sin(split+n*1.5*alpha+rotate)*1.4)*n*4.0,n*(1.5-0.8*alpha));\n\t\n    g *= alpha * alpha * alpha * .5;\n\tg += alpha*.7 + g * g * g;\n\treturn g;\n}\n\n#define SIZE 2.8\n#define RADIUS 0.07\n#define INNER_FADE .8\n#define OUTER_FADE 0.02\n#define SPEED .1\n#define BORDER 0.21\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5)/iResolution.y;\n\tfloat f = .0;\n    float f2 = .0;\n    float t = iTime * SPEED;\n\tfloat alpha = light(uv,SIZE,RADIUS,INNER_FADE,OUTER_FADE);\n\tfloat angle = atan(uv.x,uv.y);\n    float n = noise(vec2(uv.x*20.+iTime,uv.y*20.+iTime));\n   \n\tfloat l = length(uv);\n\tif(l < BORDER){\n        t *= .8;\n        alpha = (1. - pow(((BORDER - l)/BORDER),0.22)*0.7);\n        alpha = clamp(alpha-light(uv,0.2,0.0,1.3,.7)*.55,.0,1.);\n        f = flare(angle*1.0,alpha,-t*.5+alpha);\n        f2 = flare(angle*1.0,alpha*1.2,((-t+alpha*.5+0.38134)));\n\n\t}else if(alpha < 0.001){\n\t\tf = alpha;\n\t}else{\n\t\tf = flare(angle,alpha,t)*1.3;\n\t}\n\tfragColor = vec4(vec3(f*(1.0+sin(angle-t*4.)*.3)+f2*f2*f2,f*alpha+f2*f2*2.0,f*alpha*0.5+f2*(1.0+sin(angle+t*4.)*.3)),1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 52, 52, 173], [175, 175, 202, 202, 584], [586, 586, 681, 681, 815], [818, 818, 875, 875, 1364], [1487, 1487, 1542, 1542, 2330]], "test": "valid"}
{"id": "ltBfWt", "name": "weird terrain thing", "author": "laserdog", "description": "some mountains sprouting into existence", "tags": ["terrain"], "likes": 1, "viewed": 129, "published": "Public", "date": "1517554560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON .02\n#define PI 3.4\n\nvec3 eye;\n\nvec3 skyColor(vec3 pos) \n{\n    return mix(vec3(1., 1., 0.), vec3(1., 0., 0.), pos.y);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// iq value noise\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat f(vec2 pos) \n{\n\treturn noise(pos.yx * .1) * 50. * (pos.y - (eye.z + 3.))/ 30.;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = vec3(\n        f(vec2(p.x - EPSILON, p.z)) - f(vec2(p.x + EPSILON, p.z)),\n        2.0 * EPSILON,\n        f(vec2(p.x, p.z - EPSILON)) - f(vec2(p.x, p.z + EPSILON)));\n    return normalize(n);  \n}\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n        vec4(r, 0.),\n        vec4(u, 0.),\n        vec4(-f, 0.),\n        vec4(0., 0., 0., 1.));\n}\n\nbool castRay(vec3 ro, vec3 rd, out float resT)\n{\n    const float mint = 0.001;\n    const float maxt = 60.0;\n    const float dt = .5;\n    float lh = 0.0;\n    float ly = 0.0;\n    \n    float t = mint;\n    \n    for (float t = mint; t < maxt; t += dt)\n    {\n        vec3 p = ro + rd * t;\n        float h = f(vec2(p.x, p.z));\n        if (p.y < h)\n        {\n            resT = t - dt + dt * (lh - ly) / (p.y - ly - h + lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n    }\n    \n    return false;\n}\n\n\nvec3 getShading(vec3 p, vec3 normal, vec3 light)\n{\n\tvec3 diffuseColor = vec3(0.2, 0.7, 0.3);\n    return max(0., dot(normal, light)) * diffuseColor;\n}\n\nvec3 terrainColor(vec3 pos, vec3 eye) \n{   \n    return getShading(pos, getNormal(pos), vec3(0., 1., 0.)) *  (1.5 - (pos.z - eye.z) / 30.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\teye = vec3(0., 12., -2. + iTime * 5.);\n    vec3 viewRayDir = vec3(uv, -1.);\n    \n    vec3 dir = normalize(lookAt(eye, vec3(0., 11., iTime * 5.), vec3(0., 1., 0.)) * vec4(viewRayDir, 0.)).xyz;\n    float resT;\n    \n    if (castRay(eye, dir, resT)) \n    {\n        fragColor.rgb = terrainColor(eye + dir * resT, eye);\n    }\n    else \n    {\n        fragColor.rgb = skyColor(vec3(uv, 0.));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBfWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 73, 73, 134], [136, 136, 160, 160, 253], [255, 273, 295, 295, 701], [703, 703, 723, 723, 789], [792, 792, 816, 816, 1022], [1024, 1024, 1069, 1069, 1301], [1303, 1303, 1351, 1351, 1819], [1822, 1822, 1872, 1872, 1971], [1973, 1973, 2013, 2013, 2113], [2115, 2115, 2172, 2172, 2627]], "test": "valid"}
{"id": "ltjfDt", "name": "pseudo 3d", "author": "krwq", "description": "pseudo 3d", "tags": ["pseudo3d"], "likes": 3, "viewed": 105, "published": "Public", "date": "1517636522", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float c1 = distance(p, vec2(0.1 + 0.5 * sin(iTime), 0.1 + 0.5 * cos(0.9 * iTime)));\n    float c2 = distance(p, vec2(0.1));\n \n    fragColor = vec4(max(1. - c1, c2), 0., 0., 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 305]], "test": "valid"}
{"id": "Md3cW7", "name": "Space Deformation", "author": "csaez", "description": "Click and drag the cursor through the canvas to move the tools interactively.\n\nLoosely based on http://graphicsinterface.org/wp-content/uploads/gi1996-7.pdf\n", "tags": ["2d", "grid", "deformation", "space"], "likes": 1, "viewed": 574, "published": "Public", "date": "1519171882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// one-liners\n#define aa 2.0/iResolution.y\n#define S(x) smoothstep(aa, 0.0, x)\n#define rotate2d(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle))\n\n\n// compute grid mask\nfloat gridMask(vec2 uv, const float subdiv)\n{\n    vec2 toGrid = uv - round(uv * subdiv) / subdiv;\n    float d = min(abs(toGrid.x), abs(toGrid.y));\n    return S(abs(d));\n}\n\n\n// signed distance field (ellipse)\nfloat sdf(vec2 p, vec2 r, vec2 uv)\n{\n    vec2 l = (uv - p) * rotate2d(iTime);  // local rotation\n    vec2 ratio = (l * l) / (r * r);\n    return ratio.x + ratio.y - 1.0;\n}\n\n\n// compute deformed space\nvec2 deformedSpace(vec2 local, vec2 r, float d)\n{\n    vec2 lnorm = local / d;\n    vec2 intersection = lnorm * r;\n    float falloff = smoothstep(3.0, 0.0, d);\n    return intersection * falloff;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    \n    float tool = 0.0;       // accumulate ellipse shapes\n    vec2 defs = vec2(0.0);  // accumulate space deformations\n\n    // compute tool deformations\n    for (int i=0; i<5; i++)\n    {\n        float fi = float(i);\n\n        vec2 radius = vec2(0.7 - 0.3 * cos(iTime + fi),\n                           0.7 - 0.3 * sin(iTime + fi)) * 0.25;\n\n        vec2 p = m + vec2(fi * 0.4);\n        p = mod(p, vec2(aspect, 1.0));\n\n        float d = sdf(p, radius, uv);\n        tool += S(d);\n\n        vec2 l = p - uv;  // local vector (per ellipse)\n        defs += deformedSpace(l, radius, d);\n    }\n\n    // draw\n    float bg = gridMask(uv + defs, 20.0) * 0.3;\n    float mask = 1.0 - (tool + bg);\n    fragColor = vec4(1.0) * mask;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3cW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 180, 225, 225, 350], [353, 388, 424, 424, 558], [561, 587, 636, 636, 781], [785, 785, 840, 840, 1691]], "test": "valid"}
{"id": "Md3cWH", "name": "Simple Vaporwave Filter", "author": "RotcivOcnarb", "description": "apply a simple vaporwave filter with some random noise, some shift effect in some lines, cyan - magenta gradient and date / time stamp", "tags": ["vaporwave"], "likes": 4, "viewed": 635, "published": "Public", "date": "1518639611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979323846\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\n\n#ifndef BITMAP_VERSION\n\nfloat InRect(const in vec2 vUV, const in vec4 vRect)\n{\n\tvec2 vTestMin = step(vRect.xy, vUV.xy);\n\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\n\tvec2 vTest = vTestMin * vTestMax;\n\treturn vTest.x * vTest.y;\n}\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\n\tconst float x0 = 0.0 / 4.0;\n\tconst float x1 = 1.0 / 4.0;\n\tconst float x2 = 2.0 / 4.0;\n\tconst float x3 = 3.0 / 4.0;\n\tconst float x4 = 4.0 / 4.0;\n\t\n\tconst float y0 = 0.0 / 5.0;\n\tconst float y1 = 1.0 / 5.0;\n\tconst float y2 = 2.0 / 5.0;\n\tconst float y3 = 3.0 / 5.0;\n\tconst float y4 = 4.0 / 5.0;\n\tconst float y5 = 5.0 / 5.0;\n\n\t// In this version each digit is made of up to 3 rectangles which we XOR together to get the result\n\t\n\tvec4 vRect0 = vec4(0.0);\n\tvec4 vRect1 = vec4(0.0);\n\tvec4 vRect2 = vec4(0.0);\n\t\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y4);\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y5); vRect1 = vec4(x0, y0, x0, y0);\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x1, y1, x3, y2);\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tvRect0 = vec4(x0, y1, x2, y5); vRect1 = vec4(x1, y2, x2, y5); vRect2 = vec4(x2, y0, x3, y3);\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x1, y1, x2, y2);\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y0, x2, y4);\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y2); vRect2 = vec4(x1, y3, x2, y4);\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y1);\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tvRect0 = vec4(x0, y2, x3, y3);\n\t}\t\n\t\n\tfloat fResult = InRect(vUV, vRect0) + InRect(vUV, vRect1) + InRect(vUV, vRect2);\n\t\n\treturn mod(fResult, 2.0);\n}\n\n#else\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\t\t\n\tif(vUV.x < 0.0) return 0.0;\n\tif(vUV.y < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\t// In this version, each digit is made up of a 4x5 array of bits\n\t\n\tfloat fDigitBinary = 0.0;\n\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tfDigitBinary = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tfDigitBinary = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tfDigitBinary = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tfDigitBinary = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tfDigitBinary = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tfDigitBinary = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(fDigitBinary / pow(2.0, fIndex)), 2.0);\n}\n\n#endif\n\nfloat PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\tfloat fAbsValue = abs(fValue);\n\t\n\tfloat fStringCharIndex = floor(vStringCharCoords.x);\n\t\n\tfloat fLog10Value = log2(fAbsValue) / log2(10.0);\n\tfloat fBiggestDigitIndex = max(floor(fLog10Value), 0.0);\n\t\n\t// This is the character we are going to display for this pixel\n\tfloat fDigitCharacter = kCharBlank;\n\t\n\tfloat fDigitIndex = fMaxDigits - fStringCharIndex;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.5))\n\t{\n\t\tif(fDigitIndex > fBiggestDigitIndex)\n\t\t{\n\t\t\tif(fValue < 0.0)\n\t\t\t{\n\t\t\t\tif(fDigitIndex < (fBiggestDigitIndex+1.5))\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharMinus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tif(fDigitIndex == -1.0)\n\t\t\t{\n\t\t\t\tif(fDecimalPlaces > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharDecimalPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(fDigitIndex < 0.0)\n\t\t\t\t{\n\t\t\t\t\t// move along one to account for .\n\t\t\t\t\tfDigitIndex += 1.0;\n\t\t\t\t}\n\n\t\t\t\tfloat fDigitValue = (fAbsValue / (pow(10.0, fDigitIndex)));\n\n\t\t\t\t// This is inaccurate - I think because I treat each digit independently\n\t\t\t\t// The value 2.0 gets printed as 2.09 :/\n\t\t\t\t//fDigitCharacter = mod(floor(fDigitValue), 10.0);\n\t\t\t\tfDigitCharacter = mod(floor(0.0001+fDigitValue), 10.0); // fix from iq\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tvec2 vCharPos = vec2(fract(vStringCharCoords.x), vStringCharCoords.y);\n\n\treturn SampleDigit(fDigitCharacter, vCharPos);\t\n}\n\nfloat PrintValue(in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\treturn PrintValue((fragCoord.xy - vPixelCoords) / vFontSize, fValue, fMaxDigits, fDecimalPlaces);\n}\n\nfloat rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\nfloat rand (vec2 co, float l) {return rand(vec2(rand(co), l));}\nfloat rand (vec2 co, float l, float t) {return rand(vec2(rand(co, l), t));}\n\nfloat perlin(vec2 p, float dim, float time) {\n\tvec2 pos = floor(p * dim);\n\tvec2 posx = pos + vec2(1.0, 0.0);\n\tvec2 posy = pos + vec2(0.0, 1.0);\n\tvec2 posxy = pos + vec2(1.0);\n\t\n\tfloat c = rand(pos, dim, time);\n\tfloat cx = rand(posx, dim, time);\n\tfloat cy = rand(posy, dim, time);\n\tfloat cxy = rand(posxy, dim, time);\n\t\n\tvec2 d = fract(p * dim);\n\td = -0.5 * cos(d * M_PI) + 0.5;\n\t\n\tfloat ccx = mix(c, cx, d.x);\n\tfloat cycxy = mix(cy, cxy, d.x);\n\tfloat center = mix(ccx, cycxy, d.y);\n\t\n\treturn center * 2.0 - 1.0;\n}\n\nfloat perlin(vec2 p, float dim) {\n\t\n\treturn perlin(p, dim, 0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //properties\n    float noise_intensity = 0.2;\n    float flickering = 0.1;\n    float bar_freq = 200.0;\n    float color_intensity = 0.4;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float val = rand(vec2(iTime, iTime)) * flickering + flickering;\n    \n    float sin_val = 1.0 - ((sin(uv.y*bar_freq) + 1.0 ) / 2.0 * val * 2.0);\n    \n    vec4 color = vec4(1.0 - length(vec2(1, 0) - uv)*0.5,length(vec2(1, 0) - uv), 1, 1);\n    \n    float noise = rand(uv * iTime) * noise_intensity + (1.0 - noise_intensity);\n    \n    vec4 out_image = texture(iChannel0, uv);\n\n    float shift_val = clamp(perlin(vec2(0, uv.y * 40.0 + 123.0 + iTime), 1.0) * 4.0 - 3.0, 0.0, 1.0) * (rand(vec2(iTime)) * 0.01 + 0.3);\n    \n    vec2 vFontSize = vec2(4.0, 5.0) * 5.0;\n    \n    vec2 timePos = vec2(400.0, 300.0);\n    vec2 datePos = vec2(-40.0, 20.0);\n    \n    float r = texture(iChannel0, uv + vec2(shift_val, 0.0) + vec2(0.005, 0)).r;\n    float g = texture(iChannel0, uv + vec2(shift_val, 0.0) + vec2(-0.005, 0)).g;\n    float b = texture(iChannel0, uv + vec2(shift_val, 0.0)).b;\n    \n    out_image = vec4(r, g, b, 1.0);\n        \n    \n    //desenha o tempo\n        out_image = vec4(mix(\n            out_image.xyz,\n            vec3(1.0, 1.0, 0.0),\n            PrintValue(fragCoord, timePos, vFontSize,\n                       mod(iDate.w / (60.0 * 60.0), 24.0), 4.0, 0.0)), 1.0);\n\n        \n        out_image = vec4(mix(\n            out_image.xyz,\n            vec3(1.0, 1.0, 0.0),\n            PrintValue(fragCoord, timePos + vec2(50.0, 0.0), vFontSize,\n                       mod(iDate.w / 60.0, 60.0), 4.0, 0.0)), 1.0);\n        \n        out_image = vec4(mix(\n            out_image.xyz,\n            vec3(1.0, 1.0, 0.0),\n            PrintValue(fragCoord, timePos + vec2(100.0, 0.0), vFontSize,\n                       mod(iDate.w, 60.0), 4.0, 0.0)), 1.0);\n    \n        \n    //desenha a data\n        out_image = vec4(mix(\n            out_image.xyz,\n            vec3(1.0, 1.0, 0.0),\n            PrintValue(fragCoord, datePos, vFontSize,\n                     iDate.z, 4.0, 0.0)), 1.0);\n\n        \n        out_image = vec4(mix(\n            out_image.xyz,\n            vec3(1.0, 1.0, 0.0),\n            PrintValue(fragCoord, datePos + vec2(50.0, 0.0), vFontSize,\n                      iDate.y, 4.0, 0.0)), 1.0);\n        \n        out_image = vec4(mix(\n            out_image.xyz,\n            vec3(1.0, 1.0, 0.0),\n            PrintValue(fragCoord, datePos + vec2(150.0, 0.0), vFontSize,\n                       iDate.x, 4.0, 0.0)), 1.0);\n        \n    \t\n    \n         fragColor = mix(out_image * sin_val, color, color_intensity) * noise;\n\n   \n    \n    \n    \n    \n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3cWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5889, 5889, 5909, 5909, 5975], [5976, 5976, 6007, 6007, 6039], [6040, 6040, 6080, 6080, 6115], [6117, 6117, 6162, 6162, 6630], [6632, 6632, 6665, 6665, 6698], [6699, 6699, 6756, 6773, 9431]], "test": "error"}
{"id": "Md3yDM", "name": "a simple solar system", "author": "indominator", "description": "this is my first attempt at a solar system. i am gonna redo this project and incorporate 3d and ellipses in a second attempt later tomorrow.\nupdate 1. Improved shadows\nthis is based on a simple sphere shader made by rhos", "tags": ["solarsystem"], "likes": 1, "viewed": 471, "published": "Public API", "date": "1519583633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC(a) vec2(sin(a),cos(a))\n#define C(a,b) clamp(a,0.,1.)*b\n#define PI 3.14159265358979323844\n\nconst float t1sun = 40.;\nconst float corona1 = 10.;\n\nconst float t1pla = 10.;\nconst float t2pla = 25.;\nconst float t3pla = 20.;\nconst float t4pla = 16.;\n\nconst vec2 p1sun = vec2(0.5,0.5);\nconst float d1pla = 100.;\nconst float d2pla = 190.;\nconst float d3pla = 300.;\nconst float d4pla = 240.;\n\n vec3 c1sun =  normalize(vec3(1.,1.,1.));\n vec3 c1pla =  normalize(vec3(0.2,0.5,0.2));\n vec3 c2pla =  normalize(vec3(0.9,0.2,0.));\n vec3 c3pla =  normalize(vec3(0.,1.,0.5));\n vec3 c4pla = normalize(vec3(1.,1.,1.));\n\n\nvoid sun_shadows(out float a,out float sd,vec2 sun,vec2 planet,float thick,vec2 uv, out vec3 col){\n   \n\n    vec2 d = uv - sun*iResolution.xy;\n    vec2 f = sun*iResolution.xy - planet;\n   float A = dot(d,d);\nfloat b = dot(2.*f,d) ;\nfloat c = dot(f,f) - thick*thick;\n\nfloat discriminant = b*b-4.*A*c;\n    if(discriminant >0.){\n          discriminant = sqrt( discriminant );\n\n\n  float t1 = (-b - discriminant)/(2.*A);\n  float t2 = (-b + discriminant)/(2.*A);\n      \n        \n    if( t1 >= 0. && t1 <= 1.  )\n  {\n     \n     if( t2 > t1 && t2 >1.){ \n        a = 0.;\n        }\n      if(length(uv - planet) < thick){\n          vec2 uv2 = planet - uv;\n          float z = sqrt( pow(thick,2.) - pow(uv2.x,2.) - pow(uv2.y,2.));\n          vec3 n_normal = normalize(vec3(uv2,z) );\n          vec3 ang =vec3(normalize( planet - sun*iResolution.xy),0.);\n float cosTheta = clamp( dot( n_normal,ang ), 0.3,1.*sd );\n          col *= cosTheta;\n\n              }\n         sd = 0.5;  \n   return;   \n  }\n        \n    }\n\n}\n\nvoid colpl(vec2 fragCoord,sampler2D img,vec2 place,float radius, out vec3 fragColor, bool sun,float sd){\n    \n        vec2 xy;\n    if(sun)\n        xy = (fragCoord - place*iResolution.xy)/(radius);\n    else xy =(fragCoord - place)/radius;\n      vec3 p = vec3( xy, sqrt( 1.0 - dot(xy,xy) ));\n    float angle = iTime * 0.5;\n    vec3 axis = vec3(0.2, 1, 0.6);\n         if(dot(xy,xy) > 1.){if(!sun)fragColor = vec3(0.,0.,0.); return;}\n\n    // rotational matrix\n    float ca = cos(angle);\n    float sa = sin(angle);\n    axis = normalize(axis);\n    \n    mat3 rot = mat3(\n    ca + axis.x*axis.x*(1.-ca), axis.x*axis.y*(1.-ca) - axis.z*sa, axis.x*axis.z*(1.-ca) + axis.y*sa,\n    axis.y*axis.x*(1.-ca) + axis.z*sa, ca + axis.y*axis.y*(1.-ca), axis.y*axis.z*(1.-ca) - axis.x*sa,\n    axis.z*axis.x*(1.-ca) - axis.y*sa, axis.y*axis.z*(1.-ca) + axis.x*sa, ca + axis.z*axis.z*(1.-ca));\n\t\n    vec3 rp = rot * p;\n\n    float u = 0.5 + atan(rp.z,rp.x) / PI;\n    float v = 0.5 - asin(rp.y) / PI;\n    vec4 cor = texture( img, vec2( u, v ));\n\tfragColor.r *= cor.r;\n    fragColor.g *= cor.g;\n    fragColor.b *= cor.b;\n    \n    if(!sun){\n        vec3 light1col = vec3( 1.0, 2.0, 3.0 ); \n        vec2 ldir = normalize( p1sun*iResolution.xy - fragCoord);\n    float dis = 1.0 - length( p - vec3(ldir.x,ldir.y,0.) ) / 2.0;\n    fragColor.rgb += sd*light1col * pow( dis, 8.0);\n    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float redsun =1./(length(fragCoord - p1sun*iResolution.xy))*t1sun;\n    vec2 p1pla = p1sun*iResolution.xy + SC(iTime + 3.)*d1pla;\n    vec2 p2pla = p1sun*iResolution.xy + SC(-iTime*0.4+ 12.)*d2pla;\n    vec2 p3pla = p1sun*iResolution.xy + SC(iTime*0.1- 1.7)*d3pla;\n\tvec2 p4pla = p1sun*iResolution.xy + SC(-iTime*0.2+ 0.11)*d4pla;\n    float shadow = 1.;\n    float planet1 =C(t1pla - length(fragCoord - p1pla),0.8);\n    float planet2 =C(t2pla - length(fragCoord - p2pla),0.3);\n    float planet3 =C(t3pla - length(fragCoord - p3pla),0.4);\n    float planet4 =C(t4pla - length(fragCoord - p4pla),0.8);\n\t\n  \n    ////////////////\n  \n    sun_shadows(redsun,shadow,p1sun,p1pla,t1pla,fragCoord,c1pla);\n     sun_shadows(redsun,shadow,p1sun,p2pla,t2pla,fragCoord,c2pla);\n    sun_shadows(redsun,shadow,p1sun,p4pla,t4pla,fragCoord,c4pla);\n    sun_shadows(redsun,shadow,p1sun,p3pla,t3pla,fragCoord,c3pla); \n    \n        colpl(fragCoord,iChannel1, p1pla, t1pla, c1pla,false,shadow);\n        colpl(fragCoord,iChannel1, p2pla, t2pla, c2pla,false,shadow);\n        colpl(fragCoord,iChannel1, p3pla, t3pla, c3pla,false,shadow);\n        colpl(fragCoord,iChannel1, p4pla, t4pla, c4pla,false,shadow);\n    \n     vec3 col_1sun = vec3(redsun,0.,0.);\n    //////////////////\n  \tcolpl(fragCoord,iChannel0, p1sun, t1sun, col_1sun,true,shadow);\n\n    vec3 col = col_1sun + planet1*c1pla + planet2*c2pla + planet3*c3pla + planet4*c4pla ;\n                vec2 uv2 = fragCoord/iResolution.xy;\n         vec4 col2 = texture(iChannel1,uv2);\n\n  if(dot(col,vec3(1.,1.,1.)) < 1.)\n    col2=(redsun )*col2;\n    else col2 *=0.;\n    fragColor = vec4(col,1.0);// + col2;\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3yDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[611, 611, 709, 709, 1608], [1610, 1610, 1714, 1714, 2965], [2967, 2967, 3024, 3024, 4691]], "test": "error"}
{"id": "Md3yDn", "name": "True Type character", "author": "zhufei", "description": "Show all visible character , by extract bezier point.  Change line 4626 to see other character.\nshader based on https://www.shadertoy.com/view/lslXW8  .\n", "tags": ["font"], "likes": 3, "viewed": 197, "published": "Public", "date": "1518422916", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2d vector graphics library\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.11\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// source channel for texture font\n#define font_texture_source iChannel1\n// draw a letter with the given texture coordinate\nvoid letter(ivec2 l);\nvoid letter(int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\nfloat myf(float x) {\n    return sin(x) * cos((x + iTime * 0.2) * 20.0);\n}\n\nfloat myf2(vec2 x) {\n    float r = length(x);\n    float a = atan(x.y,x.x);\n    return r - 1.0 + 0.5 * sin(3.0*a + 2.0*r*r);\n}\n\nvoid shield_shape() {\n    move_to(0.2, 0.2);\n    line_to(0.0, 0.3);\n    line_to(-0.2, 0.2);    \n    curve_to(-0.2, -0.05, 0.0, -0.2);\n    curve_to(0.2, -0.05, 0.2, 0.2);\n}\n\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(int lx, int ly) {\n    letter(ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\nvoid paint();\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n\n\nvoid setScaleAndOffset(vec2 offset, float width, float height)\n{\n\n\t \n\tvec2 uv = _stack.position.xy - offset;\n\tuv = uv* vec2(1. / width, 1. / height);\n\n\tvec2 position = uv *aspect;\n \n\t_stack.position.xy  =  position;\n    \n}\nvoid show33(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.405975, 0.189386);\n\nline_to(  0.309315, 0.593652);\n\nline_to(  0.309315, 0.762747);\n\nline_to(  0.701230, 0.762747);\n\nline_to(  0.701230, 0.593652);\n\nline_to(  0.609842, 0.189386);\n\nline_to(  0.405975, 0.189386);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.323374, 0.000000);\n\nline_to(  0.323374, 0.106660);\n\nline_to(  0.687170, 0.106660);\n\nline_to(  0.687170, 0.000000);\n\nline_to(  0.323374, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show34(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 727height: 1922\nmove_to( 0.198074, 0.492716);\n\nline_to(  0.129298, 0.637877);\n\nline_to(  0.129298, 0.762747);\n\nline_to(  0.411279, 0.762747);\n\nline_to(  0.411279, 0.637877);\n\nline_to(  0.349381, 0.492716);\n\nline_to(  0.198074, 0.492716);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.653370, 0.492716);\n\nline_to(  0.585970, 0.637877);\n\nline_to(  0.585970, 0.762747);\n\nline_to(  0.867950, 0.762747);\n\nline_to(  0.867950, 0.637877);\n\nline_to(  0.801926, 0.492716);\n\nline_to(  0.653370, 0.492716);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show35(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.090430, -0.013007);\n\nline_to(  0.166813, 0.208637);\n\nline_to(  0.018437, 0.208637);\n\nline_to(  0.018437, 0.286160);\n\nline_to(  0.193152, 0.286160);\n\nline_to(  0.258121, 0.475026);\n\nline_to(  0.018437, 0.475026);\n\nline_to(  0.018437, 0.552549);\n\nline_to(  0.284460, 0.552549);\n\nline_to(  0.360843, 0.775754);\n\nline_to(  0.492537, 0.775754);\n\nline_to(  0.416155, 0.552549);\n\nline_to(  0.692713, 0.552549);\n\nline_to(  0.769096, 0.775754);\n\nline_to(  0.901668, 0.775754);\n\nline_to(  0.825285, 0.552549);\n\nline_to(  0.977173, 0.552549);\n\nline_to(  0.977173, 0.475026);\n\nline_to(  0.798946, 0.475026);\n\nline_to(  0.733099, 0.286160);\n\nline_to(  0.977173, 0.286160);\n\nline_to(  0.977173, 0.208637);\n\nline_to(  0.706760, 0.208637);\n\nline_to(  0.630378, -0.013007);\n\nline_to(  0.498683, -0.013007);\n\nline_to(  0.574188, 0.208637);\n\nline_to(  0.298507, 0.208637);\n\nline_to(  0.222125, -0.013007);\n\nline_to(  0.090430, -0.013007);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.324846, 0.286160);\n\nline_to(  0.600527, 0.286160);\n\nline_to(  0.666374, 0.475026);\n\nline_to(  0.389816, 0.475026);\n\nline_to(  0.324846, 0.286160);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show36(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.447761, -0.109781);\n\nline_to(  0.447761, -0.016129);\n\ncurve_to( 0.329236, -0.007284, 0.254609,  0.015088);\ncurve_to( 0.180860, 0.037981, 0.126427,  0.088450);\ncurve_to(  0.072871,  0.138918, 0.064091, 0.211759);\nline_to(  0.223003, 0.229448);\n\ncurve_to(  0.241440,  0.154006, 0.287972, 0.118626);\ncurve_to(  0.354697,  0.068678, 0.447761, 0.062955);\nline_to(  0.447761, 0.361082);\n\ncurve_to(  0.350307,  0.372008, 0.248464, 0.405827);\ncurve_to( 0.172959, 0.430801, 0.131694,  0.475026);\ncurve_to(  0.091308,  0.519251, 0.091308, 0.575442);\ncurve_to(  0.091308,  0.675338, 0.210711, 0.737253);\ncurve_to(  0.290606,  0.778876, 0.447761, 0.788241);\nline_to(  0.447761, 0.832986);\n\nline_to(  0.540825, 0.832986);\n\nline_to(  0.540825, 0.788241);\n\ncurve_to(  0.678666,  0.780437, 0.759438, 0.740375);\ncurve_to(  0.863038,  0.689386, 0.884109, 0.600416);\nline_to(  0.720808, 0.585848);\n\ncurve_to( 0.706760, 0.640999, 0.661984,  0.670135);\ncurve_to(  0.618086,  0.699792, 0.540825, 0.709157);\nline_to(  0.540825, 0.439126);\n\ncurve_to(  0.660228,  0.421436, 0.698859, 0.411550);\ncurve_to( 0.772608, 0.392300, 0.819140,  0.364724);\ncurve_to( 0.865672, 0.337149, 0.890255,  0.299168);\ncurve_to(  0.915716,  0.261186, 0.915716, 0.216962);\ncurve_to( 0.915716, 0.119667, 0.811238,  0.054631);\ncurve_to(  0.706760,  -0.010406, 0.540825, -0.015088);\nline_to(  0.540825, -0.109781);\n\nline_to(  0.447761, -0.109781);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.447761, 0.710198);\n\ncurve_to( 0.355575, 0.701873, 0.302019,  0.666493);\ncurve_to(  0.249342,  0.631113, 0.249342, 0.582726);\ncurve_to( 0.249342, 0.534860, 0.294118,  0.502601);\ncurve_to(  0.339772,  0.470343, 0.447761, 0.451093);\nline_to(  0.447761, 0.710198);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.540825, 0.062955);\n\ncurve_to( 0.633011, 0.069719, 0.692713,  0.110302);\ncurve_to(  0.753292,  0.150884, 0.753292, 0.210718);\ncurve_to( 0.753292, 0.261707, 0.710272,  0.292404);\ncurve_to(  0.668130,  0.323621, 0.540825, 0.348075);\nline_to(  0.540825, 0.062955);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show37(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1821height: 1922\nmove_to( 0.065349, 0.579605);\n\ncurve_to( 0.065349, 0.661290, 0.108731,  0.718522);\ncurve_to(  0.152114,  0.775754, 0.234487, 0.775754);\ncurve_to( 0.310269, 0.775754, 0.359692,  0.724246);\ncurve_to(  0.409665,  0.673257, 0.409665, 0.573881);\ncurve_to( 0.409665, 0.477107, 0.359143,  0.424558);\ncurve_to(  0.309171,  0.372529, 0.235585, 0.372529);\ncurve_to( 0.162548, 0.372529, 0.113674,  0.424037);\ncurve_to(  0.065349,  0.475546, 0.065349, 0.579605);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.237232, 0.711238);\n\ncurve_to( 0.200439, 0.711238, 0.175728,  0.681061);\ncurve_to(  0.151565,  0.650885, 0.151565, 0.570239);\ncurve_to( 0.151565, 0.496878, 0.176277,  0.466701);\ncurve_to(  0.200988,  0.437045, 0.237232, 0.437045);\ncurve_to( 0.274574, 0.437045, 0.298737,  0.467222);\ncurve_to(  0.323449,  0.497399, 0.323449, 0.577523);\ncurve_to( 0.323449, 0.651405, 0.298737,  0.681061);\ncurve_to(  0.274025,  0.711238, 0.237232, 0.711238);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.237781, -0.028096);\n\nline_to(  0.678199, 0.775754);\n\nline_to(  0.758375, 0.775754);\n\nline_to(  0.319605, -0.028096);\n\nline_to(  0.237781, -0.028096);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.585942, 0.178980);\n\ncurve_to( 0.585942, 0.261186, 0.629325,  0.317898);\ncurve_to(  0.672707,  0.375130, 0.755629, 0.375130);\ncurve_to( 0.831411, 0.375130, 0.880835,  0.323621);\ncurve_to(  0.930807,  0.272633, 0.930807, 0.173257);\ncurve_to( 0.930807, 0.076483, 0.880286,  0.023933);\ncurve_to(  0.830313,  -0.028096, 0.756178, -0.028096);\ncurve_to( 0.683141, -0.028096, 0.634267,  0.023413);\ncurve_to(  0.585942,  0.075442, 0.585942, 0.178980);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.758375, 0.310614);\n\ncurve_to( 0.721032, 0.310614, 0.696321,  0.280437);\ncurve_to(  0.672158,  0.250260, 0.672158, 0.169615);\ncurve_to( 0.672158, 0.096774, 0.696870,  0.066597);\ncurve_to(  0.721582,  0.036420, 0.757825, 0.036420);\ncurve_to( 0.795717, 0.036420, 0.819879,  0.066597);\ncurve_to(  0.844591,  0.096774, 0.844591, 0.176899);\ncurve_to( 0.844591, 0.250780, 0.819879,  0.280437);\ncurve_to(  0.795168,  0.310614, 0.758375, 0.310614);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show38(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1366height: 1922\nmove_to( 0.712299, 0.090010);\n\ncurve_to( 0.647145, 0.038502, 0.570278,  0.012487);\ncurve_to(  0.493411,  -0.013007, 0.404100, -0.013007);\ncurve_to(  0.239385,  -0.013007, 0.142753, 0.066077);\ncurve_to(  0.064422,  0.130593, 0.064422, 0.210198);\ncurve_to( 0.064422, 0.280957, 0.128111,  0.337669);\ncurve_to(  0.192533,  0.394901, 0.319912, 0.438085);\ncurve_to( 0.247438, 0.497399, 0.223280,  0.534339);\ncurve_to(  0.199122,  0.571280, 0.199122, 0.605619);\ncurve_to( 0.199122, 0.674298, 0.274524,  0.724766);\ncurve_to(  0.350659,  0.775754, 0.465593, 0.775754);\ncurve_to( 0.575403, 0.775754, 0.644949,  0.727888);\ncurve_to(  0.715227,  0.680021, 0.715227, 0.612903);\ncurve_to(  0.715227,  0.504162, 0.512445, 0.427159);\nline_to(  0.704978, 0.252862);\n\ncurve_to(  0.737921,  0.298647, 0.756223, 0.359001);\nline_to(  0.893119, 0.338189);\n\ncurve_to(  0.857979,  0.238293, 0.797950, 0.173777);\ncurve_to(  0.871889,  0.104058, 0.965593, 0.056712);\nline_to(  0.877013, -0.017690);\n\ncurve_to(  0.797218,  0.018730, 0.712299, 0.090010);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.444363, 0.487513);\n\ncurve_to( 0.530015, 0.523413, 0.554905,  0.550468);\ncurve_to(  0.580527,  0.577523, 0.580527, 0.610302);\ncurve_to( 0.580527, 0.649324, 0.545388,  0.673777);\ncurve_to(  0.510981,  0.698751, 0.459004, 0.698751);\ncurve_to( 0.405564, 0.698751, 0.369693,  0.674298);\ncurve_to(  0.334553,  0.649844, 0.334553, 0.614464);\ncurve_to( 0.334553, 0.596774, 0.346999,  0.577003);\ncurve_to(  0.360176,  0.557752, 0.385798, 0.535900);\nline_to(  0.444363, 0.487513);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.629575, 0.163892);\n\nline_to(  0.387994, 0.376691);\n\ncurve_to( 0.281113, 0.331426, 0.243777,  0.292404);\ncurve_to(  0.206442,  0.253902, 0.206442, 0.215921);\ncurve_to( 0.206442, 0.169615, 0.258419,  0.119667);\ncurve_to(  0.310395,  0.069719, 0.405564, 0.069719);\ncurve_to( 0.464861, 0.069719, 0.527818,  0.095734);\ncurve_to(  0.591508,  0.122268, 0.629575, 0.163892);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show39(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 391height: 1922\nmove_to( 0.347826, 0.492716);\n\nline_to(  0.230179, 0.635276);\n\nline_to(  0.230179, 0.762747);\n\nline_to(  0.754476, 0.762747);\n\nline_to(  0.754476, 0.635276);\n\nline_to(  0.631714, 0.492716);\n\nline_to(  0.347826, 0.492716);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show40(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 682height: 1922\nmove_to( 0.702346, -0.224246);\n\ncurve_to( 0.483871, -0.126431, 0.332845,  0.004683);\ncurve_to(  0.181818,  0.135796, 0.181818, 0.276275);\ncurve_to(  0.181818,  0.400104, 0.294721, 0.513528);\ncurve_to(  0.426686,  0.645161, 0.702346, 0.775754);\nline_to(  0.891496, 0.775754);\n\ncurve_to(  0.714076,  0.667534, 0.656892, 0.621228);\ncurve_to(  0.567449,  0.549428, 0.516129, 0.471384);\ncurve_to(  0.453079,  0.374089, 0.453079, 0.275754);\ncurve_to(  0.453079,  0.025494, 0.891496, -0.224246);\nline_to(  0.702346, -0.224246);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show41(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 682height: 1922\nmove_to( 0.370968, -0.224246);\n\nline_to(  0.181818, -0.224246);\n\ncurve_to(  0.620235,  0.025494, 0.620235, 0.275754);\ncurve_to(  0.620235,  0.373569, 0.557185, 0.469823);\ncurve_to(  0.507331,  0.547867, 0.417889, 0.619667);\ncurve_to(  0.360704,  0.666493, 0.181818, 0.775754);\nline_to(  0.370968, 0.775754);\n\ncurve_to(  0.646628,  0.645161, 0.778592, 0.513528);\ncurve_to(  0.891496,  0.400104, 0.891496, 0.276275);\ncurve_to( 0.891496, 0.135796, 0.739003,  0.004683);\ncurve_to(  0.587977,  -0.126431, 0.370968, -0.224246);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show42(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 797height: 1922\nmove_to( 0.080301, 0.622789);\n\nline_to(  0.138018, 0.696670);\n\ncurve_to(  0.337516,  0.667534, 0.427854, 0.646202);\ncurve_to(  0.404015,  0.740375, 0.402760, 0.775754);\nline_to(  0.584693, 0.775754);\n\ncurve_to(  0.580929,  0.724246, 0.555834, 0.646722);\ncurve_to(  0.685069,  0.673777, 0.851945, 0.696670);\nline_to(  0.909661, 0.622789);\n\ncurve_to(  0.750314,  0.600937, 0.597240, 0.593652);\ncurve_to(  0.673777,  0.566077, 0.813049, 0.495317);\nline_to(  0.662484, 0.451093);\n\ncurve_to(  0.589711,  0.492196, 0.490590, 0.562955);\ncurve_to(  0.397742,  0.489594, 0.327478, 0.451093);\nline_to(  0.179423, 0.495317);\n\ncurve_to(  0.324969,  0.569719, 0.387704, 0.593652);\ncurve_to(  0.225847,  0.606660, 0.080301, 0.622789);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show43(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1196height: 1922\nmove_to( 0.428930, 0.123309);\n\nline_to(  0.428930, 0.332466);\n\nline_to(  0.095318, 0.332466);\n\nline_to(  0.095318, 0.419875);\n\nline_to(  0.428930, 0.419875);\n\nline_to(  0.428930, 0.627471);\n\nline_to(  0.571070, 0.627471);\n\nline_to(  0.571070, 0.419875);\n\nline_to(  0.904682, 0.419875);\n\nline_to(  0.904682, 0.332466);\n\nline_to(  0.571070, 0.332466);\n\nline_to(  0.571070, 0.123309);\n\nline_to(  0.428930, 0.123309);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show44(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.319859, 0.000000);\n\nline_to(  0.319859, 0.106660);\n\nline_to(  0.680141, 0.106660);\n\nline_to(  0.680141, 0.000000);\n\ncurve_to( 0.680141, -0.058793, 0.609842,  -0.094693);\ncurve_to(  0.539543,  -0.131113, 0.386643, -0.150884);\nline_to(  0.298770, -0.110822);\n\ncurve_to( 0.398946, -0.097815, 0.446397,  -0.072320);\ncurve_to(  0.493849,  -0.047347, 0.499121, 0.000000);\nline_to(  0.319859, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show45(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 682height: 1922\nmove_to( 0.095308, 0.228928);\n\nline_to(  0.095308, 0.323101);\n\nline_to(  0.906158, 0.323101);\n\nline_to(  0.906158, 0.228928);\n\nline_to(  0.095308, 0.228928);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show46(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.326889, 0.000000);\n\nline_to(  0.326889, 0.106660);\n\nline_to(  0.687170, 0.106660);\n\nline_to(  0.687170, 0.000000);\n\nline_to(  0.326889, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show47(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.000000, -0.013007);\n\nline_to(  0.746924, 0.775754);\n\nline_to(  1.000000, 0.775754);\n\nline_to(  0.254833, -0.013007);\n\nline_to(  0.000000, -0.013007);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show48(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.074627, 0.376171);\n\ncurve_to( 0.074627, 0.511446, 0.121159,  0.593652);\ncurve_to( 0.168569, 0.676379, 0.260755,  0.721124);\ncurve_to(  0.353819,  0.765869, 0.494293, 0.765869);\ncurve_to( 0.597893, 0.765869, 0.676032,  0.740895);\ncurve_to( 0.754170, 0.716441, 0.805092,  0.669615);\ncurve_to( 0.856014, 0.623309, 0.884987,  0.556191);\ncurve_to(  0.913960,  0.489594, 0.913960, 0.376171);\ncurve_to( 0.913960, 0.241935, 0.867428,  0.159209);\ncurve_to( 0.820895, 0.077003, 0.727831,  0.031738);\ncurve_to(  0.635645,  -0.013007, 0.494293, -0.013007);\ncurve_to(  0.308165,  -0.013007, 0.201932, 0.066077);\ncurve_to(  0.074627,  0.161290, 0.074627, 0.376171);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.237050, 0.376171);\n\ncurve_to( 0.237050, 0.188345, 0.310799,  0.125911);\ncurve_to(  0.385426,  0.063996, 0.494293, 0.063996);\ncurve_to( 0.603161, 0.063996, 0.676910,  0.126431);\ncurve_to(  0.751536,  0.188866, 0.751536, 0.376171);\ncurve_to( 0.751536, 0.564516, 0.676910,  0.626431);\ncurve_to(  0.603161,  0.688345, 0.492537, 0.688345);\ncurve_to(  0.383670,  0.688345, 0.318701, 0.633715);\ncurve_to(  0.237050,  0.563996, 0.237050, 0.376171);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show49(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.669886, 0.000000);\n\nline_to(  0.511853, 0.000000);\n\nline_to(  0.511853, 0.596774);\n\ncurve_to( 0.454785, 0.564516, 0.361721,  0.532258);\ncurve_to(  0.269535,  0.500000, 0.195786, 0.483871);\nline_to(  0.195786, 0.574402);\n\ncurve_to( 0.328358, 0.611342, 0.427568,  0.663892);\ncurve_to(  0.526778,  0.716441, 0.568042, 0.765869);\nline_to(  0.669886, 0.765869);\n\nline_to(  0.669886, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show50(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.905180, 0.090010);\n\nline_to(  0.905180, 0.000000);\n\nline_to(  0.054434, 0.000000);\n\ncurve_to(  0.052678,  0.033819, 0.072871, 0.065036);\ncurve_to( 0.105356, 0.116545, 0.176471,  0.166493);\ncurve_to(  0.248464,  0.216441, 0.383670, 0.281998);\ncurve_to( 0.593503, 0.383975, 0.667252,  0.443288);\ncurve_to(  0.741001,  0.503122, 0.741001, 0.556191);\ncurve_to( 0.741001, 0.611863, 0.673398,  0.649844);\ncurve_to(  0.606673,  0.688345, 0.498683, 0.688345);\ncurve_to( 0.384548, 0.688345, 0.316067,  0.647763);\ncurve_to(  0.247586,  0.607180, 0.246708, 0.535380);\nline_to(  0.084284, 0.545265);\n\ncurve_to( 0.100966, 0.652966, 0.209833,  0.709157);\ncurve_to(  0.318701,  0.765869, 0.502195, 0.765869);\ncurve_to( 0.687445, 0.765869, 0.795435,  0.704995);\ncurve_to(  0.903424,  0.644121, 0.903424, 0.554110);\ncurve_to( 0.903424, 0.508325, 0.871817,  0.464100);\ncurve_to( 0.840211, 0.419875, 0.766462,  0.370968);\ncurve_to(  0.693591,  0.322060, 0.523266, 0.236733);\ncurve_to( 0.381036, 0.165973, 0.340650,  0.140479);\ncurve_to(  0.300263,  0.115505, 0.273924, 0.090010);\nline_to(  0.905180, 0.090010);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show51(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.075505, 0.201353);\n\nline_to(  0.233538, 0.213840);\n\ncurve_to( 0.260755, 0.134235, 0.325724,  0.098855);\ncurve_to(  0.391572,  0.063996, 0.485514, 0.063996);\ncurve_to( 0.597015, 0.063996, 0.673398,  0.109781);\ncurve_to(  0.750658,  0.155567, 0.750658, 0.223205);\ncurve_to( 0.750658, 0.287721, 0.679543,  0.329344);\ncurve_to(  0.608428,  0.371488, 0.498683, 0.371488);\ncurve_to(  0.453907,  0.371488, 0.387182, 0.361082);\nline_to(  0.404741, 0.443288);\n\ncurve_to(  0.420544,  0.442248, 0.430202, 0.442248);\ncurve_to( 0.531168, 0.442248, 0.611940,  0.473465);\ncurve_to(  0.692713,  0.504683, 0.692713, 0.569719);\ncurve_to( 0.692713, 0.621228, 0.633889,  0.655047);\ncurve_to(  0.575066,  0.688866, 0.482002, 0.688866);\ncurve_to( 0.389816, 0.688866, 0.328358,  0.654527);\ncurve_to(  0.266901,  0.620187, 0.249342, 0.551509);\nline_to(  0.091308, 0.568158);\n\ncurve_to( 0.120281, 0.662331, 0.223003,  0.713840);\ncurve_to(  0.325724,  0.765869, 0.478490, 0.765869);\ncurve_to( 0.583845, 0.765869, 0.672520,  0.738814);\ncurve_to( 0.761194, 0.712279, 0.807726,  0.665973);\ncurve_to(  0.855136,  0.619667, 0.855136, 0.567638);\ncurve_to( 0.855136, 0.518210, 0.810360,  0.477627);\ncurve_to(  0.765584,  0.437045, 0.677788, 0.413111);\ncurve_to( 0.791923, 0.397503, 0.855136,  0.348075);\ncurve_to(  0.918349,  0.299168, 0.918349, 0.225286);\ncurve_to( 0.918349, 0.125390, 0.795435,  0.055671);\ncurve_to(  0.672520,  -0.013528, 0.484636, -0.013528);\ncurve_to( 0.315189, -0.013528, 0.202809,  0.046306);\ncurve_to(  0.091308,  0.106139, 0.075505, 0.201353);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show52(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.581212, 0.000000);\n\nline_to(  0.581212, 0.182622);\n\nline_to(  0.022827, 0.182622);\n\nline_to(  0.022827, 0.268470);\n\nline_to(  0.610184, 0.762747);\n\nline_to(  0.739245, 0.762747);\n\nline_to(  0.739245, 0.268470);\n\nline_to(  0.913082, 0.268470);\n\nline_to(  0.913082, 0.182622);\n\nline_to(  0.739245, 0.182622);\n\nline_to(  0.739245, 0.000000);\n\nline_to(  0.581212, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.581212, 0.268470);\n\nline_to(  0.581212, 0.612383);\n\nline_to(  0.178227, 0.268470);\n\nline_to(  0.581212, 0.268470);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show53(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.074627, 0.199792);\n\nline_to(  0.240562, 0.208117);\n\ncurve_to( 0.258999, 0.136316, 0.325724,  0.099896);\ncurve_to(  0.393327,  0.063996, 0.488147, 0.063996);\ncurve_to( 0.602283, 0.063996, 0.681299,  0.114984);\ncurve_to(  0.760316,  0.165973, 0.760316, 0.250260);\ncurve_to( 0.760316, 0.330385, 0.683933,  0.376691);\ncurve_to(  0.608428,  0.422997, 0.485514, 0.422997);\ncurve_to( 0.409131, 0.422997, 0.347673,  0.402185);\ncurve_to(  0.286216,  0.381894, 0.251097, 0.349115);\nline_to(  0.102722, 0.360562);\n\nline_to(  0.227392, 0.752341);\n\nline_to(  0.867428, 0.752341);\n\nline_to(  0.867428, 0.662851);\n\nline_to(  0.353819, 0.662851);\n\nline_to(  0.284460, 0.457856);\n\ncurve_to(  0.400351,  0.505723, 0.527656, 0.505723);\ncurve_to( 0.696225, 0.505723, 0.812116,  0.436524);\ncurve_to(  0.928007,  0.367326, 0.928007, 0.258585);\ncurve_to(  0.928007,  0.155047, 0.826163, 0.079605);\ncurve_to(  0.702371,  -0.013007, 0.488147, -0.013007);\ncurve_to( 0.312555, -0.013007, 0.201054,  0.045265);\ncurve_to(  0.090430,  0.103538, 0.074627, 0.199792);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show54(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.894644, 0.575963);\n\nline_to(  0.737489, 0.568678);\n\ncurve_to(  0.716418,  0.623829, 0.677788, 0.648803);\ncurve_to(  0.613696,  0.688866, 0.519754, 0.688866);\ncurve_to(  0.444249,  0.688866, 0.387182, 0.663892);\ncurve_to( 0.312555, 0.631634, 0.269535,  0.569719);\ncurve_to(  0.226514,  0.507804, 0.224759, 0.393340);\ncurve_to( 0.281826, 0.444849, 0.364355,  0.469823);\ncurve_to(  0.446883,  0.494797, 0.537313, 0.494797);\ncurve_to( 0.695347, 0.494797, 0.805970,  0.425598);\ncurve_to(  0.917471,  0.356920, 0.917471, 0.247659);\ncurve_to( 0.917471, 0.175858, 0.864794,  0.113944);\ncurve_to( 0.812994, 0.052549, 0.721686,  0.019771);\ncurve_to(  0.630378,  -0.013007, 0.514486, -0.013007);\ncurve_to( 0.316945, -0.013007, 0.192274,  0.072841);\ncurve_to(  0.067603,  0.159209, 0.067603, 0.356920);\ncurve_to(  0.067603,  0.578044, 0.205443, 0.678460);\ncurve_to(  0.325724,  0.765869, 0.529412, 0.765869);\ncurve_to( 0.681299, 0.765869, 0.777875,  0.715401);\ncurve_to(  0.875329,  0.664932, 0.894644, 0.575963);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.249342, 0.247138);\n\ncurve_to( 0.249342, 0.198751, 0.283582,  0.154527);\ncurve_to( 0.318701, 0.110302, 0.381036,  0.086889);\ncurve_to(  0.443371,  0.063996, 0.511853, 0.063996);\ncurve_to( 0.611940, 0.063996, 0.683933,  0.111863);\ncurve_to(  0.755926,  0.159729, 0.755926, 0.241935);\ncurve_to( 0.755926, 0.321020, 0.684811,  0.366285);\ncurve_to(  0.613696,  0.412071, 0.505707, 0.412071);\ncurve_to( 0.398595, 0.412071, 0.323968,  0.366285);\ncurve_to(  0.249342,  0.321020, 0.249342, 0.247138);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show55(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.085162, 0.662851);\n\nline_to(  0.085162, 0.752862);\n\nline_to(  0.918349, 0.752862);\n\nline_to(  0.918349, 0.680021);\n\ncurve_to( 0.795435, 0.602497, 0.674276,  0.473985);\ncurve_to(  0.553995,  0.345473, 0.488147, 0.209677);\ncurve_to(  0.440737,  0.113944, 0.427568, 0.000000);\nline_to(  0.265145, 0.000000);\n\ncurve_to( 0.267779, 0.090010, 0.324846,  0.217482);\ncurve_to( 0.381914, 0.344953, 0.488147,  0.463059);\ncurve_to(  0.595259,  0.581686, 0.715540, 0.662851);\nline_to(  0.085162, 0.662851);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show56(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.317823, 0.413632);\n\ncurve_to( 0.219491, 0.434964, 0.172081,  0.474506);\ncurve_to(  0.124671,  0.514048, 0.124671, 0.569199);\ncurve_to( 0.124671, 0.652445, 0.225637,  0.709157);\ncurve_to(  0.326602,  0.765869, 0.494293, 0.765869);\ncurve_to( 0.662862, 0.765869, 0.765584,  0.707596);\ncurve_to(  0.868306,  0.649844, 0.868306, 0.566597);\ncurve_to( 0.868306, 0.513528, 0.820895,  0.473985);\ncurve_to(  0.774363,  0.434964, 0.678666, 0.413632);\ncurve_to( 0.797191, 0.390739, 0.858648,  0.339750);\ncurve_to(  0.920983,  0.288762, 0.920983, 0.218002);\ncurve_to( 0.920983, 0.120187, 0.804214,  0.053590);\ncurve_to(  0.687445,  -0.013007, 0.496927, -0.013007);\ncurve_to( 0.306409, -0.013007, 0.189640,  0.053590);\ncurve_to(  0.072871,  0.120708, 0.072871, 0.220604);\ncurve_to( 0.072871, 0.295005, 0.136084,  0.344953);\ncurve_to(  0.200176,  0.395421, 0.317823, 0.413632);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.286216, 0.572321);\n\ncurve_to( 0.286216, 0.518210, 0.345040,  0.483871);\ncurve_to(  0.403863,  0.449532, 0.497805, 0.449532);\ncurve_to( 0.589113, 0.449532, 0.647059,  0.483351);\ncurve_to(  0.705882,  0.517690, 0.705882, 0.567118);\ncurve_to( 0.705882, 0.618626, 0.645303,  0.653486);\ncurve_to(  0.585601,  0.688866, 0.496049, 0.688866);\ncurve_to( 0.405619, 0.688866, 0.345917,  0.654527);\ncurve_to(  0.286216,  0.620187, 0.286216, 0.572321);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.235294, 0.220083);\n\ncurve_to( 0.235294, 0.180021, 0.266901,  0.142560);\ncurve_to( 0.299385, 0.105099, 0.362599,  0.084287);\ncurve_to(  0.425812,  0.063996, 0.498683, 0.063996);\ncurve_to( 0.611940, 0.063996, 0.685689,  0.107180);\ncurve_to(  0.759438,  0.150364, 0.759438, 0.216962);\ncurve_to( 0.759438, 0.284599, 0.683055,  0.328824);\ncurve_to(  0.607551,  0.373049, 0.493415, 0.373049);\ncurve_to( 0.381914, 0.373049, 0.308165,  0.329344);\ncurve_to(  0.235294,  0.285640, 0.235294, 0.220083);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show57(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.098332, 0.176379);\n\nline_to(  0.250219, 0.184703);\n\ncurve_to( 0.269535, 0.121228, 0.323968,  0.092612);\ncurve_to(  0.378402,  0.063996, 0.463565, 0.063996);\ncurve_to( 0.536435, 0.063996, 0.590869,  0.083767);\ncurve_to( 0.646181, 0.103538, 0.681299,  0.136316);\ncurve_to( 0.716418, 0.169615, 0.740123,  0.225806);\ncurve_to(  0.763828,  0.281998, 0.763828, 0.340271);\ncurve_to(  0.763828,  0.346514, 0.762950, 0.359001);\ncurve_to( 0.715540, 0.314256, 0.633011,  0.286160);\ncurve_to(  0.551361,  0.258585, 0.455663, 0.258585);\ncurve_to( 0.295874, 0.258585, 0.185250,  0.327263);\ncurve_to(  0.074627,  0.395942, 0.074627, 0.508325);\ncurve_to( 0.074627, 0.624350, 0.189640,  0.695109);\ncurve_to(  0.305531,  0.765869, 0.479368, 0.765869);\ncurve_to( 0.604917, 0.765869, 0.708516,  0.725806);\ncurve_to( 0.812994, 0.685744, 0.866550,  0.611342);\ncurve_to(  0.920983,  0.537461, 0.920983, 0.396982);\ncurve_to( 0.920983, 0.250780, 0.867428,  0.163892);\ncurve_to( 0.813872, 0.077523, 0.707638,  0.032258);\ncurve_to(  0.602283,  -0.013007, 0.460053, -0.013007);\ncurve_to( 0.309043, -0.013007, 0.213345,  0.036420);\ncurve_to(  0.117647,  0.086368, 0.098332, 0.176379);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.745391, 0.513007);\n\ncurve_to( 0.745391, 0.593652, 0.672520,  0.640999);\ncurve_to(  0.600527,  0.688345, 0.498683, 0.688345);\ncurve_to( 0.393327, 0.688345, 0.315189,  0.637357);\ncurve_to(  0.237050,  0.586368, 0.237050, 0.505203);\ncurve_to( 0.237050, 0.432362, 0.310799,  0.386576);\ncurve_to(  0.385426,  0.341311, 0.494293, 0.341311);\ncurve_to( 0.604039, 0.341311, 0.674276,  0.386576);\ncurve_to(  0.745391,  0.432362, 0.745391, 0.513007);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show58(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.325132, 0.445890);\n\nline_to(  0.325132, 0.552549);\n\nline_to(  0.685413, 0.552549);\n\nline_to(  0.685413, 0.445890);\n\nline_to(  0.325132, 0.445890);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.325132, 0.000000);\n\nline_to(  0.325132, 0.106660);\n\nline_to(  0.685413, 0.106660);\n\nline_to(  0.685413, 0.000000);\n\nline_to(  0.325132, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show59(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.319859, 0.445890);\n\nline_to(  0.319859, 0.552549);\n\nline_to(  0.680141, 0.552549);\n\nline_to(  0.680141, 0.445890);\n\nline_to(  0.319859, 0.445890);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.319859, 0.000000);\n\nline_to(  0.319859, 0.106660);\n\nline_to(  0.680141, 0.106660);\n\nline_to(  0.680141, 0.000000);\n\ncurve_to( 0.680141, -0.058793, 0.609842,  -0.094693);\ncurve_to(  0.539543,  -0.131113, 0.386643, -0.150884);\nline_to(  0.298770, -0.110822);\n\ncurve_to( 0.398946, -0.097815, 0.446397,  -0.072320);\ncurve_to(  0.493849,  -0.047347, 0.499121, 0.000000);\nline_to(  0.319859, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show60(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1196height: 1922\nmove_to( 0.093645, 0.333507);\n\nline_to(  0.093645, 0.420916);\n\nline_to(  0.905518, 0.634235);\n\nline_to(  0.905518, 0.541103);\n\nline_to(  0.261706, 0.376691);\n\nline_to(  0.905518, 0.210718);\n\nline_to(  0.905518, 0.117586);\n\nline_to(  0.093645, 0.333507);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show61(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1196height: 1922\nmove_to( 0.904682, 0.448491);\n\nline_to(  0.095318, 0.448491);\n\nline_to(  0.095318, 0.535900);\n\nline_to(  0.904682, 0.535900);\n\nline_to(  0.904682, 0.448491);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.904682, 0.216962);\n\nline_to(  0.095318, 0.216962);\n\nline_to(  0.095318, 0.304370);\n\nline_to(  0.904682, 0.304370);\n\nline_to(  0.904682, 0.216962);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show62(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1196height: 1922\nmove_to( 0.905518, 0.333507);\n\nline_to(  0.093645, 0.117586);\n\nline_to(  0.093645, 0.210718);\n\nline_to(  0.736622, 0.376691);\n\nline_to(  0.093645, 0.541103);\n\nline_to(  0.093645, 0.634235);\n\nline_to(  0.905518, 0.420916);\n\nline_to(  0.905518, 0.333507);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show63(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.414399, 0.187825);\n\ncurve_to(  0.413521,  0.206556, 0.413521, 0.215921);\ncurve_to(  0.413521,  0.271072, 0.439860, 0.311134);\ncurve_to(  0.459175,  0.341311, 0.502195, 0.372008);\ncurve_to( 0.533802, 0.394381, 0.615452,  0.437045);\ncurve_to( 0.697981, 0.480229, 0.722564,  0.505723);\ncurve_to(  0.747147,  0.531217, 0.747147, 0.561394);\ncurve_to( 0.747147, 0.616025, 0.675154,  0.657128);\ncurve_to(  0.603161,  0.698751, 0.498683, 0.698751);\ncurve_to( 0.397717, 0.698751, 0.330114,  0.661290);\ncurve_to(  0.262511,  0.623829, 0.241440, 0.544225);\nline_to(  0.079017, 0.555671);\n\ncurve_to( 0.100966, 0.662331, 0.208955,  0.719043);\ncurve_to(  0.317823,  0.775754, 0.496049, 0.775754);\ncurve_to( 0.684811, 0.775754, 0.797191,  0.714880);\ncurve_to(  0.909570,  0.654006, 0.909570, 0.567638);\ncurve_to( 0.909570, 0.517690, 0.870061,  0.475546);\ncurve_to(  0.830553,  0.433403, 0.715540, 0.373049);\ncurve_to( 0.638279, 0.332466, 0.614574,  0.313215);\ncurve_to( 0.590869, 0.293965, 0.579456,  0.268991);\ncurve_to(  0.568042,  0.244017, 0.566286, 0.187825);\nline_to(  0.414399, 0.187825);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.404741, 0.000000);\n\nline_to(  0.404741, 0.106660);\n\nline_to(  0.584723, 0.106660);\n\nline_to(  0.584723, 0.000000);\n\nline_to(  0.404741, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show64(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 2079height: 1922\nmove_to( 0.558442, 0.084807);\n\ncurve_to( 0.527176, 0.045786, 0.488215,  0.021852);\ncurve_to(  0.449735,  -0.001561, 0.410774, -0.001561);\ncurve_to( 0.367965, -0.001561, 0.327561,  0.025494);\ncurve_to( 0.287157, 0.052549, 0.261664,  0.108741);\ncurve_to(  0.236652,  0.164932, 0.236652, 0.232050);\ncurve_to( 0.236652, 0.314776, 0.275613,  0.397503);\ncurve_to( 0.315055, 0.480749, 0.373256,  0.522373);\ncurve_to(  0.431457,  0.563996, 0.486291, 0.563996);\ncurve_to( 0.528139, 0.563996, 0.566138,  0.540062);\ncurve_to(  0.604137,  0.516649, 0.631554, 0.468262);\nline_to(  0.647908, 0.548907);\n\nline_to(  0.734007, 0.548907);\n\nline_to(  0.664743, 0.199792);\n\ncurve_to(  0.650313,  0.126951, 0.650313, 0.119147);\ncurve_to( 0.650313, 0.105099, 0.659933,  0.094693);\ncurve_to(  0.670034,  0.084807, 0.683983, 0.084807);\ncurve_to(  0.709476,  0.084807, 0.750842, 0.116545);\ncurve_to( 0.805676, 0.158169, 0.837422,  0.227888);\ncurve_to(  0.869649,  0.298127, 0.869649, 0.372529);\ncurve_to( 0.869649, 0.459417, 0.828283,  0.534860);\ncurve_to( 0.787398, 0.610302, 0.705628,  0.655567);\ncurve_to(  0.624339,  0.700832, 0.525734, 0.700832);\ncurve_to( 0.413179, 0.700832, 0.319865,  0.643600);\ncurve_to( 0.227032, 0.586889, 0.175565,  0.480229);\ncurve_to(  0.124579,  0.374089, 0.124579, 0.252341);\ncurve_to( 0.124579, 0.124870, 0.175565,  0.032778);\ncurve_to( 0.227032, -0.059313, 0.323713,  -0.103018);\ncurve_to(  0.420875,  -0.147242, 0.538721, -0.147242);\ncurve_to( 0.664743, -0.147242, 0.749880,  -0.101457);\ncurve_to(  0.835017,  -0.055671, 0.877345, 0.009886);\nline_to(  0.964406, 0.009886);\n\ncurve_to( 0.939875, -0.044745, 0.880231,  -0.101457);\ncurve_to( 0.820587, -0.158169, 0.738336,  -0.190947);\ncurve_to(  0.656085,  -0.224246, 0.540164, -0.224246);\ncurve_to( 0.433381, -0.224246, 0.342953,  -0.194589);\ncurve_to( 0.253006, -0.164932, 0.189514,  -0.105099);\ncurve_to(  0.126022,  -0.045786, 0.093795, 0.031738);\ncurve_to(  0.053391,  0.130073, 0.053391, 0.244017);\ncurve_to(  0.053391,  0.370968, 0.101491, 0.485952);\ncurve_to( 0.160173, 0.626951, 0.267917,  0.701873);\ncurve_to(  0.376142,  0.776795, 0.530063, 0.776795);\ncurve_to( 0.649351, 0.776795, 0.744108,  0.723725);\ncurve_to(  0.839346,  0.671176, 0.894180, 0.566597);\ncurve_to(  0.940837,  0.476587, 0.940837, 0.370968);\ncurve_to(  0.940837,  0.220083, 0.842713, 0.103018);\ncurve_to(  0.755171,  -0.002081, 0.651275, -0.002081);\ncurve_to( 0.618086, -0.002081, 0.597403,  0.008845);\ncurve_to(  0.577201,  0.019771, 0.567581, 0.040062);\ncurve_to(  0.561328,  0.053070, 0.558442, 0.084807);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.325637, 0.225806);\n\ncurve_to( 0.325637, 0.154527, 0.356902,  0.114984);\ncurve_to(  0.388167,  0.075442, 0.428571, 0.075442);\ncurve_to( 0.455507, 0.075442, 0.485329,  0.092612);\ncurve_to( 0.515152, 0.110302, 0.542088,  0.144641);\ncurve_to( 0.569505, 0.178980, 0.586821,  0.231530);\ncurve_to(  0.604137,  0.284599, 0.604137, 0.337669);\ncurve_to( 0.604137, 0.408429, 0.571429,  0.447451);\ncurve_to(  0.539202,  0.486472, 0.492545, 0.486472);\ncurve_to( 0.461760, 0.486472, 0.434343,  0.469303);\ncurve_to( 0.407407, 0.452653, 0.381914,  0.415193);\ncurve_to( 0.356421, 0.377732, 0.341029,  0.324142);\ncurve_to(  0.325637,  0.270552, 0.325637, 0.225806);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show65(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1366height: 1922\nmove_to( -0.002196, 0.000000);\n\nline_to(  0.409956, 0.762747);\n\nline_to(  0.562958, 0.762747);\n\nline_to(  1.002196, 0.000000);\n\nline_to(  0.840410, 0.000000);\n\nline_to(  0.715227, 0.231009);\n\nline_to(  0.266471, 0.231009);\n\nline_to(  0.148609, 0.000000);\n\nline_to(  -0.002196, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.307467, 0.313215);\n\nline_to(  0.671303, 0.313215);\n\nline_to(  0.559297, 0.524454);\n\ncurve_to(  0.508053,  0.620708, 0.483163, 0.682622);\ncurve_to(  0.462665,  0.609261, 0.425329, 0.536941);\nline_to(  0.307467, 0.313215);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show66(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1366height: 1922\nmove_to( 0.109810, 0.000000);\n\nline_to(  0.109810, 0.762747);\n\nline_to(  0.512445, 0.762747);\n\ncurve_to( 0.635432, 0.762747, 0.709370,  0.739334);\ncurve_to( 0.784041, 0.716441, 0.825769,  0.668054);\ncurve_to(  0.868228,  0.620187, 0.868228, 0.567638);\ncurve_to( 0.868228, 0.518730, 0.830893,  0.475546);\ncurve_to(  0.793558,  0.432362, 0.718155, 0.405827);\ncurve_to( 0.815520, 0.385536, 0.867496,  0.336629);\ncurve_to(  0.920205,  0.287721, 0.920205, 0.221124);\ncurve_to( 0.920205, 0.167534, 0.887994,  0.121228);\ncurve_to( 0.856515, 0.075442, 0.809663,  0.050468);\ncurve_to( 0.762811, 0.025494, 0.691801,  0.012487);\ncurve_to(  0.621523,  0.000000, 0.519034, 0.000000);\nline_to(  0.109810, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.251830, 0.442248);\n\nline_to(  0.483895, 0.442248);\n\ncurve_to(  0.578331,  0.442248, 0.619326, 0.451093);\ncurve_to( 0.673499, 0.462539, 0.700586,  0.489074);\ncurve_to(  0.728404,  0.515609, 0.728404, 0.555671);\ncurve_to( 0.728404, 0.593652, 0.702782,  0.622268);\ncurve_to( 0.677160, 0.651405, 0.629575,  0.661811);\ncurve_to(  0.581991,  0.672737, 0.466325, 0.672737);\nline_to(  0.251830, 0.672737);\n\nline_to(  0.251830, 0.442248);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.251830, 0.090010);\n\nline_to(  0.519034, 0.090010);\n\ncurve_to(  0.587848,  0.090010, 0.615666, 0.093652);\ncurve_to( 0.664715, 0.099896, 0.697657,  0.114464);\ncurve_to( 0.730600, 0.129032, 0.751830,  0.156608);\ncurve_to(  0.773060,  0.184703, 0.773060, 0.221124);\ncurve_to( 0.773060, 0.263788, 0.742313,  0.295005);\ncurve_to( 0.711567, 0.326743, 0.656662,  0.339230);\ncurve_to(  0.602489,  0.352237, 0.500000, 0.352237);\nline_to(  0.251830, 0.352237);\n\nline_to(  0.251830, 0.090010);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show67(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1479height: 1922\nmove_to( 0.814064, 0.267430);\n\nline_to(  0.945233, 0.241935);\n\ncurve_to( 0.903989, 0.117586, 0.796484,  0.052029);\ncurve_to(  0.689655,  -0.013007, 0.534821, -0.013007);\ncurve_to( 0.374577, -0.013007, 0.273834,  0.036941);\ncurve_to( 0.173766, 0.087409, 0.121028,  0.182622);\ncurve_to(  0.068966,  0.277836, 0.068966, 0.387097);\ncurve_to( 0.068966, 0.506243, 0.127789,  0.594693);\ncurve_to( 0.187289, 0.683663, 0.296146,  0.729448);\ncurve_to(  0.405680,  0.775754, 0.536849, 0.775754);\ncurve_to( 0.685598, 0.775754, 0.787018,  0.717482);\ncurve_to(  0.888438,  0.659209, 0.928330, 0.553590);\nline_to(  0.799189, 0.530177);\n\ncurve_to( 0.764706, 0.613424, 0.699121,  0.651405);\ncurve_to(  0.633536,  0.689386, 0.534145, 0.689386);\ncurve_to( 0.419878, 0.689386, 0.342799,  0.647242);\ncurve_to( 0.266396, 0.605099, 0.235294,  0.533819);\ncurve_to(  0.204192,  0.463059, 0.204192, 0.387617);\ncurve_to( 0.204192, 0.290323, 0.240703,  0.217482);\ncurve_to( 0.277890, 0.145161, 0.355646,  0.109261);\ncurve_to(  0.433401,  0.073361, 0.524003, 0.073361);\ncurve_to( 0.634212, 0.073361, 0.710615,  0.122268);\ncurve_to(  0.787018,  0.171176, 0.814064, 0.267430);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show68(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1479height: 1922\nmove_to( 0.106829, 0.000000);\n\nline_to(  0.106829, 0.762747);\n\nline_to(  0.448276, 0.762747);\n\ncurve_to(  0.563895,  0.762747, 0.624746, 0.751821);\ncurve_to(  0.709939,  0.736733, 0.770115, 0.697190);\ncurve_to( 0.848546, 0.646202, 0.887086,  0.566597);\ncurve_to(  0.926302,  0.487513, 0.926302, 0.385536);\ncurve_to( 0.926302, 0.298647, 0.899932,  0.231530);\ncurve_to( 0.873563, 0.164412, 0.832319,  0.120187);\ncurve_to( 0.791075, 0.076483, 0.741717,  0.050989);\ncurve_to( 0.693036, 0.026015, 0.623394,  0.013007);\ncurve_to(  0.554429,  0.000000, 0.464503, 0.000000);\nline_to(  0.106829, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.237999, 0.090010);\n\nline_to(  0.449628, 0.090010);\n\ncurve_to( 0.547667, 0.090010, 0.603110,  0.104058);\ncurve_to(  0.659229,  0.118106, 0.692360, 0.143600);\ncurve_to( 0.739013, 0.179501, 0.764706,  0.239854);\ncurve_to(  0.791075,  0.300728, 0.791075, 0.387097);\ncurve_to( 0.791075, 0.506764, 0.739689,  0.570760);\ncurve_to(  0.688979,  0.635276, 0.615957, 0.657128);\ncurve_to(  0.563218,  0.672737, 0.446247, 0.672737);\nline_to(  0.237999, 0.672737);\n\nline_to(  0.237999, 0.090010);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show69(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1366height: 1922\nmove_to( 0.118594, 0.000000);\n\nline_to(  0.118594, 0.762747);\n\nline_to(  0.894583, 0.762747);\n\nline_to(  0.894583, 0.672737);\n\nline_to(  0.260615, 0.672737);\n\nline_to(  0.260615, 0.439126);\n\nline_to(  0.854319, 0.439126);\n\nline_to(  0.854319, 0.349636);\n\nline_to(  0.260615, 0.349636);\n\nline_to(  0.260615, 0.090010);\n\nline_to(  0.919473, 0.090010);\n\nline_to(  0.919473, 0.000000);\n\nline_to(  0.118594, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show70(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1251height: 1922\nmove_to( 0.134293, 0.000000);\n\nline_to(  0.134293, 0.762747);\n\nline_to(  0.924860, 0.762747);\n\nline_to(  0.924860, 0.672737);\n\nline_to(  0.289369, 0.672737);\n\nline_to(  0.289369, 0.436524);\n\nline_to(  0.839329, 0.436524);\n\nline_to(  0.839329, 0.346514);\n\nline_to(  0.289369, 0.346514);\n\nline_to(  0.289369, 0.000000);\n\nline_to(  0.134293, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show71(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1593height: 1922\nmove_to( 0.529818, 0.299168);\n\nline_to(  0.529818, 0.388658);\n\nline_to(  0.919648, 0.389178);\n\nline_to(  0.919648, 0.106139);\n\ncurve_to( 0.829881, 0.046826, 0.734463,  0.016649);\ncurve_to(  0.639046,  -0.013007, 0.538606, -0.013007);\ncurve_to( 0.403013, -0.013007, 0.291902,  0.034860);\ncurve_to( 0.181419, 0.083247, 0.124922,  0.174298);\ncurve_to(  0.068424,  0.265349, 0.068424, 0.377732);\ncurve_to( 0.068424, 0.489074, 0.124294,  0.585328);\ncurve_to( 0.180791, 0.682102, 0.286252,  0.728928);\ncurve_to(  0.391714,  0.775754, 0.529190, 0.775754);\ncurve_to( 0.629002, 0.775754, 0.709353,  0.748699);\ncurve_to( 0.790333, 0.722164, 0.836158,  0.674298);\ncurve_to(  0.881984,  0.626431, 0.905838, 0.549428);\nline_to(  0.795982, 0.524454);\n\ncurve_to( 0.775267, 0.582726, 0.744507,  0.616025);\ncurve_to( 0.713748, 0.649324, 0.656623,  0.669095);\ncurve_to(  0.599498,  0.689386, 0.529818, 0.689386);\ncurve_to( 0.446328, 0.689386, 0.385436,  0.668054);\ncurve_to( 0.324545, 0.647242, 0.286880,  0.612903);\ncurve_to(  0.249843,  0.578564, 0.229127, 0.537461);\ncurve_to(  0.193974,  0.466701, 0.193974, 0.383975);\ncurve_to( 0.193974, 0.281998, 0.236033,  0.213319);\ncurve_to( 0.278719, 0.144641, 0.359699,  0.111342);\ncurve_to(  0.440678,  0.078044, 0.531701, 0.078044);\ncurve_to( 0.610797, 0.078044, 0.686127,  0.103018);\ncurve_to(  0.761456,  0.128512, 0.800377, 0.157128);\nline_to(  0.800377, 0.299168);\n\nline_to(  0.529818, 0.299168);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show72(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1479height: 1922\nmove_to( 0.110886, 0.000000);\n\nline_to(  0.110886, 0.762747);\n\nline_to(  0.242055, 0.762747);\n\nline_to(  0.242055, 0.449532);\n\nline_to(  0.757268, 0.449532);\n\nline_to(  0.757268, 0.762747);\n\nline_to(  0.888438, 0.762747);\n\nline_to(  0.888438, 0.000000);\n\nline_to(  0.757268, 0.000000);\n\nline_to(  0.757268, 0.359521);\n\nline_to(  0.242055, 0.359521);\n\nline_to(  0.242055, 0.000000);\n\nline_to(  0.110886, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show73(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.335677, 0.000000);\n\nline_to(  0.335677, 0.762747);\n\nline_to(  0.676626, 0.762747);\n\nline_to(  0.676626, 0.000000);\n\nline_to(  0.335677, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show74(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1024height: 1922\nmove_to( 0.057617, 0.216441);\n\nline_to(  0.228516, 0.228928);\n\ncurve_to( 0.235352, 0.141519, 0.290039,  0.109261);\ncurve_to(  0.344727,  0.077003, 0.441406, 0.077003);\ncurve_to( 0.512695, 0.077003, 0.564453,  0.094173);\ncurve_to( 0.616211, 0.111863, 0.635742,  0.141519);\ncurve_to(  0.655273,  0.171696, 0.655273, 0.237253);\nline_to(  0.655273, 0.762747);\n\nline_to(  0.844727, 0.762747);\n\nline_to(  0.844727, 0.242976);\n\ncurve_to( 0.844727, 0.147242, 0.800781,  0.094693);\ncurve_to( 0.757813, 0.042144, 0.663086,  0.014568);\ncurve_to(  0.569336,  -0.013007, 0.442383, -0.013007);\ncurve_to( 0.253906, -0.013007, 0.153320,  0.044745);\ncurve_to(  0.053711,  0.102497, 0.057617, 0.216441);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show75(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1366height: 1922\nmove_to( 0.109810, 0.000000);\n\nline_to(  0.109810, 0.762747);\n\nline_to(  0.251830, 0.762747);\n\nline_to(  0.251830, 0.384495);\n\nline_to(  0.784773, 0.762747);\n\nline_to(  0.977306, 0.762747);\n\nline_to(  0.527086, 0.453694);\n\nline_to(  0.997072, 0.000000);\n\nline_to(  0.809663, 0.000000);\n\nline_to(  0.427526, 0.386056);\n\nline_to(  0.251830, 0.264308);\n\nline_to(  0.251830, 0.000000);\n\nline_to(  0.109810, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show76(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.131694, 0.000000);\n\nline_to(  0.131694, 0.762747);\n\nline_to(  0.302019, 0.762747);\n\nline_to(  0.302019, 0.090010);\n\nline_to(  0.935909, 0.090010);\n\nline_to(  0.935909, 0.000000);\n\nline_to(  0.131694, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show77(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1706height: 1922\nmove_to( 0.089097, 0.000000);\n\nline_to(  0.089097, 0.762747);\n\nline_to(  0.260258, 0.762747);\n\nline_to(  0.463658, 0.222685);\n\ncurve_to(  0.491794,  0.147242, 0.504689, 0.109781);\ncurve_to(  0.519343,  0.151405, 0.550410, 0.232050);\nline_to(  0.756155, 0.762747);\n\nline_to(  0.909144, 0.762747);\n\nline_to(  0.909144, 0.000000);\n\nline_to(  0.799531, 0.000000);\n\nline_to(  0.799531, 0.638398);\n\nline_to(  0.549824, 0.000000);\n\nline_to(  0.447245, 0.000000);\n\nline_to(  0.198710, 0.649324);\n\nline_to(  0.198710, 0.000000);\n\nline_to(  0.089097, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show78(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1479height: 1922\nmove_to( 0.105477, 0.000000);\n\nline_to(  0.105477, 0.762747);\n\nline_to(  0.240027, 0.762747);\n\nline_to(  0.760649, 0.163892);\n\nline_to(  0.760649, 0.762747);\n\nline_to(  0.886410, 0.762747);\n\nline_to(  0.886410, 0.000000);\n\nline_to(  0.751859, 0.000000);\n\nline_to(  0.231237, 0.599376);\n\nline_to(  0.231237, 0.000000);\n\nline_to(  0.105477, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show79(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1593height: 1922\nmove_to( 0.062147, 0.371488);\n\ncurve_to( 0.062147, 0.561394, 0.185185,  0.668574);\ncurve_to(  0.308223,  0.776275, 0.502825, 0.776275);\ncurve_to( 0.630257, 0.776275, 0.732580,  0.725806);\ncurve_to( 0.834903, 0.675338, 0.888261,  0.584808);\ncurve_to(  0.942247,  0.494797, 0.942247, 0.380333);\ncurve_to( 0.942247, 0.264308, 0.885750,  0.172737);\ncurve_to( 0.829253, 0.081165, 0.725675,  0.033819);\ncurve_to(  0.622097,  -0.013007, 0.502197, -0.013007);\ncurve_to( 0.372254, -0.013007, 0.269931,  0.039022);\ncurve_to( 0.167608, 0.091051, 0.114878,  0.181061);\ncurve_to(  0.062147,  0.271072, 0.062147, 0.371488);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.187696, 0.369927);\n\ncurve_to( 0.187696, 0.232050, 0.276836,  0.152445);\ncurve_to(  0.366604,  0.073361, 0.501569, 0.073361);\ncurve_to( 0.639046, 0.073361, 0.727558,  0.153486);\ncurve_to(  0.816698,  0.233611, 0.816698, 0.380853);\ncurve_to( 0.816698, 0.473985, 0.778406,  0.543184);\ncurve_to( 0.740741, 0.612903, 0.667294,  0.650885);\ncurve_to(  0.594476,  0.689386, 0.503453, 0.689386);\ncurve_to( 0.374137, 0.689386, 0.280603,  0.615505);\ncurve_to(  0.187696,  0.542144, 0.187696, 0.369927);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show80(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1366height: 1922\nmove_to( 0.115666, 0.000000);\n\nline_to(  0.115666, 0.762747);\n\nline_to(  0.520498, 0.762747);\n\ncurve_to(  0.627379,  0.762747, 0.683748, 0.755463);\ncurve_to( 0.762811, 0.746098, 0.816252,  0.719563);\ncurve_to( 0.869693, 0.693548, 0.901903,  0.646202);\ncurve_to(  0.934846,  0.598855, 0.934846, 0.542144);\ncurve_to( 0.934846, 0.444849, 0.847731,  0.377211);\ncurve_to(  0.760615,  0.310094, 0.532943, 0.310094);\nline_to(  0.257687, 0.310094);\n\nline_to(  0.257687, 0.000000);\n\nline_to(  0.115666, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.257687, 0.400104);\n\nline_to(  0.535139, 0.400104);\n\ncurve_to( 0.672767, 0.400104, 0.730600,  0.436524);\ncurve_to(  0.788433,  0.472945, 0.788433, 0.539022);\ncurve_to( 0.788433, 0.586889, 0.754026,  0.620708);\ncurve_to(  0.720351,  0.655047, 0.664715, 0.665973);\ncurve_to(  0.628843,  0.672737, 0.532211, 0.672737);\nline_to(  0.257687, 0.672737);\n\nline_to(  0.257687, 0.400104);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show81(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1593height: 1922\nmove_to( 0.796610, 0.081686);\n\ncurve_to(  0.881356,  0.033299, 0.952919, 0.010926);\nline_to(  0.917138, -0.059313);\n\ncurve_to(  0.817954,  -0.029657, 0.719397, 0.034339);\ncurve_to(  0.617075,  -0.013007, 0.493409, -0.013007);\ncurve_to( 0.368487, -0.013007, 0.266792,  0.036941);\ncurve_to( 0.165097, 0.086889, 0.109856,  0.177419);\ncurve_to(  0.055242,  0.267950, 0.055242, 0.381374);\ncurve_to( 0.055242, 0.494277, 0.110483,  0.586889);\ncurve_to( 0.165725, 0.679501, 0.267420,  0.727888);\ncurve_to(  0.369743,  0.776275, 0.495920, 0.776275);\ncurve_to( 0.623352, 0.776275, 0.725675,  0.725806);\ncurve_to( 0.827998, 0.675858, 0.881356,  0.585328);\ncurve_to(  0.935342,  0.495317, 0.935342, 0.381894);\ncurve_to( 0.935342, 0.287721, 0.900816,  0.212279);\ncurve_to(  0.866290,  0.137357, 0.796610, 0.081686);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.528562, 0.210718);\n\ncurve_to(  0.634024,  0.186264, 0.702448, 0.137877);\ncurve_to(  0.809793,  0.219043, 0.809793, 0.381894);\ncurve_to( 0.809793, 0.474506, 0.771500,  0.543704);\ncurve_to( 0.733836, 0.612903, 0.660389,  0.650885);\ncurve_to(  0.587571,  0.689386, 0.496547, 0.689386);\ncurve_to( 0.360326, 0.689386, 0.270559,  0.611863);\ncurve_to(  0.180791,  0.534860, 0.180791, 0.381374);\ncurve_to( 0.180791, 0.232570, 0.269303,  0.152966);\ncurve_to(  0.358443,  0.073361, 0.496547, 0.073361);\ncurve_to(  0.561833,  0.073361, 0.619586, 0.093652);\ncurve_to(  0.562461,  0.124350, 0.499058, 0.137357);\nline_to(  0.528562, 0.210718);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show82(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1479height: 1922\nmove_to( 0.108857, 0.000000);\n\nline_to(  0.108857, 0.762747);\n\nline_to(  0.548343, 0.762747);\n\ncurve_to( 0.680865, 0.762747, 0.749831,  0.741935);\ncurve_to( 0.818796, 0.721644, 0.860041,  0.669615);\ncurve_to(  0.901285,  0.617586, 0.901285, 0.554631);\ncurve_to( 0.901285, 0.473465, 0.832995,  0.417794);\ncurve_to(  0.764706,  0.362123, 0.622042, 0.347034);\ncurve_to(  0.674104,  0.327784, 0.701149, 0.309053);\ncurve_to(  0.758621,  0.268470, 0.810007, 0.207596);\nline_to(  0.982421, 0.000000);\n\nline_to(  0.817444, 0.000000);\n\nline_to(  0.686275, 0.158689);\n\ncurve_to( 0.628803, 0.227367, 0.591616,  0.263788);\ncurve_to( 0.554429, 0.300208, 0.524679,  0.314776);\ncurve_to(  0.495605,  0.329344, 0.465179, 0.335068);\ncurve_to(  0.442867,  0.338710, 0.392157, 0.338710);\nline_to(  0.240027, 0.338710);\n\nline_to(  0.240027, 0.000000);\n\nline_to(  0.108857, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.240027, 0.426119);\n\nline_to(  0.521974, 0.426119);\n\ncurve_to( 0.611900, 0.426119, 0.662610,  0.440167);\ncurve_to( 0.713320, 0.454735, 0.739689,  0.485952);\ncurve_to(  0.766058,  0.517690, 0.766058, 0.554631);\ncurve_to( 0.766058, 0.608741, 0.714672,  0.643600);\ncurve_to(  0.663962,  0.678460, 0.553753, 0.678460);\nline_to(  0.240027, 0.678460);\n\nline_to(  0.240027, 0.426119);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show83(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1366height: 1922\nmove_to( 0.067350, 0.245057);\n\nline_to(  0.201318, 0.253382);\n\ncurve_to( 0.210835, 0.196150, 0.245242,  0.159209);\ncurve_to( 0.280381, 0.122789, 0.353587,  0.099896);\ncurve_to(  0.426794,  0.077523, 0.518302, 0.077523);\ncurve_to( 0.599561, 0.077523, 0.661786,  0.094693);\ncurve_to( 0.724012, 0.111863, 0.754026,  0.141519);\ncurve_to(  0.784773,  0.171696, 0.784773, 0.207076);\ncurve_to( 0.784773, 0.242976, 0.755490,  0.269511);\ncurve_to(  0.726208,  0.296566, 0.658858, 0.314776);\ncurve_to( 0.615666, 0.326743, 0.467789,  0.351717);\ncurve_to(  0.319912,  0.377211, 0.260615, 0.399584);\ncurve_to( 0.183748, 0.428200, 0.145681,  0.470343);\ncurve_to(  0.108346,  0.513007, 0.108346, 0.565557);\ncurve_to( 0.108346, 0.623309, 0.154466,  0.673257);\ncurve_to( 0.200586, 0.723725, 0.289165,  0.749740);\ncurve_to(  0.377745,  0.775754, 0.486091, 0.775754);\ncurve_to( 0.605417, 0.775754, 0.696193,  0.748179);\ncurve_to( 0.787701, 0.721124, 0.836750,  0.668054);\ncurve_to(  0.885798,  0.614984, 0.889458, 0.547867);\nline_to(  0.753294, 0.540583);\n\ncurve_to( 0.742313, 0.612903, 0.678624,  0.649844);\ncurve_to(  0.615666,  0.686785, 0.491947, 0.686785);\ncurve_to( 0.363104, 0.686785, 0.303807,  0.652966);\ncurve_to(  0.245242,  0.619667, 0.245242, 0.572321);\ncurve_to(  0.245242,  0.531217, 0.286969, 0.504683);\ncurve_to( 0.327965, 0.478148, 0.500732,  0.450052);\ncurve_to(  0.674231,  0.422477, 0.738653, 0.401665);\ncurve_to( 0.832357, 0.370968, 0.877013,  0.323621);\ncurve_to(  0.921669,  0.276795, 0.921669, 0.215401);\ncurve_to( 0.921669, 0.154527, 0.872621,  0.100416);\ncurve_to( 0.823572, 0.046826, 0.731332,  0.016649);\ncurve_to(  0.639824,  -0.013007, 0.524890, -0.013007);\ncurve_to( 0.379209, -0.013007, 0.280381,  0.017170);\ncurve_to( 0.182284, 0.047347, 0.125915,  0.107700);\ncurve_to(  0.070278,  0.168574, 0.067350, 0.245057);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show84(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1251height: 1922\nmove_to( 0.424460, 0.000000);\n\nline_to(  0.424460, 0.672737);\n\nline_to(  0.038369, 0.672737);\n\nline_to(  0.038369, 0.762747);\n\nline_to(  0.967226, 0.762747);\n\nline_to(  0.967226, 0.672737);\n\nline_to(  0.579536, 0.672737);\n\nline_to(  0.579536, 0.000000);\n\nline_to(  0.424460, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show85(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1479height: 1922\nmove_to( 0.757268, 0.762747);\n\nline_to(  0.888438, 0.762747);\n\nline_to(  0.888438, 0.322060);\n\ncurve_to( 0.888438, 0.207076, 0.854631,  0.139438);\ncurve_to( 0.820825, 0.071800, 0.732252,  0.029136);\ncurve_to(  0.644354,  -0.013007, 0.501014, -0.013007);\ncurve_to( 0.361731, -0.013007, 0.273158,  0.023933);\ncurve_to( 0.184584, 0.060874, 0.146721,  0.130593);\ncurve_to(  0.108857,  0.200832, 0.108857, 0.322060);\nline_to(  0.108857, 0.762747);\n\nline_to(  0.240027, 0.762747);\n\nline_to(  0.240027, 0.322581);\n\ncurve_to( 0.240027, 0.223205, 0.263692,  0.175858);\ncurve_to( 0.288032, 0.129032, 0.346180,  0.103538);\ncurve_to(  0.405003,  0.078044, 0.489520, 0.078044);\ncurve_to( 0.634212, 0.078044, 0.695740,  0.128512);\ncurve_to(  0.757268,  0.178980, 0.757268, 0.322581);\nline_to(  0.757268, 0.762747);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show86(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1366height: 1922\nmove_to( 0.422401, 0.000000);\n\nline_to(  0.006589, 0.762747);\n\nline_to(  0.160322, 0.762747);\n\nline_to(  0.439239, 0.208637);\n\ncurve_to(  0.472914,  0.142040, 0.495608, 0.083767);\ncurve_to(  0.520498,  0.146202, 0.553441, 0.208637);\nline_to(  0.843338, 0.762747);\n\nline_to(  0.988287, 0.762747);\n\nline_to(  0.568082, 0.000000);\n\nline_to(  0.422401, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show87(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1933height: 1922\nmove_to( 0.214175, 0.000000);\n\nline_to(  0.012933, 0.762747);\n\nline_to(  0.115882, 0.762747);\n\nline_to(  0.231247, 0.262747);\n\ncurve_to(  0.249871,  0.184183, 0.263321, 0.106660);\ncurve_to(  0.292292,  0.228928, 0.297465, 0.247659);\nline_to(  0.441800, 0.762747);\n\nline_to(  0.562856, 0.762747);\n\nline_to(  0.671495, 0.376691);\n\ncurve_to(  0.712364,  0.233091, 0.730471, 0.106660);\ncurve_to(  0.744956,  0.178980, 0.768236, 0.272633);\nline_to(  0.887222, 0.762747);\n\nline_to(  0.988101, 0.762747);\n\nline_to(  0.780134, 0.000000);\n\nline_to(  0.683394, 0.000000);\n\nline_to(  0.523539, 0.581165);\n\ncurve_to(  0.503363,  0.654006, 0.499741, 0.670656);\ncurve_to(  0.487843,  0.618106, 0.477496, 0.581165);\nline_to(  0.316606, 0.000000);\n\nline_to(  0.214175, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show88(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1366height: 1922\nmove_to( 0.006589, 0.000000);\n\nline_to(  0.421669, 0.397503);\n\nline_to(  0.055637, 0.762747);\n\nline_to(  0.224744, 0.762747);\n\nline_to(  0.419473, 0.567118);\n\ncurve_to(  0.480234,  0.506243, 0.505857, 0.473465);\ncurve_to(  0.541728,  0.515088, 0.590776, 0.560354);\nline_to(  0.806735, 0.762747);\n\nline_to(  0.961201, 0.762747);\n\nline_to(  0.584187, 0.403226);\n\nline_to(  0.990483, 0.000000);\n\nline_to(  0.814788, 0.000000);\n\nline_to(  0.544656, 0.272112);\n\ncurve_to(  0.521962,  0.295525, 0.497804, 0.323101);\ncurve_to(  0.461933,  0.281478, 0.446559, 0.265869);\nline_to(  0.177160, 0.000000);\n\nline_to(  0.006589, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show89(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1366height: 1922\nmove_to( 0.418009, 0.000000);\n\nline_to(  0.418009, 0.323101);\n\nline_to(  0.004392, 0.762747);\n\nline_to(  0.177160, 0.762747);\n\nline_to(  0.388726, 0.532778);\n\ncurve_to(  0.447291,  0.468262, 0.497804, 0.403746);\ncurve_to(  0.546120,  0.463580, 0.614934, 0.538502);\nline_to(  0.822840, 0.762747);\n\nline_to(  0.988287, 0.762747);\n\nline_to(  0.560029, 0.323101);\n\nline_to(  0.560029, 0.000000);\n\nline_to(  0.418009, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show90(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1251height: 1922\nmove_to( 0.032774, 0.000000);\n\nline_to(  0.032774, 0.093652);\n\nline_to(  0.633094, 0.582206);\n\ncurve_to(  0.697042,  0.634235, 0.754596, 0.672737);\nline_to(  0.100719, 0.672737);\n\nline_to(  0.100719, 0.762747);\n\nline_to(  0.940048, 0.762747);\n\nline_to(  0.940048, 0.672737);\n\nline_to(  0.282174, 0.143600);\n\nline_to(  0.211031, 0.090010);\n\nline_to(  0.959233, 0.090010);\n\nline_to(  0.959233, 0.000000);\n\nline_to(  0.032774, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show91(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.244288, -0.211759);\n\nline_to(  0.244288, 0.762747);\n\nline_to(  0.942003, 0.762747);\n\nline_to(  0.942003, 0.685224);\n\nline_to(  0.560633, 0.685224);\n\nline_to(  0.560633, -0.134235);\n\nline_to(  0.942003, -0.134235);\n\nline_to(  0.942003, -0.211759);\n\nline_to(  0.244288, -0.211759);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show92(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.746924, -0.013007);\n\nline_to(  0.000000, 0.775754);\n\nline_to(  0.254833, 0.775754);\n\nline_to(  1.000000, -0.013007);\n\nline_to(  0.746924, -0.013007);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show93(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.766257, -0.211759);\n\nline_to(  0.068541, -0.211759);\n\nline_to(  0.068541, -0.134235);\n\nline_to(  0.449912, -0.134235);\n\nline_to(  0.449912, 0.685224);\n\nline_to(  0.068541, 0.685224);\n\nline_to(  0.068541, 0.762747);\n\nline_to(  0.766257, 0.762747);\n\nline_to(  0.766257, -0.211759);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show94(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 961height: 1922\nmove_to( 0.248699, 0.359001);\n\nline_to(  0.056191, 0.359001);\n\nline_to(  0.423517, 0.775754);\n\nline_to(  0.574402, 0.775754);\n\nline_to(  0.943809, 0.359001);\n\nline_to(  0.755463, 0.359001);\n\nline_to(  0.498439, 0.669615);\n\nline_to(  0.248699, 0.359001);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show95(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( -0.027217, -0.211759);\n\nline_to(  -0.027217, -0.144121);\n\nline_to(  1.020193, -0.144121);\n\nline_to(  1.020193, -0.211759);\n\nline_to(  -0.027217, -0.211759);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show96(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 682height: 1922\nmove_to( 0.681818, 0.621228);\n\nline_to(  0.469208, 0.621228);\n\nline_to(  0.130499, 0.766909);\n\nline_to(  0.483871, 0.766909);\n\nline_to(  0.681818, 0.621228);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show97(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.726953, 0.068158);\n\ncurve_to( 0.639157, 0.023933, 0.557507,  0.005723);\ncurve_to(  0.476734,  -0.012487, 0.383670, -0.012487);\ncurve_to( 0.230026, -0.012487, 0.147498,  0.031738);\ncurve_to(  0.064969,  0.076483, 0.064969, 0.145682);\ncurve_to( 0.064969, 0.186264, 0.095698,  0.219563);\ncurve_to( 0.127305, 0.253382, 0.177349,  0.273673);\ncurve_to(  0.228270,  0.293965, 0.291484, 0.304370);\ncurve_to(  0.338016,  0.311655, 0.431958, 0.318418);\ncurve_to(  0.623354,  0.331946, 0.713784, 0.350676);\ncurve_to(  0.714662,  0.369927, 0.714662, 0.375130);\ncurve_to(  0.714662,  0.432362, 0.669886, 0.455775);\ncurve_to(  0.609306,  0.487513, 0.489903, 0.487513);\ncurve_to( 0.378402, 0.487513, 0.324846,  0.464100);\ncurve_to(  0.272169,  0.441207, 0.246708, 0.382414);\nline_to(  0.092186, 0.394901);\n\ncurve_to( 0.113257, 0.453694, 0.161545,  0.489594);\ncurve_to( 0.209833, 0.526015, 0.301141,  0.545265);\ncurve_to(  0.392450,  0.565036, 0.512730, 0.565036);\ncurve_to( 0.632133, 0.565036, 0.706760,  0.548387);\ncurve_to( 0.781387, 0.531738, 0.816506,  0.506243);\ncurve_to(  0.851624,  0.481270, 0.865672, 0.442768);\ncurve_to(  0.873573,  0.418835, 0.873573, 0.356400);\nline_to(  0.873573, 0.231530);\n\ncurve_to( 0.873573, 0.100937, 0.883231,  0.066077);\ncurve_to(  0.893766,  0.031738, 0.923617, 0.000000);\nline_to(  0.758560, 0.000000);\n\ncurve_to(  0.733977,  0.029136, 0.726953, 0.068158);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.713784, 0.277315);\n\ncurve_to(  0.627744,  0.256504, 0.455663, 0.241935);\ncurve_to( 0.358209, 0.233611, 0.317823,  0.223205);\ncurve_to( 0.277436, 0.212799, 0.255487,  0.192508);\ncurve_to(  0.233538,  0.172737, 0.233538, 0.148283);\ncurve_to( 0.233538, 0.110822, 0.280948,  0.085848);\ncurve_to(  0.329236,  0.060874, 0.421422, 0.060874);\ncurve_to( 0.512730, 0.060874, 0.583845,  0.084287);\ncurve_to(  0.654961,  0.108221, 0.688323, 0.149324);\ncurve_to(  0.713784,  0.181061, 0.713784, 0.242976);\nline_to(  0.713784, 0.277315);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show98(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.264267, 0.000000);\n\nline_to(  0.117647, 0.000000);\n\nline_to(  0.117647, 0.762747);\n\nline_to(  0.275680, 0.762747);\n\nline_to(  0.275680, 0.490635);\n\ncurve_to(  0.375768,  0.565036, 0.531168, 0.565036);\ncurve_to( 0.617208, 0.565036, 0.693591,  0.544225);\ncurve_to( 0.770852, 0.523933, 0.820018,  0.486472);\ncurve_to( 0.870061, 0.449532, 0.898156,  0.396982);\ncurve_to(  0.926251,  0.344433, 0.926251, 0.284599);\ncurve_to( 0.926251, 0.142560, 0.807726,  0.065036);\ncurve_to(  0.689201,  -0.012487, 0.523266, -0.012487);\ncurve_to(  0.358209,  -0.012487, 0.264267, 0.069199);\nline_to(  0.264267, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.262511, 0.280437);\n\ncurve_to(  0.262511,  0.181061, 0.308165, 0.136837);\ncurve_to(  0.382792,  0.064516, 0.510097, 0.064516);\ncurve_to( 0.613696, 0.064516, 0.689201,  0.117586);\ncurve_to(  0.764706,  0.171176, 0.764706, 0.276795);\ncurve_to( 0.764706, 0.385016, 0.691835,  0.436524);\ncurve_to(  0.619842,  0.488033, 0.517120, 0.488033);\ncurve_to( 0.413521, 0.488033, 0.338016,  0.434443);\ncurve_to(  0.262511,  0.381374, 0.262511, 0.280437);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show99(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1024height: 1922\nmove_to( 0.808594, 0.202393);\n\nline_to(  0.981445, 0.190427);\n\ncurve_to( 0.953125, 0.095213, 0.835938,  0.041103);\ncurve_to(  0.719727,  -0.012487, 0.549805, -0.012487);\ncurve_to( 0.336914, -0.012487, 0.207031,  0.061394);\ncurve_to(  0.078125,  0.135796, 0.078125, 0.274194);\ncurve_to( 0.078125, 0.363684, 0.133789,  0.430801);\ncurve_to( 0.189453, 0.497919, 0.302734,  0.531217);\ncurve_to(  0.416992,  0.565036, 0.550781, 0.565036);\ncurve_to( 0.719727, 0.565036, 0.827148,  0.519251);\ncurve_to(  0.934570,  0.473985, 0.964844, 0.390219);\nline_to(  0.793945, 0.376171);\n\ncurve_to( 0.769531, 0.431842, 0.707031,  0.459938);\ncurve_to(  0.645508,  0.488033, 0.557617, 0.488033);\ncurve_to( 0.424805, 0.488033, 0.341797,  0.437045);\ncurve_to(  0.258789,  0.386576, 0.258789, 0.276795);\ncurve_to( 0.258789, 0.165453, 0.338867,  0.114984);\ncurve_to(  0.418945,  0.064516, 0.547852, 0.064516);\ncurve_to( 0.651367, 0.064516, 0.720703,  0.098335);\ncurve_to(  0.790039,  0.132154, 0.808594, 0.202393);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show100(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.723442, 0.000000);\n\nline_to(  0.723442, 0.069719);\n\ncurve_to(  0.634767,  -0.012487, 0.462687, -0.012487);\ncurve_to( 0.351185, -0.012487, 0.257243,  0.023933);\ncurve_to( 0.164179, 0.060354, 0.112379,  0.125390);\ncurve_to(  0.061457,  0.190947, 0.061457, 0.275754);\ncurve_to( 0.061457, 0.358481, 0.107989,  0.425598);\ncurve_to( 0.154522, 0.493236, 0.247586,  0.529136);\ncurve_to(  0.340650,  0.565036, 0.455663, 0.565036);\ncurve_to( 0.539947, 0.565036, 0.605795,  0.543704);\ncurve_to(  0.671642,  0.522893, 0.712906, 0.489074);\nline_to(  0.712906, 0.762747);\n\nline_to(  0.870061, 0.762747);\n\nline_to(  0.870061, 0.000000);\n\nline_to(  0.723442, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.223881, 0.275754);\n\ncurve_to( 0.223881, 0.169615, 0.299385,  0.117066);\ncurve_to(  0.374890,  0.064516, 0.477612, 0.064516);\ncurve_to( 0.581212, 0.064516, 0.653205,  0.114464);\ncurve_to(  0.726076,  0.164932, 0.726076, 0.267950);\ncurve_to( 0.726076, 0.381374, 0.652327,  0.434443);\ncurve_to(  0.578578,  0.487513, 0.470588, 0.487513);\ncurve_to( 0.365233, 0.487513, 0.294118,  0.436524);\ncurve_to(  0.223881,  0.385536, 0.223881, 0.275754);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show101(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.756804, 0.177940);\n\nline_to(  0.920105, 0.165973);\n\ncurve_to( 0.881475, 0.081165, 0.776997,  0.034339);\ncurve_to(  0.672520,  -0.012487, 0.510097, -0.012487);\ncurve_to( 0.305531, -0.012487, 0.185250,  0.061915);\ncurve_to(  0.065847,  0.136837, 0.065847, 0.271592);\ncurve_to( 0.065847, 0.411030, 0.187006,  0.488033);\ncurve_to(  0.308165,  0.565036, 0.501317, 0.565036);\ncurve_to( 0.688323, 0.565036, 0.806848,  0.489594);\ncurve_to(  0.925373,  0.414152, 0.925373, 0.277315);\ncurve_to(  0.925373,  0.268991, 0.924495, 0.252341);\nline_to(  0.229148, 0.252341);\n\ncurve_to( 0.237928, 0.161290, 0.316067,  0.112903);\ncurve_to(  0.394205,  0.064516, 0.510975, 0.064516);\ncurve_to( 0.597893, 0.064516, 0.659350,  0.091571);\ncurve_to(  0.720808,  0.118626, 0.756804, 0.177940);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.237928, 0.329344);\n\nline_to(  0.758560, 0.329344);\n\ncurve_to(  0.748025,  0.399063, 0.698859, 0.433923);\ncurve_to(  0.623354,  0.488033, 0.503073, 0.488033);\ncurve_to( 0.394205, 0.488033, 0.319579,  0.444849);\ncurve_to(  0.245830,  0.401665, 0.237928, 0.329344);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show102(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.312830, 0.000000);\n\nline_to(  0.312830, 0.479709);\n\nline_to(  0.033392, 0.479709);\n\nline_to(  0.033392, 0.552549);\n\nline_to(  0.312830, 0.552549);\n\nline_to(  0.312830, 0.611342);\n\ncurve_to(  0.312830,  0.667014, 0.346221, 0.694069);\ncurve_to( 0.391916, 0.730489, 0.506151,  0.752862);\ncurve_to(  0.622144,  0.775754, 0.829525, 0.775754);\ncurve_to(  0.963093,  0.775754, 1.124780, 0.766389);\nline_to(  1.077329, 0.684703);\n\ncurve_to(  0.978910,  0.689906, 0.891037, 0.689906);\ncurve_to( 0.746924, 0.689906, 0.687170,  0.671696);\ncurve_to(  0.627416,  0.653486, 0.627416, 0.603538);\nline_to(  0.627416, 0.552549);\n\nline_to(  0.991213, 0.552549);\n\nline_to(  0.991213, 0.479709);\n\nline_to(  0.627416, 0.479709);\n\nline_to(  0.627416, 0.000000);\n\nline_to(  0.312830, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show103(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.089552, -0.045786);\n\nline_to(  0.243196, -0.059313);\n\ncurve_to(  0.252853,  -0.101457, 0.296752, -0.120708);\ncurve_to(  0.355575,  -0.146722, 0.457419, -0.146722);\ncurve_to( 0.567164, -0.146722, 0.626866,  -0.120708);\ncurve_to(  0.686567,  -0.094693, 0.707638, -0.047867);\ncurve_to(  0.719930,  -0.019251, 0.719052, 0.072320);\ncurve_to(  0.615452,  0.000000, 0.460931, 0.000000);\ncurve_to( 0.268657, 0.000000, 0.163301,  0.082206);\ncurve_to(  0.057946,  0.164412, 0.057946, 0.279396);\ncurve_to( 0.057946, 0.358481, 0.106234,  0.425078);\ncurve_to( 0.154522, 0.492196, 0.245830,  0.528616);\ncurve_to(  0.338016,  0.565036, 0.461809, 0.565036);\ncurve_to(  0.626866,  0.565036, 0.733977, 0.485952);\nline_to(  0.733977, 0.552549);\n\nline_to(  0.879719, 0.552549);\n\nline_to(  0.879719, 0.074922);\n\ncurve_to( 0.879719, -0.054110, 0.834943,  -0.107700);\ncurve_to( 0.791045, -0.161811, 0.694469,  -0.193028);\ncurve_to(  0.598771,  -0.224246, 0.458297, -0.224246);\ncurve_to( 0.291484, -0.224246, 0.188762,  -0.179501);\ncurve_to(  0.086040,  -0.135276, 0.089552, -0.045786);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.220369, 0.286160);\n\ncurve_to( 0.220369, 0.177419, 0.293240,  0.127471);\ncurve_to(  0.366111,  0.077523, 0.475856, 0.077523);\ncurve_to( 0.584723, 0.077523, 0.658472,  0.126951);\ncurve_to(  0.732221,  0.176899, 0.732221, 0.283038);\ncurve_to( 0.732221, 0.384495, 0.655838,  0.436004);\ncurve_to(  0.580334,  0.487513, 0.473222, 0.487513);\ncurve_to( 0.367867, 0.487513, 0.294118,  0.436524);\ncurve_to(  0.220369,  0.386056, 0.220369, 0.286160);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show104(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.118525, 0.000000);\n\nline_to(  0.118525, 0.762747);\n\nline_to(  0.276558, 0.762747);\n\nline_to(  0.276558, 0.489074);\n\ncurve_to(  0.387182,  0.565036, 0.555751, 0.565036);\ncurve_to( 0.659350, 0.565036, 0.735733,  0.540583);\ncurve_to( 0.812116, 0.516649, 0.844600,  0.473985);\ncurve_to(  0.877963,  0.431322, 0.877963, 0.350156);\nline_to(  0.877963, 0.000000);\n\nline_to(  0.719930, 0.000000);\n\nline_to(  0.719930, 0.350156);\n\ncurve_to( 0.719930, 0.420395, 0.668130,  0.452133);\ncurve_to(  0.617208,  0.484391, 0.523266, 0.484391);\ncurve_to( 0.453029, 0.484391, 0.390694,  0.462539);\ncurve_to( 0.329236, 0.441207, 0.302897,  0.404266);\ncurve_to(  0.276558,  0.367326, 0.276558, 0.302289);\nline_to(  0.276558, 0.000000);\n\nline_to(  0.118525, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show105(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 455height: 1922\nmove_to( 0.298901, 0.655047);\n\nline_to(  0.298901, 0.762747);\n\nline_to(  0.694506, 0.762747);\n\nline_to(  0.694506, 0.655047);\n\nline_to(  0.298901, 0.655047);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.298901, 0.000000);\n\nline_to(  0.298901, 0.552549);\n\nline_to(  0.694506, 0.552549);\n\nline_to(  0.694506, 0.000000);\n\nline_to(  0.298901, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show106(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 455height: 1922\nmove_to( 0.294506, 0.654006);\n\nline_to(  0.294506, 0.762747);\n\nline_to(  0.690110, 0.762747);\n\nline_to(  0.690110, 0.654006);\n\nline_to(  0.294506, 0.654006);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( -0.206593, -0.214360);\n\nline_to(  -0.131868, -0.134755);\n\ncurve_to(  -0.013187,  -0.142040, 0.054945, -0.142040);\ncurve_to( 0.175824, -0.142040, 0.235165,  -0.122789);\ncurve_to(  0.294506,  -0.104058, 0.294506, -0.028096);\nline_to(  0.294506, 0.552549);\n\nline_to(  0.690110, 0.552549);\n\nline_to(  0.690110, -0.030177);\n\ncurve_to(  0.690110,  -0.132154, 0.578022, -0.172216);\ncurve_to(  0.435165,  -0.224246, 0.103297, -0.224246);\ncurve_to(  -0.057143,  -0.224246, -0.206593, -0.214360);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show107(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1024height: 1922\nmove_to( 0.132813, 0.000000);\n\nline_to(  0.132813, 0.762747);\n\nline_to(  0.308594, 0.762747);\n\nline_to(  0.308594, 0.327784);\n\nline_to(  0.724609, 0.552549);\n\nline_to(  0.952148, 0.552549);\n\nline_to(  0.555664, 0.347555);\n\nline_to(  0.992188, 0.000000);\n\nline_to(  0.775391, 0.000000);\n\nline_to(  0.432617, 0.282518);\n\nline_to(  0.308594, 0.219043);\n\nline_to(  0.308594, 0.000000);\n\nline_to(  0.132813, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show108(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 455height: 1922\nmove_to( 0.287912, 0.000000);\n\nline_to(  0.287912, 0.762747);\n\nline_to(  0.683517, 0.762747);\n\nline_to(  0.683517, 0.000000);\n\nline_to(  0.287912, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show109(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1706height: 1922\nmove_to( 0.079132, 0.000000);\n\nline_to(  0.079132, 0.552549);\n\nline_to(  0.173505, 0.552549);\n\nline_to(  0.173505, 0.475026);\n\ncurve_to( 0.202814, 0.515609, 0.251465,  0.540062);\ncurve_to(  0.300117,  0.565036, 0.362251, 0.565036);\ncurve_to( 0.431419, 0.565036, 0.475381,  0.539542);\ncurve_to(  0.519930,  0.514048, 0.538101, 0.468262);\ncurve_to(  0.611958,  0.565036, 0.730363, 0.565036);\ncurve_to( 0.822978, 0.565036, 0.872802,  0.519251);\ncurve_to(  0.922626,  0.473985, 0.922626, 0.379292);\nline_to(  0.922626, 0.000000);\n\nline_to(  0.817702, 0.000000);\n\nline_to(  0.817702, 0.348075);\n\ncurve_to( 0.817702, 0.404266, 0.807151,  0.428720);\ncurve_to( 0.797186, 0.453694, 0.770223,  0.468783);\ncurve_to(  0.743259,  0.483871, 0.706917, 0.483871);\ncurve_to( 0.641266, 0.483871, 0.597890,  0.444849);\ncurve_to(  0.554513,  0.406348, 0.554513, 0.321020);\nline_to(  0.554513, 0.000000);\n\nline_to(  0.449004, 0.000000);\n\nline_to(  0.449004, 0.359001);\n\ncurve_to( 0.449004, 0.421436, 0.423212,  0.452653);\ncurve_to(  0.397421,  0.483871, 0.338804, 0.483871);\ncurve_to( 0.294256, 0.483871, 0.256155,  0.463059);\ncurve_to( 0.218640, 0.442248, 0.201641,  0.402185);\ncurve_to(  0.184642,  0.362123, 0.184642, 0.286681);\nline_to(  0.184642, 0.000000);\n\nline_to(  0.079132, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show110(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.118525, 0.000000);\n\nline_to(  0.118525, 0.552549);\n\nline_to(  0.260755, 0.552549);\n\nline_to(  0.260755, 0.473985);\n\ncurve_to(  0.363477,  0.565036, 0.557507, 0.565036);\ncurve_to( 0.641791, 0.565036, 0.712028,  0.546826);\ncurve_to( 0.783143, 0.529136, 0.818262,  0.500000);\ncurve_to(  0.853380,  0.470864, 0.867428, 0.430801);\ncurve_to(  0.876207,  0.404787, 0.876207, 0.339750);\nline_to(  0.876207, 0.000000);\n\nline_to(  0.718174, 0.000000);\n\nline_to(  0.718174, 0.336108);\n\ncurve_to( 0.718174, 0.393340, 0.699737,  0.421436);\ncurve_to( 0.681299, 0.450052, 0.633889,  0.466701);\ncurve_to(  0.587357,  0.483871, 0.524144, 0.483871);\ncurve_to( 0.423178, 0.483871, 0.349429,  0.445890);\ncurve_to(  0.276558,  0.407908, 0.276558, 0.301769);\nline_to(  0.276558, 0.000000);\n\nline_to(  0.118525, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show111(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.059701, 0.276275);\n\ncurve_to(  0.059701,  0.429761, 0.203687, 0.503642);\ncurve_to(  0.323968,  0.565036, 0.496927, 0.565036);\ncurve_to( 0.689201, 0.565036, 0.811238,  0.490114);\ncurve_to(  0.933275,  0.415713, 0.933275, 0.284079);\ncurve_to( 0.933275, 0.177419, 0.878841,  0.116025);\ncurve_to( 0.825285, 0.055151, 0.721686,  0.021332);\ncurve_to(  0.618964,  -0.012487, 0.496927, -0.012487);\ncurve_to( 0.301141, -0.012487, 0.179982,  0.061915);\ncurve_to(  0.059701,  0.136316, 0.059701, 0.276275);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.222125, 0.276275);\n\ncurve_to( 0.222125, 0.170135, 0.300263,  0.117066);\ncurve_to(  0.378402,  0.064516, 0.496927, 0.064516);\ncurve_to( 0.614574, 0.064516, 0.692713,  0.117586);\ncurve_to(  0.770852,  0.170656, 0.770852, 0.279396);\ncurve_to( 0.770852, 0.381894, 0.691835,  0.434443);\ncurve_to(  0.613696,  0.487513, 0.496927, 0.487513);\ncurve_to( 0.378402, 0.487513, 0.300263,  0.434964);\ncurve_to(  0.222125,  0.382414, 0.222125, 0.276275);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show112(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.118525, -0.211759);\n\nline_to(  0.118525, 0.552549);\n\nline_to(  0.262511, 0.552549);\n\nline_to(  0.262511, 0.480749);\n\ncurve_to( 0.313433, 0.522893, 0.377524,  0.543704);\ncurve_to(  0.441615,  0.565036, 0.532924, 0.565036);\ncurve_to( 0.652327, 0.565036, 0.743635,  0.528616);\ncurve_to( 0.834943, 0.492196, 0.881475,  0.425598);\ncurve_to(  0.928007,  0.359521, 0.928007, 0.280437);\ncurve_to( 0.928007, 0.195630, 0.876207,  0.127471);\ncurve_to( 0.825285, 0.059834, 0.726953,  0.023413);\ncurve_to(  0.629500,  -0.012487, 0.521510, -0.012487);\ncurve_to( 0.442493, -0.012487, 0.379280,  0.007284);\ncurve_to(  0.316945,  0.027055, 0.276558, 0.057232);\nline_to(  0.276558, -0.211759);\n\nline_to(  0.118525, -0.211759);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.261633, 0.273153);\n\ncurve_to( 0.261633, 0.166493, 0.334504,  0.115505);\ncurve_to(  0.407375,  0.064516, 0.510975, 0.064516);\ncurve_to( 0.616330, 0.064516, 0.690957,  0.117066);\ncurve_to(  0.766462,  0.170135, 0.766462, 0.280957);\ncurve_to( 0.766462, 0.386576, 0.692713,  0.439126);\ncurve_to(  0.619842,  0.491675, 0.517998, 0.491675);\ncurve_to( 0.417032, 0.491675, 0.338894,  0.435484);\ncurve_to(  0.261633,  0.379813, 0.261633, 0.273153);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show113(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.712906, -0.211759);\n\nline_to(  0.712906, 0.058793);\n\ncurve_to( 0.676032, 0.028096, 0.609306,  0.007804);\ncurve_to(  0.543459,  -0.012487, 0.468832, -0.012487);\ncurve_to( 0.302897, -0.012487, 0.182616,  0.066077);\ncurve_to(  0.063213,  0.144641, 0.063213, 0.281478);\ncurve_to( 0.063213, 0.364724, 0.111501,  0.430801);\ncurve_to( 0.160667, 0.496878, 0.252853,  0.530697);\ncurve_to(  0.345917,  0.565036, 0.456541, 0.565036);\ncurve_to(  0.629500,  0.565036, 0.728709, 0.478668);\nline_to(  0.728709, 0.552549);\n\nline_to(  0.870939, 0.552549);\n\nline_to(  0.870939, -0.211759);\n\nline_to(  0.712906, -0.211759);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\nmove_to( 0.225637, 0.277836);\n\ncurve_to( 0.225637, 0.171176, 0.301141,  0.117586);\ncurve_to(  0.376646,  0.064516, 0.482002, 0.064516);\ncurve_to( 0.582968, 0.064516, 0.655838,  0.114984);\ncurve_to(  0.728709,  0.165973, 0.728709, 0.269511);\ncurve_to( 0.728709, 0.379813, 0.651449,  0.435484);\ncurve_to(  0.575066,  0.491155, 0.471466, 0.491155);\ncurve_to( 0.368745, 0.491155, 0.296752,  0.439126);\ncurve_to(  0.225637,  0.387617, 0.225637, 0.277836);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show114(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 682height: 1922\nmove_to( 0.195015, 0.000000);\n\nline_to(  0.195015, 0.552549);\n\nline_to(  0.432551, 0.552549);\n\nline_to(  0.432551, 0.468783);\n\ncurve_to( 0.523460, 0.527575, 0.599707,  0.546306);\ncurve_to(  0.677419,  0.565036, 0.769795, 0.565036);\ncurve_to(  0.903226,  0.565036, 1.041056, 0.534860);\nline_to(  0.950147, 0.447971);\n\ncurve_to(  0.853372,  0.468262, 0.756598, 0.468262);\ncurve_to( 0.670088, 0.468262, 0.601173,  0.449532);\ncurve_to(  0.532258,  0.431322, 0.502933, 0.398543);\ncurve_to(  0.458944,  0.348595, 0.458944, 0.289282);\nline_to(  0.458944, 0.000000);\n\nline_to(  0.195015, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show115(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1024height: 1922\nmove_to( 0.061523, 0.164932);\n\nline_to(  0.235352, 0.179501);\n\ncurve_to( 0.250000, 0.123829, 0.316406,  0.094173);\ncurve_to(  0.383789,  0.064516, 0.503906, 0.064516);\ncurve_to( 0.625000, 0.064516, 0.683594,  0.090531);\ncurve_to(  0.742188,  0.117066, 0.742188, 0.152445);\ncurve_to(  0.742188,  0.184183, 0.690430, 0.202393);\ncurve_to(  0.654297,  0.214880, 0.510742, 0.234131);\ncurve_to( 0.317383, 0.260146, 0.242188,  0.278876);\ncurve_to( 0.167969, 0.298127, 0.128906,  0.331426);\ncurve_to(  0.090820,  0.365245, 0.090820, 0.405827);\ncurve_to( 0.090820, 0.442768, 0.122070,  0.473985);\ncurve_to(  0.154297,  0.505723, 0.208984, 0.526535);\ncurve_to( 0.250000, 0.542664, 0.320313,  0.553590);\ncurve_to(  0.391602,  0.565036, 0.472656, 0.565036);\ncurve_to( 0.594727, 0.565036, 0.686523,  0.546306);\ncurve_to( 0.779297, 0.527575, 0.823242,  0.495317);\ncurve_to(  0.867188,  0.463580, 0.883789, 0.409990);\nline_to(  0.711914, 0.397503);\n\ncurve_to( 0.700195, 0.440167, 0.643555,  0.464100);\ncurve_to(  0.587891,  0.488033, 0.485352, 0.488033);\ncurve_to( 0.364258, 0.488033, 0.312500,  0.466701);\ncurve_to(  0.260742,  0.445369, 0.260742, 0.416753);\ncurve_to(  0.260742,  0.398543, 0.282227, 0.383975);\ncurve_to(  0.303711,  0.368887, 0.349609, 0.359001);\ncurve_to(  0.375977,  0.353798, 0.504883, 0.335068);\ncurve_to( 0.691406, 0.308533, 0.764648,  0.291363);\ncurve_to( 0.838867, 0.274714, 0.880859,  0.242456);\ncurve_to(  0.922852,  0.210198, 0.922852, 0.162331);\ncurve_to( 0.922852, 0.115505, 0.871094,  0.073881);\ncurve_to( 0.820313, 0.032778, 0.723633,  0.009886);\ncurve_to(  0.626953,  -0.012487, 0.504883, -0.012487);\ncurve_to( 0.302734, -0.012487, 0.196289,  0.032258);\ncurve_to(  0.090820,  0.077003, 0.061523, 0.164932);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show116(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 569height: 1922\nmove_to( 0.927944, 0.083767);\n\nline_to(  0.973638, 0.001041);\n\ncurve_to(  0.840070,  -0.007284, 0.734622, -0.007284);\ncurve_to( 0.562390, -0.007284, 0.467487,  0.008845);\ncurve_to( 0.372583, 0.024974, 0.333919,  0.050989);\ncurve_to(  0.295255,  0.077523, 0.295255, 0.161811);\nline_to(  0.295255, 0.479709);\n\nline_to(  0.063269, 0.479709);\n\nline_to(  0.063269, 0.552549);\n\nline_to(  0.295255, 0.552549);\n\nline_to(  0.295255, 0.689386);\n\nline_to(  0.609842, 0.745578);\n\nline_to(  0.609842, 0.552549);\n\nline_to(  0.927944, 0.552549);\n\nline_to(  0.927944, 0.479709);\n\nline_to(  0.609842, 0.479709);\n\nline_to(  0.609842, 0.156608);\n\ncurve_to( 0.609842, 0.116545, 0.625659,  0.105099);\ncurve_to( 0.643234, 0.093652, 0.680141,  0.086889);\ncurve_to(  0.718805,  0.080125, 0.789104, 0.080125);\ncurve_to(  0.841828,  0.080125, 0.927944, 0.083767);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show117(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1139height: 1922\nmove_to( 0.729587, 0.000000);\n\nline_to(  0.729587, 0.081165);\n\ncurve_to(  0.620720,  -0.012487, 0.433714, -0.012487);\ncurve_to( 0.351185, -0.012487, 0.279192,  0.006243);\ncurve_to( 0.208077, 0.024974, 0.172959,  0.053070);\ncurve_to(  0.138718,  0.081686, 0.124671, 0.122789);\ncurve_to(  0.115013,  0.150364, 0.115013, 0.210198);\nline_to(  0.115013, 0.552549);\n\nline_to(  0.273047, 0.552549);\n\nline_to(  0.273047, 0.246098);\n\ncurve_to(  0.273047,  0.172737, 0.282704, 0.147242);\ncurve_to( 0.297630, 0.110302, 0.345917,  0.088970);\ncurve_to(  0.394205,  0.068158, 0.465320, 0.068158);\ncurve_to( 0.536435, 0.068158, 0.598771,  0.089490);\ncurve_to( 0.661106, 0.111342, 0.686567,  0.148283);\ncurve_to(  0.712906,  0.185744, 0.712906, 0.256504);\nline_to(  0.712906, 0.552549);\n\nline_to(  0.870939, 0.552549);\n\nline_to(  0.870939, 0.000000);\n\nline_to(  0.729587, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show118(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1024height: 1922\nmove_to( 0.419922, 0.000000);\n\nline_to(  0.025391, 0.552549);\n\nline_to(  0.210938, 0.552549);\n\nline_to(  0.433594, 0.221644);\n\ncurve_to(  0.469727,  0.168054, 0.500000, 0.110302);\ncurve_to(  0.523438,  0.154006, 0.565430, 0.215401);\nline_to(  0.795898, 0.552549);\n\nline_to(  0.976563, 0.552549);\n\nline_to(  0.583984, 0.000000);\n\nline_to(  0.419922, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show119(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1479height: 1922\nmove_to( 0.223800, 0.000000);\n\nline_to(  0.004057, 0.552549);\n\nline_to(  0.129817, 0.552549);\n\nline_to(  0.244084, 0.233611);\n\nline_to(  0.286680, 0.114984);\n\ncurve_to(  0.289385,  0.123829, 0.323867, 0.228928);\nline_to(  0.438134, 0.552549);\n\nline_to(  0.563218, 0.552549);\n\nline_to(  0.670723, 0.232050);\n\nline_to(  0.706558, 0.126431);\n\nline_to(  0.747803, 0.233091);\n\nline_to(  0.870859, 0.552549);\n\nline_to(  0.989182, 0.552549);\n\nline_to(  0.764706, 0.000000);\n\nline_to(  0.638269, 0.000000);\n\nline_to(  0.524003, 0.330905);\n\nline_to(  0.496281, 0.425078);\n\nline_to(  0.350913, 0.000000);\n\nline_to(  0.223800, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show120(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1024height: 1922\nmove_to( 0.014648, 0.000000);\n\nline_to(  0.393555, 0.287201);\n\nline_to(  0.042969, 0.552549);\n\nline_to(  0.262695, 0.552549);\n\nline_to(  0.421875, 0.422997);\n\ncurve_to(  0.466797,  0.386056, 0.494141, 0.361082);\ncurve_to(  0.537109,  0.395421, 0.573242, 0.421956);\nline_to(  0.748047, 0.552549);\n\nline_to(  0.958008, 0.552549);\n\nline_to(  0.599609, 0.292404);\n\nline_to(  0.985352, 0.000000);\n\nline_to(  0.769531, 0.000000);\n\nline_to(  0.556641, 0.171696);\n\nline_to(  0.500000, 0.218002);\n\nline_to(  0.227539, 0.000000);\n\nline_to(  0.014648, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show121(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1024height: 1922\nmove_to( 0.124023, -0.212799);\n\nline_to(  0.104492, -0.124870);\n\ncurve_to(  0.162109,  -0.133195, 0.205078, -0.133195);\ncurve_to( 0.263672, -0.133195, 0.298828,  -0.122789);\ncurve_to(  0.333984,  -0.112383, 0.356445, -0.093652);\ncurve_to(  0.373047,  -0.079605, 0.410156, -0.023933);\ncurve_to(  0.415039,  -0.016129, 0.425781, -0.001041);\nline_to(  0.032227, 0.552549);\n\nline_to(  0.221680, 0.552549);\n\nline_to(  0.437500, 0.232570);\n\ncurve_to(  0.479492,  0.171696, 0.512695, 0.104579);\ncurve_to(  0.542969,  0.169095, 0.584961, 0.230489);\nline_to(  0.806641, 0.552549);\n\nline_to(  0.982422, 0.552549);\n\nline_to(  0.587891, -0.009365);\n\ncurve_to(  0.524414,  -0.100416, 0.489258, -0.134755);\ncurve_to( 0.442383, -0.181061, 0.381836,  -0.202393);\ncurve_to(  0.321289,  -0.224246, 0.237305, -0.224246);\ncurve_to(  0.186523,  -0.224246, 0.124023, -0.212799);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show122(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1024height: 1922\nmove_to( 0.039063, 0.000000);\n\nline_to(  0.039063, 0.075963);\n\nline_to(  0.699219, 0.479709);\n\ncurve_to(  0.586914,  0.476587, 0.500977, 0.476587);\nline_to(  0.078125, 0.476587);\n\nline_to(  0.078125, 0.552549);\n\nline_to(  0.925781, 0.552549);\n\nline_to(  0.925781, 0.490635);\n\nline_to(  0.364258, 0.139958);\n\nline_to(  0.255859, 0.075963);\n\ncurve_to(  0.374023,  0.080645, 0.477539, 0.080645);\nline_to(  0.957031, 0.080645);\n\nline_to(  0.957031, 0.000000);\n\nline_to(  0.039063, 0.000000);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show123(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 684height: 1922\nmove_to( 0.083333, 0.318418);\n\ncurve_to( 0.195906, 0.319459, 0.266082,  0.339750);\ncurve_to( 0.337719, 0.360562, 0.361111,  0.396462);\ncurve_to( 0.384503, 0.432362, 0.385965,  0.519251);\ncurve_to(  0.387427,  0.606139, 0.394737, 0.633715);\ncurve_to( 0.407895, 0.677419, 0.442982,  0.703954);\ncurve_to( 0.479532, 0.730489, 0.532164,  0.746098);\ncurve_to(  0.584795,  0.762227, 0.666667, 0.770552);\ncurve_to(  0.722222,  0.775754, 0.847953, 0.775754);\nline_to(  0.929825, 0.775754);\n\nline_to(  0.929825, 0.694069);\n\nline_to(  0.884503, 0.694069);\n\ncurve_to( 0.732456, 0.694069, 0.682749,  0.674298);\ncurve_to(  0.633041,  0.655047, 0.633041, 0.587409);\ncurve_to(  0.633041,  0.451093, 0.616959, 0.415193);\ncurve_to( 0.590643, 0.359521, 0.526316,  0.329344);\ncurve_to(  0.463450,  0.299168, 0.327485, 0.275754);\ncurve_to( 0.488304, 0.251821, 0.559942,  0.202393);\ncurve_to(  0.633041,  0.153486, 0.633041, 0.041623);\ncurve_to(  0.633041,  -0.059834, 0.638889, -0.079084);\ncurve_to( 0.650585, -0.114464, 0.697368,  -0.128512);\ncurve_to(  0.745614,  -0.142560, 0.884503, -0.142560);\nline_to(  0.929825, -0.142560);\n\nline_to(  0.929825, -0.224246);\n\nline_to(  0.847953, -0.224246);\n\ncurve_to(  0.704678,  -0.224246, 0.640351, -0.215921);\ncurve_to( 0.546784, -0.203954, 0.485380,  -0.176899);\ncurve_to( 0.423977, -0.150364, 0.404971,  -0.109261);\ncurve_to( 0.387427, -0.068158, 0.385965,  0.025494);\ncurve_to( 0.384503, 0.119147, 0.361111,  0.155047);\ncurve_to( 0.337719, 0.190947, 0.266082,  0.211759);\ncurve_to(  0.195906,  0.232570, 0.083333, 0.233611);\nline_to(  0.083333, 0.318418);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show124(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 532height: 1922\nmove_to( 0.353383, -0.224246);\n\nline_to(  0.353383, 0.775754);\n\nline_to(  0.648496, 0.775754);\n\nline_to(  0.648496, -0.224246);\n\nline_to(  0.353383, -0.224246);\n\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show125(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 684height: 1922\nmove_to( 0.915205, 0.318418);\n\nline_to(  0.915205, 0.233611);\n\ncurve_to( 0.802632, 0.232570, 0.730994,  0.211759);\ncurve_to( 0.660819, 0.190947, 0.637427,  0.155047);\ncurve_to( 0.614035, 0.119667, 0.612573,  0.032778);\ncurve_to(  0.611111,  -0.054110, 0.603801, -0.081686);\ncurve_to( 0.590643, -0.125911, 0.554094,  -0.151925);\ncurve_to( 0.519006, -0.178460, 0.466374,  -0.194069);\ncurve_to(  0.413743,  -0.210198, 0.331871, -0.218522);\ncurve_to(  0.276316,  -0.224246, 0.150585, -0.224246);\nline_to(  0.068713, -0.224246);\n\nline_to(  0.068713, -0.142560);\n\nline_to(  0.114035, -0.142560);\n\ncurve_to( 0.266082, -0.142560, 0.315789,  -0.122789);\ncurve_to(  0.365497,  -0.103538, 0.365497, -0.035380);\ncurve_to(  0.365497,  0.094693, 0.378655, 0.129553);\ncurve_to( 0.402047, 0.187305, 0.472222,  0.221644);\ncurve_to(  0.542398,  0.256504, 0.671053, 0.275754);\ncurve_to( 0.502924, 0.304370, 0.434211,  0.351197);\ncurve_to(  0.365497,  0.398543, 0.365497, 0.510406);\ncurve_to(  0.365497,  0.611863, 0.358187, 0.631634);\ncurve_to( 0.347953, 0.666493, 0.299708,  0.680021);\ncurve_to(  0.252924,  0.694069, 0.114035, 0.694069);\nline_to(  0.068713, 0.694069);\n\nline_to(  0.068713, 0.775754);\n\nline_to(  0.150585, 0.775754);\n\ncurve_to(  0.293860,  0.775754, 0.358187, 0.767430);\ncurve_to( 0.451754, 0.755983, 0.513158,  0.728928);\ncurve_to( 0.574561, 0.701873, 0.592105,  0.660770);\ncurve_to( 0.611111, 0.619667, 0.612573,  0.526015);\ncurve_to( 0.614035, 0.432362, 0.637427,  0.396462);\ncurve_to( 0.660819, 0.361082, 0.730994,  0.340271);\ncurve_to(  0.802632,  0.319459, 0.915205, 0.318418);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show126(float xpos, float ypos, float width, float height)\n{\n save(ctx);\nsetScaleAndOffset(   vec2(xpos, ypos), width, height);\n//width: 1196height: 1922\nmove_to( 0.072742, 0.289802);\n\nline_to(  0.072742, 0.396462);\n\ncurve_to(  0.161371,  0.458897, 0.305184, 0.458897);\ncurve_to( 0.355351, 0.458897, 0.410535,  0.449532);\ncurve_to(  0.465719,  0.440687, 0.567726, 0.413632);\ncurve_to( 0.625418, 0.398543, 0.653846,  0.393861);\ncurve_to(  0.683110,  0.389178, 0.712375, 0.389178);\ncurve_to( 0.766722, 0.389178, 0.824415,  0.409469);\ncurve_to(  0.882943,  0.429761, 0.928094, 0.460458);\nline_to(  0.928094, 0.350156);\n\ncurve_to( 0.874582, 0.318939, 0.819398,  0.304891);\ncurve_to(  0.765050,  0.290843, 0.696488, 0.290843);\ncurve_to( 0.646321, 0.290843, 0.600334,  0.298127);\ncurve_to( 0.555184, 0.305411, 0.455686,  0.332986);\ncurve_to(  0.357023,  0.360562, 0.290970, 0.360562);\ncurve_to( 0.237458, 0.360562, 0.189799,  0.345994);\ncurve_to(  0.142977,  0.331946, 0.072742, 0.289802);\nstroke(); // if you want just stroke, uncomment this line and comment the fill();\n //fill();\n\n restore(ctx);\n}\n\n\nvoid show127(float xpos, float ypos, float width, float height)\n{\n     save(ctx);\n    setScaleAndOffset(   vec2(xpos, ypos), width, height);\n    //width: 1536height: 1922\n    move_to( 0.166667, 0.000000);\n\n    line_to(  0.166667, 0.665973);\n\n    line_to(  0.833333, 0.665973);\n\n    line_to(  0.833333, 0.000000);\n\n    line_to(  0.166667, 0.000000);\n\n    stroke(); // if you want just stroke, uncomment this line and comment the fill();\n     //fill();\n    move_to( 0.187500, 0.016649);\n\n    line_to(  0.812500, 0.016649);\n\n    line_to(  0.812500, 0.649324);\n\n    line_to(  0.187500, 0.649324);\n\n    line_to(  0.187500, 0.016649);\n\n    stroke(); // if you want just stroke, uncomment this line and comment the fill();\n     //fill();\n\n     restore(ctx);\n}\n\n \n\nvoid paint() {\n    \n    float t = iTime;\n \n    set_source_rgb(vec3(.0, .0, .0));\n    clear();\n    set_source_rgba(1., 1., 1., 1.);\n    set_line_width(0.02);\n \n    // showxx   you can change xx between 33 and 127\n    //for example show33(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2. );\n    show65(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2. );\n    \n    \n/*    \n  if(c == 33)\n    show33(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2. );\n    else if (c == 33)\n    show33(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 34)\n    show34(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 35)\n    show35(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 36)\n    show36(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 37)\n    show37(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 38)\n    show38(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 39)\n    show39(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 40)\n    show40(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 41)\n    show41(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 42)\n    show42(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 43)\n    show43(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 44)\n    show44(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 45)\n    show45(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 46)\n    show46(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 47)\n    show47(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 48)\n    show48(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 49)\n    show49(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 50)\n    show50(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 51)\n    show51(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 52)\n    show52(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 53)\n    show53(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 54)\n    show54(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 55)\n    show55(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 56)\n    show56(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 57)\n    show57(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    \n        \n        if (c == 58)\n    show58(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 59)\n    show59(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 60)\n    show60(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 61)\n    show61(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 62)\n    show62(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 63)\n    show63(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 64)\n    show64(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 65)\n    show65(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 66)\n    show66(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 67)\n    show67(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 68)\n    show68(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 69)\n    show69(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 70)\n    show70(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 71)\n    show71(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n     if (c == 72)\n    show72(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 73)\n    show73(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 74)\n    show74(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 75)\n    show75(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 76)\n    show76(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 77)\n    show77(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 78)\n    show78(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 79)\n    show79(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 80)\n    show80(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 81)\n    show81(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 82)\n    show82(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 83)\n    show83(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    \n    if (c == 84)\n    show84(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 85)\n    show85(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 86)\n    show86(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 87)\n    show87(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 88)\n    show88(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 89)\n    show89(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 90)\n    show90(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 91)\n    show91(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 92)\n    show92(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 93)\n    show93(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 94)\n    show94(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 95)\n    show95(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 96)\n    show96(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 97)\n    show97(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 98)\n    show98(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 99)\n    show99(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 100)\n    show100(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 101)\n    show101(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 102)\n    show102(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 103)\n    show103(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 104)\n    show104(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 105)\n    show105(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 106)\n    show106(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 107)\n    show107(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 108)\n    show108(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 109)\n    show109(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    \n        \n        if (c == 110)\n    show110(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 111)\n    show111(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 112)\n    show112(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 113)\n    show113(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 114)\n    show114(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 115)\n    show115(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 116)\n    show116(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 117)\n    show117(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 118)\n    show118(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 119)\n    show119(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 120)\n    show120(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 121)\n    show121(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 122)\n    show122(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 123)\n    show123(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 124)\n    show124(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 125)\n    show125(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 126)\n    show126(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n    else if (c == 127)\n    show127(-1., -.5, abs(sin(t))*2., abs(sin(t)) * 2.);\n  */\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3yDn.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[7107, 7107, 7127, 7127, 7180], [7182, 7182, 7202, 7202, 7307], [7309, 7309, 7330, 7330, 7480], [7719, 7719, 7746, 7746, 7772], [7834, 7834, 7855, 7855, 7962], [7964, 7964, 8001, 8001, 8087], [8089, 8089, 8135, 8135, 8168], [8308, 8308, 8336, 8336, 8796], [8824, 8824, 8843, 8843, 8876], [8878, 8878, 8896, 8896, 8929], [8931, 8931, 8955, 8955, 9059], [9061, 9061, 9078, 9078, 9099], [9101, 9101, 9128, 9150, 9433], [9435, 9435, 9463, 9463, 9697], [9699, 9699, 9723, 9723, 9809], [9811, 9811, 9838, 9838, 10051], [10053, 10053, 10079, 10079, 10307], [10309, 10309, 10331, 10331, 10457], [10459, 10459, 10479, 10479, 10539], [10541, 10541, 10573, 10573, 10600], [10602, 10602, 10623, 10623, 10645], [10647, 10647, 10671, 10671, 10731], [10733, 10733, 10767, 10767, 10791], [10793, 10793, 10807, 10807, 10871], [10873, 10873, 10899, 10899, 10937], [10939, 10939, 10965, 10965, 10986], [10988, 10988, 11011, 11011, 11106], [11108, 11108, 11132, 11132, 11201], [11203, 11203, 11228, 11228, 11275], [11277, 11277, 11294, 11294, 11407], [11409, 11409, 11432, 11432, 11561], [11563, 11563, 11591, 11591, 11719], [11721, 11721, 11745, 11745, 11885], [11887, 11887, 11925, 11925, 12059], [12061, 12061, 12098, 12098, 12133], [12135, 12135, 12162, 12162, 12212], [12214, 12214, 12244, 12244, 12300], [12302, 12302, 12331, 12331, 12512], [12514, 12514, 12536, 12536, 12703], [12705, 12705, 12718, 12718, 12757], [12759, 12759, 12789, 12789, 12818], [12820, 12820, 12853, 12853, 12910], [12912, 12912, 12938, 12938, 12988], [12990, 12990, 13011, 13011, 13076], [13078, 13078, 13102, 13102, 13185], [13187, 13187, 13202, 13202, 13243], [13245, 13245, 13261, 13261, 13299], [13301, 13301, 13319, 13319, 13376], [13378, 13378, 13408, 13430, 13812], [13814, 13814, 13872, 13872, 13910], [13912, 13912, 13941, 13941, 13977], [13979, 13979, 14027, 14027, 14058], [14060, 14060, 14094, 14094, 14153], [14155, 14155, 14232, 14232, 14397], [14399, 14399, 14476, 14476, 14556], [14558, 14558, 14634, 14634, 14750], [14752, 14752, 14828, 14828, 14906], [14908, 14908, 14946, 14946, 14980], [14982, 14982, 15004, 15004, 15050], [15052, 15052, 15079, 15079, 15123], [15125, 15125, 15147, 15147, 15541], [15543, 15543, 15572, 15572, 15600], [15602, 15602, 15651, 15651, 15912], [15914, 15914, 15987, 15987, 16041], [16043, 16043, 16075, 16075, 16111], [16113, 16113, 16169, 16169, 16225], [16227, 16227, 16257, 16257, 16350], [16351, 16351, 16391, 16391, 16414], [16416, 16462, 16501, 16501, 17657], [17659, 17659, 17689, 17689, 17791], [17793, 17793, 17845, 17845, 17885], [17887, 17887, 17909, 17909, 17960], [17962, 17962, 17994, 17994, 18016], [18018, 18033, 18055, 18055, 18347], [18349, 18349, 18381, 18381, 18403], [18405, 18405, 18424, 18424, 18456], [18505, 18568, 18610, 18610, 18676], [18678, 18748, 18799, 18799, 19151], [19153, 19187, 19233, 19233, 19745], [19747, 19816, 19862, 19862, 20368], [20370, 20370, 20403, 20403, 20619], [20621, 20621, 20680, 20680, 20725], [20727, 20727, 20770, 20770, 20831], [20833, 20833, 20875, 20875, 20917], [20992, 20992, 21049, 21049, 21248], [21340, 21340, 21404, 21404, 21562], [21563, 21563, 21627, 21627, 22305], [22308, 22308, 22372, 22372, 23114], [23117, 23117, 23181, 23181, 24569], [24572, 24572, 24636, 24636, 26983], [26986, 26986, 27050, 27050, 29595], [29598, 29598, 29662, 29662, 31940], [31943, 31943, 32007, 32007, 32433], [32436, 32436, 32500, 32500, 33225], [33228, 33228, 33292, 33292, 34017], [34020, 34020, 34084, 34084, 35008], [35011, 35011, 35075, 35075, 35694], [35697, 35697, 35761, 35761, 36373], [36376, 36376, 36440, 36440, 36802], [36805, 36805, 36869, 36869, 37231], [37234, 37234, 37298, 37298, 37663], [37666, 37666, 37730, 37730, 39142], [39145, 39145, 39209, 39209, 39814], [39817, 39817, 39881, 39881, 41189], [41192, 41192, 41256, 41256, 43008], [43011, 43011, 43075, 43075, 43882], [43885, 43885, 43949, 43949, 45200], [45203, 45203, 45267, 45267, 47080], [47083, 47083, 47147, 47147, 47857], [47860, 47860, 47924, 47924, 50142], [50145, 50145, 50209, 50209, 52124], [52127, 52127, 52191, 52191, 52805], [52808, 52808, 52872, 52872, 53736], [53739, 53739, 53803, 53803, 54262], [54265, 54265, 54329, 54329, 54944], [54947, 54947, 55011, 55011, 55470], [55473, 55473, 55537, 55537, 57086], [57089, 57089, 57153, 57153, 60655], [60658, 60658, 60722, 60722, 61541], [61544, 61544, 61608, 61608, 63637], [63640, 63640, 63704, 63704, 65054], [65057, 65057, 65121, 65121, 66512], [66515, 66515, 66579, 66579, 67198], [67201, 67201, 67265, 67265, 67820], [67823, 67823, 67887, 67887, 69522], [69525, 69525, 69589, 69589, 70208], [70211, 70211, 70275, 70275, 70637], [70640, 70640, 70704, 70704, 71594], [71597, 71597, 71661, 71661, 72280], [72283, 72283, 72347, 72347, 72774], [72777, 72777, 72841, 72841, 73598], [73601, 73601, 73665, 73665, 74220], [74223, 74223, 74287, 74287, 75697], [75700, 75700, 75764, 75764, 76957], [76960, 76960, 77024, 77024, 78766], [78769, 78769, 78833, 78833, 80384], [80387, 80387, 80451, 80451, 82483], [82486, 82486, 82550, 82550, 83041], [83044, 83044, 83108, 83108, 84114], [84117, 84117, 84181, 84181, 84746], [84749, 84749, 84813, 84813, 85782], [85785, 85785, 85849, 85849, 86680], [86683, 86683, 86747, 86747, 87376], [87379, 87379, 87443, 87443, 88083], [88086, 88086, 88150, 88150, 88645], [88648, 88648, 88712, 88712, 89077], [89080, 89080, 89144, 89144, 89639], [89642, 89642, 89706, 89706, 90164], [90167, 90167, 90231, 90231, 90602], [90605, 90605, 90669, 90669, 91031], [91034, 91034, 91098, 91098, 93323], [93326, 93326, 93390, 93390, 94753], [94756, 94756, 94820, 94820, 96014], [96017, 96017, 96082, 96082, 97496], [97499, 97499, 97564, 97564, 98916], [98919, 98919, 98984, 98984, 99971], [99974, 99974, 100039, 100039, 101861], [101864, 101864, 101929, 101929, 102892], [102895, 102895, 102960, 102960, 103574], [103577, 103577, 103642, 103642, 104593], [104596, 104596, 104661, 104661, 105280], [105283, 105283, 105348, 105348, 105710], [105713, 105713, 105778, 105778, 107257], [107260, 107260, 107325, 107325, 108341], [108344, 108344, 108409, 108409, 109664], [109667, 109667, 109732, 109732, 111201], [111204, 111204, 111269, 111269, 112634], [112637, 112637, 112702, 112702, 113497], [113500, 113500, 113565, 113565, 115495], [115498, 115498, 115563, 115563, 116604], [116607, 116607, 116672, 116672, 117744], [117747, 117747, 117812, 117812, 118377], [118380, 118380, 118445, 118445, 119277], [119280, 119280, 119345, 119345, 120102], [120105, 120105, 120170, 120170, 121231], [121234, 121234, 121299, 121299, 121992], [121995, 121995, 122060, 122060, 123845], [123848, 123848, 123913, 123913, 124278], [124281, 124281, 124346, 124346, 126132], [126135, 126135, 126200, 126200, 127234], [127237, 127237, 127302, 127302, 127989], [127994, 127994, 128008, 128008, 135926]], "test": "error"}
{"id": "Md3yRf", "name": "The Rabbit Hole", "author": "rigel", "description": "Click your mouse to follow the white rabbit down to the rabbit hole ! Fullscreen is better.", "tags": ["2d", "droste", "escher", "kifs", "fold"], "likes": 31, "viewed": 946, "published": "Public API", "date": "1519672883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Rigel rui@gil.com\n// licence: https://creativecommons.org/licenses/by/4.0/\n// link: https://www.shadertoy.com/view/Md3yRf\n\n\n/*\nThis was inpired by Escher painting \"Print Gallery\" and this lecture\nhttps://youtu.be/clQA6WhwCeA?t=7m50s\n\nI wanted to do something with the Escher/Droste effect, and I discovered \nthis blog post http://roy.red/droste-.html#droste \nby user Roy Wiggins https://www.shadertoy.com/user/roywig\n\nAnd his other post about KIFS (Kaleidoscopic Iterated Function Systems)\nhttp://roy.red/folding-the-koch-snowflake-.html#folding-the-koch-snowflake\n\nAn this sended me along a rabbit hole of folding space, and constructing \nKIFS with escher like spiral zooms :) \n\nThere are plenty of Escher/Droste effect on shadertoy, but this one by reinder\nis like total magic. https://www.shadertoy.com/view/Mdf3zM\n*/\n\n\n// utility functions\n// conversion from cartesian to polar\nvec2 toPolar(vec2 uv) { return vec2(length(uv),atan(uv.y,uv.x)); }\n// conversion from polar to cartesian\nvec2 toCarte(vec2 z) { return z.x*vec2(cos(z.y),sin(z.y)); }\n// complex division in polar form z = vec2(radius,angle)\nvec2 zdiv(vec2 z1, vec2 z2) { return vec2(z1.x/z2.x,z1.y-z2.y); }\n// complex log in polar form z = vec2(radius,angle)\nvec2 zlog(vec2 z) { return toPolar(vec2(log(z.x),z.y)); }\n// complex exp in polar form z = vec2(radius,angle)\nvec2 zexp(vec2 z) { z = toCarte(z); return vec2(exp(z.x),z.y); }\n// smoothstep antialias with fwidth\nfloat ssaa(float v) { return smoothstep(-1.,1.,v/fwidth(v)); }\n// stroke an sdf 'd', with a width 'w', and a fill 'f' \nfloat stroke(float d, float w, bool f) {  return abs(ssaa(abs(d)-w*.5) - float(f)); }\n// fills an sdf 'd', and a fill 'f'. false for the fill means inverse \nfloat fill(float d, bool f) { return abs(ssaa(d) - float(f)); }\n// a signed distance function for a rectangle 's' is size\nfloat sdfRect(vec2 uv, vec2 s) { vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }\n// a signed distance function for a circle, 'r' is radius\nfloat sdfCircle(vec2 uv, float r) { return length(uv)-r; }\n// a signed distance function for a hexagon\nfloat sdfHex(vec2 uv) { vec2 auv = abs(uv); return max(auv.x * .866 + auv.y * .5, auv.y)-.5; }\n// a signed distance function for a equilateral triangle\nfloat sdfTri(vec2 uv) { return max(abs(uv.x) * .866 + uv.y * .5, -uv.y)-.577; }\n// a 'fold' is a kind of generic abs(). \n// it reflects half of the plane in the other half\n// the variable 'a' represents the angle of an axis going through the origin\n// so in normalized coordinates uv [-1,1] \n// fold(uv,radians(0.)) == abs(uv.y) and fold(uv,radians(90.)) == abs(uv.x) \nvec2 fold(vec2 uv, float a) { a -= 1.57; vec2 axis = vec2(cos(a),sin(a)); return uv-(2.*min(dot(uv,axis),.0)*axis); }\n// 2d rotation matrix\nmat2 uvRotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n\n// this functions 'folds' space with the symmetries of the Koch Snowflake\n// https://en.wikipedia.org/wiki/Koch_snowflake\n// it returns a coordinate system uv, where you can draw whatever you like\n// 'n' is the number of iterations\nvec2 uvKochSnowflake(vec2 uv, int n) {\n    uv = fold(vec2(-abs(uv.x),uv.y),radians(150.))-vec2(.0,.44);\n    for (int i=0; i<n; i++) \n        uv = fold(vec2(abs(uv.x),uv.y)*3.-vec2(.75,.0),radians(60.))-vec2(.75,.0);\n    return uv;\n}\n\n// this functions 'folds' space with the symmetries of the Sierpinski Carpet\n// https://en.wikipedia.org/wiki/Sierpinski_carpet\n// it's like the 2d equivalent of the menger sponge\n// it returns a coordinate system uv, where you can draw whatever you like\n// 'n' is the number of iterations\nvec2 uvSierpinskiCarpet(vec2 uv, int n) {\n    for (int i=0; i<n; i++) {\n        uv = fold(abs(uv*3.),radians(45.))-vec2(2.0,1.0);\n        uv = vec2(uv.x,abs(uv.y)-1.);\n    }\n    return uv;    \n}\n\n// the scene\nvec3 TheRabbitHole(vec2 uv) {\n\n    // a flag for the scene\n    float sc = 1.;\n\t// save current uv for the rabbit\n    vec2 uvr = uv;\n\n    // if mouse clicked apply the Escher/Droste transform\n    if (iMouse.z >.0) {\n        float scale = log(4.);\n        float angle = atan(scale/6.283);\n        \n        // this line is an infinite zoom\n        uv /= exp(mod(iTime*.8,6.283/angle));\n        \n        // this line is the Escher Deformation with a vec2(scale,rotation)\n        uv = toCarte(zexp(zdiv(zlog(toPolar(uv)),vec2(cos(angle),angle))));\n        \n        // this line is the Droste Effect for the size of the frame\n        uv /= exp(scale*floor(log(sdfRect(uv*vec2(.8,.66),vec2(0.)))/scale));\n        sc = -1.;\n    }\n\n    // the frame\n    float frame = min(\n        stroke(sdfRect(uv,vec2(1.5,1.75)),.5,true),\n        // drawing a simple rectangle in the sierpinsi carpet coordinate system\n        fill(sdfRect(uvSierpinskiCarpet(mod((uv-vec2(.25,.0))*6.,3.)-1.5,2),vec2(1.)),false));\n\n    // the canvas behind the rabbit\n    float canvas = fill(sdfRect(uv,vec2(1.4,1.6)),true)*(1.-sdfRect(uv,vec2(.4,.6)));\n    \n    // uv for the rabbit\n    uvr = sc == 1. ? uvr*.2+vec2(0.,.15) : uvr*.5*uvRotate(iTime*4.);\n    \n    // uv for the rabbit ears\n    vec2 uvears = vec2(abs(uvr.x),uvr.y)*uvRotate(radians(-20.)); \n    float ears = stroke(sdfCircle(vec2(-abs(uvears.x),uvears.y)-vec2(.16,.3),.2),.04,true); \n    \n    // uv for the rabbit eyes\n    vec2 uveyes = vec2(abs(uvr.x),uvr.y)*uvRotate(radians(-40.)); \n    float eyes = fill(sdfCircle(vec2(-abs(uveyes.x),uveyes.y)-vec2(.05,.1),.07),false); \n    \n    // nose ant teeth\n    float nose = fill(sdfCircle(vec2(abs(uvr.x),uvr.y)-vec2(.008,.0),.02),false);\n    float teeth = fill(sdfRect(vec2(abs(uvr.x),uvr.y)-vec2(.007,-.045),vec2(.005,.015)),false);\n\n    // the face is just a bunch of circles\n    float face = max(max(\n        fill(sdfCircle(uvr-vec2(.0,.0),.07),true),\n        fill(sdfCircle(vec2(abs(uvr.x),uvr.y)-vec2(.078,.05),.07),true)),\n        fill(sdfCircle(uvr-vec2(.0,.1),.12),true));\n    \n    // compose the rabbit\n    float rabbit = min(min(min(eyes,nose),teeth),max(ears,face));\n\n    // a coodinate system uv for the Koch Snowflake KIFS\n    vec2 uvka = uvKochSnowflake(vec2(abs(uv.x),uv.y)*.7-vec2(2.3,.0),2);\n    vec2 uvkb = vec2(uvka.x,mod(uvka.y+iTime,.8)-.4);\n    // drawing a pattern with this uv\n    float kifs = max(max(max(min(\n        fill(sdfCircle(uvkb,.4),false),\n        fill(sdfRect(uvka-vec2(.0,-1.5),vec2(.6,6.)),true)),\n        stroke(sdfRect(uvka,vec2(1.,.2)),.3,true)),\n        fill(sdfHex(uvka-vec2(cos(iTime),sin(iTime)*2.)),true)), \n        fill(sdfRect(uvkb,vec2(.2)),true));\n\n    // the small clock on the left\n    vec2 uvc = (uv+vec2(3.3,.0))*1.2;\n    vec2 uvch = sc==1. ? uvc : uvc*uvRotate(radians(iTime*60.));\n    float chronos = min(min(\n        fill(sdfHex(uvc),true),\n        stroke(sdfCircle(uvc,.4),.1,false)+\n        stroke(mod(atan(uvc.y,uvc.x)+radians(15.),radians(30.))-radians(15.),.15,false)),\n        fill(sdfRect(uvch-vec2(.0,.15),vec2(.03,.15)),false));\n    \n    // the small card figure on the right    \n    vec2 uvh = (uv-vec2(3.3,.0))*1.2;\n    float card = max(max(stroke(sdfHex(uvh),.1,true),\n    fill(sdfCircle(vec2(uvh.x,-sc*uvh.y-sqrt(abs(uvh.x)*.25)+.15)*1.2,.3),true)),\n    fill(sdfTri(uvh*7.+vec2(.0,2.2)),true)*sc);\n\n\t// background\n    vec3 c = vec3(.9)* (sc == 1. ? 1. : 1.2-length(uv)*.15);\n    // mixing all components together\n    c = mix(c,vec3(.1),canvas);\n    c = mix(c,vec3(.6)-sc*vec3(.3),kifs);\n    c = mix(c,vec3(.3)-sc*vec3(.3,.0,.0),chronos);\n    c = mix(c,vec3(.3)-sc*vec3(.3,.0,.0),card);\n    c = mix(c,vec3(.2),frame);\n    c = mix(c,vec3(sc),rabbit);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n\n\tfragColor = vec4( TheRabbitHole(uv*6.), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3yRf.jpg", "access": "shaders20k", "license": "cc-by-sa-3.0", "functions": [[834, 893, 916, 916, 959], [960, 998, 1020, 1020, 1058], [1059, 1116, 1145, 1145, 1181], [1182, 1234, 1253, 1253, 1291], [1292, 1344, 1363, 1363, 1408], [1409, 1445, 1466, 1466, 1507], [1508, 1564, 1604, 1604, 1649], [1650, 1721, 1750, 1750, 1784], [1785, 1843, 1875, 1875, 1930], [1931, 1989, 2024, 2024, 2047], [2048, 2092, 2115, 2115, 2186], [2187, 2244, 2267, 2267, 2323], [2324, 2613, 2642, 2642, 2730], [2731, 2753, 2777, 2777, 2822], [2825, 3057, 3095, 3095, 3289], [3291, 3581, 3622, 3622, 3775], [3777, 3790, 3819, 3848, 7494], [7496, 7496, 7553, 7553, 7670]], "test": "valid"}
{"id": "Md3yWn", "name": "Sushi. SHARI.", "author": "gyabo", "description": "TDF2015 seminar Make Sushi With Raymarching livecoding(20min) template.\nNO NETA. ONLY SHARI ;-)\nWe recruited the SUSHINETA on the day of the seminar and live-coded it.", "tags": ["raymarchingsushi"], "likes": 2, "viewed": 123, "published": "Public", "date": "1518405970", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define ITE_MAX      50\n#define DIST_COEFF   1.00\n#define DIST_MIN     0.01\n#define DIST_MAX     1000.0\n\n#define ID_NONE      0.0\n#define ID_TABLE     1.0\n#define ID_GETA      2.0\n#define ID_SHARI     3.0\n\n#define ID_NETA1     4.0\n#define ID_NETA2     4.0\n\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a), \n\t\tp.x * sin(a) + p.y * cos(a));\n\t\t\n}\n\nfloat box(vec3 pos, vec3 scale, float r) {\n\t\n\treturn length(max(abs(pos) - scale , 0.0)) - r;\n}\n\nvoid geta(vec3 p, out float id, out float t) {\n\t//p.xz = rot(p.xz, time + p.z);\n\tfloat w  = DIST_MAX;\n\tvec3 tp  = p;\n\tvec3 mp  = p;\n\tt = 0.1 + dot(p, vec3(0, 1, 0));\n\tid = ID_TABLE;\n\n\t//GETA\n\tmp.y += 0.0;\n\ttp = mp + vec3(0, 0, 0);\n\tw = box(tp, vec3(0.5, 0.01, 0.2), 0.001);\n\tif(w < t) id = ID_GETA;\n\tt = min(t, w);\n\t\n\ttp = mp + vec3(0.3, 0.1, 0);\n\tw = box(tp, vec3(0.07, 0.1, 0.2), 0.001);\n\tif(w < t) id = ID_GETA;\n\tt = min(t, w);\n\n\ttp = mp + vec3(-0.3, 0.1, 0);\n\tw = box(tp, vec3(0.07, 0.1, 0.2), 0.001);\n\tif(w < t) id = ID_GETA;\n\tt = min(t, w);\n\n\t//SHARI\n\ttp = mp + vec3(-0.2, -0.04, 0);\n\tw = length(max(abs(tp) - vec3(0.05, 0.0005, 0.002) * 1.6 , 0.0)) - 0.05;\n\tif(w < t) id = ID_SHARI;\n\tt = min(t, w);\n\n\ttp = mp + vec3(0.2, -0.04, 0);\n\tw = length(max(abs(tp) - vec3(0.05, 0.005, 0.002) * 1.6 , 0.0)) - 0.05;\n\tif(w < t) id = ID_SHARI;\n\tt = min(t, w);\n\n}\n\n\n\nfloat map(vec3 p, out float id) {\n\tfloat t  = DIST_MAX;\n\tp.xz = mod(p.xz, 1.4) - .7; \n\t//p = mod(p, 2.0) - 1.0; \n\tgeta(p, id, t);\n\treturn t;\n}\n\n// \nfloat rnd(vec2 p){\n    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec4 gentex(vec3 ip, float id) {\n\tif(id == ID_TABLE) return vec4(5,3,2,1) * 0.4;\n    if(id == ID_SHARI) return vec4(3.0);\n\tif(id == ID_GETA)  return vec4(rnd(ip.xy * 0.0002)) * vec4(5,3,2,1) * 0.4;\n\tif(id == ID_NETA1) return vec4(rnd(ip.xy * 0.002)) * vec4(5,3,2,1) * 0.4;\n\treturn vec4(1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    vec2 uv      = ( gl_FragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec3  dir    = normalize(vec3(uv * vec2(aspect, 1.0), 1.0));\n\tdir.yz = rot(dir.yz, 0.7);\n    float kmk = fract(time * 0.5);\n    float imk =  (time - kmk ) + smoothstep(0.25, 0.75, kmk);\n\tvec3 pos     = vec3(0.7 + imk, 1.5 + cos(imk), 0.1);\n\tfloat t      = 0.0;\n\tfloat id     = ID_NONE;\n\tfor(int i = 0 ; i < ITE_MAX; i++) {\n\t\tfloat ttemp = map(t * dir + pos, id);\n\t\tif(ttemp < DIST_MIN) break;\n\t\tt += ttemp * DIST_COEFF;\n\t}\n\tvec3 ip = pos + dir * t;\n\n\n\tvec3 color = gentex(ip, id).xyz * abs(min(0.9, map(ip.xyz + 0.1, id))) + vec3(t * 0.02);\n\tif(id == ID_SHARI) fragColor *= vec4(4.0);\n    color = pow(color, vec3(1.0 / 2.2));\n\tcolor *= (1.0 - dot(uv * 0.5, uv));\n\tfragColor = vec4(color, 1.0) + abs(sin(imk)) * vec4(1,1,3,1) * 0.05;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3yWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 259, 286, 286, 369], [371, 371, 413, 413, 466], [468, 468, 514, 547, 1324], [1328, 1328, 1361, 1361, 1470], [1472, 1488, 1506, 1506, 1574], [1577, 1577, 1609, 1609, 1870], [1874, 1874, 1931, 1931, 2813]], "test": "valid"}
{"id": "MdccWH", "name": "Truchet regions", "author": "huttarl", "description": "Playing with truchet tiles, with color-filling of \"emergent\" regions. At the moment we don't fill them intelligently, we just use parity to choose one of two colors.", "tags": ["2d", "truchet", "tiling"], "likes": 5, "viewed": 569, "published": "Public API", "date": "1518649614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nIdea: 2D truchet tiles\n Each tile is oriented according to some background data,\n e.g. some electric charges of various strengths and polarities\n moving around behind the scenes.\n\n Then once the tiles are oriented, the bonus is to color in\n the enclosed regions.\n - The hard part is to try to preserve the colors of most of the\n   regions, even as their shape changes ... then what determines their color?\n - An easy way is to do it with two colors (Duotone Surfaces -\n   http://oaktrust.library.tamu.edu/handle/1969.1/149501) that doesn't\n   rely on computation outside the single given tile? Yes... the corners'\n   color can rely solely on the parity of the tile's coordinates.\n   There may not be time to do any real filling, even using multipass buffers...\n\nTo try:\n- how about animating the changing of tiles: e.g. rotating them, or fading the center\n  diamond shape from one color to the other.\n  \n*/\n\n// Display grid lines?\n// #define GRIDLINES 1\n\nconst float tileSize = 0.1; // Tile size relative to viewport height\nconst float lineWidth = 0.05; // Line thickness relative to tile size\n\n// Determine orientation of tile at i,j.\nbool ori1(ivec2 ij) {\n    // Alternating: return (ij.x + ij.y) % 2 == 0;\n    // More varied, randomish pattern:\n    return fract(sin(float(ij.x) * 13493.45 + iTime * .01) +\n                 cos(float(ij.y) * 1706.93 - iTime * .013)) > .5;\n}\n\n// Determine orientation of tile at i,j.\nbool orientation(ivec2 ij) {\n    /* Mixing up the orientation based on orbiting electric charges.\n\tTo try: instead, determine orientation based on value v at (i, j, iTime)\n    in 3D gradient noise. We could animate the transition based on\n    smoothstep(.4, .6, v) if v goes from 0 to 1. */\n    const float nCharges = 29.;\n    vec2 totalEffect = vec2(0.);\n    \n    for (float i = 0.; i < nCharges; i += 1.) {\n        float strength = mod(i * .65, 2.) - 1.,\n\t        r = fract(i * .74) * 10. + .5,\n        \ta = iTime * (i + 5.) * .001 + i * 22.;\n        \n        vec2 c = vec2(r * cos(a), r * sin(a));\n        vec2 d = vec2(ij) - c;\n        totalEffect += normalize(d) * strength * 4. / dot(d, d);\n    }\n\t\n\treturn (totalEffect.x < 0. ^^ totalEffect.y < 0.);\n}\n\nvec3 color(vec2 uv) {\n    const vec3 line = vec3(.2);    \n\n    // Coordinates of current tile\n    vec2 ij1;\n    // Coordinate within current tile (0 to 1)\n    vec2 p = modf(uv / tileSize, ij1);\n    ivec2 ij = ivec2(ij1);\n    // Make ij row/column left of/below the origin = -1 instead of -0.\n    if (p.x < 0.) ij.x -= 1;\n    if (p.y < 0.) ij.y -= 1;\n\n    // Make p non-negative.\n    p = fract(p + vec2(1.));\n    \n    // Is this an odd or even-position tile?\n    bool parity = ((ij.x + ij.y) % 2 == 0);\n    // Which way do the lines go?\n    bool ori = orientation(ij);\n\n    // Corner point; swizzle to change corners.\n    vec2 c = vec2(0., 1.), c1, c2;\n    c1 = ori ? c.xx : c.xy;\n    c2 = ori ? c.yy : c.yx;\n    \n    const float arcR = .5;\n    \n    // Distance from arcs\n    float r1 = distance(p, c1) - arcR, r2 = distance(p, c2) - arcR;\n    bool inCorner = (min(r1, r2) < 0.);\n    \n    // Min abs distance from arcs\n    float d = min(abs(r1), abs(r2));\n\n    const vec3 A = vec3(.4), B = vec3(.82, .71, .55);\n    vec3 background = (parity ^^ ori ^^ inCorner) ? A : B;\n\n    vec3 col = mix(line, background, smoothstep(0., lineWidth, d));\n    \n    \n#ifdef GRIDLINES\n    float gridD = min(min(p.x, p.y), min(1. - p.x, 1. - p.y));\n    col = mix(line, col, smoothstep(0., .05, gridD));\n\t// origin dot:\n    col = mix(vec3(0.), col, smoothstep(.01, .02, length(uv)));\n#endif\n    return col;    \n}\n\n// Slowly panning camera.\nvec2 pan() {\n    float a = iTime * .11, a2 = iTime * .3;\n    float r = .3 + sin(a2) * .1;\n    return vec2(r * cos(a), r * sin(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.yy + pan();\n\n    // Time varying pixel color\n    vec3 col = color(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "ld2XDz", "previewfilepath": "https://soundcloud.com/edluhrs/counterpoint-542-bach", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/edluhrs/counterpoint-542-bach", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdccWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1098, 1139, 1160, 1250, 1379], [3574, 3600, 3612, 3612, 3732], [3734, 3734, 3791, 3841, 4033]], "test": "error"}
{"id": "MdcyRM", "name": "Cool Paw Metaballs", "author": "kingish", "description": "Paw looking metaballs.", "tags": ["procedural"], "likes": 0, "viewed": 66, "published": "Public", "date": "1518147166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float EPSILON = 0.01;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 24.0;\nint MAX_MARCHING_STEPS = 24;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translationMatrix(vec3 translation)\n{\n  return mat4(1,0,0,0,\n              0,1,0,0,\n              0,0,1,0,\n              translation.x, translation.y, translation.z, 1);\n}\n\nstruct SDFData {\n    float SDV;\n    float id;\n};\n    \nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nfloat SDFSphere(vec3 p) {\n    return length(p)-1.0;\n}\n\nSDFData SDFScene(vec3 p) {\n    float rotations[5] = float[](0.0,72.0,144.0,216.0,288.0);\n    \n    vec3 center = vec3(0,1.5,0);\n    \n    center = vec3(rotationMatrix(vec3(1,0,0), -iTime * 90.0) * vec4(center,1));\n    \n    SDFData best = SDFData(1000000000.0, 0.0);\n    \n    for(int i = 0; i < 5; ++i) {\n    \tmat4 trans = translationMatrix(vec3(0,-2,0)) * translationMatrix(center) * translationMatrix(vec3(0,2.0,0)) * \n            rotationMatrix(vec3(1,0,0), iTime * 40.0 + rotations[i]) * \n            translationMatrix(vec3(0,2,0));\n            ;\n        vec3 q = vec3(inverse(trans)*vec4(p,1));\n        float scale = 0.54;\n    \tfloat v = scale * SDFSphere(q/scale);\n        \n        if(v < best.SDV) {\n        \tbest = SDFData(v, 1.0);\n        }\n    }\n    \n    float scale = 1.6;\n    float v = scale * (SDFSphere(p/scale));\n    \n    best.SDV = smin(v, best.SDV, 1.1);\n        \n\n\treturn best;\n}\n\nSDFData raymarch(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        SDFData data = SDFScene(eye + depth * marchingDirection);\n        float dist = data.SDV;\n        if (dist < EPSILON) {\n            return SDFData(depth, data.id);\n        }\n        depth += dist;\n        if (depth >= end) {\n            return SDFData(end, 0.0f);\n        }\n    }\n    return SDFData(end, 0.0f);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n  vec3 f = normalize(center - eye);\n  vec3 s = normalize(cross(f, up));\n  vec3 u = cross(s, f);\n  return mat4(vec4(s, 0.0), vec4(u, 0.0), vec4(-f, 0.0), vec4(0.0, 0.0, 0.0, 1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 dir = rayDirection(70.0, vec2(iResolution.x,iResolution.y), vec2(gl_FragCoord.x, gl_FragCoord.y));\n    vec3 eye = vec3(15.0, 0.0, 0.0);\n\n    mat4 viewToWorld = viewMatrix(eye, vec3(0, 0, 0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    SDFData data = raymarch(eye, worldDir, MIN_DIST, MAX_DIST);\n    float dist = data.SDV;\n    \n    if (dist > MAX_DIST - EPSILON) {\n    \tfragColor = vec4(255,255,255,255) / 255.0;\n        return;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    fragColor = vec4(0,0,0,255.0)/255.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcyRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 154, 154, 800], [802, 802, 844, 844, 978], [1034, 1034, 1075, 1075, 1168], [1174, 1174, 1199, 1199, 1227], [2125, 2125, 2201, 2201, 2597], [2599, 2599, 2664, 2664, 2796], [2798, 2798, 2847, 2847, 3027], [3029, 3029, 3086, 3086, 3697]], "test": "error"}
{"id": "MdcyRs", "name": "preAlpha Vector Field v:0.0.7", "author": "Chris_M_Thomasson", "description": "Fwiw, another experimental vector field with the ability to click and drag an attracting point around the dynamically generated field. This one is isolating field lines. Check out the if condition in line 154 within the ct_vpixel function. This is key.", "tags": ["fractal", "math", "space", "orbit", "field", "vector", "spin", "physics", "dynamic", "art", "gravity"], "likes": 10, "viewed": 3170, "published": "Public API", "date": "1519794883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nPre-Alpha Vector Field by Chris M. Thomasson ver:0.0.7\nThe code is basic, and the math can be streamlined.\nThis is a basic experiment, not thinking of sheer performance yet.\n\nCreate an attractor by clicking and dragging it around. \nCopyright (c) 2018\n___________________________________*/\n\n\n// The number of points in the spiral\n#define CT_N 10\n#define CT_LINES 32\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// A vector field point\nstruct ct_vfpoint\n{\n    vec2 p;\n    float m;\n};\n\n\n// Our global per-pixel points\nct_vfpoint g_vfp[CT_N + 1];\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec2 ct_vfield_normal(\n    in vec2 p,\n    float npow\n){\n    vec2 g = vec2(0.0, 0.0);\n    \n    const int imax = CT_N + 1;\n    \n    for (int i = 0; i < imax; ++i)\n    {\n        vec2 dif = g_vfp[i].p - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1];\n        float mass = pow(sum, npow);\n        \n      \tg[0] = g[0] + g_vfp[i].m * dif[0] / mass;\n      \tg[1] = g[1] + g_vfp[i].m * dif[1] / mass;\n    }\n    \n    return normalize(g);\n}\n\n\nfloat ct_normal_pi(\n    in vec2 z,\n    in float sa\n){\n    float a = atan(z[1], z[0]) + sa;\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    vec2 vn = ct_vfield_normal(z, npow);\n    \n    float a = cos(iTime * .25) * 3.14;\n\n    vec2 rc = vec2(\n        vn[0] * cos(a) - vn[1] * sin(a),\n        vn[0] * sin(a) + vn[1] * cos(a)\n    );\n    \n    float color = ct_normal_pi(vn, a) * float(CT_LINES);\n    color = mod(color, 1.0);\n    float color2 = 0.0;\n    if (color < .1 + abs(cos(iTime * .5)) * .2)\n    {\n        color = 1.0 - color;\n        color2 = 1.0;\n    }\n    \n    else\n    {\n        color = 0.0;\n        color2 = 0.0;\n    }\n    \n\n    return vec4(\n        color2, //mod(color * 4.0, 1.0), \n        mod(color * 3.0, 1.0), \n        mod(color * 2.0, 1.0),\n        1.0\n    );\n}\n\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){\n    const int n = CT_N;\n    float scale = 1.0;\n    \n    for (int x = 0; x < n; ++x)\n    {\n        int y = 0;\n        float xr = float(x) / float(n);\n        float angle = xr * 6.28;// + cos(iTime * .02) * 5.0;\n        \n        g_vfp[x] = ct_vfpoint(\n            vec2(cos(angle), sin(angle)), \n            1.0\n        );\n    }\n    \n    if (iMouse.z > 0.0)\n    {\n        vec2 cm = ct_plane2d_project(plane, vec2(iMouse));\n        g_vfp[n] = ct_vfpoint(\n            cm, \n            -1.6\n        );\n    }\n    \n    return ct_vpixel(c, c, 128, 2.0 + abs(cos(iTime * 3.0)));\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        0.0, \n        0.0, \n        2.0 + cos(iTime * 1.0) * abs(sin(iTime * .5))\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[480, 480, 532, 532, 692], [799, 799, 851, 851, 1540], [1543, 1543, 1605, 1605, 1713], [1851, 1914, 1969, 1969, 2352], [2355, 2355, 2408, 2408, 2510], [2513, 2539, 2619, 2619, 3257], [3260, 3280, 3335, 3335, 3906], [3909, 3923, 3984, 3984, 4333]], "test": "valid"}
{"id": "MdcyW7", "name": "Cuty pusheen", "author": "Flopine", "description": "Little tribute to our beloved pusheen the cat : http://www.pusheen.com/\n\nYou can use your mouse to move a little bit around the cat! ", "tags": ["raymarching", "modeling", "cat", "pusheen"], "likes": 5, "viewed": 163, "published": "Public", "date": "1519139994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind and Leon for teaching me :) \n\n\n#define ITER 90\n#define PI 3.141592\n\n#define MAT_BODY 0.0\n#define MAT_PART 1.0\n\n\n/////////////////////// UTILITIES\nmat2 rot (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec2 mat_min (vec2 obj1, vec2 obj2)\n{\n    if (obj1.x < obj2.x)\n    {\n        return obj1;\n    }\n    else\n    {\n        return obj2;\n    }\n}\n\nfloat  random (vec2 obj)\n{\n\t  return fract(sin(dot(obj,vec2(131,648)))*415461.);  \n}\n\n\n///////////////////////\tSHAPES\nfloat sphe (vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat cylY (vec3 p, float r, float h)\n{\n    return max(length(p.xz)-r, abs(p.y)-h);\n}\n\n// iq's formula\n//c = vec3 (?, largeur de la base, longueur du cone)\nfloat sdCone( in vec3 p, in vec3 c) \n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\n// iq's formula\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n// iq's formula\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\n//////////////////////// MODELING\nfloat tail (vec3 p)\n{\n    p *= 1.5;\n    p.xy*= rot(-PI/4.);\n    p.x -= cos(p.y);\n   float cyl = cylY(p, (p.y+1.5)*0.25,1.);\n    p.y -= 1.2;\n    float sphere = sphe(p, 0.67);\n    return smin(sphere,cyl,0.1); \n}\n\nfloat mouth (vec3 p)\n{\n    p *= 2.;\n    float nose = sdCapsule(p, vec3 (0.), vec3 (0.,.4,0.),0.1);\n   \tp.x = abs(p.x);\n   \tp.y -= sin((p.x-1.)/0.4);\n    p.y -= 0.7;\n    float lips1 = sdCapsule(p, vec3 (0.), vec3 (0.6,.0,0.),0.1);\n    float prim = smin(nose,lips1,0.2);\n    return prim;\n}\n\nfloat mustaches (vec3 p)\n{   \n    p.xz *= rot(PI/25.);\n    p.x = abs(p.x);\n    p.xz *= rot(-PI/15.);\n    p.x -= .6;\n    p.xy *= rot(-PI/5.);\n    p.y -= sin(p.x-2.3/0.4);\n    float must1 = sdCapsule(p, vec3 (0.), vec3(0.6,0.,0.),0.06);\n    float must2 = sdCapsule(p, vec3 (0.,-0.3,0.), vec3(0.6,-0.5,0.),0.05);\n    return min(must1, must2);\n}\n\nfloat ears(vec3 p)\n{\n    vec3 cone_parameters = vec3(1.,0.4,1.); \n    p.x -= 1.;\n    float ears_R = sdCone(p, cone_parameters);\n    p.x += 1.5;\n    float ears_L = sdCone(p, cone_parameters);\n   return min(ears_R, ears_L);\n}\n\nfloat head (vec3 p)\n{\n    float head_shapes = sphe(p, 1.5);\n    float _ears = ears(vec3(p.x,p.y-2.1,p.z));\n    return smin(head_shapes, _ears, 0.5);\n}\n\nfloat body (vec3 p)\n{\n    p.x *= .7;\n    p.z *= 1.4;\n    return udRoundBox(p,vec3 (.2),2.);   \n}\n\nfloat paw (vec3 p)\n{\n    p.y *= 0.9;\n    return sphe(p,0.3);\n}\n\nvec2 basic_shape (vec3 p)\n{\n    float _body = body(vec3(p.x,p.y,p.z));\n    float _head = head(vec3(p.x+2., p.y-0.8,p.z+0.4));\n    float _tail = tail(vec3(p.x-2.5, p.y-0.8,p.z-0.2));\n    float _paw1 = paw(vec3(p.x+2.,p.y+1.8,p.z-0.6));\n    float _paw2 = paw(vec3(p.x+1.,p.y+1.9,p.z+0.8));\n    float _paw3 = paw(vec3(p.x-2., p.y+1.8, p.z -0.6));\n    float _paw4 = paw(vec3 (p.x-.9,p.y+1.9,p.z+0.8));\n    float _paws = min(min(min(_paw1,_paw2),_paw3), _paw4);\n    \n    return vec2(smin(_paws,smin(smin(_body,_head, 0.5), _tail,0.5), 0.5), MAT_BODY);\n}\n\n\nvec2 face (vec3 p)\n{\n    float _eyes1 = sphe(vec3 (p.x+0.2,p.y-0.5,p.z+1.45), .1);\n    float _eyes2 = sphe(vec3 (p.x-0.8,p.y-0.5,p.z+1.25), .1);   \n    float _mouth = mouth(vec3 (p.x-0.3,p.y-0.4,p.z+1.5));\n    float _must = mustaches(vec3 (p.x-0.3,p.y-0.2,p.z+1.));\n    float _face = min(_must,min(_mouth,min(_eyes1, _eyes2)));\n    return vec2(_face, MAT_PART);\n}\n\nvec3 heart (vec2 uv)\n{\n    uv.x += sin(iTime/0.7)*0.2;\n    uv.x = abs(uv.x);\n\n    uv.y -= uv.x*0.7;\n    float circle = step(length(uv), .12); \n    return vec3(0.,1.,1.)*circle;\n}\n\nvec3 background (vec2 uv)\n{\n    float per = 0.7;\n    uv.y += iTime;\n\n    uv = mod(uv-per/2.,per)-per/2.;\n    return 1.-heart(uv); \n}\n\n\n////////////////////////////////////////////////////////////////////\n// CAMERA\nvec3 getcam (vec3 eye, vec3 lookat, vec2 uv, float fov)\n{\n    vec3 forward = normalize(lookat-eye);\n    vec3 right = normalize(cross(vec3(0.,1.,0.),forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward*fov+right*uv.x+up*uv.y);\n}\n\n\n//////////////////////// MAP\nvec2 SDF (vec3 p)\n{\n    p.xz *= rot(iTime);\n\treturn mat_min(basic_shape(p), face(vec3(p.x+2., p.y-0.8,p.z+0.4)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = 2.*(iMouse.xy/iResolution.xy)-1.;\n    vec3 p = vec3(mouse*5.,-6.);\n    vec3 dir = getcam(p, vec3(0.),uv,1.);\n\n    float shad = 0.;\n    vec3 col = vec3 (0.);\n    \n    for (int i = 0; i<ITER; i++)\n    {\n        vec2 d = SDF(p);\n        if (d.x<0.001)\n        {\n            if (d.y == MAT_BODY) shad = float(i)/float(ITER);\n            else if (d.y == MAT_PART) shad = 1.;\n            \n            col = vec3(1.-shad);\n            break;\n        }\n        else col = background(uv);\n        p+=d.x*0.7*dir;\n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcyW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 185, 209, 209, 290], [292, 292, 331, 331, 421], [423, 423, 460, 460, 562], [564, 564, 590, 590, 648], [651, 682, 712, 712, 738], [741, 741, 780, 780, 826], [828, 897, 935, 935, 1102], [1105, 1121, 1166, 1166, 1206], [1208, 1224, 1276, 1276, 1390], [1393, 1427, 1448, 1448, 1636], [1638, 1638, 1660, 1660, 1925], [1927, 1927, 1953, 1953, 2268], [2270, 2270, 2290, 2290, 2493], [2495, 2495, 2516, 2516, 2645], [2647, 2647, 2668, 2668, 2743], [2745, 2745, 2765, 2765, 2807], [2809, 2809, 2836, 2836, 3357], [3360, 3360, 3380, 3380, 3723], [3725, 3725, 3747, 3747, 3903], [3905, 3905, 3932, 3932, 4037], [4040, 4119, 4176, 4176, 4370], [4373, 4402, 4421, 4421, 4517], [4520, 4520, 4577, 4627, 5316]], "test": "valid"}
{"id": "MdcyzB", "name": "IRONICFLUX", "author": "greendestruction", "description": "The words of these songs were composed without any human intervention whatever on an instrument known as a versificator. But the woman sang so tunefully as to turn the dreadful rubbish into an almost pleasant sound.", "tags": ["raydance"], "likes": 16, "viewed": 747, "published": "Public API", "date": "1519341633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* it even comes with a little message */\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat map(vec3 p) {\n    \n    p.z = abs(p.z) - 2.0;\n    p.z = abs(p.z) - 2.0;\n    \n    \n    float gt = iTime * 2.0;\n    p.x += gt;\n    float d = 1000.0;\n    const int n = 12;\n    for (int i = 1; i < n; ++i) {\n        float x = float(i) / float(n);\n        vec3 q = p;\n        q.x += x * 3.141592 * 1.0;\n        q.z = abs(q.z) - 1.0;\n        q.yz *= rot(x * q.x);\n        q.y = abs(q.y) - 2.0;\n        q.y += x * 3.141592 * 0.5;\n        float k = length(q.yz) - 0.125;\n        d = min(d, k);\n        d = max(d, 1.5 * x + gt - p.x);\n    }\n    return min(d, 5.0 + gt - p.x);\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t) * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.5));\n    vec3 o = vec3(0.0, 0.0, 0.0);\n    \n    r.xz *= rot(3.141592 * 0.5);\n    \n    float t = trace(o, r);\n    \n    vec3 w = o + r * t;\n    float fd = map(w);\n\n    float f = 1.0 / (1.0 + t * t * 0.1 + fd * 1000.0);\n\n    vec3 c = vec3(0.0, 0.5, 1.0) * f;\n    \n    c = mix(c, vec3(1.0), 1.0 / (1.0 + t * t * 0.1));\n    \n    c = mix(vec3(0.125), c, 1.0 / (1.0 + t * t * 0.1));\n    \n    vec3 fc = vec3(c);\n    \n    float b = sign((fract(uv.y * 16.0) - 0.5) / 16.0) * 0.5 + 0.5;\n    \n    float b2 = sign(0.8 - abs(uv.y)) * 0.5 + 0.5;\n    \n    fc = mix(fc * vec3(0.5, 0.5, 0.5), fc, b);\n    \n    fc *= b2;\n\n    fragColor = vec4(fc, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcyzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 62, 62, 114], [116, 116, 135, 135, 688], [690, 690, 719, 719, 830], [832, 832, 889, 889, 1697]], "test": "valid"}
{"id": "MdcyzN", "name": "Spindle of Death CIS 566", "author": "lsx", "description": "Spindle of Death CIS 566\nBased on gif https://media.giphy.com/media/26DN7fdyFRqfBjqMw/giphy.gif", "tags": ["3d", "raymarching"], "likes": 4, "viewed": 121, "published": "Public", "date": "1518043411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Assignment 3 CIS 566\n//Adapted from https://www.shadertoy.com/view/Xll3DM\n//Adjust the NUM to change the number of wireframes and white dots\n//Adjust the LAG to change the lag of the white dots' rotations\n#define NUM 16\n#define LAG 0.39\n\n#define MAX_STEPS 96\n#define MIN_DIST 0.001\n#define NORMAL_SMOOTHNESS 0.02\n#define PI 3.14159265359\n\nmat2 Rotate(float angle)\n{\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));   \n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec2 Union(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;;\n}\n\nfloat Sphere(float radius, vec3 position)\n{\n    return length(position) - radius;\n}\n\nfloat Box(float radius, vec3 position)\n{\n    return max(max(abs(position.x), abs(position.y)), abs(position.z)) - radius;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n//http://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\nvec3 rep(vec3 p, vec3 c)\n{\n    return mod(p, c) - 0.5 * c;\n}\nvec2 Scene(vec3 position)\n{\n    float num = float(NUM);\n    float time = -iTime * 3.0;\n    \n    float map = -Sphere(24.0, position);\n    \n    vec2 final = vec2(map, 0.0);\n    \n    float size = 6.0;\n    vec3 newpos = position;\n    pModPolar(newpos.xy, num);\n    final = Union(final, vec2(sdTorus(newpos, vec2(6.0, 0.05)), 1.0));\n    \n    for(float i = 0.0; i<num / 2.0; i += 1.0)\n    {\n        newpos = position + vec3(cos(i * 2.0/num*PI) * sin(time + LAG * i) * size, \n                                 sin(i * 2.0/num*PI) * sin(time + LAG * i) * size, \n                                 cos(time + LAG * i) * size);\n    \tfinal = Union(final, vec2(Sphere(0.3, newpos), 2.0));\n    }\n    return final;\n}\n\nvec4 RayMarch(vec3 origin,vec3 direction)\n{\n    float hitDist = 0.0;\n    vec2 temp = vec2(0.0);\n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        temp = Scene(origin + direction * hitDist);\n        float sceneDist = temp.x;\n        \n        hitDist += sceneDist;\n        \n        if(sceneDist < MIN_DIST)\n        {\n            break;\n        }\n    }\n    \n    return vec4(origin + direction * hitDist, temp.y);\n}\n\nvec3 Shade2(vec4 position)\n{\n    vec3 black = vec3(57, 57, 57)/255.0;\n    vec3 color = vec3(0.0);\n    \n    if(position.w==0.0)\n    {\n        color = vec3(57, 57, 57)/255.0;\n    }\n    else if(position.w==1.0)\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    else if(position.w==2.0)\n    {\n        color = vec3(236, 236, 236)/255.0;\n    }\n    \n    //Background\n    color = mix(color, black, step(22.0, length(vec3(position))));\n    \n    return color;\n}\n\nfloat transform(float a, float b, float change)\n{\n    return a + (b - a) * change;\n}\n\nfloat f1(float x)\n{\n    return min(fract(x /4.0) * 4.0, 1.0);\n}\n\nfloat f2(float x)\n{\n    return -sign((fract(x/8.0)*2.0 - 1.0));\n}\n\nfloat f3(float x)\n{\n    return smoothstep(0.0, 1.0, f1(x) * f2(x)  -(f2(x) * 0.5 - 0.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float iTime2 = iTime * 0.8;\n    \n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float size = 15.0;\n    vec3 rayOrigin = vec3((uv.x) * size , (uv.y) * size, -20.0);\n    vec3 rayDirection = normalize(vec3(0.0, 0.0, 1.0));\n    \n    float change = f3(mod(iTime2, 8.0));\n    float angle = transform(0.0,  1.0 / 2.0 * PI, change);\n    \n    mat2 rotateX = Rotate(angle);\n    mat2 rotateY = Rotate(0.0);\n    mat2 rotateZ = Rotate(iTime);\n    \n    mat3 rotation = rotationMatrix(vec3(0.0, 0.0, 1.0),1.0 / 2.0 * PI);\n    \n    rayOrigin.yz *= rotateX;\n    rayOrigin.xz *= rotateY;\n    rayOrigin *= rotation;\n    rayDirection.yz *= rotateX;\n    rayDirection.xz *= rotateY;\n    rayDirection *= rotation;\n\n    vec4 scenePosition = RayMarch(rayOrigin, rayDirection);\n   \n    //vec3 white = vec3(250, 250, 250)/255.0;\n    vec3 outColor = Shade2(scenePosition);\n\tfragColor = vec4(outColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 341, 367, 367, 435], [437, 437, 482, 482, 954], [956, 956, 986, 986, 1023], [1025, 1025, 1068, 1068, 1108], [1110, 1110, 1150, 1150, 1233], [1234, 1234, 1267, 1267, 1322], [1323, 1353, 1403, 1403, 1793], [1794, 1794, 1820, 1820, 1854], [1855, 1855, 1882, 1882, 2554], [2556, 2556, 2599, 2599, 2968], [2970, 2970, 2998, 2998, 3424], [3426, 3426, 3475, 3475, 3510], [3512, 3512, 3531, 3531, 3575], [3577, 3577, 3596, 3596, 3642], [3644, 3644, 3663, 3663, 3735], [3737, 3737, 3794, 3794, 4785]], "test": "valid"}
{"id": "MddcRM", "name": "Perturbation", "author": "zyddnth", "description": "CMYK perturbation", "tags": ["colors", "circle", "abstract"], "likes": 36, "viewed": 1014, "published": "Public API", "date": "1518281241", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    vec3 p3  = fract(vec3(p) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return 2.0*fract((p3.x + p3.y) * p3.z)-1.0;\n}\n\nfloat noise(float t) {\n    float i = floor(t);\n    float f = fract(t);\n\n    return mix(hash11(i) * f, hash11(i+1.0) * (f - 1.0), f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = vec2(2.0,-2.0)*fragCoord/iResolution.xy + vec2(-1.0,1.0);\n    coord.x *= iResolution.x/iResolution.y;\n\n    vec2 delta = vec2(noise(iTime), noise(iTime+60.0)) * abs(noise(20.0*iTime));\n\n    float rho2c = dot(coord-delta,coord-delta);\n    float rho2m = dot(coord,coord);\n    float rho2y = dot(coord+delta,coord+delta);\n\n    vec3 cmy = vec3(rho2c, rho2m, rho2y) - 0.2;\n    cmy = 0.0025/(cmy*cmy);\n\n    fragColor = vec4(vec3(1.00) - cmy,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddcRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 64, 64, 191], [193, 193, 215, 215, 327], [329, 329, 386, 386, 844]], "test": "valid"}
{"id": "MddcRN", "name": "Julia folder", "author": "Fra32", "description": "\"Folds\" a julia fractal from a circle. Automatically timelapses after a while. Timelapse and operation speed can be adjusted, the seed is specified using the mouse. The overlay maps all solid julia fractals at the current iteration(Overlay offset to fit).", "tags": ["fractal"], "likes": 2, "viewed": 158, "published": "Public", "date": "1518113520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Change these as you desire\nfloat shiftTime = 1.;\nfloat rootTime = 1.;\nfloat timeLapseStart = 10.;\nfloat timeLapseDur = 10.;\nfloat timeLapseIter = 200.;\nfloat sloMoSpeed = .5;\nfloat mandelbrotOverlayOpacity = .75;\n\n\n\n\nvec2 c = vec2(cos(0.2)*.25-1.,sin(0.2)*.25);\nfloat tau = radians(360.);\n\nfloat arg(vec2 p){\n return acos(dot(normalize(p),vec2(1,0)));\n}\n\nvec3 grid(vec2 p, vec3 c){\n    float len = length(p);\n    float arg = arg(p);\n    if(mod(arg*16.+0.125/len,tau)<0.25/len||\n       mod(len+0.0125,.25)<0.025)\n    \treturn c;   \n    \n    return vec3(1.);\n    \n    \n    \n}\nvec2  offset = vec2(1,0);\nvec3 julia(vec2 p){\n    float t = iTime+(timeLapseIter-iTime*(1.-sloMoSpeed))*smoothstep(0.,1.,smoothstep(0.,1.,clamp(iTime-timeLapseStart,0.,timeLapseDur)/timeLapseDur));\n    int fullIter = int(t/(shiftTime+rootTime));\n    float partIter = mod(t,shiftTime+rootTime);\n    \n    vec2 p2 = vec2(p);\n    vec2 p3 = vec2(0.);\n    vec2 c2 = .5*vec2(p)-offset;\n    vec3 gridCol1 = vec3(1);\n    vec3 gridCol2 = vec3(1);\n    float ang2 = 0.;\n    if(partIter >= shiftTime){\n        float prog = smoothstep(0.,1.,(partIter-shiftTime)/rootTime);\n        float len = length(p);\n        float ang = arg(p);\n        if(p.y<0.)\n            ang = tau-ang;\n        float a = pow(2.,prog);\n        ang *= a;\n        ang2 = ang+tau*a;\n        len = pow(len,prog+1.);\n        p = len*vec2(cos(ang),sin(ang));\n        p2 = len*vec2(cos(ang2),sin(ang2));\n    }\n    \n    gridCol1 = grid(p,vec3(0,.6,.9));\n    gridCol2 = grid(p2,vec3(0,.6,.9));\n    \n    if(partIter < shiftTime){\n        p += c*smoothstep(0.,1.,partIter/shiftTime);\n        p2 += c*smoothstep(0.,1.,partIter/shiftTime);\n    }else{\n        p += c;\n        p2 += c;\n    }\n    \n    \n    for(int i = 0;i<fullIter;i++){\n        if(length(p)<4.)\n        p = vec2(pow(p.x,2.)-pow(p.y,2.),2.*p.x*p.y)+c;\n        if(length(p2)<4.)\n        p2 = vec2(pow(p2.x,2.)-pow(p2.y,2.),2.*p2.x*p2.y)+c;\n        if(length(p3)<4.)\n        p3 = vec2(pow(p3.x,2.)-pow(p3.y,2.),2.*p3.x*p3.y)+c2;\n    }\n    \n    vec3 col1 = vec3(0.);\n    vec3 col2 = vec3(0.);\n    vec3 col3 = vec3(.75,.5,.5);\n    \n    if(length(p)>2.)\n        col1 = vec3(1.);\n    if(length(p2)>2.)\n        col2 = vec3(1.);\n    if(length(p3)>2.||distance(4.*(iMouse.zw-iResolution.xy/2.)/iResolution.x,vec2(0,0))>3.||iMouse.x==0.&&iMouse.y==0.)\n        col3 = vec3(1.);\n    if(ang2>2.*tau){\n    \tcol2 = gridCol2 = vec3(1);\n    }\n    if(col3 == vec3(1.))\n    \treturn (col1*gridCol1+col2*gridCol2)/2.;\n    else\n    \treturn mix((col1*gridCol1+col2*gridCol2)/2.,col3,mandelbrotOverlayOpacity);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\tif(iMouse.x==0. && iMouse.y==0.)\n    c = vec2(-1,0.24);\n    else\n    c = 4.*(iMouse.xy-iResolution.xy/2.)/iResolution.x-offset;\n    vec2 uv = 8.*(fragCoord-iResolution.xy/2.)/iResolution.x;\n\n    vec3 col = julia(uv);\n \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddcRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 292, 310, 310, 355], [357, 357, 383, 383, 574], [601, 601, 620, 620, 2579], [2582, 2582, 2639, 2639, 2891]], "test": "valid"}
{"id": "Mddczn", "name": "Into the Woods", "author": "dr2", "description": "Stream meandering through an endless random forest; summer/winter views; use mouse to look around", "tags": ["voronoi", "reflection", "landscape", "tree", "hexagon", "forest", "snow"], "likes": 27, "viewed": 1339, "published": "Public API", "date": "1517832200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Into the Woods\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmootherStep (float a, float b, float x);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HexGrid (vec2 p);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 sunDir, vuPos;\nvec2 gId, trOff;\nfloat tCur, dstFar, szFac, trSym, grHt, trRot, snowFac;\nint idObj;\nconst int idTrnk = 1, idLv = 2, idRk = 3;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\nvec2 TrackPathS (float t)\n{\n  return vec2 (dot (vec3 (1.9, 2.9, 4.3),\n     sin (vec3 (0.23, 0.17, 0.13) * t)), t);\n}\n\nvec2 TrackPath (float t)\n{\n  return TrackPathS (t) + vec2 (dot (vec2 (0.07, 0.08), sin (vec2 (2.5, 3.3) * t)), 0.);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float h, w;\n  h = 0.35 + 0.17 * (sin (dot (p, vec2 (1., 1.4))) + sin (dot (p, vec2 (-1.2, 0.8))));\n  w = abs (p.x - TrackPath (p.y).x) * (1.1 + 0.3 * sin (0.5 * p.y));\n  h = h * SmootherStep (0.75, 1.5, w) - 0.05 * (1. - w * w / 0.64) * step (w, 0.8);\n  return h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.02 * s, 0.3 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 9; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, ht;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId) + trOff;\n  if (szFac > 0.) {\n    dMin /= szFac;\n    p.xz = Rot2D (p.xz, trRot);\n    p.y -= grHt - 0.1;\n    p /= szFac;\n    ht = 2.2;\n    q = p;\n    q.y -= ht;\n    d = PrCylDf (q.xzy, 0.12 - 0.03 * q.y / ht, ht);\n    qq = p;\n    qq.xz = Rot2D (qq.xz, 2. * pi * (floor (trSym * atan (qq.z, - qq.x) / (2. * pi) +\n       0.5) / trSym));\n    q = qq;\n    q.xy = Rot2D (q.xy - vec2 (-0.2, 0.3), -0.3 * pi);\n    d = SmoothMin (d, PrCylDf (q.yzx, 0.09 + 0.02 * q.x / 0.6, 0.6), 0.2);\n    q = qq;\n    q.xy = Rot2D (q.xy - vec2 (-0.2, 1.2 * ht), 0.3 * pi);\n    d = SmoothMin (d, PrCylDf (q.yzx, 0.05 + 0.02 * q.x / 0.5, 0.5), 0.1);\n    DMIN (idTrnk);\n    q = p;\n    q.y -= 2. * ht;\n    d = PrSphDf (q, 1.);\n    q.y -= 1.;\n    d = SmoothMin (d, PrSphDf (q, 0.5), 0.5);\n    q.xz = qq.xz;\n    q.xy -= vec2 (-0.3, -2.);\n    d = SmoothMin (d, PrSphDf (q, 0.6), 0.3);\n    DMIN (idLv);\n    dMin *= szFac;\n  } else  if (szFac < 0.) {\n    q = p;\n    d = PrSphDf (q, - szFac * 0.15);\n    DMIN (idRk);\n  }\n  return dMin;\n}\n\nvoid SetTrParms ()\n{\n  vec2 g, w;\n  float s;\n  szFac = 0.3 + 0.4 * Hashfv2 (17. * gId + 99.);\n  trSym = floor (3. + 2.9 * Hashfv2 (19. * gId + 99.));\n  w = Hashv2v2 (33. * gId);\n  g = HexToPix (gId);\n  s = abs (g.x - TrackPath (g.y).x);\n  if (s < 0.5) {\n    trOff = 0.25 * sqrt3 * w.x * vec2 (cos (2. * pi * w.y), sin (2. * pi * w.y));\n    szFac *= -1.;\n  } else if (s < 2.) {\n    szFac = 0.;\n  } else {\n    trOff = max (0., 0.5 * sqrt3 - szFac) * w.x * vec2 (cos (2. * pi * w.y), sin (2. * pi * w.y));\n    trRot = 0.6 * pi * (Hashfv2 (23. * gId + 99.) - 0.5);\n    grHt = GrndHt (g + trOff);\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = 1. / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2]));\n  pM = HexToPix (PixToHex (ro.xz));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetTrParms ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + 0.002;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < 0.0005 || dHit > dstFar || p.y < 0. || p.y > 10.) break;\n  }\n  if (d >= 0.0005) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-99.);\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    p = ro + rd * d;\n    gId = PixToHex (p.xz);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetTrParms ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += clamp (h, 0.05, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  return mix (vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - rd.y, 8.) +\n     0.35 * pow (max (dot (rd, sunDir), 0.), 6.), vec3 (1.), clamp (0.1 + 0.8 * rd.y *\n     Fbm2 (5. * rd.xz / max (rd.y, 0.001)), 0., 1.));\n}\n\nfloat WaterHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 t;\n  float wFreq, wAmp, ht, tWav;\n  tWav = 0.5 * tCur;\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t = tWav * vec2 (1., -1.);\n    t4 = (p.xyxy + t.xxyy) * wFreq;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    ht += wAmp * dot (pow (1. - sqrt (v4.xz * v4.yw), vec2 (8.)), vec2 (1.));\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p)\n{\n  vec3 vn;\n  vec2 e = vec2 (0.05, 0.);\n  vn.xz = 0.002 * (WaterHt (p.xz) - vec2 (WaterHt (p.xz + e.xy), WaterHt (p.xz + e.yx)));\n  vn.y = e.x;\n  return normalize (vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 col, c1, c2, rbCol, fCol, wCol, snCol, vn, vnw, rog, rdo;\n  vec2 vf;\n  float dstObj, dstGrnd, dstWat, sh, spec, s, h1, h2, glit;\n  bool isRefl, isSky;\n  isRefl = false;\n  isSky = false;\n  spec = 0.;\n  HexVorInit ();\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  rdo = rd;\n  rog = ro + dstGrnd * rd;\n  if (dstWat < min (min (dstGrnd, dstObj), dstFar)) {\n    ro += dstWat * rd;\n    vnw = WaterNf (8. * ro);\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstGrnd = GrndRay (ro, rd);\n    dstObj = ObjRay (ro, rd);\n    isRefl = true;\n  }\n  vf = vec2 (0.);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    snCol = vec3 (0.9, 0.9, 0.95);\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      gId = PixToHex (ro.xz);\n      h1 = Hashfv2 (gId * vec2 (17., 27.) + 0.5);\n      h2 = Hashfv2 (gId * vec2 (19., 29.) + 0.5);\n      if (idObj == idTrnk) {\n        fCol = HsvToRgb (vec3 (0.1 * h1, 0.5, 0.4 - 0.2 * h2));\n        wCol = mix (snCol, mix (fCol, snCol, smoothstep (0.01, 0.2, vn.y)),\n           smoothstep (0.1 * szFac, 0.3 * szFac, ro.y - GrndHt (HexToPix (gId))));\n        vf = vec2 (32., 2.);\n      } else if (idObj == idLv) {\n        fCol = HsvToRgb (vec3 (0.2 + 0.2 * h1, 0.7, 0.8 - 0.4 * h2)) *\n           (1. - 0.2 * Noisefv3 (64. * ro));\n        spec = 0.1;\n        wCol = mix (0.6 * fCol, snCol, 0.2 + 0.8 * smoothstep (-0.8, -0.6, vn.y));\n        vf = vec2 (16., mix (4., 16., 1. - snowFac));\n      } else if (idObj == idRk) {\n        fCol = mix (vec3 (0.4, 0.3, 0.3), vec3 (0.3, 0.4, 0.5), Fbm2 (16. * ro.xz));\n        spec = 0.1;\n        wCol = mix (fCol, snCol, 0.2 + 0.8 * smoothstep (0.1, 0.3, vn.y));\n        vf = vec2 (8., 8.);\n      }\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      gId = PixToHex (ro.xz);\n      SetTrParms ();\n      vn = GrndNf (ro);\n      vf = vec2 (8., 4.);\n      if (snowFac < 1.) {\n        c1 = mix (vec3 (0.1, 0.2, 0.15), vec3 (0.2, 0.4, 0.2),\n           smoothstep (0.3, 0.5, Fbm2 (8. * ro.xz)));\n        if (szFac > 0.) c1 = mix (vec3 (0.15, 0.05, 0.1), c1, 0.2 + 0.8 *\n           smoothstep (0.4 * szFac, 0.7 * szFac, length (ro.xz - HexToPix (gId) - trOff)));\n        c1 *= (1. - 0.2 * Noisefv2 (128. * ro.xz));\n        c2 = vec3 (0.3, 0.3, 0.35) * (1. - 0.2 * Noisefv2 (256. * ro.zy));\n        fCol = mix (c2, mix (c2, c1, smoothstep (0.4, 0.7, vn.y)),\n           smoothstep (0., 0.005 * Noisefv2 (128. * ro.xz), ro.y));\n      } else fCol = vec3 (0.);\n      wCol = vec3 (0.8, 0.8, 0.85);\n    }\n    col = mix (fCol, wCol, snowFac);\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    sh = ObjSShadow (ro, sunDir);\n    col = col * (0.1 + 0.1 * max (dot (normalize (- sunDir.xz), vn.xz), 0.) +\n       0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       sh * spec * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    if (snowFac > 0. && dstGrnd < dstObj) {\n      glit = 64. * step (0.01, max (0., dot (vn, sunDir))) *\n         pow (max (0., dot (sunDir, reflect (rd, vn))), 16.) *\n         pow (1. - 0.6 * abs (dot (normalize (sunDir - rd), VaryNf (512. * ro, vn, 8.))), 8.);\n      col += vec3 (1., 1., 0.8) * smoothstep (0.6, 0.9, snowFac) * step (0.5, sh) * glit;\n    }\n  } else {\n    col = SkyCol (rd);\n    isSky = true;\n  }\n  if (isRefl) {\n    vc = HexVor (128. * rog.xz);\n    vn = normalize (vec3 (-0.7 * vc.yz, 1.).xzy);\n    s = mod (10. * vc.w, 1.);\n    sh = ObjSShadow (rog, sunDir);\n    rbCol = HsvToRgb (vec3 (0.1 + 0.3 * step (2. * s, 1.) + 0.1 * mod (5. * s, 1.),\n       0.2 + 0.2 * mod (17. * s, 1.), 0.2 + 0.2 * mod (12. * s, 1.))) *\n       (0.5 + 0.3 * smoothstep (0., 0.2, vc.x)) * (1. - 0.2 * Noisefv2 (128. * rog.xz));\n    rbCol = rbCol * (0.2 + 0.1 * max (vn.y, 0.) + 0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       sh * 0.1 * pow (max (dot (normalize (sunDir - rdo), vn), 0.), 64.);\n    col = mix (rbCol, 0.95 * col, 1. - 0.9 * pow (dot (- rdo, vnw), 2.));\n    if (isSky) col = mix (col, 1.5 * vec3 (1., 1., 0.9), sh *\n       pow (max (0., dot (sunDir, reflect (rdo, vnw))), 2048.));\n  }\n  col = pow (col, vec3 (0.6));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa, vd;\n  float el, az, tCyc, tt, a, vel;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCyc = 40.;\n  tCur = mod (tCur, 36000.) + floor (floor (dateCur.w / 600.) / (2. * tCyc)) * 2. * tCyc;\n  snowFac = SmoothBump (0.4, 0.9, 0.05, mod (0.5 * tCur / tCyc, 1.));\n  vel = 0.7;\n  vuPos.xz = TrackPathS (vel * tCur);\n  vuPos.y = 0.6;\n  ro = vuPos;\n  vd = TrackPathS (vel * (tCur + 0.2)) - vuPos.xz;\n  az = atan (vd.x, vd.y);\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el = 0.7 * pi * mPtr.y;\n  } else {\n    a = 0.45 * pi * SmoothBump (0.3, 0.7, 0.1, 0.1 * mod (tCur, 0.25 * tCyc));\n    tt = mod (tCur / tCyc, 1.);\n    if (tt < 0.25) az += a;\n    else if (tt < 0.5) az -= a;\n    else if (tt < 0.75) el = -0.4 * a;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 1.6));\n  dstFar = 80.;\n  sunDir = normalize (vec3 (1., 1.5, 0.3));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat SmootherStep (float a, float b, float x)\n{\n  x = clamp ((x - a) / (b - a), 0., 1.); \n  return ((6. * x - 15.) * x + 10.) * x * x * x;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mddczn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[955, 955, 982, 982, 1071], [1073, 1073, 1099, 1099, 1190], [1192, 1192, 1215, 1215, 1483], [1485, 1485, 1519, 1519, 2048], [2050, 2050, 2072, 2072, 2216], [2218, 2218, 2240, 2240, 3318], [3320, 3320, 3340, 3340, 3917], [3919, 3919, 3952, 3952, 5040], [5042, 5042, 5063, 5063, 5263], [5265, 5265, 5302, 5302, 5716], [5718, 5718, 5741, 5741, 5949], [5951, 5951, 5975, 5975, 6525], [6527, 6527, 6550, 6550, 6720], [6722, 6722, 6757, 6757, 10927], [10929, 10929, 10982, 10982, 12271], [12273, 12273, 12306, 12306, 12333], [12335, 12335, 12377, 12377, 12428], [12430, 12430, 12475, 12475, 12578], [12580, 12580, 12637, 12637, 12720], [12722, 12722, 12770, 12770, 12863], [12865, 12865, 12895, 12895, 12969], [12971, 12971, 12995, 12995, 13225], [13227, 13227, 13251, 13251, 13311], [13313, 13313, 13336, 13336, 13469], [13495, 13495, 13515, 13515, 13735], [13737, 13737, 13759, 13759, 14355], [14357, 14357, 14381, 14381, 14517], [14551, 14551, 14575, 14575, 14635], [14637, 14637, 14661, 14661, 14714], [14716, 14716, 14740, 14740, 14870], [14872, 14872, 14896, 14896, 15116], [15118, 15118, 15143, 15143, 15329], [15331, 15331, 15356, 15356, 15581], [15583, 15583, 15604, 15604, 15759], [15761, 15761, 15790, 15790, 16002], [16004, 16004, 16043, 16043, 16223]], "test": "error"}
{"id": "MdtcDn", "name": "3d Julia", "author": "felipunkerito", "description": "Raymarched simple fractal", "tags": ["3d", "fractal"], "likes": 0, "viewed": 520, "published": "Public API", "date": "1518545750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tim iTime * 0.2\n#define PI acos( -1.0 )\n\nmat2 rot( float a )\n{\n\n    return mat2( cos( a ), -sin( a ),\n                 sin( a ),  cos( a ) );\n    \n}\n\nfloat map( vec3 p )  \n{\n\n    if( dot( p, p ) < 5.0 )\n    {\n        \n        for( int i = 0; i < 4; ++i )\n        {\n            \n            p.x = dot( p.x, p.x ) - dot( p.y, p.y ); // * sin( iTime * 0.42 );\n            p.y = dot( p.y, p.y ) - dot( p.x, p.x ); // * sin( iTime * 0.42 );\n            p.z = dot( p.x, p.x ) - dot( p.z, p.x ) ;\n            p.xyz = p.zyx;\n            p.xy *= rot( tim );\n            p.yz *= rot( tim );\n            p.xz *= rot( tim );\n        }    \n        \n    }\n    \n    return ( length( p ) - 1.0 );\n}\n\nvec3 grad( vec3 p )\n{\n\n\n    vec2 e = vec2( 0.001, 0.0 );\n    vec3 n = vec3( map( p + e.xyy ) - map( p - e.xyy ),\n                   map( p + e.yxy ) - map( p - e.yxy ),\n                   map( p + e.yyx ) - map( p - e.yyx )\n                 );\n    return n;\n    \n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n    float res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n    \n        float h = map( ro + rd * t );\n        if( h < 0.0001 ) return 0.0;\n        res = min( res, h * 8.0 / t );\n        t += h;\n        \n    }\n    \n    return res;\n    \n}\n\nvec3 shade( vec3 ro, vec3 rd, float t )\n{\n\n    vec3 p = ro + rd * t;\n    vec3 n = normalize( grad( p ) );\n    vec3 lig = normalize( vec3( sin( iTime ), 0.8, cos( iTime ) ) );\n    vec3 ref = reflect( rd, n );\n    vec3 col;\n    \n    float amb = 0.5 + 0.5 * n.y;\n    float dif = max( 0.0, dot( n, lig ) );\n    float sha = softShadows( p, lig );\n    float spe = pow( clamp ( dot( lig, ref ), 0.0, 1.0 ), 16.0 );\n    \n    //col = vec3( 1.0 );\n    col += vec3( 0.45 ) * amb;\n    col += dif * vec3( 0.5 ) * sha; \n    col *= 2.0 * n;\n    col += 1.0 * spe;\n    \n    return col;\n    \n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    \n    vec4 mouser = iMouse / iResolution.xyxy;\n    \n    //vec3 rd = normalize( vec3( uv, mouser.y ) );\n    \n    vec3 ro = 4.0 * vec3( sin( mouser.x * 2.0 * PI ), 0.0, cos( -mouser.x * 2.0 * PI ) );\n    \n    //vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 ww = normalize( vec3( 0.0 ) - ro );\n    vec3 uu = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    vec3 rd = normalize( uv.x * uu + uv.y * vv + 1.5 * ww );\n    \n    float t = 0.0; float d = 0.002;\n    for( int i = 0; i < 1028; ++i )\n    {\n    \n    \td = map( ro + rd * t );\n        if( d <  0.002 || t > 10.0 ) break;\n        t += d;\n        \n    }\n    \n    vec3 col = d < 0.002 ? shade( ro, rd, t ) : mix( vec3( 0.0 ), vec3( 0.3, 0.2, 0.4 ), length( uv ) );\n    \n    fragColor = vec4( col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtcDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 70, 70, 156], [158, 158, 181, 181, 690], [692, 692, 713, 713, 956], [958, 958, 1003, 1003, 1248], [1250, 1250, 1291, 1291, 1825], [1831, 1831, 1888, 1938, 2807]], "test": "error"}
{"id": "MdtcRr", "name": "Hypnotic Flower Power ", "author": "Flopine", "description": "Make shader and love, not war", "tags": ["raymarching", "colorful", "flower", "repetition"], "likes": 4, "viewed": 311, "published": "Public", "date": "1517866489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Color tricks inspired by IQ's article : http://www.iquilezles.org/www/articles/palettes/palettes.htm\n// and by dlsym shader : https://www.shadertoy.com/view/lljfDd\n// Thanks to wsmind and leon for teaching me :) \n\n\n#define PI 3.141592\n#define TAU 2.*PI\n\nmat2 rot (float angle)\n{\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat2 (c,s,-s,c);\n}\n\nvec2 logmoda (vec2 p, float per)\n{\n    float angle = atan(p.y,p.x);\n\n    float l = length(p);\n    //magic line from dlsym shader\n    float r = log(sqrt(p.x*p.x+p.y*p.y)); \n    angle = mod(angle-per/2.,per)-per/2.;\n    return vec2(angle, r);\n}\n\nfloat cylY (vec3 p, float r)\n{return length(p.xz)-r;}\n\n\nfloat SDF (vec3 p)\n{\n    \n\tfloat per =2.2;\n\tp.xy *= rot(iTime*0.2);\n    p.xy = logmoda(p.xy, TAU/6.);\n    p.xy *= rot(iTime)*p.yz;\n    p.z = mod(p.z-per/2.,per)-per/2.;\n\n    return cylY(p,0.1);\n}\n\n//IQ's code from article : http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette(in float oscill, in vec3 a, in vec3 b, in vec3 c, in vec3 phase )\n{\n    return a + b*cos(TAU*(c*oscill+phase));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 p = vec3 (0.001,0.001, -4.);\n    vec3 dir = normalize(vec3(uv,1.));\n    \n    float shad = .5;\n    \n    for(int i=0; i<90; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001 || d>5.)\n        {\n            shad = float (i)*PI/60.;\n            break;\n        }\n        p += d*dir*0.8;\n    }\n    \n    // Time varying pixel color\n    vec3 col = (1.-shad)/palette(p.z*0.01,\n                                 vec3(0.5), \n                                 vec3(0.5),\n                                 vec3(2.,1.,0.),\n                                 vec3(0.50, 0.30, 0.8)\n                                );\n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtcRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 276, 300, 300, 378], [380, 380, 414, 414, 622], [624, 624, 654, 654, 677], [680, 680, 700, 700, 875], [877, 965, 1045, 1045, 1091], [1093, 1093, 1150, 1200, 1975]], "test": "valid"}
{"id": "Mdtyzj", "name": "Refraction Exercise", "author": "dr2", "description": "Simple example showing refraction and reflection (mousing recommended).\nRepeating sets of three cycles: 1) Vary refractive index. 2) Perturb surface\nnormals by varying amount. 3) Combine both.\n(Uses conditionless normals for block.)\n", "tags": ["raytracing", "reflection", "refraction"], "likes": 9, "viewed": 469, "published": "Public API", "date": "1519598464", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Refraction Exercise\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\nSimple example showing refraction and reflection (mousing recommended).\nRepeating sets of three cycles: 1) Vary refractive index. 2) Perturb surface\nnormals by varying amount. 3) Combine both.\n(Uses conditionless normals for block.)\n*/\n\nvec3 HexGrid (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, blkPos, blkSize, qnBlk[2], qnBall, vnCylOut;\nfloat tCur, dstFar, bCylRad, bCylHt, dCylOut;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\nvec2 BlkHit (vec3 ro, vec3 rd, vec3 blkSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    qnBlk[0] = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    qnBlk[1] = - sign (rd) * step (tp, tp.zxy) * step (tp, tp.yzx);\n  }\n  return vec2 (dMin, df);\n}\n\nfloat BallHit (vec3 ro, vec3 rd, float rad)\n{\n  float dMin, d, b, w;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + rad * rad;\n  if (w >= 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      dMin = d;\n      qnBall = (ro + d * rd) / rad;\n    }\n  }\n  return dMin;\n}\n\nvoid InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, b, w, ws, srdy;\n  dCylOut = dstFar;\n  vnCylOut = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      dCylOut = (- b + ws) / a;\n      s = ro + dCylOut * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylOut.xz = - s.xz / bCylRad;\n    else {\n      dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vnCylOut.y = - srdy;\n    }\n  }\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd;\n  rd = normalize (vec3 (rd.x, max (0.001, rd.y), rd.z));\n  ro.xz += tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  return mix (vec3 (0.2, 0.3, 0.65) + 0.1 * pow (sd, 16.) + 0.2 * pow (sd, 256.), vec3 (0.9),\n     clamp (3. * (Fbm2 (0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz)) - 0.5) * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, qh, rg;\n  vec2 qw;\n  float hy, hhy, hw, ww, f, b, aa, sRotH, sRotV;\n  InCylHit (ro + vec3 (0., - bCylHt + 1.25, 0.), rd);\n  if (vnCylOut.y == 0.) {\n    ro += dCylOut * rd;\n    vn = vnCylOut;\n    hy = (ro.y - 1.75) / bCylHt;\n    hhy = abs (hy) - 0.43;\n    aa = atan (vn.x, - vn.z) / pi;\n    sRotH = mod (64. * 0.5 * (1. + aa) + 0.5, 1.) - 0.5;\n    hw = 0.29;\n    ww = 0.28;\n    qw = abs (vec2 (sRotH, hhy));\n    if (qw.x < ww && qw.y < hw) {\n      qw = abs (qw - 0.5 * vec2 (ww, hw)) - vec2 (0.44 * ww, 0.47 * hw);\n      if (max (qw.x, qw.y) < 0.) col = 0.7 * SkyCol (ro, reflect (rd, vn));\n      else col = vec3 (0.5, 0.5, 0.3) * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.5 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    } else {\n      col = vec3 (0.8, 0.7, 0.5);\n      qw -= vec2 (ww, hw);\n      if (abs (hy) > (1. - 0.85/16.) || max (qw.x, qw.y) < 0.02) {\n        col *= 0.9;\n        vn.xz = Rot2D (vn.xz, - pi * aa);\n        if (abs (hy) > (1. - 0.85/16.)) {\n          sRotV = (1. - abs (2. * SmoothBump (1. - 0.9/16., 0.97, 0.03, abs (hy)) - 1.));\n        } else {\n          sRotV = (1. - abs (2. * SmoothBump (hw, hw + 0.02, 0.02, abs (hhy)) - 1.)) * sign (hhy);\n          vn.xz = Rot2D (vn.xz, 0.4 * pi * sign (sRotH) *\n             (1. - abs (2. * SmoothBump (- (ww + 0.02), ww + 0.02, 0.04, sRotH) - 1.)));\n        }\n        vn.yz = Rot2D (vn.yz, -0.2 * pi * sRotV * sign (hy));\n        vn.xz = Rot2D (vn.xz, pi * aa);\n      } else {\n        qw = 16. * vec2 (12. * aa, hy);\n        rg = ShStagGrid (qw);\n        col *= rg.y * (1. - 0.3 * Noisefv2 (8. * qw));\n        rg.xz *= sign ((abs (vn.x) > 0.5) ? vn.x : vn.z);\n        if (abs (vn.x) > 0.5) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      }\n      col = col * (0.4 + 0.6 * max (dot (vn, sunDir), 0.)) +\n         0.1 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    }\n  } else if (vnCylOut.y > 0.) {\n    ro += dCylOut * rd;\n    b = 1. - smoothstep (-0.1, -0.01, rd.y) * smoothstep (0.4, 0.8, dCylOut / (1.6 * bCylRad));\n    qh = HexGrid (4. * ro.zx);\n    f = max (length (qh.xy) - 0.5, 0.) * b;\n    vn = vec3 (0., Rot2D (vec2 (1., 0.), 4. * f * f));\n    vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n    vn = VaryNf (64. * ro, vn, 0.2 * b);\n    col = vec3 (0.72, 0.75, 0.72) * (1. - 0.1 * b * Noisefv2 (128. * ro.xz)) *\n       (1. - min (0.2 * b * (1. - smoothstep (0.03, 0.06, qh.z)), 0.1));\n    col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n       0.1 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    col *= 0.9 + 0.1 * smoothstep (0., 2., BlkHit (ro - blkPos, sunDir, blkSize).x);\n    col *= 0.7 + 0.3 * smoothstep (0., 3., BallHit (ro - blkPos, sunDir, 0.6 * blkSize.y));\n  } else col = SkyCol (ro, rd);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, vno, rdo, roo, rdr;\n  vec2 dBlock, a;\n  float dBall, rIndx, nVar, tt, b;\n  bool isBall;\n  blkPos = vec3 (0., bCylHt - 2.5, 0.);\n  blkSize = vec3 (2., 1., 2.);\n  tt = floor (mod (tCur / 10., 3.));\n  b = SmoothBump (0.2, 0.8, 0.1, mod (tCur / 10., 1.));\n  rIndx = (tt == 1.) ? 1.05 : 1.05 + 2.5 * b * b;\n  nVar = (tt == 0.) ? 0. : 0.5 * b;\n  col = BgCol (ro, rd);\n  dBlock = BlkHit (ro - blkPos, rd, blkSize);\n  if (dBlock.x < dstFar) {\n    ro += dBlock.x * rd;\n    roo = ro;\n    rdo = rd;\n    vno = VaryNf (ro + 0.1 * tCur, qnBlk[0], nVar);\n    rd = refract (rd, vno, 1. / rIndx);\n    dBlock = BlkHit (ro - blkPos, rd, blkSize);\n    dBall = BallHit (ro - blkPos, rd, 0.6 * blkSize.y);\n    if (dBall < dBlock.y) isBall = true;\n    else {\n      ro += dBlock.y * rd;\n      qnBlk[1] = VaryNf (ro + 0.1 * tCur, qnBlk[1], nVar);\n      rdr = refract (rd, qnBlk[1], rIndx);\n      if (length (rdr) > 0.) {\n        rd = rdr;\n        col = vec3 (0.8, 1., 0.8) * BgCol (ro, rd);\n      } else {\n        rd = reflect (rd, qnBlk[1]);\n        dBlock = BlkHit (ro - blkPos, rd, blkSize);\n        dBall = BallHit (ro - blkPos, rd, 0.6 * blkSize.y);\n        if (dBall < dBlock.y) isBall = true;\n        else col = vec3 (0.8, 1., 0.8) * BgCol (ro, rd);\n      }\n    }\n    if (isBall) {\n      vn = qnBall;\n      qnBall.xz = Rot2D (qnBall.xz, 0.5 * tCur);\n      qnBall.yz = Rot2D (qnBall.yz, 0.3 * tCur);\n      qnBall.xy = Rot2D (qnBall.xy, 0.4 * tCur);\n      a = mod (floor (8. * vec2 (atan (qnBall.x, qnBall.z), asin (qnBall.y)) / pi), 2.) - 0.5;\n      col = vec3 (0.9, 0.7, 0.2) * (0.6 + 0.4 * step (0., sign (a.x) * sign (a.y)));\n      col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.3 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    }\n    col = mix (col, BgCol (roo, reflect (rdo, vno)), pow (1. - abs (dot (rdo, vno)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 20.;\n  bCylRad = 16.;\n  bCylHt = 3.;\n  az = -0.83 * pi + (1.2/16.) * pi * (floor (0.2 * tCur) +\n     smoothstep (0.9, 1., mod (0.2 * tCur, 1.)));\n  el = -0.06 * pi;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, 0.03 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -0.75 * bCylRad);\n  rd = vuMat * normalize (vec3 (uv, 5.));\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdtyzj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[711, 711, 757, 757, 1263], [1265, 1265, 1310, 1310, 1548], [1550, 1550, 1584, 1584, 2105], [2107, 2107, 2139, 2139, 2458], [2460, 2460, 2486, 2486, 2836], [2838, 2838, 2869, 2869, 5826], [5828, 5828, 5863, 5863, 7774], [7776, 7776, 7832, 7832, 8761], [8763, 8763, 8787, 8787, 9017], [9019, 9019, 9043, 9043, 9103], [9105, 9105, 9128, 9128, 9261], [9263, 9263, 9320, 9320, 9403], [9405, 9405, 9435, 9435, 9509], [9543, 9543, 9567, 9567, 9697], [9699, 9699, 9724, 9724, 9910], [9912, 9912, 9933, 9933, 10088], [10090, 10090, 10119, 10119, 10331], [10333, 10333, 10372, 10372, 10552]], "test": "error"}
{"id": "Ml2fWd", "name": "80s grid", "author": "williammanco", "description": "80s grid", "tags": ["grid", "80s"], "likes": 4, "viewed": 269, "published": "Public", "date": "1517666590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from https://www.shadertoy.com/view/4lsSzX\n// thanks to @FabriceNeyret2\n// twitter.com/williammanco\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Variables\n    float col = 20.0;\n    float thickness = 1.05;\n    float antialiasing = 0.001;\n    float intensity = 1.0;\n    float speed = 0.9;\n    vec2 offset = vec2(1.0,1.0);\n   \tvec4 color = vec4(0.0,0.0,1.0,1.0);\n    \n    vec2 uv = (fragCoord.xy/iResolution.x)*col;\n\t\n    //offset animation\n\tvec2 next = vec2(offset.x, iTime*speed);\n    uv += next;\n\t\n    //grid\n    vec2 grep = abs(fract(uv) - 0.5);\n    float grid = max(grep.x,grep.y)*thickness;\n\t\n    //antialiasing\n\tfloat a = antialiasing;\n\tcolor *= smoothstep(0.48-a,0.49+a,grid);\n\n\tfragColor = vec4(color*intensity);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2fWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 162, 178, 744]], "test": "valid"}
{"id": "MlBBWt", "name": "Pentagram", "author": "lsdlive", "description": "Trying to practice 2d shaders.\n\nThus, I'm now in the small pentagram club.", "tags": ["pentagram"], "likes": 3, "viewed": 197, "published": "Public", "date": "1517520774", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265\n#define TWO_PI 2.*PI\n#define pentagon(uv) polygon(uv, 5.)\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// from: https://thndl.com/square-shaped-shaders.html\nfloat polygon(vec2 uv, float n) {\n\tfloat a = atan(uv.x, uv.y) + PI;\n\tfloat r = TWO_PI / n;\n\treturn cos(floor(.5 + a / r) * r - a) * length(uv);\n}\n\nfloat inner(float dist, float radius, float size) {\n\treturn abs(dist - radius) * size;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n\n\tuv *= r2d(sin(iTime));\n\n\t// pentagram mostly inspired from nimitz:\n    // https://www.shadertoy.com/view/XtX3DH\n\t\n    float pen1 = pentagon(uv * vec2(1, -1));\n\tfloat pen2 = pentagon(uv);\n\tfloat d = inner((pen1 - pen2 * .619) * 4.2, .3, .8);\n\n\t// circle\n\td = min(d, inner(length(uv), .35, 2.));\n\n\t// pentagon\n\td = min(d, inner(pen2, .123, 2.5));\n\n\tfragColor = vec4(smoothstep(.1, .11, d));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBBWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 101, 101, 161], [163, 217, 250, 250, 362], [364, 364, 415, 415, 452], [454, 454, 509, 509, 962]], "test": "valid"}
{"id": "MlBfWd", "name": "Eye Wonker", "author": "mooped", "description": "Hex Warp with spirals.", "tags": ["distancefields"], "likes": 0, "viewed": 72, "published": "Public", "date": "1517561878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nfloat circle(vec2 pos, float rad)\n{\n    return length(pos) - rad;\n}\n\nfloat box(vec2 pos, vec2 b)\n{\n  vec2 d = abs(pos) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// This is rough and ready but it works for now\n// https://www.topcoder.com/community/data-science/data-science-tutorials/geometry-concepts-line-intersection-and-its-applications/#!\nvec2 line_line(vec2 s1, vec2 e1, vec2 s2, vec2 e2)\n{\n    float a1 = e1.y - s1.y;\n    float b1 = s1.x - e1.x;\n    float c1 = a1 * s1.x + b1 * s1.y;\n    \n    float a2 = e2.y - s2.y;\n    float b2 = s2.x - e2.x;\n    float c2 = a2 * s2.x + b2 * s2.y;\n    \n\tfloat det = a1*b2 - a2*b1;\n    if(det == 0.0)\n    {\n        // LINES ARE PARALLEL - SHOULD NEVER HAPPEN\n        return s1;\n    }\n    else\n    {\n        return vec2((b2*c1 - b1*c2) / det, (a1*c2 - a2*c1) / det);\n    }\n}\n\nvec2 getMouse()\n{\n    return iMouse.xy/iResolution.y;\n}\n\nfloat dist(vec2 uv)\n{\n    // Experiment with various distance fields\n    //return texture(iChannel0, uv).r;\n    //return min(circle(uv - getMouse(), 0.1), circle(uv - vec2(.5, .5), 0.1));\n    //return min(box(uv - getMouse(), vec2(0.2, 0.1)), circle(uv - getMouse() + vec2(0.2, 0.0), 0.1));\n    return circle(uv - getMouse(), 0.0);\n    //return min(\n    //    min(circle(uv - vec2(0.5, 0.5), 0.1),\n    //       box(uv - vec2(0.75, 0.5), vec2(0.2, 0.1))\n    //    ),\n    //    circle(uv - getMouse(), 0.1)\n    //);\n}\n\nconst float sides = 6.0;\nconst float seg = 2.0 * PI / sides;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.y);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Distance field lookup\n    float d = dist(uv);\n    vec2 n = normalize(vec2(dFdx(d), dFdy(d)));\n    \n    // Calculate angle towards distance field surface (0-2PI)\n    float ang = atan(n.y, n.x) + PI;\n    \n    // Work out the angle at which the segment starts and the angle from segment start to uv\n    float seg_ang = floor(ang / seg) * seg;\n    float rel_ang = abs(ang - seg_ang);\n    \n    // Compute vectors for each edge of the segment\n    vec2 s0 = vec2(cos(seg_ang), sin(seg_ang));\n    vec2 s1 = vec2(cos(seg_ang + seg), sin(seg_ang + seg));\n    \n    // Intersect the distance field normal with the edge of a unit hexagon (s1 - s0) to get a distance adjustment factor\n    float adjust = length(line_line(n, n + (s1 - s0), vec2(0), s1));\n    \n    // Adjust towards the hexagon edge - draws hexagons around the distance field for a circle\n    float val = d * pow(adjust, 0.5 + 0.5 * sin(iTime));\n    \n    val = sin((val + iTime * 0.1 + sin(ang + iTime)) * 50.0) > 0.0 ? 1.0 : 0.0;\n    \n    // Uncomment to silhouette the shapes\n    if (d < 0.0) val = 0.0;\n\n    // Output to screen\n    fragColor = vec4(val * col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBfWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 55, 55, 87], [89, 89, 118, 118, 198], [200, 382, 434, 434, 852], [854, 854, 871, 871, 909], [911, 911, 932, 1201, 1426], [1490, 1490, 1547, 1597, 2862]], "test": "valid"}
{"id": "MljfWc", "name": "Torus_Thingy_12", "author": "balkhan", "description": "torus knot", "tags": ["torus", "knot"], "likes": 12, "viewed": 131, "published": "Public", "date": "1517529187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t110.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 60.0);\n\n    pos.z += 10.5*sin(t*10.);    \n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    col.xyz = ret_col*(1.-inter.x*.005);\n    col += h*.005;\n    c_out =  vec4(col,1.0);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    rotate(p.xz, 1.57-.5*iTime );\n    rotate(p.yz, 1.57-.5*iTime );\n    vec3 op = p;\n    p.xy = modA(p.xy, 15.);\n    p.x -= 25.;\n    var  = atan(op.x,op.y);\n    vec2 q = vec2( ( mylength(p.xy) )-1.,p.z);\n    rotate(q, var*.25+iTime*.5 );\n    q = abs(q)-10.;q = abs(q)-.5;q = abs(q)-.25;\n    ret_col = vec3(1.0, .82, 1.0);\n    mind = mylength(q)-.25;\n    h -= vec3(-.50,.1250,1.)*vec3(1.)*.0125/(.01+mind*mind);\n    h -= vec3(.05,.05,1.)*vec3(1.)*.0125/(.01+mind*mind);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljfWc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[592, 592, 635, 635, 982], [1055, 1055, 1088, 1088, 1219], [1244, 1244, 1265, 1265, 1794], [1796, 1796, 1828, 1828, 2239], [2255, 2255, 2279, 2279, 2376], [2378, 2378, 2418, 2418, 2493], [2495, 2495, 2523, 2523, 2631], [2633, 2633, 2655, 2655, 2861], [2863, 2863, 2913, 2913, 3176]], "test": "error"}
{"id": "MllfW2", "name": "snow mountain2", "author": "ruolan", "description": "raymarch, noise\nlearned from tutorial:http://blog.csdn.net/candycat1992/article/details/50603529", "tags": ["raymarch"], "likes": 4, "viewed": 174, "published": "Public", "date": "1519608630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPHERE 0\n#define TERRAIN 1\n#define SEALEVEL 3\n#define NO_INTERSECT 2\n#define HELIX 5\n\n#define LOD_NORM 10\n#define LOD_RAY 4\n\n#define SEALEVEL_HEIGHT 4.0\n\n#define MIN_HEIGHT 2.0\n#define MAX_HEIGHT 4.5\n#define WIND vec2(0.2, 0.1)\n\nvec3 c_l;\n\nvec3 sundir = normalize(vec3(1.2,0.45,0.5));\n\nvec3 sun(vec3 dir) //makes that bright spot on the sky\n{\n\tfloat sun = dot(dir,c_l);\n\tsun+=1.0; sun*=0.5; sun= pow(sun,127.0);\n\treturn vec3(sun);\n}\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, TERRAIN, or NO_INTERSECT\n};\n\nfloat hash21(vec2 p) {\n    float h = dot(vec2(p),vec2(127.1,311.7));\n    return fract(sin(h)*43758.5453123) * 2.0 - 1.0;\n}\n\nfloat hash31(vec3 p) {\n    p = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat valueNoise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n    vec2 u = pf*pf*pf*(6.0*pf*pf - 15.0*pf + 10.0);\n\n    float va = hash21(pi + vec2(0.0, 0.0));\n    float vb = hash21(pi + vec2(1.0, 0.0));\n    float vc = hash21(pi + vec2(0.0, 1.0));\n    float vd = hash21(pi + vec2(1.0, 1.0));\n\n    return mix(mix(va, vb, u.x), mix(vc, vd, u.x), u.y);\n}\n\n//iq hash\nfloat hash( float n )\n{\n    return fract(sin(n)*54321.98761234);  // value has no meaning that I could find\n}\n\n//iq  noise function\nfloat noise(vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    f= (10.0+(-15.0+6.0*f)*f)*f*f*f; // smooth\n    \n    float n = p.x + p.y*57.0;\n    \n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    \n    return res;\n}\n\nfloat valueNoise(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = fract(p);\n    vec3 u = pf*pf*pf*(6.0*pf*pf - 15.0*pf + 10.0);\n\n    float va = hash31(pi + vec3(0.0, 0.0, 0.0));\n    float vb = hash31(pi + vec3(1.0, 0.0, 0.0));\n    float vc = hash31(pi + vec3(0.0, 1.0, 0.0));\n    float vd = hash31(pi + vec3(1.0, 1.0, 0.0));\n    float ve = hash31(pi + vec3(0.0, 0.0, 1.0));\n    float vf = hash31(pi + vec3(1.0, 0.0, 1.0));\n    float vg = hash31(pi + vec3(0.0, 1.0, 1.0));\n    float vh = hash31(pi + vec3(1.0, 1.0, 1.0));\n\n    return mix(mix(mix(va, vb, u.x), mix(vc, vd, u.x), u.y),\n               mix(mix(ve, vf, u.x), mix(vg, vh, u.x), u.y), u.z);\n}\n\nfloat fbmTerrain(vec2 p, int level) {\n    float amp = 0.51;\n    float freq = 0.03;\n    float sum = 0.0;\n\n    for (int i = 0; i < level; i++) {\n        float vNoise = valueNoise(p * freq);\n        sum += amp * vNoise;\n        freq *= 2.01;\n        amp *= -0.49;\n    }\n    sum = pow(sum, 2.0);\n    return sum * 45.0;\n}\n\nfloat fbmSealevel(vec3 p, int level) {\n    float amp = 0.51;\n    float freq = 0.03;\n    float sum = 0.0;\n\n    for (int i = 0; i < level; i++) {\n        float vNoise = valueNoise(p * freq);\n        sum += amp * vNoise;\n        freq *= 2.01;\n        amp *= -0.49;\n    }\n    //sum = pow(sum, 2.0);\n    return sin(sum * 10.);\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    vec3 spherePosition = vec3(0.0, 2.0, 0.0);\n    float radius = 1.5;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat mapTerrain(vec3 p, int level) {\n    return p.y - (fbmTerrain(p.xz, level) * 1.0 - 10. / (pow(p.x*p.x + p.z*p.z, .1) + 1.));\n}\n\nfloat mapSealevel(vec3 p, int level) {\n    return p.y - SEALEVEL_HEIGHT - fbmSealevel(vec3(p.xz * .1, iTime * .5) * 5., level);\n}\n\nconst float theta = 3.14 * 2. / 16.;\nconst mat2 rotate2D = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n\nfloat mapHelix(vec3 p) {\n    p.y = mod(p.y, 22.2);\n    vec3 offset = vec3(7., 3., 0.);\n    float dh = 1.2;\n    vec3 dimen = vec3(2.5, .1, 1.);\n    float res = 100000.0;\n    for (int i=0; i<0; i++) {\n        res = min(res, udBox(p - offset, dimen)); p.xz = rotate2D * p.xz; p.y -= dh;\n    }\n\treturn res;\n}\n\nPrimitiveDist map(vec3 p) {\n    float terrainDist = mapTerrain(p, LOD_RAY);\n    float sealevelDist = mapSealevel(p, LOD_RAY - 1);\n    float helixDist = mapHelix(p);\n    PrimitiveDist res = PrimitiveDist(terrainDist, TERRAIN);\n\n    //if (sealevelDist < res.dist) res = PrimitiveDist(sealevelDist, SEALEVEL);\n    if (helixDist < res.dist) res = PrimitiveDist(helixDist, HELIX);\n    \n    return res;\n}\n\nPrimitiveDist mapUnderSea(vec3 p) {\n    float terrainDist = mapTerrain(p, LOD_RAY);\n    float helixDist = mapHelix(p);\n    \n    PrimitiveDist res = PrimitiveDist(terrainDist, TERRAIN);\n\n    if (helixDist < res.dist) res = PrimitiveDist(helixDist, HELIX);\n\n    return res;\n}\n\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p, int which) {\n    vec3 norm = vec3(0.);\n    if (which == TERRAIN) {\n        norm.x = mapTerrain(p + e.xyy, LOD_NORM) - mapTerrain(p - e.xyy, LOD_NORM);\n        norm.y = mapTerrain(p + e.yxy, LOD_NORM) - mapTerrain(p - e.yxy, LOD_NORM);\n        norm.z = mapTerrain(p + e.yyx, LOD_NORM) - mapTerrain(p - e.yyx, LOD_NORM);\n    } else if (which == SEALEVEL){\n    \tnorm.x = mapSealevel(p + e.xyy, LOD_NORM) - mapSealevel(p - e.xyy, LOD_NORM);\n        norm.y = mapSealevel(p + e.yxy, LOD_NORM) - mapSealevel(p - e.yxy, LOD_NORM);\n        norm.z = mapSealevel(p + e.yyx, LOD_NORM) - mapSealevel(p - e.yyx, LOD_NORM);\n    } else {\n        norm.x = map(p + e.xyy).dist - map(p - e.xyy).dist;\n        norm.y = map(p + e.yxy).dist - map(p - e.yxy).dist;\n        norm.z = map(p + e.yyx).dist - map(p - e.yyx).dist;\n    }\n\n    return normalize(norm);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.001;\n    float boundingVolume = 35.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n\n    for(int i = 0; i < 30; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        darkness = min(darkness, k * h / marchDist);\n        marchDist += h * 0.7;\n    }\n\n    return darkness;\n}\n\nPrimitiveDist raymarchUnderSea(vec3 ro, vec3 rd, float maxDist, float marchSpeed) {\n    float marchDist = 0.001;\n    float boundingDist = maxDist;\n    float threshold = 0.1;\n\n    // Fill in the iteration count\n    for (int i = 0; i < 100; i++) {\n        // Fill in loop body\n        vec3 pos = ro + rd * marchDist;\n        PrimitiveDist near = mapUnderSea(pos);\n        if (near.dist < threshold)\n            return PrimitiveDist(marchDist, near.primitive);\n        marchDist += near.dist * marchSpeed;\n        if (marchDist > boundingDist) break;\n    }\n\n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd, float maxDist, float marchSpeed) {\n    float marchDist = 0.001;\n    float boundingDist = maxDist;\n    float threshold = 0.1;\n\n    // Fill in the iteration count\n    for (int i = 0; i < 500; i++) {\n        // Fill in loop body\n        vec3 pos = ro + rd * marchDist;\n        PrimitiveDist near = map(pos);\n        if (near.dist < threshold)\n            return PrimitiveDist(marchDist, near.primitive);\n        marchDist += near.dist * marchSpeed;\n        if (marchDist > boundingDist) break;\n    }\n\n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 generateTerrainColor(float t, vec3 pos, vec3 norm, vec3 lig) {\n    vec3 col = vec3(0.0);\n\n    vec3 lightGreen = vec3(0.564, 0.833, 0.564);\n    vec3 lawnGreen = vec3(0.498, 0.99, 0);\n    vec3 springGreen = vec3(0.0, 1.0, 0.5);\n    vec3 greenYellow = vec3(.678, 0.99, .184);\n    vec3 olive = vec3(0.5, 0.5, 0.0);\n    float z = pos.y;\n    z += noise( pos.xz * 47.0 )* 0.2;\n\n    //vec3 grass1 = vec3(.125, .365, .0);\n    //vec3 grass2 = vec3(.16, .274, .141);\n    vec3 grass3 = vec3(.0, .2, .0);\n    vec3 grass4 = vec3(.45, .6, .0);\n    \n    vec3 grass2 = vec3 (.19, .335, .14);\n    vec3 grass1 = vec3 (.478, .451, .14);\n    vec3 snow1 = vec3 ( .78,.78,.78);\n    vec3 snow2 = vec3 ( .9,.9,.9);\n\n    vec3 earth      = vec3(.824, .706, .549);\n    vec3 calcaire   = vec3(.624, .412, .118);\n    vec3 rocks      = vec3(.412, .388, .422);\n    vec3 beach      = vec3( 1.0, .894, .710);\n\n    float posNoise = valueNoise(pos.xz) + 1.0 * 0.5;\n      \n    // Ambient\n    float ambient = 0.2;\n    // Diffuse\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n\n    // base color\n    col = mix (        beach,    earth, smoothstep(0.0 , 0.08 , pos.y) );\n    col = mix ( col, calcaire, smoothstep(0.08, 0.3 , pos.y) );\n    col = mix ( col,    rocks, smoothstep(0.3, 10.0  , pos.y) );\n\n    if (norm.y > 0.5) {\n        col = mix(snow1, snow2, smoothstep(0.0, 10.0, posNoise * 10.0));\n    }\n\n    \n    if (pos.y <=0.) {\n        //col = vec3(0.0, 0.0, 0.8);\n    }\n    \n    float fo = 1.0 - exp( -t*0.001 );\n   \n    vec3 fco = vec3(0.4,0.65,1.0);// + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n    col = mix( col, fco, fo );\n    \n    return ambient + diffuse * col;\n}\n\nvec3 generateHelixColor(vec3 pos, vec3 norm, vec3 lig) {\n    // Ambient\n    float ambient = 0.2;\n    // Diffuse\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n    vec3 col = vec3(1.0, .2, .2);\n    return ambient + col * diffuse;\n}\n\nvec3 generateSeaColor(float t, vec3 ro, vec3 rd, vec3 norm, vec3 lig) {\n    float ndotr = dot(norm, rd);\n    float r0 = .6;\n    float fresnel = r0 + (1. - r0) * pow(1.0 - abs(ndotr), 5.);\n    vec3 col = vec3(.292, .434, .729), reflCol, refrCol;\n    \n    //rd = reflect(rd, vec3(0., 1., 0.));\n    vec3 reflD = reflect(rd, normalize(norm + vec3(.0, .3, .0)));\n    PrimitiveDist res = raymarch(ro, reflD, 100., .5);\n    vec3 reflPos = ro + res.dist * reflD;\n    if (res.primitive == TERRAIN) {\n    \t//col = mix(col, vec3(.3, .3, .3), .5);\n        //col = vec3(0., 0., 0.);\n        reflCol = generateTerrainColor(t, reflPos, calcNormal(reflPos, TERRAIN), lig);\n    }\n    \n    //vec3 refrD = refract(rd, normalize(norm + vec3(.0, .5, .0)), .8);\n    vec3 refrD = refract(rd, vec3(0., 1., 0.), .8);\n    res = raymarchUnderSea(ro, refrD, 20., .8);\n    vec3 refrPos = ro + res.dist * refrD;\n    //refrCol = texture(iChannel1, refrPos.xz * 2.).xyz;\n    if (res.primitive == TERRAIN) {\n        refrCol = generateTerrainColor(t, refrPos, calcNormal(refrPos, TERRAIN), lig);\n    } else if (res.primitive == HELIX) {\n    \trefrCol = generateHelixColor(refrPos, calcNormal(refrPos, HELIX), lig);\n    }\n    \n    col = mix(col, fresnel * reflCol + (1. - fresnel) * refrCol, .8);\n    //col = reflCol * .4;\n    //col *= fresnel;\n    \n    // Ambient\n    float ambient = 0.2;\n    // Diffuse\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n    // Specular \n    float specular = pow(clamp(dot(rd, reflect(lig, norm)), 0.0, 1.0), 32.);\n    \n    return ambient + col * (diffuse + specular);\n}\n\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n\n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(0.2,0.9,0.3));\n    vec3 lightCol = vec3(1., 1., 1.);\n    float shiness = 32.;\n    float gloss = 1.;\n\n\n    // Normal vector\n    vec3 nor = calcNormal(pos, which);\n\n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == TERRAIN) {\n        //material = texCube(iChannel0, pos, nor);\n        col = generateTerrainColor(t, pos, nor, lig);    \n    } else if (which == HELIX) {\n        col = generateHelixColor(pos, nor, lig);\n    } else if (which == SEALEVEL){\n      \tcol = generateSeaColor(t,pos - rd * .05, rd, nor, lig);\n    } \n    \n    // Ambient\n    float ambient = 0.2;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), shiness) * gloss;\n\n    float darkness = shadow(pos, lig, 18.0);\n    // Applying the phong lighting model to the pixel.\n    //col += vec3(((ambient + diffuse + specular) * darkness));\n    //col += vec3(ambient + diffuse + specular);\n\n    // Blend the material color with the original color.\n    //col = mix(col, material, 0.4);\n    //col = ambient + lightCol * material * (diffuse + specular);\n\n    return col;\n}\n\n\n//calculate single noise\nfloat c_noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = floor(x); \n    f = f * f * (3.0 - 2.0 * f);\n    \n    p.xz += WIND * iTime;\n    vec2 uv = (p.xz + vec2(1.0, 10.0) * p.y) + f.xz;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.y);\n}\n\n//calculate fractcal noise\nfloat c_fractal_noise(vec3 p)\n{\n    float fbm = 0.0;\n\n    p = p * 3.0;\n    fbm += 0.50000 * c_noise(p); p = 3.0 * p;\n\tfbm += 0.25000 * c_noise(p); p = 3.0 * p;\n\tfbm += 0.12500 * c_noise(p); p = 3.0 * p;\n\tfbm += 0.06250 * c_noise(p); p = 3.0 * p;\n    \n    return fbm;\n}\n\nfloat c_density(vec3 pos)\n{    \n    return 3.5 * c_fractal_noise(pos * 0.1) - 0.5 + (pos.y - MIN_HEIGHT);    \n}\n\nvec3 c_raymarching(vec3 ro, vec3 rd, float t, vec3 backCol)\n{   \n    vec4 sum = vec4(0.0);\n    vec3 pos = ro + rd * t;\n    for (int i = 0; i < 40; i++) {\n        if (sum.a > 0.99 || \n            pos.y < (MIN_HEIGHT-1.0) || \n            pos.y > (MAX_HEIGHT+1.0)) break;\n        \n        float den = c_density(pos);\n        \n        if (den > 0.01) {\n            float dif = clamp((den - c_density(pos+0.3*sundir))/0.6, 0.0, 1.0);\n\n            vec3 lin = vec3(0.65,0.7,0.75)*1.5 + vec3(1.0, 0.6, 0.3)*dif;        \n            vec4 col = vec4( mix( vec3(1.0,0.95,0.8)*0.7, vec3(0.35,0.4,0.45), den), den);\n            col.rgb *= lin;\n\n            // front to back blending    \n            col.a *= 0.5;\n            col.rgb *= col.a;\n\n            sum = sum + col*(1.0 - sum.a); \n        }\n        \n        t += max(0.05, 0.02 * t);\n        pos = ro + rd * t;\n    }\n    \n    sum = clamp(sum, 0.0, 1.0);\n    \n    float h = rd.y;\n    sum.rgb = mix(sum.rgb, backCol, exp(-20.*h*h) );\n    \n    return mix(backCol, sum.xyz, sum.a);\n}\n\nfloat planeIntersect( vec3 ro, vec3 rd, float plane)\n{\n    float h = plane - ro.y;\n    return h/rd.y;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    c_l =normalize(vec3(sin(iTime*0.41),sin(iTime*0.1)*0.27+0.30,cos(iTime*0.512)));\n    float height = 0.;\n    \n    vec3 rayOrigin = vec3(30.0 * sin(iTime * .3), 15., 30.0 * cos(iTime * .3));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0, 12., 0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n  \n    // Construct the ray direction vector\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    vec3 rayDirection = vec3(uv, focalLength);\n    rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + focalLength * cameraForward);\n      \n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection, 500., .3);\n    float dist = planeIntersect(rayOrigin, rayDirection, MIN_HEIGHT);\n    //sky color\n    vec3 col = vec3(0.78,0.78,0.7);\n    \n    float sun = clamp(dot(sundir, rayDirection), 0.0, 1.0);\n    \n    if (rayMarchResult.primitive != NO_INTERSECT) {\n      col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n      \n    }\n    else\n        col = c_raymarching(rayOrigin, rayDirection, dist, col);\n    \t//col=vec3(0.);\n    col +=0.55*vec3(0.9,0.3,0.1)*pow(sun, 30.0);\n     \n    float fo = 1.0 - exp( -rayMarchResult.dist*0.006 );\n    vec3 fco = vec3(0.78,0.78,0.7);\n    col = mix( col, fco, fo );\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllfW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 350, 350, 440], [589, 589, 611, 611, 711], [713, 713, 735, 735, 852], [854, 854, 880, 880, 1217], [1219, 1229, 1252, 1252, 1338], [1340, 1361, 1383, 1383, 1653], [1655, 1655, 1681, 1681, 2305], [2307, 2307, 2344, 2344, 2623], [2625, 2625, 2663, 2663, 2948], [2950, 2992, 3023, 3023, 3177], [3179, 3179, 3210, 3210, 3248], [3250, 3250, 3287, 3287, 3381], [3383, 3383, 3421, 3421, 3512], [3629, 3629, 3653, 3653, 3933], [3935, 3935, 3962, 3962, 4333], [4335, 4335, 4370, 4370, 4608], [4668, 4685, 4721, 4721, 5547], [5549, 5549, 5590, 5590, 5953], [5955, 5955, 6038, 6038, 6557], [6559, 6559, 6634, 6634, 7145], [7147, 7147, 7214, 7214, 8794], [8796, 8796, 8852, 8867, 9032], [9034, 9034, 9105, 9105, 10605], [10608, 10608, 10659, 10712, 12058], [12061, 12086, 12114, 12114, 12373], [12375, 12402, 12433, 12433, 12670], [12672, 12672, 12699, 12699, 12783], [12785, 12785, 12846, 12846, 13808], [13810, 13810, 13864, 13864, 13913], [13916, 13916, 13971, 13971, 15645]], "test": "error"}
{"id": "MlSfRd", "name": "More Cairo Tiles", "author": "mla", "description": "Cairo tiling again.", "tags": ["tiles", "pentagonal", "cairo"], "likes": 12, "viewed": 760, "published": "Public API", "date": "1519543581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Matthew Arcus, 2018\n// Minimal animated Cairo tiling\nvoid mainImage(out vec4 c, vec2 p) {\n  vec2 p0 = p;\n  p = 2.0*fract(4.0*p/iResolution.y)-1.0;\n  if (p.x*p.y < 0.0) p = p.yx;\n  p = 1.0-2.0*abs(abs(p)-0.5);\n  float t = iTime + p0.x/iResolution.x;\n  vec2 n = vec2(sin(t),cos(t));\n  vec2 m = vec2(-n.y,n.x);\n  float d = dot(p,n), e = dot(p,m);\n  float k = min(abs(d),abs(e));\n  if (d < 0.0) k = min(k,abs(p.x-1.0));\n  if (e < 0.0) k = min(k,abs(p.y-1.0));\n  c = vec4(smoothstep(0.0,0.1,k)*vec3(1),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSfRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 103, 103, 516]], "test": "valid"}
{"id": "MlSGDt", "name": "Ray marching - SI testing", "author": "captain_shader", "description": "ray marching", "tags": ["raymarching"], "likes": 1, "viewed": 74, "published": "Public", "date": "1519746901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SMALL_AMOUNT 0.0001\n#define SAMPLES 30.0\n\n//////////////////////////////////////////////////////////////////\n// PRIMITIVE DEFINITION // PRIMITIVE DEFINITION // PRIMITIVE DE //\n//////////////////////////////////////////////////////////////////\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y+1.0-0.5*sin(p.x)-0.5*cos(p.z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s-0.01*sin(0.4*p.x*iTime);\n}\n\n\n//////////////////////////////////////////////////////////////////\n// UTILS METHODS // UTILS METHODS // UTILS METHODS // UTILS MET // \n//////////////////////////////////////////////////////////////////\n\nvec4 getCloser( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 getIntersect( vec4 d1, vec4 d2 )\n{\n    return (d1.x > d2.x) ? d1 : d2;\n}\n\n//////////////////////////////////////////////////////////////////\n// MAP RETURNS THE CLOSER INTERSECTION AND ITS COLOUR // MAP RE //\n//////////////////////////////////////////////////////////////////\n\nvec4 map( in vec3 pos )\n{\n\t// plane definition\n\tfloat planeDistance = sdPlane(pos);\n\tvec3 planeColour = vec3(0.1, 0.2, 0.5);\n\t\n   // sphere definition\n\tfloat sphereRadius = 0.5;\n\tfloat sphereDistance = sdSphere( pos-vec3( 0.0, sphereRadius, 0.0), sphereRadius );\n\tvec3 sphereColour = vec3(0.3, 0.0, 0.2);\n    \n    // mapping\n\tvec4 res = getCloser( vec4( planeDistance, planeColour), vec4( planeDistance, planeColour) );\n    res = getCloser( res, vec4( sphereDistance, sphereColour ) );\n    \n\treturn res;\n}\n\n//////////////////////////////////////////////////////////////////\n// 3D NORMAL OF POINT // 3D NORMAL OF POINT // 3D NORMAL OF POI //\n//////////////////////////////////////////////////////////////////\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( SMALL_AMOUNT, 0.0 );\n\t\n\t// amazingly clever function to find the normal of a point in space\n\t// knowing the distance to the camera of the points around it\t\n\tvec3 nor = vec3(\n\t\tmap(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t\tmap(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t\tmap(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    \n    //float t = 0.0;\n  \t//t += normalize(texture(iChannel0,.3+pos.xz/6e3,-99.)).x;\n    \n\treturn normalize(nor);\n}\n\n//////////////////////////////////////////////////////////////////\n// CAMERA METHODS // CAMERA METHODS // CAMERA METHODS // CAMERA //\n//////////////////////////////////////////////////////////////////\n\nmat3 setCamera( in vec3 eye, in vec3 center, float upAngle )\n{\n\tvec3 front = normalize(center-eye);\n\tvec3 worldUp = vec3(sin(upAngle), cos(upAngle), 0.0);\n\tvec3 right = normalize( cross(front, worldUp) );\n\tvec3 cameraUp = normalize( cross(right, front) );\n\treturn mat3( right, cameraUp, front );\n}\n\nvec4 castRay( in vec3 eye, in vec3 rayDir )\n{\n\tfloat tmin = 0.0;\n\tfloat tmax = 20.0;\n\t\n\tfloat tHit = tmin;\n\tvec3 colour = vec3(-1.0);\n\tfor( int i=0; i<550; i++ )\n\t{\n\t\tvec4 res = map( eye+rayDir*tHit );\n\t\t// if intersection is too close or too far break\n\t\tif( res.x < SMALL_AMOUNT || tHit > tmax ) break;\n\t\ttHit += res.x; // tHit\n\t\tcolour = vec3(res.y, res.z, res.w); // point colour\n\t}\n\t\n\tif (tHit > tmax) colour = vec3(-1.0);\n\treturn vec4( tHit, colour );\n}\n\n//////////////////////////////////////////////////////////////////\n// LIGHT METHODS // LIGHT METHODS // LIGHT METHODS // LIGHT MET // \n//////////////////////////////////////////////////////////////////\n\nfloat getAmbientOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occlusion = 0.0;\n\tfloat shadowScatter = 1.5;\n\t\n\tconst int maxit = 5; // maxit shades\n\tfor( int i=1; i<=maxit; i++ )\n\t{\n\t\tfloat height = 0.01 + 0.1*float(i)/float(maxit);\n\t\tvec3 shadowPos =  nor * height + pos; // 3D point that might cast a shadow\n\t\tfloat dist = map( shadowPos ).x;\n\t\t// (height - dist) avoids a point casting a shadow over itself\n\t\tocclusion += (height-dist)*shadowScatter;\n\t\t// objects far cast less shadow\n\t\tshadowScatter *= 0.75;\n\t}\n\treturn clamp( 1.0 - 3.0*occlusion, 0.0, 1.0 );\t\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i < int(SAMPLES); i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, SAMPLES/2.0 * h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h < 0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n//////////////////////////////////////////////////////////////////\n// MAIN // MAIN // MAIN // MAIN // MAIN // MAIN // MAIN // MAIN //\n//////////////////////////////////////////////////////////////////\n\nvec3 render( in vec3 eye, in vec3 rayDir )\n{ \n\t// background color\n\tvec3 finalColour = vec3(1.0);\n\tvec4 res = castRay(eye, rayDir);\n\t\n\tfloat tHit = res.x;\n\tvec3 hitColour = vec3(res.y, res.z, res.w);\n\t\n\t// if no intersection was found, the pixel colour is not changed\n\tif( hitColour.x + hitColour.y + hitColour.z > -0.5 )\n\t{\n\t\tvec3 pos = eye + tHit*rayDir;\n\t\tvec3 nor = calcNormal( pos );\n\t\tvec3 ref = reflect( rayDir, nor );\n\t\t\n\t\t// material\t\t\n\t\tif( hitColour.x > 100.0 )\n\t\t{   \n\t\t\tfloat tileSize = 0.75;\n\t\t\tfloat f = mod( floor(tileSize*pos.z) + floor(tileSize*pos.x), 2.0);\n\t\t\tfinalColour = 0.05+f*vec3(0.25);\n\t\t}\n        else\n        {\n            finalColour = hitColour;\n        }\n\n\t\t// lighting\t\t\n\t\tfloat occlusion = getAmbientOcclusion( pos, nor );\n        float howfastistime = 0.3;\n\t\tvec3  ligthposition = normalize( vec3(sin(iTime*howfastistime), 0.7+0.2*sin(iTime*0.01), cos(iTime*howfastistime)) ); //ligth position\n        \n\t\t// phong\n\t\tfloat ambient = clamp( nor.y, 0.0, 1.0 );\n\t\tfloat diffuse = clamp( dot( nor, ligthposition ), 0.0, 1.0 );\n\t\tfloat specular = pow(clamp( dot( ref, ligthposition ), 0.0, 1.0 ), 20.0);\n\t\t\t  \n\t\tfloat reflection = softshadow( pos, ref, 0.01, 1.1 );\n\t\tdiffuse *= softshadow( pos, ligthposition, 0.05, 1.0 );\n\t\t\t\t\n\t\tfloat light = 0.3 + ambient * 0.2; // ambient light\n        light += diffuse * 1.0 ; // diffuse light\n\t\tlight += specular * 1.0 * diffuse; // specular light\n        \n\t\t//light += reflection * 0.3;\t\t\n\t\t\n\t\tfinalColour *= light * occlusion; // ambient occlusion\n\t\t//finalColour *= exp( -tHit*SMALL_AMOUNT*1000.0 ); // distance matters\n\t}\n\n\treturn vec3( clamp(finalColour,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 screenPoint = -1.0 + 2.0*q;\n\tscreenPoint.x *= iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\t//vec3 eye = vec3( 3.2*cos(0.1*time + 0.5*mo.x), 1.5, 3.2*sin(0.1*time + 0.5*mo.y));\n    vec3 eye = vec3( -4.0*cos(0.1*iTime), 1.0, -4.0*sin(0.1*iTime));\n\tvec3 center = vec3( 0.0 );\n\t\n\t\n\t// camera-to-world transformation\n\tmat3 camera = setCamera( eye, center, 0.0 );\n\t\n\t// ray direction\n\tvec3 rayDir = camera * normalize( vec3(screenPoint.xy,2.0) );\n\n\t// render\t\n\tvec3 rayColor = render( eye, rayDir );\n\t\n\t// nicer color \n\trayColor = pow( rayColor, vec3(0.5) );\n\n\tfragColor=vec4( rayColor, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 252, 277, 277, 322], [324, 324, 359, 359, 406], [612, 612, 648, 648, 681], [683, 683, 722, 722, 760], [964, 964, 989, 1010, 1469], [1673, 1673, 1705, 1705, 2147], [2351, 2351, 2413, 2413, 2648], [2650, 2650, 2695, 2695, 3108], [3313, 3313, 3368, 3368, 3879], [3881, 3881, 3955, 3955, 4206], [4410, 4410, 4454, 4476, 6051], [6053, 6053, 6110, 6110, 6812]], "test": "valid"}
{"id": "Ms3cR4", "name": "a nice mandala", "author": "netgrind", "description": "circles n such :)\nv messy code, oops", "tags": ["mandala"], "likes": 35, "viewed": 684, "published": "Public API", "date": "1518536462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    fragCoord -= iResolution.xy*.5;\n    vec2 uv = fragCoord/iResolution.yy;\n    uv*=5.;\n\tfloat t = iTime*3.1415;\n    \n    float a = atan(uv.y, uv.x);\n    float d = length(uv)-.3; \n    vec3 col = vec3(1.);\n    float timeWobble = cos(t+d)*.01*d;\n    float tt = mod(iTime*.5, .5)-.5;\n    for(float j = 0.; j<10.; j+=.5){\n        for(float i = 0.; i<6.28; i+=3.14*.125){\n            float q = (j==0.?(tt+.5):1.);\n            float p = i;//+sin(t+d)*.2;\n            vec2 u = uv+vec2(sin(p), cos(p))*(j-timeWobble+tt-0.25)*q;\n            col += smoothstep(.0, .013, length(u)-(smoothstep(0., 3.,j+tt)+timeWobble)* q*2.);\n        }    \n    }\n\tcol = sin((mod(col, vec3(4.))+vec3(1.,0.0, 3.))*1.5707-(d*3.-a*3.)+t)*.5+.5;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3cR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 877]], "test": "valid"}
{"id": "Ms3cRM", "name": "cd drive", "author": "XBA", "description": "simple beginner shader", "tags": ["cd"], "likes": 0, "viewed": 76, "published": "Public", "date": "1518154757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float speed = 5.;\n    float t = sin(speed * iTime) * 3.141;\n    float t2 = cos(speed * iTime) * 3.141;\n    float t3 = sin( speed * 2. * iTime + 50.) * 3.141;\n    float t4 = cos( speed * 2. * iTime - 50.) * 3.141;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    \n    float noise = 0.15 * hash(uv);\n    \n    float r = sqrt(uv.x*uv.x + uv.y * uv.y);\n    fragColor = vec4(0);\n    \n    float tt = uv.y / uv.x;\n    if (r < 0.1 && abs(tt - tan(t)) < (noise+0.05))\n        fragColor += vec4(uv.y + 0.5, uv.x + 0.5, 0.2, 1);\n    \n    if (r > 0.1 && r < 0.3 && abs(tt - tan(t2)) < (noise+0.05))\n        fragColor += vec4(0.1, 0.1, sqrt(uv.x *uv.x + uv.y * uv.y), 1);\n    \n    \n    if (r > 0.1 && r < 0.3 && abs(tt - tan(t3)) < (noise+0.05))\n        fragColor += vec4(sqrt(uv.x *uv.x + uv.y * uv.y), 0.1, 0.1, 1); \n    \n    \n    if (r > 0.1 && r < 0.3 && abs(tt - tan(t4)) < (noise+0.05))\n        fragColor += vec4(0.1, abs(uv.x), 0.1, 1); \n    \n    fragColor *= 3.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3cRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 103], [105, 105, 160, 160, 1143]], "test": "valid"}
{"id": "Ms3cWr", "name": "Stir Master", "author": "104", "description": "smoooth", "tags": ["2d"], "likes": 5, "viewed": 167, "published": "Public", "date": "1518446783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage(out vec4 o, vec2 O)\n{\n    float t = iTime*.5+1e3,\n        a,\n        A = 2.39,\n        s,\n        c;\n    vec2 R = iResolution.xy,\n        V=(O-.5*R)/R.y*4.5\n        ,N=O/R-.5// normalized coords (0-1)\n        ,P=O-R*.5// screen space coords, centered\n        ;\n    V.x-=.8;\n    \n   \t//V*=mat2(c=cos(a=length(V)*.9-t*.2),s=sin(a),-s,c);\n    //V*=mat2(c=cos(a=length(V)*.3+t*.5),s=sin(a),-s,c);\n\n    a=(length(V)*(sin(t)*.3+.5))-t*.5;\n    V*=mat2(c=cos(a),s=sin(a),-s,c);\n    \n    V=pow(abs(V),vec2(sin(t)*.5+1.));//1=dia, 2=cir\n    \n    o=N.xyxy+fract(V.x+vec4(N,-N)*.2+V.y);\n    \n\n    o.r*=.5;\n\n    o+=.14*fract(sin(dot(R+t,N))*1e5)\n        -dot(N,N*3.);\n\n    o=max(o,vec4(.1));\n    \n    // some post\n    if((abs(P.y) > R.x*.5/A) ||\n       (abs(P.x) > R.y*.5*A))\n        o-=o;\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3cWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 794]], "test": "valid"}
{"id": "Mscczr", "name": "2d shader thingy", "author": "Emiel", "description": "WIP", "tags": ["2d"], "likes": 2, "viewed": 88, "published": "Public", "date": "1517766795", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define freq(f) texture(iChannel0, vec2(f, 0.25)).x\n#define PI 3.1415926535897932384626433832795\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = clamp(abs(mod(h * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus(vec2 p, float r, float t) {\n    return abs(length(p) - r) - t;\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat freqHue(float f) {\n    return iTime * 0.1 + freq(0.1) * 0.1 + f * 0.15;\n}\n\nfloat freqV(float f) {\n    return freq(f * 0.55 + 0.05) * (1.0 + f * 0.4) * 0.8;\n}\n\nfloat map(vec2 p, out vec3 color) {\n    float t = 1e10;\n    \n    /*\n    int count = 36;\n    color = vec3(0);\n    for (int i = 0; i < count; i++) {\n        float f = float(i) / float(count - 1);\n        f += 0.5;\n        f = mod(f, 1.0);\n        f = abs(mod(f, 1.0) - 0.5) * 2.0;\n        \n    \tfloat v = freqV(f);\n        \n        vec2 pPart = p + vec2(cos(f * PI * 2.0), sin(f * PI * 2.0)) * 0.2;\n        float tPart = sdCircle(pPart, 0.1);\n        if (tPart < t) {\n            if (tPart <= 0.0) {\n                float li = -tPart * 15.0;\n                li *= li * li;\n                color = max(color, vec3(li) * hsl(freqHue(f), 0.5 + v, 0.1 + v));\n            }\n            t = tPart;\n        }\n    }\n\t*/\n    \n    \n    float f = atan(p.x, p.y) / PI * 0.5 + 0.5;\n    f += 0.5;\n    f = mod(f, 1.0);\n    f = abs(mod(f, 1.0) - 0.5) * 2.0;\n    \n    float v = freqV(f);\n    \n    float tTorus = sdTorus(p, freq(0.05) * 0.05 + 0.19 + v * 0.17, 0.002 + v * 0.13);\n    if (tTorus < t) {\n    \tcolor = hsl(freqHue(f), 0.5 + v, 0.1 + v);\n        t = tTorus;\n    }\n    \n    \n    return t;\n}\n\nvec3 pixel(in vec2 fragCoord) {\n    float ar = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 p = (uv - 0.5) * vec2(ar, 1.0);\n    vec3 color = vec3(1.0, 0.0, 0.0);\n    float dist = map(p, color);\n    if (dist < 0.0) {\n        return color;\n    }\n    \n    // background\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor.rgb = (\n        pixel(fragCoord) + \n        pixel(fragCoord + vec2(0.5, 0.0)) +\n        pixel(fragCoord + vec2(0.0, 0.5)) +\n        pixel(fragCoord + vec2(0.5, 0.5))\n   \t) / 4.0;\n}", "image_inputs": [{"id": "Xs2Xzc", "previewfilepath": "https://soundcloud.com/monstercat/duumu-take-me-away", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/monstercat/duumu-take-me-away", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mscczr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 135, 135, 288], [290, 290, 329, 329, 422], [424, 424, 457, 457, 485], [487, 487, 528, 528, 565], [567, 567, 596, 596, 677], [679, 679, 703, 703, 758], [760, 760, 782, 782, 842], [844, 844, 879, 879, 1925], [1927, 1927, 1958, 1958, 2259], [2261, 2261, 2316, 2316, 2511]], "test": "error"}
{"id": "MscyW4", "name": "Inverse Menger", "author": "chronosis", "description": "9 levels of recursion on an inverse Menger sponge, with 200 steps of raymarching. \n\nNote: At farther distances and dense regions there will be distortion from light scattering. This can be fixed by increasing the # of steps at the cost of performance.", "tags": ["raymarching", "fractal", "menger"], "likes": 4, "viewed": 174, "published": "Public", "date": "1518814426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Based on Inigo Quilez Menger Sponge\n// http://www.iquilezles.org/www/articles/menger/menger.htm\n\n#define levels 9.\n#define steps 200\n\n// light\nvec3 light = normalize(vec3(1.0, 0.9, 0.3));\n\nfloat msize = pow(3., (levels - 3.));\n\nfloat maxcomp(in vec3 pos) { return max(pos.x, max(pos.y, pos.z));}\nint msteps = steps;\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n  vec3 delta = abs(pos) - size;\n  float mc = maxcomp(delta);\n  return min(mc, length(max(delta, 0.0)));\n}\n\nvec4 map(in vec3 pos)\n{\n    float d = sdBox(pos, vec3(msize));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float size = (1. / msize);\n    for( float lvl = 0.; lvl < levels; lvl++ )\n    {\n        // \n        vec3 a = mod( pos * size, 2.0 ) - 1.0;\n        // Increase size by 3 each level\n        size *= 3.0;\n        vec3 r = abs(3.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / size;\n\n        // if point is outside box\n        if( c > d )\n        {\n          d = c;\n          res = vec4( d, min(res.y, 0.2 * da * db * dc), (1.0 + float(lvl)) / levels, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n\tvec4 h = vec4(1.0);\n    for( int i=0; i < msteps; i++ )\n    {\n\t\tif( h.x < 0.001 || t > msize ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n\tif( t > msize ) res=vec4(-1.0);\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i = 0; i < msteps; i++ )\n    {\n        h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n\t\tt += clamp(h, 0.0005, 0.1);\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    // background color\n    float f = rd.x * 0.5 + 0.5;\n    vec3 col = mix( vec3(0.8, 0.3, 0.2), vec3(0.7, 0.7, 0.2), f);\n    vec2 r = rd.xy;\n    r.x = abs(abs(r.y) - abs(r.x));\n    col *= vec3(texture(iChannel0, r.xy).x);\n\t\n    vec4 tmat = intersect(ro, rd);\n    if( tmat.x > 0.0 )\n    {\n        vec3  pos = ro + tmat.x * rd;\n        vec3  nor = calcNormal(pos);\n\t\t\n        float occ = tmat.y;\n\t\tfloat sha = softshadow(pos, light, 0.1, 128.0);\n\n\t\tfloat dif = max(0.1 + 0.9 * dot(nor, light), 0.0);\n\t\tfloat sky = 0.5 + 0.5 * nor.y;\n        float bac = max(0.4 + 0.6 * dot(nor, vec3(-light.x, light.y, -light.z)), 0.0);\n\n        vec3 lin  = vec3(0.0);\n        lin += 1.00 * dif * vec3(1.10, 0.85, 0.60) * sha;\n        lin += 0.50 * sky * vec3(0.10, 0.20, 0.40);// * occ;\n        lin += 0.10 * bac * vec3(1.00, 1.00, 1.00) * (0.5 + 0.5 * occ);\n        lin += 0.25 * occ * vec3(0.15, 0.17, 0.20);\t \n\n        vec3 matcol = vec3(\n            0.6 + 0.5 * cos(2.0 + 2.0 * tmat.z),\n            0.5 + 0.5 * cos(1.0 + 1.0 * tmat.z),\n            0.5 + 0.5 * cos(0.0 + 0.0 * tmat.z) );\n        col = matcol * lin;\n    }\n\n    //return col;\n    return pow( col, vec3(0.4545) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    float ctime = iTime;\n    // camera\n    vec3 ro = 10. * vec3(0.5 * sin(0.25 * ctime), 1.0 + 1.0 * cos(.13 * ctime), 0.5 * cos(0.25 * ctime));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0, 1.0, 0.0), ww ));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize( p.x * uu + p.y * vv + 2.5 * ww );\n\n    vec3 col = render( ro, rd );\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "XtSGRc", "previewfilepath": "https://soundcloud.com/chronosis/chronosis-satellite", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/chronosis/chronosis-satellite", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscyW4.jpg", "access": "shaders20k", "license": "mit", "functions": [[250, 250, 278, 278, 317], [339, 339, 373, 373, 479], [481, 481, 504, 504, 1200], [1202, 1202, 1244, 1244, 1525], [1527, 1527, 1592, 1592, 1829], [1831, 1831, 1861, 1861, 2101], [2103, 2103, 2140, 2164, 3306], [3308, 3308, 3365, 3365, 3880]], "test": "error"}
{"id": "MscyWH", "name": "Low Poly Planet", "author": "laserdog", "description": "A cartoony, low-poly planet with multiple biomes. Use mouse to move. I used this image as a reference: https://img2.cgtrader.com/items/695091/c2b1342e77/3d-cartoon-planet-city-3d-model-max.jpg. Used a lot of learnings from @morgan3d and @kuvlar's shaders.", "tags": ["raymarch", "planet", "lowpoly"], "likes": 14, "viewed": 721, "published": "Public", "date": "1518633162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n* Many of the utility functions for noise, intersections, etc. are from Morgan McGuire's\n* tiny planet (https://www.shadertoy.com/view/lt3XDM). Also borrowed his code for input handling.\n*\n* Also used a variant of IQ's 3d Voronoi Noise (https://www.shadertoy.com/view/ldl3Dl) for the\n* biome mapping and heavily utilized this amazing noise function\n* by @kuvlar: https://www.shadertoy.com/view/ldGSzc\n*/\n\nconst float pi\t= 3.1415926535;\nconst float inf\t= 1.0 / 1e-10;\nconst float deg2rad\t= pi / 180.0;\nconst float epsilon = .0001;\nconst int numMarches = 150;\nconst bool autoRotate = true;\n\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\nbool intersectSphere(vec3 C, float r, vec3 rayOrigin, vec3 direction, inout float nearDistance, inout float farDistance) { vec3 P = rayOrigin; vec3 w = direction; vec3 v = P - C; float b = 2.0 * dot(w, v); float c = dot(v, v) - square(r); float d = square(b) - 4.0 * c; if (d < 0.0) { return false; } float dsqrt = sqrt(d); float t0 = infIfNegative((-b - dsqrt) * 0.5); float t1 = infIfNegative((-b + dsqrt) * 0.5); nearDistance = min(t0, t1); farDistance  = max(t0, t1); return (nearDistance < inf); }\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x); float a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n\n#define DEFINE_FBM(name, OCTAVES) float name(vec3 x) { float v = 0.0; float a = 0.5; vec3 shift = vec3(100); for (int i = 0; i < OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm1, 1)\nDEFINE_FBM(fbm3, 3)\nDEFINE_FBM(fbm5, 5)\nDEFINE_FBM(fbm6, 6)\n    \nconst float fov = 20. * deg2rad;\nconst vec3 planetCenter = vec3(0.);\nconst float planetRadius = 1.;\nconst vec3 light = vec3(0., 1., 3.);\nconst float cellDiffThreshold = .1;\n\nmat3 planetRotation;\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43754.5453123);\n}\n\nmat2 rotate(float a)\n{\n    float ca = cos(a); float sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rnd(vec2 p)\n{\n    return abs(rand(p)) * 0.8 + 0.1;\n}\n\nfloat value (float x, float randx, float c)\n{\n    float a = min(x/randx, 1.0);\n    \n    float d = clamp(1.0 - (randx + c), 0.1, .9);\n    float b = min(1.0, (1.0 - x) / d);\n    return a + (b - 1.0);\n}\n\nfloat polynoise(vec2 p, float sharpness)\n{\n    vec2 seed = floor(p);\n    vec2 rndv = vec2(rnd(seed.xy), rnd(seed.yx));\n    vec2 pt = fract(p);\n    float bx = value(pt.x, rndv.x, rndv.y * sharpness);\n    float by = value(pt.y, rndv.y, rndv.x * sharpness);\n    return min(bx, by) * (0.3 + abs(rand(seed.xy * 0.01)) * 0.7);\n}\n\nvec3 mapBiome(vec3 x )\n{\n    x = planetRotation * x;\n    \n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    \n    // distance to closest and second closest\n    vec2 res = vec2( 100.0 );\n    // biome ID for closest and second closest\n    vec2 resId = vec2(-1., -1.);\n    \n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = length(r);\n        id = mod(abs(dot( p+b, vec3(1.0,57.0,113.0 ))), 3.);\n\n        if( d < res.x )\n        {\n            res = vec2( d, res.x );\n            resId = vec2( id, resId.x );\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n            resId.y = id;\n        }\n    }\n    \n    float diff = res.y - res.x;\n    \n    // this is a giant hack. need a better way to blend between the voronoi regions.\n    float ratio1 = min(1., pow(smoothstep(1., 3., clamp(res.y / res.x, 1., 3.)), .35) + .5);\n    float ratio2 = 1. - ratio1;\n        \n    return vec3(resId.x == 0. ? ratio1 : resId.y == 0. ? ratio2 : 0.,\n                resId.x == 1. ? ratio1 : resId.y == 1. ? ratio2 : 0.,\n               \tresId.x == 2. ? ratio1 : resId.y == 2. ? ratio2 : 0.);\n}\n\nfloat polyfbm(vec2 p, float dullness)\n{\n    vec2 seed = floor(p);\n    mat2 r1 = rotate(2.4);\n    mat2 r2 = rotate(0.4);\n    mat2 r3 = rotate(-2.0);\n    \n    // 1st octave\n    float m1 = polynoise(p * r2, dullness);\n    \n    m1 += polynoise ( r1 * (vec2(0.5, 0.5) + p), dullness);\n    m1 += polynoise ( r3 * (vec2(0.35, 0.415) + p), dullness);\n    m1 *= 0.333 * 0.75;\n    \n    // 2nd\n    float m2 = polynoise (r3 * (p * 2.0), dullness + .1);\n    m2 += polynoise (r2 * (p + vec2(0.2, 0.6)) * 2.0, dullness);\n    m1 += m2 * 0.5 * 0.5;\n\t\n    return m1 + .5;\n}\n\nfloat calcInitialDisplacement(vec3 p, float dullness)\n{\n    float x = polyfbm(p.zy, dullness);\n    float y = polyfbm(p.xz, dullness);\n    float z = polyfbm(p.xy, dullness);\n    \n    vec3 n = max((abs(p) - 0.2)*7., 0.001);\n    n /= (n.x + n.y + n.z ); \n    \n    return x * n.x + y * n.y + z * n.z;\n}\n\nfloat sceneSDF(vec3 p, out bool isWater) \n{\n    vec3 biome = mapBiome(p);\n    isWater = false;\n    p = planetRotation * p;\n    vec3 surfaceLocation = normalize(p);\n    float freq = 1.5;\n    float mult = 1. - biome.r * .075 + biome.b * .045;\n    float dullness = .2 + biome.r * .2;\n    \n    float elevation = calcInitialDisplacement(p * freq, dullness) * mult;\n    elevation *= planetRadius;\n    \n    if (elevation < .7) \n    {\n        elevation = .7 - pow(.7 - elevation, .25) * fbm1(surfaceLocation * 4. + iTime / 4.) * .2;\n        isWater = true;\n    }\n    \n    return (length(p) - elevation) * .8;\n}\n\nvec3 gradient(in vec3 rp)\n{\n    vec2 off = vec2(0.005, 0.0);\n    bool temp;\n    vec3 g = vec3(sceneSDF(rp + off.xyy, temp) - sceneSDF(rp - off.xyy, temp),\n                  sceneSDF(rp + off.yxy, temp) - sceneSDF(rp - off.yxy, temp),\n                  sceneSDF(rp + off.yyx, temp) - sceneSDF(rp - off.yyx, temp));\n    return normalize(g);\n}\n\nbool rayMarch(vec3 eye, vec3 dir, float minDistance, float maxDistance,\n              out float totDist, out bool isWater)\n{\n    totDist = minDistance;\n    vec3 pos = eye;\n\tfor (int i = 0; i < numMarches; i++)\n    {\n        pos = eye + totDist * dir;\n        float dist = sceneSDF(pos, isWater);\n        if (dist < epsilon)\n        {\n            return true;\n        }\n        else if (dist > maxDistance)\n        {\n            return false;\n        }\n        totDist += dist * .25;\n    }\n    \n    return false;\n}\n\nvec3 shade(vec3 pos, bool isWater)\n{\n    vec3 normal = gradient(pos);\n    vec3 lightDir = normalize(light - pos);\n    vec3 ambient = vec3(.2, 0., 0.);\n    \n    float diffuse = max(0., dot(normal, lightDir));\n    float len = length(pos);\n    \n    vec3 biomeWeights = mapBiome(pos * 1.);\n    vec3 col = vec3(.8, .8, .1) * biomeWeights.x\n        + vec3(0., 1., 0.) * biomeWeights.y\n        + vec3(.2, .2, .2) * biomeWeights.z;\n    \n    if (biomeWeights.z > .75 && len > .8)\n    {\n        col = vec3(1., 1., 1.);\n    }\n    \n    if (isWater)\n    {\n    \tcol = vec3(0., 0.62, 1.);\n    }\n    \n    // start off just doing plain old blinn phong\n\treturn diffuse * col + ambient;\n}\n\nvec3 draw(vec3 eye, vec3 dir, float minDistance, float maxDistance, vec2 fragCoord, vec2 invResolution)\n{\n    float totDist;\n    bool isWater;\n    if (rayMarch(eye, dir, minDistance, maxDistance, totDist, isWater)) {\n        return shade(eye + dir * totDist, isWater);\n    }\n    else \n    {\t\n        float galaxyClump = (pow(noise(fragCoord.xy * (30.0 * invResolution.x) + iTime / 2.), 3.0) * 0.5 +\n            pow(noise(100.0 + fragCoord.xy * (15.0 * invResolution.x)), 5.0)) / 1.5;\n        return vec3(galaxyClump * pow(hash(fragCoord.xy), 1500.0) * 80.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float yaw  = -((2. * iMouse.x / iResolution.x) * 2.5 - 1.25) + (autoRotate ? -iTime * 0.035 : 0.0);\n\tfloat pitch = ((2. * iMouse.y > 0.0 ? 2. * iMouse.y : iResolution.y * 0.3) / iResolution.y) * 2.5 - 1.25;\n \tplanetRotation = \n    \tmat3(cos(yaw), 0, -sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) *\n    \tmat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch));\n    \n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 eye = vec3(0., 0., 6.);\n    vec3 dir = normalize(vec3(fragCoord.xy - iResolution.xy / 2., -iResolution.y / (2. * tan(fov / 2.))));\n    \n    // get the near and far plane for the raymarch to reduce operations\n    float minDistance, maxDistance;\n    intersectSphere(planetCenter, planetRadius, eye, dir, minDistance, maxDistance);\n    \n    fragColor.rgb = draw(eye, dir, minDistance, maxDistance, fragCoord, 1. / iResolution.xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscyWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[593, 593, 616, 616, 632], [633, 633, 663, 663, 694], [695, 695, 817, 817, 1197], [1198, 1198, 1219, 1219, 1249], [1250, 1250, 1270, 1270, 1358], [1359, 1359, 1381, 1381, 1497], [1498, 1498, 1519, 1519, 1795], [1796, 1796, 1817, 1817, 2323], [2815, 2815, 2836, 2836, 2994], [2996, 2996, 3018, 3018, 3096], [3098, 3098, 3119, 3119, 3191], [3193, 3193, 3212, 3212, 3251], [3253, 3253, 3298, 3298, 3452], [3454, 3454, 3496, 3496, 3776], [3778, 3778, 3802, 3802, 5059], [5061, 5061, 5100, 5100, 5616], [5618, 5618, 5673, 5673, 5916], [5918, 5918, 5961, 5961, 6520], [6522, 6522, 6549, 6549, 6862], [6864, 6864, 6988, 6988, 7377], [7379, 7379, 7415, 7415, 8048], [8050, 8050, 8155, 8155, 8616], [8618, 8618, 8675, 8675, 9536]], "test": "valid"}
{"id": "Mscyz2", "name": "Sea at Night", "author": "felipunkerito", "description": "fractal brownian motion", "tags": ["raymarch", "sdf", "fbm"], "likes": 0, "viewed": 1278, "published": "Public API", "date": "1519533719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.001\n#define FAR 100.0\n#define STEPS 256\nconst float PI = 3.14159265359;\n\n// Move the mouse for rotation and light position\n\nfloat hash( float n )\n{\n\n    return fract( sin( n ) * 45843.349 );\n    \n}\n\nfloat noise( in vec3 x )\n{\n\n    vec3 p = floor( x );\n    vec3 z = fract( x );\n    \n    z *= z * z * ( 3.0 - 2.0 * z );\n    \n    float n = p.x + p.y * 57.0 + p.z * 113.0; \n    \n    float a = hash( n );\n    float b = hash( n + 1.0 );\n    float c = hash( n + 57.0 );\n    float d = hash( n + 58.0 );\n    \n    float e = hash( n + 113.0 );\n    float f = hash( n + 114.0 );\n    float g = hash( n + 170.0 );\n    float h = hash( n + 171.0 );\n    \n    float i = hash( n + 210.0 );\n    float j = hash( n + 211.0 );\n    float k = hash( n + 250.0 );\n    float l = hash( n + 251.0 );\n    \n    float res = mix( mix( mix ( a, b, z.x ), mix( c, d, z.x ), z.y ),\n                     mix( mix ( e, f, z.x ), mix( g, h, z.x ), z.y ), \n                     z.z\n    \t\t\t\t );\n    \n    return res;\n    \n}\n\nfloat fbm( in vec3 p )\n{\n\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p *= 2.02;\n    f += 0.2500 * noise( p ); p *= 2.03;\n    f += 0.1250 * noise( p ); p *= 2.01;\n    f += 0.0625 * noise( p );\n    f += 0.0317 * noise( p );\n    f += 0.0150 * noise( p );\n    return f / 0.9375;\n    \n}\n\n\nfloat map( vec3 p )\n{\n\n    float t = fbm( p + ( iTime * 0.1 ) );\n    \n    float sea = p.y + sin( noise( p + ( iTime * 0.2 ) ) ) * t ;\n    \n    /*\n\t\n\tp.y -= 5.0; \n    \n    float sph = length( p ) - 1.;\n    \n    if( sph < sea ) sea = sph;\n\n\t*/\n    \n    return sea;\n    \n}\n\nvec3 grad( vec3 p )\n{\n\n\tvec2 e = vec2( 0.0, EPS ); \n    vec3 n = vec3( map( p + e.xyy ) - map( p - e.xyy ),\n                   map( p + e.yxy ) - map( p - e.yxy ),\n                   map( p + e.yyx ) - map( p - e.yyx )\n    \t\t\t   );\n    return n;\n    \n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n    float res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n        \n        float h = map( ro + rd * t );\n        \n        if( h < 0.001 ) return 0.0;\n        res = min( res, 4.0 * h / t );\n        t += h;\n    \n    }\n    \n    return res;\n    \n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(map( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nvec3 shade( vec3 ro, vec3 rd, float t )\n{\n\n    vec3 p = ro + rd * t;\n    vec3 n = normalize( grad( p ) );\n    \n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    \n    vec3 lig = normalize( vec3( sin( iTime * 0.2 ), 0.8, cos( iTime * 0.2 ) ) );\n    vec3 blig = vec3( -lig.x, -lig.y, -lig.z );\n    vec3 ligO = normalize( vec3( m.x, m.y, 0.6 ) );\n    vec3 ref = reflect( rd, n );\n    \n    // AO from XT95 at: https://www.shadertoy.com/view/4sdGWN \n    \n    float a = ambientOcclusion( p, n, 4.0, 2.0 );\n    float dif = max( 0.0, dot( n, lig ) );\n    float difO = max( 0.0, dot( n, ligO ) );\n    float con = 1.0;\n    float sha = softShadows( p, lig );\n    float shaO = softShadows( p, ligO );\n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 16.0 );\n    float speO = pow( clamp( dot( ligO, ref ), 0.0, 1.0 ), 16.0 );\n    float amb = 0.5 + 0.5 * n.y;\n    float bac = max( 0.0, 0.2 + 0.8 * dot( n, blig ) );\n    float rim = pow( 1.0 + dot(n, rd), 2.0 );\n    \n    vec3 col = con * vec3( 0.1, 0.15, 0.2 );\n    col += amb * vec3( 0.1, 0.15, 0.2 );\n    col += dif * vec3( 1.0, 0.97, 0.85 ) * sha;\n    col += difO * vec3( 1.0, 0.97, 0.85 ) * shaO;\n    col += bac * vec3( 1.0, 0.97, 0.85 ) * bac;\n    \n    col = sqrt( col );\n    col *= 0.6;\n    \n    col += 0.1 * rim;\n    col += 1.0 * spe;\n    col *= 0.1 + vec3( 0.1, 0.2, .4 );\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n        vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    \n    float an = 1.1 + 0.05*(iTime-10.0) - 7.0*m.x;\n\n\tvec3 ro = vec3(10.5*sin(an),10.0,10.5*cos(an));\n    vec3 ta = vec3(0.0,2.0,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( uv.x*uu + uv.y*vv + 1.5*ww );;\n    \n    float t = 0.0; float d = EPS;\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        d = 0.5 * map( ro + rd * t );\n        \n        if( d < EPS || t > FAR ) break;\n        \n        t += d;\n        \n    }\n    \n    // Time varying pixel color\n    vec3 tex = texture( iChannel0, uv ).xyz;\n    vec3 col = d < EPS ? shade( ro, rd, t ) : mix( vec3( 0.1 ), tex * vec3( 0.4 ), uv.y + 0.1 );\n\n    // Output to screen\n    fragColor = vec4( col,1.0 );\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mscyz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 161, 161, 211], [213, 213, 239, 239, 993], [995, 995, 1019, 1019, 1282], [1285, 1285, 1306, 1306, 1554], [1556, 1556, 1577, 1577, 1808], [1810, 1810, 1855, 1855, 2108], [2110, 2110, 2142, 2142, 2245], [2247, 2247, 2292, 2292, 2384], [2386, 2386, 2470, 2470, 3014], [3017, 3017, 3058, 3058, 4397], [4399, 4399, 4456, 4506, 5518]], "test": "error"}
{"id": "Mscyzl", "name": "Torii Gate", "author": "Azunyan_Taichou", "description": "Rising sun with torii gate", "tags": ["toriigate"], "likes": 7, "viewed": 112, "published": "Public", "date": "1519785566", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 colorA= vec3(0,0,0); // Black\nvec3 colorB= vec3(0.65,0,0); // Red\nvec3 colorC= vec3(1,1,1); // White\n\nfloat circle(vec2 uv, vec2 pos, float radius)\n{\n    float dist = distance(pos, uv);\n    float value = 1.0-smoothstep(radius,radius + 0.01, dist);\n    //float value = 1.0-step(radius, dist);\n    \n    return value;\n}\n\nfloat rect(vec2 uv, vec2 pos, vec2 size)\n{\n\n    float value = step(pos.x,uv.x);\n    value = (step(pos.x,uv.x) - step(pos.x+size.x,uv.x)); \n    value *= (step(pos.y, uv.y) - step(pos.y+size.y,uv.y));\n   \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    // Sun\n    vec2 pos = vec2(0.28 *ratio, 0.69);\n    float radius = abs(0.30);\n    float value = circle(uv, pos, radius);\n    vec3 color = mix(colorC, colorB, value);\n    \n    // Rising Sun Rays\n    pos = vec2(0.28 *ratio, 0.69);\n    float dist = distance(pos, uv) * .011; \n    dist -= 0.13;\n    uv -= pos;  \n    float angle = atan(uv.y, uv.x);\n    radius = floor(cos(16. * angle +iTime));\n    value = 1.0-step(radius, dist);\n   \tcolor = mix(color, colorB, value);\n    uv += pos;  \n    \n    // Kasagi\n    pos = vec2(.14 * ratio, .75);\n    vec2 size = vec2(1.2,0.08);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    // Shimaki\n    pos = vec2(.21 * ratio, .7);\n    size = vec2(0.96,0.08);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    // Left Daiwa\n    pos = vec2(.285 * ratio, .65);\n    size = vec2(0.15,0.08);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    // Right Daiwa\n    pos = vec2(.585 * ratio, .65);\n    size = vec2(0.15,0.08);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    // Gakuzuka\n    pos = vec2(.46 * ratio, .5);\n    size = vec2(0.09,0.2);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    // Nuki\n    pos = vec2(.2 * ratio, .5);\n    size = vec2(1.0,0.1);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n\n    // Left Hashira\n    pos = vec2(.3 * ratio, .2);\n    size = vec2(0.1,0.5);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n \t// Right Hashira\n    pos = vec2(.6 * ratio, .2);\n    size = vec2(0.1,0.5);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    // Left Nemaki\n    pos = vec2(.28 * ratio, .1);\n    size = vec2(0.18,0.15);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    // Right Nemaki\n    pos = vec2(.58 * ratio, .1);\n    size = vec2(0.18,0.15);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n     \n    // Platform 1\n    pos = vec2(.15 * ratio, .04);\n    size = vec2(1.24,0.06);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    // Platform 2\n    pos = vec2(.1 * ratio, .001);\n    size = vec2(1.4,0.06);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    \n//Left\n    pos = vec2(.17 * ratio, .1);\n    size = vec2(0.06,0.3);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    pos = vec2(.15 * ratio, .33);\n    size = vec2(0.3,0.05);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n   \n    pos = vec2(.15 * ratio, .26);\n    size = vec2(0.3,0.05);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n//Right\n    pos = vec2(.77 * ratio, .1);\n    size = vec2(0.06,0.3);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    pos = vec2(.65 * ratio, .33);\n    size = vec2(0.3,0.05);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n   \n    pos = vec2(.65 * ratio, .26);\n    size = vec2(0.3,0.05);\n    value = rect(uv, pos, size);\n    color = mix(color, colorA, value);\n    \n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mscyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 154, 154, 321], [323, 323, 365, 365, 545], [547, 547, 604, 604, 3950]], "test": "valid"}
{"id": "Msdczn", "name": "Naive soft brush stroke", "author": "ApoorvaJ", "description": "Naive and incorrect implementation of brush stroke with a distance falloff", "tags": ["brush"], "likes": 1, "viewed": 2413, "published": "Public API", "date": "1517835327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RADIUS 0.12\n\nfloat dist_to_line(vec2 p1, vec2 p2, vec2 uv)\n{\n\tfloat a = abs(distance(p1, uv));\n\tfloat b = abs(distance(p2, uv));\n\tfloat c = abs(distance(p1, p2));\n\n\tfloat d = sqrt(c*c + RADIUS*RADIUS);\n\n\tif (a >= d || b >= d)\t{\n        float dist1 = distance(p1, uv);\n        float dist2 = distance(p2, uv);\n        return min(dist1,dist2);\n\t}\n\n\tfloat p = (a + b + c) * 0.5;\n\n\tfloat h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n    return h;\n}\n\nfloat falloff(float dist)\n{\n    if (dist > RADIUS) {\n        return 0.0;\n    } else {\n        return (RADIUS-dist)*10.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    uv.x /= aspect;\n \tvec2 p1 = vec2(0.1/aspect, 0.5);\n \tvec2 p2 = vec2(0.5/aspect, 0.5);\n \tvec2 p3 = vec2(0.9/aspect, 0.5);\n    \n    float dist1 = dist_to_line(p1, p2, uv);\n    float dist2 = dist_to_line(p2, p3, uv);\n    float i1 = falloff(dist1);\n    float i2 = falloff(dist2);\n    \n    float s = sin(iTime) * 0.5 + 0.5;    \n \tfragColor = vec4(i1+i2*(1.0-s), s*i2, 0, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msdczn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 68, 68, 463], [465, 465, 492, 492, 593], [595, 595, 652, 652, 1115]], "test": "valid"}
{"id": "MsdyDN", "name": "Perlin noise fire", "author": "BenWheatley", "description": "Perlin noise based fire; each octave of the Perlin noise has a slightly different speed than the others, y ~ f(log2(octive_scale)*time)", "tags": ["procedural", "perlinnoise", "fire"], "likes": 5, "viewed": 225, "published": "Public", "date": "1519034639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Fire\" by Ben Wheatley - 2018\n * License MIT License\n * Contact: github.com/BenWheatley\n */\n\n// constants\nconst int MAX_OCTAVE = 8;\nconst float PI = 3.14159265359;\n\nfloat cosineInterpolate(float a, float b, float x) {\n\tfloat ft = x * PI;\n\tfloat f = (1.0 - cos(ft)) * 0.5;\n\t\n\treturn a*(1.0-f) + b*f;\n}\n\nfloat seededRandom(float seed) {\n    int x = int(seed);\n    x = x << 13 ^ x;\n    x = (x * (x * x * 15731 + 789221) + 1376312589);\n    x = x & 0x7fffffff;\n    return float(x)/1073741824.0;\n}\n\n// The magic constants are essentially arbitary:\n// they define the scale of the largest component of the Perlin noise\nfloat perlinNoise(float x_arg, float y_arg, float time_arg) {\n    float sum = 0.0;\n    for (int octave=0; octave<MAX_OCTAVE; ++octave) {\n        float sf = pow(2.0, float(octave));\n        float x = x_arg*sf;\n    \tfloat y = (y_arg*sf) + (1.5*time_arg*log2(sf));\n    \tfloat y_scale = 1.0*sf;\n        \n\t\tfloat x_floor = floor(x);\n\t\tfloat y_floor = floor(y);\n\t\tfloat fraction_x = x - x_floor;\n\t\tfloat fraction_y = y - y_floor;\n        \n        float t1 = seededRandom( x_floor\t+\ty_scale *  y_floor      );\n\t\tfloat t2 = seededRandom( x_floor\t+\ty_scale * (y_floor+1.0) );\n        \n        x_floor += 1.0;\n        float t3 = seededRandom( x_floor\t+\ty_scale *  y_floor      );\n\t\tfloat t4 = seededRandom( x_floor\t+\ty_scale * (y_floor+1.0) );\n        \n\t\tfloat i1 = cosineInterpolate(t1, t2, fraction_y);\n\t\tfloat i2 = cosineInterpolate(t3, t4, fraction_y);\n        \n        sum += cosineInterpolate(i1, i2, fraction_x)/sf;\n    }\n    return 2.0*sum;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float dx = 0.5 - uv.x;\n    float dy = 0.5 - uv.y;\n    dy *= iResolution.y / iResolution.x;\n    \n    float c = perlinNoise(dx, dy, iTime);\n    // Fiddle with brightness and contrast to push it into a nice range\n    c -= 2.4;\n    c *= cos(dx*PI); // This also makes it central in the image\n    c *= 1.0-((uv.y/iResolution.y)*256.0);\n    \n    float red = c*0.9;\n    float green =  c*(dy+0.25); // This makes it more yellow towards the bottom\n    \n    fragColor = vec4(red, green, 0, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdyDN.jpg", "access": "shaders20k", "license": "mit", "functions": [[171, 171, 223, 223, 306], [308, 308, 340, 340, 497], [499, 618, 679, 679, 1558], [1560, 1568, 1625, 1625, 2165]], "test": "valid"}
{"id": "MsdyWN", "name": "Circular Buffer", "author": "Lucanio", "description": "Circular Buffer Visualization", "tags": ["ring"], "likes": 1, "viewed": 171, "published": "Public", "date": "1519066057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Luke Craig 2/19/2018\n#define PI 3.1415926535897932384\n//#define radius 0.3\n//#define warped\n//#define stress\n\n\nfloat ringSmooth(vec2 c, vec2 uv, float r, float width){\n    float d = distance(uv,c);\n    float b = abs(d-r);\n    float edge = (b-width);\n    float edgewidth= 0.004;\n    return smoothstep(-edgewidth,edgewidth,-edge);\n}\n\nfloat circleSmooth(vec2 p,vec2 hk, float r){    \n    float d = length(p-hk);\n    float t = (r-d); \n    float edgewidth= 0.002;\n    return smoothstep(-edgewidth,edgewidth,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef stress\n    for(int i =0;i<100000000;i++){\n#endif\n\tvec2 uv = (fragCoord - (iResolution.xy*0.5))/iResolution.y;\n        float radius = 0.25+(sin(iTime*0.1)+1.0)*0.1;\n    #ifdef warped\n\tuv=mix(uv,uv*uv.x,0.25);\n    #endif\n    vec3 col = vec3(0.196,0.243,0.262);\n    float increment = iTime*.5;\n    float dwp = 0.0;\n    float drp = 0.0;\n    float predelay = 0.01;\n    dwp += increment;\n\tfloat lfo_freq = 1.0;\n    drp += increment-((sin(iTime*lfo_freq)+1.0)*.2)-predelay;\n\t\n    vec2 circleWritePos = vec2(cos(dwp*2.0*PI),sin(dwp*2.0*PI))*radius;\n    vec2 circleReadPos = vec2(cos(drp*2.0*PI),sin(drp*2.0*PI))*radius;\n    float ring1 = ringSmooth(vec2(0.0),uv,radius,0.01);    \n        \n    vec2 midpoint = normalize(cross((vec3(circleWritePos,1.0)),(vec3(circleReadPos,1.0))).xy)*radius;\n    float distanceFromMidPoint = dot(normalize(uv),normalize(midpoint) );\n    float distanceFromRead = dot(normalize(midpoint),normalize(circleReadPos) );      \n    float a = -floor(distanceFromRead-distanceFromMidPoint);\n    a = clamp(a,0.0,1.0);\n    float uv_distFromWrite = dot(normalize(uv),normalize(circleWritePos));\n    vec3 bluering = mix(vec3(ring1),vec3(ring1)*(vec3(0.0,0.5,0.8)*vec3(uv_distFromWrite)),a);\n    col+=bluering;         \n\t\n    float circleWrite = circleSmooth(circleWritePos,uv, 0.03);\n    col=mix(col,vec3(0.247,0.592,0.714),circleWrite);\t\n    float circleRead = circleSmooth(circleReadPos,uv, 0.03);\n    col=mix(col,vec3(0.0,0.0,0.01),circleRead);\n    \n    fragColor = vec4(col,1.0);\n#ifdef stress\n    }\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 170, 170, 333], [335, 335, 379, 379, 510]], "test": "valid"}
{"id": "MsdyzH", "name": "graprog_ilas_act11", "author": "ilaschino", "description": "heartbeat circle", "tags": ["iq"], "likes": 0, "viewed": 88, "published": "Public", "date": "1517971319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv,float radius, vec2 shapePos)\n{\n     \n    float dist = distance(shapePos,uv);\n    float value = step(radius,dist);\n    \n    return value; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\t \n    float ratio = iResolution.x / iResolution.y;\n    \n    vec2 shapePos = vec2(.5,.5);\n    shapePos.x *= ratio;\n    uv.x *= ratio;\n    \n    float radius = .2;\n\n    //vec2 shapePos = vec2(.5 * ratio, .5);\n    //float dist = distance( shapePos,uv);\n    //float radius = .2;\n    //float value = step(radius,dist);\n    \n    float value = circle(uv,radius *(sin(sin(iTime *3.0 )* 2.5)+1.0),shapePos);\n    vec3 color = vec3(value,1,0);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdyzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 160], [163, 163, 220, 220, 727]], "test": "valid"}
{"id": "MsdyzM", "name": "Julia Orbit", "author": "fydrenak", "description": "An aesthetically pleasing orbit of the julia set.", "tags": ["fractal", "julia", "simple", "orbit"], "likes": 0, "viewed": 54, "published": "Public", "date": "1518290357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = mod(iTime / 128.0, 6.28);\n    float r = 0.385;\n    float theta = a;\n    float degs = theta * 180.0 / 3.14;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 c = vec2(r * cos(degs), r * sin(degs));\n    vec2 z = vec2(uv.x * 3.5 - 1.75, uv.y * 2.0 - 1.0);\n    vec3 col = vec3(0);\n    int iter = 0;\n    int max_iter = 100;\n    \n    while (iter < max_iter && z.x*z.x + z.y*z.y < 4.0) {\n    \tfloat newzre = z.x * z.x - z.y*z.y + c.x;\n        \n        z.y = 2.0 * z.x * z.y + c.y;\n        z.x = newzre;\n        \n        iter++;\n    }\n    \n    if (iter < max_iter) {\n    \tcol = vec3(0.1 + float(iter) / float(max_iter));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdyzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 734]], "test": "valid"}
{"id": "MstcR8", "name": "Zooming Trippy Plasma", "author": "Optimus", "description": "This is the flying through layers version of my trippy plasma.", "tags": ["plasma", "zoom", "colorful", "trippy", "layers"], "likes": 11, "viewed": 710, "published": "Public", "date": "1517960437", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plasma(vec2 p, float iso, float fade)\n{\n\tfloat c = 0.0;\n\tfor (float i=1.0; i<10.0; ++i) {\n\t\tfloat f1 = i / 0.6;\n\t\tfloat f2 = i / 0.3;\n\t\tfloat f3 = i / 0.7;\n\t\tfloat f4 = i / 0.5;\n\t\tfloat s1 = i / 2.0;\n\t\tfloat s2 = i / 4.0;\n\t\tfloat s3 = i / 3.0;\n\t\tc += sin(p.x * f1 + iTime) * s1 + sin(p.y * f2 + 0.5 * iTime) * s2 + sin(p.x * f3 + p.y * f4 - 1.5 * iTime) * s3;\n\t}\n\t//c = mod(clamp(c, -1.0, 1.0), 0.5) * 2.0;\n\tc = mod(c, 16.0) * 0.5 - 7.0;\n\tif (c < iso) {\n\t\treturn 0.0;\n\t}\n\telse {\n\t\tif (c > 0.5) c = 1.0 - c;\n\t\tc *= 2.0;\n\t\treturn c * fade;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 pos = (( fragCoord.xy / iResolution.xy ) - vec2(0.5)) * vec2(iResolution.x / iResolution.y, 1.0);\n\n\tfloat c = 0.0;\n\tfor (float i=0.0; i<27.0; ++i)\n\t{\n\t\tfloat patazoom = mod(0.5 * iTime, 1.0);\n\t\tfloat zoom = 1.0 + i - patazoom;\n\t\tvec2 trans = vec2(sin(iTime * 0.3) * 0.5, sin(iTime * 0.4) * 0.2);\n\t\tc = plasma(pos * zoom + trans, 0.0, 2.0 / (1.0 + i - patazoom));\n\t\tif (c> 0.001) break;\n\t}\n\tfragColor = vec4(c * pos.x, c * pos.y, c * abs(pos.x + pos.y), 0.5) * 2.0;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstcR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 548], [550, 550, 607, 607, 1082]], "test": "valid"}
{"id": "Mstczr", "name": "Glowing blob", "author": "lsdlive", "description": "Experimenting with new techniques & a little bit of geometry.\n\nThe glowing trick came from balkhan.", "tags": ["raymarching", "glow"], "likes": 20, "viewed": 374, "published": "Public", "date": "1517846034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 glow = vec3(0.);\nfloat glow_intensity = .005;\nvec3 glow_color = vec3(.5, .8, .5);\n\nfloat smin(float a, float b) {\n\tfloat k = 3.;\n\tfloat res = exp(-k*a) + exp(-k*b);\n\treturn -log(res) / k;\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n#define sph(p, r) (length(p) - r)\n#define cyl sph\n\nfloat de(vec3 p) {\n\tvec3 q = p;\n\n\tp.xy *= r2d(-3.14 / 3.);\n\tp.xz *= r2d(iTime);\n\tp.x += cos(p.y*8.)*.2;\n\tp.z += sin(p.y*4.)*.2;\n\tfloat d = cyl(p.xz, .1);\n\n\tp = q;\n\tp.xy *= r2d(3.14 / 3.);\n\tp.xz *= r2d(iTime);\n\tp.x += cos(p.y*8.)*.2;\n\tp.z += sin(p.y*4.)*.2;\n\n\td = smin(d, cyl(p.xz, .1));\n\n\tp = q;\n\tp.xz *= r2d(iTime);\n\tp.x += cos(p.y*8.)*.2;\n\tp.z += sin(p.y*4.)*.2;\n\n\td = smin(d, cyl(p.xz, .1));\n\n\tp = q;\n\tp.xy *= r2d(3.14 / 2.);\n\tp.xz *= r2d(iTime);\n\tp.x += cos(p.y*8.)*.2;\n\tp.z += sin(p.y*4.)*.2;\n\n\td = smin(d, cyl(p.xz, .1));\n\n\t// trick extracted from balkhan https://www.shadertoy.com/view/4t2yW1\n\tglow += glow_color * .025 / (.01 + d*d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\n\tvec3 ro = vec3(cos(iTime)*.2, 0, 3. + cos(iTime)*.2), p;\n\tvec3 rd = normalize(vec3(uv, -1));\n\tp = ro;\n\n\tfloat t = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tp = ro + rd * t;\n\t\tfloat d = de(p);\n\t\tif (d < .001 || t > 10.) break;\n\t\tt += d * .2; // avoid clipping, enhance the glow\n\t}\n\n\tvec3 c = vec3(.9, .05 + cos(iTime)*.1, .2);\n\tc.r *= p.y + p.z;\n\tc += glow * glow_intensity;\n\n\tfragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mstczr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 118, 118, 194], [196, 196, 215, 215, 275], [328, 328, 346, 346, 982], [984, 984, 1039, 1039, 1510]], "test": "valid"}
{"id": "Mt2BDt", "name": ", lipse!", "author": "mmutai", "description": "The title, in Portuguese, translates to \"Oh, lipse!\", like what you would say to the \"lipse\" if it just did something dumb.\nThe point is that the title sounds like \"ellipse\" said in Portuguese.\n\"Lipse\", of course, is completely meaningless. ", "tags": ["geometry", "homework"], "likes": 3, "viewed": 128, "published": "Public", "date": "1518125660", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Extra Credit #defines:\n//#define FLIP\n//#define ADD_LIGHT_BLEND\n//#define ADD_DARK_BLEND\n//#define PULSATING_COLOR\n\n// can switch to fixed value for easier debugging/tweaking (a.k.a TOKI YO TOMARE)\n// can also change general speed with this\n#define U_TIME (0.75 * iTime + 0.0)\n\n\nconst float LIMIT_EPSILON = 0.04; // controls size of white limit dot\nconst float ELLIPSE_EPSILON = 0.018; // controls thickness of ellipse\n\n#ifdef PULSATING_COLOR\n#define ELLIPSE_COLOR (mix(vec3(245.0, 92.0, 59.0) / 255.0, vec3(255.0, 190.0, 190.0) / 255.0, cos(U_TIME * PI * 1.5) * 0.5 + 0.5))\n#define LIMIT_COLOR (mix(vec3(0.7, 0.6, 1.1), vec3(0.9), cos(U_TIME * PI * 1.5) * 0.5 + 0.5))\n#else\nconst vec3 ELLIPSE_COLOR = vec3(245.0, 92.0, 59.0) / 255.0;\nconst vec3 LIMIT_COLOR = vec3(0.9, 0.9, 0.9);\n#endif\nconst vec3 BG_COLOR = vec3(42.0, 29.0, 69.0) / 255.0;\nconst float PI = 3.14159265;\nconst float ROT_OFFSET = PI * 1.23;//-PI * 0.5;\nconst float LIMIT_OFFSET = -PI;\nconst float SCALE_OFFSET = -PI;\nconst float LIMIT_ORIGIN = -PI * 0.18;\nconst float GAIN_PARAM_LIMIT = 0.3;\nconst float GAIN_PARAM_ROT = 0.2;\n\n\n// note to self: edge(a, b) returns (a >= b) ? 1.0 : 0.0\n\n// http://demofox.org/biasgain.html\n// bias and gain functions\nfloat getBias(float time, float bias) {\n  return (time / ((((1.0 / bias) - 2.0) * (1.0 - time)) + 1.0));\n}\n\nfloat getGain(float time, float gain) {\n    if(time < 0.5) {\n        return getBias(time * 2.0, gain) / 2.0;\n    }\n    else {\n        return getBias(time * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;\n    }\n}\n\n// !!! assumes LIMIT_ORIGIN <= 0.0 !!!\n// from here on, LIMIT_ORIGIN is shortened to L_O for brevity\n// if L_O != 0.0, there's a special region in\n// [PI + L_O, PI] where checking just angle < angleLimit fails\n// because adding L_O to angleLimit shifts its range to [-PI + L_O, PI + L_O]\n// but atan() returns [-PI, PI]\n// now, we could add L_O to angle and hope it works...\n// this makes the correct amount of ellipse to exposed, but it's still\n// starting in the wrong place (at the -PI point)\n// so we need to identify when angle is in this special region\n// and perform a special computation\n// note about assuming L_O <= 0.0:\n// this is needed because the checks to see if angle is in the special region\n// change if L_O > 0.0. they change in a trivial way, so a function that\n// handles L_O > 0.0 could also be written.\nbool isBehindAngleLimit(float angle, float angleLimit) {\n    if (PI + LIMIT_ORIGIN <= angle && angle <= PI) {\n        // if angleLimit >= -PI, then we are certainly behind it already\n        if (angleLimit >= -PI) {\n            return true;\n        }\n        // else, angleLimit is also in the special region\n        // we can subtract -2 * PI to keep our angle in the same place,\n        // but numerically make it comparable to angleLimit\n        else {\n            return (angle - 2.0 * PI) < angleLimit; \n        }\n    }\n    else {\n        return angle < angleLimit;\n    }\n}\n\n// blendColor should be the color obtained from sampling previous layer\nvec3 getEllipseColor(vec2 p, vec3 blendColor, out bool hitGeometry) {\n    const float a = 1.0;\n    const float b = 1.0;\n    \n    hitGeometry = false;\n    float adjTime = U_TIME * PI * 0.5;\n    float modAdjTime = mod(adjTime, 2.0 * PI);\n    \n#ifdef FLIP\n    if (0.5 * PI < modAdjTime && modAdjTime < 1.5 * PI) {\n        //p.x /= cos(modAdjTime * 4.0) * 0.5 + 0.75;\n    \tp.y /= cos(modAdjTime * 4.0);\n    }\n#endif\n    float angle = atan(p.y, p.x);// + LIMIT_ORIGIN;\n    vec2 ellipse = vec2(a * cos(angle), b * sin(angle));\n\n    // this gives us a \"square wave\" with 50% duty cycle\n    // and frequency of 2 PI\n    bool goingBack = modAdjTime > PI;\n    if (goingBack) {\n        adjTime *= -1.0;\n    }\n    else {\n        // this offset shifts adjTime so it's in the correct\n        // part of the cos() domain\n\t    adjTime += LIMIT_OFFSET;        \n    }\n\n    // [-1, 1] -> [0, 1] -(gain)-> [0, 1] -> [-1, 1]\n    float adjCos = getGain(cos(adjTime) * 0.5 + 0.5, GAIN_PARAM_LIMIT) * 2.0 - 1.0;\n    float angleLimit = -(adjCos) * PI + LIMIT_ORIGIN;\n    vec2 limit = vec2(a * cos(angleLimit), b * sin(angleLimit));\n    \n    float distToEllipse = distance(p, ellipse);\n    float distToLimit = distance(p, limit);\n\tbool isBehind = isBehindAngleLimit(angle, angleLimit);\n\tif (goingBack) {\n        isBehind = !isBehind;\t\n\t}\n    \n    // we could just return color\n    // but this leads to a very binary effect\n    // i.e. pixel is either on ellipse or not,\n    // which leads to pixellated/aliased effect\n    // solution: blend based on distance to ellipse\n    \n    // remap to [0, 1] and \"flip\"\n    float proximity = 1.0 - distToEllipse / ELLIPSE_EPSILON;\n    // bias towards higher values\n    float blend = smoothstep(0.0, 0.2, proximity);\n    //vec3 blendedEllipseColor = mix(BG_COLOR, ELLIPSE_COLOR, blend);\n    vec3 blendedEllipseColor = mix(blendColor, ELLIPSE_COLOR, blend);\n    \n    if (distance(p, limit) < LIMIT_EPSILON) {\n        hitGeometry = true;\n        // do same thing, but blend with blendedEllipseColor\n        \n        // remap to [0, 1] and \"flip\"\n        float proximity = 1.0 - distToLimit / LIMIT_EPSILON;\n        // bias towards higher values\n        float blend = smoothstep(0.0, 0.2, proximity);\n        // pick either background or ellipse depending on our angle\n        // this prevents the ellipse from showing under the limit point\n        //vec3 otherColor = mix(BG_COLOR, blendedEllipseColor, step(angleLimit, angle));\n        vec3 otherColor = (isBehind ? blendColor : blendedEllipseColor);\n        return mix(otherColor, LIMIT_COLOR, blend);\n        //return ELLIPSE_COLOR; \n        \n        //return LIMIT_COLOR; \n    }\n    else if (isBehind) {\n    //else if (angle + LIMIT_ORIGIN < angleLimit) {\n        return BG_COLOR;\n    }\n    else if (distToEllipse < ELLIPSE_EPSILON) {\n        hitGeometry = true;\n        //return ELLIPSE_COLOR;\n        return blendedEllipseColor; \n    }\n    else {\n        return BG_COLOR;\n        //return vec3(0,1,0);\n    }\n}\n\nvec3 ellipse(vec2 p, vec3 blendColor, float rotOffset, float rotSpeed, float scale, out bool hitGeometry) {\n    vec2 transP;\n    \n    // make ellipse rotate\n    // [-1, 1] -> [0, 1] -(gain)-> [0, 1] -> [-1, 1]\n    float adjCos = getGain(cos(U_TIME * PI * 0.5) * 0.5 + 0.5, GAIN_PARAM_ROT) * 2.0 - 1.0;\n    float angle = adjCos * rotSpeed;\n    float c = cos(angle + rotOffset);\n    float s = sin(angle + rotOffset);\n    mat2 rot = mat2(vec2(c, s), vec2(-s, c));\n    transP = p * rot;\n    \n    // make ellipse more stretched over time\n    float yScale = mix(1.0, 2.8,  cos(U_TIME * PI * 0.5 + SCALE_OFFSET) * 0.5 + 0.5);\n    float totalScale = mix(0.82, 1.1,  -cos(U_TIME * PI * 0.5 + SCALE_OFFSET) * 0.5 + 0.5);\n    transP *= vec2(1.0, yScale) * scale * totalScale;\n    return getEllipseColor(transP, blendColor, hitGeometry);\n\n}\n\nvoid blend(bool hitGeometry, in vec3 ellipseColor, inout vec3 blendColor) {\n#if defined(ADD_LIGHT_BLEND) || defined(ADD_DARK_BLEND)\n    blendColor += hitGeometry ? ellipseColor : vec3(0.0);//blendColor;\n#else\n    blendColor = hitGeometry ? ellipseColor : blendColor;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n    \n    // basic idea:\n    // there is a sequence of ellipses, where each:\n    //   is smaller than the previous\n    //   has a different rotation speed\n    //   has a different initial rotation offset (to account for speed)\n    // in order to achieve correct blending, we have to:\n    //   init blendColor = BG_COLOR\n    //   from big to small ellipse:\n    //     sample ellipse, passing in blendColor\n    //     if we hit geometry, update blendColor w/ return value\n    // at the end, this will give us the correctly blended color.\n    // we go from big to small because bigger ellipses seem to\n    // be closer to the background in the original GIF, hence they\n    // should be blended with the background first.\n    bool hitGeometry = false;\n    vec3 blendColor = BG_COLOR;\n\n    // 1st ellipse\n    vec3 col = ellipse(p, blendColor, ROT_OFFSET, PI * 0.45, 1.0, hitGeometry);\n    blend(hitGeometry, col, blendColor);\n    \n\tcol = ellipse(p, blendColor, ROT_OFFSET + 0.41, PI * 0.32, 1.15, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 0.76, PI * 0.21, 1.32, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 1.2, PI * 0.07, 1.50, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    // 5th ellipse\n    col = ellipse(p, blendColor, ROT_OFFSET + 1.55, -PI * 0.04, 1.7, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 1.99, -PI * 0.18, 1.9, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 2.335, -PI * 0.29, 2.15, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 2.775, -PI * 0.43, 2.4, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 3.12, -PI * 0.54, 2.65, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    // 10th ellipse\n    col = ellipse(p, blendColor, ROT_OFFSET + 3.559, -PI * 0.68, 2.93, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 3.93, -PI * 0.795, 3.25, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 4.318, -PI * 0.92, 3.55, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n#ifdef ADD_LIGHT_BLEND\n    blendColor =  2.0 * pow(blendColor / 1.0, vec3(2.2));\n#elif defined(ADD_DARK_BLEND)    \n    blendColor = 32.0 * pow(blendColor / 6.0, vec3(2.4));\n#endif    \n    fragColor = vec4(blendColor, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2BDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1155, 1218, 1257, 1257, 1324], [1326, 1326, 1365, 1365, 1525], [1527, 2353, 2409, 2409, 2931], [2933, 3005, 3074, 3074, 5980], [5982, 5982, 6089, 6089, 6810], [6812, 6812, 6887, 6887, 7087], [7089, 7089, 7146, 7196, 9976]], "test": "valid"}
{"id": "Mt2fDd", "name": "distance field slices", "author": "abje", "description": "inspired by [url=https://www.shadertoy.com/view/MlsBDB]Layered Terrain Islands[/url]\nbasically many layers of 2d raymarching", "tags": ["raymarching", "voxels", "slixels"], "likes": 4, "viewed": 565, "published": "Public API", "date": "1517754145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(spin) mat2(sin(spin),cos(spin),cos(spin),-sin(spin))\n\nfloat box(vec2 p, vec2 s) {\n    return length(max(abs(p)-s,vec2(0)));\n}\n\nfloat map(vec2 p, float slice)\n{\n    vec2 offset = vec2(sin(slice*0.1+iTime*0.3),cos(slice*0.1+iTime*0.3));\n    p = fract(p*0.1+offset)*10.0-5.0;\n    \n    vec2 size = vec2((sin(floor(slice))*sin(iTime))*0.2+0.45,cos(slice*0.5)*0.5+0.6)*2.5;\n    \n    float isbox = mod(slice,2.0);\n    \n    return box(p,vec2(size*isbox))-size.x*(1.0-isbox);\n}\n\nvec2 findnormal(vec2 p, float slice, float len) {\n    vec2 eps = vec2(0.0,0.01);\n    return normalize(vec2(\n        map(p+eps.yx,slice),\n        map(p+eps.xy,slice))-\n        len);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0,iTime*3.0,0.0);\n    vec3 rd = vec3(uv,1.0);\n    \n    rd.zy *= rot(iMouse.y/iResolution.y*3.14+3.14);\n    rd.zx *= rot(-iMouse.x/iResolution.x*6.28+3.14*0.5);\n    rd /= length(rd.xz);\n    float rdlen = length(rd);\n    bool hit = false;\n    float len;\n    float dist = 0.0;\n    \n    vec3 floorpos = floor(ro);\n    vec3 signdir = sign(rd);\n    float inv = 1.0/(abs(rd.y)+0.0001);\n    \n    float limit = inv*abs((signdir.y*0.5+0.5)-fract(ro.y));\n    \n    float slice = floor(ro.y);\n    \n    bool hitside = false;\n    \n    for (int i = 0; i < 200; i++)\n    {\n        len = map(ro.xz,slice);\n        \n        if (len < 0.01||dist>100.0)\n        {\n            hit = len < 0.01;\n            break;\n        }\n        \n        hitside = false;\n        \n        len = min(limit,len);\n        limit -= len;\n        ro += rd*len;\n        dist += len*rdlen;\n        \n        if (limit == len)\n        {\n            limit = inv;\n            slice+=signdir.y;\n            \n            hitside = true;\n            \n            //break;\n        }\n    }\n    if (dist < 100.0)\n    {\n        vec3 normal;\n        if (hitside)\n        {\n            normal = vec3(0,-signdir.y,0);\n        } else {\n        \tnormal = vec3(findnormal(ro.xz,slice,len),0.0).xzy;\n        }\n        \n        vec3 lightdir = vec3(-1);\n        \n        vec3 col = vec3(1.0,0.3,0.0);\n        if (hitside) col = vec3(1.0,0.2,0.1);\n        \n        float ambient = 0.2;\n        \n        float diffusion = clamp(dot(-lightdir,normal),ambient,1.0);\n        \n        fragColor = vec4(col*diffusion,1.0);\n        \n        fragColor /= dist*dist*0.005+1.0;\n        \n    }\n    fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2fDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 93, 93, 137], [139, 139, 171, 171, 480], [482, 482, 531, 531, 664], [667, 667, 724, 724, 2495]], "test": "valid"}
{"id": "Mt2fWt", "name": "3 perpendicular cylinders", "author": "UnluckyNinja", "description": "Added 3 cylinders that are perpendicular to each other as intersection and union.\n\nused https://www.shadertoy.com/view/ltyXD3 as template", "tags": ["primitives"], "likes": 1, "viewed": 125, "published": "Public", "date": "1517618093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nTaking IQ's https://www.shadertoy.com/view/Xds3zN and commenting it extensively to make it easier to learn from.\n*/\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// Antialiasing: number of samples in x and y dimensions\n#define AA 1   // make this 1 if your machine is too slow\n\n//------------------------------------------------------------------\n// Distance functions\n//\n// Each function gives the distance from p to a primitive centered at the origin.\n// The position and orientation of the primitive is fixed. To simulate moving\n// the primitive, transform p in the opposite way.\n//\n// The s and u prefixes tell whether the result is signed or unsigned.\n// A signed function will return negative values for p inside the primitive;\n// an unsigned function will return 0.\n\n// Distance from p to plane (at y = 0)\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n//*** Added\nfloat sd3PerpenCylInter( vec3 p, vec3 r )\n{\n    vec3 d = abs(p) - r;\n\treturn max(max(length(p.xy)-r.z, length(p.xz)-r.y),length(p.yz)-r.x);\n}\n\nfloat sd3PerpenCylUnion( vec3 p, vec3 r )\n{\n    vec3 d = abs(p) - 0.4;\n    //broken light\n\treturn max(min(min(length(p.xy)-r.z, length(p.xz)-r.y),length(p.yz)-r.x), length(max(d, 0.0)));\n}\n//*************\n\n\n// Distance from p to sphere of radius s (centered at origin)\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// Distance from p to box whose half-dimensions are b.x, b.y, b.z\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Distance from p to ellipsoid the length of whose semi-principal axes is r.x, r.y, r.z\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// Distance from p to box of half-dimensions b.x,y,z plus buffer radius r\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n// Distance from p to horizontal torus with major radius t.x and minor radius t.y\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x, p.y)) - t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\n// Distance from p to cylinder of radius r with spherical ends centered at a and b.\n// This is a rare exception to the rule that all primitives are centered at the origin.\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\n// Distance from p to cylinder with radius h.x and half-length h.y.\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Distance from p to a cone of height c.z whose vertex is at the origin\n// and is pointing up.\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2(length(p.xz), p.y );\n    float d1 = -q.y - c.z;\n    float d2 = max(dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\n// Euclidean distance function (same as builtin length(p)?)\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// Non-Euclidean distance function, so the sphere \"length6(p) = k\" is squarish.\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\n// Non-Euclidean distance function, so the sphere \"length8(p) = k\" is more squarish.\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// A torus with a squarish minor cross section, using non-Euclidean distance function.\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\n// A torus with squarish major and minor cross sections, using non-Euclidean distance function.\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\n// a cylinder with squarish horizontal cross-section, with radius h.x and half-length h.y.\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n// CSG operations\n\n// subtract primitive 2 from primitive 1, where d1 is distance to primitive 1.\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\n// union primitives 1 and 2\n// d1 is a vec2 where .x is the distance, and .y is the color/material code.\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// intersection of two primitives\nfloat opI( float d1, float d2 )\n{\n    return max(d1, d2);\n}\n\n// Smooth minimum (polynomial smin())\n// See http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat opBlend( float d1, float d2 ) {\n    const float k = 0.1;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\n//------------------------------------------------------------------\n// Domain operations\n\n// Repetition over grid with spacing c.x, c.y, c.z\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Domain deformation: transform the input point p before passing to distance function.\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opCheapBend( vec3 p )\n{\n    float c = cos(20.0 * p.y);\n    float s = sin(20.0 * p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\n\n//------------------------------------------------------------------\n// Return (x,y) where x is minimum distance from pos to objects in the scene, and\n// y is the material of the closest object.\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\tres = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );\n    res = opU( res, vec2( opI( sdBox(    pos-vec3( 2.0,0.2, 1.0), vec3(0.20)),\n\t                           sdSphere( pos-vec3( 2.0,0.2, 1.0), 0.25)), 113.0 ) );\n    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                           sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                           sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n    // distance deformation (knobbly sphere):\n\tres = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 )\n                           + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z)\n                         , 65.0 ) );\n    \n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(    pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n\tres = opU( res, vec2( 0.3*sdTorus( opCheapBend(pos-vec3( 2.0,0.25,-1.0)),vec2(0.20,0.05)), 46.7 ) );\n\n    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n    // scaled primitive:\n    const float scale = .4;\n    res = opU( res, vec2( sdSphere((pos - vec3(-2.0, 0.25, -2.0))/scale, 0.25)*scale, 70. ) );\n    \n    res = opU( res, vec2( opBlend( sdBox(      pos-vec3( 2.0,0.25, 0.0), vec3(.15,.05,.15) ),\n                                   sdCylinder( pos-vec3( 2.0,0.25, 0.0), vec2(0.04,0.2))), 75. ) );\n    res = opU( res, vec2( sd3PerpenCylInter( pos-vec3(2.0, 0.25, 2.0), vec3(0.15)) ,29.0) );\n    res = opU( res, vec2( sd3PerpenCylUnion( pos-vec3(2.0, 0.25, -2.0), vec3(0.15)) ,81.0) );\n    return res;\n}\n\n// Cast a ray from origin ro in direction rd until it hits an object.\n// Return (t,m) where t is distance traveled along the ray, and m\n// is the material of the object hit.\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n// Cast a shadow ray from origin ro (an object surface) in direction rd\n// to compute soft shadow in that direction. Returns a lower value\n// (darker shadow) when there is more stuff nearby as we step along the shadow ray.\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec3 calcNormal( in vec3 pos )\n{\n    // epsilon = a small number\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\n// compute ambient occlusion value at given position/normal\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// Figure out color value when casting ray from origin ro in direction rd.\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    // background sky color gradient\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    // cast ray to nearest object\n    vec2 res = castRay(ro,rd);\n    float t = res.x; // distance\n\tfloat m = res.y; // material code\n    if( m > -0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor ); // reflected ray\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m < 1.5 )\n        {\n            // gray checkerboard floor material\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n\n        // lighting        \n        float occ = calcAO( pos, nor ); // ambient occlusion\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) ); // sunlight\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 ); // ambient light\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ); // diffuse reflection from sunlight\n        // backlight\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y ); // dome light\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 ); // fresnel\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0); // specular reflection\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n        // mix in fog?\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\n// Compute camera-to-world transformation.\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera (ro = ray origin)\t\n        vec3 ro = vec3( 4.0*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2fWt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1110, 1149, 1174, 1174, 1189], [1191, 1203, 1246, 1246, 1344], [1346, 1346, 1389, 1389, 1534], [1553, 1615, 1650, 1650, 1676], [1678, 1744, 1775, 1775, 1866], [1868, 1957, 2000, 2000, 2060], [2062, 2136, 2181, 2181, 2223], [2225, 2307, 2340, 2340, 2397], [2399, 2399, 2435, 2435, 2677], [2679, 2851, 2903, 2903, 3017], [3019, 3019, 3055, 3055, 3303], [3305, 3373, 3409, 3409, 3508], [3510, 3606, 3644, 3644, 3813], [3815, 3815, 3887, 3887, 4102], [4104, 4104, 4171, 4210, 4582], [4584, 4644, 4669, 4669, 4706], [4708, 4788, 4813, 4813, 4871], [4873, 4958, 4983, 4983, 5048], [5050, 5137, 5172, 5172, 5243], [5245, 5341, 5376, 5376, 5447], [5449, 5540, 5577, 5577, 5630], [5720, 5799, 5832, 5832, 5858], [5860, 5965, 5995, 5995, 6028], [6030, 6064, 6097, 6097, 6123], [6125, 6223, 6260, 6260, 6382], [6476, 6527, 6557, 6557, 6586], [6677, 6677, 6701, 6701, 6833], [6835, 6835, 6863, 6863, 6986], [6989, 7184, 7209, 7209, 10237], [10239, 10413, 10453, 10453, 11072], [11074, 11297, 11371, 11371, 11631], [11633, 11711, 11743, 11775, 12219], [12221, 12281, 12323, 12323, 12622], [12624, 12699, 12738, 12776, 14643], [14645, 14688, 14740, 14740, 14919]], "test": "valid"}
{"id": "MtBBDd", "name": "Kaleidesquare", "author": "104", "description": "more playing", "tags": ["kaleidescope"], "likes": 12, "viewed": 187, "published": "Public", "date": "1517565796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n  \tvec2 d = max(tl - uv, uv - br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\nvoid mainImage( out vec4 o, in vec2 uvo)\n{\n    vec2 uv = uvo/iResolution.y;\n    uv.x-=iResolution.x/iResolution.y/2.;\n    uv.y-=.5;\n    float dist = 0.;\n    const float h=.45;\n    for(float i=h;i>0.;i-=.03)\n    {\n        float a = (1.-(i/h))*-iTime*.4;\n\t    float c = cos(a), s = sin(a);\n        dist = min(sdAxisAlignedRect(uv*mat2(c, s, -s, c), vec2(-i),vec2(i)), -dist);\n    }\n    o.rgb = mix(vec3(0.),vec3(.9,.9,.6), 0.77*clamp(1./(clamp(dist, 1./350., 1.)*350.),0.,1.));\n\tvec2 uvn = uvo.xy / iResolution.xy-.5;\n    o -= .07*fract(sin(dot(uvo + iTime,vec2(12.9898,78.233))) * 43758.5453);\n    o *= 1.-dot(uvn,uvn*2.1);\n    o.a=1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBBDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 153], [154, 154, 196, 196, 790]], "test": "valid"}
{"id": "MtBfDd", "name": "Hypnoball", "author": "104", "description": "more playing!", "tags": ["purple", "sizecoding"], "likes": 12, "viewed": 232, "published": "Public", "date": "1517650270", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// fixed mobile by initializing everything.\n\n\nvoid mainImage( out vec4 o, in vec2 uvo)\n{\n    const float h=1.5;\n    float ab = .014,\n        t=iTime*.6+1e3,\n        k=.2,\n        a=0.,\n        c=0.,\n        s=0.;\n    vec3 mc = vec3(.35,.45,.9),\n    \tmc2 = vec3(1.,0.,0.),\n        r=vec3(0.),\n        d2=vec3(0.),\n        e=vec3(0.),\n        n=uvo.xyy,\n        a2=vec3(0.),\n        b=vec3(0.),\n        z=vec3(0.),\n        g=vec3(0.);\n    n.z=t;\n    o.xyz=iResolution;\n    vec2 uv = uvo/o.y,\n        uvn = uvo.xy / o.xy-.5,\n        g2=vec2(0.);\n    uv.x-=o.x/o.y/2.;\n    uv.y-=.5;\n    for(float i=h;i>.2;i-=.05)\n    {\n        a = (1.-(i/h))*t*(k=-k);\n        for(int ai=0;ai<3;++ai) {\n    \t\tuv *= mat2(c = cos(a), s = sin(a), -s, c);\n        \ta=ab;\n  \t\t\to.xy=max(-uv-i,uv-i);\n    \t\td2[ai] = length(max(g2, o.xy)) + min(0., max(o.x, o.y));\n        }\n        r = min(d2, -r);\n    }\n    z+=length(uv);\n    r = max(min(max(r,-z+.24), z-.2), -z+.18);\n    mc2 = mix(mc, mc2, pow(z,g+1.4)*.8);\n    b = pow(max(1.-z,0.),g+2.7)*1e3;\n    e = 1.-pow(max(g,r), g+.09);\n    a2 = clamp(1./(clamp(r, 1./b, g+1.)*b),0.,1.);\n    o.rgb = mix(.12*(-z+1.),mc2, e+.5*a2);\n   \tn = fract(n * vec3(.14,.13,.15));\n    n += dot(n, n.yxz+19.);\n    o.rgb -=fract((n.xxy + n.yxx)*n.zyx)*.09;\n    o *= 1.-dot(uvn,uvn*2.);\n}\n\n\n\n\n/*\n\nvoid mainImage( out vec4 o, in vec2 uvo)\n{\n    const float h=1.5;\n    float ab = 0.014,t=iTime*.6+1e3,k=.2,a,c,s;\n    vec3 mc = vec3(.35,.45,.9),\n    \tmc2,r,d2,e,n=uvo.xyy,a2,b,z,g;\n    n.z=t;\n    mc2.r=1.;\n    o.xyz=iResolution;\n    vec2 uv = uvo/o.y,uvn = uvo.xy / o.xy-.5,g2;\n    uv.x-=o.x/o.y/2.;\n    uv.y-=.5;\n    for(float i=h;i>.2;i-=.05)\n    {\n        a = (1.-(i/h))*t*(k=-k);\n        for(int ai=0;ai<3;++ai) {\n    \t\tuv *= mat2(c = cos(a), s = sin(a), -s, c);\n        \ta=ab;\n  \t\t\to.xy=max(-uv-i,uv-i);\n    \t\td2[ai] = length(max(g2, o.xy)) + min(0., max(o.x, o.y));\n        }\n        r = min(d2, -r);\n    }\n    z+=length(uv);\n    r = max(min(max(r,-z+.24), z-.2), -z+.18);\n    mc2 = mix(mc, mc2, pow(z,g+1.4)*.8);\n    b = pow(max(1.-z,0.),g+2.7)*1e3;\n    e = 1.-pow(max(g,r), g+.09);\n    a2 = clamp(1./(clamp(r, 1./b, g+1.)*b),0.,1.);\n    o.rgb = mix(.12*(-z+1.),mc2, e+.5*a2);\n   \tn = fract(n * vec3(.14,.13,.15));\n    n += dot(n, n.yxz+19.);\n    o.rgb -=fract((n.xxy + n.yxx)*n.zyx)*.09;\n    o *= 1.-dot(uvn,uvn*2.);\n}\n\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBfDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 89, 89, 1292]], "test": "valid"}
{"id": "MtBfzy", "name": "Torus_Thingy_11", "author": "balkhan", "description": "torus", "tags": ["torus"], "likes": 7, "viewed": 180, "published": "Public", "date": "1517972862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t400.\n#define E\t\t\t0.00001\n#define FAR\t\t\t50.\n#define PI\t\t\t3.14\n\n// noises taken from : https://www.shadertoy.com/view/4djSRW\n\n// -------------noise--------------------- //\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1, .05030, -.0973)\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n// -------------noise--------------------- //\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    pos.z = 24.5+1.5*sin(t*10.);    \n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    if (inter.y < FAR)\n    col.xyz = ret_col*(inter.y*.085);\n    col += -h*.01251-.75+.25*blackbody(3000.*length(h.x+h.y+h.z)*.005125);\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    p.z += 10.;\n    \n//    rotate(p.xz, 1.57-.5*iTime );\n    rotate(p.yz, 1.57-.5*iTime );\n    var = atan(p.x,p.y);\n    vec2 q = vec2( ( length(p.xy) )-6.,p.z);\n    var = sin(floor(sin(atan(p.x, p.y)*1.+iTime*2.)*3.14 + 3.14*sin(floor(atan(q.x, q.y)*4. + iTime*5.) + ((iTime*1.1))*.8 ) ));//+sin(floor(atan(p.x, p.y)*4. +floor(iTime*10.1)*.1 ) );\n    float\toldvar = var;//var;\n    var = ( hash11(sin(var*1.) ) );\n    ret_col = 1.-vec3(.350, .2, .3);\n    ret_col = .5*hash31(sin(var*1.) );\n    q.x -= 2.5*var;\n    mind = length(q)-2.-var*1.5;\n    mind = max(mind, -(length(q)-1.5-var*1.5) );\n    h -= .8-ret_col*.125/(.0251+mind*mind);\n    \n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.12; // makes artefacts disappear\n            // log trick by aiekick\n\t        if (log(dist.y*dist.y/dist.x/1e5) > .0 || dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBfzy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[542, 542, 565, 565, 683], [685, 685, 707, 707, 825], [1207, 1207, 1235, 1235, 1560], [1609, 1609, 1652, 1652, 2077], [2079, 2079, 2100, 2100, 2800], [2802, 2802, 2834, 2834, 3320], [3336, 3336, 3376, 3376, 3451], [3453, 3453, 3475, 3475, 3681]], "test": "error"}
{"id": "MtjBDc", "name": "palm tree top", "author": "jaredmcdonald", "description": "sorta following along with https://www.youtube.com/watch?v=0ifChJ0nJfM", "tags": ["beginner"], "likes": 1, "viewed": 400, "published": "Public API", "date": "1517456245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.2, 0.5, 0.9);\n    vec2 q = p - vec2(0.5, 0.5);\n    \n    float r = 0.25 + 0.1 *\n        cos(atan(q.x, q.y) * 12. -\n             (20. + 0.8 * sin(iTime)) * p.x\n           );\n    col = mix(vec3(0., 0.9, 0.), col,\n              smoothstep(r, r + 0.01, length(q)));\n \n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjBDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 494]], "test": "valid"}
{"id": "MtjBWc", "name": "fireflies", "author": "ShadowX", "description": "camera+raymarching", "tags": ["raymarching"], "likes": 1, "viewed": 191, "published": "Public", "date": "1517443616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define mf(a) min(fract(a),1.-fract(a))\n\nfloat map(vec3 p, float r)\n{\n    return length(2.*fract(p)-1.) - r;\n}\n\nfloat trace(vec3 ro, vec3 rd, vec3 o, float r)\n{\n    float t = 0.;\n    for(int i = 1; i<=32; i++)\n    {\n        vec3 p = ro + rd*t;\n        float d = map(p+o,r);\n        t += d*.5;\n    }\n   return 1./t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2. - 1.;\n    uv.x *=iResolution.x/iResolution.y;\n    \n    float t = iTime/5.;\n    float z = 1.;\n    \n    vec3 cp = vec3(3.*sin(t),sin(t),-3.*cos(t));\n    vec3 ct = vec3(0.,cos(t),0.);\n    \n    \n    vec3 f = normalize(ct-cp);\n    vec3 r = cross(vec3(0.,1.,0.),f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = cp + f * z; \n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    vec3 rd = i-cp;   \n    \n    vec3 col = vec3(0.);\n    for(float i=1.; i<=4.; i++)\n    {   \n      col += vec3(trace(cp,rd, vec3(sin(t*i)/2.,cos(t*i)/2.,0.),.05+(.05*sin(iTime+i*45.))));\n    }\n    float tx = sin(t)/2.+.5;\n    col.r -= mf(col.r*1.*sin(2.*t)/2.+.5)/1.2;\n    col.g -= mf(col.g*1.*sin(3.*t+120.)/2.+.5);\n    col.b -= mf(col.b*1.*sin(5.*t+240.)/2.+.5)/1.4;\n//col = mf(col);\n    fragColor = vec4(col*3.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjBWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 129], [131, 131, 179, 179, 335], [336, 336, 393, 393, 1231]], "test": "valid"}
{"id": "Xd3cR8", "name": "Rounded Loading Spinner", "author": "Kosro", "description": "Could be optimized quite a lot...", "tags": ["2d", "loading", "pureevil"], "likes": 14, "viewed": 1876, "published": "Public API", "date": "1517852022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\n#define THICCNESS 0.03\n#define RADIUS 0.2\n#define SPEED 4.0\n\n#define aa 2.0 / min(iResolution.x,iResolution.y)\n\nvec2 remap(vec2 coord) {\n\treturn coord / min(iResolution.x,iResolution.y);\n}\n\nfloat circle(vec2 uv, vec2 pos, float rad) {\n\treturn 1.0 - smoothstep(rad,rad+0.005,length(uv-pos));\n}\n\nfloat ring(vec2 uv, vec2 pos, float innerRad, float outerRad) {\n\treturn (1.0 - smoothstep(outerRad,outerRad+aa,length(uv-pos))) * smoothstep(innerRad-aa,innerRad,length(uv-pos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n vec2 uv = remap(fragCoord.xy);\n uv -= vec2(0.5 / iResolution.y * iResolution.x,0.5);\n\n float geo = 0.0;\n\n geo += ring(uv,vec2(0.0),RADIUS-THICCNESS,RADIUS);\n\n float rot = -iTime * SPEED;\n\n uv *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));\n\n float a = atan(uv.x,uv.y)*PI*0.05 + 0.5;\n\n a = max(a,circle(uv,vec2(0.0,-RADIUS+THICCNESS/2.0),THICCNESS/2.0));\n\n fragColor = vec4(a*geo);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3cR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 156, 156, 208], [210, 210, 254, 254, 312], [314, 314, 377, 377, 494], [496, 496, 553, 553, 939]], "test": "valid"}
{"id": "Xd3yzj", "name": "Codebar Feb18 Demo Shader", "author": "rkibria", "description": "Demo shader for the Codebar February Monthly 2018 talk. https://codebar.io/meetings/monthly-feb-2018\n\nPresentation link https://docs.google.com/presentation/d/17AlwAX1xU1QmHqgH_LPrRbTD2hpVXgPtMQI4nqgCG6c/edit?usp=sharing\n", "tags": ["2d", "tutorial", "demo"], "likes": 1, "viewed": 82, "published": "Public", "date": "1519566451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // ANIMATE\n    float t = 0.0;\n    t = iTime;\n    \n    // MOVE COORDINATE ORIGIN TO CENTRE\n    uv -= vec2(0.5, 0.5);\n    \n    // 5a) ROTATE EVERYTHING AROUND ORIGIN\n    // https://en.wikipedia.org/wiki/Rotation_matrix\n    float rt = t * 0.5;\n    mat2 rmt = mat2(cos(rt), -sin(rt), sin(rt), cos(rt));\n    uv = rmt * uv;\n    \n    // 5b) WAVY DISTORTION EFFECT\n\tuv.y += sin(uv.x * 12. + t) * 0.25;\n\tuv.x += sin(uv.y * 12. + t) * 0.25;\n\n\t// 4) CLONE THE IMAGE SEVERAL TIMES\n    uv *= 3.0;\n    uv = mod(uv, 1.0);\n\n    // BLUE BACKGROUND\n    fragColor = vec4(0.,0.,1.,1.);\n\n    // 1) RIGHT SIDE IS RED\n    if (uv.x > 0.5) fragColor = vec4(1.,0.,0.,1.);\n    \n    // 2) UPPER HALF ADDS GREEN\n    if (uv.y > 0.5) fragColor.y = 1.;\n    \n    // 3) OUTSIDE CIRCLE SWIZZLE COLOURS AROUND\n    if (distance(uv, vec2(0.5)) > 0.25) fragColor.xyz = fragColor.zxy;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3yzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 949]], "test": "valid"}
{"id": "XdccDr", "name": "Torus_Thingy_14", "author": "balkhan", "description": " ", "tags": ["torus"], "likes": 3, "viewed": 135, "published": "Public", "date": "1518394295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.1 // defining a high epsilon value let you blurr jittering stuff\n#define FAR\t\t\t410.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n#define FILLED\t\t1 // can be [0-2]\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 210.0);\n\n    pos.z += 100.5*sin(t*2.);\n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    col.xyz = vec3(.5,.6,.20)*(1.-inter.y/inter.x*.45);\n    c_out =  vec4(.75-.25/abs(-h*4.+1.25-.0625*col),1.0);\n    c_out = c_out * c_out * c_out * (3.-2.*c_out);\n    c_out *= (1.5-length(uv)*1.);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    rotate(p.xz, 1.57-.125*iTime );\n    rotate(p.yz, 1.57-.5*iTime );\n    vec3 op = p;\n    var  = atan(op.x,op.y);\n    p.xy = modA(p.xy, 80.);\n    p.x -= 50.;\n    p.zy = modA(p.zy, 80.);\n    p.z -= 20.;\n    p.yz = modA(p.yz, 80.); // sidefx++\n    p.y -= 40.;\n    vec2 q = vec2( ( mylength(p.xy) )-1.,1.*p.z+10.*cos(iTime*-1.5*1.+.25*length(p.xy)) );\n    rotate(q, (var*.25+iTime*.5) );\n    q.xy = abs(q.xy)-12.;\n    #if FILLED >= 1\n    q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;\n    #if FILLED == 2\n    q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;\n    #endif\n    #endif\n    ret_col = vec3(.20, .2, .0);\n    mind = mylength(q)-.5;\n    h -= vec3(.00751,.00851,.01)*vec3(1.)*1./max(1.+mind*mind, .001);\n    h += vec3(.05,.105,.205)*vec3(1.)*.25/max(5.10001+mind*mind, .001);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdccDr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[680, 680, 723, 723, 1178], [1251, 1251, 1284, 1284, 1415], [1440, 1440, 1461, 1461, 2459], [2461, 2461, 2493, 2493, 2904], [2920, 2920, 2944, 2944, 3041], [3043, 3043, 3083, 3083, 3158], [3160, 3160, 3188, 3188, 3296], [3298, 3298, 3320, 3320, 3526], [3528, 3528, 3578, 3578, 3841]], "test": "error"}
{"id": "XdccRH", "name": "Spindle of Death", "author": "kMiller", "description": "Hw for procedural graphics class", "tags": ["sdf", "gif"], "likes": 1, "viewed": 71, "published": "Public", "date": "1518120202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n// Union (with material data)\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sphere(vec3 pos, float r)\n{\n    return length(pos) - r;\n}\n\nfloat torus(vec3 pos, vec2 t)\n{\n    vec2 qos = vec2(length(pos.yz) - t.x, pos.x);\n    return length(qos) - t.y;\n}\n\nmat3 rotMat(float theta) {\n    float s1 = sin(theta);\n    float c1 = cos(theta);\n\treturn mat3(vec3(c1, -s1, 0),\n                    vec3(s1, c1, 0),\n                    vec3(0, 0, 1)); \n}\n\nvec3 rotRing(vec3 p) {\n   float c = cos(radians(22.5));\n   float s = sin(radians(22.5));\n   return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\nvec2 sceneSDF(vec3 pos) {\n    float r = .8;\n    float t = .005;\n     float time = iTime;\n    //float time = gain(fract(iTime), .7);\n\t\n    mat3 rotZ = rotMat(time * 2.0);\n    vec3 p = pos;\n    float t1 = torus(p, vec2(r, t));\n    vec3 bp = rotZ * p;\n    bp.y -= r;\n    float b1 = sphere(bp, .06);\n    \n    \n    p = rotRing(p);\n    float t2 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .1);\n   \tbp = rotZ * p;\n    bp.y -= r;\n    float b2 = sphere(bp, .06);\n    float ball = min(b1, b2);\n    float sdf = min(t1, t2);\n    \n    p = rotRing(p);\n    float t3 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .2);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b3 = sphere(bp, .06);\n    ball = min(ball, b3);\n    sdf = min(sdf, t3);\n    \n    p = rotRing(p);\n    float t4 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .3);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b4 = sphere(bp, .06);\n    ball = min(ball, b4);\n    sdf = min(sdf, t4);\n    \n    p = rotRing(p);\n    float t5 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .4);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b5 = sphere(bp, .06);\n    ball = min(ball, b5);\n    sdf = min(sdf, t5);\n    \n    p = rotRing(p);\n    float t6 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .5);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b6 = sphere(bp, .06);\n    ball = min(ball, b6);\n    sdf = min(sdf, t6);\n    \n    p = rotRing(p);\n    float t7 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .6);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b7 = sphere(bp, .06);\n    ball = min(ball, b7);\n    sdf = min(sdf, t7);\n    \n    p = rotRing(p);\n    float t8 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .7);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b8 = sphere(bp, .06);\n    ball = min(ball, b8);\n    sdf = min(sdf, t8);\n    \n    //return vec2(sdf, 0);\n    \n\tvec2 rings = vec2(sdf, 0);\n\n    return opU(rings, vec2(ball, 1.0));\n}\n\n\nvec2 raymarch(in vec3 origin, in vec3 dir)\n{\n    vec2 dist = vec2(10000000.0, 0.0);\n    float dt = 0.01;\n    float t = 0.01;\n    \n    for(int i = 0; i < 200; i++)\n    {\n        dist = sceneSDF(origin + t * dir);\n\n        if(dist.x < 0.001)\n        {\n            return vec2(t, dist.y);\n        }\n        else if (t >100.0)\n        {\n            break;\n        }\n        \n        t += dist.x;\n    }\n    return vec2(-1, 0);\n}\n\nvec3 rayCast(vec2 pixel, vec3 origin)\n{ \n    vec3 ref = vec3(0.0, 0.0, 0.0);\n    vec3 camLook = normalize(ref - origin);\n    vec3 camRight = normalize( cross(camLook, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = ref + pixel.x * camRight + pixel.y * camUp;\n    return normalize(rayPoint - origin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    //ndc coordinates\n    vec2 scrPt = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float pi = 3.1415;\n    float timeInt = mod(iTime * .5, 8.0);\n    float c = cos(timeInt * .5);\n    float s = sin(timeInt * .5);\n\n    mat3 rotX = mat3(vec3(c, 0, -s),\n                    vec3(s, 0, c),\n                    vec3(0, 0, 1)); \n    vec3 cameraPos;\n    if(timeInt <= 1.0) {\n        cameraPos = vec3(0, 0, 4);\n    } else if(timeInt <= 2.0) {\n        cameraPos = mix(vec3(0, 0, 4), vec3(0, 4, 0), mod(timeInt,1.0));\n    } else if(timeInt <= 3.0) {\n        cameraPos = vec3(0, 4, 0.01);\n    } else if(timeInt <= 4.0) {\n        cameraPos = mix(vec3(0, 4, 0.01), vec3(0, 0, -4), mod(timeInt,1.0));\n    } else if(timeInt <= 5.0) {\n        cameraPos = vec3(0, 0, -4);\n    } else if(timeInt <= 6.0) {\n        cameraPos = mix(vec3(0, 0, -4), vec3(0, -4, 0.01), mod(timeInt,1.0));\n    } else if(timeInt <= 7.0) {\n        cameraPos = vec3(0, -4, 0.01);\n    } else {\n        cameraPos = mix(vec3(0, -4, 0.01), vec3(0, 0, 4), mod(timeInt,1.0));\n    }\n    //vec3 cameraPos = vec3(0, 0, 4);\n    vec3 rayDir = rayCast(scrPt, cameraPos);\n\tvec2 object = raymarch(cameraPos, rayDir);\n    \n    if (object.x > 0.0) // hit\n    {\n        if(object.y == 0.0) {\n\t\t\tfragColor = vec4(0, 0, 0, 1);\n        } else {\n            fragColor = vec4(1);\n        }\n    }\n    else // miss\n    {\n        fragColor = vec4(.5, .5, .5, 1.0);\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdccRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 110], [112, 142, 172, 172, 210], [212, 212, 245, 245, 275], [277, 277, 308, 308, 390], [392, 392, 418, 418, 579], [581, 581, 603, 603, 730], [732, 732, 757, 757, 2647], [2650, 2650, 2694, 2694, 3073], [3075, 3075, 3114, 3114, 3430], [3432, 3432, 3489, 3512, 4907]], "test": "valid"}
{"id": "Xdccz7", "name": "Spindle of Death-CIS 566", "author": "jamie2719", "description": "CIS 566 project 2", "tags": ["raymarching"], "likes": 0, "viewed": 85, "published": "Public", "date": "1518142570", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.15926\n\nmat4 rotate(vec3 rot) {\n\tmat4 rx = mat4(vec4(1, 0, 0, 0),\n\t\t\t\t\tvec4(0, cos(rot.x * PI/180.0), sin(rot.x * PI/180.0), 0),\n\t\t\t\t\tvec4(0, -sin(rot.x * PI/180.0), cos(rot.x * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\tmat4 ry = mat4(vec4(cos(rot.y * PI/180.0), 0, -sin(rot.y * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 1, 0, 0),\n\t\t\t\t\tvec4(sin(rot.y * PI/180.0), 0, cos(rot.y * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\tmat4 rz = mat4(vec4(cos(rot.z * PI/180.0), sin(rot.z * PI/180.0), 0, 0),\n\t\t\t\t\tvec4(-sin(rot.z * PI/180.0), cos(rot.z * PI/180.0), 0, 0),\n\t\t\t\t\tvec4(0, 0, 1, 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\t\t\t\t\t\n\treturn rz * ry * rx;\n\t\n}\n\nmat4 translate(vec3 trans) {\n\treturn mat4(vec4(1, 0, 0, 0),\n\t\t\t\tvec4(0, 1, 0, 0),\n\t\t\t\tvec4(0, 0, 1, 0),\n\t\t\t\tvec4(trans.x, trans.y, trans.z, 1));\n}\n\n\n\nfloat sdSphere( vec3 p, float s, vec3 trans, vec3 rot, vec3 rot1) \n{\n    \n    p = vec3(rotate(rot1) * vec4(p, 1));\n    p = vec3(rotate(rot) * vec4(p, 1));\n   \tp = vec3(translate(trans) * vec4(p, 1));\n    \n    \n    \n  \treturn length(p)-s;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t, vec3 trans, vec3 rot )\n{\n    p = vec3(rotate(rot) * vec4(p,1));\n    p = vec3(translate(trans) * vec4(p,1));\n    \n  \tvec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat ringSDF(vec3 p) {\n    float ringRotSpeed = clamp(fract(iTime * .25) * 4.0 - 1.0, 0.0, 1.0) + floor(iTime * .25);\n    \n    p = vec3(rotate(vec3(90.0 * ringRotSpeed, 0, 0)) * vec4(p,1));\n    \n    float centerRing =  sdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90, 0, 90));\n    float ring1 =\t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, 67.5));\n    float ring2 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, 45));\n    float ring3 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, 22.5));\n    float ring4 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, 0));\n    float ring5 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, -22.5));\n    float ring6 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, -45));\n    float ring7 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, -67.5));\n    float ring8 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, 90));\n    centerRing = unionSDF(centerRing, ring1);\n    centerRing = unionSDF(centerRing, ring2);\n    centerRing = unionSDF(centerRing, ring3);\n    centerRing = unionSDF(centerRing, ring4);\n    centerRing = unionSDF(centerRing, ring5);\n    centerRing = unionSDF(centerRing, ring6);\n    centerRing = unionSDF(centerRing, ring7);\n    centerRing = unionSDF(centerRing, ring8);\n    \n    return centerRing;\n}\n\nfloat ballSDF(vec3 p) {\n    float ringRotSpeed = clamp(fract(iTime * .25) * 4.0 - 1.0, 0.0, 1.0) + floor(iTime * .25);\n    p = vec3(rotate(vec3(90.0 * ringRotSpeed, 0, 0)) * vec4(p,1));\n    //130\n    \n    float centerBall = sdSphere(p, .5,  vec3(0, 5, 0), vec3(125.0 * iTime, 0, 0), vec3(0, 0, 0));\n    float ball1 = sdSphere(p, .2,  vec3(0, 5, 0), vec3(-109.0 * iTime, 0, 0), vec3(0, -22.5, 0));\n    float ball2 = sdSphere(p, .2,  vec3(0, 5, 0), vec3(-111.0 * iTime, 0, 0), vec3(0, -45, 0));\n    float ball3 = sdSphere(p, .2,  vec3(0, 5, 0), vec3(-113.0 * iTime, 0, 0), vec3(0, -67.5, 0));\n    float ball4 = sdSphere(p, .2,  vec3(0, 5, 0), vec3(-115.0 * iTime, 0, 0), vec3(0, -90, 0));\n    float ball5 = sdSphere(p, .2,  vec3(0, 5, 0), vec3( 123.0 * iTime, 0, 0), vec3(0, 22.5, 0));\n    float ball6 = sdSphere(p, .2,  vec3(0, 5, 0), vec3( 121.0 * iTime, 0, 0), vec3(0, 45, 0));\n    float ball7 = sdSphere(p, .2,  vec3(0, 5, 0), vec3( 119.0 * iTime, 0, 0), vec3(0, 67.5, 0));\n    float ball8 = sdSphere(p, .2,  vec3(0, 5, 0), vec3( 117.0 * iTime, 0, 0), vec3(0, 90, 0));\n   \n    centerBall = unionSDF(centerBall, ball1);\n    centerBall = unionSDF(centerBall, ball2);\n    centerBall = unionSDF(centerBall, ball3);\n    centerBall = unionSDF(centerBall, ball4);\n    centerBall = unionSDF(centerBall, ball5);\n    centerBall = unionSDF(centerBall, ball6);\n    centerBall = unionSDF(centerBall, ball7);\n    centerBall = unionSDF(centerBall, ball8);\n    \n    \n    return centerBall;\n}\n\n\n\n\nvec3 toWorldSpace(vec3 p, vec3 eye, vec3 ref) {\n\tfloat fov = 75.0;\n\n\tfloat sx = (p.x);\n    float sy = (p.y);\n    float A = iResolution.x / iResolution.y;\n    float alpha = fov / 2.0 * (3.159 / 180.0);\n    vec3 forward = normalize(ref - eye);\n   \tvec3 right = normalize(cross(vec3(0, 1, 0), forward));\n   \tvec3 localUp = normalize(cross(forward, right));\n    \n\n    //convert screen point to world point\n    float len = .1;//length(forward);\n    vec3 V = (localUp * len * tan(alpha));\n    vec3 H = right * A * len *tan(alpha);\n\n    return vec3(eye + len * forward + sx * H + sy * V); //world point \n}\n\nfloat raymarch(vec3 p, vec3 eye, vec3 ref) {\n    //get ray from world point\n    vec3 dir = normalize(p - eye);\n    vec3 origin = eye;\n    \n    \n    \n    float rings;\n    float balls;\n    vec3 minInter; \n    vec3 intersection;\n    float intersected = 0.0; //0 if not intersected, 1 if intersected ring, 2 if intersected balls\n    float t = 0.005;\n\tfor (int i = 0; i < 64; i++) {\n\t\tintersection = origin + dir * t;\n\t\t\n        \n        rings = ringSDF(intersection);\n        balls = ballSDF(intersection);\n\t\t\n\t\tif(rings <= .001) {\n\t\t\tintersected = 1.0;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n        else if(balls <= .001) {\n            intersected = 2.0;\n            break;\n        }\n\t\tt += unionSDF(balls, rings);\n\t}\n   \treturn intersected;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scrPt = uv * 2.0 - 1.0; // Transform to NDC\n    scrPt *= iResolution.x / iResolution.y;\n    \n    vec3 eye =  vec3(0, 0, -7);\n    vec3 ref = vec3(0.0, 0.0, 0.0);\n    \n    \n    vec3 p = toWorldSpace(vec3(scrPt, 1), eye, ref);\n    \n    \n    float val = raymarch(p, eye, ref);\n    \n    vec3 col;\n    if(val == 2.0) {\n        col = vec3(1, 1, 1);\n    }\n    else if(val == 1.0) {\n        col = vec3(0, 0, 0);\n    }\n    else {\n        col = vec3(.2, .2, .2);\n    }\n    \n    fragColor = vec4(col,1);\n     \n\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdccz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 43, 43, 630], [632, 632, 660, 660, 778], [782, 782, 850, 850, 1021], [1024, 1024, 1079, 1079, 1234], [1237, 1237, 1279, 1279, 1311], [1313, 1313, 1336, 1336, 2637], [2639, 2639, 2662, 2662, 4116], [4121, 4121, 4168, 4168, 4719], [4721, 4721, 4765, 4796, 5441], [5443, 5443, 5500, 5550, 6106]], "test": "valid"}
{"id": "XdcczH", "name": "Torus_Thingy_13", "author": "balkhan", "description": "Torus", "tags": ["torus"], "likes": 21, "viewed": 287, "published": "Public", "date": "1517892169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t110.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 60.0);\n\n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    if (inter.y >= FAR)\n        ret_col = vec3(.90, .82, .70);\n    col.xyz = ret_col*(1.-inter.x*.005);\n    col += h*.005;\n    c_out =  vec4(col,1.0);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nfloat\tscene(vec3 p)\n{  \n    p.z += -45.;\n    float\tvar;\n    float\tmind = 1e5;\n    float\tcage = 1e5;\n    p.z -= sin(t*2.+3.14)*4.;\n    rotate(p.xz, 1.57-.35*iTime );\n    rotate(p.yz, 1.57-.5*iTime );\n    vec3 op = p;\n    p.xz = modA(p.xz, 50.);\n    p.x -= 4.;\n    var  = atan(op.x,op.y);\n    vec2 q = vec2( ( length(p.xy) )-20.,p.z);\n    \n    cage = mylength(q)-.25;\n    \n    p = op;\n    q = vec2( length(p.xz)-4., p.y );\n    rotate(q, iTime+1.*atan(p.x, p.z));\n\n    q = modA(q, 15.);\n    q.x -= 1.5;\n    q.x = abs(q.x)-.125;\n    q.x = abs(q.x)-.125;\n    q.x = abs(q.x)-.125;\n    q.x = abs(q.x)-.125;\n    q.x = abs(q.x)-.125;\n    q.x = abs(q.x)-.125;\n    q.x = abs(q.x)-.125;\n    mind = min(cage,\n               length(q)-.06125\n              );\n    \n    ret_col = (mind == cage) ? vec3(.90, .9, 1.0) : vec3(.90, .82, .70);\n    float ball = 1e5;\n    p = op;\n    p.xz = modA(p.xz, 30.);\n    p.x -= 10.;\n    rotate(p.xy, iTime*.25);\n    p.yx = modA(p.yx, 100.);\n    p.y -= 10.;\n    ball = length(p.xy)-.001;\n    ball = min(ball, length(p.zy)-.001);\n    ball = min(ball, length(p)-.05);\n\n    p = op;\n    p.xz = modA(p.xz, 100.);\n    p.x -= 15.;\n    rotate(p.xy, -iTime*.5);\n    p.yx = modA(p.yx, 5.);\n    p.y -= 14.;\n    ball = min(ball, mylength(p.xyz)-.2);\n    \n    mind = min(mind, ball);\n    h += vec3(.5, .5, .9)*1./(ball*ball*1.+.25);\n    h -= vec3(-.50,.1250,1.)*vec3(1.)*.0125/(.01+mind*mind);\n    h -= vec3(.05,.05,1.)*vec3(1.)*.0125/(.01+mind*mind);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    ret = max(abs(p.z)+.5*abs(p.x), ret);\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcczH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[616, 616, 659, 659, 1035], [1108, 1108, 1141, 1141, 1272], [1297, 1297, 1318, 1318, 2773], [2775, 2775, 2807, 2807, 3218], [3234, 3234, 3258, 3258, 3355], [3357, 3357, 3381, 3381, 3515], [3517, 3517, 3557, 3557, 3632], [3634, 3634, 3662, 3662, 3770], [3772, 3772, 3794, 3794, 4000], [4002, 4002, 4052, 4052, 4315]], "test": "error"}
{"id": "XdcyW8", "name": "I love you all", "author": "huttarl", "description": "Happy Valentine's Day, 2018, to my wife and daughters.", "tags": ["distanceestimation", "heart"], "likes": 11, "viewed": 5990, "published": "Public API", "date": "1518581527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Distance estimation: thanks to http://www.iquilezles.org/www/articles/distance/distance.htm\n\n/* Tweaks to try:\n - fill in the hearts (where heart(p) < 0)  With what texture?\n*/\n\n// My daughter requested stripes.\n// #define STRIPES 1\n// #define SOLID_HEARTS 1\n\n// heart(p) = 0 is a heart-shaped curve.\n\n#define EQUATION 2\n\n#if EQUATION == 1\n\n// See https://math.stackexchange.com/a/438161\n// This one has burrs/discontinuities on the sides.\nfloat heart(vec2 p) {\n    float k = dot(p, p) - 1.;\n    return k * k * k - p.x * p.x * p.y * p.y * p.y;\n}\n\n// Gradient of heart function, analytical version, thanks to IQ.\nvec2 grad(vec2 p) {\n    float k = dot(p, p) - 1.;\n    return p * (6.0 * k * k - p.yx * p.yx * p.y * vec2(2.0, 3.0));\n}\n\n#else\n\n// Heart curve suggested by IQ, improved by Dave_Hoskins.\nfloat heart(vec2 p) {\n    // Center it more, vertically:\n    p.y += .6;\n    // This offset reduces artifacts on the center vertical axis.\n    const float offset = .3;\n    // (x^2+(1.2*y-sqrt(abs(x)))^21)\n    float k = 1.2 * p.y - sqrt(abs(p.x) + offset);\n    return p.x * p.x + k * k - 1.;\n}\n\n// Gradient of heart function.\n// TODO: make it analytic.\n// For now, use central differences method.\nvec2 grad(vec2 p) {\n    vec2 h = vec2(0.01, 0.0);\n    return vec2(heart(p + h.xy) - heart(p - h.xy),\n                heart(p + h.yx) - heart(p - h.yx)) / (2.0 * h.x);\n}\n\n#endif\n\n// Return 0-1 scalar based on abs distance from heart line.\nfloat color(vec2 p, float vol) {\n    float v = heart(p);\n#ifdef SOLID_HEARTS\n    if (v < 0.) return 0.;\n#endif\n    vec2  g = grad(p);\n    float de = abs(v) / length(g);\n    // Thickness: vary with volume\n    float eps = (15. + vol * 3.)/iResolution.x;\n    return smoothstep(1.0 * eps, 2.0 * eps, de);\n}\n\n// from https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float pi = 3.14159;\n\nvec3 heart1(vec2 p, int i, float vol) {\n    vec2 offset = vec2(0.);\n    float scale = .7;\n    float a;\n    vec3 hue;\n    \n    switch (i) {\n        case 0:\n            hue = vec3(1., .3, .3); \n            a = pi * 0. - iTime * .3; \n            offset = vec2(cos(a), sin(a)) * .03;\n            break;\n        case 1:\n            hue = vec3(.6, .6, 1.); \n            a = pi * 1. - iTime * .3; \n            offset = vec2(cos(a), sin(a)) * .03;\n            break;\n        default:\n            hue = hsv2rgb(vec3(float(i) / 5. + iTime * .2, .4, .9));\n            a = pi * (float(i) - 2.) * (2. / 5.) + iTime * .3; \n            offset = vec2(cos(a), sin(a)) * .2;\n            scale = .3 + (float(i) * .05);\n    }\n\n    vec2 q = (p + offset) / (scale * (1.0 + vol * .3) * .8);\n    float brightness = 1. - color(q * 10., vol);\n    return brightness * hue;\n}\n\nconst int nLevels = 32;\n\n// Adapted from https://www.shadertoy.com/view/4tjBRz\n// TO DO: would like to use buffers to make the effects of volume\n// ease in and out, instead of sudden spikes.\nfloat soundVolume() {\n    float total = 0.0, maxVol = 0.0;\n    for( int i = 0; i < nLevels; i++ )\n    {\n        float v = texelFetch(iChannel0, ivec2((i*256)/nLevels, 1), 0).x-0.5;\n        maxVol = max(maxVol, v*v);\n        total += v*v;\n    }\n    // Split the difference between average and max.\n    float vol = (total / float(nLevels) + maxVol) * 0.5;\n    // Attempt to smooth out the maximum.\n    return pow(vol, 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.xx;\n    \n    float vol = soundVolume();\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < 7; i++) {\n        col += heart1(uv, i, vol);\n    }\n\n#ifdef STRIPES\n    float y = floor(mod(uv.y, .2) * 5. * 3.) / 3.;\n    vec3 background = vec3(1., y, y);\n#else\n    vec3 background = mix(vec3(.1), vec3(1., 0., 0.), vol * .2);\n#endif\n    \n    fragColor = vec4(col + background, 1.0);\n}\n", "image_inputs": [{"id": "MsjSDz", "previewfilepath": "https://soundcloud.com/rockcreekfellowship/oh-the-deep-deep-love-of-jesus", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/rockcreekfellowship/oh-the-deep-deep-love-of-jesus", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcyW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1376, 1436, 1468, 1468, 1738], [1740, 1810, 1832, 1832, 1995], [2898, 3064, 3085, 3085, 3487], [3489, 3489, 3546, 3582, 4025]], "test": "error"}
{"id": "XdcyzN", "name": "Fractured Poses", "author": "104", "description": "enjoy!", "tags": ["xor", "sizecoding"], "likes": 11, "viewed": 237, "published": "Public", "date": "1518004043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//327 chars. original before a lot of size optimizing but it at least works on\n// mac & safari again.\nvoid mainImage(out vec4 o, vec2 s)\n{\n    vec2 R = iResolution.xy,\n        r = ( s - .5 * R ) /R.y,\n        q = s / R-.5;\n    float t = iTime,\n        k = 1.;\n    t+=sin(t);\n    o-=o;\n    vec3 a;\n    for(float i = 1.;i>0.;i-=.1) {\n        a = (vec3(-.03,0.,.03)+i)*(k=-k);\n        for(int x=0;x<3;++x)\n            if(sin(8.*length(r-(cos(vec2(a[x]+t*.4,a[x]+t*.7))*i)))<0.)\n                o[x]=1.-o[x];\n            }\n    o -= .1*fract(sin(dot(r*t,r+t))*1e5);\n    o *= 1.-dot(q,q*1.4);\n}\n\n\n\n\n\n// parity=k\n// fragcood = s\n// uvn = q\n// uv = r\n// 268ch\n// compromises I made for size coding:\n// - behavior changes based on aspect ratio, but almost always good looking\n// - noise is not well distributed\n// - output color may go out of bounds. black areas output around -1.0\n// BUT DOESNT WORK ON SAFARI\n/*void mainImage(out vec4 o, vec2 s)\n{\n    vec2 R = iResolution.xy,\n        r = ( s - .5 * R ) /R.y,\n        q = s / R-.5;\n    float t = iTime,\n        k = 1.,i,x;\n    t+=sin(t);\n    o-=o-k+.1*fract(sin(dot(R+t,r))*1e5)+dot(q,q+q);\n    for(i = k;i>0.;i-=.1,k=-k)\n        for(x=0.;x<3.;)\n            o[int(x)]*=sign(sin(8.*length(r-cos(R/R.y*.4*t+(++x*.03+i)*k)*i)));\n}\n*/\n\n/*\n271\nvoid mainImage(out vec4 o, vec2 s)\n{\n    vec2 R = iResolution.xy,\n        r = ( s - .5 * R ) /R.y,\n        q = s / R-.5;\n    float t = iTime,\n        k = 1.,i,x;\n    t+=sin(t);\n    o-=o-k+.1*fract(sin(dot(r*t,r+t))*1e5)+dot(q,q);\n    for(i = k;i>0.;i-=.1,k=-k)\n        for(x=0.;x<3.;++x)\n            o[int(x)]*=sign(sin(8.*length(r-(cos(R/R.y*.4*t+(x*.03+i)*k)*i))));\n}\n*/\n\n\n// 180 ch minimalistic version with no post or aberration\n/*void mainImage(out vec4 o, vec2 s)\n{\n    vec2 R = iResolution.xy,\n        r = ( s - .5 * R ) /R.y;\n    \n    float t = iTime,\n        k = 1.,i;\n    \n    t+=sin(t);\n    o++;\n    \n    for(i = k;i>0.;i-=.1,k=-k)\n        o*=sign(sin(8.*length(r-cos(R/R.y*.4*t+i*k)*i)));\n}\n*/\n\n\n/*\n// 289\nvoid mainImage(out vec4 o, vec2 s)\n{\n    vec2 R = iResolution.xy,\n        r = ( s - .5 * R ) /R.y,\n        q = s / R-.5;\n    float t = iTime,\n        k = 1.,i,x;\n    t+=sin(t);\n    o-=o-k;\n    for(i = 1.;i>0.;i-=.1,k=-k)\n        for(x=0.;x<3.;++x)\n            o[int(x)]*=sign(sin(8.*length(r-(cos(vec2(t*.4,t*.7)+(x*.03+i)*k)*i))));\n    o -= .1*fract(sin(dot(r*t,r+t))*1e5);\n    o *= k-dot(q,q*1.4);\n}\n*/\n\n\n/*\n//312\nvoid mainImage(out vec4 o, vec2 s)\n{\n    vec2 R = iResolution.xy,\n        r = ( s - .5 * R ) /R.y,\n        q = s / R-.5;\n    float t = iTime,\n        k = 1.,i;\n    t+=sin(t);\n    o-=o-1.;\n    vec3 a;\n    for(i = 1.;i>0.;i-=.1, a = (vec3(-.03,0.,.03)+i)*(k=-k))\n        for(int x=0;x<3;++x)\n            o[x]*=sign(sin(8.*length(r-(cos(vec2(t*.4,t*.7)+a[x])*i))));\n    o -= .1*fract(sin(dot(r*t,r+t))*1e5);\n    o *= 1.-dot(q,q*1.4);\n}\n*/\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 104, 140, 140, 590]], "test": "valid"}
{"id": "XddcDM", "name": "4P_Test", "author": "FiveOutOfKevin", "description": "This looked cooler in my head. I'm so bad at shaders", "tags": ["trianglesiguess"], "likes": 0, "viewed": 419, "published": "Public API", "date": "1519187915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 color1 = vec3(113.0/255.0, 165.0/255.0, 16.0/255.0);\nvec3 color2 = vec3(64.0/255.0, 126.0/255.0, 10.0/255.0);\nvec3 color3 = vec3(29.0/255.0, 87.0/255.0, 5.0/255.0);\nvec3 color4 = vec3(173.0/255.0, 203.0/255.0, 24.0/255.0);\nvec3 color5 = vec3(7.0/255.0, 48.0/255.0, 2.0/255.0);\nint numColors = 4;\n\n//size of the side of each triangle (in screen space)\nfloat triEquLen = 0.2;\n\nfloat constTimeMod = .1;\n\nint getUVTriColorIndex(vec2 uv)\n{\n    float halfLen = triEquLen * .5;\n    //fake it 'till you make it\n    float triHeight = sqrt(.8*halfLen);\n    \n    //need to do this before collecting my fake \"tri-space\" transforms\n    uv.y += iTime*constTimeMod;\n    \n    //0 or 1\n    int rowFlip = int(floor(uv.y / triHeight))%2;\n    \n    uv.x += -iTime*.1+(halfLen*float(rowFlip));\n\t\n     //the remainder (in a weird-space, basically halftri, maintri, halftri)\n    vec2 triRemainder = vec2(mod(uv.x, triEquLen), mod(uv.y, triHeight));\n\n    //get which \"half\" of the tri we are in. < 1 we're in the left half, > 1 we're in the right half\n    float triHalfX = triRemainder.x / halfLen;\n    \n    //0=bottom-up, 1=top-down\n    float triSide = min(floor(triHalfX), 1.0);\n    \n    float triLocX = mod(triRemainder.x, halfLen);\n    \n    //mod of the half-x will always return between 0 and 1)\n    //% of distance on X to half + % of distance to full on Y\n\tfloat modSideFloat = (triLocX / halfLen) + \n        \t(abs( (triHeight*triSide) - triRemainder.y) / triHeight);\n    \n    //should be between 0 and 1 and 2??\n    float flooredSideFloat = floor(modSideFloat);\n    \n    int retSideVal = int( modSideFloat + triSide) % 2;\n    \n    //How did I get here?\n\treturn retSideVal + (rowFlip*2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Yes, this is dumb. No, I don't care\n    vec3[] triColors = vec3[](color1,color2,color3, color4, color5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(triColors[getUVTriColorIndex(uv)],1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddcDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[406, 406, 439, 439, 1676]], "test": "error"}
{"id": "XddcRH", "name": "Metaball Animation", "author": "salaark", "description": "2D metaballs forming a rotating paw shape with smooth transitions.", "tags": ["metaball", "ink", "paw"], "likes": 2, "viewed": 149, "published": "Public", "date": "1517954427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979\n\nfloat smin( float a, float b, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 blob(vec2 pos, float offset) {\n    vec2 center = (pos-(iResolution.xy/2.0))/2.0;\n    return vec3(pos.x+sin(-iTime*2.0+offset*M_PI)*center.x*2.0, pos.y+sin(-iTime*2.0+offset*M_PI)*center.y*2.0, 20.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates and origin point\n    vec2 uv = fragCoord;\n    vec2 origin = iResolution.xy/2.0;\n\n    // Position and time offset of blobs\n    vec3 center = vec3(origin, 40.0);\n    vec3 meta1 = blob(origin+vec2(50,0), 0.0);\n    vec3 meta2 = blob(origin+vec2(42.04,42.04), 0.25);\n    vec3 meta3 = blob(origin+vec2(0,50), 0.5);\n    vec3 meta4 = blob(origin+vec2(-42.04,42.04), 0.75);\n    vec3 meta5 = blob(origin+vec2(-50,0), 1.0);\n    vec3 meta6 = blob(origin+vec2(-42.04,-42.04), 1.25);\n    vec3 meta7 = blob(origin+vec2(0,-50), 1.5);\n    vec3 meta8 = blob(origin+vec2(42.04,-42.04), 1.75);\n\n    vec3 metaballs[9] = vec3[9]( center, meta1, meta2, meta3, meta4,\n                                 meta5, meta6, meta7, meta8);\n    \n    // Pixel color based on smin distance to metaballs\n    vec3 col = vec3(1);\n    float sticky = 40.0;\n    float total = smin(distance(center.xy, uv)-center.z, distance(meta1.xy, uv)-meta1.z, sticky);\n    for(int i = 2; i < metaballs.length(); i++) {\n        total = smin(total, distance(metaballs[i].xy, uv)-metaballs[i].z, sticky);\n    }\n    if(total <= 0.0){\n        col = vec3(0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddcRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 72, 72, 161], [163, 163, 198, 198, 369], [371, 371, 428, 470, 1614]], "test": "valid"}
{"id": "XddczB", "name": "what does kifs stand for?", "author": "wyatt", "description": "learned how to ray march today", "tags": ["raymarching", "kifs"], "likes": 14, "viewed": 312, "published": "Public", "date": "1519404606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rot (vec3 s) {\n    float \tsa = sin(s.x),\n        ca = cos(s.x),\n        sb = sin(s.y),\n        cb = cos(s.y),\n        sc = sin(s.z),\n        cc = cos(s.z);\n    return mat3 (\n        vec3(cb*cc, -cb*sc, sb),\n        vec3(sa*sb*cc+ca*sc, -sa*sb*sc+ca*cc, -sa*cb),\n        vec3(-ca*sb*cc+sa*sc, ca*sb*sc+sa*cc, ca*cb)\n    );\n}\nmat3 mm;\nfloat map (vec3 p) {\n    float a = 5.5;\n    for (int i = 0; i < 6; i++) {\n        p = mm*(abs(p)-a);\n        a *= 0.5;\n    }\n    return length(max(abs(p)-.1,0.))-0.05;\n}\nvec3 norm (vec3 p) {\n    vec2 e = vec2 (.001,0.);\n    return normalize(vec3(\n        map(p+e.xyy) - map(p-e.xyy),\n        map(p+e.yxy) - map(p-e.yxy),\n        map(p+e.yyx) - map(p-e.yyx)\n    ));\n}\nvec3 dive (vec3 p, vec3 d) {\n    for (int i = 0; i < 30; i++) {\n        p += d*map(p);\n    }\n    return p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 vv = fragCoord.xy/iResolution.xy*2.-1.;\n    vv.x *= iResolution.x/iResolution.y;\n    float ui = float(iFrame);\n    vec3 r = vec3(0.,0.,-30.);\n    vec3 d = normalize(vec3(vv,2));\n    mat3 m = rot(0.003*ui*vec3(1,1,1));\n    mm = rot(0.005*ui*(vec3(0,1,2)));\n    r = m*r;\n    d = m*d;\n    vec3 p = dive(r,d);\n    vec3 light = vec3(10);\n    d = normalize(p - light);\n    p += 0.01*d;\n    bool sh = length(dive(p,d))<100.;\n    float b = (sh?0.4:1.)*(dot(normalize(reflect(r-p,norm(p))),m*vec3(-1,0,0)));\n\n    fragColor = vec4(\n        length(p-r)>50.?vec3(vv,1):vec3((2.*b*b)/(1.+0.01*length(p-light))*\n                                              (norm(p)*0.5+0.5)\n                                             )\n        ,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddczB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 328], [338, 338, 358, 358, 507], [508, 508, 528, 528, 704], [705, 705, 733, 733, 813], [814, 814, 870, 870, 1603]], "test": "valid"}
{"id": "XddczM", "name": "Hopf Fibers", "author": "Ebanflo", "description": "For a much smoother version with interactivity and more in-depth explanation check out\n[url=http://ebencowley.com/resources/docs/projects/hopfFibers.html]my article about it[/url].", "tags": ["raymarching", "4d", "tori"], "likes": 6, "viewed": 137, "published": "Public", "date": "1519525010", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*MATH!\n\nhttps://en.wikipedia.org/wiki/Hopf_fibration\n\nThe Hopf Fibration is a continuous surjective (onto) function from the unit 3-sphere to\nthe unit 2-sphere such that the preimage of every point on the 2-sphere is a circle on\nthe 3-sphere.\n\nIf we represent a point in 4D space as a pair of complex numbers: (z1, z2) and a point\nin 3d space as a complex number with a real number: (z0, x). The map is given by:\n\n(z1, z2) -> (2(z1)(z2)*, (z1)(z1)* - (z2)(z2)*)\n\nwhere I've used * to represent complex conjugation.\n\nHere's how we see that the preimage of any point is exactly a circle:\nThink of the orthogonal transformation v -> qvq^-1 for some vec3 v and unit quaternion q\nIf we write down the matrix representation for this transformation in terms of the\ncomponents of q we see that the image of (1,0,0) under this transformation is the Hopf\nmap applied to the unit quaternion! This means that the pre-image of p on the 2-sphere\nis all the quaternions which rotate (1,0,0) to p. We can construct a quaternion which\nrotates (1,0,0) directly to p and then pre-compose that quaternion with any quaternion\nrepresenting a rotation about the x-axis. The group of rotations about the x-axis is a \ncircle, so we see that every \"fiber\" is a circle. A special case must be considered for\nthe rotation to (-1,0,0), but it still works.\n\nCall the quaternion which rotates (1,0,0) directly to p q_p and the quaternion which\nrotates about the x-axis by angle t q_t. Then (q_p)(q_t) gives us the pre-image of p\nparametrized with respect to t.\n\nMy method for rendering the Hopf fibration is as follows:\nFor a point on the 2-sphere, compute three points on the pre-image and then \nstereographically project these points to get a triangle in 3D. Compute the orthocenter\nof each triangle and the radius of the circle that it defines and use this information\nto raymarch a torus with the given center and radius. The color of the torus is based on\nthe position of the corresponding point on the 2-sphere.\n\nA major problem with the Shader Toy implementation is that pre-image computation,\nstereographic projection, and orthocenter calculation are all performed for every torus\nfor every step of the ray. I tried to store all of this information in a buffer, but to\nno avail. This is why I'm not using the torus normals at all, its already very slow on\nmy machine.\n\nI also have a WebGL version that uses uniforms wo speed everything up, but I want to get\nrid of this stupid artifacting before I publish it on my website.\n\n*/\n#define thickness 0.03\n#define longitudinalSamps 1\n#define lattitudinalSamps 16\n#define steps 40\n#define far 20.0\n#define threshold 0.01\nconst float piT = 8.0*atan(1.0);\nconst float pi  = 0.5*piT;\nconst float pi2 = 0.5*pi;\nconst float isqrt2 = inversesqrt(2.0);\n\nstruct Line{vec3 o; vec3 d;};\n\nvec3 intersectLines(Line l1, Line l2){\n    vec3 C = l1.o + l1.d;\n    vec3 D = l2.o + l2.d;\n    vec3 g = D - C;\n    vec3 fcg = cross(l2.d, g);\n    vec3 fce = cross(l2.d, l1.d);\n    return C + sign(dot(fcg, fce))*length(fcg)*l1.d*inversesqrt(dot(fce,fce));}\n\nfloat sdTorus(vec3 p, float r){return length(vec2(length(p.xz) - r, p.y)) - thickness;}\n\nvec3 nTorus(vec3 pos, float r){\n    return normalize(pos*(dot(pos,pos)- thickness*thickness - r*r*vec3(1.0,1.0,-1.0)));}\n\nfloat sdSphere(vec3 p, vec3 c){return distance(p, c) - thickness;}\n\nvec3 r(vec3 v, vec2 r){//rodolphito's rotation\n    vec4 t = sin(vec4(r, r + pi2));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);}\n\nvec3 unitVector(vec2 angles){\n    vec2 t1 = sin(angles.x + vec2(0, pi2));\n    vec2 t2 = sin(angles.y + vec2(0, pi2));\n    return vec3(t1.x*t2.y, t1.y*t2.y, t2.x);}\n\nmat3 rotateTo(vec3 v){\n    vec4 quat = vec4(0.0, v.z, -v.y, sqrt(1.0 + v.x));\n    return\n    mat3(\n      1.0 - (quat.y*quat.y + quat.z*quat.z), quat.w*quat.z, -quat.w*quat.y,\n      -quat.w*quat.z, 1.0 - quat.z*quat.z, quat.y*quat.z,\n      quat.w*quat.y, quat.y*quat.z, 1.0 - quat.y*quat.y);}\n\nvec3 stereoProj(vec4 v){return v.xyz/(1.0 - v.w);}\n\nvec4 getFiber(vec3 p, float t){\n    p.z++;\n    vec2 trig = sin(t + vec2(0, pi2));\n    return inversesqrt(2.0*p.z)*vec4(p.z*trig.y,\n                                     p.x*trig.x - p.y*trig.y,\n                                     p.x*trig.y + p.y*trig.x,\n                                     p.z*trig.x);}\n\nvec4 sdf(vec3 p){\n    float d = 9e9;\n    vec3 col;\n    for(int i = 0; i < longitudinalSamps; i++){\n        for(int j = 0; j < lattitudinalSamps; j++){\n            vec3 unit = unitVector(\n                vec2(float(i + 1)/float(longitudinalSamps)*piT,\n                     float(j + 1)/float(lattitudinalSamps + 1)*pi - pi2));\n            unit = r(unit, 0.1*iTime + (2.0*iMouse.xy - iResolution.xy)/iResolution.y);\n            vec3 v1 = stereoProj(getFiber(unit, 0.0));\n            vec3 v2 = stereoProj(getFiber(unit, pi2)) - v1;\n            vec3 v3 = stereoProj(getFiber(unit, pi)) - v1;\n            vec3 dir = normalize(cross(v2, v3));\n            vec3 center = intersectLines(Line(v1 + 0.5*v2, cross(dir, v2)),\n                                         Line(v1 + 0.5*v3, cross(dir, v3)));\n            float torus = sdTorus(rotateTo(dir)*p - center, distance(center, v1));\n            if(torus < d){\n                d = torus;\n                col = 0.5 + 0.5*unit;\n            }\n        }\n    }\n    return vec4(col, d);}\n\nvec3 raymarch(vec3 ro, vec3 rd){\n    float t = 0.0;\n    vec3 p = ro;\n    bool hit = false;\n    vec3 col;\n    for(int i = 0; i < steps; i++){\n        vec4 colAndDist = sdf(p);\n        if(colAndDist.w < threshold){\n            hit = true;\n            col = colAndDist.rgb;\n            break;\n        }\n        if(t > far) break;\n        float d = 0.5*colAndDist.w;\n        t += d;\n        p += d*rd;\n    }\n    if(hit) return col;\n    return vec3(0);}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    fragColor = vec4(0);\n    vec2 xy = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,-5);\n    vec3 rd = normalize(vec3(xy, 2));\n    fragColor.rgb = raymarch(ro, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddczM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2800, 2800, 2838, 2838, 3055], [3057, 3057, 3088, 3088, 3144], [3146, 3146, 3177, 3177, 3266], [3268, 3268, 3299, 3299, 3334], [3336, 3336, 3359, 3382, 3564], [3566, 3566, 3595, 3595, 3729], [3731, 3731, 3753, 3753, 4022], [4024, 4024, 4048, 4048, 4074], [4076, 4076, 4107, 4107, 4381], [4383, 4383, 4400, 4400, 5403], [5405, 5405, 5437, 5437, 5853], [5855, 5855, 5906, 5906, 6099]], "test": "error"}
{"id": "XddyRX", "name": "keep making fractals", "author": "wyatt", "description": "just keep playin'", "tags": ["fractal", "complex", "inversion"], "likes": 7, "viewed": 186, "published": "Public", "date": "1519676095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 mul (vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (5.+2.*sin(iTime))*(fragCoord/iResolution.xy*2.-1.);\n    uv.x *= iResolution.x/iResolution.y;\n    float t = 0.1*iTime;\n    mat2 m = mat2 (sin(t),cos(t),-cos(t),sin(t));\n    vec3 col = vec3(0);\n    for (int x = 0; x < 2; x++)\n        for (int y = 0; y < 2; y++) {\n        vec2 v = uv+vec2(x,y)/iResolution.xy;\n        for (int i = 0; i < 50; i++){\n            v = v/dot(v,v);\n            v = mul(v,v)-vec2(2./3.,.11*sin(iTime));\n        }\n        col += 1./4.*clamp(abs(v.xyy),0.,1.);\n    }\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 77], [79, 79, 136, 186, 721]], "test": "valid"}
{"id": "XddyzS", "name": "Periodic Delay 2", "author": "smkgames", "description": "The periodic delay \nyou can see here:\nhttps://www.desmos.com/calculator/l3m2wli93t", "tags": ["periodic", "delay"], "likes": 5, "viewed": 124, "published": "Public", "date": "1519373042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.desmos.com/calculator/l3m2wli93t\n\n// Created by Seyed Morteza Kamali\n\n//you can use this periodic delay in your animation\n//for example, your animation run after 2 second\n\n\n#define period 2.0 //you can change the period\n\n#define Delay 2.0 //you can change the delay\n\n#define PI 3.14\n\nfloat periodicShift(float x) {\nfloat shift = (period-1.)*PI+Delay;\n    \nreturn fract(x/(PI+shift))*(PI+shift);    \n//return x-(PI+shift)*floor(x/(PI+shift)); \n}\n\nfloat f(float x) {\nfloat p = periodicShift(x); \nreturn sin(clamp(p,0.,period*PI));\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{  \n    U /= iResolution.xy;\n    float z = f(6.28*(U.x+iTime) );\n    z = .5+.2*z- U.y ; \n    O = vec4( smoothstep(2.,0.,abs(z)/fwidth(z)) );\n    //O = vec4(f(iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddyzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 299, 329, 329, 459], [461, 461, 479, 479, 545], [547, 547, 585, 585, 752]], "test": "valid"}
{"id": "XdtcWM", "name": "Pruebas 2", "author": "jpechevarria", "description": "Meta Ball entre un pivot y el mouse", "tags": ["mousemetaball"], "likes": 0, "viewed": 95, "published": "Public", "date": "1519153147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\t///* V2\n    vec2 pivot;\n    \n    vec2 coord;\n    vec2 mouse;\n    \n    vec2 direction;\n    \n    coord = fragCoord;\n    pivot = iResolution.xy * 0.5;\n    mouse = iMouse.xy;\n    \n    pivot.x += sin(0.5*iTime) * iResolution.x * 0.5;\n    \n    float distPivot = length(coord-pivot);\n    float distMouse = length(coord-mouse);\n    \n    float col1 = 0.0, col2 = 0.0;\n\t//*/\n    \n    // VARIA EL COLOR\n    col1 += sqrt( 10.0 / ( distPivot  ) );\n    col2 += sqrt( 10.0 / ( distMouse  ) );\n    \n    // ESQUEMA DE COLOR 1\n    float color = col1 + col2;\n    fragColor = vec4(1.0) * color;\n\n\t// ESQUEMA DE COLOR 2\n    vec4 color1 = vec4(1.0,0.0,0.0,1.0);\n    vec4 color2 = vec4(1.0,1.0,0.0,1.0);\n    \n    fragColor = color1 * col1 + color2 * col2;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtcWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 974]], "test": "valid"}
{"id": "XdtcWN", "name": "speedy cube", "author": "laserdog", "description": "recreating a GIF, linked below. i simulate 3d rendering by using orthographic projection.  no raymarching.\n\ngif:\nhttps://camo.githubusercontent.com/027b2fc8715d8ab93f571c59b0444d6c89b5f824/68747470733a2f2f692e696d6775722e636f6d2f4c746d35786a442e676966", "tags": ["motionblur", "gif"], "likes": 13, "viewed": 241, "published": "Public", "date": "1518939134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define left -2.2\n#define right 2.2\n#define bottom -2.2\n#define top 2.2\n#define pi 3.14159265359\n#define blurIterations 24\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n        vec4(r, -dot(r, eye)),\n        vec4(u, -dot(u, eye)),\n        vec4(-f, -dot(f, eye)),\n        vec4(0., 0., 0., 1.));\n}\n\nconst mat4 proj = mat4(\n\tvec4(2. / (right - left), 0., 0., -(right + left) / (right - left)),\n    vec4(0., 2. / ( top - bottom), 0., -(top + bottom) / (top - bottom)),\n    vec4(0., 0., 0., 0.),\n    vec4(0., 0., 0., 1.)\n);\n\nmat4 rotateY(float rads)\n{\n    return mat4(\n        vec4(cos(rads), 0., sin(rads), 0.),\n        vec4(0., 1., 0., 0.),\n        vec4(-sin(rads), 0., cos(rads), 0.),\n        vec4(0.)\n    );\n}\n\nconst vec4[] horizontalPoints = vec4[](vec4(-1., 1., 0., 1.), vec4(0., 1., 1., 0.), \n                                vec4(-1., -1., 0., 1.), vec4(0., 1., -1., 0.),\n                                vec4(1., -1., 0., 1.), vec4(0., -1., 1., 0.), \n                                vec4(1., 1., 0., 1.), vec4(0., -1., -1., 0.));\n\nconst vec4[] verticalPoints = vec4[](vec4(-1., 0., 1., 0.), vec4(1., 0., 1., 0.),\n                             \t\t vec4(-1., 0., -1., 0.), vec4(1., 0., -1., 0.));\n\nfloat ease(float t)\n{\n    return t < .5 ? 4. * pow(t, 3.) : (t - 1.) * (2. * t - 2.) * (2. * t - 2.) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float duration = 4.5;\n    const float oscillationStart = 2.;\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0., 3., 5.);\n    vec3 target = vec3(0.);\n    \n    float minDist = 100.;\n    \n    int horizontalCount = horizontalPoints.length();\n    int verticalCount = verticalPoints.length();\n    \n    mat4 view = lookAt(eye, target, vec3(0., 1., 0.));\n    mat4 mvp = proj * view * rotateY(iTime * 1.25);\n    vec3 blurCol = vec3(0.);\n    \n    // motion blur technique inspired by https://www.shadertoy.com/view/XdXXz4 by @HLorenzi\n    for (int x = 0; x < blurIterations; x++)\n    {\n        float t = mod(iTime - float(x) * (1. / 15. / 32.), duration);\n        float num = ease(max(0., t - oscillationStart) / (duration - oscillationStart)) * 2. * pi;\n    \tfloat distOffset = sin(num * 7.);\n\n        for (int i = 0; i < horizontalCount; i++)\n    \t{\n        \tvec4 offsetVec = i % 2 == 0 ? vec4(0., 0., distOffset, 0.) : vec4(distOffset, 0., 0., 0.);\n        \tminDist = min(distance(uv, (mvp * (horizontalPoints[i] - offsetVec)).xy), minDist);\n        \tminDist = min(distance(uv, (mvp * (horizontalPoints[i] + offsetVec)).xy), minDist);\n    \t}\n    \n    \tfor (int i = 0; i < verticalCount; i++)\n    \t{\n        \tvec4 offsetVec = vec4(0., distOffset, 0., 0.);\n        \tminDist = min(distance(uv, (mvp * (verticalPoints[i] - offsetVec)).xy), minDist);\n        \tminDist = min(distance(uv, (mvp * (verticalPoints[i] + offsetVec)).xy), minDist);\n    \t}\n    \n    \tblurCol += mix(vec3(1.), vec3(.27, .19, .237), step(.02, minDist));\n    }\n\n    fragColor.rgb = blurCol / float(blurIterations);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtcWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 169, 169, 431], [656, 656, 682, 682, 844], [1332, 1332, 1353, 1353, 1440], [1442, 1442, 1499, 1499, 3129]], "test": "error"}
{"id": "XdtyWn", "name": "freder-trippy", "author": "freder", "description": "asdf", "tags": ["trippy"], "likes": 2, "viewed": 75, "published": "Public", "date": "1518464468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\nvec3 color(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n\treturn a + b * cos(2. * 3.1415 * (c * t + d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n  \n    vec3 displacement = vec3(.0);\n    \n    float c1 = snoise(\n      vec3(st.x * 5., st.y, 0.)\n    );\n    \n    vec3 a = vec3(.5);\n    vec3 b = vec3(.5);\n    vec3 c = vec3(1.);\n    vec3 d = vec3(cos(.3 * .5 * iTime), sin(.2 * iTime), .2);\n    displacement = color(c1, a, b, c, d);\n    \n    \n    fragColor = vec4(displacement, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtyWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 47, 47, 96], [98, 98, 119, 119, 168], [170, 170, 192, 192, 232], [234, 234, 262, 262, 314], [316, 316, 340, 340, 2481], [2484, 2484, 2537, 2537, 2587], [2590, 2590, 2647, 2647, 3066]], "test": "valid"}
{"id": "Xl2BDK", "name": "Thing_6", "author": "balkhan", "description": "thing", "tags": ["thing"], "likes": 17, "viewed": 291, "published": "Public", "date": "1517860883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n#define I_MAX\t\t150\n#define E\t\t\t0.001\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec2\trot_t;\nvec3\th;\nvec3\tbase;\nvec3\tlight_pos;\nfloat \tt;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    vec3\tcol = vec3(0., 0., 0.);\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-.0, .0, 149.);\n    t = iTime;\n    vec4\tinter = (march(pos, dir));\n\n    col.xyz += -3.+h*.353061251;\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n    \n    p = p*p*p*p;\n    p = p*p;\n    ret = (p.x+p.y);\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\n/*\n**\tLeon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\n#define\tPI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n**\tend mod polar\n*/\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    vec3\top = p;\n    vec3\tap = p;\n    p.xy = (fract(p.xy/60.)-.5)*40.;\n    p.z = (fract(p.z/60.)-.5)*120.;\n    \n    rotate(op.zx, iTime*.35);\n    rotate(op.yx, iTime*.75);\n    rotate(op.xz, iTime*.5);\n    ap = op;\n    ap.xz = modA(ap.xz, 10.);\n    ap.x -= 25.+15.*sin(iTime*.75);\n    ap.zy = modA(ap.zy, 10.);\n    ap.z -= 25.+5.*sin(iTime*1.+1.04);\n    ap.yx = modA(ap.yx, 10.);\n    ap.y -= 25.+5.*sin(-iTime*2.+2.08);\n    ap.x = fract(ap.x*.51)-.5;\n    //ap.xyz = (fract(ap.xyz/10.)-.5)*10.;\n    mind = min(mind,\n              length( vec2(mylength(ap.yz)-8.*sin(iTime*.5)-25., ap.x))-.10012501\n              );\n    mind = (.11+(mind));\n\n    h += .076125-vec3(.05, .10, .05)*1./(mind*mind +2.05102);\n    return(mind)*1.;\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\ts = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n    \trotate(p.zx, 1.+iTime*.5);\n        rotate(p.yz, 1.+iTime*.5);\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E )\n        {\n            s.y = 1.;\n            break;\n        }\n\n        s.x++;\n    }\n    s.w = dist.y;\n    return (s);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2BDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[283, 283, 326, 326, 599], [601, 601, 625, 625, 743], [859, 859, 892, 892, 1023], [1049, 1049, 1070, 1070, 1816], [1819, 1819, 1851, 1851, 2293], [2309, 2309, 2349, 2349, 2424], [2426, 2426, 2454, 2454, 2562], [2565, 2565, 2615, 2615, 2875], [2877, 2877, 2899, 2899, 3105]], "test": "error"}
{"id": "XljBDc", "name": "Shaking impacts", "author": "antonOTI", "description": "Impacting squares in the ground.\nSub optimal code but I'm too lazy to fix it ;)", "tags": ["2d", "curve", "shake"], "likes": 12, "viewed": 703, "published": "Public API", "date": "1517440773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tuned to DEATH ON WHEELS Part I \n// CHRISTINE\n// https://soundcloud.com/sheischristine/death-on-wheels-part-i-1\n\n#define PI 3.14159\n#define TAU (PI * 2.)\n#define HPI (PI * .5)\n\n\nfloat HitCurve(float t,float hitFlag, float raiseFlag)\n{\n    t = mod(t,1.);\n    float hit = step(t,hitFlag);\n    float raise = step(raiseFlag,t);\n    float stay = 1. - raise - hit;\n    return 1. - (\n        pow(t / hitFlag,2.) * hit \n        + stay\n        + (cos((t - raiseFlag) * 1. / (1. - raiseFlag) * PI) * .5 + .5) * (raise)\n        );\n    //);\n}\n\nfloat HitShakeCurve(float t, float hitFlag)\n{\n    t = mod(t, 1.);\n    return  step(hitFlag, t) * max(pow(hitFlag - t + 1., 18.), 0.);\n}\n\n\nfloat squareDf(vec2 uv)\n{\n    uv = abs(uv);\n    return max(uv.x,uv.y);\n}\n\nfloat dfPolygon(float side,vec2 p)\n{   \n    float a=atan(p.x,p.y);\n    float b=TAU/side;\n    return cos(floor(.5+a/b)*b-a)*length(p.xy) ;\n}\n\nfloat shapeDf(vec2 uv, vec2 pos)\n{\n    uv = uv - pos;\n    float sq = squareDf(uv);\n    uv *= 3.3;\n    uv.x += .15;\n    uv.y += .43;\n    float d1 = dfPolygon(3.,uv);\n    uv.x -= .3;\n    float d2 = dfPolygon(3.,uv);\n    return min(\n    \tsq,\n        min(d1,d2)\n    );\n}\n\nfloat bounce(float p, float b)\n{\n    return .5 - cos(p * PI) * .5 + sin(p * PI) * p * b ;\n}\n\nfloat multiplexer(float channel, float nbChannel, float t, float b)\n{\n    float ft = floor(t);\n    float mt = t- ft;\n    mt *= nbChannel;\n    channel = clamp(mt - channel,0.,1.);\n    channel = bounce(channel, b) ;\n    return ft + channel;\n}\n\nvec2 triChecker(vec2 p, float s)\n{\n    p.x += p.y * .5 ;\n    vec2 m = mod(p,s); \n    vec2 base = p - m;\n    p = m / s; \n    \n    base.x *= 2. + step(p.x,p.y);\n    \n    return base;\n}\nfloat noise(vec2 p)\n{\n    return fract(dot(sin(p.x * 123.12)*142.,cos(p.y *34.95)*165.47));\n}\n\nfloat NB_SQUARE = 6.;\n\nfloat bpm = 125.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float width = iResolution.x / iResolution.y;\n    uv.x *= width;\n    \n    float time = iChannelTime[0] * bpm / 60. ;\n    float hit = .05;\n    float raise = .75;\n    \n    \n    float shakeForce = 0.;\n    \n    \n    \n    for(float i = 0.; i < NB_SQUARE; ++i)\n    {\n        float decal = (time + i) / NB_SQUARE;\n        shakeForce += HitShakeCurve(decal, hit);\n    }\n    \n    float shakeAmplitude = .025;\n    vec2 shake = vec2(sin(time * 3256.123), sin(time * 4256.365)) * shakeAmplitude * shakeForce;\n    \n\n    uv += shake;\n    \n    float f = 10000.;\n    \n    for(float i = 0.; i < NB_SQUARE; ++i)\n    {\n        float decal = i / NB_SQUARE;\n        float square =(time - i)/ NB_SQUARE;\n        square = HitCurve(square, hit, raise);\n        f = min(shapeDf(uv, vec2(.15 + .3 * i, .45 * square + .1)) , f);\n    }\n    \n    \n    f = step(f,.1);\n    \n    float radius = .05; \n    float cx = multiplexer(0.,2.,time - .025 ,.35) * (width / NB_SQUARE) + .12;\n    cx = mod(cx, width);\n    vec2 circlePos = vec2(cx,radius);\n    \n    float circle = step(distance(circlePos,uv) , .05);\n    \n    vec2 tri = triChecker(uv + iTime * .01, .14);\n    f += noise(tri) * .3 * (1. + pow(shakeForce,2.));\n    \n    fragColor = vec4(f,f + circle, f, 1.);\n}", "image_inputs": [{"id": "XsSXWR", "previewfilepath": "https://soundcloud.com/sheischristine/death-on-wheels-part-i-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/sheischristine/death-on-wheels-part-i-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljBDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 237, 237, 533], [535, 535, 580, 580, 670], [673, 673, 698, 698, 745], [747, 747, 783, 783, 886], [888, 888, 922, 922, 1154], [1156, 1156, 1188, 1188, 1247], [1249, 1249, 1318, 1318, 1489], [1491, 1491, 1525, 1525, 1673], [1674, 1674, 1695, 1695, 1767], [1811, 1811, 1868, 1918, 3191]], "test": "error"}
{"id": "XlXBRn", "name": "raymarching1-trl", "author": "ruolan", "description": "raymarching followed by tutorial", "tags": ["raymarching"], "likes": 1, "viewed": 71, "published": "Public", "date": "1519609118", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p)\n{\n    vec3 q = fract(p)*2.-1.;\n    return length(q)-0.25;\n}\n\nfloat trace(vec3 origin, vec3 ray)\n{\n    float t=0.;\n    for(int i=0; i<32; i++){\n        vec3 p = origin + t*ray;\n        float d=map(p);\n        t += d*0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2. -1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv,1.));\n    ray.xz *= mat2(cos(iTime), -sin(iTime), sin(iTime),cos(iTime));\n    \n    //vec3 ori = vec3(0.,0.,-3.);\n    vec3 ori = vec3(0.,0.,iTime);\n    float t = trace(ori, ray);\n    \n    float fog = 1.0/(1.0+t*t*0.1);\n    \n    vec3 color = vec3(fog);\n    \n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 77], [79, 79, 115, 115, 259], [261, 261, 318, 318, 752]], "test": "valid"}
{"id": "Xs3cz7", "name": "Cut Cube-CIS 566", "author": "jamie2719", "description": "CIS 566 project 1", "tags": ["raymarching"], "likes": 1, "viewed": 65, "published": "Public", "date": "1518142545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.15926\n\n//#define OUTLINE //uncomment this line to render only the outlines of the planes \n\n\nmat4 rotate(vec3 rot) {\n\tmat4 rx = mat4(vec4(1, 0, 0, 0),\n\t\t\t\t\tvec4(0, cos(rot.x * PI/180.0), sin(rot.x * PI/180.0), 0),\n\t\t\t\t\tvec4(0, -sin(rot.x * PI/180.0), cos(rot.x * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\tmat4 ry = mat4(vec4(cos(rot.y * PI/180.0), 0, -sin(rot.y * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 1, 0, 0),\n\t\t\t\t\tvec4(sin(rot.y * PI/180.0), 0, cos(rot.y * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\tmat4 rz = mat4(vec4(cos(rot.z * PI/180.0), sin(rot.z * PI/180.0), 0, 0),\n\t\t\t\t\tvec4(-sin(rot.z * PI/180.0), cos(rot.z * PI/180.0), 0, 0),\n\t\t\t\t\tvec4(0, 0, 1, 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\t\t\t\t\t\n\treturn rz * ry * rx;\n\t\n}\n\nmat4 translate(vec3 trans) {\n\treturn mat4(vec4(1, 0, 0, 0),\n\t\t\t\tvec4(0, 1, 0, 0),\n\t\t\t\tvec4(0, 0, 1, 0),\n\t\t\t\tvec4(trans.x, trans.y, trans.z, 1));\n}\n\n\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\nfloat sdBox(vec3 p, vec3 b, vec3 rot, vec3 trans, float rotSpeed)\n{\n    p = vec3(rotate(rot * rotSpeed) * vec4(p, 1));\n    p = vec3(translate(trans) * vec4(p, 1));\n    \n    \n  \tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat sceneSDF(vec3 p) {\n    float rotSpeed =  smoothstep(.3, 1.0, clamp(fract(iTime * .6) * 2.0 - 1.0, 0.0, 1.0)) + floor(iTime * .6);\n    float rotSpeed1 = smoothstep(.4, 1.0, clamp(fract(iTime * .6) * 2.0 - 1.0, 0.0, 1.0)) + floor(iTime * .6);\n    float rotSpeed2 = smoothstep(.5, 1.0, clamp(fract(iTime * .6) * 2.0 - 1.0, 0.0, 1.0)) + floor(iTime * .6);\n    float rotSpeed3 = smoothstep(.6, 1.0, clamp(fract(iTime * .6) * 2.0 - 1.0, 0.0, 1.0)) + floor(iTime * .6);\n    float rotSpeed4 = smoothstep(.7, 1.0, clamp(fract(iTime * .6) * 2.0 - 1.0, 0.0, 1.0)) + floor(iTime * .6);\n    float rotSpeed5 = smoothstep(.8, 1.0, clamp(fract(iTime * .6) * 2.0 - 1.0, 0.0, 1.0)) + floor(iTime * .6);\n    float rotSpeed6 = smoothstep(.9, 1.0, clamp(fract(iTime * .6) * 2.0 - 1.0, 0.0, 1.0)) + floor(iTime * .6);\n    \n    float bounceSpeed = (cos((iTime -.15) * 4.0) + 1.0) / 2.0 + .8;\n\n    \n    float centerCube = sdBox(p, vec3(1, 1, 1), vec3(0, -90, 0), vec3(0, 0, 0), rotSpeed);\n    //float centerCubei = sdBox(p, vec3(.9, 1.2, 1.2), vec3(0, -90, 0), vec3(0, 0, 0), rotSpeed);\n    //centerCube = opS(centerCubei, centerCube);\n    \n    \n    \n    //front planes\n    float frontWall =  sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, -2.0 * bounceSpeed), rotSpeed1);\n    float frontWall2 = sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, -2.2 * bounceSpeed), rotSpeed2);    \n    float frontWall3 = sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, -2.4 * bounceSpeed), rotSpeed3);    \n    float frontWall4 = sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, -2.5 * bounceSpeed), rotSpeed4);    \n    float frontWall5 = sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, -2.6 * bounceSpeed), rotSpeed5);    \n    float frontWall6 = sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, -2.7 * bounceSpeed), rotSpeed6);\n    \n    #ifdef OUTLINE\n    float frontWalli = sdBox(p, vec3(.95, .95, .05), vec3(0, -90, 0), vec3(0, 0, -2.0 * bounceSpeed), rotSpeed1);\n    float frontWall2i = sdBox(p, vec3(.95, .95, .05), vec3(0, -90, 0), vec3(0, 0, -2.2 * bounceSpeed), rotSpeed2);\n    float frontWall3i = sdBox(p, vec3(.95, .95, .05), vec3(0, -90, 0), vec3(0, 0, -2.4 * bounceSpeed), rotSpeed3);\n    float frontWall4i = sdBox(p, vec3(.95, .95, .05), vec3(0, -90, 0), vec3(0, 0, -2.5 * bounceSpeed), rotSpeed4);\n    float frontWall5i = sdBox(p, vec3(.95, .95, .015), vec3(0, -90, 0), vec3(0, 0, -2.6 * bounceSpeed), rotSpeed5);\n    float frontWall6i = sdBox(p, vec3(.95, .95, .05), vec3(0, -90, 0), vec3(0, 0, -2.7 * bounceSpeed), rotSpeed6);\n    \n    frontWall = opS(frontWalli, frontWall);\n    frontWall2 = opS(frontWall2i, frontWall2);\n    frontWall3 = opS(frontWall3i, frontWall3);\n    frontWall4 = opS(frontWall4i, frontWall4);\n    frontWall5 = opS(frontWall5i, frontWall5);\n    frontWall6 = opS(frontWall6i, frontWall6);\n    #endif\n    \n    frontWall = unionSDF(frontWall, frontWall2);\n    frontWall = unionSDF(frontWall, frontWall3);\n    frontWall = unionSDF(frontWall, frontWall4);\n    frontWall = unionSDF(frontWall, frontWall5);\n    frontWall = unionSDF(frontWall, frontWall6);\n    \n   \n    \n    //back planes\n    float backWall =  sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, 2.0 * bounceSpeed), rotSpeed1);\n    float backWall2 = sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, 2.2 * bounceSpeed), rotSpeed2);\n    float backWall3 = sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, 2.4 * bounceSpeed), rotSpeed3);\n    float backWall4 = sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, 2.5 * bounceSpeed), rotSpeed4);\n    float backWall5 = sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, 2.6 * bounceSpeed), rotSpeed5);\n    float backWall6 = sdBox(p, vec3(1, 1, .01), vec3(0, -90, 0), vec3(0, 0, 2.7 * bounceSpeed), rotSpeed6);\n    \n    #ifdef OUTLINE\n    float backWalli =  sdBox(p, vec3(.95, .95, .05), vec3(0, -90, 0), vec3(0, 0, 2.0 * bounceSpeed), rotSpeed1);\n    float backWall2i = sdBox(p, vec3(.95, .95, .05), vec3(0, -90, 0), vec3(0, 0, 2.2 * bounceSpeed), rotSpeed2);\n    float backWall3i = sdBox(p, vec3(.95, .95, .05), vec3(0, -90, 0), vec3(0, 0, 2.4 * bounceSpeed), rotSpeed3);\n    float backWall4i = sdBox(p, vec3(.95, .95, .05), vec3(0, -90, 0), vec3(0, 0, 2.5 * bounceSpeed), rotSpeed4);\n    float backWall5i = sdBox(p, vec3(.95, .95, .05), vec3(0, -90, 0), vec3(0, 0, 2.6 * bounceSpeed), rotSpeed5);\n    float backWall6i = sdBox(p, vec3(.95, .95, .05), vec3(0, -90, 0), vec3(0, 0, 2.7 * bounceSpeed), rotSpeed6);\n    \n    backWall = opS(backWalli, backWall);\n    backWall2 = opS(backWall2i, backWall2);\n    backWall3 = opS(backWall3i, backWall3);\n    backWall4 = opS(backWall4i, backWall4);\n    backWall5 = opS(backWall5i, backWall5);\n    backWall6 = opS(backWall6i, backWall6);\n    #endif\n    \n    backWall = unionSDF(backWall, backWall2);\n    backWall = unionSDF(backWall, backWall3);\n    backWall = unionSDF(backWall, backWall4);\n    backWall = unionSDF(backWall, backWall5);\n    backWall = unionSDF(backWall, backWall6);\n    \n    \n    //left planes\n    float leftWall =  sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(2.0 * bounceSpeed, 0.0, 0.0), rotSpeed1);\n    float leftWall2 = sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(2.2 * bounceSpeed, 0.0, 0.0), rotSpeed2);\n    float leftWall3 = sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(2.4 * bounceSpeed, 0.0, 0.0), rotSpeed3);\n    float leftWall4 = sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(2.5 * bounceSpeed, 0.0, 0.0), rotSpeed4);\n    float leftWall5 = sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(2.6 * bounceSpeed, 0.0, 0.0), rotSpeed5);\n    float leftWall6 = sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(2.7 * bounceSpeed, 0.0, 0.0), rotSpeed6);\n    \n    #ifdef OUTLINE\n    float leftWalli =  sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(2.0 * bounceSpeed, 0.0, 0.0), rotSpeed1);\n    float leftWall2i = sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(2.2 * bounceSpeed, 0.0, 0.0), rotSpeed2);\n    float leftWall3i = sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(2.4 * bounceSpeed, 0.0, 0.0), rotSpeed3);\n    float leftWall4i = sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(2.5 * bounceSpeed, 0.0, 0.0), rotSpeed4);\n    float leftWall5i = sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(2.6 * bounceSpeed, 0.0, 0.0), rotSpeed5);\n    float leftWall6i = sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(2.7 * bounceSpeed, 0.0, 0.0), rotSpeed6);\n    \n    leftWall = opS(leftWalli, leftWall);\n    leftWall2 =opS(leftWall2i, leftWall2);\n    leftWall3 =opS(leftWall3i, leftWall3);\n    leftWall4 =opS(leftWall4i, leftWall4);\n    leftWall5 =opS(leftWall5i, leftWall5);\n    leftWall6 =opS(leftWall6i, leftWall6);\n    #endif\n    \n    leftWall = unionSDF(leftWall, leftWall2);\n    leftWall = unionSDF(leftWall, leftWall3);\n    leftWall = unionSDF(leftWall, leftWall4);\n    leftWall = unionSDF(leftWall, leftWall5);\n    leftWall = unionSDF(leftWall, leftWall6);\n    \n     \n    \n    \n    //right planes\n    float rightWall =  sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(-2.0 * bounceSpeed, 0.0, 0.0), rotSpeed1);\n    float rightWall2 = sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(-2.2 * bounceSpeed, 0.0, 0.0), rotSpeed2);\n    float rightWall3 = sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(-2.4 * bounceSpeed, 0.0, 0.0), rotSpeed3);\n    float rightWall4 = sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(-2.5 * bounceSpeed, 0.0, 0.0), rotSpeed4);\n    float rightWall5 = sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(-2.6 * bounceSpeed, 0.0, 0.0), rotSpeed5);\n    float rightWall6 = sdBox(p, vec3(.01, 1, 1), vec3(0, -90, 0), vec3(-2.7 * bounceSpeed, 0.0, 0.0), rotSpeed6);\n    \n    #ifdef OUTLINE\n    float rightWalli =  sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(-2.0 * bounceSpeed, 0.0, 0.0), rotSpeed1);\n    float rightWall2i = sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(-2.2 * bounceSpeed, 0.0, 0.0), rotSpeed2);\n    float rightWall3i = sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(-2.4 * bounceSpeed, 0.0, 0.0), rotSpeed3);\n    float rightWall4i = sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(-2.5 * bounceSpeed, 0.0, 0.0), rotSpeed4);\n    float rightWall5i = sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(-2.6 * bounceSpeed, 0.0, 0.0), rotSpeed5);\n    float rightWall6i = sdBox(p, vec3(.05, .95, .95), vec3(0, -90, 0), vec3(-2.7 * bounceSpeed, 0.0, 0.0), rotSpeed6);\n    \n    rightWall = opS(rightWalli, rightWall);\n    rightWall2 = opS(rightWall2i, rightWall2);\n    rightWall3 = opS(rightWall3i, rightWall3);\n    rightWall4 = opS(rightWall4i, rightWall4);\n    rightWall5 = opS(rightWall5i, rightWall5);\n    rightWall6 = opS(rightWall6i, rightWall6);\n    #endif\n    \n    rightWall = unionSDF(rightWall, rightWall2);\n    rightWall = unionSDF(rightWall, rightWall3);\n    rightWall = unionSDF(rightWall, rightWall4);\n    rightWall = unionSDF(rightWall, rightWall5);\n    rightWall = unionSDF(rightWall, rightWall6);\n    \n    \n    //top planes\n    float topWall =  sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, -2.0 * bounceSpeed, 0.0), rotSpeed1);\n    float topWall2 = sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, -2.2 * bounceSpeed, 0.0), rotSpeed2);\n    float topWall3 = sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, -2.4 * bounceSpeed, 0.0), rotSpeed3);\n    float topWall4 = sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, -2.5 * bounceSpeed, 0.0), rotSpeed4);\n    float topWall5 = sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, -2.6 * bounceSpeed, 0.0), rotSpeed5);\n    float topWall6 = sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, -2.7 * bounceSpeed, 0.0), rotSpeed6);\n    \n    #ifdef OUTLINE\n    float topWalli =  sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, -2.0 * bounceSpeed, 0.0), rotSpeed1);\n    float topWall2i = sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, -2.2 * bounceSpeed, 0.0), rotSpeed2);\n    float topWall3i = sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, -2.4 * bounceSpeed, 0.0), rotSpeed3);\n    float topWall4i = sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, -2.5 * bounceSpeed, 0.0), rotSpeed4);\n    float topWall5i = sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, -2.6 * bounceSpeed, 0.0), rotSpeed5);\n    float topWall6i = sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, -2.7 * bounceSpeed, 0.0), rotSpeed6);\n    \n    topWall =  opS(topWalli, topWall);\n    topWall2 = opS(topWall2i, topWall2);\n    topWall3 = opS(topWall3i, topWall3);\n    topWall4 = opS(topWall4i, topWall4);\n    topWall5 = opS(topWall5i, topWall5);\n    topWall6 = opS(topWall6i, topWall6);\n    #endif\n    \n    topWall = unionSDF(topWall, topWall2);\n    topWall = unionSDF(topWall, topWall3);\n    topWall = unionSDF(topWall, topWall4);\n    topWall = unionSDF(topWall, topWall5);\n    topWall = unionSDF(topWall, topWall6);\n    \n    \n    //bottom planes\n    float bottomWall =  sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, 2.0 * bounceSpeed, 0.0), rotSpeed1);\n    float bottomWall2 = sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, 2.2 * bounceSpeed, 0.0), rotSpeed2);\n    float bottomWall3 = sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, 2.4 * bounceSpeed, 0.0), rotSpeed3);\n    float bottomWall4 = sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, 2.5 * bounceSpeed, 0.0), rotSpeed4);\n    float bottomWall5 = sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, 2.6 * bounceSpeed, 0.0), rotSpeed5);\n    float bottomWall6 = sdBox(p, vec3(1, .01, 1), vec3(0, -90, 0), vec3(0, 2.7 * bounceSpeed, 0.0), rotSpeed6);\n    \n    #ifdef OUTLINE\n    float bottomWalli =  sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, 2.0 * bounceSpeed, 0.0), rotSpeed1);\n    float bottomWall2i = sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, 2.2 * bounceSpeed, 0.0), rotSpeed2);\n    float bottomWall3i = sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, 2.4 * bounceSpeed, 0.0), rotSpeed3);\n    float bottomWall4i = sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, 2.5 * bounceSpeed, 0.0), rotSpeed4);\n    float bottomWall5i = sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, 2.6 * bounceSpeed, 0.0), rotSpeed5);\n    float bottomWall6i = sdBox(p, vec3(.95, .05, .95), vec3(0, -90, 0), vec3(0, 2.7 * bounceSpeed, 0.0), rotSpeed6);\n    \n    \n    bottomWall = opS(bottomWalli, bottomWall);\n    bottomWall2 =opS(bottomWall2i, bottomWall2);\n    bottomWall3 =opS(bottomWall3i, bottomWall3);\n    bottomWall4 =opS(bottomWall4i, bottomWall4);\n    bottomWall5 =opS(bottomWall5i, bottomWall5);\n    bottomWall6 =opS(bottomWall6i, bottomWall6);\n    #endif\n    \n    bottomWall = unionSDF(bottomWall, bottomWall2);\n    bottomWall = unionSDF(bottomWall, bottomWall3);\n    bottomWall = unionSDF(bottomWall, bottomWall4);\n    bottomWall = unionSDF(bottomWall, bottomWall5);\n    bottomWall = unionSDF(bottomWall, bottomWall6);\n  \n    \n    //union all walls together\n    frontWall = unionSDF(frontWall, backWall);\n    frontWall = unionSDF(frontWall, leftWall);\n   \tfrontWall = unionSDF(frontWall, rightWall);\n   \tfrontWall = unionSDF(frontWall, topWall);\n    frontWall = unionSDF(frontWall, bottomWall);\n    \n    return unionSDF(centerCube, frontWall);\n}\n\nvec3 toWorldSpace(vec3 p, vec3 eye, vec3 ref) {\n\tfloat fov = 75.0;\n\n\tfloat sx = (p.x);\n    float sy = (p.y);\n    float A = iResolution.x / iResolution.y;\n    float alpha = fov / 2.0 * (3.159 / 180.0);\n    vec3 forward = normalize(ref - eye);\n   \tvec3 right = normalize(cross(vec3(0, 1, 0), -forward));\n   \tvec3 localUp = normalize(cross(-forward, right));\n    \n    \n\n    //convert screen point to world point\n    float len = .1;//length(forward);\n    vec3 V = (localUp * len * tan(alpha));\n    vec3 H = right * A * len *tan(alpha);\n\n    return vec3(eye + len * forward + sx * H + sy * V); //world point \n}\n\nbool raymarch(vec3 p, vec3 eye, vec3 ref) {\n    //get ray from world point\n    vec3 dir = normalize(p - eye);\n    vec3 origin = eye;\n    \n    \n    \n    float scene;\n    vec3 minInter; \n    vec3 intersection;\n    bool intersected = false;\n    float t = 0.01;\n\tfor (int i = 0; i < 64; i++) {\n\t\tintersection = origin + dir * t;\n\t\tintersection = vec3(rotate(vec3(30, 45, 0)) * vec4(intersection, 1));\n        \n        scene = sceneSDF(intersection);\n\t\t\n\t\tif(scene <= .001) {\n\t\t\tintersected = true;\n\t\t\tminInter = intersection;\n\t\t\tbreak;\n\t\t}\n\t\tt += scene;\n\t}\n   \treturn intersected;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scrPt = uv * 2.0 - 1.0; // Transform to NDC\n    scrPt *= iResolution.x / iResolution.y;\n    \n    vec3 eye =  vec3(0, 1, -6);\n    vec3 ref = vec3(0.0, 0.0, 0.0);\n    \n    \n    vec3 p = toWorldSpace(vec3(scrPt, 1), eye, ref);\n    \n    \n    float _time = iTime;\n    \n    vec3 col;\n    if(raymarch(p, eye, ref)) {\n        col = vec3(1, 1, 1);\n    }\n    else {\n        col = vec3(0, 0, 0);\n    }\n    \n   \tfragColor = vec4(col, 1);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3cz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 128, 128, 715], [717, 717, 745, 745, 863], [867, 867, 909, 909, 941], [943, 943, 976, 976, 1002], [1005, 1005, 1072, 1072, 1267], [1271, 1271, 1295, 1295, 14405], [14407, 14407, 14454, 14454, 15012], [15014, 15014, 15057, 15088, 15592], [15596, 15596, 15653, 15703, 16185]], "test": "valid"}
{"id": "Xs3yRM", "name": "Glowing petals", "author": "lsdlive", "description": "Variant of https://www.shadertoy.com/view/Mstczr", "tags": ["raymarch", "glow"], "likes": 26, "viewed": 551, "published": "Public", "date": "1518116503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://www.shadertoy.com/view/Mstczr\n\nvec3 glow = vec3(0.);\nfloat glow_intensity = .01;\nvec3 glow_color = vec3(.5, .8, .5);\n\nfloat smin(float a, float b) {\n\tfloat k = 3.;\n\tfloat res = exp(-k*a) + exp(-k*b);\n\treturn -log(res) / k;\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 amod(vec2 p, float m) {\n\tfloat a = mod(atan(p.x, p.y) -m*.5, m) - m * .5;\n\treturn vec2(cos(a), sin(a)) * length(p);\n}\n\n#define sph(p, r) (length(p) - r)\n#define cyl sph\n#define cube(p, b) length(max(abs(p) - vec3(b), 0.))\n\nfloat de(vec3 p) {\n\t\n    p.xy *= r2d(iTime*.1 + p.z);\n    p.xz *= r2d(3.14/2.);\n    \n    \n    \n    p.zy = amod(p.zy, .785);\n    \n    p.y = abs(p.y) - .4;\n\tp.z = abs(p.z) - .4;\n\tif (p.z > p.y) p.yz = p.zy;\n    \n    \n    vec3 q = p;\n\n\tp.xy *= r2d(-3.14 / 3.);\n\tp.xz *= r2d(iTime);\n\tp.x += cos(p.y*8.)*.2;\n\tp.z += sin(p.y*4.)*.2;\n\tfloat d = cyl(p.xz, .1);\n\n\tp = q;\n\tp.xy *= r2d(3.14 / 3.);\n\tp.xz *= r2d(iTime);\n\tp.x += cos(p.y*8.)*.2;\n\tp.z += sin(p.y*4.)*.2;\n\n\td = smin(d, cyl(p.xz, .1));\n\n\tp = q;\n\tp.xz *= r2d(iTime);\n\tp.x += cos(p.y*8.)*.2;\n\tp.z += sin(p.y*4.)*.2;\n\n\td = smin(d, cyl(p.xz, .1));\n\n\tp = q;\n\tp.xy *= r2d(3.14 / 2.);\n\tp.xz *= r2d(iTime);\n\tp.x += cos(p.y*8.)*.2;\n\tp.z += sin(p.y*4.)*.2;\n\n\td = smin(d, cyl(p.xz, .1));\n\n\t// trick extracted from balkhan https://www.shadertoy.com/view/4t2yW1\n\tglow += glow_color * .025 / (.01 + d*d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\n\tvec3 ro = vec3(0., 0, 6. + cos(iTime)), p;\n\tvec3 rd = normalize(vec3(uv, -1));\n\tp = ro;\n\n\tfloat t = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tp = ro + rd * t;\n\t\tfloat d = de(p);\n\t\tif (d < .001 || t > 8.) break;\n\t\tt += d * .2; // avoid clipping, enhance the glow\n\t}\n\n\tvec3 c = vec3(.9, .05 + cos(iTime)*.1, .2);\n\tc.r *= p.y + p.z;\n\tc += glow * glow_intensity;\n\n\tfragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3yRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 170, 170, 246], [248, 248, 267, 267, 327], [329, 329, 357, 357, 451], [557, 557, 575, 575, 1410], [1412, 1412, 1467, 1467, 1923]], "test": "valid"}
{"id": "Xs3yW7", "name": "Some fractal", "author": "wyatt", "description": "playing around with convergent/divergent series \n\n", "tags": ["fractal", "imaginary"], "likes": 8, "viewed": 164, "published": "Public", "date": "1519088197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float a = 0.1*iTime;\n    uv.x *= iResolution.x/iResolution.y;\n\tuv = 1.3*(uv*2.-1.)*mat2(sin(a),cos(a),-cos(a),sin(a));\n    \n    // Time varying pixel color\n    vec2 v = uv;\n    float t = 3.1*exp(-10.*sin(0.52424*iTime)*sin(0.52424*iTime));\n    float g = 4.*sin(iTime)*sin(iTime);\n    float j = 0.;\n    vec2 c = vec2(-0.8,0.3);\n    for (int i = 0; i < 30; i++) {\n        \n    \tfloat x = (3.+t)*(v.x*v.x-v.y*v.y) - 3.*(v.x*uv.x - v.y*uv.y);\n        v.y = (3.+t+x*g)*(2.*v.x*v.y) - 3.*(v.x*uv.y+uv.x*v.y);\n        v.x = x;\n        j += .4*exp(-.01*dot(v,v));\n        if (dot(v,v) > 100.)break;\n    }\n    vec3 col = sin(vec3(1,1.5,2)*j)*0.5+0.5;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3yW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 850]], "test": "valid"}
{"id": "Xs3yWN", "name": "deep inside", "author": "Del", "description": "deep", "tags": ["deep"], "likes": 8, "viewed": 592, "published": "Public API", "date": "1518799032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Bloody Tunnel - Del - 16/02/2018 (modified water shader from somewhere on shadertoy)\n\n#define EULER 2.7182818284590452353602874\n#define IEULER 0.367879\n// its from here https://github.com/achlubek/venginenative/blob/master/shaders/include/WaterHeight.glsl \nfloat wave(vec2 uv, vec2 emitter, float speed, float phase, float timeshift)\n{\n\tfloat dst = distance(uv, emitter);\n    float time = iTime*0.1;\n\treturn pow(EULER, sin(dst * phase - (time + timeshift) * speed));\n}\nvec2 wavedrag(vec2 uv, vec2 emitter)\n{\n\treturn normalize(uv - emitter);\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2.0 - 1.0;\n\treturn c;\n}\n\nfloat getwaves(vec2 position,float mirrorX,float mirrorY)\n{\n    float iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.2;\n    float w = 0.0;\n    float ws = 0.0;\n    float iwaterspeed = 1.0;\n    \n    pModMirror1(position.x,mirrorX);\n    pModMirror1(position.y,mirrorY);\n    for(int i=0;i<20;i++)\t\t\t\t\t\t\t\t\t\t// crank this for more veins\n    {\n        vec2 p = vec2(sin(iter), cos(iter)) * 300.0;\n        float res = wave(position, p, speed, phase, 0.0) * IEULER;\n        float res2 = wave(position, p, speed, phase, 0.006) * IEULER;\n        position -= wavedrag(position, p) * (res - res2) * weight * 5.0 * iwaterspeed;\n        w += res * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.12);\n        phase *= 1.2;\n        speed = pow(speed, 1.014);\n    }\n    return w / ws;\n}\n\n\n\nvec3 tunnel(vec2 p)\n{\n    float _d = length(p);\n    p.x += sin(p.x);\n    float wibble = 1.0-(0.1+sin(iTime+_d*_d*15.0)*0.1);\n    p.x *= wibble;\n    float offx = 0.1+sin(iTime*0.5)*0.05;\n    float offy = 0.1+cos(iTime*0.5)*0.1;\n    p.x += offx;\n    p.y += 0.1-offy;\n    \n    float a = atan(p.y,p.x);\n    float r = length(p);\n    vec2 uv = vec2( 0.13/r + 0.125*iTime, a/3.1415927 );\n    float w = getwaves(uv,128.0,1.0);\n    vec3 col = vec3( 1.0 - w*vec3(.88-w*.15,1.6,1.8)*1.0 );\n    col = clamp(col,0.0,1.0);\n    r = smoothstep(0.0,0.064,r);\n    col = mix(vec3(0.55,0.1,0.05),col,r*r);\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - 0.5* iResolution.xy ) / iResolution.y;\n    vec3 col = tunnel(uv*0.4);\n    \n    \n    // vignette\n    float rf = sqrt(dot(uv, uv)) * 0.666;\n    float rf2_1 = rf * rf + 1.0;\n    col *= 1.0 / (rf2_1 * rf2_1);\n    \n    \n    fragColor = vec4(col.xyz,1.0);\n    \n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3yWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 260, 338, 338, 471], [472, 472, 510, 510, 545], [547, 617, 663, 663, 812], [814, 814, 873, 873, 1655], [1659, 1659, 1680, 1680, 2262], [2266, 2266, 2323, 2323, 2610]], "test": "error"}
{"id": "XscyRs", "name": "bouncy boi on the run", "author": "stellabialek", "description": "subsurface stuff and lots of sillyness", "tags": ["subsurfacescattering", "sss", "spheretracing", "reflections", "weird"], "likes": 66, "viewed": 4121, "published": "Public", "date": "1519758848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\nconst float TWOPI = 2.0 * PI;\nconst float EPSILON = 0.0001;\n\nconst float MAXDIST = 20.0;\n\nconst int m_boi = 0;\nconst int m_eyes = 1;\nconst int m_world = 2;\nconst int m_ghost = 3;\n\nvec3 bg = vec3(0.3, 0.3, 0.2);\n\nstruct ray\n{\n\tvec3 o; //origin\n\tvec3 d;\t//direction\n};\n\nstruct result\n{\n\tfloat t;\n\tvec2 uv;\n\tvec3 p;\n\tvec3 n;\n\tint mID;\n};\n\nstruct material \n{\n\tvec3 diffuse;\n\tvec3 shadow;\n\tfloat sss;\n\tfloat refl;\n};\n\nresult compare(result a, result b)\n{\n    if(a.t < b.t)\n        return a;\n    return b;\n}\n\nfloat rand(float seed)\n{\n\treturn fract(sin(seed) * 1231534.9);\n}\n\nfloat rand(vec2 seed) \n{ \n    return rand(dot(seed, vec2(12.9898, 783.233)));\n}\n\nfloat distSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat opU(float a, float b)\n{\n\treturn min(a, b);\n}\n\nfloat opU2(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opD(float a, float b)\n{\n\treturn max(a, -b);\n}\n\nvec3 opR(vec3 p, vec3 r)\n{\n\treturn mod(p, r)-0.5*r;\n}\n\nvec3 rotateX(vec3 p, float angle)\n{\n\tmat3 r = mat3(1, 0, 0,\n\t\t\t\t\t0, cos(angle), -sin(angle),\n\t\t\t\t\t0, sin(angle), cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), 0, sin(angle),\n\t\t\t\t0, 1, 0,\n\t\t\t\t-sin(angle),0 , cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), -sin(angle), 0,\n\t\t\t\tsin(angle), cos(angle), 0,\n\t\t\t\t0, 0, 1);\n\treturn r * p;\n}\n\nvec2 getUVSphere(vec3 p)\n{\n\tp = normalize(p);\n\tfloat x = atan(p.z, p.x) / TWOPI;\n\tfloat y = asin(p.y) / PI;\n\t\n\treturn vec2(0.5) + vec2(x,y);\n}\n\nvec3 getLightPos(float t)\n{\n\treturn vec3(-2.0*sin(t), 0.3+sin(t*4.0)*0.2, 5.0 + 2.0 * cos(t));\n}\n \nresult bouncyBoi(vec3 p, float t)\n{\n\tresult res;\t\n\tres.mID = m_boi;\n\n\tp.y -= abs(sin(t * 4.0)) * 0.4;\t\n\tp.x -= sin(t * 2.0) * 0.2;\n\tp.z -= 5.0;\n\tp = rotateY(p, sin(t * 4.0) * PI * 0.2);\t\t\n\tp = rotateZ(p, smoothstep(-.6, 0.4, p.y) * PI * 0.1 * sin(t * 4.0));\n\t\t\t\n\tvec3 op = p;\n\t\n\t//body\n\tp = op;\n\tp.y += smoothstep(0.15, 2.5, abs(op.x));\n\tp.y *= 0.8;\n\tp.z += (1.0 - smoothstep(0.0, 1.2, abs(op.y - 0.1))) * 0.4 * max(0.0, op.z);\n\tp.xz *= (1.0 + opU2(0.0, p.y, 0.2) * 0.2 * pow((1.0 - abs(sin(t * 4.0))), 2.0));\n\tres.t = distSphere(p, 1.0);\n\t\t\n\t//arms\n\tp = op;\n\tp.x *= 0.13;\n\tp.y += sin((p.x) * 2.0 + t * 8.0) * 0.2 * smoothstep(0.8, 2.0, abs(op.x));\n\tres.t = opU2(res.t, distSphere(p, 0.2), 0.2);\n\t\t\n\t//mouth\n\tp = op;\n\tp -= vec3(0.0, 0.45, -1.0);\n\tp *= vec3(1.0, ((sin(t  * 8.0) + 1.0) * 0.5) * 0.5 + 0.5, 0.8);\n\tres.t = opD(res.t, distSphere(p, 0.1));\n\t\t\n\t//right eye\n\tp = op;\n\tp -= vec3(0.25, 0.6, -0.7);\n\tp = rotateY(p, -PI/16.0 + sin(t*6.0)*PI/16.0);\n\tp = rotateX(p, PI/2.0 + sin(t*6.0)*PI/16.0);\n\tresult resEyeR;\n\tresEyeR.t = distSphere(p, 0.2);\n\tresEyeR.mID = m_eyes;\n\tresEyeR.uv = getUVSphere(p);\n\t\n\t//left eye\n\tp = op;\n\tp -= vec3(-0.25, 0.6, -0.7);\n\tp = rotateY(p, PI/16.0 - sin(t*6.0)*PI/16.0);\n\tp = rotateX(p, PI/2.0 - sin(t*6.0)*PI/16.0);\t\t\n\tresult resEyeL;\n\tresEyeL.t = distSphere(p, 0.2);\n\tresEyeL.mID = m_eyes;\n\tresEyeL.uv = getUVSphere(p);\n\t\n\tres = compare(res, resEyeR);\n\tres = compare(res, resEyeL);\n\treturn res;\n}\n\nfloat angle(vec2 a, vec2 b)\n{\n\ta = normalize(a);\n\tb = normalize(b);\n\tfloat c = dot(a,b);\n\tfloat s = a.x*b.y - b.x*a.y;\n\treturn atan(s,c);\n}\n  \nresult ghost(vec3 p, float t)\n{\n\tresult res;\n\tres.mID = m_ghost;\n\t\n\tvec3 lPos = getLightPos(t);\n\tp -= lPos;\n\tfloat rY = angle(lPos.xz - vec2(0.0,5.0), vec2(-1.0, 0.0));\n\tfloat rX = sin(t * 4.0) * PI / 16.0;\n\tp = rotateY(p, rY);\n\tp = rotateX(p, rX);\n\t\n\tvec3 op = p;\n\t\n\t//body\n\tp = rotateX(p, p.y*10.0*(1.0 + 0.2*sin(t*8.0)));\n\tp.y += mix(0.0, 0.2, 1.0 - smoothstep(-0.6, 0.0, p.y));\t\t\n\tres.t = distSphere(p, 0.16);\n\n\t//arms\n\tp = op;\n\tp = rotateZ(p, p.x*sin(t*4.0)*2.0);\n\tp.y += 0.04;\n\tp.x *= 0.6;\n\tp.zy *= 8.0;\t\t\n\tres.t = opU2(res.t, distSphere(p,0.1), 0.2);\n\t\n\t//eyes\n\tp = op;\n\tp += vec3(0.07,-0.06,0.1);\n\tres.t = opD(res.t, distSphere(p, 0.06));\t\n\tp.x -= 0.14;\n\tres.t = opD(res.t, distSphere(p, 0.06));\n\n\treturn res;\n}\n\nresult world(vec3 p, float t)\n{\n\tresult res;\n\tres.mID = m_world;\n\t\n\t//floor deformations\n\tp.z -= t * 1.4;\n\tp = rotateZ(p, p.x*0.1);\n\tp.y += sin(p.x/2.0)*sin(p.z/2.0)*0.4;\n\tp.y += sin(p.x)*sin(p.z)*0.2;\n\tp.y += sin(p.x*2.0)*sin(p.z*2.0)*0.1;\n\tp.y += sin(p.x*6.0)*sin(p.z*6.0)*0.01;\n\tres.t = p.y + 1.0;\n\t\n\t//lumps\n\tvec3 rep = vec3(3.0, 0.0, 2.0);\n\tvec2 id = floor(p/rep).xz;\n\tp = mod(p,rep)-rep*0.5;\n\tp.y += mix(0.6, 1.0,rand(id));\n\tp.x += rand(id.y)-0.5;\n\tp.z += rand(id.x)-0.5;\n\tres.t = opU2(res.t, distSphere(p, mix(0.2, 0.3, rand(id))), 0.6);\n\t\n\treturn res;\n}\n\nresult distanceField(vec3 p, float t)\n{\n\tresult res;\n\tres = bouncyBoi(p,t);\n\tres = compare(res, ghost(p,t));\n\tres = compare(res, world(p,t));\n\treturn res;\n}\n\n//shadow casters only\nresult distanceFieldShadow(vec3 p, float t)\n{\n\tresult res;\n\tres = bouncyBoi(p,t);\n\tres = compare(res, world(p,t));\n\treturn res;\n}\n  \nvec3 getNormal(vec3 p, float t)\n{\n\tvec2 d = vec2(0.01, 0.0);\n\tfloat dx = distanceField(p + d.xyy,t).t\n\t\t\t\t- distanceField(p - d.xyy,t).t;\n\tfloat dy = distanceField(p + d.yxy,t).t\n\t\t\t\t- distanceField(p - d.yxy,t).t;\n\tfloat dz = distanceField(p + d.yyx,t).t\n\t\t\t\t- distanceField(p - d.yyx,t).t;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nfloat SSS(vec3 p, vec3 l, vec3 n, float t, float delta)\n{\n\tconst int samples = 6;\n\tfloat sss = 0.0;\n\tfloat lDist = length(l);\n\tl = normalize(l);\n\tfor(int i = 1; i <= samples; i++)\n\t{\n\t\tfloat i_f = float(i);\n\t\tfloat dist = rand(i_f) * delta;\n\t\tvec3 offset = vec3(rand(i_f),rand(i_f+1.0),rand(i_f+2.0));\n\t\toffset = normalize(offset - vec3(0.5));\n\t\tvec3 dir = normalize(l + offset*0.3);\n\t\tfloat d = distanceField(p + dir * dist, t).t;\n\t\tfloat s = max(dist+d, 1.0 - (lDist - dist)/lDist);\n\t\ts /=  pow(1.0 + (delta/dist)*0.4, 2.0);\n\t\tsss += s;\n\t}\n\tsss /= float(samples);\n\tsss = smoothstep(0.0, 0.4, sss);\n\treturn sss;\n}\n\nresult trace(ray r, float time)\n{\t\t\n\tresult res;\n\tfloat t = 0.0;\n\tvec3 p;\n\twhile(t <= MAXDIST)\n\t{\n\t\tp = r.o + r.d * t;\n\t\tres = distanceField(p, time);\t\t\n\t\tif(res.t <= EPSILON) break;\t\n\t\t//don't use full distance because artifacts\n\t\tt += max(res.t*0.6, t * 0.0001);\n\t}\t\n\tres.t = t;\n\tres.p = p;\n\tres.n = getNormal(p, time);\n\treturn res;\n}\n\nfloat shadow(result res, float time, float k)\n{\n\tray r;\n\tr.o = res.p + res.n * 0.01;\n\tvec3 l = getLightPos(time) - r.o;\n\tr.d = normalize(l);\n\tfloat maxDist = length(l);\n\n\tfloat s = 1.0;\n\tfloat t = 0.0;\n\twhile(t <= maxDist)\n\t{\n\t\tvec3 p = r.o + r.d * t;\n\t\tfloat d = distanceFieldShadow(p, time).t;\t\t\n\t\tif(d <= EPSILON) break;\n\t\ts = min(s, d*k / t);\n\t\tt += max(d, t * 0.0001);\n\t}\t\n\treturn min(s, t < maxDist ? 0.0 : 1.0);\n}\n\nmaterial getMaterial(result res)\n{\n\tmaterial m;\n\tswitch(res.mID)\n\t{\n\t\tcase(m_boi):\n\t\t\tm.diffuse = vec3(1.0, 0.6, 0.4);\n\t\t\tm.shadow = vec3(0.4, 0.1, 0.0);\n\t\t\tm.sss = 1.0;\n\t\t\tm.refl = 0.4;\n\t\tbreak;\n\t\tcase(m_eyes):\n\t\t\tm.diffuse = vec3(1.0, 1.0, 0.8);\n\t\t\tm.diffuse *= smoothstep(0.02,0.05, res.uv.y);\n\t\t\tm.shadow = vec3(0.4, 0.1, 0.1);\n\t\t\tm.sss = 1.0;\n\t\t\tm.refl = 0.6;\n\t\tbreak;\n\t\tcase(m_world):\n\t\t\tm.diffuse = vec3(1.0, 0.6, 0.4);\n\t\t\tm.shadow = vec3(0.4, 0.1, 0.0);\n\t\t\tm.sss = 1.0;\n\t\t\tm.refl = 0.2;\n\t\tbreak;\n\t\tcase(m_ghost):\n\t\t\tm.diffuse = vec3(1.4, 1.3, 1.0);\n\t\t\tm.shadow = vec3(0.6, 0.5, 0.4);\n\t\t\tm.sss = 0.2;\n\t\t\tm.refl = 0.5;\n\t\tbreak;\n\t}\n\treturn m;\n}\n\nvec3 getColor(result res, float time)\n{\n\tvec3 color = bg;\n\tif(res.t <= MAXDIST)\n\t{\n\t\tmaterial m = getMaterial(res);\n\t\tcolor = m.diffuse;\n\t\t\n\t\tvec3 l = getLightPos(time) - res.p;\t\t\t\n\t\tfloat ndl = max(0.0, dot(normalize(l),res.n));\n\t\tfloat i = max(0.0, ndl);\n\t\ti *= shadow(res, time, 16.0);\n\t\tfloat sss = SSS(res.p, l, res.n, time, m.sss);\n\t\ti = mix(i, sss, (-ndl+1.0)/2.0);\n\t\ti *= 1.0 - smoothstep(4.0, 8.0, length(l));\n\t\tcolor = mix(color * m.shadow, color, i);\t\n\t}\n\treturn color;\n} \n\nvec3 reflection(ray r, result res, float time)\n{\n\tr.o = res.p + res.n * 0.01;\n\tr.d = reflect(r.d, res.n);\n\tres = trace(r, time);\n\treturn getColor(res,time);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime;\t\t\n\tvec4 color = vec4(0.0);    \n\t\t\n\tfloat camRotY = PI * 0.1 * sin(time * 0.5);\n\tfloat camRotX = -PI *(0.01 + 0.03 *(sin(time * 0.2)+1.0));\n\t\n\tray r;\n\tr.o = vec3(0.0,0.0,-5.0);\n\tr.o = rotateX(r.o, camRotX);\n\tr.o = rotateY(r.o, camRotY);\n\tr.o.z += 5.0;\n\tr.o.y += 0.2;\n\tfloat fx = tan(radians(70.0) / 2.0) / iResolution.x;\n\tvec2 d = fx * (fragCoord.xy * 2.0 - iResolution.xy);\n\tr.d = normalize(vec3(d, 1.0));\n\tr.d = rotateX(r.d, camRotX);\n\tr.d = rotateY(r.d, camRotY);\n\t\t\n\tresult res = trace(r, time);\n\tcolor.rgb = getColor(res,time);\t\n\tif(res.t <= MAXDIST)\n\t{\t\n\t\tfloat fresnel = pow(1.0 + dot(r.d,res.n),2.0);\n\t\tfresnel = clamp(fresnel, 0.0, 1.0);\n\t\n\t\tmaterial mat = getMaterial(res);\n\t\tcolor.rgb *= (1.0 - mat.refl * fresnel);\n\t\n\t\tvec3 reflectedColor = reflection(r, res,time);\n\t\tcolor.rgb += reflectedColor * mat.refl * fresnel;\t\n\t}\n\tfloat fog = smoothstep(MAXDIST * 0.5, MAXDIST,res.t);\n\tcolor.rgb = mix(color.rgb, bg, fog);\n\t\n\tvec3 l = getLightPos(time)-r.o;\n\tfloat halo = dot(normalize(l),r.d);\n\thalo *= max(0.0, sign(res.t - length(l)));\n\thalo = smoothstep(0.99, 0.999, halo);\n\tcolor.rgb += halo * vec3(0.2, 0.2, 0.1);\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 465, 501, 501, 553], [555, 555, 579, 579, 619], [621, 621, 645, 645, 700], [702, 702, 737, 737, 762], [764, 764, 793, 793, 814], [816, 816, 855, 855, 945], [947, 947, 976, 976, 998], [1000, 1000, 1026, 1026, 1053], [1055, 1055, 1090, 1090, 1197], [1199, 1199, 1234, 1234, 1339], [1341, 1341, 1376, 1376, 1481], [1483, 1483, 1509, 1509, 1625], [1627, 1627, 1654, 1654, 1723], [1726, 1726, 1761, 1761, 3156], [3158, 3158, 3187, 3187, 3297], [3301, 3301, 3332, 3332, 4020], [4022, 4022, 4053, 4053, 4583], [4585, 4585, 4624, 4624, 4741], [4743, 4765, 4810, 4810, 4894], [4898, 4898, 4931, 4931, 5228], [5230, 5230, 5287, 5287, 5844], [5846, 5846, 5879, 5879, 6182], [6184, 6184, 6231, 6231, 6604], [6606, 6606, 6640, 6640, 7255], [7257, 7257, 7296, 7296, 7739], [7742, 7742, 7790, 7790, 7900], [7902, 7902, 7957, 7957, 9123]], "test": "valid"}
{"id": "XscyRX", "name": "Smooth Voronoi (weights)", "author": "jcg_", "description": "the neighboring cells are weighted based on a function of their distance to a point. The weights of surrounding cells can be individually used. Not perfect but good enough. Useful for generating a random smooth biome map, for example in terrain generation", "tags": ["voronoi", "biomes"], "likes": 7, "viewed": 443, "published": "Public", "date": "1519641850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ANIMATE\n\n// How far cells can go off center during animation (must be <= .5)\n#define ANIMATE_D .5\n\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .00001\n\nstruct vor{\n    vec2 p1;\n    vec2 p2;\n    vec2 cell1;\n    vec2 cell2;\n    float distToBorder;\n    \n    mat4 pointDistances;\n};\n    float rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat weightFunction(float i)\n{\n    return 1./(pow(i,3.));\n}\nfloat matSum(mat4 m)\n{\n    float res;\n    for (int i = 0; i < 4;i++)\n    {\n        for (int j = 0; j < 4;j++)\n        {\n            res += weightFunction(m[i][j]);\n        }\n    }\n    return res;\n}\n\n\nvec3 colors[5] =vec3[]( vec3(1,0,0),vec3(0,1,0),vec3(0,0,1),vec3(1,1,0),vec3(1,0,1));\nvec2 hash2(vec2 p)\n{\n       // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n       vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n       p3 += dot(p3, p3.yzx+19.19);\n       vec2 o = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n    #ifdef ANIMATE\n       o = 0.5 + ANIMATE_D*sin( iTime + o*6.2831853 );\n    #endif\n   return o;\n   \n}\n\n\n\nfloat noise12(vec2 pi)\n{\n\tvec3 p = vec3(pi,0);\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\n\n//---------------------------------------------------------------\n// 4x4 scan in both passes = most accurate\n//---------------------------------------------------------------\n\nvor voronoi( in vec2 x )\n{\n    \n    \n\tvor res;\n    // slower, but better handles big numbers\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            res.p1 = g+o+n;\n            res.cell1 = g+n;\n        }\n        res.pointDistances[i][j]=d;\n        \n        \n        \n        \n        \n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON )\n        {\n            float newD = dot( 0.5*(mr+r), normalize(r-mr) );\n            if (newD < md)\n            {\n                md = newD;\n                res.p2 = g+o+n;\n                res.cell2 = g+n;\n            }\n        }// skip the same cell\n    }\n    res.distToBorder = md;\n    \n    \n    \n    \n    \n   \n    return res;\n}\n\n\nvec3 plot( vec2 p, float ss )\n{\n    vec3 col;\n    \n    vor O = voronoi(p);\n    \n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n    \n    float S = matSum(O.pointDistances);\n    for (int i = 0; i <= 3;i++)\n    {\n        for (int j = 0; j <= 3;j++)\n        {\n            float w = weightFunction(O.pointDistances[i][j]);\n                if (w/S > 0.01)\n                {\n                    \n                    vec3 thisCol = colors[int(5.0*noise12(n+vec2(i,j)))];\n            \t\tcol += thisCol*w/S;\n                }\n        }\n        \n    }\n    \n    \n   \n    \n    \n    \n    \n    //col=c1;\n    if (O.distToBorder < 0.01)\n    {\n        //col = vec3(1);\n    }\n    if (length(O.p1-p) < 0.03 )\n    {\n        //col = vec3(1);\n    }\n    \n    \n    if (iMouse.z > 0.) // show grid\n    {\n\t\tvec2 g = abs(fract(p)-.5);\n        col = mix(col,vec3(.8),smoothstep(.5-ss*1.5,.5,max(g.x,g.y)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*4. + 4.; // scale differently for fullscreen\n\tfloat ss = sc / iResolution.y; // size of 1 pixel\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) * ss;\n    fragColor = vec4(plot(uv, ss), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 308, 328, 328, 366], [367, 367, 398, 398, 427], [428, 428, 450, 450, 625], [714, 714, 734, 807, 1079], [1083, 1083, 1107, 1107, 1379], [1558, 1558, 1584, 1584, 2989], [2992, 2992, 3023, 3023, 3941], [3943, 3943, 4000, 4000, 4234]], "test": "valid"}
{"id": "Xscyz2", "name": "Kelly", "author": "krax", "description": "While my girlfriend is away for a month, playing with shaders seems like a good distraction.", "tags": ["abstract"], "likes": 6, "viewed": 159, "published": "Public", "date": "1519495180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define ALIAS_AMOUNT 0.01\n#define delta 0.001\n\n#define jump_in (smoothstep(0., 2., iTime))\n\nvec2 barycentric(vec2 a, vec2 b, vec2 c, vec2 p) {\n    float det = (b.y - c.y)*(a.x - c.x) + (c.x - b.x)*(a.y - c.y);\n    return vec2(\n        ((b.y - c.y)*(p.x - c.x) + (c.x - b.x)*(p.y - c.y))/det,\n        ((c.y - a.y)*(p.x - c.x) + (a.x - c.x)*(p.y - c.y))/det\n    );\n}\n\nfloat in_triangle(vec2 st) {\n    // Given barycentric coords, check if it's in a triangle\n    float c = smoothstep(-delta-ALIAS_AMOUNT, 0., st.y);\n    c *= smoothstep(-delta-ALIAS_AMOUNT, delta, st.x);\n    c *= (1.0+delta)-(smoothstep(1.0-delta-ALIAS_AMOUNT, 1.0+delta, st.x+st.y));\n    return c;\n}\n\n// Adapted from: https://www.shadertoy.com/view/Xds3Dn\n// - @P_Malin\nfloat curve(vec2 a, vec2 b, vec2 c, vec2 uv) {\n    // Get barycentric coordinates\n    vec2 st = barycentric(a, b, c, uv)*jump_in;\n\n    // Get in triangle mask\n    float tri_mask = in_triangle(st);\n    \n    // Get the curve\n    float curve = 1.0-length(1.0-st);\n    \n    // Return a smooth stepped curve masked by the triangle it's in\n    return smoothstep(delta, ALIAS_AMOUNT, tri_mask * curve);\n}\n\n\nfloat tri(vec2 a, vec2 b, vec2 c, vec2 uv) {\n    // Get barycentric coordinates\n    vec2 st = barycentric(a, b, c, uv)*jump_in;\n    // Get in triangle mask\n    return in_triangle(st);\n}\n\n\nfloat quad(vec2 a, vec2 b, vec2 c, vec2 d, vec2 uv) {\n\n    return max(\n        tri(a, b, c, uv),\n        tri(d, a, c, uv)\n    );\n}\n\n\nfloat leaf(\n        const in vec2 start,\n        const in vec2 end,\n        const in vec2 push,\n        const in float hmult,\n        const in vec2 uv\n    ) {\n    \n    // Calculate where circles intersect to find\n    // perpendicular points\n    // https://stackoverflow.com/a/3349134\n    // Could have just multiplied\n    // it by a matrix with 90 degrees\n    float dist = distance(start, end);\n    vec2 direction_dist = end-start;\n    vec2 direction = normalize(direction_dist);\n\n    // Central point \n    vec2 P = start + direction_dist*.5;\n\n    // How long we want our line to be\n    float h = dist*hmult;;\n    vec2 pA = vec2(\n        P.x - h * direction.y,\n        P.y + h * direction.x\n    );\n    vec2 pB = vec2(\n        P.x + h * direction.y,\n        P.y - h * direction.x\n    );\n\n    float col = (\n        curve(start, end, pA + pA*push, uv) +\n        curve(start, end, pB + pB*push, uv)\n    );\n    \n    return col;\n}\n\n// by defhlt\n// from: https://stackoverflow.com/a/19212122\nfloat line(vec2 p1, vec2 p2, float size, vec2 uv) {\n\n  float a = jump_in*abs(distance(p1, uv));\n  float b = jump_in*abs(distance(p2, uv));\n  float c = jump_in*abs(distance(p1, p2));\n\n  if ( a >= c || b >=  c ) return 0.0;\n\n  float p = (a + b + c) * 0.5;\n\n  // median to (p1, p2) vector\n  float h = 2. / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n  return mix(1.0, 0.0, smoothstep(0.5 * size, 1.5 * size, h));\n}\n\n\n\nfloat vine_a(\n        const in vec2 start,\n        const in vec2 control,\n        const in vec2 end,\n        const in float size,\n        const in vec2 uv\n    ) {\n\n    \n    float c = 0.;\n    vec2 last = start;\n\n    for(float t=0.; t < 1.0; t+=0.1) {\n        \n        vec2 source = mix(start, control, t);\n        vec2 dest = mix(control, end, t);\n        vec2 point = mix(source, dest, t);\n        \n        if(abs(t-.5) < delta ) {\n            c = max(c, leaf(point, point+vec2(0.01, 0.06), vec2(0.), .5, uv));\n        }\n        if(abs(t-.7) < delta ) {\n            c = max(c, leaf(point, point+vec2(.05, -.05), vec2(0.), .5, uv));\n        }\n        if(abs(t-.9) < delta ) {\n            c = max(c, leaf(point, point-0.05, vec2(0.), .5, uv));\n        }\n\n        c = max(c, line(point, last, size, uv));\n        last = point;\n    }\n    c = max(c, line(last, end, size, uv));\n    return c;\n}\n\n\nfloat circle(vec2 pos, float r, vec2 uv) {\n    return smoothstep(0.001, 0., length(uv-pos)-r);\n}\n\nfloat ellipse(vec2 pos, vec2 r, vec2 uv) {\n    float base = max(r.x, r.y);\n    vec2 scale = r / min(r.x, r.y);\n    return smoothstep(0.001, 0., length(uv-pos*scale)-base);\n}\n\n\nvoid make_vines(vec2 uv, inout vec3 col) {\n\n    col = mix(col, vec3(0.1, 0.7, 0.01), vine_a(vec2(.0897, .0897) , vec2(sin(iTime)*.01, -.2), vec2(-.25, 0.), 0.001, uv));\n    col = mix(col, vec3(0.1, 0.7, 0.01), vine_a(vec2(-.0897, -.0897) , vec2(cos(iTime+0.4)*.01 - 0.2, -.2), vec2(-.25, 0.), 0.001, uv));\n    col = mix(col, vec3(0.1, 0.7, 0.01), vine_a(vec2(.3, .195) , vec2(.3 + cos(iTime+0.6)*.01, -.2), vec2(-.25, 0.1), 0.001, uv));\n}\n\n\nvoid make_main(vec2 uv, inout vec3 col) {\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(.2246, .1673), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(.3430, .1281), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(.3105, -.0116), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(.1856, -.1050), .08952, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(.0404, -.1148), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(.2514, -.0678), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(.0252, .1840), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(-.3097, .1490), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(-.2136, .2001), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(-.2489, -.0207), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(-.1768, -.1202), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(-.0634, -.1619), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(-.3373, .0275), .08953, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(-.2611, -.1122), .046, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(.1162, -.1300), .046, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(.1162, .2040), .04601, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(.2894, .1815), .04601, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(.3864, .0429), .046, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(-.1234, .2206), .046, uv));\n    col = mix(col, vec3(1., .5725, .5725), circle(vec2(-.0573, .1826), .046, uv));\n    col = mix(col, vec3(.7843, 1., .7529), quad(vec2(.3011, -.1304), vec2(-.2711, -.1304), vec2(-.2609, .1927), vec2(.3113, .1927), uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(.2246, .1673), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(.3430, .1281), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(.3105, -.0116), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(.1856, -.1050), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(.0404, -.1148), .08138, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(.2514, -.0678), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(.0252, .1840), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(-.3097, .1490), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(-.2136, .2001), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(-.2489, -.0207), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(-.1768, -.1202), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(-.0634, -.1619), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(-.3373, .0275), .08139, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(-.2611, -.1122), .03802, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(.1162, -.1300), .03802, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(.1162, .2040), .03803, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(.2894, .1815), .03803, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(.3864, .0429), .03802, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(-.1234, .2206), .03802, uv));\n    col = mix(col, vec3(.7843, 1., .7529), circle(vec2(-.0573, .1826), .03802, uv));\n    col = mix(col, vec3(.7843, 1., .7529), quad(vec2(-.3603, -.2609), vec2(-.3644, -.2709), vec2(-.3644, -.0344), vec2(-.3603, -.0344), uv));\n    col = mix(col, vec3(.7843, 1., .7529), quad(vec2(-.3288, -.1783), vec2(-.3336, -.1583), vec2(-.3336, -.0388), vec2(-.3288, -.0388), uv));\n    col = mix(col, vec3(.7843, 1., .7529), quad(vec2(-.1937, -.2381), vec2(-.1985, -.2481), vec2(-.1985, -.1086), vec2(-.1937, -.1086), uv));\n    col = mix(col, vec3(.7843, 1., .7529), quad(vec2(-.0549, -.3623), vec2(-.0597, -.3423), vec2(-.0597, -.2228), vec2(-.0549, -.2228), uv));\n    col = mix(col, vec3(.7843, 1., .7529), quad(vec2(.0413, -.2781), vec2(.0365, -.2981), vec2(.0365, -.1586), vec2(.0413, -.1586), uv));\n    col = mix(col, vec3(.7843, 1., .7529), quad(vec2(.1339, -.2825), vec2(.1291, -.2925), vec2(.1291, -.1531), vec2(.1339, -.1531), uv));\n    col = mix(col, vec3(.7843, 1., .7529), quad(vec2(.0733, -.2283), vec2(.0685, -.2183), vec2(.0685, -.0888), vec2(.0733, -.0888), uv));\n    col = mix(col, vec3(.7843, 1., .7529), quad(vec2(.3351, -.1469), vec2(.3304, -.1369), vec2(.3304, -.0073), vec2(.3351, -.0073), uv));\n    col = mix(col, vec3(.7843, 1., .7529), quad(vec2(.3229, -.2001), vec2(.3181, -.1801), vec2(.3181, -.0606), vec2(.3229, -.0606), uv));\n    col = mix(col, vec3(.3373, .2314, .9294), quad(vec2(.1185, .0522), vec2(.0677, .1115), vec2(.0918, .1010), vec2(.1265, .0505), uv));\n    col = mix(col, vec3(.9176, .5137, .2392), quad(vec2(.2429, .1125), vec2(.3060, .1552), vec2(.3274, .1552), vec2(.2514, .1045), uv));\n    col = mix(col, vec3(.2471, .9098, .8471), quad(vec2(.2713, -.0151), vec2(.3311, -.0513), vec2(.3389, -.0742), vec2(.2616, -.0252), uv));\n    col = mix(col, vec3(.5333, 1., .9451), tri(vec2(.3311, -.0513), vec2(.2772, -.0236), vec2(.3290, -.0606), uv));\n    col = mix(col, vec3(.4706, .4196, .9686), tri(vec2(.0897, .0986), vec2(.0677, .1115), vec2(.0897, .0881), uv));\n    col = mix(col, vec3(.9569, .6941, .5176), tri(vec2(.3060, .1552), vec2(.2772, .1281), vec2(.3274, .1552), uv));\n    col = mix(col, vec3(.4196, .4196, .4196), quad(vec2(.1471, .0501), vec2(.2429, .0106), vec2(.2088, .0049), vec2(.1384, .0361), uv));\n    col = mix(col, vec3(.7176, .7176, .7176), quad(vec2(.1246, .2331), vec2(.0897, -.0344), vec2(.1856, .0492), vec2(.1322, .0280), uv));\n    col = mix(col, vec3(.7176, .7176, .7176), quad(vec2(.0897, -.0419), vec2(.2271, .0692), vec2(.2663, .0740), vec2(.0996, -.0544), uv));\n    col = mix(col, vec3(.7176, .7176, .7176), quad(vec2(.1913, .0083), vec2(.2713, .0692), vec2(.2713, .0461), vec2(.1913, -.0149), uv));\n    col = mix(col, vec3(.7176, .7176, .7176), tri(vec2(.1829, .0049), vec2(.1829, -.0168), vec2(.1621, -.0149), uv));\n    col = mix(col, vec3(.4196, .4196, .4196), quad(vec2(.1246, .2331), vec2(.1384, .0361), vec2(.1829, .0550), vec2(.1517, .0541), uv));\n    col = mix(col, vec3(.4196, .4196, .4196), quad(vec2(.1980, .0653), vec2(.2429, .0106), vec2(.2205, .0049), vec2(.1829, .0692), uv));\n    col = mix(col, vec3(.4196, .4196, .4196), quad(vec2(.2663, .0240), vec2(.1829, .0692), vec2(.2129, .0692), vec2(.2663, .0275), uv));\n    col = mix(col, vec3(.4196, .4196, .4196), quad(vec2(.1029, .1125), vec2(.1162, .2331), vec2(.0971, .2156), vec2(.0988, .1406), uv));\n    col = mix(col, vec3(.2863, .2863, .2863), tri(vec2(.0596, .1728), vec2(-.0295, -.0806), vec2(.0596, -.0625), uv));\n    col = mix(col, vec3(.4196, .4196, .4196), quad(vec2(.0813, .2040), vec2(.0804, .2001), vec2(-.0034, -.1050), vec2(.0596, -.0700), uv));\n    col = mix(col, vec3(.2863, .2863, .2863), quad(vec2(-.0015, -.0367), vec2(.1038, .0049), vec2(.1438, .0049), vec2(-.0122, -.0692), uv));\n    col = mix(col, vec3(.2863, .2863, .2863), quad(vec2(.0003, -.0207), vec2(.0813, .0187), vec2(.1162, .0187), vec2(.0771, .0373), uv));\n    col = mix(col, vec3(.2863, .2863, .2863), quad(vec2(.0813, .0256), vec2(.1004, -.0023), vec2(.1246, .0002), vec2(.1162, .0187), uv));\n    col = mix(col, vec3(.4196, .4196, .4196), quad(vec2(.0389, -.0759), vec2(.1029, -.0419), vec2(.0813, .0156), vec2(.0771, -.0384), uv));\n    col = mix(col, vec3(.4196, .4196, .4196), quad(vec2(-.0034, -.1117), vec2(.1521, -.0252), vec2(.1829, -.0241), vec2(-.0034, -.1300), uv));\n    col = mix(col, vec3(.4078, .4078, .4078), tri(vec2(.0114, .0881), vec2(-.0492, .1122), vec2(-.0671, .0772), uv));\n    col = mix(col, vec3(.4078, .4078, .4078), quad(vec2(-.0108, .0231), vec2(-.0895, .0231), vec2(-.0713, .0492), vec2(.0252, .0772), uv));\n    col = mix(col, vec3(.4078, .4078, .4078), quad(vec2(-.0449, .0231), vec2(-.0895, .0231), vec2(-.0574, .1614), vec2(-.0173, .1628), uv));\n    col = mix(col, vec3(.5765, .5765, .5765), quad(vec2(-.0684, .0333), vec2(-.1020, .0380), vec2(-.0763, .1330), vec2(-.0406, .1478), uv));\n    col = mix(col, vec3(.4078, .4078, .4078), tri(vec2(-.0502, .1488), vec2(.0252, .0881), vec2(-.0322, .1930), uv));\n    col = mix(col, vec3(.7176, .7176, .7176), quad(vec2(-.0606, .0301), vec2(-.0037, .0501), vec2(.0252, .0231), vec2(-.0406, .0156), uv));\n    col = mix(col, vec3(.6863, .6863, .6863), quad(vec2(.0404, .0947), vec2(.0313, .0881), vec2(-.0434, .2338), vec2(.0014, .2197), uv));\n    col = mix(col, vec3(.6863, .6863, .6863), quad(vec2(-.0122, .1382), vec2(-.0197, .1513), vec2(-.0197, .1940), vec2(-.0122, .1940), uv));\n    col = mix(col, vec3(.6863, .6863, .6863), quad(vec2(.0078, .1082), vec2(.0003, .1213), vec2(.0003, .1640), vec2(.0078, .1640), uv));\n    col = mix(col, vec3(.8471, .3922, .9569), quad(vec2(-.0693, .0512), vec2(-.0924, .0544), vec2(-.0763, .1230), vec2(-.0502, .1300), uv));\n    col = mix(col, vec3(.8471, .8471, .8471), quad(vec2(.0404, .0947), vec2(.0348, .0906), vec2(-.0177, .2056), vec2(.0014, .2197), uv));\n    col = mix(col, vec3(.8471, .8471, .8471), quad(vec2(-.0504, .0493), vec2(-.0552, .0505), vec2(-.0365, .1319), vec2(-.0278, .1478), uv));\n    col = mix(col, vec3(.6157, .2039, .7176), circle(vec2(-.0703, .1054), .00968, uv));\n    col = mix(col, vec3(.4549, .1020, .5373), circle(vec2(-.0606, .1185), .00599, uv));\n    col = mix(col, vec3(.8471, .3922, .9569), quad(vec2(-.1121, .0692), vec2(-.0623, .0692), vec2(-.0623, .0613), vec2(-.1408, .0613), uv));\n    col = mix(col, vec3(.3765, .3804, .3804), quad(vec2(-.1028, -.0151), vec2(-.1765, .1483), vec2(-.1662, .1631), vec2(-.0884, -.0086), uv));\n    col = mix(col, vec3(.4078, .4078, .4078), quad(vec2(-.0298, -.0419), vec2(-.1234, -.0419), vec2(-.1003, -.0064), vec2(.0004, -.0064), uv));\n    col = mix(col, vec3(.5059, .5098, .5098), quad(vec2(-.0399, -.0294), vec2(-.1534, -.0294), vec2(-.1255, .0136), vec2(-.0034, .0136), uv));\n    col = mix(col, vec3(.4706, .4667, .4667), quad(vec2(-.0295, .2323), vec2(-.2047, .1056), vec2(-.1795, .1728), vec2(-.0895, .2223), uv));\n    col = mix(col, vec3(1., .0, .0745), quad(vec2(-.2533, .1214), vec2(-.4115, .1552), vec2(-.3664, .1669), vec2(-.2489, .1418), uv));\n    col = mix(col, vec3(.0, 1., .6667), quad(vec2(-.2586, .2940), vec2(-.3911, .2440), vec2(-.3595, .2790), vec2(-.2393, .3256), uv));\n    col = mix(col, vec3(.4275, .4314, .4314), quad(vec2(-.1861, .2956), vec2(-.3795, .2156), vec2(-.3345, .2723), vec2(-.2407, .3423), uv));\n    col = mix(col, vec3(.6549, .0, 1.), quad(vec2(-.2261, -.0419), vec2(-.3911, -.0019), vec2(-.4245, .0373), vec2(-.2261, -.0110), uv));\n    col = mix(col, vec3(.4275, .4314, .4314), quad(vec2(-.2261, -.0294), vec2(-.3245, -.0019), vec2(-.2753, .2690), vec2(-.2261, .2856), uv));\n    col = mix(col, vec3(.5961, .5961, .5961), quad(vec2(-.1861, -.0194), vec2(-.2961, -.0194), vec2(-.2411, .3290), vec2(-.1861, .2956), uv));\n    col = mix(col, vec3(.7137, .7333, 1.), quad(vec2(-.1961, -.0094), vec2(-.2878, -.0094), vec2(-.2341, .3073), vec2(-.1961, .2856), uv));\n    col = mix(col, vec3(.5059, .5098, .5098), quad(vec2(-.1595, -.0544), vec2(-.3145, -.0360), vec2(-.3795, .0506), vec2(-.1595, -.0227), uv));\n    col = mix(col, vec3(.4471, .4471, .4510), quad(vec2(-.2400, -.0197), vec2(-.2522, -.0167), vec2(-.2411, .0315), vec2(-.2293, .0238), uv));\n    col = mix(col, vec3(.4471, .4471, .4510), quad(vec2(-.2154, -.0251), vec2(-.2276, -.0221), vec2(-.2161, .0256), vec2(-.2047, .0184), uv));\n    col = mix(col, vec3(.5020, .4980, .4980), quad(vec2(-.2470, .0888), vec2(-.2878, .0989), vec2(-.2828, .1548), vec2(-.2293, .1673), uv));\n    col = mix(col, vec3(.5686, .5647, .5647), quad(vec2(-.0929, .2018), vec2(-.2470, .0888), vec2(-.2293, .1660), vec2(-.0560, .2568), uv));\n    col = mix(col, vec3(.4275, .4314, .4314), quad(vec2(-.2574, -.0806), vec2(-.3422, -.0619), vec2(-.3084, -.0513), vec2(-.1943, -.0619), uv));\n    col = mix(col, vec3(.7137, .7333, 1.), quad(vec2(-.2399, .2040), vec2(-.3557, .2040), vec2(-.3157, .2206), vec2(-.1993, .2206), uv));\n    col = mix(col, vec3(.3765, .3804, .3804), quad(vec2(-.0778, -.0151), vec2(-.1595, .1728), vec2(-.1411, .1840), vec2(-.0634, -.0086), uv));\n    col = mix(col, vec3(.5059, .5098, .5098), quad(vec2(-.2493, .1181), vec2(-.4111, .1181), vec2(-.3695, .1390), vec2(-.2493, .1390), uv));\n    col = mix(col, vec3(.0, 1., .9725), circle(vec2(-.2282, .2906), .00654, uv));\n    col = mix(col, vec3(.0, 1., .9725), circle(vec2(-.2102, .2786), .00458, uv));\n    col = mix(col, vec3(.0, 1., .9725), circle(vec2(-.2213, .2702), .01136, uv));\n    col = mix(col, vec3(.0, 1., .9725), circle(vec2(-.2114, .2497), .0059, uv));\n    col = mix(col, vec3(.0, .6667, 1.), circle(vec2(-.2114, .2497), .0034, uv));\n    col = mix(col, vec3(.0, 1., .9725), circle(vec2(-.2014, .2697), .0034, uv));\n    col = mix(col, vec3(.0, 1., .9725), circle(vec2(-.2014, .2297), .0034, uv));\n    col = mix(col, vec3(.0, .6667, 1.), circle(vec2(-.2213, .2702), .00839, uv));\n    col = mix(col, vec3(.0, .6667, 1.), circle(vec2(-.2282, .2906), .00434, uv));\n    col = mix(col, vec3(.0, 1., .9725), circle(vec2(-.2228, .2490), .00225, uv));\n    col = mix(col, vec3(.0, 1., .9725), circle(vec2(-.2114, .2353), .00225, uv));\n    col = mix(col, vec3(.0, 1., .9725), circle(vec2(-.2014, .2568), .00225, uv));\n    col = mix(col, vec3(.0, 1., .9725), quad(vec2(-.3023, .0106), vec2(-.3302, .0212), vec2(-.3553, .0373), vec2(-.3023, .0194), uv));\n    col = mix(col, vec3(.0, 1., .9725), quad(vec2(-.2683, .0002), vec2(-.2992, .0095), vec2(-.2992, .0187), vec2(-.2775, .0106), uv));\n    col = mix(col, vec3(.5373, .0, .8863), quad(vec2(-.3373, -.0149), vec2(-.3911, -.0019), vec2(-.4245, .0373), vec2(-.3795, .0081), uv));\n    col = mix(col, vec3(1., .5020, .5608), quad(vec2(-.3334, .1490), vec2(-.3911, .1605), vec2(-.3664, .1669), vec2(-.3122, .1554), uv));\n    col = mix(col, vec3(.4627, 1., .8078), quad(vec2(-.3447, .2697), vec2(-.3795, .2531), vec2(-.3653, .2697), vec2(-.3302, .2832), uv));\n    col = mix(col, vec3(.7176, .7176, .7176), quad(vec2(-.1115, .2123), vec2(-.2326, .1442), vec2(-.2261, .1631), vec2(-.0962, .2323), uv));\n    col = mix(col, vec3(.2980, .2980, .2980), ellipse(vec2(-.0734, -.0079), vec2(.0161, .0173), uv));\n    col = mix(col, vec3(.4471, .4471, .4471), ellipse(vec2(-.0734, -.0079), vec2(.0120, .0128), uv));\n    col = mix(col, vec3(.5765, .5765, .5765), ellipse(vec2(-.0734, -.0079), vec2(.0083, .0089), uv));\n    col = mix(col, vec3(.4667, .4667, .4667), quad(vec2(.2313, -.0059), vec2(.2313, -.0388), vec2(.2573, -.0224), vec2(.2592, .0156), uv));\n    col = mix(col, vec3(.3373, .3373, .3373), quad(vec2(.0078, -.1375), vec2(.1980, -.0294), vec2(.2397, -.0344), vec2(.0113, -.1558), uv));\n    col = mix(col, vec3(.3373, .3373, .3373), quad(vec2(.2830, .0142), vec2(.1980, -.0391), vec2(.2397, -.0441), vec2(.3205, .0134), uv));\n    col = mix(col, vec3(.4667, .4667, .4667), quad(vec2(.2290, -.0513), vec2(.0084, -.1725), vec2(.0296, -.1783), vec2(.2663, -.0544), uv));\n    col = mix(col, vec3(.4667, .4667, .4667), quad(vec2(.2313, -.0659), vec2(.2313, -.0301), vec2(.2592, -.0079), vec2(.2530, -.0544), uv));\n    col = mix(col, vec3(.4667, .4667, .4667), quad(vec2(-.0573, -.1148), vec2(.0547, -.1651), vec2(.0296, -.1783), vec2(-.1234, -.1392), uv));\n    col = mix(col, vec3(.4667, .4667, .4667), quad(vec2(-.0143, -.0875), vec2(-.0878, -.1000), vec2(-.0971, -.1368), vec2(-.0143, -.1050), uv));\n    col = mix(col, vec3(.3373, .3373, .3373), quad(vec2(-.1137, -.0908), vec2(-.0929, -.0517), vec2(-.1095, -.0441), vec2(-.1768, -.1466), uv));\n    col = mix(col, vec3(.3373, .3373, .3373), quad(vec2(-.0829, -.0958), vec2(-.0622, -.0566), vec2(-.0787, -.0491), vec2(-.1419, -.1466), uv));\n    col = mix(col, vec3(.3373, .3373, .3373), quad(vec2(-.0470, -.0958), vec2(-.0262, -.0566), vec2(-.0428, -.0491), vec2(-.1011, -.1407), uv));\n    col = mix(col, vec3(.4667, .4667, .4667), tri(vec2(.2864, .0329), vec2(.3914, .1346), vec2(.3389, .0315), uv));\n    col = mix(col, vec3(.4667, .4667, .4667), quad(vec2(.3205, .0231), vec2(.3355, .1940), vec2(.3914, .2863), vec2(.3347, .0231), uv));\n    col = mix(col, vec3(.4667, .4667, .4667), quad(vec2(.3047, .0373), vec2(.3389, .0049), vec2(.3814, .0315), vec2(.3205, .0493), uv));\n    col = mix(col, vec3(.5490, .5490, .5490), quad(vec2(.3105, .0740), vec2(.2313, .1346), vec2(.1780, .1346), vec2(.2955, .0692), uv));\n    col = mix(col, vec3(.5490, .5490, .5490), quad(vec2(.2313, .1185), vec2(.3014, .1940), vec2(.2764, .2040), vec2(.1939, .1346), uv));\n    col = mix(col, vec3(.5490, .5490, .5490), tri(vec2(.2663, .1442), vec2(.2514, .1300), vec2(.2663, .1185), uv));\n    col = mix(col, vec3(.5490, .5490, .5490), quad(vec2(.2772, .1552), vec2(.2772, .1122), vec2(.2947, .0947), vec2(.2947, .1758), uv));\n    col = mix(col, vec3(.5490, .5490, .5490), quad(vec2(.2663, .2040), vec2(.1829, .2040), vec2(.2089, .1882), vec2(.2476, .1882), uv));\n    col = mix(col, vec3(.3490, .3490, .3490), quad(vec2(.2806, .0644), vec2(.3239, .1045), vec2(.3372, .1045), vec2(.2914, .0572), uv));\n    col = mix(col, vec3(.3490, .3490, .3490), quad(vec2(.3089, .0844), vec2(.2860, .0083), vec2(.3047, -.0168), vec2(.3164, .0906), uv));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = 0.7*(fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    make_main(uv, col);\n    make_vines(uv, col);\n\n    fragColor = vec4(col, 1.0);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xscyz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 144, 144, 366], [368, 368, 396, 457, 666], [668, 737, 783, 818, 1134], [1137, 1137, 1181, 1216, 1322], [1325, 1325, 1378, 1378, 1455], [2384, 2443, 2494, 2494, 2857], [3752, 3752, 3794, 3794, 3848], [3850, 3850, 3892, 3892, 4023], [4026, 4026, 4068, 4068, 4464], [4467, 4467, 4508, 4508, 21876], [21879, 21879, 21935, 21935, 22113]], "test": "error"}
{"id": "Xscyz4", "name": "Green Field", "author": "quadrupleslap", "description": "My first shader on Shadertoy! It's pretty dodgy, but it looks kind of cool. :)", "tags": ["raytracing", "mouse", "green", "perspective"], "likes": 2, "viewed": 469, "published": "Public API", "date": "1517990720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535\n\n#define INC 0.01\n#define ESC 50.0\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nbool intersects(in vec3 pos, out vec4 color) {\n    #define WIDTH 0.02\n    \n    vec2 uv = pos.xz;\n    color = vec4(0, 0.75, 0, 1);\n    \n    vec2 lol = fract(pos.xz);\n    vec2 kek = floor(pos.xz);\n    float h;\n    \n    if (max(lol.x, lol.y) <= WIDTH)\n        h = rand(kek);\n    else if (lol.x <= WIDTH)\n        h = mix(rand(kek), rand(kek + vec2(0, 1)), lol.y);\n    else if (lol.y <= WIDTH)\n        h = mix(rand(kek), rand(kek + vec2(1, 0)), lol.x);\n    else\n        return false;\n\n    return abs(h - pos.y) <= WIDTH;\n\n    #undef WIDTH\n}\n\nvec3 ray(in vec3 pos, in vec2 frag) {\n    vec2 uv = frag / iResolution.xy - 0.5;\n\n    vec2 angle = iMouse.xy / iResolution.xy - 0.5;\n    angle.x *= 2.0*PI; // [-PI,   PI  ]\n    angle.y *=     PI; // [-PI/2, PI/2]\n\n    vec3 forwards = vec3(\n        cos(angle.y) * sin(angle.x),\n        sin(angle.y),\n        cos(angle.y) * cos(angle.x));\n    \n    vec3 up = vec3(\n        -sin(angle.y) * sin(angle.x),\n         cos(angle.y),\n        -sin(angle.y) * cos(angle.x));\n    \n    vec3 right = vec3(\n        cos(angle.x),\n    \t0,\n    \t-sin(angle.x));\n    \n    vec3 result = forwards + mat3(right, up, forwards) * vec3(uv.x, uv.y, 0);\n\n    return normalize(result) * INC;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default color.\n\n    fragColor = vec4(vec3(0), 1);\n\n    // Trace.\n\n    vec3 pos = vec3(0, 3, 8.0 * iTime);\n    vec3 inc = ray(pos, fragCoord);\n    vec4 col;\n    float dst;\n    \n    //NOTE: Assumes that the grid is always below you and its top is at height 1.0.\n    if (inc.y >= 0.0)\n        return;\n    float jump = ((1.0 - pos.y) / inc.y);\n    pos += inc * jump;\n    dst += INC * jump;\n    \n\n    while (dst < ESC) {\n        if (intersects(pos, col)) {\n            fragColor = col;\n            break;\n        }\n        \n        //NOTE: Assumes you're looking down on the grid.\n        if (pos.y <= -INC)\n            return;\n        \n        pos += inc;\n    \tdst += INC;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xscyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 81, 81, 150], [689, 689, 726, 726, 1351], [1353, 1353, 1408, 1430, 2092]], "test": "valid"}
{"id": "Xscyz7", "name": "Dobrar a meta (EC)", "author": "mmutai", "description": "Part 1: https://www.shadertoy.com/view/4s3cRM\nI wish there was more room in the description. Then I could tell you all the wonders of Dilma's speech about the \"meta\". For now, I will leave you with this:\nWhen we hit the \"meta\", we will double the \"meta\".", "tags": ["raymarch", "metaballs", "metaball"], "likes": 3, "viewed": 165, "published": "Public", "date": "1518145678", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Extra credit #defines -- uncomment only one of these!\n//#define NORMALS\n//#define CUBEMAP\n#define BLINN_PHONG\n\nconst float PI = 3.14159265;\nconst vec3 BG_COLOR = vec3(0.2, 0.2, 0.2);\nconst vec3 BALL_COLOR = vec3(0.97, 0.25, 0.04);\nconst float THRESHOLD = 3.4;\nconst float BLEND_EPSILON = 0.05;\n\nconst float DIR_LEN = 0.75;\nconst float HALF_SQRT2 = 0.70710678118;\nconst vec3 DIR1 = (vec3(+0.0, +1.0, 0.0)) * DIR_LEN;\nconst vec3 DIR2 = (vec3(-HALF_SQRT2, +HALF_SQRT2, 0.0)) * DIR_LEN;\nconst vec3 DIR3 = (vec3(-1.0, +0.0, 0.0)) * DIR_LEN;\nconst vec3 DIR4 = (vec3(-HALF_SQRT2, -HALF_SQRT2, 0.0)) * DIR_LEN;\nconst vec3 DIR5 = (vec3(+0.0, -1.0, 0.0)) * DIR_LEN;\nconst vec3 DIR6 = (vec3(+HALF_SQRT2, -HALF_SQRT2, 0.0)) * DIR_LEN;\nconst vec3 DIR7 = (vec3(+1.0, +0.0, 0.0)) * DIR_LEN;\nconst vec3 DIR8 = (vec3(+HALF_SQRT2, +HALF_SQRT2, 0.0)) * DIR_LEN;\n// some browsers don't like normalize() in const declarations?\n/*\nconst vec2 DIR1 = normalize(vec2(+0.0, +1.0)) * DIR_LEN;\nconst vec2 DIR2 = normalize(vec2(-1.0, +1.0)) * DIR_LEN;\nconst vec2 DIR3 = normalize(vec2(-1.0, +0.0)) * DIR_LEN;\nconst vec2 DIR4 = normalize(vec2(-1.0, -1.0)) * DIR_LEN;\nconst vec2 DIR5 = normalize(vec2(+0.0, -1.0)) * DIR_LEN;\nconst vec2 DIR6 = normalize(vec2(+1.0, -1.0)) * DIR_LEN;\nconst vec2 DIR7 = normalize(vec2(+1.0, +0.0)) * DIR_LEN;\nconst vec2 DIR8 = normalize(vec2(+1.0, +1.0)) * DIR_LEN;\n*/\n\nconst float TIME_OFFSET = -PI * 0.25;\n\n#define U_TIME (iTime * 0.44)\n\n// don't eat uncooked metaballs\nfloat rawMetaball(vec3 p, vec3 center, float radius) {\n    return radius / distance(p, center);\n}\n\n// anime metaball, or ~metaballon anim~\nfloat aniMetaball(vec3 p, vec3 dir, float radius, float timeOffset) {\n\tfloat dist = cos(U_TIME * PI + timeOffset) * 0.5 + 0.5;\n    //dist = pow(dist, 1.1);\n    vec3 center = dir * dist;\n    return rawMetaball(p, center, radius);\n}\n\n\nfloat metaStep(vec3 p, out float minDist) {\n    float metaSum = 0.0;\n    float thisVal = 0.0;\n    float minVal = 10000000.0;\n    thisVal = rawMetaball(p, vec3(0.0), 0.08);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR1, 0.16, 0.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR2, 0.16, TIME_OFFSET);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR3, 0.16, TIME_OFFSET * 2.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR4, 0.16, TIME_OFFSET * 3.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR5, 0.16, TIME_OFFSET * 4.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR6, 0.16, TIME_OFFSET * 5.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR7, 0.16, TIME_OFFSET * 6.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR8, 0.16, TIME_OFFSET * 7.0);   \n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    \n    minDist = minVal;\n    return metaSum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n\tfloat metaSum;\n\tfloat t = 0.0;\n\tfloat minDist;\n    \n    vec3 rayO = vec3(p, -0.5);\n    vec3 rayD = vec3(0.0, 0.0, 1.0);\n    \n    for (int i = 0; i < 200; i++) {\n        metaSum = metaStep(rayO + rayD * t, minDist);\n        if (metaSum >= THRESHOLD) {\n            break; \n        } \n        t += 0.005;//minDist * 0.1;\n    }\n    \n    vec3 bgCol = BG_COLOR;\n#ifdef CUBEMAP\n\tbgCol = texture(iChannel0, normalize(vec3(p, 0.5))).xyz;    \n#endif\n    vec3 col = bgCol;\n    \n    // estimate normal\n    vec3 rayP = rayO + rayD * t;\n    const float NOR_EPSILON = 0.01;\n    \n    float xL = metaStep(rayP + vec3(-NOR_EPSILON, 0.0, 0.0), minDist);\n    float xH = metaStep(rayP + vec3(+NOR_EPSILON, 0.0, 0.0), minDist);\n    float yL = metaStep(rayP + vec3(0.0, -NOR_EPSILON, 0.0), minDist);\n    float yH = metaStep(rayP + vec3(0.0, +NOR_EPSILON, 0.0), minDist);\n    float zL = metaStep(rayP + vec3(0.0, 0.0, -NOR_EPSILON), minDist);\n    float zH = metaStep(rayP + vec3(0.0, 0.0, +NOR_EPSILON), minDist);\n    \n    vec3 nor = normalize(vec3(xL - xH, yL - yH, zL - zH));\n    vec3 lightDir = normalize(vec3(1, 1, -2));\n    const vec3 eyeDir = vec3(0, 0, -1);\n    \n    if (metaSum >= THRESHOLD) {\n        //col = mix(BG_COLOR, vec3(0.1), smoothstep(0.0, BLEND_EPSILON, metaSum - THRESHOLD)); \n#ifdef NORMALS\n        col = nor * 0.5 + 0.5;\n        \n#elif defined(CUBEMAP)\n        vec4 amb = texture(iChannel0, nor * 0.5 + 0.5);\n        col = amb.xyz;\n#elif defined(BLINN_PHONG)\n        col = BALL_COLOR * clamp(dot(nor, lightDir), 0.0, 1.0);\n        float spec = pow(max(0.0, dot(lightDir, normalize(nor + eyeDir))), 16.0);\n        col += vec3(spec);\n#else\n        col = BALL_COLOR;\n#endif\n        // blend like it's 2D\n        metaSum = metaStep(vec3(p, 0.0), minDist);\n        col = mix(bgCol, col, smoothstep(0.0, BLEND_EPSILON, metaSum - THRESHOLD)); \n        //col = vec3((metaSum / 2.2) - 1.0);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3zn", "previewfilepath": "/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xscyz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1442, 1474, 1528, 1528, 1571], [1573, 1615, 1684, 1684, 1845], [1848, 1848, 1891, 1891, 3070], [3072, 3072, 3129, 3179, 5250]], "test": "valid"}
{"id": "XscyzS", "name": "Kinestesia", "author": "felipunkerito", "description": "a lil convergence of five masters", "tags": ["raymarching", "sdf", "fbm", "formulanimations"], "likes": 5, "viewed": 567, "published": "Public API", "date": "1519336673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 10.0\n#define STEPS 256\n#define EPS 0.0001\nconst float PI = 3.14159265359;\n\n// This is based upon two tutorials: https://www.youtube.com/watch?v=CHmneY8ry84&t=211s by iq\n// and \t\t\t\t\t\t\t   : https://www.youtube.com/watch?v=RGmgHfbU0hU by vgs\n\nfloat hash( float n )\n{\n\n    return fract( sin( n ) * 45843.349 );\n    \n}\n\nfloat noise( in vec3 x )\n{\n\n    vec3 p = floor( x );\n    vec3 k = fract( x );\n    \n    k *= k * k * ( 3.0 - 2.0 * k );\n    \n    float n = p.x + p.y * 57.0 + p.z * 113.0; \n    \n    float a = hash( n );\n    float b = hash( n + 1.0 );\n    float c = hash( n + 57.0 );\n    float d = hash( n + 58.0 );\n    \n    float e = hash( n + 113.0 );\n    float f = hash( n + 114.0 );\n    float g = hash( n + 170.0 );\n    float h = hash( n + 171.0 );\n    \n    float res = mix( mix( mix ( a, b, k.x ), mix( c, d, k.x ), k.y ),\n                     mix( mix ( e, f, k.x ), mix( g, h, k.x ), k.y ),\n                     k.z\n    \t\t\t\t );\n    \n    return res;\n    \n}\n\nfloat fbm( in vec3 p )\n{\n\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p *= 2.02;\n    f += 0.2500 * noise( p ); p *= 2.03;\n    f += 0.1250 * noise( p ); p *= 2.01;\n    f += 0.0625 * noise( p );\n    f += 0.0125 * noise( p );\n    return f / 0.9375;\n    \n}\n\nvec3 flowerMaterial( in vec3 pos, in vec3 nor )\n{\n    \n    float a = atan( pos.x, pos.z );\n    float r = length( pos.xz );\n    \n    // Blue colour\n    vec3 col = vec3( 0.0, 0.0, 1.0 );\n    \n    // Mix to red\n    float f = fbm( pos );\n    col = mix( col, vec3( 1.0, 0.0, 0.0 ), f );\n    \n    return col;\n\n}\n\nfloat map( vec3 p )\n{\n\n    float wave = texture( iChannel0, vec2( 0.0, 0.85 ) ).x;\n    // Change this to a lower number if there is too much distortion\n    wave *= 0.12;\n    \n    float r = 1.0 + 0.15 * cos( 5.0 * atan( p.x, p.y ) ) + 0.4 * p.z;\n    \n    float t = fbm( p + wave + ( iTime * 0.5 ) - r );;\n    \n    float plane = p.y + 1.8;\n    \n    float sphere = length( p ) - ( 2.0 * t );\n    \n    if( plane < sphere ) sphere = plane;\n    \n    return sphere;\n    \n}\n\nvec3 grad( vec3 p )\n{\n    \n    vec2 e = vec2( 0.0, EPS );\n    vec3 n = vec3( map( p + e.yxx ) - map( p - e.yxx ),\n                   map( p + e.xyx ) - map( p - e.xyx ),\n                   map( p + e.xxy ) - map( p - e.xxy )\n     \t\t\t\t);\n    return n;\n\n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n    float res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n        \n        float h = map( ro + rd * t );\n        \n        if( h < 0.001 ) return 0.0;\n        res = min( res, 4.0 * h / t );\n        t += h;\n    \n    }\n    \n    return res;\n    \n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(map( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvec3 shade( vec3 ro, vec3 rd, float t )\n{\n\n\tvec3 pos = ro + rd * t;\n    vec3 n = normalize( grad( pos ) );\n    \n    vec3 lig = normalize( vec3( 1.0, 0.8, 0.6 ) );\n    vec3 blig = vec3( -lig.x, -lig.y, -lig.z );\n    vec3 ref = reflect( rd, n );\n    \n    // AO from XT95 at: https://www.shadertoy.com/view/4sdGWN \n    \n    float a = ambientOcclusion( pos, n, 4.0, 2.0 );\n    float dif = max( 0.0, dot( n, lig ) );\n    float con = 1.0;\n    float sha = softShadows( pos, lig );\n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 16.0 );\n    float amb = 0.5 + 0.5 * n.y;\n    float bac = max( 0.0, 0.2 + 0.8 * dot( n, blig ) );\n    float rim = pow( 1.0 + dot(n, rd), 2.0 );\n    \n    vec3 col = con * vec3( 0.1, 0.15, 0.2 );\n    col += amb * vec3( 0.1, 0.15, 0.2 );\n    col += dif * vec3( 1.0, 0.97, 0.85 ) * sha;\n    col += bac * vec3( 1.0, 0.97, 0.85 ) * bac;\n    \n    col = sqrt( col );\n    col *= 0.6;\n    \n    if( pos.y > -1.79 )\n    {\n    \n    \tcol *= flowerMaterial( pos, n );\n        \n    }\n    \n    else\n    \n    {\n    \n        vec3 x = texture( iChannel1, pos.xz, 1.0 ).xyz;\n        col *= x;\n    }\n    \n    col += 0.1 * rim;\n    col += 1.0 * spe;\n    col *= a;\n    \n    return col;\n \n}\n\n// Camera taken from symbol of chaos by lsdlive https://www.shadertoy.com/view/4stczB\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 mouse = iMouse / iResolution.xyxy;\n    \n    float dt = iTime * .3;\n\tvec3 ro = vec3( 2.5 * cos(dt), 1.0, -2.5 * sin(dt));\n    vec3 ta = vec3(0, 0, 0);\n\tvec3 rd;\n\n\trd = camera(ro, uv, ta);\n\n    float t = 0.0; float d = EPS;\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        d = 0.5 * map( ro + rd * t );\n        \n        if( d < EPS || t > FAR ) break;\n        \n        t += d;\n        \n    }\n    \n    // Time varying pixel color\n    vec3 col;\n    \n    if( d < EPS )\n    {\n    \n        col = shade( ro, rd, t );\n        \n    }\n    else\n    {\n        col = mix( vec3( 0.1, 0.10, 0.2 ), vec3( 0.3, 0.2, 0.1 ), uv.y );\n    \n    }\n\n    // Output to screen\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Ms2XD1", "previewfilepath": "https://soundcloud.com/shponglemusic/how-the-jellyfish-jumped-up", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/shponglemusic/how-the-jellyfish-jumped-up", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscyzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 252, 275, 275, 325], [327, 327, 353, 353, 969], [971, 971, 995, 995, 1228], [1230, 1230, 1279, 1279, 1535], [1537, 1537, 1558, 1558, 2002], [2004, 2004, 2025, 2025, 2257], [2259, 2259, 2304, 2304, 2557], [2559, 2559, 2591, 2591, 2694], [2696, 2696, 2741, 2741, 2833], [2835, 2835, 2919, 2919, 3463], [3465, 3465, 3506, 3506, 4660], [4749, 4749, 4789, 4789, 4938], [4940, 4940, 4997, 5047, 5866]], "test": "error"}
{"id": "Xsdczl", "name": "Twisted Ladder 2", "author": "dr2", "description": "Animated version \"Twisted Ladder\" (mouseable)\niapafoto got me thinking about animation, but this differs from his suggestion", "tags": ["mobius", "animation", "symmetry", "trefoil"], "likes": 12, "viewed": 2253, "published": "Public API", "date": "1519833396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Twisted Ladder 2\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 qHit;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a, r, ns, aa;\n  r = 3.5;\n  ns = 32.;\n  dMin = dstFar;\n  aa = 2. * pi * mod (0.05 * tCur, 1.);\n  q = p;\n  a = atan (q.z, q.x);\n  q.xz = vec2 (length (q.xz) - r, q.y);\n  q.xz = Rot2D (q.xz, 1.5 * a);\n  q.xz = Rot2D (q.xz, - pi * (floor (atan (q.z, q.x) / pi + 0.5)));\n  q.x -= 1.;\n  q.y = a - aa;\n  d = length (PrBox2Df (q.xz, vec2 (0.3))) - 0.05;\n  DMINQ (1);\n  q = p;\n  q.xz = Rot2D (q.xz, aa);\n  a = atan (q.z, - q.x) / (2. * pi);\n  a = 2. * pi * (floor (ns * a) + 0.5) / ns;\n  q.xz = Rot2D (q.xz, a);\n  q.x += r;\n  q.xy = Rot2D (q.xy, 1.5 * (a + aa));\n  d = PrRoundCylDf (q.xzy, 0.2, 0.02, 1.45);\n  DMINQ (2);\n  return 0.4 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  return vec3 (0.6, 1., 0.6) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj;\n  col = BgCol (rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (dot (rd, vn) < -0.001) col = BgCol (reflect (rd, vn));\n    if (idObj == 1) {\n      col *= vec3 (1., 1., 0.9) * (0.95 + 0.05 * cos (8. * pi * qHit.z)) *\n         mix (1., 0.9 + 0.1 * cos (32. * qHit.y), step (abs (qHit.x), 0.29));\n    }\n    else if (idObj == 2) col *= vec3 (1., 0.9, 0.9) * mix (1., 0.95 +\n       0.05 * cos (16. * atan (qHit.z, - qHit.x)), step (abs (qHit.y), 1.44));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.5 * pi;\n  el = -0.3 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.3 * pi * sin (0.025 * pi * tCur);\n  }\n  el = clamp (el, -0.5 * pi, 0.5 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -20.);\n  zmFac = 4.8 - abs (el);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 40.;\n  col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col *= mix (0.8, 1., pow (1. - 0.5 * length (uvs * uvs), 4.));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsdczl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[385, 385, 407, 407, 1069], [1071, 1071, 1104, 1104, 1281], [1283, 1283, 1304, 1304, 1504], [1506, 1506, 1528, 1528, 1605], [1607, 1607, 1642, 1642, 2220], [2222, 2222, 2278, 2278, 3254], [3256, 3256, 3289, 3289, 3378], [3380, 3380, 3437, 3437, 3601], [3603, 3603, 3633, 3633, 3691]], "test": "valid"}
{"id": "Xsdczr", "name": "Cayley graph of F_2", "author": "phi16", "description": "[url]https://commons.wikimedia.org/wiki/File:Cayley_graph_of_F2.svg[/url]", "tags": ["2d", "fractal"], "likes": 27, "viewed": 855, "published": "Public API", "date": "1517807188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float w() {\n\treturn 1./iResolution.y;\n}\n\nvoid tree( vec2 pos, float len, inout vec4 color) {\n    for(int i=0;i<9;i++) {\n        color *= smoothstep(-0.1, 0.1, (length(pos) - len*0.08) * 100.);\n        color *= max(\n            smoothstep(-0.1,0.1,(abs(pos.y)-w()) * 100.), \n            sign(abs(pos.x-len/2.)-len/2.)*0.5+0.5\n    \t);\n        pos.x -= len;\n        if(pos.y > 0. && pos.x < pos.y) pos *= mat2(0,1,-1,0);\n        else if(pos.y < 0. && pos.x < -pos.y) pos *= mat2(0,-1,1,0);\n        len *= 0.48;\n    }\n}\nvoid three( vec2 pos, float len, inout vec4 color) {\n\ttree(pos, len, color);\n\ttree(pos.yx, len, color);\n\ttree(-pos.yx, len, color);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat dir(float t) {\n    float orig = floor(rand(vec2(t,0.)) * 4.);\n    float prev = floor(rand(vec2(t-1.,0.)) * 4.);\n    float next = floor(rand(vec2(t+1.,0.)) * 4.);\n    if(mod(t,2.) < 0.5) {\n        // do not back\n        for(int i=0;i<4;i++) {\n            if(orig==prev || orig==next) orig = mod(orig+1., 4.);\n        }\n    }\n    return orig;\n}\n\nvec4 image(vec2 pos, float time) {\n    vec4 color = vec4(1.0);\n    float ratio = smoothstep(0.,1.,mod(time,1.));\n    float a = (dir(floor(time)) + mod(floor(time),2.) * 2.) * 3.1415926535/2.;\n    pos *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    float s1 = mix(1.,0.48,1.-pow(1.-ratio,1.5));\n    float s2 = mix(1.,0.48,1.-pow(ratio,1.5));\n    three(pos - vec2(0.4*ratio, 0.), 0.4*s1, color);\n    three(-pos - vec2(0.4*(1.-ratio), 0.), 0.4*s2, color);\n    color = min(color, max(\n        smoothstep(-0.1, 0.1, (abs(pos.y)-w()) * 100.),\n        smoothstep(-0.1, 0.1, (abs(-pos.x)-0.8/2.) * 100.)\n\t));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    fragColor = image(pos, iTime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsdczr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 11, 11, 39], [41, 41, 92, 92, 515], [516, 516, 568, 568, 649], [650, 650, 670, 670, 742], [743, 743, 763, 763, 1091], [1093, 1093, 1127, 1127, 1708], [1710, 1710, 1767, 1767, 1864]], "test": "valid"}
{"id": "XsdyRM", "name": "And now something completely ...", "author": "samuelotherion", "description": "nearly mandel2018\nusing dFdx, dFdy instead of a texture", "tags": ["mandelbrotset"], "likes": 3, "viewed": 147, "published": "Public", "date": "1518210423", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define mi 256.\n\nfloat\nmb( vec2 c, float r2 ) {\n\n    vec2\n    z = c,\n    d = z * z;\n    \n    for( float i = 0.; i < mi; ++ i ) {\n        \n        if( r2 < d.x + d.y )\n            \n            return i;\n\n        z = vec2( d.x - d.y, 2. * z.x * z.y ) - c;\n        \n        d = z * z;\n    }\n    \n    return mi;\n}\n\nvoid\nmainImage( out vec4 o, in vec2 i ) {\n\n    float\n    c = cos( .3 * iTime ),\n    s = sin( 2.115 * iTime );\n    \n    mat2\n\tr = mat2( c, -s, s, c );\n    \n    c = log2( mb( vec2( 1.39005, 0.114548 ) + ( 2. * i.xy / iResolution.xy - 1. ) * vec2( iResolution.x / iResolution.y, 1. ) * 10. * r * pow( 1e-6, ( .5 + .5 * sin( .2 * iTime ) ) ), mi * .1 * ( 1. + sin( 3. * iTime ) * cos( .5 * iTime ) ) ) ) * 64.,\n    s = dot( sign( vec2( -dFdy( c ), dFdx( c ) ) ), vec2( 1. ) );\n    \n    o = vec4( clamp( .5 * ( s + 1. ) * ( c / mi ) * vec3( 1., .6, .4 ), 0., 1. ), 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdyRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 47, 47, 309], [311, 311, 352, 352, 878]], "test": "valid"}
{"id": "XstcRl", "name": "Drop pulse", "author": "Slaus", "description": "Like a drop", "tags": ["wave"], "likes": 0, "viewed": 66, "published": "Public", "date": "1519820739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Pi = 3.14159265359;\n\nfloat HERZ = 0.3;\nfloat SPEED = 6.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 b = texture(iChannel0, uv);\n    \n    \n    float l = length( uv - vec2( 0.5, 0.5 ) );\n    vec3 light = vec3( 0.0, 0.0, 0.0 );\n    if ( l * 2.0 < iTime )\n    {\n        light = mix(\n            light,\n            vec3( 0.28, 0.28, 0.28 ),\n            max( sin( l * Pi * 2.0 / HERZ - iTime * SPEED ), 0.0 )\n        );\n    }\n    \n    fragColor = vec4( b.rgb + light, 1.0 );\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstcRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 122, 122, 549]], "test": "error"}
{"id": "XstcRS", "name": "Gradient Perlin FBM 2D", "author": "Aethersong", "description": "Gradient Perlin FBM Noise\n\nLeft - No FBM\nRight - FBM", "tags": ["noise", "fbm", "perlin"], "likes": 2, "viewed": 157, "published": "Public", "date": "1519369626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// References\n// https://thebookofshaders.com/11/\n// https://thebookofshaders.com/13/\n// http://flafla2.github.io/2014/08/09/perlinnoise.html\n// http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch05.html\n// https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter26.html\n\n// Random\nvec2 Random2( vec2 xy )\n{\n    xy = vec2( dot( xy, vec2( 127.1, 311.7 ) ),\n              dot( xy, vec2( 269.5,183.3 ) ) );\n    \n    return -1.0 + 2.0 * fract( sin( xy ) * 43758.5453123 );\n}\n\n// Perlin Noise\nfloat Noise( vec2 xy )\n{\n    vec2 i = floor( xy );\n    vec2 f = fract( xy );\n          \n    // Cubic Hermine Curve ( Smoothstep( 0.0, 1.0, f )\n    //vec2 t = f * f * ( 3.0 - 2.0 * f );\n    \n    // Fifth Degree Interpolator\n    // Remove Artifacts ( eg. when bumpmapping )\n    vec2 t = f * f * f * ( f * ( f * 6.0 - 15.0 ) + 10.0 ); \n    \n    // Four Gradients of 2D Tile\n    vec2 g1 = Random2( i + vec2( 0.0, 0.0 ) );\n    vec2 g2 = Random2( i + vec2( 1.0, 0.0 ) );\n    vec2 g3 = Random2( i + vec2( 0.0, 1.0 ) );\n    vec2 g4 = Random2( i + vec2( 1.0, 1.0 ) );\n\n    \n    // Calculate Influence Values\n    // ( Influence Value is Dot between Gradient and Distance Vec )\n    float iv1 = dot( g1, f - vec2( 0.0, 0.0 ) );\n    float iv2 = dot( g2, f - vec2( 1.0, 0.0 ) );\n    float iv3 = dot( g3, f - vec2( 0.0, 1.0 ) );\n    float iv4 = dot( g4, f - vec2( 1.0, 1.0 ) );\n    \n    // Interpolate Between Influence Values\n    return( mix( mix( iv1, iv2, t.x ), mix( iv3, iv4, t.x ), t.y ) );\n}\n\n// FBM\nfloat FBM( vec2 xy )\n{\n    // Step Propertiees\n    const int OCTAVES = 4;\t\t// Number of Steps\n    float lacunarity = 2.0;\t\t// Affects Frequency ( x > 1.0, increases noise )\n\tfloat gain = 0.5;\t\t\t// Affects Amplitude ( x < 1.0, blurs )\n    \n    // Initial Values\n    float value = 0.0;\n    float amplitude = 1.5;\n    float frequency = 1.0;\n    \n    // FBM Loop\n    for( int i = 0; i < OCTAVES; i++ )\n    {\n        value += amplitude * Noise( xy * frequency );\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    value = clamp( value, -1.0, 1.0 );\n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;   \n    vec3 col = vec3( 0.0 );\n    vec2 tileCount = vec2( 10.0, 10.0 );\n    vec2 noisePos = ( uv * vec2( aspectRatio, 1.0 ) + vec2( iTime * 0.05, 0.0 ) ) * tileCount;\n\n    // Left ( Standard Perlin Noise )\n    if( uv.x < 0.5 )\n    \tcol = vec3( Noise( noisePos ) * 0.5 + 0.5 );\n    \n    // Right ( Perlin FBM Noise )\n    else\n    \tcol = vec3( FBM( noisePos ) * 0.5 + 0.5 );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstcRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 303, 328, 328, 491], [493, 509, 533, 533, 1492], [1494, 1501, 1523, 1547, 2088], [2091, 2091, 2148, 2198, 2731]], "test": "valid"}
{"id": "Xstcz4", "name": "Cut cube", "author": "sidsuk", "description": "cut cube, case study, CIS566\nanimation reference: https://camo.githubusercontent.com/4f8139b56f24036d9273eafebd71fae2bf95e7df/68747470733a2f2f692e696d6775722e636f6d2f735a61325050492e676966", "tags": ["raymarching"], "likes": 10, "viewed": 180, "published": "Public", "date": "1518132222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// CIS566 cut cube\n/// SDF reference: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define DEPTH 30\n#define END 1000.0\n#define EPSILON 0.0075\n#define EPSILON2 0.0005\n#define PI 3.14159265359\n\n#define WIREFRAME\n\n\n// signed distance function of cube\n\nvec2 unionSDF(vec2 v1, vec2 v2) {\n    if(v1.x < v2.x) {\n        return v1;\n    } else {\n        return v2;\n    }\n}\n\n\nvec2 boxSDF(vec3 p, vec3 b) {\n    p /= 1.5;\n    //b /= 1.5;\n    vec3 d = abs(p) - b;\n  \tfloat dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    \n    float e = 0.0;\n    \n    float c1 = step(b.x - EPSILON, abs(p.x));\n    float c2 = step(b.y - EPSILON, abs(p.y));\n    float c3 = step(b.z - EPSILON, abs(p.z));\n    \n    if(c1 + c2 + c3 > 1.5)\n    {\n        e = 1.0;\n    }    \n    dist *= 1.5;\n    return vec2(dist, e);\n}\n\n\nmat4 rotate(vec3 axis, float angle) {\n    axis = normalize(axis);\n    angle = radians(angle);\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n    \n    return transpose(mat4(\n        t * pow(axis.x, 2.0) + c, t * axis.x * axis.y - s * axis.z, t * axis.x * axis.z + s * axis.y, 0.0,\n        t * axis.x * axis.y + s * axis.z, t * pow(axis.y, 2.0), t * axis.y * axis.z - s * axis.x, 0.0,\n        t * axis.x * axis.z - s * axis.y, t * axis.y * axis.z + s * axis.x, t * pow(axis.z, 2.0), 0.0,\n        0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 rotateY(float a) {\n    float c = cos(radians(a));\n    float s = sin(radians(a));\n    return mat4(\n        c, 0.0, -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        s, 0.0, c, 0.0,\n        0.0, 0.0, 0.0, 1.0);  \n}\n\nmat4 rotateX(float t) {\n\tfloat cost = cos(radians(t));\n\tfloat sint = sin(radians(t));\n\treturn mat4(\n\t\t1.0, 0.0, 0.0, 0.0,   // first column\n\t\t0.0, cost, sint, 0.0, // second column\n\t\t0.0, -sint, cost, 0.0, // third column\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n}\n\nmat4 rotateZ(float t) {\n\tfloat cost = cos(radians(t));\n\tfloat sint = sin(radians(t));\n\treturn mat4(\n\t\tcost, sint, 0.0, 0.0,   // first column\n\t\t-sint, cost, 0.0, 0.0, // second column\n\t\t0.0, 0.0, 1.0, 0.0, // third column\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n}\n\nmat4 translate(vec3 t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        t.x, t.y, t.z, 1.0\n        );\n}\n\n\n// scene builder\nvec2 scene(vec3 p) {\n    \n    float offset = floor(0.75 * iTime) + max(0.0, 4.0 * fract(0.75 * iTime) - 3.0);\n    \n    mat4 m1 = rotateY(45.0 + offset * 90.0);\n    vec3 p1 = vec3(inverse(m1) * vec4(p, 1.0));\n    \n    vec2 dist = boxSDF(p1, vec3(0.1, 0.1, 0.1));\n    \n    mat4 m2 = rotateY(45.0) * translate(vec3(0.0, 0.0, 0.3));\n    vec3 p2 = vec3(inverse(m2) * vec4(p, 1.0));\n    \n    float bounce = 0.075 * pow(sin(iTime * PI * 2.0 * 0.75) + 1.0, 1.0 / 3.0);\n    \n    int num = 6;\n    \n    for(int i = 0; i < num; ++i) {\n        for(int j = 0; j < 6; ++j) {\n            \n            float lag = float(i) / 10.0;\n            \n            offset = floor(0.75 * (iTime - lag)) + max(0.0, 4.0 * fract(0.75 * (iTime - lag)) - 3.0) + floor(0.75 * lag);\n            \n            m1 = rotateY(45.0 + 90.0 * offset);\n            \n            mat4 rotation;\n            if(j < 4) {\n                float angle = 90.0 * float(j);\n                rotation = rotateY(angle);\n            } else if(j == 4) {\n                float angle = -90.0;\n                rotation = rotateX(angle);\n            } else {\n                float angle = 90.0;\n                rotation = rotateX(angle);\n            }\n                \n            rotation = m1 * rotation;\n\n            vec3 trans = vec3(0.0, 0.0, 0.3 + pow(float(i), 1.0 / 1.5) * 0.2 + bounce);\n\n            mat4 transform = rotation * translate(trans);\n\n            vec3 pos = vec3(inverse(transform) * vec4(p, 1.0));\n\n            vec2 d = boxSDF(pos, vec3(0.1, 0.1, 0.001));\n\n            dist = unionSDF(dist, d);\n                                 \n        }\n    }\n\n    return dist;\n}\n\nvec2 rayMarching(vec3 origin, vec3 dir, float start) {\n    float t = start;\n\tfor(int i = 0; i < DEPTH; ++i) {\n\t\tvec3 curP = origin + dir * t;\n\t\tvec2 step = scene(curP);\n\t\tt += step.x;\n\t\tif(step.x < EPSILON2) {\n\t\t\treturn vec2(t, step.y);\n\t\t}\n\t\tif(t >= END){\n\t\t\treturn vec2(END, 0.0);\n\t\t}\t\n\t}\n\treturn vec2(END, 0.0);\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON2, p.y, p.z)).x - scene(vec3(p.x - EPSILON2, p.y, p.z)).x,\n\t\tscene(vec3(p.x, p.y + EPSILON2, p.z)).x - scene(vec3(p.x, p.y - EPSILON2, p.z)).x,\n\t\tscene(vec3(p.x, p.y, p.z + EPSILON2)).x - scene(vec3(p.x, p.y, p.z - EPSILON2)).x\n\t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 spos = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0.0, 5.0, 8.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 dir = normalize(target - eye);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(dir, up);\n    up = cross(right, dir);\n    \n    vec3 lightpos = vec3(0.0, 2.0, 1.0);\n    \n    vec3 pos = eye + right * spos.x + up * spos.y;\n    \n    vec2 final_t = rayMarching(pos, dir, 0.001);\n    \n    if(final_t.x > END) {\n        fragColor = vec4(0.0);\n        return;\n    } \n    \n    #ifdef WIREFRAME\n    fragColor = vec4(vec3(final_t.y), 1.0);\n    #endif\n    \n    #ifndef WIREFRAME\n    vec3 intersection = pos + final_t.x * dir;\n    vec3 normal = getNormal(intersection);\n    float diffuse = dot(normalize(lightpos - intersection),normal);\n    fragColor = vec4(vec3(diffuse), 1.0);\n    #endif\n    \n      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xstcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 310, 310, 391], [394, 394, 423, 423, 824], [827, 827, 864, 864, 1372], [1374, 1374, 1397, 1397, 1586], [1588, 1588, 1611, 1611, 1836], [1838, 1838, 1861, 1861, 2086], [2088, 2088, 2112, 2112, 2253], [2256, 2273, 2293, 2293, 3897], [3899, 3899, 3953, 3953, 4215], [4217, 4217, 4241, 4241, 4535], [4538, 4538, 4595, 4595, 5448]], "test": "error"}
{"id": "XstyDN", "name": "Xorshift White Noise", "author": "surma", "description": "Xorshift RNG to produce (mediocre) white noise", "tags": ["xorshifthashrand"], "likes": 6, "viewed": 303, "published": "Public", "date": "1518974162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uint rngstate = uint(0);\n\n//#define BLACK_AND_WHITE\n\nuint randInt() {\n    rngstate ^= rngstate << 13;\n    rngstate ^= rngstate >> 17;\n\trngstate ^= rngstate << 5;\n    return rngstate;\n}\n\nvoid setSeed(uint seed) {\n    rngstate = seed;\n    randInt(); randInt(); randInt(); // Shift some bits around\n}\n\nfloat randFloat() {\n    return fract(float(randInt()) / float(1<<32 - 5));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    setSeed(uint(fragCoord.y * iResolution.x + fragCoord.x));\n    setSeed(randInt() + uint(floor(iTime*10000.0)));\n\n    // Time varying pixel color\n    \n    #ifdef BLACK_AND_WHITE\n    \tvec3 col = vec3(randFloat());\n    #else\n    \tvec3 col = vec3(randFloat(), randFloat(), randFloat());\n    #endif\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstyDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 69, 69, 184], [186, 186, 211, 211, 297], [299, 299, 318, 318, 375], [377, 377, 432, 432, 768]], "test": "valid"}
{"id": "Xstyz8", "name": "spindle of death", "author": "fivertrial", "description": "Finished", "tags": ["raymarching"], "likes": 5, "viewed": 108, "published": "Public", "date": "1517955355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define Epsilon 0.0001\n\n// rotation\nvec2 r(vec2 v, float y){\n    return cos(y)*v + sin(y)*vec2(-v.y, v.x);\n}\n\nfloat sdSphere(vec3 p, float s){\n  return length(p)-s;\n}\n\n//Torus - signed - exact\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 smin(vec2 a, vec2 b){\n\tif(a.x < b.x)\n        return a;\n    else\n        return b;\n}\n\nvec2 map( vec3 p ){  \n    //p.xy = r(p.xy, PI*0.5);\n    //p.xz = r(p.xz, PI*0.5);\n    float dt = max(0.0, fract(iTime*0.5)*4.0-3.0) + floor(iTime*0.5);\n    p.yz = r(p.yz, dt*PI*0.5);\n    vec3 q = p;\n    q.xy = r(q.xy, PI*0.5);\n    vec2 d = vec2(100.0, 10.0);\n    for (int i = 0; i < 8; i++){\n    \tq.yz = r(q.yz, PI/8.0*float(i));\n        d = smin(d, vec2(sdTorus(q, vec2(6.0, 0.05)), 0.0));\n    }\n    for (int i = 0; i < 8; i++){\n        float t = PI*iTime*1.25 + 0.125*PI*float(i);\n\t\tq = p;\n        q.xz = r(q.xz, 0.125*PI*float(i));\n        q.yz -= 6.0 * vec2(cos(t), sin(t));\n    \td = smin(d, vec2(sdSphere(q, 0.35), 1.0));\n    }\n    return d;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 colorize(float index){\n    // Black\n    if (index == 0.0)\n        return vec3(0.1, 0.1, 0.1);\n    // Light yellow\n    if (index == 1.0)\n        return vec3(1.0,1.0,0.9);\n    // Brown\n    if (index == 2.0)\n        return vec3(0.54, 0.27, 0.075);\n    // Green\n    if (index == 3.0)\n        return vec3(0.5, 0.8, 0.6);\n    // Dark yellow\n    if (index == 4.0)\n        return vec3(0.3, 0.3, 0);\n    // Red\n    if (index == 5.0)\n        return vec3(1.0, 0.2, 0.3);\n    // Pink\n    if (index == 6.0)\n        return vec3(1.0, 0.78, 0.8);\n    // White\n    if (index == 9.0)\n        return vec3(0.95, 0.95, 0.95);\n    \n    return vec3(index / 10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p = vec3((fragCoord.xy / iResolution.xy - 0.5), 10.0);\n    //float vignette = 1.0 - length(q.xy);\n    p.x *= iResolution.x / iResolution.y;\n    p.xy *= 15.0;\n    p.z += 20.0;\n    //q.y -= 0.25;\n    vec3 q = vec3(0.0, 0.0, -1.0);\n    fragColor = vec4(1.0, 0.5, 0.0, 1.0);\n    q = normalize(q);\n    //q.xz = r(q.xz, u_Time * 0.1);\n    //p.y += 1.25;\n    //p.x -= 1.3;\n    //p.z -= 0.5;\n\n    float t = 0.0;\n    // d.x: distance; d.y: colorize\n    vec2 d = vec2(0.0);\n    const float maxSteps = 256.0;\n    // Ray Marching\n    for (float tt = 0.0; tt < maxSteps; ++tt){\n        d = map(p + q*t);\n        t += d.x*0.45;\n        if(!(t<=50.0) || d.x <= Epsilon)\n            break;\n    }\n\n    vec3 fog = vec3(0.7, 0.75, 0.8);\n    vec3 color = fog;\n\n    vec3 ldir = normalize(vec3(1.0, 0.75, -1.0));\n    vec3 hit = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    float fao = 1.0;\n    // inside view distance\n    if (t <= 50.0){\n        hit = p + q*t;\n\n        vec3 light = colorize(d.y);\n        // rim\n        color = min(vec3(1.0), light);\n    }\n    // contrast\n    color = smoothstep(0.0, 1.0, color); \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xstyz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 57, 81, 81, 129], [131, 131, 163, 163, 187], [189, 214, 247, 247, 312], [314, 314, 340, 340, 402], [404, 404, 423, 485, 1052], [1055, 1055, 1087, 1087, 1295], [1297, 1297, 1324, 1337, 1944], [1946, 1946, 2003, 2003, 3141]], "test": "valid"}
{"id": "Xstyzn", "name": "GranTurismo tone mapper", "author": "meshula", "description": "An implementation of the Gran Turismo tone mapper, as described here https://www.desmos.com/calculator/gslcdxvipg", "tags": ["hdr", "tonemapping", "tonemapper", "granturismo"], "likes": 6, "viewed": 1078, "published": "Public", "date": "1517778619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// GT Tonemap\n// Copyright(c) 2017 by Hajime Uchimura @ Polyphony Digital Inc.\n// Translated to GLSL by Nick Porcino from\n// Romain Guy's translation of https://www.desmos.com/calculator/gslcdxvipg\n// merged with lots of stuff from\n// Timothy Lotte's shader - https://www.shadertoy.com/view/XljBRK\n// original presentation here - https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n\n#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nF1 w(F1 x, F1 e0, F1 e1)\n{\n    if (x <= e0) return 0.0;\n    if (x >= e1) return 1.0;\n    F1 m = (x-e0)/(e1-e0);\n    return m * m * 3.0 - 2.0 * m;\n}\nF3 w3(F3 x, F3 e0, F3 e1) { return F3(w(x.x, e0.x, e1.x),\n                                      w(x.y, e0.y, e1.y),\n                                      w(x.z, e0.z, e1.z));}\nF3 Hue(F1 n){return clamp(F3(\n abs(fract(n)-0.5)*(-6.0)+2.0,\n abs(fract(n+(1.0/3.0))-0.5)*(-6.0)+2.0,\n abs(fract(n-(1.0/3.0))-0.5)*(-6.0)+2.0),F3(0.0),F3(1.0));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // these parameters would be uniforms\n    //\n    // Maximum brightness, 1 .. 100\n    float P_in = 1.0;\n    \n    // Contrast 1 .. 5\n    float a_in = 1.0;\n    \n    // Linear section start 0 .. 1\n    float m_in = 0.4;\n    \n    // Linear section length 0 .. 1\n    float l_in = 0.24;\n    \n    // Black tightness 1 .. 3, 0 .. 1\n    float c_in = 1.33;\n    float b_in = 0.0;\n    //\n    // end of parameters section\n    \n    vec4 P = vec4(P_in);\n    vec4 a = vec4(a_in);\n    vec4 m = vec4(m_in);\n    vec4 l = vec4(l_in);\n    vec4 c = vec4(c_in);\n    vec4 b = vec4(b_in);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 x = texture(iChannel0, uv * 3.0);\n \tx.rgb=Linear3(x.rgb) * 0.5;\n\n    // swatches from Timothy Lotte's shader - https://www.shadertoy.com/view/XljBRK\n \n #if 1\n  // Add colored gradients\n  F3 bars=Hue(uv.y/(5.0/8.0))*2.0;   \n  x.xyz+=bars*bars*(uv.x*uv.x*uv.x*uv.x*uv.x);\n #endif\n    #if 1\n    float fy = 1.0-uv.y;\n  // Draw swatches\n  if(fy>7.0/8.0){\n   x.b=fract(uv.x*8.0);\n   x.r=1.0-fract(fy*8.0);\n   x.g=floor(uv.x*8.0)/8.0;\n   x.rgb=Linear3(x.rgb);}\n  else if(fy>6.0/8.0){\n   x.r=fract(uv.x*8.0);\n   x.g=1.0-fract(fy*8.0);\n   x.b=floor(uv.x*8.0)/8.0;\n   x.rgb=Linear3(x.rgb);}\n  else if(fy>5.0/8.0){\n   x.g=fract(uv.x*8.0);\n   x.b=1.0-fract(fy*8.0);\n   x.r=floor(uv.x*8.0)/8.0;\n   x.rgb=Linear3(x.rgb);}\n#endif\n\n    x *= 4.0;\n     #if 1\n  // Fade in/out\n  x.rgb*=pow(abs(sin(fract(iTime/16.0)*3.14159*2.0)),2.2);    \n #endif\n\n\n    // Linear Region Computation\n    // l0 is the linear length after scale\n    vec4 l0 = ((P - m) / l) / a;\n    vec4 L0 = m - (m / a);\n    vec4 L1 = m + (l - m) / a;\n    vec4 Lx = m + a * (x - m);\n\n    // Toe\n    vec4 Tx = m * pow(x / m, c) + b;\n    \n    // Shoulder\n    vec4 S0 = m + l0;\n    vec4 S1 = m + a * l0;\n    vec4 C2 = (a * P) / (P - S1);\n    vec4 Sx = P - (P - S1) * exp(-(C2 * (x - S0) / P));\n    \n    // Toe weight\n    vec4 w0;\n    w0.xyz = w3(x.xyz, vec3(0.0), m.xyz);\n    w0 = vec4(1.0) - w0;\n\n    // Shoulder weight\n    vec4 w2 = smoothstep(m + l0, m + l0, x);\n    // Linear weight\n    vec4 w1 = vec4(1) - w0 - w2;\n    \n    x = Tx * w0 + Lx * w1 + Sx * w2;\n    x.rgb = Srgb3(x.rgb);\n\n    fragColor = x;\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xstyzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[428, 428, 445, 445, 498], [499, 499, 516, 516, 567], [568, 568, 583, 583, 639], [640, 640, 655, 655, 700], [702, 702, 728, 728, 849], [850, 850, 877, 877, 1025], [1026, 1026, 1039, 1039, 1187], [1189, 1189, 1246, 1331, 3469]], "test": "error"}
{"id": "Xt2BWd", "name": "Relativistic Light", "author": "Fra32", "description": "A shader simulating what it would look like if light moved a lot slower than usual.\nThe scene starts at a fairly high speed of light, but steadily decreases it until it is equal to the camera movement speed.", "tags": ["raymarching", "light"], "likes": 1, "viewed": 168, "published": "Public", "date": "1517588525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nUse the mouse to move the camera.\n\nAs the speed decreases, your Field of View starts to shift due to you \"catching up\" with light rays that would normaly move faster\nthan you. This eventually causes the area behind you to fade out while everything else is shifted forwards.\n\nDue to the light intensity shifting as you get closer to the speed of light, light in front of you is perceived more bright while\nlight behind you fades to black. This is called the Searchlight Effect.\n\nAnother effect caused by this is the change in light frequency's. At normal speed, the spheres change betwee red and blue color,\nbut as light gets slower, black seems to appear inbetween too. I simulated this in a primitive way by using the color hue as an\nalternative for the frequency. Light in front of you get's blueshift, which causes the rainbow colors to fade to blue and then\nto ultraviolet, leaving only the originally red light as short blue pulses. Similarly, light behind you get's redshift before\nfading out.\n\nThe final effect is Time Dillation. The slower light get's, the more time it requires to reach an object. This causes the\nsynchronized pulses to appear delayed. Time in front of you seems to pass twice as fast at slow speed of light, while it doesn't\nseem to pass at all behind you.\n\nUses Raymarching to render the spheres and manipulates the image depending on the current speed of light.\n*/\n\nfloat pi = 3.14159267378979;\nfloat light = 1000.;\n\nstruct ray{vec3 o; vec3 d;};\n\n//The hue-color function, offset depending on RGB component\nfloat h2col(float h, float col)\n{\n\th=h+1./3.-col/3.;\n    float val;\n    if(h<=0.)\n    val = 0.;\n    else if(h<=1./6.){  \n        val = h*6.;\n        if(col==0.)val = 0.;\n    }\n    else if(h<=1./2.){\n        val = 1.;\n        if(col==0.&& h <= 1./3.)val = h*6.-1.;\n        if(col==2.&& h >= 1./3.)val = 1.-(h-1./3.)*6.;\n    }\n    else if(h<=2./3.){\n        val = 4.-h*6.;\n        if(col==2.)val = 0.;\n    }\n    else val = 0.;\n    return val;\n}\n\nvec3 hsv2rgb(vec3 col)\n{\n    float r = h2col(col.x,0.);\n    float g = h2col(col.x,1.);\n    float b = h2col(col.x,2.);\n    float s = col.y;\n    float v = col.z;\n    return v*vec3((r-1.)*s+1.,(g-1.)*s+1.,(b-1.)*s+1.);\n}\n\n\nvec3 loop(vec3 p)\n{\n return vec3(\nmod(p.x+2.,4.)-2., \nmod(p.y+2.,4.)-2.,\nmod(p.z+2.,4.)-2.);\n}\n\nfloat sphere(vec3 p, vec3 o, float r)\n{\n return distance(o,p)-r;   \n}\n\n\nfloat sdf(vec3 o)\n{ \t\n    vec3 b1s = vec3(1,1,1);\n \treturn sphere(o,vec3(0),.5);\n}\n\nvoid rotX(inout vec3 p, float a)\n{\n    p = vec3(p.x,p.y*cos(a)-p.z*sin(a),p.y*sin(a)+p.z*cos(a));\n}\n\nvoid rotY(inout vec3 p, float a)\n{\n    p = vec3(p.x*cos(a)-p.z*sin(a),p.y,p.x*sin(a)+p.z*cos(a));\n}\n\nvoid rotZ(inout vec3 p, float a)\n{\n    p = vec3(p.x*cos(a)-p.y*sin(a),p.x*sin(a)+p.y*cos(a),p.z);\n}\n\nvoid rotX(inout ray r, float a)\n{\n    rotX(r.o,a);\n    rotX(r.d,a);\n}\nvoid rotY(inout ray r, float a)\n{\n    rotY(r.o,a);\n    rotY(r.d,a);\n}\nvoid rotZ(inout ray r, float a)\n{\n    rotZ(r.o,a);\n    rotZ(r.d,a);\n}\n\n\nfloat sqr(float a){\n    return pow(a,2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    //Defining the camera movement and the speed of light depending on time\n    float mvs = 4.;\n    vec3 mvdir = vec3(0,0,mvs);\n    light = mvs+2000./pow(2.,iTime/2.);\n    \n    //Setting up the camera rays\n\tvec2 uv = fragCoord.xy / iResolution.xy-vec2(.5);\n    ray r = ray(vec3(0),normalize(vec3(uv,1)));\n    \n    vec2 mouse = iMouse.xy/iResolution.xy-vec2(.5);\n    float mlen = length(mouse);\n    mouse = normalize(mouse)*2.;\n    \n    rotX(r,-mouse.y*sqr(mlen)*pi*2.);\n    rotY(r,-mouse.x*sqr(mlen)*pi*2.);\n    r.o = loop(r.o+mvdir*iTime) + vec3(2,2,0);\n    \n    //Reference value for evaluating distances\n    vec3 campos = r.o;\n    \n    //Calculating the FoV manipulation caused by relativistic speeds. As you get faster, more and more light from behind you reaches your eye.\n    float x = -length(r.d.xy);\n    float y = -r.d.z;\n    float a = (sqrt(sqr(light)+sqr(mvs*y/light)-sqr(mvs))-mvs*y/light)*light;\n    \n    //Overriding the ray direction\n    r.d = r.d*a-mvdir;\n    r.d = normalize(r.d);\n    \n    //Intensity at which the light hit's the camera. Increases in front of you, decreases behind you.\n    float li = length(r.d+mvdir/light);\n    \n    //Performing the raymarch\n    for(int i=0;i<200;i++)\n    {\n        float d = sdf(loop(r.o));\n        if(d<.001 || length(r.o-campos)>200.) break; \n     \tr.o += r.d*d;\n    }\n    \n    //Calculating the time the light takes to reach the camera.\n    float timeDil = distance(campos,r.o)/light;\n    \n    //A primitive modelling of light frequencys. Spheres simultaneously shift from red to blue.\n    float h = 380. + (790.-380.)*(.5-.5*cos((iTime-timeDil)/1.5));\n    \n    //Implementation of the Doppler Effect. The faster light hit's you, the more blueshift it is, the slower it hit's you, the more redshift it is.\n    h /= li;\n    h = .7-.7*(h-380.)/(790.-380.);\n    \n    //Simple flat shading with distance fog\n    vec3 n = normalize(loop(r.o));\n    float angcos = dot(n,-r.d);\n    float colval = 1.-((1.-1./(1.+pow(distance(campos,r.o)/10.,2.))*angcos));\n    \n    //Applying the searchlight effect. Light in front of you gets brighter and dimmer behind you.\n    colval = (-1./(colval-1.)-1.)*li;\n    colval = 1.-1./(1.+colval);\n    \n    //Converting hue to RGB and calculating final color.\n    vec3 hue =hsv2rgb(vec3(h,1.,1.));\n    vec3 col = hue*colval;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2BWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1479, 1539, 1572, 1572, 1981], [1983, 1983, 2007, 2007, 2200], [2203, 2203, 2222, 2222, 2297], [2299, 2299, 2338, 2338, 2368], [2371, 2371, 2390, 2390, 2453], [2455, 2455, 2489, 2489, 2554], [2556, 2556, 2590, 2590, 2655], [2657, 2657, 2691, 2691, 2756], [2758, 2758, 2791, 2791, 2827], [2828, 2828, 2861, 2861, 2897], [2898, 2898, 2931, 2931, 2967], [2970, 2970, 2989, 2989, 3013], [3016, 3016, 3073, 3150, 5417]], "test": "error"}
{"id": "XtSBDd", "name": "Radar Example", "author": "jgkling", "description": "In class example\nReference: http://www.modejong.com/blog/post8_seamless_video_looping_on_ios/index.html", "tags": ["toolboxfunctions"], "likes": 2, "viewed": 206, "published": "Public", "date": "1517510591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scrPt = uv * 2.0 - 1.0; // Transform to NDC\n    scrPt.x *= iResolution.x / iResolution.y; // Account for aspect ratio\n    // The above is very explicitly written out.\n    // Fast way to get NDC is: vec2 scrPt = (2.*fragCoord - iResolution.xy )/ iResolution.y;\n    \n    // Create rotation matrix based on time\n    float theta = -iTime * 2.0 * 3.14159 - 2.2; // The 2.2 was visually tweaked, repeatedly guess values until it looks right :)\n    float cosTheta, sinTheta;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n    mat2 rot = mat2(cosTheta, -sinTheta, sinTheta, cosTheta);\n    \n    vec2 scrPtRot = rot * scrPt;\n    \n    // Parameterize radar shape\n    float angle = 1.0 - (atan(scrPtRot.y, scrPtRot.x) / 6.2831 + 0.5);\n    float falloff = 1.0 - length(scrPtRot);\n    \n    // Color accumulator\n    vec3 col = vec3(0);\n    \n    // Rings\n    float ringSpacing = 0.23;\n    if(mod(length(scrPtRot), ringSpacing) < 0.01 && length(scrPtRot) / ringSpacing < 5.0) {\n        col += vec3(0, 0.5, 0);\n    }\n    \n    // 2D SDF (you should actually use step()!) with color intensity function made in GraphToy (http://www.iquilezles.org/apps/graphtoy/)\n    if(length(scrPt - vec2(0.5, 0.5)) < 0.05) {\n        //col.r = 2.0 * max(0.0, fract(-iTime * 0.5) - 0.5); // Old function described in class\n        \n        // New way to animate the point! While the above function does work, it is difficult to make it\n        // visually align with the radar line. If we make the dot color a function of the angle, the blinking\n        // dot will match up perfectly. \n        col.r = angle * angle * angle; // Why angle^3? It makes the the dot's color intensity fall off faster.\n        // Try:\n        // col.r = angle;\n        // or\n        // col.r = pow(angle, 5.0);\n        // to see this in action. Keep in mind that angle is on the range [0, 1] when thinking about why this works!\n    }\n    \n    // Rings with no branching\n    col += vec3(0, 0.0, 0.8) * step(mod(length(scrPtRot), ringSpacing), 0.01) * step(length(scrPtRot), 1.0);\n    \n    float angleFalloff = pow(angle, 2.0); // try tweaking the exponent\n    fragColor = vec4(vec3(angleFalloff * falloff) * vec3(0, 1, 0) + col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSBDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2289]], "test": "valid"}
{"id": "XtSfWt", "name": "Poison Kaleidescope", "author": "104", "description": "playing around with squircles, negative space. been a long time since I shadertoy'd!", "tags": ["kaleidescopesquircle"], "likes": 10, "viewed": 235, "published": "Public", "date": "1517477582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdSquircle(vec2 uv, vec2 origin, float radius, float power, float rot_)\n{\n    float c = cos(rot_), s = sin(rot_);\n    mat2 rot = mat2(c,s,-s,c);    \n    vec2 v = abs((origin*rot) - (uv*rot));\n    float d = pow(v.x,power) + pow(v.y, power);\n    d -= pow(radius, power);\n    return d;\n}\nvec3 sdWhatever(vec2 uv, float r0, float r, float p, float t)\n{\n  float ab = 0.01;\n  return vec3(\n      sdSquircle(uv, uv+r0-mod(uv,r0*2.), r-ab, p+ab, t+ab),\n      sdSquircle(uv, uv+r0-mod(uv,r0*2.), r, p, t),\n      sdSquircle(uv, uv+r0-mod(uv,r0*2.), r+ab, p+ab, t+ab)\n             );\n}\n\nfloat rand(vec2 co)\n{\n   return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\nvoid mainImage(out vec4 o, in vec2 uvo)\n{\n   \tvec2 uv = uvo.xy / iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv.y *= 1.06;\n    float t = iTime*.15;\n    vec3 dist;\n    float r0 = 0.4;\n    float p = 2.;\n    float r = r0;\n\n    for(float i = 0.; i < 21.; ++ i)\n    {\n        vec3 dist1 = sdWhatever(uv, r0, r, p,t);\n        dist = max(-dist, -dist1);\n        dist1 = sdWhatever(uv-r0, r0, r, p,-t);\n        dist = min(dist, dist1);\n        r = r*0.85 + 0.01;\n        p = sin(iTime*.22+i)*.5+1.;\n        t = -t-.2;\n    }\n\n    o.rgb = mix(vec3(.9,.9,.6), vec3(0.,0.,0.), 0.7*clamp(1.0 / (clamp(dist, 1.0/250., 1.0)*250.),0.,1.)); \n\tvec2 uvn = uvo.xy / iResolution.xy-.5;\n    o -= rand(uvo + iTime)*.07;\n    o *= 1.-dot(uvn,uvn*2.1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSfWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 80, 80, 291], [292, 292, 355, 355, 580], [582, 582, 603, 603, 673], [674, 674, 715, 715, 1420]], "test": "valid"}
