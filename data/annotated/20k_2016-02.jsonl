{"id": "4dG3DV", "name": "Yin Yang Spin 158 chars", "author": "GregRostami", "description": "This is a continuation of the Yin Yang challenge that was started by s23b here:<br/>https://www.shadertoy.com/view/4sKGRG", "tags": ["small", "short", "tweet", "2tc"], "likes": 1, "viewed": 617, "published": "Public API", "date": "1456356988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 o, vec2 I) {\nvec2 R = iResolution.xy, i = (I+I-R)/R.y * mat2( cos( vec4(0,33,55,0) - iTime));\n    float a = dot(i,i), b = abs(i.y);\n    o += (a>1. ? .5 : 9./(b-a-.23)/(b>a ? i.y : i.x)); }\n\n// 174 chars - Fabrice simplified the rotation matrix by removing the cos\n// Fabrice uses black magic to remove a char by removing the \"-\" in rotation matrix ( -cos(X) = sin(X + PI/2*3) )\n/**\nvoid mainImage(out vec4 o,vec2 i)\n{\n    float a = dot(i = (i+i-(o.xy=iResolution.xy) )/o.y *\n                  mat2(cos(iTime+.78*vec4(6,0,0,2))), i), \n          b = abs(i.y);\n    o += (a>1. ? .5 : 9./(b-a-.23)/(b>a ? i.y : i.x))-o;\n}\n/**/\n\n// 161 chars - smallest version with rotation (not centered, no gray background)\n/*\nvoid mainImage(out vec4 o,vec2 i)\n{\n    float a = dot(i= (2.*i/iResolution.y-1.) * mat2(sin(iDate.w+1.57*vec4(3,0,0,1))), i),\n    b = abs(i.y);\n    o += 9./(b>a ? (b-a-.23)*i.y : --a*i.x) - o;\n}\n*/\n\n// 180 chars - Original\n/*\nvoid mainImage(out vec4 o,vec2 i)\n{\n    float t=iDate.w, s=sin(t), c=cos(t),\n\ta = dot(i = (i + i - (o.xy=iResolution.xy) )/o.y * mat2(-c,s,s,c) , i), b = abs(i.y);\n    o += (a>1. ? .5 : 9./(b-a-.23)/(b>a ? i.y : i.x))-o;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dG3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 212]], "test": "untested"}
{"id": "4dG3RK", "name": "Sphere Tracing 103", "author": "fab", "description": "Final shader for the 3rd introduction to SDF blog post: http://fabricecastel.github.io/blog/2016-02-11/main.html", "tags": ["tutorial", "cube"], "likes": 26, "viewed": 4775, "published": "Public", "date": "1455236651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\n\n// epsilon-type values\nconst float S = 0.01;\nconst float EPSILON = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n\tfloat s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\n\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec3 result = vec3(0.0);\n    for(int i = 0; i < 20; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < EPSILON){\n            vec3 hit = p+dir*dist;\n            vec3 light = vec3(100.0*sin(iTime), 30.0*cos(iTime), 50.0*cos(iTime));\n            result = computeLambert(hit, computeSurfaceNormal(hit), light);\n            break;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float cameraDistance = 10.0;\n    vec3 cameraPosition = vec3(10.0*sin(iTime), 0.0, 10.0*cos(iTime));\n\tvec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0, -1.0*cos(iTime));\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n  \n    // generate the ray for this pixel\n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec3 pixelColour = intersectWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4(pixelColour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dG3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 307, 346, 346, 469], [472, 564, 598, 598, 815], [818, 818, 862, 862, 905], [907, 907, 949, 949, 1422], [1424, 1424, 1481, 1481, 2315]], "test": "untested"}
{"id": "4dG3RV", "name": "Test new shader shit 2", "author": "suspiciousimage", "description": "Test new shader shit 2", "tags": ["testnewshadershit2"], "likes": 1, "viewed": 129, "published": "Public", "date": "1455275160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int RAY_MARCHING_ITERATIONS = 95;\nconst float RAY_MARCHING_TMAX = 40.0;\nconst float MATERIAL_SKY = -1.0;\nconst float MATERIAL_FLOOR = 1.49;\nconst float MATERIAL_BALL = 47.0;\nconst vec3 COLOR_SKY = vec3(0.8, 0.7, 0.5);\nconst vec3 COLOR_BALL = vec3(0.2, 0.5, 0.9);\nconst vec3 COLOR_FLOOR = vec3(0.2, 0.2, 0.2);\n\n\nvec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(107.1,301.7)),\n\t\t\t  dot(p,vec2(151.5,353.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot(hash( i + vec2(0.0,0.0)), f - vec2(0.0,0.0)), \n                     dot(hash( i + vec2(1.0,0.0)), f - vec2(1.0,0.0)), u.x),\n                mix( dot(hash( i + vec2(0.0,1.0)), f - vec2(0.0,1.0)), \n                     dot(hash( i + vec2(1.0,1.0)), f - vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat fractalnoise(in vec2 p, float scale, float opacity) {\n\tfloat f = 0.0;\n    p *= scale;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise(p); \n    p = m*p;\n    f += 0.2500*noise(p); \n    p = m*p;\n    f += 0.1250*noise(p); \n    p = m*p;\n    f += 0.0625*noise(p); \n    p = m*p;\n    f += 0.0312*noise(p); \n\treturn (1.0 - opacity) + opacity * f;\n}\n\n// Objects\t\nfloat objectFloor(vec3 pos, float level) {\n\treturn pos.y - level;\n} \n\nfloat objectSphere(vec3 pos, float radius) {\n\treturn length(pos) - radius;\n} \n\n// Dado un vector de (distancia, material) y otro (distancia, material) retorna el que tenga menor distancia\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n// PodrÃ­a separarse dos versiones donde una no devuelva el material y usarlo en el calculo de normales (ver si optimiza x default)\nvec2 hit(in vec3 pos) {\n\tvec3 sphereRotPoint = vec3(pos.x + cos(iTime + pos.z), \n                               pos.y + 0.5 * sin(iTime + pos.z), \n                               mod(pos.z + iTime * 4.0, 0.75))\n                           \t- vec3(-1.25, 0.1, 0.2);\n  \t\n    vec2 sphereZ = vec2(objectSphere(\n                    \tvec3(pos.x, pos.y, mod(pos.z + iTime, 1.0)) \n       \t\t\t\t\t\t- vec3(-1.25, 0.1, 0.2), 0.25), MATERIAL_BALL),\n         sphereRot = vec2(objectSphere(sphereRotPoint, 0.15), MATERIAL_BALL),\n         sphereRotRot =\n        \tvec2(objectSphere(\n        \t\tsphereRotPoint + \n        \t\tvec3(0.25 * cos(iTime * 2.0),\n                     0.25 * sin(iTime * 2.0),\n                     0.0),\n                  0.06),\n                 \tMATERIAL_BALL),\n        sphereRotRot2 = vec2(objectSphere(\n        \t\tsphereRotPoint + \n        \t\tvec3(0.25 * cos(iTime * 2.0 + 6.28 * 0.33),\n                     0.25 * sin(iTime * 2.0 + 6.28 * 0.33),\n                     0.0),\n                  0.06),\n                 \tMATERIAL_BALL),\n        sphereRotRot3 = vec2(objectSphere(\n        \t\tsphereRotPoint + \n        \t\tvec3(0.25 * cos(iTime * 2.0 + 6.28 * 0.66),\n                     0.25 * sin(iTime * 2.0 + 6.28 * 0.66),\n                     0.0),\n                  0.06),\n                 \tMATERIAL_BALL),\n        floorPlane = vec2(objectFloor(pos - vec3(0.25, -1.0, 0.0), 0.0), MATERIAL_FLOOR);\n    \n    vec2 res = opU(opU(opU(sphereRotRot, opU(sphereRotRot2, sphereRotRot3)), floorPlane), \n                   opU(sphereRot, sphereRot));\n    \n    return res;\n}\n\nvec3 calcNormal(in vec3 pos) {\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\thit(pos + eps.xyy).x - hit(pos - eps.xyy).x,\n\t\thit(pos + eps.yxy).x - hit(pos - eps.yxy).x,\n\t\thit(pos + eps.yyx).x - hit(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\nbool isMaterial (float material, float value) {\n\treturn abs(material - value) < 0.01;\n}\n\nvec3 colorForMaterial(float material, vec3 p) {\n\t// #TODO: Pasar a tabla\n\tif (isMaterial(material, MATERIAL_FLOOR)) {\n        return 0.4 + COLOR_FLOOR * mod(floor(p.x * 4.0) + floor(p.z * 4.0), 2.0);\n\t}\n\telse if (isMaterial(material, MATERIAL_BALL))\n\t\treturn COLOR_BALL;\n\telse if (isMaterial(material, MATERIAL_SKY))\n\t\treturn vec3(fractalnoise(vec2(p.x / 20.0, p.z), 0.1, 0.2));\n\t\t//return COLOR_SKY;\n\telse\n\t\t// #NOTE: green is error color :)\n\t\treturn vec3(0.0, 1.0, 0.0);\n}\n\nvec2 castRayToWorld(in vec3 ro, in vec3 rd) {\n\tfloat tmin=1.0, tmax=RAY_MARCHING_TMAX, precis=0.01, t=tmin, m=-1.0;\n\n\tfor (int i=0; i< RAY_MARCHING_ITERATIONS; i++) {\n\t\tvec2 p = hit(ro + rd * t);\n\t\tif ((precis > p.x) || (t > tmax)) break;\n\t\t// En x viene la distancia al objeto\n\t\tt += p.x;\n\t\t// El material vuelve en la segunda coordenada\n\t\tm = p.y;\n\t}\n\n\t// m = -1.0 significa que pega en el infinito\n\tif (t > tmax) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n\tvec2 value = castRayToWorld(ro, rd);\n\tfloat distance = value.x;\n\tfloat material = value.y;\n\tvec3 color;\n\t\n\tif (isMaterial(material, MATERIAL_SKY)) \n\t\t// #ADD: PodrÃ­a depender de la posicion tambiÃ©n, para usar un hash + perlin\n\t\tcolor = COLOR_SKY;\n\telse {\n\t\tvec3 pos = ro + distance * rd;\n\t\t\n\t\t// Material\n\t\tcolor = colorForMaterial(material, pos);\n\t\t// Normal\n\t\tvec3 normal = calcNormal(pos);\n\t\t//vec3 ref = reflect(rd, normal);\n\t\t// #TODO: Factorizar para tener varias luces\n\t\tvec3 light = normalize(vec3(-0.6, 0.7, -0.5));\t\n\t\tfloat dif = clamp(dot(normal, light), 0.0, 1.0);\n\t\t// Lighting\n\t\t\t// Ambient occlusion\n\t\t\t// Shadow\n\t\t\t// Ambient lighting\n\t\t\tfloat amb = clamp(0.5+0.5*normal.y, 0.0, 1.0);\n\t\t\n\t\t// Mix\n\t\tvec3 brdf = vec3(dif);\n\t\tbrdf += 1.2 * amb * vec3(0.50, 0.20, 1.00);\n\t\tcolor *= brdf;\n\t}\n\t\n\treturn color;\n} \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Ajuste de definicion\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t// #VER: Aspect adjustment ??\n\tvec2 p = q * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\t// Calculamos camara (algo a la izquierda del medio, un toque arriba y mirando para adelante 2.5).\n\t//vec3 ro = vec3(-0.5, 0.75, 4.5);\n    vec3 ro = vec3(-1.25, 0.25, iTime);\n\tvec3 ta = vec3(-3.5 + iMouse.x / 100.0, -1.1  + iMouse.y / 100.0 , 0.5 );\n\t// Matriz de la camara\n\tmat3 ca = setCamera(ro, ta, 0.0);\n\t// Disparamos rayo\n\t// #TODO: Ver normalizacion con dimensiones de arriba y dejar en unidad\n\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n\t// Renderizamos ese punto\n\tfragColor = vec4(render(ro, rd), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dG3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 317, 338, 338, 458], [460, 460, 486, 486, 869], [871, 871, 930, 930, 1234], [1236, 1248, 1290, 1290, 1315], [1318, 1318, 1362, 1362, 1394], [1397, 1506, 1534, 1534, 1569], [1571, 1705, 1728, 1728, 3264], [3266, 3266, 3296, 3296, 3517], [3519, 3519, 3569, 3569, 3740], [3742, 3742, 3789, 3789, 3829], [3831, 3831, 3878, 3903, 4305], [4307, 4307, 4352, 4352, 4754], [4756, 4756, 4793, 4793, 5623], [5626, 5626, 5681, 5706, 6358]], "test": "untested"}
{"id": "4dG3Wc", "name": "Checkerboards", "author": "RolandRock", "description": "Flying above a bunch of checkerboards. Inspired by Titan's demo Overdrive: https://youtu.be/iQqJm14sHRY?t=260<br/>Hold mouse down to move camera around. There's also some code you can uncomment for some cool effects.", "tags": ["3d"], "likes": 1, "viewed": 210, "published": "Public", "date": "1456626123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cameraPos;\nfloat focalLength;\n\nvec3 backgroundColor = vec3(0.0);\nvec3 baseCheckerboardColor = vec3(0.2, 0.9, 0.2);\n\nvec2 screenCenter;\nconst int numLayers = 10;\n\nbool IsCheckerboardAtPixel(in vec2 fragCoord, in float checkerboardZ)\n{\n    float z = checkerboardZ - cameraPos.z;\n    \n    //Dont draw checkerboard if it's behind the camera\n    if(z <= 0.) return false;\n    \n    //Transform pixel coords to world coords\n    //Inverse of [screenxy = ((worldxy - camxy)/z * scale) + center] is [worldxy = camxy + (z * ((screenxy - center)/scale)]\n    vec2 worldxy = cameraPos.xy + ((fragCoord - screenCenter)/focalLength) * z;\n    \n    // Uncomment for spinning!\n    //mat2 rotationMatrix = mat2(cos(iTime/3.0), -sin(iTime/3.0),\n    //                           sin(iTime/3.0), cos(iTime/3.0));\n    //worldxy = cameraPos.xy + (rotationMatrix * (worldxy - cameraPos.xy));\n       \n    // Uncomment for melting!\n    //worldxy.x += sin(worldxy.y + iTime - (checkerboardZ * checkerboardZ));\n    //worldxy.y += sin(worldxy.x + iTime + (checkerboardZ * checkerboardZ));\n       \n    //checkboard squares are 1x1\n    worldxy = mod(worldxy, 2.);\n    return (worldxy.x < 1.) == (worldxy.y < 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    screenCenter = iResolution.xy / 2.0;\n    \n    //+z is towards checkerboard, -z is away from checkerboard\n    cameraPos = vec3(10.0 * cos(iTime / 2.0), \n                     10.0 * sin(iTime / 2.0), \n                     -((sin(iTime) + 1.0) * 2.0 - 0.5)\n                    );\n    \n    //holding mouse lets you move camera around a bit\n    cameraPos.xy -= iMouse.xy / 50.;\n    \n    //Not sure if focal length is correct term but it gets the idea across\n    //Multiply by resolution so scale stays the same when resolution is higher\n    focalLength = 100.0 * (iResolution.x/1000.0);\n    \n    //Generate checkerboard layers\n    fragColor = vec4(backgroundColor, 1.0);\n    for(int i=0; i < numLayers; ++i)\n    {\n        float checkerZ = float(i)*0.8;\n        \n        //Colors get darker at lower layers\n        float colorMult = float(numLayers - i)/float(numLayers);\n        vec4 planeColor = vec4(baseCheckerboardColor * colorMult, 1.0);\n        \n        //Check if the checkerboard is visible at this pixel\n        if(IsCheckerboardAtPixel(fragCoord, checkerZ))\n        {\n            fragColor = planeColor;\n            break;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dG3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 238, 238, 1186], [1188, 1188, 1245, 1245, 2395]], "test": "untested"}
{"id": "4dG3WG", "name": "CubicBezier", "author": "yomotsu", "description": "render CubicBezier in glsl", "tags": ["vector"], "likes": 1, "viewed": 182, "published": "Public", "date": "1456059722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 p0 = vec2( 0.0, 0.5 ); //start\nvec2 p1 = vec2( 0.0, 1.0 ); //ctrl1\nvec2 p2 = vec2( 1.0, 0.0 ); //ctrl2\nvec2 p3 = vec2( 1.0, 0.5 ); //end\n\nvec2 getPoint ( float t ) {\n\n    float tp = 1.0 - t;\n    \n    return t * t * t         * p3 +\n           3.0 * t * t * tp  * p2 +\n           3.0 * t * tp * tp * p1 +\n           tp * tp * tp      * p0;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    p1.y = ( sin( iTime ) + 1.0 ) * 0.5; // 0 to 1\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 point = getPoint( uv.x );\n\n    if ( uv.y - point.y > 0.0 ) {\n\n      fragColor = vec4(1.0);\n\n    } else {\n\n      fragColor = vec4( uv, 0.0, 1.0);\n\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dG3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 143, 170, 170, 346], [348, 348, 405, 405, 667]], "test": "untested"}
{"id": "4dGGDK", "name": "Metal Beads", "author": "galb", "description": "metalic beads", "tags": ["raymarching"], "likes": 11, "viewed": 222, "published": "Public", "date": "1456315452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on www.shadertoy.com/view/Xds3zN Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI_16TH 0.39269908169 \n#define HALF_PI 1.57079632679\n#define PI 3.14159265359\n\nfloat sdSphere( vec3 p, float s , float a, float b)\n{\n    mat3 rot1 = mat3(vec3(sin(b),cos(b),0.0), \n                     vec3(cos(b),-sin(b),0.0),\n                     vec3(0.0,0.0,1.0));\n    mat3 rot2 = mat3(vec3(sin(a),0.0,cos(a)), \n                     vec3(0.0, 1.0, 0.0),\n                     vec3(cos(a), 0.0, -sin(a)));\n    p -= rot2*rot1*vec3(0.0,0.9,0.0);\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t , float a)\n{\n  mat3 rot = mat3(vec3(sin(a),0.0,cos(a)), \n                  vec3(0.0, 1.0, 0.0),\n                  vec3(cos(a), 0.0, -sin(a)));\n  \n  p = rot*p;\n  p -= -vec3( 0.0,0.0, 0.0);\n  return length( vec2(length(p.yz)-t.x,p.x) )-t.y;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    float time = 2.0 * iTime;\n    vec2 res = vec2(11111111.0,0.0);\n\n    for( int i=0; i<8; i++ )\n    {\n    \tres = opU( res, vec2( sdTorus(pos, vec2(0.90,0.01), float(i) * PI_16TH ), 25.0 ) );  \n        res = opU(res, vec2( sdSphere(    pos, 0.13 , float(i) * PI_16TH, time + PI_16TH * float(i)), time + float(i)));\n    }\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 0.0 + iTime/3.0;\n    float cra = HALF_PI - clamp(HALF_PI * (cos(time)), 0.0, HALF_PI); // camera rotation angle\n    \n    float y = (0.5 + 0.5 * cos(time))*3.0;\n    \n\t// camera\t\n\tvec3 ro = vec3( 0.0, sqrt(9.0-y*y), y);\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGGDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 251, 304, 304, 642], [644, 644, 686, 686, 914], [916, 916, 946, 946, 979], [981, 981, 1006, 1006, 1345], [1347, 1347, 1387, 1387, 1707], [1710, 1710, 1784, 1784, 2045], [2047, 2047, 2079, 2079, 2300], [2302, 2302, 2344, 2344, 2643], [2645, 2645, 2684, 2684, 4255], [4257, 4257, 4309, 4309, 4486], [4488, 4488, 4545, 4545, 5222]], "test": "untested"}
{"id": "4dGGRK", "name": "drl0010 (Generator)", "author": "DrLuke", "description": "Just some funny swirling voxel tori", "tags": ["voxel", "dithering"], "likes": 6, "viewed": 1043, "published": "Public API", "date": "1455243572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tThanks to fb39ca4 for this shader: https://www.shadertoy.com/view/4dX3zl\n\n\tI've copied it and then plugged in my own distance functions in getVoxel.\n\n\tAdditionally I've added a basic lighting system. I've commented my changes.\n*/\n\n/*\t------------------------- SETTINGS ------------------------- */\n// Dither the entire screen for a fun effect\n//#define DITHERING\n// Whether you want \n//#define CAMERAROTATING\n\n\n\n/*\t------------------------ /SETTINGS/ ------------------------ */\n\n\n\n\n// function to generate a rotation matrix. Very handy!\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n//The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//http://lodev.org/cgtutor/raycasting.html\n\nconst int MAX_RAY_STEPS = 170;\n\n\n// For different distance functions, look here: https://www.shadertoy.com/view/Xds3zN\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// this function returns true if there's a bool in the provided grid position.\nbool getVoxel(ivec3 c, mat3 rotMat1, mat3 rotMat2) \n{\n\tvec3 p = vec3(c) + vec3(0.5);\n    // Generate 2 rotation matrices for the \n\tfloat d = min(min(sdTorus(rotMat1*vec3(c), vec2(10,3)),sdTorus(rotMat2*vec3(c), vec2(25,4))), -sdSphere(p, 50.0));\n    \n    #define CAPSULEDIST (0.0 + abs(sin(iTime))*13.0)\n    d = min(d, sdCapsule(rotMat1*vec3(c), vec3(0,CAPSULEDIST,0), vec3(0,-CAPSULEDIST,0), 4.0));\n\treturn d < 0.0;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n#ifdef DITHERING\nfloat dither(vec2 position, float brightness) {\n\tfloat bayer = texture(iChannel0, position).r;\n    return step(bayer, brightness-0.1);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy * 2.0) / iResolution.xy) - vec2(1);\t// Make UV go from -1 to 1 instead of 0 to 1\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 s = vec3(sin(iTime*0.1)*45.0,sin(iTime*0.4)*15.0,cos(iTime*0.1)*45.0);\n    #define FOCALLEN 0.6\n    vec3 d = vec3(uv*FOCALLEN, 1.0);\n    mat3 rotMat = rotationMatrix(vec3(0,1,sin(iTime*3.14159*0.1)*-0.3), -iTime*0.1 + 3.14159) * rotationMatrix(vec3(1,0,0), -0.4*sin(iTime*0.4) - 0.0);\n    d = rotMat * d;\n    \n\tvec3 rayDir = d;\n\tvec3 rayPos = s;\n\t\n\t\n\tivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n    mat3 rotMat1 = rotationMatrix(vec3(1,1,0), iTime*0.3);\n    mat3 rotMat2 = rotationMatrix(vec3(1,1,0), iTime*0.2);\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) \n    {\n\t\t//if (getVoxel(mapPos)) continue;\n\t\tbvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);\n\t\tbvec3 b2 = lessThanEqual(sideDist.xyz, sideDist.zxy);\n\t\tmask.x = b1.x && b2.x;\n\t\tmask.y = b1.y && b2.y;\n\t\tmask.z = b1.z && b2.z;\n\t\t//Would've done mask = b1 && b2 but the compiler is making me do it component wise.\n\t\t\n\t\t//All components of mask are false except for the corresponding largest component\n\t\t//of sideDist, which is the axis along which the ray should be incremented.\t\t\t\n\t\t\n        if(getVoxel(mapPos, rotMat1, rotMat2)) break;\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += ivec3(mask) * rayStep;\n\t}\n\n    /*\n\t\tBasic lighting\n\t\tI calculate the distance from the current voxel center (mapPos) to a given light.\n\t*/\n    \n    fragColor = vec4(0,0,0,1);\t// Thanks otaviogood\n    \n    #define POW2(a) (a*a)\n    \n    #define CENTERCOLOR (vec3(0,0.4,0.8) * clamp(cos(-iTime*2.0)*1.4-0.4, -0.1, 1.) )\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(0,0,0), rotMat*vec3(mapPos))) ) * 100.0 * CENTERCOLOR;\n    \n    #define MEDROTCOLOR vec3(0.1,0.5,0)\n    rotMat = rotationMatrix(vec3(1,1,0), iTime*0.2);\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(sin(iTime)*25.0,0,cos(iTime)*25.0), rotMat*vec3(mapPos))) ) * 20.0 * MEDROTCOLOR;\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(sin(-iTime)*25.0,0,cos(iTime)*25.0), rotMat*vec3(mapPos))) ) * 20.0 * MEDROTCOLOR;\n    \n    #define CAPSULECOLOR (vec3(1,0,1)*(-cos(iTime*2.0)*0.5+0.5))\n    //#define CAPSULEDIST (10.0 + sin(iTime)*5.0) Actually defined further up\n    rotMat = rotationMatrix(vec3(1,1,0), iTime*0.3);\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(0, CAPSULEDIST+1.0,0), rotMat*vec3(mapPos))) ) * 10.0 * CAPSULECOLOR;\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(0,-CAPSULEDIST+1.0,0), rotMat*vec3(mapPos))) ) * 10.0 * CAPSULECOLOR;\n    \n    #define RIMCOLOR vec3(0,0.1,0.3) * max(0.0, sin(atan(float(mapPos.z), float(mapPos.x))*5.0+iTime*5.0)) * step(30.0, length(vec3(mapPos))) * (1.0-smoothstep(20., 50., abs(float(mapPos.y))))\n    fragColor.rgb += clamp(( 1.0/abs(sdTorus(vec3(mapPos - ivec3(0,0,0)), vec2(50.0,20)) )), 0., 1.0) * 5.0 * RIMCOLOR;\n    \n    #define OUTROTSPEED 0.2\n    #define OUTROTRADIUS 45.0\n    #define OUTROTBRIGHTNESS 100.0\n    #define OUTROTCOLOR vec3(1,0.4,0)\n    fragColor.rgb += ( 1.0/POW2(distance(vec3( sin(iTime*OUTROTSPEED)*OUTROTRADIUS,0, cos(iTime*OUTROTSPEED)*OUTROTRADIUS), vec3(mapPos))) ) * OUTROTBRIGHTNESS * OUTROTCOLOR;\n    fragColor.rgb += ( 1.0/POW2(distance(vec3( cos(iTime*OUTROTSPEED)*OUTROTRADIUS,0,-sin(iTime*OUTROTSPEED)*OUTROTRADIUS), vec3(mapPos))) ) * OUTROTBRIGHTNESS * OUTROTCOLOR;\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(-sin(iTime*OUTROTSPEED)*OUTROTRADIUS,0,-cos(iTime*OUTROTSPEED)*OUTROTRADIUS), vec3(mapPos))) ) * OUTROTBRIGHTNESS * OUTROTCOLOR;\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(-cos(iTime*OUTROTSPEED)*OUTROTRADIUS,0, sin(iTime*OUTROTSPEED)*OUTROTRADIUS), vec3(mapPos))) ) * OUTROTBRIGHTNESS * OUTROTCOLOR;\n    \n    #ifdef DITHERING\n    fragColor.r = dither(fragCoord.xy / vec2(8), fragColor.r);\n    fragColor.g = dither(fragCoord.xy / vec2(8), fragColor.g);\n    fragColor.b = dither(fragCoord.xy / vec2(8), fragColor.b);\n    #endif\n\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[487, 542, 587, 587, 1059], [1224, 1310, 1343, 1343, 1367], [1370, 1370, 1401, 1401, 1497], [1499, 1499, 1532, 1532, 1585], [1587, 1587, 1639, 1639, 1753], [1755, 1834, 1887, 1887, 2252], [2254, 2254, 2286, 2286, 2397], [2561, 2561, 2618, 2618, 6724]], "test": "untested"}
{"id": "4dGGWG", "name": "ngRay5", "author": "netgrind", "description": "4 colab", "tags": ["colab"], "likes": 2, "viewed": 294, "published": "Public API", "date": "1456039889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------------------------------\n// Simple test/port of Mercury's SDF GLSL library: http://mercury.sexy/hg_sdf/\n// by Tom '2015\n// Disclaimer:\n//   The library is done by Mercury team for OpenGL 4+ (look below),\n//   not me, and this is just an unofficial port.\n//-----------------------------------------------------------------------------\n\n// Here rather hacky and very basic sphere tracer, feel free to replace.\n\n// fField(p) is the final SDF definition, declared at the very bottom\n\nconst int iterations =160;\nconst float dist_eps = .001;\nconst float ray_max = 400.0;\nconst float fog_density = 0.01;\n\nfloat fField(vec3 p);\n\nvec3 dNormal(vec3 p)\n{\n   const vec2 e = vec2(0.01,0.0);\n   return normalize(vec3(\n      fField(p + e.xyy) - fField(p - e.xyy),\n      fField(p + e.yxy) - fField(p - e.yxy),\n      fField(p + e.yyx) - fField(p - e.yyx) ));\n}\n\nvec4 trace(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = fField(p);\n      if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\n// abs(0+0-1)=1\n// abs(1+0-1)=0\n// abs(0+1-1)=0\n// abs(1+1-1)=1\nfloat xnor(float x, in float y) { return abs(x+y-1.0); }\n\nvec4 tex(vec3 pos, float sample_size)\n{\n   pos = pos*8.0 + .5;\n   vec3 cell = step(1.0,mod(pos,2.0));\n   float checker = xnor(xnor(cell.x,cell.y),cell.z);\n   vec4 col = mix(vec4(.4),vec4(.5),checker);\n   float fade = 1.-min(1.,sample_size*24.); // very fake \"AA\"\n   col = mix(vec4(.5),col,fade);\n   pos = abs(fract(pos)-.5);\n   float d = max(max(pos.x,pos.y),pos.z);\n   d = smoothstep(.45,.5,d)*fade;\n   return mix(col,vec4(0.0),d);\n}\n\nvec3 sky_color(vec3 ray_dir, vec3 light_dir)\n{\n   float d = max(0.,dot(ray_dir,light_dir));\n   float d2 = light_dir.y*.7+.3;\n   vec3 base_col;\n   base_col = mix(vec3(.3),vec3((ray_dir.y<0.)?0.:1.),abs(ray_dir.y));\n   return vec3(0.);\n}\n\nvec4 debug_plane(vec3 ray_start, vec3 ray_dir, float cut_plane, inout float ray_len)\n{\n    // Fancy lighty debug plane\n    if (ray_start.y > cut_plane && ray_dir.y < 0.) {\n       float d = (ray_start.y - cut_plane) / -ray_dir.y;\n       if (d < ray_len) {\n           vec3 hit = ray_start + ray_dir*d;\n           float hit_dist = fField(hit);\n           float iso = (hit_dist*1.0);\n           vec3 dist_color = mix(vec3(1.),vec3(0.5),iso);\n           dist_color *= 1.0/(max(0.0,hit_dist)+.1);\n           ray_len = d;\n           return vec4(dist_color,.1);\n      }\n   }\n   return vec4(0);\n}\n\nvec3 shade(vec3 ray_start, vec3 ray_dir, vec3 light_dir)\n{\n    vec4 hit = trace(ray_start, ray_dir);\n    \n   float ray_len;\n   vec3 color;\n   if (hit.w == 0.0) {\n      ray_len = 1e16;\n      color = vec3(.6,.9,.7);\n   } else {\n      vec3 dir = hit.xyz - ray_start;\n      vec3 norm = dNormal(hit.xyz);\n    \n      float diffuse = max(0.0, dot(norm, light_dir));\n      float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n      spec = pow(spec, 8.0)*.5;\n       \n      ray_len = distance(hit.xyz,ray_start);\n   \n      vec3 base_color = vec3(0.);\n\n       color.r = 1.0-(diffuse*.5);\n       color.r = max(0.,color.r);\n       color.r = pow(color.r,2.)*(norm.y*.5+.5);\n      // color.gb = color.rr;\n      color.rgb = mix(vec3(.08,.02,.2),vec3(1.,1.2,.666),color.r);\n   }\n   \n   /*float cut_plane0 =2.;\n   for(int k=0; k<1; ++k) {\n      vec4 dpcol = debug_plane(ray_start, ray_dir, cut_plane0, ray_len);\n      //if (dpcol.w == 0.) continue;\n      float fog_dist = ray_len;\n      dpcol.w *= 1.0/exp(fog_dist*.015);\n      color = mix(color,vec3(1.,1.4,.4)*dpcol.xyz*1.,dpcol.w);\n   }/*/\n\n   return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    uv.x = abs(uv.x);\n   \n   // Simple model-view matrix:\n   float ang, si, co;\n   ang =0.;\n  \tvec3 light_dir = normalize(vec3(uv.x,2., uv.y));\n\n    float cam_dist = 70.;\n\n   vec3 pos = vec3(0., cam_dist,0.);\n   vec3 dir = normalize(vec3(uv.x,-.8,uv.y));\n   \n   vec3 color = shade(pos, dir, light_dir);\n   //color = 1.0-color;\n   \n   color*=1.0-length(uv)*.5*vec3(1.,1.,.8); \n   fragColor = vec4(color, 1.);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n#define PHI (1.618033988749895)\n     // PHI (sqrt(5)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI+1., 1)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n float l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n// Macro based version for GLSL 1.2 / ES 2.0\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n    fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n    fGDFExpEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n    fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n    fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n    fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n    fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions, float phase) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.+phase/repetitions;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle*.5;\n    a = abs(a);\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sign(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\tfloat m = min(a, b);\n\t//if ((a < r) && (b < r)) {\n\t\treturn min(m, (a - r + b)*sqrt(0.5));\n\t//} else {\n\t\treturn m;\n\t//}\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif (r <= 0.) return m;\n\tif (((-a < r) && (-b < r)) || (m < 0.)) {\n\t\treturn max(m, (a + r + b)*sqrt(0.5));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat d = min(a, b);\n\tvec2 p = vec2(a, b);\n\tpR45(p);\n\tp = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n\tp.x += 0.5*sqrt(2.)*r/n;\n\tfloat x = r*sqrt(2.)/n;\n\tpMod1(p.x, x);\n\td = min(d, p.y);\n\tpR45(p);\n\treturn min(d, vmax(p -vec2(0.5*r/n)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n// This produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n//------------------------------------------------------------------------\n// Your custom SDF\n//------------------------------------------------------------------------\n\nfloat mic(float i){\n\treturn texture(iChannel0,vec2(i,.2)).r;   \n}\n\nfloat fField(vec3 p){\n    vec3 o = p;\n    float off = 13.;\n   // p+=off;\n    pModPolar(p.xz,2.33,0.);\n    p-=off;\n    pModPolar(p.xz,3., 0.);\n    p-=off*.4;\n    float f = fOctahedron(p,4.,30.);\n    \n\tpModPolar(p.xy,12.,TAU);\n    pModPolar(p.xz, 8.,iTime*TAU);\n    p.x-=6.5;\n   //p.x+=sin(-length(o.xz)*1.+iTime*TAU+sin(length(o.xz)+iTime*TAU)*.5)*.4;\n    f = fOpUnionStairs(f, fOctahedron(p,1.,10.), 2., 4.);\n\t\n   \t/*\n\tpModPolar(p.xy,6.,o.z*(.1+.2*cos(o.z*1.+iTime*TAU)));\n    pModPolar(p.xy, 12.,TAU*.4);\n    pModPolar(p.xz, 66.,iTime*TAU*6.);\n    p.x-=6.5;\n    p.x+=sin(o.z*1.+iTime*TAU+cos(length(o.xz)+iTime*TAU)*.5)*.4;\n    float st = cos(clamp(o.z*.3,-PI*.5,PI*.5));\n    p.x*=1.-.2*st;//=max(1.-(cos(+PI)*.5,+.5),0.);\n    f = fOpUnionRound(f, fSphere(p,.5), 1.-st*.8);\n    */\n    /*\n     float st = cos(clamp(o.z*.3,-PI*.5,PI*.5));\n        pModPolar(p.xy, 18.,TAU);\n        pModPolar(p.xz,4.,TAU*iTime);\n        p.x-=4.;\n    for(float i = 4.; i>0.;i--){\n        pModPolar(p.xz, (16.-i*2.),-TAU*mod(i,2.)*iTime);\n        p.yz = p.zy;\n        p.x*=1.-i*.03+i*.03*sin(o.z*1.+iTime*TAU+cos(length(o.xz)+iTime*TAU)*.5)*.4;\n       p.x-=i*.4;\n       // p.x*=1.-.2*st*i;//=max(1.-(cos(+PI)*.5,+.5),0.);\n        f = fOpUnionRound(f, fSphere(p,(.5-i*.1)), .5-i*.1);\n    }\n    */\n   return f;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 676, 698, 698, 898], [900, 900, 942, 942, 1216], [1218, 1282, 1315, 1315, 1338], [1340, 1340, 1379, 1379, 1774], [1776, 1776, 1822, 1822, 2011], [2013, 2013, 2099, 2131, 2600], [2602, 2602, 2660, 2660, 3710], [3712, 3712, 3764, 3764, 4240], [5348, 5387, 5407, 5407, 5432], [5434, 5434, 5458, 5458, 5473], [5475, 5475, 5497, 5497, 5512], [5514, 5514, 5536, 5536, 5551], [5553, 5553, 5578, 5578, 5599], [5602, 5642, 5662, 5662, 5687], [5689, 5689, 5709, 5709, 5744], [5746, 5746, 5766, 5766, 5811], [5813, 5813, 5833, 5833, 5858], [5860, 5860, 5880, 5880, 5915], [5917, 5917, 5937, 5937, 5982], [5987, 6540, 6572, 6572, 6597], [6599, 6673, 6729, 6729, 6771], [6773, 6824, 6857, 6869, 6897], [6899, 6935, 6963, 6963, 7044], [7046, 7103, 7137, 7137, 7163], [7165, 7165, 7194, 7194, 7275], [7278, 7298, 7322, 7322, 7381], [7383, 7487, 7508, 7508, 7881], [7883, 7928, 7976, 7976, 8050], [8052, 8105, 8147, 8147, 8241], [8243, 8327, 8371, 8371, 8474], [8476, 8548, 8597, 8597, 8634], [8636, 8661, 8721, 8721, 8792], [8794, 8893, 8925, 8925, 8986], [8988, 9121, 9151, 9151, 9232], [9234, 9275, 9319, 9319, 9559], [9561, 9598, 9638, 9638, 9702], [9704, 9800, 9849, 9849, 10348], [12249, 12272, 12317, 12317, 12429], [12431, 12431, 12478, 12478, 12640]], "test": "untested"}
{"id": "4dGGzc", "name": "Flower of life RGB", "author": "xoihazard", "description": "my first demo", "tags": ["hexagon"], "likes": 117, "viewed": 2372, "published": "Public", "date": "1455539042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// (c) 2016 xoihazard\n\n#define TWO_PI 6.2831853072\n#define PI 3.14159265359\n\nconst float timeScale = 0.2;\nconst float displace = 0.01;\nconst float gridSize = 20.0;\nconst float wave = 5.0;\nconst float brightness = 1.5;\n\nvec2 rotate(in vec2 v, in float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return v * mat2(c, -s, s, c);\n}\n\nvec3 coordToHex(in vec2 coord, in float scale, in float angle) {\n    vec2 c = rotate(coord, angle);\n    float q = (1.0 / 3.0 * sqrt(3.0) * c.x - 1.0 / 3.0 * c.y) * scale;\n    float r = 2.0 / 3.0 * c.y * scale;\n    return vec3(q, r, -q - r);\n}\n\nvec3 hexToCell(in vec3 hex, in float m) {\n    return fract(hex / m) * 2.0 - 1.0;\n}\n\nfloat absMax(in vec3 v) {\n    return max(max(abs(v.x), abs(v.y)), abs(v.z));\n}\n\nfloat nsin(in float value) {\n    return sin(value * TWO_PI) * 0.5 + 0.5;\n}\n\nfloat hexToFloat(in vec3 hex, in float amt) {\n    return mix(absMax(hex), 1.0 - length(hex) / sqrt(3.0), amt);\n}\n\nfloat calc(in vec2 tx, in float time) {\n    float angle = PI * nsin(time * 0.1) + PI / 6.0;\n    float len = 1.0 - length(tx) * nsin(time);\n    float value = 0.0;\n    vec3 hex = coordToHex(tx, gridSize * nsin(time * 0.1), angle);\n\n    for (int i = 0; i < 3; i++) {\n        float offset = float(i) / 3.0;\n        vec3 cell = hexToCell(hex, 1.0 + float(i));\n        value += nsin(hexToFloat(cell,nsin(len + time + offset)) * \n                  wave * nsin(time * 0.5 + offset) + len + time);\n    }\n\n    return value / 3.0;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 tx = (fragCoord / iResolution.xy) - 0.5;\n    tx.x *= iResolution.x / iResolution.y;\n    float time = iTime * timeScale;\n    vec3 rgb = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < 3; i++) {\n        float time2 = time + float(i) * displace;\n        rgb[i] += pow(calc(tx, time2), 2.0);\n    }\n    fragColor = vec4(rgb * brightness, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 219, 259, 259, 347], [349, 349, 413, 413, 591], [593, 593, 634, 634, 675], [677, 677, 702, 702, 755], [757, 757, 785, 785, 831], [833, 833, 878, 878, 945], [947, 947, 986, 986, 1468], [1471, 1471, 1526, 1526, 1873]], "test": "untested"}
{"id": "4dGGzy", "name": "Light on Plates", "author": "samuelotherion", "description": "Light on Plates", "tags": ["lightonplates"], "likes": 2, "viewed": 137, "published": "Public", "date": "1454974416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DISTANCE  1000000000.\n#define _t_           iTime\n#define I3            mat3( +1., +0., +0.,  +0., +1., +0.,  +0., +0., +1. )\n#define NUM_OF_OBJS_X 3\n#define NUM_OF_OBJS_Y 3\n#define NUM_OF_OBJS   ( NUM_OF_OBJS_X * NUM_OF_OBJS_Y )\nprecision lowp float;\n\nstruct Loc { vec3 pos, ext; mat3 xyz; };\nstruct Inp { vec3 eye, ray; };\nstruct Out { vec3 pnt, nrm, col; float dst; };\nstruct Scn { Inp  inp; Loc loc[ NUM_OF_OBJS ]; };\n    \nScn\n    scn;\n\nInp\n    inp;\n\nOut\n    outp;\n\nint\nmb( in vec2 p_ri ) {\n\n    vec2\n    c = p_ri;\n    \n    float\n    tmpR;\n    \n    for( int i = 0; i < 255; i++ ) {\n    \n        tmpR = c.x;\n        \n    \tc.x = c.x * c.x - c.y * c.y - p_ri.x; \n    \tc.y = 2. * tmpR * c.y - p_ri.y;\n        \n        if( 16. < c.x * c.x + c.y * c.y ) {\n        \n        \treturn i;\n        }\n    }\n    \n    return 255;\n}\n\n/*mat3\n    transpose( in mat3 p_m ) {\n        \n        return mat3( p_m[ 0 ][ 0 ], p_m[ 1 ][ 0 ], p_m[ 2 ][ 0 ], p_m[ 0 ][ 1 ], p_m[ 1 ][ 1 ], p_m[ 2 ][ 1 ], p_m[ 0 ][ 2 ], p_m[ 1 ][ 2 ], p_m[ 2 ][ 2 ] );\n    }\n*/\nmat3\n    crss( in vec3 p_vecLHS ) {\n        \n        return mat3( +0., -p_vecLHS.z, +p_vecLHS.y, +p_vecLHS.z, +0., -p_vecLHS.x, -p_vecLHS.y, +p_vecLHS.x, +0. );\n    }\n\nmat3\n    parallel( in vec3 p_axeN ) {\n        \n        return mat3( p_axeN.x * p_axeN, p_axeN.y * p_axeN, p_axeN.z * p_axeN );\n    }\n\nvec3\n    parallel( in vec3 p_axeN, in vec3 p_vec ) {\n        \n        return dot( p_axeN, p_vec ) * p_axeN;\n    }\n\nmat3\n    orthogonal( in vec3 p_axeN ) {\n        \n        return I3 - parallel( p_axeN );\n    }\n\nvec3\n    orthogonal( in vec3 p_axeN, in vec3 p_vec ) {\n        \n        return p_vec - parallel( p_axeN, p_vec );\n    }\n\nmat3\n    rot( vec3 p_axe, float p_alpha ) {\n        \n        vec3\n            n = normalize( p_axe );\n        \n        return parallel( n ) + cos( p_alpha ) * orthogonal( n ) + sin( p_alpha ) * crss( n );\n    }\n\nvec3\n    rot( in vec3 p_axe, in vec3 p_vec, float p_alpha ) {\n        \n        vec3\n            n = normalize( p_axe ),\n            p = dot( n, p_vec ) * n;\n        \n        return p + cos( p_alpha ) * ( p_vec - p ) + sin( p_alpha ) * cross( n, p_vec );\n    }\n\nvoid\n    setOutput( in vec3 p_pnt, in vec3 p_norm, in vec3 p_col ) {\n        \n        vec3\n            dist = p_pnt - inp.eye;\n        \n        float\n            distSqr = dot( dist, dist );\n        \n        if( distSqr < outp.dst ) {\n        \n            outp.pnt = p_pnt;\n            outp.nrm = p_norm;\n            outp.col = p_col;\n        \toutp.dst = distSqr;\n        }\n    }\n\nvoid\n    intersectBox( in Loc p_loc ) {\n    \n        vec3\n            eye = inp.eye - p_loc.pos,\n            rog = orthogonal( -inp.ray, -eye );\n\n        float\n            de = dot( p_loc.ext, p_loc.ext ),\n            dr = dot( rog, rog );\n        \n        if( de < dr ) return;\n\n        vec3\n            eyeXYZ = p_loc.xyz * eye,\n            rayXYZ = p_loc.xyz * inp.ray,\n            front  = ( eyeXYZ - sign( eyeXYZ ) * p_loc.ext ) / rayXYZ;\n           \n        vec3\n            pxf = eyeXYZ - front.x * rayXYZ,\n            pyf = eyeXYZ - front.y * rayXYZ,\n            pzf = eyeXYZ - front.z * rayXYZ;\n        \n//        if( all( lessThan( abs( pxf.yz ), p_loc.ext.yz ) ) ) setOutput( pxf * p_loc.xyz + p_loc.pos, -sign( eyeXYZ.x ) * p_loc.xyz[ 0 ], mix( texture( iChannel0, pxf.yz ).rgb, vec3( 1.0, 0.8, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ) );\n//        if( all( lessThan( abs( pyf.zx ), p_loc.ext.zx ) ) ) setOutput( pyf * p_loc.xyz + p_loc.pos, +sign( eyeXYZ.y ) * p_loc.xyz[ 1 ], mix( texture( iChannel0, pyf.zx ).rgb, vec3( 0.8, 1.0, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ) );\n//        if( all( lessThan( abs( pzf.xy ), p_loc.ext.xy ) ) ) setOutput( pzf * p_loc.xyz + p_loc.pos, +sign( eyeXYZ.z ) * p_loc.xyz[ 2 ], mix( texture( iChannel0, pzf.xy ).rgb, vec3( 0.8, 0.8, 1.0 ), .5 + .5 *sin( .3 * _t_ ) ) );\n        if( all( lessThan( abs( pxf.yz ), p_loc.ext.yz ) ) ) setOutput( pxf * p_loc.xyz + p_loc.pos, -sign( eyeXYZ.x ) * p_loc.xyz[ 0 ], mix( texture( iChannel0, pxf.yz ).rgb, vec3( 1.0, 0.8, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ) );\n        if( all( lessThan( abs( pyf.zx ), p_loc.ext.zx ) ) ) setOutput( pyf * p_loc.xyz + p_loc.pos, +sign( eyeXYZ.y ) * p_loc.xyz[ 1 ], mix( texture( iChannel0, pyf.zx ).rgb, vec3( 0.8, 1.0, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ) );\n        if( all( lessThan( abs( pzf.xy ), p_loc.ext.xy ) ) ) {\n            \n            float\n                c = cos( .2 * _t_ ),\n                s = sin( .2 * _t_ );\n            \n            mat2\n                rotMB = mat2( c, -s, s, c );\n            \n//            setOutput( pzf * p_loc.xyz + p_loc.pos, +sign( eyeXYZ.z ) * p_loc.xyz[ 2 ], mix( texture( iChannel0, pzf.xy ).rgb, float( 255 - mb( rotMB * ( rotMB * ( pzf.xy / vec2( 1., p_loc.ext.x ) + vec2( +.8, .0 ) ) * vec2( 1., p_loc.ext.x ) - vec2( +.8, .0 )  ) * ( 3. + 2. * sin( .9 * _t_ ) ) ) ) / 255. * vec3( 0.8, 1.0, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ) );\n              setOutput( pzf * p_loc.xyz + p_loc.pos, +sign( eyeXYZ.z ) * p_loc.xyz[ 2 ], mix( mix( texture( iChannel0, pzf.xy ).rgb, float( 255 - mb( inp.ray.xy *  ( 3. + sin( .12 * _t_ ) ) ) )  * ( 3. + 2. * sin( .23 * _t_ ) ) / 255. * vec3( 0.8, 1.0, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ), float( mb( rotMB * ( rotMB * ( pzf.xy / vec2( 1., p_loc.ext.x ) ) ) * ( 3. + 2. * sin( .9 * _t_ ) ) ) ) / 255. * vec3( 1.0, 0.0, 0. ), .5 + .5 * sin( .73 * _t_ ) ));\n        }\n    }\n\nvec4\n    intersect( ) {\n    \n        outp = Out( vec3( 0., 0., -MAX_DISTANCE ), vec3( 0., 0., 1. ), vec3( .1, .1, .1 ), MAX_DISTANCE * MAX_DISTANCE );\n        \n        for( int i = 0; i < NUM_OF_OBJS; i++ ) {\n            \n            intersectBox( scn.loc[ i ] ); \n        }\n        \n        vec3\n            lit = vec3( 2. * sin( sin( _t_ ) ), -1. * cos( sin( _t_ ) ), 0.75 ) - outp.pnt;\n        \n        return vec4( outp.col * clamp( 2.75 * dot( lit, outp.nrm ) / dot( lit, lit ), 0., 1. ) , 1. );\n    }\n\nvoid\n    init( vec2 p_xy ) {\n        \n        mat3\n            rotAxe = rot( vec3( 0., 2. * cos( 2. * _t_ ), sin( 2. * _t_ ) ), 2. * 3.14 * pow( sin( _t_ / 6.283 ), 19. ) );\n        \n        vec3\n            xy0   = vec3( vec2( p_xy / iResolution.xy - .5 ) * vec2( iResolution.x / iResolution.y, 1. ), 1. ),\n            eye  = vec3( 0., 0., 2. );\n        \n        inp = Inp( eye, normalize( eye - xy0 ) );\n        \n        vec3\n            ext = vec3( iResolution.xy / iResolution.x, .05 ),\n            pos0 = vec3( vec2( float( 1 - NUM_OF_OBJS_X ), float( 1 - NUM_OF_OBJS_Y ) ) * ext.xy, -1.44 ),\n            pos = pos0;\n        \n        vec2\n            dxy = 2. * ext.xy;\n        \n\t\tfor( int y = 0; y < NUM_OF_OBJS_Y; y++ ) {\n        \n        \tfor( int x = 0; x < NUM_OF_OBJS_X; x++ ) {\n        \n            \tscn.loc[ y * NUM_OF_OBJS_X + x ] = Loc( pos, ext, rotAxe );\n            \n                pos.x += dxy.x;\n            }\n            \n            pos.x = pos0.x;\n            pos.y += dxy.y;\n        }\n    }\n\nvoid\n    mainImage( out vec4 p_c, in vec2 p_xy ) {\n        \n        init( p_xy );\n       \n        p_c = intersect( );\n       \n    }", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[482, 482, 506, 506, 832], [834, 1048, 1083, 1083, 1214], [1216, 1216, 1253, 1253, 1348], [1350, 1350, 1402, 1402, 1463], [1465, 1465, 1504, 1504, 1559], [1561, 1561, 1615, 1615, 1680], [1682, 1682, 1725, 1725, 1892], [1894, 1894, 1955, 1955, 2153], [2155, 2155, 2223, 2223, 2534], [2536, 2536, 2575, 2575, 5390], [5392, 5392, 5415, 5415, 5898], [5900, 5900, 5928, 5928, 6915], [6917, 6917, 6967, 6967, 7048]], "test": "untested"}
{"id": "4dK3R3", "name": "恬纳微晰-TNWX", "author": "834144373", "description": "It's just a public name,and have been for 2 years. the pinyin is  \"tián nà wēi xī\"", "tags": ["2d", "font", "string", "chinese", "distancefont", "unicode"], "likes": 14, "viewed": 844, "published": "Public API", "date": "1455626245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//恬纳微晰-TNWX.glsl\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//Created by 834144373  2015/2/16\n////Tags: 2d, font, chinese, distancefont, string,unicode\n//Original: https://www.shadertoy.com/view/4dK3R3\n///////////////////////////////////////////////////////////////////////////////////////\nvec2 uv;\n\nfloat line( in vec2 a, in vec2 b ,float r)\n{\n    vec2 p = uv - a;\n    vec2 ab = b - a; // ->ab\n    return length(p-ab*clamp(dot(p,ab)/dot(ab,ab),0.,1.))-r;\n}\n\nfloat e(vec2 a,vec2 b,float r){\n\treturn distance(uv,a)+distance(uv,b)-distance(a,b)*r;\n}\n\n\nfloat o(vec2 where,float r,float R){\n\tfloat d  = distance(uv,where);\n\tfloat d1 = d - r;\n\tfloat d2 = d - R;\n\treturn max(-d1,d2);\n}\n\nfloat box(vec2 where,vec2 ab){\n\treturn length(max(abs(uv-where)-ab,0.)) - 1e-10;\n}\n\nfloat edge_box(vec2 where,vec2 ab,float r){\n\tfloat b1 = box(where,vec2(ab.x-r,ab.y-r));\n\tfloat b2 = box(where,ab);\n\treturn max(-b1,b2);\n}\n\n//-----------------------------------\n//æ¬ 6x4\n//å¿„ 2x4\nconst vec2 s = vec2(12,8); //size\nfloat su(vec2 where){\n\t\n\tfloat d1 = line(vec2(0.)-where,vec2(0.,4.)/s-where,0.02);\n\tfloat d2 = line(vec2(-1.,2.)/s-where,vec2(-0.86,3.)/s-where,0.02);\n\tfloat d3 = line(vec2(0.54,3.2)/s-where,vec2(.8,2.4)/s-where,0.02);\n\td1 = min(d1,d2);\n\td1 = min(d1,d3);\n\treturn d1;\n}\n//èˆŒ 4x4\nfloat she(vec2 where){\n\t//const vec2 s = vec2(12,8);//size\n\tfloat d = line(vec2(-1.8,3.5)/s-where,vec2(1.5,3.9)/s-where,0.02);\n\tfloat d1 = line(vec2(-2.,2.68)/s-where,vec2(2.,2.68)/s-where,0.02);\n\tfloat d2 = line(vec2(0.,1.8)/s-where,vec2(0.,3.5)/s-where,0.02);\n\t//float d3 = edge_box(vec2(0.,-0.02)-where,vec2(1.7,1.5)/s-where,0.048)-0.02;\n\tfloat d3 = line(vec2(-1.5,0.)/s-where,vec2(-1.5,1.7)/s-where,0.02);\n\tfloat d4 = line(vec2(-1.3,1.66)/s-where,vec2(1.3,1.66)/s-where,0.02);\n\tfloat d5 = line(vec2(1.5,0.)/s-where,vec2(1.5,1.7)/s-where,0.02);\n\tfloat d6 = line(vec2(-1.3,0.24)/s-where,vec2(1.3,0.24)/s-where,0.02);\n\td = min(d,d1);\n\td = min(d,d2);\n\td = min(d,d3);\n\td = min(d,d4);\n\td = min(d,d5);\n\td = min(d,d6);\n\treturn d;\n}\n//æ¬\nfloat tian(vec2 where){\n\t//const vec2 s = vec2(12,8);\n\treturn min(su(vec2(2.,0.)/s-where),she(vec2(-1.4,0.)/s-where));\n} \n//-----------------------------------\n//çº³ 6x4\n//çºŸ2x4\n//const vec2 s = vec2(12,8);\nfloat si(vec2 where){\n\tfloat d  = line(vec2(-1.,2.5)/s-where,vec2(0.5,4.)/s-where,0.02);\n\tfloat d1 = line(vec2(-1.,2.4)/s-where,vec2(0.47,2.55)/s-where,0.02);\n\tfloat d2 = line(vec2(-0.9,1.2)/s-where,vec2(1.06,3.)/s-where,0.02);\n\tfloat d3 = line(vec2(-0.9,1.12)/s-where,vec2(1.06,1.3)/s-where,0.02);\n\tfloat d4 = line(vec2(-1.,0.)/s-where,vec2(1.,0.4)/s-where,0.02);\n\td = min(d,d1);\n\td = min(d,d2);\n\td = min(d,d3);\n\td = min(d,d4);\n\treturn d;\n}\n//å†… 4x4\nfloat nei(vec2 where){\n\tfloat d  = line(vec2(-1.2,0.)/s-where,vec2(-1.2,3.1)/s-where,0.02);\n\tfloat d1 = line(vec2(-1.2,3.1)/s-where,vec2(1.8,3.1)/s-where,0.02);\n\tfloat d2 = line(vec2(1.8,3.1)/s-where,vec2(1.8,0.07)/s-where,0.02);\n\tfloat d3 = line(vec2(1.7,0.0)/s-where,vec2(1.2,0.05)/s-where,0.02);\n\tfloat d4 = line(vec2(0.24,4.)/s-where,vec2(0.15,2.4)/s-where,0.02);\n\tfloat d5 = line(vec2(0.1,2.5)/s-where,vec2(-0.6,1.3)/s-where,0.02);\n\tfloat d6 = line(vec2(0.2,2.5)/s-where,vec2(1.2,1.4)/s-where,0.02);\n\td = min(d,d1);\n\td = min(d,d2);\n\td = min(d,d3);\n\td = min(d,d4);\n\td = min(d,d5);\n\td = min(d,d6);\n\treturn d;\n}\n//çº³\nfloat na(vec2 where){\n\treturn min(si(vec2(1.,0.)/s-where),nei(vec2(-2.,0.)/s-where));\n}\n\n//å¾® 7x4 ss\n//å½³ 2x4\nconst vec2 ss = vec2(13.4,8); //size\nfloat xing(vec2 where){\n\tfloat d  = line(vec2(-1.,3.01) /ss-where,vec2(0.2 ,3.86)/ss-where,0.02);\n\tfloat d1 = line(vec2(-1.,1.7)/ss-where,vec2(.4,2.8)/ss-where,0.02);\n\tfloat d2 = line(vec2(-0.1,0.)/ss-where,vec2(-0.1,2.35)/ss-where,0.02);\n\t\n\td = min(d,d1);\n\td = min(d,d2);\n\t//d = min(d,d3)\n\treturn d;\n}\n//å±± ä¸€ å‡  3x4\nfloat SYJ(vec2 where){\n\tfloat d  = line(vec2(-0.9,2.7)/ss-where,vec2(-0.9,3.46)/ss-where,0.02);\n\tfloat d1 = line(vec2(0.,2.7)/ss-where,vec2(0.,3.88)/ss-where,0.02);\n\tfloat d2 = line(vec2(0.9,2.7)/ss-where,vec2(0.9,3.46)/ss-where,0.02);\n\tfloat d3 = line(vec2(-0.9,2.7)/ss-where,vec2(0.9,2.7)/ss-where,0.02);\n\tfloat d4 = line(vec2(-0.97,2.15)/ss-where,vec2(0.72,2.15)/ss-where,0.02);\n\tfloat d5 = line(vec2(-0.66,1.6)/ss-where,vec2(0.56,1.6)/ss-where,0.02);\n\tfloat d6 = line(vec2(-0.66,1.6)/ss-where,vec2(-0.7,0.8)/ss-where,0.02);\n\tfloat d7 = line(vec2(-0.7,.8)/ss-where,vec2(-1.,0.3)/ss-where,0.0206);\n\tfloat d8 = line(vec2(0.56,1.6)/ss-where,vec2(0.56,0.7)/ss-where,0.02);\n\tfloat d9 = line(vec2(0.56,0.58)/ss-where,vec2(1.2,1.)/ss-where,0.02);\n\t\n\t\n\td = min(d,d1);\n\td = min(d,d2);\n\td = min(d,d3);\n\td = min(d,d4);\n\td = min(d,d5);\n\td = min(d,d6);\n\td = min(d,d7);\n\td = min(d,d8);\n\td = min(d,d9);\n\t\n\t\n\treturn d;\n}\n//æ”µ 4x4\nfloat mei(vec2 where){\n\tfloat d  = line(vec2(-0.6,2.20)/ss-where,vec2(0.4,3.88)/ss-where,0.02);\n\tfloat d1 = line(vec2(0.,3.)/ss-where,vec2(2.28,3.)/ss-where,0.02);\n\tfloat d2 = line(vec2(1.2,3.)/ss-where,vec2(1.08,2.)/ss-where,0.02);\n\tfloat d3 = line(vec2(1.08,2.)/ss-where,vec2(0.5,1.1)/ss-where,0.02);\n\tfloat d4 = line(vec2(0.5,1.1)/ss-where,vec2(-1.1,0.)/ss-where,0.02);\n\tfloat d5 = line(vec2(-0.1,2.)/ss-where,vec2(.3,1.)/ss-where,0.02);\n\tfloat d6 = line(vec2(0.3,1.)/ss-where,vec2(1.,0.5)/ss-where,0.02);\n\tfloat d7 = line(vec2(01.,0.5)/ss-where,vec2(2.,0.)/ss-where,0.02);\n\t\n\td = min(d,d1);\n\td = min(d,d2);\n\td = min(d,d3);\n\td = min(d,d4);\n\td = min(d,d5);\n\td = min(d,d6);\n\td = min(d,d7);\n\t\n\treturn d;\n}\n//å¾®\nfloat wei(vec2 where){\n\treturn min(xing(vec2(1.8,0.)/ss-where),min(SYJ(vec2(0.)/ss-where),mei(vec2(-2.,0.)/ss-where)));\n}\n//------------------------------------\n//æ™°  7x4 ss\n//æ—¥ 2x4\nfloat ri(vec2 where){\n\tfloat d  = line(vec2(-1.,0.2)/ss-where,vec2(-1.,3.77)/ss-where,0.02);\n\tfloat d1 = line(vec2(-1.,3.67)/ss-where,vec2(0.6,3.67)/ss-where,0.02);\n\tfloat d2 = line(vec2(0.6,3.77)/ss-where,vec2(0.6,0.5)/ss-where,0.02);\n\tfloat d3 = line(vec2(-1.,2.25)/ss-where,vec2(0.6,2.25)/ss-where,0.02);\n\tfloat d4 = line(vec2(-1.,0.8)/ss-where,vec2(0.6,0.8)/ss-where,0.02);\n\t\n\td = min(d,d1);\n\td = min(d,d2);\n\td = min(d,d3);\n\td = min(d,d4);\n\n\treturn d;\n}\n//æœ¨ 2x4\nfloat mu(vec2 where){\n\tfloat d  = line(vec2(-0.88,2.88)/ss-where,vec2(1.,2.88)/ss-where,0.02);\n\tfloat d1 = line(vec2(0.,4.)/ss-where,vec2(0.,0.)/ss-where,0.02);\n\tfloat d2 = line(vec2(-0.88,1.1)/ss-where,vec2(0.,2.7)/ss-where,0.02);\n\tfloat d3 = line(vec2(0.56,2.1)/ss-where,vec2(1.1,1.58)/ss-where,0.02);\n\t\n\td = min(d,d1);\n\td = min(d,d2);\n\td = min(d,d3);\n\t\n\treturn d;\n}\n//æ–¤ 4x4 \nfloat jing(vec2 where){\n\tfloat d  = line(vec2(-0.1,3.5)/ss-where,vec2(-0.1,2.0)/ss-where,0.02);\n\tfloat d1 = line(vec2(-0.1,2.0)/ss-where,vec2(-0.38,1.0)/ss-where,0.02);\n\tfloat d2 = line(vec2(-0.38,1.)/ss-where,vec2(-1.0,0.086)/ss-where,0.02);\n\tfloat d3 = line(vec2(-0.12,3.5)/ss-where,vec2(1.88,3.86)/ss-where,0.02);\n\tfloat d4 = line(vec2(0.,2.6)/ss-where,vec2(2.,2.6)/ss-where,0.02);\n\tfloat d5 = line(vec2(1.1,2.5)/ss-where,vec2(1.1,0.)/ss-where,0.02);\n\t\n\td = min(d,d1);\n\td = min(d,d2);\n\td = min(d,d3);\n\td = min(d,d4);\n\td = min(d,d5);\n\t\n\treturn d;\n}\n//æ™°\tmu vec2(0.)\nfloat xi(vec2 where){\n\treturn min(ri(vec2(2.,0.)/ss-where),min(mu(vec2(0.)/ss-where),jing(vec2(-2.,0.)/ss-where)));\n}\n//------------------------------------\n//æ¬çº³å¾®æ™° function\nfloat TNWX(vec2 where){\n\tfloat Tian = tian(vec2(0.)-where);\n\tfloat Na   = na(vec2(0.5,0.)-where);\n\tfloat Wei  = wei(vec2(1.08,0.)-where);\n\tfloat Xi   = xi(vec2(1.68,0.)-where);\n\t\n\treturn min(min(Tian,Na),min(Wei,Xi));\n}\n//------------------------------------\n#define PI 3.141592653\n#define time iTime\nfloat rand(){\n    float Dot = dot(uv+vec2(sin(time),0), vec2(12.9898, 78.233));\n\treturn fract(sin(mod(Dot, PI / 2.0)) * 43758.5453);\n}\nbool inside(float d){\n\treturn d < 0.;\n}\nbool font_effect_inside(float d,float r){\n\treturn abs(d)<r;\n}\nbool font_super_inside(float d,float r1,float r2,float r3){\n    //e.g\n    //abs(abs(abs(d)-0.01)-0.006)-0.0026\n\treturn abs(abs(abs(d)-r1)-r2)-r3 < 0.;\n}\nvec3 color_effect(vec2 u){\n\treturn vec3(sin(1.-u/iResolution.xy+time),sin(time))/1.2+.3;\n}\nvoid mainImage( out vec4 o, in vec2 u)\n{\n\tuv = (u+u-iResolution.xy) / iResolution.y;\n    float d = TNWX(vec2(0.86,0.2));\n    vec3 c = vec3(0.);\n    if(font_effect_inside(d,0.01)/*font_super_inside(d,0.01,0.006,0.0026)*/){\n    \tc = vec3(0.4,0.6,0.5)*color_effect(u)/1.1;\n        //c = pow(c,vec3(.7));\n    }\n    else {\n    \tc.rgb = vec3(1.-length(uv)/2.4);\n        c.rgb *= vec3(0.6,0.7,0.5)*1.7;\n        c.rgb = pow(c.rgb,vec3(1./2.2))/2.6;\n    }\n\to = vec4(c,1.);\n    o = mix(o,vec4(rand()/4.),0.4)*1.6;\n    //o += texture(iChannel0,u/iResolution.xy);\n}", "image_inputs": [{"id": "ldf3D4", "previewfilepath": "https://soundcloud.com/nocopyrightsounds/alan-walker-fade-ncs-release", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/nocopyrightsounds/alan-walker-fade-ncs-release", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dK3R3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 351, 395, 395, 508], [510, 510, 541, 541, 598], [601, 601, 637, 637, 730], [732, 732, 762, 762, 814], [816, 816, 859, 859, 953], [955, 1054, 1075, 1075, 1322], [1323, 1336, 1358, 1394, 2063], [2064, 2073, 2096, 2126, 2193], [2195, 2287, 2308, 2308, 2728], [2729, 2744, 2766, 2766, 3357], [3358, 3367, 3388, 3388, 3454], [3456, 3522, 3545, 3545, 3824], [3825, 3854, 3876, 3876, 4761], [4762, 4776, 4798, 4798, 5481], [5482, 5491, 5513, 5513, 5612], [5613, 5684, 5705, 5705, 6141], [6142, 6155, 6176, 6176, 6523], [6524, 6539, 6562, 6562, 7089], [7090, 7112, 7133, 7133, 7229], [7230, 7306, 7329, 7329, 7525], [7526, 7607, 7620, 7620, 7741], [7742, 7742, 7763, 7763, 7781], [7782, 7782, 7823, 7823, 7843], [7844, 7844, 7903, 7954, 7996], [7997, 7997, 8023, 8023, 8087], [8088, 8088, 8128, 8128, 8641]], "test": "untested"}
{"id": "4dK3zc", "name": "Wall and chimney", "author": "TambakoJaguar", "description": "Tried to simulate smoke, under windy weather. I took iq's formulas as base. I also created some refraction from the high temperature air coming out of the chimney. It was also nice to create a blurry reflection for the chimney and rather realistic bricks.", "tags": ["noise", "clouds", "grass", "bump", "smoke", "diffuse", "tube", "bricks", "steam", "metallic", "pipe", "chimney", "wallturbulence", "smooothreflection"], "likes": 20, "viewed": 1092, "published": "Public", "date": "1456340046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"Wall and chimney\" by Emmanuel Keller aka Tambako - February 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\n// Switches, you can play with them!\n#define brick_bump\n#define specular\n#define shadow\n#define ambocc\n#define reflections\n#define procedural_clouds\n#define show_chimney\n#define show_smoke\n#define heat_refraction\n#define smoke_turbulence\n    \nstruct DirLamp\n{\n  vec3 direction;\n  vec3 color;\n  float intensity;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n    \nfloat aaindex;\n\n// Every object of the scene has its ID\n#define SKY_OBJ        0\n#define WALL_OBJ       1\n#define BRICKS_OBJ     2\n#define CHIMNEY_OBJ    3\n\nfloat currTime;\nconst float timeFactor = 1.;\n\n// Scene objects sizes and description\nconst vec3 wallPos = vec3(30, -20, -11.3);\nconst vec3 wallSize = vec3(20, 46, 50);\nconst vec3 brickSize = vec3(0.2, 0.34, 2.04);\nconst vec3 brickStep = vec3(0., 0.44, 2.29);\nconst float brickBR = 0.05;\n\nconst float tubeDiam = 1.8;\nconst float tubeLen1 = 2.1;\nconst float tubeclen = 1.6;\nconst float tubeLen2 = 1.5;\nconst float tubeDiam2 = 2.6;\nconst float tubeLen3 = 0.9;\nconst vec3 chimneyOrig = vec3(-1.3, wallPos.x - wallSize.x - tubeLen1 + 0.2, -17.5);\n\n// Camera options\nvec3 campos;\nvec3 camtarget = vec3(7., 3., -18);\nvec3 camdir;\nfloat fov = 4.5;\n\n// Lighing options\nconst vec3 ambientColor = vec3(0.1, 0.5, 1.);\nconst float ambientint = 0.21;\nDirLamp sunLamp = DirLamp(vec3(-3., 1.2, 1.7), vec3(1., 0.98, 0.94), 1.5);\n\n// Shading options\nfloat specint[4];\nfloat specshin[4];\nconst float aoint = 0.9;\nconst float aoMaxdist = 50.;\nconst float aoFalloff = 0.2;\nconst float shi = 0.55;\nconst float shf = 0.05;\n    \n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 400.;\nconst float nbrref = 12.;      // This controls the number of diffuse reflections. You can set it higher if you want the chimney appear softer, but the FPS will drop\nconst float rrefblur = 0.8;\n\n// Smoke options\nconst float smokeBrightness = 4.0;\nconst vec3 smokeCol = vec3(0.7, 0.75, 0.8)*smokeBrightness;\nconst float smokeColPresence = 0.4;\nconst float smokeColBias = 0.7;\nconst float smokeScale = 2.;\nconst float smokeSpeed = 5.7;\nconst float smokeDens = 5.5;\nconst float smokeBias = -0.01;\nconst float smokePow = 1.9;\nconst float smokeRefInt = 0.0003;\nconst float smokeTurbulence = 0.05;\nconst float smokeTurbulenceScale = 2.5;\n\n// Wind options\nconst float maxWindIntensity = 1.8;\nconst float maxWindAngle = 0.27;\nfloat windIntensity;\nfloat dWindIntensity;\nfloat windAngle;\n\n// Cloud options\nconst vec3 cloudSize = vec3(0.07, 0.2, 0.07);\nconst vec3 cloudSpeed = 0.001*vec3(1., 0.3, 1.2);\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.65;\nconst int aasamples = 1;\n\n// 1D hash function\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\n// 3D hash function\nvec3 hash3( vec3 n ){\n\treturn fract(vec3(sin(n.x)*3538.5453, sin(n.y)*2753.8256, sin(n.z)*5296.3728));\n}\n\n// 2D Vector rotation\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\n#ifdef procedural_clouds\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0 - 2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0),f.x),\n                   mix(hash(n + 157.0), hash(n + 158.0),f.x),f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0),f.x),\n                   mix(hash(n + 270.0), hash(n + 271.0),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise2(vec3 pos)\n{\n    vec3 q = 8.0*pos;\n    float f  = 0.5000*noise(q) ; q = m*q*2.01;\n    f+= 0.2500*noise(q); q = m*q*2.02;\n    f+= 0.1250*noise(q); q = m*q*2.03;\n    f+= 0.0625*noise(q); q = m*q*2.01;\n    return f;\n}\n#endif\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// Difference operation from iq\nfloat opS(float d1, float d2)\n{\n    return max(-d2,d1);\n}\n\n// From http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5*(b - a)/k, 0.0, 1.0 );\n    return mix(b, a, h) - k*h*(1.0 - h);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)),0.0) + length(max(d, 0.0));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n    return length(max(abs(p) - b,0.0)) - r;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y), 0.0) + length(max(d, 0.0));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdTorus(vec3 p, vec2 t)\n{\n    return length(vec2(length(p.xz) - t.x,p.y)) - t.y;\n}\nfloat sdTorusQ(vec3 p, vec2 t)\n{\n    return max(max(length(vec2(length(p.xz) - t.x,p.y)) - t.y, p.x), p.z);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdConeSection(in vec3 p, in float h, in float r1, in float r2)\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1 - r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0 - si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2), 0.0)) + min(max(d1,d2), 0.);\n}\n\n// Distance mapping of the bricks\nvec2 map_bricks(vec3 pos)\n{\n    vec3 pos2 = pos;\n    pos2.yz+= 0.07*texture(iChannel1, pos.yz*0.005).g;\n    pos2.z+= 0.5*(brickStep.z + 0.02)*mod(floor(0.5*pos2.y/brickStep.y), 2.);\n\n    vec2 nb = floor(pos2.yz/brickStep.yz*vec2(0.5, 1.));\n    float nbBrick = nb.x*2. + nb.y*80.;\n    float btd = 1. + 0.3*(hash(nbBrick) - 0.5);\n    \n    pos2.yz = mod(pos2.yz, brickStep.yz*vec2(2., 1.));\n    float bricks = udRoundBox(pos2 - vec3(wallPos.x - wallSize.x + brickSize.x*0.5*btd, brickStep.y, 0.), brickSize, brickBR);\n    \n    #ifdef brick_bump\n    bricks+= 0.01*smoothstep(0.1, 0.95, texture(iChannel3, pos.yz*0.18).r + 0.6*texture(iChannel0, 0.2*pos.yz).r)*smoothstep(-0.2, -0.23, pos.x - wallPos.x + wallSize.x - brickSize.x*0.5*btd);\n    #endif\n    \n    #ifdef show_chimney\n    bricks = max(bricks, -sdCylinder(pos.yxz-chimneyOrig, vec2(tubeDiam/2. + 0.1, 2.)));\n    #endif\n    \n    return vec2(bricks, BRICKS_OBJ);\n}\n\n#ifdef show_chimney\n// Distance mapping of the inside (hole of the chimney)\nfloat getTubeInt(vec3 pos)\n{ \n    return sdCylinder(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2 - 3., 0), vec2(tubeDiam/2.3, tubeLen2*2.));\n}\n\n// Distance mapping of the metallic chimney\nvec2 map_chimney(vec3 pos)\n{\n    const float cw = 0.16;\n    const float ch = 0.02;\n    \n    pos = pos.yxz;\n    pos-= chimneyOrig;\n    \n    // Horizontal tube\n    float chimney = sdCylinder(pos, vec2(tubeDiam/2., tubeLen1));\n    // Bands around the tube\n    float angle1 = atan(pos.x, pos.z) + 3.*pos.y - 0.07;\n    float angle2 = atan(pos.y + tubeLen1 + tubeclen, pos.z) - 3.*pos.x + 1.07;\n    chimney-= ch*smoothstep(cw, 0., abs(0.2 - mod(angle1, pi)));\n    \n    // Curved tube\n    float rtube = sdTorusQ(pos.yzx + vec3(tubeLen1, 0., -tubeclen), vec2(tubeclen, tubeDiam/2.));\n    vec3 pos2 = pos.yzx + vec3(tubeLen1, 0., -tubeclen);\n    // Bands around the tube\n    float angle3 = atan(pos2.x - 0.025, pos2.z);\n    float angle4 = atan(pos.x*cos(angle3*0.65 - 1.15) + (pos.y + 2.7)*sin(angle3*0.65 - 1.), pos.z) + 4.3*angle3 - 1.72;\n    rtube-= ch*smoothstep(cw, 0., abs(0.2 - mod(angle4, pi)));\n    \n    chimney = min(chimney, rtube);\n    \n    // Vertical tube\n    float tube2 = sdCylinder(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2, 0), vec2(tubeDiam/2., tubeLen2));\n    // Bands around the tube\n    tube2-= ch*smoothstep(cw, 0., abs(0.2 - mod(angle2, pi)));\n    chimney = min(chimney, tube2);\n \n    // Broad conic top of the chimney\n    float cone1 = sdConeSection(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2 - tubeLen3, 0), tubeLen3/2., tubeDiam/2.6, tubeDiam2/2.23);\n    float cone2 = sdConeSection(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2 - tubeLen3*2. - 0.08, 0), tubeLen3/2., tubeDiam2/2.23, tubeDiam/2.56);\n    float cone = smin(cone1, cone2, 0.2);\n    chimney = smin(chimney, cone, 0.1);\n    \n    // Small \"collar\" at the base of the broad part \n    float collar1 = sdCylinder(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2 - 0.6, 0), vec2(tubeDiam/1.85, 0.065));\n    chimney = smin(chimney, collar1, 0.15);\n    \n    // Small rounding at the middle of the broad part  \n    float rborder = sdTorus(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2 - tubeLen3 - 0.5, 0.), vec2(tubeDiam2/1.8, 0.01));\n    chimney = smin(chimney, rborder, 0.2);\n    \n    // Inside of the chimney (hole of the chimney)\n    float tubeInt = getTubeInt(pos);\n    chimney = max(chimney, -tubeInt);\n    \n    return vec2(chimney, CHIMNEY_OBJ);\n}\n#endif\n\n// Main distance mapping function\nvec2 map(vec3 pos)\n{\n    vec2 wall = vec2(sdBox(pos - wallPos, wallSize), WALL_OBJ);\n    float wallBound = sdBox(pos - wallPos, wallSize*1.04);\n    vec2 bricks = max(map_bricks(pos), wallBound);\n    #ifdef show_chimney\n    vec2 chimney = map_chimney(pos);\n    return opU(opU(wall, bricks), chimney);\n    #else\n    return opU(wall, bricks);\n    #endif\n}\n\n// Simple mapping function of the wall\n#ifdef show_chimney\nvec2 map_s(vec3 pos)\n{\n    vec2 wall = vec2(sdBox(pos-wallPos, wallSize), BRICKS_OBJ);\n    \n    return wall;\n}\n\n// Mapping of the inside of the hole (for smoke mapping)                            \nfloat map_int(vec3 pos)\n{\n    pos = pos.yxz;\n    pos-= chimneyOrig;\n    \n    return getTubeInt(pos);\n}\n#endif\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 1.;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 90; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = map(pos).x;\n        if (dist>maxdist || abs(dist)<0.0004)\n            break;\n        t+= dist*1.;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// Gets the position of the wall\n#ifdef show_chimney\nvec2 trace_s(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = max((-cam.x - wallPos.x + wallSize.x)/ray.x, maxdist);\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n  \n    pos = ray*t + cam;\n    vec2 res = map_s(pos);\n    dist = res.x;\n    t+= dist;\n    objnr = abs(res.y);\n\n  \treturn vec2(t, objnr);\n}\n#endif\n\n// From https://www.shadertoy.com/view/MstGDM\n// Normal mapping function\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,\n                          map(pos + q.xyx).x - map(pos - q.xyx).x,\n                          map(pos + q.xxy).x - map(pos - q.xxy).x));\n}\n\n// Normal mapping function, simplified version\n#ifdef show_chimney\nvec3 getNormal_s(vec3 pos, float e)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map_s(pos + q.yxx).x - map_s(pos - q.yxx).x,\n                          map_s(pos + q.xyx).x - map_s(pos - q.xyx).x,\n                          map_s(pos + q.xxy).x - map_s(pos - q.xxy).x));\n}\n#endif\n\n// Gets the flares of the lamps (kind of non-reflective specular)\nvec3 getFlares(vec3 ray)\n{\n\tvec3 rc = vec3(0.);\n    rc+= 0.4*clamp(normalize(sunLamp.color)*sunLamp.intensity*pow(max(0.0, dot(ray, normalize(sunLamp.direction))), 300.), 0., 1.);\n\n    return rc;\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{\n    float elev = atan(ray.y);\n    float azimuth = atan(ray.x, ray.z);\n \n    vec3 sky = ambientColor + vec3(0.4, 0.22, 0.05)*2.5*(0.65 - elev);\n    \n    // Clouds\n    #ifdef procedural_clouds\n    float cloudst = smoothstep(-0.2, 0.5, elev)*smoothstep(0.1, 0.97, noise2(11.*cloudSize*ray + vec3(cloudSpeed*currTime)));\n    #else\n    float cloudst = smoothstep(-0.2, 0.5, elev)*texture(iChannel1, cloudsize*ray.xy).r;\n    #endif\n    sky = mix(sky, 0.45 + 0.6*vec3(cloudst), smoothstep(0.12, 0.5, cloudst)) + 0.3*vec3(smoothstep(0.2, 0.8, cloudst));\n    \n    // Ground\n    vec3 grass = vec3(0.05, 0.45, 0.3) + vec3(0.19, 0.13, -0.03)*2.7*(0.65 - elev);\n    grass = grass*(0.6 + 2.*abs(elev)*texture(iChannel0, 12.*ray.xy).r);\n    \n    return mix(mix(grass, vec3(0.65)*(0.7 + 0.3*texture(iChannel0, 12.*ray.xy).r), smoothstep(-0.17 - 0.035*abs(azimuth), -0.172 - 0.035*abs(azimuth), elev)), sky, smoothstep(-0.0003, 0.0003, elev)) + getFlares(ray); \n}\n\n// Gets the simplified version of the color of the sky\nvec3 sky_color_s(vec3 ray)\n{\n    float elev = atan(ray.y);\n \n    const float cloudsize = 0.25;\n    vec3 sky = ambientColor + vec3(0.4, 0.22, 0.05)*2.5*(1. - elev);\n    \n    vec3 grass = vec3(0.0, 0.35, 0.25) + vec3(0.22, 0.16, -0.03)*2.8*(0.65 - elev);\n    \n    return mix(mix(grass, vec3(0.65), smoothstep(-0.31, -0.312, elev)), sky, smoothstep(-0.0003, 0.0003, elev)); \n}\n\n// Get the color of the cement parts between the bricks\nvec3 getWallColor(vec3 pos)\n{\n    return vec3(0.3 + 0.7*texture(iChannel0, 0.9*pos.yz).r)*(0.5 + 0.5*smoothstep(0., 0.12, texture(iChannel3, 0.3*pos.yz).r));\n}\n\n// Get the color of the metallic chimney\nvec3 getChimneyColor(vec3 pos, vec3 norm)\n{\n    vec3 chcol = vec3(1.25) - 0.7*texture(iChannel2, 0.0007*(5.*pos.xy + cross(norm, pos).yz + cross(pos, norm).zx)).x;\n    \n    return chcol;\n}\n\n// Get the color of the bricks\nvec3 getBrickColor(vec3 pos)\n{\n    vec3 brickCol1 = vec3(0.60, 0.27, 0.15);\n    vec3 brickCol2 = vec3(0.45, 0.24, 0.13);\n    vec3 brickCol3 = vec3(0.29, 0.10, 0.04);\n    \n    vec3 pos2 = pos;\n    pos2.yz+= 0.07*texture(iChannel1, pos.yz*0.005).g;\n    pos2.z+= 0.5*brickStep.z*floor(0.5*pos2.y/brickStep.y);\n    vec2 nb = floor(pos2.yz/brickStep.yz*vec2(0.5, 1.));\n    float nbBrick = nb.x + nb.y*90.;\n    float nbBrickf = pow(hash(nbBrick), 6.);\n    vec3 brickCol = mix(brickCol1, brickCol2, nbBrickf);\n    brickCol = mix(brickCol, brickCol3, pow(smoothstep(0.1, 1.05, 1.2*texture(iChannel2, pos.yz*0.18).x*texture(iChannel2, pos.yz*0.23).x), 1.5));\n    brickCol*= 0.4 + 0.6*smoothstep(0.80, 0.60, texture(iChannel1, pos.yz*0.07).b);\n    return brickCol;\n}\n\nvec3 getBrickColor_s(vec3 pos)\n{\n    return vec3(0.9, 0.3, 0.05);\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr)\n{\n   vec3 col = objnr==WALL_OBJ?getWallColor(pos):(\n              objnr==BRICKS_OBJ?getBrickColor(pos):(\n              objnr==CHIMNEY_OBJ?getChimneyColor(pos, norm):sky_color(pos)));\n\n   return col;\n}\n\n// Get the simplified color of the wall (basic brick color)\nvec3 getColor_s(vec3 norm, vec3 pos, int objnr)\n{\n   vec3 col = getBrickColor_s(pos);\n   return col;\n}\n\n////////////////////////////////////////////////////////\n// Smoke functions from www.shadertoy.com/view/XsX3RB //\n////////////////////////////////////////////////////////\n\n#ifdef show_smoke\nvec3 rayRef;\n// Mapping of the smoke\nvec4 mapSmoke(in vec3 pos)\n{\n    vec3 pos2 = pos;\n    pos2-= chimneyOrig + vec3(5.65, -0.8, 0.);\n    \n    // Calculating the smoke domain (3D space giving the probability to have smoke inside\n    float sw = max(tubeDiam*0.84 + 0.25*pos2.y*(1. + max(0.15*pos2.y, 0.)) + 0.2*windIntensity*(pos.y + chimneyOrig.x - tubeclen - tubeLen2 + 0.3), 0.);\n    float smokeDomain = smoothstep(1.2 + sw/4.3, 0.7 - sw*0.5, length(pos2.xz)/sw);\n    \n    float d;\n    vec4 res;\n    if (smokeDomain>0.1)\n    {           \n    \t// Space modification in function of the time and wind\n        vec3 q = pos2*vec3(1., 1. + 0.5*windIntensity, 1.) + vec3(0.0,-currTime*smokeSpeed + 10.,0.0);\n    \tq/= smokeScale;\n        q.y+= 8.*dWindIntensity + 1.5/(0.7 + dWindIntensity);\n        \n        // Turbulence of the smoke\n        #ifdef smoke_turbulence\n        if (smokeTurbulence>0.)\n        {\n        \tfloat n = smoothstep(4., 0., pos2.y + 3.2)*smokeTurbulence*noise(q*smokeTurbulenceScale)/(currTime + 3.);\n        \tq.xy = rotateVec(-q.xy, pos.z*n);\n        \tq.yz = rotateVec(-q.yz, pos.x*n);\n        \tq.zx = rotateVec(-q.zx, pos.y*n);\n        }\n        #endif\n        \n        // Calculation of the noise\n        d = clamp(0.6000*noise(q), 0.4, 1.); q = q*2.02;  \n        d+= 0.2500*noise(q); q = q*2.03;\n        d+= 0.1200*noise(q); q = q*2.08;\n        d+= 0.0500*noise(q);\n        \n        #ifdef heat_refraction\n        // Calculation of the refraction due to the temperature difference in the air\n        float rrf = smokeDomain*(1. - clamp((pos2.y + 2.8)*0.55, 0., 1.))*smoothstep(0., .3, pos2.y + 3.2);\n        rayRef.x+= (smokeRefInt*noise(q*3.27 + q*4.12) - 0.5*smokeRefInt)*rrf;\n        rayRef.y+= (smokeRefInt*noise(q*3.37 - q*3.96) - 0.5*smokeRefInt)*rrf;\n        rayRef.z+= (smokeRefInt*noise(q*3.11 + q*3.82) - 0.5*smokeRefInt)*rrf;\n        #endif\n\n        d = d - 0.3 - smokeBias - 0.04*pos.y + 0.05*(1. + windIntensity);\n        d = clamp(d, 0.0, 1.0);\n        \n \t\tres = vec4(pow(d*smokeDomain, smokePow));\n\n    \t// Some modifications of color and alpha\n\t\tres.xyz = mix(smokeCol, 0.2*vec3(0.4, 0.4, 0.4), res.x);\n\t\tres.xyz*= 0.2 + 0.2*smoothstep(-2.0, 1.0, pos.y);\n    \tres.w*= max(smokeDens - 1.8*sqrt(pos.y - 4.), 0.);\n    }\n    else\n    {\n        d = 0.;\n        res = vec4(0.);\n    }\n\t\n\treturn res;\n}\n\n// Raymarching of the smoke\nvec4 raymarchSmoke(in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, bool isShadow)\n{\n\tvec4 sum = vec4(0.0);\n    vec2 windDir = rotateVec(vec2(1., 0.), windAngle);\n\n\tfloat t = isShadow?5.4:abs(0.95*(campos.z - chimneyOrig.z)/rd.z);\n\tfor(int i=0; i<32; i++)\n\t{\n\t\tif(t>tmax || sum.w>1.) break;\n\t\tvec3 pos = ro + t*rd;\n        \n        // Influence of the wind\n        pos.xz+= windDir*windIntensity*(pos.y + chimneyOrig.x - tubeclen - tubeLen2 + 0.3);\n\n\t\tvec4 col = mapSmoke(pos);\n\t\t\n        if (col != vec4(0.))\n        {\n        \t// Color modifications of the smoke\n        \tcol.rgb+= (1. - smokeColPresence)*(1.0 - col.w);\n\t\t\tcol.rgb = mix(col.rgb, bcol, smoothstep(smokeColBias, 0.0, col.w));\n\t\t\tcol.rgb*= col.a;\n\n\t\t\tsum = sum + col*(1.0 - sum.a);\n        }\n\t\tt+= 0.07*(1. + windIntensity)*max(0.1,0.05*t);\n\t}\n\tsum.rgb/= (0.001 + sum.a);\n\treturn clamp(sum, 0.0, 1.0);\n}\n#endif\n\n////////////////////////////////////////////////////////////////\n\nvec4 smokeRes;\n// From https://www.shadertoy.com/view/Xds3zN, but I changed the code\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<12; i++)\n    {\n    \tfloat h = map(ro + rd*t).x;\n        res = min(res, 10.0*h/t + 0.02*float(i));\n        t+= 1.5*clamp(h, 0.01, 0.5);\n        if(h<0.001 || t>tmax) break;\n    }\n    #ifdef show_smoke\n    vec4 rsr = raymarchSmoke(ro, rd, vec3(1.), 6., true);\n    return clamp(min(res, 1. - rsr.a*0.9), 0.0, 1.0);\n    #else\n    return clamp(res, 0.0, 1.0);\n    #endif\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<5; i++)\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos).x;\n        occ+= -(dd - hr)*sca;\n        sca*= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1 - n2)/(n1 + n2), (n1 - n2)/(n1 + n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return r;\n}\n\n// Shading of the objects\nvec3 lampShading(DirLamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, bool simple)\n{\n\tvec3 pl = normalize(lamp.direction);\n      \n    // Diffuse shading\n    vec3 col;\n    if (objnr==CHIMNEY_OBJ)\n        col = ocol*lamp.color*lamp.intensity*(0.1 + 0.75*pow(clamp(dot(norm, pl), 0., 0.93), 1.8));\n    else\n        col = ocol*lamp.color*lamp.intensity*clamp(dot(norm, pl), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    float specint2 = objnr==CHIMNEY_OBJ?specint[CHIMNEY_OBJ]:specint[BRICKS_OBJ];\n    float specshin2 = objnr==CHIMNEY_OBJ?specshin[CHIMNEY_OBJ]:specshin[BRICKS_OBJ];\n    if (dot(norm, lamp.direction) > 0.)\n        col+= lamp.color*lamp.intensity*specint2*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin2);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    if (!simple)\n        col*= shi*softshadow(pos, pl, shf, 7.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.52, 0.65);\n   else\n      iMouse2 = iMouse.xy;\n   \n   campos = vec3(19.*(1. - iMouse2.x/iResolution.x - 0.5),\n                 18.*(iMouse2.y/iResolution.y - 0.35),\n                 10.);\n   /*campos = camtarget + vec3(-20.*cos(3. + 6.*iMouse2.x/iResolution.x),\n                 20.*cos(3.*iMouse2.y/iResolution.y),\n                 20.*sin(3. + 6.*iMouse2.x/iResolution.x)*sin(3.*iMouse2.y/iResolution.y)); */\n    \n   camdir = camtarget-campos;   \n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0., 1., 0.), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x*vRight + vWindow.y*vUp + vForward*fov);\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool simple)\n{\n    #ifdef show_chimney\n    vec2 tr = simple?trace_s(tpos, ray, maxdist):trace(tpos, ray, maxdist);\n    #else\n    vec2 tr = trace(tpos, ray, maxdist);\n    #endif\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist)\n    {\n        #ifdef show_chimney\n        norm = simple?getNormal_s(pos, normdelta):getNormal(pos, normdelta);\n        col = simple?getColor_s(norm, pos, objnr):getColor(norm, pos, objnr);\n        #else\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr);        \n        #endif\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        float aofact;\n        if (!simple)\n           aofact = 1. - aoint + aoint*calcAO(pos, norm);\n        else\n           aofact = 1.;\n        #else\n        float aofact = 1.;\n        #endif\n        \n        // Shading\n        col = ambientColor*ambientint*aofact + lampShading(sunLamp, norm, pos, col, objnr, simple)*(0.6 + 0.4*aofact);\n    }\n    else\n    {\n        // Shows the color of the sky\n        objnr = SKY_OBJ;\n        col = simple?sky_color_s(ray):sky_color(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Function to get the intensity of the wind as a function \nfloat getWindIntensity(float t)\n{\n    return maxWindIntensity*smoothstep(-0.3, 2.2, sin(t*0.153 + 18.) + 0.63*sin(t*0.716 - 7.3) + 0.26*sin(t*1.184 + 87.));\n}\n// Function to get the angle of the wind as a function \nfloat getWindAngle(float t)\n{\n    return maxWindAngle*pi*(sin(t*0.0117) + 0.67*sin(t*0.0672 + 5.6) + 0.26*sin(t*0.1943 - 18.7));\n}\n\n// Main render function with diffuse reflections on the chimney\nvec3 ray;\nint robjnr;\nbool isIns;\nvec3 render(vec2 fragCoord, bool calcSmoke)\n{   \n    // The specular is different between the bricks and chimney\n    specint[BRICKS_OBJ] = 0.15;\n    specshin[BRICKS_OBJ] = 0.8;\n    specint[CHIMNEY_OBJ] = 0.95;\n    specshin[CHIMNEY_OBJ] = 15.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; \n    uv = uv*2.0 - 1.0;\n    uv.x*= iResolution.x / iResolution.y;\n\n    ray = GetCameraRayDir(uv, camdir, fov);\n\n    // Modification of the ray because of the air refraction due to the heat\n    #ifdef show_smoke\n    rayRef = vec3(0.);\n    smokeRes = raymarchSmoke(campos, ray, vec3(1.), 40., false);\n    #ifdef heat_refraction\n    ray+= rayRef;\n    #endif\n    #endif\n    \n    RenderData traceinf = trace0(campos, ray, maxdist, false);\n    vec3 pos = traceinf.pos;\n    vec3 col = traceinf.col;\n    robjnr = traceinf.objnr;\n    \n    #ifdef reflections\n    vec3 refray = reflect(ray, traceinf.norm);\n    if (robjnr==CHIMNEY_OBJ)\n    {   \n        vec3 cols = vec3(0.);\n        for (float r=0.; r<nbrref ;r++)\n        {\n           vec3 randpart = hash3(vec3(1.)*(1.74 + r*21.12 + aaindex) + 80.*traceinf.pos);\n           vec3 refray2 = refray + rrefblur*(randpart - vec3(0.5));\n           RenderData traceinf_ref = trace0(traceinf.pos, refray2, 20., true);\n           cols+= traceinf_ref.col;   \n        }\n        float r = clamp(fresnel(ray, traceinf.norm, 2.9), 0., 0.45);\n        col = mix(col, cols/nbrref, r);\n    }\n    #endif\n    \n    // Sets a variable if the smoke is inside the chimney\n    #ifdef show_smoke\n    isIns = map_int(pos)<0.04;\n    #endif\n    \n    return col;\n}\n\n// Main tracing function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    currTime = iTime*timeFactor;\n    setCamera();\n    windIntensity = getWindIntensity(currTime*0.8);\n    dWindIntensity = windIntensity - getWindIntensity(currTime*0.8 - 0.2);\n    windAngle = getWindAngle(currTime);\n    \n    // Antialiasing loop\n    vec3 vs = vec3(0.);\n    for (int j=0; j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0; i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy), i + j==0);\n          aaindex = 1.23*float(i) + 18.79*float(j);\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vs/vec3(aasamples*aasamples);\n    \n    // Adds the smoke to the image\n    #ifdef show_smoke\n    if (robjnr!=CHIMNEY_OBJ || isIns)\n        col = mix(col, smokeRes.xyz, smokeRes.w)*(1. + 0.06*smokeRes.w);\n    #endif\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dK3zc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2886, 2906, 2928, 2928, 2963], [2965, 2985, 3006, 3006, 3089], [3091, 3113, 3153, 3153, 3283], [4192, 4219, 4247, 4247, 4280], [4282, 4314, 4345, 4345, 4371], [4373, 4430, 4469, 4469, 4565], [4567, 4613, 4642, 4642, 4736], [4738, 4784, 4827, 4827, 4873], [4875, 4921, 4955, 4955, 5060], [5062, 5108, 5139, 5139, 5196], [5197, 5197, 5229, 5229, 5306], [5308, 5354, 5424, 5424, 5644], [5646, 5680, 5707, 5707, 6598], [9171, 9205, 9225, 9225, 9557], [9926, 9951, 9999, 9999, 10339], [10712, 10785, 10820, 10820, 11052], [11411, 11477, 11503, 11503, 11674], [11676, 11705, 11731, 11731, 12678], [12680, 12735, 12763, 12763, 13108], [13110, 13166, 13195, 13195, 13325], [13327, 13368, 13411, 13411, 13556], [13558, 13589, 13619, 13619, 14345], [14347, 14347, 14379, 14379, 14414], [14416, 14439, 14486, 14486, 14685], [14687, 14747, 14796, 14796, 14849], [18364, 18434, 18494, 18494, 18919], [18921, 18967, 19007, 19007, 19300], [19302, 19419, 19465, 19465, 19660], [19662, 19688, 19776, 19776, 20612], [20614, 20693, 20711, 20711, 21253], [21255, 21311, 21375, 21375, 21618], [21620, 21651, 21719, 21719, 22916], [22918, 22978, 23011, 23011, 23136], [23137, 23193, 23222, 23222, 23323], [23325, 23423, 23468, 23535, 24991], [24993, 25018, 25073, 25073, 26004]], "test": "untested"}
{"id": "4dKGWW", "name": "Cloth Texture Simulation", "author": "TambakoJaguar", "description": "I could simulate a cloth, and I think it finally got quite realistic. Sadly it needs much time to compile. There is an animation, but you can also change the perspective with the mouse.\nI now used a cheap trick to reduce moiré/aliasing.", "tags": ["test", "texture", "cloth", "fabrics", "threads", "woven"], "likes": 38, "viewed": 1043, "published": "Public", "date": "1454503043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"Cloth Texture Simulation\" by Emmanuel Keller aka Tambako - February 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n    \nLamp lamps[2];\n\nconst vec3 campos0 = vec3(40.3, -26.0, 1.2);\nvec3 campos;\nvec3 camdir = vec3(0., 0.75, -1.);\nvec3 camtarget0 = vec3(40.3, -26.0 , 0.);\nfloat fov = 10.;\n\nconst vec3 ambientColor = vec3(0.3, 0.4, 0.5);\nconst float ambientint = 0.03;\nconst vec3 objcolor1 = vec3(0.87);\nconst vec3 objcolor2 = vec3(0.39, 0.62, 0.85);\nconst vec3 objcolor3 = vec3(0.85, 0.33, 0.23);\n\nconst float tbrl = 3.;\nconst float difi = 0.73;\nconst float specint = 0.002;\nconst float specshin = 0.8;\nconst float aoint = 0.42;\nconst float ssstrmr = 0.18;\nconst float sssInt = 0.35;\n\nconst float txti0 = 0.4;\nconst float txtf = 30.;\n\nfloat normdelta = 0.00002;\n\nconst float fr0 = 0.022;\nfloat fr;\nconst float fe = 0.057;\nconst float fd = 0.395;\nconst float fds = 0.176;\nconst float twf = 65.;\nconst float twfs = -110.;\nconst float clsize = 60.;\nconst float tdv = 0.22;\nconst float tdd = 0.15;\nconst float ttwd = 0.002;\nconst float crv = 0.2;\nconst vec2 ffa = vec2(0.14, 0.37);\nconst float fft = 0.68;\n\nconst float maxdist = 1500.;\n\n// Be careful setting it, since it drastically increase the compiling time, but in the other\n// hand, it reduces the moire quite much.\n//#define ANTIALIASING\nconst float aawidth = 0.63;\nconst int aasamples = 1;\n\n#define SPECULAR\n#define SH_OA\n#define SS_SCATERING\n#define COL_TEXTURE\n#define POSSIZE_VAR\n\nfloat gtf;\nfloat gtf2;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\n// Simple \"random\" function\nfloat random(float co)\n{\n    return fract(sin(co*752.19) * 238.5);\n}\n\nfloat map_f_hor(vec3 pos, vec2 delta, float n)\n{\n    return length(vec2(mod(pos.y + delta.x, fe) - fe*0.6, pos.z + delta.y + fr*sin((pos.x + fe*2. + fe*floor(pos.y/fe))/fe*pi))) - fr*fds*0.86;\n}\n\nfloat hsf;\nfloat map_hor_small(vec3 pos, vec2 delta, float n)\n{\n    float fy = 132.*random(12.54*floor(pos.y/fe));\n    float ad = 1. + ttwd*hsf;\n                          \n    float angle = ad*twf*pos.x;\n    vec2 d1 = rotateVec(vec2(fr*fd, fr*fd), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_f_hor(pos, d1 + delta, n + 1.), map_f_hor(pos, d2 + delta, n + 2.)), map_f_hor(pos, -d2 + delta, n + 3.)), map_f_hor(pos, -d1 + delta, n + 4.)); \n}\n\nfloat pyd;\nfloat map_hor(vec3 pos)\n{  \n    float fy = 132.*random(1.254*floor(pos.y/fe));\n\n    fy = 17.5*random(2.452*floor(pos.y/fe));\n    pyd = fe*tdd*(1. - 0.45*0.5*sin(pos.x*2.15 + 13.*fy) - 0.3*0.5*sin(pos.x*4.12 + 42.*fy) - 0.25*0.5*sin(pos.y*8.72 + 70.*fy));\n    pos.y+= pyd;\n\n    hsf = 0.35*sin(pos.x*4.3 + 20.*fy) + 0.4*sin(pos.x*5.7 + 45.*fy) + 0.25*sin(pos.x*8.48 + 55.*fy);\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*tdv*hsf);\n    \n    float angle = twfs*pos.x;\n    vec2 d1 = rotateVec(vec2(fr*fds, fr*fds), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_hor_small(pos, d1, 1.), map_hor_small(pos, d2, 5.)), map_hor_small(pos, -d2, 9.)), map_hor_small(pos, -d1, 13.)); \n}\n\nfloat map_f_ver(vec3 pos, vec2 delta, float n)\n{\n    return length(vec2(mod(pos.x + delta.x, fe) - fe*0.6, pos.z + delta.y - fr*sin((pos.y + fe*2. + fe*floor(pos.x/fe))/fe*pi))) - fr*fds*0.86;\n}\n\nfloat vsf;\nfloat map_ver_small(vec3 pos, vec2 delta, float n)\n{    \n    float fx = 145.*random(19.36*floor(pos.x/fe));\n    float ad = 1. + ttwd*vsf;            \n    \n    float angle = ad*twf*pos.y;\n    vec2 d1 = rotateVec(vec2(fr*fd, fr*fd), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_f_ver(pos, d1 + delta, n + 1.), map_f_ver(pos, d2 + delta, n + 2.)), map_f_ver(pos, -d2 + delta, n + 3.)), map_f_ver(pos, -d1 + delta, n + 4.)); \n}\n\nfloat pxd;\nfloat map_ver(vec3 pos)\n{   \n    float fx = 145.*random(1.936*floor(pos.x/fe));\n    \n    fx = 45.8*random(1.885*floor(pos.x/fe)); \n    pxd = fe*tdd*(1. + 0.45*0.5*sin(pos.y*1.3 + 27.*fx) + 0.3*0.5*sin(pos.y*3.7 + 74.*fx) - 0.25*0.5*sin(pos.y*9.48 + 112.*fx));\n    pos.x+= pxd;\n    \n    vsf = 0.35*tdv*sin(pos.y*4.3 + 31.*fx) - 0.4*tdv*sin(pos.y*5.7 + 58.*fx) - 0.25*tdv*sin(pos.y*8.48 + 38.*fx);\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*tdv*vsf);\n    \n    float angle = twfs*pos.y;\n    vec2 d1 = rotateVec(vec2(fr*fds, fr*fds), angle);\n    vec2 d2 = d1.yx*vec2(1., -1);\n    return min(min(min(map_ver_small(pos, d1, 1.), map_ver_small(pos, d2, 5.)), map_ver_small(pos, -d2, 9.)), map_ver_small(pos, -d1, 13.)); \n}\n\nfloat map_s(vec3 pos)\n{  \n    vec3 pos0 = pos;\n    float fy = 132.*random(1.254*floor(pos.y/fe));\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*hsf);\n\n    pos.y+= pyd;\n    float fh = length(vec2(mod(pos.y, fe) - fe*0.6, pos.z + fr*sin((pos.x + fe*2. + fe*floor(pos.y/fe))/fe*pi))) - fr*1.1;\n \n    pos = pos0;\n    \n    float fx = 145.*random(1.936*floor(pos.x/fe));\n    fr = fr0*(-tdv*0.5 + 1. - 0.5*vsf);\n    \n    pos.x+= pxd;\n    \n    float fv = length(vec2(mod(pos.x, fe) - fe*0.6, pos.z - fr*sin((pos.y + fe*2. + fe*floor(pos.x/fe))/fe*pi))) - fr*1.1;\n    return min(fh, fv);\n}\n\nfloat map_s2(vec3 pos)\n{\n    return mix(map_s(pos), abs(pos.z) - fr*1.1, smoothstep(14., 23., iTime));\n}\n\nfloat map(vec3 pos)\n{\n    float disth = map_hor(pos);\n    float distv = map_ver(pos);\n    return mix(min(disth, distv), map_s2(pos), gtf);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat calcAO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor*hr + pos;\n        \n    \tfloat dd = map(aopos);\n        \n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float o;\n    float t = -cam.z/ray.z -0.05;\n    \n  \tfor (int i = 0; i < 27; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = map(pos);\n        if (dist<0.0006 || dist>maxdist)\n        {\n            o = (abs(dist-map_ver(pos))<abs(dist-map_hor(pos))?1.:0.);\n            break;\n        }\n        t+= dist*(0.75 + float(i)*0.06);\n  \t}\n  \treturn vec2(t, o);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e, float o)\n{\n    vec2 q = vec2(0., e); //vec2(0.,distance(campos, pos)*0.0005);\n    return normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n}\n\nvec3 color_hor(vec3 norm, vec3 pos)\n{\n    vec3 col = mix(mix(mix(objcolor1, mix(objcolor1, objcolor2, smoothstep(-0.1, 0.1, sin(abs(pos.y)*3.74*50./clsize))), smoothstep(0.66, 0.665, abs(pos.y/clsize))), objcolor2, smoothstep(0.88, 0.89, abs(pos.y/clsize))), objcolor3, smoothstep(0.62, 0.621, abs(pos.y/clsize))*smoothstep(0.6508, 0.6503, abs(pos.y/clsize)));\n\n    #ifdef COL_TEXTURE\n    float txti = txti0;\n    float fx = 14.64*random(2.857*floor(pos.x/fe));\n    float fc = 1. - crv*0.5*(1. + 0.5*sin(pos.y*1.6 + 60.*fx) + 0.5*sin(pos.y*2.5 + 90.*fx) + crv*0.5*sin(pos.y*3.88 + 155.*fx));\n    \n    col*= 1.1*fc*vec3(1. - txti + txti*clamp(2.*texture(iChannel0,pos.xy*vec2(5., txtf)).r, 0., 1.));\n    #endif\n    return col;\n}\n\nvec3 color_ver(vec3 norm, vec3 pos)\n{\n    vec3 col = mix(mix(mix(objcolor1, mix(objcolor1, objcolor2, smoothstep(-0.02, 0.02, sin(abs(pos.x + 0.02)*3.74*50./clsize))), smoothstep(0.66, 0.665, abs(pos.x/clsize))), objcolor2, smoothstep(0.88, 0.89, abs(pos.x/clsize))), objcolor3, smoothstep(0.62, 0.621, abs(pos.x/clsize))*smoothstep(0.6508, 0.6503, abs(pos.x/clsize)));\n\n    #ifdef COL_TEXTURE\n    float txti = txti0;\n    float fy = 21.23*random(2.316*floor(pos.y/fe));\n    float fc = 1. - crv*0.5*(1. + 0.2*sin(pos.x*1.6 + 70.*fy) + 0.3*sin(pos.x*2.2 + 90.*fy) + 0.25*sin(pos.x*3.88 + 130.*fy));    \n\n    col*= 1.1*fc*vec3(1. - txti + txti*clamp(2.*texture(iChannel0,pos.xy*vec2(txtf, 5.)).r, 0., 1.));\n    #endif\n    return col;\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    vec3 nlcol = normalize(lamp.color);\n      \n    // Diffuse shading\n    float b = abs(dot(norm, pli));\n    if (b<0.5 && norm.z<0.65 && iTime>18.4) b=1.3;\n    vec3 col = (1. - 0.35*smoothstep(14.7, 19., iTime))*lamp.intensity*ocol*(1. - difi + difi*nlcol*pow(b, tbrl));\n\n    // Specular shading\n    #ifdef SPECULAR\n    //if (dot(norm, lamp.position - pos) > 0.0)\n        col+= vec3(1., 0.7, 0.3)*nlcol*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n\t// Sub surface scattering from https://www.shadertoy.com/view/MdXSzX\n    #ifdef SS_SCATERING\n\tfloat transmission = map(pos + pl*ssstrmr)/ssstrmr;\n\tvec3 sssLight = ocol*nlcol*smoothstep(0.0,1.0,transmission);\n    col = col*(1. - sssInt) + sssInt*sssLight;\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<2; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(-70., 10., 190.), vec3(1., 0.99, 0.92), 1.5, .0001);\n  lamps[1] = Lamp(vec3(70., -40., 190.), vec3(1., 1., 1.), 1.5, .0001);\n    \n  vec2 uv = fragCoord.xy;\n  uv/= iResolution.xy;\n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x/iResolution.y;\n    \n  vec3 ray =  GetCameraRayDir(uv, camdir, fov);         \n    \n  vec2 t = trace(campos, ray, maxdist);\n  float tx = t.x;\n  vec3 col;\n\n  if (tx<maxdist)\n  {\n      vec3 pos = campos + tx*ray;\n      \n      if (abs(pos.x)>clsize || abs(pos.y)>clsize)\n          return vec4(ambientColor, 1.0);\n      \n      vec3 norm = getNormal(pos, normdelta, t.y);\n\n      vec3 colh = color_hor(norm, pos);\n      vec3 colv = color_ver(norm, pos);\n      if (t.y==0.) // Horizontal\n          col = colh;\n      else // Vertical\n          col = colv;\n      col = mix(col, (colh + colv)/2., smoothstep(14., 21., iTime));\n      \n      // Shading\n      col = ambientColor*ambientint + lampsShading(norm, pos, col);\n      \n      // Ambient Occlusion\n      #ifdef SH_OA\n      col*= 1. - aoint + 1.25*aoint*vec3(calcAO(pos, norm));\n      #endif\n  }\n  else\n  {\n      // Background\n      col = ambientColor;\n  }\n      \n  return vec4(col, 1.0);\n}\n\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.5, 0.4);\n   else\n      iMouse2 = iMouse.xy;\n   float tf = pow(80.*smoothstep(0., 80., iTime), 1.9)/9.;\n   //float tf = 0.;\n   //gtf2=0.;\n   vec3 camtarget = camtarget0*(1. - gtf2);\n   campos = campos0*(1. - gtf2) + tf*vec3(-5.*cos(2.*iMouse2.x/iResolution.x + 0.4),\n                 5.*cos(1.2*iMouse2.y/iResolution.y + 1.5),\n                 5.*sin(2.*iMouse2.x/iResolution.x)*sin(1.2*iMouse2.y/iResolution.y + 1.5));\n   camdir = camtarget-campos;   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tgtf = smoothstep(5., 17., iTime);\n\tgtf2 = smoothstep(15., 55., iTime);\n    \n    setCamera();\n    \n    // Antialiasing\n    #ifdef ANTIALIASING\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKGWW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1317, 1646, 1686, 1686, 1816], [1818, 1846, 1870, 1870, 1914], [1916, 1916, 1964, 1964, 2110], [2123, 2123, 2175, 2175, 2576], [2589, 2589, 2614, 2614, 3274], [3276, 3276, 3324, 3324, 3470], [3483, 3483, 3535, 3535, 3930], [3943, 3943, 3968, 3968, 4649], [4651, 4651, 4674, 4674, 5219], [5221, 5221, 5245, 5245, 5325], [5327, 5327, 5348, 5348, 5467], [5469, 5516, 5550, 5550, 5857], [5859, 5859, 5907, 5907, 6275], [6277, 6323, 6367, 6367, 6627], [6629, 6629, 6666, 6666, 7355], [7357, 7357, 7394, 7394, 8089], [8091, 8091, 8152, 8152, 9101], [9103, 9103, 9154, 9154, 9302], [9304, 9360, 9424, 9424, 9677], [9679, 9679, 9708, 9708, 10887], [10889, 10889, 10907, 10907, 11453], [11455, 11455, 11510, 11510, 12064]], "test": "untested"}
{"id": "4dKGzy", "name": "Benham's Disk Pattern 2", "author": "fontmaster", "description": "1. Enlarge the screen and look fixed to the center of the disk for 3 seconds.\n2. Try to perceive lines of colors from the center to the border of the disc.\n3. If you don't see the colors change the speed by cliking the mouse from the left to righ", "tags": ["colors", "color", "illusion", "disk", "optic", "benham"], "likes": 4, "viewed": 297, "published": "Public", "date": "1455157015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Benham's Disk Pattern 2\n// Created by fontmaster\n\n// Modified version of @P_Malin at:\n// https://www.shadertoy.com/view/MdSGWm\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// How to see the colors\n// 1. Enlarge the screen and look fixed to the center of the disk for 3 seconds.\n// 2. Try to perceive lines of colors from the center to the border of the disc.\n// 3. If you don't see the colors change the speed by cliking the mouse from the left to right.\n// 4. Change the maxfactorspeed on the code it's necessary.\n\n\n#define saturate(X) clamp(X, 0.0, 1.0)\n\n#define PI 3.141592653589793238462643383279502884197\n\n/////////////////////////////////////////////////////////////////////////////    \n// SPEED FACTOR -- CHANGE HERE!\n// If speedfactor is positive the order of the colors are inverted.\nfloat maxspeedfactor = -3.5;\n/////////////////////////////////////////////////////////////////////////////    \n    \n\n/////////////////////////////////////////////////////////////////////////////\n// Others custom values\nconst float fScale = 0.95;\t\t\nconst float fShutterAngle = 0.0; // Motion blur factor\n\n\n// These values create funny patterns\nconst float fStripeDistWidth = 0.025;\nconst float fStripeDistSpacing = 0.075;\n\n/////////////////////////////////////////////////////////////////////////////\n\n\nfloat Ramp( const in float x, const in float fBegin, const in float fEnd, const in float fFeather )\n{\n\tfloat fBeginScale = 1.0 / (fFeather * 2.0);\n\tfloat fBeginOffset = (fFeather - fBegin) / (fFeather * 2.0);\n\tfloat fFeatherBegin = saturate(x * fBeginScale + fBeginOffset);\n\n\tfloat fEndScale = -1.0 / (fFeather * 2.0);\n\tfloat fEndOffset = (fEnd + fFeather) / (fFeather * 2.0);\n\tfloat fFeatherEnd = saturate(x * fEndScale + fEndOffset);\n\t\n\treturn min( fFeatherBegin, fFeatherEnd );\n}\n\nfloat Arc( float fAngle, float fAngleFeather, float fAngleBegin, float fAngleEnd, float fDist, float fDistFeather, float fDistBegin, float fDistEnd)\n{\n\treturn min(Ramp( fAngle, fAngleBegin, fAngleEnd, fAngleFeather ),Ramp( fDist, fDistBegin, fDistEnd, fDistFeather ));\n}\n\nfloat DiskPattern( float fAngle, float fDist, float fAngleFeather, float fDistFeather )\n{\n\tfloat fResult = 0.0;\n\n\t// Semicircle\t\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, -0.75, 0.25, fDist, fDistFeather, -12.0, 12.0) );\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, 0.75, 1.5, fDist, fDistFeather, -12.0, 12.0) );\n\n\tfloat fStripeDist = 1.0 / 8.0;\n\n\tfloat fStripeAngle1;\n\tfloat fStripeAngle2;\n\t\n\tfStripeAngle1 = 0.25 + 0.5 / 2.0;\n\tfStripeAngle2 = 0.25 + 1.0 / 1.5;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\t\n\tfStripeAngle1 = 0.25 + 0.5 / 3.0;\n\tfStripeAngle2 = 0.25 + 1.0 / 3.5;\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\n\tfStripeAngle1 = 0.25 + 0.5 / 6.5;\n\tfStripeAngle2 = 0.25 + 1.0 / 6.0;\n\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\n\tfStripeAngle1 = 0.25 + 0.5 / 500.0;\n\tfStripeAngle2 = 0.25 + 1.0 / 11.0;\n\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\n\treturn fResult;\n}\n\nfloat speedfactor2;\n\nfloat GetShade(vec2 fragCoord)\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 vPos = vUV * 2.0 - 1.0;\n\tvPos.x *= iResolution.x / iResolution.y;\n\t\n\tfloat fAngle = atan(vPos.x, vPos.y) / (PI);\n\tfloat fDist = length(vPos);\n\t\t\n\tfDist /= fScale; // make it slightly smaller\n\n\tfloat fSpeed = iMouse.x>0.?PI * (-iMouse.x*maxspeedfactor/iResolution.x):PI*maxspeedfactor;\n\t\n\tfAngle = fract(fAngle + iTime * fSpeed);\n\tfloat fAngleFeather = abs(fSpeed * fShutterAngle * (1.0 / 60.0));\n\tfAngleFeather = max( fAngleFeather, 0.001 );\n\tfloat fDistFeather = fScale * 2.0 / iResolution.y;\n\n\tfloat fShade = 1.0 - DiskPattern( fAngle, fDist, fAngleFeather, fDistFeather );\n\t\n\tfloat fDiscOutline = Ramp( fDist, -0.5, 1.0, fDistFeather );\n\t\n\tfShade = mix(0.5, fShade, fDiscOutline);\n\n\tfShade = sqrt(fShade);\n\n\treturn fShade;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat fShade = GetShade(fragCoord);\n\t\n\tvec3 vCol = vec3(fShade);\t\n\t\n\tfragColor = vec4(vCol,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKGzy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1262, 1342, 1443, 1443, 1824], [1826, 1826, 1976, 1976, 2096], [2098, 2098, 2187, 2187, 5145], [5168, 5168, 5200, 5200, 5979], [5981, 5981, 6038, 6038, 6139]], "test": "untested"}
{"id": "4dV3DG", "name": "Carousel 2: horsPwr++; shiny--;", "author": "wjbgrafx", "description": "A modified version of the slow Carousel #1. This version is based on Inigo Quilez' \"Raymarching Primitives\" code.", "tags": ["3d", "raymarch", "modeling"], "likes": 2, "viewed": 1022, "published": "Public API", "date": "1456200586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n \tCarousel 2 : horsepower++ ; shiny--;\n \t\tby wjbgrafx\n \t\t\n \tThis code is a slightly modified version of\n \tRaymarching Primitives\n\thttps://www.shadertoy.com/view/Xds3zN\t\n \tCreated by inigo quilez - iq/2013\n \tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported \n\t\n\tAdditional sources:\n\n\tAntialiasing code in the castRay() function\n \tFrom \"Edge AA\"   Uploaded by Trisomie21 on 2014-Jul-29\n\thttps://www.shadertoy.com/view/MsfXDS\n\t\n\tgetRayDir() function\n\tFrom \"Distance Functions Playground, by Ruslan Shestopalyuk, 2014/15\n\thttps://www.shadertoy.com/view/MtXGDr\n\n\tcreateCamRotMatrix() function\n\tFrom\t\"Simple test/port of Mercury's SDF library to WebGL\"\n \thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh on 2015-Dec-16\n\n\t\"4-tap\" calcNormal() function\n\thttp://raymarching.com/WebGL/WebGL_ShadowsReflections.htm\n    Author - Gary \"Shane\" Warne\n\t\n\tUnsigned Triangle function by Inigo Quilez\t\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tSmooth Minimum blending function by Otavio Good\n\thttps://www.shadertoy.com/view/XtjXWD\n\n\tHG_SDF GLSL Library for building signed distance bounds by MERCURY\n\thttp://mercury.sexy/hg_sdf\n\t\n\t--------------------------------\n\tEditing and modification by wjb. \n\t\n\tThe modeling code within the map() function is licensed under a Creative\n\tCommons Attribution-NonCommercial-ShareAlike 4.0 International License.\n*/\n//==============================================================================\n\n#define PI \t\t\t\t\t3.1415926535897932384626433832795\n\n#define CAM_DIST \t\t\t75.0\n#define MAX_RAY_DIST\t\t150.0\n#define LOOK_AT  \t\t\tvec3( 0.0, 2.0, 0.0 )\n#define CAM_FOV_FACTOR\t\t4.0\n#define NUM_RAY_STEPS\t\t100\n\nvec3 lightPos = vec3( 0.0 );\n\n//------------------------------------------------------------------------------\n// Function declarations\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ); \nmat4 createCamRotMatrix();\nvec3 applyTexture( vec4 hitPosAndID );\nvec3 texture1( vec3 pos );\nvec3 texture2( vec3 pos );\nvec3 texture3( vec3 pos );\nvec3 texture4( vec3 pos );\nvec3 texture5( vec3 pos );\nvec3 texture6( vec3 pos );\nvec3 texture7( vec3 pos );\n\n// Comments here are from the HG_SDF Library.\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions);\nfloat fSphere(vec3 p, float r);\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin);\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius);\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height);\n// Cone with correct distances to tip and base circle. \n// Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height);\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r);\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c );\nfloat snoise(vec3 v);\nfloat smin(float a, float b);\n\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n\nvec2 map( vec3 p ) \n{\n\t// Copy p before repetition domain operation.\n\tvec3 p0 = p;\n\n\t// Ground Plane\n\tfloat objID = 1.0;\n\tvec2 ground = vec2( fPlane( p - vec3( 0.0, -1.0, 0.0 ),\n\t                      normalize( vec3( 0.0, 1.0, 0.0 ) ), 1.0 ), objID );\t\n\t\n\t// Ground ring for inner structure frame.\n\tobjID = 2.0;\n\tvec2 inGrndRing = vec2( fTorus( p - vec3( 0.0, -1.85, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\t\t\n\t// Top ring for inner structure frame.\n\tvec2 inUprRing = vec2( fTorus( p - vec3( 0.0, 9.7, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\t\n\t// Ground ring for outer structure frame.\n\tobjID = 3.0;\n\tvec2 outGrndRing = vec2( fTorus( p - vec3( 0.0, -1.85, 0.0 ), 0.15, 20.0 ), \n\t                                                                   objID );\t\n\t// Top ring for outer structure frame.\n\tvec2 outUprRing = vec2( fTorus( p - vec3( 0.0, 10.0, 0.0 ), 0.15, 20.0 ), \n\t                                                                   objID );\t\n\t// Roof\n\tobjID = 4.0;\n\tvec2 roof = vec2( fCone( p - vec3( 0.0, 10.0, 0.0 ), 20.0, 5.0 ), objID );\n\t\n\t// Repetition : \n\t//------------------------------------\n\tfloat segNum = pModPolar( p.xz, 6.0 );\n\t//------------------------------------\n\t\n\t// Inner ring poles\n\tobjID = 2.0;\n\tvec2 inrPole = vec2( fCylinder( p - vec3( 10.0, 0.0, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\n\t// Outer ring poles\n\tobjID = 3.0;\n\tvec2 outrPoleA = vec2( fCylinder( \n\t                       p - vec3( 19.3, 0.0, -5.0 ), 0.15, 10.0 ), objID );\n\t                                                                   \n\tvec2 outrPoleB = vec2( fCylinder( \n                           p - vec3( 19.3, 0.0,  5.0 ), 0.15, 10.0 ), objID );\n\t                                                                   \n\t// Roof dividers\n\tvec2 rfDivA = vec2( fCapsule( p, vec3( 19.3, 10.0, 5.0 ),\n\t                                 vec3(  0.0, 15.0, 0.0 ), 0.1 ), objID );\n\t\n\tvec2 rfDivB = vec2( fCapsule( p, vec3( 19.3, 10.0, -5.0 ),\n\t                                 vec3(  0.0, 15.0, 0.0 ), 0.1 ), objID );\n\t\n\t//------------------------------------\t\n\t// Calculating horse up/down movement.\n\t//------------------------------------\n\t// From the HG_SDF Library:\n\t// \"Many of the operators partition space into cells. An identifier\n\t// or cell index is returned, if possible. This return value is\n\t// intended to be optionally used e.g. as a random seed to change\n\t// parameters of the distance functions inside the cells.\"\n\t\n\t// I used the variable segNum for the return values, but they were not the\n\t// simple values I'd expected. The ranges or exact values returned for each \n\t// segment ( direction ) are listed below. So it wasn't just simply a matter\n\t// of testing for an individual value, it required testing in a certain\n\t// order: NW, NE, E, SE, W, SW, S, else N \n\t\n\t// nothing >3 or <-2\n\t// NW,W >2 and <=3\n\t// SW,W,NW >1 and <=2\n\t// nothing >1 and <2\n\t// NE,E,SE = 1\n\t// nothing >0 and <1\n\t// NE,E = 0\n\t// nothing >-1 and <0\n\t// NE = -1\n\t// nothing >-2 and <-1\n\t// NW = -2\n\t// nothing <-2\n\n\t// Assign varying y-coords for each horse copy.\n\tfloat bodyPosY = 0.0;\n\n\tif ( segNum <= -2.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime );\n\t}\n\telse if ( segNum < -1.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 150.0 );\n\t}\n\telse if ( segNum < 0.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 300.0 );\n\t}\n\telse if ( segNum < 1.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 450.0 );\n\t}\n\telse if ( segNum < 2.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 600.0 );\n\t}\n\telse if ( segNum < 3.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 750.0 );\n\t}\n\telse\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 900.0 );\n\t}\n\t\t\n\t//--------------------------------------------\n\t// Horse body\n\tobjID = 5.0;\n\tfloat y = 1.25; // Initial ground offset for horse body\n\t\n\tfloat body1= fSphere( p - vec3( 15.0, y + bodyPosY, -0.9 ), 0.9 );\n\tfloat body2 = fSphere( p - vec3(15.0, y + bodyPosY,  0.9 ), 0.9 );\n\tvec2 body = vec2( smin( body1, body2 ), objID );\n\n\t//--------------------------------------------\n\t// Legs\n\t// Front left leg in two parts\n\tfloat x = 14.3,\n\t      z = -1.2,\n\t      legFLa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t   \n\t                            vec3( x, -0.25 + bodyPosY, z - 0.61 ), 0.2 );\n\n\tvec2 legFLb = vec2( smin( body1, legFLa ), objID );\n\n\tvec2 legFL = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z - 0.61 ),\n\t                                vec3( x, -1.26 + bodyPosY, z - 0.6 ), \n\t                                0.16 ), objID );\n\t//--------------------------------------------\n\t// Front right leg in two parts\n\tx = 15.7;\n\tz = -1.2;\n\tfloat legFRa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t         \n\t                            vec3( x, -0.25 + bodyPosY, z + 0.13 ), 0.2 );\n\n\tvec2 legFRb = vec2( smin( body1, legFRa ), objID );\n\n\tvec2 legFR = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z + 0.12 ),\n\t                                vec3( x, -1.26 + bodyPosY, z + 0.9 ), \n\t                                0.16 ), objID );\t\n\t\n\t//--------------------------------------------\n\t// Back left leg in two parts\n\tx = 14.5;\n\tz = 1.2;\n\tfloat legBLa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t  \n\t                            vec3( x, -0.25 + bodyPosY, z - 0.75 ), 0.2 );\n\n\tvec2 legBLb = vec2( smin( body2, legBLa ), objID );\n\n\tvec2 legBL = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z - 0.75 ),\n\t                                vec3( x, -1.26 + bodyPosY, z - 0.6 ), \n\t                                0.16 ), objID );\n\t\n\t//--------------------------------------------\n\t// Back right leg in two parts\n\tx = 15.7;\n\tz = 1.2;\n\tfloat legBRa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t\n\t                            vec3( x, -0.25 + bodyPosY, z + 0.13 ), 0.2 );\n\n\tvec2 legBRb = vec2( smin( body2, legBRa ), objID );\n\n\tvec2 legBR = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z + 0.12 ),\n\t                                vec3( x, -1.26 + bodyPosY, z + 0.75 ), \n\t                                0.16 ), objID );\n\t\n\t//--------------------------------------------\n\t// Neck\n\tfloat neckA = fCapsule( p, vec3( 15.0, 2.0 + bodyPosY, -1.8 ),\n\t                          vec3( 15.0,  3.0 + bodyPosY, -2.3 ), 0.35 );\n\t                          \n\tvec2 neck = vec2( smin( neckA, body1 ), objID );\t\n\t\n\t//--------------------------------------------\n\t// Head\n\tfloat headA = fCapsule( p, vec3( 15.0, 3.1 + bodyPosY, -2.5 ),\n\t                           vec3( 15.0, 2.1 + bodyPosY, -3.25 ), 0.275 );\n\t \n\tvec2 head = vec2( smin( neckA, headA ), objID );\t\n\t\n\t//---------------------------------------------\t\n\t// Tail\n\tvec2 tail = vec2( fCapsule( p, vec3( 15.0,  1.6 + bodyPosY, 1.7 ),\n\t                                vec3( 15.0, -0.5 + bodyPosY, 2.5 ), \n\t                                0.125 ), objID );\n\t\n\t//---------------------------------------------\n\t// Ears\n\tvec2 earL = vec2( fCapsule( p, vec3( 14.6, 3.2 + bodyPosY, -2.2 ),\n\t                               vec3( 14.6, 3.9 + bodyPosY, -2.2 ),\n\t                               0.1 ), objID );  \n\t\n\tvec2 earR = vec2( fCapsule( p, vec3( 15.4, 3.2 + bodyPosY, -2.2 ),\n\t                               vec3( 15.4, 3.9 + bodyPosY, -2.2 ),\n\t                               0.1 ), objID );  \n\t\n\t//---------------------------------------------\n\t// Horse pole\n\tobjID = 2.0;\n\tvec2 hPole = vec2( fCylinder( \n\t                        p - vec3( 15.0, 0.0, 0.0 ), 0.05, 10.0 ), objID );\t\n\t// Flag pole\n\tvec2 flagPole = vec2( fCylinder(\t\n\t                        p - vec3( 0.0, 15.0, 0.0 ), 0.05, 3.0 ), objID );\n\t\n\t// Flag in non-repeated space: p0\n\tobjID = 6.0;\n\tfloat wind = sin( iTime );\n\tvec2 flag = vec2( udTriangle( p0, vec3(  0.0, 16.5, 0.0 ), \n\t                                  vec3(  0.0, 18.0, 0.0 ),\n\t                          vec3( -4.0, 17.0 + wind, wind * 2.0 ) ), objID );\n\t// Pole top spheres\n\tvec2 poleTopA = vec2( fSphere( p - vec3( 19.3, 10.5, -5.0 ), 0.4 ), objID );\n\tvec2 poleTopB = vec2( fSphere( p - vec3( 19.3, 10.5,  5.0 ), 0.4 ), objID );\n\t\n\t// Flag sphere\n\tobjID = 3.0;\n\tvec2 flagSphere = vec2( fSphere( p - vec3( 0.0, 15.4, 0.0 ), 0.4 ), objID );\n\t\n\t// Outer ring spheres\n\tobjID = 2.0;\n\tvec2 outRingA = vec2( fSphere( p - vec3( 19.3, -1.65, -5.0 ), 0.6 ), objID );\n\tvec2 outRingB = vec2( fSphere( p - vec3( 19.3, -1.65,  5.0 ), 0.6 ), objID );\n\n\t// Center sphere\n\tobjID = 7.0;\t\n\tvec2 cntrSphere = vec2( \n\t                      fSphere( p - vec3( 0.0, -9.0, 0.0 ), 10.0 ), objID );\n\t\n\t// Center ring spheres\n\tobjID = 4.0;\n\tvec2 cntrRingSphere = vec2( \n\t                      fSphere( p - vec3( 9.0, -1.25, 0.0 ), 0.75 ), objID ); \n\t                      \n\t//-------------------------------------------\n\t// Distance comparisons for minimum distance.\n\t\n\tvec2 closest = ground.s < inGrndRing.s ? ground : inGrndRing;\n\tclosest = closest.s < inUprRing.s ? closest : inUprRing;\n\tclosest = closest.s < outGrndRing.s ? closest : outGrndRing;\n\tclosest = closest.s < outUprRing.s ? closest : outUprRing;\n\tclosest = closest.s < roof.s ? closest : roof;\n\tclosest = closest.s < inrPole.s  ? closest : inrPole;\n\tclosest = closest.s < outrPoleA.s  ? closest : outrPoleA;\n\tclosest = closest.s < outrPoleB.s  ? closest : outrPoleB;\n\tclosest = closest.s < rfDivA.s  ? closest : rfDivA;\n\tclosest = closest.s < rfDivB.s  ? closest : rfDivB;\n\n\tclosest = closest.s < body.s ? closest : body;\n\tclosest = closest.s < legFLb.s ? closest : legFLb ;\n\tclosest = closest.s < legFL.s ? closest : legFL;\n\tclosest = closest.s < legFRb.s ? closest : legFRb ;\n\tclosest = closest.s < legFR.s ? closest : legFR;\n\tclosest = closest.s < legBLb.s ? closest : legBLb ;\n\tclosest = closest.s < legBL.s ? closest : legBL;\n\tclosest = closest.s < legBRb.s ? closest : legBRb ;\n\tclosest = closest.s < legBR.s ? closest : legBR;\n\tclosest = closest.s < neck.s ? closest : neck;\n\tclosest = closest.s < head.s ? closest : head;\n\tclosest = closest.s < tail.s ? closest : tail;\n\tclosest = closest.s < earL.s ? closest : earL;\n\tclosest = closest.s < earR.s ? closest : earR;\n\t\n\tclosest = closest.s < hPole.s ? closest : hPole;\n\tclosest = closest.s < flagPole.s ? closest : flagPole;\n\tclosest = closest.s < flag.s ? closest : flag;\n\tclosest = closest.s < poleTopA.s ? closest : poleTopA;\n\tclosest = closest.s < poleTopB.s ? closest : poleTopB;\n\tclosest = closest.s < flagSphere.s ? closest : flagSphere;\n\tclosest = closest.s < outRingA.s ? closest : outRingA;\n\tclosest = closest.s < outRingB.s ? closest : outRingB;\n\tclosest = closest.s < cntrSphere.s ? closest : cntrSphere;\n\tclosest = closest.s < cntrRingSphere.s ? closest : cntrRingSphere;\n\t\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// CALC NORMAL\n// -----------\n// http://raymarching.com/WebGL/WebGL_ShadowsReflections.htm\n// Author - Gary \"Shane\" Warne\n// If speed is an issue, here's a slightly-less-accurate, 4-tap version.  \n// Visually speaking, it's virtually the same    \n\nvec3 calcNormal( in vec3 p )\n{\n\n\tfloat eps = 0.005;\n\tfloat ref = map( p ).s;\n\tvec2 e = vec2( eps, 0.0 );\n\treturn normalize( vec3( map( vec3( p.x + eps, p.y, p.z ) ).s - ref,\n\t\t                    map( vec3( p.x, p.y + eps, p.z ) ).s - ref,\n\t\t                    map( vec3( p.x, p.y, p.z + eps ) ).s - ref ) ); \n}\n\n// end calcNormal()\n\n//------------------------------------------------------------------------------\n// This is a modified version of the lighting section of the render function in \n// IQ's Raymarching Primitives code\n\n// GET COLOR\n// ---------\n\nvec3 getColor( vec3 rayOrig, vec3 rayDir, float objDist, float objID )\n{\n    vec3 pos = rayOrig + objDist * rayDir;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rayDir, nor );\n    \n    vec3 clr = vec3( 1.0 );\n\tclr = mix( applyTexture( vec4( pos, objID ) ), clr, 0.5 );\n\t\n    // lighting        \n\tvec3  lig = normalize( lightPos );\n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), \n                                          0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rayDir),0.0,1.0), 2.0 );\n\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),6.0);\n\n\tvec3 lin = vec3(0.0);\n    lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n    lin += 0.20*amb*vec3(0.50,0.70,1.00);\n    lin += 0.30*dom*vec3(0.50,0.70,1.00);\n    lin += 0.30*bac*vec3(0.25,0.25,0.25);\n    lin += 0.40*fre*vec3(1.00,1.00,1.00);\n\tclr = clr*lin;\n\n\treturn clamp( clr, 0.0, 1.0 );\t\n}\t\n\n// end getColor()\n\n//------------------------------------------------------------------------------\n// From \tEdge AA   Uploaded by Trisomie21 in 2014-Jul-29\n//\t\t    https://www.shadertoy.com/view/MsfXDS\n\nvec4 blend( vec4 fg, in vec4 bg ) \n{\n\tfloat alpha = 1.0 - fg.a;\n\treturn fg + bg * alpha;\n}\n\n//------------------------------------------------------------------------------\n// From \tEdge AA   Uploaded by Trisomie21 in 2014-Jul-29\n//\t\t    https://www.shadertoy.com/view/MsfXDS\n\n// CAST RAY\n// --------\n\nvec3 castRay( in vec3 rayOrig, in vec3 rayDir )\n{\n\tvec4 clr = vec4(0.0);\t// Forground (pre-multiplied)\n\t \n\t      // Minimum distance considered an object hit\n\tfloat minHitDist = 0.001,   \n          // Distance to surface returned by map() from the most recent\n          // ray position\n          curDist = 0.0,\n          // The smallest of any distance returned from map() \t\n    \t  minCurDist = 1e20,\n          // The accumulation of all step distances returned from map()\n          sumDist = 0.0, \n          // The smallest value sumDist has held so far\n          minSumDist = 0.0,\n          // The objectID number of the current closest object\n          objID = -1.0, \t\n\t      // Keep track of the most recent object's ID number\n\t      storedObjID = -1.0,\n\t\t  // Keep track if moving closer to or away from a surface\n\t      movingCloserFlag = 1.0;\t\n\n    // Raymarch loop\n    for( int i = 0; i < NUM_RAY_STEPS; i++ )\n\t{\n        // Update the cumulative distance ray has traveled.\n        sumDist += curDist;\n\t    \n\t    // Find current closest distance and ID of closest object\n\t    vec2 res = map( rayOrig + rayDir * sumDist );\n        curDist = res.x;\n\t    objID = res.y;\n\n\t\t// If current closest distance is within hit distance, or\n\t\t// cumulative distance ray has travelled is beyond back plane\n\t\tif( abs( curDist ) < minHitDist || sumDist > MAX_RAY_DIST ) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// If the ray is closer than it's been to any object so far...\n\t\tif( curDist < minCurDist ) \n\t\t{ \n\t\t\t// then it's moving closer to an object\n\t\t\tmovingCloserFlag = 1.0;\n\t\t\t\n\t\t\t// Set the least distance to any object as the current distance\n\t\t\tminCurDist = curDist;\n\t\t\t\n\t\t\t// Set the current ray length as the minimum of any ray length\n\t\t\tminSumDist = sumDist;\n\t\t\t\n\t\t\t// Store the ID number of this closest object\n\t\t\tstoredObjID = objID;\n\t\t} \n\t\t// Otherwise the ray is moving away from the nearest object. Enter this\n\t\t// section only if the ray was most recently moving towards an object.\n\t\telse if( movingCloserFlag > 0.0 ) \n\t\t{ \n\t\t\t// moving away\n\t\t\tmovingCloserFlag = 0.0;\n\t\t\t\n\t\t\t// The outline pixel size is normalized to the screen height, based\n\t\t\t// on the length of the shortest ray length so far.\n\t\t\t// Changing pixSize changes the width of the antialiased 'outline'.\t\t\t\n\t\t\tfloat pixSize = ( minSumDist + 1.0 ) / iResolution.y;\n\n\t\t\t//----------------------------------------------------------------\n\t\t\t// This fragment of code can be used as a replacement for the code\n\t\t\t// just below, to enlarge the width of the antialiasing outline. It\n\t\t\t// will make the object edge appear fuzzier.\n\t\t\t//if ( minCurDist < pixSize * 4.0 ) \n\t\t\t//{\n\t\t\t//\t  float alpha = 1.0 - ( minCurDist / pixSize * 0.25 );\n\t\t\t//----------------------------------------------------------------\n\t\t\t\n\t\t\t// If the minimum ray-to-object length of any ray so far is less \n\t\t\t// than the pixel size\n\t\t\tif( minCurDist < pixSize ) \n\t\t\t{\n\t\t\t\t// The color transparency is based on the ratio of shortest\n\t\t\t\t// distance so far, to pixel size\n\t\t\t\tfloat alpha = 1.0 - ( minCurDist / pixSize );\n\t\t\t\t\t\t\n\t\t\t\t// Color of the closest object to the current ray position.\n\t\t\t\tvec3 rgb = getColor( rayOrig, rayDir, minSumDist, storedObjID );\n\t\t\t\tclr = blend( clr, vec4( rgb * alpha, alpha ) );\n\n\t\t\t\t// To view \"outlined\" pixels in white, uncomment this line:\n\t\t\t\t//clr = vec4(1.0);\n\t\t\t}\n\t\t\n\t\t} // end else if (... )\n    \n    } // end for( i... ) raymarch loop\n\t\t\t\n\t//---------------------------------------------------------\n\t// Toggle antialiasing: Turn off by uncommenting this line:\n\t//clr = vec4(0.0);\n\n\t//----------------------------------------------------------------\n\t// Toggle Color and Opacity: Turn off by uncommenting these lines:\n\t//if( objID > 1.0 ) \t{\tclr.a = 1.0;\t}\n\t//return vec3( pow( clr.a, 2.2 ) );\n\t\n\t//----------------------------------------------------------------\n\t\n\t// This gets the color of the object that was hit.\n\t// To show only the antialias outline, comment out these two lines.\n\tclr = blend( clr, \n\t                vec4( getColor( rayOrig, rayDir, sumDist, objID ), 1.0 ) );\n\t\n    return clr.rgb;\n}\n\n// end castRay()\n\n//------------------------------------------------------------------------------\n\n// RENDER \n// ------\n\nvec3 render( in vec3 rayOrig, in vec3 rayDir )\n{ \n    vec3 clr = castRay( rayOrig, rayDir );\n\treturn vec3( clamp( clr, 0.0, 1.0 ) );    \n}\n\n//------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\t// -1 to 1 screen\n\t// --------------\n\t// Adjust aspect ratio, normalize coords, center origin in xy-plane.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\t\n    vec2 m = iMouse.xy / iResolution.xy;\n\t\t \n \tmat4 camMat = createCamRotMatrix();\n\tvec3 camPos = vec3( camMat * vec4( 0.0, 2.0, -CAM_DIST, 1.0 ) );\t    \n    vec3 rayDir = getRayDir( camPos, normalize( LOOK_AT - camPos ), p );       \n\tvec3 rayOrig = camPos;\n\tlightPos = camPos;\n\n    vec3 clr = render( rayOrig, rayDir );\n\tclr = pow( clr, vec3(0.8) );\n\t\n    fragColor = vec4( clr, 1.0 );\n}\n\n//------------------------------------------------------------------------------\n// From\t\"Simple test/port of Mercury's SDF library to WebGL\"\n// https://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = iTime * 0.2;\n\t}\n\telse\n\t{\n\t\t// wjb added the 180 degree rotation ( PI ) because the objects were\n\t\t// being created on the negative side of the x-axis ( mirrored position\n\t\t// across z-plane ) instead of the positive side, where they should be.\n\t\tang = ( iMouse.x - iResolution.x * 0.5 ) * rotRange + PI;\n\t}\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = 0.25 * ( sin( iTime * 0.1 ) + 1.0 );\n\t}\n\telse\n\t{\n\t\t// Scale iMouse.y so x-axis rotation range is only from partway overhead\n\t\t// to just about level with ground.\n\t\tang = ( 0.4825 * iMouse.y - iResolution.y * 0.5 ) * rotRange; \n\t}\n\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n// From \"Distance Functions Playground, by Ruslan Shestopalyuk, 2014/15\n// https://www.shadertoy.com/view/MtXGDr\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n// APPLY TEXTURE\n// -------------\n\nvec3 applyTexture( vec4 hitPosAndID )\n{\n\tvec3 baseColor = vec3( 0.0 ),\n\t     pos = hitPosAndID.xyz;\n\t\n\tint objNum = int( hitPosAndID.w );\n\n\t// ground\n\tif ( objNum == 1 )\n\t{\t\t\n\t\tbaseColor = texture1( pos );\n\t}\t\n\t// inner rings, inner pillars\n\telse if ( objNum == 2 )\n\t{\n\t\tbaseColor = texture2( pos );\n\t}\t\n\t// outer rings, outer pillars\n\telse if ( objNum == 3 )\n\t{\n\t\tbaseColor = texture3( pos );\n\t}\t\n\t// roof\t\n\telse if ( objNum == 4 )\n\t{\n\t\tbaseColor = texture4( pos );\n\t}\n\t// horse\t\t\t\n\telse if ( objNum == 5 )\n\t{\n\t\tbaseColor = texture5( pos );\n\t}\t\n\t// pole top sphere\n\telse if ( objNum == 6 )\n\t{\n\t\tbaseColor = texture6( pos );\n\t}\t\n\t// center sphere\n\telse if ( objNum == 7 )\n\t{\n\t\tbaseColor = texture7( pos );\n\t}\t\n\t\n\treturn baseColor;\n}\n\n// end applyTexture()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 1\n// ---------\n\nvec3 texture1( vec3 pos )\n{\n\t//vec3 objClr = vec3( 0.0, 0.2, 0.7 );\t\n\tvec3 objClr = vec3( 0.0, 1.0, 1.0 );\t\n\t\t\n\tfloat scale = 1.0,\n\t\t  complexity = 5.0,\n\t\t  mixVal = 0.5;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Marble( triangular ) #1\n\tvec3 v = pos * scale;\n\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n\tt += snoise(v);\t\n\tfloat value = t - floor(t);\t\t\t\n\t// smooth out the discontinuity\n\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n\tvalue = 0.333 + value*0.667;\n\tvec3 color = vec3(value);\t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture1()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 2\n// ---------\n\nvec3 texture2( vec3 pos )\n{\n\tvec3 objClr = vec3( 1.0, 1.0, 0.0 );\t\n\t\t\n\tfloat scale = 4.0,\n\t\t  complexity = 2.5,\n\t\t  mixVal = 0.6;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Combination Marble( triangular) with Marble( sharp ) #10\n\t// Marble( triangular )\n\tvec3 v = pos * scale;\n\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n\tt += snoise(v);\t\n\tfloat value = t - floor(t);\t\t\t\n\t// smooth out the discontinuity\n\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n\tvalue = 0.333 + value*0.667;\n\tvec3 color = vec3(value);\t\t    \n\t// Marble ( sharp )  :  wjb added variable complexity factor\n\tt = (v.x + 2.0*v.y + 3.0*v.z);\n\tt +=  snoise(v) * complexity;\n\tvalue =  abs(sin(t));\n\tcolor /= vec3(sqrt(value)); // modified to divide    \t\t    \n\treturn mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture2()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 3\n// ---------\n\nvec3 texture3( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.75, 0.0, 1.0 );\t\n\t\t\n\tfloat scale = 1.0,\n\t\t  complexity = 1.0,\n\t\t  mixVal = 0.5;\t  \n\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Marble( triangular ) #1\n\tvec3 v = pos * scale;\n\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n\tt += snoise(v);\t\n\tfloat value = t - floor(t);\t\t\t\n\t// smooth out the discontinuity\n\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n\tvalue = 0.333 + value*0.667;\n\tvec3 color = vec3(value);\t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture3()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 4\n// ---------\n\nvec3 texture4( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.0, 0.15, 1.0 );\t\n\t\t\n\tfloat scale = 2.0,\n\t\t  complexity = 0.5,\n\t\t  mixVal = 0.6;\t  \n\t\n\t// wjb modified Perlin Noise 3D ( #19 )\n\t// With complexity = 1.0, squiggly lines in objColor on white\n\tvec3 v = pos * scale;\n\tfloat value = log( pow( snoise( v ), 2.0 ) ) * complexity; \n    value = 0.75 + value*0.25;\n    vec3 color = vec3( value);    \t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture4()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 5\n// ---------\n\nvec3 texture5( vec3 pos )\n{\n\treturn vec3( 0.0 );\n//\tvec3 objClr = vec3( 0.0 );\t\n//\t\n//\tfloat scale = 1.0,\n//\t\t  //complexity = 5.0,\n//\t\t  mixVal = 0.5;\t  \n//\t\n//\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n//\t// Marble( triangular ) #1\n//\tvec3 v = pos * scale;\n//\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n//\tt += snoise(v);\t\n//\tfloat value = t - floor(t);\t\t\t\n//\t// smooth out the discontinuity\n//\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n//\tvalue = 0.333 + value*0.667;\n//\tvec3 color = vec3(value);\t\t    \n//    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture5()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 6\n// ---------\n\nvec3 texture6( vec3 pos )\n{\n\tvec3 objClr = vec3( 1.0, 0.0, 0.0 );\t\n\t\n\tfloat scale = 2.0,\n\t\t  complexity = 5.0,\n\t\t  mixVal = 0.9;\t  \n\t\n\t// wjb modified Perlin Noise 3D ( #21 )\n\t// Blotches of objClr surrounded by very thin squiggly black lines\n\t// on white background\n\tvec3 v = pos * scale;\n\tfloat value = exp( inversesqrt( pow( snoise( v ), 2.0 ) * complexity ) ); \n    value = 0.75 + value*0.25;\n    vec3 color = vec3( value);    \t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\t\n}\n\n// end texture6()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 7\n// ---------\n\nvec3 texture7( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.0 ),//( 1.0, 0.0, 1.0 ),\n\t     color = vec3( 0.0 );\t\n\t\n\tfloat scale = 2.0,\n\t\t  mixVal = 0.5;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Checkerboard 3D #6\n\tvec3 v = pos * scale;\n\tfloat a = floor( v.x );\n\tfloat b = floor( v.y );\n\tfloat c = floor( v.z );\n\tif ( mod( a + b + c, 2.0 ) > 0.5 ) \n\t{  // a+b+c is odd\n\t    color = vec3( 0.3 ); // the dark value\n\t}\n\telse \n\t{  // a+b+c is even\n\t    color = vec3( 1.0 ); // the light value\n\t}    \t\t\n\treturn mix( color, objClr, mixVal );        \t\t\t\t\t\t\t\t\t\t\t\t\n}\n\n// end texture7()\n\n//------------------------------------------------------------------------------\n\n// TRIANGLE - unsigned\n// --------\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n//------------------------------------------------------------------------------\n\n// SMOOTH MINIMUM\n// --------------\n// https://www.shadertoy.com/view/XtjXWD\t-Otavio Good\n// smooth blending function; k should be negative. -4.0 works nicely.\nfloat smin(float a, float b)\n{\n\tfloat k = -4.0;\n\treturn log2( exp2( k * a ) + exp2( k * b ) ) / k;\n}\n\n//==============================================================================\n// The code below is excerpted from :\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n#define clamp(x,a,b) min(max(x,a),b)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//\n    // FOLLOWING CODE was OBTAINED FROM https://github.com/ashima/webgl-noise\n    // This is the code for 3D  Perlin noise, using simplex method.\n    //\n    \n    //------------------------------- 3D Noise ------------------------------------------\n    \n    // Description : Array and textureless GLSL 2D/3D/4D simplex \n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    // \n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      { \n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n      \n      // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n      \n      // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n      \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n      \n      // Permutations\n        i = mod289(i); \n        vec4 p = permute( permute( permute( \n                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n      \n      // Gradients: 7x7 points over a square, mapped onto an octahedron.\n      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n      \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n      \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n      \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n      \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n      \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n      \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n      \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n      \n      //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n      \n      // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                      dot(p2,x2), dot(p3,x3) ) );\n      }\n\n//------------------------------------------------------------------------------\n", "image_inputs": [{"id": "Xds3zS", "previewfilepath": "https://soundcloud.com/reichmarshall/gladiolus-rag-on-pipe-organ", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/reichmarshall/gladiolus-rag-on-pipe-organ", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dV3DG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[3145, 3160, 3181, 3228, 13764], [13862, 14110, 14140, 14140, 14422], [14644, 14671, 14743, 14743, 15763], [15785, 15970, 16006, 16006, 16060], [16247, 16272, 16321, 16321, 20348], [20450, 20472, 20520, 20520, 20610], [20612, 20694, 20752, 20938, 21397], [21619, 21686, 21713, 21713, 23001], [23227, 23270, 23331, 23331, 23618], [23722, 23757, 23796, 23796, 24489], [24596, 24623, 24650, 24691, 25216], [25319, 25346, 25373, 25373, 26162], [26265, 26292, 26319, 26319, 26844], [26947, 26974, 27001, 27001, 27424], [27527, 27554, 27581, 27581, 28152], [28255, 28282, 28309, 28309, 28775], [28878, 28905, 28932, 28932, 29491], [29594, 29704, 29729, 29729, 29748], [29749, 29749, 29801, 29801, 30308], [30391, 30551, 30581, 30581, 30651], [30653, 31389, 31421, 31421, 31446], [31448, 31522, 31578, 31578, 31620], [31623, 31668, 31716, 31716, 31790], [31792, 31876, 31920, 31920, 32023], [32025, 32097, 32146, 32146, 32183], [32185, 32210, 32270, 32270, 32341], [32343, 32439, 32488, 32488, 32987], [32990, 33103, 33153, 33153, 33543], [33968, 34399, 34420, 34420, 34477], [34487, 34487, 34508, 34508, 34565], [34575, 34575, 34597, 34597, 34645], [34655, 34655, 34687, 34687, 34747], [34757, 34757, 34785, 34785, 37361]], "test": "untested"}
{"id": "4dV3DK", "name": "Nasty Box Test", "author": "tomkel", "description": "A nasty ray-marched box demo ", "tags": ["procedural"], "likes": 0, "viewed": 156, "published": "Public", "date": "1456486858", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat pattern( vec3 p )\n{\n    p = mod( p, vec3( 32.0,32.0, 32.0) );    \n    float sum = 0.0;\n    for( float i = 4.0; i > 0.0;i--)\n    {\n        float e = pow( 2.0, i );\n        float v = 0.0;\n        if ( floor( p.x / e ) > 0.0 )\n        {\n            v++;\n        }\n        if ( floor( p.y / e ) > 0.0 )\n        {\n            v++;\n        }\n        if ( floor( p.z / e ) > 0.0 )\n        {\n            v++;\n        }\n        \n         sum += e * mod(v,2.0); \n       \n    }\n    \n    return sum / 32.0;\n}\n\n\nvec4 march2( vec3 start, vec3 ray )\n{\n    vec4 colour;\n    for ( int i = 0; i < 512; i++ )\n    {\n     \n        vec3 p = start;\n      \n        if ( p.y < -50.0 || \n             p.y > 50.0  )\n        {   \n             float value = pattern( vec3( p.x,p.z,p.y ));\n             return vec4( 0.0, value, value, 1.0 );\n        \n        }\n        \n        else if (  mod( floor(p.x/40.0), 2.0) > 0.0 && \n                   mod( floor(p.z/40.0), 2.0 )> 0.0 )\n        \t{\n            \tfloat value = pattern( p );\n                return vec4( value, 0, 0, 1.0 );\n       \n        \t}\n        \n        start += ray;\n    }\n    \n    return vec4(0,0,0,1.0);\n}\n\nvec4 march( vec3 start, vec3 ray )\n{\n    vec4 colour;\n    for ( int i = 0; i < 1024; i++ )\n    {\n        float fog = (1.0 - ( float(i) / 1024.0 ));\n     \n        vec3 p = start;\n      \n        if ( p.y < -50.0 || \n             p.y > 50.0  )\n        {   \n             float value = pattern( vec3( p.x,p.z,p.y ));\n             return (vec4( 0.0, value, value, 1.0 ) * 0.5 +\n                     march2( p + vec3(0,-ray.y, 0), vec3( ray.x, -ray.y, ray.z) ) * 0.5 ) * fog;\n        \n        }\n        \n       else if (  mod( floor(p.x/40.0), 2.0) > 0.0 && \n                   mod( floor(p.z/40.0), 2.0 )> 0.0 )\n        \t{\n            \tfloat value = pattern( p );\n                return vec4( value, 0, 0, 1.0 ) * fog;\n       \n        \t} \n        \n        start += ray;\n    }\n    \n    return vec4(0,0,0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    float angle = iTime;\n    vec3 m0 = vec3( cos( angle), 0, -sin(angle));\n    vec3 m1 = vec3( 0,1.0,  0 );\n    vec3 m2 = vec3( sin( angle), 0, cos(angle) );\n    vec3 local = vec3( uv.x - 0.5, (uv.y - 0.5) * aspect, 0.5);\n    vec3 ray = vec3( dot( local, m0 ), dot( local, m1 ), dot(local,m2)  );\n    //ray =  vec3( 0.5, uv.y - 0.5, uv.x - 0.5 );\n    vec3 origin = vec3( 2.0 + cos( iTime ) * 0.2, sin( iTime ) * 4.0, iTime * 10.0 );\n    vec3 pos = origin; //+ ray; //vec3( uv.x - 0.5, uv.y - 0.5, 0 );\n    float value = 0.0;\n    vec4 colour;\n\n\t\n\tfragColor = march( pos * 10.0, ray * 10.0  * 1.0/16.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dV3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 503], [506, 506, 543, 543, 1148], [1150, 1150, 1186, 1186, 1954], [1956, 1956, 2013, 2013, 2709]], "test": "untested"}
{"id": "4dy3Ry", "name": "radical rings", "author": "asneakyfatcat", "description": "feel the motion sickness ", "tags": ["raymarching", "raymarch", "torus", "color", "motion", "shift", "sickness"], "likes": 5, "viewed": 638, "published": "Public API", "date": "1454969869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 a)\n{\n    //return length(p)-1.0;\n    vec3 p = fract(a)*2.0-1.0;\n    //vec2 q = vec2(length(p.xz)-2.0 - sin(iTime),p.y);\n    vec2 q = vec2(length(p.xz)-1.0,p.y);\n    return length(q)-.07;\n}\n\nfloat trace(vec3 origin, vec3 ray)\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 64; ++i){\n     \tvec3 p = origin + ray*t;\n        float d = map(p);\n        t += d*.35;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //comment for no warping\n    uv.x += sin(uv.y+iTime);\n    \n    vec3 rey = normalize(vec3(uv, .5)); // decrease z for greater camera FoV\n    \n    float the = iTime*.5;\n    //rey.xz *= mat2(cos(the),-sin(the),sin(the),cos(the));\n    \n    // rotation matrix\n    rey *= mat3(cos(the),sin(the),sin(the),.7*sin(the),.7,0.0,-sin(the),cos(the),cos(the)); \n    \n    vec3 origin = vec3(iTime*.4,iTime*.2, 0.0);\n    float t = trace(origin, rey);\n    float fog = 1.0/(0.5+t*t*.3);\n    //vec3 fc = vec3(fog);\n    vec3 fc = vec3(sin(t)*9.0);\n    fc.x = sin(iTime)*fc.x;\n    fc.y = .33*sin(iTime)*fc.y;\n    fc.z = .7*cos(iTime)+1.0;\n    vec3 fcc = vec3(fog)*fc;\n    \n    //fc.x = (sin(iTime)+1.0)/2.0;\n    //fc.x = 2.0-2.0*sin(iTime);\n\tfragColor = vec4(fcc,.9);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dy3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 47, 203], [205, 205, 241, 241, 390], [392, 392, 449, 449, 1313]], "test": "untested"}
{"id": "4dy3WG", "name": "mgreen's Mandelbrot zoom", "author": "mgreen", "description": "Mandelbrots set, with a simple zoom animation", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 103, "published": "Public", "date": "1456061012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Mandelbrot\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat scale = iResolution.y / iResolution.x;\n\tuv=((uv-0.5)*5.5)*abs(1.0-sin(iTime));\n\tuv.y*=scale;\n\tuv.y+=0.63;\n\tuv.x-=0.55;\n    \n\tvec2 z = vec2(0.0, 0.0);\n\tvec3 c = vec3(0.0, 0.0, 0.0);\n\tfloat v;\n \n\tfor(int i=0;(i<255);i++)\n\t{\n \n\t\tif(((z.x*z.x+z.y*z.y) >= 4.0)) break;\n\t\tz = vec2(z.x*z.x - z.y*z.y, 2.0*z.y*z.x) + uv;\n \n\t\tif((z.x*z.x+z.y*z.y) >= 2.0)\n\t\t{\n\t\t\tc.b=float(i)/20.0;\n\t\t\tc.r=sin((float(i)/5.0));\n\t\t}\n \n\t}\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dy3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 15, 72, 72, 558]], "test": "untested"}
{"id": "4dy3zV", "name": "Implicit Motion Gradients", "author": "paniq", "description": "Sampling the same field at two different times to build a motion vector. This is useful for systems where surface particles need to track a changing surface. Hold mouse to see time gradient at that position.", "tags": ["time", "sdf", "gradient", "vector", "motion"], "likes": 22, "viewed": 1136, "published": "Public API", "date": "1455290300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2d vector graphics library\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.3\n\n// I release this into the public domain.\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    float scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n// save current source color, stroke width and starting\n// point from active context.\nContext save();\n// restore source color, stroke width and starting point\n// to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\nvoid arrow(vec2 u, vec2 n) {\n\tvec2 o = vec2(n.y, -n.x);\n\tmove_to(u);\n\tu += n;\n\tline_to(u);\n\tmove_to(u - o*0.2);\n\tline_to(u + o*0.2);\n\tline_to(u + n*0.4);\n\tclose_path();\n}\n\nfloat sdcircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdbox(vec2 p, vec2 b)\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dtf(vec2 p, float t) {\n    float a = sin(t*0.5)*3.0;\n    vec2 sc = vec2(sin(a),cos(a));    \n    vec2 rp = vec2(sc.y*p.x-sc.x*p.y, dot(sc,p));\n    float w = sin(t);\n    float b = sdbox(p - vec2(0.5,w*0.5), vec2(0.5));\n    return smin(b,mix(sdcircle(p,0.5),sdbox(rp, vec2(0.25, 0.5)),sin(t)*0.5+0.5),\n        mix(0.0,0.1,sin(t*12.0)*0.5+0.5));\n}\nvec2 grad(vec2 p, float t) {\n    vec2 eps = vec2(0.0,1e-3);\n    return vec2(\n\t\tdtf(p + eps.yx, t) - dtf(p - eps.yx, t),\n        dtf(p + eps.xy, t) - dtf(p - eps.xy, t)) / 2e-3;\n}\n\nfloat timef = 0.0;\nfloat myf2(vec2 p) {\n    return dtf(p, timef);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue(float n) {\n    return hue(0.66667 * (1.0 - clamp(n,0.0,1.0)));\n}\n\nvoid paint() {\n    float t = iTime;\n    \n    // clear screen\n    \n    float timest = 1.0/60.0;\n    float t0 = iTime;\n    float t1 = t0 + timest;\n    \n    vec2 o = get_origin();\n    vec2 v = grad(o, t0);\n    float dt = (dtf(o, t0) - dtf(o, t1)) / timest;\n    \n    set_source_rgb(vec3(v*dt,0.0)*0.5+0.5);\n    clear();\n\t\n    float dm = dtf(o, t1);\n    set_line_width_px(1.0);\n    set_source_rgba(vec4(vec3(1.0,1.0,1.0),0.5));\n\tfor (int i = 0; i < 5; ++i) {\n\t\tadd_field(dm-float(i)*0.2);\n\t\tstroke();\n\t}    \n    // graphs only look good at pixel size\n    set_line_width_px(1.0);\n    timef = t0;\n    graph2D(myf2);\n    set_source_rgba(vec4(vec3(0.0,1.0,1.0),1.0));\n    stroke();\n    timef = t1;\n    graph2D(myf2);\n    set_source_rgba(vec4(vec3(1.0),1.0));\n    stroke();\n    \n    \n    vec2 m = get_query();\n    vec2 mv = grad(m, t0);\n    float mdt = (dtf(m, t0) - dtf(m, t1));\n   \t\n    arrow(m, mv*mdt*20.0);\n    stroke();\n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    ScreenH = min(iResolution.x,iResolution.y);\n    AA = ScreenH*0.4;\n    AAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n    \n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        1.0,\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;    \n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;    \n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);    \n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape.x * 6.0, \n            1.0, (_stack.shape.x>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;    \n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA, 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);    \n\treturn wa * wb; //min(wa,wb);    \n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale/AA;\n}\n\nfloat get_gradient_eps() {\n    return _stack.scale/AA;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o += s;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    add_field(max(dmin.xz, dmin.yw) + length2(dmax));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    add_field(length2(pa - ba.xyxy*h.xxyy));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis; // * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    add_field(vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw)));\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord);\n    \n    paint();\n    \n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dy3zV.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[5084, 5168, 5196, 5196, 5338], [5340, 5340, 5373, 5373, 5401], [5403, 5403, 5432, 5432, 5519], [5521, 5521, 5562, 5562, 5655], [5657, 5657, 5685, 5685, 6006], [6007, 6007, 6035, 6035, 6185], [6206, 6206, 6226, 6226, 6254], [6256, 6304, 6327, 6327, 6381], [6383, 6383, 6397, 6397, 7305], [7482, 7542, 7569, 7569, 7595], [7597, 7657, 7678, 7678, 7787], [7789, 7789, 7826, 7826, 7912], [7914, 7914, 7960, 7960, 7993], [7995, 8103, 8131, 8131, 8683], [8711, 8711, 8730, 8730, 8763], [8765, 8765, 8783, 8783, 8816], [8818, 8818, 8842, 8842, 8910], [8912, 8912, 8928, 8928, 8949], [8951, 8951, 8978, 9000, 9081], [9083, 9083, 9111, 9111, 9345], [9347, 9347, 9371, 9371, 9451], [9453, 9453, 9480, 9480, 9686], [9688, 9688, 9714, 9714, 9948], [9950, 9950, 9972, 9972, 10098], [10100, 10100, 10121, 10121, 10177], [10179, 10179, 10203, 10203, 10263], [10265, 10265, 10299, 10299, 10323], [10325, 10325, 10339, 10339, 10403], [10405, 10405, 10431, 10431, 10463], [10465, 10465, 10491, 10491, 10512], [10514, 10514, 10538, 10538, 10611], [10613, 10613, 10638, 10638, 10685], [10687, 10687, 10704, 10704, 10748], [10750, 10750, 10773, 10773, 10900], [10902, 10902, 10926, 10926, 11066], [11068, 11068, 11106, 11106, 11244], [11246, 11246, 11283, 11283, 11318], [11320, 11320, 11349, 11349, 11529], [11531, 11531, 11553, 11553, 11617], [11619, 11619, 11632, 11632, 11671], [11673, 11673, 11703, 11703, 11732], [11734, 11734, 11767, 11767, 11812], [11814, 11814, 11840, 11840, 11870], [11872, 11872, 11893, 11893, 11958], [11960, 11960, 11984, 11984, 12067], [12069, 12069, 12084, 12084, 12125], [12127, 12127, 12143, 12143, 12181], [12183, 12183, 12201, 12201, 12258], [12260, 12260, 12290, 12290, 12315], [12317, 12317, 12375, 12375, 12414], [12416, 12416, 12445, 12445, 12481], [12483, 12483, 12531, 12531, 12562], [12564, 12564, 12598, 12598, 12657], [12659, 12659, 12681, 12681, 12727], [12729, 12729, 12756, 12756, 12800], [12802, 12802, 12834, 12834, 13023], [13025, 13025, 13081, 13081, 13124], [13126, 13126, 13156, 13156, 13249], [13250, 13250, 13290, 13290, 13313], [13315, 13315, 13337, 13337, 13388], [13390, 13390, 13422, 13422, 13444], [13446, 13461, 13483, 13483, 13701], [13703, 13703, 13735, 13735, 13757], [13759, 13759, 13778, 13778, 13810], [13859, 13893, 13939, 13939, 14452], [14454, 14523, 14569, 14569, 15089], [15091, 15091, 15124, 15124, 15290], [15292, 15292, 15351, 15351, 15396], [15398, 15398, 15441, 15441, 15502], [15504, 15504, 15546, 15546, 15588], [15590, 15650, 15707, 15707, 15774]], "test": "untested"}
{"id": "4dyGW3", "name": "Moving Blocky Blobs", "author": "VoidChicken", "description": "Blobs made of blocks.", "tags": ["3d", "noise", "blobs", "voxel", "random", "raymarcher", "minecraft", "animation", "blocks"], "likes": 5, "viewed": 136, "published": "Public", "date": "1456608047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n//This work by VoidChicken is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\n \n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\nvec3 pos;\nmat4 rm(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nfloat n (vec3 v) {\n\treturn noise(v/40.0+iDate.w/10.0);\n}\nbool isc (vec3 v, vec3 c) {\n    if (floor(length(v-c)) < 10.0) return false;\n\treturn n((v))>0.76;\n}\nvec3 ray(vec3 ro, vec3 rd) {\n\tfor (int i = 1; i < 512;i++) {\n\t\tvec3 p = ro+rd*float(i)/2.0;\t\n        p=floor(p/20.0)*20.0;\n\t\tif (isc(p, ro))\n\t\t\treturn (1.0-floor(float(i))/256.0)* vec3(sin(time), 1.0-sin(time), sin(-time));\n\t}\n\treturn vec3(0);\n}\n\nvoid mainImage( out vec4 v, in vec2 f ) {\n\n\tvec2 uv = ( f.xy / iResolution.xy ) ;\n\tvec4 a = vec4(uv-0.5, 1, 1);\n    a*= rm(vec3(0, 1, 0), 4.0*(iMouse.x/iResolution.x));\n     a*= rm(vec3(1, 0, 1), 4.0*(iMouse.y/iResolution.y));\n\tv = vec4(ray(vec3(0, 1, time*10.0), a.xyz) , 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 150, 171, 171, 201], [202, 202, 223, 223, 811], [822, 822, 855, 855, 1483], [1484, 1484, 1502, 1502, 1540], [1541, 1541, 1568, 1568, 1640], [1641, 1641, 1669, 1669, 1886], [1888, 1888, 1929, 1929, 2170]], "test": "untested"}
{"id": "4sc3W2", "name": "simple lighted sphere", "author": "samuelotherion", "description": "1st try", "tags": ["spherewithsimplelight"], "likes": 0, "viewed": 164, "published": "Public", "date": "1455491983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define left   -.5\n#define right  +.5\n#define bottom -.5\n#define top    +.5\n#define pi     +3.1415926535\n#define globalTimePeriod 2.\n#define globalTimeOffset 3. * pi / 2. //phase\n#define globalTimeSpeed  .1\n#define ld   0.01\n#define ldr ( 1. / ( ld ) )\n#define ld2  ( ld * ld )\n#define ld2r ( 1. / ( ld2 ) )\n\n\n\nstruct Ball {\n\n    vec3\n    pos;\n    \n    float\n    rad;\n\n    vec3\n    col;\n    \n    mat3\n    dir;\n\n};\n    \nstruct Light {\n\n\tvec3\n    pos,\n    col;\n};\n    \nstruct Wall {\n\n    vec3\n    pos;\n    \n    mat3\n    dir;\n\n    vec2\n    size;   \n};\n\nbool\nhit( out vec3 p_hitp, in vec3 p_eye, in vec3 p_dir, in Ball p_ball ) {\n\n    vec3\n    dist = p_ball.pos - p_eye;\n  \n    float\n    aa = dot( p_dir, p_dir ),\n    ab = dot( p_dir, dist ),\n    bb = dot( dist, dist ),\n    ds = ( p_ball.rad * p_ball.rad - bb ) * aa + ab * ab;\n    \n    if( 0. <= ds ) {\n    \n    \tds = sqrt( +ds );\n        \n        float\n        l = ( ab - ds ) / aa;\n        \n        p_hitp = p_eye + l * p_dir;\n        \n        return true;\n    }\n    \n    return false;\n}\n\nvoid\nmainImage( out vec4 fragColor, in vec2 fragCoord ) {\n        \n\tvec2\n    uv = ( fragCoord.xy / iResolution.xy - .5 ) * vec2( iResolution.x / iResolution.y, 1. ),    \n    muv = ( iMouse.xy / iResolution.xy - .5 ) * vec2( iResolution.x / iResolution.y, 1. ),\n    tuv = ( uv +.5 );// * vec2( iChannelResolution[ 0 ].x, iChannelResolution[ 0 ].y );\n    \n    float\n    t1 = globalTimeOffset + globalTimePeriod * pi * sin( globalTimeSpeed * iTime );\n    \n    vec3\n    eye = vec3( 0., 0., -5. ),\n    dir = vec3( uv, 0. ) - eye,\n    htp;\n\n    float\n    ballZ = 5.;\n    \n    vec3\n    muv3 = vec3( muv * ( ballZ - eye.z ) / ballZ, ballZ );\n\t\n    \n    Ball\n    b1 = Ball( muv3, .5, vec3( .75, .5, .25 ), mat3( 1., 0., 0., 0., 1., 0., 0., 0., 1. ) );\n        \n\tLight\n    l1 = Light( vec3( 1. * cos( t1 ), 0., 5. + 1. * sin( t1 ) ), 2. * vec3( 0., .4, .91 ) ),\n    l2 = Light( vec3( 1. * cos( t1 ), 1. * sin( t1 ), 5. ), vec3( .5, .3, .1 ) );\n        \n    vec2\n    ll1 = vec2( l1.pos.x, l1.pos.y ) * length( eye ) / length( l1.pos - eye ) - uv;\n    \n    float\n    l = length( ll1 );\n    \n    if( hit( htp, eye, dir, b1 ) ) {\n     \n        vec3\n        lgtcol = max( 0., 2. / pi * asin( ( dot( normalize( l1.pos - htp ), normalize( htp - b1.pos ) ) ) ) ) * l1.col,\n//        bllcol = 2. / pi * asin( ( dot( normalize( eye - htp ), normalize( htp - b1.pos ) ) ) ) * b1.col,\n        bllcol = max( 0., 2. / pi * asin( dot( normalize( eye - htp ), normalize( htp - b1.pos ) ) ) ) * b1.col,\n        col = vec3( 1. * ( .95 * bllcol + .5 * lgtcol * b1.col ) );\n\n        if( l < ld && l1.pos.z < htp.z ) {\n\n//            fragColor = vec4( 1. * ( ( 1. - 400. * l * l ) * l1.col + .5 * (  col ) * (  400. * l * l ) ), 1. );\n           \n\t    \tl = l * l;\n            \n            fragColor = vec4( .7 *( 1. - ld2r * l ) * l1.col, 1. ) + 0.3 * texture( iChannel1, tuv );\n        }\n        else {\n                \n            fragColor = vec4( .97 * col, 1. ) + .03 * texture( iChannel1, tuv );\n        }\n    }\n    else {\n        \n        if( l < ld ) {\n            \n            l = l * l;\n\n            fragColor = vec4( .7 * ( 1. - ld2r * l ) * l1.col, 1. ) + vec4( vec3( .3 * ld2r * l * texture( iChannel0, tuv ) ), 1. );\n        }\n        else {\n        \t\n            fragColor = vec4( 0.5, 0.4, 0.1, 1. ) * texture( iChannel0, tuv );\n        }\n    }\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sc3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[550, 550, 625, 625, 1037], [1039, 1039, 1096, 1096, 3370]], "test": "untested"}
{"id": "4sG3z3", "name": "Edge Detect (fixed)", "author": "ming", "description": "The original Edge Detect shader was created by mu6k (be found at https://www.shadertoy.com/view/4s23WV#).\nThis fork fixed the compile errors caused by ShaderToy update.", "tags": ["raymarching", "edge", "derivative", "toon"], "likes": 7, "viewed": 438, "published": "Public", "date": "1455509318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tDerivative based edge detection. \n\tdFdx() and dFdy() are applied to the surface normal. \n\tIt will detect discontinuities in the normal.\n\n*/\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nfloat t()\n{\n    return iTime - 4.0;\n}\nfloat df_back(vec3 p)\n{\n\treturn (16.0-length(p));\n}\n\nmat3 rot()\n{\n    return rotate_x(t()*.5)*rotate_y(t()*.5)*rotate_z(t()*.5);\n}\nvec3 trans()\n{\n    return vec3(sin(t()),cos(t()),sin(t()))*.1;\n}\n\n//2D texture based 3 component 1D, 2D, 3D noise\nvec3 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);}\n\nvec3 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod).xyz;}\nvec3 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod).xyz;}\nvec3 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev,lod).yz,lod).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s,lod).yz,lod).xyz,m);}\n\n\nfloat df_obj(vec3 p)\n{\n\tp += trans();\n\tp *= rot();\n\t\n\t//p = mod(p+vec3(2.0),4.0)-vec3(2.0);\n\tfloat s0 = dot(abs(p),vec3(1.0))-1.5;\n\ts0*=.5;\n\t\n\t//p*=rot;\n\t\n\tfloat s1 = length(p+vec3(1.,.0,.0))-.5;\n\tfloat s2 = length(p+vec3(.0,1.,.0))-.5;\n\tfloat s3 = length(p+vec3(.0,.0,1.))-.5;\n\tfloat s4 = length(p-vec3(1.,.0,.0))-.5;\n\tfloat s5 = length(p-vec3(.0,1.,.0))-.5;\n\tfloat s6 = length(p-vec3(.0,.0,1.))-.5;\n\ts0 = min(s0,s1);\n\ts0 = min(s0,s2);\n\ts0 = min(s0,s3);\n\ts0 = max(s0,-s4);\n\ts0 = max(s0,-s5);\n\ts0 = max(s0,-s6);\n\t\n\tp*=rot();\n\t\n\ts0 = min(s0,max(max(abs(p.x+2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+2.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-2.0),abs(p.x)),abs(p.y))-.25);\n\t\n\tp*=rot();\n\t\n\ts0 = min(s0,max(max(abs(p.x+4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+4.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-4.0),abs(p.x)),abs(p.y))-.25);\n\t\n\treturn s0;\n}\n\n\nfloat df(vec3 p)\n{\n\treturn min(df_obj(p),df_back(p));\n}\n\n\nvec3 nf(vec3 p)\n{\n\tfloat e = .01;\n\tfloat dfp = df(p);\n\treturn vec3(\n\t\t(dfp+df(p+vec3(e,.0,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,e,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,.0,e)))/e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec2 mouse = iMouse.xy/ iResolution.xy*2.0-1.0;\n\tmouse.x *= iResolution.x/iResolution.y*4.0;\n\t\n\tmat3 rotmat = rotate_y(mouse.x) * rotate_x(mouse.y);\n\t\n\tvec3 pos = vec3(.0,.0,-3.0)*rotmat ;\n\tvec3 dir = normalize(vec3(uv*.5,1.0-length(uv)*.25))*rotmat;\n\t\n\tvec3 light_dir = normalize(vec3(.4,.5,.6));\n\tvec3 light_color = vec3(.6,.5,.4);\n\t\n\tfloat dist;\n\t\n\tfor (int i=0; i<80; i++)\n\t{\n\t\tdist = df(pos);\n\t\tpos+=dir*dist;\n\t\tif (dist<.00001) break;\n\t}\n\n\tvec3 color = vec3(1.0);\n\tvec3 n = nf(pos);\n\t\n\tvec3 dfdxn = dFdx(n);\n\tvec3 dfdyn = dFdy(n);\n\t\n\tfloat lines = length((abs(dfdxn)+abs(dfdyn))*3.0);\n\tlines = lines*3.75;\n\tlines = lines-1.0;\n\tlines = clamp(lines,.0,1.0);\n\tif (lines>1.0)lines = 1.0;\n\t\n\tif (length(pos)>5.0)\n\t{\n\t\tcolor = vec3(1.0);\n\t}\n\telse\n\t{\n\t\tfloat oa = 0.5;//df(pos+n)*.5+.5;\n\t\tfloat od = 1.0;\n\t\t\n\t\tfor (int i=0; i<30; i++)\n\t\t{\n\t\t\tfloat fi = float(i);\n\t\t\toa += df_obj(pos+noise(fi)-vec3(.5))*.15;\n\t\t}\n\t\t\n\t\toa = min(1.0,oa);\n\t\t\n\t\tvec3 ocdir = light_dir;\n\t\tvec3 ocpos = pos+ocdir*.1;\n\t\tfor (int i=0; i<60; i++)\n\t\t{\n\t\t\tfloat dist = df_obj(ocpos);\n\t\t\tod = min(od,dist*10.);\n\t\t\tocpos += ocdir*dist*.3;\n\t\t\tif (dist<.0||dist>10.0) break;\n\t\t}\n\t\t\n\n\t\tod = max(.0,od);\n\t\t\n\t\t//oa -= mod(oa,.33);\n\t\t\n\t\tfloat diffuse = max(.0,dot(n,light_dir)*.8+.2)*od*oa*1.5;\n\t\n\n\t\t\n\t\tcolor = vec3(.1,.2,.3)*oa + diffuse*light_color;\n\t\t\n\t\n\t}\n\t\n\tvec3 color0 = mix(color,vec3(.0),lines);\n\tvec3 color1 = n*.4+.4;\n\tvec3 color2 = dfdxn+dfdyn;\n\tvec3 color3 = vec3(lines);\n\t\n\tfloat mt = mod(t(),32.0);\n\tfloat mti = mod(t(),1.0);\n\t\n\tif (mt<7.0){color = color0;}\n\telse if (mt<8.0){color = mix(color0,color1,mti);}\n\telse if (mt<11.0){color = color1;}\n\telse if (mt<12.0){color = mix(color1,color2,mti);}\n\telse if (mt<13.0){color = color2;}\n\telse if (mt<14.0){color = mix(color2,color3,mti);}\n\telse if (mt<18.0){color = color3;}\n\telse if (mt<19.0){color = mix(color2,color1-color3,mti);}\n\telse if (mt<24.0){color = color1-color3;}\n\telse if (mt<25.0){color = mix(color1-color3,color,mti);}\n\telse if (mt<29.0){;}\n\telse if (mt<30.0){color = mix(color,color0,mti);}\n\telse if (mt<32.0){color = color0;}\n\t\n\tcolor += noise(vec3(fragCoord.xy,t()*60.0))*0.01;\n\t\n\t\n\t\n\tfragColor = vec4(pow(color,vec3(.5)),1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sG3z3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[237, 278, 302, 302, 367], [368, 368, 391, 391, 478], [479, 479, 502, 502, 589], [590, 590, 613, 613, 699], [701, 701, 712, 712, 738], [739, 739, 762, 762, 790], [792, 792, 804, 804, 869], [870, 870, 884, 884, 934], [936, 984, 1004, 1004, 1070], [1071, 1071, 1090, 1090, 1148], [1149, 1149, 1168, 1168, 1427], [1429, 1429, 1460, 1460, 1530], [1531, 1531, 1561, 1561, 1623], [1624, 1624, 1654, 1654, 1929], [1932, 1932, 1954, 1954, 3209], [3212, 3212, 3230, 3230, 3267], [3270, 3270, 3287, 3287, 3433], [3436, 3436, 3493, 3493, 5759]], "test": "untested"}
{"id": "4sGGRt", "name": "Zebrablob", "author": "rohtie", "description": "This is why you should not skip leg day.", "tags": ["skiplegday"], "likes": 1, "viewed": 148, "published": "Public", "date": "1456150500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float waves(vec2 p) {\n    p.y += sin(p.x * 6.0) * 0.1;\n    p.y -= sin(iTime) * 0.15;\n\tp.y += sin(p.x * 12.0) * 0.06 * sin(iTime);\n    \n    p.y = mod(p.y, 0.25 + sin(iTime)*0.05);\n    \n    float res = abs(p.y);\n    res = smoothstep(0.11, 0.1, res);\n    \n    return res;\n}\n\nfloat circle(vec2 p) {\n    p.y += sin(p.x * 7.0 + iTime) * 0.35;\n    return smoothstep(0.6, 0.61, length(p));\n}\n\nvoid mainImage( out vec4 o, in vec2 p ) {\n    p /= iResolution.xy;\n\tp -= 0.5;\n    p.x *= iResolution.x / iResolution.y;\n    \n    \n    float res = waves(p);\n    res = max(res, circle(p));\n    \n    o.rgb = vec3(res) + (1.0 - circle(p)) * -abs(p.y) * 0.5 - circle(p) * 0.5 + circle(p) * (1.0 - length(p)) * 0.3;\n\n    p.y += sin(p.x * 0.21 + texture(iChannel0, vec2((p.x + 1.0) * 0.5, 0.0)).r * 0.1);\n    \n    o.r /= p.y + 0.07 * 2.0;\n    o.b += p.y * 0.4;\n    \n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 270], [272, 272, 294, 294, 383], [385, 385, 426, 426, 844]], "test": "untested"}
{"id": "4sK3Dy", "name": "Spinal Injury", "author": "rohtie", "description": "Hello.", "tags": ["spine"], "likes": 1, "viewed": 158, "published": "Public", "date": "1456234584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 o, in vec2 p) {\n    p = (p / iResolution.xy) - 0.5;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec2 q = vec2(p.x, mod(p.y + iTime * 0.4, 0.15));\n    q.x /= abs(q.y) * 8.0 + -1.0 + sin(iTime) * 0.6;\n    \n    float tri = smoothstep(0.2, 0.02, max(abs(q.y), smoothstep(0.6, 0.61, abs(q.x))));\n    o.rgb = (1.0 - tri) * vec3((0.5 + p.y) * 0.75, (1.0 - abs(p.x)) * 0.02, (1.0 - p.y) * 0.2) +\n        \ttri * vec3(1.0, p.y * 4.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sK3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 458]], "test": "untested"}
{"id": "4sK3RK", "name": "Heart PGATR", "author": "Jachu", "description": "This is an ongoing project.\nIbÃ³n GuillÃ©n.\nAlfredo Cerezo.", "tags": ["heart"], "likes": 1, "viewed": 138, "published": "Public", "date": "1455365867", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat atan2(in float x, in float y)\n{\n    if (x > 0.0) {\n        return atan(y/x);\n    } else if (x < 0.0) {\n        if (y >= 0.0) {\n            return PI + atan(y/x);\n        } else {\n            return PI - atan(y/x);\n        }\n    }\n    \n    return sign(y)*PI/2.0;\n}\n\nfloat computeHeartBeatFrequency(float t){   \n    float ss = pow(t, 0.2)*1.2;\n    ss = 1.0 + ss*sin(2.0*PI*t)*exp(-t*4.0);\n    \n    return ss;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // convert screen coordinates to -1:1\n    vec2 uv = fragCoord.xy / vec2(iResolution.xy);\n    uv = 2.0*uv + vec2(-1.0);\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 position = vec2(uv.x * aspect, uv.y);\n    \n    // correct point coordinates\n    float dx = 0.05;\n    float dy = -0.1;\n    \n    position.x -= dx;\n    position.y += dy;\n    \n    // time\n    float speedRedction = 1.;\n    float time = mod(iTime/speedRedction, 1.5)/1.5;\n    \n    float heartBeat = computeHeartBeatFrequency(time);\n    \n    // heart function\n    float theta = atan2(position.y, position.x + dx);\n    float xh = 11.0*pow(sin(theta), 5.0);\n    float yh = 10.9*cos(theta) - 4.83*cos(2.27*theta) - 3.33*cos(3.32*theta) - 1.1*cos(3.77*theta);\n    \n    xh = xh/(30.0 - 10.0*heartBeat);\n    yh = yh/(30.0 - 10.0*heartBeat);\n    \n    vec2 heartPoint = vec2(xh, yh);\n\n    // distances\n    float distHeart = distance(heartPoint, vec2(0,0));\n    float distPoint = distance(position, vec2(0,0));\n\n    // colors\n    vec3 color = vec3(1.0);\n    vec3 lcolor = vec3(0.2 + sin(abs(theta)), 0.0, 0.0)*1.5*heartBeat*heartBeat;\n    vec3 bcolor = vec3(0.1 - 0.01*position.y)*(1.0 - 0.25*length(position))*heartBeat*heartBeat;\n    \n    float thres = 0.1;\n    \n    if (distHeart > distPoint) {\n        color = mix(lcolor, bcolor, smoothstep(-thres*0.5, thres*0.9, (distHeart - distPoint)));\n    } else {\n        color = mix(bcolor, lcolor, smoothstep(-thres*0.5, thres*0.5, (distHeart - distPoint)));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sK3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 83, 83, 315], [317, 317, 358, 358, 460], [462, 462, 517, 559, 2039]], "test": "untested"}
{"id": "4sK3WV", "name": "Solaris", "author": "piratehurrdurr", "description": "Modified this after receiving some advice.", "tags": ["raymarching", "trippy", "whynot"], "likes": 4, "viewed": 269, "published": "Public", "date": "1456497647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IT 64\n#define MAX 10.0\n#define EP 1e-3\n#define EPN 1e-2\n#define CS .xzy\n\n#define E 2.71828182845904523536028747135266249775724709369995\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Uncomment to only see AO\n//#define AMBONLY\n\n#define aoc 12\n#define aos 0.109\n\nvec3 aoOffsets[aoc];\n\nvec3 amb(vec3 dir) {\n    \n    vec3 skyBase = vec3(0.6, 0.8, 0.9)*(1.0+0.6*dot(dir, vec3(0.0,0.0,-1.0)));\n    float sunStr = pow(max(1.05* dot(dir, normalize(vec3(1.0,1.0,1.0))),0.0),6.0);\n\tvec3 skySun = vec3(0.5,0.5,0.2)*sunStr;\n    \n    skyBase = rgb2hsv(skySun*5.0+skyBase);\n    skyBase.x += iTime/5.0;\n    skyBase.y =(skyBase.y +1.0)/2.0;\n    skyBase = hsv2rgb(skyBase);\n    \n    return skySun+skyBase;\n    \n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nfloat terrain(vec2 pos) {\n    return (\n        texture(iChannel0,pos/15.0).r/3.0-texture(iChannel1,pos/64.0).g/5.0)\n        -(pow(length(pos.xy),2.0)*0.003)\n        +sin(-iTime+length(pos)*5.0)/10.0\n        \n        ;\n        ;\n}\n\n\nfloat dist(vec3 pos) {\n    \n    \n    return max(min(\n        max(sphere(pos,0.5), -sphere(vec3(0.5)-pos,0.5)),\n        -(terrain(pos.xy)-pos.z)\n        ),min(-sphere(-pos,0.48),pos.z-0.2));\n    \n}\n\n\nfloat AO(vec3 pos) {\n    float hit;\n    float total = float(aoc);\n    \n    for (int i=0; i<aoc; i++) {\n        float d = dist(pos+aoOffsets[i]);\n        if (d>0.0) {\n            hit+=d;\n        }\n    }\n    \n    //float total = 3.0*3.0*3.0;\n    //for (int i=-1; i<=1; i++) {\n    //    for (int j=-1; j<=1; j++) {\n    //        for (int k=-1; k<=1; k++) {\n    //            float d= dist(pos+vec3(i,j,k)*0.1);\n    //            if (d>=0.0) {\n    //                hit+=d;\n    //            }\n    //                 }\n    //    }\n    //}\n    return max(min(hit*32.0/total,1.0),0.0);\n}\n\nvec3 scan(vec3 pos, vec3 dir) {\n    \n    float totalDistance=0.0;\n    for (int i=0; i<IT; i++) {\n        float rayDist = dist(pos);\n        totalDistance+=rayDist;\n        if (abs(rayDist)<=EP) {\n            \n           #ifdef AMBONLY\n            return vec3(AO(pos));\n            #endif\n            \n            if (pos.z<0.0) {\n            //return amb(reflect(dir, vec3(0.0,0.0,1.0)));\n            }\n            \n            vec2 eps = vec2(0.0, EPN);\n\t\t\tvec3 normal = normalize(vec3(\n    \t\tdist(pos + eps.yxx) - dist(pos - eps.yxx),\n    \t\tdist(pos + eps.xyx) - dist(pos - eps.xyx),\n    \t\tdist(pos + eps.xxy) - dist(pos - eps.xxy)));\n            \n            \n            \n            vec3 sunColor = vec3(1.0,0.8,0.4);\n            vec3 sunVector = normalize(vec3(1.0,1.0,1.0));\n            float sunAtten = max(0.0, dot(sunVector,normal));\n            \n            vec3 ambientColor = vec3(0.6,0.8,1.0);\n            float ambientAtten = AO(pos);\n            \n            vec3 reflDir = reflect(dir, normal);\n            sunAtten+=pow(max(dot(reflDir, sunVector),0.0),16.0)*ambientAtten;\n            \n            //return vec3(ambientAtten);\n            \n            vec4 fog = vec4(0.6, 0.8, 0.9,1.0-1.0/pow(E,totalDistance*0.05));\n            fog.a=0.0;\n            \n            vec3 light = sunColor*sunAtten + ambientColor*ambientAtten;\n            vec3 world = mix(texture(iChannel1, pos.xy/7.0).rgb,texture(iChannel1,pos.xy).rgb,0.5)*light;\n            \n            vec3 finalColor = mix(world, fog.rgb,fog.a);\n            \n            finalColor = rgb2hsv(finalColor);\n            finalColor.x -= iTime;\n            finalColor.x += totalDistance*3.0+ length(pos+vec3(cos(iTime)*20.0,sin(iTime)*20.0,0.0));\n            finalColor = hsv2rgb(finalColor);\n            \n            return finalColor ;//*texture(iChannel2, normal).rgb;\n        }\n        if (totalDistance>=MAX) {\n            return amb( reflect(dir, vec3(0.0,0.0,1.0)));\n        }\n        pos+=dir*(rayDist);\n    }\n    \n    if (dir.z<0.0) {\n    \treturn amb( reflect(dir, vec3(0.0,0.0,1.0)));\n    }\n    return amb(dir);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 uv){\n    uv = (uv-iResolution.xy/2.0)/iResolution.y;\n    float a = iTime*0.125;\n    \n    \n\naoOffsets[0]=vec3(\taos*0.0\t\t\t,aos*-0.525731\t\t,aos*0.850651);\naoOffsets[1]=vec3(\taos*0.850651\t,aos*0.0\t\t\t\t,aos*0.525731);\naoOffsets[2]=vec3(\taos*0.850651\t,aos*0.0\t\t\t\t,aos*-0.525731);\naoOffsets[3]=vec3(\taos*-0.850651\t,aos*0.0\t\t\t\t,aos*-0.525731);\naoOffsets[4]=vec3(\taos*-0.850651\t,aos*0.0\t\t\t\t,aos*0.525731);\naoOffsets[5]=vec3(\taos*-0.525731\t,aos*0.850651\t\t,aos*0.0);\naoOffsets[6]=vec3(\taos*0.525731\t,aos*0.850651\t\t,aos*0.0);\naoOffsets[7]=vec3(\taos*0.525731\t,aos*-0.850651\t\t,aos*0.0);\naoOffsets[8]=vec3(\taos*-0.525731\t,aos*-0.850651\t\t,aos*0.0);\naoOffsets[9]=vec3(\taos*0.0\t\t\t,aos*-0.525731\t\t,aos*-0.850651);\naoOffsets[10]=vec3(\taos*0.0\t\t\t,aos*0.525731\t\t,aos*-0.850651);\naoOffsets[11]=vec3(\taos*0.0\t\t\t,aos*0.525731\t\t,aos*0.850651);\n\t\n\n    \n    //vec3 pos = vec3(cos(a/4.0+sin(a/2.0)),cos(a*0.2),sin(a*0.31)/4.5+1.0)*3.0;\n    vec3 pos = vec3(cos(iMouse.x/64.0),sin(iMouse.x/64.0),iMouse.y/64.0+0.3);\n    vec3 on = vec3(1.0,uv.x,uv.y);\n    vec3 n = pos;\n\n    //n = normalize(pos + (0.1*vec3(cos(a*2.3),cos(a*2.61),cos(a*1.62))));\n\tvec3 crossRight = normalize( cross(n,vec3(0.0,0.0,1.0)));\n\tvec3 crossUp = normalize(cross(n, crossRight));\n\tn = n*(0.5+sin(length(uv-0.5)*5.0+iTime)/5.0) + crossRight*uv.x + crossUp*uv.y;\n    \n    fragColor.rgb = scan(pos,-normalize(n)).rgb;\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sK3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 167, 167, 498], [500, 500, 522, 522, 691], [693, 795, 815, 815, 1207], [1209, 1209, 1247, 1247, 1282], [1284, 1284, 1316, 1316, 1364], [1366, 1366, 1391, 1391, 1595], [1598, 1598, 1620, 1620, 1794], [1797, 1797, 1817, 1817, 2378], [2380, 2380, 2411, 2411, 4472], [4474, 4474, 4520, 4520, 5873]], "test": "untested"}
{"id": "4sKGDw", "name": "afka", "author": "cardmechanic", "description": "kalafka", "tags": ["afla"], "likes": 1, "viewed": 94, "published": "Public", "date": "1454842011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Dreieck \n{\n    vec2 pos,\n        width,\n        height;\n        \n    vec4 col;\n};\n\nDreieck dro = Dreieck (vec2 (0.+ cos(iTime),.6),vec2 (.15,.0), vec2 (0.,.5), vec4(1.,0.5,.25,1.)),\n    \tdrre = Dreieck (vec2 (.33+cos(iTime),.27),vec2 (.5,.0), vec2 (0.,.15), vec4(1.,0.5,.25,1.)),\n   \t\tdrri = Dreieck (vec2 (.29 +cos(iTime),.26),vec2 (.37,.0), vec2 (0.,.09), vec4(1.,0.5,.25,1.)),\n    \tdroi = Dreieck (vec2 (-0.014 +cos(iTime),.55),vec2 (.09,.0), vec2 (0.,.37), vec4(0.,1.5,.0,1.));\n  \nvec4 Hiteck (in vec2 p_uv, in Dreieck p_dr){\n  \n        vec2 xynew = p_uv - p_dr.pos;\n        float\n        x = dot(xynew, p_dr.width)/dot(p_dr.width, p_dr.width),\n        y = dot(xynew, p_dr.height)/dot(p_dr.height, p_dr.height); \n        \n    if (abs(x)>.5 || abs(y) >.5)\n    { \n        return vec4(.0);\n    }\n     if (x+y < 0.0 )\n        return p_dr.col;\n    return vec4 (.0);\n   \n} \n\nDreieck drl = Dreieck (vec2 (-.325 +cos(iTime),.265),vec2 (.5,.0), vec2 (0.,.15), vec4(1.,0.5,.25,1.)),\n    \tdrli = Dreieck (vec2 (-.29 +cos(iTime),.28),vec2 (.37,.0), vec2 (0.,.09), vec4(1.,0.5,.25,1.)),\n   \t\tdru = Dreieck (vec2 (0.003 +cos(iTime),-.065),vec2 (.15,.0), vec2 (0.,.5), vec4(1.,0.5,.25,1.)),\n    \tdrui = Dreieck (vec2(0.01 +cos(iTime),-.035),vec2 (.09,.0), vec2 (0.,.37), vec4(0.,1.5,.0,1.));\n                     \n      vec4 Hiteck2 (in vec2 p_uv, in Dreieck p_dr){\n  \n        vec2 xynew = p_uv - p_dr.pos;\n        float\n        x = dot(xynew, p_dr.width)/dot(p_dr.width, p_dr.width),\n        y = dot(xynew, p_dr.height)/dot(p_dr.height, p_dr.height); \n        \n    if (abs(x)>.5 || abs(y) >.5)\n    { \n        return vec4(.0);\n    }\n     if (x+y > 0.0 )\n        return p_dr.col;\n    return vec4 (.0);\n   \n}              \n     \nDreieck rm = Dreieck (vec2(0.0045 +cos(iTime),.267),vec2 (.145,.0), vec2 (0.,.14), vec4(1.,0.5,.25,1.));\n\n\n vec4 Hiteck3 (in vec2 p_uv, in Dreieck p_dr){\n  \n        vec2 xynew = p_uv - p_dr.pos;\n        float\n        x = dot(xynew, p_dr.width)/dot(p_dr.width, p_dr.width),\n        y = dot(xynew, p_dr.height)/dot(p_dr.height, p_dr.height); \n        \n    if (abs(x)>.5 || abs(y) >.5)\n    { \n        return vec4(.0);\n          }\n     if (x*x+y*y < .275*.275)\n         return p_dr.col;\n     return vec4 (0.);\n   }              \n                      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.xy-0.5)*vec2 ( iResolution.x/iResolution.y, 1.);\n\tfragColor = vec4(0.2,.5,.65,1.);\n\n vec4 col =  Hiteck( uv, dro)-Hiteck(uv, droi)+Hiteck(uv, drre)-Hiteck(uv, drri)+Hiteck2( uv, drl)-Hiteck2( uv, drli)+Hiteck2(uv,dru)-Hiteck2(uv,drui)+Hiteck3(uv,rm);\n         \n      if (col.a < .9)\n        fragColor = vec4(0.2,.5,.65,1.0);\n      else\n    fragColor = col;\n    \n}\n   \n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKGDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 492, 536, 536, 877], [1316, 1316, 1361, 1361, 1702], [1831, 1831, 1876, 1876, 2233], [2271, 2271, 2328, 2328, 2734]], "test": "untested"}
{"id": "4sV3zt", "name": "Vector Interpolation", "author": "demofox", "description": "Interactive demonstration showing the differences between common vector interpolation techniques.  Use the mouse to control the white destination vector. Green = slerp, Blue = lerp, Orange = nlerp. Green (slerp) is the same as the true normal.", "tags": ["2d", "vector", "interpolation"], "likes": 17, "viewed": 2463, "published": "Public API", "date": "1455904980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nRelated post with more info on my blog:\nhttp://blog.demofox.org/2016/02/19/normalized-vector-interpolation-tldr/\n\n*/\n\n#define AA_AMOUNT 2.0 / iResolution.x\n\nconst float c_circleSize = 0.075;\nconst float c_vectorLength = 0.1;\nconst float c_lineWidth = 0.01;\n\n//============================================================\n// Signed Distance Functions taken/adapted/inspired by from:\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat UDCircle( in vec2 coords, in vec2 circle, float radius)\n{    \n    return max(length(coords - circle.xy) - radius, 0.0);\n}\n\n//============================================================\nfloat UDFatLineSegment (in vec2 coords, in vec2 A, in vec2 B, in float height)\n{    \n    // calculate x and y axis of box\n    vec2 xAxis = normalize(B-A);\n    vec2 yAxis = vec2(xAxis.y, -xAxis.x);\n    float width = length(B-A);\n    \n\t// make coords relative to A\n    coords -= A;\n    \n    vec2 relCoords;\n    relCoords.x = dot(coords, xAxis);\n    relCoords.y = dot(coords, yAxis);\n    \n    // calculate closest point\n    vec2 closestPoint;\n    closestPoint.x = clamp(relCoords.x, 0.0, width);\n    closestPoint.y = clamp(relCoords.y, -height * 0.5, height * 0.5);\n    \n    return length(relCoords - closestPoint);\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec2 slerp(vec2 start, vec2 end, float percent)\n{\n     // Dot product - the cosine of the angle between 2 vectors.\n     float dot = dot(start, end);     \n     // Clamp it to be in the range of Acos()\n     // This may be unnecessary, but floating point\n     // precision can be a fickle mistress.\n     dot = clamp(dot, -1.0, 1.0);\n     // Acos(dot) returns the angle between start and end,\n     // And multiplying that by percent returns the angle between\n     // start and the final result.\n     float theta = acos(dot)*percent;\n     vec2 RelativeVec = normalize(end - start*dot); // Orthonormal basis\n     // The final result.\n     return ((start*cos(theta)) + (RelativeVec*sin(theta)));\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set up our camera\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy) - vec2(0.5);\n    uv.x *= aspectRatio;\n    uv *= 0.5;\n        \n    // calculate the starting and ending vector\n    vec2 startVector = vec2(cos(0.0), sin(0.0));\n\tvec2 endVector = vec2(0.0, 1.0);\n    if (iMouse.x > 0.0)\n    {\n    \tvec2 mouseuv = (iMouse.xy / iResolution.xy) - vec2(0.5);\n    \tmouseuv.x *= aspectRatio;     \n        endVector = normalize(mouseuv);\n    }\n    \n    // calculate our interpolation factor\n\tfloat t = abs(1.0 - (fract(iTime / 4.0) * 2.0));   \n    \n    // calculate the true vector\n    float trueAngle = atan(endVector.y, endVector.x) * t;\n    vec2 trueVector = vec2(cos(trueAngle), sin(trueAngle));\n    \n    // calculate the interpolated vectors\n    vec2 lerpVector = mix(startVector, endVector, t);\n    vec2 nlerpVector = normalize(lerpVector);\n    vec2 slerpVector = slerp(startVector, endVector, t);\n    \n    // background color\n    vec3 pixelColor = vec3(0.2);\n    \n    // the starting vector in dark grey\n    float dist = UDFatLineSegment(uv, vec2(0.0), startVector * (c_circleSize + c_vectorLength), c_lineWidth);\n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n    pixelColor = mix(pixelColor, vec3(0.5), dist);\n\n    // the ending vector in lighter grey\n    dist = UDFatLineSegment(uv, vec2(0.0), endVector * (c_circleSize + c_vectorLength), c_lineWidth);\n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n    pixelColor = mix(pixelColor, vec3(0.9), dist); \n    \n    // the slerp vector in green\n    dist = UDFatLineSegment(uv, vec2(0.0), slerpVector * (c_circleSize + c_vectorLength), c_lineWidth);\n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n    pixelColor = mix(pixelColor, vec3(0.2, 1.0, 0.2), dist);\n    \n    // the nlerpVector in orange\n    dist = UDFatLineSegment(uv, vec2(0.0), nlerpVector * (c_circleSize + c_vectorLength), c_lineWidth);\n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n    pixelColor = mix(pixelColor, vec3(1.0, 0.5, 0.2), dist);  \n    \n    // the lerpvector in blue. Note that we must start it at the edge of the circle so use nlerpvector * c_circleSize to start there.\n    dist = UDFatLineSegment(uv, vec2(0.0), nlerpVector * c_circleSize + lerpVector * c_vectorLength, c_lineWidth);\n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n    pixelColor = mix(pixelColor, vec3(0.2, 0.4, 0.8), dist);      \n                           \n\t// the true vector in skinny yellow\n    //dist = UDFatLineSegment(uv, vec2(0.0), trueVector * (c_circleSize + c_vectorLength), c_lineWidth / 6.0);\n    //dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n    //pixelColor = mix(pixelColor, vec3(1.0, 1.0, 0.0), dist);      \n    \n\t// the central circle\n\tdist = UDCircle(uv, vec2(0.0), c_circleSize);\n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n    pixelColor = mix(pixelColor, vec3(0.7), dist);    \n        \n    // make the final color\n\tfragColor = vec4(pixelColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sV3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 457, 520, 520, 584], [586, 649, 729, 770, 1263], [1265, 1439, 1488, 1553, 2129], [2131, 2194, 2251, 2276, 5202]], "test": "untested"}
{"id": "4sVGRc", "name": "Linjat", "author": "noby", "description": "One-hour, improvised.", "tags": ["cube", "abstract", "blue", "minimalism"], "likes": 4, "viewed": 245, "published": "Public", "date": "1455644781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 2\nfloat time;\nmat3 rx(float a){return mat3(1.0,0.0,0.0,0.0,cos(a),-sin(a),0.0,sin(a),cos(a));}\nmat3 ry(float a){return mat3(cos(a),0,sin(a),0.0,1.0,0.0,-sin(a),0.0,cos(a));}\nmat3 rz(float a){return mat3(cos(a),-sin(a),0.0,sin(a),cos(a),0.0,0.0,0.0,1.0);}\n\nfloat box(vec3 p, vec3 b, float r){\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat map(vec3 p, float dt){\n    mat3 r = rx(1.1*time+dt)*ry(time+dt)*rz(0.9*time+dt);\n    return box( (p+vec3(0,0,2))*r, vec3(0.3), 0.01);\n}\n\nvec3 normal(vec3 p, float dt){\n\tfloat e=1e-3;\n\treturn normalize(vec3(map(p+vec3(e,0,0),dt)-map(p-vec3(e,0,0),dt),\n\t                      map(p+vec3(0,e,0),dt)-map(p-vec3(0,e,0),dt),\n\t                      map(p+vec3(0,0,e),dt)-map(p-vec3(0,0,e),dt)));\n}\n\nfloat intersect(vec3 o, vec3 d, float dt){\n    float dist = 0.0;\n    for(int i = 0; i < STEPS; i++){\n        float s = map(o+d*dist, dt);\n        dist += s;\n        if(dist > 200.0 || s < 0.001) break;\n    }\n    dist = min(dist, 200.0);\n    dist = abs(dot(normal(o+d*dist, dt), normalize(vec3(0,1,1))));\n    return pow(1000.0/dist, 0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n    time = iTime*1.0;\n    float ac = 0.0;\n    \n    for(int d = 0; d < 20; d++){\n        float dt = -0.006+0.0006*float(d); \n        float depth = intersect( vec3(-1.3,-0.7,3), normalize(vec3(uv,-2)), dt);\n    \tac += pow(sin(160.0*uv.y+1.5*tan(sin(uv.x*depth))), 75.0);\n    }\n    vec3 op = mix(vec3(1), 0.7*vec3(0.3,0.45,0.8), max(ac, 0.01)/20.0);\n\tfragColor = vec4(pow(op, vec3(1.0/2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 45, 45, 108], [109, 109, 126, 126, 187], [188, 188, 205, 205, 268], [270, 270, 305, 305, 345], [347, 347, 375, 375, 488], [490, 490, 520, 520, 743], [745, 745, 787, 787, 1084], [1086, 1086, 1140, 1140, 1577]], "test": "untested"}
{"id": "4sXGRB", "name": "TinyFont", "author": "danbri", "description": "Experimenting with tiny GLSL font. ", "tags": ["test", "font"], "likes": 0, "viewed": 123, "published": "Public", "date": "1455399986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define font_size 35. \n#define font_spacing .035\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n#define P_ vec2(0.,5.)\n#define Q_ vec2(1.,5.)\n#define R_ vec2(1.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(1.,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p) \n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p) \n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(B_,A_,p) + t(A_,M_,p) + t(M_,G_,p) + t(G_,H_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define H(p) t(A_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(G_,H_,p) + t(H_,N_,p) \n#define J(p) t(G_,H_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(I_,K_,p) + t(K_,O_,p)\n#define L(p) t(B_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,H_,p) + t(H_,N_,p) + t(N_,H_,p) + t(H_,I_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_,p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p) \n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define W(p) t(G_,M_,p) + t(M_,N_,p) + t(N_,H_,p) + t(H_,N_,p) + t(N_,O_,p) + t(O_,I_,p)\n#define X(p) t(G_,O_,p) + t(O_,K_,p) + t(K_,M_,p) + t(M_,I_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat min_distance(vec2 v, vec2 w, vec2 p) {  // thanks http://glsl.heroku.com/e#6140.0\t\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 \n  \tif (l2 == 0.0) { return distance(p, v); }\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) { return distance(p, v); } \n\telse if (t > 1.0) { return distance(p, w); }\n  \tvec2 projection = v + t * (w - v);  \n\treturn distance(p, projection);\n}\n\nfloat textColor(vec2 from, vec2 to, vec2 p) {\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner, strokeWidth = 0.05;\n        nearLine = min_distance(from,to,p); // basic distance from segment, \n        inkNess += smoothstep(0., 1., 1.- 14.*(nearLine - strokeWidth)); // ugly still\n        inkNess += smoothstep(0., 3.2, 1.- (nearLine  + 6. * strokeWidth)); // glow\n\treturn inkNess;\n}\n\nvec2 grid(vec2 letterspace) { return ( vec2( (letterspace.x / 1.8) * .65 , 1. - ((letterspace.y / .45) * 1.55) ));}\nfloat t(vec2 from, vec2 to, vec2 p) {  return textColor(grid(from), grid(to),p);  }\n\nvec2 r(vec2 p, float r) { // to the right ...\n  p.y -= .8;\t\n  p.x -= font_spacing * r;\t\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat ink, ink2, ink3, ink4 = 0., time = iTime;\n\tvec3 col = vec3(0.05,0.05,0.05);  // b/g \n\tvec2 c = vec2(resolution.x/2.0, resolution.y/2.0);\n\tvec2 p = fragCoord.xy/iResolution.xy; // our pixel\n   // vec2 uv = fragCoord.xy / iResolution.xy;\n\n        ink4 += A(r(p,1.)) + B(r(p,2.)) + C(r(p,3.)) ;\n\tink3 += D(r(p,4.)) + E(r(p,5.)) + F(r(p,6.)) ;\n\tink2 += G(r(p,7.)) + H(r(p,8.)) + I(r(p,9.)) + J(r(p,10.)) + K(r(p,11.)) ;\n\tink2 += L(r(p,12.)) + M(r(p,13.)) + N(r(p,14.)) + O(r(p,15.)) + P(r(p,16.)) + Q(r(p,17.)) + R(r(p,18.)) + S(r(p,19.)) + T(r(p,20.));\n        ink += U(r(p,21.)) + V(r(p,22.)) + W(r(p,23.)) + X(r(p,24.)) + Y(r(p,25.)) + Z(r(p,26.)) ;\n\t\n        col += vec3(ink,0.,0.);  \n\t// blend between zigzag FGQOKF in green, and 'e' (OMGILJ) in red\n\tcol += mix( vec3(ink,cos(time/2.) * ink,0.), vec3(0., ink2, ink - ink2), (sin(.9 * time)));\n\tcol += vec3(0., 0., ink3 * (5.  * p.x));\n\tcol += vec3(0., ink4, 0.0);\n\n\t// example background from http://glsl.heroku.com/e#9742.3\n\t\n\tvec2 v=(fragCoord.xy-(resolution*0.5))/min(resolution.y,resolution.x)*10.0;\n\tfloat t=time * 0.4,r=2.0;\n\tfor (int i=1;i<4;i++){\n\t\tfloat d=(3.14159265 / float(6))*(float(i)*14.0);\n\t\tr+=length(vec2(v.y,v.x))+1.21;\n\t\tv = vec2(v.x+cos(v.y+cos(r)+d)+cos(t),v.y-sin(v.x+cos(r)+d)+sin(t));\n\t}\n        r = (sin(r*0.05)*0.5)+0.5;\n\tr = pow(r, 30.0);\n\tcol += .2 * vec3(r,pow(max(r-0.75,0.0)*4.0,2.0),pow(max(r-1.875,0.1)*5.0,4.0) );\n\t\n\t\n        fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2169, 2169, 2213, 2257, 2610], [2612, 2612, 2657, 2657, 3000], [3002, 3002, 3031, 3031, 3117], [3118, 3118, 3155, 3155, 3201], [3203, 3203, 3228, 3248, 3304], [3306, 3306, 3363, 3363, 4814]], "test": "untested"}
{"id": "4sy3Rd", "name": "mandelbrot turbo test", "author": "asneakyfatcat", "description": "Just a simple implementation of the mandelbrot set with orbit maps to color", "tags": ["fractal", "mandelbrot", "orbit", "plane", "complex", "trap"], "likes": 1, "viewed": 149, "published": "Public", "date": "1455768998", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zoom coordinate from iq's 2tweet zoom\n    vec2 R = iResolution.xy,uv =vec2(-.745,.186)+ 3.*(fragCoord/R.y-.5)*pow(.002,1.+cos(.1*iTime));\n    vec2 z = vec2(0.);\n    vec4 col = vec4(0.);\n    int trap=0;\n    \n    // step through the radical mandelbrot set\n    // vec2 z holds a+bi\n    // trap holds orbit trap count\n    // c is point at uv\n    // z gets set to vec2 equiv equiv of (a+bi)^2 + c\n    for(int i = 0; i < 512; i++){\n        if(dot(z,z)>100.){trap = i;break;}\n        z = mat2(z,-z.y,z.x)*z + uv;\n    }\n\tfloat orb = sqrt(float(trap))/64.;\n    fragColor = (orb!=0. ? 1.-orb*vec4(9.,5.,3.,0.):vec4(0.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sy3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 102, 677]], "test": "untested"}
{"id": "4sy3Ry", "name": "Above the Dome", "author": "dixuanYang", "description": "This shader will burn your GPU and eat your brain!", "tags": ["raymarching", "stars", "rainbow", "lensflare", "house", "bird", "volumetriccloud", "balloons"], "likes": 11, "viewed": 549, "published": "Public", "date": "1455757975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//============================================\n// Dixuan Yang\n// Feb 17th, 2016\n//============================================\n\n\n//============================================\n// globals & constants\n//============================================\n\n// camera parameters\nvec3 camera_pos, camera_tar, camera_dir;\nvec3 u, v, w;\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n// environment\nfloat brightness;\n\n// motion\nvec3 sun_dir;\nvec3 movement;\nconst vec3 building_top    = vec3(0.0, 3.0, 0.0);\nconst vec3 building_bottom = vec3(0.0, 1.9, 0.0);\n\n// objects parameters\nconst int   bird_num = 1;\nconst vec3  body_size = vec3(0.4, 0.3, 0.2);\nconst vec2  funnel_size = vec2(0.04, 0.4);\nconst float line_radius = 0.0;\nconst float ambient_factor = 0.4;\nconst float ambient_compensate = 0.2;\nconst float bird_max_height = 3.0;\n\n// object colors\nconst vec3 line_color       = vec3(0.3, 0.3,  0.5);\nconst vec3 sun_color        = vec3(1.0, 0.7,  0.4);\nconst vec3 sun_color_red    = vec3(1.0, 0.2,  0.2);\nconst vec3 sky_color        = vec3(0.3, 0.6,  0.8);\nconst vec3 sky_color_dark   = vec3(0.0, 0.1,  0.4);\nconst vec3 cloud_color      = vec3(1.0, 0.95, 1.0);\nconst vec3 cloud_color_dark = vec3(0.3, 0.25, 0.3);\nconst vec3 roof_color       = vec3(0.6, 0.5,  0.3);\nconst vec3 body_color       = vec3(0.5, 0.2,  0.1);\nconst vec3 funnel_color     = vec3(0.0, 0.0,  0.5);\nconst vec3 bird_color       = vec3(0.9, 0.8,  0.9);\n\n// colors\nconst vec3 color_purple = vec3(0.761, 0.506, 0.835);\nconst vec3 color_blue   = vec3(0.384, 0.667, 0.655);\nconst vec3 color_yellow = vec3(0.961, 0.753, 0.196);\nconst vec3 color_green  = vec3(0.624, 0.796, 0.361);\nconst vec3 color_orange = vec3(0.953, 0.482, 0.318);\nconst vec3 color_red    = vec3(0.886, 0.557, 0.616);\n\n// cloud parameters\nconst float cloud_max_height        = 2.0;\nconst float cloud_min_height        = 0.0;\nconst float cloud_amplitude         = 0.4;\nconst float cloud_density_threshold = 0.001;\nconst float cloud_max_alpha         = 0.99;\n\n// ray marching parameters\nconst int   max_step = 250;\nconst float dist_per_step = 0.04;\nconst float epsilon = 0.015;\nconst float pi = 3.1415926536;\n\n\n//============================================\n// prototypes\n//============================================\n\n// background\nvec3 meet_sky(in vec3 ray_dir, in vec2 uv);\nvec3 lens_flare(in vec2 uv);\nvec3 rainbow(in vec3 ray_dir);\nvec3 star(in vec2 uv);\n\n// all objects maps\nbool object_divide_map(in vec3 position, in vec3 ray_dir, out vec3 color);\nbool building_map(in vec3 position, out vec3 color);\nbool bird_map(in vec3 position, out vec3 color);\nbool balloon_map(in vec3 position, in vec3 ray_dir, in vec3 center, in vec3 balloon_color, float radius, out vec3 color);\nbool balloon_group_map(in vec3 position, in vec3 ray_dir, out vec3 color);\n\n// objects distance & density function\nfloat meet_sphere(in vec3 p, in float r);\nfloat meet_cone(in vec3 p, in vec3 c);\nfloat meet_roof(vec3 p, float h);\nfloat meet_box(in vec3 p, in vec3 b);\nfloat meet_cylinder(in vec3 p, in vec2 h);\nfloat meet_capsule(in vec3 p, in vec3 a, in vec3 b, float r);\nfloat meet_triangle(vec3 p, vec3 a, vec3 b, vec3 c);\nfloat meet_roundbox(in vec3 p, in vec3 b, float r);\nfloat cloud_density(in vec3 position);\n\nvec2  meet_building(in vec3 position);\nfloat meet_bird(in vec3 position, int index);\n\n// render\nvec4 render(in vec3 ray_pos, in vec3 ray_dir, in vec2 uv);\nvec4 raymarch(in vec3 ray_pos, in vec3 ray_dir);\n\n// motion & environment\nvoid motion_setup();\nvoid camera_setup();\nvoid environment_setup();\nvoid bird_motion(int index, out vec3 bird_pos, out vec3 bird_dir, out float phase);\n\n// math\nfloat dot2(in vec3 v);\nvec2  hash(vec2 p);\nfloat hash(float n);\nfloat noise(in vec2 p);\nvec2  polar_convert(in vec3 position, in vec3 center, in float radius);\nvec2  compx(in vec2 v1, in vec2 v2);\nfloat smin(float a, float b, float k);\nvec3  bend(vec3 p);\nvec2  sd2Segment(vec3 a, vec3 b, vec3 p);\n\n\n//============================================\n// main function\n//============================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // uv convert\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (-1.0 + 2.0 * uv) * vec2(iResolution.x/iResolution.y, 1.0);\n\n    // setup environment\n    camera_setup();\n    motion_setup();\n    environment_setup();\n\n    // cast ray\n    vec3 ca_dir = normalize(vec3(p, 0.0) - vec3(0.0, 0.0, -1.5));\n    vec3 wd_dir = normalize(ca_dir.x * u + ca_dir.y * v - ca_dir.z * w);\n\n    // render\n    fragColor = render(camera_pos, wd_dir, p);\n}\n\n\n//============================================\n// setup\n//============================================\n\nvoid camera_setup() {\n\n    float iTime = iTime * 0.8;\n    float tTime = iTime + 0.05;\n    float camera_radius = 5.0;\n    camera_pos = vec3(camera_radius * sin(0.16 * iTime), 4.0, camera_radius * cos(0.145 * iTime + .3));\n    camera_tar = vec3(0.0, 4.0, 0.0);\n    camera_dir = normalize(camera_tar - camera_pos);\n\n    w = -camera_dir;\n    u = normalize(cross(w, up));\n    v = normalize(cross(u, w));\n}\n\nvoid motion_setup() {\n\n    float iTime = iTime * 0.05;\n    movement = vec3(0.0, 1.0 * sin(iTime * 2.0), 0.0);\n    sun_dir = normalize(vec3(0.5 * cos(iTime) + 0.7, -0.5 * sin(iTime) * cos(iTime), 0.5 * sin(iTime)));\n}\n\n// must after the camera setup and motion setup\nvoid environment_setup() {\n\t\n    // pure bright\n    if (sun_dir.y < -0.1) {\n        brightness = 1.0;\n        return;\n    }\n\t\n    // pure dark\n    if (sun_dir.y > 0.1) {\n    \tbrightness = 0.0;\n        return;\n    }\n    \n    // linear transition\n    brightness = 0.5 - 5.0 * sun_dir.y;\n}\n\n\n//============================================\n// render\n//============================================\n\nvec4 render(in vec3 ray_pos, in vec3 ray_dir, in vec2 uv) {\n\n    // sky and sun color as background\n    vec3 color = meet_sky(ray_dir, uv);\n\n    // cloud and build ray marching\n    vec4 march_color = raymarch(ray_pos, ray_dir);\n\n    // alpha blending (front view and sky)\n    color = color * (1.0 - march_color.a) + march_color.rgb;\n    \n    return vec4(color, 1.0);\n}\n\n\n//============================================\n// ray marching\n//============================================\n\nvec4 raymarch(in vec3 ray_pos, in vec3 ray_dir) {\n\n    vec4 color = vec4(0.0);\n\n    float t = 0.0;\n\n    // integrate color while ray marching\n    for(int i = 0; i < max_step; ++ i) {\n        \n        vec3 pos = ray_pos + t * ray_dir;\n        \n        if (pos.y < cloud_min_height || color.a > cloud_max_alpha) break;\n\n        float density = cloud_density(pos);\n\n        vec3 object_color;\n\n        // ray has met an object, \"alpha blend\" object color with cloud color and stop marching\n        if (object_divide_map(pos, ray_dir, object_color)) {\n            color += vec4(object_color, 1.0) * (1.0 - color.a);\n            break;\n        }\n\n        if (density > cloud_density_threshold) {\n\n            // cloud color\n            vec3 cloud_color = mix(cloud_color, cloud_color_dark, density);\n            float sun_factor = min(max(dot(vec3(0.0, -1.0, 0.0), sun_dir - vec3(0.0, 0.2, 0.0)) * 6.3, 0.6), 1.25);\n            float alpha = density * 0.2;\n\n            // alpha blending (cloud and objects)\n            color += vec4(cloud_color * alpha * sun_factor, alpha) * (1.0 - color.a);\n        }\n\n        t += dist_per_step;\n    }\n\n    return clamp(color, 0.0, 1.0);\n}\n\n\n//============================================\n// background effects\n//============================================\n\nvec3 meet_sky(in vec3 ray_dir, in vec2 uv) {\n\n    float sun_intensity = max(dot(-ray_dir, sun_dir), 0.0);\n\n    // sky color\n    vec3 color = mix(sky_color_dark, sky_color, 1.0 - ray_dir.y) * max(brightness, ambient_compensate);\n\n    // add sun color\n    color += sun_color * min(pow(sun_intensity, 400.0) * 10.2, 1.0) * 0.315 +\n             sun_color * min(pow(sun_intensity, 14.9 ) * 1.2 , 1.0) * 0.45;\n\n    // add lens flare\n    color += lens_flare(uv);\n    \n    // add rainbow\n    color += rainbow(ray_dir);\n    \n    // add stars\n    color += star(uv);\n\n    return clamp(color, 0.0, 1.0);    \n}\n\nvec3 rainbow(in vec3 ray_dir) {\n    \n    vec3 rainbow_dir = normalize(vec3(-0.4, -0.2, 0.0));\n    float theta = degrees(acos(dot(rainbow_dir, ray_dir)));\n\n    const float intensity = 0.30;\n\t\n\tvec3 color_range = vec3(50.0, 53.0, 56.0);\t// angle for red, green and blue\n    vec3 nd = clamp(1.0 - abs((color_range - theta) * 0.2), 0.0, 1.0);\n\tvec3 color = (3.0 * nd * nd - 2.0 * nd * nd * nd) * intensity;\n    \n    return color * max((brightness - 0.8) * 3.5, 0.0);\n}\n\nvec3 star(in vec2 uv) {\n        \n    const float star_threshold = 0.97;\n\n    float xhash = hash(uv.x * 37.0);\n    float yhash = hash(uv.y * 57.0);\n    float star_val = fract(xhash + yhash);\n\t\n    if (star_val > star_threshold) {\n\t\treturn vec3(pow((star_val - star_threshold) / (1.0 - star_threshold), 6.0)) * (1.0 - brightness);\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 lens_flare(in vec2 uv) {\n\n    vec3 color = vec3(0.0);\n    float sun_factor = dot(w, sun_dir);\n    const float max_inten = 1.3;\n    const float intensity = 0.021;\n    const float shininess = 7.0;\n    const float shininess1 = 10.0, shininess2 = 8.0, shininess3 = 4.0;\n\n    if (sun_factor > 0.0){      // which means sun is inside the screen\n\n        vec2 sun_uv = vec2(dot(sun_dir, u), dot(sun_dir, v));\n        vec2 uv_diff = uv - sun_uv;\n        uv_diff = uv_diff * (length(uv_diff));\n        sun_factor = pow(sun_factor, shininess);\n\n        float lensf1 = max(max_inten - length(uv_diff + sun_uv * 2.0) * 2.0, 0.0);\n        float lensf2 = max(max_inten - length(uv_diff + sun_uv * 0.5) * 4.0, 0.0);\n        float lensf3 = max(max_inten - length(uv_diff * 3.3 + sun_uv * 5.0 - uv * 2.5) * 1.2, 0.0);\n\n        color += sun_color_red * pow(lensf1, shininess1) * 12.0 +\n                 sun_color     * pow(lensf2, shininess2) * 4.0  +\n                 sun_color     * pow(lensf3, shininess3) * 12.0;\n    }\n\n    return clamp(color * sun_factor * intensity, 0.0, 1.0) * brightness;\n}\n\n\n//============================================\n// maps\n//============================================\n\nbool object_divide_map(in vec3 position, in vec3 ray_dir, out vec3 color) {\n    \n    vec3 pos = position;\n    float height = building_top.y + movement.y;\n    \n    if (pos.y > height && balloon_group_map(pos - movement, ray_dir, color)) return true;\n    if (pos.y <= height && building_map(pos - movement, color)) return true;\n    if (pos.y <= bird_max_height && bird_map(position, color)) return true;\n\n    return false;\n}\n\nbool building_map(in vec3 position, out vec3 color) {\n       \n    vec2 ret = meet_building(position);\n    \n    if (ret.x < epsilon) {\n        \n        vec3 eps = vec3(0.01, 0.0, 0.0); \n        \n        // calculate normal at intersection point\n    \tvec3 normal = normalize(vec3(\n        \tmeet_building(position + eps.xyy).x - meet_building(position - eps.xyy).x,\n            meet_building(position + eps.yxy).x - meet_building(position - eps.yxy).x,\n            meet_building(position + eps.yyx).x - meet_building(position - eps.yyx).x\n        ));\n        \n        // calculate color\n        float diffuse_factor = max(dot(normal, -sun_dir) * brightness, ambient_compensate);\n        vec3 ambient_color, diffuse_color;\n        \n        if (ret.y == 1.0) {\t\t\t\t// roof\n        \tambient_color = texture(iChannel1, position.xz).rgb;\n            diffuse_color = roof_color;\n        } else if (ret.y == 2.0) {\t\t// body\n            float theta = atan(position.z / position.x);\n            if (position.x < 0.0) theta += pi;\n        \tambient_color = texture(iChannel2, vec2(theta * 0.3, position.y)).rgb;\n            diffuse_color = body_color;\n        } else {\t\t\t\t\t\t// funnel\n        \tambient_color = texture(iChannel0, position.xz).rgb;\n            diffuse_color = funnel_color;\n        }\n        \n        color = ambient_factor * ambient_color + diffuse_factor * diffuse_color;\n        return true;\n    }\n    \n    return false;\n}\n\nbool bird_map(in vec3 position, out vec3 color) {\n    \n    for (int i = 0; i < bird_num; ++ i) {\n        \n    \tfloat dist = meet_bird(position, i);\n    \n    \tif (dist < epsilon) {\n        \n        \tvec3 eps = vec3(0.005, 0.0, 0.0);\n        \n        \t// calculate normal at intersection point\n    \t\tvec3 normal = normalize(vec3(\n        \t\tmeet_bird(position + eps.xyy, i) - meet_bird(position - eps.xyy, i),\n            \tmeet_bird(position + eps.yxy, i) - meet_bird(position - eps.yxy, i),\n            \tmeet_bird(position + eps.yyx, i) - meet_bird(position - eps.yyx, i)\n        \t));\n        \n        \t// calculate color\n        \tfloat diffuse_factor = max(dot(normal, -sun_dir) * brightness, ambient_compensate);\n    \t\tcolor = bird_color * diffuse_factor;\n        \treturn true;\n    \t}\n    }\n    \n    return false;\n}\n\nbool balloon_group_map(in vec3 position, in vec3 ray_dir, out vec3 color) {\n\n    // group different layers of balloons, some layers are near, while some are far\n    if (balloon_map(position, ray_dir, vec3( 0.1, 4.9,  0.0), color_purple, 0.3, color)) return true;\n    if (balloon_map(position, ray_dir, vec3( 0.2, 4.2,  0.0), color_green,  0.3, color)) return true;\n    if (balloon_map(position, ray_dir, vec3( 0.3, 4.1,  1.0), color_blue,   0.3, color)) return true;\n    if (balloon_map(position, ray_dir, vec3(-0.2, 4.7,  0.5), color_yellow, 0.3, color)) return true;\n    if (balloon_map(position, ray_dir, vec3(-0.3, 4.0, -0.5), color_red,    0.3, color)) return true;\n    if (balloon_map(position, ray_dir, vec3(-0.3, 5.0, -0.5), color_orange, 0.3, color)) return true;\n    \n    return false;\n}\n\nbool balloon_map(in vec3 position, in vec3 ray_dir, in vec3 center, in vec3 balloon_color, float radius, out vec3 color) {\n\n    float dist_balloon = meet_sphere(position - center, radius);\n\n    if (dist_balloon < epsilon) {\n        \n        vec3 normal = normalize(position - center);\n        vec3 reflect_ray = reflect(ray_dir, normal);\n        float diffuse_factor  = max(dot(normal, -sun_dir) * brightness, ambient_compensate);\n        float specular_factor = pow(max(dot(reflect_ray, -sun_dir), 0.0), 10.0) * 0.8 * brightness;\n        \n        // use polar cordinates as uv to sample texture\n        vec2 uv = polar_convert(position, center, radius) * vec2(2.0, 1.0);\n        vec3 texture_color = texture(iChannel0, uv * 0.15).rgb;\n        color = ambient_factor * texture_color + diffuse_factor * balloon_color + specular_factor * sun_color;\n        color = clamp(color, 0.0, 1.0);\n        return true;\n        \n    } else {\n        vec3 a = position - center;\n        vec3 b = building_top - center;\n        float h = clamp(dot(a, b) / dot(b, b), 0.0, 1.0);\n        vec3 normal = a - b * h;\n        float dist_line = length(normal) - line_radius;\n        \n        // meet the line\n        if (dist_line < epsilon && dot(a, a) < dot(b, b)) {\n            \n            float diffuse_factor = max(dot(normalize(normal), -sun_dir) * brightness, 0.3);\n            color = mix(balloon_color, line_color, diffuse_factor) * diffuse_factor;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n\n//============================================\n// objects distance function\n//============================================\n\nfloat meet_sphere(in vec3 p, in float r) {\n    \n    return length(p) - r;\n}\n\nfloat meet_cone(in vec3 p, in vec3 c) {\n\t\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - c.z;\n    float d2 = max(dot(q, c.xy), q.y);\n    \n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\nfloat meet_capsule(in vec3 p, in vec3 a, in vec3 b, float r) {\n\t\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    return length(pa - ba * h) - r;\n}\n\nfloat meet_triangle(vec3 p, vec3 a, vec3 b, vec3 c) {\n\t\n    vec3 ba = b - a, pa = p - a;\n    vec3 cb = c - b, pb = p - b;\n    vec3 ac = a - c, pc = p - c;\n    vec3 nor = cross(ba, ac);\n    \n    float f1 = sign(dot(cross(ba, nor), pa)) + sign(dot(cross(cb, nor), pb)) + sign(dot(cross(ac, nor), pc));\n    float f2 = min(min(dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0.0, 1.0) - pa),\n                       dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0.0, 1.0) - pb)),\n                   \t   dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0.0, 1.0) - pc));\n    float f3 = dot(nor, pa) * dot(nor, pa) / dot2(nor);\n    \n    return sqrt(f1 < 2.0 ? f2 : f3);\n}\n\nfloat meet_roof(vec3 p, float h) {\n\n    p.y -= h + 0.1;\n    float k = dot(vec2(abs(p.z), p.y), vec2(0.7071067811865475));\n    float l = -p.y - h;\n    float w = abs(p.x * 0.9) - h;\n\n    return max(k, max(l, w));\n}\n\nfloat meet_box(in vec3 p, in vec3 b) {\n    \n\treturn length(max(abs(p) - b, 0.0));\n}\n\nfloat meet_cylinder(in vec3 p, in vec2 h) {\n    \n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat meet_roundbox(in vec3 p, in vec3 b, float r) {\n    \n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat cloud_density(in vec3 position) {\n\n    // let cloud move only in z directoin\n    vec2 xz_move = position.xz - vec2(0.0, 1.0) * iTime;\n\n    // expand in xz\n    float density = noise(xz_move * 0.7);\n       \n    // limit the height of cloud\n    return clamp(cloud_max_height - position.y + cloud_amplitude * density, 0.0, 1.0);\n}\n\nvec2 meet_building(in vec3 position) {\n    \n    vec3 offset;\n    vec2 ret = vec2(1.0, 0.0);\n    \n    // meet house roof\n    offset = building_top - vec3(0.0, 0.5, 0.0);\n    ret = compx(ret, vec2(meet_roof(position - offset, 0.4), 1.0));\n    \n    // meet house body\n    offset = building_top + vec3(0.0, -0.65, 0.0);\n    ret = compx(ret, vec2(meet_box(position - offset, body_size), 2.0));\n   \t\n    // meet house funnel\n    offset = building_top + vec3(0.2, 0.0, -0.15);\n    ret = compx(ret, vec2(meet_cylinder(position - offset, funnel_size), 3.0));\n    \n    return ret;\n}\n\nfloat meet_bird(in vec3 position, int index) {\n\n    // calculate bird's position and direction in world space\n    float phase = 0.0;\n    vec3 bird_pos, bird_dir;\n    bird_motion(index, bird_pos, bird_dir, phase);\n    vec3 pos = position - bird_pos;\t\t// object space to world space\n    \n    // object space\n    float dist_body = 1.0;\n    float h = 0.0;\n    vec3 a = vec3(0.0);\n    vec3 axis_point = a;\n    vec3 p, d;\n    \n    // body\n    for (int i = 0; i < 5; ++ i) {\n    \t\n        float moved = float(i) / 5.0;\n        float stepf = 0.3;\n        if (i == 0) stepf = 0.25;\t// head\n        if (i == 4) stepf = 0.45;\t// tail\n        vec3 b = a + stepf * bird_dir;\n        \n        vec2 dist2 = sd2Segment(a, b, pos);\n        \n        if (dist2.x < dist_body) {\n        \tdist_body = dist2.x;\n            h = moved + dist2.y / 5.0;\n            axis_point = a + (b - a) * dist2.y;\n        }\n        \n        // get wings position\n        if (i == 1) {\n            p = b;\n            d = b - a;\n        }\n        \n        a = b;\n    }\n    \n    float radius = 0.001 + h * pow(1.0 - h, 2.0) / 2.0;\n    dist_body = distance(pos, axis_point) - radius;\n\n    // wings\n    vec3 wing_w = normalize(d);\t// direction of the axis\n    vec3 wing_u = cross(wing_w, up);\n    vec3 wing_v = cross(wing_w, wing_u);\n    \n    vec3 wing_pos = pos - p;\t// translation\n    \n    // transform to wing space coordinate\n    wing_pos = wing_pos.x * wing_u + wing_pos.y * wing_v + wing_pos.z * wing_w;\n    \n    // symmetric with respect to the x-axis in wing space\n    wing_pos.x = abs(wing_pos.x);\n\n    // wings motion, it's a sin wave\n    wing_pos.y += sin(distance(pos, axis_point) * phase);\n    \n    // meet round box\n    float dist_wing = meet_roundbox(wing_pos, vec3(0.53, 0.001, 0.33), 0.001);\n    \n    // clap the wings by circles\n    float dist1 = length(wing_pos.xz) - 0.5;\t\t\t\t// circle 1\n    float dist2 = -length(wing_pos.xz - vec2(0.3)) + 0.4;\t// circle 2\n    dist_wing = max(max(dist_wing, dist1), dist2);\n\n\treturn smin(dist_body, dist_wing, 0.07);\n}\n\nvoid bird_motion(int index, out vec3 bird_pos, out vec3 bird_dir, out float phase) {\n\t    \n    float bTime = iTime * 0.6;\n    phase = 0.5 * sin(bTime * 3.0);\n    float radius = 2.0;\n    float amp = 0.8;\n \tfloat h = 1.5;\n    float speed = 1.0 + 0.4 * sin(bTime);\n    bird_pos = vec3(radius * sin(bTime), h + amp * sin(bTime), radius * cos(bTime));\n    vec3 pos_next = vec3(radius * sin(bTime + 0.1), h + amp * sin(bTime + 0.1), radius * cos(bTime + 0.1));\n    bird_dir = -normalize(pos_next - bird_pos) * speed;\n}\n\n\n\n//============================================\n// math\n//============================================\n\nfloat dot2(in vec3 v) {\n    return dot(v, v);\n}\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat hash(float n) {\n\treturn fract((1.0 + cos(n)) * 415.92653);\n}\n\n// 2D simplex noise function\nfloat noise(in vec2 p) {\n    const float K1 = 0.366025404;\n    const float K2 = 0.211324865;\n\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));\n\n    return dot(n, vec3(70.0));\n}\n\nvec2 polar_convert(in vec3 position, in vec3 center, in float radius) {\n    vec3 diff = position - center;\n    \n    float phi = acos(diff.y / radius);\n    float theta = atan(diff.z / diff.x);\n    if (diff.x < 0.0) theta += pi;\n    \n    return vec2(phi, theta);\n}\n\nvec2 compx(in vec2 v1, in vec2 v2) {\n    return v1.x < v2.x ? v1 : v2;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 sd2Segment(vec3 a, vec3 b, vec3 p) {\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec3 v = pa - ba * t;\n    \n\treturn vec2(dot(v, v), t);\n}\n\nvec3 bend(vec3 p) {\n\tfloat c = cos(20.0 * p.y);\n    float s = sin(20.0 * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    \n    return vec3(m * p.xy, p.z);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sy3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3897, 4009, 4064, 4083, 4512], [4515, 4619, 4640, 4640, 5019], [5021, 5021, 5042, 5042, 5237], [5239, 5287, 5313, 5334, 5573], [5576, 5681, 5740, 5780, 6049], [6052, 6163, 6212, 6212, 7334], [7337, 7454, 7498, 7498, 8051], [8053, 8053, 8084, 8084, 8517], [8519, 8519, 8542, 8542, 8882], [8884, 8884, 8913, 8913, 9969], [9972, 10075, 10150, 10150, 10497], [10499, 10499, 10552, 10552, 11923], [11925, 11925, 11974, 11974, 12740], [12742, 12742, 12817, 12902, 13539], [13541, 13541, 13663, 13663, 15043], [15046, 15170, 15212, 15212, 15245], [15247, 15247, 15286, 15286, 15466], [15468, 15468, 15530, 15530, 15666], [15668, 15668, 15721, 15721, 16309], [16311, 16311, 16345, 16345, 16523], [16525, 16525, 16563, 16563, 16608], [16610, 16610, 16653, 16653, 16765], [16767, 16767, 16819, 16819, 16871], [16873, 16873, 16912, 16955, 17205], [17207, 17207, 17245, 17245, 17779], [17781, 17781, 17827, 17890, 19810], [19812, 19812, 19896, 19896, 20324], [20328, 20431, 20454, 20454, 20478], [20480, 20480, 20499, 20499, 20626], [20628, 20628, 20649, 20649, 20694], [20696, 20725, 20749, 20749, 21221], [21223, 21223, 21294, 21294, 21485], [21487, 21487, 21523, 21523, 21559], [21561, 21561, 21600, 21600, 21697], [21699, 21699, 21740, 21740, 21889], [21891, 21891, 21910, 21910, 22040]], "test": "untested"}
{"id": "4sy3zG", "name": "Ray Marching Practice 2", "author": "Takoa", "description": "Quite simple one, just for practicing\n\nReplace Lambertian BRDF with Oren-Nayar BRDF\n\n1: [url]https://www.shadertoy.com/view/XdK3WW[/url]", "tags": ["3d", "raymarching", "orennayar"], "likes": 0, "viewed": 300, "published": "Public API", "date": "1455159109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sphere with Oren-Nayar BRDF\n// \n// Paper: http://www1.cs.columbia.edu/CAVE/publications/pdfs/Oren_SIGGRAPH94.pdf\n// Ref: http://shaderjvo.blogspot.jp/2011/08/van-ouwerkerks-rewrite-of-oren-nayar.html\n//\n// Note: 0.33 in coefficient A has been replaced with 0.57\n//       according to the footnote in the paper.\n\n#define PI 3.141592653\n#define INV_PI 0.3183098861\n#define GAMMA 2.2\n#define INV_GAMMA 0.4545454545\n\n#define EPSILON 0.001\n\nvec3 cameraPosition = vec3(0.0, 0.0, 2.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraLookingAt = vec3(0.0, 0.0, -100.0);\n\nfloat albedo = 0.9;\nfloat roughness = 0.3;\n\nfloat getDistanceToSphere(vec3 rayPosition, vec3 spherePosition, float radius)\n{\n    return length(spherePosition - rayPosition) - radius;\n}\n\nfloat getDistance(vec3 position)\n{\n    return min(\n        getDistanceToSphere(position, vec3(-0.5, 0.0, 0.0), 1.0),\n        getDistanceToSphere(position, vec3(0.5, 0.0, 0.0), 1.0));\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n          getDistance(p + vec3(EPSILON, 0.0, 0.0)) - getDistance(p - vec3(EPSILON, 0.0, 0.0)),\n          getDistance(p + vec3(0.0, EPSILON, 0.0)) - getDistance(p - vec3(0.0, EPSILON, 0.0)),\n          getDistance(p + vec3(0.0, 0.0, EPSILON)) - getDistance(p - vec3(0.0, 0.0, EPSILON))\n        ));\n}\n\nvec3 getRayDirection(vec2 screenPosition, vec3 origin, vec3 lookingAt, vec3 up, float fov)\n{\n    vec3 d = normalize(lookingAt - origin);\n    vec3 rayRight = normalize(cross(d, up));\n    \n    return normalize(screenPosition.x * rayRight + screenPosition.y * up + 1.0 / tan(radians(fov / 2.0)) * d);\n}\n\nfloat rayMarch(inout vec3 p, vec3 rayDirection)\n{\n    float d;\n    \n    for (int i = 0; i < 128; i++)\n    {\n        d = getDistance(p);\n        p += d * rayDirection;\n    }\n    \n    return d;\n}\n\nfloat getOrenNayarReflectance(vec3 normal, vec3 lightDirection, vec3 viewDirection, float roughness, float albedo)\n{\n    float roughness2 = roughness * roughness;\n    float orenNayarA = 1.0 - 0.5 * roughness2 / (roughness2 + 0.57);\n    float orenNayarB = 0.45 * roughness2 / (roughness2 + 0.09);\n    float orenNayarL = max(0.0, dot(normal, lightDirection));\n    float orenNayarV = max(0.0, dot(normal, viewDirection));\n    float orenNayarP = max(0.0, dot(normalize(lightDirection - normal * orenNayarL), normalize(viewDirection - normal * orenNayarV)));\n    float orenNayarL2 = orenNayarL * orenNayarL;\n    float orenNayarV2 = orenNayarV * orenNayarV;\n        \n    return albedo * INV_PI * orenNayarL * (orenNayarA + orenNayarB * orenNayarP * sqrt((1.0 - orenNayarL2) * (1.0 - orenNayarV2)) / max(orenNayarL, orenNayarV));\n}\n\nvec3 pow3(vec3 color, float g)\n{\n    return vec3(pow(color.x, g), pow(color.y, g), pow(color.z, g));\n}\n\nvec3 correctGamma(vec3 color, float reflectance)\n{\n   return pow3(color * reflectance, INV_GAMMA);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 lightPosition = vec3(10.0 * cos(iTime), 10.0, 10.0 * sin(iTime));\n    vec3 rayDirection = getRayDirection(position, cameraPosition, cameraLookingAt, cameraUp, 90.0);\n    vec3 p = cameraPosition;\n    float d = rayMarch(p, rayDirection);\n    \n    if (d < EPSILON)\n    {\n        float diffuse = getOrenNayarReflectance(getNormal(p), normalize(lightPosition - p), -rayDirection, roughness, albedo);\n        \n        fragColor = vec4(correctGamma(vec3(0.3, 0.9, 0.6), diffuse), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sy3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 611, 691, 691, 751], [753, 753, 787, 787, 937], [939, 939, 963, 963, 1288], [1290, 1290, 1382, 1382, 1589], [1591, 1591, 1640, 1640, 1784], [1786, 1786, 1902, 1902, 2610], [2612, 2612, 2644, 2644, 2714], [2716, 2716, 2766, 2766, 2816], [2818, 2818, 2873, 2873, 3505]], "test": "untested"}
{"id": "4sy3zy", "name": "Old School Plasma Test", "author": "asneakyfatcat", "description": "plasma effect by combining sines ", "tags": ["test", "plasma", "old", "school"], "likes": 3, "viewed": 238, "published": "Public", "date": "1454985561", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y += sin(uv.y*1.5+iTime);\n    //uv.y += sin(uv.y*10.0+iTime);\n    uv.y += sin(uv.x)*cos(uv.x);\n    uv.y += sin((uv.y*10.0+iTime)/2.0);\n    uv.x += sin((uv.x+uv.y+iTime)/2.0);\n    uv.x += sin(sqrt(uv.x*uv.x+uv.y*uv.y+1.0)+iTime);\n    \n    vec3 shiet = vec3(.5+sin(PI*uv.y),cos(PI*uv.x),abs(sin(iTime)));\n    //vec3 shiet = vec3(sin(PI*uv.y),cos(PI*uv.x),cos(uv.y));\n    //vec3 shiet = vec3(sin(PI*uv.x),sin(PI*uv.x+2.0*PI/3.0),sin(PI*uv.x+4.0*PI/3.0));\n    //vec3 shiet = vec3(.3*abs(sin(PI*uv.y)),0.9*abs(sin(PI*uv.x)),1.5-abs(cos(PI*uv.y)));\n   \t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = vec4(shiet,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sy3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 893]], "test": "untested"}
{"id": "4syGzy", "name": "Polynomial Arithmetic", "author": "paniq", "description": "Raytracing implicit surfaces in the fewest possible steps via polynomial arithmetic. Drag the mouse to change the starting point of the ray.", "tags": ["raytracing", "quadratic", "polynomial", "implicits", "arithmetic"], "likes": 13, "viewed": 965, "published": "Public API", "date": "1455017288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// instant implicit surfaces via polynomial arithmetic\n// -- @paniq\n\n// uncomment to visualize various extra graphs\n// #define DEBUG_VIZ\n// rainbow zig zag line: actual trace, each hue is an iteration\n// red: zero line\n// white: f(x)\n// yellow: f'(x)\n// green: f''(x)\n// magenta: distance to next horizon (discontinuity)\n// cyan: distance to next root\n\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    float scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n// save current source color, stroke width and starting\n// point from active context.\nContext save();\n// restore source color, stroke width and starting point\n// to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n/////////////////////////////////////////////////////////\n\nvoid paint();\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    ScreenH = min(iResolution.x,iResolution.y);\n    AA = ScreenH*0.4;\n    AAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n    \n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        1.0,\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;    \n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;    \n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);    \n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape.x * 6.0, \n            1.0, (_stack.shape.x>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;    \n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA, 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);    \n\treturn wa * wb; //min(wa,wb);    \n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale/AA;\n}\n\nfloat get_gradient_eps() {\n    return _stack.scale/AA;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o += s;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    add_field(max(dmin.xz, dmin.yw) + length2(dmax));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    add_field(length2(pa - ba.xyxy*h.xxyy));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis; // * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    add_field(vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw)));\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord);\n    \n    paint();\n    \n    fragColor = vec4(_color.xyz, 1.0);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n\n//////////////////////////////////////////////////////////\n\n// polynomial arithmetic\n// describes piecewise univariate polynomial with degree 2\nstruct poly2 {\n    // the coefficients for f(x) = a0 * x^0 + a1 * x^1 + a2 * x^2\n    vec3 a;\n    // distance to horizon\n    float h;\n};\n\nconst float infinity = 1. / 0.;\n\nbool hasaxis(float h) {\n    return (h != infinity);\n}\n\nbool hasaxis(poly2 f) {\n    return hasaxis(f.h);\n}\n\npoly2 pa_init(float x) {\n    return poly2(vec3(x,1.0,0.0),infinity);\n}\n\nfloat merge_axes(float f, float g) {\n    if (hasaxis(g)) {\n        if (hasaxis(f)) {\n            float a0 = min(f, g);\n            float a1 = max(f, g);\n            return ((a0 > 0.0)?a0:a1);\n        } else {\n            return g;\n\t\t}\n    }\n    return f;\n}\n\nfloat merge_axes(poly2 f, poly2 g) {\n    return merge_axes(f.h,g.h);\n}\n\npoly2 pa_add(poly2 f, poly2 g) {\n    return poly2(f.a + g.a,merge_axes(f,g));\n}\npoly2 pa_add(poly2 f, float c) {\n    return poly2(vec3(f.a[0] + c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_add(float c, poly2 f) {\n    return poly2(vec3(f.a[0] + c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_sub(poly2 f, poly2 g) {\n    return poly2(f.a - g.a,merge_axes(f,g));\n}\npoly2 pa_sub(poly2 f, float c) {\n    return poly2(vec3(f.a[0] - c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_sub(float c, poly2 f) {\n    return poly2(vec3(c - f.a[0],-f.a[1],-f.a[2]),f.h);\n}\npoly2 pa_unm(poly2 f) {\n    return poly2(-f.a,f.h);\n}\n\n// {a0 a1 a2} * {b0 b1 b2}\n// = {a0*b0 (a0*b1 + a1*b0) (a0*b2 + a2*b0 + a1*b1) (a1*b2 + a2*b1) (a2*b2)}\n// the two new coefficients are truncated, so only linear\n// functions are going to work here\npoly2 pa_mul(poly2 f, poly2 g) {    \n    return poly2(vec3(\n    \tf.a[0] * g.a[0],\n\t    f.a[0] * g.a[1] + f.a[1] * g.a[0],\n        /* f.a[0] * g.a[2] + */ f.a[1] * g.a[1] /* + f.a[2] * g.a[0] */\n        //f.a[1] * g.a[2] + f.a[2] * g.a[1],\n        //f.a[2] * g.a[2]\n        ), f.h);\n}\npoly2 pa_mul(poly2 f, float c) {\n    return poly2(f.a * c,f.h);\n}\npoly2 pa_mul(float c, poly2 f) {\n    return poly2(f.a * c,f.h);\n}\n\npoly2 pa_pow2(poly2 f) {\n    return poly2(vec3(\n    \tf.a[0] * f.a[0],\n\t    2.0 * f.a[0] * f.a[1],\n        /* 2.0 * f.a[0] * f.a[2] + */ f.a[1] * f.a[1]\n        //2.0 * f.a[1] * f.a[2],\n        //f.a[2] * f.a[2]\n        ), f.h);\n}\n\n// returns f(x), f'(x), f''(x)\nvec3 pa_f(vec3 a, float x) {\n    return vec3(\n        a[0] + (a[1] +       a[2] * x) * x,\n                a[1] + 2.0 * a[2] * x,\n                             a[2]);\n}\n\nfloat solve_quadratic(vec3 fa, float x) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return -c / b;\n    } else { \n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = -0.5*b/a;\n        float q = sqrt(k*k - c/a);\n        float q0 = k - q;\n        float q1 = k + q;\n        \n        // pick the root right of x\n\t\treturn (q0 <= x)?q1:q0;\n    }\n}\n\nfloat solve_quadratic0(vec3 fa) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return -c / b;\n    } else { \n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = -0.5*b/a;\n        float q = sqrt(k*k - c/a);\n        // pick the closest root right of 0\n\t\treturn k + ((k <= q)?q:-q);\n    }\n}\n\nfloat solve_quadratic(poly2 f) {\n    return solve_quadratic0(f.a);\n}\n\n// returns the x position of the next root, where f(x) = 0\nfloat nextroot(poly2 f) {\n    return solve_quadratic(f);\n}\n\n// returns the position of the next event (root or start of new segment)\nfloat nextevent(poly2 f) {\n    float s = nextroot(f);\n    float h = (f.h <= 0.0)?infinity:f.h;\n    s = (s <= 0.0)?h:min(s,h);\n    return s;\n}\n\nfloat axis(poly2 f) {\n    return nextevent(f);\n}\n\npoly2 pa_abs(poly2 f) {\n    float s = ((f.a[0] < 0.0)?-1.0:1.0);\n    return poly2(f.a * s, axis(f));\n}\n\n// intermediate abs: discontinuity will disappear in next step\npoly2 pa_imabs(poly2 f) {\n    float s = ((f.a[0] < 0.0)?-1.0:1.0);\n    return poly2(f.a * s, f.h);\n}\n\npoly2 pa_const(float c) {\n    return poly2(vec3(c,0.0,0.0), infinity);\n}\n\npoly2 pa_ipol(vec2 a, vec2 b) {\n    float a1 = (a.y - b.y)/(a.x - b.x);\n\tfloat a0 = a.y - a1*a.x;\n    return poly2(vec3(a0, a1, 0.0), infinity);\n}\n\npoly2 pa_ipol(vec2 a, vec2 b, float k) {\n    float a2 = 0.5*k;\n    float aa2 = a2*a.x*a.x;\n    float a1 = (a.y - b.y + a2*b.x*b.x - aa2) / (a.x - b.x);\n    float a0 = a.y - a1*a.x - aa2;\n    return poly2(vec3(a0, a1, a2), infinity);\n}\n\npoly2 pa_min(poly2 f, poly2 g) {\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx < gx)?f.a:g.a, h);\n}\npoly2 pa_max(poly2 f, poly2 g) {\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx > gx)?f.a:g.a, h);\n    \n}\n\n// intermediate min: discontinuity will disappear\npoly2 pa_immin(poly2 f, poly2 g) {\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx < gx)?f.a:g.a, merge_axes(f,g));\n}\n\n// intermediate max: discontinuity will disappear\npoly2 pa_immax(poly2 f, poly2 g) {\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx > gx)?f.a:g.a, merge_axes(f,g));\n    \n}\n\n// can only be used once on flat surfaces\npoly2 pa_smin(poly2 a, poly2 b, float r) {\n    poly2 c = pa_sub(a,b);\n    float h0 = axis(pa_sub(c, r));\n    float h1 = axis(pa_add(c, r));\n    float h = merge_axes(h0,h1);\n    poly2 e = pa_immin(\n        pa_immax(\n            pa_add(\n                pa_unm(\n                    pa_imabs(\n                        pa_sub(a, b))), r),\n            pa_const(0.0)),pa_const(r));\n    poly2 d = pa_sub(pa_immin(a, b), pa_mul(pa_pow2(e), 0.25 / r));\n    d.h = h;\n    return d;\n}\n\n// approximates blend with a quadratic patch, but\n// still buggy. do not use.\npoly2 pa_smin2(poly2 a, poly2 b, float r) {\n    poly2 c = pa_sub(a,b);\n    float h0 = axis(pa_sub(c, r));\n    float h1 = axis(pa_add(c, r));\n    float x0 = min(h0,h1);\n    float x1 = max(h0,h1);\n    float h = merge_axes(h0,h1);\n    if (x0 > 0.0) {\n        a.h = h;\n        return a;\n    } else if (x1 <= 0.0) {\n        b.h = h;\n        return b;\n    } else {\n        vec3 ay0 = pa_f(a.a, x0);\n        vec3 by0 = pa_f(b.a, x0);\n        vec3 ay1 = pa_f(a.a, x1);\n        vec3 by1 = pa_f(b.a, x1);\n        vec3 y0 = (ay0.x < by0.x)?ay0:by0;\n        vec3 y1 = (ay1.x < by1.x)?ay1:by1;\n        poly2 m = pa_ipol(vec2(x0, y0.x), vec2(x1, y1.x), (y1.y - y0.y) / (x1 - x0));\n        m.h = x0;\n    \treturn m;\n    }\n}\n\npoly2 pa_map(poly2 f) {\n    float wf = mix(0.0,0.3,sin(iTime)*0.5+0.5);\n    float wu = mix(1.0,0.0,cos(iTime*0.2)*0.5+0.5);\n\n#if 0\n    f = pa_add(pa_mul(f,0.85),wf);\n\n    f = pa_abs(f);\n    f = pa_mul(f, -1.0);\n    f = pa_add(f, 0.5);\n    f = pa_add(f, mix(-0.8,0.3,wu));\n    f = pa_abs(f);\n    f = pa_add(f, -0.2);\n    f = pa_abs(f);\n    f = pa_add(f, -0.1);\n#endif\n#if 0\n    poly2 a = pa_add(pa_mul(f,0.9),0.1);\n    poly2 b = pa_add(pa_mul(f,-0.2),0.3);\n    \n    f = pa_smin2(a,b,0.1);\n    \n    //f.w = max(a.w,b.w);\n    \n    f = pa_add(f,wf-0.5);\n    //f = pa_abs(f);\n    f = pa_add(f,0.2);\n#endif\n#if 0\n    poly2 x = pa_add(pa_mul(f, 0.44721),0.2);\n    poly2 y = pa_add(pa_mul(f, 0.89443),-0.3);\n    \n    //f = pa_add(pa_abs(x),pa_abs(y));\n    \n    f = pa_add(pa_pow2(x),pa_pow2(y));\n    //f = pa_sqrt(f);\n    f = pa_add(f,-0.9+wf);\n    f = pa_mul(f, -0.5);\n    f = pa_abs(f);\n    f = pa_add(f, -0.3);\n#endif\n#if 0\n    \n    poly2 a = pa_pow2(f);\n    a = pa_add(a, -0.2);\n\n    poly2 b = pa_pow2(pa_add(f, -0.5));\n    b = pa_add(b, -0.2);\n    b = pa_unm(b);\n    \n    f = pa_smin(a,b,0.1);\n    \n    f = pa_add(f, mix(-0.5,0.5,wu));\n    \n    \n#endif\n#if 1\n    // rotating cube with subtracted sphere\n    poly2 x = pa_const(0.0);\n    poly2 y = f;\n\tpoly2 z = pa_const(0.45);\n    \n    float a = iTime*0.1;\n    float s = sin(a);\n    float c = cos(a);\n    \n    poly2 rz = pa_sub(pa_mul(c, z),pa_mul(s, y));\n    poly2 ry = pa_add(pa_mul(s, z),pa_mul(c, y));\n    \n    // cube\n    poly2 cube = pa_sub(pa_max(pa_abs(x),pa_max(pa_abs(ry),pa_abs(rz))),0.5);\n    \n    // sphere\n    poly2 sphere = pa_sub(pa_add(pa_add(pa_pow2(x),pa_pow2(ry)),pa_pow2(pa_sub(rz,0.5))),0.25*0.25);\n    \n    // subtract sphere from cube\n    f = pa_max(cube, pa_unm(sphere));\n    \n    \n#endif\n    \n    //f = pa_ipol(f, vec2(-1.0, 0.0), vec2(1.0, 1.0), -0.5);\n    \n    return f;\n}\n\n// how to convert pa_map to a classic map function\n// t is the ray scalar\n// returns function value at that point, and distance\n// to next root or horizon\nvec2 map(float t) {\n    poly2 f = pa_map(pa_init(t));\n    return vec2(f.a[0], nextevent(f));\n}\n\nfloat rayf(float t) {\n    return pa_map(pa_init(t)).a[0];\n}\n\nfloat rayff(float t) {\n    return pa_map(pa_init(t)).a[1];\n}\n\nfloat rayfff(float t) {\n    return pa_map(pa_init(t)).a[2];\n}\n\nfloat raynextroot(float t) {\n    return nextroot(pa_map(pa_init(t)));\n}\n\nfloat rayhorizon(float t) {\n    return pa_map(pa_init(t)).h;\n}\n\nvoid paint() {\n\tvec2 ms = ((iMouse.xy/iResolution.xy)*2.0-1.0) * aspect;\n\t\n    // clear screen\n\t\n\tset_source_rgb(vec3(0.0,0.0,0.5));\n\tclear();\n\n\tset_line_width_px(1.3);\n    \n    // draw zero crossing\n    move_to(-2.0,0.0);\n    line_to(2.0,0.0);\n    set_line_width_px(1.0);\n    set_source_rgb(vec3(1.0,0.0,0.0));\n    stroke();\n\n    #ifdef DEBUG_VIZ\n\n    // draw 1D graph of estimated distance to horizon\n    graph1D(rayhorizon);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(1.0,0.0,1.0));\n    stroke();    \n\n    // draw 1D graph of estimated distance to root\n    graph1D(raynextroot);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(0.0,1.0,1.0));\n    stroke();    \n\n    // draw 1D graph of second derivative\n    graph1D(rayfff);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(0.5,1.0,0.0));\n    stroke();    \n\n    // draw 1D graph of first derivative\n    graph1D(rayff);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(1.0,1.0,0.0));\n    stroke();    \n    \n    #endif\n\n    // draw 1D graph of ray distances\n    graph1D(rayf);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(1.0));\n    stroke();    \n    \n\tfloat maxt = aspect.x;\n    \n\tfloat precis = 0.01;\n\tfloat t = (iMouse.z > 0.5)?ms.x:-aspect.x;\n    \n\tfor(int i = 0; i < 20; i++) {\n\t\tif(t > maxt) continue;\n\t\tset_source_rgb(hsl(float(i)/20.0, 1.0, 0.5));\n        vec2 d = map(t);\n        float w = t + d.y;\n        move_to(t, 0.0);\n        line_to(t, d.x);  \n        line_to(w, 0.0);\n\t\tstroke();\n        if (abs(d.x) <= precis) {\n            circle(t, 0.0, 0.03);\n            fill();\n        }        \n        t = w + 0.001;\n\t}\n    if (t > maxt) {\n        set_source_rgb(vec3(0.0,1.0,1.0));\n        move_to(aspect.x * 0.99, -1.0);\n        line_to(aspect.x * 0.99, 1.0);\n        stroke();\n    }\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5240, 5300, 5327, 5327, 5353], [5355, 5415, 5436, 5436, 5545], [5547, 5547, 5584, 5584, 5670], [5672, 5672, 5718, 5718, 5751], [5753, 5861, 5889, 5889, 6441], [6469, 6469, 6488, 6488, 6521], [6523, 6523, 6541, 6541, 6574], [6576, 6576, 6600, 6600, 6668], [6670, 6670, 6686, 6686, 6707], [6709, 6709, 6736, 6758, 6839], [6841, 6841, 6869, 6869, 7103], [7105, 7105, 7129, 7129, 7209], [7211, 7211, 7238, 7238, 7444], [7446, 7446, 7472, 7472, 7706], [7708, 7708, 7730, 7730, 7856], [7858, 7858, 7879, 7879, 7935], [7937, 7937, 7961, 7961, 8021], [8023, 8023, 8057, 8057, 8081], [8083, 8083, 8097, 8097, 8161], [8163, 8163, 8189, 8189, 8221], [8223, 8223, 8249, 8249, 8270], [8272, 8272, 8296, 8296, 8369], [8371, 8371, 8396, 8396, 8443], [8445, 8445, 8462, 8462, 8506], [8508, 8508, 8531, 8531, 8658], [8660, 8660, 8684, 8684, 8824], [8826, 8826, 8864, 8864, 9002], [9004, 9004, 9041, 9041, 9076], [9078, 9078, 9107, 9107, 9287], [9289, 9289, 9311, 9311, 9375], [9377, 9377, 9390, 9390, 9429], [9431, 9431, 9461, 9461, 9490], [9492, 9492, 9525, 9525, 9570], [9572, 9572, 9598, 9598, 9628], [9630, 9630, 9651, 9651, 9716], [9718, 9718, 9742, 9742, 9825], [9827, 9827, 9842, 9842, 9883], [9885, 9885, 9901, 9901, 9939], [9941, 9941, 9959, 9959, 10016], [10018, 10018, 10048, 10048, 10073], [10075, 10075, 10133, 10133, 10172], [10174, 10174, 10203, 10203, 10239], [10241, 10241, 10289, 10289, 10320], [10322, 10322, 10356, 10356, 10415], [10417, 10417, 10439, 10439, 10485], [10487, 10487, 10514, 10514, 10558], [10560, 10560, 10592, 10592, 10781], [10783, 10783, 10839, 10839, 10882], [10884, 10884, 10914, 10914, 11007], [11008, 11008, 11048, 11048, 11071], [11073, 11073, 11095, 11095, 11146], [11148, 11148, 11180, 11180, 11202], [11204, 11219, 11241, 11241, 11459], [11461, 11461, 11493, 11493, 11515], [11517, 11517, 11536, 11536, 11568], [11617, 11651, 11697, 11697, 12210], [12212, 12281, 12327, 12327, 12847], [12849, 12849, 12882, 12882, 13048], [13050, 13050, 13109, 13109, 13154], [13156, 13156, 13199, 13199, 13260], [13262, 13262, 13304, 13304, 13346], [13348, 13408, 13465, 13465, 13550], [13701, 13955, 13978, 13978, 14008], [14010, 14010, 14033, 14033, 14060], [14062, 14062, 14086, 14086, 14132], [14134, 14134, 14170, 14170, 14390], [14392, 14392, 14428, 14428, 14462], [14464, 14464, 14496, 14496, 14543], [14544, 14544, 14576, 14576, 14632], [14633, 14633, 14665, 14665, 14721], [14722, 14722, 14754, 14754, 14801], [14802, 14802, 14834, 14834, 14890], [14891, 14891, 14923, 14923, 14981], [14982, 14982, 15005, 15005, 15035], [15037, 15235, 15267, 15267, 15518], [15519, 15519, 15551, 15551, 15584], [15585, 15585, 15617, 15617, 15650], [15652, 15652, 15676, 15676, 15881], [15883, 15914, 15942, 15942, 16080], [16082, 16082, 16123, 16123, 16566], [16568, 16568, 16601, 16601, 16995], [16997, 16997, 17029, 17029, 17065], [17067, 17126, 17151, 17151, 17184], [17186, 17259, 17285, 17285, 17400], [17402, 17402, 17423, 17423, 17450], [17452, 17452, 17475, 17475, 17554], [17556, 17619, 17644, 17644, 17719], [17721, 17721, 17746, 17746, 17793], [17795, 17795, 17826, 17826, 17941], [17943, 17943, 17983, 17983, 18177], [18179, 18179, 18211, 18211, 18332], [18333, 18333, 18365, 18365, 18491], [18493, 18543, 18577, 18577, 18679], [18681, 18731, 18765, 18765, 18872], [18874, 18916, 18958, 18958, 19386], [19388, 19466, 19509, 19509, 20173], [20175, 20175, 20198, 20198, 22021], [22023, 22178, 22197, 22197, 22272], [22274, 22274, 22295, 22295, 22333], [22335, 22335, 22357, 22357, 22395], [22397, 22397, 22420, 22420, 22458], [22460, 22460, 22488, 22488, 22531], [22533, 22533, 22560, 22560, 22595], [22597, 22597, 22611, 22611, 24379]], "test": "untested"}
{"id": "ldG3R3", "name": "Quilt", "author": "sillsm", "description": "Color a box, tilt the viewing plane by cell, raymarch.", "tags": ["raymarching"], "likes": 1, "viewed": 160, "published": "Public", "date": "1455564895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Max Sills 2016 licensed under the MIT license.\n//\n// Quaternion rotation around axis, of angle, centered at center.\nvec3 qRotate(vec3 axis, float angle, vec3 center, vec3 point)\n{\nfloat x = axis.x * sin(angle / 2.);\nfloat y = axis.y * sin(angle / 2.);\nfloat z = axis.z * sin(angle / 2.);\nfloat w = cos(angle / 2.);\n\nmat3 rotation = mat3(1. - 2.*y*y - 2.*z*z, 2.*(x*y+w*z), 2.*(x*z-w*y),\n                     2.*(x*y-w*z), 1. - 2.*x*x - 2.*z*z, 2.*(y*z +w*x),\n                     2.*(x*z + w*y), 2.*(y*z-w*x),1. - 2.*x*x - 2.*y*y);\n     \nreturn center + (rotation * (point-center));\n}\n\n// Return <theta, phi, distance>\nvec3 udBox( vec3 p, vec3 b )\n{\n  vec3 newP = qRotate(vec3(0.,1.,0.),iTime,vec3(0.), p);\n  float theta = acos(normalize(p).z) - acos(normalize(newP).z);\n  float phi   = atan(p.y/p.x) - atan(newP.y/newP.x);\n  return vec3(phi,theta, length(max(abs(newP)-b,0.0)));\n}\n\nvec3 march(vec3 eye, vec3 ray)\t\t\t\t\n{\n    vec3 box = vec3(0);\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i)\t\t\t\t\n    {\t\n        vec3 p = eye + t* normalize(ray-eye);\t\n        box = udBox(p, vec3(1,1,1));\n        float distance = box.z;\n        t += distance * 0.5;\t\t\t\t\t\n    }\n    return vec3(box.x,box.y,t);\t\t\t\t\t\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t// Scale pixel coords to 0..1 range instead\n    uv = uv * 2.0 - 1.0;\t\t\t\t\t\t// Now to the -1 to +1 range\n    uv.x *= iResolution.x / iResolution.y;\t\t// Correct for aspect ratio.\n    \n    // Image plane is at (0, 0, -1)\n    vec3 ray = vec3(uv, -1.0);\t\n    vec3 eye = vec3(0.0, 0.0, -3);\n    \n    // Tilt the viewing pyramid a bit based on cell.\n    float angle = floor(fract(uv.x)*4.)+floor(fract(uv.y)*4.);\n    float angle2= floor(fract(uv.x)*20.)+floor(fract(uv.y)*20.);\n    angle = mix(angle,angle2, .1*abs(cos(iTime/10.)));\n    ray = qRotate(vec3(1.,0.,0.),angle,vec3(0.), ray);\n    eye = qRotate(vec3(1.,0.,0.),angle,vec3(0.), eye);\n\n    vec3 tr     = march(eye, ray);\t\t\n    vec2 pos    = tr.xy;\n    float t     = tr.z;\n\n    fragColor = (1.0/t)*vec4(cos(pos.x), cos(pos.y), sin(pos.x), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldG3R3.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 119, 182, 182, 587], [589, 622, 652, 652, 884], [886, 886, 922, 922, 1206], [1208, 1208, 1265, 1265, 2101]], "test": "untested"}
{"id": "ldGGRc", "name": "Mouse Gift", "author": "Belocio", "description": "Mouse with a gift box", "tags": ["mouse", "giftbox"], "likes": 14, "viewed": 205, "published": "Public", "date": "1456175368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime * 0.5\nconst float PI=3.14159265;\nconst float PIH = PI*0.5;\nconst int MAX_ITER = 110;\nconst float EPSILON = 0.00001;\nvec3 lightDir = normalize(vec3(0, 1, 0.75)); \n\nfloat bgMatType = 0.0;\nfloat EyesNoseAndMouthType = 1.0;\nfloat BodyMatType = 2.0;\nfloat PlaneMatType = 3.0;\nfloat BoxMatType = 4.0;\nfloat RibbonMatType = 5.0;\n\nvec3 boxPos = vec3(0, 10, -18);\nvec3 boxSize = vec3(8, 5, 5);\n\nvec3 skyColor = vec3(0.8, 0.9, 1.0);\nvec3 bodyColor = vec3(0.35,0.35,0.35);\nvec3 planeColor = vec3(0.7,0.7,0.7);\nvec3 eyesColor = vec3(0.0, 0.0, 0.0);\nvec3 boxColor = vec3(0.7,0.0,0.0);\nvec3 ribbonColor = vec3(0.7,0.7,0.0);\n\n//#define SELF_SHADOW\n#define CHEAP_AO\n\n//---------------------------------------------\nvec3 rotationCoord(vec3 n, float t)\n{\n vec3 result;\n\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n\n  result = n * rotate;\n  return result;\n}\n\n//------------------------------------------\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n//------------------------------------------\nvec2 rot(vec2 p,float r)\n{\n  vec2 ret;\n  ret.x=p.x*cos(r)-p.y*sin(r);\n  ret.y=p.x*sin(r)+p.y*cos(r);\n  return ret;\n}\n\n//------------------------------------------\nvec2 rotsim(vec2 p,float s)\n{\n  vec2 ret=p;\n  ret=rot(p,-PI/(s*2.0));\n  ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n  return ret;\n}\n\n//----------------------------------------------------\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float basic = 0.61;\n    return max(q.z-h.y,max(q.x* basic +p.y*0.5,-p.y)-h.x*0.5);\n}\n\n//----------------------------------------------------\nfloat dSphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n\n//----------------------------------------------------------------\nvec3 InstantiateRotY(vec3 p, float inPiFrac)\n{\n\tfloat rad\t\t= mod(atan(p.x, p.z) +  PIH*inPiFrac, PI*inPiFrac) - PIH*inPiFrac;\n\tp.xz\t\t\t= vec2(sin(rad), cos(rad)) * length(p.xz);\n\treturn p;\n}\n\n//----------------------------------------------------------------\nfloat tail(vec3 p)\n{\n    p.yz = rot(p.yz, PIH * 0.5);\n    p = rotationCoord(p, -PIH*0.4);\n\tfloat hMax\t\t= 40.0;\n\tfloat hScalePos\t= clamp(p.y / hMax, 0.0, 1.0);\n\tfloat h\t\t\t= abs(p.y-hMax*0.5)- hMax*0.5;\n\t\n\tp.x\t\t\t\t+= sin(hScalePos * PI * 1.75) * hScalePos * hMax * 0.25;\n    p.x\t\t\t\t+= sin(hScalePos * PI * 4.0) * hMax * 0.05;\n    p.z\t\t\t\t+= sin(hScalePos * PI * 1.5) * hMax * 0.25;\n    p.z\t\t\t\t+= sin(hScalePos * PI * 3.0) * hMax * 0.1;\n\t\n\t// Y - axis rotate-instantiation\n\tp\t\t\t\t= InstantiateRotY(p, 1.0/16.0);\n\t\t\n\tfloat wl\t\t= mix(1.2, 0.2, hScalePos);\n\treturn max(max(p.x-wl, p.z-wl), h);\n}\n\nfloat dSegment(vec3 pa, vec3 ba, float r)\n{\n    return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0))-r;\n}\n\nfloat dBox( vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n//--------------------------------------------------Ð’ÐµÑ€Ñ‚ÑƒÑˆÐºÐ°\nfloat ribbon(in vec3 p )\n{\n    p.xy = rot(p.xy, PIH);\n \tp.yz=rotsim(p.yz,2.5);\n \treturn sdTriPrism( p, vec2(1.5, 3.5) );\n}\n\n//--------------------------------------------------\nfloat smin( float a, float b, float k ) \n{\n   float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n   return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------------------------------\nvec2 minDistMat(vec2 curDist, vec2 dist)\n{\n   \tif (dist.x < curDist.x) \n   \t{\n    \treturn dist;\n   \t}\n   \treturn curDist;\n}\n\n//--------------------------------------------------\nfloat mouse(in vec3 pos )\n{\n  \tfloat d = 1.;\n   \t// Head\n   \td = dSphere(pos * vec3(0.8, 1.3, 1.0), 10.);\n    d = smin(d, dSphere(pos * vec3(0.7, 0.5, 0.8) + vec3(0., 0.58, 0.0), 6.), 2.0);\n    \n   \tpos.y +=11.;\n    // Body\n   \td = smin(d, dSphere(pos * vec3(0.6, 0.5, 0.8), 6.), 1.0); \n    d = smin(d, dSphere(pos * vec3(0.7, 1.5, 0.7) + vec3(0., 6.58, 0.0), 8.), 10.0);\n    \n    pos.y +=5.;\n    // Snout\n   \td = smin(d, dSphere(pos * vec3(1.03, 1.08, -0.64) + vec3(0., -15.58, 4.5), 3.8), 3.);\n    \n    // Ears\n   \tvec3 p1 = pos;\n   \tp1.x = abs(p1.x);       \n   \td = smin(d, dSphere(p1 * vec3(0.66, 0.5, 1.8) + vec3(-6, -15., 0), 5.), 1.5);\n    d = max(d, -dSphere(p1 *vec3(1,0.7,2)+ vec3(-9, -22, -5.2), 5.2)); \n    \n   \t// Legs\n   \td = smin(d, dSphere(p1 * vec3(1, 1, 0.4) + vec3(-5., 7.25, -1.0), 4.), 1.3);    \n    \n   \t// Arms\n   \td = smin(d, dSphere(p1 * vec3(1.95, 2.3, -0.8 ) + vec3(-20, -10.8, 5.5), 7.), 1.0); \n    \n    // Tail\n    d = smin(d, tail(pos + vec3(2.0,0.0, 6.0)),1.5);\n\n  \treturn d;\n  \n}\n\n//--------------------------------------------------\nvec2 map(in vec3 p)\n{\n   \tvec3 pos = p;\n   \tpos += vec3(0., 5., 35.);\n   \tpos = rotationCoord(pos, time);     \n   \tvec2 d = vec2(1.0, bgMatType);\n   \t\n   \tvec3 p1 = pos;\n   \tp1.x = abs(p1.x);\n    p1 += vec3(-3.12, -1.62, -9.54);   \n    \n    // Eyes\n   \tvec2 eyes = vec2(dSphere(p1, 1.), EyesNoseAndMouthType);\n   \td =  minDistMat(d,   eyes); \n    \n\t// Moustache\n    d =  minDistMat(d,  vec2(dSegment( p1 + vec3(2.0, 2.2, -3.), vec3(7, 0, -1), 0.1),  EyesNoseAndMouthType)); \n    d =  minDistMat(d,  vec2(dSegment( p1 + vec3(2.0, 1.8, -3.), vec3(6.5, 1, -1), 0.1),  EyesNoseAndMouthType)); \n    d =  minDistMat(d,  vec2(dSegment( p1 + vec3(2.0, 2.7, -3.), vec3(6.5, -1, -1), 0.1),  EyesNoseAndMouthType));\n    \n    // Nose\n   \td =  minDistMat(d,   vec2(dSphere(pos + vec3(0., 0.6, -12.5), 0.5) ,  EyesNoseAndMouthType));    \n\n  \tfloat toy = mouse(pos);\n   \td =  minDistMat(d,   vec2(toy , BodyMatType));   \n    \n    // Box\n    d = minDistMat(d, vec2(dBox(pos + boxPos, boxSize), BoxMatType));\n    \n    // Ribbon\n    d = minDistMat(d, vec2(dBox(pos + boxPos, boxSize * vec3(1.05, 1.05, 0.3)), RibbonMatType));\n    d = minDistMat(d, vec2(dBox(pos + boxPos, boxSize * vec3(0.2, 1.05, 1.05)), RibbonMatType));\n    d = minDistMat(d, vec2(ribbon(pos + boxPos - vec3(0, boxSize.y + 0.5, 0)), RibbonMatType));\n    \n    // Plane\n    d = minDistMat(d, vec2(sdPlane(pos + vec3(0,23.6,0)), PlaneMatType));\n    \n\treturn d; \n}\n\n//------------------------------------------------- \nvec3 getNormal(in vec3 p)\n{\n\n   vec3 e = vec3( 0.1, 0., 0. );\n   vec3 nor = vec3(\n       map(p+e.xyy).x - map(p-e.xyy).x,\n       map(p+e.yxy).x - map(p-e.yxy).x,\n       map(p+e.yyx).x - map(p-e.yyx).x);\n   return normalize(nor);  \n\n}\n\n//------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {        \n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<EPSILON || t>tmax ) break;\n    }\n    return clamp(res, 0.0, 1.0 );\n}\n\n//------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n#ifdef CHEAP_AO\n    return mix(0.5, 1.0, clamp((nor.y + 1.0) * 0.5, 0.0, 1.0)); \n#else\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n    \tfloat hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 0.5*occ, 0.0, 1.0 );   \n#endif\n}\n\n\n//------------------------------------------\nvec3 illum(in vec3 pos, in vec3 ro, in vec3 rd ,in vec3 nor, in vec3 lig, in vec3 col, in float t, in float mat)\n{\n    // lighitng \n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );    \n    \n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n#ifndef SELF_SHADOW\n    if(mat == PlaneMatType) \n#endif\n    \tdif *= softshadow( pos, lig, 5.5, 75.0 );\n    \n    vec3 brdf = vec3(0.0);\n    brdf += 1.0*dif*vec3(1,1,1);\n    brdf += 0.15*spe*vec3(1,1,1)*dif;\n    brdf += 0.30*amb*skyColor*occ;\n    brdf += 0.10*dom*skyColor*occ;\n    brdf += 1.0*bac*vec3(0.25,0.25,0.25)*occ;\n    brdf += 1.0*fre*vec3(1.00,1.00,1.00)*occ;\n    brdf += 0.02;\n\tcol = col*brdf;\n    \n    return col;\n}\n//----------------------------------------------------------------------\nvec3 getColor(inout vec3 ro, vec3 rd, vec2 t)\n{\n  \tvec3 color = skyColor; \n \n   \tfloat mat =  t.y;\n   \tif (mat > 0.0) \n   \t{\n        vec3 hitPos = ro + rd * t.x;\n  \t\tvec3 normal = normalize(getNormal(hitPos)); \n        \n   \t\tif (mat == BodyMatType) \n   \t\t{\n\t    \tcolor = bodyColor;\n   \t\t}\n    \telse if (mat == PlaneMatType) \n   \t\t{\n\t    \tcolor = planeColor;\n   \t\t}\n   \t\telse if (mat == EyesNoseAndMouthType) \n   \t\t{\n     \t\tcolor = eyesColor; \n   \t\t}\n        else if (mat > PlaneMatType && mat < RibbonMatType) \n        {\n            color = boxColor;\n        }\n        else \n        {\n            color = ribbonColor;\n        }\n\t    \n    \tcolor = illum(hitPos, ro, rd, normal, lightDir, color.rgb, t.x, mat);\n    }\n   \n  \treturn color;\n}\n\n//-------------------------------------------------\nvec2 render(in vec3 posOnRay, in vec3 rayDir)\n{ \n    vec2 t = vec2(0.0, bgMatType);\n    float maxDist = 100.;\n    for(int i=0; i<MAX_ITER; ++i)\n    {\n        vec2 d = map(posOnRay + t.x*rayDir); \n        if (abs(d.x) < EPSILON || t.x > maxDist) \n            break;\n        t.x += d.x;//max(d.x, MIN_STEP);\n        t.y = d.y;\n    }\n    return t;\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos     =  fragCoord.xy / iResolution.xy * 2. - 1.;\n    pos.x *= iResolution.x / iResolution.y;  \n       \n    vec3 camP = vec3(0., 4., 30.);\n    vec3 camUp = vec3(0. , 1., 0.);\n    vec3 camDir = normalize(-camP);\n    vec3 u = normalize(cross(camUp,camDir));\n    vec3 v = cross(camDir,u);\n    vec3 rayDir = normalize(2. * camDir + pos.x * u + pos.y * v);  \n   \t \n    vec2 t =  render(camP, rayDir);  \n    vec3 color = getColor(camP, rayDir, t); \n    \n    // gamma\n\tcolor = pow( clamp( color, 0.0, 1.0 ), vec3(0.45) );\n    \n    // vignetting\n    pos*=0.35;\n    float distSqr = dot(pos, pos);\n\tfloat vignette = 1.0 - distSqr;\n    color *=  vignette;\n    \n    fragColor = vec4(color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[670, 718, 755, 755, 987], [989, 1034, 1059, 1059, 1074], [1077, 1122, 1148, 1148, 1238], [1240, 1285, 1314, 1314, 1421], [1423, 1478, 1514, 1514, 1624], [1626, 1681, 1713, 1713, 1740], [1742, 1809, 1855, 1855, 1998], [2000, 2067, 2087, 2087, 2653], [2655, 2655, 2698, 2698, 2765], [2767, 2767, 2796, 2796, 2894], [2896, 2984, 3010, 3010, 3106], [3108, 3161, 3203, 3203, 3294], [3296, 3344, 3386, 3386, 3467], [3469, 3522, 3549, 3549, 4533], [4535, 4588, 4609, 4609, 5999], [6001, 6054, 6081, 6081, 6287], [6289, 6334, 6408, 6408, 6678], [6680, 6725, 6767, 6767, 7160], [7163, 7208, 7322, 7339, 8231], [8232, 8305, 8352, 8352, 9042], [9044, 9096, 9143, 9143, 9442], [9443, 9488, 9545, 9545, 10243]], "test": "untested"}
{"id": "ldGGW1", "name": "Even More Spirals", "author": "vox", "description": "Even More Spirals", "tags": ["evenmorespirals"], "likes": 1, "viewed": 106, "published": "Public", "date": "1454479291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\tfloat PI = 3.14159265359;\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\nfloat jag(float x)\n{\n    return mod(x, 1.0);\n}\nvec2 jag(vec2 x)\n{\n    return vec2(jag(x.x), jag(x.y));\n}\n\nfloat stair(float x)\n{\n    return float(int(x));\n}\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 tree(vec2 uv)\n{\n    uv.x = uv.x*2.0-1.0;\n    float turns = 6.0+5.0*saw(iTime);\n    uv = RotateZ(vec3(uv.xy, 0.0), PI/(1.0*turns)).xy;\n    float theta = atan(uv.y, uv.x);\n    \n    float rot = float(int((theta/PI*.5+.5)*turns))/turns;\n    \n    vec2 xy = RotateZ(vec3(uv.xy, 0.0), \n                      PI*2.0*(rot)+PI/turns).xy;\n    //xy = sign(xy)*log(abs(xy));\n    //return vec2(saw(theta*turns+PI*stair(xy.x*1.0)), 1.0-jag(xy.x*4.0));\n    //return vec2(saw(xy.y*turns+PI*stair(xy.x*1.0)), 1.0-jag(xy.x*4.0));\n    return vec2(saw(xy.y*turns+PI*stair(xy.x*1.0)), 1.0-saw(xy.x*4.0*PI));\n}\n\nconst int max_iterations = 32;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    int iterations = 1;\n   \t\tuv = tree(uv);; \n            vec4 screen = vec4(saw(uv.x*PI*2.0));\n            \n   \t\tuv = tree(uv);; \n            screen += vec4(saw(uv.x*PI*2.0));\n   \t\tuv = tree(uv);; \n            screen += vec4(saw(uv.x*PI*2.0));\n    //fragColor = vec4(uv, 0.0, 1.0);\n    fragColor = screen;\n    screen.x *= 2.0*PI;\n    fragColor = clamp(screen.x, 0.0, 1.0)*vec4(vec3(sin(iTime*5.0+0.0+screen.x),\n                                                       sin(iTime*5.0+4.0*PI/3.0+screen.x),\n                                                       sin(iTime*5.0+2.0*PI/3.0+screen.x))*.5+.5,\n                                                  1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGGW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 49, 49, 81], [82, 82, 100, 100, 132], [133, 133, 153, 153, 179], [180, 180, 198, 198, 237], [239, 239, 261, 261, 289], [291, 291, 324, 324, 356], [357, 357, 416, 416, 524], [532, 532, 591, 591, 634], [635, 635, 655, 655, 1227], [1261, 1261, 1318, 1318, 2019]], "test": "untested"}
{"id": "ldGGzG", "name": "4096 ~ Mandelcell", "author": "MrHenryBemis", "description": "~~(()((([[-O-]])))())~~", "tags": ["fractal", "mandelbrot", "cellular"], "likes": 5, "viewed": 118, "published": "Public", "date": "1455004964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tEmin Kura - http://emin.me\n*/\n#define iGlobaTime .0005*iTime\nvec3 rotate( vec3 pos, float x, float y, float z )\n{\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );\n\tmat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );\n\tmat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );\n\n\treturn rotX * rotY * rotZ * pos;\n}\n\nfloat hit( vec3 r )\n{\n\tr = rotate( r, sin(iTime), cos(iTime), 0.0 );\n\tvec3 zn = vec3( r.xyz );\n\tfloat rad = 0.0;\n\tfloat hit = 0.0;\n\tfloat p = 28.0;\n\tfloat d = 1.0;\n\tfor( int i = 0; i < 15; i++ )\n\t{\n\t\t\n\t\t\trad = length( zn );\n\n\t\t\tif( rad > 3.0 )\n\t\t\t{\t\n\t\t\t\thit = 0.25 * log(rad) * rad / d;\n\t\t\t}else{\n\n\t\t\tfloat th = atan( length( zn.xy ), zn.z );\n\t\t\tfloat phi = atan( zn.y, zn.x );\t\t\n\t\t\tfloat rado = pow(rad,8.0);\n\t\t\td = pow(rad, 6.0) * sin(iTime*3.75) * d + 6.0;\n\t\t\t\n\n\n\t\t\tfloat sint = sin( th * p );\n\t\t\tzn.x = rado * sint * cos( phi * p );\n\t\t\tzn.y = rado * sint * sin( phi * p );\n\t\t\tzn.z = rado * cos( th * p ) ;\n\t\t\tzn += r;\n\t\t\t}\n\t\t\t\n\t}\n\t\n\treturn hit;\n\n}\n\nvec3 eps = vec3( .1, 0.0, 0.0 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\t\n\n\tpos.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3( pos, -1.2 );\n\tvec3 la = vec3( 0.0, 0.0, 1.0 );\n\t\n\tvec3 cameraDir = normalize( la - ro );\n\tvec3 cameraRight = normalize( cross( cameraDir, vec3( 0.0, 1.0, 0.0 ) ) );\n\tvec3 cameraUp = normalize( cross( cameraRight, cameraDir ) );\n\t\n\n\tvec3 rd = normalize( cameraDir + vec3( pos, 0.0 ) );\n\n\tfloat t = 0.0;\n\tfloat d = 100.0;\n\t\n\tvec3 r;\n\tvec3 color = vec3(0.0);\n\n\tfor( int i = 0; i < 200; i++ ){\n\t\t\n\t\t\n\t\tif( d > .001 )\n\t\t{\t\n\t\t\tr = ro + rd * t;\n\t\t\td = hit( r );\n\t\t\tt+=d;\t\n\n\t\t}\n\t}\n\n\t  \tvec3 n = vec3( hit( r + eps ) - hit( r - eps ),\n\t  \t\t\thit( r + eps.yxz ) - hit( r - eps.yxz ),\n\t  \t\t\thit( r + eps.zyx ) - hit( r - eps.zyx ) );\n\t \n\t \n\tvec3 mat = vec3( .5, .1, .3 ); \n \tvec3 light = vec3( .5, .5, -2.0 );\n\tvec3 lightCol = vec3(.6, .4, .5);\n\t\n\tvec3 ldir = normalize( light - r );\n  \tvec3 diff = dot( ldir, n ) * lightCol * 60.0;\n\t\n\t\n\tcolor = diff  * mat;\n\t\n    float l = length(color)*sin(iTime*4.409614)*5.5+sin(iTime*2.0);\n    fragColor = vec4( vec3(cos(l), sin(iTime)*cos(l+3.14*5.0/3.0), sin(iTime)*cos(l+3.14*2.0/3.0))*.5+.5, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 117, 117, 411], [413, 413, 434, 434, 1064], [1100, 1100, 1157, 1157, 2304]], "test": "untested"}
{"id": "ldK3WG", "name": "Colored Rings", "author": "Cubeleo", "description": "Just some clean colored rings to warm up my brain for the day.", "tags": ["2d"], "likes": 5, "viewed": 678, "published": "Public API", "date": "1456256184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//iq's smooth HSV to RGB\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv - vec2(.5);\n    uv.x = uv.x * (iResolution.x / iResolution.y);\n    \n    float d = distance(uv, vec2(0));\n    \n    // scale the figure\n    d = d * 30.;\n    \n    float hue = floor(d) / 20. + iTime * .1;\n    \n    float value = .9;\n    \n    // create space between the rings\n    value = value * smoothstep(0., .2, fract(d));\n    value = value * smoothstep(.9, .7, fract(d));\n    \n    // limit the number of rings\n    value = value * float(d > 2.) * float(d < 13.);\n    \n    vec3 hsv = vec3(hue, .75, value);\n\tcolor = hsv2rgb_smooth(hsv);\n    \n    fragColor = vec4(color, 1);\n}    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldK3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 25, 59, 59, 237], [239, 239, 296, 296, 944]], "test": "untested"}
{"id": "ldKGRm", "name": "mandelballs", "author": "samuelotherion", "description": "fractals, cat animation, balls, simple lights, mouse interaction, just playing", "tags": ["mandelballs"], "likes": 0, "viewed": 109, "published": "Public", "date": "1455491802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi            3.1415926535\n#define MB_MAX_ITERS  255\n#define factor        ( 1. / float( MB_MAX_ITERS ) )\nconst mat3\nid3x3 = mat3( 1., 0., 0., 0., 1., 0., 0., 0., 1. );\n\nfloat\ntime,\ngSR[ 7 ];\n\nvec2\nxy,\nmxy,\ntxy;\n\nvec3\nhit,\ngSP[ 7 ],\ncol[ 7 ];\n\nstruct Datas {\n\n\tvec3\n    eye,\n    rayN;\n};\n\nDatas\nrTD; //run time datas\n    \nmat3\nproj( in vec3 p_r ) {\n\n\treturn mat3( p_r.x * p_r, p_r.y * p_r, p_r.z * p_r );\n}\n\nmat3\nantiproj( in vec3 p_r ) {\n\n\treturn id3x3 - proj( p_r );\n}\n\nvoid\ninit( in vec2 p_xy ) {\n\n    time = 1. * iTime;\n\n    float\n    rxy = iResolution.x / iResolution.y;\n    \n    xy   = ( p_xy / iResolution.xy -.5 );\n    xy.x *= rxy;\n    \n    mxy  = ( iMouse.xy / iResolution.xy -.5 ); \n    mxy.x *= rxy;\n    \n    txy = p_xy / iResolution.xy;\n    txy.x /= 6.;\n    txy.x += mod( float( int( 6. * time ) ), 6. ) / 6.4;\n    //txy.x = fract( txy.x );\n    \n    rTD.eye  = vec3( 1. * mxy.x, 0., 10.5 + 20. *  mxy.y );\n    rTD.rayN = normalize( rTD.eye - vec3( xy, 0. ) );\n    \n\tgSP[ 0 ] = vec3( .5 * sin( time ), 0., cos( time ) - 2. );\n\tgSR[ 0 ] = 1. / 16.;\n\tcol[ 0 ] = vec3( 1., .15, .025 );\n    \n    gSP[ 1 ] = vec3( 0., .5 * cos( time ), sin( time ) - 2. );\n\tgSR[ 1 ] = 1. / 16.;\n\tcol[ 1 ] = vec3( .025, 1., .15 );\n\n    gSP[ 2 ] = vec3( .5 * cos( time ), .5 * sin( time ),  - 2. );\n\tgSR[ 2 ] = 1. / 16.;\n\tcol[ 2 ] = vec3( .15, .025, 1. );\n\n    gSP[ 3 ] = vec3( -.5 * sin( time ), 0., -cos( time ) - 2. );\n\tgSR[ 3 ] = 1. / 16.;\n\tcol[ 3 ] = vec3( 0., .85, .975 );\n    \n    gSP[ 4 ] = vec3( 0., -.5 * cos( time ), -sin( time ) - 2. );\n\tgSR[ 4 ] = 1. / 16.;\n\tcol[ 4 ] = vec3( .975, 0., .85 );\n\n    gSP[ 5 ] = vec3( -.5 * cos( time ), -.5 * sin( time ),  - 2. );\n\tgSR[ 5 ] = 1. / 16.;\n\tcol[ 5 ] = vec3( .85, .975, 0. );\n\n    gSP[ 6 ] = vec3( 0., 0.,  -2. );\n\tgSR[ 6 ] = 1. / 16.;\n\tcol[ 6 ] = vec3( 1., 1., 1. );\n}\n\nbool\nintersectSphere( in vec3 p_distCenterEye, in float p_radSqr ) {\n\n    float\n    lambda = dot( rTD.rayN, p_distCenterEye ),\n    radSqr = dot( p_distCenterEye, p_distCenterEye ) - lambda * lambda; \n    \n    if( p_radSqr < radSqr ) {\n    \n    \treturn false;\n    }\n    \n    hit = rTD.eye + ( sqrt( p_radSqr - radSqr ) - lambda ) * rTD.rayN;\n    \n    return true;\n}\n\nint\nmb( in vec2 p_ri ) {\n\n    vec2\n    c = p_ri;\n    \n    float\n    tmpR;\n    \n    for( int i = 0; i < 255; i++ ) {\n    \n        tmpR = c.x;\n        \n    \tc.x = c.x * c.x - c.y * c.y - p_ri.x; \n    \tc.y = 2. * tmpR * c.y - p_ri.y;\n        \n        if( 16. < c.x * c.x + c.y * c.y ) {\n        \n        \treturn i;\n        }\n    }\n    \n    return 255;\n}\n\nvec4\nrender( ) {\n\n    vec3\n    h = vec3( 0., 0., -1000000. ),\n    n = vec3( 0., 0., 1. ),\n    c = vec3( 0.025, 0.05, 0.0 ),\n    light1 = vec3( -1.5, +1.5, -2. ),\n    light2 = vec3( +1.5, -1.5, -2. ),\n    light3 = vec3( -3. * cos( 5. * time ), 0., -2. + 2. * sin( 5. * time ) );\n    \n    for( int i = 0; i < 7; i++ ) {\n    \n\t    if( intersectSphere( rTD.eye - gSP[ i ], gSR[ i ] ) ) { \n        \n    \t    if( h.z < hit.z ) {\n        \n        \t\th = hit;\n\t\t        n = h - gSP[ i ];\n\t\t        c = col[ i ];\n                \n                if( i == 1 ) {\n                \t\n //                   c *= 1. - float( mb( 5. * ( hit - gSP[ 1 ] ).xy - vec2( pi * sin( .5 * time ), 0. ) ) ) / 255.;\n                }\n                if( i == 5 ) {\n                \t\n          //          c *= float( mb( 5. * ( hit - gSP[ 5 ] ).xy - vec2( -.75 + .5 * sin( .5 * time ), 0. ) ) ) / 255.;\n                }\n        \t}\n        }\n    }\n    \n    if( h.z == -1000000. ) {\n    \n    \tvec2\n        xy_ = xy;\n        \n        xy_ += vec2( .05, -.05 );\n        xy_ = vec2( cos( 1.2 * time ) * xy_.x - sin( 1.2 * time ) * xy_.y, sin( 1.2 * time ) * xy_.x + cos( 1.2 * time ) * xy_.y );\n        xy_ += vec2( -.25, 0. );\n        xy_ = vec2( cos( 2.2 * time ) * xy_.x + sin( 2.2 * time ) * xy_.y, -sin( 2.2 * time ) * xy_.x + cos( 2.2 * time ) * xy_.y );\n        xy_ += vec2( +.25, 0. );\n        xy_ = vec2( cos( 3.2 * time ) * xy_.x - sin( 3.2 * time ) * xy_.y, sin( 3.2 * time ) * xy_.x + cos( 3.2 * time ) * xy_.y );\n        \n        c = vec3( ( 16. * factor * mod( float( mb( ( 5. + 5.7 * sin( .125 * time ) ) * xy_ ) ), 16. ) ) ) * texture( iChannel0, txy ).rgb;\n        return vec4( c, 1 );\n    }\n       \n    float\n    brt = clamp( 2. / pi * asin( ( clamp( -dot( normalize( n ), normalize( h - light1 ) ), 0., 1. ) ) ), 0., 1. ) + \n  \t\t  clamp( 2. / pi * asin( ( clamp( -dot( normalize( n ), normalize( h - light2 ) ), 0., 1. ) ) ), 0., 1. ) +\n          clamp( 2. / pi * asin( ( clamp( -dot( normalize( n ), normalize( h - light3 ) ), 0., 1. ) ) ), 0., 1. );\n//    brt = sqrt( ( 2. / pi * asin( -dot( normalize( n ), normalize( h - light1 ) ) ) ) ) + \n//          sqrt( ( 2. / pi * asin( -dot( normalize( n ), normalize( h - light2 ) ) ) ) ) +\n//          sqrt( ( 2. / pi * asin( -dot( normalize( n ), normalize( h - light3 ) ) ) ) );\n        \n\n    return vec4( .5 * brt * c, 1. );\n}\n\n\nvoid \nmainImage( out vec4 p_col, in vec2 p_xy ) {\n    \n    init( p_xy );\n\t\n    p_col = render( );    \n    \n    //p_col = vec4( .5 +  length( xy ) * vec3( sin( time ), sin( 2. * time ), sin( 3. * time ) ), 1. );\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 330, 356, 356, 414], [416, 416, 446, 446, 478], [480, 480, 507, 507, 1820], [1822, 1822, 1890, 1890, 2186], [2188, 2188, 2212, 2212, 2538], [2540, 2540, 2556, 2556, 4901], [4904, 4904, 4953, 4953, 5116]], "test": "untested"}
{"id": "ldKGRy", "name": "Ray Marching Practice 4", "author": "Takoa", "description": "Quite simple one, just for practicing\nImplement full Disney's (GTR) BRDF\n\n3b: [url]https://www.shadertoy.com/view/lsGGR3[/url]", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 390, "published": "Public API", "date": "1456056602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sphere with Disney's (GTR) BRDF\n// \n// Notes: http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n//------------------------------------------------------------------\n//\n// ALL parts surrounded by \"/* Begin Disney's */\" and /* End Disney's */ are from Disney's codes\n// (https://github.com/wdas/brdf) which are licensed under the license below.\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n// Copyright Disney Enterprises, Inc.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License\n// and the following modification to it: Section 6 Trademarks.\n// deleted and replaced with:\n//\n// 6. Trademarks. This License does not grant permission to use the\n// trade names, trademarks, service marks, or product names of the\n// Licensor and its affiliates, except as required for reproducing\n// the content of the NOTICE file.\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n// Note: Disney's codes are slightly modified for compilability, readability, etc.\n\n#define PI 3.141592653\n#define INV_PI 0.3183098861\n#define GAMMA 2.2\n#define INV_GAMMA 0.4545454545\n\n#define EPSILON 0.0001\n\nvec3 sphereColor = vec3(0.3, 0.9, 0.6);\n\nvec3 cameraPosition = vec3(0.0, 0.0, 2.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraLookingAt = vec3(0.0, 0.0, -100.0);\n\nfloat roughness = 0.3; // Surface roughness, controls both diffuse and specular response.\nfloat subsurface = 0.0; // Controls diffuse shape using a subsurface approximation.\nfloat sheen = 0.0; // An additional grazing component, primarily intended for cloth.\nfloat sheenTint = 0.0; // Amount to tint sheen towards base color.\nfloat specular = 0.5; // Incident specular amount. This is in lieu of an explicit index-of-refraction.\nfloat specularTint = 0.0; // A concession for artistic control that tints incident specular towards the base color. Grazing specular is still achromatic.\nfloat metallic = 0.0; // The metallic-ness (0 = dielectric, 1 = metallic). This is a linear blend between two different models. The metallic model has no diffuse component and also has a tinted incident specular, equal to the base color.\nfloat anisotropic = 0.0; // Degree of anisotropy. This controls the aspect ratio of the specular highlight. (0 = isotropic, 1 = maximally anisotropic.)\nfloat clearcoat = 0.0; // A second, special-purpose specular lobe.\nfloat clearcoatGloss = 1.0; // Controls clearcoat glossiness (0 = a \\satin\" appearance, 1 = a \\gloss\" appearance).\n\nfloat getDistanceToSphere(vec3 rayPosition, vec3 spherePosition, float radius)\n{\n    return length(spherePosition - rayPosition) - radius;\n}\n\nfloat getDistance(vec3 position)\n{\n    return min(\n        getDistanceToSphere(position, vec3(-0.5, 0.0, 0.0), 1.0),\n        getDistanceToSphere(position, vec3(0.5, 0.0, 0.0), 1.0));\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n          getDistance(p + vec3(EPSILON, 0.0, 0.0)) - getDistance(p - vec3(EPSILON, 0.0, 0.0)),\n          getDistance(p + vec3(0.0, EPSILON, 0.0)) - getDistance(p - vec3(0.0, EPSILON, 0.0)),\n          getDistance(p + vec3(0.0, 0.0, EPSILON)) - getDistance(p - vec3(0.0, 0.0, EPSILON))\n        ));\n}\n\nvec3 getRayDirection(vec2 screenPosition, vec3 origin, vec3 lookingAt, vec3 up, float fov)\n{\n    vec3 d = normalize(lookingAt - origin);\n    vec3 rayRight = normalize(cross(d, up));\n    \n    return normalize(screenPosition.x * rayRight + screenPosition.y * up + 1.0 / tan(radians(fov / 2.0)) * d);\n}\n\nfloat rayMarch(inout vec3 p, vec3 rayDirection)\n{\n    float d;\n    \n    for (int i = 0; i < 128; i++)\n    {\n        d = getDistance(p);\n        p += d * rayDirection;\n    }\n    \n    return d;\n}\n\nfloat sq(float f)\n{\n    return f * f;\n}\n\nfloat getSchlicksApproximation(float f)\n{\n    float g = clamp(1.0 - f, 0.0, 1.0);\n    float g2 = g * g;\n    \n    return g2 * g2 * g;\n}\n\nfloat gtr1(float cosThH, float roughness2)\n{\n    float roughness2M1 = roughness2 - 1.0;\n    \n    return roughness2M1 / (PI * log(roughness2) * (1.0 + roughness2M1 * cosThH * cosThH));\n}\n\nfloat gtr2WithAnisotropy(vec3 tangent, vec3 binormal, vec3 halfVector, float cosThH, float roughness2)\n{\n    float aspect = sqrt(1.0 - 0.9 * anisotropic);\n    float aspectX = roughness2 / aspect;\n    float aspectY = roughness2 * aspect;\n    float cosThHSinPhHDivA = dot(halfVector, tangent) / aspectX;\n    float sinThHSinPhHDivA = dot(halfVector, binormal) / aspectY;\n    \n    return 1.0 / (PI * aspectX * aspectY * sq(sq(cosThHSinPhHDivA) + sq(sinThHSinPhHDivA) + sq(cosThH))); // GTR with anisotropy (gamma = 2)\n}\n\nfloat smithG(float cosV, float alphaG2)\n{\n    float cosV2 = cosV * cosV;\n    \n    return 1.0 / (cosV + sqrt(alphaG2 + (1.0 - alphaG2) * cosV2));\n}\n\nvec3 getDisneysReflectance(\n    vec3 normal,\n    vec3 lightDirection,\n    vec3 viewDirection,\n    vec3 tangent,\n    vec3 binormal,\n    vec3 baseColor,\n    float roughness,\n    float subsurface,\n    float sheen,\n    float sheenTint,\n    float specular,\n    float specularTint,\n    float metallic,\n    float anisotropic, \n    float clearcoat,\n    float clearcoatGloss)\n{\n    vec3 halfVector = normalize(lightDirection + viewDirection);\n    float cosL = dot(normal, lightDirection);\n    float cosV = dot(normal, viewDirection);\n    float cosD = dot(lightDirection, halfVector);\n    float cosH = dot(normal, halfVector);\n    float roughness2 = sq(roughness);\n    \n    if (cosL < 0.0)\n        return vec3(0.0);\n    \n    float schlickL = getSchlicksApproximation(cosL);\n    float schlickV = getSchlicksApproximation(cosV);\n    float d90M1 = -0.5 + 2.0 * cosD * cosD * roughness;\n    float diffuse = (1.0 + d90M1 * schlickL) * (1.0 + d90M1 * schlickV);\n    \n    /* Begin Disney's */\n    float fSS90 = cosD * cosD * roughness;\n\tfloat fSS = mix(1.0, fSS90, schlickL) * mix(1.0, fSS90, schlickV);\n\tfloat ss = 1.25 * (fSS * (1.0 / (cosL + cosV) - 0.5) + 0.5);\n    \n    float luminance = 0.298912 * baseColor.x + 0.586611 * baseColor.y + 0.114478 * baseColor.z;\n    vec3 cTint = baseColor / luminance;\n    vec3 cSheen = mix(vec3(1.0), cTint, sheenTint);\n    /* End Disney's */\n    float schlickD = getSchlicksApproximation(cosD);\n    vec3 sheenAmount = schlickD * sheen * cSheen;\n    \n    float specularD = gtr2WithAnisotropy(tangent, binormal, halfVector, cosH, roughness2);\n    float schlickH = getSchlicksApproximation(cosH);\n    vec3 specularF = mix(mix(specular * 0.08 * mix(vec3(1.0), cTint, specularTint), baseColor, metallic),\n                  vec3(1.0),\n                  schlickH);\n    float specularG = smithG(cosL, roughness2) * smithG(cosV, roughness2);\n    \n    /* Begin Disney's */\n    float clearcoatD = gtr1(cosH, sq(mix(0.1, 0.001, clearcoatGloss)));\n    float clearcoatF = mix(0.04, 1.0, schlickH);\n    /* End Disney's */\n    float clearcoatG = smithG(cosL, 0.25) * smithG(cosV, 0.25);\n    \n    return ((baseColor * INV_PI * mix(diffuse, ss, subsurface) + sheenAmount) * (1.0 - metallic)\n           \t    + specularD * specularF * specularG\n        \t\t/* Begin Disney's */\n                + 0.25 * clearcoat * clearcoatD * clearcoatF * clearcoatG)\n                /* End Disney's */\n            * cosL;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 lightPosition = vec3(10.0 * cos(iTime), 10.0, 10.0 * sin(iTime));\n    vec3 rayDirection = getRayDirection(position, cameraPosition, cameraLookingAt, cameraUp, 90.0);\n    vec3 p = cameraPosition;\n    float d = rayMarch(p, rayDirection);\n    \n    if (d < EPSILON)\n    {\n        vec3 normal = getNormal(p);\n        vec3 lightDirection = normalize(lightPosition - p);\n        vec3 tangent = normalize(cross(vec3(0.0, 1.0, 0.0), normal));\n    \tvec3 binormal = normalize(cross(normal, tangent));\n        vec3 reflectance = getDisneysReflectance(\n            normal,\n            lightDirection,\n            -rayDirection,\n            tangent,\n            binormal,\n            sphereColor,\n            roughness,\n            subsurface,\n            sheen,\n            sheenTint,\n            specular,\n            specularTint,\n            metallic,\n            anisotropic,\n            clearcoat,\n            clearcoatGloss);\n        \n        fragColor = vec4(pow(reflectance, vec3(INV_GAMMA)), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKGRy.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[1560, 2693, 2773, 2773, 2833], [2835, 2835, 2869, 2869, 3019], [3021, 3021, 3045, 3045, 3370], [3372, 3372, 3464, 3464, 3671], [3673, 3673, 3722, 3722, 3866], [3868, 3868, 3887, 3887, 3907], [3909, 3909, 3950, 3950, 4043], [4045, 4045, 4089, 4089, 4230], [4232, 4232, 4336, 4336, 4747], [4749, 4749, 4790, 4790, 4895], [4897, 4897, 5265, 5265, 7307], [7309, 7309, 7364, 7364, 8511]], "test": "untested"}
{"id": "ldKGWG", "name": "[TDF16]BoostedDrone", "author": "yasuo", "description": "Tokyodemofest GLSL compo 4th", "tags": ["drone"], "likes": 8, "viewed": 700, "published": "Public API", "date": "1456242327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NEAR 0.01\n#define FAR 84.\n#define ITER 84\n\nfloat tt;\nfloat atime;\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nfloat c_0 = 31599.0;\nfloat c_1 = 9362.0;\nfloat c_2 = 29671.0;\nfloat c_3 = 29391.0;\nfloat c_4 = 23497.0;\nfloat c_5 = 31183.0;\nfloat c_6 = 31215.0;\nfloat c_7 = 29257.0;\nfloat c_8 = 31727.0;\nfloat c_9 = 31695.0;\nfloat c_colon = 1040.0;\n\nmat4 matRotateX(float rad)\n{\n\treturn mat4(1,       0,        0,0,\n\t\t\t\t0,cos(rad),-sin(rad),0,\n\t\t\t\t0,sin(rad), cos(rad),0,\n\t\t\t\t0,       0,        0,1);\n}\n\nmat4 matRotateY(float rad)\n{\n\treturn mat4( cos(rad),0,-sin(rad),0,\n\t\t\t\t 0,       1,        0,0,\n\t\t\t\t sin(rad),0, cos(rad),0,\n\t\t\t\t 0,       0,        0,1);\n}\n\nmat4 matRotateZ(float rad)\n{\n\treturn mat4(cos(rad),-sin(rad),0,0,\n\t\t\t\tsin(rad), cos(rad),0,0,\n\t\t\t\t       0,        0,1,0,\n\t\t\t\t\t   0,        0,0,1);\n}\n\nmat3 mat3RotateX(float rad)\n{\n\treturn mat3(1,       0,        0,\n\t\t\t\t0,cos(rad),-sin(rad),\n\t\t\t\t0,sin(rad), cos(rad));\n}\n\nvec4 combine(vec4 val1, vec4 val2 )\n{\n\tif ( val1.w < val2.w ) return val1;\n\treturn val2;\n}\n\n// iq's distance functions\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n\tfloat WEIGHT = 3.0 / iResolution.x;\n    float t = clamp(dot(d,p-p0) / dot(d,d), tan(iTime *1.0)*1.5,1.0+tan(iTime *1.0)*0.5);\n    vec2 proj = p0 + d * t/1.0;\n    float dist = length(p - proj);\t\t\t\n    dist = 1.0/dist*WEIGHT*(w);\n\t\n    return min(dist*dist,1.0);\n}\n\nfloat staticline(vec2 p, vec2 p0, vec2 p1, float w) {\n    float WEIGHT = 3.0 / iResolution.x;\n    vec2 d = p1 - p0;\n\t\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t/1.0;\n    float dist = length(p - proj);\t\t\t\n    dist = 1.0/dist*WEIGHT*(w);\n\t\n    return min(dist*dist,1.0);\n}\n\nfloat getBit(float num,float bit)\n{\n\tnum = floor(num);\n\tbit = floor(bit);\n\t\n\treturn float(mod(floor(num/pow(2.,bit)),2.) == 1.0);\n}\n\nfloat Sprite3x5(float sprite,vec2 p)\n{\n\tfloat bounds = float(all(lessThan(p,vec2(3,5))) && all(greaterThanEqual(p,vec2(0,0))));\n\t\n\treturn getBit(sprite,(2.0 - p.x) + 3.0 * p.y) * bounds;\n}\n\nfloat Digit(float num,vec2 p)\n{\n\tnum = mod(floor(num),11.0);\n\t\n\tif(num == 0.0) return Sprite3x5(c_0,p);\n\tif(num == 1.0) return Sprite3x5(c_1,p);\n\tif(num == 2.0) return Sprite3x5(c_2,p);\n\tif(num == 3.0) return Sprite3x5(c_3,p);\n\tif(num == 4.0) return Sprite3x5(c_4,p);\n\tif(num == 5.0) return Sprite3x5(c_5,p);\n\tif(num == 6.0) return Sprite3x5(c_6,p);\n\tif(num == 7.0) return Sprite3x5(c_7,p);\n\tif(num == 8.0) return Sprite3x5(c_8,p);\n\tif(num == 9.0) return Sprite3x5(c_9,p);\n\tif(num == 10.0) return Sprite3x5(c_colon,p);\n\t\n\treturn 0.0;\n}\n\n// terrain from https://www.shadertoy.com/view/lt2GRV\nvoid rotate(const float a, inout vec2 v)\n{\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n}\n\nfloat dfTerraHills(vec3 p)\n{\n    p.y-=1.0;\n    vec3 pm = p;\n    pm.xz = mod(pm.xz+vec2(8.0),16.0)-vec2(8.0);\n    pm = abs(pm);\n    return (p.y*.8+3.0+pm.x*.1+pm.z*.1);\n}\n\nfloat dfTerra(vec3 p)\n{\n    p.y+=.1;\n    vec3 p2 = p;\n    float height = (sin(p.x*.1)+sin(p.z*.1))*1.5;\n    rotate(.6,p2.xz);\n    return max(dfTerraHills(p2),dfTerraHills(p))+height;\n}\n\nvec4 map( vec3 pos, mat4 m)\n{\n\tfloat d = 10.0;\n\n\tvec4 q = vec4(pos+vec3(0,-3,-50.0),1.0)*m;\n\tvec4 ql = vec4(pos+vec3(0,-3,-50.0)+vec3( 0, 0, iTime*50.0 ),1.0);\n\tvec4 body1 = vec4(vec3(0.35,0.0,0.0),sdBox(q.xyz + vec3( 0, 0, 0 ), vec3(1.0,1.0,13.0) ));\n\tvec4 body2 = vec4(vec3(0.35,0.0,0.0),sdBox(q.xyz + vec3( 0, 0, 0 ), vec3(13.0,1.0,1.0) ));\n\tvec4 body3 = vec4(vec3(0.35,0.0,0.0),sdBox(q.xyz + vec3( 0, 0, 0 ), vec3(3.0,2.0,3.0) ));\n\td = min(d, smin(body1.w, body2.w, 0.2));\n\td = smin(d, body3.w, 0.2);\n\n\tql.z = mod(ql.z, 16.0)-8.0;\n\tvec4 lineL = vec4(vec3(0.5,0.1,0.1),sdBox(ql.xyz + vec3( 17.0, 2.0, 0 ), vec3(0.5,0.01,3.0) ));\n\tvec4 lineR = vec4(vec3(0.5,0.1,0.1),sdBox(ql.xyz + vec3( -17.0, 2.0, 0 ), vec3(0.5,0.01,3.0) ));\n\n\tvec4 wholeBody = vec4(0.33,0.33,0.32,d);\n\n\tvec4 propeller1a = vec4(vec3(0.7,0.7,0.7),sdBox(q.xyz + vec3( 12.0, -1.0, 0 ), vec3(0.5,3.0,0.5) ));\n\tvec4 prot1 = (q+vec4( 12.0, -3.7, 0, 1.0))*matRotateY(-iTime*7.0);\n\tvec4 propeller1b = vec4(vec3(1.0,0.16,0.0),sdBox(prot1.xyz, vec3(0.5,0.1,7.0) ));\n\n\tvec4 propeller2a = vec4(vec3(0.7,0.7,0.7),sdBox(q.xyz + vec3( -12.0, -1.0, 0 ), vec3(0.5,3.0,0.5) ));\n\tvec4 prot2 = (q+vec4( -12.0, -3.7, 0, 1.0))*matRotateY(-iTime*7.5);\n\tvec4 propeller2b = vec4(vec3(1.0,0.16,0.0),sdBox(prot2.xyz, vec3(0.5,0.1,7.0) ));\n\n\tvec4 propeller3a = vec4(vec3(0.7,0.7,0.7),sdBox(q.xyz + vec3( 0.0, -1.0, 12.0 ), vec3(0.5,3.0,0.5) ));\n\tvec4 prot3 = (q+vec4(0.0, -3.7, 12.0, 1.0))*matRotateY(iTime*7.3);\n\tvec4 propeller3b = vec4(vec3(1.0,0.16,0.0),sdBox(prot3.xyz, vec3(0.5,0.1,7.0) ));\n\n\tvec4 propeller4a = vec4(vec3(0.7,0.7,0.7),sdBox(q.xyz + vec3( 0.0, -1.0, -12.0 ), vec3(0.5,3.0,0.5) ));\n\tvec4 prot4 = (q+vec4(0.0, -3.7, -12.0, 1.0))*matRotateY(iTime*7.5);\n\tvec4 propeller4b = vec4(vec3(1.0,0.16,0.0),sdBox(prot4.xyz, vec3(0.5,0.1,7.0) ));\n\n\tvec4 terrain = vec4(0.15,0.15,0.15,dfTerra(pos+vec3( 0, 0, iTime*30.0 )));\n\n\tvec4 temp = combine(terrain,wholeBody);\n\tvec4 temp1 = combine(lineL,lineR);\n\tvec4 temp2 = combine(propeller1a,propeller1b);\n\tvec4 temp3 = combine(propeller2a,propeller2b);\n\tvec4 temp4 = combine(propeller3a,propeller3b);\n\tvec4 temp5 = combine(propeller4a,propeller4b);\n\n\tvec4 temp6 = combine(temp,temp1);\n\tvec4 temp7 = combine(temp2,temp3);\n\tvec4 temp8 = combine(temp4,temp5);\n\tvec4 temp9 = combine(temp6,temp7);\n\tvec4 temp10 = combine(temp8,temp9);\n\n\treturn temp10;\n}\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tcos(a) * p.x - sin(a) * p.y,\n\t\tsin(a) * p.x + cos(a) * p.y);\n}\n\nvec3 gradientbg(float p)\n{\n\tfloat span = 15.0;\n\tvec3 b0 = vec3(0.15, 0.15, 0.15)   * (step(p,(1.0/span) * 5.0) - (step(p,(1.0/span) * (5.0 - 1.))));\n    vec3 b1 = vec3(0.25, 0.25, 0.25)   * (step(p,(1.0/span) * 4.0) - (step(p,(1.0/span) * (4.0 - 1.))));\n    vec3 b2 = vec3(0.3, 0.3, 0.3)   * (step(p,(1.0/span) * 3.0) - (step(p,(1.0/span) * (3.0 - 1.))));\n    vec3 b3 = vec3(0.32, 0.32, 0.32)   * (step(p,(1.0/span) * 2.0) - (step(p,(1.0/span) * (2.0 - 1.))));\n    vec3 b4 = vec3(0.35,0.35, 0.35) * (step(p,(1.0/span) * 1.0) - (step(p,(1.0/span) * (1.0 - 1.))));\n    return b0 + b1 + b2 + b3 + b4;\n}\n\nvec3 drawRader(vec2 p, vec2 pos, float r){\n    float dist =  sqrt(dot(p+pos, p+pos));\n\tfloat border = 0.006;\n\tfloat circle_radius = 0.15;\n\tvec3 cl = vec3(0);\n\tfloat l = staticline(p+pos,vec2(0),rot(vec2(0.1,0.1),r), 0.5);\n\t\n\tif ( (dist > (circle_radius+border)) || (dist < (circle_radius-border)) ){\n\t\tcl += vec3(0)+vec3(vec3(l)*vec3(1.0,0.16,0.0));\n\t}else{ \n\t\tcl += vec3(0.3)+vec3(vec3(l)*vec3(1.0,0.16,0.0));\n\t}\n\treturn cl;\n}\n\nfloat loopEnd = 20.0;\nvoid drwaScene(out vec4 fragColor, in vec2 fragCoord, vec2 position,vec3 dir) {\n\tfloat aspect = iResolution.x / iResolution.y;\n \tdir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n \tvec3 pos;\n\n \tif(mod(iTime,loopEnd) >= 0.0 && mod(iTime,loopEnd) < 5.0) {\n\t\tdir.yz = rot(dir.yz, 1.2 - mod(iTime*(1.0/5.0),1.0));\n\t \tpos = vec3(0.0, 60.0-mod(iTime*(52.0/5.0), 52.0), 35.0-mod(iTime*(30.0/5.0),30.0));\n \t}\n\n \tif(mod(iTime,loopEnd) >= 5.0 && mod(iTime,loopEnd) < 15.0) {\n \t\tdir.yz = rot(dir.yz, 0.2);\n \t\tpos = vec3(0.0, 8.0, 5.0);\n \t}\n\n    /*\n\tif(mod(time,loopEnd) >= 10.0 && mod(time,loopEnd) < 15.0) {\n\t\tdir.xz = rot(dir.xz, (DEG_TO_RAD*180.0));\n \t\tpos = vec3(0.0, 3.0, 115.0);\n\t}\n    */\n\n\tif(mod(iTime,loopEnd) >= 15.0) {\n \t\tdir.yz = rot(dir.yz, 0.2);\n \t\tpos = vec3(0.0, 8.0, 5.0);\n\t}\n\n\tmat4 m = matRotateY(DEG_TO_RAD*45.0)*matRotateX(sin(iTime*2.0)*(DEG_TO_RAD*5.0))*matRotateZ(sin(iTime*1.5)*(DEG_TO_RAD*7.0));\n\n\tvec4 result;\n\tfloat e = 0.0001;\n\tfloat t = e * 2.0;\n\tfloat h = 0.0;\n\tfor (int i = 0; i < ITER; i++)\n\t{\n\t\tif(t < e || t > 20.0) continue;\n\t\tresult = map(pos, m);\n\t\tif (result.w < NEAR || result.w > FAR) break;\n\t\tpos += result.w * dir;\n\t\tt += h;\n\t}\n \n\tvec3 col = map(pos, m).xyz;\n\tvec4 bgCol;\n\tif ( pos.z> 100. )\n\t{\n\t\t// bg\n\t\tposition.y += (sin((position.x + (iTime * 0.3)) * 2.0) * 0.1) + (sin((position.x + (iTime * 0.1)) * 10.0) * 0.01);\n\t\tfloat xpos = 0.2;\n\t\tfloat ypos = 0.13;\n\t\tfloat l = line(position,vec2(0.1+xpos,0.1+ypos),vec2(0.22+xpos,0.1+ypos),0.2);\n\t\tl += line(position,vec2(0.12+xpos,0.12+ypos),vec2(0.2+xpos,0.12+ypos),0.2);\t\t\t\t\n\t\tl += staticline(position,vec2(0.1+xpos,0.1+ypos),vec2(0.22+xpos,0.1+ypos),0.2);\n\t\tl += staticline(position,vec2(0.1+xpos,0.1+ypos),vec2(0.178+xpos,0.3+ypos),0.2);\n\t\tl += staticline(position,vec2(0.22+xpos,0.1+ypos),vec2(0.19+xpos,0.25+ypos),0.2);\n\t\tl += staticline(position,vec2(0.12+xpos,0.12+ypos),vec2(0.2+xpos,0.12+ypos),0.2);\n\t\tl += staticline(position,vec2(0.12+xpos,0.12+ypos),vec2(0.178+xpos,0.27+ypos),0.2);\n\n\t\tcol = gradientbg(position.y+0.1)+(vec3(l)*vec3(1.0,0.16,0.0));\n\t}\n\telse\n\t{\n\t\t// shade\n\t\tvec3 lightPos = vec3(20.0, 20.0, 20.0 );\n\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\tvec3 eps = vec3( .1, .01, .0 );\n\t\tvec3 n = vec3( result.w - map( pos - eps.xyy, m ).w,\n\t\t\t       result.w - map( pos - eps.yxy, m ).w,\n\t\t\t       result.w - map( pos - eps.yyx, m ).w );\n\t\tn = normalize(n);\n\t\t\t\t\n\t\tfloat lambert = max(.0, dot( n, light2Pos));\n\t\tcol *= vec3(lambert);\n\n\t\tcol += vec3(result.xyz);\n\t}\n\n\tposition = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cl3 = vec3(0);\n\tcl3 += drawRader(position,vec2(1.23,-0.80),iTime*2.0);\n\tcl3 += drawRader(position,vec2(1.58,-0.80),-iTime*3.0);\n\n\tposition = ( fragCoord.xy /iResolution.xy ) * vec2(256,128);\n\tvec2 cpos = vec2(1.5);\n\tfloat dc = Digit(fract(iTime)*10.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*20.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(10.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*40.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*50.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(10.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*70.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*80.0,floor(position-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*90.0,floor(position-cpos));\n\n\tvec3 cl2 = vec3(dc)*vec3(0.3,0.3,0.3);\n\n\tfragColor = vec4( col+cl2+cl3, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 position = ( fragCoord.xy / iResolution.xy );\n\tposition -= .5;\n\tvec3 dir = vec3( position, 1.0 );\n\t/*\n\tif(mod(time,20.0) >= 10.0 && mod(time,20.0) < 15.0) {\n\t\tposition = mod(position, .5);\n\t\tposition = position * 2.0 - .5;\n\t\tposition.y /= iResolution.x / iResolution.y;\n\t}\n\t*/\n    drwaScene(fragColor,fragCoord,position,dir);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 378, 406, 406, 530], [532, 532, 560, 560, 688], [690, 690, 718, 718, 839], [841, 841, 870, 870, 960], [962, 962, 999, 999, 1052], [1054, 1081, 1112, 1112, 1197], [1199, 1199, 1238, 1238, 1335], [1338, 1338, 1385, 1385, 1671], [1673, 1673, 1726, 1726, 1981], [1983, 1983, 2018, 2018, 2114], [2116, 2116, 2154, 2154, 2304], [2306, 2306, 2337, 2337, 2841], [2843, 2897, 2939, 2939, 3047], [3049, 3049, 3077, 3077, 3218], [3220, 3220, 3243, 3243, 3404], [3406, 3406, 3435, 3435, 5749], [5751, 5751, 5778, 5778, 5857], [5859, 5859, 5885, 5885, 6458], [6460, 6460, 6502, 6502, 6887], [6911, 6911, 6990, 6990, 10369], [10371, 10371, 10427, 10427, 10764]], "test": "untested"}
{"id": "ldKGWW", "name": "A Sphere Amid A Pyramid", "author": "wjbgrafx", "description": "An experiment in building a scene using the Mercury GLSL Library and Inigo Quilez' distance functions, based on the\n\"Simple test/port of Mercury's SDF Library to WEBGL\" by tomkh, and code from other sources.", "tags": ["3d", "raymarching", "sphere", "pyramid", "mercury", "hgsdf"], "likes": 21, "viewed": 1014, "published": "Public API", "date": "1454547791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*  \n \tA SPHERE AMID A PYRAMID\n \n\tCode is mainly based on\n\t\n\thttps://www.shadertoy.com/view/Xs3GRB\n\tUploaded by tomkh on 2015-Dec-16\t\n\tSimple test/port of Mercury's SDF library to WebGL.\n\t\n\tMinor editing and modification by wjb. \n\tExcerpted functions with my comments that were removed from this code are\n\tattached at the bottom of this file, as well as a program flow analysis \n\tthat helped me figure out what was going on in the original code, in the hope\n    that someone else might find them useful.\n\n\tAdditional sources:\n\t===================\n\tHG_SDF GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS by MERCURY\n\thttp://mercury.sexy/hg_sdf\n\n\thttp://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\thttps://github.com/ashima/webgl-noise\n\n\thttps://www.shadertoy.com/view/lll3z4\n\tGardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n\t\n\thttp://raymarching.com/WebGL/WebGL_ShadowsReflections.htm\n    Source - Raymarching.com\n    Author - Gary \"Shane\" Warne\n    eMail - mail@Raymarching.com, mail@Labyrinth.com\n    Last update: 28th Aug, 2014\n\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n*/\n//==============================================================================\n\n#define PI 3.141592653589793\n\nconst int nTerms = 10;\nconst int iterations = 160;\nconst float dist_eps = .001;\nconst float ray_max = 200.0;\nconst float fog_density = 0.001; \nconst float cam_dist = 17.0;\nconst float eps = 0.005;\n\nvec3 surfNormal = vec3(0.0 );\n                                                           \n//------------------------------------------------------------------------------\n// Function declarations \nvec2 scene(vec3 p);\t\nfloat pMirror (inout float p, float dist);\nfloat fSphere(vec3 p, float r);\nfloat fBox(vec3 p, vec3 b);\nfloat fCylinder(vec3 p, float r, float height);\nfloat fOpUnionStairs(float a, float b, float r, float n);\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r);\nfloat snoise(vec3 v);\n\n//------------------------------------------------------------------------------\n// Triangular Prism - signed\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// Modified from sdTriPrism()\n\n// Prism with apex parallel to z-axis\nfloat sdPrismZ( vec3 p, float angleRads, float height, float depth ) \n{\n    // sin 60 degrees = 0.866025\n    // sin 45 degrees = 0.707107\n    // sin 30 degrees = 0.5\n    // sin 15 degrees = 0.258819\n    vec3 q = abs( p );\n    return max( q.z - depth, \n           max( q.x * angleRads + p.y * 0.5, -p.y ) - height * 0.5 );\n}\n//------------------------------------------------------------------------------\n\n// Prism with apex parallel to x-axis\nfloat sdPrismX( vec3 p, float angleRads, float height, float depth ) \n{\n    vec3 q = abs( p );\n    return max( q.x - depth, \n           max( q.z * angleRads + p.y * 0.5, -p.y ) - height * 0.5 );                                                         \n}\n//------------------------------------------------------------------------------\n\n// For a 60 degree pyramid, height must be equal to depth. If height is greater\n// than depth, a square base is drawn beneath the pyramid. \n\n// If height is less than depth, the drawn depth will only be as large as height.\n\n// For angles less than 60 degrees, the depth must be proportionately larger\n// than the height to avoid a square base beneath the pyramid.\n\nfloat sdPyramid( vec3 p, float angleRads, float height, float depth )\n{\n    // Limited to range of 15 to 60 degrees ( for aesthetic reasons ).\n    angleRads = clamp( angleRads, 0.258819, 0.866025 );\n    vec3 q = abs( p );\n\t\n\t// Intersection of prisms along two perpendicular axes.\n\treturn max( sdPrismX( p, angleRads, height, depth ), \n\t            sdPrismZ( p, angleRads, height, depth ) );\n\n}\n//------------------------------------------------------------------------------\n\n// SCENE\n// -----\n\nvec2 scene( vec3 p )\n{\n\t// Domain Manipulation.\n\t//---------------------\n\t// Mirror at an axis-aligned plane which is at a specified distance \n\t// <dist> from the origin.\n\tpMirror( p.x, 0.0 );\n\tpMirror( p.z, 0.0 );\n\t\n\t// Object initialization.\n\t//------------------------\t\n\t// Center pyramid\n\t//---------------\n\tfloat objID = 1.0;\n\tvec2 pyramid = vec2( sdPyramid( p - vec3( 0.0, -0.25, 0.0 ), 0.866025, \n\t                                                       3.5, 3.5 ), objID );\n\n\tvec2 innerFrontPyramid = vec2( sdPyramid( p - vec3( 0.0, -0.25, 0.55 ), \n\t                                            0.866025, 2.6, 2.66 ), objID ); \n\n\tvec2 innerEastPyramid = vec2( sdPyramid( p - vec3( 0.55, -0.25, 0.0 ), \n\t                                            0.866025, 2.6, 2.66 ), objID ); \t\n\t// Sphere inside center pyramid\n\t//-----------------------------\n\tobjID = 2.0;\n\tvec2 centerSphere = vec2( fSphere( p - vec3( 0.0, -0.25, 0.0 ), 0.8 ), \n\t                                                                   objID );\t               \n\t// Sphere above center pyramid\n\t//----------------------------\n\tobjID = 3.0;\n\tvec2 upperSphere = vec2( fSphere( p - vec3( 0.0, 5.0, 0.0 ), 0.3 ), \n\t                                                                   objID );\t\t\n\t// Corner gazebo\n\t//--------------\n\tobjID = 4.0;\n\tvec2 cornerBox = vec2( fBox( p - vec3( 5.0, -0.225, 5.0 ), \n\t                                       vec3( 0.75, 1.75, 0.75 ) ), objID ); \t\n\n\tvec2 boxHollow = vec2( fCapsule( p, vec3( 5.0, -1.2, 5.0 ), \t                                     \n\t                                    vec3( 5.0,  0.6, 5.0 ), 0.9 ), objID );                             \n\t// Mound beneath corner gazebo                                                                   \t                                       \n\t//----------------------------\n\tobjID = 5.0;\n\tvec2 cornerMound = vec2( fSphere( p - vec3( 5.0, -4.25, 5.0 ), 3.0 ), \n\t                                                                   objID );\t\n\tvec2 sphereHide = vec2( fBox( p - vec3( 5.0, -5.0, 5.0 ),\n\t                                          vec3( 3.1, 3.0, 3.1 ) ), objID );\n\t// Pyramid atop gazebo\n\t//--------------------\n\tobjID = 6.0;\n\tvec2 cornerPyramid = vec2( sdPyramid( p - vec3( 5.0, 2.15, 5.0 ), 0.866025,\n\t                                                     1.25, 1.25 ), objID );\t\n\n\t// Because these cutout pyramids are not at origin, like the center pyramid,\n\t// one for each side is necessary.\n\tvec2 innerFrontCornerPyramid = vec2( sdPyramid( p - vec3( 5.0, 2.15, 5.15 ), \n\t                                            0.866025, 1.0, 1.25 ), objID );\n\n\tvec2 innerEastCornerPyramid = vec2( sdPyramid( p - vec3( 5.15, 2.15, 5.0 ), \n\t                                            0.866025, 1.0, 1.25 ), objID );\n\t                                                            \n\tvec2 innerBackCornerPyramid = vec2( sdPyramid( p - vec3( 5.0, 2.15, 4.85 ), \n\t                                            0.866025, 1.0, 1.25 ), objID );\n\n\tvec2 innerWestCornerPyramid = vec2( sdPyramid( p - vec3( 4.85, 2.15, 5.0 ), \n\t                                            0.866025, 1.0, 1.25 ), objID );\n\t// Corner sphere\n\t//--------------\n\tobjID = 8.0;\n\tvec2 cornerSphere = vec2( fSphere( p - vec3( 5.0, 2.25, 5.0 ), 0.25 ), \n\t                                                                   objID );\t\t\n\t// Upper corner sphere\n\t// -------------------\n\tobjID = 9.0;\n\tvec2 upperCornerSphere = vec2( fSphere( p - vec3( 5.0, 4.0, 5.0 ), 0.15 ), \n\t                                                                   objID );\t               \n\t// East globe platform\n\t//--------------------\n\tobjID = 16.0;\n\tvec2 eastGlobePlatform = vec2( fCylinder( p - vec3( 8.0, -1.95, 2.0 ),\n\t                                                     1.25, 0.05 ), objID );\t\t\n\t// East Globe\n\t//-----------\n\tobjID = 10.0;\n\tvec2 eastGlobe = vec2( fSphere( p - vec3( 8.0, -1.0, 2.0 ), 1.0 ), objID );\n\t\n\tvec2 innerEastHollowTop = vec2( fCapsule( p, \n\t           vec3( 7.0, 0.0, 2.0 ), vec3( 9.0, -2.0, 2.0 ), 0.475 ), objID );\t\n\t\n\tvec2 innerEastHollowBtm = vec2( fCapsule( p, \n\t           vec3( 9.0, 0.0, 2.0 ), vec3( 7.0, -2.0, 2.0 ), 0.475 ), objID );\n\t\n\tvec2 innerFrontHollowTop = vec2( fCapsule( p, \n\t           vec3( 8.0, 0.0, 3.0 ), vec3( 8.0, -2.0, 1.0 ), 0.475 ), objID );\t\n\t\n\tvec2 innerFrontHollowBtm = vec2( fCapsule( p, \n\t           vec3( 8.0, 0.0, 1.0 ), vec3( 8.0, -2.0, 3.0 ), 0.475 ), objID );\n\t\n\tvec2 innerFrontHollowLeft = vec2( fCapsule( p,\n\t          vec3( 7.0, -1.0, 3.0 ), vec3( 9.0, -1.0, 1.0 ), 0.475 ), objID );\n\t\n\tvec2 innerFrontHollowRight = vec2( fCapsule( p,\n\t          vec3( 9.0, -1.0, 3.0 ), vec3( 7.0, -1.0, 1.0 ), 0.475 ), objID );\n\t          \t\n\t// Pyramid above east globe\n\t//-------------------------\n\tobjID = 15.0;\n\tvec2 globePyramid = vec2( sdPyramid( p - vec3( 8.0, 1.0, 2.0 ), 0.866025,\n\t                                                     0.35, 0.35 ), objID );\t\n\t// Sphere in globe\n\t//----------------\n\tobjID = 11.0;\n\tvec2 sphereInGlobe = vec2( fSphere( p - vec3( 8.0, -1.0, 2.0 ), 0.5 ), \n\t                                                                   objID );\n\t// Front pyramid platform\n\t//-----------------------\n\tobjID = 12.0;\n\tvec2 frontPyramidPlatform = vec2( fCylinder( p - vec3( 0.0, -1.85, 8.0 ),\n\t                                                     2.25, 0.15 ), objID );\n\t// Front pyramid\n\t//--------------\t\n\tobjID = 13.0;\n\tvec2 frontPyramid = vec2( sdPyramid( p - vec3( 0.0, -0.8, 8.0 ), 0.866025, \n\t                                                     1.75, 1.75 ), objID );\t\n\tvec2 sphereHollow = vec2( fSphere( p - vec3( 0.0, -1.5, 8.0 ), 1.5 ), \n\t                                                                   objID );\n\t// Front pyramid sphere\n\tobjID = 14.0;\n\tvec2 frontPyramidSphere = vec2( fSphere( p - vec3( 0.0, -0.9, 8.0 ), 0.5 ), \n\t                                                                   objID );\n\t// Sphere above front pyramid\n\tobjID = 17.0;\n\tvec2 frontPyramidUpperSphere = \n\t                  vec2( fSphere( p - vec3( 0.0, 2.5, 8.0 ), 0.2 ), objID );\n\t                                                                    \n\t//------------------------------------------\n\t// Combination operations.\n\t\n\tpyramid = max( pyramid, -innerFrontPyramid );\n\tpyramid = max( pyramid, -innerEastPyramid );\n\t\n\tcornerMound = max( cornerMound, -sphereHide );\t\n\tcornerBox = max( cornerBox, -boxHollow );\n\t\n\tcornerPyramid = max( cornerPyramid, -innerFrontCornerPyramid );\n\tcornerPyramid = max( cornerPyramid, -innerEastCornerPyramid );\n\tcornerPyramid = max( cornerPyramid, -innerBackCornerPyramid );\n\tcornerPyramid = max( cornerPyramid, -innerWestCornerPyramid );\n\n\tobjID = 7.0;\n\tvec2 cornice = vec2( fOpUnionStairs( cornerBox.s, cornerPyramid.s,\n\t                                                      0.25, 4.0 ), objID );\n\n    eastGlobe = max( eastGlobe, -innerEastHollowTop );\n\teastGlobe = max( eastGlobe, -innerEastHollowBtm );\n\teastGlobe = max( eastGlobe, -innerFrontHollowTop );\n\teastGlobe = max( eastGlobe, -innerFrontHollowBtm );\n\teastGlobe = max( eastGlobe, -innerFrontHollowLeft );\n\teastGlobe = max( eastGlobe, -innerFrontHollowRight );\n\t\n\tfrontPyramid = max( frontPyramid, -sphereHollow );\n\t\n\t//-----------------------------------------------\n\t// Distance comparisons.\n    //----------------------\n\t// Note that the line comparing 'cornice' must be placed before both \n    // 'cornerBox' and 'cornerPyramid'; otherwise it changes their color\n    // and textures to its own.\n\tvec2 closer = pyramid.s < centerSphere.s ? pyramid : centerSphere;\n\tcloser = pyramid.s < centerSphere.s ? pyramid : centerSphere;\n\tcloser = closer.s < upperSphere.s ? closer : upperSphere;\n\tcloser = closer.s < cornice.s ? closer : cornice;\n\tcloser = closer.s < cornerBox.s ? closer : cornerBox;\n\tcloser = closer.s < cornerPyramid.s ? closer : cornerPyramid;\n\tcloser = closer.s < cornerMound.s ? closer : cornerMound;\n\tcloser = closer.s < cornerSphere.s ? closer : cornerSphere;\n\tcloser = closer.s < upperCornerSphere.s ? closer : upperCornerSphere;\n\tcloser = closer.s < eastGlobe.s ? closer : eastGlobe;\n\tcloser = closer.s < sphereInGlobe.s ? closer : sphereInGlobe;\n\tcloser = closer.s < frontPyramidPlatform.s ? closer : frontPyramidPlatform;\n\tcloser = closer.s < frontPyramid.s ? closer : frontPyramid;\n\tcloser = closer.s < frontPyramidSphere.s ? closer : frontPyramidSphere;\n\tcloser = closer.s < globePyramid.s ? closer : globePyramid;\n\tcloser = closer.s < eastGlobePlatform.s ? closer : eastGlobePlatform;\n\tcloser = closer.s < frontPyramidUpperSphere.s ? closer : \n\t                                                   frontPyramidUpperSphere;\t\n\treturn closer;\n}\n\n//------------------------------------------------------------------------------\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n    \n    // Updated 2-16-16 because the shader wouldn't auto-animate until clicked into. This if/else\n    // clause was intended to stop auto-animation if user was manipulating world with mouse.\n    // if ( iMouse.z < 0.0 )\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = iTime * 0.2;\n    }\n    else\n    {\n    \tang = ( iMouse.x - iResolution.x * 0.5 ) * rotRange;\n    }\n    sinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n    if ( iMouse.z < 0.0 )\n    {\n        ang = 1.5 * ( abs( 2.0 * fract( iTime * 0.01 ) - 1.0 ) - 0.25 );\n    }\n    else\n    {\n    \tang = ( iMouse.y - iResolution.y * 0.5 ) * rotRange; \n    }\n    sinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// http://raymarching.com/WebGL/WebGL_ShadowsReflections.htm\n\n// Source - Raymarching.com\n// Author - Gary \"Shane\" Warne\n// eMail - mail@Raymarching.com, mail@Labyrinth.com\n// Last update: 28th Aug, 2014\n\nvec3 getNormal( in vec3 p ) \n{\t\t\n\tvec2 e = vec2( eps, 0.0 );\n\treturn normalize( vec3( scene( p + e.xyy ).s - scene( p - e.xyy ).s, \n\t                        scene( p + e.yxy ).s - scene( p - e.yxy ).s, \n\t                        scene( p + e.yyx ).s - scene( p - e.yyx ).s ));\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// RAYMARCH\n// --------\n\nvec4 raymarch( vec3 rayOrig, vec3 rayDir )\n{\n   vec3 p = rayOrig;\n   vec2 nearest = vec2( 0.0 );\n   float rayLength = 0.0;\n   \n   for( int i = 0; i < iterations; ++i ) \n   {\n\t\tnearest = scene( p );\n\t\tfloat dist = nearest.s;\n\t\t\n\t\tif ( dist < dist_eps ) \tbreak;\t\t\n\t\tif ( rayLength > ray_max ) return vec4( 0.0 );\n\t\t\n\t\tp += dist * rayDir;\n\t\trayLength += dist;\n   }\n   \n   return vec4( p, nearest.t );\n}\n\n// end raymarch()\n\n//------------------------------------------------------------------------------\n\n// GET TEXTURE\n// -----------\n\n// Slightly modified and reformatted the original code from\n// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n// by David J. Eck : http://math.hws.edu/graphicsbook/\n// ---------------\n// Creative Commons Attribution-Noncommercial-ShareAlike 4.0 License.\n\nvec4 getTexture( int texNum, vec3 pos, float scale, float complexity, \n                                                  vec4 objClr, float mixVal )\n{\n\tvec3 v = vec3( 0.0 ),\n\t     color = vec3( 0.0 );\n\t     \n\tfloat value = 0.0;\n\t\n\tif ( texNum == 19 )\n\t{\n\t\t// wjb modified Perlin Noise 3D\n\t\t// With complexity = 1.0, squiggly lines in objColor on white\n\t\tv = pos * scale;\n\t\tvalue = log( pow( snoise( v ), 2.0 ) ) * complexity; \n\t    value = 0.75 + value * 0.25;\n\t    color = vec3( value);    \t\t    \n\t    return mix( vec4( color, 1.0 ), objClr, mixVal );        \t\t\t\t\n\t}\n\telse if ( texNum == 20 )\n\t{\n\t\t// wjb modified Perlin Noise 3D\n\t\t// white squiggly lines on objClr\n\t\tv = pos * scale;\n\t\tvalue = inversesqrt( pow( snoise( v ), 2.0 ) ) * complexity; \n\t    value = 0.75 + value * 0.25;\n\t    color = vec3( value);    \t\t    \n\t    return mix( vec4( color, 1.0 ), objClr, mixVal );\n\t}\n\telse if ( texNum == 21 )\n\t{        \t\t\t\t\n\t\t// wjb modified Perlin Noise 3D\n\t\t// Blotches of objClr surrounded by very thin squiggly black lines\n\t\t// on white background\n\t\tv = pos * scale;\n\t\tvalue = exp( inversesqrt( pow( snoise( v ), 2.0 ) * complexity ) ); \n\t    value = 0.75 + value * 0.25;\n\t    color = vec3( value);    \t\t    \n\t    return mix( vec4( color, 1.0 ), objClr, mixVal );        \t\t\t\t\n\t}\n\n\treturn vec4( 0.0 );\n}\n\n// end getTexture()\n\n//------------------------------------------------------------------------------\n\n// APPLY TEXTURE\n// -------------\n\nvec3 applyTexture( vec4 hitPosAndID )\n{\n\tvec4 objClr = vec4( 0.0 );\n\t\n\tvec3 pos = hitPosAndID.xyz,\n\t     base_color = vec3( 0.0 );\n\t\n\tfloat scale = 0.0,\n\t      complexity = 0.0,\n\t      mixVal = 0.0; \n\n\tint texNum = 0,\n\t    objNum = int ( hitPosAndID.w );\n\t      \n\t//  1: pyramid\n\t// 11: sphere in globe\n\t// 12: front pyramid platform\n\t// 16: east globe platform\t\n\tif ( objNum == 1 || objNum == 11 || objNum == 12 || objNum == 16 )\n\t{\t\t\t\t\n\t\ttexNum = 20;\n\t\tobjClr = vec4( 0.15, 0.5, 1.0, 1.0 );\n\t\tscale = 1.5;\n\t\tcomplexity = 4.0,\n\t\tmixVal = 0.85;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\n\t//  2: center sphere\n\t// 15: globe pyramid\n\telse if ( objNum == 2 || objNum == 15 )\n\t{\n\t\ttexNum = 21;\n\t\tobjClr = vec4( 0.0, 0.15, 1.0, 1.0 );\n\t\tscale = 2.0;\n\t\tcomplexity = 1.5,\n\t\tmixVal = 0.9;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\n\t// 3: upper sphere\n\telse if ( objNum == 3 )\n\t{\n\t\ttexNum = 21;\n\t\tobjClr = vec4( 0.0, 0.15, 1.0, 1.0 );\n\t\tscale = 5.0;\n\t\tcomplexity = 5.0,\n\t\tmixVal = 0.9;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\t\t\n\t// 4: corner gazebo\n\telse if ( objNum == 4 )\n\t{\n\t\ttexNum = 19;\n\t\tobjClr = vec4( 0.2, 0.275, 1.0, 1.0 );\n\t\tscale = 2.0;\n\t\tcomplexity = 0.5,\n\t\tmixVal = 0.6;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\n\t// 5: mound beneath corner gazebo\n\telse if ( objNum == 5 || objNum == 7 )\n\t{\t\n\t\ttexNum = 19;\n\t\tobjClr = vec4( 0.66, 0.66, 1.0, 1.0 );\n\t\tscale = 3.0;\n\t\tcomplexity = 0.75,\n\t\tmixVal = 0.5;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\n\t//  6: pyramid atop corner gazebo\n\t// 14: front pyramid sphere\n\t// 17: front pyramid upper sphere\n\telse if ( objNum == 6 || objNum == 14 || objNum == 17 )\n\t{\n\t\ttexNum = 20;\n\t\tobjClr = vec4( 0.5, 0.4, 1.0, 1.0 );\n\t\tscale = 3.0;\n\t\tcomplexity = 5.0,\n\t\tmixVal = 0.85;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\n\t// 8: corner sphere\t\n\telse if ( objNum == 8 )\n\t{\n\t\ttexNum = 21;\n\t\tobjClr = vec4( 0.0, 0.15, 1.0, 1.0 );\n\t\tscale = 2.0;\n\t\tcomplexity = 1.5,\n\t\tmixVal = 0.9;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\n\t// 9: upper corner sphere\n\telse if ( objNum == 9 )\n\t{\n\t\ttexNum = 21;\n\t\tobjClr = vec4( 0.0, 0.15, 1.0, 1.0 );\n\t\tscale = 2.0;\n\t\tcomplexity = 1.5,\n\t\tmixVal = 0.9;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\n\t// 10: east globe\n\t// 13: front pyramid\n\telse if ( objNum == 10 || objNum == 13 )\n\t{\n\t\ttexNum = 19;\n\t\tobjClr = vec4( 0.0, 0.15, 1.0, 1.0 );\n\t\tscale = 2.0;\n\t\tcomplexity = 1.5,\n\t\tmixVal = 0.9;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                  objClr, mixVal ).xyz;\t\t\n\t} \n\t\n\treturn base_color;\n}\n\n// end applyTexture()\n\n//------------------------------------------------------------------------------\n\n// SKY COLOR\n// ---------\n// https://www.shadertoy.com/view/lll3z4\n// Gardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n/*\n * Gardner Cos Clouds\n *\n * Translated/adapted from the RenderMan implementation in\n * Texturing & Modeling; a Procedural Approach (3rd ed, p. 50)\n */\n \nvec3 skyColor( vec2 pix )\n{\t\n\tfloat zoom = 1.0,\n          cloudDensity = 0.0,\n          amplitude = 0.45,\n          xphase = 0.9 * iTime,\n          yphase = 0.7,\n          xfreq = 2.0 * PI * 0.023,\n          yfreq = 2.0 * PI * 0.021,\n    \n          offset = 0.5,\n          xoffset = 37.0,\n          yoffzet = 523.0,\n    \n          x = pix.x,\n          y = pix.y,\n\t      scale = 1.0 / iResolution.x * 60.0 * 1.0 / zoom;\n\n    x = x * scale + offset + iTime * 1.5;\n    y = y * scale + offset - iTime / 2.3;\n    \n    for ( int i = 0; i < nTerms; i++ )\n    {\n        float fx = amplitude * ( offset + cos( xfreq * ( x + xphase ) ) );\n        float fy = amplitude * ( offset + cos( yfreq * ( y + yphase ) ) );\n        cloudDensity += fx * fy;\n        xphase = PI * 0.5 * 0.9 * cos( yfreq * y );\n        yphase = PI * 0.5 * 1.1 * cos( xfreq * x );\n        amplitude *= 0.602;\n        xfreq *= 1.9 + float( i ) * .01;\n        yfreq *= 2.2 - float( i ) * 0.08;\n    }\n\n    //return mix( vec3(0.5, 0.55, 0.96 ), vec3( 1.0 ), cloudDensity );   \n    return mix( vec3(0.6, 0.66, 0.96 ), vec3( 1.0 ), cloudDensity * 4.0 );   \n\n}\n\n// end skyColor()\n\n//------------------------------------------------------------------------------\n\n// DEBUG PLANE\n// ===========\n \nvec4 debug_plane( vec3 rayOrig, vec3 rayDir, float cut_plane, \n                                                        inout float rayLength )\n{\n    if ( rayOrig.y > cut_plane && rayDir.y < 0.0 ) \n    {   \t\n        float d = ( rayOrig.y - cut_plane ) / -rayDir.y;\n        \n        if ( d < rayLength ) \n        {\n            vec3 hit = rayOrig + rayDir * d;\n            \n            float hit_dist = scene( hit ).s,\n                  contourSpacing = 10.0,\n\t\t\t      whole_iso = hit_dist * contourSpacing,           \n                  iso = fract( whole_iso ),                                   \n\t\t\t      markedContour = 5.0,\t\t\t\n\t\t\t\t  modContour = mod( whole_iso, markedContour );\n            \n            vec3 dist_color = mix( vec3( 0.3, 0.5, 0.7 ), \n                                   vec3( 0.3, 0.3, 0.5 ), iso );\n\t\t\t\t\n\t\t\tif ( modContour >= markedContour - 1.0 && \n\t\t\t     modContour <  markedContour )\n\t\t\t{\n\t            dist_color = mix( vec3( 0.1, 0.3, 0.6 ), \n\t                              vec3( 0.1, 0.1, 0.4 ), iso );\n\t\t\t}\n           \t           \t \n            dist_color *= 1.0 / ( max( 0.0, hit_dist ) + 0.001 );\n            rayLength = d;\n                     \n            return vec4( dist_color, 0.1 );\n       }\n    }\n    \n    return vec4( 0.0 );\n}\n\n// end debug_plane()\n\n//------------------------------------------------------------------------------\n\n// SHADE\n// -----\n \nvec3 shade( vec3 rayOrig, vec3 rayDir, vec3 lightDir, vec4 hit, vec2 curPix )                                                                 \n{\n\tvec3 fogColor = skyColor( curPix ) + vec3( 0.33, 0.66, 0.8 );\n\t\n\tfloat rayLength = 0.0;\n\tvec3 color = vec3( 0.0 );\n\t\n\tif ( hit.w == 0.0 ) \n\t{\n\t\trayLength = 1e16;\n\t\tcolor = fogColor;\n\t} \n\telse \n\t{\n\t\tvec3 dir = hit.xyz - rayOrig;\n\t\tvec3 surfNormal = getNormal(hit.xyz);\n\t\trayLength = length(dir);\n\t\t\n\t\t// Texture\n\t\t// -------\n\t\tvec3 base_color = applyTexture( hit );\n\t\tfloat diffuse = max( 0.0, dot( surfNormal, lightDir ) );\n\t\tfloat spec = max( 0.0, dot( reflect( lightDir, surfNormal ), \n\t\t                                                  normalize( dir ) ) );\n\t\tspec = pow( spec, 16.0 ) * 0.5;\n\t\tvec3 ambient = vec3( 0.1 );\n\t\tvec3 white = vec3( 1.0 );\n\t\tcolor = mix( ambient, white, diffuse ) * base_color + spec * white;\n\t\t                             \t\t\n\t\tfloat fog_dist = rayLength;\n\t\tfloat fog = 1.0 - 1.0 / exp( fog_dist * fog_density );\n\t\tcolor = mix( color, fogColor, fog );\n\t\n\t} // end else( hit.w != 0 )\n\t\n\t//------------------------------------------------------------\n\t// Debug Plane\n\t// -----------\n\tfloat planeY = -2.0,\t\t\n\t      mixVal = 0.75;\n\t\n\tvec4 dpcol = debug_plane( rayOrig, rayDir, planeY, rayLength );\n\tcolor = mix( color, dpcol.xyz, mixVal );\n\t\t\t\n\treturn color;\n}\n\n// end shade()\n\n//------------------------------------------------------------------------------\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// For Gardner Cos Clouds skyColor()\n\tvec2 st = fragCoord.xy;\n\tst.x *= 0.4;\n\tst.y *= 1.5;\n\n\tvec2 uv = ( fragCoord.xy - iResolution.xy * 0.5 ) / iResolution.y;\n\t\n\tmat4 cam_mat = createCamRotMatrix();\n\tvec3 camPos = vec3( cam_mat * vec4( 0.0, 0.0, -cam_dist, 1.0 ) );\t\n\tvec3 rayDir = normalize( vec3( cam_mat * vec4( uv, 1.0, 1.0 ) ) );\n\tvec3 lightDir = normalize( vec3( 0.5, 1.0, -0.25 ) );\t\n\tvec4 hit = raymarch( camPos, rayDir );\n\tvec3 color = shade( camPos, rayDir, lightDir, hit, st );\t\t                                                                      \t\n\tcolor = pow( color, vec3( 0.3 ) );\n\tfragColor = vec4( color, 1.0 );\t\n}\n\n//------------------------------------------------------------------------------\n\n// This section is excerpted from:\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define saturate(x) clamp(x, 0., 1.)\n\n// Maximum/minumum elements of a vector\n float vmax(vec2 v){\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat d = min(a, b);\n\tvec2 p = vec2(a, b);\n\tpR45(p);\n\tp = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n\tp.x += 0.5*sqrt(2.)*r/n;\n\tfloat x = r*sqrt(2.)/n;\n\tpMod1(p.x, x);\n\td = min(d, p.y);\n\tpR45(p);\n\treturn min(d, vmax(p -vec2(0.5*r/n)));\n}\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\n//\n    // FOLLOWING CODE was OBTAINED FROM https://github.com/ashima/webgl-noise\n    // This is the code for 3D Perlin noise, using simplex method.\n    //\n    \n    //------------------------------- 3D Noise ------------------------------------------\n    \n    // Description : Array and textureless GLSL 2D/3D/4D simplex \n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    // \n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      { \n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n      \n      // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n      \n      // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n      \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n      \n      // Permutations\n        i = mod289(i); \n        vec4 p = permute( permute( permute( \n                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n      \n      // Gradients: 7x7 points over a square, mapped onto an octahedron.\n      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n      \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n      \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n      \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n      \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n      \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n      \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n      \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n      \n      //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n      \n      // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                      dot(p2,x2), dot(p3,x3) ) );\n      }\n    \n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n/*\n EXCERPTED FUNCTIONS that contained additional comments removed from the\n code above. Apologies if there are mistakes in my interpretations, or if some\n of the variable names are wrong; these comments were compiled from multiple\n older sources.\n \n//------------------------------------------------------------------------------\n// Function declarations allow function bodies to be placed below the position\n// in the program from which they're called.\n\n// This one's here because I ended up putting the IQ distance functions just\n// above it, because it was convenient while creating the scene.\nvec2 scene(vec3 p);\n\n// Functions from the Mercury SDF Library.\t\nvec2 pMirrorOctant (inout vec2 p, vec2 dist);\nfloat pMirror (inout float p, float dist);\nfloat pModPolar(inout vec2 p, float repetitions);\nfloat fSphere(vec3 p, float r);\nfloat fBox(vec3 p, vec3 b);\nfloat fCylinder(vec3 p, float r, float height);\nfloat fOpUnionColumns(float a, float b, float r, float n);\nfloat fOpUnionStairs(float a, float b, float r, float n);\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r);\nfloat fTorus(vec3 p, float smallRadius, float largeRadius);\n\n// From the Ashima Arts 3D Noise code.\nfloat snoise(vec3 v);\n\n//------------------------------------------------------------------------------\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\n// I changed the code the day after this was uploaded to add mouse camera control,\n// but Shadertoy insisted that the rotation around the x-axis should be opposite\n// what I describe below ( actually I was too lazy to figure out what else needed\n// to change to keep it the way it was ).\n// So now, when the mouse is at the top of the screen, the camera is looking up\n// from the bottom, and vice-versa. I also changed the y-axis rotation, so now\n// moving the mouse right rotates the scene to the right.\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n\t\n\t// Rotation around x-axis = approx. +/- eightTenthsPI = approx 288 degrees\n\t// ----------------------\n\t// Assuming mouse at horizontal screen center is non-rotated position, and\n\t// rotations are viewed looking along the positive y-axis, i.e., looking up\n\t// from below scene:\n\t// Mouse at left of screen = 180 degree counterclockwise rotation from\n\t// non-rotated position.\n\t// Mouse at right of screen = 180 degree clockwise rotation from non-rotated\n\t// position.\n\t\n\t// A distance from screen center is calculated in screen coordinates, and\n\t// scaled to radian rotation angle values. (mouse vals are in screen coords)\n\t\n\t// When mouse.x = 0, rot angle = 2.494\n\t// When mouse.x = 1919, rot angle = -2.4911   =   +/- 0.79PI\n\t\t\n    if( iMouse.z < 0.0 ) \n    {\n\t\t// Steady auto rotation around the y-axis.\n\t\tang = iTime * 0.2;\n    }\n    else\n    {\n    \tang = ( iMouse.x - iResolution.x * 0.5 ) * rotRange;\n    }\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n\t// Rotation around y-axis = approx +/- halfPI = approx 180 degrees\n\t// ----------------------\n\t// Mouse at top of screen = looking straight down negative y-axis from\n\t//                          above scene\n\t// Mouse at bottom of screen = looking straight up positive y-axis from\n\t//                          below scene\n\t\n\t// When mouse.y = 0 ( top of screen ), rotY = 1.566\n\t// When mouse.y = 1079 ( btm of screen ), rotY = -1.5631    = +/- 0.49PI\n\n\t// Auto rotation around the x-axis.\n\t// The value \"abs( 2.0 * fract( iTime ) - 1.0 )\" ranges from 1 to 0, then\n\t// *reverses* from 0 to 1. So it's a means to a steady value shuttling\n\t// between 1 -> 0 -> 1. \n\n\t// Multiplying by 1.5 allows the camera to go higher and lower above and\n\t// below the plane. The value range is now 1.5 -> 0 -> 1.5.\n\t// Subtracting -0.25 shifts the range to 1.25 to -0.25. This lets the camera\n\t// go higher above the plane, and not as low below the plane.\n\n    if ( iMouse.z < 0.0 )\n    {\n        ang = 1.5 * ( abs( 2.0 * fract( iTime * 0.01 ) - 1.0 ) - 0.25 );\n    }\n    else\n    {\n    \tang = ( iMouse.y - iResolution.y * 0.5 ) * rotRange; \n    }\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// http://raymarching.com/WebGL/WebGL_ShadowsReflections.htm\n\n// Source - Raymarching.com\n// Author - Gary \"Shane\" Warne\n// eMail - mail@Raymarching.com, mail@Labyrinth.com\n// Last update: 28th Aug, 2014\n\nvec3 getNormal( in vec3 p ) \n{\t\t\n\t// wjb: scene() now returns a vec2( dist, objID ), so reference only the\n\t// first component. ( modified from original which returned a float distance\n\t// only.\n\t\n\t// The remainder are Shane's comments.\n*/\n/*\n\t// 6-tap normalization. Probably the most accurate, but a bit of a cycle \n\t// waster.\n\treturn normalize( vec3(\n\tscene( vec3( p.x + eps, p.y, p.z ) ) - \n\t                                    scene( vec3( p.x - eps, p.y, p.z ) ).s,\n\tscene( vec3( p.x, p.y + eps, p.z ) ) - \n\t                                    scene( vec3( p.x, p.y - eps, p.z ) ).s,\n\tscene( vec3( p.x, p.y, p.z + eps ) ) - \n\t                                    scene( vec3( p.x, p.y, p.z - eps ) ).s\n\t));\n*/\n/*\n// Shorthand version of the above. \n\tvec2 e = vec2( eps, 0.0 );\n\treturn normalize( vec3( scene( p + e.xyy ).s - scene( p - e.xyy ).s, \n\t                        scene( p + e.yxy ).s - scene( p - e.yxy ).s, \n\t                        scene( p + e.yyx ).s - scene( p - e.yyx ).s ));\n\n\n\n// If speed is an issue, here's a slightly-less-accurate, 4-tap version.  \n// Visually speaking, it's virtually the same, so often this is the one I'll \n// use. However, if speed is really an issue, you could take away the \n// \"normalization\" step, then  divide by \"eps,\" but I'll usually avoid doing \n// that.\n*/\n/*    \n    float ref = scene( p );\n\treturn normalize( vec3( scene( vec3( p.x + eps, p.y, p.z ) ).s - ref,\n\t\t                    scene( vec3( p.x, p.y + eps, p.z ) ).s - ref,\n\t\t                    scene( vec3( p.x, p.y, p.z + eps ) ).s - ref ) ); \n\n*/\t\n/*\n// The tetrahedral version, which does involve fewer calculations, but doesn't \n// seem as accurate on some surfaces.\n\t\n\tvec2 e = vec2( -0.5 * eps, 0.5 * eps );   \n\treturn normalize( e.yxx * scene( p + e.yxx ).s + \n\t                  e.xxy * scene( p + e.xxy ).s + \n\t                  e.xyx * scene( p + e.xyx ).s +\n\t                  e.yyy * scene( p + e.yyy ).s ); \n*/\n/*\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// RAYMARCH\n// --------\n\nvec4 raymarch( vec3 rayOrig, vec3 rayDir )\n{\n   vec3 p = rayOrig;\n   vec2 nearest = vec2( 0.0 );\n   float rayLength = 0.0;\n   \n   for( int i = 0; i < iterations; ++i ) \n   {\n\t\t// Distance to the nearest object in scene.\n\t\tnearest = scene( p );\n\t\t\n\t\t// The first component of the vec2 contains the distance value.\n\t\tfloat dist = nearest.s;\n\t\t\n\t\t// Distance is within minimum range to be declared a hit.\n\t\tif ( dist < dist_eps ) \tbreak;\t\t\n\n\t\t// wjb : Distance is not within hit distance. If distance is greater \n\t\t// than back view plane, return background color, and ID 0.0.\n\t\tif ( rayLength > ray_max ) return vec4( 0.0 );\n\t\t\n\t\t// Distance indicates that neither an ojbect has been hit nor has \n\t\t// the back view plane been reached. Move current ray position along the\n\t\t// ray direction by distance, and continue marching.\n\t\tp += dist * rayDir;\n\n\t\t//Add distance to the ray length.\n\t\trayLength += dist;\n   }\n   \n   // A hit was declared. Return the current ray position, and the ID of\n   // the hit object\n   return vec4( p, nearest.t );\n}\n\n// end raymarch()\n\n//------------------------------------------------------------------------------\n\n// DEBUG PLANE\n// ===========\n * Draw a single debug plane. The original TestPortMercury code drew four\n * planes at varying heights.\n *\n * debug_plane() is called from the shade() function.\n *\n * 'rayOrig' is passed here unchanged from the call to shade() made from\n * main(). It represents the variable in main() : 'camPos', camera position.\n *\n * 'rayDir' is passed here unchanged from the call to shade() made from main().\n * It represents the variable 'rayDir' in main(), which is the normalized\n * concatenation of the current camera position with the up vector. 'rayDir'\n * represents a normalized step length along the ray from camera to object.\n *\n * 'cut_plane' represents the variable 'planeY' in the shade() function.\n * It's the y-position of the debug_plane(s) tested for here.\n *\n * 'rayLength' is the length of the ray measured from the camera to the hit \n * object position.\n \nvec4 debug_plane( vec3 rayOrig, vec3 rayDir, float cut_plane, \n                                                        inout float rayLength )\n{\n    // Test that the camera is above the cut_plane ( y-coord ) and that\n    // it's looking down the negative y-axis.\n    if ( rayOrig.y > cut_plane && rayDir.y < 0.0 ) \n    {   \t\n        // Since rayOrig.y must be above the cut_plane y position, the\n        // result of subtracting them must be a positive value. Dividing by\n        // the negative value of rayDir yields a ray step length oriented in\n        // the correct direction down the negative y-axis.\n        float d = ( rayOrig.y - cut_plane ) / -rayDir.y;\n               \n        // If d is >= the distance from the camera to a hit obect, there\n        // won't be any debug_plane in this case, return a vec4 debug plane\n        // color of 0.0.\n        if ( d < rayLength ) \n        {\n            // Otherwise, find out where the ray intersects the debug plane by\n            // starting at the camera and moving in the correct direction along\n            // the ray by the 'rayDir' step distance, d times.\n            vec3 hit = rayOrig + rayDir * d;\n            \n            // Send the vec3 representing the point where the ray hits the\n            // debug plane to the distance estimation function, which will \n            // return the distance to the nearest object.\n            float hit_dist = scene( hit ).s,\n            \n            // Spacing between debug plane contours can be adjusted here.\n            // Larger value = narrower contour spacing.\n                  contourSpacing = 10.0,\n\t\t\t      \n            // Calculate the non-fracted value of iso, for use in demarcating\n            // repeating distances in the contour colors.\n\t\t\t      whole_iso = hit_dist * contourSpacing,           \n                  iso = fract( whole_iso ),                                   \n\t\t\t      markedContour = 5.0,\t\t\t\n\t\t\t\t  modContour = mod( whole_iso, markedContour );\n            \n            // The contours are colored with a gradient created by mixing two\n            // colors, from the lighter top color, closer to the object, to the \n            // darker bottom color, farther from the object.\n            vec3 dist_color = mix( vec3( 0.3, 0.5, 0.7 ), \n                                   vec3( 0.3, 0.3, 0.5 ), iso );\n\t\t\t\t\n\t\t\t// Demarcate repeating distances from the objects\n\t\t\t// using a different color mix to represent the contour lines at\n\t\t\t// that repeated distance, i.e., make every fifth contour line a\n\t\t\t// different color.\n\t\t\tif ( modContour >= markedContour - 1.0 && \n\t\t\t     modContour <  markedContour )\n\t\t\t{\n\t\t\t\t// Create a gradient by mixing two colors, from the lighter\n\t            // top color, closer to the object, to the darker bottom \n\t            // color, farther from the object.\n\t            dist_color = mix( vec3( 0.1, 0.3, 0.6 ), \n\t                              vec3( 0.1, 0.1, 0.4 ), iso );\n\t\t\t}\n           \t           \t \n            dist_color *= 1.0 / ( max( 0.0, hit_dist ) + 0.001 );\n            rayLength = d;\n                     \n            return vec4( dist_color, 0.1 );\n       }\n    }\n    \n    return vec4( 0.0 );\n}\n\n// end debug_plane()\n\n//------------------------------------------------------------------------------\n\n// SHADE\n// -----\n * Called from main(), the returned vec3 is assigned to 'color'.\n * 'rayOrig' is 'camPos' in main() = current camera position\n * 'hit' is the vec4 returned from \"raymarch( pos, dir )\" in main()\n \nvec3 shade( vec3 rayOrig, vec3 rayDir, vec3 lightDir, vec4 hit, vec2 curPix )                                                                 \n{\n\tvec3 fogColor = skyColor( curPix ) + vec3( 0.33, 0.66, 0.8 );\n\t\n\tfloat rayLength = 0.0;\n\tvec3 color = vec3( 0.0 );\n\t\n\t// The raymarch() function is called in main() as the 4th argument to \n\t// shade(), and is represented here by the vec4 'hit'. The raymarch() \n\t// function returns a w-component value of 0.0 if the ray reaches the back \n\t// view plane without hitting an object.\n\tif ( hit.w == 0.0 ) \n\t{\n\t\trayLength = 1e16;\n\t\tcolor = fogColor;\n\t} \n\telse \n\t{\n\t\t// 'dir' is assigned the distance between the camera and the point\n\t\t// where an object was hit.\n\t\tvec3 dir = hit.xyz - rayOrig;\n\t\t\n\t\t// Calculate the surface normal at the hit-position of the hit object.\t  \n\t\tvec3 surfNormal = getNormal(hit.xyz);\n\t\t\n\t\trayLength = length(dir);\n\t\t\n\t\t// Texture\n\t\t// -------\n\t\tvec3 base_color = applyTexture( hit );\n\t\t\n\t\t// 'diffuse' is a non-negative value describing the angle between the  \n\t\t// hit object's normal and the direction from which the light is shining.\n\t\tfloat diffuse = max( 0.0, dot( surfNormal, lightDir ) );\n\t\t\n\t\t\n\t\t// Specular light:\n\t\t//----------------\n\t\t// reflect( lightDir, surfNormal ): reflect function returns a vector\n\t\t// that points in the direction of reflection. Two input parameters:\n\t\t// first, the incident vector, and second, the normal vector of the \n\t\t// reflecting surface.\n\t\t\n\t\t// The dot product returns the cosine of the angle between the two \n\t\t// normalized vectors ( reflection vector and ray direction vector ) \n\t\t// = a value between -1 and +1 \n\t\t\n\t\t// If this value is greater than 0, it's raised to a power, and results\n\t\t// in a value darker close to 0, and brighter as it approaches 1.\n\t\t// If the value is less than 0, it's clamped to 0.\n\t\tfloat spec = max( 0.0, dot( reflect( lightDir, surfNormal ), \n\t\t                                                  normalize( dir ) ) );\n\t\tspec = pow( spec, 16.0 ) * 0.5;\n\n\t\tvec3 ambient = vec3( 0.1 );\n\t\tvec3 white = vec3( 1.0 );\n\t\tcolor = mix( ambient, white, diffuse ) * base_color + spec * white;\n\t\t                             \t\t\n\t\tfloat fog_dist = rayLength;\n\t\tfloat fog = 1.0 - 1.0 / exp( fog_dist * fog_density );\n\t\tcolor = mix( color, fogColor, fog );\n\t\n\t} // end else( hit.w != 0 )\n\t\n\t//------------------------------------------------------------\n\t// Debug Plane\n\t// -----------\n\tfloat planeY = -2.0,\t\t\n\t      mixVal = 0.75;\n\t\n\tvec4 dpcol = debug_plane( rayOrig, rayDir, planeY, rayLength );\n\tcolor = mix( color, dpcol.xyz, mixVal );\n\t\t\t\n\treturn color;\n}\n\n// end shade()\n\n//------------------------------------------------------------------------------\n\n\n*/\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\n/* PROGRAM FLOW ANALYSIS \n * =====================\n\nmain()\n------\t\n\tStore a non-normalized, scaled screen coord for use in skyColor();\n\t\n\tAdjust aspect ratio, normalize coords, translate origin to screen cntr.\n\t\n\tCreate camera rotation matrices for rotation around the x and y axes.\n\tMultiply them together to create the camera rotation matrix.\n\t\n\tThe rotation range is defined by a float value, which, when multiplied by\n\tmouse position offset from screen center in world coordinates, creates a\n\trange for vert and horiz movement in radians angles.\n\t\n\tThe mouse manipulation of the camera has been replaced in this version with\n\tautomatic rotations around the x and y axes.\n\t\n\tcamPos is initialized as the original, static cam position multiplied by\n\tthe camera rotation matrix.\n\t\n\tlightDir is initialized.\n\t\n\tcolor is calculated.\n\t\n\traymarch() : the ray marching\t\n\t-------\n\t'dist' is assigned a value returned from \n\t\n\t\tscene(), which checks for the nearest object in the world by calling\t\t\n\t\t--------  the Mercury SDF Library functions or IQ functions for each \n\t\t          object, each of which returns a distance from the current ray \n\t\t          position. This is combined with an object ID and returned to\n\t\t          raymarch() as a vec2.\n\t\t\n\tA vec4 'hit' is returned to main(), containing the vec3 hit position, 'p'. \n\t// The w-component contains the ID of the object that was hit.\n\t\n\tshade() :\n\t-------\n\t\tsky_color() is combined with a vec3 ambient light value, and assigned to \n\t\t----------- 'fogColor'.\n\t\t             \t\t            \n\t\tThe w-component flag is checked. If the back plane was reached, the ray\n\t\tlength is set to a tiny value, and color is set to fog.\n\t\t\n\t\tIf an object was hit, the distance from ray origin to hit position is\n\t\tcalculated, and \n\t\t\n\t\tgetNormal() : the average normal vector in the hit position vicinity is\t\t\n\t\t---------   calculated\n\t\t\n\t\tbase_color is assigned a vec3 from\n\t\t\n\t\t\tapplyTexture(). The object ID number determines the values sent to\t\t\t\n\t\t\t--------------\n\t\t\t\n\t\t\t\tgetTexture(), which calculates the pixel color for the current\n\t\t\t\t------------  pixel.\n\t\t\t\t\n\t\tDiffuse light value is calculated as the dot product of the hit normal\n\t\tand the light direction.\n\t\t\n\t\tSpecular light value is calculated.\n\t\n\t\tcolor is calculated as a mix of the base_color, and the diffuse and\n\t\tspecular colors, and a calculated fog color.\n\t\n\t\tdebug_plane() : a dist_color is calculated based on the distance from\t\t\n\t\t-------------   the ray position to the debug plane.\n\t\n\t\tcolor is mixed with the debug plane color.\n\t\nmain()\n------\n\ncolor is modified ( brightened ) by an exponent, and assigned to gl_FragColor.\t\n\t\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2151, 2189, 2260, 2387, 2512], [2595, 2633, 2704, 2704, 2886], [3193, 3334, 3405, 3476, 3728], [3811, 3830, 3852, 4000, 12458], [12542, 12609, 12636, 12636, 13863], [14067, 14210, 14240, 14240, 14487], [14591, 14616, 14660, 14660, 15015], [15149, 15424, 15574, 15574, 16726], [16831, 16866, 16905, 16905, 20199], [20306, 20583, 20610, 20610, 21696], [21799, 21831, 21975, 21975, 23093], [23199, 23219, 23363, 23363, 24553], [24571, 24654, 24711, 24749, 25346], [26221, 26262, 26281, 26281, 26306], [26308, 26308, 26328, 26328, 26363], [26365, 26546, 26578, 26578, 26603], [26605, 26641, 26669, 26669, 26750], [26752, 26797, 26845, 26845, 26919], [26921, 27005, 27049, 27049, 27152], [27154, 27226, 27275, 27275, 27312], [27500, 27738, 27770, 27770, 27812], [27814, 27850, 27875, 27875, 27915], [27917, 28061, 28101, 28101, 28222], [28224, 28316, 28359, 28359, 28410], [28593, 28652, 28710, 28710, 28941], [29364, 29795, 29816, 29816, 29873], [29883, 29883, 29904, 29904, 29961], [29971, 29971, 29993, 29993, 30041], [30051, 30051, 30083, 30083, 30143], [30153, 30153, 30181, 30181, 32757]], "test": "untested"}
{"id": "ldV3zy", "name": "Some Numbers", "author": "samuelotherion", "description": "flying stop watch", "tags": ["time", "numbers", "bug", "date", "periodicboundaryconditions", "pbc"], "likes": 1, "viewed": 144, "published": "Public", "date": "1455380021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t     iTime\n#define RES   iResolution\n#define ASPXY RES.x / RES.y\n#define ASPYX RES.y / RES.x\n\nvec2\n    xy;\n\nconst vec4\n    fg = vec4( 1., .1, .0, 1. ),\n    bg = vec4( .6, .6, .3, 1. ),\n    c1 = vec4( 1., .9, .8, 1. ),\n    c2 = vec4( .1, .1, .1, 1. ),\n    c3 = vec4( .9, .9, .9, 1. ),\n    c4 = vec4( .6, .5, .4, 1. );\n\nint\n    n2s( int n ) {\n\n\t\t// using binary searching for getting number sprite\n        return \n        n < 8 \n\t\t\t? n < 4\n        \t\t? n < 2\n        \t\t\t? n < 1\n        \t\t\t\t? 0xE5294E\t//0\n        \t\t\t\t: 0x421084\t//1\n                    : n < 3\n                \t\t? 0x64104E\t//2\n                \t\t: 0xE4110E\t//3\n\t\t\t\t: n < 6\t\t\t\n\t\t\t\t\t? n < 5\n                \t\t? 0xA53908\t//4\n                    \t: 0xE1390E\t//5\n             \t\t: n < 7\n\t\t\t \t\t\t? 0xE1394E\t//6\n             \t\t\t: 0xE42108\t//7\n\t\t\t: n < 12\n                ? n < 10\n                \t? n < 9 \n                \t\t? 0xE5394E\t//8\n            \t\t\t: 0xE5390E\t//9\n\t\t\t\t\t: n < 11\n                        ? 0x123456\t//10\n                        : 0xABCDEF\t//11\n\t\t\t\t: n < 14\n                \t? n < 13\n                \t\t? 0xE5394E\t//12\n            \t\t\t: 0xE5390E\t//13\n\t\t\t\t\t: n < 15\n                        ? 0x123456\t//14\n                        : 0xABCDEF;\t//15\n\t}\n\nbool\n    rdrN( int n, vec2 p ) {\n        \n        n = n2s( n );\n        \n        int\n            j = int( 5. * p.x ) + 5 * int( 5. * p.y ),\n            f = 0x2000000;\n        \n        for( int i = 25; i >= 0; i-- ) {\n            \n            if( i == j )\n                \n                break; \n            \n            if( n >= f )\n                \n                n -= f;\n            \n            f /= 2;\n        }\n                \n        return f <= n;\n    }\n\nvec4\n    rdr( vec2 p, vec4 c, vec2 rd1, vec2 rd2 ) {\n        \n        vec2\n            rel = 2. * p - 1.,\n            rl2 = 5. * ( mod( rel + 1., .4 ) - .2 );\n        \n        rel = pow( abs( rel ), rd1 ),\n        rl2 = pow( abs( rl2 ), rd2 );\n\n        float\n            f  = pow( 1. - dot( rel, rel ), 1. / dot( rd1, rd1 ) ),\n            f2 = pow( 1. - dot( rl2, rl2 ), 1. / dot( rd2, rd2 ) );\n\n        return vec4( ( .1 < f + f2 ) ? .5 * ( f + f2 ) * c.rgb : bg.rgb, 1. );\n    }\n\nint\n    //digit of decimal number\n    dod( in int dgt, in int len, in int dN ) {\n        \n        dgt = len - dgt - 1;\n        \n        if( dgt < 0 )\n            \n            dgt = 0;\n        \n        for( int i = 0; i < 10; ++i ) {\n         \n            int\n                a = dN / 10,\n                b = dN - 10 * a;\n            \n            if( i == dgt ) \n                \n                return b;                \n            \n            dN = a;\n        }\n        \n        return 0;\n    }\n\nvec4\n    dec( int n, int d, vec2 p, vec2 r, vec4 _fg, vec4 _bg, vec2 rd1, vec2 rd2 ) {\n    \n        vec4\n            c = vec4( 0. );\n        \n        vec2\n            rel = xy - p;\n        \n        if( rel.x < 0. || float( d ) * r.x < rel.x || rel.y < 0. || r.y < rel.y )\n            \n            return c;      \n        \n        float\n            x = rel.x / r.x;\n            \n        int\n            di = int( x );\n        \n        if( d < di ) \n            \n            return c;\n        \n        rel.x = fract( x );\n        rel.y /= r.y;\n        \n        int\n            dig = dod( di, d, n );\n\n        return rdr( rel, rdrN( dig, rel ) ? _fg : _bg, rd1, rd2 );\n    }\n\nvoid\n    mainImage( out vec4 p_c, in vec2 p_xy ) {\n        \n\t\txy = ( 2. * p_xy / RES.xy - 1. ) * vec2( ASPXY, 1. );\n\n        p_c  = vec4( 0. );\n        \n        float\n            x = +mod( +.2 * t, 2. * ASPXY ) - ASPXY,\n            y = +mod( +.2 * t, 2. ) - 1.,\n            f = 9.8;\n        \n        vec2\n            ext = vec2( .375 + .125 * sin( t ),    .35 + .1   * sin( .4  * t ) ),\n            _10 = vec2( 10. ),\n            rd1 = _10 + f * vec2( sin( .3 * t ), sin( .31 * t ) ),\n            rd2 = _10 + f * vec2( sin( .2 * t ), sin( .23 * t ) ),\n            _15 = vec2( .15 );\n        \n        vec2\n            rp = vec2( x - 2. * ASPXY, y - 2. );\n        \n        for( int dy = -1; dy < 1; ++dy ) \n            \n\t        for( int dx = -1; dx < 1; ++dx ) \n                \n                p_c += dec( int( 100. * t ) , 8, vec2( x + 2. * float( dx ) * ASPXY, y + 2. * float( dy ) ), ext, bg, fg, rd1, rd2  );\n        \n        p_c += dec( int( mod( 100. * iDate.w, 100. ) ), 2, vec2( -1.5, -.75 ), vec2( 1.5 ), vec4( 1.25 * bg.rgb, 1. ), bg, vec2( 20. ) + 19. * vec2( sin( .4 * t ) ), vec2( 20. ) + 19. * vec2( sin( .23 * t ) ) );\n\n        p_c += dec( int( iDate.x      ), 4, vec2( +ASPXY -  .82, +.77 ), vec2( .2 ), c2, c3, _10 + f * vec2( sin( .4  * t ), sin( .31 * t ) ), rd1 );\n        p_c += dec( int( iDate.y + 1. ), 2, vec2( +ASPXY - 1.04, +.88 ), vec2( .1 ), c2, c3, _10 + f * vec2( sin( .41 * t ), sin( .31 * t ) ), rd1 );\n        p_c += dec( int( iDate.z      ), 2, vec2( +ASPXY - 1.04, +.76 ), vec2( .1 ), c2, c3, _10 + f * vec2( sin( .42 * t ), sin( .31 * t ) ), rd1 );\n          \n        p_c += dec( int( mod( iDate.w / 3600., 24. ) ), 2, vec2( -ASPXY + .02, .83 ), _15, c3, c2, _10 + f * vec2( sin( .6  * t ), sin( .61 * t ) ), rd2 );\n        p_c += dec( int( mod( iDate.w / 60.,   60. ) ), 2, vec2( -ASPXY + .34, .83 ), _15, c3, c2, _10 + f * vec2( sin( .50 * t ), sin( .51 * t ) ), rd2 );\n        p_c += dec( int( mod( iDate.w,         60. ) ), 2, vec2( -ASPXY + .66, .83 ), _15, c3, c2, _10 + f * vec2( sin( .41 * t ), sin( .41 * t ) ), rd2 );\n\n        rd1 = vec2( 9.5 + .5 * sin( .1 * t ) );\n        p_c += dec(  1234, 5, vec2( -.85, -.96 ), _15, c4, c1, rd1, rd2 );\n        p_c += dec( 56789, 5, vec2(  .1,  -.96 ), _15, c1, c4, rd2, rd1 );\n        \n        if( p_c.a < 1. )\n            \n            p_c = bg;\n        \n        else\n            \n            p_c.rgb /= p_c.a;\n        \n        p_c.rgb = mix( p_c.rgb, texture( iChannel0, ( 5.8 + 5. * .1 * floor( 10. * cos( .03 * t ) ) ) * xy ).rgb, .2 );\n    }", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldV3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 327, 349, 404, 1226], [1228, 1228, 1260, 1260, 1691], [1693, 1693, 1745, 1745, 2173], [2175, 2175, 2255, 2255, 2671], [2673, 2673, 2759, 2759, 3344], [3346, 3346, 3396, 3396, 5877]], "test": "untested"}
{"id": "ldVGRV", "name": "Signed distance field blobbies", "author": "verminator04", "description": "Signed distance fields demo with metaballs (Blinn (1982))", "tags": ["sdf", "metaballs", "signeddistancefield", "blobbymodel", "blobbies"], "likes": 43, "viewed": 3894, "published": "Public", "date": "1455458859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int renderDepth = 400;\nconst bool showRenderDepth = false;\n\nconst vec3 background = vec3(0.2, 0.2, 0.8);\nconst vec3 white = vec3(0.8, 0.8, 0.8);\nconst vec3 black = vec3(0, 0, 0);\nconst vec3 red = vec3(0.8, 0.2, 0.2);\nconst vec3 green = vec3(0.2, 0.8, 0.2);\nconst vec3 lightPos = vec3(0, 10, 10);\n\nconst float a = 1.0;\nconst float b = 3.0;\nvec3 forces[3];\n\n\nvec3 getRayDir(vec3 camDir, vec2 fragCoord) {\n  vec3 yAxis = vec3(0, 1, 0);\n  vec3 xAxis = normalize(cross(camDir, yAxis));\n  vec2 q = fragCoord / iResolution.xy;\n  vec2 p = 2.0 * q - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n  return normalize(p.x * xAxis + p.y * yAxis + 5.0 * camDir);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.1;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat getMetaball(vec3 p, vec3 v) {\n  float r = length(p - v);\n  if (r < b / 3.0) {\n    return a * (1.0 - 3.0 * r * r / b * b);\n  } else if (r < b) {\n    return (3.0 * a / 2.0) * (1.0 - r / b) * (1.0 - r / b);\n  } else {\n    return 0.0;\n  }\n}\n\nfloat sdImplicitSurface(vec3 p) {\n  float mb = 0.0;\n  float minDist = 10000.0;\n  for (int i = 0; i < 3; i++) {\n    mb += getMetaball(p, forces[i]);\n    minDist = min(minDist, length(p - forces[i]));\n  }\n  if (minDist > b) {\n    return max (minDist - b, b - 1.2679529);\n  } else if (mb == 0.0) {\n    return b - 1.2679529;  // 1.2679529 is the x-intercept of the metaball expression - 0.5.\n  } else {\n    return b - sqrt(6.0 * mb) - 1.2679529;\n  }\n}\n\nfloat getSdf(vec3 p) {\n  float f = sdImplicitSurface(p);\n  for (int i = 0; i < 6; i++) {\n    float t = float(i) + iTime;\n    f = min(f, sdBox(\n        p - vec3(\n            3.0 + 3.0 * cos(t * 3.141592 / 3.0), \n            0, \n            3.0 * sin(t * 3.141592 / 3.0)),\n        vec3(0.5)));\n  }\n  return f;\n}\n\nfloat getSdfWithPlane(vec3 p) {\n  return min(getSdf(p), sdPlane(p, vec4(0,1,0,1)));\n}\n\nfloat diffuse(vec3 point,vec3 normal) {\n  return clamp(dot(normal, normalize(lightPos - point)), 0.0, 1.0);\n}\n\nfloat getShadow(vec3 pt) {\n  vec3 lightDir = normalize(lightPos - pt);\n  float kd = 1.0;\n  int step = 0;\n  float t = 0.1;\n\n  for (int step = 0; step < renderDepth; step++) {\n    float d = getSdf(pt + t * lightDir);\n    if (d < 0.001) {\n      kd = 0.0;\n    } else {\n      kd = min(kd, 16.0 * d / t);\n    }\n    t += d;\n    if (t > length(lightPos - pt) || step >= renderDepth || kd < 0.001) {\n      break;\n    }\n  }\n  return kd;\n}\n\nvec3 getGradient(vec3 pt) {\n  return vec3(\n    getSdfWithPlane(vec3(pt.x + 0.0001, pt.y, pt.z)) - getSdfWithPlane(vec3(pt.x - 0.0001, pt.y, pt.z)),\n    getSdfWithPlane(vec3(pt.x, pt.y + 0.0001, pt.z)) - getSdfWithPlane(vec3(pt.x, pt.y - 0.0001, pt.z)),\n    getSdfWithPlane(vec3(pt.x, pt.y, pt.z + 0.0001)) - getSdfWithPlane(vec3(pt.x, pt.y, pt.z - 0.0001)));\n}\n\nvec3 getDistanceColor(vec3 pt) {\n  float d = getSdf(pt);\n  vec3 color = mix(red, green, 0.5 + 0.5 * sin(d * 3.141592));\n  if (fract(d) < 0.05) {\n    color = mix(color, black, smoothstep(0.0, 0.05, fract(d)));\n  } else if (fract(d) < 0.1) {\n    color = mix(black, color, smoothstep(0.05, 0.1, fract(d)));\n  }\n  return color;\n}\n\nvec3 illuminate(vec3 pt) {\n  vec3 color = (abs(pt.y + 1.0) < 0.001) ? getDistanceColor(pt) : white;\n  vec3 gradient = getGradient(pt);\n  float diff = diffuse(pt.xyz, normalize(gradient));\n  return (0.25 + diff * getShadow(pt))  * color;\n}\n\nvec3 raymarch(vec3 rayorig, vec3 raydir) {\n  vec3 pos = rayorig;\n  float d = getSdfWithPlane(pos);\n  int work = 0;\n\n  for (int step = 0; step < renderDepth; step++) {\n    work++;\n    pos = pos + raydir * d;\n    d = getSdfWithPlane(pos);\n    if (abs(d) < 0.001) {\n      break;\n    }\n  }\n\n  return showRenderDepth\n    ? vec3(float(work) / float(renderDepth))\n    : (abs(d) < 0.001) \n      ? illuminate(pos)\n      : background;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  forces[0] = vec3(-3, 0, 0);\n  forces[1] = vec3(3.0 * sin(iTime), 4.0 * abs(cos(iTime)), 0.0);\n  forces[2] = vec3(3, 0, 0);\n\n  vec3 camPos = 20.0 * vec3(cos(iTime / 10.0), 0.5, sin(iTime / 10.0));\n  vec3 camDir = normalize(-camPos);\n  fragColor = vec4(raymarch(camPos, getRayDir(camDir, fragCoord)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[363, 363, 408, 408, 655], [657, 727, 756, 756, 853], [855, 855, 886, 886, 917], [919, 919, 954, 954, 1161], [1163, 1163, 1196, 1196, 1610], [1612, 1612, 1634, 1634, 1921], [1923, 1923, 1954, 1954, 2008], [2010, 2010, 2049, 2049, 2119], [2121, 2121, 2147, 2147, 2549], [2551, 2551, 2578, 2578, 2911], [2913, 2913, 2945, 2945, 3238], [3240, 3240, 3266, 3266, 3478], [3480, 3480, 3522, 3522, 3906], [3908, 3908, 3965, 3965, 4274]], "test": "untested"}
{"id": "ldy3WG", "name": "Inside a Prism", "author": "piratehurrdurr", "description": "Something more trippy. Enjoy!", "tags": ["3d", "colorful", "trippy"], "likes": 12, "viewed": 484, "published": "Public", "date": "1456111799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IT 256\n#define ITF float(IT)\n#define STR 1.5/sqrt(ITF)\n#define A 1.0\n\n#define M_PI 3.14159254\n\nvec3 colorFilter(vec3 c) {\n    vec3 color;\n    \n    float g = (c.r+c.g+c.b)/3.0;\n    float s = abs(c.r-g)+abs(c.g-g)+abs(c.b-g);\n    \n    color = c*s+(1.0-s)*(c-s);\n    \n    return color*color;\n}\n\nvec3 value(vec3 pos) {\n    vec3 color;\n    \n    color.r = sin(pos.x);\n    color.g = sin(pos.y);\n    color.b = sin(pos.z);\n    \n    return color;\n}\n\nvec3 scan(vec3 pos, vec3 dir){\n    vec3 c = vec3(0.5);\n    for (int i=0; i<IT; i++) {\n        float f = (1.0- float(i)/ITF)*STR;\n        \n        vec3 posMod = value(pos);\n        vec3 newPos;\n        newPos.x = posMod.y*posMod.z;\n        newPos.y = posMod.x*posMod.z;\n        newPos.z = posMod.x*posMod.y;\n        \n        c+=value(pos+newPos*4.0)*f;\n        pos+=dir*2.0;\n    }\n    return colorFilter(c);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 uv){\n    uv = (uv-iResolution.xy/2.0)/iResolution.y;\n    float a = iTime*0.125;\n    \n    vec3 pos = vec3(cos(a/4.0+sin(a/2.0)),cos(a*0.2),sin(a*0.31)/4.5)*16.0;\n    vec3 on = vec3(1.0,uv.x,uv.y);\n    vec3 n;\n\n    n = normalize(pos + vec3(cos(a*2.3),cos(a*2.61),cos(a*1.62)));\n\tvec3 crossRight = normalize( cross(n,vec3(0.0,0.0,1.0)));\n\tvec3 crossUp = normalize(cross(n, crossRight));\n\tn = n*1.5 + crossRight*uv.x + crossUp*uv.y;\n    \n    fragColor.rgb = scan(pos,normalize(n)).rgb;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldy3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 129, 129, 298], [300, 300, 322, 322, 446], [448, 448, 478, 478, 856], [858, 858, 904, 904, 1383]], "test": "untested"}
{"id": "ldy3zc", "name": "WTH-Fractal", "author": "tayholliday", "description": "Raymarching of a fractal.", "tags": ["3d", "fractal", "raymarch", "volumetric"], "likes": 11, "viewed": 382, "published": "Public", "date": "1455593124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// A simple fractal.\n// From https://www.shadertoy.com/view/MslGWN\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nconst float mindist = 1.0;\nconst float maxdist = 4.0;\n\nfloat map2( vec3 p ) {\n \n    float t = field(p,.5);\n    \n    return t;\n}\n\n// From https://www.shadertoy.com/view/MtX3Ws\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\n{\n    float t = tminmax.x;\n    //float d2 = .02\n    float dt = .2 * sin(iTime*.1);\n    //float dt = .2 - .195*cos(iTime*.05);//animated\n    vec3 col= vec3(0.);\n    float c = 0.;\n    for( int i=0; i<10; i++ )\n\t{\n        t+=dt*exp(-2.*c);\n        if(t>tminmax.y)break;\n        \n        c = map2(ro+t*rd);               \n        \n        //col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\n        col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\n    }    \n    return col;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    return raymarch(ro, rd, vec2(mindist, maxdist));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    vec2  p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n\n    vec3  ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n    vec3  ta = vec3(-0.6,0.2,0.0);\n    mat3  ca = setCamera( ro, ta, 0.0 );\n    vec3  rd = normalize( ca * vec3(p,-2.8) );\n\n    vec3 col = render( ro, rd );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldy3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 68, 100, 100, 487], [544, 544, 566, 566, 616], [618, 664, 716, 716, 1181], [1183, 1183, 1222, 1222, 1277], [1279, 1279, 1334, 1334, 1512], [1514, 1514, 1571, 1571, 2043]], "test": "untested"}
{"id": "ldyGDG", "name": "incubator", "author": "orangish", "description": "This is my first 3D shader", "tags": ["3dtest"], "likes": 2, "viewed": 87, "published": "Public", "date": "1456126064", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is a test shader based on the demo shader by inigo quilez. Mod by Zina.\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Demo created by inigo quilez - iq/2013 (see original here):\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos ) {\n   \n    pos = opRep(pos, vec3(1.0 + 0.1 * sin(iTime), 2.0, 2.5 + 0.1 * sin(iTime)));\n    //float displace = opDisplace(pos);\n    //float cone = sdCone(pos, vec3(2.0, 1.0, 1.0));\n    float ellipsoid = sdEllipsoid(pos, vec3(0.2, 0.2 + 0.1 * sin(iTime * 4.0), 0.2));\n    \n    float torus = sdTorus(pos, vec2(2.0, 1.0));\n    float plane = pos.y;\n    //float d = sin(pos.x);\n    //float d = 1.0 - pos.x * pos.y;\n    float sphere = length(pos) - 1.0;\n    float d = max(plane, torus);\n    d = min(d, ellipsoid);\n    return(vec2(d, 1.0));\n    \n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyGDG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[169, 323, 348, 348, 363], [365, 365, 400, 400, 426], [428, 428, 459, 459, 546], [548, 548, 591, 591, 651], [653, 653, 698, 698, 738], [740, 740, 773, 773, 826], [828, 828, 864, 864, 1106], [1108, 1108, 1160, 1160, 1274], [1276, 1276, 1312, 1312, 1560], [1562, 1562, 1598, 1598, 1697], [1699, 1699, 1737, 1737, 1906], [1908, 1908, 1980, 1980, 2195], [2198, 2198, 2223, 2223, 2260], [2262, 2262, 2287, 2287, 2345], [2347, 2347, 2372, 2372, 2437], [2439, 2439, 2474, 2474, 2541], [2543, 2543, 2578, 2578, 2645], [2647, 2647, 2684, 2684, 2735], [2737, 2811, 2844, 2844, 2870], [2872, 2872, 2902, 2902, 2935], [2937, 2937, 2967, 2967, 2996], [2998, 2998, 3022, 3022, 3154], [3156, 3230, 3255, 3255, 3793], [3795, 3795, 3835, 3835, 4425], [4428, 4428, 4502, 4502, 4763], [4765, 4765, 4797, 4797, 5018], [5020, 5020, 5062, 5062, 5361], [5366, 5366, 5405, 5405, 6976], [6978, 6978, 7030, 7030, 7207], [7209, 7209, 7266, 7266, 7860]], "test": "untested"}
{"id": "ldyGWm", "name": "Menger Sponge Variation", "author": "Shane", "description": "Simple fractal object, constructed with mild alterations to the standard repeat Menger Sponge formula.", "tags": ["raymarching", "fractal", "menger", "reflections", "wood", "sponge"], "likes": 119, "viewed": 7135, "published": "Public API", "date": "1455023071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Menger Sponge Variation\n    -----------------------\n\n\tI got bored and dusted off some old Menger Sponge related code. There's a lot of \n\texamples on this site, so I'm not bringing anything new to the table. This particular\n\tobject was constructed via a slight variation on the formula.\n\n\tThe lighting was made up as I went along, so I wouldn't pay too much attention to it. \n\tHowever, the cheap reflections might be worth looking at.\n\n\tFor anyone who's never put a Menger Sponge together, here's a very, very short, overly \n\tgeneralized explanation:\n\t\n\tConstruct a Void Cube (or repeat Void Cubes, as the case may be), which is analogous \n\tto a Rubix Cube with the center mechanism removed. Create Void Cubes from the 20 cubies \n\t(the remaining\tsmaller cubes), and continue to iterate ad infinitum.\n\t\n\tIn code:\n\n\t// Repeat Void Cubes - A Void Cube is a Level-1 Menger Sponge.\n\tfloat map(vec3 p){\n    \tp = abs(mod(p, 3.) - 1.5); // Repeat space.\n    \treturn min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.; // Void Cube.\n\t}\n\n\t// More than one level Menger Sponge - Infinitely repeated, in this case.\n\tfloat map(vec3 q){\n        \n\t\tvec3 p; float d = 0.;\n        \n        // One Void Cube.\n    \tp = abs(mod(q, 3.) - 1.5);\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.);\n\n        // Subdividing into more Void Cubes.    \n    \tp = abs(mod(q, 1.) - 0.5); // Dividing above by 3.\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3.);\n        \n        // And so on.\n    \tp = abs(mod(q, 1./3.) - 0.5/3.); // Dividing above by 3.\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3./3.);\n        \n\t\t// Continue on in this manner. For more levels, you'll want to loop it. There's\n\t\t// a commented out example in the code somewhere. Also, you can experiment with \n\t\t// the code to create more interesting variants.\n\n\t\treturn d;\n\t}\n\t\n\tFor a more formal explanation, look up \"Menger Sponge,\" \"Cantor Sets,\" \"Void Cube,\" \n\tetc., on the web, or better yet, refer to the countless Menger Sponge examples\n\ton this site.\t\n\n\tExamples:\n\n\tMenger Journey - Syntopia (A favorite of mine, and everyone else.)\n\thttps://www.shadertoy.com/view/Mdf3z7\n\n*/\n\n#define FAR 40.\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, 0.001); // n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n \n    \n}\n\n// Smooth minimum function. There are countless articles, but IQ explains it best here:\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat sminP( float a, float b, float smoothing ){\n\n    float h = clamp( 0.5+0.5*(b-a)/smoothing, 0.0, 1.0 );\n    return mix( b, a, h ) - smoothing*h*(1.0-h);\n}\n\n\n/*\n// Regular Menger Sponge formula. Very simple, but if you're not sure, look it\n// up on Wikipedia, and look up a Void Cube image.\nfloat map(vec3 q){\n    \n    vec3 p;\n\t// Scale factor, and distance.\n    float s = 3., d = 0.;\n    \n    for(int i=0; i<3; i++){\n \t\t// Repeat space.\n        p = abs(fract(q/s)*s - s/2.); // Equivalent to: p = abs(mod(q, s) - s/2.);\n\t\t// Repeat Void Cubes. Cubes with a cross taken out.\n \t\td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.);\n    \ts /= 3.; // Divide space (each dimension) by 3.\n    }\n \n \treturn d;    \n}\n*/\n\n// Variation on a Menger Sponge (See the formula above). This one has four layers. The \n// easiest way to understand this is to comment out layers, then add them back in to \n// see what each does.\nfloat map(vec3 q){\n    \n    // Layer one. The \".05\" on the end varies the hole size.\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .05;\n    \n    // Layer two.\n    p =  abs(fract(q) - .5);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\n   \n    // Layer three. 3D space is divided by two, instead of three, to give some variance.\n    p =  abs(fract(q*2.)*.5 - .25);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015); \n\n    // Layer four. The little holes, for fine detailing.\n    p =  abs(fract(q*3./.5)*.5/3. - .5/6.);\n \treturn max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\n    //return max(d, max(max(p.x, p.y), p.z) - 1./18. - .024);\n    //return max(d, length(p) - 1./18. - .048);\n    \n    //p =  abs(fract(q*3.)/3. - .5/3.);\n \t//return max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./9. - .04);\n}\n\n\n\n// Very basic raymarching equation. Menger Sponge objects raymarch reasonably well. Not all surfaces do.\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    for(int i=0; i< 64; i++){        \n        d = map(ro + rd*t);\n        if (d <.0025*t || t>FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n// The reflections are pretty subtle, so not much effort is being put into them. Only a few iterations.\nfloat refTrace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for(int i=0; i< 16; i++){\n        d = map(ro + rd*t);\n        if (d <.0025*t || t>FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO(in vec3 p, in vec3 n){\n    \n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.;\n    \n    const float maxDist = 1.;\n    for(float i=1.; i<nbIte+.5; i++){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 16; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.02, 0.25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.5, 1.0); \n}\n\n/*\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// It gives you a scalar curvature value for an object's signed distance function, which \n// is pretty handy for all kinds of things. Here's it's used to darken the crevices.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n// calculations, I'm assuming. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p){\n\n    //const float eps = 0.05, amp = 4.0, ampInit = 0.5;\n    const float eps = 0.15, amp = 2.5, ampInit = 0.0;\n\n    vec2 e = vec2(-1., 1.)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit direction ray vector: Note the absence of a divide term. I came across this via a comment \n    // Shadertoy user \"Coyote\" made. I'm pretty happy with this.\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y)); // Normalizing below.\n    \n    // Barrel distortion. Looks interesting, but I like it because it fits more of the scene in.\n    // If you comment this out, make sure you normalize the line above.\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\n    \n    // Rotating the ray with Fabrice's cost cuttting matrix. I'm still pretty happy with this also. :)\n    vec2 m = sin(vec2(0, 1.57079632) + iTime/4.);\n    rd.xy = mat2(m.y, -m.x, m)*rd.xy;\n    rd.xz = mat2(m.y, -m.x, m)*rd.xz;\n    \n    \n    // Ray origin, set off in the Z direction.\n    vec3 ro = vec3(0.0, 0.0, iTime);\n    vec3 lp = ro  + vec3(0.0, 1.0, 0.0); // Light, near the ray origin.\n    \n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n    \n    float t = trace(ro, rd); // Raymarch.\n    \n    // Scene hit, so do some lighting.\n    if(t<FAR){\n    \n        vec3 sp = ro + rd*t; // Surface position.\n        vec3 sn = normal(sp); // Surface normal.\n        vec3 ref = reflect(rd, sn); // Reflected ray.\n\n\t\tconst float ts = 2.; // Texture scale.\n        vec3 oCol = tex3D(iChannel0, sp*ts, sn); // Texture color at the surface point.\n        \n \t\t\n        // Darker toned wood paneling. Very fancy. :)\n        vec3 q = abs(mod(sp, 3.) - 1.5);\n        if (max(max(q.x, q.y), q.z) < 1.063) oCol = oCol*vec3(.7, .85, 1.); \n\n        // Bringing out the texture colors a bit.\n        oCol = smoothstep(0.0, 1.0, oCol);\n \n        float sh = softShadow(sp, lp, 16.); // Soft shadows.\n        float ao = calculateAO(sp, sn); // Self shadows.\n\n        vec3 ld = lp - sp; // Light direction.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light direction vector.\n\n        float diff = max(dot(ld, sn), 0.); // Diffuse component.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 12.); // Specular.\n        //float fres = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n\n        float atten = 1.0 / (1.0 + lDist*0.25 + lDist*lDist*.1); // Attenuation.\n        \n        \n        // Secondary camera light, just to light up the dark areas a bit more. It's here just\n        // to add a bit of ambience, and its effects are subtle, so its attenuation \n        // will be rolled into the attenuation above.\n        diff += max(dot(-rd, sn), 0.)*.45;\n        spec += pow(max(dot(reflect(rd, sn), -rd), 0.), 12.)*.45;\n        \n        // Based on Eiffie's suggestion. It's an improvement, but I've commented out, \n        // for the time being.\n        //spec *= curve(sp); \n\n\n\t\t// REFLECTION BLOCK.\n        //\n        // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much \n        // effort is being put in.\n        float rt = refTrace(sp + ref*0.1, ref); // Raymarch from \"sp\" in the reflected direction.\n        vec3 rsp = sp + ref*rt; // Reflected surface hit point.\n        vec3 rsn = normal(rsp); // Normal at the reflected surface.\n        \n        vec3 rCol = tex3D(iChannel0, rsp*ts, rsn); // Texel at \"rsp.\"\n        q = abs(mod(rsp, 3.) - 1.5);\n        if (max(max(q.x, q.y), q.z)<1.063) rCol = rCol*vec3(.7, .85, 1.);  \n        // Toning down the power of the reflected color, simply because I liked the way it looked more. \n        rCol = sqrt(rCol); \n        float rDiff = max(dot(rsn, normalize(lp-rsp)), 0.); // Diffuse at \"rsp\" from the main light.\n        rDiff += max(dot(rsn, normalize(-rd-rsp)), 0.)*.45; // Diffuse at \"rsp\" from the camera light.\n        \n        float rlDist = length(lp - rsp);\n        float rAtten = 1./(1.0 + rlDist*0.25 + rlDist*rlDist*.1);\n        rCol = min(rCol, 1.)*(rDiff + vec3(.5, .6, .7))*rAtten; // Reflected color. Not accurate, but close enough.\n        //\n    \t// END REFLECTION BLOCK.\n        \n\n        // Combining the elements above to light and color the scene.\n        col = oCol*(diff + vec3(.5, .6, .7)) + vec3(.5, .7, 1)*spec*2. + rCol*0.25;\n\n\n        // Shading the scene color, clamping, and we're done.\n        col = min(col*atten*sh*ao, 1.);\n        \n        \n        \n        \n        \n         \n    }\n    \n    // Working in a bit of a blue fadeout in the distance. Totally fake. I chose blue to counter all\n    // that walnut. Seemed like a good idea at the time. :)\n    col = mix(col, vec3(.55, .75, 1.), smoothstep(0., FAR - 15., t));////1.-exp(-0.01*t*t)\n\n    \n    // No gamma correction: It was a style choice, plus I didn't feel like going back and retweaking the \n    // colors, shades, etc. Just pretend it's a gamma corrected postprocessed value. :)\n\tfragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 2244, 2266, 2266, 2301], [2304, 2458, 2508, 2508, 2734], [2736, 2876, 2925, 2925, 3035], [3615, 3812, 3830, 3896, 4796], [4800, 4905, 4935, 4935, 5106], [5108, 5212, 5245, 5245, 5404], [5407, 5479, 5502, 5611, 5769], [5990, 6222, 6262, 6262, 6570], [6573, 6788, 6832, 6949, 8063], [8065, 9110, 9166, 9344, 14004]], "test": "untested"}
{"id": "lsG3Dm", "name": "DJ Doggie", "author": "MMGS", "description": "meet tha dawg,  shadertoy happen..", "tags": ["3d", "music", "stuff", "model"], "likes": 11, "viewed": 1473, "published": "Public", "date": "1454780451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// madeBy@MMGS 2016\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an =  3.1+iMouse.x*0.1;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( vec2 uv)\n{\n    return vec3( uv,0.5+0.5*sin(iTime)*texture(iChannel0,uv).x)+0.1;\n}\n    \nfloat sMin( float a, float b )\n{\n    float k = .12;\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    \n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nvec2 doModel( vec3 p )\n{\n     float id;\n    \n    vec3 music = texture(iChannel0,p.xz).xyz;\n    \n    float scene[19]; //array to hold scene objects\n    float s,s1,s2;\n    vec3 hpos=vec3(0.+cos(p.y+iTime*4.)*p.x*0.005,0,0); //model position\n    s1 = length(p+hpos+p.y*0.2) - 1.02;\n   \n     s2 = .5;///length(p+vec3(1.,0,0)) - .30;\n      float s3;\n    \n    s=sMin(s1,s2);\n     scene[0] = s1;\n     p+=hpos;\n    for(int i=0;i<4;i++)\n    {\n        \n         s2 = length(p+vec3(1.+float(i)*0.15,0.+cos(p.x*3.5)*0.49,0)) - .25+p.x*0.1;\n         s=sMin(s,s2);scene[1] = s2;\n        \n       \n        s2 = length(p+vec3(-1.-float(i)*0.2,0.+cos(p.x*3.5)*0.6,0)) - .20-p.x*0.1;\n         s=sMin(s,s2);scene[2] = s2;\n        \n         s2 = length(p+vec3(0.+cos(p.y*2.5+iTime*2.5)*0.05,1.+float(i)*0.05,0)) - .30+p.y*0.4;\n         s=sMin(s,s2);scene[3] = s2;\n      \n        p = p*rotate_y(.7);\n         s2 = length(p+vec3(.8+float(i)*0.25,  1.+cos(p.x*4.+iTime*music.x*0.5)*0.2*music.x  ,0.)) - .25;\n         s=sMin(s,s2);scene[4] = s2;\n        p = p*rotate_y(-.7);\n        \n          p = p*rotate_y(-.7);\n         s2 = length(p+vec3(-.6-float(i)*0.25,  1.+sin(-p.x*5.5+iTime)*0.08  ,0.)) - .25;\n         s=sMin(s,s2);scene[5] = s2;\n        p = p*rotate_y(.7);\n     \n \n    }\n    \n       s2 = length(p+vec3(.0,0.,.8)) - .30+p.y*0.4;\n         s=sMin(s,s2);scene[6] = s2;\n    \n      s2 = length(p+vec3(.0,-0.1,1.)) - .20+p.y*0.4;\n         s=min(s,s2);scene[7] = s2;\n      \n      s2 = length(p+vec3(.3,-0.4,.7)) - .29;\n         s=sMin(s,s2);scene[8] = s2;\n     s2 = length(p+vec3(.3,-0.4,.85)) - .19;\n         s=sMin(s,s2);scene[9] = s2;\n    \n    \n     s2 = length(p+vec3(-.3,-0.4,.7)) - .27;\n        s=sMin(s,s2); scene[10] = s2;\n      s2 = length(p+vec3(-.3,-0.4,.85)) - .19;\n         s=sMin(s,s2);scene[11] = s2;\n    \n     s2 = length(p+vec3(-.3,-0.39,.9)) - .15;\n         s=sMin(s,s2);scene[12] = s2;\n     s2 = length(p+vec3(.3,-0.39,.9)) - .15;\n         s=sMin(s,s2);scene[13] = s2;\n    \n    s2 = length(p+vec3(.1,0.3,1.)) - .1;\n         s=sMin(s,s2);scene[14] = s2;\n    \n     s2 = sdCappedCylinder(p+vec3(1.1,1.5,1.3), vec2 (0.7,.02) );\n         s=sMin(s,s2);scene[15] = s2;\n     \n    \n    s2 = sdCappedCylinder(p+vec3(1.1,1.5,1.3), vec2 (0.2,.023) );\n         s=sMin(s,s2);scene[16] = s2;\n    s2 = sdCappedCylinder(p+vec3(1.1,1.5,1.3), vec2 (0.08,.025) );\n         s=sMin(s,s2);scene[17] = s2;\n     s2 = udBox(p+vec3(.8,2.,1.5), vec3 (2.1,.5,1.) );\n         s=sMin(s,s2);scene[18] = s2;\n    \n      //////SORT OBJECTS\n    float test=9999.0;  //return closest object in scene\n    for(int i=0;i<19;i++){\n        float test2=scene[i];\n        if(test2<test)test=test2;\n    }\n    \n    \n    if(test == scene[0])id=1.0;\n    if(test == scene[1])id=1.0;\n    if(test == scene[2])id=1.0;\n    if(test == scene[3])id=1.0;\n    if(test == scene[4])id=1.0;\n    if(test == scene[5])id=1.0;\n    if(test == scene[6])id=2.0;\n     if(test == scene[8])id=3.0;\n     if(test == scene[9])id=4.0;\n    if(test == scene[10])id=3.0;\n    if(test == scene[11])id=4.0;\n    if(test == scene[14])id=5.0;\n     if(test == scene[16])id=6.0;\n     if(test == scene[18])id=3.0;\n    return vec2(s,id);\n}\n\nvec3 doMaterial( in vec3 pos, in vec3 nor,vec2 obj )\n{\n    vec3 col;\n    \n    if(obj.y==1.) col =  vec3(0.2,0.07,0.01);\n     if(obj.y==2.) col =  vec3(.3,0.07,0.01);\n       if(obj.y==3.) col =  vec3(.3);\n     if(obj.y==4.) col =  vec3(0,0,0.5);\n    if(obj.y==5.) col =  vec3(0.1,0,0.);\n    if(obj.y==6.) col = texture(iChannel1,pos.xz*1.5+0.5 ).xyz*0.5;\n    return col;\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(-1.0,0.7,-0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.001*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<60; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<25; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,1.8) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground(fragCoord.xy/iResolution.xy);\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\t\n        vec2 obj = doModel(pos);\n        // materials\n       vec3 mal = doMaterial( pos, nor, obj );\n\t\t//vec3 obj = doModel(p);\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "Mss3WH", "previewfilepath": "https://soundcloud.com/oodora/yoshis-island-athletic-theme", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/oodora/yoshis-island-athletic-theme", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsG3Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 105, 105, 218], [220, 220, 249, 249, 320], [326, 326, 358, 358, 464], [466, 507, 531, 531, 596], [597, 597, 620, 620, 707], [708, 708, 731, 731, 818], [819, 819, 842, 842, 928], [930, 930, 972, 972, 1076], [1077, 1077, 1108, 1108, 1146], [1147, 1147, 1171, 1171, 4296], [4298, 4298, 4352, 4352, 4669], [4671, 4882, 4966, 4966, 5540], [5542, 5542, 5592, 5592, 6011], [6013, 6013, 6045, 6045, 6465], [6467, 6467, 6515, 6515, 6943], [6945, 6945, 7009, 7009, 7187], [7189, 7189, 7246, 7246, 8542]], "test": "untested"}
{"id": "lsG3zt", "name": " Carousel", "author": "wjbgrafx", "description": "Another experiment in distance function ray marching, based on Ruslan Shestopalyuk's \"Distance Functions Playground\" code.", "tags": ["3d", "raymarch", "modeling"], "likes": 7, "viewed": 987, "published": "Public API", "date": "1455822402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tCAROUSEL by wjbgrafx   2-18-16\n\t\n\t\"A new and rare invencon knowne by the name of the royalle carousell or \n\ttournament being framed and contrived with such engines as will not only \n\tafford great pleasure to us and our nobility in the sight thereof, but \n\tsufficient instruction to all such ingenious young gentlemen as desire to \n\tlearne the art of perfect horsemanshipp.\" \n\tFrom a letter of 1673\t\t\thttp://www.thesaurus.com/browse/carousel\n\t\n\tThis code is based mainly on\t\n\tDistance functions playground, by Ruslan Shestopalyuk, 2014/15\t\n\thttps://github.com/silverio/raymarching\n\thttps://www.shadertoy.com/view/MtXGDr\n\t\n\tAdded additional code for specular and reflection light components from\n\thttp://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n\thttps://www.shadertoy.com/view/XlXGRM\n\t\n\tThe shadow() function was added from ChristmasTree.frag        \n\thttps://github.com/silverio/raymarching/blob/master/ChristmasTree.frag\n\t\n\tAdditional sources\n\t------------------\t\n\tUnsigned Triangle function by Inigo Quilez\t\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tSmooth Minimum blending function by Otavio Good\n\thttps://www.shadertoy.com/view/XtjXWD\n\n\tHG_SDF GLSL Library for building signed distance bounds by MERCURY\n\thttp://mercury.sexy/hg_sdf\n\n    Gardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n    https://www.shadertoy.com/view/lll3z4\n\n\t\"Simple test/port of Mercury's SDF library to WebGL\"\n\thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\n\t--------------------------------\n\tEditing and modification by wjb. \n\t\n\tThe modeling code within the map() function is licensed under a Creative\n\tCommons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\t\n\tI can highly recommend the Raymarching Christmas Tree tutorial at the\n\taddress above. It gave me some insights into modeling with distance \n\tfunctions that I haven't seen elsewhere.\t\n*/\n//==============================================================================\n\n#define PI                      3.1415926535897932384626433832795\n\n#define MTL_BACKGROUND          -1.0\n\n#define NORMAL_EPS              0.001\n\n#define NEAR_CLIP_PLANE         0.001\n#define FAR_CLIP_PLANE          110.0 \n#define MAX_RAYCAST_STEPS       100  \n#define STEP_DAMPING            0.98\n#define DIST_EPSILON            0.001\n\n#define MAX_SHADOW_DIST         100.0\n#define MAX_SHADOW_STEPS        30\n#define SHADOW_SOFTNESS\t\t\t16.0 // 2.0=very soft 128.0=very hard\n\n#define LIGHT_POSITION          vec3( 0.0, 12.0, 5.0 );\n#define GLOBAL_LIGHT_COLOR      vec3( 0.8, 1.0, 0.9)\n#define SPEC_COLOR              vec3( 0.8, 0.90, 0.60 )\n#define SPEC_POWER              32.0\n#define BACKGROUND_COLOR        vec3( 0.1, 0.2, 0.8 )\n#define MAX_RAY_BOUNCES         6.0\t\n#define MATERIAL_REFLECTIVITY   0.55\n#define FOG_DENSITY\t\t\t\t-0.0003\n#define REFLECT_ANGLE_LIMIT\t\t0.01\n\n#define CAM_DIST                80.0\n#define CAM_H                   1.5\n#define CAM_FOV_FACTOR          4.0\n#define LOOK_AT_H               0.2\n\n#define LOOK_AT                 vec3(0.0, LOOK_AT_H, 0.0)\n\n#define N_TOR_ROT\t\t\t\tPI * 0.325\n#define TOP_TOR_ROT\t\t\t\tPI * 0.165\n\n//------------------------------------------------------------------------------\n// Function declarations\nvec3 applyTexture( vec4 hitPosAndID );\nvec3 texture1( vec3 pos );\nvec3 texture2( vec3 pos );\nvec3 texture3( vec3 pos );\nvec3 texture4( vec3 pos );\nvec3 texture5( vec3 pos );\nvec3 texture6( vec3 pos );\nvec3 texture7( vec3 pos );\n\n// Comments here are from the HG_SDF Library.\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions);\nfloat fSphere(vec3 p, float r);\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin);\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius);\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height);\n// Cone with correct distances to tip and base circle. \n// Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height);\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r);\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c );\nfloat snoise(vec3 v);\nfloat smin(float a, float b);\n\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n\nvec2 map( vec3 p ) \n{\n\t// Copy p before repetition domain operation.\n\tvec3 p0 = p;\n\n\t// Ground Plane\n\tfloat objID = 1.0;\n\tvec2 ground = vec2( fPlane( p - vec3( 0.0, -1.0, 0.0 ),\n\t                      normalize( vec3( 0.0, 1.0, 0.0 ) ), 1.0 ), objID );\t\n\t\n\t// Ground ring for inner structure frame.\n\tobjID = 2.0;\n\tvec2 inGrndRing = vec2( fTorus( p - vec3( 0.0, -1.85, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\t\t\n\t// Top ring for inner structure frame.\n\tvec2 inUprRing = vec2( fTorus( p - vec3( 0.0, 9.7, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\t\n\t// Ground ring for outer structure frame.\n\tobjID = 3.0;\n\tvec2 outGrndRing = vec2( fTorus( p - vec3( 0.0, -1.85, 0.0 ), 0.15, 20.0 ), \n\t                                                                   objID );\t\n\t// Top ring for outer structure frame.\n\tvec2 outUprRing = vec2( fTorus( p - vec3( 0.0, 10.0, 0.0 ), 0.15, 20.0 ), \n\t                                                                   objID );\t\n\t// Roof\n\tobjID = 4.0;\n\tvec2 roof = vec2( fCone( p - vec3( 0.0, 10.0, 0.0 ), 20.0, 5.0 ), objID );\n\t\n\t// Repetition : \n\t//------------------------------------\n\tfloat segNum = pModPolar( p.xz, 6.0 );\n\t//------------------------------------\n\t\n\t// Inner ring poles\n\tobjID = 2.0;\n\tvec2 inrPole = vec2( fCylinder( p - vec3( 10.0, 0.0, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\n\t// Outer ring poles\n\tobjID = 3.0;\n\tvec2 outrPoleA = vec2( fCylinder( \n\t                       p - vec3( 19.3, 0.0, -5.0 ), 0.15, 10.0 ), objID );\n\t                                                                   \n\tvec2 outrPoleB = vec2( fCylinder( \n                           p - vec3( 19.3, 0.0,  5.0 ), 0.15, 10.0 ), objID );\n\t                                                                   \n\t// Roof dividers\n\tvec2 rfDivA = vec2( fCapsule( p, vec3( 19.3, 10.0, 5.0 ),\n\t                                 vec3(  0.0, 15.0, 0.0 ), 0.1 ), objID );\n\t\n\tvec2 rfDivB = vec2( fCapsule( p, vec3( 19.3, 10.0, -5.0 ),\n\t                                 vec3(  0.0, 15.0, 0.0 ), 0.1 ), objID );\n\t\n\t//------------------------------------\t\n\t// Calculating horse up/down movement.\n\t//------------------------------------\n\t// From the HG_SDF Library:\n\t// \"Many of the operators partition space into cells. An identifier\n\t// or cell index is returned, if possible. This return value is\n\t// intended to be optionally used e.g. as a random seed to change\n\t// parameters of the distance functions inside the cells.\"\n\t\n\t// I used the variable segNum for the return values, but they were not the\n\t// simple values I'd expected. The ranges or exact values returned for each \n\t// segment ( direction ) are listed below. So it wasn't just simply a matter\n\t// of testing for an individual value, it required testing in a certain\n\t// order: NW, NE, E, SE, W, SW, S, else N \n\t\n\t// nothing >3 or <-2\n\t// NW,W >2 and <=3\n\t// SW,W,NW >1 and <=2\n\t// nothing >1 and <2\n\t// NE,E,SE = 1\n\t// nothing >0 and <1\n\t// NE,E = 0\n\t// nothing >-1 and <0\n\t// NE = -1\n\t// nothing >-2 and <-1\n\t// NW = -2\n\t// nothing <-2\n\n\t// Assign varying y-coords for each horse copy.\n\tfloat bodyPosY = 0.0;\n\n\tif ( segNum <= -2.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime );\n\t}\n\telse if ( segNum < -1.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 150.0 );\n\t}\n\telse if ( segNum < 0.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 300.0 );\n\t}\n\telse if ( segNum < 1.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 450.0 );\n\t}\n\telse if ( segNum < 2.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 600.0 );\n\t}\n\telse if ( segNum < 3.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 750.0 );\n\t}\n\telse\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 900.0 );\n\t}\n\t\t\n\t//--------------------------------------------\n\t// Horse body\n\tobjID = 5.0;\n\tfloat y = 1.25; // Initial ground offset for horse body\n\t\n\tfloat body1= fSphere( p - vec3( 15.0, y + bodyPosY, -0.9 ), 0.9 );\n\tfloat body2 = fSphere( p - vec3(15.0, y + bodyPosY,  0.9 ), 0.9 );\n\tvec2 body = vec2( smin( body1, body2 ), objID );\n\n\t//--------------------------------------------\n\t// Legs\n\t// Front left leg in two parts\n\tfloat x = 14.3,\n\t      z = -1.2,\n\t      legFLa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t   \n\t                            vec3( x, -0.25 + bodyPosY, z - 0.61 ), 0.2 );\n\n\tvec2 legFLb = vec2( smin( body1, legFLa ), objID );\n\n\tvec2 legFL = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z - 0.61 ),\n\t                                vec3( x, -1.26 + bodyPosY, z - 0.6 ), \n\t                                0.16 ), objID );\n\t//--------------------------------------------\n\t// Front right leg in two parts\n\tx = 15.7;\n\tz = -1.2;\n\tfloat legFRa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t         \n\t                            vec3( x, -0.25 + bodyPosY, z + 0.13 ), 0.2 );\n\n\tvec2 legFRb = vec2( smin( body1, legFRa ), objID );\n\n\tvec2 legFR = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z + 0.12 ),\n\t                                vec3( x, -1.26 + bodyPosY, z + 0.9 ), \n\t                                0.16 ), objID );\t\n\t\n\t//--------------------------------------------\n\t// Back left leg in two parts\n\tx = 14.5;\n\tz = 1.2;\n\tfloat legBLa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t  \n\t                            vec3( x, -0.25 + bodyPosY, z - 0.75 ), 0.2 );\n\n\tvec2 legBLb = vec2( smin( body2, legBLa ), objID );\n\n\tvec2 legBL = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z - 0.75 ),\n\t                                vec3( x, -1.26 + bodyPosY, z - 0.6 ), \n\t                                0.16 ), objID );\n\t\n\t//--------------------------------------------\n\t// Back right leg in two parts\n\tx = 15.7;\n\tz = 1.2;\n\tfloat legBRa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t\n\t                            vec3( x, -0.25 + bodyPosY, z + 0.13 ), 0.2 );\n\n\tvec2 legBRb = vec2( smin( body2, legBRa ), objID );\n\n\tvec2 legBR = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z + 0.12 ),\n\t                                vec3( x, -1.26 + bodyPosY, z + 0.75 ), \n\t                                0.16 ), objID );\n\t\n\t//--------------------------------------------\n\t// Neck\n\tfloat neckA = fCapsule( p, vec3( 15.0, 2.0 + bodyPosY, -1.8 ),\n\t                          vec3( 15.0,  3.0 + bodyPosY, -2.3 ), 0.35 );\n\t                          \n\tvec2 neck = vec2( smin( neckA, body1 ), objID );\t\n\t\n\t//--------------------------------------------\n\t// Head\n\tfloat headA = fCapsule( p, vec3( 15.0, 3.1 + bodyPosY, -2.5 ),\n\t                           vec3( 15.0, 2.1 + bodyPosY, -3.25 ), 0.275 );\n\t \n\tvec2 head = vec2( smin( neckA, headA ), objID );\t\n\t\n\t//---------------------------------------------\t\n\t// Tail\n\tvec2 tail = vec2( fCapsule( p, vec3( 15.0,  1.6 + bodyPosY, 1.7 ),\n\t                                vec3( 15.0, -0.5 + bodyPosY, 2.5 ), \n\t                                0.125 ), objID );\n\t\n\t//---------------------------------------------\n\t// Ears\n\tvec2 earL = vec2( fCapsule( p, vec3( 14.6, 3.2 + bodyPosY, -2.2 ),\n\t                               vec3( 14.6, 3.9 + bodyPosY, -2.2 ),\n\t                               0.1 ), objID );  \n\t\n\tvec2 earR = vec2( fCapsule( p, vec3( 15.4, 3.2 + bodyPosY, -2.2 ),\n\t                               vec3( 15.4, 3.9 + bodyPosY, -2.2 ),\n\t                               0.1 ), objID );  \n\t\n\t//---------------------------------------------\n\t// Horse pole\n\tobjID = 2.0;\n\tvec2 hPole = vec2( fCylinder( \n\t                        p - vec3( 15.0, 0.0, 0.0 ), 0.05, 10.0 ), objID );\t\n\t// Flag pole\n\tvec2 flagPole = vec2( fCylinder(\t\n\t                        p - vec3( 0.0, 15.0, 0.0 ), 0.05, 3.0 ), objID );\n\t\n\t// Flag in non-repeated space: p0\n\tobjID = 6.0;\n\tfloat wind = sin( iTime );\n\tvec2 flag = vec2( udTriangle( p0, vec3(  0.0, 16.5, 0.0 ), \n\t                                  vec3(  0.0, 18.0, 0.0 ),\n\t                           vec3( -5.0, 17.0 + wind, wind * 2.0 ) ), objID );\n\t// Pole top spheres\n\tvec2 poleTopA = vec2( fSphere( p - vec3( 19.3, 10.5, -5.0 ), 0.4 ), objID );\n\tvec2 poleTopB = vec2( fSphere( p - vec3( 19.3, 10.5,  5.0 ), 0.4 ), objID );\n\t\n\t// Flag sphere\n\tobjID = 3.0;\n\tvec2 flagSphere = vec2( fSphere( p - vec3( 0.0, 15.4, 0.0 ), 0.4 ), objID );\n\t\n\t// Outer ring spheres\n\tobjID = 2.0;\n\tvec2 outRingA = vec2( fSphere( p - vec3( 19.3, -1.65, -5.0 ), 0.6 ), objID );\n\tvec2 outRingB = vec2( fSphere( p - vec3( 19.3, -1.65,  5.0 ), 0.6 ), objID );\n\n\t// Center sphere\n\tobjID = 7.0;\t\n\tvec2 cntrSphere = vec2( \n\t                      fSphere( p - vec3( 0.0, -9.0, 0.0 ), 10.0 ), objID );\n\t\n\t// Center ring spheres\n\tobjID = 4.0;\n\tvec2 cntrRingSphere = vec2( \n\t                      fSphere( p - vec3( 9.0, -1.25, 0.0 ), 0.75 ), objID ); \n\t                      \n\t//-------------------------------------------\n\t// Distance comparisons for minimum distance.\n\t\n\tvec2 closest = ground.s < inGrndRing.s ? ground : inGrndRing;\n\tclosest = closest.s < inUprRing.s ? closest : inUprRing;\n\tclosest = closest.s < outGrndRing.s ? closest : outGrndRing;\n\tclosest = closest.s < outUprRing.s ? closest : outUprRing;\n\tclosest = closest.s < roof.s ? closest : roof;\n\tclosest = closest.s < inrPole.s  ? closest : inrPole;\n\tclosest = closest.s < outrPoleA.s  ? closest : outrPoleA;\n\tclosest = closest.s < outrPoleB.s  ? closest : outrPoleB;\n\tclosest = closest.s < rfDivA.s  ? closest : rfDivA;\n\tclosest = closest.s < rfDivB.s  ? closest : rfDivB;\n\n\tclosest = closest.s < body.s ? closest : body;\n\tclosest = closest.s < legFLb.s ? closest : legFLb ;\n\tclosest = closest.s < legFL.s ? closest : legFL;\n\tclosest = closest.s < legFRb.s ? closest : legFRb ;\n\tclosest = closest.s < legFR.s ? closest : legFR;\n\tclosest = closest.s < legBLb.s ? closest : legBLb ;\n\tclosest = closest.s < legBL.s ? closest : legBL;\n\tclosest = closest.s < legBRb.s ? closest : legBRb ;\n\tclosest = closest.s < legBR.s ? closest : legBR;\n\tclosest = closest.s < neck.s ? closest : neck;\n\tclosest = closest.s < head.s ? closest : head;\n\tclosest = closest.s < tail.s ? closest : tail;\n\tclosest = closest.s < earL.s ? closest : earL;\n\tclosest = closest.s < earR.s ? closest : earR;\n\t\n\tclosest = closest.s < hPole.s ? closest : hPole;\n\tclosest = closest.s < flagPole.s ? closest : flagPole;\n\tclosest = closest.s < flag.s ? closest : flag;\n\tclosest = closest.s < poleTopA.s ? closest : poleTopA;\n\tclosest = closest.s < poleTopB.s ? closest : poleTopB;\n\tclosest = closest.s < flagSphere.s ? closest : flagSphere;\n\tclosest = closest.s < outRingA.s ? closest : outRingA;\n\tclosest = closest.s < outRingB.s ? closest : outRingB;\n\tclosest = closest.s < cntrSphere.s ? closest : cntrSphere;\n\tclosest = closest.s < cntrRingSphere.s ? closest : cntrRingSphere;\n\t\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// CALC NORMAL\n// -----------\n// The surface normal computed using the finite difference formula.\nvec3 calcNormal( in vec3 p )\n{\n    vec2 d = vec2( NORMAL_EPS, 0.0 );\n    \n    return normalize( vec3( map( p + d.xyy ).x - map( p - d.xyy ).x,\n                            map( p + d.yxy ).x - map( p - d.yxy ).x,\n                            map( p + d.yyx ).x - map( p - d.yyx ).x ) );\n}\n\n//------------------------------------------------------------------------------\n\n// RAY MARCH\n// ---------\n\nvec2 rayMarch( vec3 rayOrig, vec3 rayDir ) \n{\n    vec2 objDistID = vec2( 0.0 );\n    float t = NEAR_CLIP_PLANE;\n    float m = MTL_BACKGROUND;\t// -1 : flag for hit far clip plane\n    \n    for (int i = 0; i < MAX_RAYCAST_STEPS; i++ ) \n    {\n        objDistID = map( rayOrig + rayDir * t );\n        \n        if ( objDistID.x < DIST_EPSILON || t > FAR_CLIP_PLANE )  \n        {\n        \tbreak;\n        }\n        t += objDistID.x * STEP_DAMPING;\n    }\n\n    m = objDistID.y;\n\n    if ( t > FAR_CLIP_PLANE ) \n    {\n    \tm = MTL_BACKGROUND;\n    }\n    return vec2( t, m );\n}\n\n// end rayMarch()\n\n//------------------------------------------------------------------------------\n\n// APPLY FOG\n// ---------\n\n// Fog is implemented by mixing in the the background color exponentially,\n// depending on the distance to the point. wjb added skyClr to replace\n// background color.\nvec3 applyFog( vec3 clr, float dist, vec3 skyClr ) \n{\n    //return mix( clr, BACKGROUND_COLOR, 1.0 - exp( -0.0015 * dist * dist ) );\n    vec3 fog = mix( clr, skyClr, 1.0 - exp( FOG_DENSITY * dist * dist ) );\n\treturn clamp( fog, 0.0, 0.4 );\n}\n\n//------------------------------------------------------------------------------\n\n// SHADOW\n// ------\n// source : http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// Added from ChristmasTree.frag        \n// https://github.com/silverio/raymarching/blob/master/ChristmasTree.frag\n// tmin = DIST_EPSILON, tmax = MAX_SHADOW_DIST\nfloat shadow( vec3 rayOrig, vec3 rayDir, float tmin, float tmax ) \n{\n    float shadowAmt = 1.0;\n    float t = tmin;\n    \n    for ( int i = 0; i < MAX_SHADOW_STEPS; i++ ) \n    {\n        float d = map( rayOrig + rayDir * t ).s * STEP_DAMPING;\n        \n        if ( d < DIST_EPSILON || t > tmax ) \n        {\n        \tbreak;\n        }\n        \n        shadowAmt = min( shadowAmt, SHADOW_SOFTNESS * d / t );\n        \n        t += clamp( d, 0.01, 0.25 );\n    }\n\n    return clamp( shadowAmt, 0.0, 1.0 );\n}\n\n// end shadow()\n\n//------------------------------------------------------------------------------\n\n// RENDER\n// ------\n\nvec3 render( vec3 rayOrig, vec3 rayDir, vec4 objHitPosID, vec3 skyClr ) \n{\n\t// Added from \n\t// http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n    // Reflections\n    // -----------\n    // After the ray hits an object, we can cast so called secondary rays, \n    // including the one in the direction of the reflection vector. For \n    // reflections we'll keep doing it either until we reach the hit number or \n    // raymarching step limit:\n    vec3 objClr = vec3( 0.0 );\n    //vec3  lightDir = -rayDir; // original - light position is at ray origin\n    \n    vec3 lightDir = LIGHT_POSITION - LOOK_AT;\n    lightDir = normalize( lightDir );\n        \n    vec3 mtlClr = applyTexture( objHitPosID );\n    vec2 objDistID = vec2( 0.0 );\n    \n    float specSharp = 0.9;//1.0\t// the specular \"sharpness\" coefficient\n    float ambient = 0.01;\n\n\tfor ( float i = 0.0; i < MAX_RAY_BOUNCES; i++ ) \n\t{\n\t\t// Number of raymarch calls can be set separately from reflection loop.\n\t\tif ( i < 3.0 )\n\t\t{\n\t    \tobjDistID = rayMarch( rayOrig, rayDir );\n\t\t}\n\n\t    float objDist = objDistID.x;\n\t    float objID = objDistID.y;\n\t    \n\t    vec3 pos = rayOrig + objDist * rayDir;\n\t    vec3 nor = calcNormal( pos );\n\t    //vec3 mtlClr = getMaterialColor( objID ); // original\n    \t\n    \t// The dot product of the angle between the normal vector at the object \n    \t// hit position and the light direction vector returns a value between \n    \t// -1 and +1; which is then clamped between 0 and +1 to give the diffuse \n    \t// light component value ( 0 = darkest, 1 = brightest ). \n    \tfloat diffuse = clamp( dot( nor, lightDir ), 0.0, 1.0 );\n        diffuse *= shadow( pos, lightDir, DIST_EPSILON, MAX_SHADOW_DIST );\n\t\n\t\t// Added from \n\t\t// http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n\t    // Phong ( specular ) component\n\t    // ----------------------------\n\t    // Phong model adds so-called specular component on top of the diffuse \n\t    // Lambertian one. Essentially it's a fake reflection that assumes that \n\t    // environment consists from a single blob light source. \n\t    \n\t    // rayDir is view direction, specSharp is the specular \"sharpness\" \n\t    // coefficient (used to adjust the shape of the reflected fake blob), \n\t    // ref is \"reflection vector\"\n\t    vec3 ref = reflect( rayDir, nor );\n\t    float specular = pow(clamp(dot(ref, lightDir), 0.0, 1.0), SPEC_POWER);\n    \n\t    // Modified from\n\t\t// http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n\t    //vec3 clr = mtlClr*(ambient + GLOBAL_LIGHT_COLOR*diffuse);\n\t    vec3 clr = mtlClr * ( ambient + GLOBAL_LIGHT_COLOR * \n\t                                     ( diffuse + specular * SPEC_COLOR ) );       \t\n    \tclr = mix( applyFog( clr, objDist, skyClr ), clr, 0.33 );\n\t\t\n\t\t// Added from\n\t\t// http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n\t\tobjClr += clr * specSharp; //  blend in (a possibly reflected) new color\n\t\t\n\t\t// If the reflection angle is very small, discontinue the loop.\n\t\tif ( abs( dot( nor, rayDir ) ) < REFLECT_ANGLE_LIMIT )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// The ray origin is updated to the sum of the current ray position and\n\t\t// the reflection vector multiplied by the \"close enough to be a hit\"\n\t\t// value. I think this is done to move the ray position far enough away\n\t\t// from the hit object so that it doesn't immediately hit it again ( per\n\t\t// code comments from Shane in raymarching.com code ).\n        rayOrig = pos + ref * DIST_EPSILON;\n        \n        //specSharp is the specular \"sharpness\" coefficient (used to adjust the \n        // shape of the reflected fake blob in the Christmas Tree shader)\n        specSharp *= MATERIAL_REFLECTIVITY;\n        rayDir = ref;\n\t}    \n   \n    return vec3( clamp( objClr, 0.0, 1.0 ) );\n}\n\n// end render()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n// SKY COLOR\n// ---------\n// https://www.shadertoy.com/view/lll3z4\n// Gardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n/*\n * Gardner Cos Clouds\n *\n * Translated/adapted from the RenderMan implementation in\n * Texturing & Modeling; a Procedural Approach (3rd ed, p. 50)\n */\n \nvec3 skyColor( vec2 pix )\n{\n\tconst int nTerms = 10;\n\t\n\tfloat zoom = 1.0,\n          cloudDensity = 0.0,\n          amplitude = 0.4,//0.45,\n          xphase = 0.9 * iTime,\n          yphase = 0.7,\n          xfreq = 2.0 * PI * 0.023,\n          yfreq = 2.0 * PI * 0.021,\n    \n          offset = 0.5,\n          xoffset = 37.0,\n          yoffzet = 523.0,\n    \n          x = pix.x,\n          y = pix.y,\n\t      scale = 1.0 / iResolution.x * 60.0 * 1.0 / zoom;\n\n    x = x * scale + offset + iTime * 1.5;\n    y = y * scale + offset - iTime / 2.3;\n    \n    for ( int i = 0; i < nTerms; i++ )\n    {\n        float fx = amplitude * ( offset + cos( xfreq * ( x + xphase ) ) );\n        float fy = amplitude * ( offset + cos( yfreq * ( y + yphase ) ) );\n        cloudDensity += fx * fy;\n        xphase = PI * 0.5 * 0.9 * cos( yfreq * y );\n        yphase = PI * 0.5 * 1.1 * cos( xfreq * x );\n        amplitude *= 0.602;\n        xfreq *= 1.9 + float( i ) * .01;\n        yfreq *= 2.2 - float( i ) * 0.08;\n    }\n\n    return mix( vec3(0.25, 0.55, 0.96 ), vec3( 1.0 ), cloudDensity * 2.0 );   \n}\n\n// end skyColor()\n\n//------------------------------------------------------------------------------\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\n// From\t\"Simple test/port of Mercury's SDF library to WebGL\"\n// \thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = iTime * 0.2;\n\t}\n\telse\n\t{\n\t\t// wjb added the 180 degree rotation ( PI ) because the objects were\n\t\t// being created on the negative side of the x-axis ( mirrored position\n\t\t// across z-plane ) instead of the positive side, where they should be.\n\t\tang = ( iMouse.x - iResolution.x * 0.5 ) * rotRange + PI;\n\t}\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = 0.25 * ( sin( iTime * 0.1 ) + 1.0 );\n\t}\n\telse\n\t{\n\t\t// Scale mouse.y so x-axis rotation range is only from partway overhead\n\t\t// to just about level with ground.\n\t\tang = ( 0.4825 * iMouse.y - iResolution.y * 0.5 ) * rotRange; \n\t}\n\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// For skyColor()\n\tvec2 curPix = fragCoord.xy;\n\tcurPix *= vec2( 0.35, 0.65 );\n\t\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n \tmat4 cam_mat = createCamRotMatrix();\n\tvec3 camPos = vec3( cam_mat * vec4( 0.0, 0.0, -CAM_DIST, 1.0 ) );\t    \n    vec3 rayDir = getRayDir( camPos, normalize( LOOK_AT - camPos ), p );   \n    \n    // Determine whether ray has reached back plane.\n    vec2 objDistID = rayMarch( camPos, rayDir );\n    \n    // Set to background and skip the reflection and lighting process if the\n    // ray got all the way to the back.\n    vec3 skyClr = skyColor( curPix );\n    vec3 color = skyClr;                        \n    \n\tif ( objDistID.s < FAR_CLIP_PLANE )\n\t{\t\t\n\t\tvec3 objHitPos = camPos + rayDir * objDistID.s;\n\t\tvec4 objHitPosID = vec4( objHitPos, objDistID.t );\n\t\tcolor = render( camPos, rayDir, objHitPosID, skyClr );\n\t}\n\t\n    fragColor = vec4(color, 1.0);\n}\n\n//------------------------------------------------------------------------------\n\n// APPLY TEXTURE\n// -------------\n\nvec3 applyTexture( vec4 hitPosAndID )\n{\n\tvec3 baseColor = vec3( 0.0 ),\n\t     pos = hitPosAndID.xyz;\n\t\n\tint objNum = int( hitPosAndID.w );\n\n\t// ground\n\tif ( objNum == 1 )\n\t{\t\t\n\t\tbaseColor = texture1( pos );\n\t}\t\n\t// inner rings, inner pillars\n\telse if ( objNum == 2 )\n\t{\n\t\tbaseColor = texture2( pos );\n\t}\t\n\t// outer rings, outer pillars\n\telse if ( objNum == 3 )\n\t{\n\t\tbaseColor = texture3( pos );\n\t}\t\n\t// roof\t\n\telse if ( objNum == 4 )\n\t{\n\t\tbaseColor = texture4( pos );\n\t}\n\t// horse\t\t\t\n\telse if ( objNum == 5 )\n\t{\n\t\tbaseColor = texture5( pos );\n\t}\t\n\t// pole top sphere\n\telse if ( objNum == 6 )\n\t{\n\t\tbaseColor = texture6( pos );\n\t}\t\n\t// center sphere\n\telse if ( objNum == 7 )\n\t{\n\t\tbaseColor = texture7( pos );\n\t}\t\n\t\n\treturn baseColor;\n}\n\n// end applyTexture()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 1\n// ---------\n\nvec3 texture1( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.0, 0.7, 0.2 );\t\n\t\t\n\tfloat scale = 1.0,\n\t\t  complexity = 5.0,\n\t\t  mixVal = 0.5;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Marble( triangular ) #1\n\tvec3 v = pos * scale;\n\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n\tt += snoise(v);\t\n\tfloat value = t - floor(t);\t\t\t\n\t// smooth out the discontinuity\n\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n\tvalue = 0.333 + value*0.667;\n\tvec3 color = vec3(value);\t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture1()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 2\n// ---------\n\nvec3 texture2( vec3 pos )\n{\n\tvec3 objClr = vec3( 1.0, 1.0, 0.0 );\t\n\t\t\n\tfloat scale = 4.0,\n\t\t  complexity = 2.5,\n\t\t  mixVal = 0.6;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Combination Marble( triangular) with Marble( sharp ) #10\n\t// Marble( triangular )\n\tvec3 v = pos * scale;\n\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n\tt += snoise(v);\t\n\tfloat value = t - floor(t);\t\t\t\n\t// smooth out the discontinuity\n\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n\tvalue = 0.333 + value*0.667;\n\tvec3 color = vec3(value);\t\t    \n\t// Marble ( sharp )  :  wjb added variable complexity factor\n\tt = (v.x + 2.0*v.y + 3.0*v.z);\n\tt +=  snoise(v) * complexity;\n\tvalue =  abs(sin(t));\n\tcolor /= vec3(sqrt(value)); // modified to divide    \t\t    \n\treturn mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture2()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 3\n// ---------\n\nvec3 texture3( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.75, 0.0, 1.0 );\t\n\t\t\n\tfloat scale = 2.0,\n\t\t  complexity = 5.0,\n\t\t  mixVal = 0.9;\t  \n\t\n\t// wjb modified Perlin Noise 3D ( #21 )\n\t// Blotches of objClr surrounded by very thin squiggly black lines\n\t// on white background\n\tvec3 v = pos * scale;\n\tfloat value = exp( inversesqrt( pow( snoise( v ), 2.0 ) * complexity ) ); \n    value = 0.75 + value*0.25;\n    vec3 color = vec3( value);    \t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture3()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 4\n// ---------\n\nvec3 texture4( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.0, 0.15, 1.0 );\t\n\t\t\n\tfloat scale = 2.0,\n\t\t  complexity = 0.5,\n\t\t  mixVal = 0.6;\t  \n\t\n\t// wjb modified Perlin Noise 3D ( #19 )\n\t// With complexity = 1.0, squiggly lines in objColor on white\n\tvec3 v = pos * scale;\n\tfloat value = log( pow( snoise( v ), 2.0 ) ) * complexity; \n    value = 0.75 + value*0.25;\n    vec3 color = vec3( value);    \t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture4()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 5\n// ---------\n\nvec3 texture5( vec3 pos )\n{\n\treturn vec3( 0.0 );\n//\tvec3 objClr = vec3( 0.0 );\t\n//\t\n//\tfloat scale = 1.0,\n//\t\t  //complexity = 5.0,\n//\t\t  mixVal = 0.5;\t  \n//\t\n//\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n//\t// Marble( triangular ) #1\n//\tvec3 v = pos * scale;\n//\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n//\tt += snoise(v);\t\n//\tfloat value = t - floor(t);\t\t\t\n//\t// smooth out the discontinuity\n//\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n//\tvalue = 0.333 + value*0.667;\n//\tvec3 color = vec3(value);\t\t    \n//    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture5()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 6\n// ---------\n\nvec3 texture6( vec3 pos )\n{\n\tvec3 objClr = vec3( 1.0, 0.0, 0.0 );\t\n\t\n\tfloat scale = 2.0,\n\t\t  complexity = 5.0,\n\t\t  mixVal = 0.9;\t  \n\t\n\t// wjb modified Perlin Noise 3D ( #21 )\n\t// Blotches of objClr surrounded by very thin squiggly black lines\n\t// on white background\n\tvec3 v = pos * scale;\n\tfloat value = exp( inversesqrt( pow( snoise( v ), 2.0 ) * complexity ) ); \n    value = 0.75 + value*0.25;\n    vec3 color = vec3( value);    \t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\t\n}\n\n// end texture6()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 7\n// ---------\n\nvec3 texture7( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.0 ),//( 1.0, 0.0, 1.0 ),\n\t     color = vec3( 0.0 );\t\n\t\n\tfloat scale = 2.0,\n\t\t  mixVal = 0.5;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Checkerboard 3D #6\n\tvec3 v = pos * scale;\n\tfloat a = floor( v.x );\n\tfloat b = floor( v.y );\n\tfloat c = floor( v.z );\n\tif ( mod( a + b + c, 2.0 ) > 0.5 ) \n\t{  // a+b+c is odd\n\t    color = vec3( 0.3 ); // the dark value\n\t}\n\telse \n\t{  // a+b+c is even\n\t    color = vec3( 1.0 ); // the light value\n\t}    \t\t\n\treturn mix( color, objClr, mixVal );        \t\t\t\t\t\t\t\t\t\t\t\t\n}\n\n// end texture7()\n\n//------------------------------------------------------------------------------\n//==============================================================================\n// Triangle - unsigned\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n//------------------------------------------------------------------------------\n\n// SMOOTH MINIMUM\n// --------------\n// https://www.shadertoy.com/view/XtjXWD\t-Otavio Good\n// smooth blending function; k should be negative. -4.0 works nicely.\nfloat smin(float a, float b)\n{\n\tfloat k = -4.0;\n\treturn log2( exp2( k * a ) + exp2( k * b ) ) / k;\n}\n\n//==============================================================================\n// The code below is excerpted from :\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n#define clamp(x,a,b) min(max(x,a),b)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//\n    // FOLLOWING CODE was OBTAINED FROM https://github.com/ashima/webgl-noise\n    // This is the code for 3D  Perlin noise, using simplex method.\n    //\n    \n    //------------------------------- 3D Noise ------------------------------------------\n    \n    // Description : Array and textureless GLSL 2D/3D/4D simplex \n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    // \n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      { \n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n      \n      // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n      \n      // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n      \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n      \n      // Permutations\n        i = mod289(i); \n        vec4 p = permute( permute( permute( \n                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n      \n      // Gradients: 7x7 points over a square, mapped onto an octahedron.\n      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n      \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n      \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n      \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n      \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n      \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n      \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n      \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n      \n      //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n      \n      // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                      dot(p2,x2), dot(p3,x3) ) );\n      }\n\n//------------------------------------------------------------------------------\n", "image_inputs": [{"id": "ldf3DN", "previewfilepath": "https://soundcloud.com/reichmarshall/gladiolus-rag-on-pipe-organ", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/reichmarshall/gladiolus-rag-on-pipe-organ", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsG3zt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[4487, 4502, 4523, 4570, 15107], [15205, 15303, 15333, 15333, 15589], [15673, 15700, 15745, 15745, 16262], [16392, 16559, 16612, 16691, 16800], [16884, 17141, 17209, 17209, 17639], [17740, 17761, 17835, 18217, 21509], [21610, 21653, 21714, 21714, 22001], [22105, 22382, 22409, 22409, 23452], [23622, 23762, 23789, 23789, 25076], [25107, 25189, 25246, 25265, 26293], [26377, 26412, 26451, 26451, 27144], [27251, 27278, 27305, 27305, 27830], [27933, 27960, 27987, 27987, 28776], [28879, 28906, 28933, 28933, 29400], [29503, 29530, 29557, 29557, 29980], [30083, 30110, 30137, 30137, 30708], [30811, 30838, 30865, 30865, 31331], [31434, 31461, 31488, 31488, 32047], [32068, 32328, 32353, 32353, 32372], [32373, 32373, 32425, 32425, 32932], [33015, 33175, 33205, 33205, 33275], [33277, 34014, 34046, 34046, 34071], [34073, 34147, 34203, 34203, 34245], [34248, 34293, 34341, 34341, 34415], [34417, 34501, 34545, 34545, 34648], [34650, 34722, 34771, 34771, 34808], [34810, 34835, 34895, 34895, 34966], [34968, 35064, 35113, 35113, 35612], [35615, 35728, 35778, 35778, 36168], [36593, 37024, 37045, 37045, 37102], [37112, 37112, 37133, 37133, 37190], [37200, 37200, 37222, 37222, 37270], [37280, 37280, 37312, 37312, 37372], [37382, 37382, 37410, 37410, 39986]], "test": "untested"}
{"id": "lsGGRc", "name": "San PGATR shader", "author": "jviedma", "description": "Based on this tutorial: https://www.youtube.com/watch?v=0ifChJ0nJfM\n\nJust Training with I&ntilde;igo Quilez tutorials\nReferences: https://www.youtube.co\n\nThis shader represents my friend's treacherous love triangle ;)\n\nJavier Viedma\n", "tags": ["heart"], "likes": 4, "viewed": 1107, "published": "Public API", "date": "1455576253", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Javier Viedma - jviedma/2016\n// MASTER UNIVERSITARIO EN INFORMÃTICA GRAFICA, VIDEOJUEGOS Y REALIDAD VIRTUAL. PGATR. PRÃCTICA 1.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Just Training with IÃ±igo Quilez tutorials\n// References: https://www.youtube.com/watch?v=0ifChJ0nJfM\n\nvec4 pintaCorazon(vec2 uv, vec2 despl,vec4 color1 ,vec4 color2, vec4 color3, vec4 bgColor, float tamano, float brightradius,vec2 brightcenter, float maximo, float minimo)\n{\n    //Corazon: no es un corazon de nadie, es propio: j.viedma\n    \n\n    vec2 q = uv + despl;\n    vec2 center = vec2(0.0,0.0)- despl;\n    \n    float tamanobase = mix(minimo,maximo,tamano);\n    \n    float arturadelpedaso = mix(0.4,0.6,sin(tamano*3.14*2.));\n    float anchuradelpedaso = mix(1.4,1.7,sin(tamano*3.14*1.));\n    float aperturadelpedaso = mix(1.7,2.0,sin(tamano*3.14*2.));\n    float larguradelpedaso = mix(0.3,0.25,sin(tamano*3.14*1.));\n    \n    float radius = (tamanobase + 0.25*cos(sin(q.y*anchuradelpedaso)/cos(q.x)*aperturadelpedaso -6.*abs(sin(q.x))) + larguradelpedaso *(sin(3.14*q.y+arturadelpedaso))); //esta es la funciÃ³n que define el corazon\n    \n    float brightdiffuse = 0.1 + clamp(0.11,0.15,tamano); //modifica esto para hacer el brillo mas difuso o menos\n    \n    vec4 HeartColor = mix(color2,color3,(length(q+brightcenter)));\n    HeartColor = mix(color1,HeartColor,smoothstep(brightradius-brightdiffuse,brightradius+brightdiffuse,sqrt(length(q+brightcenter))));\n\t\n    \n    float val = smoothstep(radius+0.01,radius-0.01,length(uv-center)); //aqui se pinta el corazÃ³n y sus colores\n    return mix(bgColor,HeartColor,val);\n}\n\nvec4 pintaFondo(vec2 uv, vec4 color1 ,vec4 color2,vec2 posluz)\n{\n    return  mix(color1,color2,smoothstep(0.0,2.0,sqrt(length(uv-posluz))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    \n    //Colorines\n    vec4 pink = vec4(1.0,.6,0.6,1.0);\n    vec4 purple = vec4(.6,.0,0.5,1.0);\n    vec4 darkpurple = vec4(.3,.0,0.2,1.0);\n    vec4 red = vec4(1.0,0.0,0.0,1.0);\n    vec4 red2 = vec4(0.4,0.1,0.01,1.0);\n    vec4 white = vec4(1.0,1.0,1.0,1.0);\n    vec4 bg = vec4(0.2,0.2,0.2,0.2);\n    \n    //Color de fondo\n    vec4 ret = pintaFondo(uv, pink ,darkpurple, vec2(sin(iTime)*atan(iTime)*0.2+0.7,cos(iTime)*0.2+0.7));\n    //ret = mix(ret , pintaFondo(uv,bg,purple, vec2(-0.7,-0.7)),smoothstep(0.4,1.0,sqrt(length(vec2(0.7,0.7)-vec2(-0.7,-0.7)))));\n    \n    \n    \n    //Corazoncitos\n    float velocidadlatido = 3.; //Con esto se controla la velocidad del latido\n    float velocidadlatido2 = 5.;\n    \n    float time = smoothstep(0.5,1.,1.5*sin(iTime*velocidadlatido));\n    float minitime = smoothstep(0.5,1.,1.5*sin(iTime*velocidadlatido2));\n    \n    \n    ret = pintaCorazon(uv, vec2(cos(iTime+3.14),sin(iTime+3.14)),white,pink,purple,ret,clamp(0.1,0.4,minitime),0.3,vec2(-0.2,-0.3),0.1,0.4);\n    \n    ret = pintaCorazon(uv, vec2(0.0,0.2),white,red,red2,ret,time,0.3,vec2(-0.3,-0.4),0.5,0.65);\n    \n    ret = pintaCorazon(uv, vec2(1.2*cos(iTime),1.1*sin(iTime)),white,pink,purple,ret,clamp(0.1,0.4,minitime),0.3,vec2(-0.2,-0.3),0.1,0.4);\n\n    \n\tfragColor = ret;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGGRc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 343, 515, 577, 1670], [1672, 1672, 1736, 1736, 1814], [1816, 1816, 1873, 1873, 3259]], "test": "untested"}
{"id": "lsGGRt", "name": "Happy Memories", "author": "rohtie", "description": "Using iq's IK solver: https://www.shadertoy.com/view/ldlGR7", "tags": ["ik", "guy", "running"], "likes": 9, "viewed": 287, "published": "Public", "date": "1456309484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 solve(vec2 p, float upperLimbLength, float lowerLimbLength) {\n    vec2 q = p * (0.5 + 0.5 * (upperLimbLength * upperLimbLength - lowerLimbLength * lowerLimbLength) / dot(p, p));\n\n    float s = upperLimbLength * upperLimbLength / dot(q, q) - 1.0;\n\n    if (s < 0.0) { \n        return vec2(-100.0);\n    }\n        \n    return q + q.yx * vec2(-1.0, 1.0) * sqrt(s);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 p) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    return length(pa - ba * h) - 0.04;\n}\n\nfloat limb(vec2 p, vec2 target, float upperLimbLength, float lowerLimbLength) {    \n    vec2 joint = solve(target, upperLimbLength, lowerLimbLength);\n    return min(line(vec2(0.0), joint, p), line(joint, target, p));\n}\n\nfloat limb(vec2 p, vec2 target) {   \n    return limb(p, target, 0.5, 0.5);\n}\n\nfloat legs(vec2 p) {\n    float speed = 4.0;\n    \n    p.y += sin(iTime * speed) * 0.05;\n    \n    float leftLeg = limb(p,\n        vec2(-0.1 + sin(iTime * speed) * 0.4, \n             -0.7 + cos(iTime * speed) * 0.25)\n    );\n    \n    float rightLeg = limb(p,\n        vec2(-0.1 + sin(2.75 + iTime * speed) * 0.4, \n             -0.7 + cos(2.75 + iTime * speed) * 0.25)\n    );\n    \n    return smin(\n        min(leftLeg, rightLeg), \n        smin(length(p) - 0.2, \n            line(vec2(0.0), vec2(0.3, 0.7), p) - p.y * 0.2, \n            0.2\n        ),\n        0.3\n    );\n}\n\nfloat arms(vec2 p) {   \n    p.y = 1.0 - p.y;\n    p.y -= 0.25;\n    p.x -= 0.3;\n    \n    float speed = 4.0;\n    p.y += sin(iTime * speed) * 0.025;\n    \n    vec2 target = vec2(0.0, 0.5);\n    vec2 ellipse = vec2(-0.5, 0.2);\n    vec2 limbSize = vec2(0.5, 0.4);\n    \n    float leftArm = limb(p,\n        vec2(target.x - sin(iTime * speed) * ellipse.x, \n             target.y - cos(iTime * speed) * ellipse.y),\n        limbSize.x,\n        limbSize.y\n    );\n    \n    float rightArm = limb(p,\n        vec2(target.x - sin(2.75 + iTime * speed) * ellipse.x, \n             target.y - cos(2.75 + iTime * speed) * ellipse.y),\n        limbSize.x,\n        limbSize.y\n    );\n    \n    return smin(min(leftArm, rightArm), length(p) -0.15, 0.3);\n}\n\nfloat head(vec2 p) {\n    float speed = 4.0;\n    \n    p.y += sin(iTime * speed) * 0.06;\n    \n    float head = length(p) - 0.3;\n    \n    float mouth = max(length(p - vec2(0.25, 0.0)) - 0.1, p.y);\n    float eye = max(length(p - vec2(0.0, 0.06)) - 0.1, -p.y + 0.12);\n    float hat = max(length(p - vec2(-0.35, 0.06)) - 0.1, -p.y + 0.12);\n    \n    return max(min(head, hat), -min(mouth, eye));\n}\n\nfloat plant(vec2 p, vec2 target) {\n    vec2 q = p - target;\n    \n    q *= 2.0;\n    q.x += mod(iTime * 10.0, 20.0);\n    \n    return mix(cos(atan(q.x, q.y) * 2.5), length(q), 0.8) - 0.2;\n}\n\nfloat grass(vec2 p) {\n    p *= 0.5;\n    p.y -= 0.5;\n    \n    p.x += iTime * 1.5;\n    p.x = mod(p.x, 0.5);\n    p.y += 0.7;\n    \n    \n    float f = max(abs(p.x * 6.0), abs(p.y * 0.8));\n    f = min(f, max(abs(p.x * 0.4), abs(p.y * 6.8)));\n    f = min(f, max(abs(p.x * 0.4), abs((p.y - 0.25) * 6.8)));\n    \n    \n    return f - 0.2;\n}\n\nvoid mainImage( out vec4 o, in vec2 p ) {\n    p = (p / iResolution.xy) - 0.5;\n    p.x *= iResolution.x / iResolution.y; \n\n    p *= 3.0;\n    p.y += 0.2;\n    \n    float f = min(legs(p), arms(p));\n    f = smin(f, head(p - vec2(0.6, 1.1)), 0.1);\n    f = smin(f, p.y + 0.9, 0.1);\n    \n    f = min(f, plant(p, vec2(4.0, -0.8)));\n\n    p.y += sin(p.x * 0.2 + iTime);\n    \n    o.rgb = vec3(0.0) + \n        smoothstep(0.00, 0.01, f) * \n        vec3(1.6 * smoothstep(0.00, 0.01, grass(p)), p.y * 6.7, (p.y + 1.3) * 0.5);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 366], [368, 368, 409, 409, 502], [504, 504, 540, 540, 691], [693, 693, 772, 772, 911], [913, 913, 946, 946, 989], [991, 991, 1011, 1011, 1555], [1557, 1557, 1577, 1577, 2283], [2285, 2285, 2305, 2305, 2675], [2677, 2677, 2711, 2711, 2863], [2865, 2865, 2886, 2886, 3194], [3196, 3196, 3237, 3237, 3707]], "test": "untested"}
{"id": "lsGGzG", "name": "4096 ~ Omegusbulb", "author": "MrHenryBemis", "description": "~112129409696904921211~", "tags": ["fractal", "mandelbrot", "hypersphere"], "likes": 3, "viewed": 136, "published": "Public", "date": "1455005801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tEmin Kura - http://emin.me\n*/\n#define iGlobaTime .05*iTime\nvec3 rotate( vec3 pos, float x, float y, float z )\n{\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );\n\tmat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );\n\tmat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );\n\n\treturn rotX * rotY * rotZ * pos;\n}\n\nfloat hit( vec3 r )\n{\n\tr = rotate( r, sin(iTime), cos(iTime), 1.0 );\n\tvec3 zn = vec3( r.xyz );\n\tfloat rad = 0.0;\n\tfloat hit = 0.0;\n\tfloat p = 18.0*iTime;\n\tfloat d = sin(3.0*iTime)*iTime;\n\tfor( int i = 0; i < 10; i++ )\n\t{\n\t\t\n\t\t\trad = length( zn );\n\n\t\t\tif( rad > 4.0 )\n\t\t\t{\t\n\t\t\t\thit = 0.225 * log(rad) * rad / d;\n\t\t\t}else{\n\n\t\t\tfloat th = atan( length( zn.xy ), zn.z );\n\t\t\tfloat phi = atan( zn.y, zn.x );\t\t\n\t\t\tfloat rado = pow(rad,8.0);\n\t\t\td = pow(rad, 6.0) * sin(iTime*.125) * d + 6.0;\n\t\t\t\n\n\n\t\t\tfloat sint = sin( th * p );\n\t\t\tzn.x = rado * sint * cos( phi * p );\n\t\t\tzn.y = rado * sint * sin( phi * p );\n\t\t\tzn.z = rado * cos( th * p ) ;\n\t\t\tzn += r;\n\t\t\t}\n\t\t\t\n\t}\n\t\n\treturn hit;\n\n}\n\nvec3 eps = vec3( .1, 0.0, 0.0 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\t\n\n\tpos.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3( pos, -1.2 );\n\tvec3 la = vec3( 0.0, 0.0, 1.0 );\n\t\n\tvec3 cameraDir = normalize( la - ro );\n\tvec3 cameraRight = normalize( cross( cameraDir, vec3( 0.0, 1.0, 0.0 ) ) );\n\tvec3 cameraUp = normalize( cross( cameraRight, cameraDir ) );\n\t\n\n\tvec3 rd = normalize( cameraDir + vec3( pos, 0.0 ) );\n\n\tfloat t = 0.0;\n\tfloat d = 100.0;\n\t\n\tvec3 r;\n\tvec3 color = vec3(0.0);\n\n\tfor( int i = 0; i < 60; i++ ){\n\t\t\n\t\t\n\t\tif( d > .001 )\n\t\t{\t\n\t\t\tr = ro + rd * t;\n\t\t\td = hit( r );\n\t\t\tt+=d;\t\n\n\t\t}\n\t}\n\n\t  \tvec3 n = vec3( hit( r + eps ) - hit( r - eps ),\n\t  \t\t\thit( r + eps.yxz ) - hit( r - eps.yxz ),\n\t  \t\t\thit( r + eps.zyx ) - hit( r - eps.zyx ) );\n\t \n\t \n\tvec3 mat = vec3( .5, .1, .3 ); \n \tvec3 light = vec3( .5, .5, -2.0 );\n\tvec3 lightCol = vec3(.6, .4, .5);\n\t\n\tvec3 ldir = normalize( light - r );\n  \tvec3 diff = dot( ldir, n ) * lightCol * 60.0;\n\t\n\t\n\tcolor = diff  * mat;\n\t\n    float l = length(color)*sin(iTime*4.409614)*5.5+sin(iTime*2.0);\n    fragColor = vec4( vec3(cos(l), sin(iTime)*cos(l+3.14*5.0/3.0), sin(iTime)*cos(l+3.14*2.0/3.0))*.5+.5, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 63, 115, 115, 409], [411, 411, 432, 432, 1086], [1122, 1122, 1179, 1179, 2325]], "test": "untested"}
{"id": "lsjGDW", "name": "Zag", "author": "OttoVonBismarck", "description": "Found this in my drafts, I think this was an insanely displaced version of my aging apple.  The name \"Zag\" refers to my favorite printf() statement.", "tags": ["raymarching", "zag"], "likes": 1, "viewed": 193, "published": "Public", "date": "1454396591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Paul Kanyuk, derived from 'Apple\" by inigo quilez - 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noiseHash( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nfloat fbmHash( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noiseHash( p ); p = m*p*2.02;\n    f += 0.2500*noiseHash( p ); p = m*p*2.03;\n    f += 0.1250*noiseHash( p ); p = m*p*2.01;\n    f += 0.0625*noiseHash( p );\n\n    return f/0.9375;\n}\n\nfloat age(){\n   return (1.0+sin((iTime*0.25)-(3.14159/2.0)))/2.0;\t\n}\t\n\nfloat doubleAge(){\n   return (1.0+sin((iTime*0.5)-(3.14159/2.0)))/2.0;\t\n}\n\nvec2 map( vec3 p )\n{\n\t\n    float a = atan(p.x,p.z);\n\t//float a = atan(pos.y/pos.x);\n\tfloat u = a/(3.14159/2.0);\n    float r = length(p.xz);\n\tfloat b = acos(p.y/(6.0*r));\n\tfloat f = 1.0-smoothstep( 0.20, 0.35, r );\n\t//return vec3(f,f,f);\n\t//b = min(b+abs(f*(acos(pos.y/(100.0*r)))),1.0);\n\tb = acos(p.y/(10.0*r));\n\tfloat v = (b/(3.14159/2.0))*6.0;\n\tvec3 uvw = vec3(u*1.2,v*1.2,0);\t\n\t\n\n    // mold displacement\t\n    //float mold = (smoothstep( 0.0, 1.0, fbmHash(uvw*2.0) )*0.3) +(smoothstep(0.5,1.0,age())/2.2);\n    //mold = smoothstep( 0.3,1.0,mold);\t\n\tfloat top = 1.0-smoothstep( 0.10, 1.0, r );\n\t//mold = mold*(1.0-top);\n\t\n\tfloat boom = smoothstep(0.0,1.0,fbmHash(p*17.0))*(1.0-top);\n\tboom = boom + 1.5*smoothstep(0.0,1.0,fbmHash(p*2.0))*(1.0-top);\t\t\t  \n\t\n   vec2 d2 = vec2( p.y+0.55, 2.0 );\n\n   p.y -= ((doubleAge()-0.530)*0.75*pow(dot(p.xz,p.xz),0.2))+(boom*0.5);//+(mold*-0.20);//+((stripes-0.5)*0.40);\n   vec2 d1 = vec2( length(p) - 1.0, 1.0 );\n\n   if( d2.x<d1.x) d1=d2;\n   return d1;\n}\n\nvec3 appleColor( in vec3 pos, in vec3 nor, in vec3 pRef, in vec3 nRef, out vec2 spe )\n{\n    spe.x = 1.0;\n    spe.y = 1.0;\n\n    // spherical-ish projection\n    float a = atan(pos.x,pos.z);\n    float u = a/(3.14159/2.0);\n    float r = length(pos.xz);\n    float b = acos(pos.y/(6.0*r));\n    float f = 1.0-smoothstep( 0.20, 0.35, r );\n    b = acos(pos.y/(10.0*r));\n    float v = (b/(3.14159/2.0))*6.0;\n\n    // uvw manifold\n    vec3 uvw = vec3(u*1.2,v*1.2,0);\n\n    // red\n    vec3 col = vec3(1.0,0.0,0.0);\n\n    // green\n    f = smoothstep( 0.1, 1.0, fbm(uvw*1.0)+((1.0-age())*(1.0-age())) );\n    col = mix( col, vec3(0.7,1.0,0.2), f);\n\t\n    //brown\n    float decay = smoothstep(0.75,1.0,age()*age()*age());\n    col = mix( col, vec3(0.7,0.6,0.5), decay);\t\n\n    // dirty\n    f = smoothstep( 0.0, 1.0, fbm(uvw*10.0) );\n\tf = f*(2.0*age());\n    col *= 0.8+0.2*f;\n\n    // frekles\n    f = smoothstep( 0.0, 1.0, fbm(uvw*48.0) );\n    f = smoothstep( 0.7,0.9,f);\n    col = mix( col, vec3(0.9,0.9,0.6), f*0.5 );\n\n    // stripes\n    f = fbm( vec3(a*7.0 + uvw.z,3.0*uvw.y,uvw.x)*2.0);\n\tf = f*(age()*2.0);\n    f = smoothstep( 0.2,1.0,f);\n    f *= smoothstep(0.4,1.2,pos.y + 0.75*(noise(4.0*pos.zyx)-0.5) );\n\tcol = mix( col, vec3(0.4,0.2,0.0), 0.5*f );\n    spe.x *= 1.0-0.35*f;\n    spe.y = 1.0-0.5*f;\n\t\n    // mold\n    float mold = (smoothstep( 0.0, 1.0, fbmHash(uvw*2.0) )*0.6) +(age()/2.2);\n    mold = smoothstep( 0.8,0.9,mold);\n    col = mix( col, vec3(0.9,0.9,0.6), mold*1.0 );\t\n\t\n    //mold stripe\n    float moldStripe = smoothstep(0.4,0.7,mold);\n    moldStripe = moldStripe * (1.0-smoothstep(0.75,1.0,mold));\n    col = mix( col, vec3(0.97,0.97,0.90), moldStripe*1.0 );\n\t\n\n    // top\n    f = 1.0-smoothstep( 0.12, 0.20, r+((fbm(pos*20.0)-0.5)*0.1) );\n\tvec3 topColor = mix(vec3(0.6,0.6,0.5),vec3(0.8,0.8,0.6),fbm(pos*30.0));\n    col = mix( col, topColor, f );\n    spe.x *= 1.0-f;\n\t\n    spe.x = spe.x*(1.0-decay) * (1.0-mold);\n\n    float ao = 0.5 + 0.5*nor.y;\n    col *= ao*1.2;\n\n    return col;\n}\n\nvec3 floorColor( in vec3 pos, in vec3 nor, out vec2 spe )\n{\n    spe.x = 1.0;\n    spe.y = 1.0;\n    vec3 col = vec3(0.5,0.4,0.3)*1.7;\n\n    float f = fbm( 4.0*pos*vec3(6.0,0.0,0.5) );\n    col = mix( col, vec3(0.3,0.2,0.1)*1.7, f );\n    spe.y = 1.0 + 4.0*f;\n\n    f = fbm( 2.0*pos );\n    col *= 0.7+0.3*f;\n\n    // frekles\n    f = smoothstep( 0.0, 1.0, fbm(pos*48.0) );\n    f = smoothstep( 0.7,0.9,f);\n    col = mix( col, vec3(0.2), f*0.75 );\n\n\t\n    // fake ao\n    f = smoothstep( 0.1, 1.55, length(pos.xz) );\n    col *= f*f*1.4;\n    col.x += 0.1*(1.0-f);\n\t\n    return col;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    float t=0.0;\n    float dt = 0.12;\n    float nh = 0.0;\n    float lh = 0.0;\n    float lm = -1.0;\n    for(int i=0;i<45;i++)\n    {\n        vec2 ma = map(ro+rd*t);\n        nh = ma.x;\n        if(nh>0.0) { lh=nh; t+=dt;  } lm=ma.y;\n    }\n\n    if( nh>0.0 ) return vec2(-1.0);\n    t = t - dt*nh/(nh-lh);\n\n    return vec2(t,lm);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float dt = 0.4;\n    float t = mint;\n    for( int i=0; i<8; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        if( h>0.001 )\n            res = min( res, k*h/t );\n        else\n            res = 0.0;\n        t += dt;\n    }\n    return res;\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\n    // camera\n    vec3 ro = (1.0+(iTime*0.01))*normalize(vec3(cos(0.2*sin(iTime)),1.15+0.4*cos(iTime*.11),\n\t\t\t\t\t\t\t\t  sin(0.2*iTime)));\n    vec3 ww = normalize(vec3(0.0,0.5,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    vec3 col = vec3(0.96,0.98,1.0);\n\tcol =vec3(0.26,0.1,0.0);\n    vec2 tmat = intersect(ro,rd);\n    if( tmat.y>0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd,nor);\n        vec3 lig = normalize(vec3(1.0,0.8,-0.6));\n     \n        float con = 1.0;\n        float amb = 0.5 + 0.5*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(0.2 + 0.8*dot(nor,vec3(-lig.x,lig.y,-lig.z)),0.0);\n        float rim = pow(1.0+dot(nor,rd),3.0);\n        float spe = pow(clamp(dot(lig,ref),0.0,1.0),16.0);\n\n        // shadow\n        float sh = softshadow( pos, lig, 0.06, 4.0, 4.0 );\n\n        // lights\n        col  = 0.10*con*vec3(0.80,0.390,0.200);\n        col += 0.70*dif*vec3(1.00,0.97,0.85)*vec3(sh, (sh+sh*sh)*0.5, sh*sh );\n        col += 0.15*bac*vec3(1.00,0.397,0.185);\n        col += 0.20*amb*vec3(0.10,0.05,0.020);\n\n\n        // color\n        vec2 pro;\n        if( tmat.y<1.5 )\n        col *= appleColor(pos,nor, pos, nor ,pro);\n        else\n        col *= floorColor(pos,nor,pro);\n\n        // rim and spec\n        col += 0.60*rim*vec3(0.96,0.1,0.05)*amb*amb;\n        col += 0.60*pow(spe,pro.y)*vec3(1.0)*pro.x*sh;\n\n        col = 0.3*col + 0.7*sqrt(col);\n\t\t\n\t    float r = length(pos.xyz);\n\t    col = mix(col,vec3(0.26,0.1,0.0),smoothstep(0.0,1.0,r/3.5));  \t\t\n\t\t\n    }\n\n\t\n\t\n    col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsjGDW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 267, 290, 290, 329], [332, 332, 362, 362, 767], [769, 769, 795, 795, 999], [1001, 1001, 1022, 1022, 1220], [1222, 1222, 1247, 1247, 1461], [1463, 1463, 1475, 1475, 1531], [1534, 1534, 1552, 1552, 1607], [1609, 1609, 1629, 1629, 2599], [2601, 2601, 2688, 2688, 4581], [4583, 4583, 4642, 4642, 5152], [5154, 5154, 5196, 5196, 5521], [5523, 5523, 5600, 5600, 5868], [5869, 5869, 5901, 5901, 6139], [6141, 6141, 6198, 6198, 8134]], "test": "untested"}
{"id": "lsK3Wh", "name": "flying ellipses", "author": "samuelotherion", "description": "ellipses", "tags": ["ellipses"], "likes": 2, "viewed": 154, "published": "Public", "date": "1454341989", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi  3.14159\n#define ID2 vec2( 1., 0., 0., 1. )\n\nstruct Ellipse {\n    \n    vec2\n        center,\n        size;\n    \n    mat2\n        loc;\n    \n    vec4\n        col;\n};\n\nmat2\n    rot( float p_angle ) {\n        \n        float\n            c = cos( p_angle ),\n            s = sin( p_angle );\n        \n        return mat2( c, s, -s, c );\n    }\n    \nEllipse\n    createEllipse( in vec2 p_center, in float p_width, in float p_height, in float p_angle, in vec4 p_col ) {\n    \n    \treturn Ellipse( p_center, vec2( p_width, p_height ), rot( p_angle ), p_col );\n    }\n\nbool\n    inEllipse( out float p_distSqr, in vec2 p_xy, in Ellipse p_ellipse ) {\n        \n        vec2\n            dst = ( p_ellipse.loc * ( p_ellipse.center - p_xy ) ) * ( 1. /  p_ellipse.size );\n        \n        p_distSqr = dot( dst, dst );\n        \n        return ( p_distSqr < 1. );\n    }\n\nfloat\n    t;\n\nvec2\n    xy;\n\n#define NUM_OF_ELLIPSES 4\n\nEllipse\n    ellipses[ NUM_OF_ELLIPSES ];\n\nvoid\n    init( in vec2 p_xy ) {\n        \n        t = iTime;\n        xy = ( p_xy / iResolution.xy - .5 ) * vec2( iResolution.x / iResolution.y, 1. );\n        \n        ellipses[ 0 ] = createEllipse( vec2( +0., +0. ), .50, .25 , 0., vec4( .3 + .1 * sin( t ), .5 - .4 * sin( t ), .6 + .4 * sin( t ), 1. ) );\n        ellipses[ 1 ] = createEllipse( vec2( +0., +0. ), .50, .50 , 0., vec4( .9 - .2 * sin( t ), .7 + .2 * sin( t ), .2 - .2 * sin( t ), 1. ) );\n        ellipses[ 2 ] = createEllipse( vec2( +0., +0. ), .25, .25 , 0., vec4( .5 - .45 * sin( t ), 0., .5 + .45 * sin( t ), 1. ) );\n        ellipses[ 3 ] = createEllipse( vec2( +0., +0. ), .35, .15 , 0., vec4( .6 + .3 * sin( 2.231 * t ), .5 + .45 * sin( 1.231 * t ), 0., 1. ) );\n    }\n\nvoid\n    animate( ) {\n        \n        float\n            t2 = mod( t, 45. );\n        \n        if( t2 < 5. ) {\n        \n        \tellipses[ 0 ].loc = rot( t ) * ellipses[ 0 ].loc;\n        }\n        else {\n\n\t        if( t2 < 20. ) {\n                \n                ellipses[ 0 ].loc = rot( t ) * ellipses[ 0 ].loc;\n                ellipses[ 0 ].center = .1 + .3 * vec2( cos( t ), sin( t ) );\n                ellipses[ 1 ].loc = rot( 2.1 * t ) * ellipses[ 1 ].loc;\n                ellipses[ 1 ].center = ellipses[ 1 ].center + .3 * vec2( cos( t ), sin( t ) );\n                ellipses[ 1 ].size = vec2( .5 + .2 * cos( .6 * t ), .5 + .2 * sin( .6 * t ) ); \n            }\n            else {\n                \n                ellipses[ 0 ].loc = rot( t ) * ellipses[ 0 ].loc;\n                ellipses[ 0 ].center = .2 * vec2( cos( t ), sin( t ) );\n                ellipses[ 1 ].loc = rot( 2.1 * t ) * ellipses[ 1 ].loc;\n                ellipses[ 1 ].center = ellipses[ 0 ].center + .3 * vec2( cos( t ), sin( t ) );\n                ellipses[ 1 ].size = vec2( .5 + .2 * cos( .6 * t ), .5 + .2 * sin( .6 * t ) ); \n                ellipses[ 2 ].loc = rot( 4.1 * t ) * ellipses[ 2 ].loc;\n                ellipses[ 2 ].center = ellipses[ 1 ].center + .2 * vec2( cos( 3. * t ), sin( 3. * t ) );\n                ellipses[ 2 ].size = vec2( .5 + .2 * cos( 3.6 * t ), .5 + .2 * sin( 3.6 * t ) ); \n                ellipses[ 3 ].loc = rot( -2.1 * t ) * ellipses[ 2 ].loc;\n                ellipses[ 3 ].center = ellipses[ 2 ].center + .2 * vec2( cos( 4. * t ), sin( 4. * t ) );\n                ellipses[ 3 ].size = vec2( .2 + .1 * cos( 1.6 * t ), .2 + .1 * sin( 1.6 * t ) ); \n            }\n        }\n    }\n\nvec4\n    mixAll( ) {\n        \n        vec4\n            col = vec4( 0. );\n        \n        float\n            dist = 10000.;\n        \n        for( int i = 0; i < NUM_OF_ELLIPSES; i++ ) {\n            \n            if( inEllipse( dist, xy, ellipses[ i ] ) ) {\n\n                col += ellipses[ i ].col * sqrt( 1. - dist );\n            }\n        }\n        \n        if( col.a < 1.01 - cos( .5 * t ) ) {\n        \t\n              col = vec4( .01, .02, .04,  1. );\n        }\n//        else {\n        \n        \t//col /= col.a;\n//        }\n        \n        return col;\n    }\n\n\nvoid \n    mainImage( out vec4 p_col, in vec2 p_xy ) {\n        \n        init( p_xy );\n        \n        animate( );\n        \n        p_col = mixAll( );\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsK3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 206, 206, 344], [350, 350, 467, 467, 561], [563, 563, 642, 642, 854], [953, 953, 984, 984, 1687], [1689, 1689, 1710, 1710, 3373], [3375, 3375, 3395, 3395, 3936], [3939, 3939, 3992, 3992, 4099]], "test": "untested"}
{"id": "lsKGzt", "name": "Torch", "author": "834144373", "description": "Hopeful...", "tags": ["2d", "cartoon", "torch", "hopeful"], "likes": 0, "viewed": 994, "published": "Public API", "date": "1455999601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool Is(vec2 uv,lowp vec2 A,lowp vec2 B,lowp vec2 C){\n    lowp vec3 AB,BC,AC;\n    return dot(cross(AB = vec3(B-A,0.),vec3(uv-A,0.)),cross(AB, AC = vec3(C-A,0.)))>0. && dot(cross(BC = vec3(C-B,0.),vec3(uv-B,0.)),cross(BC,-AB))>0. && dot(cross(-AC,vec3(uv-C,0.)),-cross(AC,BC))>0.; \n}\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    vec2 uv = ( u*2.- iResolution.xy)/iResolution.y;\n\tvec2 uv2 = uv;\n\tuv.x = abs(uv.x);\n\tif(Is(uv,vec2(0.,-0.035),vec2(0.2,-0.18),vec2(0.5,0.43)) || Is(uv,vec2(0.),vec2(0.16,1.5),vec2(0.1,0.)) || Is(uv2,vec2(0.,0.587),vec2(-0.1,0.55),vec2(0.,0.64))){\n\t\tf = pow(vec4( uv+0.7,1.,1.0 )/1.23,vec4(1.3));\n    }else{\n        f = vec4(1.-length(uv+vec2(0.,-1.4))/2.4);\n        f *= vec4(0.1,0.2,0.25,0.)*(1.7+2.+1.4*sin(iTime));\n        f = pow(f,vec4(1.));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 282], [284, 284, 325, 325, 784]], "test": "untested"}
{"id": "lsV3DV", "name": "water badge", "author": "bostelk", "description": "a simple sketch", "tags": ["2d"], "likes": 2, "viewed": 125, "published": "Public", "date": "1456599144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// constant thickness by iq: https://www.shadertoy.com/view/MdfGWn\n// udRoundBox by iq too.\n\n#define rgb(r,g,b) vec3(r,g,b)/255.\n\nfloat wave1(vec2 p)\n{\n    return length(p - vec2(p.x, .4 * cos(p.x*3. + iTime)));\n}\n\nfloat wave2(vec2 p)\n{\n    float f = wave1(p);\n    float e = 2.0/iResolution.y;\n    float g = length( vec2(wave1(p+vec2(e,0.0))-wave1(p-vec2(e,0.0)),\n                           wave1(p+vec2(0.0,e))-wave1(p-vec2(0.0,e))) )/(2.0*e);\n    return f/ g;\n}\n\nfloat udRoundBox( vec2 p, vec2 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n  \n    uv *= 2.;\n    \n    float f0 = wave2(uv + vec2(0., -1.1));\n    float f1 = wave2(uv + vec2(0., -.4));\n    float f2 = wave2(uv + vec2(0., .4));\n    float f3 = wave2(uv + vec2(0., 1.1));\n\n    float f = min(min(min(f0,f1),f2),f3);\n    f = 1.0-smoothstep( 0.1, 0.11, f );\n    \n    uv *= 0.5;\n    \n    float f6 = 1.-smoothstep( 0.1, 0.107,udRoundBox(uv, vec2(0.5,0.5),0.25));\n    float f7 = 1.-smoothstep( 0.1, 0.107,udRoundBox(uv, vec2(0.5,0.5),0.35));\n    float f8 = f7 - f6;\n    \n    f = min(f,f6);\n    f = f + f8;\n    \n    vec3 c = (1. - f) * vec3(.97) + f * rgb(0.,172.,242.);\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsV3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 130, 151, 151, 213], [215, 215, 236, 236, 463], [465, 465, 510, 510, 552], [554, 554, 611, 611, 1288]], "test": "untested"}
{"id": "lsV3Wh", "name": "2dlight", "author": "AntonLobanov", "description": "2dlight", "tags": ["2dlight"], "likes": 10, "viewed": 223, "published": "Public", "date": "1454338013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 HEIGHT_VECTOR = vec4(1.0/3.0, 1.0/3.0, 1.0/3.0, 0.0);\nfloat bumpStrength = 1.0;\nfloat diffuseFactor = 2.0;\nvec4 diffuseMaterial = vec4(1.0, 0.0, 0.0, 1.0);\nfloat diffuseStrength = 1.0;\nfloat specularFactor = 50.0;\nvec4 specularMaterial = vec4(1.0, 1.0, 1.0, 1.0);\nfloat specularStrength = 1.0;\n\nfloat getHeight(sampler2D channel, vec2 offset) \n{\n\treturn dot(texture(channel, offset), HEIGHT_VECTOR);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 step = vec2(1.0, 1.0) / iResolution.xy;\n    vec2 uv = fragCoord.xy * step;\n    \n    // normal generation\n    float upHeight = getHeight(iChannel1, uv + vec2(0, -step.y));\n\tfloat bottomHeight = getHeight(iChannel1, uv + vec2(0, step.y));\n\tfloat leftHeight = getHeight(iChannel1,  uv + vec2(-step.x, 0));\n\tfloat rightHeight = getHeight(iChannel1, uv + vec2(step.x, 0));\n\tfloat dx = (rightHeight - leftHeight) * bumpStrength;\n\tfloat dy = (bottomHeight - upHeight) * bumpStrength;\n\tfloat dz = sqrt(1.0 - dx*dx - dy*dy);\t\n\tvec3 normal = vec3(dx,dy,dz);\n    \n    // light pos calculation\t\n    vec2 pos = vec2((sin(iTime) + 1.0) * 0.5, (sin(iTime*2.0) + 1.0) * 0.5);\n    if(iMouse.z > 0.) pos = iMouse.xy * step;\n    \n    // light calculation\n    vec3 light = normalize(vec3(pos - uv, 1.0));\n    float shininess = log2(max(dot(normal, light), 0.0));\n    vec4 diffuse = diffuseMaterial * diffuseStrength * exp2(shininess * diffuseFactor);\n    vec4 specular = specularMaterial * specularStrength * exp2(shininess* specularFactor);\n\tfragColor = texture(iChannel0, uv) * diffuse + specular;\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsV3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 300, 350, 350, 406], [412, 412, 469, 469, 1560]], "test": "untested"}
{"id": "lsVGWh", "name": "Wedge", "author": "sillsm", "description": "x", "tags": ["2d"], "likes": 0, "viewed": 120, "published": "Public", "date": "1454321658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Max Sills 2016\n// Licensed under the MIT license.\n#define PI 3.14159265359\n\nfloat radToAngle(float r){\n    return mod(r *(180./PI), 360.);\n}\n\nfloat wedge(float low, float high, float current){ \n    float midpoint = mod(high-low,360.)/2.;        \n    float a        = mod(current - low,360.);   \n    return clamp(abs(midpoint - a)/midpoint, 0., 1.) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5,0.5);\n\n    //Calculate the angle from the center.\n    float angle = atan(uv.y,uv.x);\n    float time = iTime * 100.;\n    fragColor = vec4(0.3);\n    fragColor = mix(vec4(1.), fragColor, wedge(time, time+20., radToAngle(angle)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVGWh.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 79, 105, 105, 143], [145, 145, 195, 195, 354], [356, 356, 413, 413, 694]], "test": "untested"}
{"id": "lsVGzd", "name": "Wind Ripple", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 4, "viewed": 198, "published": "Public", "date": "1456031838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.14159265359\n#define PIH PI/2.0\n\nmat2 rotate(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 lookat(in vec3 eye, in vec3 target)\n{\n\tvec3 w = normalize(target-eye);\n\tvec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n\tvec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nfloat gaussian(in float t)\n{\n    return exp(-t*t);\n}\n\nvec2 fold(in vec2 p, in float a)\n{\n    p.x = abs(p.x);\n    vec2 v = vec2(cos(a),sin(a));\n    for(int i=0;i<6;i++)\n    {\t\n    \tp -= 2.0*min(0.0,dot(p,v))*v;\n    \tv = normalize(vec2(v.x-1.0,v.y));\n    }\n \treturn p;    \n}\n\nfloat map(in vec3 p)\n{   \n    float t = iTime*0.2;\n \tfloat de = length(p)-1.0;\n    de -= 0.015*gaussian(fold(p.xy*50.0,t+PIH).x);\n    de -= 0.015*gaussian(fold(p.yz*50.0,t-PIH).x);\n    de -= 0.015*gaussian(fold(p.zx*50.0,t).x);    \n    return de;\n}\n\nvec3 doColor(in vec3 p)\n{\n    return normalize(abs(p));\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.001;\n    return normalize(\n        e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n        e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p2 = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.8);\n    vec3 rd = normalize(vec3(p2,2.0));\n    ro.xz *= rotate(iTime*0.3);\n    rd = lookat(ro, vec3(0.0))*rd;\n    float maxd = 10.0;\n    float t = 0.0, d;\n    for(int i=0;i<64;i++)\n    {\n        t += d = map(ro+rd*t);\n        if(d<0.001 || t>maxd) break;\n    }\n    if(t<maxd)\n    {\n        vec3 p = ro+t*rd;\n        vec3 nor = calcNormal(p);\n\t\tcol = doColor(p);\n\t\tvec3 li = normalize(vec3(2.0,3.0,3.0));\n        float dif = clamp(dot(nor,li),0.0,1.0);\n        float amb = max(0.5+0.5*nor.y,0.0);\n        float spc = pow(clamp(dot(reflect(rd, nor),li),0.0,1.0),10.0);\n        col *= clamp(0.0,1.0,max(dif,0.3)*amb+spc);\n        col = mix(vec3(1.0),col,exp(-t*t*0.0015));\n\t\tcol = pow(col, vec3(0.7));\n    }\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 68, 68, 126], [128, 128, 170, 170, 311], [313, 313, 341, 341, 365], [367, 367, 401, 401, 585], [587, 587, 609, 609, 835], [837, 837, 862, 862, 894], [896, 896, 926, 926, 1089], [1091, 1091, 1148, 1148, 2000]], "test": "untested"}
{"id": "lsVGzK", "name": "Gamma correctness: lights", "author": "Zavie", "description": "Illustrating the effect of gamma space in shading. Without gamma correction on the left ; with gamma correction on the right (hint: the right is the one you want). Notice how the light adds up when the two spot lights intersect.\n\nClick and drag to control", "tags": ["raytracing", "sphere", "gamma", "gammacorrection", "linear", "lights"], "likes": 7, "viewed": 784, "published": "Public API", "date": "1455434688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis shader demonstrates the effect of gamma\ncorrection in rendering.\n\nInspired by:\nhttp://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/\n\nMove the mouse to see the difference between\nshading with no gamma correction (on the left)\nand with gamma correction (on the right).\n\nSee also: https://www.shadertoy.com/view/llBGz1\n\n--\nZavie\n\n*/\n\n#define MAX_BOUNCES 2\nfloat gamma = 2.2;\n\n// ---8<----------------------------------------------------------------------\n// Material\n\nstruct Material\n{\n    vec3 c;\t\t// diffuse color\n    float f0;\t// specular color (monochrome)\n};\n\n// ---8<----------------------------------------------------------------------\n// Geometry\n\nstruct Ray\n{\n    vec3 o;\t\t// origin\n    vec3 d;\t\t// direction\n};\n\nstruct Hit\n{\n    float t;\t// solution to p=o+t*d\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\nconst Hit noHit = Hit(1e10, vec3(0.), Material(vec3(-1.), -1.));\n\nstruct Plane\n{\n    float d;\t// solution to dot(n,p)+d=0\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\n\nstruct Sphere\n{\n\tfloat r;\t// radius\n    vec3 p;\t\t// center position\n    Material m;\t// material\n};\n\nHit intersectPlane(Plane p, Ray r)\n{\n    float dotnd = dot(p.n, r.d);\n    if (dotnd > 0.) return noHit;\n\n    float t = -(dot(r.o, p.n) + p.d) / dotnd;\n    return Hit(t, p.n, p.m);\n}\n\nHit intersectSphere(Sphere s, Ray r)\n{\n\tvec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n\n    return Hit(t, (r.o + t*r.d - s.p) / s.r, s.m);\n}\n\nbool compare(inout Hit a, Hit b)\n{\n    if (b.m.f0 >= 0. && b.t < a.t)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nHit intersectScene(Ray r)\n{\n    Sphere s = Sphere(1., vec3(0., 1., 0.), Material(vec3(1.0), 0.04));\n    Plane p  = Plane(0., vec3(0., 1., 0.), Material(vec3(1.0), 0.04));\n\n    Hit hit = noHit;\n    compare(hit, intersectPlane(p, r));\n    compare(hit, intersectSphere(s, r));\n    return hit;\n}\n\n// ---8<----------------------------------------------------------------------\n// Lights\n\nstruct DirectionalLight\n{\n    vec3 d;\t\t// Direction\n    vec3 c;\t\t// Color\n};\n\nstruct SpotLight\n{\n    vec3 p;\t\t// Position\n    vec3 d;\t\t// Direction\n    float fa;\t// Falloff start cos\n    float fb;\t// Falloff end cos\n    vec3 c;\t\t// Color\n};\n\nDirectionalLight sunLight = DirectionalLight(normalize(vec3(-2., 1., 1.)), vec3(.1));\nSpotLight spotLights[2];\n\nvoid InitLights()\n{\n    float t = abs(fract(.2*iTime)*2.-1.);\n    spotLights[0] = SpotLight(vec3(mix(-1.5, -0.2, t), 3., 1.), vec3(0., -1., 0.), .9, .902, vec3(1.));\n    spotLights[1] = SpotLight(vec3(mix(+1.5, +0.2, t), 3., 1.), vec3(0., -1., 0.), .9, .95, vec3(1.));\n}\n\nvec3 skyColor(vec3 d)\n{\n    return vec3(0.01);\n}\n\nfloat pow5(float x) { return x * x * x * x * x; }\n\n// Schlick approximation\nfloat fresnel(vec3 h, vec3 v, float f0)\n{\n  return pow5(1. - clamp(dot(h, v), 0., 1.)) * (1. - f0) + f0;\n}\n\nfloat epsilon = 4e-4;\n\nvec3 accountForDirectionalLight(vec3 p, vec3 n, DirectionalLight l)\n{\n    if (intersectScene(Ray(p + epsilon * l.d, l.d)).m.f0 < 0.)\n    {\n        return clamp(dot(n, l.d), 0., 1.) * l.c;\n    }\n    return vec3(0.);\n}\n\nvec3 accountForSpotLight(vec3 p, vec3 n, SpotLight l)\n{\n    vec3 d = normalize(l.p - p);\n    float sqrDist = dot(l.p - p, l.p - p);\n    Hit test = intersectScene(Ray(p + epsilon * d, d));\n\n    if (test.t * test.t > sqrDist)\n    {\n        float atten = smoothstep(l.fa, l.fb, dot(l.d, -d)) / sqrDist;\n        return atten * clamp(dot(n, d), 0., 1.) * l.c;\n    }\n    return vec3(0.);\n}\n\nvec3 radiance(Ray r)\n{\n    vec3 accum = vec3(0.);\n    vec3 attenuation = vec3(1.);\n\n    for (int i = 0; i <= MAX_BOUNCES; ++i)\n    {\n        Hit hit = intersectScene(r);\n\n        if (hit.m.f0 >= 0.)\n        {\n            float f = fresnel(hit.n, -r.d, hit.m.f0);\n\n            vec3 hitPos = r.o + hit.t * r.d;\n\n            // Diffuse\n            vec3 incoming = vec3(0.);\n            incoming += accountForDirectionalLight(hitPos, hit.n, sunLight);\n            incoming += accountForSpotLight(hitPos, hit.n, spotLights[0]);\n            incoming += accountForSpotLight(hitPos, hit.n, spotLights[1]);\n\n            accum += (1. - f) * attenuation * hit.m.c * incoming;\n\n            // Specular: next bounce\n            attenuation *= f;\n            vec3 d = reflect(r.d, hit.n);\n            r = Ray(r.o + hit.t * r.d + epsilon * d, d);\n        }\n        else\n        {\n            accum += attenuation * skyColor(r.d);\n            break;\n        }\n    }\n    return accum;\n}\n\n// ---8<----------------------------------------------------------------------\n// Scene\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitLights();\n\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n\n    vec3 color = vec3(0.);\n    for (int i = 0; i < 4; ++i)\n    {\n        vec3 p0 = vec3(0., 1.1, 4.);\n        vec3 p = p0;\n        //vec3 p = vec3(0., (2. * (iMouse.y==0.?.5*iResolution.y:iMouse.y) / iResolution.y - 1.), 0.) + p0;\n        vec3 offset = vec3(msaa[i] / iResolution.y, 0.);\n        vec3 d = normalize(vec3(iResolution.x/iResolution.y * uv.x, uv.y, -1.5) + offset);\n        Ray r = Ray(p, d);\n        color += radiance(r) / 4.;\n    }\n\n    float compareLimit = (iMouse.z > 0. ? iMouse.x : abs(fract(0.1*iTime) * 2. - 1.) * iResolution.x);\n\tif (compareLimit < fragCoord.x)\n        fragColor = vec4(pow(color, vec3(1./gamma)),1.0);\n    else\n        fragColor = vec4(color*2.,1.0); // Fudge x2 factor to compensate for darkened result.\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[604, 1142, 1178, 1178, 1323], [1325, 1325, 1363, 1363, 1652], [1654, 1654, 1688, 1688, 1791], [1793, 1793, 1820, 1820, 2084], [2086, 2530, 2549, 2549, 2800], [2802, 2802, 2825, 2825, 2850], [2852, 2852, 2873, 2873, 2901], [2903, 2928, 2969, 2969, 3034], [3059, 3059, 3128, 3128, 3275], [3277, 3277, 3332, 3332, 3660], [3662, 3662, 3684, 3684, 4631], [4633, 4722, 4779, 4779, 5782]], "test": "untested"}
{"id": "lsVGzt", "name": "Shadow casting 2D point lights", "author": "dine909", "description": "An experiment using raymarching in a 2d world to map light casted to a point.  The idea was to use the same sdf map function to draw the solids, and cast the shadows.  \n\nIt's not very accurate, but was fun to write.\n\nMousing encouraged.", "tags": ["2d", "light", "shadows"], "likes": 10, "viewed": 488, "published": "Public", "date": "1456002374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nconst vec2 constantList = vec2(1.0, 0.0);\n\nfloat antiAlias(float x) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.0);}\n\nfloat asrat;\nstruct Obj{    int type;    vec3 col;    vec2 pos;    float emis;}T_Obj;\nstruct Hit{    float d,t;    vec2 pos;    Obj obj;}T_Hit;\nstruct Ray{    vec2 ro,rd;    float tmin,tmax;}T_Ray;\nconst Obj NoObj=Obj(-1,vec3(0.),vec2(0.),0.);\nconst Hit NoHit=Hit(400.,400.,vec2(0.),NoObj);\n\nfloat sdCircle(vec2 p){    return distance(p,vec2(0.));}\nfloat sdBox(vec2 p, vec2 size, float radius)\n{\n    vec2 d = abs(p) - size-vec2(radius);\n    return clamp(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius,0.,1.);\n}\n\nHit renderSdf(vec2 p,inout Obj o)\n{\n    Hit hit=NoHit;\n    if(o.type==1) hit= Hit(sdCircle(p-o.pos),0.,p,o);\n    if(o.type==2) hit= Hit(sdBox(p-o.pos,vec2(0.02),0.),090.1,p,o);\n    return hit;\n}\nHit sdU(in Hit a,vec2 p,in Obj d)\n{\n    Hit hit=renderSdf(p,d);\n    if (a.d<hit.d) \n        return (a); else return (hit);\n}\n\nHit map(vec2 p, in Obj oo)\n{\n\t//----8<----- SOLIDS ----8<-----//\n\n    const vec3 solidCol=vec3(0.95,0.57,0.);\n\n    Hit hit=NoHit;\n    hit=sdU(hit,p,Obj(1,solidCol,vec2(0.5*asrat,0.5),0.));\n    hit=sdU(hit,p,Obj(1,solidCol,vec2(0.5*asrat,0.8),0.));\n    hit=sdU(hit,p,Obj(2,solidCol,vec2(0.53*asrat,0.2),0.));\n    hit=sdU(hit,p,Obj(2,solidCol,vec2(0.53*asrat,0.3),0.));\n    hit=sdU(hit,p,Obj(2,solidCol,vec2(0.47*asrat,0.2),0.));\n    hit=sdU(hit,p,Obj(2,solidCol,vec2(0.47*asrat,0.3),0.));\n    return hit;\n}\n\nvec3 render(vec3 incol,inout Hit hit)\n{\n    float aares=clamp(antiAlias(smoothstep(((1.-hit.d)), .977, 0.)),0.,1.);\n    if(aares==0.)\n    {\n        hit=NoHit;    \n    }\n    return mix(incol,hit.obj.col,aares);\n}\nHit castRay(in Ray ray){\n    float precis =.023;\n    float t = ray.tmin;\n    Hit hit=NoHit;\n    vec2 p;\n    for( int i=0; i<200; i++ )\n    {\n        p=ray.ro+ray.rd*t;\n        hit = map( p,NoObj );\n        if( hit.d<precis || t>ray.tmax ) break;\n        t += hit.d;\n    }\n    hit.t=t;\n\n    if( t>ray.tmax ) return NoHit;\n    return hit;\n\n}\nfloat getFloor(vec2 uv){    return mod( floor(32.0*(uv.x/asrat)) + floor(18.0*(uv.y)), 2.0);}\n\nvec3 getLight(vec2 uv, Obj light)\n{\n    float rot=atan(uv.y-light.pos.y, uv.x-light.pos.x);\n    Hit hit=castRay(Ray(light.pos.xy,vec2(sin(rot),cos(rot)).yx,.0001,distance(light.pos,uv)));\n\n    render(vec3(0.),hit);\n\n    float lamnt=10.5*distance(uv,light.pos);\n    lamnt=pow((1.2/(lamnt*lamnt)),.5)*0.39*light.emis;\n\n    vec3 lcol=vec3(0.01);        \n    if(hit==NoHit)\n    {\n        lcol+=light.col*lamnt;\n    }\n\n    lcol-=lamnt*light.col*0.5*getFloor(uv);\n\n\n    return lcol;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 um = iMouse.xy / iResolution.xy;\n    vec4 col = vec4(0.0);\n\n    asrat=iResolution.x/iResolution.y;\n\n    if(iMouse.z<0.5)\n    {\n        um=0.5+0.4*vec2(sin(iTime),cos(iTime));\n    }\n\n    uv.x*=asrat;um.x*=asrat;\n\n    Hit hit=map(uv,NoObj);\n    col.rgb +=render(vec3(0.),hit);\n\n    if(hit==NoHit)\n    {\n        //----8<----- LIGHTS ----8<-----//\n\n        col.rgb+=getLight(uv, Obj(1,vec3(0.5,1.,.5),um,1.));\n        col.rgb+=getLight(uv, Obj(1,vec3(1.,.5,.5),vec2(asrat-um.x,1.-um.y),2.));\n    }\n\n    fragColor = col.xyzw * constantList.xxxy + constantList.yyyx;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 95, 95, 151], [445, 445, 468, 468, 501], [502, 502, 548, 548, 671], [673, 673, 708, 708, 867], [868, 868, 903, 903, 992], [994, 994, 1022, 1058, 1499], [1501, 1501, 1540, 1540, 1712], [1713, 1713, 1737, 1737, 2052], [2053, 2053, 2077, 2077, 2146], [2148, 2148, 2183, 2183, 2626], [2627, 2627, 2684, 2684, 3301]], "test": "untested"}
{"id": "lsVGzV", "name": "My love for you is like...", "author": "onidaito", "description": "Ray marched heart that follows the equation here:\nhttp://archive.section9.co.uk/misc/heart.html", "tags": ["raymarch", "heart"], "likes": 2, "viewed": 146, "published": "Public", "date": "1455473565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// The formula for a heart\n\nfloat heartFormula(vec3 pos){\n  float EPISLON = 0.000001;\n\n  float a = (pos.x * pos.x) + (9.0/4.0 * pos.z * pos.z) + pos.y * pos.y - 1.0;\n  a = a * a * a;\n  float b = pos.x * pos.x * pos.y * pos.y * pos.y;\n  float c = 9.0/80.0 * pos.z * pos.z * pos.y * pos.y * pos.y;\n  float d = a - b - c;\n\n  return d - EPISLON;\n}\n\n// Given an origin and a normalized direction, shoot off a ray and raymarch\n\nfloat castRay(vec3 rayOrigin, vec3 rayDirection ){\n\n  float prevdist = 0.0;\n  for( float t = 0.001; t < 4.0; t += 0.07) {\n\n    vec3 p = rayOrigin + rayDirection * t;\n\n    vec3 translate = vec3(sin(iTime), 0.0, cos(iTime) / 2.5 );\n\n    float dist = heartFormula(p - translate);\n\n    if (dist < 0.0 && prevdist > 0.0){\n      return t;\n    }\n\n    prevdist = dist;\n  }\n  return 100.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n  // Convert the frag coord into its -1 to 1 representation\n\n  vec2 q = gl_FragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x/iResolution.y;\n\n\n  // We assume the screen is at 0 in distance and our camera is behind it\n  float xp = 0.0;\n  float zp = -1.5;\n\n  vec3 camera = vec3(xp,0.0,zp);\n  vec3 screen = vec3(p.x-xp,p.y,-1.1);\n\n  // A quick optimisation to make sure the ray starts at the screen\n\n  vec3 diff = screen - camera;\n  vec3 dir = normalize(diff);\n  float dist = length(diff);\n\n  float val = castRay(camera + dir * dist, dir);\n\n  val = clamp(1.0 - val,0.0,1.0);\n\n  fragColor = vec4( val,0.1,0.1, val );\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 30, 59, 59, 345], [347, 424, 474, 474, 806], [809, 809, 866, 932, 1521]], "test": "untested"}
{"id": "lsVGzy", "name": "First attempt at making snow", "author": "twbmsp", "description": "It isn't pretty but it's fast (at least on my old 40$ GPU where it runs at 60fps)...maybe I should try to add some layers at some point. :/", "tags": ["fast", "random", "snow"], "likes": 2, "viewed": 412, "published": "Public", "date": "1455221548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\n\nconst float FALL_SPEED = 0.27;\n\nconst float W = 21.0;\n\nconst float H = 9.0;\n\nconst vec3 SNOW = vec3(255.0, 255.0,255.0) / 255.0;\nconst vec3 BACK = vec3(21.0, 21.0, 35.0) / 255.0;\n\nfloat static_rand(vec2 seed)\n{\n    return fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(const float timeShift, const float index, const float timeStep)\n{\n    float f = floor((iTime + timeShift) / timeStep);\n    \n    vec2 v = vec2(mod(f + index, iResolution.y),\n                  mod(f - index, iResolution.x));\n    \n    return static_rand(v);\n}\n\nfloat continuousRand(const float index, const float timeStep)\n{\n    float c00 = 0.5 *       rand(0.0     , index, timeStep);\n    float c10 = 0.5 *       rand(timeStep, index, timeStep);\n    float c01 = 2.0 * PI  * rand(0.0     , index + 0.5, timeStep);\n    float c11 = 2.0 * PI  * rand(timeStep, index + 0.5, timeStep);\n    \n    float t = 0.5 + 0.5 * sin(PI * (fract(iTime / timeStep) - 0.5));\n    \n    return (1.0 - t) * c00 * sin(iTime / timeStep + c01) +\n                  t  * c10 * sin(iTime / timeStep + c11);\n    \n}\n\nvec2 plot(float i, float j)\n{\n    float x = (i + 0.5) / W;\n    float y = (j + 0.5) / H;\n    \n    y -= iTime * FALL_SPEED;\n    \n    float dx = 0.65 * continuousRand(j * W + i, 5.0);\n    float dy = 0.65 * continuousRand(i * H + j, 5.0);\n    \n    dx = sin(dx * 0.5 * PI);\n    dy = sin(dy * 0.5 * PI);\n    dx = sin(dx * 0.5 * PI);\n    dy = sin(dy * 0.5 * PI);\n    dx = sin(dx * 0.5 * PI);\n    dy = sin(dy * 0.5 * PI);\n    \n    float fx = max(0.0, 0.7 - abs(dx));\n    float fy = max(0.0, 0.7 - abs(dy));\n    \n    dx += 3.0 * fx * continuousRand(i * W + j * H, 1.5);\n    dy += 3.0 * fy * continuousRand(i * H + j * W, 2.0);\n    \n    x += dx * 0.5 / W;\n    y += dy * 0.5 / H;\n\n    return vec2(x, fract(y));\n}\n\nvec2 distanceField(vec2 p)\n{\n    float rj = (p.y + iTime * FALL_SPEED) * H;\n    \n    float i = p.x * W;\n    float j = mod(rj, H);\n    \n    float fi = floor(i);\n    float fj = floor(j);\n    \n    float rd = static_rand(vec2(fi * W + floor(rj), 0.0));    \n    float sr = 1.0 + sign(rd - 0.65); \n    \n    float theta = 4.0 * PI * continuousRand(fi * W + fj, 1.0);\n    float s1 = continuousRand(fi * W + fj * H, 1.1);\n    float s2 = continuousRand(fj * H + fi, 0.2);\n    \n    mat2 rot2 = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    \n    vec2 d = p - plot(fi,fj);\n    \n    d *= rot2;\n    \n    d.x /= pow((1.0 - abs(s1)), 0.3);\n    d.y /= 2.0 * pow(abs(s1), 0.3);\n    \n    float fieldx = sr + length(d) * (1.1 + pow(rd, 0.3));\n     \n    float fieldy = pow(abs(s2), 0.4);\n    \n    return vec2(fieldx, fieldy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    vec2 df = distanceField(p);\n    \n    float o = smoothstep(0.0, 0.009, df.x);\n    \n\tfragColor = vec4(o * BACK + (1.0 - o) * (BACK * df.y + SNOW * (1.0 - df.y)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 237, 237, 311], [313, 313, 389, 389, 580], [582, 582, 645, 645, 1104], [1106, 1106, 1135, 1135, 1807], [1809, 1809, 1837, 1837, 2627], [2629, 2629, 2686, 2686, 2907]], "test": "untested"}
{"id": "lsy3DK", "name": "Distance Field Text: Yandex", "author": "kashey", "description": "Based on https://www.shadertoy.com/view/4lsSzX", "tags": ["retro", "sdf", "fork"], "likes": 4, "viewed": 291, "published": "Public", "date": "1456409646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define SHOW_DISTANCE\n\n#define BACK_COL_TOP vec3(1,0,1)\n#define BACK_COL_BOTTOM vec3(0,0,1)\n\n#define TEXT_COL1_TOP vec3(0.05, 0.05, 0.40)\n#define TEXT_COL1_BOTTOM vec3(0.60, 0.90, 1.00)\n#define TEXT_COL2_TOP vec3(0.10, 0.10, 0.00)\n#define TEXT_COL2_BOTTOM vec3(1.90, 1.30, 1.00)\n\n//--- Primiives ---\nfloat dfSemiArc(float rma, float rmi, vec2 uv)\n{\n\treturn max(abs(length(uv) - rma) - rmi, uv.x-0.0);\n}\n\n//p0 = bottom left, clockwise winding\nfloat dfQuad(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv)\n{\n\tvec2 s0n = normalize((p1 - p0).yx * vec2(-1,1));\n\tvec2 s1n = normalize((p2 - p1).yx * vec2(-1,1));\n\tvec2 s2n = normalize((p3 - p2).yx * vec2(-1,1));\n\tvec2 s3n = normalize((p0 - p3).yx * vec2(-1,1));\n\t\n\treturn max(max(dot(uv-p0,s0n),dot(uv-p1,s1n)), max(dot(uv-p2,s2n),dot(uv-p3,s3n)));\n}\n\nfloat dfRect(vec2 size, vec2 uv)\n{\n\treturn max(max(-uv.x,uv.x - size.x),max(-uv.y,uv.y - size.y));\n}\n//-----------------\n\n//--- Letters ---\nvoid S(inout float df, vec2 uv)\n{\n\tdf = min(df, dfSemiArc(0.25, 0.125, uv - vec2(-0.250,0.250)));\n\tdf = min(df, dfSemiArc(0.25, 0.125, (uv - vec2(-0.125,-0.25)) * vec2(-1)));\n\tdf = min(df, dfRect(vec2(0.125, 0.250), uv - vec2(-0.250,-0.125)));\n\tdf = min(df, dfQuad(vec2(-0.625,-0.625), vec2(-0.500,-0.375), vec2(-0.125,-0.375), vec2(-0.125,-0.625), uv));\t\n\tdf = min(df, dfQuad(vec2(-0.250,0.375), vec2(-0.250,0.625), vec2(0.250,0.625), vec2(0.125,0.375), uv));\n}\n\nvoid N(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.000,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.375,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n}\n\nvoid A(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 0.825), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfRect(vec2(0.250, 0.825), uv - vec2(-0.000,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.375,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(0.1875,-0.1875)) * -1.0));\n}\n\nvoid D(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.25), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfSemiArc(0.5, 0.125, (uv.xy * vec2(-1,1) - vec2(0.375,-0.00))));\n}\n\nvoid E(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.625,-0.625)));    \n    df = min(df, dfQuad(vec2(-0.375,-0.625), vec2(-0.375,-0.375), vec2(0.250, -0.375), vec2( 0.125,-0.625), uv));\t\n    df = min(df, dfQuad(vec2(-0.375,0.375), vec2(-0.375,0.625), vec2(0.250, 0.625), vec2(0.125, 0.375), uv));\t   \n    df = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.375,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n}\n\nvoid R(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfSemiArc(0.25, 0.125, (uv.xy * vec2(-1,1) - vec2(0.125,0.25))));    \n    df = min(df, dfRect(vec2(0.25, 0.250), uv - vec2(-0.375,0.375)));\n    df = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.250,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n    df = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.1,-0.125), vec2(0.250,-0.625), vec2(-0.025,-0.625), uv));\t\n\n}\n\nvoid T(inout float df, vec2 uv)\n{\n    df = min(df, dfRect(vec2(0.250, 1.0), uv - vec2(-0.3125,-0.625))); \n\tdf = min(df, dfQuad(vec2(-0.625, 0.375), vec2(-0.625,0.625), vec2(0.250, 0.625), vec2(0.125, 0.375), uv));\t\n}\n\nvoid O(inout float df, vec2 uv)\n{\n    df = min(df, dfRect(vec2(0.25, 0.375), uv - vec2( 0.000,-0.1875)));  \n    df = min(df, dfRect(vec2(0.25, 0.375), uv - vec2(-0.625,-0.1875)));  \n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(0.1875,-0.1875)) * -1.0));\n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(-0.1875,-0.1875)) ));\n}\n\nvoid Y(inout float df, vec2 uv)\n{\n    df = min(df, dfRect(vec2(0.25, 0.25), uv - vec2( 0.000,0.375)));  \n    df = min(df, dfRect(vec2(0.25, 0.25), uv - vec2(-0.625,0.375)));  \n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(0.375,-0.1875)) ));\n    df = min(df, dfRect(vec2(0.250, 0.75), uv - vec2(-0.3125,-0.625))); \n}\n\nvoid X(inout float df, vec2 uv)\n{\n    df = min(df, dfRect(vec2(0.25, 0.25), uv - vec2( 0.000,0.375)));   \n    df = min(df, dfRect(vec2(0.25, 0.25), uv - vec2(-0.625,0.375)));  \n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(0.375,-0.1875)) ));\n    df = min(df, dfSemiArc(0.3125, 0.125, (-uv.yx + vec2(-0.375,-0.1855)) ));\n    //df = min(df, dfRect(vec2(0.250, 0.75), uv - vec2(-0.3125,-0.625)));\n    \n    df = min(df, dfRect(vec2(0.25, 0.25), uv - vec2( 0.000,-0.575)));   \n    df = min(df, dfRect(vec2(0.25, 0.25), uv - vec2(-0.625,-0.575)));\n}\n\n//---------------\n\n//--- Gradient Stuff ---\n//returns 0-1 when xn is between x0-x1\nfloat linstep(float x0, float x1, float xn)\n{\n\treturn (xn - x0) / (x1 - x0);\n}\n\nvec3 retrograd(float x0, float x1, float m, vec2 uv)\n{\n\tfloat mid = x0+(x1 - x0) * m;\n\n\tvec3 grad1 = mix(TEXT_COL1_BOTTOM, TEXT_COL1_TOP, linstep(mid, x1, uv.y));\n    vec3 grad2 = mix(TEXT_COL2_BOTTOM, TEXT_COL2_TOP, linstep(x0, mid, uv.y));\n\n\treturn mix(grad2, grad1, smoothstep(mid, mid + 0.04, uv.y));\n}\n//----------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy/iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y );\n\t\n\tuv = (uv - aspect/2.0)*8.0;\n\t\n    //Text distance field\n\tfloat dist = 1e6;\n\t\n\tvec2 chSpace = vec2(1.125,1.500);\n\t\n\tvec2 chuv = uv;\n\tchuv.x += (chSpace.x * 7.0) / 2.0 - 0.75;\n\t\t\n\tY(dist, chuv); chuv.x -= chSpace.x;\n\tA(dist, chuv); chuv.x -= chSpace.x;\n\tN(dist, chuv); chuv.x -= chSpace.x;\n\tD(dist, chuv); chuv.x -= chSpace.x;\n    E(dist, chuv); chuv.x -= chSpace.x;\n    X(dist, chuv); chuv.x -= chSpace.x;\n    \n    dist /= 2.0;\n    \n    //Colors and mixing mask\n\tfloat mask = smoothstep(4.0 / iResolution.y, 0.00, dist);\n    \n\tvec3 textcol = retrograd(-0.75, 0.50, 0.40 + pow(abs(dist), 0.25) * 0.08, uv);\n\t\n\tvec3 backcol = mix(BACK_COL_BOTTOM, BACK_COL_TOP, (uv.y/4.0)+0.5) * smoothstep(0.02, 0.025, dist);\n\t\n    //Grid Stuff\n\tvec2 gdef = vec2(uv.x / abs(uv.y), 1.0 / (uv.y));\n\tgdef.y = clamp(gdef.y,-1e2, 1e2);\n\t\n\tvec2 gpos = vec2(0.0,-iTime);\n\t\n\tgdef += gpos;\n\t\n\tvec2 grep = mod(gdef*vec2(1.0,2.0), vec2(1.0));\n\t\n\tfloat grid = max(abs(grep.x - 0.5),abs(grep.y - 0.5));\n\t\n\tfloat gs = length(gdef-gpos)*0.01;\n\t\n\tbackcol *= mix(smoothstep(0.46-gs,0.48+gs,grid), 1.0, step(0.0,uv.y))*0.75+0.25;\n\t\n    //Mixing text with background\n\tvec3 color = mix(backcol,textcol,mask);\n\t\n    #ifdef SHOW_DISTANCE\n    color = vec3(sin(dist*48.0));\n    #endif\n    \n\tfragColor = vec4( vec3( color ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsy3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 302, 350, 350, 404], [406, 444, 503, 503, 792], [794, 794, 828, 828, 894], [916, 934, 967, 967, 1396], [1398, 1398, 1431, 1431, 1684], [1686, 1686, 1719, 1719, 2055], [2057, 2057, 2090, 2090, 2243], [2245, 2245, 2278, 2278, 2695], [2697, 2697, 2730, 2730, 3184], [3186, 3186, 3219, 3219, 3402], [3404, 3404, 3437, 3437, 3748], [3750, 3750, 3783, 3783, 4076], [4078, 4078, 4111, 4111, 4632], [4653, 4717, 4762, 4762, 4795], [4797, 4797, 4851, 4851, 5103], [5104, 5130, 5187, 5187, 6570]], "test": "untested"}
{"id": "lsy3R3", "name": "malwieder", "author": "cardmechanic", "description": "asd", "tags": ["asd"], "likes": 0, "viewed": 87, "published": "Public", "date": "1455654286", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Rect {\n\tvec2 pos,\n         ext;\n    mat2 kord;\n    vec4 col;\n\n};\n\n    \nRect \n     R1 = Rect ( vec2(0.,.0), vec2 (.9,.9), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.));\n     \n     \n\n\n\nmat2 Rota (in float alpha){\n\tfloat s = sin(alpha),\n          c = cos(alpha);\n    \n   return mat2 (c, -s, s, c);\n\n}\n\n\nvoid Rotarect (in float alpha, inout Rect r_p){\n    \n    r_p.kord = Rota (alpha) * r_p.kord;\n\n\n}\n\n\n\nvec4 intersec (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n\n    if ( abs(mat.x) >.5*reco.ext.x || abs(mat.y) >.5*reco.ext.y){\n        return vec4 (.5,.25,.75,.1);\n    }\n        if ( mat.x < .0 && mat.y < .00)\n            if ((.14+mat.x)*(0.14+mat.x)*reco.ext.x + 1.2*(.21+mat.y)*(-.15+mat.y)*(reco.ext.y) < .05 )\n            return vec4 (reco.col.x-abs(mat.x)*.48*reco.ext.x,reco.col.y-.48*abs(mat.y)*reco.ext.y, reco.col.z, 1. );\n    \t\t   \tif ( mat.x >.0  && mat.y <.00)\n         \t\t   \tif ((-.14+mat.x)*(-.14+mat.x)*reco.ext.x + 1.2*(.21+mat.y)*(-.15+mat.y)*reco.ext.y < .05)\n           \t\t return vec4 (reco.col.x-abs(mat.x)*.48*reco.ext.x,reco.col.y-.48*abs(mat.y)*reco.ext.y, reco.col.z, 1. );\n    \t        if ( abs(mat.x) <.5*reco.ext.x && mat.y >=.00)\n            \t\tif (abs(mat.x)*reco.ext.x + (mat.y)*reco.ext.y < .405)\n            \treturn vec4 (reco.col.x-abs(mat.x)*.48*reco.ext.x,reco.col.y-.48*abs(mat.y)*reco.ext.y, reco.col.z, 1. );\t\n            \n   return vec4(.5,.25,.75,.1);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.xy-0.5)*vec2 ( iResolution.x/iResolution.y, 1.);\n\tfragColor = vec4(.5,.25,.75,.1);\n\n\tRotarect (iTime+3.14, R1);\n    \n    \n\n        \n    vec4 r1col = intersec (uv,R1);\n  \n    \n   fragColor = intersec (uv,R1);\n\n    \n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsy3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 213, 213, 300], [303, 303, 350, 350, 399], [403, 403, 446, 446, 1444], [1448, 1448, 1505, 1505, 1764]], "test": "untested"}
{"id": "lsy3RG", "name": "TreeL", "author": "vox", "description": "TreeL", "tags": ["treel"], "likes": 1, "viewed": 329, "published": "Public API", "date": "1455001076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\tfloat PI = 3.14159265359;\n\t#define GR 1.61803398875\n\t#define EPS .001\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\nfloat jag(float x)\n{\n    return mod(x, 1.0);\n}\nvec2 jag(vec2 x)\n{\n    return vec2(jag(x.x), jag(x.y));\n}\n\nfloat stair(float x)\n{\n    return float(int(x));\n}\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2( g, f );\n    float k1 = cross2( e, f ) + cross2( h, g );\n    float k0 = cross2( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    \n\n    w = sqrt( w );\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n    vec2 res = vec2(-1.0);\n\n    if(  b1b && !b2b ) res.x = u1;\n    else if(!b1b && b2b) res.x = u2;\n    else if(  b1b == b2b && !b1a) res.x = u2;\n    else res.x = u1;\n    \n    \n    if(  b1a && !b2a ) res.y = v1;\n    else if(!b1a && b2a)res.y = v2;\n    else if(b1a == b2a  && !b1b) res.y = v2;\n    else res.y = v1;\n        \n    return saw(res*1.0*PI);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec2 tree(vec2 uv)\n{\n    \n    uv = uv*2.0-1.0;\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = translate(square, vec2(-.5));\n    square = scale(square, vec2(2.0));\n    square = RotateZ(square, PI/6.0+sin(iTime)*.1);\n    square = scale(square, vec2(.75));\n    square = translate(square, vec2(.5, 0.0));\n    \n    \n    vec2 uv1 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    square = scale(square, vec2(-1.0, 1.0));\n    vec2 uv2 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    if(uv.x >= 0.0)\n    \treturn uv1;\n    if(uv.x < 0.0)\n    \treturn uv2;\n    else\n    \treturn uv*.5+.5;\n}\n\nvec4 draw(vec2 uv)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn vec4(1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y))/.5)*uv.x;\n\telse\n\t\treturn vec4(0.0);\n}\nconst int max_iterations = 16;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv0 = uv;\n\n        vec4 screen = draw(uv);\n    for(int i = 0; i < max_iterations; i++)\n    {\n        uv = tree(uv);; \n            screen += draw(uv);\n    }\n\n    fragColor = screen;\n    //screen.x /= float(max_iterations);\n    //screen.x *= 2.0*PI;\n    fragColor = clamp(screen.x, 0.0, 1.0)*vec4(vec3(sin(iTime*5.0+0.0+screen.x),\n                                                       sin(iTime*5.0+4.0*PI/3.0+screen.x),\n                                                       sin(iTime*5.0+2.0*PI/3.0+screen.x))*.5+.5,\n                                                  1.0);\n  \t//fragColor = vec4(uv, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsy3RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 110, 110, 138], [140, 140, 160, 160, 192], [193, 193, 211, 211, 243], [244, 244, 264, 264, 290], [291, 291, 309, 309, 348], [350, 350, 372, 372, 400], [401, 571, 646, 646, 1573], [1576, 1576, 1609, 1609, 1641], [1642, 1642, 1701, 1701, 1809], [1817, 1817, 1876, 1876, 1919], [1920, 1920, 1979, 1979, 2036], [2037, 2037, 2096, 2096, 2412], [2413, 2413, 2464, 2464, 2644], [2646, 2646, 2693, 2693, 2873], [2875, 2875, 2895, 2895, 3704], [3706, 3706, 3726, 3726, 3954], [3987, 3987, 4044, 4044, 4708]], "test": "untested"}
{"id": "lsyGWK", "name": "Shader Apple tut from iq", "author": "amdbcg", "description": "after spending 15 minutes viewing the live coding tut and only getting 7 minutes into it, I decided to copy-modify from Iq's apple shader, typing each line by hand and getting a feel for what it does.", "tags": ["3d", "apple"], "likes": 5, "viewed": 184, "published": "Public", "date": "1456548541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nmat3 m = mat3(0.00, 0.80, 0.60, \t// column 1\n              -.80,\t0.36, -0.48, \t// column 2 \n              -0.60,-0.48, 0.64);\nfloat hash ( float n ) {\n\treturn fract(sin(n)*43758.5453); //kind of like tan, but not as smooth, tan with a clamp/noise\n}\n\nfloat noise(in vec3 x)\t\t\t\t // what does in keyword do? pass by reference? \n{\n\tvec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y* 57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z); \n                    // what does this look like separated?\n    return res;                             \n}\n\nfloat fbm( vec3 p ) \n{\n\tfloat f = 0.0;\n    \n    f += 0.5000*noise( p ) ; p = m*p*2.02;\n    f += 0.2500*noise( p ) ; p = m*p*2.03;\n    f += 0.1250*noise( p ) ; p = m*p*2.01;\n    f += 0.0625*noise( p ) ; \n  \treturn f/0.9375;\n}\nfloat fruitShape(in vec3 p){\n\treturn length(p) -1.0;\n\n}\nfloat floorShape(in vec3 p)\n{\n\treturn p.y + 1.0;\n}\nvec2 map (in vec3 p)\n{\n    vec2 d2 = vec2(p.y+0.55, 2.0 );\n    p.y -= 0.75*pow(dot(p.xz, p.xz),0.2);\n    vec2 d1 = vec2(length(p)-1.0, 1.0);\n\t//vec2 d1 = vec2( fruitShape(p), 1.0);\n    //vec2 d2 = vec2(floorShape(p), 2.0);\n    if( d2.x < d1.x) d1= d2;\n    return d1;\n}\n\nvec3 appleColor(in vec3 pos, in vec3 nor, out vec2 spe) // if spec changes, outer scope spec changes\n{\n    // what does in do? \n    spe.x = 1.0;\n\tspe.y = 1.0; \n\t\n\tfloat a = atan(pos.x, pos.z);\n\tfloat r = length(pos.xz);\n\n\t//red\n\tvec3 col = vec3(1.0, 0.0, 0.0);\n\t\n\t// green\n\tfloat f = smoothstep(0.1, 1.0 , fbm(pos*1.0) ); \n\tcol = mix (col, vec3(0.8, 3.0, 0.2), f);\n    \n    // dirty \n    f = smoothstep(0.0, 1.0, fbm(pos*4.0)) ;\n    col *= 0.8 + 0.2 * f;\n    \n    //freckles\n    f = smoothstep(0.0, 1.0, fbm(pos*48.0));\n    f = smoothstep (0.7, 0.9, f);\n    col = mix(col , vec3(0.9, 0.9, 0.6), f*0.5);\n    \n    //stripes \n    f = fbm(vec3(a*7.0 + pos.z, 3.0* pos.y,pos.x))*2.0;\n    f = smoothstep(0.2,1.0, f);\n    col = mix(col, vec3(0.4,0.2,0.0), 0.5*f); // what is f in this case?\n    spe.x *= 1.0 -0.35 *f ; \n    spe.y = 1.0 -0.5*f;\n   \n    //top \n     f = 1.0-smoothstep(0.14, 0.2, r ) ; \n     col = mix(col, vec3(0.6,0.6, 0.5), f);\n     spe.x +=1.0-f;\n              \n    float ao = 0.5 +0.5*nor.y;\n   \tcol *= ao *1.2;\n    \n\treturn col;\n\n}\nvec3 floorColor(in vec3 pos, in vec3 nor, out vec2 spe){\n\tspe.x = 1.0;\n    spe.y = 1.0;\n    vec3 col = vec3(0.5,0.4,0.3)*1.7;\n    float f = fbm( 4.0 * pos* vec3 (6.0, 0.0, 0.5)) ;\n    col = mix( col , vec3(0.3, 0.2, 0.1)*1.7, f);\n\tspe.y = 1.0 + 4.0*f ; \n    \n    f = fbm (2.0*pos);\n    col *= 0.7 + 0.3*f;\n    \n    // freckles \n    f = smoothstep(0.0,1.0,fbm(pos*48.0) );\n    f = smoothstep(0.7, 0.9, f);\n    col = mix(col , vec3(0.2) , f*0.75);\n    \n    // fake ao \n    f = smoothstep(0.1 , 1.55, length(pos.xz) );\n    col *= f*f*1.4; \n    col.x += 0.1*(1.0-f); \n    return col; \n}\nvec3 calcNormal( in vec3 p){\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n        vec3 n; \n    n.x = map(p+ e.xyy).x - map(p-e.xyy).x;\n    n.y = map (p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map( p+ e.yyx).x - map(p-e.yyx).x;\n    return normalize(n) ; \n\n}\n\n\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float dt = 0.1;\n    float t = mint;\n    for( int i = 0; i < 30; i++){\n    \tfloat h = map(ro +rd*t).x;\n    \th = max (h , 0.0);\n        res = min(res, smoothstep(0.0, 1.0, k*h/t) );\n        t += dt; \n        if(h <0.001) break;\n    \n    }\n\treturn res;\n\n}\n\nvec2 intersect(vec3 ro, vec3 rd){\n\tfloat t = 0.0 ;\n    float dt = 0.06;\n    float nh = 0.0;\n    float lh = 0.0;\n    float lm = -1.0;\n    \n   for (int  i = 0; i < 128; i++ )\n     {\n       vec2 ma = map ( ro+ rd*t);\n         nh = ma.x;\n         if(nh > 0.0 ){ lh = nh; t += dt; } lm = ma.y;\n     }\n\tif( nh > 0.0) return vec2(-1.0);\n    t= t- dt*nh/(nh-lh);\n            \n        return vec2(t,lm);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 q = fragCoord.xy/ iResolution.xy;\n    vec2 p = (-1.0 +2.0 *q) ;\n       p.x *= iResolution.x/iResolution.y; // aspect ratio, centers everything.\n    //camera \n\tvec3 ro = 2.5*normalize(vec3(cos(0.2),1.15+0.4*cos(time*0.5),\n                                 sin(0.2*time)));\n    //vec3 rd = normalize(vec3( (-1.0 +2.00*q)*vec2(1.77,1.0), - 1.5));\n    vec3 ww = normalize(vec3(0.0,0.5,0.0) - ro );\n    vec3 uu = normalize ( cross(vec3(0.0, 1.0, 0.0), ww)); \n    vec3 vv = normalize ( cross(ww,uu)); \n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww);\n    // raymarch \n       vec3 col = vec3(0.88, 0.98, 1.0);\n    \n     vec2 tmat = intersect( ro, rd);\n    //vec3 col = vec3(0.6);\n    \n    if(tmat.y > 0.5)\n    {\n        //geometry \n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal( pos);\n        vec3 ref = reflect(rd,nor); \t\t\t// what does the reflect f(x) look like? \n        vec3 lig = normalize( vec3(1.0,0.8, 0.6)) ;\n        \n        \n        float con = 1.0;\n        float amb = 0.5 + 0.5*nor.y ;\n        float dif = max( 0.0, dot(nor,lig) ) ;\n        float bac = max(0.2+0.8*dot(nor, vec3( -lig.x, lig.y, -lig.z)), 0.0);\n        float rim = pow(1.0 + dot(nor, rd), 3.0);\n        float spe = pow(clamp(dot(lig,ref), 0.0, 1.0), 16.0);\n        \n        \n        //shadow\n        float sha = softshadow(pos, lig,0.06,4.0,4.0);\n        \n        // lights \n        col = 0.10*con*vec3(.8, 0.9,1.0);\n        col += 0.70*dif*vec3(1.0,0.97,0.85)*vec3(sha, (sha+sha*sha)*0.5, sha*sha);\n        col +=0.15*bac*vec3(1.0,0.97,0.85);\n    \tcol +=0.20*amb*vec3(0.10,0.15,0.2);        \n        \n        // color \n        vec2 pro ; \n        if(tmat.y < 1.5) // what does this do? it looks like it limits the shader to only affect \n            \t// the y part less than 1.5 of something. \n        col *= appleColor(pos, nor, pro ); // what is getting passed in? position, normal, ?\n        else\n        col *= floorColor(pos,nor,pro);\n        \n        // rim and spec\n        col += 0.60*rim*vec3(1.0, 0.97, 0.85)*amb*amb;\n        col += 0.60*pow(spe,pro.y)*vec3(1.0)*pro.x*sha;\n        col = 0.3*col + 0.7*sqrt(col);\n    }\t\n    col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\tfragColor = vec4(col,1.0);\n}\n\n//http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyGWK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 250, 274, 274, 372], [374, 374, 450, 450, 939], [941, 941, 963, 963, 1165], [1166, 1166, 1194, 1194, 1221], [1222, 1222, 1251, 1251, 1272], [1273, 1273, 1295, 1295, 1541], [1543, 1543, 1645, 1670, 2587], [2588, 2588, 2644, 2644, 3170], [3171, 3171, 3199, 3199, 3412], [3415, 3415, 3490, 3490, 3768], [3770, 3770, 3803, 3803, 4166], [4168, 4168, 4225, 4225, 6481]], "test": "untested"}
{"id": "lsyGzV", "name": "Love Invaders", "author": "irealex", "description": "Made by Irene BouzÃ³n and Alexandra Vicente for our first PGATR assigment (2016).\nComputer Graphics, Virtual Reality and Video Games University Master. URJC.", "tags": ["2d", "heart", "spaceinvaders", "valentine", "tetris", "love"], "likes": 3, "viewed": 247, "published": "Public", "date": "1455332473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEP 0.2\n#define PI 3.14159265359\n\n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\n\n\nvec3 piece (vec3 col, vec2 r, vec2 pos, vec3 mainColor, vec3 borderColor, vec3 shadowColor)\n{\n\tvec3 ret = col;\n\n\tvec2 bottomLeft = pos;\n\tvec2 topRight = pos + vec2(STEP, STEP);\n\tvec2 c = (bottomLeft+topRight)/2.0;\n\tfloat d = length(r - c);\n\t\n\t// Square border\n\tret = mix(ret, borderColor, rect(r, bottomLeft, topRight) );\n\n\t// Square color\n\tvec2 margin = vec2(0.01, 0.01);\n\tret = mix(ret, mainColor, rect(r, bottomLeft + margin, topRight - margin) );\n\n\t// Inner shadow\n\tret = mix(ret, shadowColor, (3.0*sin(d))*rect(r, bottomLeft + margin , topRight - margin));\n\n\t// Inner square\n\tmargin = vec2(0.035, 0.035);\n\tret = mix(ret, mainColor, rect(r, bottomLeft + margin , topRight - margin));\n\n\n\treturn ret;\n}\n\nvec2 up(vec2 pos)\n{\n\tvec2 up = pos + vec2(0.0, +STEP);\n\treturn up;\n}\n\nvec2 down(vec2 pos)\n{\n\tvec2 down = pos + vec2(0.0, -STEP);\n\treturn down;\n}\n\nvec2 left(vec2 pos)\n{\n\tvec2 left = pos + vec2(-STEP, 0.0);\n\treturn left;\n}\n\nvec2 right(vec2 pos)\n{\n\tvec2 right = pos + vec2(+STEP, 0.0);\n\treturn right;\n}\n\nvec3 piece1 (vec3 col, vec2 r, vec2 pos, float rot, vec3 colBlack, vec3 colShadow)\n{\n\tvec3 ret = col;\n\tvec2 q = r - pos;\n\n\tfloat angle = rot;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n\t\n\tfloat height = 2.0*STEP;\n\tfloat width = 2.0*STEP;\n\n\tvec2 c = vec2(width/2.0, height/2.0);\n\n\tq =  rotationMatrix*q;\n\n\tvec3 colPurple = vec3(0.724, 0.324, 0.728);\n\n\tvec2 start = -c/2.0;\n\tret = piece(ret, q, start, colPurple, colBlack, colShadow);\n\tret = piece(ret, q, up(start), colPurple, colBlack, colShadow);\n\tret = piece(ret, q, left(up(start)), colPurple, colBlack, colShadow);\n\n\treturn ret;\n}\n\nvec3 piece2 (vec3 col, vec2 r, vec2 pos, float rot, vec3 colBlack, vec3 colShadow)\n{\n\tvec3 ret = col;\n\tvec2 q = r - pos;\n\n\tfloat angle = rot;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n\t\n\tfloat height = 2.0*STEP;\n\tfloat width = 2.0*STEP;\n\n\tvec2 c = vec2(width/2.0, height/2.0);\n\n\tq =  rotationMatrix*q;\n\n\tvec3 colYellow = vec3(0.867, 0.910, 0.247);\n\n\tvec2 start = -c/2.0;\n\tret = piece(ret, q, start, colYellow, colBlack, colShadow);\n\tret = piece(ret, q, left(start), colYellow, colBlack, colShadow);\n\tret = piece(ret, q, up(start), colYellow, colBlack, colShadow);\n\tret = piece(ret, q, right(up(start)), colYellow, colBlack, colShadow);\n\n\treturn ret;\n}\n\nvec3 piece2i (vec3 col, vec2 r, vec2 pos, float rot, vec3 colBlack, vec3 colShadow)\n{\n\tvec3 ret = col;\n\tvec2 q = r - pos;\n\n\tfloat angle = rot;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n\t\n\tfloat height = 2.0*STEP;\n\tfloat width = 2.0*STEP;\n\n\tvec2 c = vec2(width/2.0, height/2.0);\n\n\tq =  rotationMatrix*q;\n\n\tvec3 colPink = vec3(0.9, 0.15, 0.4);\n\n\tvec2 start = -c/2.0;\n\tret = piece(ret, q, start, colPink, colBlack, colShadow);\n\tret = piece(ret, q, left(up(start)), colPink, colBlack, colShadow);\n\tret = piece(ret, q, up(start), colPink, colBlack, colShadow);\n\tret = piece(ret, q, right(start), colPink, colBlack, colShadow);\n\n\treturn ret;\n}\n\nvec3 piece3 (vec3 col, vec2 r, vec2 pos, float rot, vec3 colBlack, vec3 colShadow)\n{\n\tvec3 ret = col;\n\tvec2 q = r - pos;\n\n\tfloat angle = rot;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n\t\n\tfloat height = 2.0*STEP;\n\tfloat width = 2.0*STEP;\n\n\tvec2 c = vec2(width/2.0, height/2.0);\n\n\tq =  rotationMatrix*q;\n\n\tvec3 colGreen = vec3(0.151, 0.694, 0.337);\n\n\tvec2 start = -c/2.0;\n\tret = piece(ret, q, start, colGreen, colBlack, colShadow);\n\tret = piece(ret, q, up(start), colGreen, colBlack, colShadow);\n\tret = piece(ret, q, left(up(start)), colGreen, colBlack, colShadow);\n\tret = piece(ret, q, right(up(start)), colGreen, colBlack, colShadow);\n\n\treturn ret;\n}\n\nvec3 piecel (vec3 col, vec2 r, vec2 pos, float rot, vec3 colBlack, vec3 colShadow)\n{\n\tvec3 ret = col;\n\tvec2 q = r - pos;\n\n\tfloat angle = rot;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n\t\n\tfloat height = 2.0*STEP;\n\tfloat width = 2.0*STEP;\n\n\tvec2 c = vec2(width/2.0, height/2.0);\n\n\tq =  rotationMatrix*q;\n\n\tvec3 colRed = vec3(0.95, 0.151, 0.2);\n\n\tvec2 start = -c/2.0;\n\tret = piece(ret, q, start, colRed, colBlack, colShadow);\n\tret = piece(ret, q, left(start), colRed, colBlack, colShadow);\n\tret = piece(ret, q, right(start), colRed, colBlack, colShadow);\n\tret = piece(ret, q, right(right(start)), colRed, colBlack, colShadow);\n\n\treturn ret;\n}\n\nvec3 pieceLi (vec3 col, vec2 r, vec2 pos, float rot, vec3 colBlack, vec3 colShadow)\n{\n\tvec3 ret = col;\n\tvec2 q = r - pos;\n\n\tfloat angle = rot;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n\t\n\tfloat height = 2.0*STEP;\n\tfloat width = 2.0*STEP;\n\n\tvec2 c = vec2(width/2.0, height/2.0);\n\n\tq =  rotationMatrix*q;\n\n\tvec3 colOrange = vec3(0.9, 0.4, 0.0);\n\n\tvec2 start = -c/2.0;\n\tret = piece(ret, q, start, colOrange, colBlack, colShadow);\n\tret = piece(ret, q, down(start), colOrange, colBlack, colShadow);\n\tret = piece(ret, q, left(down(start)), colOrange, colBlack, colShadow);\n\tret = piece(ret, q, up(start), colOrange, colBlack, colShadow);\n\n\treturn ret;\n}\n\nvec3 pieceL (vec3 col, vec2 r, vec2 pos, float rot, vec3 colBlack, vec3 colShadow)\n{\n\tvec3 ret = col;\n\tvec2 q = r - pos;\n\n\tfloat angle = rot;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n\t\n\tfloat height = 2.0*STEP;\n\tfloat width = 2.0*STEP;\n\n\tvec2 c = vec2(width/2.0, height/2.0);\n\n\tq =  rotationMatrix*q;\n\n\tvec3 colPurple = vec3(0.724, 0.324, 0.728);\n\n\tvec2 start = -c/2.0;\n\tret = piece(ret, q, start, colPurple, colBlack, colShadow);\n\tret = piece(ret, q, down(start), colPurple, colBlack, colShadow);\n\tret = piece(ret, q, right(down(start)), colPurple, colBlack, colShadow);\n\tret = piece(ret, q, up(start), colPurple, colBlack, colShadow);\n\n\treturn ret;\n}\n\nvec3 piece4 (vec3 col, vec2 r, vec2 pos, float rot, vec3 colBlack, vec3 colShadow)\n{\n\tvec3 ret = col;\n\tvec2 q = r - pos;\n\n\tfloat angle = rot;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n\t\n\tfloat height = 2.0*STEP;\n\tfloat width = 2.0*STEP;\n\n\tvec2 c = vec2(width/2.0, height/2.0);\n\n\tq =  rotationMatrix*q;\n\n\tvec3 colBlue = vec3(0.216, 0.471, 0.698);\n\n\tvec2 start = -c/2.0;\n\tret = piece(ret, q, start, colBlue, colBlack, colShadow);\n\t/*ret = piece(ret, q, up(start), colBlue, colBlack, colShadow);\n\tret = piece(ret, q, left(up(start)), colBlue, colBlack, colShadow);\n\tret = piece(ret, q, left(start), colBlue, colBlack, colShadow);*/\n\n\treturn ret;\n}\n\nvec3 invader (vec3 col, vec2 r, vec2 pos, float rot, vec3 colBlack, vec3 colShadow)\n{\n\tvec3 ret = col;\n\t\n\tret = piece3(ret, r, pos, rot + PI, colBlack, colShadow);\n\tret = piece3(ret, r, pos + vec2(0.0, 0.6), rot, colBlack, colShadow);\n\tret = pieceL(ret, r, pos + vec2(0.4, 0.6), rot + 3.0*PI/2.0, colBlack, colShadow);\n\tret = piece4(ret, r, pos + vec2(0.8, 1.0), 0.0, colBlack, colShadow);\n\tret = piece4(ret, r, pos + vec2(-0.8, 1.0), 0.0, colBlack, colShadow);\n\tret = piecel(ret, r, pos + vec2(-0.8, 0.4), rot + PI/2.0, colBlack, colShadow);\n\tret = pieceL(ret, r, pos + vec2(-1.2, 0.4), rot + PI, colBlack, colShadow);\n\tret = piece2(ret, r, pos + vec2(-1.0, -0.2), rot + PI/2.0, colBlack, colShadow);\n\tret = piece4(ret, r, pos + vec2(-0.6, -0.6), 0.0, colBlack, colShadow);\n\tret = piece4(ret, r, pos + vec2(-0.4, -0.6), 0.0, colBlack, colShadow);\n\tret = piece4(ret, r, pos + vec2(-0.6, -0.2), 0.0, colBlack, colShadow);\n\tret = piece3(ret, r, pos + vec2(-0.2, 0.0), rot, colBlack, colShadow);\n\tret = pieceLi(ret, r, pos + vec2(0.4, -0.2), rot + PI/2.0, colBlack, colShadow);\n\tret = piece4(ret, r, pos + vec2(0.6, -0.6), 0.0, colBlack, colShadow);\n\tret = piece4(ret, r, pos + vec2(0.4, -0.6), 0.0, colBlack, colShadow);\n\tret = piece2i(ret, r, pos + vec2(0.8, -0.2), rot + PI/2.0, colBlack, colShadow);\n\tret = pieceLi(ret, r, pos + vec2(1.2, 0.4), rot + PI, colBlack, colShadow);\n\tret = pieceLi(ret, r, pos + vec2(-0.4, 0.6), rot + PI/2.0, colBlack, colShadow);\n\tret = piecel(ret, r, pos + vec2(0.8, 0.4), rot + PI/2.0, colBlack, colShadow);\n\n\treturn ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec2 q = r;\n\tvec2 w = r;\n\tvec2 cursor = (2.0*iMouse.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\t\n\tfloat xMax = iResolution.x/min(iResolution.y,iResolution.x);\n\tfloat yMax = iResolution.y/min(iResolution.y,iResolution.x);\n\tfloat distance = length(cursor);\n\tfloat cursorMod = (1.0-step(0.05*min(xMax,yMax), distance));\n\tfloat modif = 4.0 + ( cursorMod*sin(iTime*PI)*0.3 );\n\n\tr *= modif;\n\tcursor *= modif;\n\n\n\t// COLOR DEFINITIONS\n\tvec3 bgCol = vec3(1.0);\n\tvec3 colShadow = vec3(1.0) + ( 1.0-mod(length(cursor), max(iResolution.y, iResolution.x)) );\n\tvec3 colShadowInv = vec3(0.0);\n\tvec3 colBlack = vec3(0.0);\n\tvec3 colWhite = vec3(1.0);\n\tvec3 colGray = vec3(0.7);\n\t\t\n\t\n\t// GRID\n\tvec3 ret = colWhite;\n\n\n\t// BACKGROUND\n\tfloat t = iTime*0.05;\n\tvec2 br = r/modif;\n\n\tfloat v1 = sin(br.x +5.*t);\n    float v2 = sin(br.y +3.*t);\n    float v3 = sin(br.x+br.y +t);\n    float v4 = sin(sqrt(br.x*br.x+br.y*r.y) +3.*t);\n\tfloat v = v1+v2+v3+v4;\n\tv *= 3.0;\n\tret = vec3(0.2*sin(v), 0.1*sin(v+0.5*PI), 0.9*sin(v+1.0*PI));\n\tret += vec3(0.8*sin(v+1.0*PI), 0.1*sin(v+3.5*PI), 0.1*sin(v));\n\tret = 0.5*ret;\n\n\tbr = 0.5*vec2(br.x*v/3.0, br.y*v/3.0);\n\n\tret = mix(ret, texture(iChannel0, br).xyz, cursorMod*0.6*sin(iTime));\n\t\n\t// TETRIS PIECES\n\tfloat rot = 0.0;\n\tfloat factor = clamp(distance, 0.2, 1.0)-0.2;\n\n\tret = mix(piece3(ret, r, vec2(-0.2, -0.7), rot + 3.0*PI/2.0, colBlack, colShadow), ret, factor);\n\tret = mix(piece4(ret, r, vec2(-0.2, -0.5), 0.0, colBlack, colShadow), ret, factor);\n\tret = mix(piecel(ret, r, vec2(-0.4, -0.3), rot, colBlack, colShadow), ret, factor);\n\tret = mix(pieceLi(ret, r, vec2(0.2, -0.5), rot + PI, colBlack, colShadow), ret, factor);\n\tret = mix(piece4(ret, r, vec2(0.6, -0.3), 0.0, colBlack, colShadow), ret, factor);\n\tret = mix(piece4(ret, r, vec2(0.6, 0.1), 0.0, colBlack, colShadow), ret, factor);\n\tret = mix(piece4(ret, r, vec2(0.4, 0.5), 0.0, colBlack, colShadow), ret, factor);\n\tret = mix(piece4(ret, r, vec2(-0.6, 0.1), 0.0, colBlack, colShadow), ret, factor);\n\tret = mix(piece4(ret, r, vec2(-0.6, 0.3), 0.0, colBlack, colShadow), ret, factor);\n\tret = mix(pieceL(ret, r, vec2(-0.4, 0.3), rot + PI, colBlack, colShadow), ret, factor);\n\tret = mix(pieceLi(ret, r, vec2(-1.0, 0.7), rot + PI, colBlack, colShadow), ret, factor);\n\tret = mix(piece2i(ret, r, vec2(-0.4, 1.1), rot + PI, colBlack, colShadow), ret, factor);\n\tret = mix(piece2(ret, r, vec2(0.4, 1.1), rot + PI, colBlack, colShadow), ret, factor);\n\tret = mix(pieceL(ret, r, vec2(1.0, 0.7), rot + PI, colBlack, colShadow), ret, factor);\n\tret = mix(piece2i(ret, r, vec2(0.6, 0.3), rot + PI/2.0, colBlack, colShadow), ret, factor);\n\n\n\t// DECORATION PIECES\n\tfloat y;\n\tfloat x;\n\n\tw.y -= 1.5;\n\tw *= 4.0;\n\n\tfloat speed = 1.0;\n\tt = iTime*speed;\n\tfloat stopEveryAngle = PI/2.0;\n\tfloat stopRatio = 1.0;\n\trot = (floor(t) + smoothstep(0.0, 1.0-stopRatio, fract(t)) )*stopEveryAngle;\n\n\ty = -mod(iTime*0.2*PI - 2.0*PI, yMax*12.0);\n\tret = piece2i(ret, w, vec2(-0.45*xMax*4.0, y), rot + PI/2.0, colBlack, colShadowInv);\n\n\ty = -mod(iTime*0.8*PI + 3.0*PI/2.0, yMax*12.0);\n\tret = piece3(ret, w, vec2(0.8*xMax*4.0, y), rot + PI, colBlack, colShadowInv);\n\n\tt -= PI;\n\trot = (floor(t) + smoothstep(0.0, 1.0-stopRatio, fract(t)) )*stopEveryAngle;\n\ty = -mod(iTime*0.5*PI + PI, yMax*12.0);\n\tret = pieceL(ret, w, vec2(0.5*xMax*4.0, y), rot + PI, colBlack, colShadowInv);\n\n\ty = -mod(iTime*0.3*PI, yMax*12.0);\n\tret = piece2(ret, w, vec2(-0.3*xMax*4.0, y), rot + PI, colBlack, colShadowInv);\n\n\tt -= PI/2.0;\n\trot = (floor(t) + smoothstep(0.0, 1.0-stopRatio, fract(t)) )*stopEveryAngle;\n\ty = -mod(iTime*0.6*PI, yMax*12.0);\n\tret = piecel(ret, w, vec2(-0.7*xMax*4.0, y), rot + PI, colBlack, colShadowInv);\n\n\n\t// DECORATION INVADERS -> performance!!!\n\t/*q.y -= 1.5;\n\tq *= 8.0;\n\n\ty = -mod(iTime*PI - 2.0*PI, yMax*25.0);\n\tx = (-0.6*xMax)*8.0+1.5*sin(iTime*PI);\n\tret = invader(ret, q, vec2(x, y), PI, colBlack, colShadowInv);\n\n\ty = -mod(iTime*PI + 3.0*PI/2.0, yMax*25.0);\n\tx = (0.6*xMax)*8.0+1.5*sin(iTime*2.5*PI);\n\tret = invader(ret, q, vec2(x, y), PI, colBlack, colShadowInv);*/\n\n\n\t// MOUSE\n\tret = invader(ret, r, cursor, PI, colBlack, colShadow);\n\n\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 96, 96, 372], [376, 376, 469, 469, 1080], [1082, 1082, 1101, 1101, 1150], [1152, 1152, 1173, 1173, 1226], [1228, 1228, 1249, 1249, 1302], [1304, 1304, 1326, 1326, 1381], [1383, 1383, 1467, 1467, 2034], [2036, 2036, 2120, 2120, 2755], [2757, 2757, 2842, 2842, 3462], [3464, 3464, 3548, 3548, 4182], [4184, 4184, 4268, 4268, 4891], [4893, 4893, 4978, 4978, 5608], [5610, 5610, 5694, 5694, 6331], [6333, 6333, 6417, 6417, 7045], [7047, 7047, 7132, 7132, 8602], [8605, 8605, 8662, 8662, 12884]], "test": "untested"}
{"id": "MdG3Dy", "name": "sdMiter", "author": "paniq", "description": "computing the distance to two planes intersecting at zero with a rounding radius. wrote this to solve the problem of rounded capped cones, but it's also useful for beveling strokes.", "tags": ["round", "intersection", "plane", "miter"], "likes": 8, "viewed": 314, "published": "Public", "date": "1456222331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat dot2( in vec2 v ) { \n    return dot(v,v);\n}\nfloat det(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n// d1, d2 must be normalized\n// if one of the planes is axis aligned, the terms are simpler\nfloat sdMiter(vec2 p, vec2 d1, vec2 d2, float r) {\n    float d1d2 = det(d1,d2);\n    float sd1d2 = sign(d1d2);\n    p += (d1 + d2) * r / (dot(d1,d2) + 1.0);\n\n    float h1 = det(p,d1) * 0.5;\n    float h2 = det(p,d2) * 0.5;\n    vec2 l1 = p - vec2(d1.y,-d1.x) * (h1 + abs(h1)*sd1d2);\n    vec2 l2 = p - vec2(d2.y,-d2.x) * (h2 - abs(h2)*sd1d2);\n    \n\treturn sqrt(min(dot2(l1),dot2(l2))) * sign(max(dot(p, d1),dot(p, d2))) - r;\n}\n\nfloat map (vec2 p) {\n    float a = iTime * 0.3;\n    float b = 3.14159 * 0.1 + iTime * 0.1;\n    vec2 d1 = vec2(cos(a),sin(a)); // 1 0\n    vec2 d2 = vec2(cos(b),sin(b)); // -0.70710678118655 0.70710678118655\n    \n    return sdMiter(p,d1,d2,(sin(iTime)*0.5+0.5)*0.5);\n}\n\n//-------------------------------------------------------\n\nfloat circle (vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat outline (float d) {\n    return 1.0 - smoothstep(0.0, 3.0 / iResolution.y, abs(d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec2 m = (iMouse.xy / iResolution.xy)*2.0-1.0;\n    m.x *= iResolution.x / iResolution.y;\n\n    float d = map(p);\n\n    float d2 = abs(map(m));\n    \n    float s = abs(mod(d, 0.1)/0.1 - 0.5);    \n\tfragColor = vec4(((iMouse.z > 0.5)?outline(circle(p-m,d2)):0.0)+s+vec3(outline(d) + 0.3 * step(d,0.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdG3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 50], [51, 51, 78, 78, 114], [116, 208, 258, 258, 629], [631, 631, 651, 651, 897], [899, 958, 990, 990, 1018], [1020, 1020, 1045, 1045, 1110], [1112, 1112, 1169, 1169, 1593]], "test": "untested"}
{"id": "MdGGzy", "name": "Seascape-fix-while-pixels", "author": "fatcloud", "description": "Those white noisy pixels that appear after running for couples of hours are eliminated by avoiding direct addition between SEA_TIME and other floating point number", "tags": ["seawater", "floatingpointnumberissue"], "likes": 13, "viewed": 2813, "published": "Public", "date": "1455101289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"Seascape\" by Alexander Alekseev aka TDM - 2014\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tdmaav@gmail.com\n*/\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\nfloat EPSILON_NRM\t= 0.1 / iResolution.x;\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nfloat SEA_TIME = iTime * SEA_SPEED;\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec3 uvt ) {\n    vec2 p = uvt.xy;\n    vec2 ft = fract(uvt.z * vec2(1.0, 1.0));\n    vec2 i = floor(p+ft) + floor(uvt.z);\n    vec2 f = fract( p +ft );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\n// sea\nfloat sea_octave(vec3 uvt, float choppy) {\n    vec2 uv = uvt.xy;// + uvt.z;\n    uv += noise(uvt);\n    vec2 cost = cos(uvt.z * vec2(1.0, 1.0));\n    vec2 sint = sin(uvt.z * vec2(1.0, 1.0));\n    vec2 wv = 1.0-abs(sin(uv)*cost  + sint*cos(uv) );\n    vec2 swv = abs(cos(uv)*cost - sin(uv)*sint);    \n    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec3 uvt = vec3(p.xz, SEA_TIME); uvt.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uvt)*freq,choppy);\n    \td += sea_octave((uvt)*freq,choppy);\n        h += d * amp;        \n    \tuvt.xy *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec3 uvt = vec3(p.xz, SEA_TIME); uvt.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uvt)*freq,choppy);\n    \td += sea_octave((uvt)*freq,choppy);\n        h += d * amp;        \n    \tuvt.xy*= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGGzy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[638, 646, 672, 672, 1018], [1019, 1019, 1041, 1041, 1121], [1122, 1122, 1150, 1150, 1536], [1538, 1550, 1588, 1588, 1630], [1631, 1631, 1677, 1677, 1781], [1783, 1790, 1816, 1816, 1954], [1956, 1963, 2005, 2005, 2339], [2341, 2341, 2360, 2360, 2810], [2812, 2812, 2840, 2840, 3289], [3291, 3291, 3354, 3354, 3841], [3843, 3854, 3889, 3889, 4080], [4082, 4082, 4138, 4138, 4650], [4652, 4660, 4717, 4717, 5543]], "test": "untested"}
{"id": "MdK3Rm", "name": "Metal framework", "author": "TambakoJaguar", "description": "I like the Victorian times metal structures like those used in the Eiffel tower. I tried to recreate one and during coding I thought about the idea of the movement along this curved \"tunnel\", with fog.\nTurn anti-aliasing on if you have a good GPU.", "tags": ["tunnel", "framework", "fog", "bars", "metal", "movement", "structures", "victorian"], "likes": 9, "viewed": 379, "published": "Public", "date": "1454693494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"\" by Emmanuel Keller aka Tambako - January 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n#define sin45 0.7071067\n\n// Switches, you can play with them!\n//#define shadow\n#define ambocc\n#define specular\n#define curved_framework\n#define color_changes\n#define fog_variation\n//#define antialiaising\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct DirLamp\n{\n  vec3 direction;\n  vec3 color;\n  float intensity;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n    \n//Lamp lamps[2];\nDirLamp lamps[3];\n\n// Every object of the scene has its ID\n#define SKY_OBJ         0\n#define FRAMEWORK_OBJ   1\n\n// Framework options\nconst float T0 = 1.;\nconst float T0D = 0.6;\nconst float TF = 8.;\nconst float TR = 150.;\n\n// Campera options\nvec3 campos;\nvec3 camdir;\nfloat fov = 2.;\nfloat cspeed = 180.;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.05;\n\n// Fog\nconst vec3 fogColor1 = vec3(0.7);\nconst vec3 fogColor2 = vec3(0.5, 0.73, 1.);\nvec3 fogColor;\nconst float fogdens0 = 0.0024;\nfloat fogdensf;\n\n// Shading options\nconst float specint = 0.2;\nconst float specshin = 20.;\nconst float aoint = 1.3;\nconst float shi = 0.85;\nconst float shf = 0.4;\n\n// Tracing options\nconst float normdelta = 0.002;\nconst float maxdist = 1000.;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.67;\nconst int aasamples = 2;\n\n// 1D hash function\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nvec2 rotateVec45(vec2 vect)\n{\n    vec2 rv;\n    rv.x = vect.x*sin45 - vect.y*sin45;\n    rv.y = vect.x*sin45 + vect.y*sin45;\n    return rv;\n}\n\nvec2 rotateVec45i(vec2 vect)\n{\n    vec2 rv;\n    rv.x = vect.x*sin45 + vect.y*sin45;\n    rv.y = vect.x*sin45 - vect.y*sin45;\n    return rv;\n}\n\n// Rotates the position vector in function of the position of the mouse\nvec3 getCameraDir()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy; \n   \n    float angle = -2.*pi*(iMouse2.x/iResolution.x - 0.5);\n    float angle2 = 0.8*pi*(iMouse2.y/iResolution.y - 0.47);  \n    \n    vec3 posr = vec3(0., 0., 1.);\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return normalize(posr);\n}\n\nfloat bar(vec3 pos, float e)\n{\n    vec2 d = abs(pos.xy) - vec2(e, e);\n    return min(max(d.x,max(d.y,d.y)),0.0) + length(max(d,0.0)); \n}\n\nfloat mapBarsRot(vec3 pos)\n{\n    vec3 posr = pos;\n    posr.z = mod(posr.z, TF);\n    posr.yz = rotateVec45(posr.yz);\n    vec3 posr2 = pos;\n    posr2.z = mod(posr2.z, TF);\n    posr2.yz = rotateVec45i(posr2.yz);\n    \n    float fact = T0*TF*0.5;\n\n    posr = abs(posr);\n    posr.xy-= vec2(fact, fact*sin45);\n    posr2 = abs(posr2);\n    posr2.xy-= vec2(fact, fact*sin45);\n        \n    return max(min(bar(posr.xyz, T0/2.), bar(posr2.xyz, T0/2.)), bar(pos.xyz, fact + T0/2.));\n}\n\nfloat mapBars(vec3 pos)\n{     \n    vec3 pos0 = pos;\n    float fact = T0*TF*0.5;\n    \n    vec3 posr = pos;\n    posr.z = mod(posr.z + 1000., TF*TF + 3.6);\n    posr.yz = rotateVec45(posr.yz);\n    vec3 posri = pos;\n    posri.z = mod(posri.z + 1000., TF*TF + 3.6);\n    posri.yz = rotateVec45i(posri.yz);\n   \n    pos = abs(pos);\n    pos.xy-= vec2(fact*TF);\n    \n    posr = abs(posr);\n    posr.xy-= vec2(fact*TF);\n    posr.y+= TF;\n \n    posri = abs(posri);\n    posri.xy-= vec2(fact*TF);\n    posri.y+= TF;\n    \n    vec3 pos2 = abs(pos);\n    pos2.xy-= vec2(fact);\n    \n    vec3 posr2 = abs(posr);\n    posr2.xy-= vec2(fact);\n    \n    vec3 posri2 = abs(posri);\n    posri2.xy-= vec2(fact);\n    \n    //return bar(pos2, T0/2.);\n        \n    float v1 = min(min(bar(pos2, T0/2.), mapBarsRot(pos)), mapBarsRot(pos.yxz));\n    float v2 = min(min(bar(posr2, T0/2.), mapBarsRot(posr)), mapBarsRot(posr.yxz));\n    float v3 = min(min(bar(posri2, T0/2.), mapBarsRot(posri)), mapBarsRot(posri.yxz));\n    float v4 = max(min(v2, v3), bar(pos0/TF, fact + T0/2.));\n    return min(v1, v4);\n}\n\nfloat mapBars2(vec3 pos)\n{\n    return min(mapBars(pos), mapBars(pos.yxz));\n}\n\nvec3 getWaveDelta(vec3 pos)\n{\n    #ifdef curved_framework\n    return vec3(35.*sin(pos.z/368.) + 41.*sin(pos.z/185.) + 2.*sin(pos.z/96.), \n                75.*sin(pos.z/225.) + 9.*sin(pos.z/78.) + 5.*sin(pos.z/118.), \n                0.);\n    #else\n    return vec3(0.);\n    #endif\n}\n\n// Combines all the distance fields\nvec2 map(vec3 pos)\n{\n    pos+= getWaveDelta(pos);\n    return vec2(mapBars2(pos), FRAMEWORK_OBJ);           \n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.;\n    float objnr = 0.;\n    \n    for (int i = 0; i < 64; ++i) // 64 85\n    {\n    \tvec3 pos = ray*t + cam;\n        vec2 res = map(pos);\n    \tfloat dist = res.x;\n        if (dist>maxdist || abs(dist)<0.08)\n            break;\n        t+= dist*(0.9 + float(i)*0.009);\n        //t+= dist*0.82;\n        objnr = abs(res.y);\n\t}\n\treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e)\n{  \n    e = pow(distance(campos, pos), 2.)*0.00001;\n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,\n                          map(pos + q.xyx).x - map(pos - q.xyx).x,\n                          map(pos + q.xxy).x - map(pos - q.xxy).x));\n}\n\n// Gets the color of the metal rings\nvec3 framework_color(vec3 pos,vec3 norm)\n{\n    #ifdef color_changes\n    vec3 fc = vec3(0.58 + 0.03*sin(pos.z/687.), \n                   0.41 + 0.09*sin(pos.z/537.), \n                   0.12 + 0.07*sin(pos.z/856.));\n    #else\n    vec3 fc = vec3(0.58, 0.41, 0.12);\n    #endif\n    vec2 tpos = vec2(dot(pos.yx, norm.xy) + pos.z, dot(pos.yz, norm.zy) - 1.5*pos.z + 0.2);\n    vec3 mc = texture(iChannel0, 0.1*tpos).rgb;\n    float mc2 = texture(iChannel1, 0.01*tpos).r;\n    vec3 col1 = mix(mix(mc, fc*mc, 0.5), fc, 0.4);\n    col1 = mix(col1, vec3(0.05), smoothstep(0.65, 1., mc2));\n    col1 = mix(col1, vec3(0.42, 0.19, 0.13), smoothstep(0.55, 0., mc2));\n        \n    return col1;\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{\n    return fogColor;\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 5;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map(p + rd.x).x) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.35*(1.-ao/float(nbIte)), 0., 1.);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(DirLamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n\tvec3 pl = normalize(lamp.direction);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dot(norm, pl));\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.direction) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(vec3(lamp.position.x, 4.9, lamp.position.z) - pos), shf, 100.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n \n    lamps[0] = DirLamp(vec3(-2., 1., -5.), vec3(1., 1., 1.), 1.5);\n    lamps[1] = DirLamp(vec3(2., 3., -5.), vec3(1., .95, .75), 1.5);\n    lamps[2] = DirLamp(vec3(2., -1., 5.), vec3(0.6, 0.75, 1.), 1.5);\n\n    // Fog\n    #ifdef fog_variation\n    fogdensf = 0.15*sin(tpos.z/452.) + 0.1*sin(tpos.z/216.) + 0.05*sin(tpos.z/143.);\n    #else\n    fogdensf = 0.3;\n    #endif\n    float fogdens = (1.2 + 2.*fogdensf)*fogdens0;\n    fogColor = mix(fogColor2, fogColor1, 0.7 + fogdensf);\n    \n    if (tx<maxdist)\n    {\n        norm = getNormal(pos, normdelta);\n        col = framework_color(pos, norm);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm, 7., 1.1));\n        //col = vec3(calcAO(pos, norm, 25., 0.9));\n        #endif\n        \n        float fogd = clamp(exp(-pow(fogdens*tx, 2.)), 0., 1.);\n        col = mix (fogColor, col, fogd);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = sky_color(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections\nvec4 render(vec2 fragCoord)\n{   \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \n  RenderData traceinf = trace0(campos, ray, maxdist);\n  vec3 col = traceinf.col;\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    campos = vec3(0., 0., iTime*cspeed);\n    campos-= getWaveDelta(campos);\n    camdir = getCameraDir();\n    camdir+= (getWaveDelta(campos - camdir*vec3(0., 0., 0.)) - getWaveDelta(campos + camdir*vec3(0., 0., 20.)))*0.055;\n    \n    // Antialiasing\n    #ifdef antialiaising\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdK3Rm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1569, 1589, 1611, 1611, 1646], [1648, 1648, 1677, 1677, 1787], [1789, 1789, 1819, 1819, 1929], [1931, 2003, 2024, 2024, 2570], [2572, 2572, 2602, 2602, 2708], [2710, 2710, 2738, 2738, 3180], [3182, 3182, 3207, 3207, 4243], [4245, 4245, 4271, 4271, 4321], [4323, 4323, 4352, 4352, 4604], [4606, 4642, 4662, 4662, 4751], [4753, 4778, 4826, 4826, 5188], [5190, 5357, 5392, 5392, 5672], [5674, 5711, 5753, 5753, 6386], [6388, 6417, 6443, 6443, 6466], [6468, 6468, 6536, 6536, 6769], [6771, 6806, 6893, 6893, 7457], [7459, 7500, 7562, 7562, 7720], [7722, 7778, 7842, 7842, 8090], [8092, 8123, 8178, 8178, 9457], [9459, 9500, 9529, 9529, 9797], [9799, 9799, 9854, 9854, 10585]], "test": "untested"}
{"id": "MdK3zy", "name": "Curl 2D", "author": "nsweb", "description": "Experiment with the curl operator in 2D.\n\n", "tags": ["curl", "vectorfield"], "likes": 7, "viewed": 344, "published": "Public", "date": "1455626788", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// 2D curl operator visualization \n#define SHOW_VECTORFIELD\n#define SHOW_ARROW\n\nconst float TILE_SIZE = 0.045;\n\nvec2 sdCapsule(vec3 p, vec3 p0, vec3 p1, float r)\n{\n    vec3 v = vec3( p1 - p0 );\n\tvec3 w = vec3( p - p0 );\n\tfloat t_seg = max( dot( v, w ), 0.0 );\n\n\tfloat v2 = dot( v, v );\n\tt_seg = min( t_seg, v2 );\n\tt_seg = t_seg / v2;\n\tw += v*(-t_seg);\n\n\treturn vec2( sqrt( dot( w, w) ) - r, t_seg );\n}\n\n// computes arrow center location from given pos\nvec3 arrowTilePos(vec3 p) \n{\n\treturn (floor(p / TILE_SIZE) + 0.5) * TILE_SIZE;\n}\n\n// the vector field on which we'll apply the curl operator\n// in 2d, it's just a scalar field\nfloat field2d(vec3 p)\n{\n    float f = cos(10.0*p.x+iTime)* sin(10.0*p.y+iTime);\n    return f;\n}\n\n// the curl operator in 2d\nvec3 curl2d(vec3 p)\n{\n    vec3 e = vec3(0.001,-0.001,0.0);\n    float fxp = field2d(p + e.xzz);\n    float fxm = field2d(p + e.yzz);\n    float fyp = field2d(p + e.zxz);\n    float fym = field2d(p + e.zyz);\n\n    vec3 c = vec3( \t(fyp - fym) / (2.*e.x),\n                 \t(-fxp + fxm) / (2.*e.x),\n                 \t0.0 );\n\treturn c;   \n}\n\n// get the arrow color under pos (transparent if no hit)\nvec4 arrowColor(vec3 p, vec3 arrow_center, vec3 arrow_vec) \n{\n    float scale = TILE_SIZE;\n    arrow_vec = normalize( arrow_vec );\n\tvec2 darrow = sdCapsule(p, arrow_center - arrow_vec*scale, arrow_center + arrow_vec*scale, (TILE_SIZE*1.005)*0.5 );\n\tif( darrow.x > 0.0 )\n        return vec4(0.0);\n    \n    return vec4( mix(vec3(0.2,0.0,0.0), vec3(0.5,1.0,0.5), darrow.y), 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 p = vec3( (fragCoord.xy / iResolution.xx - 0.5) * 2.0, 0.0 );\n    \n    vec4 col = vec4(0.0);\n#ifdef SHOW_ARROW\n    col = arrowColor( p, arrowTilePos(p), curl2d( arrowTilePos(p) ) );\n#endif\n#ifdef SHOW_VECTORFIELD\n\tvec3 vf = vec3(field2d( p ));\n    col = mix( vec4(vf*0.5+0.5,1.0), col, col.a );\n#endif\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdK3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 113, 164, 164, 402], [404, 453, 481, 481, 533], [535, 629, 652, 652, 724], [726, 753, 774, 774, 1084], [1086, 1143, 1204, 1204, 1522], [1524, 1524, 1581, 1581, 1917]], "test": "untested"}
{"id": "MdKGDy", "name": "simple eyeball tut from iq", "author": "amdbcg", "description": "This is the result from this tutorial: <br/>https://www.youtube.com/watch?v=emjuqqyq_qc&feature=youtu.be&t=18 <br/>in order to follow along, you will need a noise function. you can copy mine or make your own. <br/>", "tags": ["tutorial", "eyeball"], "likes": 2, "viewed": 169, "published": "Public", "date": "1456284630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//alternative noise implementation\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\nmat2 m = mat2 (0.8 ,0.6,-0.6,0.8);\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat fbm (vec2 p)\n{\n\n\tfloat f = 0.0;\n    f += 0.5000*noise( p ); p*=m*2.02;\n    f += 0.2500*noise( p ); p*=m*2.03;\n    f += 0.1250*noise( p ); p*=m*2.01;\n    f += 0.0625*noise( p ); p*=m*2.04;\n    f /= 0.9375;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q  = fragCoord.xy / iResolution.xy;\n\tvec2 uv = q;\n    vec2 p = -1.0 +2.0*q;\n    p.x *= iResolution.x / iResolution.y;\n    float r = sqrt(dot(p,p));\n    \n    float ss = 0.5 + 0.5*sin(3.0*iTime);\n    float anim = 1.0 + 0.1*ss*clamp(1.0-r,0.0,1.0);\n    r *= anim;\n    float a = atan(p.y, p.x);\n\t//float f = fbm( 4.0*p);\n\t vec3 col = vec3(1.0);\n    if (r < 0.8){\n    \tcol = vec3(0.0, 0.3, 0.4);\n    \t\n        float f = fbm (7.0*p);\n        col = mix(col, vec3 (.2, .4, .5), f);\n        \n        f =1.0- smoothstep( 0.2, 0.5, r ); \n        col = mix(col,vec3(0.9, 0.8,0.2), f);\n        a += 0.05*fbm(5.0*p);\n        f = smoothstep(0.3, 1.0, fbm( vec2(6.0*r,20.0*a) )  );\n        col = mix(col, vec3(1.0), f);\n        \n        f = smoothstep(0.4, 0.9, fbm( vec2(8.00*r,10.0*a) )  );\n        col *= 1.0- f;              \n        \n        f = smoothstep(0.5, 0.8, r);\n        col *= 1.0-0.5*f;              \n        \n        f = smoothstep(0.6 ,0.8, r );\n        col *=1.0- f;\n        \n        f = 1.0- smoothstep(0.0 , 0.5, length (p - vec2(0.24, 0.2) ) ) ;\n        col += vec3(1.0,0.9,0.8)*f*0.9; \n        \n         f = smoothstep( 0.2, 0.5, r ); \n        col *= f;\n    }\n   // col *= length(uv - vec2(sin(iTime),0.5));\n   // col *= distance(uv, vec2(2.0,1.0));\n     col *= 1.0 - smoothstep( 0.4, .4, abs(uv.y-0.5) );\n    \n    //col *= cross(col,vec3(1.0,1.0,1.0));\n\tfragColor = vec4(col,1.0);\n    \t\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 35, 58, 58, 100], [137, 137, 163, 163, 369], [371, 371, 391, 391, 597], [599, 599, 656, 656, 2063]], "test": "untested"}
{"id": "MdKGzK", "name": "Electric V-Day", "author": "Hsaka", "description": "Valentines day mashup of Noise animation - Electric (https://www.shadertoy.com/view/ldlXRS) by nimitz and Heart (https://www.shadertoy.com/view/XsfGRn) by iq", "tags": ["procedural", "2d", "noise"], "likes": 15, "viewed": 451, "published": "Public", "date": "1455426509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//V-Day version of Noise animation - Electric by nimitz (https://www.shadertoy.com/view/ldlXRS)\n\n//The domain is displaced by two fbm calls one for each axis.\n//Turbulent fbm (aka ridged) is used for better effect.\n\n#define time iTime*0.05\n#define tau 6.2831853\n\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\n\nfloat fbm(in vec2 p)\n{\t\n\tfloat z=3.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i < 6.;i++)\n\t{\n\t\trz+= abs((noise(p)-0.5)*30.)/z;\n\t\tz = z*2.;\n\t\tp = p*2.;\n\t}\n\treturn rz;\n}\n\nfloat dualfbm(in vec2 p)\n{\n    //get two rotated fbm calls and displace the domain\n\tvec2 p2 = p*.7;\n\tvec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));\n\tbasis = (basis-.5)*.2;\n\tp += basis;\n\t\n\t//coloring\n\treturn fbm(p*makem2(time*0.2));\n}\n\nfloat heart(vec2 p) \n{\n\tfloat r = length(p);   \n    float a = atan(p.x,p.y)/3.141593;\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n    \n    // color\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n    \n\treturn abs(mod(s*4.9,tau)-3.14)*5.+.1;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//setup system\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tp*=4.;\n\t\n    float rz = dualfbm(p);\n\t\n\t//heart\n\tp /= exp(mod(time*10.,3.14159));\n\trz *= pow(abs((.8-heart(p))),.9);\n\t\n\t//final color\n\tvec3 col = vec3(.9,0.1,0.4)/rz;\n\tcol=pow(abs(col),vec3(.99));\n\tfragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 263, 291, 291, 356], [357, 357, 382, 382, 418], [420, 420, 442, 442, 594], [596, 596, 622, 678, 836], [838, 838, 860, 860, 1221], [1223, 1223, 1280, 1296, 1604]], "test": "untested"}
{"id": "MdV3Dw", "name": "Beachball HDD", "author": "Hanley", "description": "Mac Beachball of doom.", "tags": ["beachball"], "likes": 2, "viewed": 160, "published": "Public", "date": "1454883121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///////////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n//  Function from IÃ±igo Quiles \n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float u_time = iTime;\n  vec2 u_mouse = iMouse.xy;\n  vec2 u_resolution = iResolution.xy; //. // Note: Could use #define u_time iTime \\n instead of this in the future.\n\n    \n\tvec2 st = fragCoord.xy/u_resolution.xy; // pixel_n\n\n        // Quick Aspect Ratio Fix\n    float aspect = u_resolution.x / u_resolution.y;\n    st.x *= aspect;\n    \n    // \"HSB was originally designed to be represented in polar coordinates (based on the angle and radius) instead of cartesian coordinates (based on x and y).\"\n    vec3 color = vec3(0.0);\n\n    // Using Polar Coordinates instead of Cartesian\n    vec2 vectorToCentre = vec2(0.5) - st;\n    float angle = atan(vectorToCentre.y, vectorToCentre.x); // function is atan(y,x) , not x,y\n    float distanceToCentre = length(vectorToCentre);\n    float radius = distanceToCentre * 2.0;\n    // Bend Hue based on Time and Angle\n    angle = angle + u_time*5.0 - radius*2.5;\n    \n    // Set Color\n    vec3 hue = vec3(angle/TWO_PI+0.5, radius, 1.0);\n    color = hsb2rgb(hue);\n\n    // Set Alpha\n    float alpha = smoothstep(0.5, 0.46, distanceToCentre);\n\n    // Render Color\n\tfragColor = vec4(color*alpha, 1.0);\n    \n    // fragColor = gl_FragColor; // .\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdV3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 205, 231, 231, 392], [394, 394, 451, 451, 1629]], "test": "untested"}
{"id": "MdV3zy", "name": "Eric's bum", "author": "idwyr", "description": "Flat Eric's bum", "tags": ["flateric"], "likes": 1, "viewed": 107, "published": "Public", "date": "1455226516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat opBlend( vec3 p )\n{\n    float d1 = sdSphere(p - vec3( -0.1, 0.95,  0.37), 0.46 );\n    float d2 = sdSphere(p - vec3( -0.1, 0.95, -0.37), 0.46 );\n    float d3 = smin( d1, d2, 0.25 ); \n    float d4 = sdSphere(p - vec3( -0.1, 0.5,  0.0), 0.45 );\n    return smin( d3, d4, 0.5 )+ 0.003*sin(90.20*p.x+47.0*p.z)*sin(127.0*p.y)*sin(129.0*p.z);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1 ), vec2 (opBlend(pos),35));\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.3, 0.5, 0.6)  ;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\t col = 0.55 + 0.3*sin( vec3(0.05,0.08,0.20)*(m-1.0) );\n\t\t\n        if( m < 3.0)\n        {\n            \n            col =    vec3(0.1, 0.1, 0.1);\n        }\n\t\t\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.5, 0.4, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        if (m > 2.0) { \n        lin += 1.20*dif*vec3(1.00,0.75,0.00);\n\t\tlin += 0.50*spe*vec3(1.00,0.85,0.95)*dif;\n        lin += 0.50*amb*vec3(1.0,0.70,0.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,0.80,0.00)*occ;\n\t\tcol = col*lin;\n        } else {\n           \n        lin += 1.20*dif*vec3(0.9,0.9,0.900);\n\t\tlin += 0.50*spe*vec3(0.00,0.85,0.95)*dif;\n        lin += 0.50*amb*vec3(0.8,0.70,0.70)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(0.00,0.80,0.900)*occ;\n\t\tcol = col*lin;\n            \n        }\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\t vec3 ro = vec3( -0.9+2.0*cos(0.1*time + 6.0*mo.x), 2.6  , 0.9 - 2.0*sin(0.1*time + 6.0*mo.x) )  ;\n    \n\tvec3 ta = vec3(  -0.3,   0.6, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdV3zy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[125, 378, 403, 403, 418], [420, 420, 455, 455, 481], [483, 483, 514, 514, 601], [603, 677, 707, 707, 740], [743, 743, 784, 784, 877], [880, 880, 905, 905, 1222], [1224, 1298, 1323, 1323, 1425], [1427, 1427, 1467, 1467, 2057], [2060, 2060, 2134, 2134, 2395], [2397, 2397, 2429, 2429, 2650], [2652, 2652, 2694, 2694, 2993], [2998, 2998, 3037, 3037, 4751], [4753, 4753, 4805, 4805, 4982], [4984, 4984, 5041, 5041, 5636]], "test": "untested"}
{"id": "MdVGDV", "name": "Ray Marching Practice 3c", "author": "Takoa", "description": "Quite simple one, just for practicing<br/>Simpler and normalized version of 3b (Disney's diffuse)<br/><br/>3b: <a href=\"https://www.shadertoy.com/view/lsGGR3\" class=\"regular\" target=\"_blank\">https://www.shadertoy.com/view/lsGGR3</a>", "tags": ["3d", "raymarching"], "likes": 0, "viewed": 310, "published": "Public API", "date": "1456588730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Spheres with simpler Disney's diffuse\n// \n// http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n//\n// The diffuse is normalized according to the Frostbite course notes.\n//\n// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\n\n#define PI 3.1415926\n#define INV_PI 0.31830988\n#define INV_GAMMA 0.45454545\n\n#define EPSILON 0.0001\n\nvec3 sphereColor = vec3(0.3, 0.9, 0.6);\n\nvec3 cameraPosition = vec3(0.0, 0.0, 2.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraLookingAt = vec3(0.0, 0.0, -100.0);\n\nfloat roughness = 0.3;\n\nfloat getDistanceToSphere(vec3 rayPosition, vec3 spherePosition, float radius)\n{\n    return length(spherePosition - rayPosition) - radius;\n}\n\nfloat getDistance(vec3 position)\n{\n    return min(\n        getDistanceToSphere(position, vec3(-0.5, 0.0, 0.0), 1.0),\n        getDistanceToSphere(position, vec3(0.5, 0.0, 0.0), 1.0));\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n          getDistance(p + vec3(EPSILON, 0.0, 0.0)) - getDistance(p - vec3(EPSILON, 0.0, 0.0)),\n          getDistance(p + vec3(0.0, EPSILON, 0.0)) - getDistance(p - vec3(0.0, EPSILON, 0.0)),\n          getDistance(p + vec3(0.0, 0.0, EPSILON)) - getDistance(p - vec3(0.0, 0.0, EPSILON))\n        ));\n}\n\nvec3 getRayDirection(vec2 screenPosition, vec3 origin, vec3 lookingAt, vec3 up, float fov)\n{\n    vec3 d = normalize(lookingAt - origin);\n    vec3 rayRight = normalize(cross(d, up));\n    \n    return normalize(screenPosition.x * rayRight + screenPosition.y * up + 1.0 / tan(radians(fov / 2.0)) * d);\n}\n\nfloat rayMarch(inout vec3 p, vec3 rayDirection)\n{\n    float d;\n    \n    for (int i = 0; i < 128; i++)\n    {\n        d = getDistance(p);\n        p += d * rayDirection;\n    }\n    \n    return d;\n}\n\nvec3 pow3(vec3 color, float g)\n{\n    return vec3(pow(color.x, g), pow(color.y, g), pow(color.z, g));\n}\n\nfloat getSchlicksApproximation(float f)\n{\n    float g = clamp(1.0 - f, 0.0, 1.0);\n    float g2 = g * g;\n    \n    return g2 * g2 * g;\n}\n\nvec3 getDisneysReflectance(\n    vec3 normal,\n    vec3 lightDirection,\n    vec3 viewDirection,\n    vec3 baseColor,\n    float roughness)\n{\n    float cosL = dot(normal, lightDirection);\n    \n    if (cosL < 0.0)\n        return vec3(0.0);\n    \n    float cosV = dot(normal, viewDirection);\n    float cosD = dot(lightDirection, normalize(lightDirection + viewDirection));\n    float fl = getSchlicksApproximation(cosL);\n    float fv = getSchlicksApproximation(cosV);\n    float fD90M1 = mix(-1.0, -0.5, roughness) + 2.0 * cosD * cosD * roughness;\n    float fD = (1.0 + fD90M1 * fl) * (1.0 + fD90M1 * fv) * mix(1.0, 0.66225165, roughness);\n    \n    return baseColor * INV_PI * fD * cosL;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 lightPosition = vec3(10.0 * cos(iTime), 10.0, 10.0 * sin(iTime));\n    vec3 rayDirection = getRayDirection(position, cameraPosition, cameraLookingAt, cameraUp, 90.0);\n    vec3 p = cameraPosition;\n    float d = rayMarch(p, rayDirection);\n    \n    if (d < EPSILON)\n    {\n        vec3 normal = getNormal(p);\n        vec3 lightDirection = normalize(lightPosition - p);\n        vec3 diffuse = getDisneysReflectance(\n            normal,\n            lightDirection,\n            -rayDirection,\n            sphereColor,\n            roughness\n\t\t);\n        \n        fragColor = vec4(pow3(diffuse, INV_GAMMA), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 621, 701, 701, 761], [763, 763, 797, 797, 947], [949, 949, 973, 973, 1298], [1300, 1300, 1392, 1392, 1599], [1601, 1601, 1650, 1650, 1794], [1796, 1796, 1828, 1828, 1898], [1900, 1900, 1941, 1941, 2034], [2036, 2036, 2172, 2172, 2715], [2717, 2717, 2772, 2772, 3528]], "test": "untested"}
{"id": "MdVGDW", "name": "Sphere grid by Cubemap", "author": "foxes", "description": "Example of sphere grid by Cubemap. For view rezul of calculation level detail.", "tags": ["grid", "cubemap", "quadtree", "shere"], "likes": 15, "viewed": 1376, "published": "Public API", "date": "1454588023", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float res;\n\nfloat snoise(vec3 x)\n{\n    //float n=dot(x,vec3(1.0,23.0,244.0));\n    //return fract(sin(n)*1399763.5453123);\n    return fract((x.x+x.y)*0.5);\n}\n\nfloat sphereLeveled(vec3 ray,vec3 pos,float r)\n{\n    float level=1.;\n  \tfloat b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n\tfloat rq=r*r;\n    float s=0.0;\n    if(c <rq) {\n        int z=0;\n        float l1=sqrt(r-c);\n        vec3 r1= ray*(b-l1)-pos;\n        vec3 r2=abs(r1);\n        float m=max(max(r2.x,r2.y),r2.z);\n        vec3 r3=r1/abs(m);\n        vec3 p;\n        if ((r2.y<=r2.z) || (r2.y<=r2.x)) {\n\t\t\tp.x=r3.x;\n\t\t\tif (r3.z<0.) z=2;\n\t\t\tif (r3.z>0.) z=0;\n\t\t\tif (r2.x>r2.z) {\n\t\t\t\tp.x=r3.z;\n\t\t\t\tif (r3.x>0.) z=1;\n\t\t\t\tif (r3.x<0.) z=3;\n\t\t\t}\n\t\t\tp.y=r3.y;\n        } else {\n\t\t\tp.x=r3.x;\n\t\t\tp.y=r3.z;\n\t\t\tif (r3.y>0.) z=4;\n\t\t\tif (r3.y<0.) z=5;\n        }\n        //vec2 si=vec2(1.0);\n        //if (p.x<0.0) si.x=-si.x;\n        //if (p.y<0.0) si.y=-si.y;\n        //p.xy=abs(p.xy);\n        //p.x=pow(p.x,0.9);\n        //p.y=pow(p.y,0.9);\n        //p.xy*=si;\n        \n        float l=0.8;//max(0.1,abs(dot(ray,normalize(r1))));\n        //l=min(l,0.9);\n               \n        float d=16.0;\n        vec2 rs;        \n        \n        //for (float i=0.0;(i<17.0);i+=1.0) {\n        \tvec3 rp=p;\n        \n        \t//vec3 posp;\n\t\t\t//if (rp.z==0.) posp=vec3(rp.x-0.5,rp.y-0.5,0.5);\n\t\t\t//if (rp.z==1.) posp=vec3(0.5,rp.y-0.5,0.5-rp.x);\n\t\t\t//if (rp.z==2.) posp=vec3(0.5-rp.x,rp.y-0.5,-0.5);\n\t\t\t//if (rp.z==3.) posp=vec3(-0.5,rp.y-0.5,rp.x-0.5);\n\t\t\t//if (rp.z==4.) posp=vec3(rp.x-0.5,0.5,0.5-rp.y);\n\t\t\t//if (rp.z==5.) posp=vec3(0.5-rp.x,-0.5,0.5-rp.y);\n        \t//posp=normalize(posp);\n\n        \td=max(0.0,log(iResolution.y*0.04/length(pos+r1))*1.4); //1.6609640474436811 3.321928094887362347870\n        \tlevel=d-fract(d)+1.0;\n        \n        \tfloat scale=pow(2.0,level);\n        \tfloat iscale=1.0/scale;\n        \trs=fract(rp.xy*scale)-0.5;\n        \tvec2 rpd=(rp.xy-(rs)*iscale)*0.5;\n        \n        \tvec3 posp=r1;\n\t\t\tif (z==0) posp=vec3(rpd.x,rpd.y,0.5);\n\t\t\tif (z==1) posp=vec3(0.5,rpd.y,rpd.x);\n\t\t\tif (z==2) posp=vec3(rpd.x,rpd.y,-0.5);\n\t\t\tif (z==3) posp=vec3(-0.5,rpd.y,rpd.x);\n\t\t\tif (z==4) posp=vec3(rpd.x,0.5,rpd.y);\n\t\t\tif (z==5) posp=vec3(rpd.x,-0.5,rpd.y);\n        \tposp=normalize(posp);\n        \n        \td=max(0.0,log(iResolution.y*0.04/length(pos+posp))*1.4);\n        \tlevel=d-fract(d);\n        \n        \tscale=pow(2.0,level);\n        \tiscale=1.0/scale;\n        \trs=fract(rp.xy*scale)-0.5;\n\n        \t//if (level<d) level+=1.0;\n        //}\n        vec2 rs2=abs(rs)*2.0;\n        rs2=(max(rs2,0.1+l*0.8)-0.1-l*0.8)/(1.0-0.1-l*0.8);\n        //rp.xy=rp.xy*scale-fract(rp.xy*scale);\n        \n        //s=snoise(rp);\n        s=fract(rs2.x)+fract(rs2.y);//min(fract(rp.x)+fract(rp.y),1.0);\n    }\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = 1.0 / iResolution.y;\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) *res;\n    \n    vec3 ray = normalize(vec3(p,2.0));\n    \n\tfloat mx = iMouse.x>0.0?iMouse.x/iResolution.x*5.0:0.5;\n    float my = iMouse.y>0.0?iMouse.y/iResolution.y*2.0-1.0:0.0;\n    \n    float dist=(1.0+sin(iTime*0.25))*0.5;\n    dist=pow(dist,5.0);\n    \n    vec4 rotate = vec4(mx,my,-1.115*(1.0-dist),1.115*(1.0-dist));\n\n    vec4 sins=sin(rotate);\n    vec4 coss=cos(rotate);\n    mat3 mr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\n    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr; \n    \n    mat3 mr2=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.z,sins.z),vec3(0.0,-sins.z,coss.z));\n    mat3 mr3=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.w,sins.w),vec3(0.0,-sins.w,coss.w));\n\n    float s1=sphereLeveled(ray*mr3*mr,vec3(0.0,0.0,1.00005+2.0*dist)*mr3*mr2*mr,1.0);\n    \n    fragColor=vec4(s1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 34, 121, 156], [158, 158, 206, 206, 2759], [2761, 2761, 2818, 2818, 3737]], "test": "untested"}
{"id": "MdVGzV", "name": "distance field shape calc", "author": "ypn", "description": "distance field floor", "tags": ["distancefieldfloor"], "likes": 0, "viewed": 93, "published": "Public", "date": "1455473876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n#define t iTime\n#define res iResolution.xy\n\nvec3 cpos = vec3(0.0, 0.0, 5.0);\nvec3 cdir = normalize(-cpos);\nvec3 cside = vec3(1.0, 0.0, 0.0);\nvec3 cup  = cross(cside, cdir);\nvec3 light = normalize(vec3(0.1, 0.2, 1.0));\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat opS( float d1, float d2 ){\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 ) {\n    return min(d1,d2);\n}\n\nfloat opI( float d1, float d2 ) {\n    return max(d1,d2);\n}\n\nfloat box( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat dist(vec3 p){\n    vec3 p0 = rotate(p, t * 2., vec3(0.0,1.0,0.0)) + vec3(-1.0, 0.0,0.0);\n    vec3 p1 = rotate(p, t, vec3(0.0,1.0,0.0)) + vec3(1.0, 0.0,0.0);\n    float d = 100.0;\n    d = opI(box(p0, vec3(1.2)),\n                opU(box(p, vec3(0.8))\n                    , box(p1, vec3(0.8))\n               \t)\n           );\n    return d;\n}\n\n\nvec3 norm(vec3 p){\n\tvec2 d = vec2(0.001, 0.0);\n    float di = dist(p);\n\treturn normalize(vec3(di - dist(p - d.xyy), di - dist(p - d.yxy), di - dist(p - d.yyx)));\n}\n\nfloat shadow(vec3 o, vec3 d){\n    o += norm(o) * 0.001;\n\tfloat len = 0.0, lev = 1.0;\n\tfor(float t = 0.0; t < 32.0; t++){\n\t\tfloat di = dist(o + d * len);\n\t\tif (di < 0.001){ return 0.5;}\n\t\tlev = min(lev, di  * 24.0 / min(len, 1.0));\n\t\tlen += di;\n\t}\n\treturn max(0.5, lev) ;\n}\n\nvec3 phong(vec3 p, vec3 ray) {\n    vec3 n = norm(p);\n    return vec3(0.2,0.2,0.2) * clamp(dot(light, n), 0.0, 1.0)\n\t\t+ pow(clamp(dot(normalize(light - ray), n), 0.0, 1.0), 256.0) * 0.2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - res) / min(res.x, res.y);\n\tvec3 ray = normalize(cside * p.x + cup * p.y + cdir * 2.0);\n\n\tfloat len = 0.0, di;\n\tvec3 rhead = cpos;\n\tfor(int i = 0; i < 64; i++){\n\t\tdi = dist(rhead);\n        if (abs(di) < 0.001) {\n            break;\n        }\n\t\tlen += di;\n\t\trhead = cpos + len * ray;\n\t}\n\n\tvec3 color = vec3(1.0);\n\tif(abs(di) < 0.001){\n        color = phong(rhead, ray) * shadow(rhead, light);\n\t} \n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 292, 292, 721], [723, 723, 755, 755, 781], [783, 783, 816, 816, 841], [843, 843, 876, 876, 901], [903, 903, 932, 932, 1028], [1030, 1030, 1049, 1049, 1371], [1374, 1374, 1392, 1392, 1537], [1539, 1539, 1568, 1568, 1811], [1813, 1813, 1843, 1843, 2000], [2002, 2002, 2057, 2057, 2516]], "test": "untested"}
{"id": "Mdy3DV", "name": "Bouncy Supershapes / rev2", "author": "blurryroots", "description": "Transitioning between different shapes produced by the superformula. https://en.wikipedia.org/wiki/Superformula", "tags": ["procedural", "2d", "superformula", "supershape"], "likes": 6, "viewed": 560, "published": "Public API", "date": "1456429762", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define TWO_PI 6.28319\n\nconst float Gold = (1.0+sqrt(5.0)) / 2.0;\nconst float InvGold = 1. / Gold;\nconst float OneMinusInvGold = 1.0 - InvGold;\nconst float OneMinusInvGoldSquared = OneMinusInvGold * OneMinusInvGold;\n\nfloat superformula (float angle, vec4 shape, vec2 symmetry) {    \n    float m = shape.x;\n    float n1 = shape.y;\n    float n2 = shape.z;\n    float n3 = shape.w;\n    float a = symmetry.x;\n    float b = symmetry.y;\n\n    float rpart = (m * angle) / 4.;\n    float apart = abs (cos (rpart) / a);\n    float bpart = abs (sin (rpart) / b);\n\n    float r = pow (\n        pow (apart, n2) + pow (bpart, n3),\n        -1. / n1\n    );\n    \n    return r;\n}\n\nfloat angleBetween (vec2 a, vec2 b) {\n    float cosTheta = dot (a, b) / (length (a) * length (b));\n    \n    return acos (cosTheta);\n}\n\nvec4 createShape (float t) {    \n    float m = 1. + abs (sin (t) + cos (1.6 * t)) * 8.;\n    float n1 = 1. + abs (sin (2. * t) * 4.);\n    float n2 = 1. + (cos (t + PI / 1.6) * 2.);\n    float n3 = 2. + sin (1.6 * t + PI) * 4.;\n    \n    return vec4 (m, n1, n2, n3);\n}\n\nvec2 createSymmetry (float t) {\n    return  vec2 (.618 + sin (t + PI / 2.) * .5, .5 + cos (t) * .618);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float restraint = Gold * PI;\n    float radius = iResolution.y / restraint;\n    float border = 23.07;\n    vec4 borderColor = vec4 (0.618, 0.123, 0.987, 1.0);\n    \n    vec2 center = iResolution.xy / 2.;\n    vec2 d = fragCoord - center;\n    vec2 up = vec2 (0., 1.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n        \n    float t = iTime * 0.6;\n    float angle = angleBetween (up, d);\n    vec2 symmetry = createSymmetry (t);\n    vec4 shape = createShape (t);\n    float r = superformula (angle, shape, symmetry) * radius;\n    \n    float size = length (d); \n    vec4 colorFromShape = 1.-normalize (shape);\n    \n    if (size <= r) {\n        vec4 noise = texture(iChannel0, uv + vec2(iTime, iTime/2.0));\n        float much = (r-size);\n        fragColor = vec4(colorFromShape.rgb, much) + (noise*InvGold);\n    }\n    else if (size <= (r+border)) {\n        float much = ((r+border)-size)/border;\n        fragColor = mix(borderColor, colorFromShape, much);\n    }\n    else {\n        vec4 noise = texture(iChannel0, uv + vec2(fract(iTime), tan(iTime/2.0)));\n        fragColor = vec4 (vec3(OneMinusInvGoldSquared), 1.) + OneMinusInvGoldSquared*vec4((.5*sin(iTime)+.5)*noise.rgb, 1.0);\n    }\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdy3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 297, 297, 676], [678, 678, 715, 715, 811], [813, 813, 841, 841, 1077], [1079, 1079, 1110, 1110, 1183], [1185, 1185, 1241, 1241, 2426]], "test": "untested"}
{"id": "Mdy3Dw", "name": "Mandelzoom - 108 chars", "author": "GregRostami", "description": "Trying to get a semi-pretty Mandelbrot zoom in one tweet. Please help.\nThe Mandelbrot code is from Fabrice's https://www.shadertoy.com/view/4sK3Dz\nThe zoom code is a modification of iq's https://www.shadertoy.com/view/lllGWH", "tags": ["mandelbrot", "zoom", "short", "tweet", "2tc", "onetweet"], "likes": 5, "viewed": 2414, "published": "Public API", "date": "1454734124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 o, vec2 u) {\t\t\t\t\t\t\t\t\t\t\t\\\nwhile(o.a++<98.)\n    o.rg=.55-mat2(-o.g,o.r,o)*o.gr+(u/iResolution.y-.8)*(1.+cos(.1*iTime)); } /*\n\n// The Mandelbrot code is from Fabrice and the zoom is a mod of iq's 2TC Mandelzoom.\n// Thanks to coyote we saved another 3 chars:\n// A BIG thanks to akohdr for reducing the Mandelbrot matrix by 3 chars!!\n\nvoid mainImage(out vec4 o,vec2 u) \n{\n    o = vec4(0);\n    for (int i=0; i++ < 97;) \n       o.rg = .55 - mat2(-o.g,o.r,o)*o.gr + (u/iResolution.y-.8)*(1.+cos(.2*iTime));\n}\n\n\n\n// 134 chars - This one does not work on iOS browsers!?\n\nvoid mainImage(out vec4 o,vec2 u) \n{\n    o -=o;\n    for (int i=0; i < 97; i++) \n       o.rg = .55 - mat2(-o.g,o.r,o)*o.gr + (u/iResolution.y-.8)*(1.+cos(.2*iDate.w));\n}\n\n\n// Mandelbrot facing the correct direction and centered (147 chars):\n\nvoid mainImage( out vec4 O, vec2 p ) \n{\n    O-=O;\n    p = p/iResolution.y-.2;\n    p.x -= .6;\n    for (int i=0; i < 97; i++) \n       O.gr = .55 - mat2(O.gr,-O.r,O.g)*O.gr - p*(1.+cos(.2*iDate.w));\n}\n\n\n// Here's a version that's bigger than one tweet with better motion (144 chars):\n\nvoid mainImage( out vec4 O, vec2 p )\n{\n    O-=O;\n    for (int i=0; i < 97; i++)\n    O.gr = .56 - mat2(O.gr,-O.r,O.g)*O.gr + (p/iResolution.y-.8)*pow(.01,.9+cos(.2*iDate.w));\n}\n\n\n// The original code at 140 chars\n\nvoid mainImage( out vec4 O, vec2 p ) \n{\n    O-=O;\n    for (int i=0; i < 99; i++) \n       O.yx = -(mat2(O.yx,-O.x,O.y)*O.yx-.55+(p/iResolution.y-.5)*(1.+cos(iDate.w*.2)));\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdy3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 143]], "test": "untested"}
{"id": "Mdy3zt", "name": "mandelbrot orbit trap test", "author": "asneakyfatcat", "description": "Too lazy to clean up and simplify the code for this one. Maybe later. Gets slightly pixelated at the end because of float precision. ", "tags": ["test", "mandelbrot", "orbit", "trap"], "likes": 9, "viewed": 359, "published": "Public", "date": "1455836851", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //uv.x *= iResolution.x/iResolution.y;\n    float dist = 0.;\n    uv.x = -2.+4.*uv.x;\n    uv.y = -1.+2.*uv.y;\n    // comment the next line to see the fully zoomed out view\n    uv *=pow(.1,4.+cos(.1*iTime));\n    uv.x += .275015;//;\n    uv.y += .0060445;//\n    //uv /= 5.;\n    vec4 col =vec4(1.);\n    vec2 z = vec2(0.0);\n    \n    int trap=0;\n    for(int i = 0; i < 400; i++){\n        if(dot(z,z)>4.){trap = i;break;}\n        dist = min( 1e20, dot(z,z))+cos(float(i)*12.+3.*iTime);\n        z = mat2(z,-z.y,z.x)*z + uv;\n    }\n    dist = sqrt(dist);\n\tfloat orb = sqrt(float(trap))/64.;\n    fragColor=vec4(0.,log(dist)*sqrt(dist)-orb-orb,log(dist)*sqrt(dist-abs(sin(iTime))),1.);\n    if(orb == 0.){fragColor = vec4(0.);}\n    //fragColor = (orb!=0. ? 1.-orb*vec4(9.,5.,3.,0.):vec4(0.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdy3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 883]], "test": "untested"}
{"id": "MdyGz3", "name": "lite lore", "author": "jcolman", "description": "Knight Lore homage... Work in progress.. huge thanks to P_Malin for \"R Tape loading error, 0:1\" :)", "tags": ["spectrum", "knightlore", "zxspectrum"], "likes": 5, "viewed": 152, "published": "Public", "date": "1455700511", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//------------------------------------------------------------------------\n// Jason Colman Feb 2016\n// \"lite lore\"\n// \"Knight Lore\" sprite animation\n//------------------------------------------------------------------------\n\n/*\nThanks to P_Malin for creating this shader:\n\"R Tape loading error, 0:1\"\nhttps://www.shadertoy.com/view/lsl3Rn\nA huge inspiration, showing what is possible for true \n speccy lovers :)\n*/\n\n#define SPRITE_ARCH1 0\n#define SPRITE_ARCH2 1\n#define SPRITE_WALL1 2\n#define SPRITE_WULF 10\n\n#define BITS_PER_BYTE 32.\n\n//------------------------------------------------------------------------\n// P_Malin code below\n//vec2 kResolution = vec2(256.0, 192.0);\nvec2 kResolution = vec2(192.0, 128.0);\n//vec2 kResolution = vec2(128.0, 80.0);\n//vec2 kResolution = vec2(64.0, 40.0);\n\nvec2 GetScreenPixelCoord( vec2 vScreenUV )\n{\n    vec2 vPixelPos = floor(vScreenUV * kResolution);\n    vPixelPos.y = kResolution.y - vPixelPos.y - 1.;   \n    return vPixelPos;\n}\n\n//------------------------------------------------------------------------\n// Based on P_Malin code\nfloat getIntBit(int byte, int bit)\n{\n    int p = int(pow(2., BITS_PER_BYTE - 1. - float(bit)));\n    return mod(floor(float(byte / p)), 2.);\n}\n\nint wulf1(int a)\n{\n    int r = 0;\n    r = (a < 20) ? 234625024 : (a < 21) ? 116132864 : (a < 22) ? 116655616 : (a < 23) ? 116655616 : (a < 24) ? 234359808 : (a < 25) ? 49807360 : (a < 26) ? 125304832 : (a < 27) ? 24117248 : (a < 28) ? 13107200 : (a < 29) ? 13107200 : (a < 30) ? 31457280 : (a < 31) ? 16252928 : (a < 32) ? 4063232 : (a < 33) ? 917504 : (a < 34) ? 131072 : (a < 35) ? 0 : (a < 36) ? 0 : (a < 37) ? 0 : (a < 38) ? 0 : (a < 39) ? 0 : r;\n    r = (a < 0) ? 0 : (a < 1) ? 134219776 : (a < 2) ? 100675584 : (a < 3) ? 129949696 : (a < 4) ? 67067904 : (a < 5) ? 67084288 : (a < 6) ? 31768576 : (a < 7) ? 32407552 : (a < 8) ? 50298880 : (a < 9) ? 67092480 : (a < 10) ? 65880064 : (a < 11) ? 66568192 : (a < 12) ? 70533120 : (a < 13) ? 265617408 : (a < 14) ? 535003136 : (a < 15) ? 1056718848 : (a < 16) ? 1040146432 : (a < 17) ? 469721088 : (a < 18) ? 469725184 : (a < 19) ? 234762240 : r;\n    return r;\n}\n\nint wulf1mask(int a)\n{\n    int r = 0;\n    r = (a < 20) ? 536755200 : (a < 21) ? 268312064 : (a < 22) ? 268308224 : (a < 23) ? 268308224 : (a < 24) ? 536616448 : (a < 25) ? 268176384 : (a < 26) ? 268173312 : (a < 27) ? 133693440 : (a < 28) ? 33292288 : (a < 29) ? 33292288 : (a < 30) ? 66584576 : (a < 31) ? 33423360 : (a < 32) ? 8323072 : (a < 33) ? 2031616 : (a < 34) ? 458752 : (a < 35) ? 196608 : (a < 36) ? 0 : (a < 37) ? 0 : (a < 38) ? 0 : (a < 39) ? 0 : r;\n    r = (a < 0) ? 402656256 : (a < 1) ? 503331840 : (a < 2) ? 268433408 : (a < 3) ? 268431360 : (a < 4) ? 134213632 : (a < 5) ? 134213632 : (a < 6) ? 67100672 : (a < 7) ? 67092480 : (a < 8) ? 134201344 : (a < 9) ? 134209536 : (a < 10) ? 134209536 : (a < 11) ? 134209536 : (a < 12) ? 268427264 : (a < 13) ? 536854528 : (a < 14) ? 1073725440 : (a < 15) ? 2147475456 : (a < 16) ? 2147479552 : (a < 17) ? 1073737728 : (a < 18) ? 1073739776 : (a < 19) ? 536836096 : r;\n    return r;\n}\n\nint wulf2(int a)\n{\n    int r = 0;\n    r = (a < 20) ? 528418816 : (a < 21) ? 127893504 : (a < 22) ? 64978944 : (a < 23) ? 233799680 : (a < 24) ? 2120712192 : (a < 25) ? 2120450048 : (a < 26) ? 1615265792 : (a < 27) ? 2015100928 : (a < 28) ? 503808000 : (a < 29) ? 126083072 : (a < 30) ? 8452096 : (a < 31) ? 14336 : (a < 32) ? 2048 : (a < 33) ? 0 : (a < 34) ? 0 : (a < 35) ? 0 : (a < 36) ? 0 : (a < 37) ? 0 : (a < 38) ? 0 : (a < 39) ? 0 : r;\n    r = (a < 0) ? 0 : (a < 1) ? 134219776 : (a < 2) ? 100675584 : (a < 3) ? 129949696 : (a < 4) ? 67067904 : (a < 5) ? 67084288 : (a < 6) ? 31768576 : (a < 7) ? 32407552 : (a < 8) ? 50298880 : (a < 9) ? 67092480 : (a < 10) ? 65880064 : (a < 11) ? 66568192 : (a < 12) ? 70533120 : (a < 13) ? 265617408 : (a < 14) ? 266567680 : (a < 15) ? 251412480 : (a < 16) ? 251621376 : (a < 17) ? 251623424 : (a < 18) ? 520034304 : (a < 19) ? 520034304 : r;\n    return r;\n}\n\nint wulf2mask(int a)\n{\n    int r = 0;\n    r = (a < 20) ? 1073716224 : (a < 21) ? 536856576 : (a < 22) ? 268419072 : (a < 23) ? 2113912832 : (a < 24) ? 2147467264 : (a < 25) ? 2147467264 : (a < 26) ? 2130673664 : (a < 27) ? 2118090752 : (a < 28) ? 2141184000 : (a < 29) ? 533198848 : (a < 30) ? 130284544 : (a < 31) ? 64512 : (a < 32) ? 15360 : (a < 33) ? 2048 : (a < 34) ? 0 : (a < 35) ? 0 : (a < 36) ? 0 : (a < 37) ? 0 : (a < 38) ? 0 : (a < 39) ? 0 : r;\n    r = (a < 0) ? 402656256 : (a < 1) ? 503331840 : (a < 2) ? 268433408 : (a < 3) ? 268431360 : (a < 4) ? 134213632 : (a < 5) ? 134213632 : (a < 6) ? 67100672 : (a < 7) ? 67092480 : (a < 8) ? 134201344 : (a < 9) ? 134209536 : (a < 10) ? 134209536 : (a < 11) ? 134209536 : (a < 12) ? 268427264 : (a < 13) ? 536723456 : (a < 14) ? 536854528 : (a < 15) ? 536866816 : (a < 16) ? 536868864 : (a < 17) ? 536869888 : (a < 18) ? 1073724416 : (a < 19) ? 1073724416 : r;\n    return r;\n}\n\nint arch1mask(const int a)\n{\n    int r = 0;\n    r = (a < 40) ? 2147352576 : (a < 41) ? 2147352576 : (a < 42) ? 2147352576 : (a < 43) ? 2147352576 : (a < 44) ? 2147352576 : (a < 45) ? 2147352576 : (a < 46) ? 2147352576 : (a < 47) ? 2147352576 : (a < 48) ? 2147352576 : (a < 49) ? 2147352576 : (a < 50) ? 1073610752 : (a < 51) ? 268304384 : (a < 52) ? 66846720 : (a < 53) ? 15728640 : (a < 54) ? 6291456 : (a < 55) ? 0 : (a < 56) ? 0 : (a < 57) ? 0 : (a < 58) ? 0 : (a < 59) ? 0 : r;\n    r = (a < 20) ? 268419072 : (a < 21) ? 536854528 : (a < 22) ? 536854528 : (a < 23) ? 536854528 : (a < 24) ? 1073725440 : (a < 25) ? 1073709056 : (a < 26) ? 1073709056 : (a < 27) ? 1073709056 : (a < 28) ? 1073676288 : (a < 29) ? 1073676288 : (a < 30) ? 2147418112 : (a < 31) ? 2147352576 : (a < 32) ? 2147352576 : (a < 33) ? 2147352576 : (a < 34) ? 2147352576 : (a < 35) ? 2147352576 : (a < 36) ? 2147352576 : (a < 37) ? 2147352576 : (a < 38) ? 2147352576 : (a < 39) ? 2147352576 : r;\n    r = (a < 0) ? 3072 : (a < 1) ? 32512 : (a < 2) ? 65408 : (a < 3) ? 131040 : (a < 4) ? 262112 : (a < 5) ? 524256 : (a < 6) ? 1048544 : (a < 7) ? 2097120 : (a < 8) ? 4194272 : (a < 9) ? 8388544 : (a < 10) ? 16777088 : (a < 11) ? 16776960 : (a < 12) ? 33554176 : (a < 13) ? 33554176 : (a < 14) ? 67108352 : (a < 15) ? 134216704 : (a < 16) ? 134215680 : (a < 17) ? 268433408 : (a < 18) ? 268431360 : (a < 19) ? 268427264 : r;\n    return r;\n}\n\nint arch1(int a)\n{\n    int r = 0;\n    r = (a < 40) ? 1069285376 : (a < 41) ? 1069285376 : (a < 42) ? 1069285376 : (a < 43) ? 263979008 : (a < 44) ? 867696640 : (a < 45) ? 1017380864 : (a < 46) ? 1058799616 : (a < 47) ? 1069285376 : (a < 48) ? 1069285376 : (a < 49) ? 1069285376 : (a < 50) ? 263979008 : (a < 51) ? 62652416 : (a < 52) ? 12058624 : (a < 53) ? 6291456 : (a < 54) ? 0 : (a < 55) ? 0 : (a < 56) ? 0 : (a < 57) ? 0 : (a < 58) ? 0 : (a < 59) ? 0 : r;\n    r = (a < 20) ? 133660672 : (a < 21) ? 267878400 : (a < 22) ? 66551808 : (a < 23) ? 217546752 : (a < 24) ? 523206656 : (a < 25) ? 532676608 : (a < 26) ? 535756800 : (a < 27) ? 534708224 : (a < 28) ? 534642688 : (a < 29) ? 131989504 : (a < 30) ? 970850304 : (a < 31) ? 1045430272 : (a < 32) ? 1066139648 : (a < 33) ? 1069285376 : (a < 34) ? 1069285376 : (a < 35) ? 1069285376 : (a < 36) ? 263979008 : (a < 37) ? 867696640 : (a < 38) ? 1017380864 : (a < 39) ? 1058799616 : r;\n    r = (a < 0) ? 0 : (a < 1) ? 3072 : (a < 2) ? 25344 : (a < 3) ? 63680 : (a < 4) ? 130560 : (a < 5) ? 261952 : (a < 6) ? 523968 : (a < 7) ? 1048000 : (a < 8) ? 1309632 : (a < 9) ? 3995520 : (a < 10) ? 8335104 : (a < 11) ? 8375808 : (a < 12) ? 16758272 : (a < 13) ? 8354304 : (a < 14) ? 27229184 : (a < 15) ? 65468416 : (a < 16) ? 66711552 : (a < 17) ? 133984256 : (a < 18) ? 133922816 : (a < 19) ? 133939200 : r;\n    return r;\n}\n    \nint arch2(int a)\n{\n    int r = 0;\n    r = (a < 20) ? 126615552 : (a < 21) ? 133365760 : (a < 22) ? 32964608 : (a < 23) ? 108462080 : (a < 24) ? 127270912 : (a < 25) ? 132186112 : (a < 26) ? 133627904 : (a < 27) ? 32964608 : (a < 28) ? 108462080 : (a < 29) ? 127303680 : (a < 30) ? 132186112 : (a < 31) ? 133627904 : (a < 32) ? 133627904 : (a < 33) ? 133627904 : (a < 34) ? 32964608 : (a < 35) ? 7798784 : (a < 36) ? 1441792 : (a < 37) ? 0 : (a < 38) ? 0 : (a < 39) ? 0 : r;\n    r = (a < 0) ? 0 : (a < 1) ? 0 : (a < 2) ? 0 : (a < 3) ? 0 : (a < 4) ? 0 : (a < 5) ? 805306368 : (a < 6) ? 1006632960 : (a < 7) ? 1023410176 : (a < 8) ? 998244352 : (a < 9) ? 465567744 : (a < 10) ? 1740636160 : (a < 11) ? 967835648 : (a < 12) ? 1048051712 : (a < 13) ? 125304832 : (a < 14) ? 431751168 : (a < 15) ? 238551040 : (a < 16) ? 264634368 : (a < 17) ? 266207232 : (a < 18) ? 32374784 : (a < 19) ? 107937792 : r;\n    return r;\n}\n\nint arch2mask(int a)\n{\n    int r = 0;\n    r = (a < 20) ? 268402688 : (a < 21) ? 268402688 : (a < 22) ? 268402688 : (a < 23) ? 268402688 : (a < 24) ? 268402688 : (a < 25) ? 268402688 : (a < 26) ? 268402688 : (a < 27) ? 268402688 : (a < 28) ? 268402688 : (a < 29) ? 268419072 : (a < 30) ? 268402688 : (a < 31) ? 268402688 : (a < 32) ? 268402688 : (a < 33) ? 268402688 : (a < 34) ? 134184960 : (a < 35) ? 33521664 : (a < 36) ? 8323072 : (a < 37) ? 1966080 : (a < 38) ? 0 : (a < 39) ? 0 : r;\n    r = (a < 0) ? 0 : (a < 1) ? 0 : (a < 2) ? 0 : (a < 3) ? 0 : (a < 4) ? 1879048192 : (a < 5) ? 2013265920 : (a < 6) ? 2113929216 : (a < 7) ? 2139095040 : (a < 8) ? 2143289344 : (a < 9) ? 2145386496 : (a < 10) ? 2145386496 : (a < 11) ? 2146959360 : (a < 12) ? 2147221504 : (a < 13) ? 1073479680 : (a < 14) ? 1073610752 : (a < 15) ? 536739840 : (a < 16) ? 536805376 : (a < 17) ? 536805376 : (a < 18) ? 268369920 : (a < 19) ? 268402688 : r;\n    return r;\n}\n\nint wall1(int a)\n{\n    return (a < 0) ? 0 : (a < 1) ? 25165824 : (a < 2) ? 1105199104 : (a < 3) ? 1912078336 : (a < 4) ? 2088632320 : (a < 5) ? 2132770816 : (a < 6) ? 2143805440 : (a < 7) ? 2144466944 : (a < 8) ? 1071414784 : (a < 9) ? 266280832 : (a < 10) ? 63948672 : (a < 11) ? 12841344 : (a < 12) ? 64512 : (a < 13) ? 16128 : (a < 14) ? 4032 : (a < 15) ? 1008 : (a < 16) ? 112 : (a < 17) ? 16 : 0;\n}\n\n// Return val:\n// -1 = no colour at this pixel pos\n// 0 and 1 = pixel colour\nfloat getPixel(vec2 pos, int spriteId)\n{\n    // Convert pixel pos to sprite byte address\n    float c = floor(pos.x / BITS_PER_BYTE);\n    int address = int(pos.y); \n        \n    // Sprites are 1 \"byte\" wide, i.e. up to 31 bits\n    if (c > 0. || c < 0. || address < 0)\n        return -1.;\n    \n    float byte = -1.;\n    \n    int bit = int(mod(pos.x, BITS_PER_BYTE));\n    if (spriteId == SPRITE_ARCH1)\n    {\n        int f = arch1mask(address);\n        if (getIntBit(f, bit) > 0.)\n            return (getIntBit(arch1(address), bit));\n    }\n    else if (spriteId == SPRITE_ARCH2)\n    {\n        int f = arch2mask(address);\n        if (getIntBit(f, bit) > 0.)\n            return (getIntBit(arch2(address), bit));\n    }\n    else if (spriteId == SPRITE_WALL1)\n    {\n        // Furthes away so no need for mask, right?\n        return (getIntBit(wall1(address), bit));\n    }\n    else if (spriteId == SPRITE_WULF)\n    {        \n        // Walk anim\n        float frame = fract(iTime * 2.);        \n        if (frame > .5)\n        {\n            int f = wulf1mask(address);\n            if (getIntBit(f, bit) > 0.)\n                return (getIntBit(wulf1(address), bit));\n        }\n        else\n        {\n            int f = wulf2mask(address);\n            if (getIntBit(f, bit) > 0.)\n                return (getIntBit(wulf2(address), bit));\n        }\n    }\n    \n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 pos = GetScreenPixelCoord(uv);\n    \n    // To move\n    //pos.x -= floor(iTime * 2.);\n    \n    pos.y -= 5.;\n    \n    // Mirror image - but also mirrors position around screen\n    //  centre\n    //pos.x += kResolution.x / 2.; \n    //pos.x = kResolution.x - pos.x + 24.;\n\n    float t = mod(iTime, 7.0) - 3.;\n    float SPEED = 40.;\n    float archx = 140. - t * SPEED;\n    float archy = 60.  - t * .5 * SPEED;\n    \n    vec2 archpos = floor(pos - vec2(archx, archy));\n    float p = getPixel(archpos, SPRITE_ARCH1);\n    \n    if (p < 0.)\n    {\n        vec2 wulfpos = pos - vec2(80, 40);\n        p = getPixel(wulfpos, SPRITE_WULF); \n        if (p > 0.)\n        {\n            fragColor.rgba = vec4(0, 1, 0, 1); \n            return;\n        }\n    }\n\n    if (p < 0.)\n    {\n        // Far side of arch\n        archpos = floor(pos - vec2(archx + 25., archy - 0.));\n        p = getPixel(archpos, SPRITE_ARCH2);\n    }\n\n    // Wall pieces: this should be random.\n    // Wall with arch should only become visible once we have\n    //  gone through the arch.\n    if (t < 2. && p < 0.)\n    {\n        // Wall\n        archpos = floor(pos - vec2(archx + 55., archy - 0.));\n        p = getPixel(archpos, SPRITE_WALL1);\n    }\n\n    if (t > 0. && p < 0.)\n    {\n        // Wall\n        archpos = floor(pos - vec2(archx + 75., archy - 20.));\n        p = getPixel(archpos, SPRITE_WALL1);\n    }\n\n\tfragColor.rgb = mix(vec3(0), vec3(0, 1, 1), p);\n    fragColor.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdyGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[712, 792, 836, 836, 968], [970, 1070, 1106, 1106, 1211], [1213, 1213, 1231, 1231, 2125], [2127, 2127, 2149, 2149, 3069], [3071, 3071, 3089, 3089, 3971], [3973, 3973, 3995, 3995, 4904], [4906, 4906, 4934, 4934, 6316], [6318, 6318, 6336, 6336, 7686], [7692, 7692, 7710, 7710, 8605], [8607, 8607, 8629, 8629, 9550], [9552, 9552, 9570, 9570, 9955], [9957, 10034, 10074, 10122, 11399], [11401, 11401, 11458, 11458, 12951]], "test": "untested"}
{"id": "MsG3DK", "name": "Tame Impala - Currents", "author": "s23b", "description": "my interpretation of the Tame Impala [url=https://www.youtube.com/watch?v=NMRhx71bGo4&list=PL81_CtYCym28qkVe3nVMRG7hMR5_Ky3Hf]album cover[/url]", "tags": ["2d", "cover", "album", "tameimpala", "currents"], "likes": 37, "viewed": 1091, "published": "Public API", "date": "1456421039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SMOOTH 1\n\n#define TAU 6.28318530718\n\nfloat hash(vec2 uv) {\n    float f = fract(cos(sin(dot(uv, vec2(.009123898, .00231233))) * 48.512353) * 11111.5452313);\n    return f;\n}\n\nfloat noise(vec2 uv) {\n    vec2 fuv = floor(uv);\n    vec4 cell = vec4(\n        hash(fuv + vec2(0, 0)),\n        hash(fuv + vec2(0, 1)),\n        hash(fuv + vec2(1, 0)),\n        hash(fuv + vec2(1, 1))\n    );\n    \n    #if SMOOTH\n    vec2 axis = mix(cell.xz, cell.yw, smoothstep(0., 1., fract(uv.y)));\n    return mix(axis.x, axis.y, smoothstep(0., 1., fract(uv.x)));\n    #else\n    vec2 axis = mix(cell.xz, cell.yw, fract(uv.y));\n    return mix(axis.x, axis.y, fract(uv.x));\n\t#endif\n}\n\nfloat fbm(vec2 uv) {\n    float f = 0.;\n    float r = 1.;\n    #if SMOOTH\n    for (int i = 0; i < 3; ++i) {\n    #else\n    for (int i = 0; i < 8; ++i) {\n    #endif\n        f += noise((uv += vec2(-1, 1) * iTime / 16.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\nvec4 createBall(vec2 uv) {\n    float f = smoothstep(0.5, 1.4, distance(uv, vec2(-.1, .1))) * .5;\n    f += smoothstep(.0, .9, 1.3- distance(uv, vec2(-.3, .3))) * .5;\n    f += smoothstep(.1, .5, .5- distance(uv, vec2(-.4, .4)));\n    f += smoothstep(.1, .5, .4- distance(uv, vec2(.2, .6)));\n    f *= 1. - smoothstep(.95, 1., distance(uv, vec2(.0, .0)));\n    return vec4(f, f, f, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 ball = vec2(.2, -.4);\n    ball.y += sin(iTime * 4.) / 40.;\n    float r = .2;\n    \n    // create distorted version of the space\n    vec2 distuv = uv * vec2(150, 130) + vec2(0, 20);\n    distuv *= distance(uv, vec2(1.5, -2)) / 3.;\n    \n    // add distortion for the ball\n    distuv.x += smoothstep(1. - r * 1.5, 1., 1. - distance(uv, ball - vec2(.1, 0))) * 15.;\n    \n    // calculate distortion level from distance to lower right corner\n    float t = smoothstep(0., 1., 1. - distance(uv * .5, vec2(.4, -.85)));\n    \n    // add noise to distortion weighted by distortion level\n    distuv += (fbm(uv * 2.) - .5) * t * 100.;\n    \n    // calculate stripes\n    float f = sin(distuv.x + distuv.y);\n    \n    // calculate distance from distorted diagonal\n    float d = (distuv.x + distuv.y) / TAU;\n    \n    if (abs(uv.x) > 1. || abs(uv.y) > 1. ) { // outside boundaries\n        fragColor = vec4(0);\n    } else if (d < .5 && d > - 1.) { // inside red line\n        float grad = min(1., (.75 - abs(d + .25)) * 5.);\n\t\tfragColor = vec4(mix(vec3(.92,.16,.20), vec3(.93, .64, .17), -uv.y) * grad, 1.);\n    } else { // lines\n        float spot = clamp(3. - distance(uv * vec2(1, 2), vec2(-1, -1)), 0., 1.);\n\t\tfragColor = vec4(vec3(.8, .68, .82) * f * spot, 1.);\n    }\n    \n    // create ball color\n    vec4 b = createBall((uv - ball) / r);\n    \n    // create ball mask\n    float mask = 1. - smoothstep(r - .002, r + .01, distance(uv, ball));\n    mask *= smoothstep(-1.2, -.9, d);\n    \n    // add ball\n    fragColor = mix(fragColor, b, mask);\n    \n    // add a noise\n    fragColor.rgb -= noise(uv * 300. + fract(iTime) * 10000.) / 5.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsG3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 66, 66, 179], [181, 181, 203, 203, 659]], "test": "untested"}
{"id": "MsG3Wm", "name": "Dune Stripes", "author": "tholzer", "description": "Dune Stripes using Gabor Noise\nchanging mouse.x -> scale waves", "tags": ["2d", "noise", "animated", "stripes", "pattern", "gabor", "dunes", "desert"], "likes": 11, "viewed": 368, "published": "Public", "date": "1454781629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---------------------------------------------------------\n//\n// DuneStripes.glsl               by tholzer     2016-02-06   \n//\n// inspired from https://www.shadertoy.com/view/XsBGDc\n//\n// Tags: 2d, noise, stripes, dunes, desert, animated, pattern\n//---------------------------------------------------------\nvec2 hash( vec2 p )                       // rand in [-1,1]\n{\n  p = vec2(dot(p,vec2(127.1,311.7)),\n           dot(p,vec2(269.5,183.3)));\n  return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\n// 2d noise functions from https://www.shadertoy.com/view/XslGRr\nfloat noise( in int i, in int j )\n{\n  vec2 n = vec2(i,j); \n  vec2 p = floor(n);\n  vec2 f = fract(n);\n  f = f*f*(3.0-2.0*f);\n  vec2 uv = (p+vec2(37.0,17.0)) + f;\n  vec2 rg = hash( uv/256.0 ).yx;\n  return 0.5*mix( rg.x, rg.y, 0.5 );\n}\n\n//---------------------------------------------------------\n#define NB 100      // number or gabor blobs\n#define SIZE 0.25   // size of gabor blobs\n                    // freq tuned by mouse.x\n\nfloat DuneStripes (vec2 uv, float d, float freq, float time)\n{\n  float hv = 0.;\n  for (int i=0; i<NB; i++) \n  {\n    vec2 pos = vec2(noise(i,0), noise(i,1));\n    vec2 dir = (1.+d)*vec2(noise(i,2),noise(i,3)) - d;\n    hv += SIZE * sin(dot(uv-pos, freq*dir) * 6. + time);\n  }\n  return hv;\n}\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.y;\n  float frequence = mix(10., iResolution.x/10., iMouse.x/iResolution.x);\n  float h = DuneStripes(uv, -1.5, frequence, - 2.5*iTime);\n  vec3 col = vec3(0.7,0.6,0.2)*h;\n  fragColor = vec4(col,1.0);\n}\n                  \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsG3Wm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 309, 370, 370, 498], [500, 565, 600, 600, 797], [967, 993, 1055, 1055, 1280], [1281, 1341, 1398, 1398, 1637]], "test": "untested"}
{"id": "MsG3Wy", "name": "Carbon [TDF2016]", "author": "gam0022", "description": "Third place prize works in GLSL Compo, Tokyo Demo Fest 2016. This work expects to be combined with a BPM120 music.", "tags": ["3d", "raymarching", "mandelbox"], "likes": 10, "viewed": 745, "published": "Public", "date": "1456154495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// consts\nconst float EPS = 0.01;\nconst float OFFSET = EPS * 100.0;\nconst float PI = 3.14159;\n\n\n// globals\nconst vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );\nvec3 cPos, cDir;\nvec3 sPos;\nfloat sSize;\nvec3 illuminationColor;\nfloat tempo;\n\nstruct Intersect {\n\tbool isHit;\n\n\tvec3 position;\n\tfloat distance;\n\tvec3 normal;\n\n\tint material;\n\tvec3 color;\n};\n\nconst int CIRCUIT_MATERIAL = 0;\nconst int MIRROR_MATERIAL = 1;\n\n\n// distance functions\nvec3 onRep( vec3 p, float interval ) {\n\n\treturn mod( p, interval ) - 0.5 * interval;\n\n}\n\n// thanks to https://www.shadertoy.com/view/MdVGRc\nfloat MBoxDist( vec3 p ) {\n\n  const float scale = 2.7;\n  const int n = 12;\n  vec4 q0 = vec4 (p, 1.);\n  vec4 q = q0;\n\n  for ( int i = 0; i < n; i++ ) {\n\n    q.xyz = clamp( q.xyz, -1.0, 1.0 ) * 2.0 - q.xyz;\n    q = q * scale / clamp( dot( q.xyz, q.xyz ), 0.5, 1.0 ) + q0;\n\n  }\n\n  return length( q.xyz ) / abs( q.w );\n\n}\n\nfloat sphereDist( vec3 p, vec3 c, float r ) {\n\n\treturn length( p - c ) - r;\n\n}\n\nfloat sceneDist( vec3 p ) {\n\n\treturn min(\n\t\tsphereDist( p, sPos, sSize ),\n\t\tMBoxDist( onRep( p, 7.0 ) )\n\t);\n\n}\n\n\n// color functions\nvec3 hsv2rgb( vec3 c ) {\n\n\tvec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n\tvec3 p = abs( fract( c.xxx + K.xyz ) * 6.0 - K.www );\n\treturn c.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), c.y );\n\n}\n\n// thanks to http://glslsandbox.com/e#21290.5\nvec2 circuitPattern( vec2 p ) {\n\n\tp = fract(p);\n\tfloat r = 0.123;\n\tfloat v = 0.0, g = 0.0;\n\tr = fract(r * 9184.928);\n\tfloat cp, d;\n\t\n\td = p.x;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.y;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.x - 1.0;\n\tg += pow(clamp(3.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.y - 1.0;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 10000.0);\n\t\n\tconst int iter = 12;\n\tfor(int i = 0; i < iter; i ++)\n\t{\n\t\tcp = 0.5 + (r - 0.5) * 0.9;\n\t\td = p.x - cp;\n\t\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 200.0);\n\t\tif(d > 0.0) {\n\t\t\tr = fract(r * 4829.013);\n\t\t\tp.x = (p.x - cp) / (1.0 - cp);\n\t\t\tv += 1.0;\n\t\t}\n\t\telse {\n\t\t\tr = fract(r * 1239.528);\n\t\t\tp.x = p.x / cp;\n\t\t}\n\t\tp = p.yx;\n\t}\n\tv /= float(iter);\n\treturn vec2(g, v);\n\n}\n\n\nIntersect minIntersect( Intersect a, Intersect b ) {\n\n\tif ( a.distance < b.distance ) {\n\t\treturn a;\n\t} else {\n\t\treturn b;\n\t}\n\n}\n\nIntersect sceneIntersect( vec3 p ) {\n\n\tIntersect a, b;\n\ta.distance = sphereDist( p, sPos, sSize );\n\ta.material = MIRROR_MATERIAL;\n\n\tb.distance = MBoxDist( onRep( p, 7.0 ) );\n\tb.material = CIRCUIT_MATERIAL;\n\n\treturn minIntersect( a, b );\n}\n\nvec3 getNormal( vec3 p ) {\n\n\treturn normalize(vec3(\n\t\tsceneDist(p + vec3( EPS, 0.0, 0.0 ) ) - sceneDist(p + vec3( -EPS, 0.0, 0.0 ) ),\n\t\tsceneDist(p + vec3( 0.0, EPS, 0.0 ) ) - sceneDist(p + vec3( 0.0, -EPS, 0.0 ) ),\n\t\tsceneDist(p + vec3( 0.0, 0.0, EPS ) ) - sceneDist(p + vec3( 0.0, 0.0, -EPS ) )\n\t));\n\n}\n\nfloat getShadow( vec3 ro, vec3 rd ) {\n\n\tfloat h = 0.0;\n\tfloat c = 0.0;\n\tfloat r = 1.0;\n\tfloat shadowCoef = 0.5;\n\n\tfor ( float t = 0.0; t < 50.0; t++ ) {\n\n\t\th = sceneDist( ro + rd * c );\n\n\t\tif ( h < EPS ) return shadowCoef;\n\n\t\tr = min( r, h * 16.0 / c );\n\t\tc += h;\n\n\t}\n\n\treturn 1.0 - shadowCoef + r * shadowCoef;\n\n}\n\nIntersect getRayColor( vec3 origin, vec3 ray ) {\n\n\t// marching loop\n\tfloat dist;\n\tfloat depth = 0.0;\n\tvec3 p = origin;\n\tint count = 0;\n\tIntersect nearest;\n\n\tfor ( int i = 0; i < 64; i++ ){\n\n\t\tdist = sceneDist( p );\n\t\tdepth += dist;\n\t\tp = origin + depth * ray;\n\n\t\tcount = i;\n\t\tif ( abs(dist) < EPS ) break;\n\n\t}\n\n\tif ( abs(dist) < EPS ) {\n\n\t\tnearest = sceneIntersect( p );\n\t\tnearest.position = p;\n\t\tnearest.normal = getNormal(p);\n\t\tfloat diffuse = clamp( dot( lightDir, nearest.normal ), 0.1, 1.0 );\n\t\tfloat specular = pow( clamp( dot( reflect( lightDir, nearest.normal ), ray ), 0.0, 1.0 ), 10.0 );\n\t\t//float shadow = getShadow( p + nearest.normal * OFFSET, lightDir );\n\n\t\tif ( nearest.material == CIRCUIT_MATERIAL ) {\n\n\t\t\tvec2 uv = p.yz;\n\t\t\tvec2 dg = circuitPattern(uv);\n\t\t\tfloat glow = max( sin( length( p ) - 1.8 * iTime ) * 2.5, 0.0 );\n           \tfloat pattern = max( dg.x - 1.0, 0.0 );\n\t\t\tnearest.color = vec3( 0.2, 0.2, 0.2 ) +  illuminationColor * pattern * glow * diffuse + specular /* * max( 0.5, shadow )*/;\n\n\t\t} else if ( nearest.material == MIRROR_MATERIAL ) {\n\n\t\t\tnearest.color = ( vec3( 1.0 ) - illuminationColor ) * diffuse * 0.5 + specular/* * max( 0.5, shadow )*/;\n\n\t\t}\n\n\t\tnearest.isHit = true;\n\n\t} else {\n\n\t\tnearest.color = vec3(0.1);\n\t\tnearest.isHit = false;\n\n\t}\n\n\tnearest.color += clamp( sin( iTime * 0.2 - 0.5 * PI ) * 0.2 * depth - 0.005 * float(count), -1.0, 1.0 );\n\treturn nearest;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\t// fragment position\n\tvec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / min(  iResolution.x,  iResolution.y );\n\n\t// camera and ray\n\tcPos  = vec3( -0.8185093402862549, 4.509979248046875, iTime );\n\tcDir  = normalize( vec3( sin( iTime * 0.5 ), sin( iTime * 0.1 ), cos( iTime * 0.6 ) + 0.5 ) );\n\tvec3 cSide = normalize( cross( cDir, vec3( 1.0, 1.0 ,0.0 ) ) );\n\tvec3 cUp   = normalize( cross( cSide, cDir ) );\n\tfloat targetDepth = 1.3;\n\tvec3 ray = normalize( cSide * p.x + cUp * p.y + cDir * targetDepth );\n\n\t// music's tempo\n\ttempo = sin( 4.0 * PI * iTime );\n\n\t// sphere pos\n\tfloat d = 0.2 + 0.1 * cos( iTime * 0.5 );\n\tsPos = cPos + vec3( 0.0, 0.0, d );\n\tsSize = 0.03 + 0.005 * tempo;\n\n\t// Illumination Color\n\tilluminationColor = hsv2rgb( vec3( iTime * 0.02 + 0.6, 1.0, 1.0 ) );\n\n\tvec3 color = vec3( 0.0 );\n\tfloat alpha = 1.0;\n\tIntersect nearest;\n\n\tfor ( int i = 0; i < 3; i++ ) {\n\n\t\tnearest = getRayColor( cPos, ray );\n\n\t\tcolor += alpha * nearest.color;\n\t\talpha *= 0.7;\n\t\tray = normalize( reflect( ray, nearest.normal ) );\n\t\tcPos = nearest.position + nearest.normal * OFFSET;\n\n\t\tif ( !nearest.isHit || nearest.material == CIRCUIT_MATERIAL ) break;\n\n\t}\n\n\tcolor += 0.2 * tempo;\n\n\tfragColor = vec4(color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsG3Wy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[457, 479, 517, 517, 566], [568, 619, 645, 645, 936], [938, 938, 983, 983, 1016], [1018, 1018, 1045, 1045, 1128], [1131, 1150, 1174, 1174, 1346], [1348, 1394, 1425, 1425, 2146], [2149, 2149, 2201, 2201, 2276], [2278, 2278, 2314, 2314, 2516], [2518, 2518, 2544, 2544, 2822], [2824, 2824, 2861, 2861, 3138], [3140, 3140, 3188, 3207, 4548], [4550, 4550, 4607, 4630, 5818]], "test": "untested"}
{"id": "MsGGDm", "name": "keks", "author": "cardmechanic", "description": "wurst", "tags": ["wurst"], "likes": 0, "viewed": 75, "published": "Public", "date": "1454785948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Objekt {\n    vec2 pos,\n    \t width,\n         height;\n    vec4 col;\n     };\n \nObjekt k1 = Objekt (vec2 (- cos(.5*iTime),0.),vec2 (0.2,.0), vec2 (0.,0.2), vec4(1.,0.8,.25,1.)),\n \t   k2 = Objekt (vec2 (1. -sin(.5*iTime),0.),vec2 (0.4,.0), vec2 (0.,0.4), vec4(0.,1.,.7,1.));\n    \n    \nvec4 Hitkreis (in vec2 p_uv, in Objekt p_k){\n  \n        vec2 xynew = p_uv - p_k.pos;\n        float\n        x = dot(xynew, p_k.width)/dot(p_k.width, p_k.width),\n        y = dot(xynew, p_k.height)/dot(p_k.height, p_k.height); \n        \n    if (abs(x)>.5 && abs(y) >.5)\n    { \n        return vec4(.0);\n    }\n    if (x*x+y*y<.25)\n        return p_k.col;\n    \t\n    return vec4(.0);\n} \n\nbool kollision (in vec2 p_x1 ,in vec2 p_x2) {\n    if (abs(p_x1.x- p_x2.x) >=0. && abs(p_x1.x-p_x2.x) <=.25){\n        return true;\n            }\n    return false;\n        }\n\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\tvec2 uv = 2.*(fragCoord.xy / iResolution.xy-0.5)*vec2 ( iResolution.x/iResolution.y, 1.);\n\tfragColor = vec4(0.2,.5,.65,1.0);\n     \n   \n     if( kollision( k1.pos , k2.pos ) )\n        k1.pos.x = -cos(iTime+(2.*iTime-3.14)),\n        k2.pos.x = -k1.pos.x;\n    \n     vec4 col = Hitkreis( uv, k1)+ Hitkreis(uv, k2);\n        \n    if (col.a < .9)\n        fragColor = vec4(0.9,.5,.0,1.0);\n    \n    else\n    fragColor = col;\n    \n    vec4 col2 = Hitkreis (uv,k1)+Hitkreis(uv,k2);\n   \n    \n    \n\t\n                           \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGGDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 332, 332, 666], [669, 669, 714, 714, 840], [848, 848, 905, 905, 1424]], "test": "untested"}
{"id": "MsGGDW", "name": "Simple Shader Practice", "author": "teessider", "description": "This shader was made to practice my shader skills. I have lots more to learn!", "tags": ["2d", "simple", "funky"], "likes": 2, "viewed": 266, "published": "Public", "date": "1454462018", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// By Andrew \"teessider\" Bell\n\nfloat A = 1.0;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// https://www.shadertoy.com/view/XsXSz4 - SDF 2D Triangle!\nfloat SDTriangle(in vec2 point0, in vec2 point1, in vec2 point2, in vec2 coord)\n{  \n    vec2 edge0 = point1 - point0;\n    vec2 edge1 = point2 - point1;\n    vec2 edge2 = point0 - point2;\n    \n    // These seem to be gradients from edge of screen \n    // to edges of triangle/points of triangle ?\n    vec2 v0 = coord - point0;\n    vec2 v1 = coord - point1;\n    vec2 v2 = coord - point2;\n    \n    // I don't know what these do yet xD\n    vec2 pq0 = v0 - edge0 * saturate(dot(v0, edge0) / dot(edge0, edge0));\n    vec2 pq1 = v1 - edge1 * saturate(dot(v1, edge1) / dot(edge1, edge1));\n    vec2 pq2 = v2 - edge2 * saturate(dot(v2, edge2) / dot(edge2, edge2));\n    \n    // or these either xD xD\n    float s = sign(edge0.x*edge2.y - edge0.y*edge2.x);\n    vec2 d = min(min(vec2(dot(pq0, pq0), s*(v0.x*edge0.y-v0.y*edge0.x)),\n                     vec2(dot(pq1, pq1), s*(v1.x*edge1.y-v1.y*edge1.x))),\n                 \t vec2(dot(pq2, pq2), s*(v2.x*edge2.y-v2.y*edge2.x)));\n    \n    return -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec3 red = vec3(1.0, 0, 0);\n    vec3 green = vec3(0, 1.0, 0);\n    \n    //// PREVIOUS PRACTICE FOLLOWS\n    \n    //float mix_alpha = pow(distance(uv.x, uv.y), dot(uv.x, uv.y));\n    \n    // Alternative way of doing previous float\n    // Thanks FabriceNeyet2\n    //float mix_alpha = pow(abs(uv.x-uv.y), uv.x*uv.y);\n    \n    // mix function is GLSL version of lerp function in HLSL\n    //fragColor = vec4(invertRGB(mix(red, green, mix_alpha)), 1.0);\n    \n    // Alternative to making a oneMinus and invertRGB functions!\n    // Thanks demofox\n    //fragColor = vec4(1.0 - mix(red, green, mix_alpha), 1.0);\n    \n    //// END OF PREVIOUS PRACTICE\n    \n    \n    // TRIANGLE POINTS\n    vec2 a = vec2(0.4, 0.4);\n    vec2 b = vec2(0.75, 0.5);\n    vec2 c = vec2(0.69, 0.65);\n    \n    float triangle = 1.0 - smoothstep(0.0, 0.01, SDTriangle(a, b, cos(c * iTime) * sin(c * iTime), uv));\n    \n    //// TODO:\n    // REFERENCE\n    // https://www.shadertoy.com/view/Xl2yDW - EQUAL TRI\n    // https://www.shadertoy.com/view/4sXXRN - SDF 3D Triangle!\n    // https://www.shadertoy.com/view/4dlSRX - more triangle reference\n    // https://www.shadertoy.com/view/4sSSzG - EVEN more triangle reference\n    \n    vec2 test2 = uv;\n    \n    //fragColor = vec4(test2, 0.0, 1.0);  // Testing \n    //fragColor = vec4(mix(vec3(test2, 0.0), vec3(triangle), clamp(sin(iTime*0.5), 0.0, 1.0)), 1.0);\n    fragColor = vec4(vec3(triangle), 1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 147, 228, 228, 1147], [1149, 1149, 1206, 1206, 2719]], "test": "untested"}
{"id": "MsGGWK", "name": "Simple Polygons", "author": "sillsm", "description": "Four ways to draw a simple regular polygon.", "tags": ["2d", "geometry"], "likes": 3, "viewed": 246, "published": "Public", "date": "1456370344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Max Sills 2016\n// Licensed under the MIT license.\n//\n// Regular polygons four ways.\n// Drawing func from jonobr1 https://www.shadertoy.com/view/XsjGDt\n\n// Convert r, g, b to normalized vec3\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n// Defined by apothem.\nvec4 poly1(vec2 uv, vec2 pos, float mid, vec3 color, float n) {\n  vec2 trans = pos - uv;\n  float a = atan(trans.x,trans.y);\n  float r = length(trans);\n\n  float i = 2.*acos(-1.)/n;\n  float th= mod(a, i) - (i/2.0);\n  float l = mid/cos(th);\n\n  float t = clamp(r-l, 0.0, 1.);\n  return vec4(color, 1. -t);\n}\n\n// Lerp between the boundaries of the first wedge.\nvec4 poly2(vec2 uv, vec2 pos, float rad, vec3 color, float n) {\n  vec2 trans = pos - uv;\n  float a = atan(trans.x,trans.y);\n    \n  float i = 2.*acos(-1.)/n; // Wedge angle is 2pi/n.\n  float th = mod(a,i); // Where does trans sit in wedge?\n\n  vec2 bound = mix(vec2(rad, 0.), vec2(rad*cos(i), rad*sin(i)), th/i);\n\n  float t = clamp(length(trans)-length(bound), 0.0, 1.);\n  return vec4(color, 1. -t);\n}\n\n// Law of sines.\nvec4 poly3(vec2 uv, vec2 pos, float rad, vec3 color, float n) {\n  float pi = acos(-1.);\n  vec2 trans = pos - uv;\n  float a = atan(trans.x,trans.y);\n  float r = length(trans);\n  \n  float i = 2.*pi/n; // wedge angle\n \n  float th = mod(a, i);\n  float b = (pi - i) / 2.0;\n  float c = pi - th - b;\n  float l = (sin(b) * rad)/sin(c);\n\n  float t = clamp(r-l, 0.0, 1.);\n  return vec4(color, 1. -t);\n}\n\n// Rotate first triangle until side is perp with x-axis.\n// Maintain y bound.\nvec4 poly4(vec2 uv, vec2 pos, float rad, vec3 color, float n) {\n  float pi = acos(-1.);\n  vec2 trans = pos - uv;\n  float a = atan(trans.x,trans.y);\n  float r = length(trans);\n\n  float th = mod(a, 2.*pi/n);\n  th += pi/2. - pi/n;\n  r = r*sin(th);\n\n  float l = rad *cos(pi/n); // get radius from apothem\n  float t = clamp(r-l, 0.0, 1.);\n  return vec4(color, 1. -t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n\n    // Background layer\n\tvec4 layer1 = vec4(rgb(210.0, 222.0, 228.0), 1.0);\n\t\n    // Animate\n    float sides = 5. * abs(cos(iTime)) + 3.0;\n    \n\t// Draw the Polygon\n\tvec3 red = rgb(225.0, 95.0, 60.0);\n\tvec4 layer2 = poly4(uv, center, radius, red, sides);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGGWK.jpg", "access": "shaders20k", "license": "mit", "functions": [[155, 193, 230, 230, 279], [281, 304, 367, 367, 606], [608, 659, 722, 722, 1058], [1060, 1077, 1140, 1140, 1469], [1471, 1549, 1612, 1612, 1913], [1915, 1915, 1972, 1972, 2395]], "test": "untested"}
{"id": "MsK3Ry", "name": "Weird Fractal 7", "author": "aiekick", "description": "click on cells to see pattern fullscreen", "tags": ["fractal", "weird"], "likes": 19, "viewed": 697, "published": "Public API", "date": "1455212172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n//another variation of my Weird Fractal 0 : https://www.shadertoy.com/view/Xts3RB\n\nconst vec2 gridSize = vec2(2.,2.);//grid size (columns, rows)\n    \n// encode id from coord // s:screenSize / h:pixelCoord / sz=gridSize\nfloat EncID(vec2 s, vec2 h, vec2 sz) \n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    return cy*sz.x+cx;\n}\n\n// return id / uv\nvec3 getcell(vec2 s, vec2 h, vec2 sz) \n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    \n    float id = EncID(s,h,sz);\n    \n    vec2 size = s/sz;\n    float ratio = size.x/size.y;\n    vec2 uv = (2.*(h)-size)/size.y - vec2(cx*ratio,cy)*2.;\n    \n    return vec3(id, uv);\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n\tf.xyz = iResolution;\n    \n    vec4 p = vec4((g+g-f.xy)/f.y,0,1), r = p-p, q = r, m = iMouse, c;\n\n    if(m.z>0.) \n    {\n        c.x = EncID(f.xy,m.xy,gridSize);\n        c.yz = p.xy;\n    }\n    else\n    {\n        c.xyz = getcell(f.xy,g,gridSize);\n        p.xy = c.yz;\n    }\n    \n\tfloat k = 0.;\n\tif (c.x == 0.) k = .258;\n\tif (c.x == 1.) k = .276;\n\tif (c.x == 2.) k = .282;\n\tif (c.x == 3.) k = .3;\n\t\n    q.w += iTime * 0.3 + 1.;\n\t\n    // i is the color of pixel while hit 0. => 1.\n\tfor (float i=1.; i>0.; i-=.01) \n\t{\n        float d=0.,s=1.;\n\n        for (int j = 0; j <3; j++)\n\t\t{\n\t\t\tr = abs( mod(q * s + 1.,2.) - 1. );\n            d = max(d, (k - length( sqrt(r * .6) ) * .3) / s );\n\t\t\ts *= 3.;\n\t\t}\n\t\t\n        q += p * d;\n        \n        f = f - f + i;\n\t\t\t\n        if(d < 1e-5) break;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsK3Ry.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[346, 415, 454, 454, 555], [557, 575, 615, 615, 877], [879, 879, 920, 920, 1712]], "test": "untested"}
{"id": "MsK3zc", "name": "Cheap Tunnel", "author": "Swax97", "description": "A simple voxel marcher, textures are still kinda off", "tags": ["3d", "tunnel", "voxel"], "likes": 14, "viewed": 352, "published": "Public", "date": "1455724493", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float prng (in vec3 n) {\n    n*=0.03;\n \treturn fract(sin(dot(n.xyz ,vec3(12.9898,78.233,119.569))) * 43758.5453);  \n}\n\nfloat terrain(vec3 p){\n    p.xy += vec2(sin(p.z*0.2), cos(p.z*0.2))*4.0;\n    return prng(p)*6.0 + dot(p.xy, p.xy)*0.2 - 7.0 - sin(p.z*0.04);\n}\n\nvec3 march(vec3 ro, vec3 rd){\n    \n    vec3 dt = abs(1.0 / rd);\n    vec3 n = vec3(0.0);\n    \n    ivec3 p = ivec3(floor(ro));\n    \n    float t = 0.0;\n    \n    n = max(vec3(0.0), 1.0 / rd) - fract(ro) / rd;\n    \n    \n    ivec3 inc = ivec3(sign(rd));\n    \n    vec3 surf = vec3(0);\n    \n    for (int i = 0; i < 30; i++){\n        if(n.x < n.y) {\n            if(n.x < n.z) {\n                p.x += inc.x;\n                t = n.x;\n                n.x += dt.x;\n                surf = vec3(1.0, 0.0, 0.0);\n            } else {\n                p.z += inc.z;\n                t = n.z;\n                n.z += dt.z;\n                surf = vec3(0.0, 0.0, 1.0);\n            }\n        } else {\n            if(n.y < n.z) {\n                p.y += inc.y;\n                t = n.y;\n                n.y += dt.y;\n                surf = vec3(0.0, 1.0, 0.0);\n            } else {\n                p.z += inc.z;\n                t = n.z;\n                n.z += dt.z;\n                surf = vec3(0.0, 0.0, 1.0);\n            }\n        }\n        \n        if (terrain(vec3(p)) > 0.9) break;\n    }\n    \n    float b = 1.0/(t*t*0.02+1.0);\n    b *= abs(dot(rd, surf))*0.7+0.3;\n    \n    vec4 col = vec4(1.0);\n    \n    ro = ro + rd * t;\n    ro *= 0.075;\n        \n    col =  texture(iChannel1, ro.xy+ro.z);\n    col =  0.25 * col + 0.8 * col * texture(iChannel0, ro.xy+ro.z);\n\n        \n    col = sqrt(col);\n    \n    col = col * vec4(0.7, 0.75, 0.6, 0.0) + vec4(0.35, 0.3, 0.25, 1.0);\n    \n    return col.xyz * b ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n\t\n    vec3 ro = vec3(-sin(iTime*0.4)*3.5, -cos(iTime*0.4)*5.0, iTime*2.0);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    \n    fragColor = vec4(march(ro, rd), 1.0);\n}\n\n\n\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsK3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [119, 119, 141, 141, 261], [263, 263, 292, 292, 1737], [1739, 1739, 1796, 1796, 2026]], "test": "untested"}
{"id": "MsKGDy", "name": "Pretty Moire", "author": "amdbcg", "description": "Just playing around. I was trying to create a circle, and just said, \"heck, that looks cooler than a circle\" and put a time on it then presto! ", "tags": ["moire", "toy"], "likes": 3, "viewed": 183, "published": "Public", "date": "1456287976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv;\n    vec2 q = p - vec2(0.3, 0.5);\n    vec3 col = vec3(.0,.5,.5);\n    \tfloat r = 1.0;\n    \t\n    \tcol = mix( col, vec3(.1,.1,.1), r*cos(atan(p.x/p.y)*iTime *20.0) );\n        fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 321]], "test": "untested"}
{"id": "MsV3RV", "name": "Signed distance field blobbies 2", "author": "jherico", "description": "a modification of verminator's SDF stuff to use a color wheel for the plane.", "tags": ["raymarching", "sdf"], "likes": 14, "viewed": 930, "published": "Public API", "date": "1455468124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int renderDepth = 400;\nconst bool showRenderDepth = false;\n\nconst vec3 background = vec3(0.2, 0.2, 0.8);\nconst vec3 white = vec3(0.8, 0.8, 0.8);\nconst vec3 black = vec3(0, 0, 0);\nconst vec3 red = vec3(0.8, 0.2, 0.2);\nconst vec3 green = vec3(0.2, 0.8, 0.2);\nconst vec3 lightPos = vec3(0, 10, 10);\n\nconst float a = 1.0;\nconst float b = 3.0;\nvec3 forces[3];\n\n\nvec3 getRayDir(vec3 camDir, vec2 fragCoord) {\n  vec3 yAxis = vec3(0, 1, 0);\n  vec3 xAxis = normalize(cross(camDir, yAxis));\n  vec2 q = fragCoord / iResolution.xy;\n  vec2 p = 2.0 * q - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n  return normalize(p.x * xAxis + p.y * yAxis + 5.0 * camDir);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.1;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat getMetaball(vec3 p, vec3 v) {\n  float r = length(p - v);\n  if (r < b / 3.0) {\n    return a * (1.0 - 3.0 * r * r / b * b);\n  } else if (r < b) {\n    return (3.0 * a / 2.0) * (1.0 - r / b) * (1.0 - r / b);\n  } else {\n    return 0.0;\n  }\n}\n\nfloat sdImplicitSurface(vec3 p) {\n  float mb = 0.0;\n  float minDist = 10000.0;\n  for (int i = 0; i < 3; i++) {\n    mb += getMetaball(p, forces[i]);\n    minDist = min(minDist, length(p - forces[i]));\n  }\n  if (minDist > b) {\n    return max (minDist - b, b - 1.2679529);\n  } else if (mb == 0.0) {\n    return b - 1.2679529;  // 1.2679529 is the x-intercept of the metaball expression - 0.5.\n  } else {\n    return b - sqrt(6.0 * mb) - 1.2679529;\n  }\n}\n\nfloat getSdf(vec3 p) {\n  float f = sdImplicitSurface(p);\n  for (int i = 0; i < 6; i++) {\n    float t = float(i) + iTime;\n    f = min(f, sdBox(\n        p - vec3(\n            3.0 + 3.0 * cos(t * 3.141592 / 3.0), \n            0, \n            3.0 * sin(t * 3.141592 / 3.0)),\n        vec3(0.5)));\n  }\n  return f;\n}\n\nfloat getSdfWithPlane(vec3 p) {\n  return min(getSdf(p), sdPlane(p, vec4(0,1,0,1)));\n}\n\nfloat diffuse(vec3 point,vec3 normal) {\n  return clamp(dot(normal, normalize(lightPos - point)), 0.0, 1.0);\n}\n\nfloat getShadow(vec3 pt) {\n  vec3 lightDir = normalize(lightPos - pt);\n  float kd = 1.0;\n  int step = 0;\n  float t = 0.1;\n\n  for (int step = 0; step < renderDepth; step++) {\n    float d = getSdf(pt + t * lightDir);\n    if (d < 0.001) {\n      kd = 0.0;\n    } else {\n      kd = min(kd, 16.0 * d / t);\n    }\n    t += d;\n    if (t > length(lightPos - pt) || step >= renderDepth || kd < 0.001) {\n      break;\n    }\n  }\n  return kd;\n}\n\nvec3 getGradient(vec3 pt) {\n  return vec3(\n    getSdfWithPlane(vec3(pt.x + 0.0001, pt.y, pt.z)) - getSdfWithPlane(vec3(pt.x - 0.0001, pt.y, pt.z)),\n    getSdfWithPlane(vec3(pt.x, pt.y + 0.0001, pt.z)) - getSdfWithPlane(vec3(pt.x, pt.y - 0.0001, pt.z)),\n    getSdfWithPlane(vec3(pt.x, pt.y, pt.z + 0.0001)) - getSdfWithPlane(vec3(pt.x, pt.y, pt.z - 0.0001)));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 colorWheel(float angle) {\n    return hsv2rgb(vec3(angle, 1.0, 0.8));\n}\n            \nvec3 getDistanceColor(vec3 pt) {\n  return colorWheel(getSdf(pt) / 2.0);\n}\n\nvec3 illuminate(vec3 pt) {\n  vec3 color = (abs(pt.y + 1.0) < 0.001) ? getDistanceColor(pt) : white;\n  vec3 gradient = getGradient(pt);\n  float diff = diffuse(pt.xyz, normalize(gradient));\n  return (0.25 + diff * getShadow(pt))  * color;\n}\n\nvec3 raymarch(vec3 rayorig, vec3 raydir) {\n  vec3 pos = rayorig;\n  float d = getSdfWithPlane(pos);\n  int work = 0;\n\n  for (int step = 0; step < renderDepth; step++) {\n    work++;\n    pos = pos + raydir * d;\n    d = getSdfWithPlane(pos);\n    if (abs(d) < 0.001) {\n      break;\n    }\n  }\n\n  return showRenderDepth\n    ? vec3(float(work) / float(renderDepth))\n    : (abs(d) < 0.001) \n      ? illuminate(pos)\n      : background;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  forces[0] = vec3(-3, 0, 0);\n  forces[1] = vec3(3.0 * sin(iTime), 4.0 * abs(cos(iTime)), 0.0);\n  forces[2] = vec3(3, 0, 0);\n\n  vec3 camPos = 20.0 * vec3(cos(iTime / 10.0), 0.5, sin(iTime / 10.0));\n  vec3 camDir = normalize(-camPos);\n  fragColor = vec4(raymarch(camPos, getRayDir(camDir, fragCoord)), 1.0);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOrigin, in vec3 rayDirection ) {\n  forces[0] = vec3(-3, 0, 0);\n  forces[1] = vec3(3.0 * sin(iTime), 4.0 * abs(cos(iTime)), 0.0);\n  forces[2] = vec3(3, 0, 0);\n  fragColor = vec4(raymarch(rayOrigin * 10.0 + vec3(0.0, 3.0, 6.0), rayDirection), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsV3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[363, 363, 408, 408, 655], [657, 727, 756, 756, 853], [855, 855, 886, 886, 917], [919, 919, 954, 954, 1161], [1163, 1163, 1196, 1196, 1610], [1612, 1612, 1634, 1634, 1921], [1923, 1923, 1954, 1954, 2008], [2010, 2010, 2049, 2049, 2119], [2121, 2121, 2147, 2147, 2549], [2551, 2551, 2578, 2578, 2911], [2913, 2913, 2935, 2935, 3104], [3106, 3106, 3136, 3136, 3181], [3195, 3195, 3227, 3227, 3268], [3270, 3270, 3296, 3296, 3508], [3510, 3510, 3552, 3552, 3936], [3938, 3938, 3995, 3995, 4304], [4307, 4307, 4402, 4402, 4618]], "test": "untested"}
{"id": "MsV3W1", "name": "ellipse_and_arrows_2d", "author": "samuelotherion", "description": "ellipse 2d with arrows", "tags": ["2d", "ellipse", "arrows"], "likes": 1, "viewed": 114, "published": "Public", "date": "1454424176", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi            3.1415926535\n#define _t_           .5 * iTime\n#define ID_ARROW      0\n#define ID_ELLIPSE    1\n#define NUM_OF_ARROWS 6\n\nstruct Object { int id; vec2 pos; mat2 loc; vec4 col; };\nstruct Scene { vec2 xy; Object ellipse, arrows[ NUM_OF_ARROWS ]; };\n\nScene\n    scene;\n\nmat2\n    rotMat( in float p_angle ) {\n        \n        float\n            c = cos( p_angle ),\n            s = sin( p_angle );\n        \n        return mat2( c, s, -s, c );\n    }\n\n\nmat2\n    invMat( in mat2 p_mat ) {\n        \n        float\n            det = p_mat[ 0 ][ 0 ] * p_mat[ 1 ][ 1 ] - p_mat[ 1 ][ 0 ] * p_mat[ 0 ][ 1 ];\n        \n        return mat2( p_mat[ 1 ][ 1 ], -p_mat[ 1 ][ 0 ], -p_mat[ 0 ][ 1 ], p_mat[ 0 ][ 0 ] ) / det;\n    }\n\nvoid\n    init( vec2 p_xy ) {\n        \n        scene.xy = vec2( p_xy / iResolution.xy - .5 ) * vec2( iResolution.x / iResolution.y, 1. );\n        scene.ellipse =     Object( ID_ELLIPSE, vec2( +.25, +0. ), mat2( +.3, +0., +0., +.2 ), vec4( .7, .7, .7, 1. ) );\n        scene.arrows[ 0 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +.04, +0., +0., +.01 ), vec4( 1., .0, 0., 1. ) );\n        scene.arrows[ 1 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +0., +.04, -.01, +0. ), vec4( 0., 0., 1., 1. ) );\n        scene.arrows[ 2 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +0., +.4, -.01, +0. ), vec4(  .125, .25, .125, 1. ) );\n        scene.arrows[ 3 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +.8, +0., +0., +.02 ), vec4( .25, .125, .125, 1. ) );\n        scene.arrows[ 4 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +0., +.4, -.01, +0. ), vec4( 0., 1., 0., 1. ) );\n        scene.arrows[ 5 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +.25, +0., +0., +.01 ), vec4( .9, .9, .9, 1. ) );\n    }\n\nvec4\n    intersectArrow( in Object p_obj ) {\n        \n        float\n            border = .5 + .4 * sin( _t_ );\n        \n        vec2\n            d  = ( scene.xy - p_obj.pos ) * p_obj.loc;\n\n        d.x /= dot( p_obj.loc[ 0 ], p_obj.loc[ 0 ] );\n        d.y /= dot( p_obj.loc[ 1 ], p_obj.loc[ 1 ] );\n        \n        if( 0. <= d.x && d.x < border ) {\n         \n            if( abs( d.y ) < .3 ) return p_obj.col;\n            else if( abs( d.y ) < 1. ) return vec4( .3 * p_obj.col.rgb, 1. );\n        }\n        \n        d.x -= border;\n        border = 1. - border;\n        \n        if( 0. <= d.x && d.x < border ) {\n        \n            if( abs( d.y ) < ( 1. - d.x / border ) ) return p_obj.col;\n            else  if( abs( d.y ) < 1. ) return vec4( .3 * p_obj.col.rgb, 1. );\n        }\n        \n        return vec4( .0 );\n    }\n\nvec4\n    intersectEllipse( in Object p_obj ) {\n        \n        vec2\n            d  = ( scene.xy - p_obj.pos ) * p_obj.loc;\n        \n        d.x /= dot( p_obj.loc[ 0 ], p_obj.loc[ 0 ] );\n        d.y /= dot( p_obj.loc[ 1 ], p_obj.loc[ 1 ] );\n\n                \n        if( abs( d.x ) <= 1. && abs( d.y ) < 1. ) {\n        \n\t        if( dot( d, d ) < 1. ) return p_obj.col;\n    \n            return vec4( .3 * p_obj.col.rgb, 1. );\n        }\n        \n        return vec4( 0. );\n    }\n\nvec4\n    intersect( in Object p_obj ) {\n    \n        if( p_obj.id == ID_ARROW ) {\n            \n            return intersectArrow( p_obj );\n        }\n        \n        if( p_obj.id == ID_ELLIPSE ) {\n            \n            return intersectEllipse( p_obj );\n        }\n        \n        return vec4( 0. );\n    }\n\nvec4\n    render( ) {\n    \n        vec4\n            col = vec4( 0., 0., 0., 1. );\n        \n        col += intersect( scene.ellipse );\n        \n        for( int i = 0; i < NUM_OF_ARROWS; i++ ) {\n        \n            col += intersect( scene.arrows[ i ] );\n        }\n        //col /= col.a;\n        return vec4( .5 * col.rgb, 1. );\n    }\n\nvoid\n    animate( ) {\n        \n        mat2\n            rot1 = rotMat( _t_ * pi / 180. ),\n            rot90 = rotMat( pi / 2. ),\n            rot270 = rotMat( 3. * pi / 2. );\n        \n        mat2\n            rotT0 = rotMat( 1.3 * _t_ ),\n            rotT1 = rotMat( _t_ ),\n            rotT2 = rotMat( .1 * pi * sin( _t_ ) ),\n            rotT3 = rotMat( pi * sin( 5. / 3. * _t_ ) );\n        \n        scene.ellipse.loc = rotT3 * scene.ellipse.loc;\n\t\tscene.ellipse.pos = rotT0 * scene.ellipse.pos;\n        \n        scene.arrows[ 0 ].loc = scene.ellipse.loc;\n        scene.arrows[ 0 ].pos = scene.ellipse.pos;\n        \n        scene.arrows[ 1 ].loc = rot90 * rotT1 *  scene.arrows[ 0 ].loc;\n        scene.arrows[ 1 ].pos = scene.ellipse.pos;\n        \n        scene.arrows[ 2 ].loc = rotT2 * scene.arrows[ 2 ].loc;\n        \n        scene.arrows[ 3 ].loc = rotT2 * scene.arrows[ 3 ].loc;\n        \n        scene.arrows[ 4 ].pos = scene.ellipse.pos;\n        scene.arrows[ 4 ].loc = scene.ellipse.loc * rotT1;\n\n        scene.arrows[ 5 ].loc = rotT0 * scene.arrows[ 5 ].loc;\n    }\n\nvoid\n    mainImage( out vec4 p_c, in vec2 p_xy ) {\n        \n        init( p_xy );\n        \n        animate( );\n\t\n        p_c = render( );\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsV3W1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 322, 322, 460], [463, 463, 497, 497, 723], [725, 725, 753, 753, 1728], [1730, 1730, 1774, 1774, 2551], [2553, 2553, 2599, 2599, 3030], [3032, 3032, 3071, 3071, 3339], [3341, 3341, 3361, 3361, 3674], [3676, 3676, 3697, 3697, 4745], [4747, 4747, 4797, 4797, 4890]], "test": "untested"}
{"id": "MsV3WW", "name": "Panorama with Boats", "author": "dr2", "description": "Tracking camera switches between normal and 360 panorama modes", "tags": ["raymarching", "reflection", "water", "panorama"], "likes": 16, "viewed": 1067, "published": "Public API", "date": "1454580467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Panorama with Boats\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 i, f;\n  i = floor (p);  f = fract (p);  f = f * f * (3. - 2. * f);\n  t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 i, f;\n  float q;\n  i = floor (p);  f = fract (p);  f = f * f * (3. - 2. * f);\n  q = dot (i, cHashA3);\n  t1 = Hashv4f (q);  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);  f = fract (p);  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, cHashA3.xy));  t2 = Hashv4f (dot (i.zw, cHashA3.xy));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g, e;\n  float s;\n  e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nint idObj, idObjGrp;\nmat3 bMat, boatMat[2];\nvec3 bPos, boatPos[2], qHit, sunDir, waterDisp, cloudDisp;\nfloat tCur, bAng, boatAng[2], dstFar;\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.15, 0.2, 0.65) + vec3 (0.2) * pow (1. - max (rd.y, 0.), 5.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float cloudFac, skyHt, w, f, s;\n  skyHt = 200.;\n  if (rd.y > 0.) {\n    ro.x += cloudDisp.x;\n    p = 0.01 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    w = 0.65;\n    f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.3;\n    }\n    cloudFac = clamp (5. * (f - 0.3) * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  s = max (dot (rd, sunDir), 0.);\n  col = SkyBg (rd) + (0.35 * pow (s, 6.) + 0.65 * min (pow (s, 256.), 0.3));\n  return mix (col, vec3 (0.85), cloudFac);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (1.3 * sin (0.2 * t) + 1.7 * sin (0.09 * t) +\n     3.5 * sin (0.022 * t), 0., t);\n}\n\nfloat GrndHt (vec2 p)\n{\n  vec3 q;\n  float h, g;\n  h = 7. * Fbm2 (0.08 * p);\n  q = TrackPath (p.y);\n  return min (h, mix (q.y - 2., h, smoothstep (1.5, 4.5, sqrt (abs (p.x - q.x)))));\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy), e.x,\n     ht - GrndHt (p.xz + e.yx)));\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.1, 0.4 * h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 8; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nfloat WaveHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, t4o, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, pRough, ht;\n  wFreq = 0.3;  wAmp = 0.2;  pRough = 6.;\n  t4o.xz = tCur * vec2 (1., -1.);\n  q2 = p + waterDisp.xz;\n  ht = 0.;\n  for (int j = 0; j < 4; j ++) {\n    t4 = (t4o.xxzz + vec4 (q2, q2)) * wFreq;\n    t2 = Noisev2v4 (t4);\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + sqrt (1. - ta4 * ta4));\n    v2 = pow (1. - pow (clamp (v4.xz * v4.yw, 0., 1.), vec2 (0.65)), vec2 (pRough));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= qRot;  wFreq *= 2.;  wAmp *= 0.2;\n    pRough = 0.8 * pRough + 0.2;\n  }\n  return 0.4 * ht;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 70; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.4, 1.2 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - WaveHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  float h;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  h = WaveHt (p.xz);\n  return normalize (vec3 (h - WaveHt (p.xz + e.xy), e.x, h - WaveHt (p.xz + e.yx)));\n}\n\nfloat BoatDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= 0.7;\n  q = p;\n  d = max (max (PrRCylDf (q, 1.2, 2., 3.5),\n     - max (PrRCylDf (q - vec3 (0., 0.1, 0.), 1.15, 2., 3.5),\n     max (q.y - 0.1, - q.y - 0.1))), max (q.y - 0., - q.y - 0.2));\n  q.y -= -0.2;\n  d = max (SmoothMin (d, max (PrRCylDf (q, 1., 2., 3.3), q.y), 0.1), q.z - 2.);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 1;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (-0.5, -0.2);\n  d = max (PrRCylDf (q, 1., 1.1, 2.3), max (0.4 - q.y, q.z - 1.2));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 2;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (1.3, -0.6);\n  d = PrCylDf (q.xzy, 0.04, 0.8);\n  q.y -= 0.2;\n  d = min (d, PrCylDf (q.yzx, 0.02, 0.2));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 3; }\n  q.y -= 0.6;\n  d = PrCylDf (q.xzy, 0.15, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 4; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, -0.9, 2.);\n  d = PrRoundBoxDf (q, vec3 (0.02, 0.2, 0.1), 0.03);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 5; }\n  q.y -= -0.4;\n  d = PrCylAnDf (q, 0.1, 0.02, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 6; }\n  q = p;\n  q.yz -= vec2 (-1., 2.);\n  d = PrCylDf (q, 0.1, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 6; }\n  q = p;\n  q.yz -= vec2 (0.3, 1.9);\n  d = PrCylDf (q.xzy, 0.015, 0.5);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 7; }\n  q.yz -= vec2 (0.38, 0.15);\n  d = PrBoxDf (q, vec3 (0.01, 0.1, 0.15));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 8; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dLim;\n  const float szFac = 4.;\n  dLim = 0.5;\n  dMin = dstFar;\n  dMin *= szFac;\n  q = p - boatPos[0];\n  idObjGrp = 1 * 256;\n  d = PrCylDf (q.xzy, 2., 2.);\n  dMin = (d < dLim) ? BoatDf (szFac * boatMat[0] * q, dMin) : min (dMin, d);\n  q = p - boatPos[1];\n  idObjGrp = 2 * 256;\n  d = PrCylDf (q.xzy, 2., 2.);\n  dMin = (d < dLim) ? BoatDf (szFac * boatMat[1] * q, dMin) : min (dMin, d);\n  return dMin / szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 25; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += min (0.03, 3. * h);\n    if (h < 0.001) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 BoatCol (vec3 n)\n{\n  vec3 col, nn;\n  float spec;\n  int ig, id;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  if (ig == 1) nn = boatMat[0] * n;\n  else nn = boatMat[1] * n;\n  spec = 0.3;\n  if (id == 1) {\n    if (qHit.y < 0.1 && nn.y > 0.99) {\n      col = vec3 (0.8, 0.5, 0.3) *\n         (1. - 0.4 * SmoothBump (0.42, 0.58, 0.05, mod (7. * qHit.x, 1.)));\n      spec = 0.1;\n    } else if (qHit.x * nn.x > 0. && nn.y < 0. && qHit.z < 1.99 &&\n       abs (qHit.y - 0.1) < 0.095) col = (ig == 1) ? vec3 (0.3, 0.9, 0.3) :\n       vec3 (0.9, 0.3, 0.3);\n    else col = (qHit.y > -0.3) ? vec3 (1., 1., 0.2) : vec3 (0.7, 0.7, 0.8);\n  } else if (id == 2) {\n    if (abs (abs (qHit.x) - 0.24) < 0.22 && abs (qHit.y - 0.7) < 0.15 ||\n       abs (abs (qHit.z + 0.2) - 0.5) < 0.4 && abs (qHit.y - 0.7) < 0.15) {\n       col = vec3 (0., 0., 0.1);\n       spec = 1.;\n     } else col = vec3 (1.);\n  } else if (id == 3) col = vec3 (1., 1., 1.);\n  else if (id == 4) col = vec3 (1., 1., 0.4);\n  else if (id == 5) col = vec3 (0.4, 1., 0.4);\n  else if (id == 6) col = vec3 (1., 0.2, 0.);\n  else if (id == 7) col = vec3 (1., 1., 1.);\n  else if (id == 8) col = (ig == 1) ? vec3 (1., 0.4, 0.4) : vec3 (0.4, 1., 0.4);\n  return vec4 (col, spec);\n}\n\nfloat WaveAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 1; j <= 4; j ++) {\n    d = 0.1 * float (j);\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nfloat WakeFac (vec3 row)\n{\n  vec2 tw, tw1;\n  float wkFac, ba;\n  tw = row.xz - (boatPos[0].xz - Rot2D (vec2 (0., 1.5), boatAng[0]));\n  tw1 = row.xz - (boatPos[1].xz - Rot2D (vec2 (0., 1.5), boatAng[1]));\n  if (length (tw1) < length (tw)) {\n    tw = tw1;\n    ba = boatAng[1];\n  } else ba = boatAng[0];\n  tw *= 1.8;\n  tw = Rot2D (tw, - ba);\n  wkFac = 0.;\n  if (length (tw * vec2 (1., 0.5)) < 1.) wkFac =\n     clamp (1. - 1.5 * abs (tw.x), 0., 1.) * clamp (1. + 0.5 * tw.y, 0., 1.);\n  return wkFac;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, watCol, vn, vnw, row, rdw;\n  float dstObj, dstGrnd, dstWat, wkFac, sh;\n  int idObjT;\n  bool waterRefl;\n  dstWat = WaveRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  if (dstGrnd < dstObj) {\n    dstObj = dstGrnd;\n    idObj = 1;\n  }\n  waterRefl = (dstWat < min (dstFar, dstObj));\n  if (waterRefl) {\n    ro += rd * dstWat;\n    row = ro;\n    rdw = rd;\n    wkFac = WakeFac (row);\n    vnw = WaveNf (ro, dstWat);\n    if (wkFac > 0.) vnw = VaryNf (10. * row, vnw, 5. * wkFac);\n    rd = reflect (rd, vnw);\n    ro += 0.1 * rd;\n    idObj = -1;\n    dstObj = ObjRay (ro, rd);\n    dstGrnd = GrndRay (ro, rd);\n    if (dstGrnd < dstObj) {\n      dstObj = dstGrnd;\n      idObj = 1;\n    }\n  }\n  if (dstObj < dstWat) {\n    ro += dstObj * rd;\n    if (idObj == 1) {\n      vn = VaryNf (5. * ro, GrndNf (ro, dstObj), 1.);\n      objCol = vec4 (mix (vec3 (0.07, 0.25, 0.02), vec3 (0., 0.3, 0.),\n         clamp (0.8 * Noisefv2 (ro.xz) - 0.1, 0., 1.)), 0.1);\n      sh = 1.;\n    } else {\n      idObjT = idObj;\n      vn = ObjNf (ro);\n      idObj = idObjT;\n      objCol = BoatCol (vn);\n      sh = ObjSShadow (ro, sunDir);\n    }\n    col = objCol.rgb * (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       objCol.a * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n    col = mix (col, SkyCol (ro, rd), clamp (10. * dstObj / dstFar - 9., 0., 1.));\n  } else col = SkyCol (ro, rd);\n  if (waterRefl) {\n    watCol = (vec3 (0.15, 0.3, 0.3) * (0.5 + 0.5 * (max (vnw.y, 0.) +\n       0.1 * pow (max (0., dot (sunDir, reflect (rdw, vnw))), 64.)))) *\n       WaveAO (row, vec3 (0., 1., 0.));\n    col = mix (watCol, col, 0.8 * pow (1. - abs (dot (rdw, vnw)), 4.));\n    col = mix (col, vec3 (0.9),\n       pow (clamp (WaveHt (row.xz) + 0.4 * Fbm3 (7. * row), 0., 1.), 8.));\n    if (wkFac > 0.) col = mix (col, vec3 (0.9),\n       wkFac * clamp (0.1 + 0.5 * Fbm3 (23. * row), 0., 1.));\n    col = mix (col, SkyCol (row, rdw), clamp (10. * dstWat / dstFar - 9., 0., 1.));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvoid BoatPM (float t, float ds)\n{\n  vec2 bDir;\n  float h[5], c, s, bAz;\n  bPos = TrackPath (t);\n  vec3 bp = TrackPath (t + 0.1) - bPos;\n  bAz = atan (bp.z, - bp.x);\n  bPos.x += ds;\n  bDir = vec2 (0., 1.);\n  bDir = Rot2D (bDir, bAz);\n  h[0] = WaveHt (bPos.xz);\n  h[1] = WaveHt (bPos.xz + 0.5 * bDir);\n  h[2] = WaveHt (bPos.xz - 0.5 * bDir);\n  bDir = Rot2D (bDir, -0.5 * pi);\n  h[3] = WaveHt (bPos.xz + 0.5 * bDir);\n  h[4] = WaveHt (bPos.xz - 0.5 * bDir);\n  bPos.y = 0.05 + 1.1 * (2. * h[0] + h[1] + h[2] + h[3] + h[4]) / 6.;\n  bMat[2] = normalize (vec3 (0.5, h[2] - h[1], 0.));\n  bMat[0] = normalize (vec3 (0., 0.3 + h[3] - h[4], 2.));\n  bMat[1] = cross (bMat[0], bMat[2]);\n  c = cos (bAz);\n  s = sin (bAz);\n  bMat *= mat3 (c, 0., s, 0., 1., 0., - s, 0., c);\n  bAng = 0.5 * pi - bAz;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd, u, col;\n  vec2 canvas, uv, uvs;\n  float vuPeriod, vel, f, zmFac, sPano;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  vuPeriod = 100.;\n  sPano = SmoothBump (0.25, 0.75, 0.02, mod (tCur / vuPeriod, 1.));\n  if (abs (uvs.y) < 0.85 - 0.25 * sPano) {\n    dstFar = 300.;\n    sunDir = normalize (vec3 (cos (0.03 * tCur), 1., sin (0.03 * tCur)));\n    waterDisp = 0.1 * tCur * vec3 (-1., 0., 1.);\n    cloudDisp = 0.5 * tCur * vec3 (1., 0., 0.);\n    vel = 2.;\n    BoatPM (vel * tCur + 5., 0.2);\n    boatPos[0] = bPos;  boatMat[0] = bMat;  boatAng[0] = bAng;\n    BoatPM (vel * tCur - 5., -0.2);\n    boatPos[1] = bPos;  boatMat[1] = bMat;  boatAng[1] = bAng;\n    f = 2. * SmoothBump (0.25, 0.75, 0.2, mod (2. * tCur / vuPeriod, 1.)) - 1.;\n    ro = TrackPath (vel * tCur - 12. * f);\n    f = abs (f);\n    ro.y = 0.5 + WaveHt (ro.xz) + 3. * (1. - f * f);\n    ro.x += 1.3 * (1. - f);\n    zmFac = 4.5 - 2. * (1. - f * f);\n    f = smoothstep (0.1, 0.3, 1. - f);\n    vd = normalize (0.5 * ((1. + f) * boatPos[0] + (1. - f) * boatPos[1]) - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    rd = vuMat * normalize (mix (vec3 (uv, zmFac), \n       vec3 (sin (0.56 * pi * uv.x) , uv.y, cos (0.56 * pi * uv.x)), sPano));\n    col = ShowScene (ro, rd);\n  } else col = vec3 (0.);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsV3WW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 274, 298, 298, 345], [347, 347, 372, 372, 557], [559, 559, 584, 584, 900], [902, 902, 927, 927, 1237], [1239, 1239, 1260, 1260, 1399], [1401, 1401, 1422, 1422, 1561], [1563, 1563, 1592, 1592, 1804], [1806, 1806, 1845, 1845, 2060], [2062, 2062, 2092, 2092, 2166], [2168, 2168, 2200, 2200, 2300], [2302, 2302, 2348, 2348, 2395], [2397, 2397, 2439, 2439, 2490], [2492, 2492, 2545, 2545, 2606], [2608, 2608, 2661, 2661, 2840], [2842, 2842, 2887, 2887, 2990], [2992, 2992, 3049, 3049, 3132], [3276, 3276, 3298, 3298, 3378], [3380, 3380, 3412, 3412, 3952], [3954, 3954, 3980, 3980, 4078], [4080, 4080, 4103, 4103, 4264], [4266, 4266, 4297, 4297, 4470], [4472, 4472, 4506, 4506, 5042], [5044, 5044, 5067, 5067, 5746], [5748, 5748, 5782, 5782, 6316], [6318, 6318, 6349, 6349, 6520], [6522, 6522, 6557, 6557, 8037], [8039, 8039, 8061, 8061, 8497], [8499, 8499, 8532, 8532, 8708], [8710, 8710, 8731, 8731, 8954], [8956, 8956, 8993, 8993, 9236], [9238, 9238, 9261, 9261, 10455], [10457, 10457, 10490, 10490, 10671], [10673, 10673, 10699, 10699, 11169], [11171, 11171, 11206, 11206, 13245], [13247, 13247, 13280, 13280, 14031], [14033, 14033, 14089, 14089, 15589]], "test": "untested"}
{"id": "MsV3zG", "name": "Menger Sponge Var With Displace", "author": "aiekick", "description": " all the code under come from the famous shader from shane https://www.shadertoy.com/view/ldyGWm with texture displace\n i have just modified the map func for adding the tri planar displace at line 117\n also modify the little hole size at line 136 ", "tags": ["raymarching", "fractal", "displace", "menger", "reflections", "wood", "sponge", "shane"], "likes": 15, "viewed": 950, "published": "Public API", "date": "1455190411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//all the code under come from the famous shader from \"shane\" https://www.shadertoy.com/view/ldyGWm with texture displace\n// i have just modified the map func for adding the tri planar displace at line 117\n// also modify the little hole size at line 136 (.3/6. instead of .5/6. )\n/*\n\n    Menger Sponge Variation\n    -----------------------\n\n\tI got bored and dusted off some old Menger Sponge related code. There's a lot of \n\texamples on this site, so I'm not bringing anything new to the table. This particular\n\tobject was constructed via a slight variation on the formula.\n\n\tThe lighting was made up as I went along, so I wouldn't pay too much attention to it. \n\tHowever, the cheap reflections might be worth looking at.\n\n\tFor anyone who's never put a Menger Sponge together, here's a very, very short, overly \n\tgeneralized explanation:\n\t\n\tConstruct a Void Cube (or repeat Void Cubes, as the case may be), which is analogous \n\tto a Rubix Cube with the center mechanism removed. Create Void Cubes from the 20 cubies \n\t(the remaining\tsmaller cubes), and continue to iterate ad infinitum.\n\t\n\tIn code:\n\n\t// Repeat Void Cubes - A Void Cube is a Level-1 Menger Sponge.\n\tfloat map(vec3 p){\n    \tp = abs(mod(p, 3.) - 1.5); // Repeat space.\n    \treturn min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.; // Void Cube.\n\t}\n\n\t// More than one level Menger Sponge - Infinitely repeated, in this case.\n\tfloat map(vec3 q){\n        \n\t\tvec3 p; float d = 0.;\n        \n        // One Void Cube.\n    \tp = abs(mod(q, 3.) - 1.5);\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.);\n\n        // Subdividing into more Void Cubes.    \n    \tp = abs(mod(q, 1.) - 0.5); // Dividing above by 3.\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3.);\n        \n        // And so on.\n    \tp = abs(mod(q, 1./3.) - 0.5/3.); // Dividing above by 3.\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3./3.);\n        \n\t\t// Continue on in this manner. For more levels, you'll want to loop it. There's\n\t\t// a commented out example in the code somewhere. Also, you can experiment with \n\t\t// the code to create more interesting variants.\n\n\t\treturn d;\n\t}\n\t\n\tFor a more formal explanation, look up \"Menger Sponge,\" \"Cantor Sets,\" \"Void Cube,\" \n\tetc., on the web, or better yet, refer to the countless Menger Sponge examples\n\ton this site.\t\n\n\tExamples:\n\n\tMenger Journey - Syntopia (A favorite of mine, and everyone else.)\n\thttps://www.shadertoy.com/view/Mdf3z7\n\n*/\n\n#define FAR 40.\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, 0.001); // n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n \n    \n}\n\n// Smooth minimum function. There are countless articles, but IQ explains it best here:\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat sminP( float a, float b, float smoothing ){\n\n    float h = clamp( 0.5+0.5*(b-a)/smoothing, 0.0, 1.0 );\n    return mix( b, a, h ) - smoothing*h*(1.0-h);\n}\n\n\n/*\n// Regular Menger Sponge formula. Very simple, but if you're not sure, look it\n// up on Wikipedia, and look up a Void Cube image.\nfloat map(vec3 q){\n    \n    vec3 p;\n\t// Scale factor, and distance.\n    float s = 3., d = 0.;\n    \n    for(int i=0; i<3; i++){\n \t\t// Repeat space.\n        p = abs(fract(q/s)*s - s/2.); // Equivalent to: p = abs(mod(q, s) - s/2.);\n\t\t// Repeat Void Cubes. Cubes with a cross taken out.\n \t\td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.);\n    \ts /= 3.; // Divide space (each dimension) by 3.\n    }\n \n \treturn d;    \n}\n*/\n\n// Variation on a Menger Sponge (See the formula above). This one has four layers. The \n// easiest way to understand this is to comment out layers, then add them back in to \n// see what each does.\nfloat map(vec3 q){\n    \n    // basic tri planar add\n    float dsp = 0.02;\n    q.z += dot(texture(iChannel1, q.xy).rgb, vec3(dsp));\n\tq.x += dot(texture(iChannel1, q.yz).rgb, vec3(dsp));\n\tq.y += dot(texture(iChannel1, q.xz).rgb, vec3(dsp));\n\t\n    // Layer one. The \".05\" on the end varies the hole size.\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .05;\n    \n    // Layer two.\n    p =  abs(fract(q) - .5);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\n   \n    // Layer three. 3D space is divided by two, instead of three, to give some variance.\n    p =  abs(fract(q*2.)*.5 - .25);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015); \n\n    // Layer four. The little holes, for fine detailing.\n    p =  abs(fract(q*3./.5)*.5/3. - .3/6.);\n \treturn max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\n    //return max(d, max(max(p.x, p.y), p.z) - 1./18. - .024);\n    //return max(d, length(p) - 1./18. - .048);\n    \n    //p =  abs(fract(q*3.)/3. - .5/3.);\n \t//return max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./9. - .04);\n}\n\n\n\n// Very basic raymarching equation. Menger Sponge objects raymarch reasonably well. Not all surfaces do.\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    for(int i=0; i< 64; i++){        \n        d = map(ro + rd*t);\n        if (d <.0025*t || t>FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n// The reflections are pretty subtle, so not much effort is being put into them. Only a few iterations.\nfloat refTrace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for(int i=0; i< 16; i++){\n        d = map(ro + rd*t);\n        if (d <.0025*t || t>FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO(in vec3 p, in vec3 n){\n    \n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.;\n    \n    const float maxDist = 1.;\n    for(float i=1.; i<nbIte+.5; i++){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 16; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.02, 0.25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.5, 1.0); \n}\n\n/*\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// It gives you a scalar curvature value for an object's signed distance function, which \n// is pretty handy for all kinds of things. Here's it's used to darken the crevices.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n// calculations, I'm assuming. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p){\n\n    //const float eps = 0.05, amp = 4.0, ampInit = 0.5;\n    const float eps = 0.15, amp = 2.5, ampInit = 0.0;\n\n    vec2 e = vec2(-1., 1.)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit direction ray vector: Note the absence of a divide term. I came across this via a comment \n    // Shadertoy user \"Coyote\" made. I'm pretty happy with this.\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y)); // Normalizing below.\n    \n    // Barrel distortion. Looks interesting, but I like it because it fits more of the scene in.\n    // If you comment this out, make sure you normalize the line above.\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\n    \n    // Rotating the ray with Fabrice's cost cuttting matrix. I'm still pretty happy with this also. :)\n    vec2 m = sin(vec2(0, 1.57079632) + iTime/4.);\n    rd.xy = mat2(m.y, -m.x, m)*rd.xy;\n    rd.xz = mat2(m.y, -m.x, m)*rd.xz;\n    \n    \n    // Ray origin, set off in the Z direction.\n    vec3 ro = vec3(0.0, 0.0, iTime);\n    vec3 lp = ro  + vec3(0.0, 1.0, 0.0); // Light, near the ray origin.\n    \n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n    \n    float t = trace(ro, rd); // Raymarch.\n    \n    // Scene hit, so do some lighting.\n    if(t<FAR){\n    \n        vec3 sp = ro + rd*t; // Surface position.\n        vec3 sn = normal(sp); // Surface normal.\n        vec3 ref = reflect(rd, sn); // Reflected ray.\n\n\t\tconst float ts = 2.; // Texture scale.\n        vec3 oCol = tex3D(iChannel0, sp*ts, sn); // Texture color at the surface point.\n        \n \t\t\n        // Darker toned wood paneling. Very fancy. :)\n        vec3 q = abs(mod(sp, 3.) - 1.5);\n        if (max(max(q.x, q.y), q.z) < 1.063) oCol = oCol*vec3(.7, .85, 1.); \n\n        // Bringing out the texture colors a bit.\n        oCol = smoothstep(0.0, 1.0, oCol);\n \n        float sh = softShadow(sp, lp, 16.); // Soft shadows.\n        float ao = calculateAO(sp, sn); // Self shadows.\n\n        vec3 ld = lp - sp; // Light direction.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light direction vector.\n\n        float diff = max(dot(ld, sn), 0.); // Diffuse component.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 12.); // Specular.\n        //float fres = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n\n        float atten = 1.0 / (1.0 + lDist*0.25 + lDist*lDist*.1); // Attenuation.\n        \n        \n        // Secondary camera light, just to light up the dark areas a bit more. It's here just\n        // to add a bit of ambience, and its effects are subtle, so its attenuation \n        // will be rolled into the attenuation above.\n        diff += max(dot(-rd, sn), 0.)*.45;\n        spec += pow(max(dot(reflect(rd, sn), -rd), 0.), 12.)*.45;\n        \n        // Based on Eiffie's suggestion. It's an improvement, but I've commented out, \n        // for the time being.\n        //spec *= curve(sp); \n\n\n\t\t// REFLECTION BLOCK.\n        //\n        // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much \n        // effort is being put in.\n        float rt = refTrace(sp + ref*0.1, ref); // Raymarch from \"sp\" in the reflected direction.\n        vec3 rsp = sp + ref*rt; // Reflected surface hit point.\n        vec3 rsn = normal(rsp); // Normal at the reflected surface.\n        \n        vec3 rCol = tex3D(iChannel0, rsp*ts, rsn); // Texel at \"rsp.\"\n        q = abs(mod(rsp, 3.) - 1.5);\n        if (max(max(q.x, q.y), q.z)<1.063) rCol = rCol*vec3(.7, .85, 1.);  \n        // Toning down the power of the reflected color, simply because I liked the way it looked more. \n        rCol = sqrt(rCol); \n        float rDiff = max(dot(rsn, normalize(lp-rsp)), 0.); // Diffuse at \"rsp\" from the main light.\n        rDiff += max(dot(rsn, normalize(-rd-rsp)), 0.)*.45; // Diffuse at \"rsp\" from the camera light.\n        \n        float rlDist = length(lp - rsp);\n        float rAtten = 1./(1.0 + rlDist*0.25 + rlDist*rlDist*.1);\n        rCol = min(rCol, 1.)*(rDiff + vec3(.5, .6, .7))*rAtten; // Reflected color. Not accurate, but close enough.\n        //\n    \t// END REFLECTION BLOCK.\n        \n\n        // Combining the elements above to light and color the scene.\n        col = oCol*(diff + vec3(.5, .6, .7)) + vec3(.5, .7, 1)*spec*2. + rCol*0.25;\n\n\n        // Shading the scene color, clamping, and we're done.\n        col = min(col*atten*sh*ao, 1.);\n        \n        \n        \n        \n        \n         \n    }\n    \n    // Working in a bit of a blue fadeout in the distance. Totally fake. I chose blue to counter all\n    // that walnut. Seemed like a good idea at the time. :)\n    col = mix(col, vec3(.55, .75, 1.), smoothstep(0., FAR - 15., t));////1.-exp(-0.01*t*t)\n\n    \n\tfragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsV3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 2524, 2546, 2546, 2581], [2584, 2738, 2788, 2788, 3014], [3016, 3156, 3205, 3205, 3315], [3895, 4092, 4110, 4143, 5293], [5297, 5402, 5432, 5432, 5603], [5605, 5709, 5742, 5742, 5901], [5904, 5976, 5999, 6108, 6266], [6487, 6719, 6759, 6759, 7067], [7070, 7285, 7329, 7446, 8560], [8562, 9607, 9663, 9841, 14307]], "test": "untested"}
{"id": "MsVGRc", "name": "Dragon [TDF2016]", "author": "gaz", "description": "GLSL Graphics for Tokyo Demo Fest 2016", "tags": ["raymarching", "modeling"], "likes": 27, "viewed": 605, "published": "Public", "date": "1456068074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2 PI*2.0\n#define PIH PI*0.5\n#define EPS 0.01\n#define BB_OFFSET 0.1\n\n#define HEAD -2.0\n#define TAIL 2.0\n\n#define ZOOM 0\n\nmat2 rotate(in float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 lookat(in vec3 eye, in vec3 target)\n{\n\tvec3 w = normalize(target-eye);\n\tvec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n\tvec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvec4 quaternion(in vec3 p, in float a)\n{\n\treturn vec4(p*sin(a/2.0),cos(a/2.0));\n}\n\nvec4 invq(in vec4 q)\n{\n    return vec4(-q.xyz,q.w);\n}\n\nvec3 qtransform(in vec4 q, in vec3 p)\n{\n\treturn p+2.0*cross(cross(p,q.xyz)-q.w*p,q.xyz);\n}\n\nfloat smin(in float a, in float b, in float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}    \n\nvec2 fold1(in vec2 p, in float a)\n{\n    p.x = abs(p.x);\n    vec2 v = vec2(cos(a),sin(a));\n    p -= 2.0*min(0.0,dot(p,v))*v;\n    return p;    \n}\n\nvec2 fold3(in vec2 p, in float a)\n{\n    p.x = abs(p.x);\n    vec2 v = vec2(cos(a),sin(a));\n    for(int i=0;i<3;i++)\n    {\t\n    \tp -= 2.0*min(0.0,dot(p,v))*v;\n    \tv = normalize(vec2(v.x-1.0,v.y));\n    }\n \treturn p;    \n}\n     \nvec2 bend(in vec2 p, in float d)\n{\n    p.y -= d*p.x*p.x;\n    p.y *= cos(atan(2.0*d*p.x));\n \treturn p;   \n}\n    \nfloat gaussian(in float t)\n{\n    return exp(-t*t);\n}\n    \nfloat lengthN(in vec2 p, in float n)\n{\n\tp = pow(abs(p),vec2(n));\n\treturn pow(p.x+p.y,1.0/n);\n}\n\nvec2 segment(in vec2 p, in float a, in float b)\n{\n    float x=clamp(p.x,min(a,b),max(a,b));\n    return vec2(length(p-vec2(x,0.0)),(x-a)/(b-a));\n}\n\nfloat pattern(in vec2 p) {\n    p *= vec2(8.0,25.0);\n \tp.x = mod(p.x,2.0)-1.0;\n    p.y = mod(p.y,4.0)-2.0;    \n    float de = abs(abs(p.x)+clamp(abs(p.y)-1.0,-0.5,0.5)-0.5);\n    return clamp(de+0.7,0.0,1.0);\n}\n\nvec2 bodyCurve(in float x)\n{\n    float t = iTime * 1.5;\n    return vec2(\n        0.05*cos(x*5.0+t)+0.1*cos(x*3.0+t),\n        0.1*sin(x*5.0+t)+0.15*sin(x*3.0+t));\n}\n    \nfloat barbCurve(in float x)\n{\n    float t = iTime*1.5;\n \treturn mix(0.0,0.02*sin(-40.0*x+t),clamp(x*5.0,0.0,1.0));   \n}\n\nfloat HairCurve(in float x)\n{\n    return mix(0.0,0.02*sin(35.0*x),clamp(x*6.0,0.0,1.0))+x*0.6;   \n}\n\nfloat mapTop(in vec3 p) // head parts\n{\n    float bump = 0.005*pattern(vec2(atan(p.y,p.z),p.x)*vec2(1.0,1.5));\n    p -= vec3(-0.03,0.07,0.0);\n    p *= vec3(0.8,1.5,1.0);\n    float de = length(vec2(lengthN(p.xy,3.0),p.z))-0.07;\n    p -= vec3(-0.047,-0.01,0.0);\n    p.z = abs(p.z); p.z -= 0.035;\n    de = smin(de, length(p)-0.035,0.01);    \n    p.y -= 0.004;\n    p.yz *= rotate(-0.1);\n    p.y *= 1.8;\n    de -= -0.06*gaussian(length(p.yz)*90.0)*step(0.0,-p.x);      \n    de -= bump;\n    return de;\n}\n\nfloat mapUpperJaw(in vec3 p) // head parts\n{\n    float bump = 0.005*pattern(vec2(atan(p.y,p.z),p.x)*vec2(1.0,1.5));    \n    vec3 q = p;\n    p.y -= 0.01;\n    p.xy = bend(p.xy, 0.2);\n    vec2 sg = segment(p.xy,-0.3,0.0);\n    float de = lengthN(vec2(sg.x, p.z*0.6),2.5)-(0.02*sg.y*sg.y+0.03);\n    p.x -= -0.3;\n    p.z = abs(p.z); p.z -= 0.032;\n    de -= 0.006*gaussian(length(p.xz)*70.0)*step(0.0,p.y);\n    p.y -= 0.0045;\n    p.yz *= rotate(-0.3);\n    p.y *= 1.6;\n    de -= -0.02*gaussian(length(p.yz)*120.0)*step(0.0,-p.x);   \n    q.x -= -0.28;\n    q.x *= 0.3;\n    de -= 0.01*gaussian(length(q.xz)*70.0)*step(0.0,q.y);   \n    de -= bump;\n    return de;\n}\n\nfloat mapUpperFang(in vec3 p) // head parts\n{\n    p -= vec3(-0.3,-0.04,0.0);\n    p.z = abs(p.z); p.z -= 0.04;\n    vec2 sg = segment(p.yz,0.0,0.05);\n    return lengthN(vec2(sg.x,p.x),1.5)-0.01*sg.y;\n}\n\nfloat mapBottomJaw(in vec3 p) // head parts\n{\n    float bump = 0.005*pattern(vec2(atan(p.y,p.z),p.x)*vec2(0.7,1.7))*step(-0.02,-p.y);\n\tp.xy = bend(p.xy,-0.2);\n    vec2 sg = segment(p.xy,-0.25,0.0);\n    float de = lengthN(vec2(sg.x, p.z*0.7),2.5)-(0.02*sg.y*sg.y+0.03);    \n    de -= -0.008*gaussian(length(p.yz)*50.0)*step(0.0,-p.x);        \n    p.x -= -0.1;\n    p.x *= 0.15;   \n    de -= -0.05*gaussian(length(p.xz)*60.0)*step(0.0,p.y);            \n    de -= bump;\n    return de;\n}\n\nfloat mapBottomFang(in vec3 p) // head parts\n{\n    p -= vec3(-0.24,0.017,0.0);\n    p.z = abs(p.z); p.z -= 0.03;\n    p.x = abs(p.x); p.x -= 0.01;\n    p.x = abs(p.x); p.x -= 0.01;\n    p.yz *= rotate(0.2);\n    vec2 sg = segment(p.yz,0.03,0.0);\n    return lengthN(vec2(sg.x,p.x),1.5)-0.01*sg.y;\n}\n\nfloat mapEyes(in vec3 p) // head parts\n{\n    p -= vec3(-0.115,0.065,0.0);\n    p.z = abs(p.z); p.z -= 0.035;\n    return length(p)-0.015;\n}\n\nfloat mapEars(in vec3 p) // head parts\n{\n    p -= vec3(-0.025,0.06,0.0);\n    p.z = abs(p.z); p.z -= 0.08;\n    p.z *=1.5;\n    p.yz *= rotate(0.5);\n    p.xy *= rotate(-0.3);\n    vec2 sg = segment(p.yx,0.08,0.0);\n    float de = lengthN(vec2(sg.x,p.z),5.0)-(0.02*sg.y+0.01);\n    p.y -= 0.02;\n    p.y *=0.5;\n    de -= -0.02*gaussian(length(p.yx)*70.0)*step(0.0,p.z);\n    return de;\n}\n\nfloat mapHorns(in vec3 p) // head parts\n{\n    p -= vec3(0.0,0.05,0.0);\n    p.z = abs(p.z); p.z -= 0.04;\n    p.xz *= rotate(0.3);\n    p.xy *= rotate(-0.5);\n    p.yz = bend(p.yz, 0.3);\n    vec2 sg = segment(p.yz,0.25,0.0);\n    return lengthN(vec2(sg.x,p.x),1.5)-0.01;\n}\n    \nfloat mapBarb(in vec3 p) // head parts\n{\n    p -= vec3(-0.27,0.04,0.0);\n    p.z = abs(p.z); p.z -= 0.05;\n    p.zy *= rotate(0.5);\n    p.xz *= rotate(-0.8);\n    p.y -= barbCurve(p.z);\n    float g = (barbCurve(p.z+EPS)-barbCurve(p.z-EPS))/(2.0*EPS);\n    p.x *= cos(atan(g));\n    vec2 sg = segment(p.zx,0.25,0.0);\n    return 0.7*(length(vec2(sg.x, p.y))-(0.005*sg.y+0.003));\n}\n\nfloat mapHair(in vec3 p) // head parts\n{\n    p -= vec3(-0.02,0.055,0.0);\n    p.zy = fold3(p.zy,radians(140.0));\n    p.y -= 0.06;    \n    p.y -= HairCurve(p.x);\n    float g = (HairCurve(p.z+EPS)-HairCurve(p.z-EPS))/(2.0*EPS);\n    p.x *= cos(atan(g));\n    vec2 sg = segment(p.xz,0.12,0.0);\n    return 0.7*(length(vec2(sg.x, p.y))-(0.01*sg.y+0.004));\n}\n\nfloat mapHead(in vec3 p)\n{\n    p.x -= HEAD;\n    p.zy -= bodyCurve(HEAD);\n    \n    // bounding box\n    vec3 q = p;\n    q -= vec3(-0.1,0.07,0.0);\n    vec3 bb = vec3(0.24,0.21,0.2)+BB_OFFSET;\n    if (any(greaterThan(abs(q),bb))) return length(max(abs(q)-bb,0.0))+BB_OFFSET;\n\n    // BottomJaw postion\n    q = p;\n    q.y -= -0.01;    \n    q.xy *= rotate(0.1*sin(iTime)+0.3);\n   \n    float de = 1.0;\n    de =  min(de, mapTop(p));\n\tde = smin(de, mapUpperJaw(p),0.02);\n    de = smin(de, mapEars(p),0.03);\n\tde =  min(de, mapHair(p));\n\tde =  min(de, mapEyes(p));\n\tde =  min(de, mapHorns(p));\n    de =  min(de, mapUpperFang(p));\n    de =  min(de, mapBarb(p));\n    de =  min(de, mapBottomJaw(q));\n    de =  min(de, mapBottomFang(q));\n    return de;\n}\n\nfloat mapBody(in vec3 p)\n{\n    p.zy -= bodyCurve(p.x);\n\tvec2 g = (bodyCurve(p.x+EPS)-bodyCurve(p.x-EPS))/(2.0*EPS);\n    p.zy *= cos(atan(g));\n    \n    // bounding box\n    vec3 q = p;\n    q -= vec3(0.0,0.03,0.0);\n    vec3 bb = vec3(2.2,0.2,0.15)+BB_OFFSET;\n    if (any(greaterThan(abs(q),bb))) return length(max(abs(q)-bb,0.0))+BB_OFFSET;\n    \n    // main\n    vec3 pMain = p;\n    vec2 sg = segment(p.xy,TAIL,HEAD);\n    float t = -abs(sg.y-0.6)*1.2+0.75;\n    t = 0.1*smoothstep(0.0,0.25,t*t);\n    \n    float deMain = 0.8*(lengthN(vec2(sg.x,p.z*0.8),2.5)-(t+0.02));\n    float a = atan(p.z,-p.y);    \n    deMain -= -0.005*gaussian((abs(a)-0.6)*20.0)*step(0.0,-p.y);\n    if (abs(a)<0.6)\n    {\n        deMain -= -0.005*gaussian(sin(p.x*PI2*6.0)*3.0)*step(0.0,-p.y);\n        deMain -= 0.001*length(sin(vec2(p.x*10.0,a)*20.0));\n    } else {\n        deMain -= 0.005*pattern(vec2(a,p.x));\n    }\n\n    // fin\n    p -= vec3(-0.4,t+0.03,0.0);\n    float s = 0.05;\n    for(int i=0;i<14;i++){\n        p.x = abs(p.x);\n        p.x -= s*2.0;\n    }\n    p.x += s;\n    p.y *= 0.4;\n    p.xy *= rotate(0.8);\n    float deFin = max(abs(p.z)-0.01,lengthN(p.xy,5.0)-0.02);\n    \n    float de = 1.0;\n    de =  min(de,deMain);\n    de = smin(de,deFin,0.01);\n    return de;\n}\n\nfloat  mapArm1(in vec3 p) // arms parts\n{\n    vec2 sg = segment(p.zx,0.3,0.0);\n    float de = lengthN(vec2(sg.x, p.y*1.2),2.5)-(0.05*sg.y+0.05);\n    de -= 0.005*pattern(vec2(atan(p.y,p.x),p.z)*vec2(0.7,1.8));\n    return de;\n}\n\nfloat  mapArm2(in vec3 p) // arms parts\n{\n    vec2 sg = segment(p.zx,0.3, 0.0);\n    float de = lengthN(vec2(sg.x, p.y*1.2),2.5)-(0.02*sg.y+0.04);\n    de -= 0.005*pattern(vec2(atan(p.y,p.x),p.z)*vec2(0.7,1.8));\n    return de;\n}\n    \nfloat  mapHand(in vec3 p) // arms parts\n{\n    p -= vec3(-0.05,-0.02,0.0);\n \tp.zx = fold1(p.zx,radians(110.0));\n    p.xy *= rotate(-0.5);\n    vec2 sg = segment(p.xz,0.08,0.0);\n    float deHand = lengthN(vec2(sg.x,p.y),3.0)-(0.02*sg.y+0.02);\n    p.x -= 0.08;\n    p.xy *= rotate(-0.6);\n    p.xy = bend(p.xy, -5.0);\n    sg = segment(p.xz,0.1,0.0);\n    float deClaw = lengthN(vec2(sg.x,p.y),2.5)-(0.02*sg.y);\n    return smin(deHand, deClaw, 0.03);\n}\n\nfloat  mapClaw(in vec3 p) // arms parts for coloring\n{\n    p -= vec3(-0.05,-0.02,0.0);\n \tp.zx = fold1(p.zx,radians(110.0));\n    p.xy *= rotate(-0.5);\n    p.x -= 0.08;\n    p.xy *= rotate(-0.6);\n    p.xy = bend(p.xy, -5.0);\n    vec2 sg = segment(p.xz,0.1,0.0);\n    return lengthN(vec2(sg.x,p.y),2.5)-(0.02*sg.y);\n}\n\nfloat  mapBall(in vec3 p, in float s) // arms parts\n{\n    p -= vec3(-0.05,-0.12,0.01);\n    if (s<0.0) return length(p)-0.06;\n    return 1.0;\n}    \n\nfloat mapArms(in vec3 p)\n{\n    const float offset = -1.2;\n    p.x -= offset;\n    p.zy -= bodyCurve(offset);\n    \n    // bounding box\n    vec3 q = p;\n    q -= vec3(-0.015,-0.12,0.0);\n    vec3 bb = vec3(0.28,0.25,0.62)+BB_OFFSET;\n    if (any(greaterThan(abs(q),bb))) return length(max(abs(q)-bb,0.0))+BB_OFFSET;\n\n\tfloat s = sign(p.z);   \n    p.z = abs(p.z);\n\n    vec4 quat;\n\tp -= vec3(0.0, 0.0, 0.15);\n    quat = quaternion(normalize(vec3(0.5,1.0,0.0)),-0.7);\n    vec3 p1 = qtransform(quat, p);\n    \n    p -= qtransform(invq(quat),vec3(0.0,0.0,0.3));\n    quat = quaternion(normalize(vec3(-0.7,1.0,0.0)),1.0);\n    vec3 p2 = qtransform(quat, p);\n    \n    p -= qtransform(invq(quat),vec3(0.0,0.0,0.3));\n    quat = quaternion(normalize(vec3(0.0,0.0,1.0)),0.5);\n    vec3 p3 = qtransform(quat, p);\n         \n    float de = 1.0;\n    de =  min(de,mapArm1(p1));\n    de = smin(de,mapArm2(p2),0.04);\n    de = smin(de,mapHand(p3),0.03);\n    de =  min(de,mapBall(p3,s));\n        \n    return de;\n}\n\nfloat mapDragon(in vec3 p)\n{\n    p.zx *= rotate(PIH);\n    p.yx *= rotate(0.2);\n    float de = 1.0;\n    de =  min(de,mapBody(p));\n    de = smin(de,mapHead(p),0.03);\n    de = smin(de,mapArms(p),0.06);\n    return de;\n}\n\nfloat mapGround(in vec3 p)\n{\n    float de = p.y-0.2;\n    de -= 0.02*sin(5.0*p.x+iTime*0.5);\n    de -= 0.02*sin(7.0*p.z+iTime*1.5);\n    de -= 0.02*sin(8.0*length(p.zx)+iTime);\n    return de;\n}\n\nvec3 doMotion(in vec3 p)\n{\n#if ZOOM\n    p.z -= -2.0;\n    p.y -= 1.0;\n    return p;\n#endif\n    \n    float t = mod(iTime,60.0);\n    float h;\n    if (t < 40.0)\n    {\n    \t// 0-10s\n    \tp -= vec3(0.0,-0.5,-0.5);\n    \th = clamp(t-0.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(0.0,0.9,0.0),h);    \n    \t//10-20s\n    \th = clamp(t-10.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(0.8,-0.3,0.0),h*h);\n    \tp.xz *= rotate(PIH * h*h);\n    \tp.zy *= rotate(0.3* h);\n    \t//20-30s\n    \th = clamp(t-20.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(-0.2,1.0,0.0),h*h);\n    \tp.zy *= rotate(-0.5* h);\n    \t//30-40s\n    \th = clamp(t-30.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(-0.5,-2.3,0.0),h*h);\n\t\tp.zy *= rotate(-0.6* h*h);\n    }\n    else if (t < 50.0)    \n    {\n    \t//40-50s\n        p -= vec3(0.0,-2.1,0.7);\n        p.zy *= rotate(PIH);        \n    \th = clamp(t-40.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(0.5,0.0,6.0),h*h);\n    \tp.yx *= rotate(-PI2*1.5*h);\n    }\n    else\n    {\n    \t//50-60s\n    \tp -= vec3(0.0,0.15,-4.5);\n    \th = clamp(t-50.0,0.0,10.0)/10.0;\n    \tp -= mix(vec3(0.0),vec3(0.0,0.0,7.5),h);\n    }\n    return p;\n}\n\nfloat map(in vec3 p)\n{   \n    return min(mapGround(p),mapDragon(doMotion(p)));\n}\n\nvec3 doColor(in vec3 p)\n{\n    float e = 0.001;\n    if (mapGround(p)<e) return vec3(0.2,0.2,0.35);\n    p = doMotion(p);\n    p.zx *= rotate(PIH);\n    p.yx *= rotate(0.2);\n    vec3 q = p;\n    \n    // body\n    p.zy -= bodyCurve(p.x);\n\tvec2 g = (bodyCurve(p.x+EPS)-bodyCurve(p.x-EPS))/(2.0*EPS);\n    p.zy *= cos(atan(g));\n    float a = atan(p.z,-p.y);\n    if (abs(a)<0.65 && p.x>-1.95) return vec3(0.75,0.65,0.5);\n    vec2 sg = segment(p.xy,TAIL,HEAD);\n    float t = -abs(sg.y-0.6)*1.2+0.75;\n    t = 0.1*smoothstep(0.0,0.25,t*t);\n    if (p.y>t+0.03 && p.x>-1.8) return vec3(0.7,0.1,0.1);\n    \n    // arms\n    p = q;\n    const float offset = -1.2;\n    p.x -= offset;\n    p.zy -= bodyCurve(offset);\n\tfloat s = sign(p.z);   \n    p.z = abs(p.z);\n    vec4 quat;\n\tp -= vec3(0.0, 0.0, 0.15);\n    quat = quaternion(normalize(vec3(0.5,1.0,0.0)),-0.7);\n    p -= qtransform(invq(quat),vec3(0.0,0.0,0.3));\n    quat = quaternion(normalize(vec3(-0.7,1.0,0.0)),1.0);\n    p -= qtransform(invq(quat),vec3(0.0,0.0,0.3));\n    quat = quaternion(normalize(vec3(0.0,0.0,1.0)),0.5);\n    p = qtransform(quat, p);\n    if (mapClaw(p)<e) return vec3(1.0);\n    if (mapBall(p,s)<e) return vec3(0.9,0.8,0.3);\n\n    // head\n    p = q;\n    p.x -= HEAD;\n    p.zy -= bodyCurve(HEAD);\n    if (mapHair(p)<e) return vec3(0.1,0.05,0.05);\n\tif (mapHorns(p)<e) return vec3(0.9,0.5,0.1);\n    if (mapUpperFang(p)<e) return vec3(0.8);\n    if (mapBarb(p)<e) return vec3(0.1);\n    if (mapEyes(p)<e)\n    {\n        p -= vec3(-0.115,0.065,0.0);\n    \tp.z = abs(p.z); p.z -= 0.035;\n        vec3 col = mix(vec3(0.05,0.2,0.35),vec3(1.0),step(0.4,length(50.0*p.yz)));\n        vec2 c = vec2(0.0,0.007);\n        col = mix(vec3(1.0,1.0,0.0),col,            \n            step(0.4,max(length(50.0*(p.yz-c)),length(50.0*(p.yz+c)))));\n        return col;\n    }\n    p.y -= -0.01;    \n    p.xy *= rotate(0.1*sin(iTime)+0.3);\n    if (mapBottomFang(p)<e) return vec3(0.8);\n\n    return vec3(0.15,0.3,0.25);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.001;\n    return normalize(\n        e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n        e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p2 = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.8,0.8,0.9)*(1.0-0.7*p2.y*p2.y);\n    vec3 rd = normalize(vec3(p2,2.0));    \n    vec3 ro = vec3(0.0,0.8,2.5);  \n    ro.xz *= rotate(PI*0.77777*floor(iTime/60.0));\n    vec3 ta = vec3(0.0,0.2,0.0);\n    ro += 0.03*sin(2.0*iTime*vec3(1.1,1.2,1.3));\n\tta += 0.03*sin(2.0*iTime*vec3(1.7,1.5,1.6));\n\n#if ZOOM\n\t#if 1\n    \t// face\n    \tro = vec3(0.0,1.8,0.7);\n    \tro.xz *= rotate(1.2*sin(iTime*0.3));\n    \tta = vec3(bodyCurve(HEAD),1.5).xzy;\n\t#else\n    \t// hand\n    \tro = vec3(-1.2,1.3,-0.5);\n    \tta = vec3(-0.5,1.0,-1.0);\n\t#endif\n#endif\n    \n    rd = lookat(ro,ta)*rd;\n    float maxd = 10.0;\n    float t = 0.0,d;\n    for(int i=0;i<100;i++)\n    {\n        t += d = map(ro+rd*t);\n        if(d<0.001||t>maxd) break;\n    }\n    if(t<maxd)\n    {\n        vec3 p = ro+t*rd;\n        vec3 nor = calcNormal(p);\n\t\tcol = doColor(p);\n        vec3 li = normalize(vec3(2.0,3.0,3.0));\n        float dif = clamp(dot(nor,li),0.0,1.0);\n        float amb = max(0.5+0.5*nor.y,0.0);\n        float spc = pow(clamp(dot(reflect(rd, nor),li),0.0,1.0),10.0);\n        col *= clamp(0.0,1.0,max(dif,0.3)*amb+spc);\n        col = mix(vec3(0.6,0.6,0.7),col,gaussian(t*0.15)*min(p.y+0.25,1.0));\n\t\tcol = pow(col,vec3(0.7));\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 180, 180, 238], [240, 240, 282, 282, 423], [425, 425, 465, 465, 506], [508, 508, 530, 530, 561], [563, 563, 602, 602, 653], [655, 655, 703, 703, 788], [794, 794, 829, 829, 937], [939, 939, 974, 974, 1158], [1165, 1165, 1199, 1199, 1271], [1277, 1277, 1305, 1305, 1329], [1335, 1335, 1373, 1373, 1429], [1431, 1431, 1480, 1480, 1576], [1578, 1578, 1604, 1604, 1786], [1788, 1788, 1816, 1816, 1951], [1957, 1957, 1986, 1986, 2076], [2078, 2078, 2107, 2107, 2177], [2179, 2179, 2218, 2218, 2676], [2678, 2678, 2722, 2722, 3330], [3332, 3332, 3377, 3377, 3531], [3533, 3533, 3578, 3578, 4015], [4017, 4017, 4063, 4063, 4309], [4311, 4311, 4351, 4351, 4448], [4450, 4450, 4490, 4490, 4828], [4830, 4830, 4871, 4871, 5097], [5103, 5103, 5143, 5143, 5476], [5478, 5478, 5518, 5518, 5827], [5829, 5829, 5855, 5855, 6567], [6569, 6569, 6595, 6595, 7810], [7812, 7812, 7853, 7853, 8037], [8039, 8039, 8080, 8080, 8265], [8271, 8271, 8312, 8312, 8715], [8717, 8717, 8771, 8771, 9029], [9031, 9031, 9084, 9084, 9173], [9179, 9179, 9205, 9205, 10160], [10162, 10162, 10190, 10190, 10377], [10379, 10379, 10407, 10407, 10570], [10572, 10572, 10598, 10598, 11704], [11706, 11706, 11728, 11728, 11786], [11788, 11788, 11813, 11813, 13724], [13726, 13726, 13756, 13756, 13919], [13921, 13921, 13976, 13976, 15275]], "test": "untested"}
{"id": "MsVGRt", "name": "Wave Flames", "author": "gnalvesteffer", "description": "Cool.", "tags": ["wave", "sin", "bloom", "flames"], "likes": 3, "viewed": 589, "published": "Public API", "date": "1455950892", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float drawScale = iResolution.x / 50.0;\n    float speed = iTime * 5.0;\n\tfloat x = fragCoord.x;    \n    float y = sin(x / drawScale + speed) * ((fragCoord.x / 5.0) + 100.0 * sin(fragCoord.y + x - speed));    \n    fragColor = vec4(\n        x / distance(vec2(fragCoord.x, fragCoord.y), vec2(x, y)) / iResolution.x * 20.0, //R\n        0.02, //G\n        0.3 * (y / iResolution.y), //B\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 457]], "test": "untested"}
{"id": "MsVGzy", "name": "First by BalintYYY", "author": "BalintYYY", "description": "My first shader, variation of a tutorial.<br/>", "tags": ["raytracing", "sphere", "instance"], "likes": 2, "viewed": 191, "published": "Public", "date": "1455230125", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//My first shader, variation of a tutorial.\n\n/*OLD CODE-------------------------------------------------------------------------------------------\n\n//Function of shape **************************************************************************\nfloat map (vec3 p) \n{\n    vec3 q = fract(p) * 2.0 - 1.0;   //instancing\n\treturn length(q) - 0.25;    //gÃ¶mb\n}\n\n//Function of ray********************************************************************************\nfloat trace (vec3 o, vec3 r)   //raytrace , hely, sugarirany\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 32; i++) //ray\n    {\n    \tvec3 p = o + r*t;\n        float d = map(p);    //trace az alakzatban\n        t += (d *  0.5 * sin(iTime * 0.5))- 0.1; //mindig a felevel lep\n       \n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) //******************************************\n{\n\n//Setup of pixels ***********************************************   \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0-1.0;\n    uv.x*= iResolution.x / iResolution.y;\n    \n//Set up of rays (camera movement)******************************************************\n    \n    vec3 r = normalize(vec3(uv, 1.0));   //ray-t levetiti az image planere    a szaam az a field of view   \n    vec3 o = vec3(0.0, 0.0, iTime);  //itt vagyunk a tÃ©rben\n    float forgo = iTime * 0.5;\n    r.xz *= mat2(cos(forgo), -sin(forgo), sin(forgo), cos(forgo));   //mat2 : y tengely mentÃ©n forgato matrix\n    r.xy *= mat2(cos(forgo), -sin(forgo), sin(forgo), cos(forgo));\n    r.yz *= mat2(cos(forgo), -sin(forgo), sin(forgo), cos(forgo));  \n    float t = trace(o, r);\n    \n//Pixelcolor*****************************************************************************************\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = vec3(fog);\n    \n    \n\tfragColor = vec4(fc,1.0);\n} \n*/\n\n\n//NEW CODE\n\n//Function of shape **************************************************************************\nfloat map (vec3 p) \n{\n    vec3 q = fract(p) * 2.0 - 1.0;   //instancing\n\treturn length(q) - 0.25;    //gÃ¶mb\n}\n\n//Function of ray********************************************************************************\nfloat trace (vec3 o, vec3 r)   //raytrace , hely, sugarirany\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 32; i++) //ray\n    {\n    \tvec3 p = o + r*t;\n        float d = map(p);    //trace az alakzatban\n        t += (d *  0.5 * sin(iTime * 0.5))- 0.1; //mindig a felevel lep\n       \n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) //******************************************\n{\n\n//Setup of pixels ***********************************************   \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0-1.0;\n    uv.x*= iResolution.x / iResolution.y;\n    \n//Set up of rays (camera movement)******************************************************\n    \n    vec3 r = normalize(vec3(uv, 1.0));   //ray-t levetiti az image planere    a szaam az a field of view   \n    vec3 o = vec3(0.0, 0.0, iTime);  //itt vagyunk a tÃ©rben\n    mat2 rot = mat2(cos(iTime * 0.5), -sin(iTime * 0.5), sin(iTime * 0.5), cos(iTime * 0.5));\n    r.xz *= rot;  \n    r.xy *= rot;\n    r.yz *= rot;  \n    float t = trace(o, r);\n\tfragColor = vec4(vec3(1.0 / (1.0 + t * t  * 0.1)),1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1853, 1948, 1969, 1969, 2060], [2062, 2160, 2222, 2222, 2459], [2461, 2461, 2563, 2633, 3253]], "test": "untested"}
{"id": "Msy3D3", "name": "Morphball", "author": "piratehurrdurr", "description": "Testing some shapes and distortion here. Thanks to iq for the smin, and raymarching code. Enjoy this weird blob!\nPS: As an optimization I raytrace a sphere around the actual blob. I can improve this by actually starting the raymarch from the sphere thoug", "tags": ["raymarching", "test", "displacement", "shapes"], "likes": 7, "viewed": 190, "published": "Public", "date": "1456696181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IT 4096*1\n#define MAX 64.0\n#define EP 1e-3\n#define EPN 1e-2\n#define CS .xzy\n\n#define E 2.71828182845904523536028747135266249775724709369995\n\n//Uncomment to only see AO\n//#define AMBONLY\n\n#define aoc 12\n#define aos 0.05\n#define aoa 5.0\n\nvec3 aoOffsets[aoc];\n\nvec3 amb(vec3 dir) {\n    \n    vec3 skyBase = vec3(0.6, 0.8, 0.6)*(1.0+0.6*dot(dir, vec3(0.0,0.0,-1.0)));\n    float sunStr = pow(max(1.05* dot(dir, normalize(vec3(1.0,1.0,1.0))),0.0),6.0);\n\tvec3 skySun = vec3(0.5,0.5,0.2)*sunStr;\n    return skySun+skyBase;\n    \n    /*\n    vec3 skyBase = vec3(0.6, 0.8, 0.9)*(1.0+0.6*dot(dir, vec3(0.0,0.0,-1.0)));\n    float sunStr = pow(max(1.05* dot(dir, normalize(vec3(1.0,1.0,1.0))),0.0),6.0);\n\tvec3 skySun = vec3(0.5,0.5,0.2)*sunStr;\n    return skySun+skyBase;\n\t*/\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nbool rtSphere(vec3 pos, vec3 n, float rad) {\n    \n    float tca = dot(pos, -n);\n    if (tca<EP) {\n        return false;\n    }\n    float d2 = dot(pos,pos)-tca*tca;\n    float rad2 = rad*rad;\n    if (d2>rad2) {\n        return false;\n    }\n    float thc = sqrt(rad2-d2);\n    float t0 = tca-thc;\n    float t1 = tca+thc;\n    if (t0>t1) {\n        float t2 = t1;\n        t1 = t0;\n        t0 = t2;\n    }\n    if (t0<0.0) {\n        t0 = t1;\n        if (t0<0.0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nfloat displace(vec3 pos){\n    pos.z+=iTime/24.0;\n        return sin(pos.x*16.0+pos.y*8.0)*sin(pos.y*16.0+pos.z*8.0)*sin(pos.z*16.0+pos.x*8.0)/8.0;\n}\n\nfloat dist(vec3 pos) {\n    \n    float main = displace(pos)/5.0+\n        smin(\n        max(sphere(pos,0.4)+abs(displace(pos))/2.0+displace(pos.zyx)/2.0, displace(pos.yzx)*0.2+box(pos-vec3(-0.2),vec3(0.3))),\n            max(displace(pos)/5.0+sphere(pos,0.25+sin(iTime/5.6)*0.1), displace(-pos)+ box(pos+vec3(-0.2), vec3(0.3))),\n            12.0+sin(iTime)/6.0\n            );\n    \n    \n    return main;\n        \n    \n        /*\n    return \n        smin(\n        max(sphere(pos, 0.5)+abs(displace(pos)),\n               box(pos-vec3(-0.2),vec3(0.3))\n               ),16.0\n        //max(sphere(pos,0.35),48.0,box(pos+vec3(0.2),vec3(0.1))))\n        //);\n          */\n    //return max(box(pos,vec3(0.3)),-sphere(pos/vec3(1.0,2.0,1.0)+vec3(0.2),0.2));\n    \n}\n\n\nfloat AO(vec3 pos) {\n    float hit;\n    \n    \n    for (int i=0; i<aoc; i++) {\n        float d = dist(pos+aoOffsets[i]);\n        if (d>0.0) {\n            hit+=d;\n        }\n    }\n    \n    //float total = 3.0*3.0*3.0;\n    //for (int i=-1; i<=1; i++) {\n    //    for (int j=-1; j<=1; j++) {\n    //        for (int k=-1; k<=1; k++) {\n    //            float d= dist(pos+vec3(i,j,k)*0.1);\n    //            if (d>=0.0) {\n    //                hit+=d;\n    //            }\n    //                 }\n    //    }\n    //}\n    float total = float(aoc);\n    return max(min(hit/aos/total*aoa,1.0),0.0);\n}\n\nvec3 scan(vec3 pos, vec3 dir) {\n    \n    if (!rtSphere(pos, dir, 0.5))\n    {\n        return amb(dir);\n    }\n    \n    float totalDistance=0.0;\n    for (int i=0; i<IT; i++) {\n        float rayDist = dist(pos);\n        totalDistance+=rayDist;\n        if (abs(rayDist)<=EP) {\n            \n           #ifdef AMBONLY\n            return vec3(AO(pos));\n            #endif\n            \n            \n            \n            vec2 eps = vec2(0.0, EPN);\n\t\t\tvec3 normal = normalize(vec3(\n    \t\tdist(pos + eps.yxx) - dist(pos - eps.yxx),\n    \t\tdist(pos + eps.xyx) - dist(pos - eps.xyx),\n    \t\tdist(pos + eps.xxy) - dist(pos - eps.xxy)));\n            \n            \n            \n            vec3 sunColor = vec3(1.0,0.8,0.4);\n            vec3 sunVector = normalize(vec3(1.0,1.0,1.0));\n            float sunAtten = max(0.0, dot(sunVector,normal));\n            \n            vec3 ambientColor = vec3(0.6,0.8,0.6);\n            float ambientAtten = AO(pos);\n            \n            vec3 reflDir = reflect(dir, normal);\n            sunAtten+=pow(max(dot(reflDir, sunVector),0.0),16.0)*ambientAtten;\n            \n            float fresnel = pow(1.0- abs(dot(dir,normal)),2.0);\n            \n            //return vec3(ambientAtten);\n            \n            vec4 fog = vec4(0.6, 0.8, 0.6,1.0-1.0/pow(E,totalDistance*0.05));\n            \n            vec3 light = mix(sunColor*sunAtten + ambientColor*ambientAtten, amb(reflDir)*ambientAtten, fresnel);\n            vec3 world = vec3(0.9,0.3,0.8)*light;\n            return mix(world, fog.rgb,fog.a);//*texture(iChannel2, normal).rgb;\n        }\n        if (totalDistance>=MAX) {\n            return amb( dir);\n        }\n        pos+=dir*(rayDist)*0.25;\n    }\n    \n    \n    return amb(dir);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 uv){\n    uv = (uv-iResolution.xy/2.0)/iResolution.y;\n    float a = iTime*0.125;\n    \n    \n\naoOffsets[0]=vec3(\taos*0.0\t\t\t,aos*-0.525731\t\t,aos*0.850651);\naoOffsets[1]=vec3(\taos*0.850651\t,aos*0.0\t\t\t\t,aos*0.525731);\naoOffsets[2]=vec3(\taos*0.850651\t,aos*0.0\t\t\t\t,aos*-0.525731);\naoOffsets[3]=vec3(\taos*-0.850651\t,aos*0.0\t\t\t\t,aos*-0.525731);\naoOffsets[4]=vec3(\taos*-0.850651\t,aos*0.0\t\t\t\t,aos*0.525731);\naoOffsets[5]=vec3(\taos*-0.525731\t,aos*0.850651\t\t,aos*0.0);\naoOffsets[6]=vec3(\taos*0.525731\t,aos*0.850651\t\t,aos*0.0);\naoOffsets[7]=vec3(\taos*0.525731\t,aos*-0.850651\t\t,aos*0.0);\naoOffsets[8]=vec3(\taos*-0.525731\t,aos*-0.850651\t\t,aos*0.0);\naoOffsets[9]=vec3(\taos*0.0\t\t\t,aos*-0.525731\t\t,aos*-0.850651);\naoOffsets[10]=vec3(\taos*0.0\t\t\t,aos*0.525731\t\t,aos*-0.850651);\naoOffsets[11]=vec3(\taos*0.0\t\t\t,aos*0.525731\t\t,aos*0.850651);\n\t\n\n    \n    //vec3 pos = vec3(cos(a/4.0+sin(a/2.0)),cos(a*0.2),sin(a*0.31)/4.5+1.0)*3.0;\n    vec3 pos = vec3(cos(iMouse.x/64.0),sin(iMouse.x/64.0),(iMouse.y-0.5)/512.0);\n    vec3 on = vec3(1.0,uv.x,uv.y);\n    vec3 n = normalize(pos);\n\n    //n = normalize(pos + (0.1*vec3(cos(a*2.3),cos(a*2.61),cos(a*1.62))));\n\tvec3 crossRight = normalize( cross(n,vec3(0.0,0.0,1.0)));\n\tvec3 crossUp = normalize(cross(n, crossRight));\n\tn = n*0.8 + crossRight*uv.x + crossUp*uv.y;\n    n = -normalize(n);\n    \n    fragColor.rgb = scan(pos,n).rgb;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msy3D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 266, 286, 286, 769], [771, 771, 812, 812, 883], [885, 885, 929, 929, 1397], [1399, 1399, 1437, 1437, 1472], [1474, 1474, 1506, 1506, 1554], [1556, 1556, 1581, 1581, 1704], [1706, 1706, 1728, 1728, 2455], [2458, 2458, 2478, 2478, 3047], [3049, 3049, 3080, 3080, 4760], [4762, 4762, 4808, 4808, 6150]], "test": "untested"}
{"id": "Msy3Rt", "name": "SmoothInternalQuadGradient", "author": "Bers", "description": "A possible implementation of smooth internal gradient, while preserving (g == 0) on boundaries.", "tags": ["distancefield"], "likes": 2, "viewed": 580, "published": "Public API", "date": "1455818233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\nbool isOutside(vec2 uv, vec2 c1, vec2 c2, vec2 c3, vec2 c4)\n{\n    return dot( (c1-c2).yx*vec2(-1,1), uv-c1) < 0.\n        || dot( (c2-c3).yx*vec2(-1,1), uv-c2) < 0.\n    \t|| dot( (c3-c4).yx*vec2(-1,1), uv-c3) < 0.\n    \t|| dot( (c4-c1).yx*vec2(-1,1), uv-c4) < 0.;\n}\n\nfloat smoothInternalQuadGrad(vec2 uv, vec2 c1, vec2 c2, vec2 c3, vec2 c4)\n{\n    float da = distanceToLineSeg(uv, c3, c2);\n    float db = distanceToLineSeg(uv, c2, c1);\n    float dc = distanceToLineSeg(uv, c1, c4);\n    float dd = distanceToLineSeg(uv, c4, c3);\n    \n    //Note : a parameter controls smoothness (and scales value)\n    float a = 0.01;\n    float NORMALIZATION_TERM = log((1.+a)/a);\n    da = log((da+a)/a)/NORMALIZATION_TERM;\n    db = log((db+a)/a)/NORMALIZATION_TERM;\n    dc = log((dc+a)/a)/NORMALIZATION_TERM;\n    dd = log((dd+a)/a)/NORMALIZATION_TERM;\n    return da*db*dc*dd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = iResolution.y/iResolution.x;\n\tvec2 uv = -vec2(0.5,0.3)+2.0*fragCoord.xy / iResolution.xx;\n   \n    vec2 c1 = vec2(1.+sin(iTime*0.120)*0.2,h +cos(iTime*0.143)*0.2);\n    vec2 c2 = vec2(1.+cos(iTime*0.102)*0.2,0.+cos(iTime*0.107)*0.2);\n    vec2 c3 = vec2(0.+sin(iTime*0.096)*0.2,0.+sin(iTime*0.112)*0.2);\n    vec2 c4 = vec2(0.+sin(iTime*0.134)*0.2,h +cos(iTime*0.123)*0.2);\n    float internalGradient = smoothInternalQuadGrad(uv, c1,c2,c3,c4);\n    \n    if(isOutside(uv,c1,c2,c3,c4))\n    {\n        fragColor = vec4(0.1,0.3,0.7,0);\n        return;\n    }\n        \n    float stripeHz = 20.0;//BW Stripe frequency\n    float stripeTh = 0.25; //Switchover value, in the [0.-0.5] range. (0.25 = right in the middle)\n    float aa = 0.001; //aa = transition width (pixel \"antialiazing\" or smoothness)\n    float stripeIntensity = smoothstep(stripeTh-aa*stripeHz,stripeTh+aa*stripeHz,abs(fract(iTime+internalGradient*stripeHz)-0.5));\n    \n    fragColor = vec4((uv.x>0.5+sin(iTime))?stripeIntensity:internalGradient*3.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msy3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 118, 167, 289, 409], [411, 411, 472, 472, 673], [675, 675, 750, 750, 1267], [1269, 1269, 1326, 1326, 2347]], "test": "untested"}
{"id": "Mt23Rc", "name": "ray tracing #1", "author": "davidp", "description": "Trace pixels into rays that hit various shapes", "tags": ["rays"], "likes": 1, "viewed": 128, "published": "Public", "date": "1455484838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// We want to translate a screen position into a box rendering.\n//\n// To do that, we need to cast a ray from each fragment location (uv).\n// We \"project\" the ray into a function that returns a pixel color.\n//\n// We're saying \"at this position on the screen, the scene looks like this\" and\n// we return the fragment at that position.\n//\n// Movement can be simple -- we apply some offset to the ray position and convert into\n// a vec3 ray.  As long as our rendering function takes a vec3 as the ray, then we should be good!\n//\n// Two strategies:\n// - Use traditional ray tracing where we cast a ray and see if it hits geometry.\n// - Use ray marching, same concept except we step each ray\n \nconst float pi = 3.14159265359;\n \nvec3 offy(float i) {\n    float f = sin(iTime) * .5 + .5;\n    return vec3(0);//texture(iChannel0, vec2(i * 0.07 + f, i * 0.09 +f)).xy, 0.);\n}\n \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n   \nstruct AABB {\n    vec3 lower;\n    vec3 upper;\n};\n \n \nmat3 rotateX(float th) {\n    float c = cos(th);\n    float s = sin(th);\n    return mat3(1, 0, 0,\n                0, c, -s,\n                0, s, c);\n}\n \n \nmat3 rotateY(float th) {\n    float c = cos(th);\n    float s = sin(th);\n    return mat3(c, 0, s,\n                0, 1, 0,\n                -s,0, c);\n}\n \n// via http://prideout.net/blog/?p=64\nbool IntersectBox(Ray r, AABB box, out float t0, out float t1)\n{\n    vec3 invR = 1.0 / r.direction;\n    vec3 tbot = invR * (box.lower - r.origin);\n    vec3 ttop = invR * (box.upper - r.origin);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    t1 = min(t.x, t.y);\n    return t0 <= t1;\n}\n \n \nbool pointInsideBox(vec3 point, AABB box) {    \n    vec3 lower = box.lower;\n    vec3 upper = box.upper;\n \n    return (lower.x <= point.x && upper.x >= point.x &&\n            lower.y <= point.y && upper.y >= point.y &&\n            lower.z <= point.z && upper.z >= point.z);\n}\n \n \nfloat rayDistance;\nbool shittyRayMarch(Ray ray, AABB box) {\n    const float steps = 40.;\n    const float fraction = 0.5 / steps;\n   \n    vec3 delta = vec3(0.);\n    ///for (float i = 0.; i < steps; i += 1.) {\n        //delta = delta + (fraction * ray.direction);\n        //if (pointInsideBox(ray.origin + delta, box)) {\n            float t0, t1;\n            if (IntersectBox(ray, box, t0, t1)) {\n                rayDistance = (1. - t0); //distance(ray, delta));\n                return true;\n            }\n        //}\n    //}\n    return false;\n}\n \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    float st = 0.15 * pi * sin(iTime);\n   \n    mat3 rot = rotateY(st) * rotateX(st);\n    vec3 origin = rot * vec3(uv, 0.0);\n    vec2 uvp = (uv * 2. - 1.) * .4;\n    vec3 direction = normalize(rot * vec3(uvp.x, uvp.y, 1.0));\n   \n    Ray ray = Ray (origin, direction);\n   \n    AABB box1 = AABB( vec3(0.25, 0.0, 0.15), vec3(0.55, 0.55, 2.55));\n    AABB box2 = AABB( vec3(0.65, 0.65, 0.55), vec3(0.85, 0.85, 0.85));\n    AABB box3 = AABB( vec3(0.0, 0.65, 0.95), vec3(0.85, 0.85, 0.85));\n   \n    if (shittyRayMarch(ray, box1)) {\n        fragColor = vec4(rayDistance, rayDistance, rayDistance, 1.);\n        return;\n    } else if (shittyRayMarch(ray, box2)) {\n        fragColor = vec4(rayDistance, rayDistance, rayDistance, 1.);\n        return;\n    } else if (shittyRayMarch(ray, box3)) {\n        fragColor = vec4(rayDistance, rayDistance, rayDistance, 1.);\n        return;\n    }\n    fragColor = vec4(0);\n    // uv,0.5+0.5*sin(iTime)\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt23Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 722, 742, 742, 862], [975, 975, 999, 999, 1124], [1129, 1129, 1153, 1153, 1277], [1280, 1318, 1382, 1382, 1715], [1720, 1720, 1763, 1763, 1994], [2018, 2018, 2058, 2058, 2542], [2547, 2547, 2604, 2604, 3584]], "test": "untested"}
{"id": "XdGGDK", "name": "terrain with acid river", "author": "reaper", "description": "My first shader, it shows terrain flight over mountains. Uses ray tracing and perlin noise generated terrain functions from other shaders.", "tags": ["terrain", "perlin"], "likes": 8, "viewed": 239, "published": "Public", "date": "1456315432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simple 2d noise algorithm contributed by Trisomie21 (Thanks!)\nfloat snoise( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat terrain( vec2 p, int octaves ) {\t\n\tfloat h = 0.0; // height\n\tfloat w = 0.5; // octave weight\n\tfloat m = 0.4; // octave multiplier\n\tfor (int i=0; i<20; i++) {\n\t\tif (i<octaves) {\n\t\t\th += w * snoise((p * m));\n\t\t}\n\t\telse break;\n\t\tw *= 0.5;\n\t\tm *= 2.0;\n\t}\n\treturn h;\n}\n\nconst float dMax = 28.0;\n\nvec2 map( vec3 p, int octaves ) {\n\t\n\tfloat dMin = dMax; // nearest intersection\n\tfloat d; // depth\n\tfloat mID = -1.0; // material ID\n\t\n\t// mountains\n\tfloat h = terrain(p.xz, octaves);\n\th += smoothstep(-0.6, 1.2, h); // exaggerate the higher terrain\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n    \n    // water\n\tif (h<0.0) {\n        return vec2(p.y - 0.0, 1.0);\n    }\n\treturn vec2(dMin, mID);\n}\n\nvec2 castRay( vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001; // precision\n\tfloat t = 0.0; // distance\n\tfloat h = p * 2.0; // step\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)>p || t<dMax ) {\n\t\t\tt += h; // next step\n\t\t\tvec2 res = map(ro + rd*t, octaves); // next intersection\n\t\t\th = res.x; // distance\n\t\t\tm = res.y; // material\n\t\t} \n\t\telse break;\n\t}\n\tif (t>dMax) m = -1.0; // if no intersection, material ID is -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal( vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nvec3 render( vec3 ro, vec3 rd, vec2 uv) {\n\tconst int geoLOD = 4;\n\t\n\tvec3 color = vec3(0.3,0.4,0.6); // base color is sky color\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize( vec3(0.5, 0.5, 0.0) ); // light position\n\tvec3 lCol = vec3(1.0, 0.9, 0.7); // yellowish light\n\t\n\tvec3 pos = ro + rd*res.x; // world position\n\t\n\t// mat -1 = background/sky\n\tif (res.y < -0.5) {\n\t\tfloat sun = clamp(dot(rd,lPos),0.0,1.0); // sun orb\n\t\tcolor += 0.8 * lCol * sun*sun;\n\t\t// cheap clouds (hopefully, no one will notice)\n\t\tfloat c = snoise(pos.xz * 0.12); \n\t\tcolor = mix( color, vec3(1.0, 1.0, 0.8), smoothstep(0.0, 1.5, c) );\n\t\treturn color;\n\t}\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/dMax)); // normal LOD decreases with distance\n\tvec3 nor = calcNormal(pos, norLOD); // terrain normals\n\t\n\t// mat 0 = terrain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), nor.y);//step(0.9, nor.y) );\n\t}\n\tif (res.y>0.5) {\n        float mm = terrain(uv, 3);\n        color = vec3(uv, mm);\n    }\n\n    // fog\n\tfloat fog = exp(-0.005 * res.x*res.x); // exponentioal fog equation\n\tcolor = mix(vec3(0.3,0.3,0.35), color, fog); // add fog in distance\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat a = terrain(uv + vec2(0.5+0.5*sin(iTime), 0.2 * iTime), 20);\n\n    float x = 0.0 + (0.5*iTime);\n\tfloat y = 2.0;\n\tfloat z = 0.0 + sin(0.1*iTime);\n\tvec3 cPos = vec3(x, y, z); // position\n\n\tconst vec3 cUp = vec3(0., 1., 0.); // up \n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.7, 0.0); // lookAt\n\t\n\t// camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n\t\n\t// render\n\tvec3 color = render(cPos, rd, uv);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 89, 89, 323], [325, 325, 363, 363, 594], [622, 622, 655, 655, 1030], [1032, 1032, 1078, 1078, 1492], [1494, 1494, 1533, 1533, 1788], [1790, 1790, 1831, 1831, 2985], [2987, 2987, 3044, 3044, 3657]], "test": "untested"}
{"id": "XdGGRt", "name": "Stereo Riemann Disco Sphere", "author": "samuelotherion", "description": "stereoscopic view of the Riemann sphere", "tags": ["3d", "fractal", "light", "sphere", "stereoscopic", "riemann"], "likes": 2, "viewed": 198, "published": "Public", "date": "1455728260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n#define RES   \tiResolution\n#define ASP \tRES.x/RES.y\n#define M\t\t(vec2(10.5,1./2.5)+vec2(20,7) * (iMouse.xy/RES.xy-.5))\n#define ID3   \tmat3(1,0,0,0,1,0,0,0,1)\n#define Rxy\t\t(mat3(1,0,0,0,cos(M.y),sin(M.y),0,-sin(M.y),cos(M.y))*mat3(-sin(.1 * t),0,cos(.1 * t),0,1,0,cos(.1 * t),0,sin(.1 * t)))\n#define t     \tiTime\n#define NP\t\t.1\n#define FP\t\t100.\n#define NOO     0\n#define PLN     1\n#define SPH     2\n#define L1P\t\tvec3( 5.3 * sin( 3.2 * sin( .64 * t ) ),  1.1, 5.3 * cos( 3.2 * sin( .63 * t ) ) )\n#define L2P\t\tvec3( 0.,  -19.1 + 18. * cos( .2 * sin( .8 * t ) ), 18. * sin( .2 * sin( .8 * t ) ) )\n#define N       vec3(0,1,0)\n#define MIT\t\t256 //max iterations for fractal, use smaller numbers if speed drops down! \n#define EYD\t\t.4\nstruct Hit { float d; vec3 p, n; int i; } hit;\nvec3   eye, ray;\nvec4   col;\nvoid \n    isPln( ) {\n        \n        vec3\n            n = sign( eye.y ) * N;\n        \n        float\n            l = dot( n, eye ) / dot( n, ray );\n\n        if( hit.d < l || l < NP ) return;\n                \n        hit.d = l;\n        hit.p = eye - l * ray;\n\t\thit.n = n;\n\t\thit.i = PLN;\n}\nvoid\n    isSph( ) {\n\n        float\n            ab = dot( ray, eye ),\n            bb = dot( eye, eye ),\n            ds = ( 1. - bb ) + ab * ab;\n\n        if( 0. <= ds ) {\n\n            ds = sqrt( +ds );\n\n            float\n                l = ab - ds;\n           \n            if( l <= NP ) \n             \n\t\t\t\tl = ab + ds;\n            \n            if( hit.d < l || l <= NP ) return;\n            \n            \n            hit.d = l;\n            hit.p = eye - l * ray;\n            hit.n = normalize( hit.p );\n            hit.i = SPH;\n        }\n    }\nfloat\n    mb( vec2 iC ) {\n        \n        vec2\n            c = iC;\n\n        for( int i = 0; i < MIT; ++i ) {\n         \n            if( 8. < dot( c, c ) ) return 1. - mod( float( i ), 16. ) / 16.;\n            \n            c = vec2( c.x * c.x - c.y * c.y, 2. * c.x * c.y ) - iC;\n        }        \n\n        return 0.;\n    }\nvec3\n    getPix( vec2 iXy ) {\n    \n        vec2\n            d = iXy - 1.5 * vec2( cos( .9 * t ), sin( t ) );\n        \n        float\n            f = dot( d, d );\n        \n        vec3\n            c = vec3( 0. );\n        \n        if( f < .1 ) \n            \n            c += sqrt( 1. - 10. * f ) *  ( .5 + 2. * vec3( iXy.y, iXy.x, .00 ) );\n        \n        d = iXy - 1.5 * vec2( cos( .69 * t ), sin( t ) );\n        \n        if( all( lessThan( abs( d - .5 ), vec2( .5 ) ) ) ) \n            \n            c += ( .5 + 2. * vec3( iXy.y, iXy.x, .00 ) );\n        \n        return c + texture( iChannel0, mod( iXy + .5, vec2( 1. ) ) ).rgb + smoothstep( 0., mb( iXy * ( 1. / ( 10.01 + 10. * sin( .2 * t ) ) ) - vec2( -2, 0. ) ), .2 + .1 * sin( .76 * t ) ) * vec3( .3, .3, .2 );;\n    }\n\nvoid\n   \n    light( ) {\n\n        vec3\n            d = L1P - hit.p;\n        \n        float\n            f = dot( d, d ),\n        \tb = pow( clamp( dot( d, hit.n ) / f, 0., 1. ), 1. );\n        \n        d = L2P - hit.p;\n        f = dot( d, d );\n            b += pow( clamp( dot( d, hit.n ) / f, 0., 1. ), 11. );\n        \n        b = .252422 + .52441 * b;\n        \n        col = \n            hit.i == NOO\n            \t? vec4( b * vec3( .71231, .8521, .913331 ), 1. )\n            \t: hit.i == SPH \n                    ? vec4( b * getPix( hit.p.xz  / ( 1. - hit.p.y ) ), 1. )\n                    : vec4( b * ( vec3( .3, .4, .5 ) + getPix( hit.p.xz ) ), sin( t ) );\n    }\nvoid\n    mainImage( out vec4 oCol, in vec2 iXy ) {\n       \n\t\teye = vec3( iXy.x < .5 * RES.x ? -EYD : EYD, 0., 2. );\n        ray = normalize( eye - vec3( ( 2. * iXy / RES.xy - 1. ) * vec2( ASP, 1. ), 0. ) );\n        eye.z += .5 + M.x;\n        eye = eye * Rxy;\n        ray = ray * Rxy;\n\n        hit = Hit( FP, eye - FP * ray, ray, NOO );\n        \n        isSph( );\n        isPln( );\n        \n        light( );\n        \n        oCol = col;\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[824, 824, 844, 844, 1111], [1112, 1112, 1131, 1131, 1654], [1655, 1655, 1680, 1680, 1976], [1977, 1977, 2006, 2006, 2747], [2749, 2749, 2772, 2772, 3410], [3411, 3411, 3461, 3461, 3849]], "test": "untested"}
{"id": "XdGGWW", "name": "Plot math", "author": "anastadunbar", "description": "Plot test.", "tags": ["2d", "math", "graph", "function", "plot", "grapher", "plotter", "plotting"], "likes": 7, "viewed": 420, "published": "Public", "date": "1454375291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\nfloat function(float x) {\n    return sin(x*x*x*20.)+(sin(time+x)*.2);\n}\nfloat graph_f(vec2 uv, vec2 resolution, float scale) {\n    //There seems to be a better method.\n    float graph = step(uv.y,function(uv.x))-step(uv.y+(scale/resolution.y),function(uv.x));\n    graph += step(uv.y,function(uv.x+(scale/resolution.y)))-step(uv.y+(scale/resolution.y),function(uv.x));\n    graph += step(uv.y,function(uv.x-(scale/resolution.y)))-step(uv.y+(scale/resolution.y),function(uv.x));\n    return clamp(graph,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy / iResolution.xy;\n    float scale = sin(iTime)+2.;\n\tvec2 uv = ((fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y)*scale;\n\tfloat graph = graph_f(uv,iResolution.xy,scale);\n    \n    //Stolen anti-aliasing script.\n    float ret = 0.;\n    for (int i = 0; i < 16; i++) { \n    vec2 q = vec2(floor(mod(float(i), 16.0)) / 4.0, floor(float(i)) / 16.0);\n    vec2 uv1 = uv+(q/iResolution.xy);\n    ret += graph_f(uv1,iResolution.xy,scale);\n    }\n    graph = ret/16.;\n    \n    //Draw center lines.\n    float center = float(floor(fragCoord.x) == floor(iResolution.x/2.) || floor(fragCoord.y) == floor(iResolution.y/2.));\n    //Grid.\n    float grid = float(fract(uv.x-(scale/iResolution.y)) > fract(uv.x) || fract(uv.y-(scale/iResolution.y)) > fract(uv.y));\n    //Extra grid.\n    for (float h = 1.; h < 4.; h++) {\n\t\tfloat i = pow(2.,h);\n        grid += (1./i)*float(fract((uv.x*i)-((scale*i)/iResolution.y)) > fract((uv.x*i)) || fract((uv.y*i)-((scale*i)/iResolution.y)) > fract((uv.y*i)));\n    }\n\tfragColor = vec4(vec3(graph,0.,0.)+(center*.5)+(grid*.3),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 44, 44, 90], [91, 91, 145, 186, 527], [529, 529, 586, 586, 1662]], "test": "untested"}
{"id": "XdK3DD", "name": "Hello-2 Color Fade HDD", "author": "Hanley", "description": "Simple Color Fade", "tags": ["colour", "hello"], "likes": 1, "viewed": 135, "published": "Public", "date": "1454540644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 customColor() {\n\treturn vec3(0.8,0.5,0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tfloat u_time = iTime;\n\n\t// Core Code\n\tfloat r = abs(sin(u_time));\n\tfloat g = abs(sin(u_time*0.3));\n\tfloat b = abs(sin(u_time*0.7));\n\tfragColor = vec4(r,g,b, 1.0);\n\n\t// ShaderToy Specific Output Settings\n\t//fragColor = gl_FragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdK3DD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 50], [52, 52, 109, 109, 346]], "test": "untested"}
{"id": "XdK3Ww", "name": "Quadratics", "author": "ur_faec", "description": "Phase diagrams of quadratic polynomials z^2 + az + b near the origin. Clicking the mouse adjusts a and b (a is horizontal axis, b is vertical).", "tags": ["2d", "algebra", "complexfunctions"], "likes": 4, "viewed": 125, "published": "Public", "date": "1454800134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592653589793238462643383;\n\nconst vec2 origin = vec2(0.0, 0.0);\nconst float ViewRadius = 2.0;\n\nconst float GridCoefficientLight = 0.6;\nconst float GridCoefficientDark = 0.6;\n\n\nvec3 hueForPhase(float phase) {\n    vec3 hue = vec3(\n        sin(phase + 0.5 * iTime) + 1.0,\n        sin(2.0*(phase + 0.67*PI) + 0.3 * iTime) + 1.0,\n        sin(2.0*phase + 0.7 * iTime) + 1.0);\n    \n    return hue / sqrt(dot(hue, hue));\n}\n\n// Should be ~1 at the origin, ~0 at any significant distance from it\nfloat decay(float x) {\n\tif (abs(x) >= 0.1) {\n\t\treturn 0.0;\n\t}\n\treturn 1.0 - abs(x*10.0);//pow(abs(x*10.0), 1)\n}\n\n// Offset of x from the integer grid, ignoring integer multiples of n.\nfloat offsetFromGridExcept(int n, float x) {\n\tfloat below = floor(x);\n    float above = ceil(x);\n    if (abs(mod(below, float(n))) < 0.5) {\n        below -= 1.0;\n    }\n    if (abs(mod(above, float(n))) < 0.5) {\n        above += 1.0;\n    }\n\treturn min(x-below, above-x);\n}\n\nfloat offsetFromGrid(float x) {\n\treturn min(x-floor(x), ceil(x)-x);\n}\n\nfloat gridFn(float x) {\n    return offsetFromGrid(x);\n}\n\nvec4 eval(vec2 z, vec2 param) {\n    float a = param.x;\n    float b = param.y;\n    vec2 z2 = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n    return vec4(z2 + a*z + b*vec2(1.0,0.0),\n                2.0*z + a*vec2(1.0, 0.0));\n}\n\n// Scaling weirdness: \"hue\" is expected to be an angle measured in radians,\n// sv are [0, 1].\nvec3 HSVtoRGB(vec3 hsv) {\n    vec3 hue = hueForPhase(hsv.x);\n    return (hsv.y * hue + (1.0 - hsv.y)) * hsv.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 uv = 2.0 * ViewRadius * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 param = 2.0 * ViewRadius * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    if (iMouse.xy == vec2(0.0, 0.0)) {\n        param = vec2(0.0, 0.0);\n    }\n\n    \n    vec4 value = eval(uv, param);\t// xy = function, zw = derivative\n    \n    float vabs = sqrt(dot(value.xy, value.xy));\n    float dvabs = sqrt(dot(value.zw, value.zw));\n    float phase = atan(value.y, value.x);// / (2.0 * PI) + 0.5;\n    float dphase = dvabs / (vabs+0.01);\n    \n    float phaseOffset = offsetFromGridExcept(4, 16.0*phase / (2.0 * PI));\n    float phaseFactor = 1.0 - decay(phaseOffset * 5.0 / (ViewRadius * (dphase + 0.01)));\n    \n    float absFactor = 1.0;\n    if (vabs > 0.5) {\n        float absOffset = vabs * GridCoefficientLight;\n        absFactor = 1.0 - decay(gridFn(absOffset) * 12.0 /\n            (GridCoefficientLight * ViewRadius * (dvabs + 0.01)));\n    }\n    \n    float imagOffset = abs(value.y * GridCoefficientDark) + 1.0;\n    float imagFactor = 1.0 - decay(gridFn(imagOffset) * 15.0 /\n                                   (GridCoefficientDark * ViewRadius * (dvabs + 0.01)));\n    float realOffset = abs(value.x * GridCoefficientDark) + 1.0;\n\n    float realFactor = 1.0 - decay(gridFn(realOffset) * 15.0 /\n                                   (GridCoefficientDark * ViewRadius * (dvabs + 0.01)));\n\n    vec3 hsv = vec3(\n        phase,\n        phaseFactor * absFactor,\n        imagFactor * realFactor);\n        \n    fragColor = vec4(HSVtoRGB(hsv), 1.0);\n}\n", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdK3Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 228, 228, 435], [437, 507, 529, 529, 618], [620, 691, 735, 735, 962], [964, 964, 995, 995, 1033], [1035, 1035, 1058, 1058, 1090], [1092, 1092, 1123, 1123, 1318], [1320, 1414, 1439, 1439, 1526], [1528, 1528, 1585, 1659, 3195]], "test": "untested"}
{"id": "XdKGRK", "name": "division", "author": "ypn", "description": "division", "tags": ["division"], "likes": 0, "viewed": 105, "published": "Public", "date": "1455349147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define A 0.005\nfloat f(vec2 u, vec2 a, vec2 b) {\n\treturn smoothstep(-A,A,dot(normalize(u-a),normalize((a-b).yx*vec2(-1,1))));\n}\n\nfloat circle(vec2 u, vec2 p, float r) {\n\treturn 1.-smoothstep(r,r+A,distance(u,p));\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n\tU = (U - R* .5) / R.y;\n    float T0 = iTime * 0.5;\n    float T1 = iTime * 0.123;\n    vec2 p0 = vec2(cos(T0),sin(T0))*0.25, p1 = vec2(cos(T1),sin(T1))*0.25;\n    float v = f(U, p1, p0);\n    float g = max(circle(U,p0,0.01),circle(U,p1,0.01)); \n\tO = vec4(v,g,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 49, 49, 128], [130, 130, 169, 169, 215], [217, 217, 258, 258, 555]], "test": "untested"}
{"id": "XdKGWm", "name": "Dila's Raymarch Tutorial", "author": "Lucanio", "description": "This is dila's tutorial https://www.youtube.com/watch?v=yxNnRSefK94 I added the things he says in the video as comments", "tags": ["procedural", "3d", "raymarching", "tutorial"], "likes": 21, "viewed": 980, "published": "Public", "date": "1454834191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//map function, core of all the ray marching shaders. They return a scalar value, given a 3D point.\nfloat map(vec3 p){\n    //instancing:\n    // you transform the space so it's a repeating coordinate system\n    vec3 q = fract(p) * 2.0 -1.0;\n    \n  \t//sphere map function is the length of the point minus the radius\n    //it's negative on the inside of the sphere and positive on the outside and 0 on the surface.\n    float radius = .25;\n \treturn length(q) - radius;   \n}\n\n//we use a numerical marching algorithim called trace\n//o = origin\n//r = ray to march along\n//t = intersection along the ray\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for (int i =0; i <32; i++){\n        //origin + ray*t = where we are along the ray;\n        // we step along the ray in variable length segments, \n     \tvec3 p = o+r*t;   \n        //until we gradual converge on the intersection and evaluate the map function at that point\n        float d=map(p);\n        //we add that to t\n        // the smaller the 0.5 value, the less accurate the map function is\n        t += d * 0.5;\t\n    }\n     return t;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //transform the cordinates to -1 to 1, instead of 0 to 1\n    uv = uv * 2.0 - 1.0;\n    //correct the aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //r = ray\n    // it needs to be normalized so it doesn't poke through the geometry when it's really close to the camera\n    //the z cordinate is 1.0, that's how you project the 2D coordinate into 3D space, \n    //you just decide the z value, which determines the field of view of the camera\n    // smaller z = higher fov. 1.0 = 90 degrees\n    vec3 r = normalize(vec3(uv,1.0));\n    \n    //rotation around the y axis\n    //you have to look up on wikipedia what this is\n    float the= iTime*.25;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    // the sphere is at (0.0,0.0,0.0)\n    vec3 o = vec3(0.0,0.0, iTime);\n    \n    //trace from the origin along the ray to find the intersection from our map function\n    float t = trace(o, r);\n    // simple fogging funcition to darken things the further away they are\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 118, 205, 469], [471, 596, 624, 624, 1096], [1098, 1098, 1155, 1155, 2299]], "test": "untested"}
{"id": "XdKGWV", "name": "Simple SDF ray marcher", "author": "tomkel", "description": "Simple, illustrative ray marcher", "tags": ["procedural"], "likes": 0, "viewed": 197, "published": "Public", "date": "1456484051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere( vec3 spherepos, float r, vec3 raypos )\n{\n    return distance( spherepos, raypos ) - r;\n}\n\nvec4 getlight( vec3 normal, vec3 position, vec3 lightpos, vec4 lightcolour  )\n{\n    float d = distance( position, lightpos );\n    vec3 n = normalize( position - lightpos );\n    return max( dot( normal, n ), 0.0 ) * lightcolour;\n    \n}\n\n\nfloat smin( float a,  float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    float blend = -log( res )/k;\n    return blend;\n}\n\n\nfloat sdf( vec3 raypos )\n{\n    float e = abs( 0.5 + abs( cos( iTime )) * 3.0 ) ;\n    return smin( sphere( vec3( 0,0, 0.0), 10.0, raypos ),\n                    sphere( vec3( 0,10, 0.0), 10.0, raypos ), e );\n}\n\n\nvec3 grad( vec3 raypos, float delta )\n{\n    float dx =  sdf( raypos + vec3( delta, 0,0 ) ) - sdf( raypos - vec3( delta,0,0 ) );\n    float dy =  sdf( raypos + vec3( 0, delta,0 ) ) - sdf( raypos - vec3( 0,delta,0 ) );\n    float dz =  sdf( raypos + vec3( 0,0, delta ) ) - sdf( raypos - vec3( 0,0,delta ) );\n    return vec3( dx,dy,dz );\n}\n\nvec4 march( vec3 ray, vec3 origin, float ep )\n{\n    vec3 p = origin;\n    for ( int i = 0; i < 1024; i++ )\n    {\n        float step = sdf(p);\n        if ( step  <  ep )\n        {\n            vec3 normal = normalize( grad( p, 0.1 ) );\n            return getlight( normal, p,  vec3( 100,100,100 ), vec4(1.0,1.0,0,1.0 )) + \n                   getlight( normal, p,  vec3( -100,-100,-100 ), vec4(0.0,1.0,1.0,1.0 )) ;\n        }\n        \n        p += ray * step;\n    }\n    \n    return vec4(0.0,0,0,1);\n}\n\nvec3 rotatevecY( vec3 vec, float angle )\n{\n    vec3 m0 = vec3( -cos( angle ), 0, sin( angle ));\n    vec3 m1 = vec3( 0            , 1.0,   0      );\n    vec3 m2 = vec3( sin( angle ), 0, cos( angle ) );\n    \n    return vec3(  dot( m0, vec ), dot( m1, vec ), dot( m2, vec )) ;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = iResolution.y / iResolution.x;\n    \n    vec3 origin = vec3(0.0, 5,-30.0 );\n    vec3 ray = vec3( uv.x - 0.5, (uv.y - 0.5) * aspect, 0.5 );\n    \n    ray = rotatevecY( ray, iTime );\n    origin = rotatevecY( origin, iTime );\n\n    \n\tfragColor = march( ray, origin, 0.01 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 102], [104, 104, 183, 183, 338], [341, 341, 383, 383, 479], [482, 482, 508, 508, 689], [692, 692, 731, 731, 1026], [1028, 1028, 1075, 1075, 1523], [1525, 1525, 1567, 1567, 1800], [1804, 1804, 1861, 1861, 2197]], "test": "untested"}
{"id": "XdV3DK", "name": "BezierPathTest Multiple Paths", "author": "Sleicreider", "description": "This is a Bezier Path Test Simulation for me.. nooby pls dont judge me", "tags": ["test", "noob", "bezierpath"], "likes": 1, "viewed": 131, "published": "Public", "date": "1456478779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define YELLOW vec3(1.,1.,0.)\n#define BLUE vec3(0.,0.,1.)\n\nstruct Rect\n{\n    float width;\n    float height;\n    float x;\n    float y;\n    vec3  color;\n    float rotation;\n    \n    vec2 csys; //it's own coordinate system\n};\n   \nRect CreateRect(float width, float height, float x, float y, vec3 color)\n{\n    Rect rect;\n    \n    rect.width = width;\n    rect.height = height;\n    rect.x = x;\n    rect.y = y;\n    rect.color = color;\n    \n    return rect;\n}\n\nvoid DrawRect(inout Rect rect,vec2 p, inout vec3 pix)\n{\n    \n   \tfloat dx = p.x - rect.x;\n    float dy = p.y - rect.y;\n    \n    dx = cos(rect.rotation)*(p.x - rect.x) + sin(rect.rotation)*(p.y - rect.y);\n    dy = -sin(rect.rotation)*(p.x - rect.x) + cos(rect.rotation)*(p.y - rect.y);\n    \n    float fL = - rect.width/2.;  //far left\n    float fR = + rect.width/2.;  //far right\n    float fT = + rect.height/2.; //far top\n    float fB = - rect.height/2.; //far bottom\n\n    //anti-aliasing\n    float del;\n    del =  smoothstep(fL - 0.005, fL + 0.005,dx);\n    del *= 1. - smoothstep(fR - 0.005, fR + 0.005,dx);\n    del *=  smoothstep(fB - 0.005, fB + 0.005,dy);\n    del *= 1. - smoothstep(fT - 0.005, fT + 0.005,dy);\n    \n    float d = 0.005;\n    \n    if(dx > fL-d && dx < fR+d \n    && dy < fT+d && dy > fB-d)\n    {\n        pix = mix(pix,rect.color,del);\n    }\n    \n    rect.csys = vec2(dx,dy);\n}\n\nfloat GetPathCoord(float p1, float p2, float percent)\n{\n   return p1 + ((p2 - p1) * percent);\n}\n\nconst int NUM_PATHS = 6;\nvec2 BezierPaths[NUM_PATHS];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = 2.* vec2(fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    vec3 pixel = vec3(0.);\n    \n\tBezierPaths[0] = vec2(0.,1.);\n    BezierPaths[1] = vec2(0.2,1.);\n    BezierPaths[2] = vec2(0.,0.);\n    BezierPaths[3] = vec2(0.4,0.0);\n    BezierPaths[4] = vec2(0.45,0.0);\n\n    BezierPaths[5] = vec2(1.,0.);\n    \n    //Draw the bezier path points\n    \n    for(int i = 0; i < NUM_PATHS; i++)\n    {\n        Rect tmp_rect = CreateRect(0.05,0.05,BezierPaths[i].x, BezierPaths[i].y,YELLOW);\n        DrawRect(tmp_rect,r,pixel);\n    }\n     \n    float percent = (mod(iTime,4.0))/ 4.0;\n    \n    //Bezier path calculation for multiple paths\n    float tmp_x = 0.;\n    float tmp_y = 0.;\n    vec2 x[NUM_PATHS-1];\n    \n    for(int i = 0; i < NUM_PATHS-1; i++)\n    {\n        tmp_x = GetPathCoord(BezierPaths[i].x , BezierPaths[i+1].x, percent);\n        tmp_y = GetPathCoord(BezierPaths[i].y , BezierPaths[i+1].y, percent);\n        \n        x[i] = vec2(tmp_x,tmp_y);\n    }\n    \n    float tmp_nx = GetPathCoord(x[0].x, x[1].x,percent);\n    float tmp_ny = GetPathCoord(x[0].y, x[1].y,percent);\n    \n    for(int i = 2; i < NUM_PATHS-1; i++)\n    {\n        tmp_nx = GetPathCoord(tmp_nx,x[i].x,percent);\n    \ttmp_ny = GetPathCoord(tmp_ny,x[i].y,percent);\n    }\n    \n    //Draw Bezier Point which follows the path\n    Rect rp = CreateRect(0.05,0.05,tmp_nx,tmp_ny,BLUE);\n\tDrawRect(rp,r,pixel);\n\n\n    \n    fragColor = vec4(pixel,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdV3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 301, 301, 451], [453, 453, 508, 508, 1347], [1349, 1349, 1404, 1404, 1444], [1501, 1501, 1558, 1558, 2969]], "test": "untested"}
{"id": "XdVGWG", "name": "Funky Fungi", "author": "lsdlive", "description": "Fungi emerging from the Mandelbrot set.<br/>Released for the js1k 2016.", "tags": ["mandelbrot", "rotozoom"], "likes": 2, "viewed": 206, "published": "Public", "date": "1456177440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float center_r = -0.743, center_i = 0.13182;\n    //float zoom = 0.00009 * sin(iTime / 1.2);\n    float zoom = 0.00009 * sin(iTime / 1.6);\n    \n    //float tr = 0.000009;\n    float tr = 0.00008;\n\n    float cr = center_r + (fragCoord.x - iResolution.x / 2.0)*3.5 / iResolution.x * zoom + sin(iTime * 2.0) * tr;\n    float ci = center_i + (fragCoord.y - iResolution.y / 2.0)*2.0 / iResolution.y * zoom + cos(iTime * 4.0) * tr;\n\n    int it = 0;\n    float x = 0.0, y = 0.0;\n    for (int i = 0; i <= 1000; i++) {\n        if (x * x + y * y >= 4.0) {\n            break;\n        }\n        float xt = x * x - y * y + cr;\n        y = 2.0 * x * y + ci;\n        x = xt;\n        it = i;\n    }\n\n    vec3 color;\n    if (it == 1000) {\n        color = vec3(0.2, 0.5, 0.4);\n    } else {\n        float c = -0.2 + sin(float(it) - sin(iTime * 8.0));\n        vec3 n_color = vec3(0.6, c, 0.4);\n        vec3 i_color = vec3(c, 0.4, 0.6);\n        float weight = 0.5 + sin(iTime * 0.8) * 0.4;\n        color = mix(n_color, i_color, weight);\n\n    }\n\n    fragColor = vec4(color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1115]], "test": "untested"}
{"id": "XdVGzK", "name": "Checkerboard Tunnel", "author": "ulfbiallas", "description": "Simple tunnel effect. Click on the canvas to change the position of the vanishing point.", "tags": ["2d", "tunnel", "checkerboard"], "likes": 2, "viewed": 186, "published": "Public", "date": "1455366281", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Checkerboard Tunnel\"\n// by Ulf Biallas | https://twitter.com/ulfbiallas\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 mouse = iMouse.xy;\n    float dx = mouse.x - fragCoord.x;\n    float dy = mouse.y - fragCoord.y;\n\n    float dist = pow(pow(dx, 2.0) + pow(dy, 2.0), 1.0 / 2.0);\n    dist = 500.0 * pow(dist, 0.1);\n\n\tfloat blockSize = 35.0;\n\n    dist = mod(dist, blockSize) - 0.5 * blockSize;\n    vec4 color;\n    bool distFlag = false;\n    if (dist < 0.0) {\n        distFlag = true;\n    }\n\n    float angle = atan(dy / dx) + 0.5 * 3.14;\n    float segmentSize = 3.14 / 4.0;\n\n    angle = mod(iTime+angle, segmentSize) - 0.5 * segmentSize;\n    bool angleFlag = false;\n    if (angle <= 0.0) {\n        angleFlag = true;\n    }\n\n    color = vec4(1.0, 1.0, 1.0, 1.0);\n    if( (angleFlag && distFlag)) {\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    if( (!angleFlag && !distFlag)) {\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 77, 134, 134, 975]], "test": "untested"}
{"id": "Xdy3DV", "name": "Make a circle ", "author": "amdbcg", "description": "I spent awhile trying to figure out why my circle was looking like an oval. I found a ratio fix and applied it, it's a circle now! <br/>", "tags": ["circle"], "likes": 1, "viewed": 93, "published": "Public", "date": "1456362351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\nvoid circle(){}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \tvec2 p = fragCoord.xy / iResolution.y ;\n    //Position animation \n    vec2 q = p - vec2(.8-cos(iTime*2.0)/5.0,0.5-sin(iTime*2.1)/5.0);\n    // Color\n     vec3 col = mix(vec3(0.4, 0.6,0.1),vec3(1.0, 0.8,0.8),tan(p.x*cos(iTime*4.0)));\n   \n   \n   //the circle - make sure the aspect ratio is fixed.\n    float r = .2;\n    col *= smoothstep(r+.1, r+.01, length(q));\n   \n\tfragColor = vec4(col,1.0);\n}\n\n\n/**\nNormalizing : http://snipd.net/2d-and-3d-vector-normalization-and-angle-calculation-in-c\ncircle example: https://www.shadertoy.com/view/XsjGDt\nfrom that Gijs mentioned the reason I was getting an oval was because the ratio wasn't 1:1, \nso I fixed that and bam! a circle ! \n**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdy3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 18, 18, 19], [21, 21, 78, 78, 479]], "test": "untested"}
{"id": "Xdy3Dy", "name": "a World", "author": "MMGS", "description": "Controls: Mouse, drag around", "tags": ["planet", "world"], "likes": 2, "viewed": 196, "published": "Public", "date": "1456182984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by mmgs@2016\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    vec2 m = iMouse.xy;\n    m.x = iMouse.x*2.0-1.0;\n     m.y = iMouse.y*2.0-1.0;\n    m.x *= 2.*iMouse.x/iResolution.x;\n    \n    float an = 0.3*iTime*0.01 + m.x*0.001;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an))+0.5-m.y*0.001;\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n#define TI iTime\n#define PI 3.1415926535897932384626433832795\n#define TWOPI (2.0*PI)\nvec3 doBackground( vec2 uv )\n{\n    vec3 tex=texture(iChannel0,uv).xyz;\n    if(tex.x<0.95) tex=vec3(0);\n    return tex;\n}\n#define FBM_Iteration 6\nvec2 polar(vec3 norm)\n{\n\tvec2 res;\n    res.y = (norm.y+1.0)/2.0;\n    res.x = atan(norm.z, norm.x) / TWOPI;\n    return res.xy;\n}\n\nvec2 polarWrap(vec3 norm)\n{\n\tvec2 res = polar(norm);\n    res.x = abs(res.x-0.5)*2.0;\n    return res; \n}\n\n\nfloat perlin_noise3(vec3 p){\n \n    /*\n     not perlin noise anymore*/\n    \n    vec3 tex = texture(iChannel1,polarWrap(p)).xyz;\n    return length(p+tex*.5)*0.5;\n}\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat fbm3(vec3 p){\n    float n=0.0;\n    n=perlin_noise3(p);\n\n    float a=0.1;\n    for (int i=0;i<2;i++){\n        n+=a*perlin_noise3(p-float(i)*42.);\n        p=p*2.0;\n        a=a*0.5;\n    }\n    return n;\n}\nvec2 doModel( vec3 p )\n{\n     float id = 0.0;\n    float r=.50;\n    float s = length(p) - (r+ 0.5*( .5 + ( .5 * fbm3( p * .5  )*2.015  ) ));\n\n    if(s>=length(p+cos(p.x*222.+iTime*2.)*0.0001+sin(p.z*222.+iTime*2.)*0.00001 )-r*4.0){id=2.0;s=length(p)-r*4.;} //water\n    if(s<length(p)-r*4.13){id=3.0;} //snow\n    if(s>length(p)-r*4.05 && s<length(p)-r*4.015){id=4.0;s=length(p)-r*4.05;}\n    \n   vec3 pos = vec3(0.+cos(iTime*0.1)*2.3,-1,0.+sin(iTime*0.1)*2.3);\n    float s1 = length(p*0.5+0.5+pos) - .2*s;\n\n  \t\ts =min(s,s1);\n    if(s==s1)id=5.0;\n   \n  //if(id==2.)s+= ((p.y*222.+iTime)*.1)*0.001;\n\n    return vec2(s,id);\n}\n\n\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nvec3 appleColor( in vec3 pos, in vec3 nor, out vec2 spe )\n{\n    spe.x = 1.0;\n    spe.y = 1.0;\n\n    float a = atan(pos.x,pos.z);\n    float r = length(pos.xz);\n\n    // red\n    vec3 col = vec3(2.0,0.0,0.0);\n\n    // green\n    float f = smoothstep( 0.1, 1.0, fbm(pos*1.0) );\n    col = mix( col, vec3(0.8,1.0,0.2), f );\n\n    // dirty\n    f = smoothstep( 0.0, 1.0, fbm(pos*4.0) );\n    col *= 0.8+0.2*f;\n\n    // frekles\n    f = smoothstep( 0.0, 1.0, fbm(pos*48.0) );\n    f = smoothstep( 0.7,0.9,f);\n    col = mix( col, vec3(0.9,0.9,0.6), f*0.5 );\n\n    // stripes\n    f = fbm( vec3(a*7.0 + pos.z,3.0*pos.y,pos.x)*2.0);\n    f = smoothstep( 0.2,1.0,f);\n    f *= smoothstep(0.4,1.2,pos.y + 0.75*(noise(4.0*pos.zyx)-0.5) );\n    col = mix( col, vec3(0.4,0.2,0.0), 0.5*f );\n    spe.x *= 1.0-0.35*f;\n    spe.y = 1.0-0.5*f;\n\n    // top\n    f = 1.0-smoothstep( 0.14, 0.2, r );\n    col = mix( col, vec3(0.6,0.6,0.5), f );\n    spe.x *= 1.0-f;\n\n\n    float ao = 0.5 + 0.5*nor.y;\n    col *= ao*1.;\n\n    return col;\n}\n\n\n\n\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec3 col;\n    vec3  lig = normalize(vec3(1.0,0.7,0.9))*1.5;\n    vec2 spec = vec2(1);\n     vec3 apl = appleColor(pos*32.,  nor, spec).xyz;\n    \n    float test = doModel(pos).y;\n       vec3 tex = texture(iChannel1,polarWrap(nor)).xyz;\n   \t vec3 wtex = texture(iChannel1,polarWrap(cos(tex*8.+iTime*0.03)+sin(tex*6.+iTime*0.03)  )).xyz\n         +texture(iChannel1,polarWrap(cos(tex*25.+iTime*0.5)*0.25-sin(tex*25.-iTime*0.15)*0.5  )).xyz\n         +texture(iChannel1,polarWrap(cos(tex*25.-iTime*0.5)*0.35+sin(tex*25.-iTime*0.25)*0.5  )).xyz;\n    \n      col =vec3(0.2,0.07,0.01)*tex+apl*0.1;\n    \n      //  tex = texture(iChannel1,polarWrap(nor*.5)).xyz;\n     //  \t vec3 cluuud = texture(iChannel1,polarWrap(2.*cos(tex*2.+iTime*0.03+pos.x)+1.5*sin(pos.y*2.+tex*6.+iTime*0.03)  )).xyz;\n    \n    \n\n     if(test==1.0)col=vec3(0,0,0.4);\n    if(test==2.0){col=vec3(0,0,0.15);}\n    if(test==3.0)col=vec3(0.4)+(tex*0.01);\n    if(test==4.0)col=vec3(0,0.4,0)*tex*apl;\n      if(test==5.0)col+=vec3(0.3+dot(nor,lig)*0.1);\n  //  if(test==2.0 && col.z <0.3) col += vec3(0.1);\n    \n  //  if(cluuud.x < 0.35) col += vec3(0.7);\n    \n    \n    return col;\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n     lig = -normalize(vec3(1.0,0.7,0.9));\n   vec3 resCol=1.0 * sin( vec3(0.06,0.08,0.1)* dis);\n\n        \n        float diffuse=.50*max(0.0,dot(-lig,nor) );\n        vec3 ref=reflect(-rd,nor);\n        vec3 h=normalize(-lig-rd);\n        float specular=1.0*pow(max(0.0,dot(h, nor) ),10.0 );\n\t\tvec3 amb=vec3(.001);\n      vec3  finalCol=lin*(diffuse+specular)*col +amb;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return finalCol;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )       \n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<35; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground(fragCoord.xy/iResolution.xy);\n\t vec3  lig = normalize(vec3(1.0,0.7,0.9));\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t \n    if(col.x<0.01)\n    col+= dot(rd,lig)*0.5+vec3(0,0,0.2)+1.0-length(p)*0.4;\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdy3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 17, 100, 100, 360], [447, 447, 477, 477, 567], [592, 592, 615, 615, 719], [721, 721, 748, 748, 824], [827, 827, 855, 896, 988], [989, 989, 1030, 1030, 1125], [1128, 1128, 1147, 1147, 1333], [1334, 1334, 1358, 1358, 1953], [2065, 2065, 2088, 2088, 2127], [2130, 2130, 2156, 2156, 2561], [2563, 2563, 2584, 2584, 2782], [2784, 2784, 2843, 2843, 3777], [3782, 3782, 3827, 3827, 4965], [4967, 5178, 5262, 5262, 6206], [6208, 6208, 6258, 6258, 6629], [6631, 6631, 6663, 6663, 7083], [7085, 7085, 7133, 7133, 7561], [7563, 7563, 7627, 7627, 7805], [7807, 7807, 7864, 7864, 9220]], "test": "untested"}
{"id": "Xdy3Rc", "name": "2D Weyl hash #1", "author": "MBR", "description": "a 2D equidistributed sequence based on Weyl generators", "tags": ["hash"], "likes": 11, "viewed": 773, "published": "Public", "date": "1455545306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// LICENSE: http://unlicense.org/\n\n// Not interesting if you can use XOR.\n// SEE: https://www.shadertoy.com/view/4dlcR4\n\n#define W0 0.5545497\n#define W1 0.308517\n\n\n// as is this will start to show defects outside of\n// the interval [-2048, 2048]\nfloat hash(in vec2 c)\n{\n  float x = c.x*fract(c.x * W0);\n  float y = c.y*fract(c.y * W1);\n\n  // NOTICE: as is - if a sampling an integer lattice\n  // any zero input will cause a black line in that\n  // direction. \n  return fract(x*y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2  p = fragCoord.xy ;\n  float r = hash(p+vec2(iFrame));\n  vec4  c = vec4(vec3(r),1.0);\n    \n  fragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdy3Rc.jpg", "access": "shaders20k", "license": "unlicense", "functions": [[164, 246, 269, 269, 482], [485, 485, 542, 542, 658]], "test": "untested"}
{"id": "Xdy3Rd", "name": "Running man", "author": "bmontell", "description": "Run cycle animation test!", "tags": ["3d", "cycle", "animation", "man", "walk", "human", "run"], "likes": 27, "viewed": 505, "published": "Public", "date": "1455998059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 LIGHT_DIR = normalize(vec3(0.5, -1.0, -0.5));\n\n// Animation constants. Initialized in initAnimation() because some compilers don't like\n// non-constant global initializers.\nfloat TIME;\nfloat TORSO_LEAN;\nfloat TORSO_TWIST;\nfloat TORSO_BOUNCE;\nfloat HEAD_BOB;\nfloat L_LEG_SWING;\nfloat R_LEG_SWING;\nfloat L_KNEE_BEND;\nfloat R_KNEE_BEND;\nfloat L_ANKLE_BEND;\nfloat R_ANKLE_BEND;\nvec3 L_ARM_SWING;\nvec3 R_ARM_SWING;\nfloat L_ELBOW_BEND;\nfloat R_ELBOW_BEND;\n\nvoid initAnimation() {\n    TIME = iTime * 6.2;\n    TORSO_LEAN = -0.1;\n    TORSO_TWIST = 0.15*sin(0.5+TIME);\n    TORSO_BOUNCE = 0.9 * abs(sin(TIME + 0.4));\n    HEAD_BOB = - 0.05 * (1.0 - (sin(2.0 * (TIME - 1.0))));\n    L_LEG_SWING =  .6 * sin(TIME);\n    R_LEG_SWING = -.6 * sin(TIME);\n    L_KNEE_BEND = -0.8 * (1.0 + sin(TIME+1.7));\n    R_KNEE_BEND = -0.8 * (1.0 - sin(TIME+1.7));\n    L_ANKLE_BEND = 0.3 * (1.0 + sin(TIME+1.));\n    R_ANKLE_BEND = 0.3 * (1.0 - sin(TIME+1.));\n    L_ARM_SWING = vec3(-0.6 * sin(TIME), 0.1, -0.4);\n    R_ARM_SWING = vec3( 0.6 * sin(TIME), -0.1,  0.4);\n    L_ELBOW_BEND = mix(0.9, 1.5, 1.0 - (sin(TIME + 0.3) + 0.3 * sin(2.0 * (TIME + 0.3))));\n    R_ELBOW_BEND = mix(0.9, 1.5, 1.0 + (sin(TIME + 0.3) + 0.3 * sin(2.0 * (TIME + 0.3))));   \n}\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p)-r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 rotx(vec3 p, float rx) {\n    float sinx = sin(rx);\n    float cosx = cos(rx);\n    return mat3(1., 0., 0., 0., cosx, sinx, 0., -sinx, cosx) * p;\n}\n\nvec3 roty(vec3 p, float ry) {\n    float sinx = sin(ry);\n    float cosx = cos(ry);\n    return mat3(cosx, 0., -sinx, 0., 1., 0., sinx, 0., cosx) * p;\n}\n\nvec3 rotz(vec3 p, float rz) {\n    float sinx = sin(rz);\n    float cosx = cos(rz);\n    return mat3(cosx, sinx, 0., -sinx, cosx, 0., 0., 0., 1.) * p;\n}\n\nvec3 rot(vec3 p, vec3 r) {\n    return rotx(roty(rotz(p, r.z), r.y), r.x);\n}\n\nfloat sdLeg(vec3 p, float r, vec2 h, float legSwing, float kneeBend, float ankleBend) {    \n    vec3 cylOffset = vec3(0.0, h.y, 0.0);\n    p = rotx(p - 2.0 * cylOffset, legSwing) + 2.0 * cylOffset; // Swing upper leg.\n    \n    // Knee\n    float d = sdSphere(p, r);\n    \n    // Thigh\n\td = smin(d, sdCylinder(p - cylOffset, h), 0.4);\n    \n    p = rotx(p, kneeBend); // Swing lower leg.\n\n    // Shin\n    d = smin(d, sdCylinder(p + cylOffset, h), 0.4);\n    \n    vec3 ty = vec3(0.0, 2.0 * h.y, 0.0);\n    p = rotx(p + ty, ankleBend); // Swing foot.\n\n    // Foot\n\tvec3 tz = vec3(0.0, 0.0, -0.7);\n    d = smin(d, sdEllipsoid(p + tz, vec3(0.25, 0.2, 0.7)), 0.4);\n    \n    return d;\n}\n\nfloat sdLegs(vec3 p) {\n    vec2 legDimens = vec2(0.3, 1.9);\n    vec3 legDisp = vec3(0.9, 0.0, 0.0);\n    return min(\n        sdLeg(p - legDisp, 0.1, legDimens, L_LEG_SWING, L_KNEE_BEND, L_ANKLE_BEND),\n        sdLeg(p + legDisp, 0.1, legDimens, R_LEG_SWING, R_KNEE_BEND, R_ANKLE_BEND));\n}\n\nfloat sdArm(vec3 p, vec3 swing, float elbowBend) {\n    p = rot(p, swing);\n    \n    // Shoulder\n    float d = sdSphere(p, 0.3);\n    \n    // Upper arm\n    vec2 upperArmDimens = vec2(0.3, 1.3);\n    d = smin(d, sdCylinder(p + vec3(0.0, upperArmDimens.y, 0.0), upperArmDimens), 0.4);\n\n    // Rotate at elbow\n    p.y += 2.0 * upperArmDimens.y;\n    p = rotx(p, elbowBend);\n\n    // Elbow\n    d = smin(d, sdSphere(p, 0.3), 0.4);\n    \n    // Lower arm\n    vec2 lowerArmDimens = vec2(0.3, 1.2);\n    d = smin(d, sdCylinder(p + vec3(0.0, lowerArmDimens.y, 0.0), lowerArmDimens), 0.4);\n    \n    // Hand\n    p.y += 2.0 * lowerArmDimens.y;\n    //d = smin(d, sdSphere(p, 0.3), 0.4);\n    \n    return d;\n}\n\nfloat sdArms(vec3 p) {    \n    vec3 armDisp = vec3(1.4, 0.0, 0.0);\n    return min(\n        sdArm(p - armDisp, L_ARM_SWING, L_ELBOW_BEND),\n        sdArm(p + armDisp, R_ARM_SWING, R_ELBOW_BEND));\n}\n\nfloat sdUpperBody(vec3 p) {\n    float d = udRoundBox(p, vec3(0.7, 1.5, .0), 0.7);\n    d = smin(d, sdArms(p - vec3(0.0, 1.8, 0.0)), 0.4);\n    d = smin(d, sdCylinder(p - vec3(0.0, 2.5, 0.0), vec2(0.2, 0.4)), 0.4);\n    \n    p.y -= 2.5;\n    p = rotx(p, HEAD_BOB);\n    p.y -= 1.0;\n    d = smin(d, sdSphere(p, 1.0), 0.4);\n\n    return d;\n}\n\nvec2 argMin(in vec2 a, in vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdPerson(vec3 p) {\n    float d = sdLegs(p);    \n    p.y -= TORSO_BOUNCE + 4.9;\n    p.z -= 0.2;\n    p = rotx(p, TORSO_LEAN);\n    p = roty(p, TORSO_TWIST);\n    return smin(d, sdUpperBody(p), 0.5);\n}\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(sdPlane(p), 1.0);\n    return argMin(res, vec2(sdPerson(p - vec3(0.0, 3.95, 0.0)), 2.0));\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec2 eps = vec2(0.001, 0.0);\n    vec3 n = vec3(map(p+eps.xyy).x - map(p-eps.xyy).x,\n                  map(p+eps.yxy).x - map(p-eps.yxy).x,\n                  map(p+eps.yyx).x - map(p-eps.yyx).x);\n    return normalize(n);\n}\n\nvec2 marchRay(in vec3 ro, in vec3 rd) {\n    float t = 0.0;\n    float precis = 0.02;\n    float tmax = 15.0;\n    for (int i=0; i<200; i++)\n    {\n        vec3 p = ro + t*rd;\n\n        if (length(p) > 200.0) break; // Throw away points far from origin.\n\n        vec2 res = map(p);\n\n        if (res.x < precis) return vec2(t, res.y);\n        if (res.x > tmax) break;\n\n        t += res.x;\n    }\n    return vec2(-1.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec2 res = marchRay(ro, rd);\n    if (res.y < -0.5) return vec3(0.6, 0.7, 0.9);\n    \n    float t = res.x;\n    vec3 p = ro + t*rd;\n    vec3 n = calcNormal(p);\n    vec3 lightDir = normalize(vec3(0.5, -1.0, -0.5));\n    \n    vec3 col = vec3(0.1, 0.6, 0.8);\n    if (res.y < 1.5) {\n        col = vec3(0.3, 0.55, 0.3);\n        if (abs(p.x) < 10.0) {\n            col = vec3(mix(0.9, 0.8, step(mod(p.z + 5.4 *TIME, 20.0), 0.3)));\n        }\n    }\n    \n\tfloat lambert = 0.2 * max(0.0, dot(n, normalize(vec3(1.0, 1.0, -1.0))));// fill\n    if (marchRay(p - 0.1 * LIGHT_DIR, -LIGHT_DIR).y < -0.5) {\n        lambert = max(0.0, dot(n, -LIGHT_DIR));// key\n    }\n    \n    return col * vec3(0.3 + 0.7 * lambert);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    initAnimation();\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n\n    // camera\n    vec3 eye = vec3(25.0, 11.0, 25.0);\n    if (iMouse.z > -1.0) {\n        eye = rotx(eye, 0.3 *(iMouse.y - iMouse.w)/iResolution.y);\n        eye = roty(eye, -10.0*((iMouse.x - iMouse.z)/iResolution.x));\n    }\n    vec3 look = vec3(0.0, 6.0, 0.0);\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n    vec3 w = normalize( look - eye );\n    vec3 u = normalize( cross(w,up) );\n    vec3 v = normalize( cross(u,w) );\n    vec3 rd = normalize( p.x*u + p.y*v + 3.5*w );\n\n    vec3 col = render( eye, rd );\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor=vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdy3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 456, 478, 478, 1223], [1225, 1225, 1251, 1251, 1269], [1271, 1271, 1310, 1310, 1336], [1338, 1338, 1374, 1374, 1477], [1479, 1479, 1522, 1522, 1582], [1584, 1584, 1629, 1629, 1671], [1673, 1673, 1714, 1714, 1809], [1811, 1811, 1840, 1840, 1960], [1962, 1962, 1991, 1991, 2111], [2113, 2113, 2142, 2142, 2262], [2264, 2264, 2290, 2290, 2339], [2341, 2341, 2428, 2428, 3014], [3016, 3016, 3038, 3038, 3302], [3304, 3304, 3354, 3354, 3990], [3992, 3992, 4014, 4014, 4187], [4189, 4189, 4216, 4216, 4521], [4523, 4523, 4558, 4558, 4590], [4592, 4592, 4616, 4616, 4794], [4796, 4796, 4817, 4817, 4928], [4930, 4930, 4958, 4958, 5184], [5186, 5186, 5225, 5225, 5598], [5600, 5600, 5637, 5637, 6336], [6338, 6338, 6395, 6395, 7101]], "test": "untested"}
{"id": "Xdy3RK", "name": "Chaotic Symmetry", "author": "Passion", "description": "A 2d fractal. I went a bit overkill with the noise and fbm calls in the c1 and c2 colors. Inspired by 'interactive evolution' - by 'bergi'.", "tags": ["2d", "fractal"], "likes": 8, "viewed": 564, "published": "Public", "date": "1455241480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* 2016 Passion */\n\n//Random function\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n//Noise function\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n//Fbm function\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    //n.x+=iTime;\n    for (int i = 0; i < 5; i++) {\n        total += noise(n) * amplitude;\n        n += n;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n//2D Rotation\nmat2 rot(float deg){    \n    return mat2(cos(deg),-sin(deg),\n                sin(deg), cos(deg));\n        \n}\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    \n    //Center uv coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    float vinette = 1.-pow(length(uv*uv*uv*uv)*1.01,10.);\n    uv.x *= iResolution.x / iResolution.y;\n   \n    //uv+=noise(.2*uv-iTime);\n    float t = iTime*.75;\n    \n    const int numIter = 5;\n    \n    //The Fractal\n    for(int i = 0; i<numIter; i++){\n        \n        uv*=rot(t*.16);\n        uv = abs(uv) / dot(uv,uv);\n        uv.x = abs(uv.x+cos(t*.6)*.5);\n        uv.x = abs(uv.x-.8);\n        uv = abs(rot(-t*.3)*uv);\n        uv.y = abs(uv.y-.5);\n        uv.y = abs(uv.y+.03+sin(t)*.25);\n        \n    }\n    \n    uv = abs(uv) / float(numIter);\n\n    vec3 c1 = vec3(noise(uv*7.),\n                   sin(fbm(uv*.6)), \n                   cos(fbm(uv*8.)));\n    \n    uv+=abs(.1*t+uv*2.23);\n    \n    vec3 c2 = vec3(cos(fbm(uv*8.+noise(uv*5.5))), \n                   cos(fbm(7.*uv)), \n                   cos(uv*6. - fbm(5.*uv)));\n    //Mix and gama adjustments\n    fragColor = vec4(pow(mix( c1, c2, (noise(2.*uv))), vec3(1.0/0.5)) ,1.0)*vinette;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdy3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 38, 58, 58, 128], [130, 147, 168, 168, 374], [376, 391, 410, 410, 609], [611, 625, 645, 645, 733], [734, 741, 796, 829, 1840]], "test": "untested"}
{"id": "XdyGDy", "name": "Transparency and refractions", "author": "dine909", "description": "More experiments, this time with refractions - this has issues, but is convincing enough.\n\nSomehow need to work out marching to the back face of an sdf object, once a ray has determined transparency, in order to complete the proper refraction angle.", "tags": ["3d", "transparency", "material", "refract"], "likes": 3, "viewed": 235, "published": "Public", "date": "1456095192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHADERTOY\n\nprecision highp float;\nprecision highp int;\n\n#ifndef SHADERTOY\n#define iResolution resolution\n#define iTime time\n#define iMouse mouse\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n#endif\n\n//----8<----- SETTINGS ----8<-----//\n\n#define LIGHT_AMOUNT 1.\n//#define ANIMATE_TABLET // <<-- I get corruption with this enabled - hmm.\n#define AUTO_CAMERA\n#define MAX_REFLECT_BOUNCES 2\n#define ENABLE_TRANSPARENCY\n//#define ENABLE_SHADOWS\n//#define ENABLE_FOG\n//#define ENABLE_AO\n//#define SCREEN_POWER 1\n\n//----8<----- /SETTINGS ----8<----//\n\n\n#ifndef SCREEN_POWER\n#define SCREEN_POWER (iTime>4.8?1:0)\n#endif\n#ifndef LIGHT_AMOUNT\n#define LIGHT_AMOUNT .2 + 0.5+0.5*sin(0.5+0.5*cos(iTime*0.5)*PI); \n#endif\n\n#define hz1 (.5+0.5*sin(iTime))\n#define SSW mod(iTime*0.5,1.)>0.5?1.:0.\n\nfloat remap(float value, float low1,float high1, float low2,float high2,bool c){float r=low2 + (value - low1) * (high2 - low2) / (high1 - low1);return c?clamp(r,min(low2,high2),max(low2,high2)):r;}\nfloat remap(float value, float low2,float high2,bool c){return remap(value,0.,1.,low2,high2,c);}\nfloat antiAlias(float x) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.0);}\nfloat blur(float x) {return pow(smoothstep(.945,1.0,x),10.);}\n\n#define PI 3.14159265359\n\nconst float KEY_A = 65.5/256.0;\nconst float KEY_B = 66.5/256.0;\n\nfloat rand (in vec2 seed) {\n    seed = fract (seed * vec2 (5.3983, 5.4427));\n    seed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n    return fract (seed.x * seed.y * 95.4337);\n}\n\nfloat isKeyPressed(float key)\n{\n    #ifndef SHADERTOY\n    return 0.;\n    #else\n    return texture( iChannel0, vec2(key, 3.5) ).x;\n    #endif\n}\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat sdPlane( vec3 p ){ return p.y;}\nfloat udBox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}\nfloat sdBox( vec3 p, vec3 b ){ vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));}\nfloat sdSphere( vec3 p, float s ){ return length(p)-s;}\n\nstruct Reflectivity{ float amount; float chromacity;}T_Reflectivity;\nstruct SDPrim{ int type; vec3 tra,rot,siz; float sca; vec3 utp;}T_SDPrim;\nstruct Material{ int type; vec3 col; Reflectivity ref; float trans; float emis;}T_Material;\nstruct SDObject{int id; SDPrim def; Material mat; float d,t; vec3 mpos,nor;}T_SDObject;\nstruct Ray{vec3 ro,rd;float tmin ,tmax;float a;int id;bool solo;}T_Ray;\n\nRay newRay(vec3 ro,vec3 rd){float tmin = .10;float tmax = 20.0;return Ray(ro,rd,tmin,tmax,0.,-1,false);}\nconst SDObject NoSDObject = SDObject(-1,SDPrim(0,vec3(0.),vec3(0.),vec3(1.),(1.),vec3(0.)),Material(0,vec3(.0),Reflectivity(0.,0.),0.,0.),1000.,1000.,vec3(0.),vec3(0.));\nSDObject newSDObject(int id,Material mat, SDPrim sdo){ return SDObject(id,sdo,mat,0.,0.,vec3(0.),vec3(0.));}\nSDObject SDUnion(SDObject oa ,SDObject ob,int id,bool solo){ if((ob.id==id)?!solo: solo?true:oa.d<ob.d) return oa; else return ob;}\n\nvoid rotp(inout vec3 rp,vec3 r)\n{\n    mat2 mx=mm2(r.x);\n    mat2 my=mm2(r.y);\n    mat2 mz=mm2(r.z);\n    rp.xy*=mz;\n    rp.xz*=my;\n    rp.zy*=mx;\n\n}\nvoid transform(inout vec3 rp,in SDPrim d)\n{\n\n    // rotp(rp,d.rot);\n    rotp(rp,d.rot);\n    rp-=d.tra;\n    rp/=(d.sca);\t\t\t\n}\n\n\nSDObject SDOMap(in SDObject o,vec3 p)\n{\n    // o.ray=ray;\n    // o.ray.ro+=o.pos;\n    //o.d=iSphere(o.ray.ro,o.ray.rd);\n    SDPrim d=o.def;\n\n    o.mpos=p;\n    vec3 rp=p;\n    transform(rp,d);\n    o.def.utp=rp;\n\n\n    if(d.type==1) o.d=sdPlane(rp);\n    if(d.type==2) o.d=sdSphere(rp,1.);\n    if(d.type==3) o.d=udBox(rp,d.siz);\n\n    o.d*=d.sca;\n    return o;\n}\nSDObject mapTablet(vec3 p,vec3 pos,vec3 ori,float tanim,int ignore,bool solo)\n{\n\n    SDObject body=newSDObject(10,Material(3,vec3(.04),Reflectivity(.60,0.45),0.,0.),\n                              SDPrim(3,vec3((1.-tanim)*-1.,.5,-1.)+pos-(1.-tanim)*2.,ori,vec3(1.6,.1,.9),(1.),vec3(0.)));\n\n    SDObject screen=newSDObject(10,Material(2,vec3(0.5),Reflectivity(.60,0.95),0.,.94),\n                                SDPrim(3,vec3((1.-tanim)*-1.,.551,-1.)+pos+(1.-tanim),ori,vec3(1.6*0.9,.05,.9*0.85),(1.),vec3(0.)));\n\n    SDObject led=newSDObject(10,Material(3,SCREEN_POWER==1?vec3(0.1,0.1,2.2):vec3(0.2),Reflectivity(.0,0.05),0.,.94*float(SCREEN_POWER)),\n                             SDPrim(3,vec3(0.,.551,-1.+.9*0.92)+pos,ori,vec3(0.1,.05,0.025),(1.),vec3(0.)));\n\n    SDObject res= SDOMap(body,p);\n    res= SDUnion(res,SDOMap(screen,p),ignore,solo);\n    res= SDUnion(res,SDOMap(led,p),ignore,solo);\n    return res;\n}\nSDObject mapScene(vec3 p,int ignore,bool solo)\n{\n    vec3 testcol=vec3(1.,0.5,0.25);\n    SDObject gr=newSDObject(1,Material(1,testcol.ggg,Reflectivity(.001,0.5),0.,0.),SDPrim(1,vec3(0.,0.,0.),vec3(0.),vec3(1.),1.,vec3(0.)));\n    SDObject cu2=newSDObject(2,Material(3,testcol.gbb,Reflectivity(.70,.50),0.5,0.),SDPrim(3, vec3(2.,1.,2.6), vec3(0.,0.,0.), vec3(1.), (1.),vec3(0.)));\n    SDObject cu=newSDObject(3,Material(3,testcol.bgb,Reflectivity(.70,.50),0.5,0.),SDPrim(2,vec3(-2.,1.,2.6),vec3(0.,0.,0.),vec3(1.),(1.),vec3(0.)));\n\n\n    #ifdef ANIMATE_TABLET\n    float tanim=0.5-0.5*cos(remap(iTime,0.,1.,0.,1.,true)*PI);\n    #else\n    #define tanim 1.\n    #endif\n    SDObject tablet=mapTablet(p,\n                              mix(vec3(0.,1.,-1.),vec3(0.),tanim),\n                              mix(vec3(1.4,1.4*-2.,0),vec3(1.4,0.,0.),tanim),tanim,ignore,solo);\n\n    SDObject res= NoSDObject;\n    res= SDUnion(res,SDOMap(gr,p),ignore,solo);\t\n    res= SDUnion(res,tablet,ignore,solo);\t\n    res= SDUnion(res,SDOMap(cu2,p),ignore,solo);\n    res= SDUnion(res,SDOMap(cu,p),ignore,solo);\n\n    return res;\n}\nSDObject render(in vec3 bcol,out vec3 ocol, Ray ray);\nSDObject castRay( in Ray ray )\n{\n    int cd=1;\n    float precis =0.00001;//(state.y+1.<iTime)?0.0001:0.003;\n    float t = ray.tmin;\n    SDObject res=NoSDObject;\n    SDObject  ores=NoSDObject;\n    vec3 p;\n    int citer=0;\n    for( int i=0; i<200; i++ )\n    {\n        p=ray.ro+ray.rd*t;\n        res = mapScene( p,ray.id,ray.solo );\n        if( res.d<precis || t>ray.tmax) {              \n            break;\n        }\n        t += res.d;\n    }\n    res.t=t;\n    if( t>ray.tmax ) return NoSDObject;\n    //   res.ray.ro=p;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.004, 0.0, 0.0 );\n    vec3 nor = vec3(\n        mapScene(pos+eps.xyy,-1,false).d - mapScene(pos-eps.xyy,-1,false).d,\n        mapScene(pos+eps.yxy,-1,false).d - mapScene(pos-eps.yxy,-1,false).d,\n        mapScene(pos+eps.yyx,-1,false).d - mapScene(pos-eps.yyx,-1,false).d );\n    return normalize(nor);\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    #ifndef ENABLE_AO\n    return 1.;\n    #endif\n\n    float occ = 0.20;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = mapScene( aopos,-1,false ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ); \n}\nvec2 softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    vec2 res = vec2(1.,1.);\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        SDObject hit=mapScene( ro + rd*t ,-1,false);\n        float h = hit.d;\n        #ifdef ENABLE_TRANSPARENCY\n        if(hit.mat.type>0 && hit.mat.trans>0.)\n        {\n            res.y=min(res.y,1.-hit.mat.trans);\n        }\n        #endif\n        res.x = min( res.x, (32.0*h/t) );\n        t += clamp( h, 0.00001, 0.99999 );\n        if( h<(0.00001) || t>tmax ) break;\n    }\n    return clamp( res,1.2-res.y, 1.0 );\n\n}\n\nvec3 render(vec3 incol,vec3 col,float d)\n{\n    float aares=smoothstep(((d)), .9740, .0);\n    return clamp(mix(incol,col,aares),0.,1.);\n}\n\n#define LINE(a,b) line(p,a,b)\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n\n    return (1.0 - d);\n}\nvec3 _mainImage( in vec2 uv )\n{\n\n    return vec3(uv,0.5+0.5*sin(iTime));\n}\nvec3 hitColor(inout SDObject hit)\n{\n    Material m=hit.mat;\n    vec3 col=hit.mat.col;\n\n    if(m.type==1)\n    {\n        vec2 texm=hit.mpos.zx*.2;\n    }\n\n    if(m.type==2 )\n    {\n        if(SCREEN_POWER==1)\n        {\n            //video texture\n            vec2 ssres=hit.def.siz.xz;\n            vec2 texm=hit.def.utp.xz;\n            texm/=ssres;\n            texm/=2.;\n            texm.y=-texm.y;\n            texm+= .5;\n            #define fringe 0.015\n            col=clamp( _mainImage(texm).rgb ,0.,1.)\n                *smoothstep(0.0,fringe,texm.x)\n                *smoothstep(0.0,fringe,texm.y)\n                *smoothstep(1.,1.-fringe,texm.x)\n                *smoothstep(1.,1.-fringe,texm.y);\n        }else{\n            col=vec3(0.);\n        }\n    }\n    return col;\n}\n\nSDObject render(in vec3 bcol,out vec3 ocol,in Ray ray)\n{\n    SDObject hit=castRay(ray);\n    vec3 col=ocol;\n\n    float tamnt=LIGHT_AMOUNT;\n    if (hit.mat.type >0)\n    {\n\n        Material m=hit.mat;\n        col=hitColor(hit);\n\n        vec3 nor = calcNormal( hit.mpos );\n        vec3 ref = reflect( ray.rd, nor );\n\n        hit.nor=nor;\n\n        float occ = calcAO( hit.mpos, nor );\n        vec3 lig = normalize( vec3(-0.0, 1., 1.) );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig )*tamnt, m.emis, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-hit.mpos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y )*m.ref.amount;\n        float fre = pow( clamp(1.0+dot(nor,ray.rd),0.0,1.0), 2.0 )*m.ref.amount;\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0)*m.ref.amount;\n\n        //\tif (hit.mat.m >0)\n        // col+=rfm;\n        // shadows\n        vec3 lin = vec3(0.0);\n        #ifdef ENABLE_SHADOWS\n        {\n            vec2 difss=softshadow( hit.mpos, lig, 0.02, 2.5 );\n            dif *= mix(1.,difss.x,1.-m.emis);\n            vec2 domss=softshadow( hit.mpos, ref, 0.02, 2.5 );\n            dom *= domss.x;\n            // dom*=1.-domss.y;//1.-difss.y;\n        } \n        #endif\n        lin += 1.20*dif*mix(vec3(1.00,1.,0.75),vec3(1.),m.emis);\n        lin += 1.20*spe*vec3(1.00,1.,0.75)*dif;\n        lin += 0.20*amb*vec3(0.50,.70,1.00)*occ;\n        // lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n        // col*=1.+0.3*m.emis;\n        col = col*lin;\n\n        #ifdef ENABLE_FOG\n        col = mix( col, vec3(0.8,0.9,1.0)*0.3*tamnt, (0.9)-exp( -0.002*hit.t*hit.t ) );\n        #endif\n\n        ocol=mix(col,ocol,ray.a);\n    }else{\n        ocol=\tmix(bcol*tamnt,col,ray.a);\n\n    }\n    return hit;\n}\nRay getCamera(vec2 p,vec2 um)\n{\n    #ifdef AUTO_CAMERA\n    if(iMouse.z<0.5)\n    {\n        um=0.5+0.4*vec2(-1.25-0.5*sin(-2.8+iTime*0.6),cos(-1.18+iTime*0.3));\n    }\n    #endif\n  vec2 cr=um;\n  \n    float srat=iResolution.y/iResolution.x;\n\n    cr.x=cr.x+.45;\n    float flip=0.5-0.5*cos(remap(cr.y,0.3,0.7,0.,1.,true)*PI);\n\n \n    //camera\n    #define CENTER_CAM vec3(0.,1.95,2.45)\n    vec3 cam=vec3(0.,0.4*(1.-2.*flip),3.2);\n    vec3 ro = cam*2.5;//vec3(0.,.95,.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rdc= normalize(vec3(p ,-1.5));\n\n    mat2 mx = mm2(flip*\tPI); \n    mat2 mz = mm2(PI*2.*(-cr.x*srat)-PI*0.5);\n    mat2 my = mm2(PI*cr.y); \n\n    rd.xy*=mx;\n\n    ro.zy *= my;rd.zy *= my;\n    ro.zx *= mz;rd.zx *= mz;\n\n    rdc.zy*=my;\n    rdc.zx*=mz;\n\n    return newRay(ro,rd);\n\n}\nvec3 globalImage( in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 um = iMouse.xy / iResolution.xy;\n    float srat=iResolution.y/iResolution.x;\n\n    um.x /= srat; p.x/=srat;\n\n    Ray ray=getCamera(p,um);\n\n    vec3 ocol,col=vec3(0.);\n #define BACKGROUND ((vec3(0.1, 0.2, .30)+ray.rd.y*-0.8)*LIGHT_AMOUNT)    \n    vec3 bcol = BACKGROUND ;\n    \n    bcol*=LIGHT_AMOUNT;\n    SDObject o=render(bcol,col,ray);\n    float tr=0.;\n    #ifdef ENABLE_TRANSPARENCY\n    {\n        SDObject bob;\n        Ray rob;\n\n        SDObject tob=o;\n        Ray tray=ray;\n\n        o.mat.trans=0.;\n                for(int ti=0;ti<5;ti++)\n        {\n            tr=tob.mat.trans;\n\n            \n           \n//            col=mix(col,bacol,tr);\n\n            if(tr>0.) \n            {\n                tray.id=tob.id;\n                vec3 tcol=vec3(0.);\n                //i have no idea what i'm doing\n                tray.rd=refract(tray.rd,(2.*tob.nor)-bob.nor,1.1);\n                //     tray.rd=-refract(rob.rd,bob.nor,1.5);\n                tray.ro=tob.mpos;\n                tob=render(((vec3(0.1, 0.2, .30)+tray.rd.y*-0.8)*LIGHT_AMOUNT)   ,tcol,tray);\n                col=mix(col,tcol,tr);\n            }\n                        else break;\n        }\n    }\n    #endif\n    ocol=col;\n    float refval=1.0 ;//.25;\n    vec3 rcol=vec3(1.,1.,1.);\n    #ifdef MAX_REFLECT_BOUNCES\n    for(int i=0;i<MAX_REFLECT_BOUNCES;i++)\n    {\n        float cref=o.mat.ref.amount;\n        rcol*=mix(vec3(1.),o.mat.col*cref,o.mat.ref.chromacity);\n        if(cref==0.) break;\n        refval*=cref+0.12;\n        col=vec3(0.);\n        ray=newRay(o.mpos,reflect(ray.rd,o.nor*(1.+0.03*(1.-smoothstep(0.,.7,o.mat.ref.amount))*rand(o.mpos.xy*1000.))));\n        o=render(bcol,col,ray);\n\n        ocol+=(1.-tr)*clamp(((col/float(i+1))*(refval*(1.+.35*o.mat.emis)))*rcol,0.,1.)*(1.-cref);\n    }\n    #endif\n\n    return ocol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(globalImage(fragCoord),1.);\n}\n\n\n#ifndef SHADERTOY\nvoid main(){mainImage(gl_FragColor,gl_FragCoord.xy);}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 806, 886, 886, 1003], [1004, 1004, 1060, 1060, 1100], [1101, 1101, 1127, 1127, 1183], [1184, 1184, 1205, 1205, 1245], [1338, 1338, 1365, 1365, 1524], [1526, 1526, 1557, 1557, 1668], [1670, 1670, 1691, 1691, 1743], [1745, 1745, 1769, 1769, 1782], [1783, 1783, 1813, 1813, 1848], [1849, 1849, 1879, 1879, 1961], [1962, 1962, 1996, 1996, 2017], [2415, 2415, 2443, 2443, 2519], [2690, 2690, 2744, 2744, 2798], [2799, 2799, 2859, 2859, 2930], [2932, 2932, 2965, 2965, 3079], [3080, 3080, 3123, 3147, 3204], [3207, 3207, 3246, 3326, 3563], [3564, 3564, 3643, 3643, 4475], [4476, 4476, 4524, 4524, 5573], [5628, 5628, 5660, 5660, 6162], [6164, 6164, 6196, 6196, 6519], [6520, 6520, 6562, 6562, 6924], [6925, 6925, 6998, 6998, 7501], [7503, 7503, 7545, 7545, 7639], [7672, 7672, 7719, 7719, 7877], [7878, 7878, 7909, 7909, 7952], [7953, 7953, 7988, 7988, 8723], [8725, 8725, 8781, 8781, 10639], [10640, 10640, 10671, 10671, 11425], [11426, 11426, 11465, 11465, 13358], [13360, 13360, 13417, 13417, 13466]], "test": "untested"}
{"id": "XdyGz3", "name": "iq's eyeball", "author": "rswinkle", "description": "Implementation of iq's eyeball demo (and Beautypi icon) from this youtube video https://www.youtube.com/watch?v=emjuqqyq_qc", "tags": ["2d", "noise"], "likes": 10, "viewed": 988, "published": "Public API", "date": "1455499602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//alternative noise implementation\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\n\n\nmat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n\nfloat fbm(in vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*noise(p); p*=m*2.02;\n    f += 0.2500*noise(p); p*=m*2.03;\n    f += 0.1250*noise(p); p*=m*2.01;\n    f += 0.0625*noise(p); p*=m*2.04;\n    f /= 0.9375;\n    return f;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    \n    //p.x -= 0.75;\n    \n    float r = sqrt(dot(p, p));\n    float a = atan(p.y, p.x);\n    \n    //change this to whatever you want the background\n    //color to be\n    vec3 bg_col = vec3(1.0);\n    \n    vec3 col = bg_col;\n    \n    float ss = 0.5 + 0.5*sin(iTime);\n\tfloat anim = 1.0 + 0.1*ss*clamp(1.0-r, 0.0, 1.0);\n\tr *= anim;\n\n    if (r < 0.8) {\n        col = vec3(0.0, 0.3, 0.4);\n\n        float f = fbm(5.0*p);\n        col = mix(col, vec3(0.2, 0.5, 0.4), f);\n\n\t\tf = 1.0 - smoothstep(0.2, 0.5, r);\n\t\tcol = mix(col, vec3(0.9, 0.6, 0.2), f);\n\n\t\ta += 0.05*fbm(20.0*p);\n\n\t\tf = smoothstep(0.3, 1.0, fbm(vec2(6.0*r, 20.0*a)));\n\t\tcol = mix(col, vec3(1.0), f);\n\n\t\tf = smoothstep(0.4, 0.9, fbm(vec2(10.0*r, 15.0*a)));\n\t\tcol *= 1.0 - 0.5*f;\n\n\t\tf = smoothstep(0.6, 0.8, r);\n\t\tcol *= 1.0 - 0.5*f;\n\n\t\tf = smoothstep(0.2, 0.25, r);\n\t\tcol *= f;\n\n\n\t\tf = 1.0 - smoothstep(0.0, 0.3, length(p - vec2(0.24, 0.2)));\n\t\tcol += vec3(1.0, 0.9, 0.8)*f*0.8;\n\n\n\t\tf = smoothstep(0.75, 0.8, r);\n\t\tcol = mix(col, bg_col, f);\n    }\n    \n\n        \n    \n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 37, 60, 60, 102], [104, 104, 130, 130, 336], [377, 377, 399, 399, 599], [605, 605, 662, 662, 1826]], "test": "untested"}
{"id": "XsG3Dc", "name": "wood texture", "author": "randomekek", "description": "an attempt at planks of wood", "tags": ["2d", "noise", "texture"], "likes": 31, "viewed": 1718, "published": "Public API", "date": "1456655797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// basically draw contours of a height field.\n// making a realistic texture is not easy!\n\nconst float knobStrength = 2.0;\nconst float pixelsPerPlank = 100.0;\nconst float linesPerPlank = 5.5;\nconst float verticalScale = 6.0;\nconst float lineStrength = 0.8;\nconst float plankLength = 6.0;\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res;\n}\n\nfloat noisetex(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\treturn texture( iChannel0, (p + f + 0.5)/256.0, -100.0 ).x;\n}\n\nfloat height(in vec2 a) {\n    a = a*vec2(1.0, 1.0/verticalScale);\n    return linesPerPlank * (knobStrength*noise(a) + a.x);\n}\n\n// make the lines constant width\n// http://iquilezles.org/www/articles/distance/distance.htm\nvec2 grad(in vec2 x) {\n\tvec2 h = vec2(0.05, 0.0);\n\treturn vec2(height(x+h.xy) - height(x-h.xy),\n                height(x+h.yx) - height(x-h.yx))/(2.0*h.x);\n}\n\nvec4 composit(in vec4 top, in vec4 bottom) {\n    return vec4(mix(top.xyz, bottom.xyz, 1.0-top.a), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //animation\n    fragCoord.y += iTime * 100.;\n    \n    vec2 pixel = fragCoord / pixelsPerPlank;\n    float plank = floor(pixel.x); // unique per plank\n    float start = 15.0 * rand(vec2(plank));\n    float item = floor(pixel.y/plankLength + start);\n    \n    vec3 woodLine = vec3(90., 45., 18.)/255.;\n    vec2 plankPixel = pixel + vec2(124., 11.) * plank;\n    float value = height(plankPixel + item);\n    vec2 gradient = grad(plankPixel + item);\n    float linePos = 1.0 - smoothstep(0.0, 0.08, fract(value)/length(gradient));\n    float line = floor(value); // unique per line\n    float lineWeight = mix(1.0, 0.4+rand(vec2(line,plank)), 0.8);\n    float lineGrain = smoothstep(-0.2, 0.9, noisetex(fragCoord));\n    \n    vec3 woodBase = vec3(144., 91., 49.)/255.;\n    float darkness = mix(1.0, 0.5+rand(vec2(plank, item)), 0.2);\n    float grain = mix(1.0, 0.5 + 0.7*noisetex(fragCoord + 12.5), 0.1);\n    \n    float plankGapY = step(0.0, fract(pixel.x)) * (1.0-step(0.02, fract(pixel.x)));\n    float plankGapX = step(0.0, fract(pixel.y/plankLength+start)) * (1.0-step(0.02/plankLength, fract(pixel.y/plankLength+start)));\n   \n    // final images\n    vec4 planks = vec4(0.1, 0.1, 0.1, max(plankGapY, plankGapX));\n    vec4 lines = vec4(woodLine, lineStrength*lineWeight*lineGrain*linePos);\n    vec4 wood = vec4(woodBase*darkness*grain, 1.0);\n    \n    fragColor = composit(planks, composit(lines, wood));\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsG3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 288, 308, 308, 378], [380, 380, 400, 400, 631], [633, 633, 660, 660, 791], [793, 793, 818, 818, 918], [920, 1013, 1035, 1035, 1170], [1172, 1172, 1216, 1216, 1277], [1279, 1279, 1334, 1350, 2733]], "test": "untested"}
{"id": "XsG3Rc", "name": "testfarbe", "author": "cardmechanic", "description": "test", "tags": ["farbe"], "likes": 0, "viewed": 75, "published": "Public", "date": "1455550699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Rect {\n\tvec2 pos,\n         ext;\n    mat2 kord;\n    vec4 col;\n\n};\n\n    \nRect D1 = Rect ( vec2(-.45+.5*cos(iTime),-.6+.5*sin(iTime)), vec2 (1.23,1.23), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.)),\n     R1 = Rect ( vec2(-.2+.5*cos(iTime),.2+.5*sin(iTime)), vec2 (.6,.6), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.)),\n     R2 = Rect ( vec2(-.2,.2), vec2 (.6,.6), mat2 (1.,0.,0.,1.), vec4 (9,.99,.80,2.));\n     \n\n\n\n\nmat2 Rota (in float alpha){\n\tfloat s = sin(alpha),\n          c = cos(alpha);\n    \n   return mat2 (c, -s, s, c);\n\n}\n\nvoid Rotarect (in float alpha, inout Rect r_p){\n    \n    r_p.kord = Rota (alpha) * r_p.kord;\n\n\n}\n\n\n\n\n\nvec4 intersec (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n    \n    if ( abs(mat.x) >.5*reco.ext.x && abs(mat.y) >.5*reco.ext.y){\n        return vec4 (0.);\n    \t}\n        if (mat.x*mat.x+mat.y*mat.y <.135 && mat.y > -0.2)\n        return reco.col;\n    \t\n    return vec4(.0);\n\n}\n\nvec4 intersecD (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n    \n    if ( abs(mat.x) >.5*reco.ext.x || abs(mat.y) >.5*reco.ext.y){\n        return vec4 (0.);\n    \t}\n        if (abs(1.65*mat.x)*reco.ext.x + mat.y*reco.ext.y >.4)\n        return vec4(.0);\n    \t\n    return reco.col;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy / iResolution.xy-.5)*(iResolution.x/iResolution.y,1.);\n\tfragColor = vec4(.5,.25,.75,.1);\n\n\tRotarect (iTime, R1);\n    Rotarect (iTime, R2);\n    Rotarect (iTime+3.14, D1);\n    \n \n        \n    vec4 r1col = intersec (uv,R1);\n    vec4 r2col = intersec (uv,R2);\n\tvec4 r3col = intersecD (uv,D1);\n    float col = r1col.a + r2col.a +r3col.a;\n    \n    if (col > 3.){\n        fragColor = vec4(.9,.99,.80,4.); }\n    \n    else\n        \n    \tif (col >1. && col <3.)\n       \n        fragColor = vec4(.9,.99,.80,4.);\n    \n   \t\t else\n        fragColor = vec4(.5,.25,.75,.1);\n\n    \n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsG3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 413, 440, 440, 527], [529, 529, 576, 576, 625], [631, 631, 674, 674, 957], [959, 959, 1003, 1003, 1290], [1294, 1294, 1351, 1351, 1946]], "test": "untested"}
{"id": "XsG3WD", "name": "dark donuts", "author": "abje", "description": "raymarching donuts\nby the way if you wonder why you don't see artifacts it is because you see it from the best angle (look at surrounding donuts)", "tags": ["wobbly", "dark", "donuts"], "likes": 2, "viewed": 372, "published": "Public API", "date": "1454420367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = acos(0.0);\n\nfloat donut(vec3 pos) {\n    \n    float rot = atan(pos.x,pos.y)*floor(iTime);\n    \n    vec2 pos2 = vec2(length(pos.xy)-sin(rot)*0.1-1.0,pos.z-cos(rot)*0.1);\n    \n    float len = length(pos2);\n    \n    rot = atan(pos.x,pos.y)*ceil(iTime);\n    \n    pos2 = vec2(length(pos.xy)-sin(rot)*0.1-1.0,pos.z-cos(rot)*0.1);\n    \n    return mix(len,length(pos2),fract(iTime));\n}\n\nfloat map(vec3 pos) {\n    vec3 pos2 = mod(pos+2.5,5.0)-2.5;\n    vec3 pos3 = pos-pos2;\n    return donut(pos2)-0.1;\n}\n\nvec3 calcNormal(vec3 pos, float len) {\n    vec2 eps = vec2(0.001,0.0);\n    vec3 nor = vec3(\n        len-map(pos-eps.xyy),\n        len-map(pos-eps.yxy),\n        len-map(pos-eps.yyx)\n    );\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n\tvec2 uv = (fragCoord.xy*2.0-iResolution.xy)/ iResolution.y;\n    \n    vec3 rayorig = vec3(0.01,0.01,mod(iTime,5.0));\n    vec3 raypos = rayorig;\n    vec3 raydir = normalize(vec3(uv, 2.0));\n    raypos += raydir*0.5;\n    \n    float dist = 0.0;\n    float len = 0.0;\n    \n    for (float i = 0.0; i < 1000.0; i++) {\n        len = map(raypos);\n        if ( len < 0.01 || dist > 20.0 ) {\n            break;\n        }\n        dist += len;\n        raypos += raydir*len;\n        \n    }\n    \n    if (len < 0.01) {\n        fragColor = vec4(abs(calcNormal(raypos, len))*(1.0-dist*0.05),1.0);\n    }\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsG3WD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 52, 52, 393], [395, 395, 416, 416, 510], [512, 512, 550, 550, 728], [730, 730, 787, 787, 1432]], "test": "untested"}
{"id": "XsG3WV", "name": "Distance shapes morphing", "author": "Andre", "description": "A collection of 2D shape formulas and morphing between them", "tags": ["2d", "distancefield", "numbers", "shapes"], "likes": 27, "viewed": 453, "published": "Public", "date": "1456578893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float heart(vec2 i) {\n    // From: https://www.shadertoy.com/view/ldVGzt by coyote & Fabrice\n    i.y += .034;\n    i *= 1.1;\n    return sqrt(dot(i, i) - abs(i.x)*i.y);\n}\n\nfloat diamond(vec2 i) {\n    i = abs(i);\n    return (i.x+i.y);\n}\n\nfloat square(vec2 i) {\n    i = abs(i);\n    return max(i.x,i.y);\n}\n\nfloat circle(vec2 i) {\n    return length(i);\n}\n\nfloat circle2(vec2 i) {\n    \n    return length(vec2(abs(length(i)-.5),max(0.,abs(atan(i.x,i.y))/2.-sin(iTime)-.7)))+.35;\n   //return length(vec2(abs(length(i)-.5),1.3-2.*atan(i.x,i.y)))+.35;\n}\n\nfloat honeycomb(vec2 i) {\n    i.x*=.866;\n    i = abs(i);\n    return max(i.x+i.y*.5,i.y);\n}\n\nfloat segment(vec2 uv)\n{\n    uv = abs(uv);\n\tfloat f = max(0.45+uv.x,0.225+uv.y+uv.x);\n    return f;\n}\n\nfloat m(float a, float b)\n{\n    return min(a,b);\n    //return 1./(1./a+1./b);\n    //return length(vec2(a,b));\n}\n\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 5.0;\n\tseg = (num!=-1 && num!=1 && num!=4                    ?m(segment(uv.yx+vec2(-0.450, 0.000)),seg):seg);\n\tseg = (num!=-1 && num!=1 && num!=2 && num!=3 && num!=7?m(segment(uv.xy+vec2( 0.225,-0.225)),seg):seg);\n\tseg = (num!=-1 && num!=5 && num!=6                    ?m(segment(uv.xy+vec2(-0.225,-0.225)),seg):seg);\n\tseg = (num!=-1 && num!=0 && num!=1 && num!=7          ?m(segment(uv.yx+vec2( 0.000, 0.000)),seg):seg);\n\tseg = (num==0 || num==2 || num==6 || num==8           ?m(segment(uv.xy+vec2( 0.225, 0.225)),seg):seg);\n\tseg = (num!=-1 && num!=2                              ?m(segment(uv.xy+vec2(-0.225, 0.225)),seg):seg);\n\tseg = (num!=-1 && num!=1 && num!=4 && num!=7          ?m(segment(uv.yx+vec2( 0.450, 0.000)),seg):seg);\n\t\n\treturn seg;\n}\n\nvec2 rotate(vec2 i,float a) {\n   return i *mat2(cos(a), -sin(a),\n                  sin(a), cos(a));\n}\n\nfloat getShape(int nr, vec2 uv) {\n    \n    //return circle2(uv);\n        \n    bool outline = false;\n    if (nr<10)\n        return sevenSegment(uv,nr);\n    else {\n        outline = (nr>=15);\n        nr = int(mod(float(nr),5.));\n    }\n\n    float x = 0.0;\n    if (nr==0) x = heart    (uv); else\n    if (nr==1) x = diamond  (uv); else\n    if (nr==2) x = square   (uv); else\n    if (nr==3) x = circle   (uv); else\n               x = honeycomb(uv);\n        \n    return outline ? 0.45+abs(x-.5) : x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y *1.1;\n    \n    //uv = rotate(uv,iTime);\n    \n    float gt = iTime;\n    int shapeNr1 = int(mod(gt    ,20.0));\n    int shapeNr2 = int(mod(gt+1.0,20.0));\n    float mixPerc = mod(gt, 1.0);\n    \n    // Start morph in the middle\n    mixPerc = smoothstep(0.2,0.8,mixPerc);\n    \n    // Add bounce to morph\n    mixPerc = sin(pow(mixPerc,2.5)*2.2)/sin(2.2);\n    \n    // Linear mix\n    //float x = mix(getShape(shapeNr1,uv),\n    //              getShape(shapeNr2,uv),\n    //              mixPerc);\n    \n    // Alternate mix\n    float x = 1.0/mix(1.0/getShape(shapeNr1,uv),\n                      1.0/getShape(shapeNr2,uv),\n                      mixPerc);\n                      \n\tvec3 clr = vec3(0.0);\n    \n    float px2 = 2.0/iResolution.y;\n    // distance lines\n    clr.g = 0.6-0.6*smoothstep( 0.0,\n                                px2,\n                                abs(mod(x-.001,.05)-0.025));\n    // shape\n    clr.b = 1.0-smoothstep(0.5,\n                           0.5+px2,\n                           x);\n    if (iMouse.w>0.) {\n    \tclr.r = 0.7-0.7*smoothstep(0.49,0.49+px2, x); // The numbers\n    \tclr.g = 0.7-0.7*smoothstep(0.00,px2, abs(x-0.49)); // Yellow outline\n    \tclr.b = 0.4-0.4*smoothstep(0.43,0.53,1.0-x); // Background with shadow\n    \tclr.rg += 0.12-0.12*smoothstep(0.00,0.04, abs(x-0.49)); // Yellow glow\n    \tclr += 0.12-0.12*smoothstep(0.40,0.50, x); // Stretchmarks\n    \tclr -= clr.b*(1.0- smoothstep( 0.0,\n                                   px2,\n                                   abs(mod(x-.001,.05)-0.025)));\n    }\n    \n    fragColor = vec4(clamp(clr,0.0,1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsG3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 92, 168], [170, 170, 193, 193, 233], [235, 235, 257, 257, 300], [302, 302, 324, 324, 348], [350, 350, 373, 373, 542], [544, 544, 569, 569, 634], [636, 636, 660, 660, 737], [739, 739, 766, 766, 850], [852, 852, 889, 889, 1651], [1653, 1653, 1682, 1682, 1754], [1756, 1756, 1789, 1820, 2250], [2252, 2252, 2309, 2309, 3949]], "test": "untested"}
{"id": "XsG3zc", "name": "Heart Broken ", "author": "DeMaCia", "description": "Heart Broken ", "tags": ["formula2d"], "likes": 1, "viewed": 563, "published": "Public API", "date": "1455546540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = uv*10. - 5.;\n    \n    \n    pos.y *= 0.8;\n    pos.y += 0.2;\n    \n    //complete\n    //float value = 17. * pos.x * pos.x - \n        //16. * abs(pos.x) * pos.y + \n        //17. * pos.y * pos.y  + 100.;\n    \n    float value = 17. * pos.x * pos.x - \n        16. * abs(pos.x) * pos.y + \n        17. * pos.y * pos.y  + \n        150.*abs(sin(iTime) + 1.)/(abs(5. * pos.x + sin(5.*pos.y))); \n    \n    value = 225. - value;\n    \n    \n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0)*\n        smoothstep(0.,10.,value);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsG3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 60, 60, 633]], "test": "untested"}
{"id": "XsGGW3", "name": "Morphing numbers", "author": "Andre", "description": "Morphing numbers with auto centering. Adjust speed with mouse X.", "tags": ["2d", "distancefield", "motionblur", "numbers", "digits"], "likes": 27, "viewed": 550, "published": "Public", "date": "1456659766", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float lineWidth;\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n//Numbers\nfloat _11(vec2 uv) {\n    return min(min(\n             line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n             \n}\nfloat _22(vec2 uv) {\n    float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\nfloat segment(vec2 uv)\n{\n    uv = abs(uv);\n    \n    //Round edges\n    uv.y = max(uv.y-0.225, 0.);\n\tfloat f = length(uv)+.43;\n    \n    //Bevel edges\n\t//float f = max(0.45+uv.x,0.225+uv.y+uv.x);\n    return f;\n}\n\nfloat sevenSegment(vec2 uv,int num)\n{\n    if (iMouse.w>0.) {\n        uv.y+=.1;\n        uv.y/=.95;\n        if (num==0) return _00(uv)+.43;\n        if (num==1) return _11(uv)+.43;\n        if (num==2) return _22(uv)+.43;\n        if (num==3) return _33(uv)+.43;\n        if (num==4) return _44(uv)+.43;\n        if (num==5) return _55(uv)+.43;\n        if (num==6) return _66(uv)+.43;\n        if (num==7) return _77(uv)+.43;\n        if (num==8) return _88(uv)+.43;\n        if (num==9) return _99(uv)+.43;\n    }\n        \n\tfloat seg= 5.0;\n\tseg = (num!=-1 && num!=1 && num!=4                    ?min(segment(uv.yx+vec2(-0.450, 0.000)),seg):seg);\n\tseg = (num!=-1 && num!=1 && num!=2 && num!=3 && num!=7?min(segment(uv.xy+vec2( 0.225,-0.225)),seg):seg);\n\tseg = (num!=-1 && num!=5 && num!=6                    ?min(segment(uv.xy+vec2(-0.225,-0.225)),seg):seg);\n\tseg = (num!=-1 && num!=0 && num!=1 && num!=7          ?min(segment(uv.yx+vec2( 0.000, 0.000)),seg):seg);\n\tseg = (num==0 || num==2 || num==6 || num==8           ?min(segment(uv.xy+vec2( 0.225, 0.225)),seg):seg);\n\tseg = (num!=-1 && num!=2                              ?min(segment(uv.xy+vec2(-0.225, 0.225)),seg):seg);\n\tseg = (num!=-1 && num!=1 && num!=4 && num!=7          ?min(segment(uv.yx+vec2( 0.450, 0.000)),seg):seg);\n\t\n\treturn seg;\n}\n\nfloat sevenSegmentFloat(vec2 uv, float num, float digit) {\n    float start = 1.0-.9/pow(9.,digit);\n    float m = smoothstep(start,1.0,fract(num));\n    if (m<0.01)\n        return sevenSegment(uv,int(num));\n    else {\n        //uv *= 1.0+0.08*sin(m*3.14);\n        float s1 = sevenSegment(uv,int(num));\n    \tfloat s2 = sevenSegment(uv,int(mod(num+1.0,10.)));\n        //s1 -= m*.1;\n        //s2 -= (1.0-m)*.1;\n        m = sin(pow(m,1.5)*2.035)/sin(2.035);\n    \treturn 1.0/mix(1.0/s1, 1.0/s2, m);\n    }\n}\n\nfloat curveFract(float x) {\n    float f = fract(x);\n    f = 1.0-cos(f*3.1416);\n    return floor(x)+f*.4999;\n}\n\nfloat log10 = log(10.0);\nfloat showNum(vec2 uv,float nr, bool zeroTrim)\n{\n    bool neg = nr<0.0;\n    if (neg) nr *= -1.;\n    \n    float digitCount = max(1.0,log(nr)/log10+.000001+1.0);\n\tfloat seg= 5.0;\n    \n    // Center number\n    float dc = curveFract(digitCount)-0.5;\n                // Attempt to center one +0.5*smoothstep(0.0,2.0,nr / pow(10.,floor(digitCount)-1.0));\n    uv *= (4.+dc)*.25;\n    uv.x -= dc * .375 + uv.y * 0.07;\n    \n    digitCount = floor(digitCount);\n\tif (uv.x>-5.25 && uv.x<0.0 && abs(uv.y)<0.75)\n\t{\n        float digit = floor(-uv.x / .75);\n\t\tnr /= pow(10.,digit);\n        nr = mod(nr,10.0);\n        if (neg && digit==digitCount)\n            nr = -2.;\n        else\n\t\t    if (floor(nr)<=0. && zeroTrim && digit>=digitCount && digit!=0.0)\n\t\t\t    nr = -1.0;\n\t\tseg = sevenSegmentFloat(uv+vec2( 0.375 + digit*.75,0.0),nr,digit);\n    }\n\treturn seg;\n}\n\nvec3 getFrameColor(vec2 uv, float gt) {\n    float nr = showNum(uv,gt*(10.-9.8*iMouse.x/iResolution.x),true);\n    //float nr = showNum(uv,gt,true);\n    \n\tvec3 clr = vec3(0.0);\n    clr.g = 0.8-0.8*smoothstep(lineWidth*.5,lineWidth*1.5, abs(nr-0.49)); // Yellow outline\n    clr.r = 0.8-0.8*smoothstep(0.49,0.49+lineWidth, nr); // The numbers\n    clr.b += 0.4-0.4*smoothstep(0.45,0.52,1.0-nr); // Background with shadow\n    clr.rg += 0.25-0.25*pow(smoothstep(0.00,0.1, abs(nr-0.49)),0.25); // Yellow glow\n    clr += 0.12-0.12*smoothstep(0.40,0.45, nr); // Stretchmarks\n    return clamp(clr,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lineWidth = 6.0/iResolution.x;\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n    \n    //float gt = 200.+iMouse.x*0.1;//iTime;\n    float gt = iTime;\n    vec3 clr = vec3(0.0);\n    \n    for (float i = 0.0; i < 16.0; i += 1.0)\n        clr += pow(getFrameColor(uv, gt+i/500.),vec3(2.))*(i+1.0);\n    fragColor = vec4(pow(clr/136.,vec3(1.0/2.)),1.0);\n\n/*    \n    for (float i = 0.0; i < 16.0; i += 1.0)\n        clr += getFrameColor(uv, gt+i/500.)*(i+1.0);\n    fragColor = vec4(clr/136.,1.0);\n*/    \n    //fragColor = vec4(getFrameColor(uv, gt),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 54, 54, 179], [181, 191, 211, 211, 415], [416, 416, 436, 436, 709], [710, 710, 730, 730, 904], [905, 905, 925, 925, 1115], [1116, 1116, 1136, 1136, 1488], [1489, 1489, 1509, 1509, 1804], [1805, 1805, 1825, 1825, 1946], [1947, 1947, 1967, 1967, 2129], [2130, 2130, 2150, 2150, 2431], [2432, 2432, 2452, 2452, 2530], [2532, 2532, 2556, 2556, 2740], [2742, 2742, 2779, 2779, 4030], [4032, 4032, 4090, 4090, 4531], [4533, 4533, 4560, 4560, 4642], [4669, 4669, 4717, 4717, 5514], [5516, 5516, 5555, 5555, 6113], [6115, 6115, 6172, 6172, 6737]], "test": "untested"}
{"id": "XsK3Dy", "name": "hmas", "author": "cardmechanic", "description": "hm", "tags": ["hmh"], "likes": 0, "viewed": 81, "published": "Public", "date": "1456233058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Rect {\n\tvec2 pos,\n         ext;\n    mat2 kord;\n    vec4 col;\n\n};\n\n    \nRect \n     R1 = Rect ( vec2(.0,.5-4.*(iTime*iTime)), vec2 (1.,1.), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.));\n \n\n\n\nmat2 Rota (in float alpha){\n\tfloat s = sin(alpha),\n          c = cos(alpha);\n    \n   return mat2 (c, -s, s, c);\n\n}\n\n\nvoid Rotarect (in float alpha, inout Rect r_p){\n    \n    r_p.kord = Rota (alpha) * r_p.kord;\n\n\n}\n\n\n\nvec4 intersec (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n\t\n    if ( abs(mat.x) >.5*reco.ext.x || abs(mat.y) >.5*reco.ext.y){\n        return vec4 (0.);\n    }\n    \t\n    \tif (mat.x*mat.x*reco.ext.x +mat.y*mat.y*reco.ext.y <.025)\n    \treturn reco.col;\n    \n    \n    return vec4(0.);\n        \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.xy-0.5)*vec2 ( iResolution.x/iResolution.y, 1.);\n\tfragColor = vec4(0.);\n\n\tRotarect (iTime, R1);\n    \n\tif (R1.pos.y <-.3)\n        R1.pos.y = -.3+(4./(3.*iTime+.5))*(iTime-.5);\n    \n        \n    vec4 r1col = intersec (uv,R1) ;\n    if (r1col.a < 1.){\n        fragColor = vec4(.5,.25,.75,.1);}\n    else   \n   fragColor = intersec (uv,R1) ;\n    \n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsK3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 220, 220, 307], [310, 310, 357, 357, 406], [410, 410, 453, 453, 751], [754, 754, 811, 811, 1197]], "test": "untested"}
{"id": "XsK3R3", "name": "Sneak Preview", "author": "dr2", "description": "When the fog clears you will see a model of the latest roller-coaster; perhaps you will be able to take a ride soon.\n", "tags": ["fog", "rollercoaster"], "likes": 20, "viewed": 5765, "published": "Public API", "date": "1455622497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Sneak Preview\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\nWhen the fog clears you will see a model of the latest roller-coaster; perhaps you\nwill be able to take a ride soon.\n*/\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 ip = floor (p);\n  vec2 fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  vec4 t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRnd2BoxDf (vec3 p, vec3 b, float r)\n{\n  vec3 d = abs (p) - b;\n  return max (length (max (d.xz, 0.)) - r, d.y);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  p.z -= h * clamp (p.z / h, -1., 1.);\n  return length (p) - r;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nmat3 AxToRMat (vec3 vz, vec3 vy)\n{\n  vec3 vx;\n  vz = normalize (vz);\n  vx = normalize (cross (vy, vz));\n  vy = cross (vz, vx);\n  return mat3 (vec3 (vx.x, vy.x, vz.x), vec3 (vx.y, vy.y, vz.y),\n     vec3 (vx.z, vy.z, vz.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\n#define NCAR 5\n\nmat3 carMat[NCAR];\nvec3 cp[12], carPos[NCAR], cOrg, oPos, cUpCurve, cDnCurve, sunDir, qHit, qnHit,\n   ballPos, noiseDisp;\nfloat cLen[13], tCur, dstFar, hTop, rLoop, lenLoop, hzRamp, rDnCurve,\n   rUpCurve, rampDn, rampUp, lenStr, hTrk, wTrk, tWait, vFast, vfLoop, ballRad;\nint idObj;\nconst int nCar = NCAR;\nconst vec4 uVec = vec4 (1., 1., 1., 0.);\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  return vec3 (0.5) * max ((1. - 1.5 * abs (rd.y)), 0.);\n}\n\nvoid TrkSetup ()\n{\n  cOrg = vec3 (2., 0., -3.);\n  hTop = 1.5;\n  rLoop = 2.2;\n  lenLoop = 0.3;\n  hzRamp = 0.5;\n  rDnCurve = 2.;\n  rUpCurve = rDnCurve + lenLoop;\n  rampDn = 1.5;\n  rampUp = 1.3 * rampDn;\n  lenStr = rampDn - rampUp + 3. * hzRamp;\n  wTrk = 0.03;\n  hTrk = 0.05;\n  tWait = 2.;\n  vFast = 3.;\n  vfLoop = 0.6;\n  cDnCurve = cOrg + vec3 (- rDnCurve - lenLoop, 0., -2. * hzRamp);\n  cUpCurve = cOrg + vec3 (- rUpCurve + lenLoop, 2. * hTop, 2. * rampDn +\n     6. * hzRamp);\n  cp[0] = cDnCurve + vec3 (- rDnCurve, 0., lenStr);\n  cp[1] = cp[0] + lenStr * uVec.wwz;\n  cp[3] = cUpCurve - rUpCurve * uVec.xww;\n  cp[4] = cUpCurve + rUpCurve * uVec.xww;\n  cp[2] = cp[3] - 2. * hzRamp * uVec.wwz;\n  cp[5] = cp[4] - 2. * hzRamp * uVec.wwz;\n  cp[7] = cOrg + lenLoop * uVec.xww;\n  cp[8] = cOrg - lenLoop * uVec.xww;\n  cp[6] = cp[7] + 4. * hzRamp * uVec.wwz;\n  cp[9] = cDnCurve + rDnCurve * uVec.xww;\n  cp[10] = cDnCurve - rDnCurve * uVec.xww;\n  cp[11] = cp[0];\n  cLen[0] = 0.;\n  for (int k = 1; k <= 11; k ++) cLen[k] = length (cp[k] - cp[k - 1]);\n  cLen[4] = pi * rUpCurve;\n  cLen[8] = length (vec2 (2. * pi * rLoop, 2. * lenLoop)) * (1. + vfLoop);\n  cLen[10] = pi * rDnCurve;\n  for (int k = 6; k <= 10; k ++) cLen[k] /= vFast;\n  for (int k = 1; k <= 11; k ++) cLen[k] += cLen[k - 1];\n  cLen[12] = cLen[11] + tWait;\n}\n\nvec3 TrkPath (float t, out vec3 oDir, out vec3 oNorm)\n{\n  vec3 p, p1, p2, u;\n  float w, a, s;\n  int ik;\n  t = mod (t, cLen[12]);\n  ik = -1;\n  for (int k = 1; k <= 11; k ++) {\n    if (t < cLen[k]) {\n      t -= cLen[k - 1];\n      p1 = cp[k - 1];\n      p2 = cp[k];\n      w = cLen[k] - cLen[k - 1];\n      ik = k;\n      break;\n    }\n  }\n  oNorm = vec3 (0., 1., 0.);\n  if (ik < 0) {\n    p = cp[0];\n    oDir = vec3 (0., 0., 1.);\n  } else if (ik == 2 || ik == 6) {\n    oDir = p2 - p1;\n    p.xz = p1.xz + oDir.xz * t / w;\n    p.y = p1.y + oDir.y * smoothstep (0., 1., t / w);\n    oDir.xz /= w;\n    oDir.y *= 6. * (t  / w) * (1. - t / w) / w;\n    oDir = normalize (oDir);\n  } else if (ik == 4) {\n    a = pi * t / w;\n    p = cUpCurve;\n    u = vec3 (- cos (a), 0., sin (a));\n    p.xz += rUpCurve * u.xz;\n    oDir = cross (oNorm, u);\n  } else if (ik == 8) {\n    a = t / w;\n    a = (a < 0.5) ? a * (1. + vfLoop * (1. - 2. * a)) :\n       a * (1. + 2. * vfLoop * (a - 1.5)) + vfLoop;\n    p = 0.5 * (cp[7] + cp[8]);\n    p.x += lenLoop * (1. - 2. * a);\n    a = 2. * pi * a;\n    u = vec3 (0., cos (a), sin (a));\n    p.yz += rLoop * (vec2 (1., 0.) - u.yz);\n    oNorm = u;\n    oDir = normalize (vec3 (-2. * lenLoop,\n       2. * pi * rLoop * vec2 (sin (a), - cos (a))));\n  } else if (ik == 10) {\n    a = pi * t / w;\n    p = cDnCurve;\n    u = vec3 (cos (a), 0., - sin (a));\n    p.xz += rDnCurve * u.xz;\n    oDir = cross (oNorm, u);\n  } else if (ik <= 11) {\n    oDir = p2 - p1;\n    p = p1 + oDir * t / w;\n    oDir = normalize (oDir);\n  }\n  return p;\n}\n\nfloat TrkDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 trkCs, tr;\n  float d, f;\n  trkCs = vec2 (wTrk, hTrk);\n  q = p - cOrg;\n  q.y -= rLoop;\n  f = smoothstep (0., 1., atan (abs (q.z), - q.y) / pi);\n  tr = vec2 (length (q.yz) - rLoop, q.x - sign (q.z) * lenLoop * f);\n  d = min (max (max (PrBox2Df (tr - lenLoop * uVec.wy, trkCs.yx), q.z),\n     q.x - lenLoop - wTrk), max (max (PrBox2Df (tr + lenLoop * uVec.wy,\n     trkCs.yx), - q.z), - q.x - lenLoop - wTrk));\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q = p - 0.5 * (cp[5] + cp[6]);\n  f = clamp ((0.5 / rampDn) * q.z + 0.5, 0., 1.);\n  q.y -= hTop * (2. * smoothstep (0., 1., f) - 1.);\n  d = max (PrBoxDf (q, vec3 (wTrk, hTrk * (1. + 2. * abs (f * (1. - f))),\n     rampDn)), abs (q.z) - rampDn);\n  q = p - 0.5 * (cp[1] + cp[2]);\n  f = clamp ((0.5 / rampUp) * q.z + 0.5, 0., 1.);\n  q.y -= hTop * (2. * smoothstep (0., 1., f) - 1.);\n  d = min (d, max (PrBoxDf (q, vec3 (wTrk, hTrk * (1. + 2. * abs (f * (1. - f))),\n     rampUp)), abs (q.z) - rampUp));\n  d = min (d, PrBoxDf (p - 0.5 * (cp[2] + cp[3]), vec3 (trkCs, hzRamp)));\n  d = min (d, PrBoxDf (p - 0.5 * (cp[4] + cp[5]), vec3 (trkCs, hzRamp)));\n  d = min (d, PrBoxDf (p - 0.5 * (cp[6] + cp[7]), vec3 (trkCs, 2. * hzRamp)));\n  d = min (d, PrBoxDf (p - 0.5 * (cp[8] + cp[9]), vec3 (trkCs, hzRamp)));\n  d = min (d, PrBoxDf (p - 0.5 * (cp[1] + cp[10]), vec3 (trkCs, lenStr)));\n  q = p - 0.5 * (cp[9] + cp[10]);\n  d = min (max (PrBox2Df (vec2 (length (q.xz) - rDnCurve, q.y), trkCs), q.z), d);\n  q = p - 0.5 * (cp[3] + cp[4]);\n  d = min (d, max (PrBox2Df (vec2 (length (q.xz) - rUpCurve, q.y), trkCs),\n     - q.z));\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, f, colRad, szFac;\n  p.y -= -2.;\n  dMin = dstFar;\n  dMin = TrkDf (p, dMin);\n  q = p - cp[0] - 0.5 * hTrk * uVec.wyw;\n  q.x = abs (q.x) - 0.2;\n  d = PrBoxDf (q, vec3 (0.15, 0.5 * hTrk, 0.4));\n  q = p - cDnCurve + (rDnCurve - 0.1) * uVec.wwz;\n  d = min (d, max (min (PrCylAnDf (q.yzx, 0.3, 0.015, 0.6),\n     PrBoxDf (q, vec3 (0.6, 0.005, 0.3))), - q.y));\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  colRad = 0.04;\n  q = p - cUpCurve - vec3 (0., - hTop, rUpCurve);\n  d = PrCylDf (q.xzy, colRad, hTop);\n  q = p - cUpCurve - vec3 (0., - hTop, - hzRamp);\n  q.x = abs (q.x) - rUpCurve;\n  d = min (d, PrCylDf (q.xzy, colRad, hTop));\n  q = p - 0.5 * (cp[1] + cp[2]) + 0.5 * (hTop + colRad) * uVec.wyw;\n  d = min (d, PrCylDf (q.xzy, colRad, 0.5 * hTop + colRad));\n  q = p - 0.5 * (cp[5] + cp[6]) + 0.5 * hTop * uVec.wyw;\n  d = min (d, PrCylDf (q.xzy, colRad, 0.5 * hTop));\n  q = p - cOrg - (rLoop + 0.03) * uVec.wyw;\n  q.x = abs (q.x) - lenLoop - wTrk - 0.15;\n  d = min (d, PrCylDf (q.xzy, colRad, rLoop + 0.03));\n  q = p - cOrg - vec3 (0., 2. * (rLoop + 0.03), 0.);\n  d = min (d, PrCylDf (q.yzx, colRad, lenLoop + wTrk + 0.15));\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = p;\n  q.y -= -0.003;\n  d = PrRnd2BoxDf (q, vec3 (2.5, 0.002, 5.5), 1.);\n  if (d < dMin) { dMin = d;  idObj = 7; }\n  szFac = 0.8;\n  dMin *= szFac;\n  for (int k = 0; k < nCar; k ++) {\n    q = carMat[k] * (p - carPos[k]);\n    q.y -= hTrk + 0.04;\n    q *= szFac;\n    d = max (PrCapsDf (q, 0.085, 0.125),\n       - max (PrCapsDf (q + vec3 (0., -0.03, 0.), 0.08, 0.12), -0.015 - q.y));\n    if (d < dMin) { dMin = d;  idObj = 4; }\n  }\n  dMin /= szFac;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat BallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float h, b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  h = dstFar;\n  if (d >= 0.) {\n    h = - b - sqrt (d);\n    qHit = ro + h * rd;\n    qnHit = (qHit - p) / s;\n  }\n  return h;\n}\n\nfloat FrAbsf (float p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nvec3 FrAbsv3 (vec3 p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nfloat TriNoise3d (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  p *= 0.005;\n  q = p;\n  for (int j = 0; j < 5; j ++) {\n    p += FrAbsv3 (q + FrAbsv3 (q).yzx) + noiseDisp;\n    p *= 1.2;\n    f += a * (FrAbsf (p.x + FrAbsf (p.y + FrAbsf (p.z))));\n    q *= 2. * mr;\n    q += 0.21;\n    a *= 0.9;\n  }\n  return 0.1 * clamp (2. * f - 1.5, 0., 1.);\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dHit, float tRot)\n{\n  vec3 p, roo;\n  const vec3 cFog = vec3 (1.);\n  float diAx, d, b, f;\n  roo = ro;\n  ro -= ballPos;\n  ro.xz = Rot2D (ro.xz, tRot);\n  rd.xz = Rot2D (rd.xz, tRot);\n  diAx = 1. / max (0.001, length (ro - dot (rd, ro) * rd));\n  b = 0.05 * ballRad;\n  d = 0.;\n  for (int i = 0; i < 20; i ++) {\n    d += b;\n    f = smoothstep (1., 1.3, sqrt (d * (2. * ballRad - d)) * diAx);\n    p = ro + d * rd;\n    f = clamp (TriNoise3d (p) * f * f, 0., 1.);\n    col += f * (cFog - col);\n    if (length (p) > ballRad || length (roo + d * rd) > dHit) break;\n  }\n  return col;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, roo, rdo, vn;\n  float dstHit, dstBHit, s;\n  int idObjT;\n  dstFar = 100.;\n  roo = ro;\n  rdo = rd;\n  noiseDisp = 0.05 * tCur * vec3 (-1., 0., 1.);\n  dstBHit = BallHit (ro, rd, ballPos, ballRad);\n  dstHit = dstFar;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col = vec3 (0.7, 0.7, 0.);\n    col = col * (0.5 + 0.5 * max (dot (vn, sunDir), 0.)) +\n       0.5 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n  } else col = BgCol (ro, rd);\n  if (dstBHit < dstFar) {\n    ro = roo;\n    rd = rdo;\n    ro += rd * dstBHit;\n    col = HsvToRgb (vec3 (mod (0.3 * tCur, 1.), 1., 1.)) *\n       FogCol (col, ro, rd, dstHit, 0.1 * tCur);\n    rd = reflect (rd, qnHit);\n    col = col + 0.1 + 0.2 * max (dot (qnHit, sunDir), 0.) +\n       0.2 * pow (max (0., dot (sunDir, rd)), 64.);\n  }\n  if (dstBHit < dstFar) {\n    s = 1. - abs (dot (rd, qnHit));\n    if (s > 0.) col = mix (col, BgCol (ro, rd), pow (s, 4.));\n  }\n  col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, oDir, oNorm, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, vel;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  dstFar = 100.;\n  TrkSetup ();\n  vel = 0.8;\n  for (int k = 0; k < nCar; k ++) {\n    carPos[k] = TrkPath (vel * tCur - tWait + cLen[12] *\n       float (nCar - 1 - k) / float (nCar), oDir, oNorm);\n    carMat[k] = AxToRMat (oDir, oNorm);\n  }\n  ballPos = vec3 (0.);\n  ballRad = 8.;\n  el = 0.1 * pi;\n  az = 0.1 * tCur;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  ro = vec3 (0., 1., -15.) * vuMat;\n  sunDir = normalize (vec3 (1., 2., 1.));\n  rd = normalize (vec3 (uv, 6.)) * vuMat;\n  ro = vec3 (0., 0., -50.) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsK3R3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[121, 392, 416, 416, 463], [465, 465, 490, 490, 679], [681, 681, 702, 702, 841], [843, 843, 875, 875, 970], [972, 972, 1005, 1005, 1089], [1091, 1091, 1136, 1136, 1211], [1213, 1213, 1246, 1246, 1273], [1275, 1275, 1317, 1317, 1368], [1370, 1370, 1413, 1413, 1479], [1481, 1481, 1534, 1534, 1595], [1597, 1597, 1631, 1631, 1821], [1823, 1823, 1853, 1853, 1927], [2293, 2293, 2324, 2324, 2383], [2385, 2385, 2403, 2403, 3694], [3696, 3696, 3751, 3751, 5223], [5225, 5225, 5259, 5259, 6902], [6904, 6904, 6926, 6926, 8580], [8582, 8582, 8615, 8615, 8791], [8793, 8793, 8814, 8814, 9037], [9039, 9039, 9090, 9090, 9309], [9311, 9311, 9335, 9335, 9369], [9371, 9371, 9394, 9394, 9428], [9430, 9430, 9457, 9457, 9857], [9859, 9859, 9925, 9925, 10478], [10480, 10480, 10504, 10504, 10635], [10637, 10637, 10672, 10672, 11791], [11793, 11793, 11849, 11849, 12772]], "test": "untested"}
{"id": "XsK3WV", "name": "Rhythm Lines", "author": "vamoss", "description": "Original work: http://57.media.tumblr.com/5ca79532ad296fcdc07bb48209c16dea/tumblr_o32r02CWzb1tcuj64o1_400.gif", "tags": ["lines", "rhythm"], "likes": 25, "viewed": 366, "published": "Public", "date": "1456518700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nOriginal work\nhttp://57.media.tumblr.com/5ca79532ad296fcdc07bb48209c16dea/tumblr_o32r02CWzb1tcuj64o1_400.gif\n*/\n\n#define PI 3.14159265359\n\nfloat easeInOutExpo(float t, float b, float c, float d) {\n\tt /= d/2.0;\n\tif (t < 1.0) return c/2.0 * pow( 2.0, 10.0 * (t - 1.0) ) + b;\n\tt--;\n\treturn c/2.0 * ( -pow( 2.0, -10.0 * t) + 2.0 ) + b;\n}\n\n/**\n * Draw a rectangle at vec2 `pos` with width `width`, height `height` and color `color`.\n * @author jonobr1 / http://jonobr1.com/\n */\nvec4 rectangle(vec2 uv, vec2 pos, float width, float height, vec3 color) {\n\tfloat t = 0.0;\n\tif ((uv.x > pos.x) && (uv.x < pos.x + width)\n\t\t&& (uv.y > pos.y) && (uv.y < pos.y + height)) {\n\t\tt = 1.0;\n\t}\n\treturn vec4(color, t);\n}\n\nvec3 getColor(float frame, float frequency) {\n    vec3 color1 = vec3(0.86, 0.86, 0.82);\n    vec3 color2 = vec3(0.15, 0.15, 0.15);\n    \n    if(cos(frame*2.0+frequency+PI/2.0)>0.0) return color1;\n    return color2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 center = vec2(0.5, 0.1);\n    const int total = 8;//number of lines\n    \n    float frame = iTime;\n    if(iMouse.x>0.0) frame *= 5.0 * (iMouse.x / iResolution.x);//velocity\n    \n    \n    vec4 color = vec4(getColor(frame, PI), 1.0);//bg\n    vec3 rectColor = getColor(frame, 0.0);\n    \n    float freqDecay = 2.0;\n        \n    float space = 0.05;\n    float size = 0.7;\n//*Vertical Lines\n    for(int i=0; i<total; i++){\n        float freq = (1.0-float(i)/float(total))/freqDecay;\n        float x = center.x + space*float(i-total/2);\n    \tfloat y = center.y;\n        float height = size * easeInOutExpo(((cos((frame+freq)*2.0)+1.0)/2.0), 0.0, 1.0, 1.0);\n    \tif(cos(frame+freq+PI/2.0)<0.0) y += size-height;;\n        height += 0.035;\n        float width = 0.02;\n\t    \n        vec4 rect = rectangle(uv, vec2(x, y), width, height, rectColor);\n\t    color = mix(color, rect, rect.a);\n    }\n/**/\n//*Horizontal Lines\n    frame += PI/2.0;\n    space = 0.08;\n\tcenter = vec2(0.25, 0.5);\n    size = 0.45;\n    for(int i=0; i<total; i++){\n        float freq = (1.0-float(i)/float(total))/freqDecay;\n        float x = center.x;\n        float width = size * easeInOutExpo(((cos((frame+freq)*2.0)+1.0)/2.0), 0.0, 1.0, 1.0);\n\t    if(cos(frame+freq+PI/2.0)<0.0) x += size - width;\n    \tfloat y = center.y + space*float(i-total/2);\n        float height = 0.035;\n    \twidth += 0.021;\n        \n        vec4 rect = rectangle(uv, vec2(x, y), width, height, rectColor);\n\t    color = mix(color, rect, rect.a);\n    }\n/**/\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsK3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 142, 199, 199, 336], [338, 476, 550, 550, 702], [704, 704, 749, 749, 918], [920, 920, 977, 977, 2536]], "test": "untested"}
{"id": "XsKGDD", "name": "RT -fnieto -jgan", "author": "Wicpar", "description": "the RT project\n", "tags": ["raytracer"], "likes": 1, "viewed": 104, "published": "Public", "date": "1454536152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FOV 90\n\nstruct camera\n{\n    vec3 pos;\n    vec3 ray;\n    vec3 light;\n};\n\nstruct material\n{\n    vec3 color;\n    float gloss;\n   \tfloat metal;\n};\n    \nstruct sphere\n{\n\tvec3 pos;\n    float rad;\n    material mat;\n};\n    \nstruct plane\n{\n    float height;\n    vec3 normal;\n};\n    \nstruct RayResult\n{\n    float t;\n    material mat;\n    vec3 normal;\n};\n   \nstruct cube\n{\n\tfloat rad;\n    vec3 pos;\n    material mat;\n};\n    \nconst int SPHERENUM = 3;\nconst int CUBENUM = 3;\n\nsphere sp[SPHERENUM];\ncube cu[CUBENUM];\nmaterial plastic;\n\nfloat time = iTime;\n\nint iter = 0;\n\nvoid init()\n{\n    plastic.color = vec3(0, 0.9, 0);\n    plastic.metal = 0.1;\n    plastic.gloss = 0.9;\n    for (int i = 0; i < SPHERENUM; ++i)\n    {\n    \tsp[i].pos = vec3(float(i) * 2. - 2., sin(time) -1., 0);\n        sp[i].rad = 1.;\n    \tsp[i].mat = plastic;\n    }\n    for (int i = 0; i < CUBENUM; ++i)\n    {\n    \tcu[i].pos = vec3(float(i) * 3. - float(CUBENUM),  sin(time), 3.);\n        cu[i].rad = 1.;\n    \tcu[i].mat = plastic;\n    }\n}\n\nfloat seed = 0.;\nfloat rand(float f) { \n    return fract(sin(++seed * f)*43758.5453123); \n}\nvec3 light(){\n    return normalize(vec3(sin(time), 0.3, cos(time)));\n}\n\nvec3 background(vec3 rd)\n{\n\tfloat sun = max(0.0, dot(rd, light()));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 0.5)*vec3(0.4, 0.3, 0.2) +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7);\n}\n\nRayResult spherecol(camera cam, sphere sp)\n{\n    RayResult res;\n    \n\tvec3 rc = cam.pos-sp.pos;\n\tfloat c = dot(rc, rc) - (sp.rad*sp.rad);\n\tfloat b = dot(cam.ray, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\tres.t =  mix(-1.0, t, st);\n    res.mat = sp.mat;\n    res.normal = -normalize(sp.pos - (cam.pos+cam.ray*t));\n    return res;\n}\n\nRayResult cubecol(camera cam, cube cu)\n{\n    RayResult res;\n    \n    vec3 tmin = ((cu.pos + cu.rad * sign(cam.ray) * -1.) - cam.pos) / cam.ray;\n    vec3 tmax = ((cu.pos + cu.rad * sign(cam.ray)) - cam.pos) / cam.ray;\n    float mi = max(max(tmin.x, tmin.y), tmin.z);\n    float ma = min(min(tmax.x, tmax.y), tmax.z);\n    res.t = (min(mi, ma) >= 0. ? min(mi, ma) : max(mi, ma));\n    if (ma < mi)\n        res.t = -1.;\n    res.mat = cu.mat;\n    res.normal = normalize(vec3(float(mi == tmax.x)-float(mi == tmin.x),float(mi == tmax.y) -float(mi == tmin.y),float(mi == tmax.z) -float(mi == tmin.z)));\n    return res;\n}\n\nvec3 makeColor2(RayResult r, camera cam)\n{\n    if (r.t < 0.)\n        return background( cam.ray);\n    cam.pos += (r.t - 0.001) * cam.ray;\n    cam.ray = reflect(cam.ray, r.normal);\n    float tomix = (dot(r.normal, cam.ray) * ( 1. - r.mat.metal));\n    vec3 li = cam.light;\n    cam.light = reflect(cam.light, r.normal);\n    return mix(mix(background(cam.ray), vec3(0), 1.- (r.mat.gloss) * dot(li, r.normal)) + (1. - r.mat.gloss)/2. , r.mat.color , tomix);\n}\n\nRayResult rayTrace2(camera cam)\n{\n    RayResult r;\n    \n    r.t = -1.;\n    if (iter > 4)\n        return r;\n    else\n        iter++;\n    for (int i = 0; i < SPHERENUM; ++i)\n    {\n        RayResult new;\n        new = spherecol(cam, sp[i]);\n        if (new.t > 0. && (new.t <= r.t || r.t == -1.))\n            r = new;\n    }\n    for (int i = 0; i < CUBENUM; ++i)\n    {\n        RayResult new;\n        new = cubecol(cam, cu[i]);\n        if (new.t > 0. && (new.t <= r.t || r.t == -1.))\n            r = new;\n    }\n    return r;\n}\n\nvec3 makeColor(RayResult r, camera cam)\n{\n    if (r.t < 0.)\n        return background(cam.ray);\n    cam.pos += (r.t - 0.001) * cam.ray;\n    cam.ray = reflect(cam.ray, r.normal);\n    float tomix = (dot(r.normal, cam.ray) * ( 1. - r.mat.metal));\n    vec3 li = cam.light;\n    cam.light = reflect(cam.light, r.normal);\n    return mix(mix(makeColor2(rayTrace2(cam), cam), vec3(0), 1. - (r.mat.gloss) * dot(li, r.normal)) + (1. - r.mat.gloss)/2. , r.mat.color , tomix);\n}\n\n\nRayResult rayTrace(camera cam)\n{\n    RayResult r;\n    \n    r.t = -1.;\n    if (iter > 4)\n        return r;\n    else\n        iter++;\n    for (int i = 0; i < SPHERENUM; ++i)\n    {\n        RayResult new;\n        new = spherecol(cam, sp[i]);\n        if (new.t > 0. && (new.t <= r.t || r.t == -1.))\n            r = new;\n    }\n    for (int i = 0; i < CUBENUM; ++i)\n    {\n        RayResult new;\n        new = cubecol(cam, cu[i]);\n        if (new.t > 0. && (new.t <= r.t || r.t == -1.))\n            r = new;\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camera \tcam;\n    \n    cam.pos = vec3(0, 2., -5);\n\tvec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n\tcam.ray = normalize(vec3(uv, 1.0));\n    cam.light = light();\n    init();\n\tfragColor = vec4(makeColor(rayTrace(cam), cam), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKGDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[566, 566, 579, 579, 1002], [1021, 1021, 1042, 1042, 1095], [1096, 1096, 1109, 1109, 1166], [1168, 1168, 1194, 1194, 1494], [1496, 1496, 1540, 1540, 1872], [1874, 1874, 1914, 1914, 2484], [2486, 2486, 2528, 2528, 2940], [2942, 2942, 2975, 2975, 3463], [3465, 3465, 3506, 3506, 3930], [3933, 3933, 3965, 3965, 4453], [4455, 4455, 4512, 4512, 4795]], "test": "untested"}
{"id": "XsV3DK", "name": "Subluminic 4", "author": "aiekick", "description": "Subluminic 4", "tags": ["voronesque", "subluminic"], "likes": 8, "viewed": 567, "published": "Public API", "date": "1456481875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n// by shane\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y);\n}\n\nvec2 path(vec3 p)\n{\n\tp.x = sin(p.z*0.1)*20.;\n\tp.y = cos(p.z*0.05)*20.;\n\treturn p.xy;\n}\n\nfloat df(vec3 p)\n{\n\tp.xy += path(p);\n\tp *= Voronesque(p/2.);//p *= Voronesque(p.zzz/2.);\n\treturn 2. - length(p.xy);\n}\n\nvec3 march(vec3 f, vec3 ro, vec3 rd, float st)\n{\n\tvec3 s = vec3(1), h = vec3(0.055,0.028,0.022), w = vec3(0);\n\tfloat d=1.,dl=0., td=0.;\n\tvec3 p = ro;\n\tfor(float i=0.;i<60.;i++)\n\t{      \n\t\tif(s.x<0.0025*d||d>30.||td>.95) break;\n        s = df(p) * .1 * i/vec3(6.42,16,12.96);\n\t\tw = (1.-td) * (h-s) * i/vec3(74.42,50.22,31.32) * step(s,h);\n\t\tf += w;\n\t\ttd += w.x + .01;\n\t\tdl += 1. - exp(-0.0042 * log(d));;\t\n\t\ts = max(s, st);\n\t\td +=s.x; \n\t\tp =  ro+rd*d;\t\n   \t}\n\tdl += 0.4;\n\tf /= dl/1.1264;\n\t\n\tfloat stars = pow(fract( cos(rd.y * 8. + rd.x *800.) * 5000.), 50.);\n\tf.rgb = mix( f.rgb, vec3(stars), 1. - exp( -0.004*d*d) );\n\treturn f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n\tvec2 si = iResolution.xy;\n\tvec2 uv = (fragCoord*2.-si.xy) / min(si.x, si.y);\n\n\tfloat t = iTime * 12.;\n\tvec3 ro = vec3(0,-.5,t);\n\tro.xy -= path(ro);\n\t\n\tvec3 co = ro + vec3(0,0,1);\n\tvec3 cu = vec3(0,1,0);\n\t\n\tfloat fov = 5.;\n\tvec3 z = normalize(co - ro);\n\tvec3 x = normalize(cross(cu, z));\n\tvec3 y = normalize(cross(z, x));\n\tvec3 rd = normalize(z + fov * uv.x * x + fov * uv.y * y);\n\n\tfragColor.rgb = march(fragColor.rgb, ro, rd, 0.135);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsV3DK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[196, 208, 239, 239, 804], [806, 806, 825, 825, 892], [894, 894, 912, 912, 1011], [1013, 1013, 1061, 1061, 1643], [1645, 1645, 1702, 1702, 2170]], "test": "untested"}
{"id": "XsV3RK", "name": "Ãœbung Krempel", "author": "cardmechanic", "description": "hui", "tags": ["rundeecken", "parallelogrammevtlundandererkram"], "likes": 1, "viewed": 90, "published": "Public", "date": "1455371758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Rect {\n\tvec2 pos,\n    \t ext;\n    mat2 kord;\n    vec4 col;\n};\n\n    Rect R1 = Rect (vec2(-.2,.2), vec2 (.2*iTime,.8), mat2 (1.,0.,0.,1.), vec4 (.15,.75,.013,1.)),\n \t\t K1 = Rect (vec2(-.2,-.6), vec2 (.8,.8), mat2 (1.,0.,0.,1.), vec4 (.5,.25,.413,1.)),\n    \t RK = Rect (vec2(-.8,-.1), vec2 (.5,.5), mat2 (1.,0.,0.,1.), vec4 (.85,.05,.013,1.)),\n    \t RKk = Rect (vec2(-.8,-.1), vec2 (.1,.1), mat2 (1.,0.,0.,1.), vec4 (.0,.9,.4,1.)),\n    \t RP = Rect (vec2(.2,-.4), vec2 (.075,1.9), mat2 (1.,0.,0.,1.), vec4 (.2,.4,.913,1.));\n\t\t \nmat2 Rot (in float alpha){\n    float s = sin(alpha),\n    \t  c = cos(alpha);\n    \n    return mat2 (c,-s,s,c);\n        \n        }\n    \t  \n\nvoid Rotvec (in float alpha, inout Rect reco){\n\n    reco.kord = Rot(alpha) * reco.kord;\n\n}\n\n\nvec4 intersec (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n    \n    if ( abs(mat.x) >.5*reco.ext.x || abs(mat.y) >.5*reco.ext.y)\n        return vec4 (0.);\n\t\n        if (abs(mat.x)+ mat.y <.01 * 20.*iTime)\n        return reco.col;\n    \t\n    return vec4(.0);\n\n}\n\nvec4 intersecKr (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n    \n    if ( abs(mat.x) >.5*reco.ext.x && abs(mat.y) >.5*reco.ext.y){\n        return vec4 (0.);\n    \t}\n       \n    \tif (abs(1.8*mat.x)+ (mat.y) <.55 && 1.8*mat.y >.011*reco.ext.y-1.8)\n        return reco.col;   \t    \t\n\n    \t\n    return vec4(.0);\n\n}\n\nvec4 intersecKr2 (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n    \n    if ( abs(mat.x) >.5*reco.ext.x && abs(mat.y) >.5*reco.ext.y){\n        return vec4 (0.);\n    \t}\n        if (mat.x*mat.x+mat.y*mat.y <.0095)\n        return reco.col;\n    \t\n    return vec4(.0);\n\n}\n\nvec4 intersecKr3 (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n    \n    if ( abs(mat.x) >.5*reco.ext.x && abs(mat.y) >.5*reco.ext.y){\n        return vec4 (0.);\n    \t}\n        if (mat.x*mat.x+mat.y*mat.y <.295 && mat.y > mat.x)\n        return reco.col;\n    \t\n    return vec4(.0);\n\n}\n\n\nvec4 intersecPf (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n    \n    if ( abs(mat.x) >.5*reco.ext.x || abs(mat.y) >.5*reco.ext.y)\n        return vec4 (0.);\n\t\n        if (abs(1.4*mat.x)+ mat.y <.8)\n        return reco.col;\n    \t\n    return vec4(.0);\n\n}\n\nvec2 Flch (in Rect rA){\n\tfloat A = .5*rA.ext.x*rA.ext.y;\n    \n    if (A >.31)\n         return vec2 (abs(sin(iTime))*.4+.5037,.3+.8*abs(cos(iTime)));\n    return vec2 (.2*iTime,.8);\n}\n\nvoid Mov2 (inout Rect rA){\n\n\trA.pos = vec2 (-sin(5.*iTime),cos(3.*iTime));\n}\n\nvoid Mov1 (inout Rect rA){\n\n\trA.pos = vec2 (sin(3.*iTime), cos(3.*iTime));\n          \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n    vec2 uv = (2.*fragCoord.xy / iResolution.xy-1.)*vec2 (iResolution.x/iResolution.y,1.);\n    \n\t   fragColor = vec4(.2,.1,.6,1.);\n    \n  \tRotvec (1.6*iTime, R1);\n    Rotvec (iTime, RP);\n    Rotvec (iTime, RK);\n\tRotvec (25.*iTime, RKk);    \n    Rotvec (9.6*iTime, K1);\n    vec2 extnew = Flch (R1);\n        R1.ext = extnew;\n  \n    \n    float state = sin(iTime);\n    if (state >0.)\n        Mov1(RP);\n    else\n     Mov2(RP);\n    \n        \n    \n    vec4 r1col = intersec (uv,R1);\n    vec4 r2col = intersecPf (uv,RP);\n    vec4 r3col = intersecKr (uv,RK);\n    vec4 r4col = intersecKr2(uv, RKk);\n    vec4 r5col = intersecKr3(uv, K1);\n    \n    \n    float fakt = r1col.a + r2col.a+r3col.a+r4col.a +r5col.a;\n    \n    vec4 cols =r1col + r1col;\n         \n    if (fakt < 1.)\n        fragColor = vec4 (.2,.1,.6,1.);\n    else\n    \tfragColor = (r1col + r2col + r3col  + r4col+ r5col);\n    \n \n    \n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsV3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[530, 530, 556, 556, 657], [667, 667, 713, 713, 757], [760, 760, 803, 803, 1069], [1071, 1071, 1116, 1116, 1431], [1433, 1433, 1479, 1479, 1747], [1749, 1749, 1795, 1795, 2079], [2082, 2082, 2127, 2127, 2384], [2386, 2386, 2409, 2409, 2567], [2569, 2569, 2595, 2595, 2645], [2647, 2647, 2673, 2673, 2734], [2738, 2738, 2800, 2800, 3689]], "test": "untested"}
{"id": "XsV3Ww", "name": "Quadratic with pole", "author": "ur_faec", "description": "A meromorphic function with zeroes ranging from 1 and -1 to 3 and -3, and a simple pole wherever you click and drag the mouse.", "tags": ["math", "algebra", "complexfunctions"], "likes": 6, "viewed": 161, "published": "Public", "date": "1454804061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 ColorVariation = vec3(0.5, 0.3, 0.7);\n\n// To lock to a fixed color scheme, comment out the above definition\n// of ColorVariation and instead use this:\n//const vec3 ColorVariation = vec3(0.0, 0.0, 0.0);\n\n\nconst float PI = 3.141592653589793238462643383;\n\nconst vec2 origin = vec2(0.0, 0.0);\nconst float ViewRadius = 2.0;\n\nconst float GridCoefficientLight = 1.3;\nconst float GridCoefficientDark = 1.0;\n\n\nvec3 hueForPhase(float phase) {\n    phase *= 2.0;\n    vec3 offset = iTime * ColorVariation;\n    vec3 hue = vec3(\n        sin(phase + offset.x) + 1.0,\n        sin(2.0*(phase + 0.67*PI) + offset.y) + 1.0,\n        sin(2.0*phase + offset.z) + 1.0);\n    \n    return hue / sqrt(dot(hue, hue));\n}\n\n// Should be ~1 at the origin, ~0 at any significant distance from it\nfloat decay(float x) {\n\tif (abs(x) >= 0.1) {\n\t\treturn 0.0;\n\t}\n\treturn 1.0 - abs(x*10.0);//pow(abs(x*10.0), 1)\n}\n\n// Offset of x from the integer grid, ignoring integer multiples of n.\nfloat offsetFromGridExcept(int n, float x) {\n\tfloat below = floor(x);\n    float above = ceil(x);\n    if (abs(mod(below, float(n))) < 0.5) {\n        below -= 1.0;\n    }\n    if (abs(mod(above, float(n))) < 0.5) {\n        above += 1.0;\n    }\n\treturn min(x-below, above-x);\n}\n\nfloat offsetFromGrid(float x) {\n\treturn min(x-floor(x), ceil(x)-x);\n}\n\nfloat gridFn(float x) {\n    return offsetFromGrid(x);\n}\n\nvec2 complexInverse(vec2 z) {\n    float scale = 1.0 / dot(z, z);\n    return scale * vec2(z.x, -z.y);\n}\n\nvec2 complexMul(vec2 z1, vec2 z2) {\n    return vec2(z1.x * z2.x - z1.y * z2.y,\n                z1.x * z2.y + z1.y * z2.x);\n}\n\nvec4 eval(vec2 z, vec2 param) {\n    float c = 2.0 + sin(iTime);\n    // Evaluate: z^2 - 1 / (z - param)\n    \n    float a = param.x;\n    float b = param.y;\n    vec2 z2 = complexMul(z, z);\n    vec2 inv = complexInverse(z - param);\n    vec2 inv2 = complexMul(inv, inv);\n    vec2 num = z2 - vec2(c*c, 0.0);\n    return vec4(\n        complexMul(num, inv),\n        complexMul(2.0 * z, inv) - complexMul(num, inv2));\n}\n\n// Scaling weirdness: \"hue\" is expected to be an angle measured in radians,\n// sv are [0, 1].\nvec3 HSVtoRGB(vec3 hsv) {\n    vec3 hue = hueForPhase(hsv.x);\n    return (hsv.y * hue + (1.0 - hsv.y)) * hsv.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 uv = 2.0 * ViewRadius * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 param = 2.0 * ViewRadius * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    if (iMouse.xy == vec2(0.0, 0.0)) {\n        param = vec2(-1.7, 0.0);\n    }\n    \n    vec4 value = eval(uv, param);\t// xy = function, zw = derivative\n    \n    float vabs = sqrt(dot(value.xy, value.xy));\n    float dvabs = sqrt(dot(value.zw, value.zw));\n    float phase = atan(value.y, value.x);// / (2.0 * PI) + 0.5;\n    float dphase = dvabs / (vabs+0.01);\n    \n    float phaseOffset = offsetFromGridExcept(4, 16.0*phase / (2.0 * PI));\n    float phaseFactor = 1.0 - decay(phaseOffset * 5.0 / (ViewRadius * (dphase + 0.01)));\n    \n    float absFactor = 1.0;\n    if (vabs > 0.5) {\n        float absOffset = vabs * GridCoefficientLight;\n        absFactor = 1.0 - decay(gridFn(absOffset) * 12.0 /\n            (GridCoefficientLight * ViewRadius * (dvabs + 0.01)));\n    }\n    \n    float imagOffset = abs(value.y * GridCoefficientDark) + 1.0;\n    float imagFactor = 1.0 - decay(gridFn(imagOffset) * 15.0 /\n                                   (GridCoefficientDark * ViewRadius * (dvabs + 0.01)));\n    float realOffset = abs(value.x * GridCoefficientDark) + 1.0;\n\n    float realFactor = 1.0 - decay(gridFn(realOffset) * 15.0 /\n                                   (GridCoefficientDark * ViewRadius * (dvabs + 0.01)));\n\n    vec3 hsv = vec3(\n        phase,\n        phaseFactor * absFactor,\n        imagFactor * realFactor);\n        \n    fragColor = vec4(HSVtoRGB(hsv), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsV3Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 412, 443, 443, 701], [703, 773, 795, 795, 884], [886, 957, 1001, 1001, 1228], [1230, 1230, 1261, 1261, 1299], [1301, 1301, 1324, 1324, 1356], [1358, 1358, 1387, 1387, 1460], [1462, 1462, 1497, 1497, 1586], [1588, 1588, 1619, 1619, 1997], [1999, 2093, 2118, 2118, 2205], [2207, 2207, 2264, 2338, 3874]], "test": "untested"}
{"id": "XsVGzK", "name": "[MIGJRV] Happy Valentine's Day", "author": "RobotPenguin", "description": "Made by H&eacute;ctor Barreiro and Rosa S&aacute;nchez as the first assignment of the PGATR course (2016).\nComputer Graphics, Virtual Reality and Video Games University Master. URJC.\n\nHAPPY VALENTINE'S DAY!!", "tags": ["water", "heart", "night", "bright", "valentines", "love", "distancefieldslove"], "likes": 27, "viewed": 895, "published": "Public", "date": "1455367921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHADERTOY\n\n// -- Uniforms -----------------------------------------------------------------\n\n#ifndef SHADERTOY\nuniform vec3 iResolution;\nuniform vec3 iMouse;\nuniform float iTime;\nuniform sampler2D iChannel0;\n#endif\n\n// -- Constants ----------------------------------------------------------------\n\n// Camera constants\n\nconst float kFOV = 0.785398;                           // Camera field of view \n\n// RayMarching constants\n\nconst int kMaxSteps = 70;                              // Max number of raymarching steps\nconst float kMaxDistance = 55.0;                       // Max raymarching distance\nconst float kBias = 0.01;                              // Bias offset for normal estimation\nconst float kNoHit = -1.0;                             // No intersection distance.\n\n// Scene constants.\nconst vec3 kSkyColor = vec3(0.1, 0.12, 0.15);          // Night sky color.\nconst vec3 kSkyHorzColor = vec3(0.4, 0.2, 0.87);       // Night sky horizon color.\n\nconst vec3 kMoonDir = vec3(-0.18443, 0.3688, -0.9221); // Moon direction.\nconst vec3 kMoonColor = vec3(1.0, 1.0, 0.8);           // Moon color.\nconst vec3 kMoonSkyByColor = vec3(0.9, 0.6, 1.2);      // Moon glow color.\nconst float kMoonCosRange = 0.999;                     // Moon cosine range.\n\n// Material constants.\nconst float kMaterialNone = 0.0;\nconst float kMaterialHeart = 1.0;\nconst float kMaterialWater = 2.0;\n\n// Other constants\n\nconst vec3 kOnes = vec3(1.0, -1.0, 0.0);               // Helper vector with ones.\nconst float kPI = 3.14159265359;                       // PI\n\n// -- Global values ------------------------------------------------------------\n\nfloat gAnimTime;\n\nvec3  gHeartPos;\nfloat gHeartMorph;\nfloat gHeartColoring;\n\nfloat gWaveTime;\n\nfloat gMsgFadeInTime;\nfloat gFadeTime;\n\n\n// -- Structures ---------------------------------------------------------------\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct RayHit\n{\n    float time;\n    float material;\n};\n\nstruct DistanceSample\n{\n    float dist;\n    float stepRatio;\n    float material;\n};\n\n    \n// --- Math funcs --------------------------------------------------------------\n\n// Build quaternion from axis angle\nvec4 QuatFromAxisAngle(vec3 axis, float angle)\n{\n    float theta = 0.5 * angle;\n    float sine = sin(theta);\n    return vec4(sin(theta) * axis, cos(theta));\n}\n\n// Builds the conjugate quaternion\nvec4 QuatConjugate(vec4 q)\n{\n    return vec4(q.xyz, -q.w);\n}\n\n// Rotates a vector around the quaternion\nvec3 QuatTransformVec(vec3 v, vec4 q)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\n// -- Noise funcs --------------------------------------------------------------\n\n// Hash noise function from I. Quilez\nfloat Hash(float p)\n{\n    float h = p * 127.1;\n    return fract(sin(h)*43758.5453123);\n}\n\n// Hash noise function from I. Quilez\nfloat Hash(vec2 p)\n{\n    float h = dot(p, vec2(127.1,311.7));    \n    return fract(sin(h)*43758.5453123);\n}\n\n// Modified Hash noise function for 3D hashing.\nfloat Hash(vec3 p)\n{\n    float h = dot(p, vec3(127.1, 311.7, 511.9));    \n    return fract(sin(h)*43758.5453123);\n}\n\n// 2D Perlin Noise\nfloat PerlinNoise(vec2 p)\n{    \n    vec2 i = floor(p);\n    vec2 f = fract(p);  \n    vec2 u = smoothstep(0.0, 1.0, f);\n    \n    float f00 = mix(Hash(i + kOnes.zz), Hash(i + kOnes.xz), u.x);\n    float f01 = mix(Hash(i + kOnes.zx), Hash(i + kOnes.xx), u.x);\n    float f1 = mix(f00, f01, u.y);\n    \n    return 2.0 * f1 - 1.0;\n}\n\n// 3D Perlin Noise\nfloat PerlinNoise(vec3 p)\n{    \n    vec3 i = floor(p);\n    vec3 f = fract(p);  \n    vec3 u = smoothstep(0.0, 1.0, f);\n    \n    float f00 = mix(Hash(i + kOnes.zzz), Hash(i + kOnes.xzz), u.x);\n    float f01 = mix(Hash(i + kOnes.zxz), Hash(i + kOnes.xxz), u.x);\n    float f02 = mix(Hash(i + kOnes.zzx), Hash(i + kOnes.xzx), u.x);\n    float f03 = mix(Hash(i + kOnes.zxx), Hash(i + kOnes.xxx), u.x);\n    \n    float f10 = mix(f00, f01, u.y);\n    float f11 = mix(f02, f03, u.y);\n    \n    float f2 = mix(f10, f11, u.z);\n    \n    return 2.0 * f2 - 1.0;\n}\n\n// Fractional Brownian Motion from I. Quilez\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n// In the end, it's a sum of Perlin Noise functions with increasing frequencies\n// and decreasing amplitudes. To enhance the noise, a rotation matrix is applied\n// at each step.\n\nconst mat2 FBM_M2 = mat2(0.84147, 0.54030, 0.54030, -0.84147);\nconst mat3 FBM_M3 = mat3(0.00, 0.90, 0.60, -0.90, 0.36, -0.48, -0.60, -0.48, 0.34 );\n\nfloat FBM(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*PerlinNoise(p); p = FBM_M2 * p * 2.02;\n    f += 0.2500*PerlinNoise(p); p = FBM_M2 * p * 2.03;\n    f += 0.1250*PerlinNoise(p); p = FBM_M2 * p * 2.01;\n    //f += 0.0625*PerlinNoise(p);\n    //return f/(0.9375);\n    return f/(0.8750);\n}\n\nfloat FBM(vec3 p)\n{\n    float f = 0.0;\n    f += 0.5000*PerlinNoise(p); p = FBM_M3 * p * 2.02;\n    f += 0.2500*PerlinNoise(p); p = FBM_M3 * p * 2.33;\n    f += 0.1250*PerlinNoise(p); p = FBM_M3 * p * 2.01;\n    f += 0.0625*PerlinNoise(p); \n    return f/(0.9175);\n}\n\n// -- Camera funcs -------------------------------------------------------------\n\nRay ViewportToRay(vec2 uv, vec3 offs, vec4 rot)\n{\n    Ray ray;\n    ray.direction = QuatTransformVec(normalize(vec3(uv * tan(kFOV * 0.5), -1.0)), rot);\n    ray.origin = offs;\n    \n    return ray;\n}\n\nRay ReflectRay(Ray ray, float d, vec3 n)\n{\n    ray.origin += ray.direction * d;\n    ray.direction = reflect(ray.direction, n);\n    return ray;\n}\n\nDistanceSample NewDistanceSample(float d, float s, float m)\n{\n    DistanceSample h;\n    h.dist = d;\n    h.stepRatio = s;\n    h.material = m;\n    return h;\n}\n\nRayHit NewRayHit(float t, float m)\n{\n    RayHit h;\n    h.time = t;\n    h.material = m;\n    return h;\n}\n\n// -- Water funcs --------------------------------------------------------------\n\n// Computes the height of a wave at the specified point\nfloat WaveDirectional(vec2 p, float wavelength, float speed, vec2 direction, float amplitude)\n{\n    float freq = 2.0 * kPI / wavelength;\n    float phase = speed * freq;\n    float theta = dot(direction, p);\n\n    return amplitude * pow(sin(theta * freq + gAnimTime * phase), 3.0);\n}\n\nfloat WavePunctual(vec2 p, float wavelength, float speed, vec2 perturb, float amplitude, float waveTime)\n{\n    float freq = 2.0 * kPI / wavelength;\n    float phase = speed * freq;\n    float dist = -length(p - perturb);\n    amplitude /= 1.0 + (0.3 * -dist) + (0.15 * waveTime * waveTime);\n\n    return amplitude * pow(sin(max(0.0, dist * freq + waveTime * phase)), 3.0);\n}\n\n// -- SDF funcs ----------------------------------------------------------------\n\n// Signed Distance Field of a point to a heart located at the origin. It works by computing\n// the SDF of a sphere whose space has been distorted by a polar function\nDistanceSample SDFHeart(vec3 p)\n{\n    // Apply noise to position when it's a drop.\n    if (gHeartMorph < 1.0)\n        p += 0.16 * FBM(p + vec3(0, gAnimTime * 2.5, 0)) * (1.0 - gHeartMorph);\n    \n    // Apply domain distortion for heart.\n    float a0 = atan(p.x, p.y);\n    float a1 = atan(p.x, p.z);\n    float b0 = abs(a0 / kPI);\n    float b1 = abs(a1);\n    float l = length(p.xy);\n    \n    // Constants computed with Octave:\n    // x = [   0; 0.35;  0.53;   1; ];\n    // y = [ 0.6;  1.0;  0.9; 1.2; ];\n    // K = polyfit(x, y, 3);\n    const vec4 K = vec4(6.34975, -9.8705, 4.39112, 0.4);\n    vec4 B = vec4(b0 * b0 * b0, b0 * b0, b0, 1.0);\n    \n    float d0 = dot(K, B);\n    d0 = mix(1.0, d0, smoothstep(0.0, 0.7, l));\n    float d1 = 1.0 - 0.5*abs(cos(a1));\n    \n    p.xy /= mix(1.0, d0, gHeartMorph);\n    p.z  /= mix(1.0, d1, gHeartMorph);\n    \n    // Increase size whenever the mouse is close.\n\tfloat mouseOverSize = 1.0+0.7*smoothstep(0.2, 0.0, length((iMouse.xy / iResolution.xy) - 0.5));\n\t\n    // Compute sphere's SDF\n    return NewDistanceSample(length(p) - 0.8 - 0.5 * gHeartMorph * mouseOverSize, 0.5, kMaterialHeart);\n}\n\n// Signed Distance Field of a point to the water plane located at the origin.\n// It's simply the distance to a plane distorted by the wave field.\nDistanceSample SDFWater(vec3 p)\n{\n    const float overallSpeed = 0.7;\n    float height = 0.0;\n    height -= FBM(vec3(p.xz * 0.5, 0.75 * gAnimTime)) * 0.05;\n    height += WavePunctual(p.xz, 12.0, 1.5, vec2(0.0, -12.0), 2.0, gWaveTime);\n    \n    return NewDistanceSample(p.y - 1.5 * height, 1.0, kMaterialWater);\n}\n\n// -- SDF CGS funcs ------------------------------------------------------------\n\nDistanceSample OpUnion(DistanceSample d1, DistanceSample d2)\n{\n    if (d1.dist < d2.dist) return d1; return d2;\n}\n\nDistanceSample OpSubstract(DistanceSample d1, DistanceSample d2)\n{\n    d2.dist = -d2.dist;\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\nDistanceSample OpIntersect(DistanceSample d1, DistanceSample d2)\n{\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\nDistanceSample OpSmoothMin(DistanceSample d1, DistanceSample d2, float k)\n{\n    float h = clamp(0.5+0.5*(d2.dist - d1.dist)/k, 0.0, 1.0);\n    \n    DistanceSample d;\n    d.dist = mix(d2.dist, d1.dist, h) - k * h * (1.0-h);\n    d.stepRatio = min(d2.stepRatio, d1.stepRatio);\n    d.material = mix(d2.material, d1.material, h);\n    \n    return d;\n}\n\n// -- Transform funcs ----------------------------------------------------------\n\nvec3 Tx(vec3 p, vec3 tx)\n{\n    return (p - tx);\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec4 q)\n{\n    p -= tx;\n    return QuatTransformVec(p, QuatConjugate(q));\n}\n\n// --- Scene funcs -------------------------------------------------------------\n\nDistanceSample Scene(vec3 position)\n{\n    // Evaluate scene distances.\n    DistanceSample d0 = SDFHeart(Tx(position, gHeartPos, QuatFromAxisAngle(vec3(0.,1.,0.), gAnimTime*1.7)));\n    DistanceSample d1 = SDFWater(Tx(position, vec3(0,-2,0)));\n    return OpSmoothMin(d0, d1, 0.8);\n}\n\nvec3 SceneNormal(vec3 position)\n{\n    vec2 offset = vec2(kBias, 0.0);\n    float d = Scene(position).dist;\n    \n    return normalize(vec3\n    (\n        Scene(position + offset.xyy).dist - d,\n        Scene(position + offset.yxy).dist - d,\n        Scene(position + offset.yyx).dist - d\n    ));\n}\n\nvec3 SkyColor(vec3 n)\n{\n    // Compute the sky color from hemisphere. \n    float h = 1.0 - pow(abs(n.y), 0.4);\n    vec3 color = mix(kSkyColor, kSkyHorzColor, h);\n    \n    // Add stars.\n    float s = pow(max(0.0, PerlinNoise(n * 4e2)), 18.0);\n    color.rgb += vec3(s, s, s);\n    \n    // Add moon and moon light.\n    float dotNM = dot(n, kMoonDir);\n    color = mix(color, kMoonColor, smoothstep(0.0, 0.0001, dotNM - kMoonCosRange));\n    color += kMoonSkyByColor * pow(max(0.0, dotNM), 100.0);\n    \n    return color;\n}\n\nRayHit Raymarch(Ray ray)\n{\n    float t = 0.0;\n    DistanceSample d;\n    \n    for (int i = 0; (i < kMaxSteps); i++)\n    {\n        d = Scene(ray.origin + ray.direction * t);\n        t += d.dist * d.stepRatio;\n        \n        if ((d.dist < 0.0) || (t >= kMaxDistance))\n            break;\n    }\n    \n    if (t < kMaxDistance)\n        return NewRayHit(t, d.material);\n    \n    return NewRayHit(kNoHit, kMaterialNone);\n}\n\nfloat SparkCircle(vec2 uv, vec2 center, float rad)\n{\n    float d = length(uv - center);\n    return smoothstep(rad, 0.0, d);\n}\n\nfloat SparkRect(vec2 uv, vec2 center, vec2 size, float ang)\n{\n    vec2 cs = vec2(cos(ang), sin(ang));\n    uv -= center;\n    uv = vec2(dot(uv, cs), dot(uv.yx * vec2(-1.0, 1.0), cs));\n    \n    vec2 x = smoothstep(size*0.5, vec2(0.0, 0.0), abs(uv));\n    return pow(x.x * x.y, 3.0);\n}\n\nfloat Spark(vec2 uv, vec2 center, float ang)\n{\n    float f = 0.0;\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang);\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang+radians(60.0));\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang+radians(120.0));\n    f += SparkCircle(uv, center, 0.01);\n    return f;\n} \n\nvec3 Colorize(Ray ray, RayHit hit)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);   \n    color.rgb = SkyColor(ray.direction);\n    \n    // If there was an intersection, compute normal and the hit surface color.\n    if (hit.material != kMaterialNone)\n    {\n        vec3 p = ray.direction * hit.time + ray.origin;\n        vec3 n = SceneNormal(p);\n        \n        color.rgb = mix(vec3(0.0, 0.0, 0.0), SkyColor(reflect(ray.direction, n)), 1.0 - pow(length(n.xz), 16.0));\n        \n        if (hit.material == kMaterialHeart)\n        {\n            color.rgb += gHeartColoring * vec3(0.4, 0, 0);\n        }\n        \n        //color.rgb = SceneNormal(p);//0.3 + 0.7*pow(max(0., Normal(p).z), 30.0);\n    }\n    \n    return color;\n}\n                        \n// --- Main --------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Setup globals.\n\tgAnimTime      = mod(1.5 * iTime, 20.0);\n\tgHeartPos      = vec3(0.0, -3.5 + 5.0 * smoothstep(1.0, 3.0, gAnimTime), -12.0);\n\tgHeartMorph    = smoothstep(2.5, 4.0, gAnimTime);\n\tgHeartColoring = smoothstep(4.0, 6.0, gAnimTime);\n\tgWaveTime      = max(0.0, gAnimTime - 0.8);\n\tgMsgFadeInTime = smoothstep(7.0, 9.0, gAnimTime);\n\tgFadeTime      = smoothstep(0.0, 1.0, gAnimTime) * smoothstep(20.0, 19.0, gAnimTime);\n\n    // Get uvs in [-1 1] range and correct them with the aspect ratio.\n    vec2 uv = 2.0*(fragCoord.xy / iResolution.xy)-1.0;\n    uv *= vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // Generate first ray and raymarch along scene.\n    Ray ray = ViewportToRay(uv, kOnes.zzz, QuatFromAxisAngle(vec3(1.0, 0.0, 0.0), radians(6.0)));\n    RayHit hit = Raymarch(ray);    \n\n    // Initialize background color.\n    vec3 color = Colorize(ray, hit);\n    \n    // Show sparks around the heart\n    for(int i = 0; i < 8; i++)\n    {\n        float t = max(0.0, (gAnimTime + (float(i)) * 0.2) - 6.0);\n        float s = floor(t / 0.4);\n        float sTime = fract(t / 0.4);\n        vec2 sPos = vec2(Hash(s * 61.0), Hash(s * 17.0));\n        sPos = 2.0 * sPos - 1.0;\n        sPos *= 0.15;\n        color.rgb += sin(sTime * kPI) * Spark(uv, sPos, 0.0) * vec3(1.0, 0.4, 0.4);\n    }\n    \n    // Show the valentine's message\n    /*\n    if (gMsgFadeInTime > 0.0)\n    {\n        vec2 texAspect = vec2(1.0, -4.0);\n        vec2 texUv = uv * texAspect;\n        texUv = clamp(texUv * 0.5 + 0.5, 0.0, 1.0);\n        \n        vec2 texMsg = texture(iChannel0, texUv).rg;\n        color.rgb += gMsgFadeInTime * (texMsg.y * vec3(0.4, 0.0, 0.0) + texMsg.xxx);        \n    }\n    */\n    \n    // Apply vignetting effect.\n    color.rgb -= color.rgb*0.2*dot(uv, uv);\n\n    fragColor = vec4(gFadeTime * color, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n    vec4 fragColor;\n    mainImage(fragColor, gl_FragCoord);\n    gl_FragColor = fragColor;\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2132, 2168, 2216, 2216, 2326], [2328, 2363, 2391, 2391, 2423], [2425, 2467, 2506, 2506, 2586], [2670, 2708, 2729, 2729, 2796], [2798, 2836, 2856, 2856, 2943], [2945, 2993, 3013, 3013, 3108], [3110, 3129, 3156, 3156, 3452], [3454, 3473, 3500, 3500, 4018], [4020, 4449, 4468, 4468, 4736], [4738, 4738, 4757, 4757, 4999], [5001, 5083, 5132, 5132, 5279], [5281, 5281, 5323, 5323, 5425], [5427, 5427, 5488, 5488, 5583], [5585, 5585, 5621, 5621, 5687], [5771, 5827, 5922, 5922, 6107], [6109, 6109, 6215, 6215, 6479], [6563, 6729, 6762, 6811, 7856], [7858, 8004, 8037, 8037, 8316], [8318, 8400, 8462, 8462, 8513], [8515, 8515, 8581, 8581, 8656], [8658, 8658, 8724, 8724, 8775], [8777, 8777, 8852, 8852, 9121], [9123, 9205, 9231, 9231, 9254], [9256, 9256, 9290, 9290, 9355], [9357, 9439, 9476, 9509, 9719], [9721, 9721, 9754, 9754, 10013], [10015, 10015, 10038, 10085, 10530], [10532, 10532, 10558, 10558, 10947], [10949, 10949, 11001, 11001, 11074], [11076, 11076, 11137, 11137, 11356], [11358, 11358, 11404, 11404, 11673], [11676, 11676, 11712, 11712, 12389], [12415, 12497, 12552, 12571, 14355]], "test": "untested"}
{"id": "Xsy3Dm", "name": "Ha'tak arrival", "author": "pmjo", "description": "My first gpu generated scene using distance fields. Incomplete and quite slow since not optimized at all.", "tags": ["distancefields", "pyramids"], "likes": 26, "viewed": 5087, "published": "Public", "date": "1454701776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Initial camera settings\n\nvec3 cp = vec3(4.2, 2.8, 2.9); // Camera position\nvec3 ct = vec3(1.0, 0.8, 0.0); // Camera target\n\n#define ROTATE_CAMERA 1\n\n// Initial light settings\n\nvec4 ac = vec4(0.2, 0.2, 0.2, 1.0); // Ambient color\nvec4 lc = vec4(1.0, 0.88, 0.54, 1.0); // Light color\nvec3 lp = vec3(4.0, 1.5, -3.5); // Light position\n\n#define USE_LIGHT_RADIUS 1\n\nfloat lr = 12.0; // Light radius\n\n// Rendering settings\n\nconst int mx = 64; // Max steps\nconst float pr = 0.001; // Precision\nconst float np = 0.01; // View frustum near plane\nconst float fp = 16.0; // View frustum far plane\nvec3 sc = vec3(0.74, 0.90, 1.0); // Sky color\n\n// Helpers\n\nconst vec2 e = vec2(0.0, 0.008); // Swizzle helper for normal calculation\n\n// Distance functions\n\nvec2 u(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\nfloat dfb(vec3 p, vec3 s)\n{\n    vec3 d = abs(p) - s;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat dfs(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nvec3 rp(vec3 p, vec3 s)\n{\n    return mod(p, s) - 0.5 * s;\n}\n\nfloat dfd(vec3 p)\n{\n    float s1 = length(p - cp);\n    float s2 = length(p);\n    float m1 = 1.0 - clamp(s1 / 12.0, 0.0, 1.0);\n    float m2 = clamp(s2 / 8.0, 0.0, 2.0);\n\n    float a = sin(p.x * 0.5) * 0.25 + sin(p.z * 1.5) * 0.1;\n    float b = sin(p.z * 3.0 + p.x * 2.0) * 0.05;\n    float c = sin(p.z * 40.0 * p.y + p.x * 20.0 * p.y) * 0.004;\n    float d = sin(p.z * p.y * p.x * 80.0) * 0.005;\n\n    return p.y + (a * m2 + b * m2 + c * m1 + d * m1);\n}\n\nfloat dfp(vec3 p, float s)\n{\n    float a = dfb(p, vec3(s, 0.05 * s, s));\n    float b = dfb(p + vec3(0.0, -s, 0.0), vec3(s, s, s));\n\n    float ab = mix(a, b, 0.52); \n\n    return ab;\n}\n\nfloat dfp1(vec3 p) {\n    float a = dfp(p + vec3(-2.2, 0.5, 4.5), 1.5);\n    float b = step(abs(sin(p.y * 30.0)), 0.5) * 0.015;\n\n    return a + b;\n}\n\nfloat dfp2(vec3 p) {\n    float a = dfp(p + vec3(0.0, 0.3, 0.0), 2.0);\n    float b = step(abs(sin(p.y * 35.0)), 0.5) * 0.015;\n    float c = dfb(p - vec3(1.8, 0.03, 0.0), vec3(0.2, 0.1, 0.1));\n    float d = dfb(p - vec3(2.0, 0.02, 0.0), vec3(0.03, 0.08, 0.04));\n\n    a = min(a + b, max(-d, c));\n\n    return a;\n}\n\nfloat dfss(vec3 p, float s)\n{\n    float aa = dfb(p, vec3(s, 0.05 * s, s));\n    float bb = dfb(p + vec3(0.0, -s, 0.0), vec3(s, s, s));\n    float c = dfb(p + vec3(0.0, 0.18, 0.0), vec3(s * 1.1, 0.22 * s, s * 1.1));\n    float d = dfb(p + vec3(0.0, -0.25, 0.0), vec3(s * 0.915, 0.066 * s, s * 0.915));\n    float e = dfb(p + vec3(0.0, -1.78, 0.0), vec3(s * 0.22, 0.016 * s, s * 0.22));\n\n    float a = mix(aa, bb, 0.5);\n\n    float x = mod(p.x * 40.0, 2.0) * 0.002 + mod(p.z * 40.0, 2.0) * 0.002;\n    float x2 = mod(floor(p.x * 10.0), 2.0) * 0.005 + mod(floor(p.z * 10.0), 2.0) * 0.005;\n\n    a = max(-c, min(min(a + x, d + x2), e + x2));\n\n    float b = dfs(p, s * 0.8);\n\n    return max(-b, a);\n}\n\nvec2 df(vec3 p)\n{\n    vec2 a = vec2(dfd(p), 0.0);\n    vec2 b = vec2(min(dfp1(p), dfp1(p + vec3(8.0, 0.2, -6.0))), 1.0);\n    vec2 c = vec2(dfp2(p), 1.0);\n\n    float t0 = 0.08;\n    float t1 = -5.0;\n    float t = 1.0;\n\n    if(iTime < 10.0) {\n        t = sin(iTime * 0.15);   \n    }\n\n    vec2 d = vec2(dfss(p + vec3(0.0, mix(t1, t0, t), 0.0), 2.04), 2.0);\n\n    vec2 r = u(u(u(a, b), c), d);\n\n    return r;\n}\n\n// Rendering\n\nvec3 cn(vec3 p)\n{\n    return normalize(vec3(df(p + e.yxx).x - df(p - e.yxx).x, df(p + e.xyx).x - df(p - e.xyx).x, df(p + e.xxy).x - df(p - e.xxy).x));\n}\n\nfloat ss(vec3 ro, vec3 rd, float mint, float tmax) // thanks iq\n{\n    float res = 1.0;\n    float t = mint;\n\n    for(int i=0; i<16; i++)\n    {\n        float h = df(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        \n        if(h < 0.001 || t > tmax)\n        {\n            break;\n        }\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat ao(vec3 p, vec3 n)  // thanks iq\n{\n    float s = 0.01;\n    float t = s;\n    float oc = 0.0;\n\n    for(int i=0; i<9; i++)\n    {\n        float d = df(p + n * t).x;\n        oc += t - d;\n        t += s;\n    }\n\n    return clamp(oc, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    #if ROTATE_CAMERA\n    float s = 0.02;\n    float l = length(ct.xz - cp.xz) + 0.5;\n    cp.x = sin(iTime * s + 1.0) * l;\n    cp.z = cos(iTime * s + 1.0) * l;\n    #endif\n\n    vec3 wu = vec3(0.0, 1.0, 0.0);\n    vec3 cd = normalize(ct - cp);\n    vec3 cr = normalize(cross(wu, cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    vec2 uv = gl_FragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec4 bc = vec4(mix(vec3(1.0), sc, gl_FragCoord.y / iResolution.y * 0.5), 1.0);\n    vec4 c = bc;\n    vec3 rd = normalize(cd + cr * uv.x + cu * uv.y);\n    float t = np;\n    bool h = false;\n    vec3 p;\n    vec2 d;\n\n    for(int i=0; i<mx; i++)\n    {\n        p = cp + rd * t;\n        d = df(p);\n\n        if((d.x < pr) || (i == (mx - 1)))\n        {\n            h = true;\n\n            break;\n        }\n        else\n        {\n            t += d.x;\n\n            if(t > fp)\n            {\n                break;\n            }\n        }\n    }\n    \n    if(h)\n    {\n\t\tvec3 ld = lp - p;\n\n        vec3 n = cn(p);\n\n        float dl = max(0.0, dot(n, normalize(ld)));\n\n        vec4 mc = vec4(0.5, 0.5, 0.5, 1.0);\n        float s = 0.0;\n\n        if(d.y == 1.0)\n        {\n            mc = vec4(0.82, 0.66, 0.34, 1.0);\n        }\n        else if(d.y == 2.0)\n        {\n            s = pow(dl, 32.0); \n\n            mc = vec4(0.6, 0.6, 0.6, 1.0);   \n        }\n        else {\n            mc = vec4(0.82, 0.66, 0.34, 1.0);\n        }\n\n        #if USE_LIGHT_RADIUS\n        vec3 r = ld / lr;\n        float a = max(0.0, 1.0 - dot(r, r));\n        c = mc * (ac + lc * (dl + s) * a);\n        #else\n        c = mc * (ac + lc * (dl + s));\n        #endif\n\n        c *= ss(p, lp, 0.02, 2.5);\n        c -= ao(p, n) * 0.4;\n\n        c = mix(c, bc, 1.0 - exp(-0.01 * t * t));   \n    }\n\n    fragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsy3Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[723, 746, 770, 770, 804], [806, 806, 833, 833, 928], [930, 930, 958, 958, 986], [988, 988, 1013, 1013, 1047], [1049, 1049, 1068, 1068, 1498], [1500, 1500, 1528, 1528, 1682], [1684, 1684, 1704, 1704, 1830], [1832, 1832, 1852, 1852, 2141], [2143, 2143, 2172, 2172, 2831], [2833, 2833, 2850, 2850, 3236], [3238, 3252, 3269, 3269, 3404], [3406, 3406, 3471, 3471, 3780], [3782, 3782, 3822, 3822, 4026], [4028, 4028, 4083, 4083, 5877]], "test": "untested"}
{"id": "Xsy3DV", "name": "Make a square", "author": "amdbcg", "description": "My goal was to make a square. I succeeded. yay! ", "tags": ["square"], "likes": 0, "viewed": 97, "published": "Public", "date": "1456364173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate ( vec2 vec, float f){\n    // the rotation matrix. \n\tmat2 mrot = mat2( cos(f) ,sin(f), // column 1\n        \t\t\t-sin(f), cos(f));// column 2 \n    \n    return mrot*vec; //Rv\n}\n\nvec3 rotate(vec3 vec, float f){\n\tfloat sin_t  = sin(radians(f));\n    float cos_t  = cos(radians(f));\n    mat4 mrot  = mat4( 1.0, 0.0   ,\t0.0,\t0.0,\n                       0.0, cos_t ,\t-sin_t, 0.0,\n                       0.0, sin_t ,\tcos_t, \t0.0,\n                       0.0, 0.0   ,  0.0, \t1.0);\n    return vec;// NOT WORKING ATM\n\t\n}\nvoid transform(in mat4 mat){\n    mat4 m = mat4(mat[0][0], \tmat[0][1],\tmat[0][2],\tmat[0][3],\n                  mat[1][0],\tmat[1][1],\tmat[1][2],\tmat[1][3],\n                  mat[2][0],\tmat[2][1],\tmat[2][2],\tmat[2][3],\n                  mat[3][0],\tmat[3][1],\tmat[3][2],\tmat[3][3]);\n    //mInv\n                                              \n\n}\nvec2 multiply( vec2 ins, float cs, float sn ) {\n  vec2 result;\n  result.x = ins.x * cs - ins.y * sn;\n  result.y = ins.x * sn + ins.y * cs;\n  return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\tvec2 p = uv - vec2(tan(iTime)*.3+.8,sin(iTime)*.3 + .5);\n    p *= 0.8;\n    vec3 col = vec3 ( .8,0.8,.8);\n    \n    float speed = 7.0;\n   // p = multiply(p, 3.0*cos(iTime*speed), 3.0*sin(iTime*speed));\n    vec2 q = p;\n    p = rotate(p,-iTime*1.50);\n   \n    float r = .1;\n    if(abs(p.y) < r ){\n\t\t col *= smoothstep( .1, .1, abs(p.x));\n             \n    }\n    \n    \n    fragColor = textureProj(iChannel0,vec3(p/length(p),p.x/length(p*uv) ) );       \n    fragColor += vec4(col,1.0);\n    \n}\n\n\n\n//https://en.wikipedia.org/wiki/Rotation_matrix\n//https://en.wikipedia.org/wiki/Gaussian_elimination", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsy3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 62, 183], [185, 185, 216, 216, 516], [517, 517, 545, 545, 856], [857, 857, 904, 904, 1014], [1017, 1017, 1074, 1074, 1649]], "test": "untested"}
{"id": "Xsy3RV", "name": "I want to learn shaders", "author": "Krumons", "description": "I am experimenting with basic things", "tags": ["learning"], "likes": 0, "viewed": 444, "published": "Public", "date": "1455278373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 calculateCenter(){\n    float iTime2 = iTime+500.0;\n        return vec2((sin(iTime2+cos(iTime2*3.2))+1.0)/2.0,(sin((iTime2+sin(iTime2*3.2))*3.0)+1.0)/2.0);\n}\n\nfloat rand(vec2 co){\n    float iTime2 = iTime+500.0;\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co){\n    float iTime2 = iTime+500.0;\n    return fract(sin(dot(co.xy ,vec2(0.06*rand(vec2(iTime2/100.0,iTime2/200.0)),0.32*iTime2/50.0))) * (sin(iTime2/2.0)+1.0)*20.0);\n}\n\nfloat rand3(vec2 co){\n    float iTime2 = iTime+500.0;\n    return fract(cos(dot(co.xy ,vec2(0.453,0.12*iTime2/255.0))) * (sin(iTime2/8.0)+1.0)*23.5);\n}\n\nfloat rand4(vec2 co){\n    float iTime2 = iTime+500.0;\n    return fract(sin(dot(co.xy ,vec2(0.9858*iTime2/20.0,0.661*iTime2/6.0))) * (sin(iTime2/3.0)+1.0)*1.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float iTime2 = iTime+500.0;\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    vec4 color = vec4(0,0,0,1.0);\n    float speed = 1.0;\n    float size = 0.2;\n\t\n    vec2 position = calculateCenter();\n    \n    fragColor = color;\n\t\n    color = vec4(rand2(uv.xy),rand3(uv.xy),rand4(uv.xy),1);\n    \n    if (((uv.x > position.x - (size+sin(iTime2/0.7)/10.0 +sin(iTime2/0.3)/9.0)) && (uv.x < position.x + (size+sin(sin(iTime2)/0.3)/10.0)+sin(iTime2/0.3)/9.0)) && ((uv.y > position.y - (size+sin(iTime2/0.98)/12.0)*2.5) && (uv.y < position.y + (size+cos(iTime2/0.8)/10.0)*1.3))){\n    \tcolor = vec4(rand2(uv.xy),rand2(uv.xy),rand3(uv.xy),1);\n    }\n    \n    \n    fragColor = color;\n\n\n}\n\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsy3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 161], [163, 163, 183, 183, 287], [289, 289, 310, 310, 475], [477, 477, 498, 498, 627], [629, 629, 650, 650, 790], [792, 792, 848, 848, 1521]], "test": "untested"}
{"id": "Xsy3zd", "name": "blood flow", "author": "nsweb", "description": "This is the result of some experiments with the curl noise idea from Robert Bridson.\nIt uses some 3d simplex noise code from nikat for the flow perturbation.\n", "tags": ["curl", "flow", "simplexnoise", "vectorfield"], "likes": 21, "viewed": 1134, "published": "Public", "date": "1455886691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Created by Nicolas SÃ©rouart, nsweb 2015\n * This work is licensed under a \n * Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n * http://creativecommons.org/licenses/by-nc-sa/3.0/\n *  - You must attribute the work in the source code \n *    (link to https://www.shadertoy.com/view/Xsy3zd).\n *  - You may not use this work for commercial purposes.\n *  - You may distribute a derivative work only under the same license.\n */\n\n// uncomment for 2D curl debugging \n//#define SHOW_ARROW\n\nconst float ARROW_TILE_SIZE = 0.045;\n\n// signed distance to capsule (for arrow visualization)\nvec2 sdCapsule(vec3 p, vec3 p0, vec3 p1, float r)\n{\n    vec3 v = vec3( p1 - p0 );\n\tvec3 w = vec3( p - p0 );\n\tfloat t_seg = max( dot( v, w ), 0.0 );\n\n\tfloat v2 = dot( v, v );\n\tt_seg = min( t_seg, v2 );\n\tt_seg = t_seg / v2;\n\tw += v*(-t_seg);\n\n\treturn vec2( sqrt( dot( w, w) ) - r, t_seg );\n}\n\n// computes arrow center location from given pos\nvec3 arrowTilePos(vec3 p) \n{\n\treturn (floor(p / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// get the arrow color under pos (transparent if no hit)\nvec4 arrowColor(vec3 p, vec3 arrow_center, vec3 arrow_vec) \n{\n    const float scale = ARROW_TILE_SIZE;\n    arrow_vec *= 0.15;\n\tvec2 darrow = sdCapsule(p, arrow_center - arrow_vec*scale, arrow_center + arrow_vec*scale, (ARROW_TILE_SIZE*1.005)*0.5 );\n\tif( darrow.x > 0.0 )\n        return vec4(0.0);\n    \n    return vec4( mix(vec3(0.2,0.0,0.0), vec3(0.5,1.0,0.5), darrow.y), 1.0 );\n}\n\n/*************************************************/\n/* 3d simplex noise code taken from nikat\n * https://www.shadertoy.com/view/XsX3zB\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/*************************************************/\n\n\n// the scalar field driving the effect\n// curl operator is applied on top of it\nfloat field2d(vec3 p)\n{\n    // combination of an upward stream...\n    float v = -p.x*(1.0 - p.y);\n    // ... and of simplex noise\n    v += 0.25*(1.2 + 0.5*p.y) * simplex3d( vec3( p.xy*4.0, iTime*0.5 ) );\n\n    return v;\n}\n\n// the curl operator in 2d\nvec3 curl2d(vec3 p)\n{\n    vec3 e = vec3(0.001,-0.001,0.0);\n    float fxp = field2d(p + e.xzz);\n    float fxm = field2d(p + e.yzz);\n    float fyp = field2d(p + e.zxz);\n    float fym = field2d(p + e.zyz);\n\n    vec3 c = vec3( \t(fyp - fym) / (2.*e.x),\n                 \t(-fxp + fxm) / (2.*e.x),\n                 \t0.0 );\n\treturn c;   \n}\n\n// computes stream color at given pixel pos, returns transparent if outside of range\nvec4 getColor2d(vec3 p)\n{\n    const int step_count = 160;\n    const float dt = 0.005;\n    int step_idx = 0;\n    \n    for( int i = 0; i < step_count; i++ )\n    {   \n    \tvec3 f = curl2d(p);\n        p -= f * dt;\n        if( p.y < -1.3 )\n            break;\n        step_idx++; \n    }\n    \n    if( step_idx < step_count && abs(p.x) < 0.4 )\n    {\n        float fade = 1.0 - smoothstep( 0.15, 0.4, abs(p.x) );\n        float ratio = pow( float(step_idx) / float(step_count), 2.0 );\n        vec3 col = texture( iChannel0, vec2(abs(p.x), ratio-iTime*0.5) ).rgb;\n        col *= vec3(0.8, 0.1, 0.1);\t // red tint\n        col = pow( col, vec3(1.6) ); // darkens color\n        \n        return vec4( col, fade * (1.0 - ratio) );\n    }\n    \n    return vec4(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p = vec3( (fragCoord.xy / iResolution.xx - 0.5) * 2.0, 0.0 );\n    \n#ifdef SHOW_ARROW\n    vec4 ar = arrowColor( p, arrowTilePos(p), curl2d( arrowTilePos(p) ) );\n#else\n    vec4 ar = vec4(0.0);\n#endif\n\t\n    vec4 c = getColor2d( p );\n    vec3 bg_col = vec3(field2d( p ));\n    vec4 col = mix( vec4(bg_col*0.5 + 0.5,1.0), ar, ar.a );\n    col = mix( col, c, c.a );\n\n    fragColor = col;\n}\n\n\n\n\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsy3zd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[550, 606, 657, 657, 895], [897, 946, 974, 974, 1038], [1040, 1097, 1158, 1158, 1477], [1619, 1692, 1714, 1714, 1887], [1994, 2017, 2042, 2295, 3212], [3268, 3348, 3371, 3413, 3568], [3570, 3597, 3618, 3618, 3928], [3930, 4015, 4040, 4040, 4764], [4767, 4767, 4824, 4824, 5215]], "test": "untested"}
{"id": "XsyGDV", "name": "Raycasting test (Anastadunbar)", "author": "anastadunbar", "description": "It made me do this because of https://www.shadertoy.com/view/MdXXz2. It's like ray-marching without ray problems.", "tags": ["raycaster", "layer"], "likes": 4, "viewed": 192, "published": "Public", "date": "1456417452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//SETTINGS\nconst int LOOPS = 1000;\nfloat DEPTH_DIV = 120.;\nfloat SCALE_DIV = 50.;\nconst float PRECISE = 1.;\nbool VOLUME = false;\n\n#define PI 3.1415926535897932384626433832795028\nvec3 rX(vec3 p, float a) { //YZ\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.y = c * q.y - s * q.z;\n\tp.z = s * q.y + c * q.z;\n    return p;\n}\n\nvec3 rY(vec3 p, float a) { //XZ\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.x = c * q.x + s * q.z;\n\tp.z = -s * q.x + c * q.z;\n    return p;\n}\n\nvec3 rZ(vec3 p, float a) { //XY\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.x = c * q.x - s * q.y;\n\tp.y = s * q.x + c * q.y;\n    return p;\n}\n\n//Map, 1 is wall, 0 is empty.\nfloat map(vec3 p) { \n    float time = iTime;\n    p = rY(p,(fract(time*.4)*float(mod(time*.4,4.)>3.)*(PI*2.)));\n    float tunnel = float((p.x > 5. || p.x < -5.) || (p.y > 3. || p.y < -3.));\n    float radius = 1.4;\n    float sphere = float(length(p-vec3(asin(sin(time))*2.8,abs(sin(time*3.)*2.)-((3.-(radius/2.))),5.)) < radius);\n    radius = 0.2;\n    vec3 pos = vec3(0.,.7,1.4);\n    pos = rX(p-pos,time);\n    float bar = float((pos.y > -radius) && (pos.y < radius) && (pos.z > -radius) && (pos.z < radius));\n    return tunnel+sphere+bar;\n}\n\n#define clamps(x) clamp(x,0.,1.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    DEPTH_DIV *= PRECISE; SCALE_DIV *= PRECISE;\n\tvec2 uv = (fragCoord.xy / iResolution.xy)-.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Raycaster / Layering\n    vec3 p; //Position\n    float a = 0.; //\"Alpha\"\n    for (int i = 0; i < LOOPS*int(max(PRECISE,1.)); i++) {\n        vec3 pos = vec3(uv*((float(i)/SCALE_DIV)+1.),float(i)/DEPTH_DIV);\n        if (map(pos) >= 1.) {\n            if (VOLUME) {\n                a += 1./float(LOOPS*int(max(PRECISE,1.)));\n            } else {\n                a = 1.;\n                break; //Pixel doesn't need to be filled anymore. Stop the loop.\n            }\n        } else {\n            p = pos;\n        }\n    }\n    float fog = (p.z*DEPTH_DIV)/(float(LOOPS)*PRECISE);\n    if (VOLUME) {\n        fragColor = vec4(vec3(a),1.0);\n    } else {\n\t\tfragColor = vec4(fract(p)*(1.-pow(fog,4.)),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsyGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 178, 204, 209, 323], [325, 325, 351, 356, 471], [473, 473, 499, 504, 618], [620, 650, 669, 669, 1188], [1223, 1223, 1280, 1280, 2128]], "test": "untested"}
{"id": "XsyGWy", "name": "Protoplanetary Solar System", "author": "marvindanig", "description": "Forked off a shader and original work by Duke: Ref:  https://www.shadertoy.com/view/MdtGRl ", "tags": ["astronomy"], "likes": 15, "viewed": 3128, "published": "Public", "date": "1456280408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Protoplanetary disk\" by Duke: https://www.shadertoy.com/view/MdtGRl \n//-------------------------------------------------------------------------------------\n// Based on \"Dusty nebula 1\" (https://www.shadertoy.com/view/4lSXD1) \n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//-------------------------------------------------------------------------------------\n\n//#define MOUSE_CAMERA_CONTROL\n\n// comment this string to see fluffy clouds\n#define DENSE_DUST\n\n#define DITHERING\n#define BACKGROUND\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nmat2 Spin(float angle)\n{\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.1)/256.0, -100.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nfloat fpn(vec3 p)\n{\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;// + pn(p*.5)*.625;\n}\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Ring(vec3 p)\n{\n  vec2 q = vec2(length(p.xy)-2.3,p.z);\n  return length(q)-0.01;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n\nfloat Disk( vec3 p, vec3 t )\n{\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.5);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p)\n{\n    float t=0.7*iTime;\n\tfloat d1 = Disk(p,vec3(2.0,1.,0.05)) + fpn(vec3(Spin(t*0.25+p.z*.10)*p.xy*20.,p.z*20.-t)*5.0) * 0.545;\n    float d2 = Ring(p);\n    return smin(d1,d2,1.0);\n\n}\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( 1.1*vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added for disk\n\tvec3 colCenter = 6.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 2.*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.5)/2.0, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool Raycylinderintersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5\n\tfloat a = dot(dir.xy, dir.xy);\n\tfloat b = dot(org.xy, dir.xy);\n\tfloat c = dot(org.xy, org.xy) - 12.;\n\n\tfloat delta = b * b - a * c;\n\tif( delta < 0.0 )\n\t\treturn false;\n\n\t// 2 roots\n\tfloat deltasqrt = sqrt(delta);\n\tfloat arcp = 1.0 / a;\n\tnear = (-b - deltasqrt) * arcp;\n\tfar = (-b + deltasqrt) * arcp;\n\t\n\t// order roots\n\tfloat temp = min(far, near);\n\tfar = max(far, near);\n\tnear = temp;\n\n\tfloat znear = org.z + near * dir.z;\n\tfloat zfar = org.z + far * dir.z;\n\n\t// top, bottom\n\tvec2 zcap = vec2(1.85, -1.85);\n\tvec2 cap = (zcap - org.z) / dir.z;\n\n\tif ( znear < zcap.y )\n\t\tnear = cap.y;\n\telse if ( znear > zcap.x )\n\t\tnear = cap.x;\n\n\tif ( zfar < zcap.y )\n\t\tfar = cap.y;\n\telse if ( zfar > zcap.x )\n\t\tfar = cap.x;\n\t\n\treturn far > 0.0 && far > near;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n\n    #ifdef MOUSE_CAMERA_CONTROL\n    R(rd.yz, -iMouse.y*0.01*pi*2.);\n    R(rd.xz, iMouse.x*0.01*pi*2.);\n    R(ro.yz, -iMouse.y*0.01*pi*2.);\n    R(ro.xz, iMouse.x*0.01*pi*2.);\n    #else\n    R(rd.yz, -pi*3.65);\n    R(rd.xz, pi*3.2);\n    R(ro.yz, -pi*3.65);\n   \tR(ro.xz, pi*3.2);    \n    #endif \n    \n    #ifdef DITHERING\n\tvec2 dpos = ( fragCoord.xy / iResolution.xy );\n\tvec2 seed = dpos + fract(iTime);\n   \t// randomizing the length \n    //rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.1-0.03); \n\t#endif \n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(Raycylinderintersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n\tfor (int i=0; i<56; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n\n\t\tfloat fld = 0.0;\n       \n\t\t// Loop break conditions.\n        if(td>(1.-1./80.) || d<0.008*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n\t  \n\t\t// evaluate distance function\n\t\td = map(pos); \n       \n\t\t// direction to center\n\t\tvec3 stardir = normalize(vec3(0.0)-pos);\n      \n\t\t// change this string to control density \n\t\td = max(d,0.08);\n      \n\t\tif (d<0.1) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = 0.1 - d;\n\t\t\t\n            #ifdef DENSE_DUST          \n\t\t\tfld = clamp((ld - map(pos+0.2*stardir))/0.4, 0.0, 1.0 );\n\t\t\tld += fld;\n            #endif\n \t\t\t\n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tfloat radiusFromCenter = length(pos - vec3(0.0));\n\t\t\tvec4 col = vec4( computeColor(td,radiusFromCenter), td );\n\t\t\n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.2;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a/0.8;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n\t\t}\n      \n\t\ttd += 1./70.;\n       \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // star in center\n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        sum.rgb+=lightColor/(lDist*lDist*lDist*7.);//*10.); //add a bloom around the light\n\n        // using the light distance to perform some falloff\n        //float atten = 1./(1. + lDist*0.125 + lDist*lDist*0.4);\n        // accumulating the color\n        //sum += w*atten*fld;\n       \n        // enforce minimum stepsize\n        d = max(d, 0.04); \n      \n        #ifdef DITHERING\n        // add in noise to reduce banding and create fuzz\n        d=abs(d)*(1.+0.28*rand(seed*vec2(i)));\n        #endif \n\t  \n        t +=  max(d * 0.3, 0.02);\n      \n\t}\n    \n    //scattering test\n\t//sum *= 1. / exp( ld * 0.2 ) * 1.05;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    // stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(pn(rd*300.0)*0.4+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n    \n   fragColor = vec4(sum.xyz,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsyGWy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[674, 769, 793, 793, 855], [857, 871, 894, 894, 1112], [1114, 1114, 1133, 1133, 1215], [1217, 1217, 1238, 1238, 1309], [1311, 1311, 1331, 1331, 1397], [1399, 1399, 1424, 1424, 1461], [1463, 1463, 1488, 1488, 1553], [1556, 1556, 1586, 1586, 1682], [1684, 1684, 1725, 1725, 1814], [1816, 1816, 1835, 1835, 2017], [2019, 2048, 2098, 2183, 2452], [2454, 2454, 2532, 2615, 3360], [3362, 3362, 3419, 3419, 7110]], "test": "untested"}
{"id": "XtjXWD", "name": "Cyclic Redundancy Engine", "author": "otaviogood", "description": "The Cyclic Redundancy Engine is an infernal machine capable of feats of great redundancy.\nI also made a short music track to go with this shader (using Ableton).", "tags": ["raymarch"], "likes": 33, "viewed": 1460, "published": "Public API", "date": "1454908075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 15.1; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat fade = 1.0;\nfloat exposure = 1.0;\n\n// other\nfloat marchCount = 0.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec3 GetEnvColor2(vec3 rayDir)\n{\n    // fade bottom to top so it looks like the softbox is casting light on a floor\n    // and it's bouncing back\n    vec3 final = vec3(1.0) * dot(rayDir, /*sunDir*/ vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5;\n    final *= 0.25;\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    // fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    // purple lights from side\n    //final += vec3(8.0,6.0,7.0) * saturate(0.001/(1.0 - abs(rayDir.x)));\n    // yellow lights from side\n    //final += vec3(8.0,7.0,6.0) * saturate(0.001/(1.0 - abs(rayDir.z)));\n    return vec3(final);\n}\n\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// capped cylinder distance field\nfloat cylCap(vec3 p, float r, float lenRad)\n{\n    float a = length(p.xy) - r;\n    a = max(a, abs(p.z) - lenRad);\n    return a;\n}\n\nfloat cyl(vec3 p, float rad)\n{\n    return length(p.xy) - rad;\n}\n\nfloat sdTorus(vec3 p, vec2 radOuterInner)\n{\n  vec2 cylAndHeight = vec2(length(p.xz) - radOuterInner.x, p.y);\n  return length(cylAndHeight) - radOuterInner.y;\n}\n\nfloat sSphere(vec3 p, float rad)\n{\n    return length(p) - rad;\n}\n\n// k should be negative. -4.0 works nicely.\n// smooth blending function\nfloat smin(float a, float b, float k)\n{\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n\nfloat Repeat(float a, float len)\n{\n    return mod(a, len) - 0.5 * len;\n}\n\nvec3 RadialRepeat(vec3 p, float ang)\n{\n    float len = length(p.xz);\n    float a = atan(p.z, p.x);// / PI;\n    a = Repeat(a, PI/ang);\n    return vec3(cos(a)*len, p.y, sin(a)*len);\n}\n\nfloat MakeGear(vec3 p, float rad, float side)\n{\n    p = RotateZ(p, -localTime + PI * 0.2 + (side-1.0)*0.39);\n    p.xzy = RadialRepeat(p.xzy, 2.0);\n    float gear = sdTorus((p - vec3(1.5, 0.0, 0.0)).xzy, vec2(rad-0.3, 0.1));\n    return gear;\n}\n\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material index.\nvec2 DistanceToObject(vec3 p)\n{\n    // make a box where the space is subdivided around in a circle.\n    // Then subtract out a few cylinders to get the dynamic ball-roller.\n    vec3 orig = p;\n    p += vec3(0.0, 0.0, 0.0);\n    float wobble = -localTime * 4.0 - PI*0.5;\n    vec3 wobble2 = vec3(cos(wobble), 0.0, sin(wobble))*0.5;\n    p += wobble2;\n    vec2 distAndMat = vec2(0.0);\n    float a = atan(p.z, p.x);// / PI;\n    vec3 rep = RadialRepeat(p, 4096.0);\n    distAndMat.x = length(rep- vec3(3.5, 0.0, 0.0)) - 0.4;\n    a = (a+0.5);\n    rep = RotateZ(rep - vec3(3.5, 0.0, 0.0), localTime+a*0.25) + vec3(3.5, 0.0, 0.0);\n    distAndMat.x = sdBox(rep - vec3(3.5, 0.0, 0.0), vec3(0.95,0.95,2.9));\n    distAndMat.x = max(distAndMat.x, -cyl(rep - vec3(3.5, 0.0, 0.0), 0.9));\n\n    float crad = 1.38;\n    float disp = 2.0;\n    vec3 railMirror = vec3(rep.x - 3.5, abs(rep.y) - disp, rep.z);\n    distAndMat.x = max(distAndMat.x, -cyl(railMirror, crad));\n    railMirror = vec3(abs(rep.x - 3.5) - disp, rep.y, rep.z);\n    distAndMat.x = max(distAndMat.x, -cyl(railMirror, crad));\n    //distAndMat.x = max(distAndMat.x, -cyl(rep - vec3(3.5, -disp, 0.0), crad));\n    //distAndMat.x = max(distAndMat.x, -cyl(rep - vec3(3.5, disp, 0.0), crad));\n    //distAndMat.x = max(distAndMat.x, -cyl(rep - vec3(3.5+disp, 0.0, 0.0), crad));\n    //distAndMat.x = max(distAndMat.x, -cyl(rep - vec3(3.5-disp, 0.0, 0.0), crad));\n\n    // Make the ball and material. Rotate it around.\n    float ball = length(RotateY(p, localTime*4.0) - vec3(-2.57, 0.73, 0.0)) - 0.7;\n    distAndMat = matmin(distAndMat, vec2(ball, 1.0));\n\n    // Make the clover-gears\n    vec3 gPos = orig;\n    float side = sign(gPos.x);\n    gPos.x = abs(gPos.x);\n    gPos -= vec3(3.4 - wobble2.x/1.414*side, -3.3, 0.0);\n    float gear = MakeGear(gPos, crad, side);\n    distAndMat = matmin(distAndMat, vec2(gear, 4.0));\n\n    // Make the torus and supports\n    float torus = sdTorus(orig + vec3(0.0 + wobble2.x/1.414, 3.3, 0.0), vec2(3.4, 0.32));\n    vec3 mirror = orig;\n    mirror.z = abs(mirror.z);\n    vec3 blobPos = (mirror + vec3(wobble2.x, 3.3, -3.4)).zxy;\n    float blob = sdTorus(blobPos, vec2(0.4, 0.15));\n    torus = min(torus, cylCap(blobPos + vec3(-0.4, 0.0, 8.0), 0.15, 8.0));\n    torus = min(torus, blob);\n    distAndMat = matmin(distAndMat, vec2(torus, 5.0));\n\n    // Make the middle spiral and the turntable base\n    vec3 warp = RotateY(orig, localTime*4.0);\n    float p0 = p.y;\n    float p1 = p.y;\n    float w2 = warp.y+PI*0.34;\n    float spiral = length(warp.xz + vec2(cos(w2), sin(w2))*((p0*p0)*0.07) ) - 0.2;\n    float spiral2 = length(warp.xz + vec2(-cos(w2), -sin(w2))*(((p1)*(p1))*0.05) ) - 0.1;\n    spiral = min(spiral, spiral2);\n    spiral *= 0.35;\n    spiral = max(spiral, abs(p.y)-6.5);\n    float base = min(spiral, (length(orig.xz) + orig.y*2.0)*0.5+4.7);\n    base = max(base, cylCap(orig.xzy + vec3(0.0, 0.0, 6.6+4.0), 5.22, 4.4));\n    base = max(base, -sdTorus(orig + vec3(0.0, 6.25, 0.0), vec2(3.1, 0.0625)));\n    vec3 mirrorOrig = vec3(orig.x, abs(orig.z) - 3.9, orig.y);\n    base = max(base, -cyl(mirrorOrig, 0.7));\n    spiral = min(base, spiral);\n    distAndMat = matmin(distAndMat, vec2(spiral, 2.0));\n\n    return distAndMat;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    marchCount = 0.0;\n    fade = 1.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    uv /= 2.0;  // zoom in\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,-1.5,0);\n\n    // debugging camera\n    float mx=-iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=iMouse.y/iResolution.y*3.14*0.95 + PI/2.0;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*12.0;\n#else\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    const float t0 = 0.0;\n    const float t1 = 12.0;\n    const float t2 = 20.0;\n    const float t3 = 38.0;\n    // Repeat the animation after time t3\n    localTime = fract(localTime / t3) * t3;\n    if (localTime < t1)\n    {\n        float time = localTime - t0;\n        float alpha = time / (t1 - t0);\n        fade = saturate(time);\n        fade *= saturate(t1 - localTime);\n        camPos = vec3(0.0, -8.0, -8.0);\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 5.0;\n        camPos.y += smoothstep(0.0, 1.0, alpha) * 9.0;\n        camPos.z -= smoothstep(0.0, 1.0, alpha) * 6.0;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(0,-2.5,1.5);\n    } else if (localTime < t2)\n    {\n        float time = localTime - t1;\n        float alpha = time / (t2 - t1);\n        fade = saturate(time);\n        fade *= saturate(t2 - localTime);\n        camPos = vec3(12.0, 8.3, -0.5);\n        camPos.y -= alpha * 5.5;\n        camPos.x = cos(alpha*1.0) * 5.2;\n        camPos.z = sin(alpha*1.0) * 5.2;\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\n        camLookat=vec3(0,1.0,-0.5);\n    } else if (localTime < t3)\n    {\n        float time = localTime - t2;\n        float alpha = time / (t3 - t2);\n        fade = saturate(time);\n        fade *= saturate(t3 - localTime);\n        camPos = vec3(-9.0, 1.3, -10.0);\n        camPos.y -= alpha * 8.0;\n        camPos.x += alpha * 7.0;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0.0,-2.0,0.0);\n    }\n#endif\n\n\t// Camera setup for ray tracing / marching\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tvec2 distAndMat;  // Distance and material\n\tfloat t = 0.05;\n\tconst float maxDepth = 22.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0.0);\n    const float smallVal = 0.00625;\n\t// ray marching time\n    for (int i = 0; i <180; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        marchCount+=1.0;\n        // Step along the ray.\n        pos = (camPos + rayVec * t);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(pos);\n\n        // move down the ray a safe amount\n        t += distAndMat.x;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        float dist = distAndMat.x;\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\n        vec3 normal = normalize(normalU);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n\n        // Trace a relection ray\n        float refShadow = 1.0;\n        float iter = 0.01;\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\n\t\tfor (int i = 0; i < 40; i++)\n        {\n            vec3 shadowPos = nudgePos + ref * iter;\n            vec2 tempDistAndMat = DistanceToObject(shadowPos);\n\t        refShadow *= saturate(tempDistAndMat.x*150.0);\t// Shadow hardness\n            if (tempDistAndMat.x <= 0.0) break;\n\n            iter += max(0.05, tempDistAndMat.x);\n            if (iter > 7.5) break;\n        }\n        refShadow = saturate(refShadow);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        if (distAndMat.y == 2.0) texColor = vec3(0.5, 0.3, 0.3)*0.03;\n        if (distAndMat.y == 0.0) texColor = vec3(0.3,0.25,0.25)*0.1;\n        if (distAndMat.y == 1.0) texColor = vec3(0.2, 0.3, 0.71)*0.1;\n        if (distAndMat.y == 4.0) texColor = vec3(0.01, 0.01, 0.01)*0.2;\n        if (distAndMat.y == 5.0) texColor = vec3(1.0, 1.0, 1.0)*0.0015;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        vec3 lightColor = vec3(0.0);\n        // Add sky color with ambient acclusion\n        lightColor += (/*skyCol */ saturate(normal.y *0.5+0.5))*2.5;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        if (distAndMat.y == 1.0) finalColor += vec3(0.5, 0.1, 0.3)*0.5*dot(normal, -rayVec);\n        //vec3 refColor = GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*max(0.2,sunShadow);\n        vec3 refColor = GetEnvColor2(ref) * (refShadow + 0.5) * 0.5;\n        if (distAndMat.y == 0.0) refColor *= vec3(1.0, 0.5, 0.2)*3.0*dot(normal, -rayVec);\n        if (distAndMat.y == 5.0) refColor *= vec3(0.7, 0.75, 0.82)*1.0*dot(normal, -rayVec);\n        float fresnel = saturate(1.0 - dot(-rayVec, normal));\n        fresnel = mix(0.5, 1.0, fresnel);\n        finalColor += refColor * fresnel * 0.8;\n\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n        //finalColor = vec3(marchCount)/255.0;\n        //finalColor = normal * 0.5 + 0.5;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw background.\n        finalColor = GetEnvColor2(rayVec);\n    }\n    finalColor += marchCount *vec3(1.0, 0.5, 0.7)*0.001;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= exposure;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.25));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [{"id": "lss3DH", "previewfilepath": "https://soundcloud.com/flotavio/metallicmachine", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/flotavio/metallicmachine", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjXWD.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1272, 1301, 1320, 1320, 1365], [1366, 1366, 1385, 1385, 1416], [1417, 1417, 1440, 1440, 1476], [1477, 1477, 1500, 1500, 1571], [1572, 1572, 1594, 1594, 1681], [1682, 1682, 1704, 1704, 1757], [1787, 1787, 1810, 1810, 1839], [1840, 1840, 1863, 1863, 1892], [1893, 1893, 1918, 1918, 1947], [1949, 1949, 1982, 1982, 2099], [2100, 2100, 2133, 2133, 2249], [2250, 2250, 2283, 2283, 2400], [2402, 2467, 2499, 2612, 3324], [3326, 3385, 3414, 3414, 3464], [3647, 3676, 3710, 3710, 3821], [3823, 3857, 3902, 3902, 3985], [3987, 3987, 4017, 4017, 4050], [4052, 4052, 4095, 4095, 4211], [4213, 4213, 4247, 4247, 4277], [4279, 4351, 4390, 4390, 4429], [4431, 4431, 4465, 4465, 4503], [4505, 4505, 4543, 4543, 4686], [4688, 4688, 4735, 4735, 4930], [4932, 5116, 5147, 5288, 8310], [8312, 8382, 8417, 8417, 15740], [17072, 17072, 17129, 17129, 18488]], "test": "untested"}
