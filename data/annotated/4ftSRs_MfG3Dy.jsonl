{"id": "4ftSRs", "name": "felix the cat", "author": "jorge2017a2", "description": "felix the cat", "tags": ["2d", "felixthecat"], "time_retrieved": "2024-05-15T23:19:08.898203", "image_code": "//por jorge2017a2\n// abril-28-2024-\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///feliz the cat\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n\n#define S(d,b) smoothstep(antialiasing(1.5),0. , d - (b) )\n#define S2(d,b) smoothstep(4.0*antialiasing(1.5),0.,d - (b) )\n#define S3(d,b) smoothstep(12.0/antialiasing(0.5),0. , d - (b) )\n\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat SDF_I(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat SDF_U(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat SDF_D(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBordeR(vec3 pColObj, vec3 colOut, float distObj, float r )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-r,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\nvec3 DFB(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0),S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat divf(float a, float b)\n{\n    //evita crash por 1/0.0 =Infinito=error, en compilar\n    if(b==0.0)\n    {b=0.00001;}\n    return a/b;\n}\n\n\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nvec3 bigotes(vec2 uv, vec3 col)\n{\nvec2 pc1p1=vec2(1.360,.650);\nvec2 pc1p2=vec2(1.540,.670);\nvec2 pc1p3=vec2(1.780,.580);\n\nvec2 pc2p1=vec2(1.410,.540);\nvec2 pc2p2=vec2(1.580,.490);\nvec2 pc2p3=vec2(1.720,.360);\n\nvec2 pc3p1=vec2(.020,.450);\nvec2 pc3p2=vec2(.170,.580);\nvec2 pc3p3=vec2(.360,.650);\n\nvec2 pc4p1=vec2(.000,.620);\nvec2 pc4p2=vec2(.190,.700);\nvec2 pc4p3=vec2(.5330,.650);\n\nfloat d1= sdBezier(uv,pc1p1,pc1p2,pc1p3);\nfloat d2= sdBezier(uv,pc2p1,pc2p2,pc2p3);\nfloat d3= sdBezier(uv,pc3p1,pc3p2,pc3p3);\nfloat d4= sdBezier(uv,pc4p1,pc4p2,pc4p3);\n\nvec3 c1=vec3(0.0);\nvec3 c2=vec3(0.0,1.0,0.0);\ncol=DrawFigDelgado(c1,col,d1);\ncol=DrawFigDelgado(c1,col,d2);\ncol=DrawFigDelgado(c1,col,d3);\ncol=DrawFigDelgado(c1,col,d4);\n\n    return col;\n}\n\nvec3 felix(vec2 p, vec3 colout)\n{\n\nvec2 A,B, med;\nfloat dfin;\nfloat  r1 ;\n\nA=vec2(0.87,-0.06);\nr1=0.46;\nfloat d1=sdCircle(p-A,r1);\n\nA=vec2(0.69,0.08);\nr1=0.46;\nfloat d2=sdCircle(p-A,r1);\n\nA=vec2(0.65,-0.1);\nr1=0.28;\nfloat d3=sdCircle(p-A,r1);\n\nA=vec2(2.29,-0.04);\nr1=1.38;\nfloat d4=sdCircle(p-A,r1);\n\ndfin=SDF_I(d1,d2);\ndfin=SDF_U(dfin,d3);\ndfin=SDF_D(dfin,d4);\ncolout= DFB(vec3(1.0), colout, dfin);\n\nA=vec2(0.68,-0.04);\nmed=vec2(0.03,0.07);\nfloat d5=sdEllipse(p-A,med);\ncolout= DFB(vec3(0.0), colout, d5);\n\n\n\n//------ojo derecho\nA=vec2(1.05,-0.04);\nr1=0.44;\nfloat d6=sdCircle(p-A,r1);\n\nA=vec2(1.21,0.07);\nr1=0.44;\nfloat d7=sdCircle(p-A,r1);\n\nA=vec2(1.31,-0.16);\nr1=0.19;\nfloat d8=sdCircle(p-A,r1);\n\n\nA=vec2(2.06,-0.09);\nr1=1.12;\nfloat d9=sdCircle(p-A,r1);\n\ndfin=SDF_I(d6,d7);\ndfin=SDF_U(dfin,d8);\ndfin=SDF_I(d9, dfin);\ncolout= DFB(vec3(1.0), colout, dfin);\n\n\nA=vec2(1.18,-0.07);\nmed=vec2(0.03,0.07);\nfloat d10=sdEllipse(p-A,med);\ncolout= DFB(vec3(0.0), colout, d10);\n\n\n//nariz\nA=vec2(0.91,-0.49);\nmed=vec2(0.08,0.045);\nfloat d11=sdEllipse(p-A,med);\ncolout= DFB(vec3(0.0), colout, d11);\n\n\n//cabeza\nA=vec2(0.95,-0.19);\nr1=0.63;\nfloat d18=sdCircle(p-A,r1);\n\n      ///----rostro add\n\n    A=vec2(0.67,-0.39);\n    r1=0.3;\n    float d1a=sdCircle(p-A,r1);\n\n    A=vec2(1.22,-0.42);\n    r1=0.3;\n    float d2a=sdCircle(p-A,r1);\n\nd18=SDF_U(d18,d1a);\nd18=SDF_U(d18,d2a);\n\n\nfloat d18tdo=d18;\nd18=abs(d18)-0.001;\ncolout= DFB(vec3(0.0), colout, d18);\n\n//boca\nA=vec2(0.91,-1.51);\nr1=0.84;\nfloat d13=sdCircle(p-A,r1);\n\nd13=abs(d13)-0.001;\nd13=SDF_I(d18tdo,d13);\ncolout= DFB(vec3(1.0,0.0,0.0), colout, d13);\n\n\n//sup cir\nA=vec2(1.03,0.78);\nr1=0.46;\nfloat d14=sdCircle(p-A,r1);\n\n//pelo centro\nA=vec2(0.98,0.02);\nr1=0.83;\nfloat d15=sdCircle(p-A,r1);\nd15=SDF_D(d15,d18tdo);\n\n//dif pelo izq\nA=vec2(2.65,0.46);\nr1=1.18;\nfloat d16=sdCircle(p-A,r1);\n\nA=vec2(-0.74,0.76);\nr1=1.31;\nfloat d17=sdCircle(p-A,r1);\n\n\n//dif pelo\nA=vec2(1.73,0.34);\nmed=vec2(0.19,0.1);\nfloat d1b=sdTriangleIsosceles(vec2(p.x,-p.y)-A,med);\n\nA=vec2(0.15,0.2);\nmed=vec2(0.19,0.1);\nfloat d2b=sdTriangleIsosceles(vec2(p.x,-p.y)-A,med);\n\n\ndfin=SDF_D(d15,d16);\ndfin=SDF_D(dfin,d17);\ndfin=SDF_D(dfin,d14);\n\ndfin=SDF_D(dfin,d1b);\ndfin=SDF_D(dfin,d2b);\n\ncolout= DFB(vec3(1.0), colout, dfin);\n\n\n//cuerpo\nA=vec2(0.91,-1.06);\nr1=0.29;\nfloat d12=sdCircle(p-A,r1);\n//d18tdo\nd12=SDF_D(d12,d18tdo);\nd12=abs(d12)-0.01;\ncolout= DFB(vec3(0.0), colout, d12);\n\ncolout= bigotes(p-vec2(0.0,-1.0),colout);\n\n\nreturn colout;\n}\n\n///-----------------------\n\nvec3 bigotesB(vec2 uv, vec3 col)\n{\n    \nvec2 pc1p1=vec2(.020,.480);\nvec2 pc1p2=vec2(.190,.520);\nvec2 pc1p3=vec2(.370,.560);\n\nvec2 pc2p1=vec2(.100,.290);\nvec2 pc2p2=vec2(.300,.360);\nvec2 pc2p3=vec2(.410,.450);\n\nvec2 pc3p1=vec2(.450,.370);\nvec2 pc3p2=vec2(.550,.650);\nvec2 pc3p3=vec2(.850,.550);\n\nvec2 pc4p1=vec2(.690,.290);\nvec2 pc4p2=vec2(1.000,.350);\nvec2 pc4p3=vec2(1.190,.290);\n\nvec2 pc5p1=vec2(1.440,.570);\nvec2 pc5p2=vec2(1.640,.580);\nvec2 pc5p3=vec2(1.760,.590);\n\nvec2 pc6p1=vec2(1.410,.470);\nvec2 pc6p2=vec2(1.650,.460);\nvec2 pc6p3=vec2(1.800,.390);\n\n\nfloat d1= sdBezier(uv,pc1p1,pc1p2,pc1p3);\nfloat d2= sdBezier(uv,pc2p1,pc2p2,pc2p3);\nfloat d3= sdBezier(uv,pc3p1,pc3p2,pc3p3);\nfloat d4= sdBezier(uv,pc4p1,pc4p2,pc4p3);\nfloat d5= sdBezier(uv,pc5p1,pc5p2,pc5p3);\nfloat d6= sdBezier(uv,pc6p1,pc6p2,pc6p3);\n\nvec3 c1=vec3(0.0);\ncol=DrawFigBorde(c1,col,d1);\ncol=DrawFigBorde(c1,col,d2);\ncol=DrawFigBorde(c1,col,d3);\ncol=DrawFigBorde(c1,col,d4);\ncol=DrawFigBorde(c1,col,d5);\ncol=DrawFigBorde(c1,col,d6);\n\n    return col;\n}\n\nvec3 felixB(vec2 p, vec3 colout)\n{\nvec2 A,B, med;\nfloat dfin;\nfloat r1 ;\n\n//cabeza\nA=vec2(0.87,-0.2);\nr1=0.62;\nfloat d1=sdCircle(p-A,r1);\n\n//grande pelo\nA=vec2(0.88,0.02);\nr1=0.85;\nfloat d2=sdCircle(p-A,r1);\n\nA=vec2(-1.22,1.08);\nr1=1.85;\nfloat d3=sdCircle(p-A,r1);\n\nd2=SDF_D(d2,d3);\n\n\nA=vec2(0.91,0.68);\nmed=vec2(0.1,0.3);\nfloat he=0.23;\nfloat d4= sdTrapezoid(p-A, med.x, med.y, he);\nd2=SDF_D(d2,d4);\n\n\n//dif pelo 2 der\nA=vec2(2.11,0.62);\nr1=0.94;\nfloat d5=sdCircle(p-A,r1);\n\n\nA=vec2(0.08,0.27);\nmed=vec2(0.18,0.2);\nfloat d1c=sdTriangleIsosceles(vec2(p.x, -p.y)-A,med);\n\nA=vec2(1.2,-0.3);\nr1=0.54;\nfloat d5b=sdCircle(p-A,r1);\n\n\nd2=SDF_D(d2,d5);\nd2=SDF_D(d2,d1c);\nd2=SDF_D(d2,d5b);\n\ncolout= DFB(vec3(1.0), colout, d2);\ncolout= DFB(vec3(1.0), colout, d1);\n\n\n//cuerpo\nA=vec2(0.76,-1.03);\nr1=0.25;\nfloat d6=sdCircle(p-A,r1);\nd6=SDF_D(d6,d2);\ncolout= DFB(vec3(1.0), colout, d6);\n\n//ojo izq\nA=vec2(0.97,-0.04);\nr1=0.42;\nfloat d7=sdCircle(p-A,r1);\n\nA=vec2(1.4,-0.28);\nr1=0.72;\nfloat d8=sdCircle(p-A,r1);\n\nA=vec2(0.52,-0.19);\nr1=0.72;\nfloat d9=sdCircle(p-A,r1);\n\nd7=SDF_I(d7,d8);\nd7=SDF_I(d7,d9);\ncolout= DFB(vec3(1.0), colout, d7);\n\n\n//----ojo der\nA=vec2(0.99,-0.16);\nr1=0.5;\nfloat d1a=sdCircle(p-A,r1);\n\nA=vec2(1.44,0.01);\nr1=0.38;\nfloat d2a=sdCircle(p-A,r1);\n\nA=vec2(0.42,-0.19);\nr1=0.83;\nfloat d3a=sdCircle(p-A,r1);\n\nd1a=SDF_I(d1a,d2a);\nd1a=SDF_D(d1a,d3a);\ncolout= DFB(vec3(1.0), colout, d1a);\n\n\n\nA=vec2(1.09,-0.13);\nmed=vec2(0.03,0.07);\nfloat d10=sdEllipse(p-A,med);\ncolout= DFB(vec3(0.0), colout, d10);\n\nA=vec2(1.46,-0.13);\nmed=vec2(0.03,0.07);\nfloat d11=sdEllipse(p-A,med);\ncolout= DFB(vec3(0.0), colout, d11);\n\n\n//nariz\nA=vec2(1.36,-0.52);\nmed=vec2(0.07,0.05);\nfloat d13=sdEllipse(p-A,med);\nd13=abs(d13)-0.01;\ncolout= DFB(vec3(0.0), colout, d13);\n\n    colout= bigotesB(p-vec2(0.0,-1.0),colout);\n    return colout;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n    vec2 uv0=uv;\n    uv-=vec2(-0.1,0.25);\n    float esc=2.0;\n    uv*=esc;\n    \n    vec3 col=vec3(1.0)-uv0.y*2.0;\n    float opc=mod(iTime*1.5,4.0);\n    \n    if(opc<=1.0)\n        col= felix(uv,col);\n    else if(opc>1.0 && opc<=2.0 )\n        col=felixB(uv,col);\n    else if(opc>2.0 && opc<=3.0 )\n        col= felix(uv,col);\n    else if(opc>3.0 && opc<=4.0 )\n        col= felixB(vec2(1.8-uv.x,uv.y),col);\n    \n    \n    col=felixB(uv-vec2(-2.5,0.0),col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "//iq\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n///--\n\n\n\n//Quadratic Bezier - exact   (https://www.shadertoy.com/view/MlKcDD)\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ftSRs.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MfcXzl", "name": "13pong", "author": "makscee", "description": "13", "tags": ["fractal", "pong"], "time_retrieved": "2024-05-15T23:19:11.153041", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    float angle = iTime * .13 ;\n    for (int i = 0; i < 13; i++) {\n        uv = (abs(uv) - .13) * mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    }\n    fragColor = vec4(fract(uv.x * 13.), fract(uv.x * 13.), sin(uv.x * 13.), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MfcXzl.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "XfcXzs", "name": "train-240428", "author": "2903568389", "description": "2024 . 4. 28", "tags": ["2d"], "time_retrieved": "2024-05-15T23:19:11.710845", "image_code": "vec3 palette( in float t)\n{\n    //颜色渐变函数\n    vec3 a = vec3(0.868,0.158,0.998);\n    vec3 b = vec3(0.889,0.929,0.929);\n    vec3 c = vec3(-0.148,0.274,0.540);\n    vec3 d = vec3(-0.073,0.107,0.417);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    \n    vec2 uv0 = uv;//原始画布\n\n    vec3 fincol = vec3(0.0);\n    \n    for(float i = 1.0;i<4.0;i++){\n        //迭代画布\n        uv = fract(uv*=1.5)-0.5;\n\n        float l = length(uv) * exp2(-length(uv0));\n\n        vec3 col = palette(length(uv0) + iTime*.4);\n\n        l = sin(l * 8.0 + iTime)/8.0;\n        l = abs(l);\n\n        //l = smoothstep(0.0,0.1,l);\n\n        l = pow(0.01/l,1.2);\n\n        fincol += l * col;\n        \n    }\n    \n    fragColor = vec4(fincol,1.0);//输出\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfcXzs.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4f3Szs", "name": "one over x", "author": "sedcore", "description": "I'm not satisfied with distance function in https://www.shadertoy.com/view/MfKGWK\nSo I tried various thing, then I went a bit mad. (One can solve an order-4 poly to find exact distance I think. Me lazy.)", "tags": ["1x"], "time_retrieved": "2024-05-15T23:19:12.550062", "image_code": "/* 2024-04 - public domain */\n/* trying (too hard) to plot y=-1/x and going crazy */\n\n/* distance from a 2D point (a,b) to y=-1/x leads to\n * the order-4 polynomial:\n * x^4 - a x^3 - b x - 1 = 0\n * take the root (x,y) so that x>0 and dist((a,b),(x,y)) is min\n *\n * overkill\n *\n * let's try y+1/x as an approximation\n * works more or less, but not for small x\n *\n * so to deal with small x, let's try min(y+1/x, x)\n * works better, but still not very good for tiny tiny x\n *\n * so limit for x > .01, gives more or less nice result\n * (we have some noise, you can see in basic mode)\n *\n * then let's forget about all this and put some cos()\n * here and there\n */\n\n/* define BASIC for the basic mode */\n//#define BASIC\n\nfloat map(vec3 p)\n{\n#ifdef BASIC\n  float x = length(p.xz);\n#else\n  /* let's add a bit of cos() madness */\n  float x = length(p.xz)+(cos(iTime*3.)*.5+1.-2.);\n#endif\n  float y = p.y;\n  //those don't work well when x is close to 0 (what a surprise!)\n  //return y +1./x;\n  //return min(y+1./x, x);\n  //this one is better\n  return min(y+1./x, max(x,.01));\n}\n\nvec3 paletteA(vec2 p)\n{\n  vec2 q = vec2(length(p), atan(p.x,p.y)/atan(1.));\n  vec2 qb = abs(fract(4.*q+vec2(iTime*4., iTime*2.)) * 2. - 1.);\n  vec3 blue = vec3(.2,.7,1.);\n  vec2 alpha = exp(-qb*qb*20.);\n  return blue * length(alpha);\n}\n\nvec2 rot(vec2 v, float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c)*v; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n  \n  /* camera */\n  vec3 eye = vec3(0., 1., 3.);\n  vec3 target = vec3(0.,-1.3,0.);\n  float focal = 1.2;\n  vec3 ro = eye;\n  vec3 camera_center = ro + focal * normalize(target-ro);\n  vec3 rdx = vec3(1.,0.,0.);\n\n#ifndef BASIC\n  /* a bit of camera madness */\n  ro.xz = rot(ro.xz, iTime);\n  rdx.xz = rot(rdx.xz, iTime * 2.);\n#endif\n\n  vec3 rdy = normalize(cross(rdx, target-ro));\n  rdx/=1.8; rdy/=1.8;\n\n#ifndef BASIC\n  /* a bit more camera madness */\n  rdx.xy = rot(rdx.xy, iTime*2.);\n  rdy.xy = rot(rdy.xy, iTime*.8);\n#endif\n\n  vec3 rd = normalize(camera_center + rdx * uv.x + rdy * uv.y - ro);\n\n  /* raymarch */\n  float t = 0.;\n  int i;\n  float d;\n  vec3 p;\n  for (i = 0; i < 200; i++) {\n    p = ro + t * rd;\n    d = map(p);\n    if (d < 0.01) break;\n    //if (d > 100.) break;\n    t += d*.3;\n  }\n\n  /* colormap */\n  fragColor = vec4(paletteA(p.xz),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "public-domain", "thumbnail": "https://www.shadertoy.com/media/shaders/4f3Szs.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4fdSzf", "name": "drifting", "author": "acoo", "description": "water/atmosphere stuff.  based on shaders from folks much smarter than me - thank you :)", "tags": ["water", "sky", "atmosphere"], "time_retrieved": "2024-05-15T23:19:15.663069", "image_code": "// https://www.shadertoy.com/view/XlXGzB - sky\n// https://www.shadertoy.com/view/MdXyzX - water\n\n#if HW_PERFORMANCE == 0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n#define ZERO (min(iFrame,0))\n#define PI 3.14159265358979323846\n\n// General Parameters\nconst float CameraHeight = 1.5;\nconst float FOV = 60.0;\nconst bool SunAnimation = false;\nconst bool BobberAnimation = true;\n\n// Wave Parameters\nconst float BeckmanSpecular = 0.98;   // Higher values tighten the specular range.\nconst float FresnelFactor = 8.0;\nconst float WaterDepth = 1.0;\nconst float DragMultiplier = 0.38; // Changes how much waves pull on the water.\nconst int RaymarchSteps = 16;\nconst int RaymarchNormalSteps = 32;\n\n\n// Atmosphere Parameters\nconst int AtmosphereViewSteps = 64; \nconst int AtmosphereLightSteps = 4;\nconst float SunLightPower = 25.0; // sun light power, 10.0 is normal\nconst float SunIntensity = 8.0; // sun intensity for sun\nconst float G = 0.98; // Light concentration for HG phase function - lower for hazier/dispersed effect\nconst float Haze = 0.1;\n\n// Atmosphere Constants\nconst float PlanetRadius = 6360e3; // Planet radius 6360e3 actual 6371km\nconst float AtmosphereRadius = 6380e3; // Atmosphere radius 6380e3 troposphere 8 to 14.5km\nconst vec3 PlanetCenter = vec3(0.0, -PlanetRadius, 0.0);\nconst float Hr = 8e3;   // Rayleigh scattering top //8e3\nconst float Hm = 1.3e3; // Mie scattering top //1.3e3\n\n// -------------------- Helpers ---------------------\nfloat sphere_intersect(in vec3 p, in vec3 d, in float R) \n{\n\tvec3 v = p - PlanetCenter;\n\tfloat b = dot(v, d);\n\tfloat c = dot(v, v) - R*R;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return -1.;\n\tfloat det = sqrt(det2);\n\tfloat t1 = -b - det, t2 = -b + det;\n\treturn (t1 >= 0.) ? t1 : t2;\n}\n\n\nfloat plane_intersect(vec3 origin, vec3 direction, vec3 point, vec3 normal) \n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 999999.0); \n}\n\n\nmat3 rotate_angle_axis(vec3 axis, float angle) \n{\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n// -------------------- Helpers ---------------------\n\n\n// -------------------- PostFX ----------------------\nvec3 aces_tonemap(vec3 color) \n{  \n    mat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n    );\n    mat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n    );\n    vec3 v = m1 * color;  \n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n// -------------------- PostFX ----------------------\n\n\n// -------------------- Atmosphere ---------------------\nvoid calculate_particle_densities(in vec3 pos, out float rayleigh, out float mie) \n{\n\tfloat h = length(pos - PlanetCenter) - PlanetRadius;\n\trayleigh =  exp(-h/Hr);\n\tmie = exp(-h/Hm) + Haze;\n}\n\nvoid scatter(vec3 ro, vec3 rd, vec3 lp, out vec3 col, out vec3 scat, in float t) \n{\n    vec3 mie_constant = vec3(21e-6); // Standard Mie distribution \n    vec3 rayleigh_constant = vec3(5.8e-6, 13.5e-6, 33.1e-6); // Standard Rayleigh distribution\n\n\tfloat L = sphere_intersect(ro, rd, AtmosphereRadius);\t\n\tfloat mu = dot(rd, lp);\n\tfloat opmu2 = 1.0 + mu * mu;\n\tfloat rayleigh_phase = 0.0596831 * opmu2;\n    \n    // HG phase functions for Mie scattering\n    const float g2 = G * G;\n    const float s = 0.999;\n\tfloat mie_phase = 0.1193662 * (1.0 - g2) * opmu2 / ((2.0 + g2) * pow(1.0 + g2 - 2.0 * G * mu, 1.5));\n    float sun_phase = 0.1193662 * (1.0 - s) * opmu2 / ((2.0 + s) * pow(1.0 + s - 2.0 * s * mu, 1.5));\n\t\n    // Optical depth for mie and rayleigh particles\n\tfloat depth_rayleigh = 0.0, depth_mie = 0.0;\n    \n    // Rayleigh and Mie scattering distributions\n\tvec3 R = vec3(0.0), M = vec3(0.0);\n\t\n\tfloat view_step_size = L / float(AtmosphereViewSteps);\n\tfor (int i = 0; i < AtmosphereViewSteps; ++i) \n    {\n\t\tfloat l = float(i) * view_step_size;\n\t\tvec3 sample_p_view = (ro + rd * l);\n\n\t\tfloat density_rayleigh, density_mie;\n        \n\t\tcalculate_particle_densities(sample_p_view, density_rayleigh, density_mie);\n        \n\t\tdensity_rayleigh *= view_step_size; \n        density_mie *= view_step_size;\n        \n\t\tdepth_rayleigh += density_rayleigh;\n\t\tdepth_mie += density_mie;\n\n\t\tfloat to_light_isect = sphere_intersect(sample_p_view, lp, AtmosphereRadius);\n\t\tif (to_light_isect > 0.0) \n        {\n\t\t\tfloat light_step_size = to_light_isect / float(AtmosphereLightSteps);\n\t\t\tfloat depth_rayleigh_light = 0.0, depth_mie_light = 0.0;\n            \n\t\t\tfor (int j = 0; j < AtmosphereLightSteps; ++j) \n            {\n\t\t\t\tfloat ls = float(j) * light_step_size;\n\t\t\t\tvec3 sample_p_light = sample_p_view + lp * ls;\n                \n\t\t\t\tfloat density_rayleigh_light, density_mie_light;\n\t\t\t\tcalculate_particle_densities(sample_p_light, density_rayleigh_light, density_mie_light);\n                \n\t\t\t\tdepth_rayleigh_light += density_rayleigh_light * light_step_size;\n\t\t\t\tdepth_mie_light += density_mie_light * light_step_size;\n\t\t\t}\n\n\t\t\tvec3 absorption = exp(-(rayleigh_constant * (depth_rayleigh_light + depth_rayleigh) + mie_constant * (depth_mie_light + depth_mie)));\n\t\t\tR += absorption * density_rayleigh;\n\t\t\tM += absorption * density_mie;\n\t\t} \n\t}\n\n    col = SunLightPower * M * mie_constant * mie_phase;            // Mie scattering\n    col += SunLightPower * R * rayleigh_constant * rayleigh_phase; // Rayleigh scattering\n\n    col += SunIntensity * M * mie_constant * sun_phase;            // Sun\n    scat = 0.01 * mie_constant * depth_mie;\n}\n// -------------------- Atmosphere ---------------------\n\n\n// -------------------- Waves ---------------------\nvec2 wave_dx(vec2 position, vec2 direction, float frequency, float timeshift) \n{\n// Calculates wave value and its derivative, for the wave direction, position in space, wave frequency and time\n\n  float x = dot(direction, position) * frequency + timeshift;\n  float wave = exp(sin(x) - 1.0);\n  float dx = wave * cos(x);\n  return vec2(wave, -dx);\n}\n\n// Calculates waves by summing octaves of various waves with various parameters\nfloat calculate_wave_at_p(vec2 position, int iterations) \n{\n  float iter = 0.0; // this will help generating well distributed wave directions\n  float frequency = 1.0; // frequency of the wave, this will change every iteration\n  float time_mult = 2.0; // time multiplier for the wave, this will change every iteration\n  float weight = 1.0;// weight in final sum for the wave, this will change every iteration\n  float sum_of_values = 0.0; // will store final sum of values\n  float sum_of_weights = 0.0; // will store final sum of weights\n  \n  for(int i=0; i < iterations; i++) \n  {\n    vec2 p = vec2(sin(iter), cos(iter));\n    vec2 wave_data = wave_dx(position, p, frequency, iTime * time_mult);\n\n    // Shift position around according to wave drag and derivative of the wave\n    position += p * wave_data.y * weight * DragMultiplier;\n\n    sum_of_values += wave_data.x * weight;\n    sum_of_weights += weight;\n\n    // Modify next octave\n    weight = mix(weight, 0.0, 0.2);\n    frequency *= 1.18;\n    time_mult *= 1.07;\n\n    // Add some kind of random value to make next wave look random too\n    iter += 1232.399963;\n  }\n  \n  return sum_of_values / sum_of_weights;\n}\n// -------------------- Waves ---------------------\n\n\n// -------------------- March ----------------------\nfloat march(vec3 camera, vec3 start, vec3 end, float depth) \n{\n    vec3 p = start;\n    vec3 dir = normalize(end - start);\n\n    for(int i=0; i < 64; i++) \n    {\n        float wave_height = calculate_wave_at_p(p.xz, RaymarchSteps) * depth - depth;\n        if(wave_height + 0.1 > p.y) \n           return distance(p, camera);\n\n        p += dir * (p.y - wave_height);\n    }\n\n    return distance(start, camera);\n}\n\n// Calculate normal at point by calculating the height at the pos and 2 additional points very close to pos\nvec3 normal(vec2 p, float e, float depth) \n{\n  vec2 ex = vec2(e, 0);\n  float wave_height = calculate_wave_at_p(p.xy, RaymarchNormalSteps) * depth;\n  vec3 a = vec3(p.x, wave_height, p.y);\n  return normalize(\n    cross(\n      a - vec3(p.x - e, calculate_wave_at_p(p.xy - ex.xy, RaymarchNormalSteps) * depth, p.y), \n      a - vec3(p.x, calculate_wave_at_p(p.xy + ex.yx, RaymarchNormalSteps) * depth, p.y + e)\n    )\n  );\n} \n// -------------------- March ----------------------\n\n\n// -------------------- Stars ----------------------\nfloat hash21(vec2 p) \n{\n    p = fract(p*vec2(123.34,234.34));\n    p += dot(p, p+23.43);\n    return fract(p.x*p.y);\n}\n\n\nfloat star_layer(vec2 p, float seed) \n{\n    float t = iTime * 2.0 + seed;\n    vec2 id = floor(p);\n    vec2 gv = fract(p) - 0.5;\n    \n    float n = hash21(id);\n    float x = fract(n * 12.32);\n    float y = fract(n * 123.32);\n    vec2 offs = vec2(x,y) - 0.5;\n    \n    float d = length(gv - offs * 0.9);\n    float m = smoothstep(0.01, 0.0, d);\n    \n    m *= pow(sin(t + n * 6.2832)* 0.5 + 0.5, 3.0);\n    return m;\n}\n// -------------------- Stars ----------------------\n\n\nvec3 render(vec2 uv) \n{\n    vec2 mouse = (iMouse.xy - iResolution.xy * 0.5) / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    \n    if(iMouse.x == 0.0 && iMouse.y == 0.0)\n        mouse = vec2(0.0, -0.1);\n    \n    float fov_rads = tan(radians(FOV));\n    \n    float x = (sin(iTime * 0.5) + cos(iTime * 0.5)) * 0.5 + 0.5;\n    vec3 ro = BobberAnimation \n        ? vec3(iTime * 0.1, mix(CameraHeight, CameraHeight - WaterDepth, x), 1.0)\n        : vec3(iTime * 0.1, CameraHeight, 1.0);\n\n    mat3 rot = rotate_angle_axis(vec3(1.0, 0.0, 0.0), -0.18);\n    vec3 rd =  rot * normalize(vec3(uv, fov_rads / -2.5));\n    vec3 lp = iMouse.z > 0.0 || !SunAnimation\n        ? rot * normalize(vec3(mouse.xy, fov_rads / -2.5))\n        : rot * normalize(vec3(sin(iTime * 0.1) * 0.9, cos(iTime * 0.1) * 0.9, fov_rads / -2.5));\n\n    if (rd.y >= 0.0) \n    {\n        vec3 sky_color = vec3(0.0);\n        vec3 sky_scattering = vec3(0.0);\n        scatter(ro, rd, lp, sky_color, sky_scattering, iTime);\n        sky_color += sky_scattering;\n        \n        float offset = dot(rd, vec3(10.0));\n        float stars = star_layer(uv * 10.0, offset);\n        stars += star_layer(uv * 17.0+ 3.1, offset);\n        stars += star_layer(uv * 23.+23.1, offset);\n        stars *= smoothstep(0.0, -0.2, lp.y);\n        return sky_color + stars; \n    }\n    \n    vec3 water_plane_high = vec3(0.0, 0.0, 0.0);\n    vec3 water_plane_low = vec3(0.0, -WaterDepth, 0.0);\n\n    // Calculate intersections and reconstruct positions.\n    float high_plane_hit = plane_intersect(ro, rd, water_plane_high, vec3(0.0, 1.0, 0.0));\n    float low_plane_hit = plane_intersect(ro, rd, water_plane_low, vec3(0.0, 1.0, 0.0));\n    vec3 high_hit_p = ro + rd * high_plane_hit;\n    vec3 low_hit_p = ro + rd * low_plane_hit;  \n\n    float d = march(ro, high_hit_p, low_hit_p, WaterDepth);\n    vec3 water_hit_p = ro + rd * d;\n\n    vec3 N = normal(water_hit_p.xz, 0.01, WaterDepth);\n    // Smooth the normal with distance to avoid disturbing high frequency noise.\n    N = mix(N, vec3(0.0, 1.0, 0.0), 0.88 * min(1.0, sqrt(d * 0.01) * 0.9));\n    vec3 L = normalize(lp);\n    vec3 V = normalize(-rd);\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n\n    // Specular reflection lighting coefficients\n    float fresnel = (0.04 + (1.0 - 0.04) * (pow(1.0 - max(0.0, dot(-N, rd)), FresnelFactor)));\n    float k = 0.0;\n\n    float tan_a = length(cross(N, H)) / NdotH;\n    float cos_a = NdotH;\n    float m2 = BeckmanSpecular * BeckmanSpecular;\n    float tana2 = tan_a * tan_a;\n    float cosa4 = pow(abs(cos_a), 4.0);\n    k = exp(-tana2 / m2) / (PI * m2 * cosa4) * 0.1;\n    \n    // Diffuse lighting coefficents & SSS\n    float diff = max(0.0, dot(N, L));\n    vec3 sss = vec3(0.0293, 0.0698, 0.1717) * 0.1 * (1.0 + (water_hit_p.y + WaterDepth) / WaterDepth);\n\n    // Environment reflection\n    vec3 R = normalize(reflect(rd, N));\n    R.y = abs(R.y);\n    vec3 water_reflect = vec3(0.0);\n    vec3 water_scat = vec3(0.0);\n\n    scatter(ro, R, lp, water_reflect, water_scat, iTime);\n    water_reflect += water_scat;\n    vec3 diffuse_scatter = (water_scat + sss) * diff;\n\n    vec3 spec_reflection = water_reflect * k + fresnel * water_reflect;\n    \n    float offset = dot(rd * d, vec3(10.0));\n    float stars = star_layer(rd.xz * 10.0, offset);\n    stars += star_layer(rd.xz * 17.0 + 3.1, offset);\n    stars += star_layer(rd.xz * 23.0 + 23.1, offset);\n    stars *= smoothstep(0.0, -0.2, lp.y);\n\n    return spec_reflection + diffuse_scatter + stars * 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 p = ((fragCoord + o) - iResolution.xy * 0.5)/iResolution.y;\n#else    \n        vec2 p = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n#endif\n\n        vec3 color = render(p);\n        color = aces_tonemap(color);\n\n        tot += color;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4(tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fdSzf.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "lc3XD4", "name": "Outline Sharpener", "author": "Peace", "description": "I was watching low quality anime and made an OBS shader filter that makes it a bit sharper, didn't use it at the end, because this is good for blurred video but not as good at compressed one (better but not worth the hustle).", "tags": ["sharpen", "outline"], "time_retrieved": "2024-05-15T23:19:15.720509", "image_code": "const int k = 2;\nconst float s = 1.5;\n\n// Fetch\nvec3 f(vec2 p, vec2 o) {\n    return texture(iChannel0, p + o / vec2(textureSize(iChannel0, 0))).rgb;\n}\n\n// Variance\nfloat v(vec2 p, vec3 c) {\n    float v = 0.0;\n    float t = 0.0;\n    for (int x = -k; x <= k; ++x) {\n        for (int y = -k; y <= k; ++y) {\n            vec2 o = vec2(x, y);\n            v += length(c - f(p, o));\n            t += 1.0;\n        }\n    }\n    return v / t;\n}\n\n// Gaussian Blur\nvec3 g(vec2 p) {\n    vec3 c = vec3(0, 0, 0);\n    float t = 0.0;\n    for (int x = -k; x <= k; ++x) {\n        for (int y = -k; y <= k; ++y) {\n            vec2 o = vec2(x, y);\n            float w = 0.4 / (s * exp(dot(o, o) / (2.0 * s * s)));\n            c += f(p, o) * w;\n            t += w;\n        }\n    }\n    return c / t;\n}\n\n#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI\n#define INV_PI 0.31830988618379067153776752674503\nvec3 sdn(vec2 p, vec3 gv)\n{\n    float vv = min(1.0, pow(v(p, gv) * 4.0, 2.0) * 32.0);\n    float sigma = 2.0; \n    float kSigma = 2.0; \n    float threshold = 0.2 * (0.4 + 1.0 - vv);\n    float radius = round(kSigma * sigma);\n    float radQ = radius * radius;\n\n    float invSigmaQx2 = .5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)\n    float invSigmaQx2PI = INV_PI * invSigmaQx2;    // 1.0 / (sqrt(PI) * sigma)\n\n    float invThresholdSqx2 = .5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)\n    float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma)\n\n    vec3 centrPx = f(p, vec2(0, 0));\n\n    float zBuff = 0.0;\n    vec3 aBuff = vec3(0.0, 0.0, 0.0);\n\n    for (int x = 1 - int(radius); x < int(radius); x++) \n    {\n        int pt = int(sqrt(radQ - float(x * x)));\n        for (int y = -pt; y <= pt; y++) {\n            vec2 d = vec2(x, y);\n            float blurFactor = exp(-dot(d, d) * invSigmaQx2) * invSigmaQx2PI;\n            vec3 walkPx = f(p, d);\n            vec3 dC = walkPx - centrPx;\n            float deltaFactor = exp(-dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;\n            zBuff += deltaFactor;\n            aBuff += deltaFactor * walkPx;\n        }\n    }\n    return aBuff / zBuff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n    vec3 fv = f(p, vec2(0, 0));\n    vec3 gv = g(p);\n    vec3 sdnv = sdn(p, gv);\n    vec3 c = sdnv * 2.0 - gv;\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lc3XD4.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MccSRf", "name": "isosurface fractal raymarching", "author": "the0neboy", "description": " ", "tags": ["3d", "raytracing", "raymarching", "fractal", "raycasting", "isosurface"], "time_retrieved": "2024-05-15T23:19:16.105871", "image_code": "#define orthographic 0\n#define iterations 15\n\nvec2 mandelbrot(vec3 z, float n) {\n    vec3 c = z;\n    float t = 1e20;\n    float d = 0.0;\n    \n    for (int i = 0; i<iterations; i++) {\n        d += z.x*z.x+z.y*z.y+z.z*z.z;\n        if (z.x*z.x+z.y*z.y+z.z*z.z > 150.0) {\n            return vec2(sqrt(d/float(i+1)),t);\n        }\n        \n        \n        \n        z = cPow(z,n)+c;\n        \n        t = min(length(z),t);\n    }\n    return vec2(-1.0,t);\n}\nvec2 fractal(vec3 z, float n) {\n    vec3 c = z;\n    float t = 1e20;\n    float d = 0.0;\n    \n    for (int i = 0; i<iterations; i++) {\n        d += z.x*z.x+z.y*z.y+z.z*z.z;\n        if (z.x*z.x+z.y*z.y+z.z*z.z > 150.0) {\n            return vec2(sqrt(d/float(i+1)),t);\n        }\n        \n        \n        \n        z = cPow(z,n)+c;\n        \n        t = min(length(z),t);\n    }\n    return vec2(-1.0,t);\n}\n\nvec4 func(float x, float y, float z) {\n    vec2 info = fractal(vec3(x,y,z),2.0);\n\n    float iso = info.x;\n    float t = info.y;\n    \n    vec3 col = vec3(sin(t*3.7+1.4),cos(t*2.3+0.6),sin(t*2.5+1.3));\n    col *= col;\n    \n    return vec4(col,iso);\n}\n\n// RENDERING --------------------------------------------------------------------------\nvec4 f(vec3 x) {\n    return func(x.x, x.y, x.z);\n}\nvec3 grad( vec3 x )\n{\n    vec2 h = vec2( 0.00001, 0.0 );\n    return vec3( f(x+h.xyy).w - f(x-h.xyy).w,\n                 f(x+h.yxy).w - f(x-h.yxy).w,\n                 f(x+h.yyx).w - f(x-h.yyx).w )/(2.0*h.x);\n}\nfloat de(vec3 x) {\n    return f(x).w/length(grad(x));\n}\n\nmat2 rot2d(float x) {\n    return mat2(\n        cos(x), -sin(x),\n        sin(x), cos(x)\n    );\n}\nvoid rot3d(inout vec3 rd, float x, float y) {\n    rd.yz *= rot2d(x);\n    rd.xz *= rot2d(y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 m = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-3);\n    rot3d(ro, -m.y*3.0, m.x*1.777*3.0);\n    \n    vec3 rd = -normalize(ro);\n    \n    vec3 leftDir = normalize(cross(rd, vec3(0,1,0)));\n    vec3 upDir = cross(leftDir,rd);\n    if (orthographic == 0) {\n        const float focalLen = 1.0;\n\n        rd = normalize(rd + leftDir*uv.x + upDir*uv.y);\n    } else {\n        const float orthoZoom = 5.0;\n        ro = ro + leftDir*uv.x*orthoZoom + upDir*uv.y*orthoZoom;\n    }\n    vec3 col = vec3(1);\n    \n    float t = 0.0;\n    for (int i=0; i<1000; i++) {\n        float dist = de(ro+rd*t);\n        if (dist < 0.0001) {\n            col = f(ro+rd*t).rgb;\n            col *= vec3(exp(-t*.2));\n            break;\n        }\n        if (t > 1000.0) {\n            break;\n        }\n        t += dist;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "vec3 cPow(vec3 z, float n) {\n    float r = length(z);\n    float phi = atan(z.y,z.x);\n    float theta = atan(length(z.xy),z.z);\n\n    z = pow(r,n) * vec3(sin(n*theta)*cos(n*phi),sin(n*theta)*sin(n*phi),cos(n*theta));\n\n    return z;\n}\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MccSRf.jpg", "access": "api", "wgpu-test": "error"}
{"id": "lccSRf", "name": "Circular Chaos ", "author": "EthanZappa", "description": "these circles are crazy. ", "tags": ["madness"], "time_retrieved": "2024-05-15T23:19:16.124228", "image_code": "void mainImage(out vec4 O, vec2 F) {\n    vec2 r = iResolution.xy, u = (F+F-r)/r.y;    \n    O.rgb*=0.;\n    for (float i; i<20.; i++) {\n        float circleDistance =.004/(abs(length(u)-i*.04)+.005);\n        vec3 color = (tan(i+vec3(0,1.5,2.5))+1.);\n        float animation = smoothstep(.35,.4,abs(abs(mod(iTime,2.)-i*.1)-1.));\n        O.rgb += circleDistance * color * animation;\n        u *= mat2(cos((iTime+i++)*1.02 + vec4(1,35,110,10)));\n        u -= vec2(tan(iTime+i*.1), tan(iTime+i*.2))*.1;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lccSRf.jpg", "access": "api", "wgpu-test": "error"}
{"id": "Mf3SRf", "name": "String Connection ", "author": "EthanZappa", "description": "String Theory", "tags": ["stringtheory"], "time_retrieved": "2024-05-15T23:19:16.140690", "image_code": "#define R3D(a) mix(q*dot(p,q), p, cos(a)) + sin(a)*cross(p,q)\n#define R2D(a) mat2( cos( a + vec4(0,11,33,0 )))\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\nfloat i,j,d=.1,e; vec3 p,q=vec3(1,-1,1),r=iResolution;\no=vec4(0.);\n\nfor(i=0.;i++<64.&&d>1e-4;){\n    p=vec3((FC.xy-.5*r.xy)/r.y,e)*4.;\n    p.z-=6.;\n    p.xz*=R2D(iTime*.3);\n    \n    for(j=0.;j++<2.;)\n        p=abs(abs(p=R3D(i*i/j)-.06))-.04,\n        d=min(min(p.z,p.x),p.y)/24.,\n        d-=dot(tan(p),cos(p))/1e4;\n    \n    e*=d;\n\n}o+=vec4(sqrt(p*p),1)*3./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mf3SRf.jpg", "access": "api", "wgpu-test": "error"}
{"id": "lc3SRX", "name": "frame delta movement detection", "author": "jonasfrey", "description": "this shows movement since it is the difference of the current frame and the last", "tags": ["movement"], "time_retrieved": "2024-05-15T23:19:16.152269", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n       \n    vec4 o_col_webcam_last = texture(iChannel0, uv);\n    vec4 o_col_webcam_now = texture(iChannel1, uv);\n    vec4 o_col = o_col_webcam_last-o_col_webcam_now;\n\n    fragColor = abs(o_col);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float n_target_fps = 3.+floor(uv.x*20.);\n    float n_mod_frame = ceil(ceil(iFrameRate) / n_target_fps);\n    //n_mod_frame = floor(uv.x*10.);\n    n_mod_frame = 10.;\n    if(mod(float(iFrame), n_mod_frame)==0.){\n        fragColor = texture(iChannel1, uv);\n    \n    }else{\n        fragColor = texture(iChannel0, uv);\n    }\n    \n    \n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lc3SRX.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "4ccSzX", "name": "Remnants full demo", "author": "ockiller", "description": "Reverse engineering of the [url=https://www.pouet.net/prod.php?which=96536]Remnants 256 bytes demo[/url] from Alcatraz.", "tags": ["fractal", "raymarch", "demoscene", "alcatraz", "remnants"], "time_retrieved": "2024-05-15T23:19:16.647908", "image_code": "#define MAX_STEPS 42.0\n#define EPSILON 1.0 / 42.0\n\ninline vec2 rotate(vec2 v, float r) {\n/*\n\tfloat c = cos(r), s = sin(r);\n\tmat2 rot = mat2(c, -s, s, c);\n\treturn rot * v;\n/*/\n\t// Approximation used in the demo, where for small angles, cos(r) ~= 1.0 and sin(r) ~= r\n\t// It simplfies into this\n\treturn v + v.yx * vec2(r, -r);\n//*/\n}\n\ninline void mainImage(OUT(vec4, fragColor), vec2 fragCoord) {\n\tfloat time = mod(iTime / 16.0, 6.0);\n\tint shot = int(time); // current camera shot\n\n\tvec3 pos = vec3(-69.0, -6.25, 24.0); // starting position\n\tpos.y += 1.0 * float(shot);\n\tpos.z -= 4.0 * time;\n\n\tfragCoord.y -= 0.1 * iResolution.y; // look down a bit\n\tvec3 dir = vec3((2.0 * fragCoord - iResolution.xy) / iResolution.y, -1.0);\n\n\t// camera behave slightly differently on even and odd shots\n\tif ((shot & 1) != 0) {\n\t\tpos.y += float(shot) + 4.0 * (time - float(shot));\n\t\tdir = vec3(-dir.z, dir.yx);\n\t}\n\n\t// fractal gets slighly modified each shot\n\tfloat fract_rot = 0.417 + 0.0095 * float(shot);\n\n\tfloat l;\n\tfor (l = 0.0; l < MAX_STEPS; l++) {\n\t\t// The fractal\n\t\tvec3 v = pos;\n\t\tfloat rayStep = shot < 4 ? pos.y : 0.0; // ceiling is popped-off in the first 4 shots\n\t\tfor (float i = 100.0; i > 0.5; i *= fract_rot) {\n\t\t\tvec2 r = rotate(v.xz, 0.198);\n\t\t\tv.x = r.x; v.z = r.y;\n\t\t\tv = 0.79 * i - abs(mod(v, 2.0 * i) - i);\n\t\t\trayStep = max(rayStep, min(v.x, min(v.y, v.z)));\n\t\t}\n\n\t\tif (rayStep < EPSILON)\n\t\t\tbreak;\n\n\t\tpos += 0.6 * rayStep * dir;\n\t}\n\n\tfragColor = vec4(vec3(l / MAX_STEPS), 1.0);\n}", "image_inputs": [], "common_code": "#define OUT(_type, _var) out _type _var\n#define inline", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ccSzX.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MfdSRj", "name": "Bresenham's Line Algorithm", "author": "isekai", "description": "Bresenham Line Algorithm Demo\n- Controls (For Desktop/Laptop only): \n  Left Mouse Button + hold on any pixel - drag to any pixel - mouse release.\n- Modify pixel resolution by updating \"pxRes\" variable in the code.", "tags": ["line", "rasterization", "algorithm", "bresenham"], "time_retrieved": "2024-05-15T23:19:17.952291", "image_code": "/*\n\nAuthor: Pratik Dhende\nLinkedIn: https://www.linkedin.com/in/pratik-dhende/\n\nMIT License\n\nCopyright (c) 2024 Pratik Dilip Dhende\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\n\nfloat sdCircle(vec2 p, float radius) {\n    return length(p - 0.5) - radius;\n}\n\nfloat plot(vec2 st, float fx, float border){\n    return smoothstep( fx-border*0.5, fx, st.y) - smoothstep( fx, fx+border*0.5, st.y);\n}\n\nvoid drawGrid(vec2 st, float border, inout vec3 col) {\n    col *= 1.0 - vec3(plot(st, 0.0, border*0.5));\n    col *= 1.0 - vec3(plot(st, 1.0, border*0.5));\n    \n    col *= 1.0 - vec3(plot(st.yx, 0.0, border*0.5));\n    col *= 1.0 - vec3(plot(st.yx, 1.0, border*0.5));\n}\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat bresenhamLow(vec2 s, vec2 e, vec2 px){\n    // Function needs delta.x >= 0\n    \n    vec2 delta = e - s;\n    \n    float incr = 1.0;\n    \n    if (delta.y < 0.0) {\n        delta.y = -delta.y;\n        incr = -1.0;\n    }\n    \n    float d = delta.x - 2.0*delta.y;\n    float y = s.y;\n    \n    for(float x = s.x; x <= e.x; x++){\n        if (length(px - vec2(x, y)) < 0.00001){\n            // Pixel = Bresenham line pixel\n            return 1.0;\n        }\n        if (d > 0.0){\n            d -= 2.0 * delta.y;\n        }\n        else{\n            y += incr;\n            d-= 2.0 * (delta.y - delta.x);\n        }\n    }\n    \n    return 0.0;\n}\n\nfloat bresenham(vec2 s, vec2 e, vec2 px) {    \n    vec2 delta = abs(e - s);\n    \n    if (delta.y > delta.x) {\n        // Slope > 1.\n        s = s.yx;\n        e = e.yx;\n        px = px.yx;\n    }\n    \n    // Makes sure delta.x >= 0.\n    if (e.x >= s.x) {\n        return bresenhamLow(s, e, px);\n    }\n    else {\n        return bresenhamLow(e, s, px);\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale between 0 and 1.\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ms = iMouse.xy / iResolution.xy; // Current mouse position.\n    vec2 lms = abs(iMouse.zw) / iResolution.xy; // Last mouse click position.\n    \n    // Adjust for aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    ms.x *= aspectRatio;\n    lms.x *= aspectRatio;\n    \n    // Adjust this value to increase pixels in the grid.\n    float pxRes = 5.0;\n    \n    // Scale the space for tiling.\n    uv *= pxRes;\n    ms *= pxRes;\n    lms *= pxRes;\n    \n    // Get start, end and pixel positions for bresenham.\n    vec2 a = floor(lms) + 0.5;\n    vec2 b = floor(ms) + 0.5;\n    vec2 px = floor(uv) + 0.5;\n    \n    // Mask telling whether pixel belongs to bresenham line.\n    float bpx = bresenham(a, b, px);\n    \n    vec3 col = vec3(1.0);\n    \n    // Tile the space.\n    vec2 st = fract(uv);\n    \n    // Draw dot.\n    float dotRadius = 0.1;\n    float distDot = sdCircle(fract(st), dotRadius);\n    col *= vec3(smoothstep(0.0, 0.02, distDot));\n    \n    float borderResFactor = 397320.0 / (iResolution.x * iResolution.y);\n    float gridBorder = 0.015 * pxRes * borderResFactor;\n    float subGridBorder = 0.007 * pxRes * borderResFactor;\n\n    // Draw main grid.\n    drawGrid(st, max(0.006 * pxRes, min(0.018 * pxRes, gridBorder)), col);\n    // Draw sub-grid.\n    drawGrid(st - 0.5, max(0.007 * pxRes, min(0.014 * pxRes, subGridBorder)), col);\n    \n    // Highlight bresenham pixel.\n    col = mix(col, vec3(1.0 - bpx), 0.5 * bpx);\n    \n    // Draw line\n    vec3 lineColor = vec3(1.0, 1.0,0.0);\n    float lineTransparency = 0.9;\n    float lineRoundness = dotRadius * 0.01 * pxRes;\n    float d = distanceToSegment(a, b, uv) - lineRoundness;\n    col = mix( col, mix(col, lineColor, lineTransparency), 1.0-smoothstep(.01,0.01 + pxRes*0.002, d) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MfdSRj.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4fdSR2", "name": "Cornell Box Path Tracing", "author": "David654", "description": "Path Tracing in the Cornell Box.\n\nFeatures: \n• Metallic and non-metallic surfaces\n• Levels of roughness\n• Light sources and emission power\n• Caustics\n• Transparency\n• Transmittance\n• Reflections\n• Refraction\n• Dispersion\n• FXAA\n• MSAA\n", "tags": ["3d", "raytracing", "raytracer", "cornellbox", "raytrace", "pathtrace", "caustics", "pathtracing", "pathtracer", "box", "fxaa", "msaa", "path", "spectral"], "time_retrieved": "2024-05-15T23:19:18.732359", "image_code": "#define FXAA\n\n// Credits: https://www.shadertoy.com/view/mtScRc\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz)\n{\n    // Maximum texel span\n    const float span_max = 8.0;\n    // These are more technnical and probably don't need changing:\n    // Minimum \"dir\" reciprocal\n    const float reduce_min = (1.0/128.0);\n    // Luma multiplier for \"dir\" reciprocal\n    const float reduce_mul = (1.0/32.0);\n\n    const vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    // Sample center and 4 corners\n    vec3 rgbCC = texture(tex, uv).rgb;\n    vec3 rgb00 = texture(tex, uv + vec2(-0.5, -0.5) * texelSz).rgb;\n    vec3 rgb10 = texture(tex, uv + vec2(+0.5, -0.5) * texelSz).rgb;\n    vec3 rgb01 = texture(tex, uv + vec2(-0.5, +0.5) * texelSz).rgb;\n    vec3 rgb11 = texture(tex, uv + vec2(+0.5, +0.5) * texelSz).rgb;\n\n    //Get luma from the 5 samples\n    float lumaCC = dot(rgbCC, luma);\n    float luma00 = dot(rgb00, luma);\n    float luma10 = dot(rgb10, luma);\n    float luma01 = dot(rgb01, luma);\n    float luma11 = dot(rgb11, luma);\n\n    // Compute gradient from luma values\n    vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n    // Diminish dir length based on total luma\n    float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n    // Divide dir by the distance to nearest edge plus dirReduce\n    float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    // Multiply by reciprocal and limit to pixel span\n    dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n    // Average middle texels along dir line\n    vec4 A = 0.5 * (\n    texture(tex, uv - dir * (1.0 / 6.0))\n    + texture(tex, uv + dir * (1.0 / 6.0))\n    );\n\n    // Average with outer texels along dir line\n    vec4 B = A * 0.5 + 0.25 * (\n    texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n    // Get lowest and highest luma values\n    float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n    float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n    // Get average luma\n    float lumaB = dot(B.rgb, luma);\n\n    //If the average is outside the luma range, using the middle average\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    #ifdef FXAA\n        col = fxaa(iChannel0, uv, sqrt(2.0) / iResolution.xy).rgb;\n    #else\n        col = texture(iChannel0, uv).rgb;\n    #endif\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415926\n#define EPSILON 0.0001\n#define MAX_DIST 999999.9\n\nvec2 seed1;\nvec2 seed2;\nuvec4 R_STATE;\nfloat samplePart = 1.0;\n\nvec3 rotateX(in vec3 v, float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(1, 0, 0, 0, cos, -sin, 0, sin, cos);\n}\n\nvec3 rotateY(in vec3 v, float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(cos, 0, sin, 0, 1, 0, -sin, 0, cos);\n}\n\nvec3 rotateZ(in vec3 v, float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(cos, -sin, 0, sin, cos, 0, 0, 0, 1);\n}\n\nuint TausStep(uint z, int S1, int S2, int S3, uint M)\n{\n    uint b = (((z << S1) ^ z) >> S2);\n    return (((z & M) << S3) ^ b);\n}\n\nuint LCGStep(uint z, uint A, uint C)\n{\n    return (A * z + C);\n}\n\nvec2 hash22(vec2 p)\n{\n    p += seed1.x;\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat random()\n{\n    R_STATE.x = TausStep(R_STATE.x, 13, 19, 12, uint(4294967294));\n    R_STATE.y = TausStep(R_STATE.y, 2, 25, 4, uint(4294967288));\n    R_STATE.z = TausStep(R_STATE.z, 3, 11, 17, uint(4294967280));\n    R_STATE.w = LCGStep(R_STATE.w, uint(1664525), uint(1013904223));\n    return 2.3283064365387e-10 * float((R_STATE.x ^ R_STATE.y ^ R_STATE.z ^ R_STATE.w));\n}\n\nvec3 randomOnSphere()\n{\n    vec3 rand = vec3(random(), random(), random());\n    float theta = rand.x * 2.0 * 3.14159265;\n    float v = rand.y;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(rand.z, 1.0 / 3.0);\n    float x = r * sin(phi) * cos(theta);\n    float y = r * sin(phi) * sin(theta);\n    float z = r * cos(phi);\n    return vec3(x, y, z);\n}\n\nvec3 standardObserver1964[] =\nvec3[] (\nvec3(0.00016, 0.000017, 0.000705), // 380 nm\nvec3(0.000662, 0.000072, 0.002928), // 385 nm\nvec3(0.002362, 0.000253, 0.010482), // 390 nm\nvec3(0.007242, 0.000769, 0.032344), // 395 nm\nvec3(0.01911, 0.002004, 0.086011), // 400 nm\nvec3(0.0434, 0.004509, 0.19712), // 405 nm\nvec3(0.084736, 0.008756, 0.389366), // 410 nm\nvec3(0.140638, 0.014456, 0.65676), // 415 nm\nvec3(0.204492, 0.021391, 0.972542), // 420 nm\nvec3(0.264737, 0.029497, 1.2825), // 425 nm\nvec3(0.314679, 0.038676, 1.55348), // 430 nm\nvec3(0.357719, 0.049602, 1.7985), // 435 nm\nvec3(0.383734, 0.062077, 1.96728), // 440 nm\nvec3(0.386726, 0.074704, 2.0273), // 445 nm\nvec3(0.370702, 0.089456, 1.9948), // 450 nm\nvec3(0.342957, 0.106256, 1.9007), // 455 nm\nvec3(0.302273, 0.128201, 1.74537), // 460 nm\nvec3(0.254085, 0.152761, 1.5549), // 465 nm\nvec3(0.195618, 0.18519, 1.31756), // 470 nm\nvec3(0.132349, 0.21994, 1.0302), // 475 nm\nvec3(0.080507, 0.253589, 0.772125), // 480 nm\nvec3(0.041072, 0.297665, 0.57006), // 485 nm\nvec3(0.016172, 0.339133, 0.415254), // 490 nm\nvec3(0.005132, 0.395379, 0.302356), // 495 nm\nvec3(0.003816, 0.460777, 0.218502), // 500 nm\nvec3(0.015444, 0.53136, 0.159249), // 505 nm\nvec3(0.037465, 0.606741, 0.112044), // 510 nm\nvec3(0.071358, 0.68566, 0.082248), // 515 nm\nvec3(0.117749, 0.761757, 0.060709), // 520 nm\nvec3(0.172953, 0.82333, 0.04305), // 525 nm\nvec3(0.236491, 0.875211, 0.030451), // 530 nm\nvec3(0.304213, 0.92381, 0.020584), // 535 nm\nvec3(0.376772, 0.961988, 0.013676), // 540 nm\nvec3(0.451584, 0.9822, 0.007918), // 545 nm\nvec3(0.529826, 0.991761, 0.003988), // 550 nm\nvec3(0.616053, 0.99911, 0.001091), // 555 nm\nvec3(0.705224, 0.99734, 0), // 560 nm\nvec3(0.793832, 0.98238, 0), // 565 nm\nvec3(0.878655, 0.955552, 0), // 570 nm\nvec3(0.951162, 0.915175, 0), // 575 nm\nvec3(1.01416, 0.868934, 0), // 580 nm\nvec3(1.0743, 0.825623, 0), // 585 nm\nvec3(1.11852, 0.777405, 0), // 590 nm\nvec3(1.1343, 0.720353, 0), // 595 nm\nvec3(1.12399, 0.658341, 0), // 600 nm\nvec3(1.0891, 0.593878, 0), // 605 nm\nvec3(1.03048, 0.527963, 0), // 610 nm\nvec3(0.95074, 0.461834, 0), // 615 nm\nvec3(0.856297, 0.398057, 0), // 620 nm\nvec3(0.75493, 0.339554, 0), // 625 nm\nvec3(0.647467, 0.283493, 0), // 630 nm\nvec3(0.53511, 0.228254, 0), // 635 nm\nvec3(0.431567, 0.179828, 0), // 640 nm\nvec3(0.34369, 0.140211, 0), // 645 nm\nvec3(0.268329, 0.107633, 0), // 650 nm\nvec3(0.2043, 0.081187, 0), // 655 nm\nvec3(0.152568, 0.060281, 0), // 660 nm\nvec3(0.11221, 0.044096, 0), // 665 nm\nvec3(0.081261, 0.0318, 0), // 670 nm\nvec3(0.05793, 0.022602, 0), // 675 nm\nvec3(0.040851, 0.015905, 0), // 680 nm\nvec3(0.028623, 0.01113, 0), // 685 nm\nvec3(0.019941, 0.007749, 0), // 690 nm\nvec3(0.013842, 0.005375, 0), // 695 nm\nvec3(0.009577, 0.003718, 0), // 700 nm\nvec3(0.006605, 0.002565, 0), // 705 nm\nvec3(0.004553, 0.001768, 0), // 710 nm\nvec3(0.003145, 0.001222, 0), // 715 nm\nvec3(0.002175, 0.000846, 0), // 720 nm\nvec3(0.001506, 0.000586, 0), // 725 nm\nvec3(0.001045, 0.000407, 0), // 730 nm\nvec3(0.000727, 0.000284, 0), // 735 nm\nvec3(0.000508, 0.000199, 0), // 740 nm\nvec3(0.000356, 0.00014, 0), // 745 nm\nvec3(0.000251, 0.000098, 0), // 750 nm\nvec3(0.000178, 0.00007, 0), // 755 nm\nvec3(0.000126, 0.00005, 0), // 760 nm\nvec3(0.00009, 0.000036, 0), // 765 nm\nvec3(0.000065, 0.000025, 0), // 770 nm\nvec3(0.000046, 0.000018, 0), // 775 nm\nvec3(0.000033, 0.000013, 0) // 780 nm\n);\n\nfloat standardObserver1964_w_min = 380.0f;\nfloat standardObserver1964_w_max = 780.0f;\nint standardObserver1964_length = 81;\n\nvec3 wavelengthToXYZ(float wavelength)\n{\n    float pos = (wavelength - standardObserver1964_w_min) / (standardObserver1964_w_max - standardObserver1964_w_min);\n    float index = pos * float(standardObserver1964_length);\n    float floorIndex = floor(index);\n    float blend = clamp(index - floorIndex, 0.0, 1.0);\n    int index0 = int(floorIndex);\n    int index1 = index0 + 1;\n    index1 = min(index1, standardObserver1964_length - 1);\n\n    return mix(standardObserver1964[index0], standardObserver1964[index1], blend);\n}\n\nvec3 XYZtosRGB(vec3 XYZ)\n{\n    mat3 m = mat3(\n    3.2404542, -1.5371385, -0.4985314,\n    -0.9692660,  1.8760108,  0.0415560,\n    0.0556434, -0.2040259,  1.0572252);\n\n    return XYZ * m;\n}\n\nvec3 sRGBtoXYZ(vec3 sRGB)\n{\n    mat3 m = mat3(\n    0.4124564, 0.2126729, 0.0193339,\n    0.3575761, 0.7151522, 0.1191920,\n    0.1804375, 0.0721750, 0.9503041);\n\n    return sRGB * m;\n}\n\nvec3 wavelengthTosRGB(float wavelength)\n{\n    return abs(XYZtosRGB(wavelengthToXYZ(wavelength)));\n}\n\nfloat applyGammasRGBChannel(float sRGBChannel)\n{\n    if(sRGBChannel > 0.0031308)\n    {\n        return 1.055 * pow(sRGBChannel, 1.0/2.4) - 0.055;\n    }\n    else\n    {\n        return sRGBChannel * 12.92;\n    }\n}\n\nvec3 applyGammasRGB(vec3 sRGB)\n{\n    return vec3(applyGammasRGBChannel(sRGB.r), applyGammasRGBChannel(sRGB.g), applyGammasRGBChannel(sRGB.b));\n}\n\nvec3 gammaCorrection(vec3 col)\n{\n    return pow(col, vec3(1.0 / 2.2));\n}", "buffer_a_code": "#define CAMERA_POS vec3(0, 3, -6)\n#define CAMERA_FOV 60.0\n#define MAX_REFLECTIONS 100\n#define SAMPLES 16\n#define MSAA 1\n\nstruct Ray\n{\n    vec3 ro;\n    vec3 rd;\n    vec3 colorFactor;\n    float wavelength;\n};\n\nvec2 iSphere(in vec3 ro, in vec3 rd, float ra)\n{\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - ra * ra;\n    float h = b * b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nvec2 iBox(in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal)\n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if(tN > tF || tF < 0.0)\n    {\n        return vec2(-1.0);\n    }\n    outNormal = (tN > 0.0) ? step(vec3(tN), t1) : step(t2, vec3(tF));\n    outNormal *= -sign(rd);\n    return vec2(tN, tF);\n}\n\nvec3 castRay(Ray ray, inout vec3 normal)\n{\n    vec2 minIntersection = vec2(MAX_DIST);\n    vec2 intersection;\n    vec3 intersectionPoint;\n    int index = -1;\n\n    vec3 outNormal;\n\n    vec3 boxPos = vec3(0, 1, 0);\n    float boxSize = 2.0;\n    float wallThickness = 0.001;\n    float lightSourceSize = boxSize * 0.5;\n\n    // FLOOR\n    intersection = iBox(ray.ro - boxPos, ray.rd, vec3(boxSize, wallThickness, boxSize), outNormal);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 0;\n        normal = outNormal;\n    }\n\n    // BACK WALL\n    intersection = iBox(ray.ro - vec3(boxPos.x, boxPos.y + boxSize - wallThickness, boxPos.z + boxSize + wallThickness), ray.rd, vec3(boxSize, boxSize, wallThickness), outNormal);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 1;\n        normal = outNormal;\n    }\n\n    // RIGHT WALL\n    intersection = iBox(ray.ro - vec3(boxPos.x + boxSize + wallThickness, boxPos.y + boxSize - wallThickness, boxPos.z), ray.rd, vec3(wallThickness, boxSize, boxSize), outNormal);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 2;\n        normal = outNormal;\n    }\n\n    // LEFT WALL\n    intersection = iBox(ray.ro - vec3(boxPos.x -boxSize - wallThickness, boxPos.y + boxSize - wallThickness, boxPos.z), ray.rd, vec3(wallThickness, boxSize, boxSize), outNormal);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 3;\n        normal = outNormal;\n    }\n\n    // CEILING\n    intersection = iBox(ray.ro - vec3(boxPos.x, boxPos.y + 2.0 * boxSize, boxPos.z), ray.rd, vec3(boxSize, wallThickness, boxSize), outNormal);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 4;\n        normal = outNormal;\n    }\n\n    // LIGHT\n    intersection = iBox(ray.ro - vec3(boxPos.x, boxPos.y + 2.0 * boxSize - 0.001, boxPos.z), ray.rd, vec3(lightSourceSize, wallThickness, lightSourceSize), outNormal);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 5;\n        normal = outNormal;\n    }\n\n    boxPos.y += 0.02;\n\n    // GLASS BALL\n    float radius = 0.7;\n    vec3 pos = boxPos + vec3(1.1, radius, -0.4);\n    intersection = iSphere(ray.ro - pos, ray.rd, radius);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 6;\n        intersectionPoint = ray.ro + ray.rd * intersection.x;\n        normal = normalize(intersectionPoint - pos);\n    }\n\n    // BOX\n    vec3 boxDim = vec3(0.7, 1.5, 0.7);\n    pos = boxPos + vec3(-0.6, 1.495, 0.7);\n    vec3 boxRo = rotateY(ray.ro, 0.4);\n    vec3 boxRd = rotateY(ray.rd, 0.4);\n    intersection = iBox(boxRo - pos, boxRd, boxDim, outNormal);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 7;\n        normal = rotateY(outNormal, -0.4);\n    }\n\n    // MIRROR BALL\n    radius = 0.4;\n    pos = boxPos + vec3(-0.4, radius, -1.0);\n    intersection = iSphere(ray.ro - pos, ray.rd, radius);\n\n    if(intersection.x > 0.0 && intersection.x < minIntersection.x)\n    {\n        minIntersection = intersection;\n        index = 8;\n        intersectionPoint = ray.ro + ray.rd * intersection.x;\n        normal = normalize(intersectionPoint - pos);\n    }\n    return vec3(minIntersection, index);\n}\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float metallic;\n    float refraction;\n    float transmittance;\n    vec3 emissionColor;\n    float emissionPower;\n};\n\nfloat fresnel(vec3 rd, vec3 normal, float n1, float n2)\n{\n    float cos = abs(dot(-rd, normal));\n    float sin = sqrt(1.0 - pow(cos, 2.0));\n    float sq = sqrt(1.0 - pow(n1 / n2 * sin, 2.0));\n    float n1cos = n1 * cos;\n    float n2cos = n2 * cos;\n    float n1sq = n1 * sq;\n    float n2sq = n2 * sq;\n    float Rs = pow((n1cos - n2sq) / (n1cos + n2sq), 2.0);\n    float Rp = pow((n1sq - n2cos) / (n1sq + n2cos), 2.0);\n    float R = 0.5 * (Rs + Rp);\n    return R;\n}\n\nfloat sellmeier(float wavelength, float B1, float B2, float C1, float C2)\n{\n    float w_um = wavelength / 1000.0;\n    float w2 = w_um * w_um;\n    float n2 = 1.0 + B1 * w2 / (w2 - C1) + B2 * w2 / (w2 - C2);\n    return sqrt(n2);\n}\n\nvec3 getSky(vec3 rd)\n{\n    rd = rotateX(rd, PI / 2.0);\n    rd = rotateZ(rd, 3.0 * PI / 2.0);\n\n    vec2 skyUV = vec2(atan(rd.x, rd.y), asin(rd.z) * 2.0) / PI * 0.5 + 0.5;\n\n    vec3 col = texture(iChannel1, skyUV).rgb;\n    vec3 sun = vec3(0.95, 0.9, 1.0);\n    return clamp(col, 0.0, 1.0);\n}\n\nvec4 trace(inout Ray ray, inout vec3 contribution, int i)\n{\n    vec3 normal;\n    vec3 second = castRay(ray, normal);\n    vec2 intersection = second.xy;\n    vec3 intersectionPoint = ray.ro + ray.rd * intersection.x;\n    int index = int(second.z);\n\n    if(index == -1)\n    {\n        //return vec4(getSky(ray.rd), 1);\n        return vec4(vec3(0), 1);\n    }\n\n    Material mat;\n    vec4 color;\n\n    if(index == 0)\n    {\n        mat = Material(vec3(1, 1, 1), 1.0, 1.0, 0.0, 0.0, vec3(1, 1, 1), 0.0);\n    }\n    else if(index == 1)\n    {\n        mat = Material(vec3(1, 1, 1), 1.0, 0.0, 0.0, 0.0, vec3(1, 1, 1), 0.0);\n    }\n    else if(index == 2)\n    {\n        mat = Material(vec3(0, 1, 0), 1.0, 0.0, 0.0, 0.0, vec3(0, 1, 0), 0.0);\n    }\n    else if(index == 3)\n    {\n        mat = Material(vec3(1, 0, 0), 1.0, 0.0, 0.0, 0.0, vec3(1, 0, 0), 0.0);\n    }\n    else if(index == 4)\n    {\n        mat = Material(vec3(1, 1, 1), 0.0, 0.25, 0.0, 0.0, vec3(1, 1, 1), 0.0);\n    }\n    else if(index == 5)\n    {\n        mat = Material(vec3(1, 1, 1), 1.0, 0.0, 0.0, 0.0, vec3(1, 1, 1), 40.0);\n    }\n    else if(index == 6)\n    {\n        mat = Material(vec3(1, 1, 1), 0.0, 1.0, 1.5, 0.9306, vec3(1, 1, 1), 0.0);\n    }\n    else if(index == 7)\n    {\n        mat = Material(vec3(1, 1, 1), 0.0, 1.0, 1.5, 0.9306, vec3(1, 1, 1), 0.0);\n    }\n    else if(index == 8)\n    {\n        mat = Material(vec3(1, 1, 1), 0.0, 1.0, 0.0, 0.0, vec3(1, 1, 1), 0.0);\n    }\n\n    mat.roughness *= mat.roughness;\n\n    vec3 rand = randomOnSphere();\n    vec3 diff = normalize(rand * dot(rand, normal));\n    vec3 reflected = reflect(ray.rd, normal);\n    float specularBounce = (mat.metallic >= random()) ? 1.0 : 0.0;\n\n    vec3 emission = mat.emissionColor * mat.emissionPower;\n\n    if(i == 0) contribution *= mat.albedo;\n    else contribution *= mix(mat.albedo, vec3(1), specularBounce);\n\n\n    float fmix = (1.0 - mat.roughness) * specularBounce;\n\n    if(mat.emissionPower > 0.0)\n    {\n        return vec4(emission, 1);\n    }\n\n    if(mat.refraction >= 1.0)\n    {\n        float n1 = 1.000273;\n        float n2 = sellmeier(ray.wavelength, 1.03961212, 0.231792344, 6.00069867e-3, 2.00179144e-2);\n\n        if(random() - (1.0 - mat.transmittance) < fresnel(ray.rd, normal, n1, n2))\n        {\n            ray.rd = reflected;\n            ray.rd = mix(diff, reflected, fmix);\n            return vec4(emission, 0);\n        }\n\n        ray.ro += ray.rd * (intersection.x + 0.001);\n        ray.rd = mix(diff, reflected, fmix);\n        ray.rd = refract(ray.rd, normal, n1 / n2);\n        return vec4(emission, 0);\n    }\n\n    ray.ro += ray.rd * (intersection.x - 0.001);\n    ray.rd = mix(diff, reflected, fmix);\n\n    return vec4(emission, 0);\n}\n\nvec3 traceRay(in Ray ray)\n{\n    vec3 light = vec3(0.0);\n    vec3 contribution = ray.colorFactor;\n\n    for(int i = 0; i < MAX_REFLECTIONS; i++)\n    {\n        vec4 refCol = trace(ray, contribution, i);\n        if(refCol.a == 1.0)\n        {\n            return light + refCol.rgb * contribution;\n        }\n        else\n        {\n            light += refCol.rgb * contribution;\n        }\n    }\n\n    return light;\n}\n\nvec3 render(in vec2 uv)\n{\n    vec3 ro = CAMERA_POS;\n    float invTanFov = 1.0 / tan(radians(CAMERA_FOV) * 0.5);\n    vec3 rd = normalize(vec3(invTanFov, uv));\n    rd = rd.yzx;\n    \n    seed1 = hash22(gl_FragCoord.xy - iTime);\n    seed2 = hash22(gl_FragCoord.xy + iTime);\n    vec2 uvRes = hash22(uv + 1.0) * iResolution.xy + iResolution.xy;\n    R_STATE.x = uint(seed1.x + uvRes.x);\n    R_STATE.y = uint(seed1.y + uvRes.x);\n    R_STATE.z = uint(seed2.x + uvRes.y);\n    R_STATE.w = uint(seed2.y + uvRes.y);\n    \n    vec3 outColor;\n\n    for(int i = 0; i < SAMPLES; i++)\n    {\n        float wavelength = mix(380.0, 780.0, random());\n        vec3 sRGB = wavelengthTosRGB(wavelength);\n        Ray ray = Ray(ro, rd, sRGB, wavelength);\n\n        outColor += traceRay(ray);\n    }\n\n    outColor /= float(SAMPLES);\n    \n    outColor = gammaCorrection(outColor);\n\n    return outColor;\n}\n\nvec2 getUV(vec2 offset)\n{\n    return (2.0 * gl_FragCoord.xy + offset - iResolution.xy) / iResolution.y;\n}\n\nvec3 renderAAx1()\n{\n    return render(getUV(vec2(0)));\n}\n\nvec3 renderAAx2()\n{\n    float bxy = float(int(gl_FragCoord.x + gl_FragCoord.y) & 1);\n    float nbxy = 1. - bxy;\n    vec3 colAA = (render(getUV(vec2(0.33 * nbxy, 0.))) + render(getUV(vec2(0.33 * bxy, 0.66))));\n    return colAA / 2.0;\n}\n\nvec3 renderAAx3()\n{\n    float bxy = float(int(gl_FragCoord.x + gl_FragCoord.y) & 1);\n    float nbxy = 1. - bxy;\n    vec3 colAA = (render(getUV(vec2(0.66 * nbxy, 0.))) + render(getUV(vec2(0.66 * bxy, 0.66))) + render(getUV(vec2(0.33, 0.33))));\n    return colAA / 3.0;\n}\n\nvec3 renderAAx4()\n{\n    vec4 e = vec4(0.125, -0.125, 0.375, -0.375);\n    vec3 colAA = render(getUV(e.xz)) + render(getUV(e.yw)) + render(getUV(e.wx)) + render(getUV(e.zy));\n    return colAA /= 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 sampleUV = fragCoord / iResolution.xy;\n    samplePart = texture(iChannel0, sampleUV).a;\n    vec3 sampleCol = texture(iChannel0, sampleUV).rgb;\n    fragColor.rgb = sampleCol;\n    \n    vec3 col;\n    \n    if(MSAA == 2) col = renderAAx2();\n    else if(MSAA == 3) col = renderAAx3();\n    else if(MSAA == 4) col = renderAAx4();\n    else col = renderAAx1();\n    \n    samplePart++;\n    \n    fragColor = vec4(mix(fragColor.rgb, col, 1.0 / samplePart), samplePart);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fdSR2.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MfcXzj", "name": "Spinning Nested Squares", "author": "Bingle", "description": "A simple pattern that I wanted to try and implement in glsl. I spent a while on desmos trying to figure out the scaling math.", "tags": ["square", "pattern"], "time_retrieved": "2024-05-15T23:19:19.230714", "image_code": "#define PI 3.14159265359\n#define MAXITER 1000\n//#define WALL\n\n// Spinning Nested Squares by Bingle\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    #ifdef WALL\n    uv*=2.0;\n    uv+=vec2(0.2,0.06)*iTime;\n    uv = mod(uv+vec2(0.5),1.0)-vec2(0.5);\n    #endif\n    \n    float increment = mod(0.25*iTime+0.125,PI*0.5); // Angle increment (should always be less than π/2)\n    \n    int depth = 0;\n    bool fill = true;\n    \n    float scale = 1.0;\n    float angle = 0.0;\n    \n    while (true){\n        if (depth>MAXITER){\n            break; // break statement so my gpu doesn't break\n        }\n        \n        vec2 local = vec2(dot(uv,vec2(cos(angle),sin(angle))),dot(uv,vec2(-sin(angle),cos(angle)))); // Apply rotation\n        \n        if (max(abs(local.x),abs(local.y))<scale*0.5){\n            depth++;\n            scale *= 0.707106781187/cos(increment-0.785398163397); // These constants are (from left to right) the square root of 2 divided by 2 and pi divided by 4\n            fill = !fill;\n        }else{\n            break; // We're outside of the square\n        }\n        \n        depth++;\n        angle+=increment;\n    }\n    \n    vec3 col = vec3(1.0);\n    \n    if (depth>MAXITER){\n        col = vec3(0.5); // Just average things out\n    }\n    \n    if (fill){ // Invert colors\n        col = vec3(1.0)-col;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MfcXzj.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4f3XR2", "name": "Magnetic field_horseshoe magnet", "author": "A_bar_magnet", "description": "This rendering uses the idea of infinitesimal accumulation. ", "tags": ["2d", "physics"], "time_retrieved": "2024-05-15T23:19:19.268316", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Pi=3.1415926535;\n    vec2 uv = fragCoord/iResolution.xy-0.5;     \n    uv.x*=iResolution.x/iResolution.y;\n    float B= 0.;\n    vec3 col=vec3(1.);\n\n\tfor(float x = -0.05; x >= -0.1; x -= 0.001)\n\t{\n\t\tfor(float y = 0.; y <= 0.2;  y += 0.005)\n\t\t{\n\t\t\tB += (uv.x - x) / pow(pow(uv.x - x, 2.) + pow(uv.y - y, 2.), 1.5);\n\t\t}\n\t}\n\tfor (float x = 0.05; x <= 0.1; x += 0.001)\n\t{\n\t\tfor (float y = 0.; y <= 0.2; y += 0.005)\n\t\t{\n\t\t\tB += (x - uv.x) / pow(pow(uv.x - x, 2.) + pow(uv.y - y, 2.), 1.5);\n\t\t}\n\t}\n\n\tfor (float angle = 0.; angle < Pi / 2.; angle = angle + 0.075)\n\t{\n\t\tfor (float r = 0.05; r <= 0.1; r += 0.001) \n\t\t{\n\t\t\tB += (uv.y * sin(angle) + uv.x * cos(angle) + r) / pow(uv.x * uv.x + uv.y * uv.y + 2. * uv.x * r * cos(angle) + 2. * uv.y * r * sin(angle) + r * r, 1.5);\n\t\t}\n\t}\n\tfor (float angle = Pi; angle > Pi / 2.; angle = angle - 0.075)\n\t{\n\t\tfor (float r = 0.05; r <= 0.1; r += 0.001)\n\t\t{\n\t\t\tB += (uv.y * sin(angle) + uv.x * cos(angle) + r) / pow(uv.x * uv.x + uv.y * uv.y + 2. * uv.x * r * cos(angle) + 2. * uv.y * r * sin(angle) + r * r, 1.5);\n\t\t}\n\t}\n\n    B=pow(pow(B,2.),0.5);\n    for(float i=0.;i<=10.;i++)\n    {\n        if(B > 10000.*i && B < 10000.*i+1000.){\n            col=vec3(0.);            \n            break;\n        }\n    }\n    for(float i=5.;i<=20.;i++)\n    {\n        if(B > 20000.*i && B < 20000.*i+3000.){\n            col=vec3(0.);            \n            break;\n        }\n    }\n     for(float i=2.;i<=10.;i++)\n    {\n        if(B > 200000.*i && B < 200000.*i+20000.){\n            col=vec3(0.);            \n            break;\n        }\n    }\n \n    if((step(uv.x,0.1)*step(0.05,uv.x)*step(uv.y,0.2)*step(0.,uv.y))==1.)\n    {\n        col=vec3(0.);\n    }\n     if((step(uv.x,-0.05)*step(-0.1,uv.x)*step(uv.y,0.2)*step(0.,uv.y))==1.)\n    {\n        col=vec3(0.);\n    }\n     if(step(0.05*0.05,uv.x*uv.x+uv.y*uv.y)*step(uv.x*uv.x+uv.y*uv.y,0.01)*step(uv.y,0.)==1.)\n    {\n        col=vec3(0.);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4f3XR2.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Xc3Xzj", "name": "Magnetic field of bar magnet", "author": "A_bar_magnet", "description": "This rendering uses the ideas of infinitesimal  accumulation. ", "tags": ["2d", "physics"], "time_retrieved": "2024-05-15T23:19:19.305906", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy-0.5;     \n    uv.x*=iResolution.x/iResolution.y;\n    float B= 0.;\n\n    for(float x=-0.1;x<=0.1;x=x+0.0004)\n    {\n        for(float y=-0.01;y<=0.01;y=y+0.0004)\n        {\n            B+=pow((uv.y-y)*(uv.y-y),0.5)/pow(pow(uv.x-x,2.)+pow(uv.y-y,2.),1.5);\n        }\n    }\n    vec3 col =vec3(0.);\n    B=B/10000.;\n\n    for(float i=0.;i<=100.;i++)\n    {\n        if(B > 10.*i && B < 10.*i+1.){\n            col=vec3(1.);            \n            break;\n        }\n    }\n\n    if((step(uv.x,0.1)*step(-0.1,uv.x)*step(uv.y,0.01)*step(-0.01,uv.y))==1.)\n    {\n        col=vec3(1.);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xc3Xzj.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MftXzS", "name": "Fork Pixel Sort vinnieyoun 812", "author": "vinnieyoung", "description": "This is a variation of the Pixel Sorting shader by @cornusammonis here https://www.shadertoy.com/view/XdcGWf\n\nIt works on video by blending the sorted image to the incoming video by  a factor of 100 to 1.\n\nAlso uses real luminance equation.\n", "tags": ["video", "pixel", "feedback", "sorting"], "time_retrieved": "2024-05-15T23:19:19.337708", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    float step_y = texel.y;\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 n  = vec2(0.0, step_y);\n\n    vec4 im_n =  texture(iChannel0, uv+n);\n    vec4 im =    texture(iChannel0, uv);\n    vec4 im_s =  texture(iChannel0, uv+s);\n    \n    // use luminance for sorting\n    float len_n = dot(im_n, vec4(0.299, 0.587, 0.114, 0.));\n    float len = dot(im, vec4(0.299, 0.587, 0.114, 0.));\n    float len_s = dot(im_s, vec4(0.299, 0.587, 0.114, 0.));\n    \n    if(int(mod(float(iFrame) + fragCoord.y, 2.0)) == 0) {\n        if ((len_s > len)) { \n            im = im_s;    \n        }\n    } else {\n        if ((len_n < len)) { \n            im = im_n;    \n        }   \n    }\n    \n    // blend with image\n    if(iFrame<1) {\n        fragColor = texture(iChannel1, uv);\n    } else {\n        fragColor = (texture(iChannel1, uv) + im * 99. ) / 100.;\n    }\n    \n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MftXzS.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "XfdXzB", "name": "4d Cube search distfunc", "author": "sanderoneil", "description": "cube and sphere", "tags": ["cube", "4d"], "time_retrieved": "2024-05-15T23:19:20.002932", "image_code": "const float pi=3.141592653589793;\nconst float r = .5;\nfloat sum4(vec4 v){\nreturn abs(v.x)+abs(v.y)+abs(v.z)+abs(v.w);\n}\nvec3 mainloop(vec4 model_origin,vec4 ray,vec4 ray_origin, inout float lowest_d, vec3 col,inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\n    float side_length = 4.;\n    for (float w = 0.; w<side_length; w++)\n    for (float z = 0.; z<side_length; z++)\n    for (float x = 0.; x<side_length; x++)\n    for (float y = 0.; y<side_length; y++)\n    {\n    vec4 p = vec4 (x+1.,y+1.,z+1.,w+1.)-(side_length-1.)/2.;\n    \n    if (length(p)>side_length/2.){\n    col = col_return_cube(p+model_origin,0.9, ray,ray_origin, lowest_d, col,reflected_ray,reflected_ray_origin);\n   }\n    }\n    float s= 27.;\n    col = col_return_cube(model_origin-s/2.,s, ray,ray_origin, lowest_d, col,reflected_ray,reflected_ray_origin);\n    //col=sphere_inside_search(model_origin,ray,ray_origin,lowest_d,col,20.,reflected_ray,reflected_ray_origin);\n    for (int d = 0; d<4; d++)\n    {\n        \n        for (int neg = 0; neg<2; neg++)\n        {\n        vec4 a = vec4(0,0,0,0);\n        a.x = float(d==0);\n        a.y = float(d==1);\n        a.z = float(d==2);\n        a.w = float(d==3);\n        \n        a = a -2.*float(neg)*a;\n        //col=sphere_inside_search(model_origin,ray,ray_origin,lowest_d,col,14.,reflected_ray,reflected_ray_origin);\n        //col = sphere_search(model_origin+a*side_length,ray,ray_origin,lowest_d,col,1.8,reflected_ray,reflected_ray_origin);\n        }\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y ;\n    \n    vec2 M = iMouse.xy/iResolution.xy*4.;\n    float t = iTime/10.;\n    vec4 v = eulerto4(0. + M.x,0.,0.);\n    vec4 r = eulerto4(pi/2.+ M.x,0.,0.);\n    vec4 u = eulerto4(0.+ M.x,pi/2.,0.);\n    v = rot(v,0.,M.y,M.y,0.+t,0.+M.x);\n    r = rot(r,0.,M.y,M.y,0.+t,0.+M.x);\n    u = rot(u,0.,M.y,M.y,0.+t,0.+M.x);\n    vec4 ray = normalize(v + r*uv.x + u * uv.y);\n    vec4 ray_origin = vec4(0,0,0,0);\n    \n    vec4 next_ray = ray+0.;\n    vec4 next_ray_origin = ray_origin+0.;\n    \n    vec4 norms[8];\n    \n    vec4 model_origin = v*11.;\n    \n\n    vec3 col = ray.xyz;\n    \n    // Time varying pixel color\n    float lowest_d = 1000000000000.;\n\n    vec3 totalcol=vec3(0);\n    for (float reflection_depth = 0.; reflection_depth < 8.; reflection_depth++){\n    col = mainloop(model_origin,ray,ray_origin,lowest_d,col,next_ray, next_ray_origin);\n    \n    totalcol+=col/3./(reflection_depth+1.4);\n    \n    ray = next_ray+0.;\n    ray_origin = next_ray_origin + 0.;\n    lowest_d = 1000000000000.;\n    }\n\n    fragColor = vec4(totalcol,1.0);\n}", "image_inputs": [], "common_code": "vec4 eulerto4( float a, float c ,float b)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    float cb = cos(b);\n    float sb = sin(b);\n    float cc = cos(c);\n    float sc = sin(c);\n    \n    return normalize(vec4(ca*cc,sa*cc,cb*sc,sb*sc));\n}\nvec4 rot(vec4 p,float a, float b,float c,float d,float e)\n{\n\n vec4 pt;\n float co = cos(a);\n float si = sin(a);\n \n pt = vec4(co*p.x - si*p.y,si*p.x + co*p.y,p.z,p.w);\n p = pt+0.;\n co = cos(b);\n si = sin(b);\n pt = vec4(co*p.x - si*p.z,p.y,si*p.x + co*p.z,p.w);\n p = pt+0.;\n \n co = cos(c);\n si = sin(c);\n pt = vec4(co*p.x - si*p.w,p.y,p.z,si*p.x + co*p.w);\n p = pt+0.;\n \n co = cos(d);\n si = sin(d);\n pt = vec4(p.x,co*p.y - si*p.w,p.z,si*p.y + co*p.w);\n p = pt+0.;\n \n co = cos(e);\n si = sin(e);\n pt = vec4(p.x,p.y,co*p.z - si*p.w,si*p.z + co*p.w);\n p = pt+0.;\n \n return p;\n \n}\nvec4 ref(vec4 ray, vec4 norm){\nreturn ray - 2.*dot(ray,norm)*norm;\n}\nvec3 cube_search(vec4 cube,vec4 ray,vec4 ray_origin, vec4 norms[8],inout float lowest_d, vec3 col, vec4 total_center,inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\nfor (int plane_number = 0; plane_number<8; plane_number ++)\n{\n    vec4 n = norms[plane_number];\n    vec4 p0 = cube + n - ray_origin;\n    \n    float d = dot(p0, n)/ dot(ray,n);\n    \n    vec4 p = ray*d;\n    \n    vec4 intersect_to_cube_center = p - p0;\n    bool any_dimension_above_1 = any(greaterThan(abs(intersect_to_cube_center), vec4(1.0001)));\n    //intersect_to_cube_center < vec4(1,1,1,1);\n    \n    if(!any_dimension_above_1){\n    if(d<lowest_d && d>0.00010){\n    col = n.xyz + n.w + .5;\n    vec4 totald = p - total_center  +ray_origin;\n    //col = (totald.xyz+totald.w+ .5 )/3.;//n.xyz + n.w + .5 ;\n    lowest_d = min(d,lowest_d);\n    reflected_ray = ref(ray,normalize(n));\n    reflected_ray_origin = p +ray_origin ;\n    }}\n    \n    }\n    return col;\n}\n\nfloat maxmin(vec4 v, vec4 b){\n\nreturn max (max (min (v.x, b.x), min (v.y, b.y)),  max(min (v.z, b.z),min (v.w, b.w)));\n\n}\nfloat minmax(vec4 v, vec4 b){\n\nreturn min (min (max (v.x, b.x), max (v.y, b.y)), min(max (v.z, b.z),max (v.w, b.w)));\n\n}\nfloat cube_dist(vec4 ray_inverse, vec4 cube_lower_corner,float size){\n    vec4 cube_upper_corner = cube_lower_corner + 1.;\n    vec4 dist_low = cube_lower_corner*ray_inverse;\n    //vec3 sine_transform = sine(dist_low);\n    \n    vec4 dist_high = dist_low+ray_inverse*size;\n    //vec3 minimums = min2(dist_low,dist_high);\n    //vec3 maximums = max2(dist_low,dist_high);\n    \n    //float maximalMinimum = max3(minimums);\n    //float minimalMaximum = min3(maximums);\n    float minimalMaximum = minmax(dist_low,dist_high);\n    float maximalMinimum = maxmin(dist_low,dist_high);\n    \n    if (minimalMaximum>maximalMinimum){\n    if (maximalMinimum<=0.)\n    {return minimalMaximum;}\n    return maximalMinimum ;}\n   return 10000000000000.;\n}\nvec3 col_return_cube(vec4 cube,float size,vec4 ray,vec4 ray_origin,inout float lowest_d, vec3 col,inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\n    vec4 ray_inverse = 1./ray;\n    cube-=ray_origin;\n    float d = cube_dist(ray_inverse,cube,size);\n    \n    if(d<lowest_d && d>0.)\n    {\n        lowest_d = d;\n        vec4 cube_lower_corner = cube;\n        vec4 dist_low = cube_lower_corner*ray_inverse;\n        vec4 dist_high = dist_low+ray_inverse*size;\n        \n        vec4 n  = vec4(dist_low.x == d, dist_low.y == d, dist_low.z == d, dist_low.w == d);\n        n -= vec4(dist_high.x == d, dist_high.y == d, dist_high.z == d, dist_high.w == d);\n        col = (n.xyz + n.w + .5);\n        \n        reflected_ray = ref(ray,n);\n        reflected_ray_origin = ray*d +ray_origin + reflected_ray*.001;\n        \n    }\n    return col;\n}\nvec3 col_return_cube(vec4 cube,vec4 ray,vec4 ray_origin,inout float lowest_d, vec3 col,inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\n    return col_return_cube(cube,1.0,ray,ray_origin,lowest_d,col, reflected_ray, reflected_ray_origin);\n}\n\n\nvec3 sphere_search(vec4 sphere,vec4 ray,vec4 ray_origin, inout float lowest_d, vec3 col, float r, inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\n    vec4 p0 = sphere - ray_origin;\n    float gradient = dot(ray, -p0)*dot(ray, -p0) - (dot(-p0,-p0) - r*r);\n    \n    float d = -dot(ray, -p0) - sqrt(gradient);\n    \n    vec4 p = ray*d;\n    \n    vec4 intersect_to_sphere_center = p - p0;\n   \n    if(d<lowest_d&& d>0.00010){\n        col =  intersect_to_sphere_center.xyz + intersect_to_sphere_center.w + .5;//intersect_to_sphere_center.xyz + intersect_to_sphere_center.w + .5;\n        reflected_ray = ref(ray,normalize(intersect_to_sphere_center));\n    reflected_ray_origin = p +ray_origin;\n    \n    lowest_d = min(d,lowest_d);}\n    \n    //col = vec3(gradient,mod(gradient,100.),0);\n    return col;\n}\n\nvec3 sphere_inside_search(vec4 sphere,vec4 ray,vec4 ray_origin, inout float lowest_d, vec3 col, float r, inout vec4 reflected_ray,  inout vec4 reflected_ray_origin)\n{\n    vec4 p0 = sphere - ray_origin;\n    float gradient = dot(ray, -p0)*dot(ray, -p0) - (dot(-p0,-p0) - r*r);\n    \n    float d = -dot(ray, -p0) + sqrt(gradient);\n    \n    vec4 p = ray*d;\n    \n    vec4 intersect_to_sphere_center = -p + p0;\n   \n    if(d<lowest_d&& d>0.00010){\n        col =  intersect_to_sphere_center.xyz + intersect_to_sphere_center.w + .5;//intersect_to_sphere_center.xyz + intersect_to_sphere_center.w + .5;\n        reflected_ray = ref(ray,normalize(intersect_to_sphere_center));\n    reflected_ray_origin = p +ray_origin;\n    \n    lowest_d = min(d,lowest_d);}\n    \n    //col = vec3(gradient,mod(gradient,100.),0);\n    return col;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfdXzB.jpg", "access": "api", "wgpu-test": "error"}
{"id": "4fdSzB", "name": "Cubes red green", "author": "EATG", "description": "cubes move", "tags": ["cubes"], "time_retrieved": "2024-05-15T23:19:22.729517", "image_code": "/*\n    Original shader by Shane here: https://www.shadertoy.com/view/4dt3zn\n\tI just added some audio-awareness (cube's size following the fft frenquencies)\n*/\n\n/*\n\tRaymarched Reflections\n\t----------------------\n\n\tA very basic demonstration of raymarching a distance field with reflections \n\tand reasonably passable shadows. Definitely not cutting edge, but hopefully, \n\tinteresting to anyone who isn't quite familiar with the process.\n\n\tReflections are pretty easy: Raymarch to the hit point, then obtain the color \n\tat that point. Continue on from the hit point in the direction of the reflected \n\tray until you reach a new hit point. Obtain the color at the new point, then\n\tadd a portion of it to your original color. Repeat the process.\n\n\tUnfortunately, the extra work can slow things down, especially when you apply\n\tshadows, which is probably why you don't see too many shadowed,\treflected \n\texamples. However, for relatively simple distance fields, it's pretty doable.\n\n\tIt was tempting to do this up, but I figured a simpler example would be more\n\thelpful. Take away the rambling comments, and there isn't a great deal of code.\n\tI'll post a more sophisticated one later.\n\n    // Reasonably simple examples featuring reflection:\n\n    To the road of ribbon - XT95\n    https://www.shadertoy.com/view/MsfGzr\n\n    704.2 - PauloFalcao\n    https://www.shadertoy.com/view/Xdj3Dt\n\n    // Reflections and refraction. Really cool.\n    Glass Polyhedron - Nrx\n    https://www.shadertoy.com/view/4slSzj\n\n*/\n\n#define FAR 30.\n\n// Distance function. This one is pretty simple. I chose rounded\n// spherical boxes, because they're cheap and they display the \n// reflections reasonably well.\nfloat map(vec3 p)\n{\n    \n    // Positioning the rounded cubes a little off center, in order\n    // to break up the space a little.\n    //\n    // \"floor(p)\" represents a unique number (ID) for each cube \n    // (based on its unique position). Take that number and produce \n    // a randomized 3D offset, then add it to it's regular position. \n    // Simple.\n    float n = sin(dot(floor(p), vec3(7, 157, 113)));\n    vec3 rnd = fract(vec3(2097152, 262144, 32768)*n)*.16-.08;\n    \n    // Repeat factor. If irregularity isn't your thing, you can get \n    // rid of \"rnd\" to line things up again.\n    p = fract(p + rnd) - .5;\n    \n    float eq = texture(iChannel0, vec2(fract(n), 0.25)).r;\n    float boxsize = 0.1 + eq * 0.6;\n    \n    // Rounded spherical boxes. The following is made up, but kind of\n    // makes sense. Box, minus a bit of sphericalness, gives you a \n    // rounded box.\n    p = abs(p); \n    return max(p.x, max(p.y, p.z)) - boxsize + dot(p, p)*.5;\n    \n    //return length(p) - 0.225; // Just spheres.\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002 || t>FAR) break; // Normally just \"d<.0025\"        \n        \n        t += d*.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 48; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.0025 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .005;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .2);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n        //if (h<0.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + 0.25, 1.0); \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0035, -0.0035); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\n// Alternating the cube colors in a 3D checkered arrangement.\n// You could just return a single color, if you wanted, but I\n// thought I'd mix things up a bit.\n//\n// Color scheme mildly influenced by: Sound Experiment 3 - aiekick\n// https://www.shadertoy.com/view/Ml2XWt\nvec3 getObjectColor(vec3 p){\n    vec3 col;\n    \n    // Calcula el módulo de la coordenada X, Y y Z para determinar qué color asignar al cubo.\n    float modX = mod(p.x, 4.0);\n    float modY = mod(p.y, 4.0);\n    float modZ = mod(p.z, 4.0);\n    \n    // Asigna colores en función del módulo de las coordenadas.\n    if (modX < 1.0)\n        col = vec3(1.0, 0.0, 0.0); // Rojo\n    else if (modX < 2.0)\n        col = vec3(0.0, 1.0, 0.0); // Verde\n    else if (modX < 3.0)\n        col = vec3(0.0, 0.0, 1.0); // Azul\n    else\n        col = vec3(1.0); // Blanco\n    \n    return col;\n}\n\n// Using the hit point, unit direction ray, etc, to color the \n// scene. Diffuse, specular, falloff, etc. It's all pretty \n// standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist*0.2 + lDist*lDist*0.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.0);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp);\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff + 0.15) + vec3(1., .6, .2)*spec*2.) * atten;\n\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n\n    // Some cheap camera movement, for a bit of a look around. I use this far\n    // too often. I'm even beginning to bore myself, at this point. :)\n    float cs = cos(iTime * 0.25), si = sin(iTime * 0.25);\n    rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0., 0., iTime*1.5);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 1., -.5);\n    \n    \n    // FIRST PASS.\n    \n    float t = trace(ro, rd);\n    \n    // Fog based off of distance from the camera.\n    float fog = smoothstep(0., .95, t/FAR);\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    // Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    // the ray origin to describe the surface hit point is kind of confusing. The reason \n    // we do it is because the reflective ray will begin from the hit point in the \n    // direction of the reflected ray. Thus the new ray origin will be the hit point. \n    // See \"traceRef\" below.\n    vec3 sceneColor = doColor(ro, rd, sn, lp);\n    \n    // Checking to see if the surface is in shadow. Ideally, you'd also check to\n    // see if the reflected surface is in shadow. However, shadows are expensive, so\n    // it's only performed on the first pass. If you pause and check the reflections,\n    // you'll see that they're not shadowed. OMG! - Better call the shadow police. :)\n    float sh = softShadow(ro, lp, 16.);\n    \n    \n    // SECOND PASS - REFLECTED RAY\n    \n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, sn);\n    \n    \n    // The reflected pass begins where the first ray ended, which is the suface\n    // hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    // of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    // of wasteful, but not really noticeable. The direction of the new ray will\n    // obviously be in the direction of the reflected ray. See just above.\n    //\n    // To anyone who's new to this, don't forgot to nudge the ray off of the \n    // initial surface point. Otherwise, you'll intersect with the surface\n    // you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  rd*.01, rd);\n    \n    // Advancing the ray origin, \"ro,\" to the new reflected hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the reflected hit point.\n    sn = getNormal(ro);\n    \n    // Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    // How much you add is up to you, but I'm going with 35 percent.\n    sceneColor += doColor(ro, rd, sn, lp)*.35;\n    \n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    // occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    sceneColor *= sh;\n    \n    // Technically, it should be applied on the reflection pass too, but it's not that\n    // noticeable, in this case.\n    sceneColor = mix(sceneColor, vec3(0), fog); \n    \n    \n   \n\n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fdSzB.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "XcdXzB", "name": "Lava lamp boom c", "author": "EATG", "description": "lava lamp with moves boom boom c", "tags": ["boomboom"], "time_retrieved": "2024-05-15T23:19:23.765763", "image_code": "#define eps 0.005\n#define far 40.\n#define time iTime*.25\n#define PI 3.1415926\n\n#define PSD pow(abs(textureLod(iChannel0, vec2(.5), 0.).r), 2.)\n\n// Variants\n//#define rings\n//#define polar\n//#define warp\n\n#define audio\n\nvec2 rotate(vec2 p, float a)\n{\n    float t = atan(p.y, p.x)+a;\n    float l = length(p);\n    return vec2(l*cos(t), l*sin(t));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\nfloat distort(vec3 p)\n{\n    return dot(tri(p+time) + sin(tri(p+time)), vec3(.666));\n}\n\nfloat trap;\n\nfloat map(vec3 p)\n{\n    p.z += .2;\n    p += distort(p*distort(p))*.1;\n    #ifdef audio\n    trap = dot(sin(p), 1.-abs(p-PSD))*1.2;\n    #endif\n    float d = -sdTorus(p, vec2(1., .7)) + distort(p)*.05;\n    \n    #ifdef rings\n    p.y -= .2;\n    for(int i = 0; i < 3; i++)\n    {\n        p.y += float(i)*.1;\n        \n        d = min(d, sdTorus(p, vec2(.75, .01))-distort(p*float(i))*.01);\n    }\n    #endif\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n        ));\n}\n\nfloat trace(vec3 r, vec3 d, float start)\n{\n    float m, t=start;\n    for (int i = 0; i < 100; i++)\n    {\n        m = map(r + d * t);\n        t += m;\n        if (m < eps || t > far) break;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 R=iResolution.xy, u = (g+g-R)/R.y;\n    \n    #ifdef audio\n    u *= sin(PSD*5.);\n    #else\n    u *= 0.5; // Reduce la velocidad del movimiento cuando no hay sonido\n    #endif\n    \n    #ifdef polar\n    u = rotate(u, 2.*atan(u.y, u.x) + time);\n    #endif\n    \n    #ifdef warp\n    u = abs(u)/dot(u, u) - vec2(step(1., time));\n    #endif\n    \n    vec3 r = vec3(0, 0, 1), d = normalize(vec3(u, -1)), p, n, col;\n    col = vec3(0.);\n    float t = trace(r, d, 0.);\n    p = r + d * t;\n    \n    n = calcNormal(p);\n    \n    if (t < far)\n    {\n        vec3 objcol = vec3(trap/abs(1.-trap), trap*trap, 1.-trap);\n        vec3 lp = vec3(1, 3, 3);\n        vec3 ld = lp - p;\n        float len = length(ld);\n        float atten = max(0., 1./(len*len));\n        ld /= len;\n        float amb = .25;\n        float diff = max(0., dot(ld, n));\n        float spec = pow(max(0., dot(reflect(-ld, n), r)), 8.);\n        float ref = trace(r, reflect(d, n), eps*5.);\n        col = objcol * (((diff*.8+amb*.8)+.1*spec)+atten*.1)*ref;\n    }\n    \n    f = vec4(col, 1);\n}\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcdXzB.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "XctXzB", "name": "Vercel frameworks logos effect", "author": "juk", "description": "frameworks logos effect from vercel landing [in progress]\nupload your 24x24 logos with Shadertoy Custom Textures chrome plugin\nmove mouseX to reveal effect", "tags": ["vercel", "pixelatedlogo"], "time_retrieved": "2024-05-15T23:19:24.703994", "image_code": "precision mediump float;\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n\nvec4 permute(vec4 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v){ \n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy));\n    vec3 x0 =   v - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy);\n    vec3 i2 = max( g.xyz, l.zxy);\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0); \n    vec4 p = permute(permute(permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0)) +\n        i.y + vec4(0.0, i1.y, i2.y, 1.0)) +\n        i.x + vec4(0.0, i1.x, i2.x, 1.0)\n    );\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z); // mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat animationMultiplier(float t){\n    return smoothstep(0.0, 1.0, max(0.0, 1.0 - abs((t - 0.5) * 2.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    \n    float pixelSize = iResolution.y / 24.0;\n    \n    vec2 pixel = mod(fragCoord, pixelSize) - pixelSize / 2.;\n    \n    fragColor = vec4(0.0);\n    \n    float noise = snoise(vec3(floor(fragCoord/pixelSize), iTime));\n    float noise2 = snoise(vec3(floor(fragCoord/pixelSize) - pixelSize * 24.0, iTime));\n        \n    if(length(pixel) < pixelSize / 2.0) {\n        vec4 color = texture(iChannel0, uv);\n        \n        float gray = (color.r + color.g + color.b) / 3.0 * 2.0;\n        \n        fragColor = mix(\n            vec4(vec3(gray), 1.0),\n            color * floor((noise * 0.4 + 0.75) * 8.0) / 8.0,\n            iMouse.x/iResolution.x +\n            noise2 * animationMultiplier(iMouse.x/iResolution.x)\n        );\n    }\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XctXzB.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "XcK3Wd", "name": "pathfinder", "author": "hexagon8899", "description": "you may need to click a few times before you get a maze that is actually solvable", "tags": ["pathfinder"], "time_retrieved": "2024-05-15T23:19:24.753784", "image_code": "void mainImage( out vec4 col, in vec2 pos )\n{\n    col = texture(iChannel0, pos.xy/iResolution.xy);\n    if (texelFetch(iChannel0, ivec2(iResolution.x-1.,0.), 0).x > 0.) {\n        col.x = 0.;\n        if (col.z == 1.) {col = vec4(2.);}\n    }// else if (col.y == 0.) {col.x /= float(iFrame);}\n\n    if (col.y == 1.) {col = vec4(0.5);}\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 xy = ivec2(pos);\n    \n    if ( iFrame == 0 || iMouse.w > 0. || texelFetch(iChannel0, ivec2(0,iResolution.y-1.), 0).z==1. ) {\n        col = vec4(0,0,0,0);\n        initRandomGenerator(pos);\n        if (random()>0.6) { col = vec4(0,1,0,0); }\n        if (pos.x < 7. && pos.y > iResolution.y-7.) { col = vec4(0,0,0,0); }\n        if (pos.y < 7. && pos.x > iResolution.x-7.) { col = vec4(0,0,0,0); }\n        if (pos.x < 1. && pos.y > iResolution.y-1.) { col = vec4(1,0,0,0); }\n    } else {\n        col = texelFetch(iChannel0, xy, 0);\n        if (col.y == 1.) {return;}\n        vec4 W = vec4(0), A = vec4(0), S = vec4(0), D = vec4(0);\n        W = texelFetch(iChannel0, xy+ivec2(0,-1), 0);\n        A = texelFetch(iChannel0, xy+ivec2(-1,0), 0);\n        S = texelFetch(iChannel0, xy+ivec2(0,1), 0);\n        D = texelFetch(iChannel0, xy+ivec2(1,0), 0);\n        if ( texelFetch(iChannel0, ivec2(iResolution.x-1.,0.), 0).x == 0. ) {\n            float m = max(max(W.x, A.x), max(S.x, D.x));\n            if ( col.x==0. && m > 0. ) {\n                col.x = m+1.;\n            }\n        } else {\n            if (pos.y < 1. && pos.x > iResolution.x-1.) { col.z = 1.; }\n            if ( (W.z==1.&&W.x==col.x+1.) || (A.z==1.&&A.x==col.x+1.) ||\n                 (S.z==1.&&S.x==col.x+1.) || (D.z==1.&&D.x==col.x+1.) ) { col.z = 1.; }\n        }\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcK3Wd.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "4ctSW8", "name": "2d kernels", "author": "jonasfrey", "description": "a collection of 2d kernels, \nclick and hold down in a section on the bottom half of the image to see that kernel applied to the top part of the image", "tags": ["kernel"], "time_retrieved": "2024-05-15T23:19:24.788233", "image_code": "\n\nvec4 f_o_convolved_static_3x3(\n    vec2 o_trn, \n    float[3*3] a_n_factor_weight_krnl, \n    int[3*3] a_n_exponent_weight_krnl\n){\n\n    vec2 o_scl_krnl = vec2(3.);\n    vec2 o_scl_krnl_half = floor(o_scl_krnl/2.);\n    \n    \n    vec4 o_col_sum = vec4(0.);\n        \n    for(float n_x = 0.; n_x < o_scl_krnl.x; n_x+=1.){\n        for(float n_y = 0.; n_y < o_scl_krnl.y; n_y+=1.){\n            vec2 o_trn_krnl = vec2(n_x, n_y);\n            vec2 o_trn_krnl2 = o_trn_krnl-o_scl_krnl_half;\n            float n_idx_a_n_krnl = n_y*o_scl_krnl.x + n_x;\n            float n_factor = a_n_factor_weight_krnl[int(n_idx_a_n_krnl)];\n            int n_exponent = a_n_exponent_weight_krnl[int(n_idx_a_n_krnl)];\n\n            vec4 o_col_tmp =\n                texture(\n                    iChannel0,\n                    (o_trn+o_trn_krnl2.xy)/iResolution.xy\n                )*n_factor;\n            o_col_tmp = pow((o_col_tmp), vec4((n_exponent)));\n            o_col_sum+= o_col_tmp;\n        }\n    }\n    vec4 o_col_res = o_col_sum;\n    return (o_col_res);\n\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trn = fragCoord.xy;\n    float n_pixelation = 1.;\n    o_trn=floor(o_trn*(1./n_pixelation))*n_pixelation;\n    vec2 o_trn_nor = fragCoord.xy/iResolution.xy;\n    vec4 o_mouse_nor = iMouse/vec4(iResolution.xy, 1.,1.);\n    \n    vec4 o_col_img = texture(iChannel0,(o_trn)/iResolution.xy);\n    float n = 1./(3.*3.);\n\n        vec4 o_col_sobel_x = f_o_convolved_static_3x3(\n            o_trn,\n            float[](\n            //sobel edge detection x\n            -1., 0., 1.,\n            -2., 0., 2.,\n            -1., 0., 1.\n            ),\n            int[](\n            1, 1, 1,\n            1, 1, 1,\n            1, 1, 1\n            )\n        );\n        vec4 o_col_sobel_y = f_o_convolved_static_3x3(\n            o_trn,\n            float[](\n            //sobel edge detection y\n            1., 2., 1.,\n            0., 0., 0.,\n            -1., -2., -1.\n            ),\n            int[](\n            1, 1, 1,\n            1, 1, 1,\n            1, 1, 1\n            )\n        );\n        vec4 o_col_sobel_x_pow = pow(o_col_sobel_x,vec4(2.));\n        vec4 o_col_sobel_y_pow = pow(o_col_sobel_y,vec4(2.));\n    vec4[] a_o_col = vec4[](\n        o_col_img,\n        f_o_convolved_static_3x3(\n            o_trn,\n            float[](\n            //slight blur\n            1./16., 1./8., 1./16.,\n            1./8., 1./4., 1./8., \n            1./16., 1./8., 1./16. \n            ),\n            int[](\n            1, 1, 1,\n            1, 1, 1,\n            1, 1, 1\n            )\n        ), \n        f_o_convolved_static_3x3(\n            o_trn,\n            float[](\n            //sharpening\n            -1., -1., -1.,\n            -1., 9., -1., \n            -1., -1., -1.\n            ),\n            int[](\n            1, 1, 1,\n            1, 1, 1,\n            1, 1, 1\n            )\n        ), \n        f_o_convolved_static_3x3(\n            o_trn,\n            float[](\n            //slight 'de'blur / deconvolve\n            -1./16., -1./8., -1./16.,\n            -1./8., 1., -1./8., \n            -1./16., -1./8., -1./16. \n            ),\n            int[](\n            1, 1, 1,\n            1, 1, 1,\n            1, 1, 1\n            )\n        ), \n                f_o_convolved_static_3x3(\n            o_trn,\n            float[](\n            //laplacian sharpening\n            0.0, -1.0, 0.0,\n           -1.0,  5.0, -1.0,\n            0.0, -1.0, 0.0\n            ),\n            int[](\n            1, 1, 1,\n            1, 1, 1,\n            1, 1, 1\n            )\n        ), \n\n        (vec4(o_col_sobel_x_pow)),\n        (vec4(o_col_sobel_y_pow)),\n            //sobel edge x+y\n        (\n            vec4(\n                sqrt(o_col_sobel_x_pow.x+o_col_sobel_y_pow.x),\n                sqrt(o_col_sobel_x_pow.y+o_col_sobel_y_pow.y),\n                sqrt(o_col_sobel_x_pow.z+o_col_sobel_y_pow.z),\n                sqrt(o_col_sobel_x_pow.w+o_col_sobel_y_pow.w)\n            )\n        ),\n        // emboss\n        f_o_convolved_static_3x3(\n            o_trn,\n            float[](\n               -2.0, -1.0,  0.0,\n               -1.0,  1.0,  1.0,\n                0.0,  1.0,  2.0\n            ),\n            int[](\n            1, 1, 1,\n            1, 1, 1,\n            1, 1, 1\n            )\n        ),\n        // experiment\n        fract(f_o_convolved_static_3x3(\n            o_trn,\n            float[](\n                1./9., 1./9., 1./9.,\n                1./9., 1./3., 1./9.,\n                1./9., 1./9., 1./9.\n            ),\n            int[](\n            1, 1, 1,\n            1, 1, 1,\n            1, 1, 2\n            )\n        ))\n        \n    );\n   \n    float n_len_a_o_col = float(a_o_col.length());\n    float n_idx = (o_trn_nor.x*float(n_len_a_o_col));\n    float b_mouse_down = float(iMouse.z > 0.0);\n    if(b_mouse_down == 1. && o_trn_nor.y > 0.5){\n        n_idx = (o_mouse_nor.x*float(n_len_a_o_col));\n    }\n    float n_idx_floor = floor(n_idx);\n    if(o_trn_nor.y > 0.5 && b_mouse_down != 1.){\n        n_idx_floor = mod(floor(n_idx_floor+iTime), n_len_a_o_col);\n    }\n\n    float n_line = smoothstep(0.02, 0.0, fract(n_idx));\n    fragColor = (a_o_col[int(n_idx_floor)])+vec4(n_line);\n    //fragColor = vec4(n_line);\n\n    \n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ctSW8.jpg", "access": "api", "wgpu-test": "error"}
{"id": "lc3SW8", "name": "predator-prey with diffusion", "author": "alanlu", "description": "Click palette in corner to select population to inject into the domain, and click in domain to inject selected population at the location. May exhibit numerical instability.\n\nRed = predator\nGreen = prey\n\nTip: rewind and pause to set up initial conditions.", "tags": ["pdes"], "time_retrieved": "2024-05-15T23:19:24.805452", "image_code": "// it's all in Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float forcingRate = 1.;\nconst float forcingInvSize = .5;\nconst int paletteSize = 50;\nconst int paletteOffset = 2;\nconst int pureStripSize = 10;\nconst ivec2 indicatorLoc = ivec2(10, 62);\nconst int indicatorSize = 8;\n\n// model parameters\nconst vec3 diffusionCoeffs = vec3(.4, .1, 0.);\nconst float preyGrowthRate = .1;\nconst float preyInvCarryingCapacity = 1./1.1;\nconst float predationRate = .5;\nconst float conversionRate = .3;\nconst float predatorDeathRate = .1;\n\nbool inDomain(ivec2 coord)\n{\n    return length(vec2(coord) - .5*iResolution.xy) < .46875*iResolution.y;\n}\n\nbool inPalette(ivec2 coord)\n{\n    return coord.x >= paletteOffset && coord.x <= paletteSize + paletteOffset &&\n           coord.y >= paletteOffset && coord.y <= paletteSize + paletteOffset;\n}\n\nvec3 getMixture(vec2 fragCoord)\n{\n    return vec3(clamp((fragCoord - vec2(paletteOffset + pureStripSize)) / vec2(paletteSize - pureStripSize), 0., 1.), 0.);\n}\n\nvec3 getPopulations(ivec2 coord)\n{\n    return texelFetch(iChannel0, ivec2(coord),0).rgb;\n}\n\n// used to enforce Neumann boundary conditions\nvec3 getPopulationsBounded(ivec2 coord, vec3 fallback)\n{\n    if(inDomain(coord)) return getPopulations(coord);\n    return fallback;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    vec3 forcingMixture = getPopulations(indicatorLoc);\n    \n    fragColor = vec4(0.);\n\n    if(abs(fragCoord.x - .5*iResolution.x) < .5*iResolution.y)\n        fragColor = vec4(1.,1.,1.,0.);    \n\n    ivec2 off = abs(coord - indicatorLoc);\n    if(off.x <= indicatorSize && off.y <= indicatorSize) {\n        if(iMouse.z > 0.0 && inPalette(ivec2(iMouse.xy))) {\n            forcingMixture = getMixture(iMouse.xy);\n        }\n        fragColor.rgb = forcingMixture;\n    }\n    \n    if(inDomain(coord)) {\n        fragColor = vec4(0.,0.,0.,1.);\n        vec3 curPops = getPopulations(coord);\n    \n        // Oono-Puri nine-point stencil Laplacian\n        vec3 laplacian = -3.*curPops\n            + .25 * getPopulationsBounded(coord + ivec2(1, 1), curPops)\n            + .25 * getPopulationsBounded(coord + ivec2(1, -1), curPops)\n            + .25 * getPopulationsBounded(coord + ivec2(-1, 1), curPops)\n            + .25 * getPopulationsBounded(coord + ivec2(-1, -1), curPops)\n            + .5 * getPopulationsBounded(coord + ivec2(1, 0), curPops)\n            + .5 * getPopulationsBounded(coord + ivec2(0, 1), curPops)\n            + .5 * getPopulationsBounded(coord + ivec2(-1, 0), curPops)\n            + .5 * getPopulationsBounded(coord + ivec2(0, -1), curPops);\n\n        curPops +=\n            // diagonal diffusion matrix\n            diffusionCoeffs * laplacian +\n            // Kolmogorov driver\n            curPops * vec3(\n                // predator\n                conversionRate * curPops.g - predatorDeathRate,\n                // prey\n                preyGrowthRate * (1. - curPops.g * preyInvCarryingCapacity) - predationRate * curPops.r,\n                // unused\n                0.\n            );\n\n        if(iMouse.z > 0.0) {\n            // inject populations as a gaussian\n            curPops += forcingRate * forcingMixture * exp( \n                -forcingInvSize * dot(iMouse.xy - fragCoord, iMouse.xy - fragCoord));\n        }\n        \n        fragColor.rgb = curPops;\n    } else if(inPalette(coord)) {\n        fragColor.rgb = getMixture(fragCoord);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lc3SW8.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "MftSD7", "name": "triangle renderer", "author": "simplexqwe", "description": " ", "tags": ["trianglerenderer", "texturedisplay"], "time_retrieved": "2024-05-15T23:19:24.838917", "image_code": "/*this is a renderer for a triangle it takes three cornerpoints (a ,b and c)\n  and one point p, it gives back a vector with three values\n  the first falue is 1 if p is inside the triangle and 0 if ouside.\n  the last two values are the uv cordinates for the triangle wich you can\n  use to display a texture on the triangle.\n  */\n\n\nvec3 t (vec2 p,vec2 a,vec2 b,vec2 c){\n    float w1 = (a.x*(c.y-a.y)+(p.y-a.y)*(c.x-a.x)-p.x*(c.y-a.y))/\n               ((b.y-a.y)*(c.x-a.x)-(b.x-a.x)*(c.y-a.y));\n                \n    float w2 = (p.y-a.y-w1*(b.y-a.y))/(c.y-a.y);\n    \n    float i  = 1.;\n    if(min(w1,w2)<=0.)i=0.;\n    if(w1+w2>=1.)i=0.;\n    \n    return vec3(i,w1,w2);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec2 a  = vec2(0.1,0.9);\n    vec2 b  = vec2(0.1,0.1);\n    vec2 c  = vec2(0.9,0.1);\n    \n    vec3 tc = t(uv,a,b,c);\n    \n    vec4 e  = texture(iChannel0,tc.yz,0.)*(tc.x);\n    \n    fragColor = e;\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MftSD7.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Xf3SRS", "name": "Tango", "author": "Chalouek", "description": "classic loading animation with not classic settings", "tags": ["rgb", "loading"], "time_retrieved": "2024-05-15T23:19:24.879121", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    vec2 view = uv*2.0 - vec2(1.0);\n    view.x *= ratio;\n    \n    vec4 image;\n    int amount = abs(int(iTime*0.4)%12-6)+3;\n    vec3 points;\n    \n    for (int i = 0; i<amount; i++){\n    float iF = float(i)*3.14*2./float(amount)*sin(iTime/2.);\n    points = vec3(sin(iTime+iF),cos(iTime+iF),cos(iTime*9.+iF*3.)*2.+3.);\n    points /= 1.8;\n    \n    int iFract = i%3;\n    image[iFract] +=  pow(max(0.,1.-distance(view*points.z,points.xy)*1.5),4.);\n    }\n    \n\n\n\n    fragColor = image;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xf3SRS.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4c3SRS", "name": "Inputs (API Test)", "author": "brisingre", "description": "For a test, nothing cool.", "tags": ["apitesting"], "time_retrieved": "2024-05-15T23:19:25.110411", "image_code": "// Fork of \"New Blank (API Test)\" by brisingre. https://shadertoy.com/view/ftyGzW\n// 2024-04-25 09:03:29\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float x = fragCoord.x;\n    x = 1.-mod(x, 50.0);\n   \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(uv, x, 1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4c3SRS.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "MctXDM", "name": "Face2Face", "author": "kirbyhood", "description": "This is a shader that kinda links up to Daft Punk's Face to Face", "tags": ["daftpunk"], "time_retrieved": "2024-05-15T23:19:25.144577", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime * 0.3;\n    \n    // Background color\n    vec3 col = vec3(0.0, 0.0, 0.1);\n    \n    // Circular waves\n    float circles = 0.0;\n    for (int i = 0; i < 5; i++) {\n        float t = float(i) * 0.1 + time;\n        float scale = 0.3 + sin(t) * 0.1;\n        vec2 center = vec2(0.5) + vec2(sin(t*1.2), cos(t*0.7)) * scale;\n        float dist = distance(uv, center);\n        circles += smoothstep(0.2, 0.0, dist) * (sin(dist*50.0-t*10.0)+1.0) * 0.5;\n    }\n    col += circles * vec3(0.0, 0.5, 1.0);\n    \n    // Pulsing grid\n    vec2 grid = fract(uv * 20.0);\n    float gridMix = min(grid.x, grid.y);\n    float gridPulse = smoothstep(0.92, 0.98, sin(time*5.0 + gridMix*3.14));\n    col += gridPulse * vec3(0.0, 1.0, 0.5);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MctXDM.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "lccXD7", "name": "Fuzz Earthbound", "author": "kirbyhood", "description": "It is fuzzy and fun", "tags": ["trippy"], "time_retrieved": "2024-05-15T23:19:25.179895", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec3 color = vec3(0.5);\n\n  // Psychedelic waves with even higher frequency and amplitude\n  uv.x += sin((uv.y + iTime) * 80.0) * 0.8;\n  uv.y += cos((uv.x + iTime) * 80.0) * 0.8;\n  uv.x += sin((uv.y + iTime) * 160.0) * 0.4;\n  uv.y += cos((uv.x + iTime) * 160.0) * 0.4;\n\n  // Swirling pattern with even more intricate calculations\n  vec2 center = vec2(0.5);\n  float dist = distance(uv, center);\n  uv += (center - uv) * (1.0 - dist) * 0.1;\n  uv += (center - uv) * (1.0 - dist) * 0.1 * sin(iTime * 20.0);\n  uv += (center - uv) * (1.0 - dist) * 0.1 * sin(iTime * 40.0);\n  uv += (center - uv) * (1.0 - dist) * 0.1 * sin(iTime * 80.0);\n\n  // Purple color shift with even more oscillations\n  color += vec3(0.5, 0.0, 0.5) * sin(uv.x * 80.0 + iTime);\n  color += vec3(0.5, 0.0, 0.5) * cos(uv.y * 80.0 + iTime);\n  color += vec3(0.25, 0.0, 0.25) * sin(uv.x * 40.0 + iTime * 2.0);\n  color += vec3(0.25, 0.0, 0.25) * cos(uv.y * 40.0 + iTime * 2.0);\n  color += vec3(0.125, 0.0, 0.125) * sin(uv.x * 20.0 + iTime * 4.0);\n  color += vec3(0.125, 0.0, 0.125) * cos(uv.y * 20.0 + iTime * 4.0);\n  color += vec3(0.0625, 0.0, 0.0625) * sin(uv.x * 10.0 + iTime * 8.0);\n  color += vec3(0.0625, 0.0, 0.0625) * cos(uv.y * 10.0 + iTime * 8.0);\n\n  // Add even more noise for extra visual interest\n  color += vec3(0.2) * sin(fragCoord.x * 0.01 + iTime);\n  color += vec3(0.2) * cos(fragCoord.y * 0.01 + iTime);\n  color += vec3(0.1) * sin(fragCoord.x * 0.005 + iTime * 2.0);\n  color += vec3(0.1) * cos(fragCoord.y * 0.005 + iTime * 2.0);\n  color += vec3(0.05) * sin(fragCoord.x * 0.0025 + iTime * 4.0);\n  color += vec3(0.05) * cos(fragCoord.y * 0.0025 + iTime * 4.0);\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lccXD7.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Mc3XD7", "name": "Water color orb", "author": "ianertson", "description": "Drag around with the mouse to move the orb :)", "tags": ["colors", "orb"], "time_retrieved": "2024-05-15T23:19:25.212530", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rand(vec2 co, float seed)\n{\n    uvec2 p = floatBitsToUint(co);\n    uint s = floatBitsToUint(seed);\n    uint is = ~s;\n    uvec2 ip = ~p;\n    \n    p ^= p << 17U;\n    p ^= p >> 13U;\n    p ^= p << 5U;\n    p += (ip * s + p.y * p.x);\n    p *= 1013U;\n    \n    uint n = (p.x * is + p.y)*5013U;\n    \n    return float(n) / float(0xFFFFFFFFU);\n}\n\nfloat noise(vec2 co, float seed) {\n    vec2 lv = fract(co); lv = lv*lv*(3.0-2.0*lv);\n    vec2 id = floor(co);\n    \n    return mix(\n        mix(rand(id + vec2(0, 0), seed), rand(id + vec2(1, 0), seed), lv.x),\n        mix(rand(id + vec2(0, 1), seed), rand(id + vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat noise(vec2 co, float seed, int oct) {\n    float n = 0.0;\n    float div = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    \n    for (int i = min(iFrame, 0); i < oct; i++) {\n        n += amp*noise(co*freq, seed);\n        float np = n*6.28;\n        co += 0.15*amp*vec2(sin(np), cos(np));\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 randomColor(vec2 co, float seed) {\n    co *= 9.0;\n    float r = noise(co, seed, 6);\n    float g = noise(co, seed+4.499123, 6);\n    float b = noise(co, seed+19.58389, 6);\n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec4 m = vec4((iMouse.xy - 0.5 * iResolution.xy) / iResolution.y, iMouse.zw);\n    vec2 point = vec2(0, 0);\n    \n    if (m.z > 0.001) {\n        point = m.xy;\n    } else {\n        float t = iTime*0.25;\n        point += 0.15*vec2(sin(t), cos(t)); \n    }\n    \n    int st = 1;\n    \n    vec3 right = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(st, 0), 0).rgb;\n    vec3 left = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(-st, 0), 0).rgb;\n    vec3 up = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(0, st), 0).rgb;\n    vec3 down = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(0, -st), 0).rgb;\n\n\n    vec3 old = iFrame <= 1 ? randomColor(uv, iTime) : texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb;\n    \n    vec3 col = randomColor(uv, iTime);\n    \n    vec3 cp = cross(col*2.0-1.0, old*2.0-1.0);\n    col = length(cp) > 0.00001 ? abs(normalize(cp)) : col;\n    \n    int comp = 2;\n    float r = 0.15;\n    float f = r*0.5;\n    float h = 0.5;\n    float dist = smoothstep(r-f, r+f, distance(uv, point));\n\n    comp = clamp(int(mix(0.0, 2.05, dist)), 0, 2);\n    h = mix(h, 0.25, dist);\n\n    if (right[comp] > h && left[comp] > h && up[comp] > h && down[comp] > h) {\n        vec3 ot = min(right, min(left, min(up, down))).xyz;\n        col = mix(col, ot, 1.01);        \n    }\n    \n    fragColor = vec4(mix(col, old, mix(0.5, 0.9, smoothstep(2.0, 2.5, min(iTime, 3.0)))), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mc3XD7.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "lc3XD7", "name": "Fork another sy adamko 740", "author": "adamko", "description": "I was thinking of a way to make pseudo tesselation noise and i made this to illustrate it, i might not be the first one to come up with this solution.\n\nNow as a music visualizer! (channel 0, remove line 11)", "tags": ["raymarching", "sunset", "tesselation", "synthwave", "cineshader"], "time_retrieved": "2024-05-15T23:19:27.333243", "image_code": "//#define AA 2\n//#define VAPORWAVE\n//#define stereo 1. // -1. for cross-eyed (defaults to parallel view)\n#define speed 5. \n#define wave_thing\n//#define city\n\n//you can add any sound texture in iChannel0 to turn it into a cool audio visualizer \n// (it looks better with lower speeds though)\n//you should commment out or remove the following line to enable it (it's disabled mainly for performance reasons):\n//#define disable_sound_texture_sampling\n\n#ifndef disable_sound_texture_sampling\n    #undef speed \n    // lower value of speed when using as audio visualizer\n    #define speed 1.\n#endif\n\n//self-explainatory\n#define audio_vibration_amplitude .125\n\nfloat jTime;\n\n\n#ifdef disable_sound_texture_sampling\n#define textureMirror(a, b) vec4(0)\n#else\nvec4 textureMirror(sampler2D tex, vec2 c){\n    vec2 cf = fract(c);\n    return texture(tex,mix(cf,1.-cf,mod(floor(c),2.)));\n}\n#endif\n\n\nfloat amp(vec2 p){\n    return smoothstep(1.,8.,abs(p.x));   \n}\n\nfloat pow512(float value){\n    value *= value; //^2\n    value *= value; //^4\n    value *= value; //^8\n    value *= value; //^16\n    value *= value; //^32\n    value *= value; //^64\n    value *= value; //^128\n    value *= value; //^256\n    return value * value;\n}\nfloat pow1d5(float a){\n    return a*sqrt(a);\n}\nfloat hash21(vec2 co){\n    return fract(sin(dot(co.xy,vec2(1.9898,7.233)))*45758.5433);\n}\nfloat hash(vec2 uv){\n    float amplitudeResult  = amp(uv);\n    #ifdef wave_thing\n    float w = amplitudeResult >0.?(1.-.4*pow512(.51+.49*sin((.02*(uv.y+.5*uv.x)-jTime)*2.))):0.;\n    #else\n    float w=1.;\n    #endif\n    return (amplitudeResult >0.?\n        amplitudeResult *pow1d5(\n        //texture(iChannel0,uv/iChannelResolution[0].xy).r\n        hash21(uv)\n        )*w\n        :0.)-(textureMirror(iChannel0,vec2((uv.x*29.+uv.y)*.03125,1.)).x)*audio_vibration_amplitude;\n}\n\nfloat edgeMin(float dx,vec2 da, vec2 db,vec2 uv){\n    uv.x+=5.;\n    vec3 c = fract((round(vec3(uv,uv.x+uv.y)))*(vec3(0,1,2)+0.61803398875));\n    float a1 = textureMirror(iChannel0,vec2(c.y,0.)).x>.6?.15:1.;\n    float a2 = textureMirror(iChannel0,vec2(c.x,0.)).x>.6?.15:1.;\n    float a3 = textureMirror(iChannel0,vec2(c.z,0.)).x>.6?.15:1.;\n\n    return min(min((1.-dx)*db.y*a3,da.x*a2),da.y*a1);\n}\n\nvec2 trinoise(vec2 uv){\n    const float sq = sqrt(3./2.);\n    uv.x *= sq;\n    uv.y -= .5*uv.x;\n    vec2 d = fract(uv);\n    uv -= d;\n\n    bool c = dot(d,vec2(1))>1.;\n\n    vec2 dd = 1.-d;\n    vec2 da = c?dd:d,db = c?d:dd;\n    \n    float noise = hash(uv+float(c));\n    float noise2  = hash(uv+vec2(1,0));\n    float n3 = hash(uv+vec2(0,1));\n\n    \n    float nmid = mix(noise2 ,n3,d.y);\n    float ns = mix(noise,c?noise2 :n3,da.y);\n    float dx = da.x/db.y;\n    return vec2(mix(ns,nmid,dx),edgeMin(dx,da, db,uv+d));\n}\n\n\nvec2 map(vec3 p){\n    vec2 n = trinoise(p.xz);\n    return vec2(p.y-2.*n.x,n.y);\n}\n\nvec3 grad(vec3 p){\n    const vec2 e = vec2(.005,0);\n    float a =map(p).x;\n    return vec3(map(p+e.xyy).x-a\n                ,map(p+e.yxy).x-a\n                ,map(p+e.yyx).x-a)/e.x;\n}\n\nvec2 intersect(vec3 ro,vec3 rd){\n    float d =0.,h=0.;\n    for(int i = 0;i<500;i++){ //look nice with 50 iterations\n        vec3 p = ro+d*rd;\n        vec2 s = map(p);\n        h = s.x;\n        d+= h*.5;\n        if(abs(h)<.003*d)\n            return vec2(d,s.y);\n        if(d>150.|| p.y>2.) break;\n    }\n    \n    return vec2(-1);\n}\n\n\nvoid addsun(vec3 rd,vec3 ld,inout vec3 col){\n    \n\tfloat sun = smoothstep(.21,.2,distance(rd,ld));\n    \n    if(sun>0.){\n        float yd = (rd.y-ld.y);\n\n        float a =sin(3.1*exp(-(yd)*14.)); \n\n        sun*=smoothstep(-.8,0.,a);\n\n        col = mix(col,vec3(1.,.8,.4)*.75,sun);\n    }\n}\n\n\nfloat starnoise(vec3 rd){\n    float c = 0.;\n    vec3 p = normalize(rd)*300.;\n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p)-.5;\n        vec3 id = floor(p);\n        float c2 = smoothstep(.5,0.,length(q));\n        c2 *= step(hash21(id.xz/id.y),.06-i*i*0.005);\n        c += c2;\n        p = p*.6+.5*p*mat3(3./5.,0,4./5.,0,1,0,-4./5.,0,3./5.);\n    }\n    c*=c;\n    float g = dot(sin(rd*10.512),cos(rd.yzx*10.512));\n    c*=smoothstep(-3.14,-.9,g)*.5+.5*smoothstep(-.3,1.,g);\n    return c*c;\n}\n\nvec3 gsky(vec3 rd,vec3 ld,bool mask){\n    float haze = exp2(-5.*(abs(rd.y)-.2*dot(rd,ld)));\n    \n\n    //float st = mask?pow512(texture(iChannel0,(rd.xy+vec2(300.1,100)*rd.z)*10.).r)*(1.-min(haze,1.)):0.;\n    //float st = mask?pow512(hash21((rd.xy+vec2(300.1,100)*rd.z)*10.))*(1.-min(haze,1.)):0.;\n    float st = mask?(starnoise(rd))*(1.-min(haze,1.)):0.;\n    vec3 back = vec3(.4,.1,.7)*(1.-.5*textureMirror(iChannel0,vec2(.5+.05*rd.x/rd.y,0.)).x\n    *exp2(-.1*abs(length(rd.xz)/rd.y))\n    *max(sign(rd.y),0.));\n    #ifdef city\n    float x = round(rd.x*30.);\n    float h = hash21(vec2(x-166.));\n    bool building = (h*h*.125*exp2(-x*x*x*x*.0025)>rd.y);\n    if(mask && building)\n        back*=0.,haze=.8, mask=mask && !building;\n    #endif\n    vec3 col=clamp(mix(back,vec3(.7,.1,.4),haze)+st,0.,1.);\n    if(mask)addsun(rd,ld,col);\n    return col;  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    #ifdef AA\n    for(float x = 0.;x<1.;x+=1./float(AA)){\n    for(float y = 0.;y<1.;y+=1./float(AA)){\n    #else\n        const float AA=1.,x=0.,y=0.;\n    #endif\n    vec2 uv = (2.*(fragCoord+vec2(x,y))-iResolution.xy)/iResolution.y;\n    \n    const float shutter_speed = .25; // for motion blur\n\t//float dt = fract(texture(iChannel0,float(AA)*(fragCoord+vec2(x,y))/iChannelResolution[0].xy).r+iTime)*shutter_speed;\n    float dt = fract(hash21(float(AA)*(fragCoord+vec2(x,y)))+iTime)*shutter_speed;\n    jTime = mod(iTime-dt*iTimeDelta,4000.);\n    vec3 ro = vec3(0.,1,(-20000.+jTime*speed));\n    \n        #ifdef stereo\n            ro+=stereo*vec3(.2*(float(uv.x>0.)-.5),0.,0.); \n            const float de = .9;\n            uv.x=uv.x+.5*(uv.x>0.?-de:de);\n            uv*=2.;\n\t\t#endif\n        \n    vec3 rd = normalize(vec3(uv,4./3.));//vec3(uv,sqrt(1.-dot(uv,uv)));\n    \n    vec2 i = intersect(ro,rd);\n    float d = i.x;\n    \n    vec3 ld = normalize(vec3(0,.125+.05*sin(.1*jTime),1));\n\n    vec3 fog = d>0.?exp2(-d*vec3(.14,.1,.28)):vec3(0.);\n    vec3 sky = gsky(rd,ld,d<0.);\n    \n    vec3 p = ro+d*rd;\n    vec3 n = normalize(grad(p));\n    \n    float diff = dot(n,ld)+.1*n.y;\n    vec3 col = vec3(.1,.11,.18)*diff;\n    \n    vec3 rfd = reflect(rd,n); \n    vec3 rfcol = gsky(rfd,ld,true);\n    \n    col = mix(col,rfcol,.05+.95*pow(max(1.+dot(rd,n),0.),5.));\n    #ifdef VAPORWAVE\n    col = mix(col,vec3(.4,.5,1.),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    col = sqrt(col);\n    #else\n    col = mix(col,vec3(.8,.1,.92),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    //no gamma for that old cg look\n    #endif\n    if(d<0.)\n        d=1e6;\n    d=min(d,10.);\n    fragColor += vec4(clamp(col,0.,1.),d<0.?0.:.1+exp2(-d));\n     #ifdef AA\n    }\n    }\n    fragColor/=float(AA*AA);\n    #endif\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"another synthwave sunset thing\",\n\t\"description\": \"I was thinking of a way to make pseudo tesselation noise and i made this to illustrate it, i might not be the first one to come up with this solution.\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lc3XD7.jpg", "access": "api", "wgpu-test": "error"}
{"id": "lfcSDM", "name": "Fork isovalues  maxmisling 351", "author": "maxmisling", "description": "Best seen in full screen.", "tags": ["noise", "contour", "short"], "time_retrieved": "2024-05-15T23:19:27.353243", "image_code": "void mainImage( out vec4 O,  vec2 U )\n{\n\tO = texture( iChannel0, U / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --- noise from procedural pseudo-Perlin (better but not so nice derivatives) ---------\n                    // ( adapted from IQ )\n\nfloat noise3( vec3 x ) {\n    vec3 p = floor(x),f = fract(2.0*x);\n\n    f = f*f*(3.0-8.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n    \n    return mix( mix(mix( hash3(p+vec3(0,0,0)), hash3(p+vec3(1,0,0)),f.x),       // triilinear interp\n                    mix( hash3(p+vec3(0,1,0)), hash3(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash3(p+vec3(0,0,1)), hash3(p+vec3(1,0,1)),f.x),       \n                    mix( hash3(p+vec3(0,1,1)), hash3(p+vec3(1,1,1)),f.x),f.y), f.z);\n}\n\n#define noise(x) (noise3(x)+noise3(x+11.5)) / 2. // pseudoperlin improvement from foxes idea \n\n\n\nvoid mainImage( out vec4 O, vec2 U ) // ------------ draw isovalues\n{ \n    vec2 R = iResolution.xy;\n    float n = noise(vec3(U*8./R.y, .01*iTime)),\n          v = sin(6.28*12.*n),\n        t = 15.0*iTime;\n    \n    v = smoothstep(1.,0., .1*abs(v)/fwidth(v));\n    \n\tO = mix( exp(-1./R.y )* texture( iChannel0, (U+vec2(1,sin(t)))/R), // .97\n             .5+.4*sin(12.*n+vec4(0,0,0,0)),\n             v );\n \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lfcSDM.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "lXXGR7", "name": "Altered Newton's Method testing", "author": "Elyades", "description": "Altered Newton's Method", "tags": ["alterednewtonsmethod"], "time_retrieved": "2024-05-15T23:19:28.559609", "image_code": "float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\nvec3 palette1(float t)\n{\n    vec3 a = vec3(0.4,0.4,0.5);\n    vec3 b = vec3(0.2,0.2,0.5);\n    vec3 c = vec3(1.0,1.0,0.5);\n    vec3 d = vec3(0.05,0.15,0.25);\n    return( vec3( a + b*cos( TWOPI*( c*t + d ) ) ) );\n}\n\nfloat norm(vec2 uv)\n{\n    return( uv.x*uv.x + uv.y*uv.y );\n}\n\nvec2 square(vec2 uv)\n{\n    return( vec2(uv.x*uv.x - uv.y*uv.y , 2.0*uv.x*uv.y) );\n}\n\nvec2 cube(vec2 uv)\n{\n    return vec2(uv.x*uv.x*uv.x - 3.0*uv.x*uv.y*uv.y , 3.0*uv.x*uv.x*uv.y - uv.y*uv.y*uv.y);\n}\n\nvec2 quad(vec2 uv)\n{\n    float x2 = uv.x*uv.x ; float y2 = uv.y*uv.y; float xy = uv.x*uv.y;\n    return( vec2(x2*x2 - 6.0*x2*y2 + y2*y2 , 4.0*xy*(x2 - y2) ) );\n}\n\nvec2 pent(vec2 uv)\n{\n    float x2 = uv.x*uv.x; float y2 = uv.y*uv.y; float xy = uv.x*uv.y;\n    float x3 = x2*uv.x; float y3 = y2*uv.y;\n    return( vec2(x2*x3 - 10.0*x3*y2 + 5.0*y3*xy  , 5.0*xy*x3 - 10.0*x2*y3 + y2*y3 ) );\n}\n\nvec2 times(vec2 x, vec2 y)\n{\n    return( vec2(x.x*y.x - x.y*y.y , x.y*y.x + x.x*y.y) );\n}\n\nvec2 oneover(vec2 uv)\n{\n    return( vec2(uv.x , -uv.y)/norm(uv) );\n}\n\nvec2 itimes(vec2 uv)\n{\n    return( vec2(-uv.y,uv.x) );\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\nvec2 cos2d(vec2 uv)\n{\n    return ( vec2 (exp2d(itimes(uv)) + exp2d(itimes(-uv)))*0.5);\n}\n\nvec2 sin2d(vec2 uv)\n{\n    return ( vec2 (-itimes((exp2d(itimes(uv)) - exp2d(itimes(-uv)))*0.5)));\n}\n\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan(uv.y,uv.x)));\n}\n\n\nvec2 f(vec2 uv, vec2 c)\n{\n    //vec2 m = vec2(1.0,0.0) + (iMouse.xy/iResolution.xy - 0.5)*6.0;\n    //return( cube(uv) + times(c,uv) - vec2(0.5));\n    return( cube(uv) + times(c,uv) - vec2(0.5));\n}\n\nvec2 fprime(vec2 uv, vec2 c)\n{\n    return( 2.0*square(uv) + c );\n}\n\nvec2 NewtonIteration(vec2 uv, vec2 c, vec2 a)\n{\n    return(uv - times(a, times(f(uv,c) , oneover(fprime(uv,c)) ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5)*10.0;\n    uv.y *= iResolution.y/iResolution.x;\n    float zoom = pow(10.0,-iTime/5.0); uv *= zoom;\n    vec2 m = vec2(1.0,0.0) + (iMouse.xy/iResolution.xy - 0.5)*3.0;\n    vec2 zoomPoint = vec2(0); uv += zoomPoint;\n    vec2 dummyuv = uv; vec2 previousuv = vec2(10000.0,-2451.0); float distanceToPrevious;\n    float maxIteration = 1000.0; int i = 0; float tolerance = pow(10.0,-8.0);\n    \n    int hasStopped = 0; //0 means not enough iter. 1 means converged. 2 means stuck without converging\n    float dist;\n    vec2 c; c = dummyuv; \n    uv = vec2(0.0);\n    //c = m; \n    for (i = 0; i < int(maxIteration); i++)\n    {\n        dist = norm(f(uv,c));\n        distanceToPrevious = norm( uv - previousuv );\n        if( dist < tolerance){hasStopped = 1; break;}\n        else if( distanceToPrevious < tolerance ){hasStopped = 2; break;}\n        previousuv = uv;\n        uv = NewtonIteration(uv, c, vec2(1.0,0.0));\n    }\n    \n    vec3 finalColor;\n    \n    if (hasStopped == 1)//converged\n    {\n        float index = 2.0*log(float(i) + 1.0);\n        finalColor = palette1(index);\n    }\n    else if(hasStopped == 2)//stuck\n    { finalColor = vec3(0.0,0.2265,1.0);}\n    \n    else//not enough iter\n    { finalColor = vec3(0.0,0.0,0.0);}\n  \n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lXXGR7.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4c3SW7", "name": "Columnular", "author": "dr2", "description": "Traversing columnular structures (flat-topped wats?)", "tags": ["architecture"], "time_retrieved": "2024-05-15T23:19:28.610575", "image_code": "#define Jc min(Pz,0)\n#define Qy(Of)if(Ez<ON){ON=Ez;PQ=Of;Zw=XL;}\nvec3 BP,Zw,NK,VW,Ko,SE;vec2 Df,Im;float MP,VF,KJ,RW,My,Wn,Zs,LI,Nt,Av;int Pz,PQ;const float Nx=3.1415927,CB=1.7320508;float Up(vec3 EU,vec3 QC){vec3 Ez;Ez=abs(EU)-QC;return min(max(Ez.x,max(Ez.y,Ez.z)),0.)+length(max(Ez,0.));}float Wa(vec3 EU,float CS,float Cg){return max(length(EU.xy)-CS,abs(EU.z)-Cg);}vec2 Pi(vec2 EU){vec3 LZ,JK,TU;LZ.xz=vec2((1./CB)*EU.x-(1./3.)*EU.y,(2./3.)*EU.y);LZ.y=-LZ.x-LZ.z;JK=floor(LZ+0.5);TU=abs(JK-LZ);JK-=step(TU.yzx,TU)*step(TU.zxy,TU)*dot(JK,vec3(1.));return JK.xz;}vec2 IY(vec2 Cg){return vec2(CB*(Cg.x+0.5*Cg.y),(3./2.)*Cg.y);}float Hn(vec2 EU){EU=abs(EU);return(CB/2.)-EU.x+0.5*min(EU.x-CB*EU.y,0.);}float HI(float Le){return(Le!=0.)?sign(Le):1.;}float GW(vec2 EU){return min(EU.x,EU.y);}float DA(vec2 EU){return max(EU.x,EU.y);}float IH(vec3 EU){return min(EU.x,min(EU.y,EU.z));}float Fl(vec3 EU){return max(EU.x,max(EU.y,EU.z));}float AQ(float Yt,float Mu,float Tq,float Yx){return(1.-smoothstep(Mu-Tq,Mu+Tq,Yx))*smoothstep(Yt-Tq,Yt+Tq,Yx);}mat3 Jt(float FT,float ID){vec2 Dj,Pv,Sn;Dj=vec2(FT,ID);Pv=cos(Dj);Sn=sin(Dj);return mat3(Pv.y,0.,-Sn.y,0.,1.,0.,Sn.y,0.,Pv.y)*mat3(1.,0.,0.,0.,Pv.x,-Sn.x,0.,Sn.x,Pv.x);}vec2 OR(vec2 XL,float BL){vec2 Ul;Ul=sin(BL+vec2(0.5*Nx,0.));return vec2(dot(XL,vec2(Ul.x,-Ul.y)),dot(XL.yx,Ul));}vec2 Ng(vec2 XL,vec2 Ul){return vec2(dot(XL,vec2(Ul.x,-Ul.y)),dot(XL.yx,Ul));}const float XY=43758.54;float DR(vec2 EU){return fract(sin(mod(dot(EU,vec2(37.,39.)),2.*Nx))*XY);}vec2 FC(vec2 EU){vec2 ZJ=vec2(37.,39.);return fract(sin(mod(dot(EU,ZJ)+vec2(0.,ZJ.x),2.*Nx))*XY);}float Rk(vec2 EU){vec2 Le,Tm,Qh;Tm=floor(EU);Qh=fract(EU);Qh=Qh*Qh*(3.-2.*Qh);Le=mix(FC(Tm),FC(Tm+vec2(0.,1.)),Qh.y);return mix(Le.x,Le.y,Qh.x);}float ML(vec2 EU){float La,BL;La=0.;BL=1.;for(int UX=0;UX<5;UX++){La+=BL*Rk(EU);BL*=0.5;EU*=2.;}return La*(1./1.9375);}float Ow(vec3 EU,vec3 Md){vec3 QC;float BL;QC=vec3(0.);BL=1.;for(int UX=0;UX<5;UX++){QC+=BL*vec3(Rk(EU.yz),Rk(EU.zx),Rk(EU.xy));BL*=0.5;EU*=2.;}return dot(QC,abs(Md));}vec3 Hr(vec3 EU,vec3 Md,float La){vec4 FG;vec3 Cg;vec2 Ei=vec2(0.1,0.);for(int UX=Jc;UX<4;UX++)FG[UX]=Ow(EU+((UX<2)?((UX==0)?Ei.xyy:Ei.yxy):((UX==2)?Ei.yyx:Ei.yyy)),Md);Cg=FG.xyz-FG.w;return normalize(Md+La*(Cg-Md*dot(Md,Cg)));}float Lr(vec2 EU){return dot(EU,EU);}vec3 Vs(vec2 EU){vec2 Iq,Kb,LM,Sj;float Ez,Gk,HV,Bd,CS,Fh,QC,FX;bool XH;XH=(Zs==2.||Zs==4.);if(XH){Kb=-vec2(0.,Wn);LM=vec2(CB/2.*HI(EU.x),0.5*Wn);Gk=Lr(EU-Kb);HV=Lr(EU-LM);Ez=min(Gk,HV);Iq=(Ez==Gk)?Kb:LM;CS=0.5;Ez=abs(sqrt(Ez)-CS);}else{if(Wn!=0.)EU=0.5*vec2(EU.x-Wn*CB*EU.y,Wn*CB*EU.x+EU.y);Kb=vec2(CB/2.*HI(EU.x),0.);LM=vec2(CB*HI(EU.x),0.);Gk=sqrt(Lr(EU-Kb));HV=abs(sqrt(Lr(EU-LM))-1.5);Ez=min(Gk,HV);Iq=(Ez==Gk)?Kb:LM;CS=(Ez==Gk)?0.:1.5;}Sj=EU-Iq;Bd=Df.x-Df.y;QC=(XH&&Bd<0.||!XH&&abs(Bd-2.)==1.)?-1.:1.;Fh=(0.5-atan(Sj.y,-Sj.x)/(2.*Nx))*QC;if(!XH&&abs(Bd-2.)<=1.)Fh+=1./6.;FX=HI(length(Sj)-CS);return vec3(Ez*FX,CS*FX*QC,Fh);}bool By(vec2 w){vec2 WM,Vb;float Bd;bool CO,Yc;Bd=Df.x-Df.y;CO=(mod(Df.y,2.)==1.);Vb=Ng(w,sin(-Nx/3.+vec2(0.5*Nx,0.)))-vec2(0.,0.3);WM=Ng(w,sin(Nx/3.+vec2(0.5*Nx,0.)));Yc=(Bd==-2.&&Vb.y>0.||!CO&&(Bd==-3.&&w.y>-0.3||Bd==-2.||Bd==-1.&&Vb.y>0.||Bd==1.&&Vb.y<0.||(Bd==2.||Bd==3.)&&w.x<0.||Bd==4.||Bd==5.)||CO&&(Bd==-3.||Bd==0.&&WM.x>0.||(Bd==1.||Bd==2.)&&w.x>0.||Bd==3.||Bd==4.&&Vb.x<0.||Bd==5.&&Vb.y<0.));return!Yc;}vec4 GF(int WI){vec4 Az;float Xd,Ql;Xd=1.;Ql=1.5;if(WI<8){if(WI<4){if(WI<2)Az=(WI==0)?vec4(0.,0.,-1./6.,Ql):vec4(1.,0.,1./3.,-Xd);else Az=(WI==2)?vec4(0.,1.,5./6.,Ql):vec4(-1.,1.,-1./3.,Xd);}else{if(WI<6)Az=(WI==4)?vec4(-1.,2.,1.,Xd):vec4(0.,1.,-1./6.,Ql);else Az=(WI==6)?vec4(1.,1.,1./6.,Ql):vec4(1.,2.,1.,Xd);}}else if(WI<16){if(WI<12){if(WI<10)Az=(WI==8)?vec4(2.,1.,1./2.,-Ql):vec4(2.,0.,-1./2.,Ql);else Az=(WI==10)?vec4(3.,-1.,-1./6.,Ql):vec4(4.,-1.,1./3.,-Xd);}else{if(WI<14)Az=(WI==12)?vec4(3.,0.,-1./2.,-Ql):vec4(3.,1.,1./2.,Ql);else Az=(WI==14)?vec4(2.,2.,5./6.,Ql):vec4(1.,2.,-1./3.,Xd);;}}else Az=vec4(1.,3.,1.,Xd);return Az;}vec2 Jp(float Le){const int QT=17;vec4 SA;vec2 TH,KN;float OA[QT+1],YO,CS,BL,JG;OA[0]=0.;for(int WI=Jc;WI<QT;WI++)OA[WI+1]=OA[WI]+abs(GF(WI).w);RW=OA[QT];Le/=3.;TH=floor(Le/RW)*vec2(2.);Le=mod(Le,RW);for(int WI=Jc;WI<QT;WI++){if(Le>=OA[WI]&&Le<OA[WI+1]){SA=GF(WI);YO=2.*(Le-OA[WI])/(OA[WI+1]-OA[WI])-1.;break;}}TH+=SA.xy;if(abs(SA.w)==1.5){CS=1.5;JG=CB;BL=Nx/6.;YO*=HI(SA.w);}else{CS=0.5;JG=1.;BL=-HI(SA.w)*Nx/3.;}KN=vec2(-1.,1.)*sin(Nx*SA.z+vec2(0.,0.5*Nx));return(IY(TH)+JG*KN-CS*Ng(KN,sin(YO*BL+vec2(0.5*Nx,0.))))*KJ;}void VJ(){float Cg,Bd;Im=IY(Df*KJ);Cg=DR(Df);if(DR(17.11*Df)>0.4){Wn=floor(3.*Cg)-1.;Zs=3.;}else{Wn=2.*floor(2.*Cg)-1.;Zs=4.;}Bd=Df.x-Df.y;if(Bd==0.)Zs=1.;else if(abs(Bd)==1.)Zs=mod(Df.x,2.)+1.;else if(Bd==-2.||Bd==-3.||Bd==5.)Zs=2.;else if(Bd==2.||Bd==3.||Bd==4.)Zs=1.;if(Zs<=2.){if(Zs==1.&&(Bd==1.||Bd==2.||Bd==3.))Wn=0.;else if(Zs==1.&&Bd==4.)Wn=-1.;else if(Zs==2.&&Bd==5.)Wn=1.;else Wn=2.*mod(Df.x,2.)-1.;}}\nvoid SR(){float Bu;Bu=min(floor(0.5+6.*DR(NK.xz+99.9)),4.);if(Bu==0.)LI=0.;else LI=(NK.y>=0.&&NK.y<=Bu)?2.:0.;if(LI!=0.){if(NK.y==0.)LI=1.;else if(NK.y==Bu)LI=-1.;}}void UC(vec2 JK){vec3 GB;vec2 QC;float Cx;VJ();GB=Vs((JK-Im)/KJ);Cx=KJ*abs(GB.x);QC=(JK-Im)/KJ;Nt=(Zs>2.||GB.y==0.||!By(QC)||Cx>1.2)?1.:0.;}float Vo(vec3 EU){vec3 XL;float ON,Ez;ON=VF;if(LI*Nt!=0.){EU-=VW*(NK+0.5);XL=EU;Ez=Up(XL,Ko);Qy(1);XL.xz=abs(XL.xz)-0.5*Ko.xz;Ez=length(XL.xz)-0.07;Ez=min(Ez,Wa(XL.xzy,0.09,0.14));if(abs(LI)==1.)Ez=max(Ez,-LI*XL.y);Qy(2);}return ON;}float YK(vec3 Lv,vec3 ED){vec3 EU,Go;vec2 JK,EQ;float Nc,Ez,QC,TY,HE;bool JX;if(ED.x==0.)ED.x=1e-4;if(ED.y==0.)ED.y=1e-4;if(ED.z==0.)ED.z=1e-4;Go=1./ED;HE=1e-3;JX=true;Nc=HE;for(int UX=Jc;UX<220;UX++){EU=Lv+Nc*ED;if(JX){NK=floor(EU/VW);SR();TY=IH((VW*(NK+step(0.,ED))-Lv)*Go);}JK=floor(NK.xz*VW.xz+0.5);EQ=Pi(JK/KJ);if(JX||Df!=EQ){Df=EQ;UC(JK);}JX=false;Ez=Vo(EU);QC=max(Nc,TY);if(Nc+Ez<QC){Nc+=Ez;}else{Nc=QC+HE;JX=true;}if(Ez<HE||Nc>VF)break;}if(Ez>=HE)Nc=VF;return Nc;}vec3 WZ(vec3 EU){vec4 FG;vec2 Ei;Ei=1e-3*vec2(1.,-1.);for(int UX=Jc;UX<4;UX++){FG[UX]=Vo(EU+((UX<2)?((UX==0)?Ei.xxx:Ei.xyy):((UX==2)?Ei.yxy:Ei.yyx)));}FG.x=-FG.x;return normalize(2.*FG.yzw-dot(FG,vec4(1.)));}float SV(vec3 EU){vec3 XL;float ON,Ez;ON=VF;XL=EU-vec3(SE.xz,Av+5.).xzy;Ez=Wa(XL.xzy,0.5,5.);Qy(3);return ON;}float Wr(vec3 Lv,vec3 ED){float Nc,Ez;Nc=0.;for(int UX=Jc;UX<120;UX++){Ez=SV(Lv+Nc*ED);if(Ez<0.0005||Nc>VF)break;Nc+=Ez;}return Nc;}vec3 UG(vec3 EU){vec4 FG;vec2 Ei;Ei=1e-3*vec2(1.,-1.);for(int UX=Jc;UX<4;UX++){FG[UX]=SV(EU+((UX<2)?((UX==0)?Ei.xxx:Ei.xyy):((UX==2)?Ei.yxy:Ei.yyx)));}FG.x=-FG.x;return normalize(2.*FG.yzw-dot(FG,vec4(1.)));}vec3 Zf(vec3 ED){ED.y=abs(ED.y);return mix(vec3(0.3,0.35,0.7),vec3(0.8,0.8,0.8),clamp(2.*(ML(4.*ED.xz/ED.y+0.1*MP)-0.1)*ED.y,0.,1.));}vec3 Xu(vec3 Lv,vec3 ED){vec4 QP;vec3 Pe,PU,GB,Bh,Az;vec2 QC,Oj;float AM,Zb,Xq,HZ,Cx,BL;int RB;HZ=1.;Oj=vec2(0.);for(int WI=0;WI<2;WI++){Xq=(ED.y<0.)?(-(Lv.y-Av)/ED.y):VF;AM=YK(Lv+vec3(0.5*VW.xz,0.).xzy,ED);RB=PQ;Bh=Zw;Zb=Wr(Lv,ED);if(WI==0&&Zb<min(min(AM,Xq),VF)&&abs(Zw.y)<4.9){Lv+=Zb*ED;PU=UG(Lv);ED=reflect(ED,PU);Lv+=0.01*ED;HZ=0.9;}else break;}if(min(Xq,min(Zb,AM))<VF){if(Xq<min(Zb,AM)){Zb=Xq;Lv+=Zb*ED;PU=vec3(0.,1.,0.);Df=Pi(Lv.xz/KJ);VJ();QP=vec4(0.1,0.5,0.1,0.);Oj=vec2(8.,2.);QC=(Lv.xz-Im)/KJ;GB=Vs(QC);if(Zs<=2.&&GB.y!=0.&&By(QC)){Cx=KJ*abs(GB.x)-0.5;if(Cx<0.02){QP=mix(vec4(0.4,0.3,0.2,0.),QP,smoothstep(-0.02,0.02,Cx));Oj=vec2(32.,0.5);}}}else if(AM<Zb){Zb=AM;PQ=RB;Zw=Bh;Lv+=Zb*ED+vec3(0.5*VW.xz,0.).xzy;PU=WZ(Lv);if(PQ==1){QP=vec4(0.6,0.6,0.6,0.1);if((LI==2.||abs(LI)==1.&&LI*Zw.y>0.)&&length(abs(Zw.xz)-0.5*Ko.xz)<0.11)QP*=0.8;Az=abs(Zw)-Ko;if(IH(vec3(length(Az.xz),length(Az.xy),length(Az.yz)))<0.02)QP*=0.8;Oj=vec2(4.,1.);}else if(PQ==2){QP=vec4(0.6,0.4,0.3,0.1);if(abs(Zw.y)>0.2)QP*=0.7+0.3*step(0.03,abs(fract(8.*Zw.y+0.5)-0.5));if(abs(PU.y)<0.1){BL=fract(16.*(atan(Zw.z,-Zw.x)/(2.*Nx)+0.5));PU.xz=OR(PU.xz,-0.15*Nx*sin(Nx*BL*BL));}Oj=vec2(8.,0.5);}}else{Lv+=Zb*ED;PU=UG(Lv);if(PQ==3)QP=vec4(0.7,0.6,0.4,0.1);}if(Oj.y>0.)PU=Hr(Oj.x*Lv,PU,Oj.y);Pe=QP.rgb*(0.2+0.8*max(dot(PU,BP),0.))+QP.a*pow(max(dot(BP,reflect(ED,PU)),0.),32.);Pe=mix(vec3(0.3,0.35,0.7),Pe,min(1.,exp2(2.-8.*Zb/VF)));}else{Pe=Zf(ED);}Pe*=HZ;return clamp(Pe,0.,1.);}void mainImage(out vec4 RS,in vec2 TD){mat3 RF;vec4 Ks;vec3 Lv,ED,Pe,KN;vec2 Rg,Ck,DV;float FT,ID,Ai,GS,Em;\nPz=iFrame;Rg=iResolution.xy;Ck=2.*TD.xy/Rg-1.;Ck.x*=Rg.x/Rg.y;MP=iTime;Ks=iMouse;Ks.xy=Ks.xy/Rg-0.5;\nGS=Rg.x/Rg.y;VW=vec3(1.,2.,1.);Ko=vec3(0.5*VW.xz-0.005,0.1).xzy;Av=0.5*VW.y-0.1;KJ=8.;My=2.;Lv.xz=Jp(0.5*MP*My+0.1);Lv.y=0.5*VW.y+1.+8.*AQ(0.25,0.75,0.2,fract(0.02*MP));SE.xz=Jp(0.5*MP*My+3.);SE.y=2.+0.6*Lv.y;KN=normalize(SE-Lv);ID=atan(KN.z,-KN.x)-0.5*Nx;FT=asin(KN.y);if(Ks.z>0.){ID+=2.*Nx*Ks.x;FT+=Nx*Ks.y;}RF=Jt(FT,ID);Ai=2.;VF=120.;BP=RF*normalize(vec3(1.,1.,-1.));const float NO=3.;Pe=vec3(0.);Em=2.*mod(dot(mod(floor(0.5*(Ck+1.)*Rg),2.),vec2(1.)),2.)-1.;for(float BL=float(Jc);BL<NO;BL++){DV=(Ck+step(1.5,NO)*OR(vec2(0.5/Rg.y,0.),Em*(0.667*BL+0.5)*Nx))/Ai;ED=RF*normalize(vec3(2.*tan(0.5*atan(DV.x/GS))*GS,DV.y,1.));Pe+=(1./NO)*Xu(Lv,ED);}RS=vec4(Pe,1.);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4c3SW7.jpg", "access": "api", "wgpu-test": "error"}
{"id": "4ccXWM", "name": "3D Moire", "author": "JuliaPoo", "description": "moire inspired by https://shadertoy.com/view/lc3SWN", "tags": ["moire"], "time_retrieved": "2024-05-15T23:19:30.085263", "image_code": "// Fork of \"Shape Designing Sandbox\" by JuliaPoo. https://shadertoy.com/view/3sXyzf\n// 2024-04-24 14:34:33\n\n// ###############################\n// ### STRUCTS and other stuff ###\n// ###############################\n\n\n#define END 50.\n\nstruct CAM {\n    vec3 lookat;\n    vec3 ro;\n\n    vec3 forw;\n    vec3 up;\n    vec3 right;\n    \n    float field;\n};\n    \nstruct RAY {\n\tvec3 ro;       \n    vec3 rd;\n};\n    \nmat2 rot(float a)\n{\n    float c0 = cos(a);\n    float s0 = sin(a);\n    return mat2(\n        c0,-s0,\n        s0, c0\n    );\n}\n\n// #############\n// ### SCENE ###\n// #############\n\n// --- Useful Funcs ---\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat ssub( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sint( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat onion( in float d, in float h )\n{\n    return abs(d)-h;\n}\n\n// --- PRIMITIVES ---    \n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// --- SCENE ---\n\nfloat sdScene(vec3 P)\n{\n    float d;\n    P.xy *= rot(iTime * .1 - 3.8);\n    P.yz *= rot(iTime * .21 + 5.6);\n    #define PERIOD_LINES 10.\n    #define PERIOD_CIRCLES 70.\n    #define THICK_LINES .4\n    \n    float modp1 = length(mod(P.xy*PERIOD_LINES, 1.) - .5) - THICK_LINES;\n    float modp2 = length(mod(P.yz*PERIOD_LINES, 1.) - .5) - THICK_LINES;\n    float modp3 = length(mod(P.zx*PERIOD_LINES, 1.) - .5) - THICK_LINES;\n    \n    float circles = mod(sqrt(length(P))*PERIOD_CIRCLES, 1.) - .05; \n    \n    d = min(min(modp1, modp2), modp3);\n    d = max(-d, circles);\n    d = max(d, sdBox(P, vec3(3.5)));\n    \n    return d*.05;\n}\n\n// #################\n// ### RENDERING ###\n// #################\n\n// --- Camera ---\n\nvoid InitCamera(inout CAM c)\n{\n    vec2 M = (iMouse.xy/iResolution.xy - 0.5) * 3.14;\n    \n    // x,y,z = right, up, forw\n    c.lookat = vec3(0);\n    \n    c.ro = vec3(0., 0., -10.);\n    c.ro.zy *= rot(M.y);\n    c.ro.xz *= rot(M.x);\n    \n    c.forw = normalize(c.lookat - c.ro);\n    c.right = normalize(cross(c.forw, vec3(0.0, 1.0, 0.0)));\n    c.up = normalize(cross(c.right, c.forw));\n    c.field = 2.;\n}\n\nvoid InitRay(inout RAY r, CAM c, vec2 uv)\n{\n    r.rd = normalize(uv.x*c.right + uv.y*c.up + c.field*c.forw);\n    r.ro = c.ro;\n}\n\n// --- Raytracing ---\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(sdScene(p + e.xyy)-sdScene(p - e.xyy), \n                          sdScene(p + e.yxy)-sdScene(p - e.yxy),\t\n                          sdScene(p + e.yyx)-sdScene(p - e.yyx)));\n}\n\nfloat Intersect(RAY r)\n{\n    float t = 0.01;\n    for( int i=0; i<512; i++ )\n    {\n        float c = sdScene(r.ro + r.rd*t);\n        if( c < 0.005 ) break;\n        t += c;\n        if( t>END ) return END;\n    }\n    return t;\n}\n\n// -- Shading --\n\nvec3 Render(vec2 uv)\n{\n    CAM camera;\n    RAY ray;\n    \n    InitCamera(camera);\n    InitRay(ray, camera, uv);\n    \n    float d = Intersect(ray);\n    vec3 p = d*ray.rd + ray.ro;\n    \n    vec3 n;\n    if (d < END) n = get_normal(p);\n    \n    return n;\n}\n\n// #######################\n// ### POST PROCESSING ###\n// #######################\n\nvoid PostProcessing(){}\n\n// ############\n// ### MAIN ###\n// ############\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + 2.0 * uv;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = Render(uv);\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ccXWM.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "ddVSRz", "name": "2D Simplex", "author": "polaroid", "description": "Shaders to draw a 2D simplex", "tags": ["simplex"], "time_retrieved": "2024-05-15T23:19:30.122585", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    /*\n    Linear Equation to define the simplex\n    2u + 3v <= 2.5\n    u <= 0.75\n    v <= 0.75\n    u >= 0\n    v >= 0\n    */\n    \n    \n    // Output to screen\n    float u = uv.x ;\n    float v = uv.y ;\n    float l1 = 2.*u + 3.*v ;\n    float l2 = u ;\n    float l3 = v ;\n    float l4 = u ;\n    float l5 = v ;\n    \n    bool b = \n        l1 <= 2.5 &&\n        l2 <= 0.75 &&\n        l3 <= 0.75 &&\n        l4 >= 0. &&\n        l5 >= 0.; \n    \n    fragColor = vec4(0,0,0, 1.0);\n    if (b) {\n        fragColor = vec4(255, 255, 255,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ddVSRz.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "McG3DK", "name": "Magnifying glass on a grid", "author": "NickSpyker", "description": "A circle with a convex visual effect on a grid; move the grid with the mouse by clicking.", "tags": ["grid", "distortion", "circle"], "time_retrieved": "2024-05-15T23:19:30.157678", "image_code": "float sinc(float x)\n{\n    float a = 3.14159 * (100.0 * x - 1.0);\n    return sin(a) / a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv    = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n \n    float p = length(uv);\n    float r = p - 0.6;\n    \n    vec3 color = sinc(p * uv.x - mouse.x)\n               + sinc(p * uv.y - mouse.y)\n               - 200.0 * r / (1.0 + 10000.0 * r * r)\n               * vec3(0.8, 1.0, 0.9);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McG3DK.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "XftSW4", "name": "Marble Focal Point", "author": "isaacchurchill", "description": "I like the pattern of polar rectangles orbiting, sort of sci fi looking. Here it looks retro", "tags": ["2d", "circles", "colorful", "marble", "arc", "sector"], "time_retrieved": "2024-05-15T23:19:30.187644", "image_code": "#define PI 3.14159265\n\n\nvec3 palette(float i)\n{\n    return 0.5 + 0.5 * cos(i + vec3(0.0, 2.0 * PI / 3.0, 4.0 * PI / 3.0));\n}\n\nfloat sector(float r, float theta, float r1, float r2, float theta1, float theta2, float aa_dist)\n{\n    r = max(r, 0.001);\n    theta1 = mod(theta1 + PI, PI * 2.0) - PI;\n    theta2 = mod(theta2 + PI, PI * 2.0) - PI;\n    bool reverse = theta1 > theta2;\n    if (reverse) {\n        float temp = theta1;\n        theta1 = theta2;\n        theta2 = temp;\n    }\n    float r_grad = smoothstep(r1 - aa_dist, r1, r)\n                 * smoothstep(-r2 - aa_dist, -r2, -r);\n    float theta_grad = smoothstep(theta1 - aa_dist / r, theta1, theta)\n                     * smoothstep(-theta2 - aa_dist / r, -theta2, -theta);\n    if (reverse) {\n        theta_grad = 1.0 - theta_grad;\n    }\n    return r_grad * theta_grad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n    float aa_dist = 4.0 / iResolution.y;\n\n    float theta = atan(uv.y, uv.x);\n    float r = length(uv);\n    \n    vec3 col = vec3(smoothstep(-1.0, 0.0, -r)) * 0.3 * (1.4 + sin(iTime));\n    for (float i = 0.0; i < 15.0; i++) {\n        float r1 = i * 0.15 + 0.1;\n        float r2 = r1 + 0.05;\n        float theta1 = iTime * (cos(i) + 0.1) * 3.0;\n        float theta2 = theta1 + i * 0.5 + 2.5;\n        float intensity = sector(r, theta, r1, r2, theta1, theta2, aa_dist);\n        vec3 hue = palette(i);\n        col = mix(col, hue * intensity, intensity);\n    }\n    \n    r *= 15.0;\n    if (r < 1.0) {\n        float inner_grad = 1.0 - r * r;\n        col = vec3(inner_grad);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XftSW4.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "lfcXWN", "name": "BowlingBallUgly", "author": "Ravenfight", "description": "scrolling bowling noise\nmade with chatGPT", "tags": ["noise"], "time_retrieved": "2024-05-15T23:19:30.219446", "image_code": "// Permutation table\nvec3 permute(vec3 x) {\n    return mod((x * 34.0 + 1.0) * x, 289.0);\n}\n\n// Simplex 2D noise function\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n                             dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// Swirly noise function\nfloat swirlyNoise(vec2 p) {\n    return snoise(p * 3.5 + vec2(0.0, iTime * 0.5));\n}\n\n// Weighted color function\nvec3 weightedColor(float intensity, vec3 baseColor, vec3 blackColor) {\n    return mix(blackColor, baseColor, intensity);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // Normalize coordinates\n\n    // Rotate UV coordinates by 90 degrees\n    uv = vec2(uv.y, uv.x);\n\n    // Create waves using sine function\n    float wave = sin(uv.x * 20.0 + iTime * 2.0) * 0.01;\n\n    // Add swirly noise\n    float noise = swirlyNoise(uv * 4.0);\n\n    // Calculate distance from center\n    vec2 center = vec2(0.5, 0.5);\n    float dist = length(uv - center);\n\n    // Create black and white stripes based on distance from center\n    float stripe = smoothstep(0.01 + wave, 0.99 + wave, dist);\n\n    // Combine stripe with noise\n    stripe += noise * 0.2;\n\n    // Clamp stripe to range [0, 1]\n    stripe = clamp(stripe, 0.0, 1.0);\n\n    // Map stripe value to color gradient\n    vec3 baseColor = vec3(0.2, 0.8, 0.2); // Example color (reddish)\n    vec3 blackColor = vec3(.1,.1,.4); // Customizable black color\n\n    // Weight the color based on intensity\n    vec3 finalColor = weightedColor(stripe, baseColor, blackColor);\n\n    // Output color\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lfcXWN.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Mc3XWN", "name": "It's glowing", "author": "SONENEIS", "description": "a nice effect", "tags": ["3d", "raymarching", "light", "sphere", "effect", "glow", "neon"], "time_retrieved": "2024-05-15T23:19:30.263873", "image_code": "#define sat(x) clamp(x,0.0,1.0)\n\nmat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0.0);\n\n\tvec3 ro = vec3(0,1,3);\n\tvec3 rd = normalize(vec3(uv,-1.5));\n    //orbit camera\n    rd.yz *= rot(-0.25);\n\tro.xz *= rot(iTime * 0.5);\n\trd.xz *= rot(iTime * 0.5);\n\t\n    //color\n    float k = 0.5+0.5*sin(iTime);\n\tvec3 ec = normalize(mix(mix(vec3(1,0.1,0.4),vec3(0.7,0.1,1),k*2.0),vec3(0.1,1,0.8),k));\n\t\n    float t = 0.0;\n\tvec3 ol = vec3(0.0); //outline\n\tfor(int i=0;i<256;i++){\n\t\tvec3 p = ro + rd * t;\n\t\tfloat h = 999999.999;\n        \n        //sdf scene\n        h = min(h,length(p)-0.5);\n\t\th = min(h,length(p-0.5)-0.4);\n\t\th = max(h,-(length(p-vec3(0,0.8,0))-0.9));\n\t\th = min(h,length(p-0.5)-0.2);\n\t\th = min(h,length(p+0.5)-0.2);\n\t\t\n        ol += (ec*0.5+0.5)*0.01;\n\t\tif(t > 100.0) break;\n\t\tif(h < 0.0002){ol = vec3(1); break;}\n\t\tt += h;\n\t}\n    \n    //result\n\tcol += ec*sat(pow(ol*4.5,vec3(4.0)));\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mc3XWN.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Mf3XW4", "name": "Learning about Truchets", "author": "NotJacob42", "description": "yup", "tags": ["learning"], "time_retrieved": "2024-05-15T23:19:30.656561", "image_code": "// Solution to Martijn's problem\n// Based on this video:\n// https://youtu.be/2R7h76GoIJM\n\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(234.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 UV = fragCoord.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    uv += iTime*.05;\n    uv *= 5.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id); // random number between 0 and 1\n    \n    float width = .1;\n    \n    if(n<.5) gv.x *= -1.;\n    float d = abs(abs(gv.x+gv.y)-.5);\n    vec2 cUv = gv-sign(gv.x+gv.y+.001)*.5;\n    d = length(cUv);\n    float mask = smoothstep(.01, -.01, abs(d-.5)-width);\n\tfloat angle = atan(cUv.x, cUv.y); // -pi to pi\n    float checker = mod(id.x+id.y, 2.)*2.-1.;\n    float flow = sin(iTime+checker*angle*10.);\n    \n    float x = (checker*angle/1.57-iTime*.3);\n    float y = (d-(.5-width))/(2.*width);\n    //Here the thing\n    if(n<.5 ^^ checker>0.) y=1.-y;\n    col += y*mask;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mf3XW4.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "lcdXDH", "name": "Fork Plasma Glo SwagLordLa 197", "author": "SwagLordLancalot", "description": "My first attempt at recreating a real world object.  I tried making the sphere glow based on ray position but it didn't look better and was much more expensive.\n\nMouse drag to rotate.", "tags": ["3d", "raymarching", "rays", "plasma", "volumetric"], "time_retrieved": "2024-05-15T23:19:32.309755", "image_code": "// Plasma Globe by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsjXRm\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//looks best with around 25 rays\n#define NUM_RAYS 25.\n\n#define VOLUMETRIC_STEPS 29\n\n#define MAX_ITER 25\n#define FAR 5.\n\n#define time iTime*2.1\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat noise( in float x ){return textureLod(iChannel0, vec2(x*.01,1.),0.0).x;}\nfloat globe( in float y ){return textureLod(iChannel1, vec2(y*.02,2.),0.0).y;}\n\nfloat hash( float n ){return fract(sin(n)*43758.5453);}\n\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\t\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rg     = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\n    vec2 globe = textureLod( iChannel1, (tap + 0.7)/256.0, 0.0 ).yx;\n\treturn mix(rg.x, rg.y, fp.z);\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n\n//See: https://www.shadertoy.com/view/XdfXRj\nfloat flow(in vec3 p, in float t)\n{\n\tfloat z=sin(time*3.)*2.;\n\tfloat rz = 0.;\n\tvec3 bp = p;\n\tfor (float i= 1.;i < 5.;i++ )\n\t{\n\t\tp += time*.1;\n\t\trz+= (sin(noise(p+t*0.8)*6.)*0.5+0.5) /z;\n\t\tp = mix(bp,p,0.6);\n\t\tz *= 2.;\n\t\tp *= 2.01;\n        p*= m3;\n\t}\n\treturn rz;\t\n}\n\n//could be improved\nfloat sins(in float x)\n{\n \tfloat rz = 0.;\n    float z = 2.;\n    for (float i= 0.;i < 3.;i++ )\n\t{\n        rz += abs(fract(x*1.4)-0.5)/z;\n        x *= 1.3;\n        z *= 1.15;\n        x -= time*.65*z;\n    }\n    return rz;\n}\n\nfloat segm( vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );\t\n\treturn length( pa - ba*h )*.5;\n}\n\nvec3 path(in float i, in float d)\n{\n    vec3 en = vec3(0.,0.,1.);\n    float sns2 = sins(d+i*0.5)*0.22;\n    float sns = sins(d+i*.6)*0.21;\n    en.xz *= mm2((hash(i*10.569)-.5)*6.2+sns2);\n    en.xy *= mm2((hash(i*4.732)-.5)*6.2+sns);\n    return en;\n}\n\nvec2 map(vec3 p, float i)\n{\n\tfloat lp = length(p);\n    vec3 bg = vec3(0.);   \n    vec3 en = path(i,lp);\n    \n    float ins = smoothstep(0.11,.46,lp);\n    float outs = .15+smoothstep(.0,.15,abs(lp-1.));\n    p *= ins*outs;\n    float id = ins*outs;\n    \n    float rz = segm(p, bg, en)-0.011;\n    return vec2(rz,id);\n}\n\nfloat march(in vec3 ro, in vec3 rd, in float startf, in float maxd, in float j)\n{\n\tfloat precis = 0.001;\n    float h=0.5;\n    float d = startf;\n    for( int i=0; i<MAX_ITER; i++ )\n    {\n        if( abs(h)<precis||d>maxd ) break;\n        d += h*1.2;\n\t    float res = map(ro+rd*d, j).x;\n        h = res;\n    }\n\treturn d;\n}\n\n//volumetric marching\nvec3 vmarch(in vec3 ro, in vec3 rd, in float j, in vec3 orig)\n{   \n    vec3 p = sin(time)*ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    float w = 0.;\n    for( int i=0; i<VOLUMETRIC_STEPS; i++ )\n    {\n        r = map(p,j);\n        p += rd*.03;\n        float lp = length(p);\n        \n        vec3 col = sin(vec3(1.05,2.5,1.52)*3.94+r.y)*.85+0.4;\n        col.rgb *= smoothstep(.0,.015,-r.x);\n        col *= smoothstep(0.04,.2,abs(lp-1.1));\n        col *= smoothstep(0.1,.34,lp);\n        sum += abs(col)*5. * (1.2-noise(lp*2.+j*13.+time*5.)*1.1) / (log(distance(p,orig)-2.)+.75);\n        sum += abs(col)*2. * (1.2-globe(lp*2.+j*13.+time*5.)*1.1) / (log(distance(p,orig)-2.)+.75);\n    }\n    return sum;\n}\n\n//returns both collision dists of unit sphere\nvec2 iSphere2(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return vec2(-1.);\n    else return vec2((-b - sqrt(h)), (-b + sqrt(2.0*h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = sin(time) / iResolution.xy-.5;\n    \n\t//camera\n\tvec3 ro = vec3(0.,0.,5.);\n    vec3 rd = normalize(vec3(p*.7,-1.5));\n    mat2 mx = mm2(time*.4+um.x*6.);\n    mat2 my = mm2(time*0.3+um.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec3 bro = ro;\n    vec3 brd = rd;\n\t\n    vec3 col = vec3(0.0125,0.,0.025);\n    #if 1\n    for (float j = 1.;j<NUM_RAYS+1.;j++)\n    {\n        ro = bro;\n        rd = brd;\n        mat2 mm = mm2((time*0.1+((j+1.)*5.1))*j*0.25);\n        ro.xy *= mm;rd.xy *= mm;\n        ro.xz *= mm;rd.xz *= mm;\n        float rz = march(ro,rd,2.5,FAR,j);\n\t\tif ( rz >= FAR)continue;\n    \tvec3 pos = ro+rz*rd;\n    \tcol = max(col,vmarch(pos,rd,j, bro));\n    }\n    #endif\n    \n    ro = bro;\n    rd = brd;\n    vec2 sph = iSphere2(ro,rd);\n    \n    if (sph.x > 0.)\n    {\n        vec3 pos = ro+rd*sph.x;\n        vec3 pos2 = ro+rd*sph.y;\n        vec3 rf = reflect( rd, pos );\n        vec3 rf2 = reflect( rd, pos2 );\n        float nz = (-log(abs(flow(rf*1.2,time)-.01)));\n        float nz2 = (-log(abs(flow(rf2*1.2,-time)-.01)));\n        col += (0.1*nz*nz* vec3(0.12,0.12,.5) + 0.05*nz2*nz2*vec3(0.55,0.2,.55))*0.8;\n    }\n    \n\tfragColor = vec4(col*1.3, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcdXDH.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4f3XW4", "name": "Fork treefoil ( SwagLordLa 795", "author": "SwagLordLancalot", "description": "treefoil ", "tags": ["vortex", "treefoil"], "time_retrieved": "2024-05-15T23:19:32.361735", "image_code": "//--------------------------------------------------------------------------\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n\n//--------------------------------------------------------------------------\nvec3 trefoil_point(float p,float q,float phi)\n{\n    float cp = cos(p*phi);\n    float sp = sin(p*phi);\n    float cq = cos(q*phi);\n    float sq = sin(q*phi);\n    return vec3((3.0+cq)*cp,(2.0+cq)*sp,-sq);\n} // trefoil_point()\n\n//--------------------------------------------------------------------------\n// treefoil (p,q)\n// ray is defined by point P and direction d\nvec4 compute(in float p,in float q,in vec3 P, in vec3 d)\n{\n    d = d/dot(d,d);\n    int \ti;\n    int \tnb \t\t= 1000;\n    float \tt_min \t= 8000.0;\n    float   phi_min;\n    float \tr2 \t\t= 0.1; // radius of the torus\n    for(i=0;i<nb;i++)\n    {\n        float phi \t= TWOPI*float(i)/float(nb);\n        vec3  A \t= trefoil_point(p,q,phi);\n        float t \t= -dot(P-A,d);\n        vec3  M \t= P+t*t*d;\n        vec3  diff \t= 2.0*M-A;\n        if(t > 0.0 && t < t_min && dot(diff*2.0,diff) < r2)\n        {\n            t_min \t= t;\n            phi_min = phi;\n        }\n    } // for()\n    \n    if(t_min < 1000.0)\n    {\n     \treturn COLORIZATION(6.0*phi_min/TWOPI);\n    }\n    else\n    {\n\t\treturn vec4(0.0,0.0,0.0,5.0);\n    }\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= min(iResolution.x,iResolution.y);\n\n                // center posistion and  cam zoom,\n\tvec2 uv \t\t= sin(0.25*iTime)*(fragCoord.xy / m - 2.0*vec2(0.454,0.25))*15.0; //cam zoom,\n    \n    vec3 P \t\t\t= vec3(uv*0.75,-2.0);\n    vec3 d      \t= vec3(0.0,0.0,1.0);\n            //  speed cam rotation,\n    float alpha1\t= iTime*TWOPI/8.;\n    float alpha2\t= iTime*TWOPI/1.5;\n    \n    P.zx\t\t   *= ROTATION(alpha1);\n    P.xy\t\t   *= ROTATION(alpha2);\n    d.zx \t\t   *= ROTATION(alpha1);\n    d.xy\t\t   *= ROTATION(alpha2);\n\n\n    float i = mod(iTime/2.0 /* change every 3 seconds */,16.0);\n    float p,q;\n    if(i <= 1.0) \t\t{p=6.0;q=1.0;}\n    else if(i <= 2.0)\t{p=2.0;q=5.0;}\n    else if(i <= 3.0)\t{p=2.0;q=7.0;}\n    else if(i <= 4.0)\t{p=3.0;q=2.0;}\n    else if(i <= 5.0)\t{p=3.0;q=4.0;}\n    else if(i <= 6.0)\t{p=3.0;q=5.0;}\n    else if(i <= 7.0)\t{p=3.0;q=7.0;}\n    else if(i <= 8.0)\t{p=4.0;q=3.0;}\n    else if(i <= 9.0)\t{p=4.0;q=5.0;}\n    else if(i <= 10.0)\t{p=4.0;q=7.0;}\n    else if(i <= 11.0)\t{p=5.0;q=2.0;}\n    else if(i <= 12.0)\t{p=5.0;q=3.0;}\n    else if(i <= 13.0)\t{p=5.0;q=4.0;}\n    else if(i <= 14.0)\t{p=5.0;q=6.0;}\n    else if(i <= 15.0)\t{p=5.0;q=7.0;}\n\telse\t\t\t\t{p=6.0;q=5.0;}\n       \n    fragColor = compute(p,q,P,d);\n} // mainImage()\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}", "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4f3XW4.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "DdGXRt", "name": "tgruh", "author": "The_Snek12", "description": "literal agony", "tags": ["raymarching"], "time_retrieved": "2024-05-15T23:19:32.397794", "image_code": "#define EPSILON 0.001\n#define PI 3.1415926\n\n\n\nfloat saturate(float x)\n{\n\treturn clamp(x, 0., 1.);\n}\n\n\nmat3 rotateX(float ang){\n    float c = cos(ang);\n    float s = sin(ang);\n    return mat3(vec3(1,0,0),\n                vec3(0,c,-s),\n                vec3(0,s,c));\n}\n\nmat3 rotateY(float ang){\n    float c = cos(ang);\n    float s = sin(ang);\n    return mat3(vec3(c,0,s),\n                vec3(0,1,0),\n                vec3(-s,0,c));\n}\n\nmat3 rotateZ(float ang){\n    float c = cos(ang);\n    float s = sin(ang);\n    return mat3(vec3(c,-s,0),\n                vec3(s,c,0),\n                vec3(0,0,1));\n}\n\n\n\nfloat sphereSDF(vec3 p){\n     return length(p)-3.0;\n}\nfloat rectSDF(vec3 p){\n  vec3 b = vec3(2.5);\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat mainSDF(vec3 p){\n  p = p*rotateY(iTime);\n  return max(sphereSDF(p), rectSDF(p));\n  \n}\n\nvec3 getRayDirection(vec2 pos){\n    float z= iResolution.y/tan(radians(90.)/2.);\n    return normalize(vec3(pos, -z));\n}\n\n\nfloat distanceToSurface(vec3 eye, vec3 rayDir, float nearClipingBound, float farClipingBound){\n    float rayDist = nearClipingBound;\n   \n    for (int i = 0; i<100; i++){\n      float sceneDist = mainSDF(eye + rayDist * rayDir);\n      if (sceneDist < EPSILON){\n          return rayDist;\n      }\n      rayDist += sceneDist;\n      if (sceneDist >= farClipingBound){\n         return farClipingBound;\n      }\n    }\n    return farClipingBound;\n}\nvec3 normal(vec3 p){\n    return normalize(vec3(\n    mainSDF(vec3(p.x + EPSILON, p.y, p.z)) - mainSDF(vec3(p.x - EPSILON,p.y,p.z)),\n    mainSDF(vec3(p.x,p.y + EPSILON,p.z)) - mainSDF(vec3(p.x,p.y - EPSILON,p.z)),\n    mainSDF(vec3(p.x,p.y,p.z + EPSILON)) - mainSDF(vec3(p.x,p.y,p.z - EPSILON))\n    ));\n}\n\nvec3 lambert(vec3 normal, vec3 lightdir, vec3 col, float intensity, vec3 ambientColor,float ambientIntensity){\n    return dot(normal, lightdir)*col*intensity + ambientColor*ambientIntensity;\n}\n\n\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv)\n{\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nvec3 renderSphere(vec3 cam, vec3 worldDir){\n     \n    \n     \n     float dist = distanceToSurface(cam, worldDir, 0.01, 100.);\n     vec3 p = dist*worldDir+cam;\n     \n     vec3 halfVector = normalize(normal(p) + worldDir);\n     \n      if (dist >= 100. - EPSILON){\n         vec3 col = texture(iChannel0, p).xyz;\n         return col;\n         \n     }\n\n     vec3 lightDir = normalize(vec3(7,9,5));\n    \n     vec3 envReflect = texture(iChannel0, reflect(worldDir, normal(p))).xyz; //reflections\n     vec3 frensel = EnvBRDFApprox(vec3(1.0), 0.9, saturate(dot(normal(p), -worldDir)));\n     \n     \n     //return vec3(dot(lightDir, normal(p)));\n     //return vec3( (1.-smoothstep(0., 0.3, dot(normal(p), -worldDir))) * ) ;\n     \n     \n     \n     return envReflect*frensel;\n     \n     //vec3 trans = texture(iChannel0, worldDir).xyz; //transparency\n     //vec3 diff = lambert(normal(p), normalize(vec3(7,9,5)), vec3(1,1,1), 0.2, vec3(1,1,1), 0.4); \n     //return mix(mix(diff, spec, reflection), trans, transparency);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec3 col;\n vec3 cam = vec3(cos(radians(iMouse.x))*10.,5.,sin(radians(iMouse.x))*10.);\n vec2 xy = fragCoord - iResolution.xy / 2.0;\n vec3 dir = getRayDirection(xy);\n \n mat3 viewToWorld = viewMatrix(cam, vec3(0.0, 0., 0.0), vec3(0.0, 1.0, 0.0));   \n vec3 worldDir = viewToWorld*dir;\n vec3 resultColor = renderSphere(cam, worldDir);   \n \n \n \n fragColor = vec4(resultColor, 1);\n \n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/DdGXRt.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MfdSzM", "name": "Fork  Fibonacci SwagLordLa 982", "author": "SwagLordLancalot", "description": "changed some params and got the nice effect. \nhope someone could simplify the code or get a higher framerate in some way.\ncomment pls   :(", "tags": ["3d", "sphere", "glow", "fibonacci"], "time_retrieved": "2024-05-15T23:19:32.783901", "image_code": "//learn from : https://www.shadertoy.com/view/dtf3Ws\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // thank for jolle's comment,the extended glow cause great waste!\n     //but it doesn't look so natural on the edge\n     vec2 d = (fragCoord-iResolution.xy*0.5)/iResolution.y*0.5;\n     if (dot(d, d) > 0.55)\n     {\n     fragColor = vec4(0.);\n     return;\n     }\n        \n     //Clear base color.\n    fragColor-=fragColor;\n    \n    vec2 r = iResolution.xy, p,\n         t = iTime-vec2(0,11), I = 4.*d;\n    \n   \n    //Iterate though 400 points and add them to the output color.\n    for(float i=-1.; i<1.; i+=6e-3)\n        {     \n        //Xor's neater code!\n        p = sin(i*4e4+t.yx+11.)*sqrt(1.-i*i),\n        fragColor += (cos(i+vec4(4,3,2.*sin(t)))+1.)*(1.-p.y) /\n        dot(p=I+vec2(i,p/3.)/(p.y+2.),p)/3e4,\n        // dot(p=I+vec2(p.x,i)/(p.y+2.),p)/3e4,\n       \n        p = sin(i*4e4-t)*sqrt(1.-i*i), \n        fragColor += (cos(i+vec4(1,4,6,0))+1.)*(1.-p.y) / \n        dot(p=cos(.5*t)*I+vec2(p.x,i)/(p.y+2.),p)/3e5,\n        \n        p = sin(i*4e4-t+80.)*sqrt(1.-i*i), \n        fragColor += (cos(i+vec4(2,8,6,0))+1.)*(1.-p.y) / \n        dot(p=I+vec2(p.x,i)/(p.y+2.),p)/3e5,\n        \n        p = sin(i*4e4-t+4e2)*sqrt(1.-i*i), \n        fragColor += (cos(i+vec4(2,4,12,0))+1.)*(1.-p.y) / \n        dot(p=sin(.25*t)*I+vec2(p.x,i)/(p.y+2.),p)/3e5;      \n        }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MfdSzM.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "lftXWH", "name": "Supernova (entropy)", "author": "smoothstep", "description": "sperimenting with dots across the canvas with sine functions", "tags": ["patterns", "dots", "neon", "entropy"], "time_retrieved": "2024-05-15T23:19:33.274370", "image_code": "/*\n    INSPIRED BY\n    https://www.youtube.com/watch?v=sW56us0ZBEQ&t=15s\n    \n    SMOOTHSTEP\n    \n    SUPERNOVA\n*/\n\nvec2 rotate2D(vec2 uv, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c) * uv;\n}\n\nvec2 hash12(float t) {\n    float x = fract(sin(t * 5.329));\n    float y = fract(sin((t + x) * 5.732));\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - vec2(0.45, 0.5) * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n\n\n    // tweak this to enlarge the entropy\n    float r = 0.2;\n    \n    // dots iteration number\n    for (float i=0.0; i < 120.0; i++) {\n        float factor = (sin(iTime*.1) * 0.5 + 0.5);\n        i += factor;\n\n        float a = i / 3.;\n        // This manipulates the dots spread in the x and y axis\n        float dx = 1. * r * cos(a) - r * cos(8. * a);\n        float dy = 1. * r * sin(a) - r * sin(8. * a);\n\n        col += 0.013 * factor / length(uv - vec2(dx + 0.1, dy) - 0.02 * hash12(i));\n    }\n    col *= sin(vec3(0.2, 0.7, 0.9) * iTime*.5) * 0.15 + 0.25;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lftXWH.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MftSWn", "name": "Fractal Perlin noise ", "author": "Falafel", "description": "Simple, sparingly commented fractal perlin noise implementation in a shader.\nIf you have any questions don't hesitate to ask :)", "tags": ["fractal", "noise", "perlin", "map", "mountains", "world"], "time_retrieved": "2024-05-15T23:19:34.286249", "image_code": "// This defines the base color based of the height.\nvec3 palette( float t ) {\n    vec3 a = vec3(0.428,0.588,0.488);\n    vec3 b = vec3(0.308,-0.142,0.500);\n    vec3 c = vec3(-0.422,-0.702,-0.382);\n    vec3 d = vec3(0.548,-0.062,-0.472);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n// The randomizer used is a very simple home-grown quadratic offset, seems to work well enough. It produces a random float from 0 - 2*PI and converts it o a vector.\n// This type of RNG is used because for the same inputs it will create the same outputs, meaning we do not need to save a grid of random vectors, but can calculate them on the fly.\nvec2 randomVector(int x, int y, float snapZoom) {\n\n    int u = x + (y + 5) * int(snapZoom);\n    \n    float r = mod(float(u * (u + 1) * 42043), 6.283185307);\n    \n    return vec2(cos(r), sin(r));\n}\n\n// The interpolation function used is known as 'smootherstep', the second-order version of https://en.wikipedia.org/wiki/Smoothstep.\nfloat interpolate(float a, float b, float f) {\n\n    return (b - a) * ((f * (f * 6.0 - 15.0) + 10.0) * f * f * f) + a;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    uv.y += 0.1 * iTime;\n    uv.x += 0.05 + 0.05 * sin(iTime * 0.3);\n    \n    // Offset so division by zero doesn't happen.\n    float o = 0.00001;\n    \n    // The maximum zoom, so the definition of the highest octave.\n    float maxZoom = (sin(iTime) + 1.1) * 512.0;\n    \n    float height = 0.0;\n    \n    for (float zoom = 2.0; zoom < maxZoom + 1.0; zoom *= 2.0) { \n        \n        // Casting to an int is a simple way to create a grid. Floor would probably work too.\n        int x = int(uv.x * zoom);\n        int y = int(uv.y * zoom);\n\n        // The vector pointing from the bottom right of the square to the point, also known as the local vector.\n        vec2 loc = vec2(uv.x * zoom - float(x), uv.y * zoom - float(y));\n\n        // Calculate the Dot product of the vector from the point to each corner, and the random vector at the corner.\n        float bl = dot(vec2(o) - loc, randomVector(x, y, zoom));\n        float br = dot(vec2(1.0 + o, o) - loc, randomVector(x + 1, y, zoom));\n        float tl = dot(vec2(o, 1.0 + o) - loc, randomVector(x, y + 1, zoom));\n        float tr = dot(vec2(1.0 + o, 1.0 + o) - loc, randomVector(x + 1, y + 1, zoom));\n    \n        // Interpolates a point between the bottom two points, and then the same for the top two.\n        float b = interpolate(bl, br, uv.x * zoom - float(x));\n        float t = interpolate(tl, tr, uv.x * zoom - float(x));\n        \n        // Using the square root of zoom creates the fractal effect.\n        height += interpolate(b, t, uv.y * zoom - float(y)) / pow(zoom, 0.5);\n\n    }\n    \n    fragColor = vec4(palette(height + 0.05), 0.0);\n    \n    \n    // The following turns the noise into a simple map - skip if you just need the noise.\n    \n    // Water\n    if (height < -0.07) {\n        fragColor.z += 0.45;\n        fragColor.y -= 0.2;\n        fragColor /= 1.55;\n    }\n    // Shallows\n    else if (height < 0.0) {\n        fragColor.z += 0.5;\n        fragColor.y -= 0.2;\n        fragColor /= 1.1;\n    }\n    // Beach\n    \n    else if (height < 0.05) {\n        fragColor.x += 0.3;\n        fragColor.g += 0.15;\n        fragColor.z += 0.15;\n    }\n    // Snow\n    \n    if (height > 0.3) {\n        fragColor.xyz += 0.9;\n    }\n    // Mountains\n    \n    else if (height > 0.225) {\n    fragColor.y -= 0.2;\n    fragColor.x += 0.23;\n    fragColor.z += 0.3;\n    }\n    // High forest\n    \n    else if (height > 0.11) {\n    fragColor.y -= 0.2;\n    fragColor.z += 0.1;\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MftSWn.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Xf3XW8", "name": "Three Body Problem Simulation", "author": "oemfoe", "description": "A simulation of gravity and the three body problem. When going fullscreen, click to reset the view. Sit back and relax while chaos unfolds...", "tags": ["space", "planet", "orbit", "three", "gravity", "problem", "body"], "time_retrieved": "2024-05-15T23:19:34.327293", "image_code": "float sdLineSquared(in vec2 iPoint, in vec2 iLine0, in vec2 iLine1) {\n\tvec2 diff = iPoint - iLine0;\n\tvec2 dir = iLine1 - iLine0;\n\tfloat t = dot(diff, dir) / (length(dir) * length(dir));\n\tt = clamp(t, 0.0, 1.0);\n\tvec2 oLinePoint = t * dir + iLine0;\n\treturn length(iPoint - oLinePoint);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = fragCoord/iResolution.y;\n    uv2 -= .5;\n    uv2 *= zoom;\n    uv2 += .5;\n    vec2 body1 = vec2(_(PX1), _(PY1));\n    vec2 b1v = vec2(_(VX1), _(VY1));\n    vec2 body2 = vec2(_(PX2), _(PY2));\n    vec2 b2v = vec2(_(VX2), _(VY2));\n    vec2 body3 = vec2(_(PX3), _(PY3));\n    vec2 b3v = vec2(_(VX3), _(VY3));\n\n    // Output to screen\n    fragColor = texture(iChannel1, uv);\n    //fragColor += texture(iChannel0, uv);\n    \n    float d1 = sdLineSquared(uv2, body1, body1 + b1v * 100.);\n    fragColor.rgb += vec3(smoothstep(0.005, 0.001, d1));\n    \n    float d2 = sdLineSquared(uv2, body2, body2 + b2v * 100.);\n    fragColor.rgb += vec3(smoothstep(0.005, 0.001, d2));\n    \n    float d3 = sdLineSquared(uv2, body3, body3 + b3v * 100.);\n    fragColor.rgb += vec3(smoothstep(0.005, 0.001, d3));\n    \n    \n    vec3 field = vec3(1., 0., 0.) * smoothstep(0., 100., 1./pow(length(uv2 - body1), 2.));\n    field += vec3(1., 0., 1.) * smoothstep(0., 100., 1./pow(length(uv2 - body2), 2.));\n    field += vec3(1., 1., 0.) * smoothstep(0., 100., 1./pow(length(uv2 - body3), 2.));\n\n    \n    fragColor.rgb += vec3(pow(field.x, 0.5), pow(field.y, 0.5), pow(field.z, 0.5));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SET(X,V) if (uv.x - 0.01 < X && uv.x + 0.01 > X) { fragColor = vec4(V, V, V, 1.); }\n#define SETV(P,N,V) SET(PXN, (V).x) SET(PYN, (V).y)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float x1 = texture(iChannel0, vec2(PX1, 0.)).x;\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    if (iTime < 2. || iMouse.z > 0.) {\n        SET(PX1, 1.)\n        SET(PY1, 0.5)\n        \n        SET(VX1, -0.0005)\n        SET(VY1, 0.000866)\n        \n        SET(PX2, 1.3)\n        SET(PY2, 0.5 + 0.6 * 0.866);\n        \n        SET(VX2, 0.001)\n        SET(VY2, 0.0000)\n        \n        SET(PX3, 1.6)\n        SET(PY3, 0.5)\n        \n        SET(VX3, -0.0005)\n        SET(VY3, -0.000866)\n        return;\n    }\n    \n    vec2 body1 = vec2(_(PX1), _(PY1));\n    vec2 b1v = vec2(_(VX1), _(VY1));\n    vec2 body2 = vec2(_(PX2), _(PY2));\n    vec2 b2v = vec2(_(VX2), _(VY2));\n    vec2 body3 = vec2(_(PX3), _(PY3));\n    vec2 b3v = vec2(_(VX3), _(VY3));\n    \n    float G = 0.0000006;\n    \n    float D12 = length(body1 - body2);\n    float F12 = G / (D12 * D12);\n    float D13 = length(body1 - body3);\n    float F13 = G / (D13 * D13);\n    float D23 = length(body2 - body3);\n    float F23 = G / (D23 * D23);\n    \n    b1v = normalize(body2 - body1) * F12 + b1v;\n    b1v = normalize(body3 - body1) * F13 + b1v;\n    \n    b2v = normalize(body1 - body2) * F12 + b2v;\n    b2v = normalize(body3 - body2) * F23 + b2v;\n    \n    b3v = normalize(body1 - body3) * F13 + b3v;\n    b3v = normalize(body2 - body3) * F23 + b3v;\n    \n    body1 += b1v;\n    body2 += b2v;\n    body3 += b3v;\n    \n    \n    SET(PX1, body1.x);\n    SET(PY1, body1.y);\n    SET(VX1, b1v.x);\n    SET(VY1, b1v.y);\n    \n    SET(PX2, body2.x);\n    SET(PY2, body2.y);\n    SET(VX2, b2v.x);\n    SET(VY2, b2v.y);\n    \n    SET(PX3, body3.x);\n    SET(PY3, body3.y);\n    SET(VX3, b3v.x);\n    SET(VY3, b3v.y);\n    \n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PX1 = 0.05;\nconst float PY1 = 0.10;\nconst float PX2 = 0.15;\nconst float PY2 = 0.20;\nconst float VX1 = 0.25;\nconst float VY1 = 0.30;\nconst float VX2 = 0.35;\nconst float VY2 = 0.40;\nconst float PX3 = 0.45;\nconst float PY3 = 0.50;\nconst float VX3 = 0.55;\nconst float VY3 = 0.60;\nconst float zoom = 2.;\n\n#define _(X) (texture(iChannel0, vec2(X, 0.5)).x)\n", "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = fragCoord/iResolution.y;\n    uv2 -= .5;\n    uv2 *= zoom;\n    uv2 += .5;\n\n    // Output to screen\n    fragColor = texture(iChannel1, uv) * 0.9999;\n    \n    vec2 body1 = vec2(_(PX1), _(PY1));\n    vec2 b1v = vec2(_(VX1), _(VY1));\n    vec2 body2 = vec2(_(PX2), _(PY2));\n    vec2 b2v = vec2(_(VX2), _(VY2));\n    vec2 body3 = vec2(_(PX3), _(PY3));\n    vec2 b3v = vec2(_(VX3), _(VY3));\n    \n    if (length(uv2 - body1) < 0.005)\n        fragColor = vec4(1., 0., 0., 1.);\n    \n    if (length(uv2 - body2) < 0.005)\n        fragColor = vec4(1., 0., 1., 1.);\n    \n    if (length(uv2 - body3) < 0.005)\n        fragColor = vec4(1., 1., 0., 1.);\n        \n    if (iTime < 2. || iMouse.z > 0.)\n        fragColor = vec4(0.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xf3XW8.jpg", "access": "api", "wgpu-test": "error"}
{"id": "4ctXWH", "name": "Learning bout stuff", "author": "NotJacob42", "description": "My first shade :)", "tags": ["artofcode"], "time_retrieved": "2024-05-15T23:19:34.341145", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1,1,1);\n    vec3 d= vec3(.263,0.416,0.557);\n\n    return a + b * cos(6.28318*(c*t*d));\n}\n \n\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragCoord) { \n    vec2 uv = (fragCoord *2.0 - iResolution.xy) / iResolution.xy;\n    vec2 uv0 = uv;\n    vec3 finalcolor = vec3(0.0);\n    \n for (float i = 0.0; i < 4.0; i++) {   \n    uv = fract(uv * 1.5) - 0.5;\n    \n    float d = length(uv) * exp (-length(uv0));\n    \n    vec3 col = palette(length (uv0) + i*.4 + iTime*.4);\n\n    d = sin(d*8. + iTime*.4)/8.;\n    d = abs(d);    \n    \n    d = pow(0.01/d, 1.2);\n    \n    finalcolor += col * d;\n  \n    fragcolor = vec4 (finalcolor , 1.0);\n  }  \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ctXWH.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "XctXD8", "name": "Fork cube", "author": "juk", "description": "Description", "tags": ["tag"], "time_retrieved": "2024-05-15T23:19:34.377027", "image_code": "// Bitmap to ASCII (not really) fragment shader by movAX13h, September 2013\n// This is the original shader that is now used in PixiJs, FL Studio and various other products.\n\n// Here's a little tool for new characters: thrill-project.com/archiv/coding/bitmap/\n\nfloat character(int n, vec2 p)\n{\n\tp = floor(p*vec2(-4.0, 4.0) + 2.5);\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n\t{\n        if (clamp(p.y, 0.0, 4.0) == p.y)\t\n\t\t{\n        \tint a = int(round(p.x) + 5.0 * round(p.y));\n\t\t\tif (((n >> a) & 1) == 1) return 1.0;\n\t\t}\t\n    }\n\treturn 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pix = fragCoord.xy;\n\tvec3 col = texture(iChannel0, floor(pix/16.0)*16.0/iResolution.xy).rgb;\t\n\t\n\tfloat gray = 0.3 * col.r + 0.59 * col.g + 0.11 * col.b;\n\t    \n\tint n =  4096;\n    \n    // limited character set\n    /*\n    if (gray > 0.2) n = 65600;    // :\n\tif (gray > 0.3) n = 163153;   // *\n\tif (gray > 0.4) n = 15255086; // o \n\tif (gray > 0.5) n = 13121101; // &\n\tif (gray > 0.6) n = 15252014; // 8\n\tif (gray > 0.7) n = 13195790; // @\n\tif (gray > 0.8) n = 11512810; // #\n    */\n    \n    // full character set including A-Z and 0-9\n    \n    if (gray > 0.0233) n = 4096;\n    if (gray > 0.0465) n = 131200;\n    if (gray > 0.0698) n = 4329476;\n    if (gray > 0.0930) n = 459200;\n    if (gray > 0.1163) n = 4591748;\n    if (gray > 0.1395) n = 12652620;\n    if (gray > 0.1628) n = 14749828;\n    if (gray > 0.1860) n = 18393220;\n    if (gray > 0.2093) n = 15239300;\n    if (gray > 0.2326) n = 17318431;\n    if (gray > 0.2558) n = 32641156;\n    if (gray > 0.2791) n = 18393412;\n    if (gray > 0.3023) n = 18157905;\n    if (gray > 0.3256) n = 17463428;\n    if (gray > 0.3488) n = 14954572;\n    if (gray > 0.3721) n = 13177118;\n    if (gray > 0.3953) n = 6566222;\n    if (gray > 0.4186) n = 16269839;\n    if (gray > 0.4419) n = 18444881;\n    if (gray > 0.4651) n = 18400814;\n    if (gray > 0.4884) n = 33061392;\n    if (gray > 0.5116) n = 15255086;\n    if (gray > 0.5349) n = 32045584;\n    if (gray > 0.5581) n = 18405034;\n    if (gray > 0.5814) n = 15022158;\n    if (gray > 0.6047) n = 15018318;\n    if (gray > 0.6279) n = 16272942;\n    if (gray > 0.6512) n = 18415153;\n    if (gray > 0.6744) n = 32641183;\n    if (gray > 0.6977) n = 32540207;\n    if (gray > 0.7209) n = 18732593;\n    if (gray > 0.7442) n = 18667121;\n    if (gray > 0.7674) n = 16267326;\n    if (gray > 0.7907) n = 32575775;\n    if (gray > 0.8140) n = 15022414;\n    if (gray > 0.8372) n = 15255537;\n    if (gray > 0.8605) n = 32032318;\n    if (gray > 0.8837) n = 32045617;\n    if (gray > 0.9070) n = 33081316;\n    if (gray > 0.9302) n = 32045630;\n    if (gray > 0.9535) n = 33061407;\n    if (gray > 0.9767) n = 11512810;\n\t\n    \n\tvec2 p = mod(pix/8.0, 2.0) - vec2(1.0);\n    \n\tif (iMouse.z > 0.5)\tcol = vec3(character(n, p));\n\telse col = col*character(n, p);\n\t\n\tfragColor = vec4(col, 1.0);\n    \n    // fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI acos(-1.0)\n\n// LINE FUNCTION\nvec4 line(vec2 uv, vec2 A, vec2 B, vec3 col, float thic, float blur) {\n    \n    vec2 g = B - A;\n    vec2 h = uv - A;\n    float d;\n    \n    d = length(h - g * clamp(dot(g, h) / dot(g, g), 0.0, 1.0));\n    if(blur != 0.)\n        if((blur * thic) >= thic)\n            d = smoothstep(blur * thic, thic, d);\n        else\n            d = smoothstep(thic, blur * thic * length(0.05), d);\n    else\n        d = step(thic, d);\n    \n    return vec4(col, d);\n}\n\n// CUBE FUNCTION\nvec4 cube(\n    vec2 uv,\n    vec2 pos,\n    float rot,\n    float width,\n    float height,\n    float tilt,\n    float thic,\n    vec3 col\n) {\n    vec4 background, foreground;\n    background = vec4(0.);\n    \n    for (int i = 0; i <= 3; i++) {\n        float j = float(i);\n        \n        foreground = line(\n            uv, \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y + height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y - height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            col,\n            thic/10.,\n            1.01\n        );\n        background = mix(background, foreground, foreground.a);\n        foreground = line(\n            uv, \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y + height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            vec2(\n                pos.x + sin(rot + PI/2. * (j + 1.)) * width * 1.5,\n                pos.y + height - cos(rot + PI/2. * (j + 1.)) * tilt/45. * 100.\n            ), \n            col,\n            thic/10.,\n            1.01\n        );\n        background = mix(background, foreground, foreground.a);\n        foreground = line(\n            uv, \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y - height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            vec2(\n                pos.x + sin(rot + PI/2. * (j + 1.)) * width * 1.5,\n                pos.y - height - cos(rot + PI/2. * (j + 1.)) * tilt/45. * 100.\n            ), \n            col,\n            thic/10.,\n            1.01\n        );\n        background = mix(background, foreground, foreground.a);\n    }\n    return background;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Aspect Ratio Fix\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;\n    \n    \n    vec4 background, foreground;\n    \n    background = vec4(0.);\n\n    // WHITE CUBE\n    foreground = cube(\n        uv,\n        vec2(0., 0.),\n        iTime,\n        0.5,\n        0.5,\n        0.1,\n        0.25,\n        vec3(1.0)\n    );\n    \n    background = mix(background, foreground, foreground.a);\n\n\n    fragColor = foreground;\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XctXD8.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "4fdXW8", "name": "draw a convolution kernel", "author": "jonasfrey", "description": "this is an experiment to see how a convolution kernal behaves, you can draw the kernal on the left side\nleft click to draw a positive weight, hold down spacebar to draw a negative weight\n", "tags": ["mouse", "draw", "buffer", "learn"], "time_retrieved": "2024-05-15T23:19:34.410894", "image_code": "// Fork of \"Draw with mouse [antialiased]\" by avin. https://shadertoy.com/view/wlKfDm\n// 2024-04-23 10:23:30\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{          \n\n    vec2 o_trn = fragCoord.xy;\n    vec2 o_trn_nor = o_trn / iResolution.xy;\n    vec4 o_col_sum = vec4(0.);\n    \n    vec2 o_scl_krnl = vec2(18.);\n    vec2 o_scl_krnl_half = floor(o_scl_krnl/2.);\n    float n_sum_weight = 0.;\n   for(float n_x = 0.; n_x < o_scl_krnl.x; n_x+=1.){\n        for(float n_y = 0.; n_y < o_scl_krnl.y; n_y+=1.){\n            vec2 o_trn_krnl = vec2(n_x, n_y);\n            vec2 o_trn_krnl2 = o_trn_krnl-o_scl_krnl_half;\n            vec2 o_trn_krnl_nor = o_trn_krnl / o_scl_krnl;\n            vec4 o_weight = texture(iChannel0, o_trn_krnl_nor*vec2(0.5, 1.));\n            float n_w = o_weight.r -  o_weight.g;\n            n_sum_weight += n_w;\n            o_col_sum\n                +=\n                texture(\n                    iChannel1,\n                    (o_trn+o_trn_krnl2.xy)/iResolution.xy\n                )*n_w;\n        }\n    }\n    o_col_sum /= n_sum_weight;\n    fragColor = texture(iChannel0, o_trn/iResolution.xy);\n    if(o_trn_nor.x > .5){\n        fragColor = o_col_sum;\n    }\n    \n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keyToggle(ascii)  ( texelFetch(iChannel2,ivec2(ascii,2),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel2,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel2,ivec2(ascii,0),0).x > 0.)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = (fragCoord.xy)/iResolution.y;\n       \n    vec2 pos1 = iMouse.xy/iResolution.y;\n    vec4 prevMouse = texture(iChannel1, ouv).rgba;\n    vec2 pos2 = prevMouse.rg;\n       \n    vec3 backCol = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n                \n    float d = 0.;\n    vec3 o_col = vec3(0.);\n    float n = 1.-length(pos1-ouv)*3.;\n    if(prevMouse.w > 0.){\n        o_col = vec3(n, 0., 0.);\n    }  \n    float n_key_spacebar = 32.;\n    if(keyDown(n_key_spacebar)){\n        o_col = vec3(0., n,0.);\n    }\n    \n    // vec3 col = backCol + vec3(d);\n    \n    vec3 col = max(backCol, o_col );\n    \n    fragColor = vec4(col, 1.);    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iMouse.xy/iResolution.y,1.0,iMouse.z);    \n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fdXW8.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "4fcSD8", "name": "rainbow scales", "author": "smoothstep", "description": "scales", "tags": ["scaled", "fracts"], "time_retrieved": "2024-05-15T23:19:34.813573", "image_code": "// the palette is good for dynamicity and creating patterns\n// check http://dev.thi.ng/gradients/\n\nvec3 palette( float t){\n    vec3 a = vec3(0.500, 0.500, 0.500);\n    vec3 b = vec3(1., 1., 1.);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0.000, 0.333, 0.667);\n    \n    return a + b*cos( 3.*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.x;\n     \n    uv = fract(uv * 5.);\n    \n    float d = length(uv);\n    \n    // I time gives more dynamic to the colors\n    vec3 col = palette(d + iTime);\n    \n     \n    d = sin(d * 16. - iTime)/8.;\n    d = abs(d);\n \n    d = 0.02/d;\n    \n    col *= d;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fcSD8.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Xc3XD8", "name": "the great pulse", "author": "smoothstep", "description": "usle", "tags": ["pulse", "scaled", "fracts"], "time_retrieved": "2024-05-15T23:19:35.160057", "image_code": "// the palette is good for dynamicity and creating patterns\n// check http://dev.thi.ng/gradients/\n\nvec3 palette( float t){\n    vec3 a = vec3(0.560, 0.138, 0.629);\n    vec3 b = vec3(0.934, 0.364, 0.347);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0.1, 0.1, 4.1);\n    \n    return a - b*cos( 6.123123*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n     \n     for(float i = 0.; i<1.618; i++){\n         uv = fract(uv * 1.9) - .5;\n\n        // we make the distance multiply to a exponential function for the uv0 negative length\n        float d = length(uv) * exp(length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 - iTime*.5);\n\n\n        d = sin(d * 8. - iTime)/4.;\n        d = abs(d);\n\n        d = pow(.1/d, 1.1);\n\n        col *= d;\n    \n    \n        finalColor += col * d;\n     }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xc3XD8.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4ccSD8", "name": " horizon kiss", "author": "smoothstep", "description": "something alive", "tags": ["repetition", "neon", "horizon"], "time_retrieved": "2024-05-15T23:19:35.559805", "image_code": "// the palette is good for dynamicity and creating patterns\n// check http://dev.thi.ng/gradients/\n\nvec3 palette( float t){\n    vec3 a = vec3(0.152, 0.560, 0.926);\n    vec3 b = vec3(0.599, 0.265, 0.247);\n    vec3 c = vec3(1.557, 0.424, 1.204);\n    vec3 d = vec3(5.745, 2.017, 2.988);\n    \n    return a + b*cos( 3.*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    float d = length(uv * uv.y);\n    \n    // I time gives more dynamic to the colors\n    vec3 col = palette(d + iTime);\n    \n     \n    d = sin(d * 16. - iTime)/8.;\n    d = abs(d);\n \n    d = 0.08/d;\n    \n    col *= d;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ccSD8.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MfcXDH", "name": "FTL raymarching", "author": "Alie", "description": "Result of Monday Night Bytes shader jam. Wanted to see if I could do raymarching fast enough to allow multiple samples for motion blur, then added a rainbow blur effect.", "tags": ["raymarching", "tunnel", "motionblur", "rainbow", "wccchallenge"], "time_retrieved": "2024-05-15T23:19:35.630979", "image_code": "#define r2d(p,a) p=cos(a)*p + sin(a)*vec2(-p.y,p.x);\n\nvec3 hash(vec3 p) {\n  p = fract(p * vec3(443.537, 537.247, 247.428));\n  p += dot(p, p.yxz + 19.19);\n  return fract((p.xxy + p.yxx) * p.zyx);\n} \n\n\nfloat cat(vec2 p) {\n  p.x = abs(p.x);\n  vec2 q=p;\n  q.x = abs(q.x-.2);\n  q.y += q.x - .2;\n  float r = abs(q.y)<.05 && q.x<.15 ? 1. : 0.;\n  p.x -= .6;\n  p.y = abs(p.y) - .08;\n  r += abs(p.y)<0.03 && abs(p.x)<.15 ? 1. : 0.;\n  return r;\n}\n\nfloat boxDist(vec3 p, vec3 o, vec3 s, float r) {\n  p = abs(p - o) - s / 2.;\n  return length(max(p, 0.) + min(0., max(p.x, max(p.y, p.z)))) - r;\n}\n\nvec4 df(vec3 p) {\n  float d = 1000.;\n  //const vec3 cols[3] = {vec3(1,0,1), vec3(1,1,0), vec3(0,1,1) };\n  p.z /= 3.;\n  vec3 col;\n  for (float i=0.; i<3.; i++) {\n    float e = boxDist(p * vec3(1,1,0), vec3(sin(p.z + i * 3.142), cos(p.z + i * 3.142), 0.) * 1.5, vec3(.8), .1);\n    if (e < d) {\n      d = e;\n      col = i==0. ? vec3(.7) : (i==1. ? vec3(.85) : vec3(1));\n    }\n    p.z *= -1.2;\n  }\n  \n  d = min(\n    d,\n    -length(p.xy) + 2.\n  );\n  vec3 q = p;\n  r2d(q.xy, q.z / 3.);\n  if (d > 0.1) {\n    p = .5 - abs(max(fract(p), fract(q)) - .5);\n    //col = step(0.98, fract(p + fract(q))) * 8.;\n    col = 1. - step(.01, p);\n    col = vec3(max(col.x, max(col.y, col.z))) * 4.;\n  }\n  return vec4(col, d);\n}\n\nvec3 norm(vec3 p) {\n  vec2 e = vec2(1e-3, 0.);\n  return normalize(vec3(\n    df(p + e.xyy).w - df(p - e.xyy).w,\n    df(p + e.yxy).w - df(p - e.yxy).w,\n    df(p + e.yyx).w - df(p - e.yyx).w\n  ));\n}\n\nvec3 rm(vec3 p, vec3 dir, float mDist) {\n  vec3 col = vec3(0.);\n  float td = 0.;\n  for (int i=0; i< 20; i++) {\n    vec4 d = df(p);\n    td += d.w;\n    if (d.w < 1e-3 || td > mDist) {\n      col = d.xyz;\n      vec3 n = norm(p);\n      col *= pow(max(0., dot(-n, dir)), 2.);\n      break;\n    }\n    p += d.w * dir;\n  }\n  return col;\n}\n\nconst int samples = 16;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  //vec2 uv = fragCoord/iResolution.xy;\n  vec2 uv = vec2(fragCoord.xy * 2. - iResolution.xy) / iResolution.yy;\n  \n  vec3 col = vec3(0.);\n  \n  for (int j=0;j<samples; j++) {\n    vec3 k = hash(vec3(uv, fract(iTime + float(j) / float(samples)))) - .5;\n    k.z = float(j) / float(samples);\n    float t = iTime + k.z / 15.;\n    vec2 c = vec2(fragCoord.xy) + k.xy * 2.; //texture(texFFTSmoothed, 0.01).x * 20.;\n    vec2 u = vec2(c * 2. - iResolution.xy) / iResolution.yy;\n    vec3 p = vec3(0, 0, t * 10.),\n    dir = normalize(vec3(u, .5));\n    r2d(dir.xy, t / 4.);\n    r2d(dir.xz, sin(t / 20.47) * 2.);\n    r2d(dir.yz, sin(t / 17.24) * 2.);\n  \n    float d = 1. / length(dir.xy), d2 = d * 2.;\n    p += dir * d;\n    \n    int idx = int((k.z) * 3.);\n    col[idx] += rm(p, dir, d / 2.).r * 3.;\n    //col += hash(floor(p * 10.)) * .5 + .25;\n  }\n\n  vec3 catC = vec3(0);\n  for (float i=0.;i<9.;i++) {\n    vec2 o = vec2(\n        sin(i / 10. + iTime * 2.347),\n        sin(i / 10. + iTime * 2.789)\n        );\n    o = pow(abs(o), vec2(7.)) * sign(o);\n    catC[int(i)/3] += cat((uv + o / 4.) * .5) / 3.;\n  }\n\tfragColor = vec4(col / float(samples) + catC, 1.);\n    //fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MfcXDH.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "McdSDr", "name": "radar thingy", "author": "nuzunuzu", "description": "radar exercise from the book of shaders", "tags": ["radar"], "time_retrieved": "2024-05-15T23:19:35.671870", "image_code": "#define PI 3.14159265\n\nfloat circle( vec2 uv, vec2 pos, float rad) {\n    uv -= pos;\n    return smoothstep(rad-3.0, rad-1.0, length(uv)) -\n           smoothstep(rad+1.0, rad+3.0, length(uv));\n}\n\nfloat fillCircle( vec2 uv, vec2 pos, float rad) {\n    uv -= pos;\n    return smoothstep(rad-1.0, rad-3.0, length(uv));\n}\n\nfloat line(vec2 uv, vec2 start, float len, float spinAng) {\n    vec2 l = uv - start;\n    float ang = mod(atan(l.y, l.x), 2.0*PI);\n    float dis = length(l)/len;\n    return step(-len, -length(l)) * \n           (smoothstep(spinAng-0.03*(1.2-dis), spinAng, ang) - \n            smoothstep(spinAng, spinAng+0.03*(1.2-dis), ang));\n}\n\nfloat lineShadow(vec2 uv, vec2 start, float len, float spinAng) {\n    vec2 l = uv - start;\n    float ang = mod(atan(l.y, l.x), 2.0*PI);\n    return step(-len, -length(l)) *\n           (smoothstep(spinAng-PI/3.0, spinAng, ang) +\n            smoothstep(spinAng-PI/3.0+2.0*PI, spinAng+2.0*PI, ang) -\n            step(spinAng, mod(atan(l.y, l.x), 2.0*PI))\n           );\n}\n\nfloat target(vec2 uv, vec2 center, vec2 pos, float spinAngle) {\n    vec2 taPos = pos - center;\n    float delta = mod(spinAngle - atan(taPos.y, taPos.x), 2.0*PI)/PI;\n    float color = fillCircle(uv, pos, 10.0);\n    color += circle(uv, pos, 20.0*delta+10.0);\n    return clamp(color * (1.0-delta), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    vec2 center = iResolution.xy/2.0;\n\n    float outer = circle(uv, center, 200.0);\n    float inner = fillCircle(uv, center, sin(iTime)*1.0+5.0);\n    \n    float spinAngle = mod(iTime*2.0, 2.0*PI);\n    float spin = lineShadow(uv, center, 200.0, spinAngle) * 0.3;\n    spin += line(uv, center, 200.0, spinAngle);\n    \n    float targets = target(uv, center, center + vec2(120.0, 60.0), spinAngle);\n    targets += target(uv, center, center + vec2(-50.0, -150.0), spinAngle);\n    targets += target(uv, center, center + vec2(-90.0, 100.0), spinAngle);\n    \n    float color = outer + inner + spin + targets; \n    fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McdSDr.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4cdXR7", "name": "NZXT 3D refraction", "author": "byt3_m3chanic", "description": "NZXT 3d refraction | Was playing around to make something for wallpaper and got stuck in shader land.", "tags": ["raymarching", "logo", "typography", "nzxt"], "time_retrieved": "2024-05-15T23:19:37.453141", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    NZXT logo with 2d SDF's extruded + with refaction\n    04/21/24 | @byt3_m3chanic\n\n\n*/\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI      3.141592653\n#define PI2     6.283185307\n\n#define MAX_DIST    25.\n\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nvec3 hit, hitpt;\nmat2 rx,ry,r56,r56n;\n\n//@iq box and extrude\nfloat opx( in vec3 p, float d, in float h )\n{\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat text_(vec2 p){\n    return box(p,vec2(.275,.275));\n}\n\nfloat text_n(vec2 p){\n    float d = box(vec2(abs(p.x)-.17,p.y),vec2(.08,.275));\n    vec2 pv = p*r56;\n    float e = box(pv,vec2(.075,.325));\n\n    return max(min(d, e),text_(p));\n}\n\nfloat text_z(vec2 p){\n    float d = box(p-vec2(-.045,.25),vec2(.2,.115));\n    d = min(d,box(p+vec2(-.045,.25),vec2(.2,.115)) );\n    vec2 pv = p*r56n;\n    float e = box(pv,vec2(.075,.375));\n\n    return max(min(d, e),text_(p));\n}\n\nfloat text_x(vec2 p){\n    vec2 pv = p*r56n;\n    float d = box(pv,vec2(.08,.4));\n    \n    pv = p*r56;\n    float e = box(pv,vec2(.08,.4));\n\n    return max(min(d, e),text_(p));\n}\n\nfloat text_t(vec2 p){\n    float d = box(p,vec2(.085,.275));\n    float e = box(p-vec2(0,.25),vec2(.275,.115));\n\n    return max(min(d, e),text_(p));\n}\n\nfloat swtch;\n\nvec2 map (in vec3 p) {\n    vec2 res = vec2(1e5,-1.);\n\n    vec3 q = p;\n\n    float tt,id;\n\n    if(swtch <1.) {\n        float size = 3.,hlf = size/2.;\n\n        tt = mod(T*.1,1.);\n        p+=T*(hlf/5.);\n        id = floor((p.x+hlf)/size)*.5;\n    \n        q.x+=tt*size;\n        q.x = mod(q.x+hlf,size)-hlf;\n    } else {\n        float size = 1.5,hlf = size/2.;\n    \n        tt = mod(T*.25,1.);\n        p+=T*(hlf/4.);\n        \n        q.y+=tt*size;\n        q.y = mod(q.y+hlf,size)-hlf;\n    }\n\n    float d = text_n(q.xy+vec2(.90,0));\n    d = min(d,text_z(q.xy+vec2(.30,0)));\n    d = min(d,text_x(q.xy-vec2(.30,0)));\n    d = min(d,text_t(q.xy-vec2(.90,0)));\n    \n    float fd = opx(q,d,.18);\n    \n    float e = opx(q,abs(d-.02)-.0085,.15);\n    \n    if(fd<res.x) {\n        res=vec2(fd*.8,1);\n        hit=p;\n    }\n    if(e<res.x&&mod(id,1.)==0.) {\n        res=vec2(e*.75,2);\n        hit=p;\n    }\n\treturn res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist)\n{\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n)\n{\n    vec3 clr;\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(.1,3,2);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n    float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.5);\n    fresnel = mix(.01, .7, fresnel);\n\n    float cpx = swtch<1. ? hit.x : hit.y;\n    if(m==1.) clr = .5 + .4 *sin(cpx*.75+ vec3(2.5,1.,.5));\n    if(m==2.) clr = .5 + .4 *sin((cpx+15.25)*1.+ vec3(2.5,1.,.5));\n    \n    vec3 h = mix(vec3(0),clr,diff);\n\n    return h;\n}\n\n\nvec3 renderAll( in vec2 F )\n{   \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 C=vec3(.0);\n\n    uv*=rot(.48);\n    vec3 ro = vec3(0,0,2),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) || M.z <0. ? 0. :  (M.y/R.y * .3 - .15) * PI;\n    float y = M.xy == vec2(0) || M.z <0. ? 0. : -(M.x/R.x * .3 - .15) * PI;\n\n    rx = rot(-.48+x);\n    ry = rot(y);\n    \n    ro.yz *= rx, ro.xz *= ry;\n    rd.yz *= rx, rd.xz *= ry;\n    \n    vec3  p = ro + rd * .1;\n    float atten = .75;\n    float k = 1.;\n    float b = 5.;\n    float iv = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<132;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float fresnel=0.;\n        float d = ray.x;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-9) {\n\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            if(b<0.)break;\n            \n            atten *= .65;\n            p += rd*.0001;\n            k = sign(map(p).x);\n            \n            b--;\n\n            p += rd*.005;\n            k = sign(map(p).x);\n        \n            vec3 rf=refract(rd,n,iv > 0. ? 1./1.1 : 1.075);\n            iv *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            rd=rf;\n            p+=-n*.001;\n            \n        }  \n        \n        \n        if(distance(p,rd)>50.) { break; }\n    }\n    return C;\n    \n}\n\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n\n    \n    swtch = mod(T*.08,2.);\n    r56 = rot(.56);\n    r56n = rot(-.56);\n    \n    vec3 C = renderAll(F);\n    C +=renderAll(F+vec2(.5,.5));\n    C /= 1.5;    \n\n    O = vec4(sqrt(smoothstep(0.,1.,C)),1.0);\n}\n//end", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cdXR7.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Mc3SzM", "name": "NZXT 3D font shader", "author": "byt3_m3chanic", "description": "NZXT 3d / reflections| Was playing around to make something for wallpaper and got stuck in shader land.", "tags": ["raymarching", "logo", "typography", "nzxt"], "time_retrieved": "2024-05-15T23:19:37.500120", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    NZXT logo with 2d SDF's extruded /\n    04/21/24 | @byt3_m3chanic\n\n    Did Soundcloud break shadertoy again?\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST 1e-4\n#define MAX_DIST 50.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat sampleFreq(float freq) { return texture(iChannel0, vec2(freq, .25)).x;}\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nvec3 hit,hp;\nmat2 r56,r56n;\n//@iq box and extrude\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat text_(vec2 p){\n    return box(p,vec2(.275,.275));\n}\n\nfloat text_n(vec2 p){\n    float d = box(vec2(abs(p.x)-.17,p.y),vec2(.08,.275));\n    vec2 pv = p*r56;\n    float e = box(pv,vec2(.075,.325));\n\n    return max(min(d, e),text_(p));\n}\n\nfloat text_z(vec2 p){\n    float d = box(p-vec2(-.045,.25),vec2(.2,.115));\n    d = min(d,box(p+vec2(-.045,.25),vec2(.2,.115)) );\n    vec2 pv = p*r56n;\n    float e = box(pv,vec2(.075,.375));\n\n    return max(min(d, e),text_(p));\n}\n\nfloat text_x(vec2 p){\n    vec2 pv = p*r56n;\n    float d = box(pv,vec2(.08,.4));\n    \n    pv = p*r56;\n    float e = box(pv,vec2(.08,.4));\n\n    return max(min(d, e),text_(p));\n}\n\nfloat text_t(vec2 p){\n    float d = box(p,vec2(.085,.275));\n    float e = box(p-vec2(0,.25),vec2(.275,.115));\n\n    return max(min(d, e),text_(p));\n}\n\n//@iq \nfloat opx( in vec3 p, float d, in float h )\n{\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nconst vec2 size = vec2(3.,1.75);\nconst vec2 hlf = size/2.;\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n\n    vec3 q = (p-vec3(0,.35,0))*(.5);\n\n    float d = text_n(q.xy+vec2(.90,0));\n    d = min(d,text_z(q.xy+vec2(.30,0)));\n    d = min(d,text_x(q.xy-vec2(.30,0)));\n    d = min(d,text_t(q.xy-vec2(.90,0)));\n    \n    d = opx(q,d,.15);\n    \n    if(d<res.x) {\n        res=vec2(d,1);\n        hit=p;\n    }\n\n    float f = p.y+1.;\n    if(f<res.x) {\n        res=vec2(f,2);\n        hit=p;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 FC = vec3(0.071,0.016,0.106);\n\nvec3 tile(vec3 hp){\n\n    vec2 id   = floor(hp.xz*3.);\n    vec2 grid = fract(hp.xz*3.)-.5;\n\n    float ns = hash21(id);\n    float px = fwidth(hp.x);\n    float sz = sampleFreq(ns);\n    \n    vec3 clr = .5 + .4 *sin((12.+ns)*2.75+ vec3(2.5,1.,.5));\n    float df = box(grid,vec2(sz*.45))-.075;\n    vec3 c = sz>.25 ? mix(vec3(0),clr,smoothstep(px,-px,df)) :vec3(0);\n\n    return c;\n}\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<128;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d += ray.x;\n        m  = ray.y;\n    } \n    hp = hit;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(12,8,3);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n  \n        vec3 h = vec3(.05);\n\n        if(m==1.) {\n            h= .45 + .4 *sin((hp.y+48.5)*5.25+ vec3(2.5,1.,.5));\n            ref=h*.65;\n        }\n        if(m==2.) {\n            hp.z+=T*2.15;\n            h = tile(hp);\n            ref = vec3(.35);\n         }\n\n        C = h*diff;\n        C = mix(FC,C,  exp(-.00005*d*d*d));\n    \n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    \n    }else{\n        C = FC;\n    } \n    return vec4(C,alpha);\n}\nfloat zoom = 6.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    r56 = rot(.56);\n    r56n = rot(-.56);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    FC = .5 + .4 *sin((uv.y+47.)*2.75+ vec3(2.5,1.,.5));\n    vec3 ro = vec3(0,0,4.);\n    vec3 rd = normalize(vec3(uv, -1));\n\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : (M.y / R.y * .2 - .1) * PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : (M.x / R.x * .2 - .1) * PI2;\n    \n    mat2 rx = rot(.28+x-.2*cos(T*.12)), ry = rot(y+.3*sin(T*.25));\n    ro.yz *= rx,ro.xz *= ry;\n    rd.yz *= rx,rd.xz *= ry;\n\n    vec3 C = vec3(0),ref=vec3(0),fil=vec3(1);\n    \n    float d = 0.,a = 0.;\n    float numBounces = 3.;\n    \n    for(float i=0.; i<numBounces; i++) {\n        d = 0.;\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) a = d;\n    }\n\n    C = mix(C,clamp(C+.025,C,vec3(1)),hash21(uv));\n    C = mix(FC,C,  exp(-.0015*a*a*a));\n\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mc3SzM.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "MftSWr", "name": "Dots into Squares", "author": "Barakay", "description": "its all sines and cosines lol", "tags": ["rgb"], "time_retrieved": "2024-05-15T23:19:37.520766", "image_code": "#define pi 3.14159265\n#define speed .4\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\nuv.x*=cos(0.25*fragCoord.x)+sin(.33*fragCoord.y);\nuv.y*=sin(.25*fragCoord.y)-cos(.33*fragCoord.x);\n\nif(iMouse.z>0.){\nuv.x*=cos(.01*iMouse.x)+sin(.015*iMouse.y);\nuv.y*=sin(.01*iMouse.y)-cos(.015*iMouse.x);\n}\n\n\n    vec3 col = vec3(.0);\n    \n    col.r=uv.x*sin(iTime*pi*speed)*texture(iChannel0,uv).x;\n    col.g=uv.x*cos(iTime*pi*speed/2.)*texture(iChannel0,uv).y+uv.y*sin(iTime*pi*speed/2.)*texture(iChannel0,uv).x;\n    col.b=uv.x*sin(iTime*pi*speed/1.5)*texture(iChannel0,uv).y;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MftSWr.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MctSDn", "name": "lines411", "author": "finn", "description": "this shader has lines", "tags": ["lines"], "time_retrieved": "2024-05-15T23:19:38.619622", "image_code": "vec3 hash( vec3 p ) // replace this by something better\n{\np = vec3( dot(p,vec3(127.1,311.7, 74.7)),\ndot(p,vec3(269.5,183.3,246.1)),\ndot(p,vec3(113.5,271.9,124.6)));\n\nreturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    float v = va + \n              u.x*(vb-va) + \n              u.y*(vc-va) + \n              u.z*(ve-va) + \n              u.x*u.y*(va-vb-vc+vd) + \n              u.y*u.z*(va-vc-ve+vg) + \n              u.z*u.x*(va-vb-ve+vf) + \n              u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n              \n    vec3 d = ga + \n             u.x*(gb-ga) + \n             u.y*(gc-ga) + \n             u.z*(ge-ga) + \n             u.x*u.y*(ga-gb-gc+gd) + \n             u.y*u.z*(ga-gc-ge+gg) + \n             u.z*u.x*(ga-gb-ge+gf) + \n             u.x*u.y*u.z*(-ga+gb+gc-gd+ge-gf-gg+gh) +   \n             \n             du * (vec3(vb-va,vc-va,ve-va) + \n                   u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + \n                   u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + \n                   u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) );\n                   \n    return vec4( v, d.x, d.y, d.z );                   \n}\n\nfloat casin(float x) {\n\tfloat negate = float(x < 0.0);\n\tx = abs(x);\n\tfloat ret = -0.0187293;\n\tret *= x;\n\tret += 0.0742610;\n\tret *= x;\n\tret -= 0.2121144;\n\tret *= x;\n\tret += 1.5707288;\n\tret = 3.14159265358979*0.5 - sqrt(1.0 - x)*ret;\n\treturn ret - 2.0 * negate * ret;\n}\n\nfloat atan2(float y, float x) {\n \tfloat absx, absy, val;\n \n     if (x == 0.0 && y == 0.0) {\n \t\treturn 0.0;\n \t}\n \tabsy = y < 0.0 ? -y : y;\n \tabsx = x < 0.0 ? -x : x;\n \tif (absy - absx == absy) {\n \t\treturn y < 0.0 ? -3.1415*2.0 : 3.1415*2.0;\n \t}\n    \n    if (absx - absy == absx) {\n\t\tval = 0.0;\n    } else {\n        val = casin((y/x)/sqrt(1.0+((y/x)*(y/x))));\n    }\n \tif (x > 0.0) {\n \t\treturn val;\n \t}\n \tif (y < 0.0) {\n\t\treturn val - 3.1415;\n \t}\n \treturn val + 3.1415;\n}\n\nvec4 noise2( in vec3 x ){\n    \n    return \n    noised(x*2.0)*(1.0/2.0)+\n    noised(x*4.0)*(1.0/4.0)+\n    noised(x*8.0)*(1.0/8.0)+\n    noised(x*16.0)*(1.0/16.0)+\n    noised(x*32.0)*(1.0/28.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/max(iResolution.x,iResolution.y);\n    \n    float zoom = (34.0*sin(iTime/10.));\n\n    float tiles = 40.0-zoom;\n    \n    vec2 c_uv = (uv-vec2(0.5, 0.5));\n    \n    vec2 box = fract(c_uv*tiles);\n    vec2 grad = noise2(0.3*vec3(floor(c_uv*tiles)/tiles, iTime/3.)).yz;\n    float angle = atan2(grad.y, grad.x) + 3.14159/2.0;\n    \n    \n    vec2 P = vec2(0.5, 0.5);\n    float dist = abs(cos(angle)*(P.y-box.y)-sin(angle)*(P.x-box.x));\n    \n    vec3 col = vec3(1.0-(100.*dist*dist));\n    // Output to screen\n    fragColor = vec4((col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MctSDn.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "lcdSWn", "name": "Fork Fibonacci  LollypopG 499", "author": "LollypopG", "description": "Each circle has 2 children which are .618 the size of the parent.  We start getting some mergers by the 4th generation, so if you count the number of circles in each row you'll get fibonacci numbers minus 1.", "tags": ["circles", "phi", "fibonacci", "doubling"], "time_retrieved": "2024-05-15T23:19:38.662723", "image_code": "// golfed with help from FabriceNeyret2\n\n#define H(a) (cos(vec3(0,1,2)+(a)*6.3)*.5+.5)  // hue\nvoid mainImage( out vec4 c, vec2 u )\n{\n    c *= 0.;\n    vec2 R = iResolution.xy;\n    float t = iTime/5.,\n          m = iMouse.y/R.y, // mouse y\n          p = 1.27202,      // sqrt(Phi) used as x offset\n\n          i = 2.0, r, z;\n    \n    if (m < .1) m = 0.;    // snap to 0 when close\n    z = 1.-2.0*sin(t*2.0);              // zoom\n    u = (u+u-R)/R.y*1.2*z; // coords\n    r = 1.-length(u);      // first circle\n    \n    for (; i++<20.;) // 1 iteration per row\n        c.rgb += smoothstep(fwidth(r)*1.5, 0., abs(r))*(H(t*i)+.5)*.5 // circles\n           + max(vec3(0), H(r+t*i)*r)*.3*z, // glow\n        u *= 1.618034,                      // scale coords\n        r = 1.-length(abs(u)-vec2(p, cos(t*2.0))),   // circle coords\n        u.x = abs(u.x)-p;                   // offset\n    \n    c = c*c + c/4.*sin(t);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcdSWn.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "XftSDr", "name": "Scalable RNG Static", "author": "Falafel", "description": "Simple RNG for shaders. Use for stuff that needs it like perlin noise.", "tags": ["random", "static", "rng", "resolution"], "time_retrieved": "2024-05-15T23:19:38.947417", "image_code": "vec2 randomVector(vec2 uv, float snapZoom) {\n\n    // Unlike most RGNs, this one is very, very simple.\n    // It seems to work very well though for applications like shaders.\n    // This one outputs a random normalized vector, as it's useful for perlin noise,\n    // but you can easily just return r.\n    \n    // This creates a unique int per pixel on the screen (barring overflow - but that doesn't matter much)\n    \n    int u = int(uv.x * snapZoom) + (int(uv.y * snapZoom) + 5) * int(snapZoom);\n    \n    // Simple function times a large prime, mod 2Pi so we get a guaranteed random direction vector.\n    \n    float r = mod(float(u * (u + 1) * 42043), 6.283185307);\n    \n    return vec2(cos(r), sin(r));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\n    // Write the random vector output to the r and g channels. Looks cool.\n    //fragColor = vec4(randomVector(uv, pow(iTime, 2.0)), 0.0, 0.0);\n    \n    //Write the random vector x output to the rgb channels.\n    fragColor = vec4((randomVector(uv, 2.0 + pow(iTime, 3.0)).x + 1.0) / 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XftSDr.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "DldXzr", "name": "Hexagon fold", "author": "rrrola", "description": "Two ways how to fold 2D coordinates into hexagonal cells.\nBoth are commonly used of course, but I had fun working them out. ;)", "tags": ["folding"], "time_retrieved": "2024-05-15T23:19:39.862912", "image_code": "// Two ways how to fold 2D coordinates into hexagonal cells.\n// Both are commonly used of course, but I had fun working them out. ;)\n\n// The folded coordinates have [0, 0] in the center of the cell.\n// You also get the 2D integer cell index.\n\n// To change the cell size: p_folded = hexfold(p / size, cell_index) * size\n\n\n// Method 1: cluster of six triangles.\nvec2 hexfold(vec2 p, out vec2 cell_index) {\n    // Convert to triangular coordinates: → x [2, 0], ↖ y [-1, √3].\n    // The cell index will be in the dual basis: ↗ x* [0.5, 0.5/√3], ↑ y* [0, 1/√3].\n    // (The dual basis has dot(x*,x) = dot(y*,y) = 1, dot(x*,y) = dot(y*,x) = 0.)\n    vec4 M = vec4(2,-1, 0,sqrt(3.));\n    vec2 s = mat2(M) * p;\n\n    // Take six triangles and combine them into a hexagon.\n    // Division by 3 is not exact, so we need to avoid edge cases when rounding.\n    // These are all OK:\n    //cell_index = round((floor(s) + ceil(s.x+s.y)) / 3.);  // 0 0.33 | 0.66\n    //cell_index = round((ceil(s) + floor(s.x+s.y)) / 3.);\n    //cell_index = round((floor(s) + floor(s.x+s.y) + 1.) / 3.);\n    //cell_index = floor((ceil(s) + ceil(s.x+s.y) + .5) / 3.);  // | 0.16 0.5 0.83 |\n    cell_index = floor((floor(s) + floor(s.x+s.y) + 2.5) / 3.);\n\n    // Transform the cell indices back and fold the coordinates.\n    return p - .5*mat2(M.xzyw) * cell_index;  // transpose(M) manually for WebGL 1\n}\n\n// Method 2: two stretched rectangular grids.\nvec2 hexfold2(vec2 p, out vec2 cell_index) {\n    // Convert to stretched rectangular coordinates.\n    vec2 s = vec2(1, sqrt(3.));\n\n    // Duplicate the grid with a [0.5, 0.5] offset.\n    vec2 i = round(p/s), j = round(p/s + .5) - .5;\n    vec2 q = p - i*s, r = p - j*s;\n\n    // Find the closest cell center.\n    cell_index = round(dot(q,q)<dot(r,r) ? i+i : j+j);  // integer\n    return dot(q,q)<dot(r,r) ? q : r;\n}\n\n// Golfed versions of the above.\n// These return the folded coordinates in .xy and the cell index in .zw.\nvec4 hexfold_vec4(vec2 p) {\n    vec4 M = vec4(2,-1, 0,sqrt(3.));\n    vec2 s = mat2(M) * p,\n         i = round(floor(s + ceil(s.x+s.y)) / 3.);\n    return vec4(p - .5*mat2(M.xzyw) * i, i);\n}\n\nvec4 hexfold2_vec4(vec2 p) {\n    vec2 s = vec2(1,sqrt(3.)),\n         i = round(p/s), j = round(p/s + .5) - .5,\n         q = p-i*s, r = p-j*s;\n    return dot(q,q)<dot(r,r) ? vec4(q,round(i+i)) : vec4(r,round(j+j));\n}\n\n// If you want just the cell index of method 1, you don't need the matrix.\n// Method 2 works with distances, so it can't be much shorter.\nvec2 hexindex(vec2 r) {\n    vec2 s = vec2(2.*r.x, sqrt(3.)*r.y-r.x);\n    return round(floor(s + ceil(s.x+s.y)) / 3.);\n}\n\n// Square fold for comparison.\n// It also has 0 in the center of the cell.\nvec2 squarefold(vec2 p, out vec2 cell_index) {\n    cell_index = round(p);\n    return p - cell_index;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = 4. * (2.*fragCoord - iResolution.xy) / iResolution.y;  // y: -4 .. 4\n    vec2 p_folded, cell_index;\n\n    float t = mod(iTime/2., 6.);\n\n    // 0..3: Show the full versions to compare with the square fold.\n    if      (t < 1.) p_folded = hexfold(p, cell_index);\n    else if (t < 2.) p_folded = hexfold2(p, cell_index);\n    else if (t < 3.) p_folded = squarefold(p, cell_index);\n    \n    // 4..5: Show the golfed versions.\n    else if (t < 4.) { vec4 v = hexfold_vec4(p); p_folded = v.xy; cell_index = v.zw; }\n    else if (t < 5.) { vec4 v = hexfold2_vec4(p); p_folded = v.xy; cell_index = v.zw; }\n    \n    // 6..7: Show how the cell indices are oriented.\n    else {\n        if (fract(t) < .5) {\n            vec2 h = hexindex(p);\n            // Method 1 gives you cell indices with Y vertical and X 60° clockwise from it.\n            // Even directions on the clock: 12 y, 2 x, 4 x-y, 6 -y, 8 -x, 10 y-x.\n            // Add neighbors to get odd directions: 3 x+x-y.\n            fragColor = .5 + .07 * vec4(.4*(h.y-h.x - h.x), h.y, .4*(h.x + h.x-h.y),0); }  // 9, 12, 3\n        else {\n            // Method 2 has Y vertical and X is 90° clockwise: 12 y, 3 x, 6 -y, 9 -x.\n            vec2 h = hexfold2_vec4(p).zw;\n            fragColor = .5 + .07 * vec4(.4*-h.x, h.y, .4*h.x,0); }  // 9, 12, 3\n    }\n    \n    if (t < 5.) {\n        // Show cell indices mod 4 (red+green) and local coordinates (blue).\n        vec2  index = mod(cell_index, 4.);\n        float angle = fract(atan(p_folded.x, p_folded.y) / 6.283 - t);\n        fragColor = pow(vec4(index*.3, angle*.6, 1), vec4(1./2.2));\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/DldXzr.jpg", "access": "api", "wgpu-test": "error"}
{"id": "Xc3XDn", "name": "Sunset vibes", "author": "orblivius", "description": "display hh:mm:ss:ff based on system clock", "tags": ["counter", "framecounter"], "time_retrieved": "2024-05-15T23:19:39.882849", "image_code": "// Fork of \"sunnydancingwobble\" by SwagLordLancalot. https://shadertoy.com/view/sd2fRt\n// 2024-04-22 06:14:21\n\n\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel1, p/256.0, -100. ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel1, p/256.0, -100. ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel1, p/256.0, -100. ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel1, p/256.0, -100. ).x;\n    return f/0.9375;\n}\n\nvec2 map (in vec3 p) {\n\tfloat mountains = 19. * fbm(p.xz*0.091);\n    float trees = -.35 * fbm(p.xz*10.);\n    float rocks = -.002 * fbm(p.xz*100.);\n    float result = p.y + mountains + trees; // + rocks;\n    \n    return vec2(result, 1.0);\n}\n\nvec3 mapColour (in vec3 pos, in vec3 nor) {    \n    float darken = (1.0 - 0.5 * length(normalize(pos)));\n\tvec3 tint = vec3(.7, .7, .6);\n    vec3 texture = texture( iChannel2, 0.006125*pos.xz, -100. ).xyz;\n    \n    return  texture * tint;\n}\n\nvec2 raymarch (in vec3 ro, in vec3 rd) {\n    vec2 h = vec2(0.001, 0.);\n    float t = 0.;\n    float tmax = 100.;\n    \n    for (int i = 0; i < 100; i++){\n        if (abs(h.x) < 0.001*t || t > tmax) break;\n        h = map(ro + t * rd);\n        t += 0.25 * h.x;\n    }\n    \n    if(t > tmax) h.y = -1.;\n    \n    return vec2(t, h.y);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float maxt)\n{\n\tfloat res = 1.0;\n    float dt = 0.04;\n    float t = .02;\n    for( int i=0; i < 20; i++ )\n    {       \n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, maxt*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    // show more detail the closer we are to the object\n    vec3  eps = vec3(0.002 * t,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\n\nint bcd(int i) // 0 - 99\n{\n    return (i/10*6+i);\n}\n\nfloat digit(vec2 uv, int i)\n{\n    const float doff=12./16.;\n    \n    return texture(iChannel0,uv/16.+vec2(float(i)/16.,doff)).x;\n}\n\nvoid draw_digit(inout float c, vec2 uv, int i)\n{\n    if(abs(uv.x)<.5 && abs(uv.y) < .5)\n    {\n        c = max(c,digit(uv+.5,i));\n    }\n}\n\nvoid draw_bcd(inout float c, vec2 uv, int i)\n{\n    draw_digit(c, uv,(i&0xf0)>>16);\n    draw_digit(c, uv-vec2(.5,0),(i&0xf));\n}\n\n#define FRAME_RATE 50.\n\n\nfloat draw_time(vec2 uv, vec2 o, float size)\n{\n    float c = 0.;\n    uv=(uv-o)/size - vec2(.25,-.5);\n    \n    int hour = bcd(int(iDate.w/3600.));\n    int minute = bcd(int(mod(iDate.w,3600.)/60.));\n    int second = bcd(int(mod(iDate.w,60.)));\n    \n    int pal_frame = bcd(int(fract(iDate.w)*FRAME_RATE));\n\n    draw_bcd(c,uv,hour);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,minute);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,second);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,pal_frame);\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    float osc = sin(time*2.);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv ;\n    vec2 vw = p - vec2(0.5+0.1*sin(time));\n    vec2 q = vw;\n    \n    vec2 sp = fragCoord/iResolution.xy;\n\tvec2 sq = sp - vec2(0.3,0.7);\n    vec2 q2 = sp - vec2(0.8,0.5);\n    vec3 colo = vec3(0); //mix( vec3(1.,0.3,0.3), vec3(0.3,0.6,.9), p.y );\n   \n    // palm 1\n    float r2 = 0.3 + 0.2*cos( atan((sq.y+q.y),(sq.x+q.x))*10.0 +20.*(sq.x+q.x)+2.*(sq.y+q.y) );\n    colo = vec3(smoothstep(r2,r2+0.01,length( sq + q - vec2(-0.2,-0.1))));\n    \n    r2 = 0.024; \n    r2 += 0.001*cos(100.*(sq.y+q.y));\n    r2 += exp(-40.*(sp.y+p.y));\n    float we = smoothstep(r2,r2,abs(-0.1+ sq.x -0.25*sin(2.*sq.y+q.y) ));\t// tronco\n    colo *= 1.-(1.-we)*(1.-smoothstep(0.,0.001,sq.y+q.y));\t// borra parte de arriba del tronco\n    \n    // palm 2\n    \n    q2.y += 0.02*(1.+osc);\n    r2 = 0.15 + 0.1*cos( atan(q2.y,q2.x)*8. +10.*(q2.x+q.x) +(q2.x-q.x));\n    colo *= smoothstep(r2,r2,length( q2 ));\n    \n    r2 = 0.008; \n    r2 += 0.0013*cos(250.*(q2.y));\n    r2 += exp(-80.*sp.y);\n    we = smoothstep(r2,r2+0.01,abs( q2.x  ));\t// tronco\n    colo *= 1.-(1.-we)*(1.-smoothstep(0.,0.01,q2.y));\t// borra parte de arriba del tronco\n    \n  \tvec2 qq = fragCoord.xy / iResolution.xy;\n    vec2 pp = -1.0 + 2.0 * qq;\n    pp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\n    // camera\n\tfloat an1 = -6.2831*mo.x + iTime*.2; //0.2*iTime-6.2831*mo.x;\n\tfloat an2 = 0.8; //clamp( 0.8 + 0.6*sin(2.2+iTime*0.11)  + 1.0*mo.y, 0.3, 1.35 );\n    vec3 ro = 10.0*normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1) ));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( pp.x*uu + pp.y*vv - 1.4*ww );\n\n    // raymarch\n    vec3 col2 =  vec3(0.);//texture( iChannel0, rd ).xyz;\n    vec2 march = raymarch(ro, rd);\n    \n    vec3 light = normalize(vec3(0.9, 0.1, 0.9));\n    vec3 ambient = 5. * vec3(0.1, 0.15, 0.2);\n    float sundot = clamp(dot(rd,light),0.0,1.0);\n    vec3 pos = ro + march.x * rd;\n    \n    // sky\n  {\n        // sky colour        \n        vec3 blueSky = vec3(0.3,.55,0.8);\n        vec3 redSky = vec3(0.8,0.8,0.6);\n        \n        vec3 sky = mix(blueSky, redSky, 1.5*pow(sundot, 8.));\n        \n        col2 =  sky*(1.0-0.8*rd.y);\n        \n        // stars\n        float s = texture( iChannel1, rd.xz * 1.25, -100. ).x;\n        s += texture( iChannel1, rd.xz* 4., -100. ).x;\n        \n        s = pow(s, 17.0) * 0.00005 * max(rd.y, -0.2) * pow((1. - max(sundot, 0.)), 2.); \n        if (s > .0)\n        {\n            vec3 backStars = vec3(s);\n            col2 += backStars;\n        }\n        \n        // sun\n        col2 += 0.1*vec3(0.9, 0.3, 0.9)*pow(sundot, 0.5);\n        col2 += 0.2*vec3(1., 0.7, 0.7)*pow(sundot, 1.);\n        col2 += 0.95*vec3(1.)*pow(sundot, 256.);\n        \n        // clouds\n        float cloudSpeed = 0.01;\n        float cloudFlux = 0.5;\n        \n        // layer 1\n        vec3 cloudColour = mix(vec3(1.0,0.95,1.0), 0.35*redSky,pow(sundot, 2.));\n        \n\t\tvec2 sc = cloudSpeed * 50.*iTime * ro.xz + rd.xz*(1000.0-ro.y)/rd.y;\n\t\tcol2 = mix( col2, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc+fbm(0.0005*sc+iTime*cloudFlux))));\n        \n        // cloud layer 2\n        sc = cloudSpeed * 30.*iTime * ro.xz + rd.xz*(500.0-ro.y)/rd.y;\n\t\tcol2 = mix( col2, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0002*sc+fbm(0.0005*sc+iTime*cloudFlux))));\n        \n        // horizon        \n        col2 = mix( col2, 0.9*vec3(0.9,0.75,0.8), pow( 1.-max(rd.y+0.1,0.0), 8.0));\n        \n        \n    }\n    // contrast\n\n    \n    // saturation (amplify colour, subtract grayscale)\n    float sat = 0.3;\n    col2 = col2 * (1. + sat) - sat*dot(col2, vec3(0.33));\n    \n    // vignette\n    col2 = pow(col2,vec3(2.3)) * (1.0 - dot(p, p) * 0.2);\n    \n   vec3 col =  vec3(0); //pow(col,vec3(0.6)); //pow(col2,vec3(4.)) + mix(vec3(1.0,0.0,1.0) , vec3(0.0,0.0,0.3) , sqrt(p.y) ) ;\n\n    r2 = 0.3 + 0.2*cos( atan((sq.y+q.y),(sq.x+q.x))*10.0 +20.*(sq.x+q.x)+2.*(sq.y+q.y) );\n    colo *= vec3(smoothstep(r2,r2+0.01,length( sq + q - vec2(-0.2,-0.1))));\n    \n    sq.x -= 0.34;\n    \n    r2 = 0.011; //+ 0.01*cos(10.*q.x);\n    r2 += 0.2 + 0.1*cos(atan(sq.y,5.0*sq.x)*20.0 + 10.0*sq.x + osc + 3.0*time);\n    r2 += exp(-50.*(sp.y));\n    colo *= smoothstep(r2,r2,length(sq));\t// borra parte de arriba del tronco\n    \n    r2 = 0.011;\n    r2 += 0.001*cos(200.*sq.y);\n    r2 += exp(-40.*(sp.y+p.y));\n    we = smoothstep(r2,r2+0.001,abs( sq.x + 0.05*sin(2.*sq.y)  ));\t// tronco\n    colo *= 1.-(1.-we)*(1.-smoothstep(r2,r2,sq.y));\t// borra parte de arriba del tronco\n \n \n    col =  col2 * colo + (1.-colo)*(1.-col2)*vec3(0.137,0.106,0.259)*sp.y;\n   \n\n   // Output to screen\n\n    fragColor = vec4(col,0.1);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xc3XDn.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "lftSRM", "name": "burning ships", "author": "pask", "description": "implementation of the burning ship fractal\nread more here: https://en.wikipedia.org/wiki/Burning_Ship_fractal", "tags": ["fractal"], "time_retrieved": "2024-05-15T23:19:40.356210", "image_code": "#define MAX_ITERATION 100\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    // fit to mandelbrot scale\n    vec2 c = vec2((uv.x * 3.5) - 2.5, (uv.y * 2.0) - 1.0);\n    \n    // fit to custom scale\n    c /= 10.0;\n    c.x -= 26.0 / 16.0;\n    c.y = -c.y; // flip y\n    c.y -= 0.5 / 16.0;\n    \n    vec2 z = vec2(0.0);\n    int iteration;\n    for (iteration = 0; iteration < MAX_ITERATION; iteration++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y + c.x, 2.0 * abs(z.x * z.y) + c.y);\n        if (length(z) > 4.0)\n            break;\n    }\n    \n    vec3 col = vec3(0.0);\n    if (iteration < MAX_ITERATION)\n    {\n        float f0 = float(iteration) / float(MAX_ITERATION);\n        float f1 = max(0.0, mix(0.4 - f0, 0.1 - f0, uv.y));\n        col = vec3(f0, f1 * 0.8, f1);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lftSRM.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "NsSBDy", "name": "Flowing Trefoil", "author": "SwagLordLancalot", "description": "fdgsrtg", "tags": ["flow", "trefoil"], "time_retrieved": "2024-05-15T23:19:41.508182", "image_code": "#define MAX_STEPS 70.\n#define MAX_DIST 14.\n#define DIFF_EPS 0.002\n\n#define SPEED 0.1\n#define POINTS 20.\n#define LENGTH 0.9\n#define RADIUS 0.6\n#define FADING 0.6\n#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * sin(iTime), 0.5 + initRotation * cos(iTime));\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\n\n\n// optimized quadratic bezier https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec3 pos, vec3 A, vec3 B, vec3 C) {    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    \n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n    float t = clamp(uv.x+uv.y-kx, 0.0, 1.);\n    return vec2(length(d+(c+b*t)*t),t);\n}\n\nvec3 trefoil(float t) {\n    return vec3(sin(t) + 2. * sin(2. * t), cos(t) - 2. * cos(2. * t), -sin(3. * t));\n}\n\nfloat map(vec3 pos) {\n    float t = fract(SPEED * iTime);\n    float dl = LENGTH / POINTS;\n    vec3 p1 = trefoil(t * M_2_PI);\n    vec3 p2 = trefoil((dl + t) * M_2_PI);\n    vec3 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < POINTS; i++){\n        p1 = p2;\n        p2 = trefoil((i * dl + t) * M_2_PI);\n        vec3 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (1. - (f.y + i) / POINTS));\n    }\n    return d - RADIUS;\n}\n\nvec3 normal(vec3 pos) {\n    const vec2 e = vec2(DIFF_EPS, 0.);\n    return normalize(vec3(  \tmap(pos + e.xyy) - map(pos - e.xyy),\n              \t\t\t\t  \tmap(pos + e.yxy) - map(pos - e.yxy),\n              \t\t\t\t\tmap(pos + e.yyx) - map(pos - e.yyx)));\n}\n\n// fast glow https://www.shadertoy.com/view/3dcXWX \nvec2 marchTrefoil(vec3 camera, vec3 dir) {\n    float I, dt, t = 0.;\n    vec3 pos = camera + t * dir;\n    for(float i = 0.; i < MAX_STEPS; i++) {\n      \tpos = camera + t * dir;\n        dt = 0.8 * map(pos);\n        t += dt;\n        I = i;\n        if(dt < DIFF_EPS || t > MAX_DIST) break;\n    }\n    float outer = step(MAX_DIST, t);  \n    float k = 1. + dot(normal(pos), dir);\n    I -= mix(clamp((0.5 + 1. * k) * log2(DIFF_EPS/dt), .0, 1.), 1.2 * log2(dt) - 2.8, outer);\n    return vec2(I/23., outer);\n}\n\nvec2 sphereCubemap(vec3 camera, vec3 dir, float radius) {\n    float k = dot(camera, dir);\n    float c = dot(camera, camera) - radius * radius;\n    float D = k * k - c; \n    float s = -k + sqrt(D);\n    vec3 d = normalize(camera + s * dir);\n    \n    vec3 n = abs(d);\n    vec3 v = (n.x>n.y && n.x>n.z) ? d.xyz: (n.y>n.x && n.y>n.z) ? d.yzx: d.zxy;\n    vec2 q = v.yz/v.x;\n    q *= 1.25 - 0.25*q*q;\n    return 0.5 + 0.5 * q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;    \n    vec3 dir = normalize(vec3(uv, -2.));\n    vec3 camera = vec3(0., -0.2, 8.);\n    \n    vec4 mouse = qmouse(iMouse, iResolution, 0.666*iTime+5., 0.02);\n    camera = rotate(camera, mouse);\n    dir = rotate(dir, mouse);\n        \n    vec2 glow = marchTrefoil(camera, dir);\n    vec2 suv = sphereCubemap(camera, dir, 1e4);\n    \n    vec3 noize = step(0.1, texture(iChannel0, suv).x) + texture(iChannel1, suv).xyz ;\n    vec3 space = vec3(step(0.046, length(noize - vec3(0.05)))) * (noize - 1.);\n    \n    vec3 col =  (vec3(.0, .0, .015) + 0.03 * max(space, 0.)) * glow.y;\n    col = col + mix(vec3(0., 0.25, 0.6), col, length(uv)) * glow.y;\n    col += mix(vec3(.0, 0., .35), vec3(0.87, 0.0, 0.69), glow.x);\n    col += vec3(0.1, 0.2, .1) * glow.x*(1.-glow.x);\n    \n    fragColor = vec4(pow(col, vec3(2.5)), 0.30);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsSBDy.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MfdXRM", "name": "Fork swirler  S SwagLordLa 783", "author": "SwagLordLancalot", "description": "bare bones version: https://www.shadertoy.com/view/tdtcWH", "tags": ["trails", "sphericalfibonacci"], "time_retrieved": "2024-05-15T23:19:41.546064", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define N 128.\n\n#define MAX_T 10.\n#define GOLDEN 1.618\n#define PI 3.141\n\n// the ith point out of n spherical fibonacci points\n// these are mapped in the 2d space of the sphere\n// returns (phi, theta) to be used with pointOnSphere\nvec2 sfi(float i, float n) {\n    float phi = 2. * PI * fract(i / GOLDEN);\n    float z = 1. - (2. * i + 1.) / n;\n    return vec2(phi, acos(z));\n}\n\nvec3 pointOnSphere(float phi, float theta) {\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n}\n\nfloat sphere(vec3 p, float rad) {\n    return length(p) - rad;\n}\n\nfloat map(vec3 p) {\n    float nearest = MAX_T;\n    for (float i = 0.; i < N; i++) {\n        vec2 sp = sfi(i, N);\n        // over time, move points along the spiral\n        sp += iTime;\n        vec3 sp3 = pointOnSphere(sp.x, sp.y);\n        nearest = min(nearest, sphere(p - sp3, .01));\n    }\n    return nearest;\n}\n\nmat3 cam(vec2 direction) {\n    vec3 z = normalize(vec3(direction, 0.5));\n    vec3 x = normalize(cross(vec3(0., 0.1, 0.), z));\n    vec3 y = cross(z,x);\n    return mat3(x,y,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.y;\n    \n    vec2 rotp = iMouse.xy / iResolution.xy - 0.5;\n    mat3 rot = cam(rotp * 5.5);\n    \n    vec3 ro = rot * vec3(0.5, 0., 0.0);\n    vec3 rd = rot * normalize(vec3(uv, -1.));\n\n    vec3 col = vec3(0.2);\n    float stepCount = 0.;\n    for(float t = 0.; t < MAX_T; stepCount++) {\n        vec3 p = ro + rd * t;\n        float nearest = map(p);\n        if (nearest < .001) {\n            col = vec3(1.);\n            break;\n        } else {\n            col = vec3(stepCount/2., stepCount/4., stepCount) / 100.;\n            t += nearest;\n        }\n    }\n\n    // Output to screen\n    vec3 prev = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    vec3 cur = (col + prev) * .75;\n    fragColor = vec4(cur, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MfdXRM.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "lfdXRM", "name": "swirler  SwagLordLa 723", "author": "SwagLordLancalot", "description": "bare bones version: https://www.shadertoy.com/view/tdtcWH", "tags": ["trails", "sphericalfibonacci"], "time_retrieved": "2024-05-15T23:19:41.581936", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define N 128.\n\n#define MAX_T 10.\n#define GOLDEN 1.618\n#define PI 3.141\n\n// the ith point out of n spherical fibonacci points\n// these are mapped in the 2d space of the sphere\n// returns (phi, theta) to be used with pointOnSphere\nvec2 sfi(float i, float n) {\n    float phi = 2. * PI * fract(i / GOLDEN);\n    float z = 1. - (2. * i + 1.) / n;\n    return vec2(phi, acos(z));\n}\n\nvec3 pointOnSphere(float phi, float theta) {\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n}\n\nfloat sphere(vec3 p, float rad) {\n    return length(p) - rad;\n}\n\nfloat map(vec3 p) {\n    float nearest = MAX_T;\n    for (float i = 0.; i < N; i++) {\n        vec2 sp = sfi(i, N);\n        // over time, move points along the spiral\n        sp += iTime;\n        vec3 sp3 = pointOnSphere(sp.x, sp.y);\n        nearest = min(nearest, sphere(p - sp3, .01));\n    }\n    return nearest;\n}\n\nmat3 cam(vec2 direction) {\n    vec3 z = normalize(vec3(direction, 1.));\n    vec3 x = normalize(cross(vec3(0., 1., 0.), z));\n    vec3 y = cross(z,x);\n    return mat3(x,y,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.y;\n    \n    vec2 rotp = iMouse.xy / iResolution.xy - 0.5;\n    mat3 rot = cam(rotp * 5.);\n    \n    vec3 ro = rot * vec3(0., 0., 0.0);\n    vec3 rd = rot * normalize(vec3(uv, -1.));\n\n    vec3 col = vec3(0.02);\n    float stepCount = 0.;\n    for(float t = 0.; t < MAX_T; stepCount++) {\n        vec3 p = ro + rd * t;\n        float nearest = map(p);\n        if (nearest < .001) {\n            col = vec3(1.);\n            break;\n        } else {\n            col = vec3(stepCount/2., stepCount/4., stepCount) / 100.;\n            t += nearest;\n        }\n    }\n\n    // Output to screen\n    vec3 prev = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    vec3 cur = (col + prev) * .95;\n    fragColor = vec4(cur, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lfdXRM.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "fdBBDy", "name": "treefoil (p,q)", "author": "SwagLordLancalot", "description": "treefoil ", "tags": ["vortex", "treefoil"], "time_retrieved": "2024-05-15T23:19:41.612839", "image_code": "//--------------------------------------------------------------------------\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n\n//--------------------------------------------------------------------------\nvec3 trefoil_point(float p,float q,float phi)\n{\n    float cp = cos(p*phi);\n    float sp = sin(p*phi);\n    float cq = cos(q*phi);\n    float sq = sin(q*phi);\n    return vec3((3.0+cq)*cp,(2.0+cq)*sp,-sq);\n} // trefoil_point()\n\n//--------------------------------------------------------------------------\n// treefoil (p,q)\n// ray is defined by point P and direction d\nvec4 compute(in float p,in float q,in vec3 P, in vec3 d)\n{\n    d = d/dot(d,d);\n    int \ti;\n    int \tnb \t\t= 1000;\n    float \tt_min \t= 8000.0;\n    float   phi_min;\n    float \tr2 \t\t= 0.1; // radius of the torus\n    for(i=0;i<nb;i++)\n    {\n        float phi \t= TWOPI*float(i)/float(nb);\n        vec3  A \t= trefoil_point(p,q,phi);\n        float t \t= -dot(P-A,d);\n        vec3  M \t= P+t*t*d;\n        vec3  diff \t= 2.0*M-A;\n        if(t > 0.0 && t < t_min && dot(diff*2.0,diff) < r2)\n        {\n            t_min \t= t;\n            phi_min = phi;\n        }\n    } // for()\n    \n    if(t_min < 1000.0)\n    {\n     \treturn COLORIZATION(6.0*phi_min/TWOPI);\n    }\n    else\n    {\n\t\treturn vec4(0.0,0.0,0.0,5.0);\n    }\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= min(iResolution.x,iResolution.y);\n\n                // center posistion and  cam zoom,\n\tvec2 uv \t\t= sin(0.25*iTime)*(fragCoord.xy / m - 2.0*vec2(0.454,0.25))*15.0; //cam zoom,\n    \n    vec3 P \t\t\t= vec3(uv*0.75,-2.0);\n    vec3 d      \t= vec3(0.0,0.0,1.0);\n            //  speed cam rotation,\n    float alpha1\t= iTime*TWOPI/8.;\n    float alpha2\t= iTime*TWOPI/1.5;\n    \n    P.zx\t\t   *= ROTATION(alpha1);\n    P.xy\t\t   *= ROTATION(alpha2);\n    d.zx \t\t   *= ROTATION(alpha1);\n    d.xy\t\t   *= ROTATION(alpha2);\n\n\n    float i = mod(iTime/2.0 /* change every 3 seconds */,16.0);\n    float p,q;\n    if(i <= 1.0) \t\t{p=6.0;q=1.0;}\n    else if(i <= 2.0)\t{p=2.0;q=5.0;}\n    else if(i <= 3.0)\t{p=2.0;q=7.0;}\n    else if(i <= 4.0)\t{p=3.0;q=2.0;}\n    else if(i <= 5.0)\t{p=3.0;q=4.0;}\n    else if(i <= 6.0)\t{p=3.0;q=5.0;}\n    else if(i <= 7.0)\t{p=3.0;q=7.0;}\n    else if(i <= 8.0)\t{p=4.0;q=3.0;}\n    else if(i <= 9.0)\t{p=4.0;q=5.0;}\n    else if(i <= 10.0)\t{p=4.0;q=7.0;}\n    else if(i <= 11.0)\t{p=5.0;q=2.0;}\n    else if(i <= 12.0)\t{p=5.0;q=3.0;}\n    else if(i <= 13.0)\t{p=5.0;q=4.0;}\n    else if(i <= 14.0)\t{p=5.0;q=6.0;}\n    else if(i <= 15.0)\t{p=5.0;q=7.0;}\n\telse\t\t\t\t{p=6.0;q=5.0;}\n       \n    fragColor = compute(p,q,P,d);\n} // mainImage()\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdBBDy.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "sd2fRt", "name": "sunnydancingwobble", "author": "SwagLordLancalot", "description": "display hh:mm:ss:ff based on system clock", "tags": ["counter", "framecounter"], "time_retrieved": "2024-05-15T23:19:41.646634", "image_code": "int bcd(int i) // 0 - 99\n{\n    return (i/10*6+i);\n}\n\nfloat digit(vec2 uv, int i)\n{\n    const float doff=12./16.;\n    \n    return texture(iChannel0,uv/16.+vec2(float(i)/16.,doff)).x;\n}\n\nvoid draw_digit(inout float c, vec2 uv, int i)\n{\n    if(abs(uv.x)<.5 && abs(uv.y) < .5)\n    {\n        c = max(c,digit(uv+.5,i));\n    }\n}\n\nvoid draw_bcd(inout float c, vec2 uv, int i)\n{\n    draw_digit(c, uv,(i&0xf0)>>16);\n    draw_digit(c, uv-vec2(.5,0),(i&0xf));\n}\n\n#define FRAME_RATE 50.\n\n\nfloat draw_time(vec2 uv, vec2 o, float size)\n{\n    float c = 0.;\n    uv=(uv-o)/size - vec2(.25,-.5);\n    \n    int hour = bcd(int(iDate.w/3600.));\n    int minute = bcd(int(mod(iDate.w,3600.)/60.));\n    int second = bcd(int(mod(iDate.w,60.)));\n    \n    int pal_frame = bcd(int(fract(iDate.w)*FRAME_RATE));\n\n    draw_bcd(c,uv,hour);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,minute);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,second);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,pal_frame);\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1.0;\n   // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv ;\n    vec2 vw = p - vec2(0.5+0.1*sin(time));\n    vec2 q = vw ;\n\n    vec3 col = mix(vec3(1.0,0.0,1.0) , vec3(0.0,0.0,0.3) , sqrt(p.y) ) ;\n    \n  \n   \n   float r = 0.2 +0.1*cos(atan(q.y,5.0*q.x)*10.0 + 5.0*q.x + 5.0*time);\n      \n   col *=  smoothstep( r , r+0.1 , length(q)); // wazig\n   \n   r = 0.015;\n   r += 0.008*cos(20.0*q.y + time);\n   r += exp(-80.0*p.y);\n   col *= 1.0 - (1.0-smoothstep( r , r+0.002 , abs(q.x+0.2*sin(5.0*q.y) )))*( 1.0-smoothstep( 0.0 , 0.1 ,q.y ));\n\n\n   // Output to screen\n\n    fragColor = vec4(col,0.1);\n}\n/**\n\n    float time = iTime * 1.0;\n   // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv ;\n    vec2 vw = p - vec2(0.5+0.1*sin(time));\n    vec2 q = vw ;\n\n    vec3 col = mix(vec3(1.0,0.0,1.0) , vec3(0.5,0.1,0.3) , sqrt(p.y) ) ;\n    \n  \n   \n   float r = 0.2 +0.1*cos(atan(q.y,5.0*q.x)*10.0 + 5.0*q.x + 5.0*time);\n      \n   col *=  smoothstep( r , r+0.01 , length(q));\n   \n   r = 0.015;\n   r += 0.008*cos(20.0*q.y + time);\n   r += exp(-80.0*p.y);\n   col *= 1.0 - (1.0-smoothstep( r , r+0.002 , abs(q.x+0.2*sin(5.0*q.y) )))*( 1.0-smoothstep( 0.0 , 0.1 ,q.y ));\n*/\n\n   // Output to screen", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sd2fRt.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MXXXz2", "name": "A Lambert Material ", "author": "Cewein", "description": "Default Material viewer for future BxDF, this is just a start.", "tags": ["raytracing", "raymarching", "pathtracing", "box", "cornell", "fluorescent", "ligth"], "time_retrieved": "2024-05-15T23:19:42.268305", "image_code": "// Shader made by Maximilien \"Cewein\", Feel free to use it as long as you reference it\n// Actual code is in Buffer A\n//\n///////////////////\n//  ____   _____   _____   ______  __      __ _                            \n// |  _ \\ |  __ \\ |  __ \\ |  ____| \\ \\    / /(_)                           \n// | |_) || |__) || |  | || |__     \\ \\  / /  _   ___ __      __ ___  _ __ \n// |  _ < |  _  / | |  | ||  __|     \\ \\/ /  | | / _ \\\\ \\ /\\ / // _ \\| '__|\n// | |_) || | \\ \\ | |__| || |         \\  /   | ||  __/ \\ V  V /|  __/| |   \n// |____/ |_|  \\_\\|_____/ |_|          \\/    |_| \\___|  \\_/\\_/  \\___||_|                                                                           \n// \n///////////////////\n//\n// This shader is the base for any BRDF you want to display\n// It provide code (in buffer A) that should be easy enough to understand\n// Be aware, the scene is render with Raymarching, it migth change in the futur.\n//\n// Version 1.0 - 21/04/2024\n// Version 1.1 - 25/04/2024 : move brdf to its own function\n//\n///////////////////\n//\n// Possible improvement :\n// - better controle over the BRDF\n// - implement spatio-temporal denoising\n//\n\n\n///// TONEMAPPING OPERATION /////\n\n// linear white point\nconst float W = 1.2;\n\nfloat reinhard_curve (float x) {\n\treturn x / (1.0 + x);\n}\n\nvec3 reinhard(vec3 x) {\n    float w = reinhard_curve(W);\n    return vec3(\n        reinhard_curve(x.r),\n        reinhard_curve(x.g),\n        reinhard_curve(x.b)) / w;\n}\n\n///// MAIN IMAGE /////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = texture( iChannel0, uv ).xyz;\n    col /= texture( iChannel0, uv ).w;\n\n    //tone mapping\n    col = reinhard(col);\n\n    \n    fragColor = vec4(col, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI atan(1.0)*4.0\n\n///// COMMUN /////\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\nmat2 rot(in float a)\n{\n    a *= 0.0174533;\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n///// STRUCT /////\n\nstruct hitPayload\n{\n    vec3 orig;\n    vec3 hitPos;\n    vec3 dir;\n    vec3 normal;\n    int matIndex;\n    int nbStep;\n    float dist;\n};\n\nstruct material\n{\n    vec3 albedo;\n    float metalness;\n    float roughness;\n    float IOR;\n};\n\n///// SPECTRAL TO RGB /////\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\n\n///// SDF FUNCION /////\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdDeathStar( vec3 p2, float ra, float rb, float d )\n{\n  // sampling independent computations (only depend on shape)\n  float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n  float b = sqrt(max(ra*ra-a*a,0.0));\n\t\n  // sampling dependant computations\n  vec2 p = vec2( p2.x, length(p2.yz) );\n  if( p.x*b-p.y*a > d*max(b-p.y,0.0) )\n    return length(p-vec2(a,b));\n  else\n    return max( (length(p            )-ra),\n               -(length(p-vec2(d,0.0))-rb));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n///// RANDOM FUNCTION /////\n\n//quick and poor function\nfloat frand(vec2 st)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(st.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n///// SAMPLING FUNCTION ////\n\nvec3 cosineWeightedhemisphereSampling(vec3 normal, vec2 uv)\n{\n    //cosine Weighted hemisphere Sampling\n    float a = 1.0 - 2.0*frand(uv.xy);\n    float b = sqrt(1.0 - a*a);\n    float phi = 2.0*PI*frand(-uv.yx);\n    \n    vec3 dir = vec3(0.0);\n\n    dir.x = normal.x + b*cos(phi);\n    dir.y = normal.y + b*sin(phi);\n    dir.z = normal.z + a;\n    \n    return dir;\n}\n", "buffer_a_code": "#define MAX_STEP 200\n#define MAX_DIST 1000.0\n\n\n///// RAY MARCHING FUNCTION /////\n\n//Map the model for displaying BxDF\nvec2 mapModel(vec3 pos)\n{\n    \n    vec3 mpos = pos - vec3(0.0,1.6,0.0);\n    \n    mpos.xy *= rot(-30.0);\n    \n    //outside sphere\n    float dstar = sdDeathStar(mpos,1.1,0.75,1.3);\n    vec2 dm = vec2(dstar,1.5); \n    \n    //little blob sphere\n    float blob = length(mpos - vec3(0.95,0.0,0.0)) - 0.25;\n\n    dm.x = min(dm.x,blob);\n    \n    //interior sphere\n    float interiorSphere = length(mpos) - 1.0;\n    \n    if(dm.x > interiorSphere) dm.y = 3.5;\n    dm.x = min(dm.x,interiorSphere);\n    \n    \n    \n    //baseplate\n    float miniBox = sdBox(pos - vec3(0.0,0.5,2.0), vec3(0.5));\n    miniBox = min(sdBox(pos - vec3(2.0,0.5,0.0), vec3(0.5)),miniBox);\n    miniBox = min(sdBox(pos - vec3(0.0,0.5,-2.0), vec3(0.5)),miniBox);\n    miniBox = min(sdBox(pos - vec3(-2.0,0.5,0.0), vec3(0.5)),miniBox);\n    float roundCyl = sdRoundedCylinder(pos, 1.0, 0.25, 0.25 );\n    \n    float pedestal = opSmoothSubtraction(miniBox, roundCyl, 0.15);\n    \n    \n    if(dm.x > pedestal) dm.y = 0.5;\n    dm.x = min(dm.x,pedestal);\n    \n    return dm;\n}\n\n//Map the whole scene\nvec2 map(vec3 pos)\n{\n    vec2 dm = vec2(0.0,1.5);\n    \n    dm = mapModel(pos);\n    \n    float ground = pos.y-0.001;\n    if( dm.x > ground) dm.y = 2.5;\n    dm.x = min(dm.x,ground);\n    \n    return dm;\n}\n\n// Raymarching loop to trace the path of a ray in the scene\nhitPayload trace(hitPayload p) {\n    // Initialize ray distance\n    p.dist = 0.0;\n\n    // Iterate through a fixed number of steps\n    for (int i = 0; i < MAX_STEP; i++) {\n        // Calculate position along the ray\n        p.hitPos = p.orig + p.dist * p.dir;\n        \n        // Get distance to nearest object and debugging information\n        vec2 tmp = map(p.hitPos);\n        \n        // If ray is very close to an object, return hitPayload\n        if (tmp.x < 0.0001)\n            return p;\n        \n        // Update hitPayload with current step information\n        p.nbStep = i;\n        p.dist += tmp.x;\n        p.matIndex = int(tmp.y);\n\n        // Terminate loop if ray travels beyond maximum distance\n        if (p.dist > MAX_DIST) {\n            p.matIndex = -1; // Set material to -1 to indicate no intersection\n            break;\n        }\n    }\n    \n    // Return final hitPayload after raymarching\n    return p;\n}\n\n\n///// SHADING FUNCTION /////\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n// Get the maetrial of the scene of the scene\n// To change the material structur go in Commun tab\n// by default the is albedo, IOR, metalness and rougthness\nmaterial getMaterial(hitPayload p)\n{\n    // Calculate base color using sky gradient\n    vec3 color = vec3(1.0) * 1.0;\n    //vec3 color = vec3(0.5, 0.7, 1.0) - max(p.dir.y, 0.0) * 0.75;\n\n    // Initialize material with default values\n    material mat = material(color, 0.0, 1.0, 1.0);\n    \n    //base of the model\n    if(p.matIndex == 0)\n        mat.albedo = vec3(1.0,0.35,0.10);\n    \n    //outside of the shpere\n    if(p.matIndex == 1)\n        mat.albedo = vec3(0.10,0.70,0.3);\n    \n    //floor\n    if(p.matIndex == 2)\n    {\n    \n        float zoom=.5;  \n        p.hitPos.xz=fract( p.hitPos.xz*zoom)*2.;\n        if(floor(p.hitPos.x)>.5==floor(p.hitPos.z)>.5)\n            mat.albedo = vec3(0.6);\n        else\n            mat.albedo = vec3(0.8);\n    }\n    \n    //inside of the sphere\n    if(p.matIndex == 3)\n    {\n        mat.albedo = vec3(0.20);\n    }\n\n    return mat;\n}\n\n\n///// RENDERING FUNCTION /////\n\nvec3 BRDFLambert(material mat, hitPayload p)\n{\n    //Lambert BRDF : bdrf * dot(n,rd) / pdf;\n    float pdf = dot(p.normal,p.dir)/PI;\n    vec3 brdf = mat.albedo/PI;\n    return brdf * dot(p.normal,p.dir) * (1.0/pdf);\n}\n\nmat4 getInvViewMatrix(vec3 ro, vec3 at)\n{\n    vec3 ww = normalize(at-ro); //front\n    vec3 uu = normalize(cross(ww, vec3(0.0,1.0,0.0))); // rigth;\n    vec3 vv = normalize(cross(uu,ww)); // up;\n    \n    return mat4(uu,0.,\n                vv,0.,\n                -ww,0.,\n                0.,0.,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy - 1.0)/iResolution.y;\n    \n    //jitter\n    uv += (dFdy(uv.x)+dFdy(uv.y)) * hash23(vec3(mod(iTime+1.0,10.0) * uv.x, iTimeDelta*uv.y, float(iFrame)));\n    \n    //init camera\n    float angle = 15.0*iMouse.x/iResolution.x;\n    float height= 2.0*iMouse.y/iResolution.y;\n    \n    //if screen has not been clicked yet\n    if(iMouse.x == 0.0 )\n    {\n        angle = 12.85;\n        height = 0.70;\n\n    }\n    \n    //camera parameter\n    vec3 ro = vec3(4.0 * cos(angle), 4.0*height, 4.0 * sin(angle));\n    vec3 at = vec3(0.0,0.15,0.0);\n    vec3 rd = normalize(getInvViewMatrix(ro,at) * vec4(uv,-1.5,1.0)).xyz;\n    \n    //Using a struct make the code cleaner and\n    //will also shorten many function \n    hitPayload p = hitPayload(\n        ro, //postion aka origin at first\n        ro,\n        rd,\n        vec3(0.0),\n        -1, \n        0,\n        0.0\n    );\n\n    \n    //global illumination bounces\n    vec3 energy = vec3(1.0);\n    vec3 color = vec3(0.0);\n    float spp = 1.0;\n    vec2 id = vec2(1.0);\n    \n    vec3 hitPos = vec3(0.0);\n    \n    //pathtracing loop\n    for(int i = 0; i <5; i++)\n    {\n        //preform ray-marching\n        p = trace(p);\n        \n        //compute normal and get color\n        p.normal = calcNormal(p.orig + p.dist * p.dir);\n        material mat = getMaterial(p);\n\n        //lambert BRDF\n        energy = energy * BRDFLambert(mat, p);\n        \n        \n        //bail out early hif it the sky\n        if(p.matIndex < 0)\n        {\n            color = energy;\n            break;\n        }\n        \n        //compute new bounce\n        p.dir = normalize(cosineWeightedhemisphereSampling(p.normal, uv + iTimeDelta + mod(iTime,30.0)));\n        p.orig = p.hitPos + p.normal*0.001;\n\n    }\n\n\n    if(iMouse.z < 0.0 || iMouse.x == 0.0)\n    {\n        uv = fragCoord.xy/iResolution.xy;\n        spp += texture( iChannel0, uv ).w;\n        color += texture( iChannel0, uv).xyz;\n    }\n\n    \n    fragColor = vec4(color,spp);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MXXXz2.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "lccXzM", "name": "galaxioooo", "author": "acoo", "description": "neato doods", "tags": ["spiral", "galaxy", "ellipse"], "time_retrieved": "2024-05-15T23:19:42.957193", "image_code": "// Heavily inspired by https://www.shadertoy.com/view/4dcyzX\n\n#define PI 3.14159265359\n\nmat2 rotate2d(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sphere(vec2 p, float r, float b)\n{\n    return smoothstep(r + b, r - b, length(p));\n}\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) \n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<9; i++ )\n    {\n        float n = texture(iChannel1,p).x;\n        f += s*n;\n        p *= 2.01*mat2(4.0,-3.0,3.0,4.0)/5.0;\n        s *= 0.55;\n    }\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\n    vec2 tuv = fragCoord.xy / iResolution.xy;\n    vec2 m = texture(iChannel2, tuv).xy;\n    \n    vec2 uv = 2.0 * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    \n    float effect_radius = 0.15;\n    float effect_falloff = 0.1;\n    float noise = fbm(uv * 0.005 * (cos(iTime * 0.5 + 0.5)));\n    float m_col = sphere(uv - m, effect_radius * noise, effect_falloff * noise * 2.0);\n        \n    vec2 ellipseRatio = vec2(0.4, 0.3) * (1.0 - m_col);\n    \n    float a_t = (cos(iTime * 0.0075) * 0.5 + 0.5) + 0.2;\n    float angle = -PI / a_t;               \n    float vx_e = 0.05;       \n        \n    float length_scale = 7.0;\n    float iter_length = 0.075;\n    float t = length_scale / iter_length;\n\n    for (float l = iter_length; l < length_scale; l += iter_length) \n    {\n        float e_thickness = 0.35;\n        float e_time = iTime * (0.25 / l - vx_e);\n        \n        vec2 e_uv = rotate2d(angle + angle * l) * uv;\n        vec2 inv_e = 1.0 / ellipseRatio * e_uv;\n        float d = dot(inv_e, inv_e);\n\n        vec3 tex_color = (texture(iChannel0, rotate2d(e_time) * inv_e / l)).rgb;\n        \n        vec3 p = palette(l);\n        \n        float intensity = smoothstep(e_thickness, 0.0, abs(sqrt(d) - l));\n        vec3 contrib = tex_color * tex_color * p * p * l;\n        color += intensity * contrib / l;\n    }\n    \n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec2 compute_gravitation(in vec2 p, float size, float gravity_strength)\n{\n    vec2 acceleration = vec2(0.0);\n        \n    vec2 v = -p;\n    float d = length(v);\n\n    if(d > 0.0000001) \n        acceleration += (v / d) / pow(max(d, size * 1.0) * gravity_strength, 2.0);\n        \n    return acceleration;\n}\n\nvoid initialize(inout vec2 prev_position, inout vec2 current_position)\n{\n\tcurrent_position = vec2(-1.0);\n    prev_position = vec2(-1.0);\n}\n\nvec2 get_extent_normal(vec2 p, float a, float b)\n{\n    if(p.x > a)\n        return vec2(-1.0, 0.0);\n    \n    if(p.x < -a)\n        return vec2(1.0, 0.0);\n    \n    if(p.y > b)\n        return vec2(0.0, -1.0);\n    \n    if(p.y < -b)\n        return vec2(0.0, 1.0);\n        \n    return vec2(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 previous_p = vec2(-1.0);\n    vec2 current_p = vec2(-1.0);\n    \n    if(iFrame <= 1 || iTime == 0.0)\n    {\n        initialize(previous_p, current_p);\n    }    \n    else\n    {\n        vec2 m = 2.0 * (iMouse.xy - iResolution.xy * 0.5) / iResolution.y;\n        vec4 last_buffer = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        \n        if(dot(last_buffer, last_buffer) == 0.0)\n        {\n            current_p = m;\n        }\n        else\n        {\n            previous_p = last_buffer.zw;\n            current_p = iMouse.z > 0.0 ? m : last_buffer.xy;\n        }\n    }\n        \n    float radius = 1.0;\n    vec2 acceleration = compute_gravitation(current_p, radius, 200.0);\n    vec2 intertia = current_p - previous_p;\n    vec2 velocity = intertia + acceleration;\n    \n    previous_p = current_p;\n    \n        \n    float aspect = iResolution.x / iResolution.y;\n    float r_aspect = 1.0;\n\n    vec2 next = current_p + velocity;\n\n    if(abs(next.x) > aspect || abs(next.y) > r_aspect)\n    {\n        vec2 i = normalize(next - previous_p);\n        vec2 n = get_extent_normal(next, aspect, r_aspect);\n        vec2 reflect_dir = reflect(i, n);\n        velocity = reflect_dir * length(velocity) * 0.9;\n    }\n    \n    \n    float v_lim = 0.025;\n    velocity = clamp(velocity, -vec2(v_lim), vec2(v_lim));\n    current_p += velocity;\n    \n    fragColor = vec4(current_p, previous_p);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lccXzM.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "MfKGWK", "name": "slightly real", "author": "sedcore", "description": "Some palette effect, coming from a popular demo from some years ago (future crew - unreal - 1992).\nI think it's done with a fixed image and only the palette (vga, 256 colors) is changed.", "tags": ["palette"], "time_retrieved": "2024-05-15T23:19:43.774895", "image_code": "/* 2024-04 - public domain */\n\n/* Some palette effect,\n * coming from a popular demo from some years ago\n * (future crew - unreal - 1992).\n * I think the original is done with a fixed image\n * and only the palette (vga, 256 colors) is changed.\n */\n\nfloat map(vec3 p)\n{\n  /* should find better map function... */\n  return p.y + 2. +min(3.*cos(-length(p.xz)),length(p.xz)>3.14159?-3.:1.);\n}\n\nvec3 paletteA(vec2 p)\n{\n  vec2 q = vec2(length(p), atan(p.x,p.y)/atan(1.));\n  vec2 qb = abs(fract(4.*q+vec2(iTime*4., iTime*2.)) * 2. - 1.);\n  vec3 blue = vec3(.2,.7,1.);\n  vec2 alpha = exp(-qb*qb*20.);\n  return blue * length(alpha);\n}\n\nvec3 paletteB(vec2 p)\n{\n  int fc[16*16] = int[16*16](\n2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \n2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 3, 3,\n2, 2, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3\n  );\n  float intens[4] = float[4](\n    .8,\n    .65,\n    .9,\n    .5);\n  vec3 red = vec3(1,0,0);\n  vec2 q = vec2(length(p), atan(p.x,p.y)/atan(1.));\n  vec2 qb = 16.*fract(4.*q+vec2(iTime*4.,iTime*2.));\n  return red * intens[fc[int(qb.x) * 16 + int(qb.y)]];\n}\n\nfloat on(float start, float end, float speed, float v)\n{\n  return min(smoothstep(start, start+speed, v),\n             smoothstep(1.-end, 1.-end+speed, 1.-v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n  \n  /* camera */\n  vec3 eye = vec3(0., 2.5, 5.);\n  vec3 target = vec3(0.,-1.,0.);\n  float focal = 1.2;\n  vec3 ro = eye;\n  vec3 camera_center = ro + focal * normalize(target-ro);\n  vec3 rdx = vec3(1.,0.,0.);\n  vec3 rdy = normalize(cross(rdx, target-ro));\n  rdx/=1.8; rdy/=1.8;\n  vec3 rd = normalize(camera_center + rdx * uv.x + rdy * uv.y - ro);\n\n  /* raymarch - should find a better map */\n  float t = 0.;\n  int i;\n  float d;\n  vec3 p;\n  for (i = 0; i < 100; i++) {\n    p = ro + t * rd;\n    d = map(p);\n    if (d < 0.01) break;\n    //if (d > 100.) break;\n    t += d*.3;\n  }\n\n  /* colormap */\n  vec3 col = on(0.,.55,.07, fract(iTime/10.)) * paletteA(p.xz) +\n             on(.5,.95,.14, fract(iTime/10.)) * paletteB(p.xz);\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "public-domain", "thumbnail": "https://www.shadertoy.com/media/shaders/MfKGWK.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "lfcSRM", "name": "First steps into 3D", "author": "Chalouek", "description": "Some simple educational content", "tags": ["3d", "simple", "education"], "time_retrieved": "2024-05-15T23:19:44.079207", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // just values for future point\n    vec3 point = vec3(cos(iTime),-0.3,sin(iTime)+2.);\n    float pointScale = 0.2;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    vec2 viewport = vec2((uv.x-0.5)*ratio,(uv.y-0.5));//centered uv coordinates with aspect ratio correction\n    \n    vec2 zOffset = viewport*point.z;// by multiplication we offsetting our viewport plane into Z depth direction\n    //as if our POV = 90 deg\n    //Viewport * 1 means 1 length of horizontal line from center to edge of viewport into screen depth direction\n    //more you multiply smaller scale of object you get, \n    //smaller appears distance of 1 unit from viewport center in screen plane direction\n    //play with point values to understand\n    \n    //draw our circle on zOffseted plane of viewport\n    if (distance(zOffset,vec2(point.x,point.y)) < pointScale){\n    fragColor = vec4(point.z/3.);\n    }else{\n    fragColor = vec4(zOffset,0.,1.0); //our zOffset coords\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lfcSRM.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "XcdSR4", "name": "AF - Complicated Things", "author": "tristanC", "description": "With more inputs. Demo:\n- https://youtu.be/gwM5yiKn9QQ", "tags": ["3d", "animationfractal"], "time_retrieved": "2024-05-15T23:19:46.633443", "image_code": "#ifndef ANIMATION_FRACTAL\n// Simulate the pitch inputs using a smoothed stairs function STEP\n#define STEP1(x) ((x) - sin(x))\n#define STEP(x, offset, amp) (STEP1(STEP1(offset + x * amp)) * .15)\n#define is (iTime)\n\nfloat pitches[9];\nvoid genPitches() {\n  pitches[0] = STEP(is, 1., 1.);\n  pitches[1] = STEP(is, 2., 2.);\n  pitches[2] = STEP(is, 3., 3.);\n  pitches[3] = STEP(is, 4., 4.);\n  pitches[4] = STEP(is, 5., 1.);\n  pitches[5] = STEP(is, 6., 2.);\n  pitches[6] = STEP(is, 7., 3.);\n  pitches[7] = STEP(is, 8., 4.);\n  pitches[8] = STEP(is, 1., 5.);\n}\n#define ipitch_1 pitches[0]\n#define ipitch_2 pitches[1]\n#define ipitch_3 pitches[2]\n#define ipitch_4 pitches[3]\n#define ipitch_5 pitches[4]\n#define ipitch_6 pitches[5]\n#define ipitch_7 pitches[6]\n#define ipitch_8 pitches[7]\n#define ipitch_9 pitches[8]\n\n#define icolor (iTime*.5)\n#define imoveFWD (iTime*.1)\n#endif\n\n\n// CC0: Complicating things even further\n//  That is what I do.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(a)     0.5*(cos(a)+1.0)\n\nconst float planeDist = 1.0-0.75;\nconst int   furthest  = 12;\nconst int   fadeFrom  = max(furthest-4, 0);\nconst float fadeDist  = planeDist*float(furthest - fadeFrom);\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 offset(float z) {\n  float a = z*0.5;\n  vec2 p = -0.25*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.6))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  const float eps = 0.05;\n  return (offset(z + eps) - offset(z - eps))/(2.0*eps);\n}\n\nvec3 ddoffset(float z) {\n  const float eps = 0.05;\n  return (doffset(z + eps) - doffset(z - eps))/(2.0*eps);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  return vec3(0.0);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan_approx(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nvec3 palette( float t ) {\n  return (1.0+cos(1.0*vec3(0.0, 1.0, 2.0)+TAU*t))*0.5;\n}\n\n// License: Unknown, author: kishimisu, found: https://www.shadertoy.com/view/mtyGWy\nvec3 kishimisu(vec3 col, vec2 p, float tm, float n) {\n  vec2 p0 = p;\n  vec3 finalColor = vec3(0.0);\n\n  vec2 p1 = p;\n  for (float i = 0.0; i < 4.0; i++) {\n    p1 = fract(p1 * 2.0+0.0125*tm) - 0.5;\n\n    float d = length(p1) * exp(-length(p0));\n\n    vec3 cc = palette(icolor + length(p0) + i*.4 + tm*.2);\n\n    d = sin(d*8. + tm)/8.;\n    d = abs(d);\n\n    d -= 0.0025;\n    d = max(d, 0.005);\n    d = (0.0125 / d);\n    d *= d;\n\n    col += cc * d;\n  }\n\n  return 0.5*(col);\n}\n\nvec3 effect(vec2 p, float tm, float n) {\n  vec3 col = vec3(0.0);\n  vec2 kp = p;\n  float kl = dot(kp, kp);\n  float kpf = 0.;\n  int nm3 = int(mod(n, 3.));\n  if (nm3 == 0)      kpf = ipitch_6;\n  else if (nm3 == 1) kpf = ipitch_7;\n  else if (nm3 == 2) kpf = ipitch_8;\n  float nn = 2.*floor(mix(3.0, 16.0, 0.5+0.5*sin(0.1*n)));\n  float kn = smoothKaleidoscope(kp, 0.1, nn);\n  kp += 0.5*sin(vec2(1.0, sqrt(0.5))*tm*(0.21+(.08*sin(kpf*.05))));\n  col = kishimisu(col, kp, tm, n);\n  col -= 0.75*vec3(0.0, 1.0, 2.0).zyx*dot(p, p);\n  col = clamp(col, 0.0, 4.0);\n  return col;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  float l = length(p);\n  p *= mix(0.5, 0.75, 0.5+0.5*sin(n*0.071));\n  float tm = 0.*TIME+0.125*n;\n  int nm3 = int(mod(n, 5.));\n  if (nm3 == 0)      tm += ipitch_1 * .5;\n  else if (nm3 == 1) tm += ipitch_2 * .5;\n  else if (nm3 == 2) tm += ipitch_3 * .5;\n  else if (nm3 == 3) tm += ipitch_4 * .5;\n  else if (nm3 == 4) tm += ipitch_5 * .5;\n\n  p *= ROT(-tm);\n  float fade = smoothstep(0.1, 0.15, l);\n  if (fade < 0.05) return vec4(0.0);\n  vec4 col = vec4(0.0);\n\n  col.xyz = effect(p, tm, n);\n  float i = max(max(col.x, col.y), col.z)*0.75;\n  col.w = (tanh_approx(0.5+l+max((i), 0.0))*fade);\n  return col;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  const float rdd_per   = 10.0;\n  float rdd =  (1.75+0.75*pow(lp,1.5)*tanh_approx(lp+0.9*PCOS(rdd_per*p.x)*PCOS(rdd_per*p.y)));\n//  float rdd = 2.0;\n\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 1.;\n  bool cutOut = false;\n\n  float maxpd = 0.0;\n\n  // Steps from nearest to furthest plane and accumulates the color\n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      maxpd = pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.w *= fadeOut*fadeIn;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency\n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float tm  = planeDist*imoveFWD*10.;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = cross(ww, uu);\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  // col *= smoothstep(1.0, 10.0, TIME);\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  return col;\n}\n\n#ifdef ANIMATION_FRACTAL\nvoid main() {\n    vec2 p = -1. + 2*inUV;\n    p.y *= scene.screenRatio;\n    p *= 1.5;\n#else\nvoid mainImage( out vec4 oColor, in vec2 fragCoord ) {\n    genPitches();\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n#endif\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, pp);\n\n#ifdef ANIMATION_FRACTAL\n    col = pow(col, vec3(3.));\n#endif\n\n  oColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcdSR4.jpg", "access": "api", "wgpu-test": "error"}
{"id": "4c3Xzr", "name": "2D geometric patterns 1", "author": "rrrola", "description": "2D pattern kata. Public domain.\nBrushing up my skills without looking at other people's code.", "tags": ["2d", "grid", "triangle", "patterns", "antialiasing", "hexagon", "rectangle", "rhombus"], "time_retrieved": "2024-05-15T23:19:47.621491", "image_code": "// 2D pattern kata. Public domain.\n// Brushing up my skills without looking at other people's code.\n\n// Constraints:\n// - fully deterministic (no hashing or noise)\n// - rectangular or triangular grids\n// - only two color channels\n// - needs antialiasing (smoothsteps are fine)\n// - WebGL 1 compatible, 60 fps on my old notebook\n// - 2 kB\n\nvoid mainImage(out vec4 o, vec2 x) {\n    vec3 t = iTime * vec3(.1, .316, 1);\n\n    vec3 rot = vec3(cos(t.x), sin(t.x), -sin(t.x));\n    mat2 R = mat2(rot.xzyx),\n        RT = mat2(rot.xyzx);  // slow rotation and its inverse\n    \n    float W = 15. / iResolution.y;  // antialiasing filter width\n\n    vec2 u = (x+x-iResolution.xy)/iResolution.y,  // rect coordinates, y:-1..1\n         r = R*5.*u + t.z,  // transformed rect coordinates (scale, rotation, shift)\n         rr = round(r),\n         h = .5*mat2(2,-1, 0,sqrt(3.)) * r;  // transformed hex coordinates: → x, ↖ y\n    vec3 H = vec3(h, h.x+h.y),  // add third hex direction ↗ z=x+y\n         rH = round(H);\n\n    vec3 i;  // moving hex stripes, used for patterns 1 and 3\n    {\n      vec3 I = fract(H);\n      float f = fract(t.x);\n      i = smoothstep(f   , f   +W, I) - smoothstep(f+.5, f+.5+W, I)\n        + smoothstep(f-1., f-1.+W, I) - smoothstep(f-.5, f-.5+W, I);\n    }\n\n    // Duotone color.\n    vec2 c;\n\n    // Borders between patterns.\n    float Q = .5*iResolution.x/iResolution.y;  // half of x\n    float P = floor(u.x/Q)+2. + 4.*(floor(u.y)+1.);  // pattern index 0..7\n    if (any(lessThan(abs(vec3(u, abs(u.x)-Q)), vec3(.01)))) c = vec2(0);\n\n    // Circles over squares.\n    else if (P==0.) {\n        // circles: additive outer radius, covering inner radius\n        float cw = length(r - rr);\n        vec2 C = smoothstep(cw, cw+W, vec2(.25, .35) + .125*sin(t.z));\n\n        // squares: scaled by sqrt(2) - antialiasing filter needs to be wider\n        float sw = .5 + .25*sin(t.y);\n        vec2 s = fract(R*R*(5.*sqrt(2.))*u + t.z);  // rotate even more, scale\n        vec2 S = smoothstep(sw, sw+W*sqrt(2.), s) + smoothstep(W*sqrt(2.), 0., s);\n        \n        c = 1. - vec2((1.-C.x)*min(S.x,S.y), C.y); }  // combine\n    \n    // Rhombi sliding around each other, sometimes forming Czech flag cubes.\n    else if (P==1.) {\n        vec3 d = i.xyz*(1.-i.yzx); c = d.yx + d.z; }\n\n    // Rectangular grid with a gradient that's always vertical.\n    else if (P==2.) {\n        vec2 s = r - rr;  // local coords have 0 in the center\n        vec2 aa = smoothstep(.45,.45+W, s) + smoothstep(-.5+W,-.5, s);\n        float S = max(aa.x, aa.y);\n        c = vec2(S, max(S, smoothstep(-.2,.7, (RT*s).y))); }  // unrotate the gradient\n\n    // Sliding triangular stripes.\n    else if (P==3.) {\n        c = vec2(2.*i.xy + i.z)/3.; }\n    \n    // Right triangles and hexagons. Similar to the sliding rhombi, but rectangular.\n    else if (P==4.) {\n        vec3 m = fract(vec3(r, r.x+r.y) + t.x),\n             WW = vec3(W,W,sqrt(2.)*W),  // diagonal antialias is wider\n             j = smoothstep(vec3(.5),.5+WW, m) + smoothstep(WW,vec3(0), m);\n        c = vec2(max(max(j.x,j.y),j.z), min(min(j.x,j.y),j.z)); }\n    \n    // Cute migrating blobs on a hexagonal grid.\n    else if (P==5.) {\n        vec3 i = H - rH;  // local coords have 0 in the center\n        float q = mod(rH.x + rH.z, 3.),  // cell index: select from 3 colors\n              w = .4 + .1*sin(t.z + (30. + 10.*sin(t.x))*u.y),  // warp radius\n              s = 2.*(RT*i.xz).y + 1.;  // unrotate shading\n        c = s * smoothstep(w+W, w, length(i)) * vec2(q<2.?1:0, q<1.?0:1); }  // antialias, color\n    \n    // Glowing triangular mesh.\n    else if (P==6.) {\n        float L = (length(fract(H) - .5) - .25) * 1.75;  // map to ~ 0..1\n        c = pow(vec2(L), 3.+2.*cos(t.xy)); }  // modify glow exponent 1..5\n\n    // Stairs and waves with fading echoes.\n    else if (P==7.) {\n        vec2 f = r - rr;\n        float q = mod(rr.x + rr.y, 4.);  // rectangular cell index\n        \n        c = vec2(1,0);\n        float l;  // get continuous stair- or wave field based on cell index, assign color\n        if      (q<1.) { l = min(f.x,f.y)+.5; }\n        else if (q<2.) { l = max(f.x,f.y)+.5; }\n        else if (q<3.) { c=c.yx; l = length(f-.5); }\n        else           { c=c.yx; l = 1. - length(f+.5); }\n\n        vec4 p = .5 + .35*sin(vec4(t.z, floor(t.z)-vec3(0,1,2))),  // main moving line + static echo (floor)\n             d = vec4(3, vec3(3,2,1)-fract(t.z))/3.,  // keep 3 echoes: get narrower and fade away\n             w = .075*d,  // width\n             v = d*d * smoothstep(p-w-W,p-w, vec4(l)) * smoothstep(p+w+W,p+w, vec4(l));  // intensity\n        c *= max(max(max(v.x,v.y),v.z),v.w); }\n\n    o = vec4(13,8,4,0);\n    o = sqrt(o*c.x + o.zyxw*c.y + 1.) / 4.;  // orange + blue palette\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "public-domain", "thumbnail": "https://www.shadertoy.com/media/shaders/4c3Xzr.jpg", "access": "api", "wgpu-test": "error"}
{"id": "XftXR4", "name": "Isovalues Vorple ", "author": "DasBooter", "description": "Messing with parameters to create phone background", "tags": ["noise", "color", "contour"], "time_retrieved": "2024-05-15T23:19:47.767750", "image_code": "// forked from here:\n// https://www.shadertoy.com/view/ldfczS\n// --- noise from procedural pseudo-Perlin (better but not so nice derivatives) ---------\n                    // ( adapted from IQ )\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n\tO = texture( iChannel0, U / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// forked from here:\n// https://www.shadertoy.com/view/ldfczS\n// --- noise from procedural pseudo-Perlin (better but not so nice derivatives) ---------\n                    // ( adapted from IQ )\n\nfloat noise3( vec3 x ) {\n    vec3 p = floor(x),f = fract(x);\n\n    f = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n    \n    return mix( mix(mix( hash3(p+vec3(0,0,0)), hash3(p+vec3(1,0,0)),f.x),       // triilinear interp\n                    mix( hash3(p+vec3(0,1,0)), hash3(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash3(p+vec3(0,0,1)), hash3(p+vec3(1,0,1)),f.x),       \n                    mix( hash3(p+vec3(0,1,1)), hash3(p+vec3(1,1,1)),f.x),f.y), f.z);\n}\n\n#define noise(x) (noise3(x)+noise3(x+11.5)) / 2. // pseudoperlin improvement from foxes idea\n\nvoid mainImage(out vec4 O, vec2 U ) // ------------ draw isovalues\n{\n    float t = iTime * 0.015; //speed of movement through the texture\n    vec2 R = iResolution.xy;\n    float n = noise(vec3(U*2.0/min(R.x,R.y), t)),//first num controlls zoom, second speed.\n          v = sin(30.*(cos(t / 25.) + 3.)* n);\n\n\n    v = smoothstep(1.,0., .5*abs(v)/fwidth(v));\n\n    vec2 q =(U+vec2(cos(t*.3),sin(t*.3)))/R;\n    O = mix(texture(iChannel0, q ),\n             .5+ .8*n*sin((sin(t / 9.0)+7.0+n*5.5)+vec4(-2.4,-1.1,1.1,0)),\n             v );\n   O = O * .985 - vec4(0.004,0.008,0.003,0); //fade background\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XftXR4.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "4ctXR4", "name": "Pearlescent Spiral", "author": "Peace", "description": "Pearlescent spiral", "tags": ["spiral", "color"], "time_retrieved": "2024-05-15T23:19:47.801608", "image_code": "float smin(float d1, float d2, float k) { \n\tfloat h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0); \n\treturn mix(d2, d1, h) - k * h * (1.0 - h); \n} \n\nvec3 hue_shift(vec3 col, float hue) {\n    return mix(vec3(dot(vec3(0.333), col)), col, cos(hue)) + cross(vec3(0.577), col) * sin(hue);\n}\n\nvec2 rot2d(vec2 v, float a) {\n\treturn cos(a) * v + sin(a) * vec2(-v.y, v.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / mr;\n    float a = atan(uv.y, uv.x);\n    float l = length(uv);\n\n    float d = 0.0;\n    vec2 p = sin(uv * l);\n    p = rot2d(p, -cos(l * 5.0 + iTime));\n    d = length(exp(-p * p));\n    p = rot2d(p, d - cos(l * 3.0 + iTime));\n    p = rot2d(p, smoothstep(0.0, -0.5, abs(cos(atan(p.y, p.x))) - 0.7));\n    d = smin(length(p), d, 0.9);\n    p = rot2d(p, l + a);\n\n    vec3 c = vec3(0);\n    c = sin(d * vec3(4, 3, 1)) * 0.5 + 0.5;\n    c = hue_shift(c, atan(p.y, p.x) - iTime);\n    c.b += d * 0.25;\n    c.b = sqrt(c.b);\n    c *= c * 0.4 + 0.6;\n\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ctXR4.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4ctSR4", "name": "eclipse but from space", "author": "01000001", "description": "saw [url=https://www.youtube.com/watch?v=CuTQ3j56yP0]this[/url] and wanted to recreate it. Took me long enough 💀. Got some practice with noise generation in the process.", "tags": ["art"], "time_retrieved": "2024-05-15T23:19:49.159131", "image_code": "float pi = 3.1415926;\nfloat detail = .9;\nfloat radius = 50.;\nfloat atmosphere = .1;\n#define offset(x) vec3(0, 5, x + 1.)\n\n#define cloud(x) smoothstep(-.5, 1.5, noise(cuv*2. + iTime*.02 \\\n                + vec2(                                         \\\n                    noise(cuv, 2<<2, seed + uvec3(2)),           \\\n                    noise(cuv, 2<<2, seed + uvec3(3))             \\\n                )*.8,                                              \\\n                x, seed+uvec3(1))                                   \\\n    )                                               \n\n#define eclipseCalc euv = cuv; euv.y -= 4.; euv.x -= iTime * .05 + 2.; euv.x = mod(euv.x + 4., 8.) - 4.; \\\n            eclipse = 1.-clamp( .3/(euv.x*euv.x + euv.y*euv.y) ,0.,1.);\n\n\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nmat2 rot(float t){\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat noise(vec2 p, int d, uvec3 x){\n    p *= 0.002;\n    float sum;\n    vec2 dir;\n    vec3 h;\n    for (int i = 1; i<d+1; i++){\n        h = hash(x + uvec3(i, i*i, 2<<i)) * 2. - 1.;\n        sum  += (texture(iChannel3, p * rot(atan(h.y, h.x)) * float(i)).x*2.-1.)/pow(float(i), 1./detail);\n    }\n    return sum;\n}\n\nfloat dirDeriv(vec2 p, int d, uvec3 x, vec2 dir, float e){\n    return (noise(p,d,x) - noise(p - dir*e, d, x)); \n}\n\nfloat dirDeriv(vec2 p, int d, uvec3 x, float f, vec2 dir, float e){\n    return (f - noise(p - dir*e, d, x)); \n}\n\nvec2 normal(vec2 p, int d, uvec3 x, float f, float e){\n    return vec2(\n        dirDeriv(p,d,x,f,vec2(1,0), e),\n        dirDeriv(p,d,x,f,vec2(0,1), e)\n    );\n}\n\nvec2 sphere( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    vec3 qc = oc - b*rd;\n    float h = ra*ra - dot( qc, qc );\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nfloat linePointDist(vec3 o, vec3 dir, vec3 p){\n    vec3 a = cross(p-o, dir-o);\n    vec3 b = normalize(cross(dir-o, a));\n    return dot(b, p-o);\n}\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    \n    uvec3 seed = uvec3(0,1,3);\n    \n    O = vec4(0);\n    \n    \n    vec3 o = vec3(0);\n    vec2 camuv = (cuv / 1.5) + vec2(0, .2);\n    //vec3 dir = vec3(sin(camuv.x)*cos(camuv.y),cos(camuv.x)*cos(camuv.y), sin(camuv.y));\n    //dir.zy *= rot(.5);\n    vec3 dir = normalize(vec3(camuv.x, 2., camuv.y));\n    vec2 t;\n    t.x = sphere(o, dir, offset(radius), radius).x;\n    t.y = sphere(o, dir, offset(radius), radius + atmosphere).x;\n    float fresnel = t.x>0.?dot(-dir, normalize(o + dir*t.x - offset(radius))):1e10;\n    \n    float x = linePointDist(o, dir, offset(radius)) - radius;\n    O += vec4(.2, .4, .8, 1.) * 1./sqrt(x*2.) * exp(-x*4.); //Help the people without oled screens feel a bit less bad... that includes me\n\n    float eclipse;\n    vec2 euv;\n    o.x += iTime*.2;\n    \n    if (t.y > 0.){\n        if (t.x > 0.){\n            cuv = (o + dir * t.x).xy;\n            \n            eclipseCalc\n\n            float f = noise(cuv*.2, 2<<5, seed);\n            vec3 norm = normal(cuv*.2, 2<<5, seed, f, 1e-2 / t.x).xyy;\n            norm.z = sqrt(1. - norm.x*norm.x - norm.y*norm.y);\n\n            vec3 lightDir = normalize(vec3(sin(1.), cos(1.), 1.));\n            float shading = dot(lightDir, norm);\n\n            O = mix(vec4(.8,.8,.7,1.), vec4(.2, .3,.3,1.), f) * shading;\n\n            if (f < 0.) O *= pow(vec4(.5, .6, .8, 1.), vec4(-f*5.));\n\n            //Cloud Shadows\n            O *= 1.-cloud(2<<3);\n            // By simply doing less FBM we get blurred noise. A rare case of blur being cheaper!\n            \n            O *= eclipse;\n        }\n        \n        cuv = (o + dir * t.y).xy;\n\n        eclipseCalc\n\n        // Cloud Layer\n        O = mix(O, vec4(1), \n            cloud(2<<5) * eclipse\n        );\n    }\n    \n    //O = vec4(0);\n    float f =  1./(sqrt(fresnel*10.)) * exp(-fresnel*5.);\n    O /= (f + 1.);\n    O += vec4(.2, .4, .8, 1.) * f * eclipse;\n    \n    \n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ctSR4.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "XfdSRn", "name": "value noise͏", "author": "01000001", "description": "this is way better", "tags": ["tool"], "time_retrieved": "2024-05-15T23:19:49.208611", "image_code": "//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nmat2 rot(float t){\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat noise(vec2 p, int d, uvec3 x){\n    p *= 0.005;\n    float sum;\n    vec2 dir;\n    vec3 h;\n    for (int i = 1; i<d+1; i++){\n        h = hash(x + uvec3(i, i*i, 2<<i)) * 2. - 1.;\n        sum  += (texture(iChannel3, p * rot(atan(h.y, h.x)) * float(i)).x*2.-1.)/float(i);\n    }\n    return sum;\n}\n\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    \n    O = vec4(0);\n    float f = noise(cuv, 2<<8, uvec3(1,2,3));\n    vec3 norm = vec3(dFdx(f), dFdy(f), 0);\n    norm.z = sqrt(1. - norm.x*norm.x - norm.y*norm.y);\n    \n    vec3 light = normalize(vec3(sin(3.), cos(3.), 1.));\n    \n    O = mix(vec4(.8,.8,.5,1.), vec4(.2, .4,.3,1.), f) * dot(light, norm);\n    \n    if (f < 0.) O *= pow(vec4(.3, .4, .8, 1.), vec4(-f*5.));\n    \n    O *= 1.-smoothstep(-.8, 1.3, noise(cuv + iTime*.02 - light.xy*.2, 2<<1, uvec3(2,3,5)));\n\n    O = mix(O, vec4(1), smoothstep(-.8, 1.3, noise(cuv + iTime*.02, 2<<5, uvec3(2,3,5))));\n\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfdSRn.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4fcXRN", "name": "cola bottle", "author": "ianertson", "description": "Use the mouse to look around :)", "tags": ["3d", "ray", "raymarch", "marching", "bottle", "cola"], "time_retrieved": "2024-05-15T23:19:53.074520", "image_code": "#define R iResolution.xy\n#define ZERO min(iFrame, 0)\n#define M_PI 3.14159265358979323846264338327950288\n#define TAU (M_PI*2.0)\n#define NEAR 0.003\n#define FAR 60.0\n#define STEPS 60\n#define AMBIENT 0.1\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nfloat smin(float a, float b, float k) {float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0); return mix(a, b, h) - k*h*(1.0-h); }\nfloat smax(float a, float b, float k) {return smin(a, b, -k); }\nfloat sabs(in float v, in float k) {return smax(-v, v, k);}\nfloat sclamp(in float v, in float mi, in float ma, in float k) {return smin(smax(v, mi, k), ma, k);}\nfloat sgt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (a - b) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat slt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat ssign(float x, float k) { float s = smoothstep(-k, k, x); return mix(s, sign(x), 0.5*clamp(max(0.0, 1.0-(abs(s)*2.5))*max(0.0, 1.0-k), 0.0, 1.0));}\n\nvec3 thash(vec2 p, float seed) {\n    return textureLod(iChannel0, ((p  + seed) / 256.0), 0.0).xyz;\n}\n\nvec3 tnoise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(thash(id+vec2(0,0),s),thash(id+vec2(1,0),s),lv.x),\n             mix(thash(id+vec2(0,1),s),thash(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nvec3 tnoise(vec2 p, float s, float freq, float warp, const in int oct) {\n  vec3 n = vec3(0.0);\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*tnoise((p+tx)*freq,s);\n    div += amp;\n    amp *= 0.5;\n    freq *= 2.0;\n    tx += warp * vec2(sin(n.x*6.28), cos(n.y*6.28));\n\n  }\n  return n / div;\n}\n\n\nstruct Light {\n  vec3 p;\n  vec3 dir;\n  vec3 color;\n  float strength;\n  int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIRECTIONAL 2\n\nvec3 getLightDir(Light light, vec3 p) {\n  switch (light.type) {\n    case LIGHT_AMBIENT: return normalize(light.p); break;\n    case LIGHT_POINT: return normalize(light.p - p); break;\n    case LIGHT_DIRECTIONAL: return normalize(-light.dir); break;\n    default: return normalize(vec3(1, 2, 3)); break;\n  }\n}\n\nvec3 getLightAtt(Light light, vec3 p, vec3 N) {\n  vec3 L = getLightDir(light, p);\n  float NdotL = max(AMBIENT, dot(N, L));\n  switch (light.type) {\n    case LIGHT_AMBIENT: return NdotL * light.strength * light.color; break;\n    case LIGHT_POINT: return pow(NdotL * light.strength * light.color, vec3(2.0)) / max(0.0000353, pow(distance(light.p, p), 2.0));\n    case LIGHT_DIRECTIONAL: {\n      return light.color * light.strength * NdotL * smoothstep(0.8, 1.0, dot(\n        normalize(light.p - p),\n        L\n      )); break;\n    }\n  }\n\n  return vec3(0.5);\n}\n\nstruct Material {\n  float rough;\n  float spec;\n  float z;\n  float ior;\n};\n\n#define NEW_MATERIAL Material(0.0, 0.0, 0.0, 0.0)\n\nstruct Object {\n  int id;\n  vec3 p;\n  vec3 q;\n};\n\n#define NEW_OBJECT Object(-1, vec3(0.0), vec3(0.0))\n\nstruct Data {\n  vec3 p;\n  vec3 n;\n  float d;\n  float sig;\n  int skip;\n  Object o;\n  Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, 1.0, -1, NEW_OBJECT, NEW_MATERIAL)\n\n\nfloat cylSDF(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ba = b - a;\n  vec3 pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, max(p.y, p.z)));\n}\n\n#define SAMPLE(ID, DIST) if (DIST < dist) { dist = DIST; id = ID; }\n\n#define ID_BODY 0\n#define ID_CAP 1\n#define ID_TABLE 2\n#define ID_GROUND 3\n\nfloat bodySDF(vec3 p, float h, float r) {\n    float dm = abs(p.y-(h*0.5));\n    float k = r;\n    r = mix(r, k*2.25, slt(abs(p.y-(h*0.5)), h*0.3333, 0.6)*slt(p.y, h*0.9, 1.2));\n    r = mix(r, k*2.25, slt(p.y, 0.9, 0.45));\n    return cylSDF(p, vec3(0, 0, 0), vec3(0, h, 0), r);\n}\n\nfloat capSDF(vec3 p, float h, float r) {\n    return cylSDF(p, vec3(0, h, 0), vec3(0, h+0.25, 0), r*1.1);\n}\n\nfloat bottleSDF(vec3 p, inout Data data) {\n    int id = data.o.id;\n    float dist = data.d;\n    float h = 3.0;\n    float r = 0.3;\n    \n    if (data.skip != ID_BODY) {\n        float body = bodySDF(p, h, r);\n        SAMPLE(ID_BODY, body);\n    }\n    float cap = capSDF(p, h, r);\n    SAMPLE(ID_CAP, cap);\n    data.o.id = id;\n    return dist;\n}\n\nfloat tableSDF(vec3 p) {\n    float w = 8.0;\n    float depth = 4.0;\n    float bh = 0.25;\n    float h = 6.0;\n    float r = 0.3333;\n    \n    float dist = FAR;\n    float board = boxSDF(p, vec3(w, bh, depth));\n    dist = min(dist, board);\n    \n    float inset = r*2.0;\n    float leg = cylSDF(vec3(abs(p.x), p.y, abs(p.z)), vec3(w-inset, -h, depth-inset), vec3(w-inset, 0, depth-inset), r);\n    \n    dist = min(dist, leg);\n    \n    return dist;\n    \n}\n\nfloat groundSDF(vec3 p) {\n    if (p.y > 11.0) return p.y;\n    vec3 n1 = tnoise(p.xz, 11.14925, 0.1, 0.1, 3);\n    float h = n1.x*(10.*(1.0+(n1.y*n1.y)))*smoothstep(16.0, 30.0, length(p.xz));\n    return p.y - h;\n}\n\nfloat sdf(vec3 p, inout Data data) {\n    int id = data.o.id;\n    float dist = data.d;\n    \n    float bottle = bottleSDF(p - vec3(0, 6.253, 0), data);\n    id = data.o.id;\n    dist = bottle;\n    \n    \n    float table = tableSDF(p - vec3(0, 6, 0));\n    \n    SAMPLE(ID_TABLE, table);\n    data.o.id = id;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ID_GROUND, ground);\n    data.o.id = id;\n        \n    return dist;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float d = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = data.sig * sdf(p, data);\n        if (abs(next) >= FAR) return false;\n        if (abs(next) <= (NEAR*(1.0 + abs(d)))) break;\n        d += next;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(NEAR, 0);\n    vec3 n = normalize(sdf(p, data) - vec3(\n        sdf(p - e.xyy, data),\n        sdf(p - e.yxy, data),\n        sdf(p - e.yyx, data)\n    ));\n    \n    data.p = p;\n    data.n = n;\n    data.d = d;\n    \n    return true;\n}\n\nfloat getShadow(vec3 ro, float NdotL, Light light) {\n    Data data = NEW_DATA;\n    float init = NEAR*9.0;\n    float d = init;\n    vec3 L = getLightDir(light, ro);\n    vec3 rd = L;\n    float ad = 0.0;\n    \n    for (int i = ZERO; i < 32; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        //if (next >= FAR) return 1.0;\n        if (next <= -NEAR) break;\n        ad += next;\n        d += clamp(next, 0.005, 2.0);\n    }\n    \n    if (d <= init) return 1.0;\n    float s = ad / (1.0 + ad);\n    \n    return clamp(s*s*s*s, AMBIENT, 1.0);\n}\n\n\nvec3 forEachLight(Light light, vec3 ro, vec3 rd, Data data, vec3 diffuse) {\n  vec3 p = data.p;\n  vec3 N = data.n;\n  vec3 L = getLightDir(light, p);\n  float NdotL = dot(N, L);\n  vec3 att = getLightAtt(light, p, N);\n  vec3 ref = reflect(N, L);\n  float VdotR = max(0.0, dot(rd, ref));\n  float spec = pow(VdotR, 24.0)*data.m.spec;\n  float shadow = (data.sig < 0.0) ? 1.0 : (NdotL <= 0.015) ? max(AMBIENT, abs(NdotL)) : getShadow(data.p, NdotL, light);\n  return ((diffuse + spec) * att) * shadow;\n}\n\nvec3 getAlbedoCap(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = mix(mix(p.xy, p.yz, (abs(dot(n, vec3(1, 0, 0))))), p.xz, (abs(dot(n, vec3(0, 1, 0)))));\n\n\n    col = vec3(0.99, 0.1, 0.045);\n    \n    \n    return col;\n}\n\n\nfloat chr(vec2 p, int c) {\n    if (c == 32) return 0.0;\n    p = (((p-vec2(0, 1))+vec2(float(int(1.0+float(c-97))),\n    int(-6 - (c > 111 ? 1 : 0))))/16.);\n    return texture(iChannel1, p).x;\n}\n\n\n#define TEXT(P, CHARS)\\\n{\\\n  int chars[] = int[] CHARS;\\\n  int len = chars.length();\\\n  vec2 id = floor((P)*(float(len/2)+1.));\\\n  vec2 lv = fract((P)*(float(len/2)+1.));\\\n  int idx = int(id.x);\\\n  text += (idx < 0 || idx >= len || abs(lv.x-0.9)<0.1 || abs(lv.y-0.9)<0.1) ? 0.0 : \\\n      chr(lv, chars[idx]);\\\n}\n\n\nvec3 getAlbedoBody(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    p.y -= 6.0;\n    vec3 n = data.n;\n    vec2 uv = mix(mix(p.xy, p.yz, (abs(dot(n, vec3(1, 0, 0))))), p.xz, (abs(dot(n, vec3(0, 1, 0)))));\n\n    col = vec3(0.45, 0.1, 0.1);\n    \n    float pm = abs((p.y)-1.5);\n    float label = slt(pm, 0.5, 0.02);\n    \n    col = mix(col, vec3(1.0), label);\n    \n    vec2 coord = p.xy;//mix(p.xy, p.zy, floor(abs(dot(n, vec3(1, 0, 0)))));\n    \n    coord.y += 0.1;\n    coord.x += 0.5;\n    coord *= 1.1;\n    float text = 0.0;\n    TEXT(coord, (99, 111, 108, 97))\n    col = mix(col, vec3(0.0), text*label*float(p.y > 1.4 && p.y < 1.7));\n    \n    //col = mix(col, vec3(0.0), sc);\n    \n    data.m.ior = 1.490*max(0.0, 1.0-label);\n    \n    return col;\n}\n\nvec3 getAlbedoTable(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = mix(mix(p.xy, p.yz, (abs(dot(n, vec3(1, 0, 0))))), p.xz, (abs(dot(n, vec3(0, 1, 0)))));\n\n    \n    vec3 n1 = tnoise(uv, 0.31254, 2.0, 0.03, 2);\n    vec3 n2 = tnoise(uv, 4.49583, 3.0, 0.03, 2);\n    \n    vec3 c1 = vec3(0.4, 0.2, 0.05);\n    vec3 c2 = vec3(0.5, 0.21, 0.09);\n    vec3 c3 = vec3(0.49, 0.29, 0.005);\n    vec3 c4 = vec3(0.4, 0.2, 0.1);\n    \n    \n    float px = 0.5+0.5*sin((2.0*n1.z+uv.x*6.28+2.2*(cos(uv.y*6.28+2.0*n1.x)))*(1.0+n2.y));\n    float py = 0.5+0.5*cos((2.0*n1.x+uv.x*6.28+2.2*(sin(uv.y*6.28+2.0*n1.y)))*(1.0+n2.x));\n    \n    col = mix(col, c1, n1.x);\n    col = mix(col, c2, n1.y);\n    col = mix(col, c3, n1.z);\n    col = mix(col, c4, n2.x);\n    col = mix(col, col*col, px*n1.x*n2.y);\n\n    data.m.spec = n2.x*max(0.0, 1.0-max(px, py))*n2.x*n2.x*0.5;\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 c1 = vec3(0.1, 0.7, 0.05);\n    vec3 c2 = vec3(0.25, 0.69, 0.09);\n    vec3 c3 = vec3(0.09, 0.39, 0.02);\n    vec3 c4 = vec3(0.25, 0.39, 0.05);\n    \n    vec3 n1 = tnoise(p.xz, 0.211155);\n    vec3 n2 = tnoise(p.xz*0.25, 10.44233);\n    vec3 n3 = tnoise(p.xz*0.25, 16.66343, 2.0, 0.05, 2);\n    \n    col = mix(c1, c2, n1.x);\n    col = mix(col, c3, n1.y);\n    col = mix(col, c4, smoothstep(0.4, 0.7, n3.x));\n    col = mix(col, col*col, n2.x);\n    \n    return col;\n}\n\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.o.id) {\n        case ID_CAP: return getAlbedoCap(data); break;\n        case ID_BODY: return getAlbedoBody(data); break;\n        case ID_TABLE: return getAlbedoTable(data); break;\n        case ID_GROUND: return getAlbedoGround(data); break;\n    }\n    \n    return vec3(0.48);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\n    return col;\n}\n\nvec3 getColor(vec3 ro, vec3 rd, inout Data data) {\n    vec3 col = vec3(0.0);\n    \n    Light light = Light(vec3(1, 3, -1), vec3(0.0), vec3(0.97, 0.89, 0.79), 2.0, LIGHT_AMBIENT);\n    \n    if (march(ro, rd, data)) {\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        col += forEachLight(light, ro, rd, data, diffuse);\n    } else {\n        col += getSky(rd);\n    }\n    \n    return max(col, vec3(0.0));\n}\n\n\nvoid mainImage(out vec4 o, in vec2 fc)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc.xy - 0.5 * R.xy) / R.y;\n    vec4 m = vec4((iMouse.xy - 0.5 * R.xy) / R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0, 1.9, -5);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    if (m.z > 0.001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        float ten = sgt(iTime, 8.0, 0.5)*slt(iTime, 12.0, 0.5);\n        ro.z -= mix((0.5+0.5*sin(iTime))*3.0, 0.0, ten);\n        float ang = mix(iTime, 0.0, ten);\n        //ro.yz *= rot(ang);\n        ro.xz *= rot(ang);\n       // rd.yz *= rot(ang);\n        rd.xz *= rot(ang);\n    }\n    \n    ro.y += 6.0;\n    \n    Data data = NEW_DATA;\n    col += getColor(ro, rd, data);\n    \n    if (data.m.ior > 0.01) {\n        vec3 n = data.n;\n        vec3 p = data.p;\n        float ior = data.m.ior;\n        \n        vec3 enterDir = refract(rd, n, 1.0/ior);\n        Data enterData = NEW_DATA;\n        enterData.sig = -data.sig;\n        \n        \n         vec3 enterP = p+(n*enterData.sig*NEAR*10.);\n        vec3 enterCol = getColor(enterP, enterDir, enterData);\n        \n        \n        Data exitData = NEW_DATA;\n        exitData.sig = -enterData.sig;\n        exitData.skip = ID_BODY;\n        vec3 exitDir = refract(enterDir, enterData.n, ior);\n\n        \n        if (length(exitDir) < 0.000001) {\n          exitDir = reflect(enterDir, enterData.n);\n          exitData.sig *= -1.0;\n        }\n        \n       \n        vec3 exitP = enterData.p+(enterData.n*NEAR*enterData.sig);\n        vec3 exitCol =  getColor(exitP, exitDir, exitData);\n        col =  exitCol * enterCol* M_PI;\n    }\n    \n    col = aces(col);\n    col = pow(col, vec3(1.0/2.2));\n    \n    o = vec4(col, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fcXRN.jpg", "access": "api", "wgpu-test": "error"}
{"id": "lccSz4", "name": "Wavelet Clouds [276 Chars]", "author": "SnoopethDuckDuck", "description": "golfing welcome ☁️", "tags": ["clouds", "clouds", "fun", "short", "onetweet", "golf"], "time_retrieved": "2024-05-15T23:19:53.103441", "image_code": "// -1 thanks to shadertoyjiang ☁️\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    u -= o.xy = iResolution.xy / 2.; \n    float i,\n          d = length(u /= o.y) / 4.,\n          t = iTime;\n    u /= .9 + d;\n       \n    for ( o = vec4(0, .3, .6, 0); \n          i++ < 19.;\n          u = 1.05 * u * mat2(cos(i*i + vec4(8, 19, 41, 8)))\n            + cos(o.yz*4.+t)*.01 + i + cos(1e2*u)/7e2 )          \n        o += abs(cos(.2 * (cos(o) + t) + 3. * u.x - .05*t*i))\n           -.5;\n                  \n    o = tanh((.5-.6*d) * o);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lccSz4.jpg", "access": "api", "wgpu-test": "error"}
{"id": "4f3SRN", "name": "AF - Kaleidoscope Bao01", "author": "tristanC", "description": "With more params. Demo:\n- https://youtu.be/Xdhe1KVdsxo", "tags": ["kaleidoscope", "animationfractal"], "time_retrieved": "2024-05-15T23:19:53.124550", "image_code": "#ifndef ANIMATION_FRACTAL\n// Simulate the pitch inputs using a smoothed stairs function STEP\n#define STEP1(x) ((x) - sin(x))\n#define STEP(x, offset, amp) (STEP1(STEP1(offset + x * amp)) * .15)\n#define is (iTime)\n\nfloat pitches[9];\nvoid genPitches() {\n  pitches[0] = STEP(is, 1., 1.);\n  pitches[1] = STEP(is, 2., 2.);\n  pitches[2] = STEP(is, 3., 3.);\n  pitches[3] = STEP(is, 4., 4.);\n  pitches[4] = STEP(is, 5., 1.);\n  pitches[5] = STEP(is, 6., 2.);\n  pitches[6] = STEP(is, 7., 3.);\n  pitches[7] = STEP(is, 8., 4.);\n  pitches[8] = STEP(is, 1., 5.);\n}\n#define ipitch_1 pitches[0]\n#define ipitch_2 pitches[1]\n#define ipitch_3 pitches[2]\n#define ipitch_4 pitches[3]\n#define ipitch_5 pitches[4]\n#define ipitch_6 pitches[5]\n#define ipitch_7 pitches[6]\n#define ipitch_8 pitches[7]\n#define ipitch_9 pitches[8]\n\n#define icolor (iTime*.5)\n#define imoveFWD (iTime*.1)\n#endif\n\n#define PI 3.141592\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n}\n\nvec4 orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate(float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n// The MIT License\n// See https://iquilezles.org/articles/palettes for more information\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 palette ( float t ) {\n // return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n // return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n}\n\n#ifdef ANIMATION_FRACTAL\nvoid main() {\n    vec2 uv = -1. + 2*inUV;\n    uv *= 42.;\n    uv.y *= scene.screenRatio;\n#else\nvoid mainImage( out vec4 oColor, in vec2 fragCoord ) {\n    vec2 uv = 23.09 * (2. * fragCoord - iResolution.xy) / iResolution.y;\n    genPitches();\n#endif\n  float dist = length(uv);\n  oColor = vec4(0.);\n  uv *= rotate(imoveFWD);\n  uv = kale(uv, vec2(6.97), 9.);\n  uv *= rotate(ipitch_2 * .5);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(ipitch_7*.01);\n    uv.x += 0.57 * sin(0.3 * uv.y + ipitch_3);\n    uv.y -= 0.63 * cos(0.53 * uv.x + ipitch_4);\n    float t = i * PI / orbs * 2.;\n    float x = 4.02 * tan(t - (ipitch_1 + ipitch_5) * .1);\n    float y = 4.02 * cos(t - ipitch_6 * .5);\n    vec2 position = vec2(x, y);\n    vec3 color = .15 + palette(icolor + i / orbs) * .25; // vec3(0.,0.3,0.8) * 0.25 + 0.25;\n    oColor += orb(uv, 1.39, position, color, 1.37);\n  }\n#ifdef ANIMATION_FRACTAL\n    oColor = pow(oColor, vec4(1.2, .9, .9, 1.) * 3.);\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4f3SRN.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "XfV3Dy", "name": "AF - tm bus kaleido", "author": "tristanC", "description": "With more params. Demo:\n- https://youtu.be/O2hJp2yUBy8", "tags": ["kaleidoscope", "animationfractal"], "time_retrieved": "2024-05-15T23:19:54.077179", "image_code": "#ifndef ANIMATION_FRACTAL\n// Simulate the pitch inputs using a smoothed stairs function STEP\n#define STEP1(x) ((x) - sin(x))\n#define STEP(x, offset, amp) (STEP1(STEP1(offset + x * amp)) * .15)\n#define is (iTime)\n\nfloat pitches[9];\nvoid genPitches() {\n  pitches[0] = STEP(is, 1., 1.);\n  pitches[1] = STEP(is, 2., 2.);\n  pitches[2] = STEP(is, 3., 3.);\n  pitches[3] = STEP(is, 4., 4.);\n  pitches[4] = STEP(is, 5., 1.);\n  pitches[5] = STEP(is, 6., 2.);\n  pitches[6] = STEP(is, 7., 3.);\n  pitches[7] = STEP(is, 8., 4.);\n  pitches[8] = STEP(is, 1., 5.);\n}\n#define ipitch_1 pitches[0]\n#define ipitch_2 pitches[1]\n#define ipitch_3 pitches[2]\n#define ipitch_4 pitches[3]\n#define ipitch_5 pitches[4]\n#define ipitch_6 pitches[5]\n#define ipitch_7 pitches[6]\n#define ipitch_8 pitches[7]\n#define ipitch_9 pitches[8]\n\n#define icolor (iTime*.5)\n#define imoveFWD (iTime)\n#endif\n\n#define FAR 60.\n#define PI 3.14159\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n//@iq\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 boxes(vec3 p) {\n    vec2 h,t = vec2(1000,0);\n    vec3 q = p;\n    q.xy *= rot(ipitch_6);\n    q.zx *= rot(-ipitch_8);\n    h = vec2(sdBox(abs(q)-vec3(4,0,0), vec3(1,4,1))-.1, 1);\n    t = h.x<t.x ? h : t;\n\n    q = p;\n    q.xy *= rot(ipitch_7);\n    q.zx *= rot(-ipitch_9);\n    h = vec2(sdBox(abs(q)-vec3(0,4,2), vec3(4,1,1))-.1, 1);\n    t = h.x<t.x ? h : t;\n    return t;\n}\n\nvec2 map(vec3 p) {\n    // kaleidoscope effect adapted from @NuSan\n    for (float i=0.; i<4.; i++) {\n        p = abs(p);\n        p.xy *= rot(sin(ipitch_1*.5 + i*2.));\n        p -= i*mix(1.,1.5,sin(ipitch_2)*.5+.5);\n    }\n    p.xy *= rot(ipitch_3*.5);\n    p.yz *= rot(ipitch_4*.5);\n    vec2 t = min(boxes(p), boxes(p*2.)/2.);\n    return t;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(.001,0);\n    return normalize(map(p).x - vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvoid cam(inout vec3 p) {\n    p.xz *= rot(iTime*.2);\n}\n\n#ifdef ANIMATION_FRACTAL\nvoid main() {\n    vec2 uv = -1. + 2*inUV;\n    uv *= 2.;\n    uv.y *= scene.screenRatio;\n#else\nvoid mainImage( out vec4 oColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    genPitches();\n#endif\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0,0,-30.);\n    vec3 rd = normalize(vec3(uv, 1));\n\n    //cam(ro);cam(rd);\n\n    float t = 0.;\n    for (float i=0.; i<100.; i++) {\n        vec3 p = ro + rd*t;\n        vec2 h = map(p);\n        float d = h.x;\n        float m = h.y;\n        t += d;\n        if (t>FAR) {\n            break;\n        }\n        if (d < .001) {\n            vec3 sn = normal(p);\n            col = .5+.5*cos((sn*.3+.15)*PI+icolor+vec3(0,4,8).yxz + dot(sn,vec3(1))*PI );\n            break;\n        }\n        float a = atan(uv.y,uv.x);\n        col += (1./d *.02)*(.5*.5+cos(imoveFWD+a+vec3(0,2,4)));\n    }\n\n#ifdef ANIMATION_FRACTAL\n    col = pow(col, vec3(1.2, .9, .9) * 2.);\n#endif\n    oColor.xyz = pow(col,vec3(.4545));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfV3Dy.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MfK3Wt", "name": "AF - Chanel Final", "author": "tristanC", "description": "With more params. Demo:\n- https://youtu.be/qrnLYEljrCI", "tags": ["raymarching", "animationfractal"], "time_retrieved": "2024-05-15T23:19:56.031506", "image_code": "// Forked from https://www.shadertoy.com/view/ll3BDN\n// Created by Flopine in 2018-10-15\n// Default licence: CC-BY-NC-SA-3.0\n\n// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n// The shader has been adapted^Wbutchered to support new parameters\n// to be controlled from midi/audio inputs with animation-fractal.\n#ifndef ANIMATION_FRACTAL\n#define STEP1(x) ((x) - sin(x))\n#define STEP(x, offset, amp) (STEP1(STEP1(offset + x * amp)) * .15)\n#define is (iTime)\nfloat pitches[10];\nvoid genPitches() {\n  pitches[0] = STEP(is, 1., 1.);\n  pitches[1] = STEP(is, 2., 3.);\n  pitches[2] = STEP(is, 3., 2.);\n  pitches[3] = STEP(is, 4., 4.);\n  pitches[4] = STEP(is, 9., 1.);\n  pitches[5] = STEP(is, 3., 2.);\n  pitches[6] = STEP(is, 4., 2.);\n  pitches[7] = STEP(is, 9., 2.);\n  pitches[8] = STEP(is, 4., 2.);\n  pitches[9] = STEP(is, 9., 2.);\n}\n#define ipitch_1 pitches[0]\n#define ipitch_2 pitches[1]\n#define ipitch_3 pitches[2]\n#define ipitch_4 pitches[3]\n#define ipitch_5 pitches[4]\n#define ipitch_6 pitches[5]\n#define ipitch_7 pitches[6]\n#define ipitch_8 pitches[7]\n#define ipitch_9 pitches[8]\n#define ipitch_10 pitches[9]\n\n#define icolor (iTime*.1)\n#define imoveFWD (iTime*.1)\n#endif\n\n#define imove (im)\n\n#define ITER 64.\n#define PI 3.141592\n#define time iTime\n#define BPM 25./2.\n#define tempo 1.\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nfloat random (vec2 st)\n{return fract(sin(dot(st.xy, vec2(12.2544, 35.1571)))*5418.548416);}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nvec2 mo(vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y > p.x) p.xy = p.yx;\n    return p;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 path (float t)\n{\n    float a = sin(t*0.2 + 1.5), b = sin(t*0.2);\n    return vec2(a, a*b);\n}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p.xyz, p.yzx);\n    return min(p.x, min(p.y,p.z)) - d;\n}\n\nfloat prim1 (vec3 p)\n{\n    float c = cyl(p.xz, 0.1);\n    float per = 2.;\n    p.y += ipitch_5;\n    p.y = mod (p.y-per/2., per)-per/2.;\n    return smin(sphe(p, 0.3), c, 0.5);\n\n}\n\nfloat prim2 (vec3 p)\n{\n    float s = sphe(p,.9);\n    float o = od(p,.9);\n    p.xz *= rot(ipitch_4 + p.y*0.7);\n    p.xz = moda(p.xz, 2.*PI/5.);\n    p.x -= 1.;\n    return smin(prim1(p), max(-o,s), 0.1);\n}\n\nfloat prim3 (vec3 p)\n{\n    p.xz *= rot(sin(ipitch_6*.5)*.7 + p.x*0.1);\n    p.xy = mo(p.xy, vec2(2.));\n    p.yz *= rot(sin(ipitch_10)*.3 + p.x*0.1);\n    p.xz *= rot(ipitch_7 + p.y*0.7);\n    p *= 1.2 + (.1+.1*sin(ipitch_6));\n    return prim2(p);\n}\n\nfloat prim4 (vec3 p)\n{\n    p.yz *= rot(sin(ipitch_3*.5)*.7 + p.x*0.1);\n    p.xy = moda(p.xy, 2.*PI/4.);\n    p.x -= 4.;\n    return prim3(p);\n}\n\nfloat prim5 (vec3 p)\n{\n    float per = 17.;\n    p.xy *= rot(p.z*0.2);\n    p.z += ipitch_8;\n    p.z = mod(p.z-per/2., per) -per/2.;\n    return prim4(p);\n}\n\n#define moveScale 20.\nfloat primCenter (vec3 p)\n{\n    p.z -= imoveFWD*moveScale;\n    p.xz *= rot(ipitch_1*tempo);\n    p.xy *= rot(ipitch_2*tempo);\n    p *= 1.4;\n    return stmin(od(p, 1.), sphe(p,1.), 0.5, 6. + 2.*sin(ipitch_9));\n}\n\n\n\nfloat g = 0.;\nfloat SDF(vec3 p)\n{\n  float d = prim5(p);\n  d = smin(d, primCenter(p), 0.5);\n  g+=0.1/(0.1+d*d);\n  return d;\n}\n\n// The MIT License\n// See https://iquilezles.org/articles/palettes for more information\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 palette ( float t ) {\n // return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n // return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n}\n\n\n#ifdef ANIMATION_FRACTAL\nvoid main() {\n    vec2 uv = -.5 + inUV;\n    uv.y *= scene.screenRatio;\n    uv *= 1.4;\n#else\nvoid mainImage( out vec4 oColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    genPitches();\n#endif\n    vec3 ro = vec3(0.0,0.0,-10. + imoveFWD*moveScale); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n\n    float shad = 0.;\n    float dither = random(uv);\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.9 + dither*0.1;\n        p += d*rd * .5;\n    }\n\n    float t = length(ro-p);\n\n    vec3 pal = palette(icolor + length(uv));\n\n    vec3 c = vec3(shad) * pal;\n    c = mix(c, vec3(0.,0.,0.2), 1.-exp(-0.001 *t *t));\n    c += g* 0.025 * (1.-length(uv));\n\n#ifdef ANIMATION_FRACTAL\n    c = pow(c, vec3(1.2, .9, .9) * 1.7);\n#endif\n    oColor = vec4(c,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MfK3Wt.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Xf3Xz4", "name": "simple interpolation von formen", "author": "jonasfrey", "description": "Dieser shader dient als beispiel zur erklaerung der einfachen interpolation von zwei formen. \neinfache interpolation ", "tags": ["simple"], "time_retrieved": "2024-05-15T23:19:56.569189", "image_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat f_n_sd_heart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat f_n_sd_star(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // symmetry (optional)\n    p.x = abs(p.x);\n    \n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n    vec2 uv2 = fract(uv*vec2(2.,1.))-vec2(.5, 1.);\n    //uv = uv2;\n    uv*=1.5; // herauszoomen\n\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float n_sd_circ = dot(uv,uv);\n    float n_sd_star = f_n_sd_star(uv, .5, 5, 3.);\n    float n_sd_heart = f_n_sd_heart(uv+vec2(0., 0.5));\n    float n_t = sin(iTime)*.5+.5;//1.0 max, 0.0 min, 1.0 ->nur kreis, 0.0 ->nur stern\n    float n_interpoliert = n_t*n_sd_circ + (1.-n_t)*n_sd_star;\n    fragColor = vec4(smoothstep(0.05, 0.04, n_interpoliert));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xf3Xz4.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MftXzr", "name": ">. leino visuals", "author": "juk", "description": "visuals for >. leino site", "tags": ["simplexnoise", "asciiart"], "time_retrieved": "2024-05-15T23:19:58.050834", "image_code": "precision mediump float;\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n\nvec4 permute(vec4 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v){ \n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy));\n    vec3 x0 =   v - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy);\n    vec3 i2 = max( g.xyz, l.zxy);\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0); \n    vec4 p = permute(permute(permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0)) +\n        i.y + vec4(0.0, i1.y, i2.y, 1.0)) +\n        i.x + vec4(0.0, i1.x, i2.x, 1.0)\n    );\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z); // mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\n// Bitmap to ASCII (not really) fragment shader by movAX13h, September 2013\n// This is the original shader that is now used in PixiJs, FL Studio and various other products.\n\n// Here's a little tool for new characters: thrill-project.com/archiv/coding/bitmap/\n\nfloat character(int n, vec2 p) {\n\tp = floor(p*vec2(-4.0, 4.0) + 2.5);\n    \n    if (clamp(p.x, 0.0, 4.0) == p.x) {\n        if (clamp(p.y, 0.0, 4.0) == p.y) {\n        \tint a = int(round(p.x) + 5.0 * round(p.y));\n            \n\t\t\tif (((n >> a) & 1) == 1) return 1.0;\n\t\t}\t\n    }\n\treturn 0.0;\n}\n\nvec3 image(vec2 coord){\n    vec2 aspect;\n    \n    if(iResolution.x > iResolution.y) {\n        aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    } else { \n        aspect = vec2(iResolution.y / iResolution.x, 1.0);\n    }\n    \n    vec2 uv0 = coord.xy / iResolution.xy * aspect;\n    vec2 muv = iMouse.xy / iResolution.xy * aspect;\n    \n    //\n    \n    float noiseStrength = 0.16;\n    float noiseScale = 0.5;\n    \n    float speed = 0.1;\n    float noiseTime = iTime * speed;\n    \n    float noise = snoise(vec3(uv0 * noiseScale - noiseTime, noiseTime));\n    \n    uv0.x += noiseStrength * sin(noise * TAU);\n    uv0.y += noiseStrength * cos(noise * TAU);\n    \n    muv.x += noiseStrength * sin(noise * TAU);\n    muv.y += noiseStrength * cos(noise * TAU);\n    \n    //\n    \n    float strength =  0.6;\n\n    vec2 diff = uv0 - muv;\n    float distance = length(diff);\n\n    float scale = -smoothstep(\n        0.0,\n        1.0,\n        max(\n            0.,\n            1. - abs(distance)\n        )\n    );\n\n    vec2 fishUv = muv + normalize(diff) * scale;\n    \n    uv0 = uv0 * (1.0 - strength) + fishUv *  strength;\n    \n    //\n    \n    // Fork of \"Creation by Silexars\" by Danguafer. https://shadertoy.com/view/XsXXDn\n    // http://www.pouet.net/prod.php?which=57245\n    // If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n    vec3 c;\n    float l, z = iTime;\n    \n\tfor(int i = 0; i < 3; i++) {\n\t\tvec2 uv, p = uv0;\n\n\t\tp -= aspect/2.0;\n\t\tz += .03;\n        \n\t\tl = length(p);\n\t\tuv += p / l * (sin(z)+1.)*abs(sin(l*9.-z-z));\n\t\tc[i] = .05/length(mod(uv,1.)-.5);\n\t}\n    \n\treturn vec3(c/l);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    vec2 pix = fragCoord.xy;\n\tvec3 col = image(floor(pix/16.0)*16.0);\t\n\t\n\tfloat gray = 0.3 * col.r + 0.59 * col.g + 0.11 * col.b;\n\t    \n    // limited character set 5x5px\n    \n\tint n = 0;                            //   0px    \n\tif (gray > 4.0 / 25.0) n = 4;         // . 1px (bg tuned to 4/25)\n\tif (gray > 5.0 / 25.0) n = 8521864;   // > 5px\n\tif (gray > 8.0 / 25.0) n = 17318430;  // l 8px\n\tif (gray > 9.0 / 25.0) n = 14815374;  // i 9px\n\tif (gray > 12.0 / 25.0) n = 15255086; // o 12px\n    if (gray > 13.0 / 25.0) n = 18667121; // n 13px\n\tif (gray > 15.0 / 25.0) n = 33059359; // e 15px\n\n\tvec2 p = mod(pix/8.0, 2.0) - vec2(1.0);\n    \n    col = gray * vec3(character(n, p));\n\n\tfragColor = vec4(col, 1.0);\n    // fragColor = vec4(image(fragCoord.xy), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MftXzr.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4cdXR8", "name": "2D Waves Simulation", "author": "afsadfasdfsadf", "description": "Create waves with left click/dragging. Press O to toggle between creating waves and obstacles. Press R to reset obstacles. Press S to reset waves. Press T to load a heightmap texture. See Buffer A for additional settings/demos.", "tags": ["waves", "simulation", "interactive"], "time_retrieved": "2024-05-15T23:19:58.398007", "image_code": "// See Buffer A for simulation code.\n// \n// NOTE: 𝚜̶𝚠̶𝚒̶𝚝̶𝚌̶𝚑̶𝚒̶𝚗̶𝚐̶ ̶𝚘̶𝚏̶𝚏̶ ̶𝚝̶𝚑̶𝚎̶ ̶𝚝̶𝚊̶𝚋̶/̶𝚠̶𝚒̶𝚗̶𝚍̶𝚘̶𝚠̶ ̶𝚠̶𝚒̶𝚕̶𝚕̶ ̶𝚌̶𝚊̶𝚞̶𝚜̶𝚎̶ ̶𝚝̶𝚑̶𝚎̶ ̶𝚜̶𝚒̶𝚖̶𝚞̶𝚕̶𝚊̶𝚝̶𝚒̶𝚘̶𝚗̶ ̶𝚝̶𝚘̶ ̶𝚐̶𝚕̶𝚒̶𝚝̶𝚌̶𝚑̶ ̶𝚘̶𝚞̶𝚝̶.\n// ^ This has been fixed.\n// \n// GLSL Tutorial:\n// Anything prepended with two slashes is a commment and not part of the code.\n// Some features are toggled by commenting out the code.\n// Be sure to hit the > at the bottom left corner after changes.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float v = texture(iChannel0, uv).x;\n    float f = (1.0 - 1.0/(1.0 + abs(v))) * sign(v);\n    \n    v = texture(iChannel0, uv).w;\n    float h = (1.0 - 1.0/(1.0 + abs(v))) * sign(v);\n    \n    // Linear renderer:\n    //fragColor = (0.3*texture(iChannel0, uv).xxxx + vec4(0.0, 0.0, texture(iChannel0, uv).z, 0.0));\n    \n    // Inverse renderer (higher values approach but never reach full brightness):\n    fragColor = vec4(-f, 0.0, f, 1.0);\n    \n    //if (h > 0.491) {\n        fragColor += vec4(0.0, h, 0.0, 0.0);\n    //}\n    fragColor.z += texture(iChannel0, uv).z*0.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Use the Shadertoy Custom Textures extension to upload a custom heightmap into iChannel2.\n// https://chrome.google.com/webstore/detail/jgeibpcndpjboeebilehgbpkopkgkjda\n\n\nfloat lDistance(vec2 p0, vec2 p1, vec2 p2) {\n    vec2 p01 = p0 - p1;\n    vec2 p21 = p2 - p1;\n    float dot = p01.x * p21.x + p01.y * p21.y;\n    float len_sq = p21.x * p21.x + p21.y * p21.y;\n    float param = -1.0;\n    if (len_sq != 0.0) param = dot / len_sq;\n    \n    vec2 p = p1 + param * p21;\n    \n    if (param < 0.0) p = p1;\n    else if (param > 1.0) p = p2;\n    \n    vec2 d = p0 - p;\n    return length(d);\n}\nvec2[] dss = vec2[] (\nvec2(1.0, 0.0),\nvec2(0.707, 0.707),\nvec2(0.0, 1.0),\nvec2(-0.707, 0.707),\nvec2(-1.0, 0.0),\nvec2(-0.707, -0.707),\nvec2(0.0, -1.0),\nvec2(0.707, -0.707),\nvec2(2.0, 0.0),\nvec2(1.414, 1.414),\nvec2(0.0, 2.0),\nvec2(-1.414, 1.414),\nvec2(-2.0, 0.0),\nvec2(-1.414, -1.414),\nvec2(0.0, -2.0),\nvec2(1.414, -1.414));\n\nfloat k = 5.0;\nfloat speed = 5.0;\nfloat pi = 3.1415926;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // (displacement, velocity, obstacle, 1.0);\n    vec2 uv = fragCoord.xy;\n    vec2 p1 = iMouse.xy;\n    vec2 p3 = vec2(iTime*60.0 + 100.0, 1080.0 * 0.5);\n    vec2 p4 = vec2(iTime*iTime*iTime + 100.0, 1080.0 * 0.75);\n    vec2 p5 = vec2(iTime*30.0 + 100.0, 1080.0 * 0.25);\n    vec2 p2 = texture(iChannel1, vec2(0.25, 0.5)).zw;\n    vec2 mp = texture(iChannel1, vec2(0.75, 0.5)).xy;\n    \n    float d = lDistance(uv, p1, p2);\n    // pulsed mouse dragging:    (remove this ↓ semicolon and two slashes.)\n    // brush radius:    ↓\n    // brush smoothness:↓     ↓\n    // brush strength:  ↓     ↓          ↓\n    d = clamp(1.0-pow(d/20.0, 5.0), 0.0, 1.0);// * (sign(sin(float(iFrame)*pi+pi/2.0)-0.9)*0.5 + 0.5);\n    \n    if (mp.x <= 0.0 || mp.y <= 0.0 ) d=0.0;\n    \n    // speed of sound demos: (uncomment the three lines below)\n    //d += clamp(1.0-distance(uv, p3)/10.0, 0.0, 1.0) * 5.0 * (sign(sin(float(iFrame)*0.2*pi+pi/2.0)-0.9)*0.5 + 0.5);\n    //d += clamp(1.0-distance(uv, p4)/10.0, 0.0, 1.0) * 5.0 * (sign(sin(float(iFrame)*0.2*pi+pi/2.0)-0.9)*0.5 + 0.5);\n    //d += clamp(1.0-distance(uv, p5)/10.0, 0.0, 1.0) * 5.0 * (sign(sin(float(iFrame)*0.2*pi+pi/2.0)-0.9)*0.5 + 0.5);\n    \n    vec4 old = texture(iChannel0, uv/iResolution.xy);\n    \n    float isO = texture(iChannel3, vec2(79.0/255.0, 1.0)).x;\n    float isR = texture(iChannel3, vec2(82.0/255.0, 0.0)).x;\n    float isS = texture(iChannel3, vec2(83.0/255.0, 0.0)).x;\n    float isT = texture(iChannel3, vec2(84.0/255.0, 0.0)).x;\n    float v = old.y;\n    float o = old.z;\n    float h = old.w;\n    float dT = clamp(iTimeDelta, 0.003, 0.03);\n    vec2 iuv = uv / iResolution.xy;\n    \n    if (isR > 0.5) {\n        // Velocity based on tension demo:\n        if (iuv.x * 0.25 + iuv.y > 0.3) o = 0.7;\n        else o = 0.3;\n        \n        // Refraction demo:\n        if (iuv.x + iuv.y * 0.5 > 0.7) o = 0.7;\n        else o = 0.0;\n        \n        // Load texture from iChannel2:\n        o = length(texture(iChannel2, iuv+vec2(0.5,0.0)).xyz);\n        if (o < 0.9) {\n             o = 0.0;\n        } else {\n             o = 1.0;\n        }\n    }\n    if (isT > 0.5) {\n        h = (length(texture(iChannel2, iuv+vec2(0.5, 0.0)).xyz));\n        //float t = 0.95;\n        //if (h < t) {\n        //    d = t - h;\n        //}\n    }\n    \n    if (isO > 0.5) {\n        o = max(o, d);\n        d = 0.0;\n    }\n    d += old.x;\n    \n    // Left-to-right waves:\n    //if (fragCoord.x < 2.0/* && iTime < 3.14/5.0*/) d = sin(iTime*5.0)*5.0 + 5.0;\n    \n    for (int i = 0; i < 8; i++) {\n        vec2 ds = dss[i];\n        vec2 s = ds + uv;\n        float value = texture(iChannel0, s/iResolution.xy).x;\n        float delta = value - old.x;\n        float xo = texture(iChannel0, s/iResolution.xy).z;\n        float xh = texture(iChannel0, s/iResolution.xy).w;\n        if (h > abs(d)) xo += (h - abs(d)) * 2.0;\n        v += delta * dT * k * speed * (1.0-clamp(xo, 0.0, 1.0));\n    }\n    \n    d += v * dT * speed;\n    //if (o > 0.9999) {\n    //    d = 0.0;\n    //    v = 0.0;\n    //}\n    //if (d < h) {\n    //    v = 0.0;\n    //}\n    \n    if (isS > 0.5) {\n        d = 0.5;\n        v = 0.0;\n    }\n    \n    fragColor = vec4(d, v, o, h);\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This is for reading mouse input.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x/iResolution.x < 0.5) {\n        float x = iMouse.z * 2.0 - 1.0;\n        fragColor = vec4(iMouse.xy, texture(iChannel0, vec2(0.25, 0.5)).xy);\n    } else {\n        fragColor = vec4(iMouse.z, texture(iChannel0, vec2(0.75, 0.5)).xyz);\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cdXR8.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "4ctXR8", "name": "Fork SoundEclip Xtrullor 059", "author": "Xtrullor", "description": "Visual enhancments and code refactoring over SoundEclipse Created by DuckMonster (https://www.shadertoy.com/view/4tGXzt)\n\nYou can adjust holo brightness by forking this project and changing multiplier value at 73 row (brightness * <your_value>)", "tags": ["visualization", "mic", "virtualdj"], "time_retrieved": "2024-05-15T23:19:59.491439", "image_code": "// Use a more precise definition of PI for mathematical operations\nconst float PI = 3.141592653589793;\nconst float FREQ_RANGE = 64.0; // or another appropriate value\n\n#define RADIUS 0.6\n#define BRIGHTNESS 0.2\n#define SPEED 0.5\n\n\n// Convert HSV to RGB: Ensuring const correctness and vec3 for p\nvec3 hsv2rgb(const vec3 c) {\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 gradientColor(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67); // these control the range of colors\n    return a + b * cos(2.0 * PI * (c * t + d));\n}\n\n// Improved luminance calculation with const quality for weights\nfloat luminance(const vec3 color) {\n  const vec3 lumWeight = vec3(0.299, 0.587, 0.114);\n  return dot(color, lumWeight);\n}\n\n\n// Enhanced frequency retrieval with smooth interpolation between index frequencies\nfloat getFrequency(float x) {\n\tfloat baseIndex = floor(x * FREQ_RANGE) / FREQ_RANGE;\n\tfloat sum = 0.0;\n\tfloat count = 0.0;\n\n\n\t// Smoothing by averaging over a range of indices\n\tfor(float i = -2.0; i <= 2.0; i += 1.0){\n\t\tsum += texture(iChannel0, vec2(baseIndex + i / FREQ_RANGE, 0.25)).x;\n\t\tcount += 1.0;\n\t}\n\n\n\treturn (sum / count) + 0.06;\n}\n\n\n// Blending frequencies for smoother visual transitions\nfloat blendFrequencies(const float x) {\n    float blended = smoothstep(0.0, 1.0, fract(x * FREQ_RANGE));\n\n\n    float freq1 = getFrequency(floor(x * FREQ_RANGE) / FREQ_RANGE);\n    float freq2 = getFrequency(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE);\n\n\n    return mix(freq1, freq2, blended);\n}\n\n\n// Rendering the halo effect\nvec3 renderHalo(const vec2 fragment, const float radius) {\n    float dist = length(fragment);\n    float ring = 1.0 / abs(dist - radius);\n    float brightness = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n    vec3 col = vec3(0.0);\n\n\n    float angle = atan(fragment.x, fragment.y);\n    vec3 hsvColor = vec3((angle + iTime * 0.25) / (PI * 2.0), 1.0, 1.0);\n    col += hsv2rgb(hsvColor) * ring * brightness;\n\n    float frequency = max(blendFrequencies(abs(angle / PI)) - 0.02, 0.0);\n    col *= frequency;\n    col *= smoothstep(radius * 0.5, radius, dist);\n    \n    float t = iTime * 0.1 + (angle + 0.5) / (PI * 2.0); // Adjust time influence\n    col += gradientColor(t) * ring * (brightness * 0.2); // Use the gradient function\n\n    return col;\n}\n\n// Generating the line visual based on frequency\nvec3 renderLine(const vec2 fragment, const float radius, const float x) {\n    vec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n    float freq = abs(fragment.x * 0.5);\n    col *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getFrequency(freq);  \n    col *= smoothstep(radius, radius * 1.8, abs(fragment.x));\n    return col;\n}\n\n\n// Main image function to render the visuals\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 fragPos = (fragCoord / iResolution.xy - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\n\n    vec3 color = vec3(0.0134, 0.052, 0.1);\n    color += renderHalo(fragPos, RADIUS);\n\n\n    // Rotating the position for dynamic effects\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c, s, -s, c) * fragPos;\n    color += renderLine(rot, RADIUS, rot.x);\n\n\n    color += max(luminance(color) - 1.0, 0.0);\n\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ctXR8.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "McKGzG", "name": "Burning Ship Fractal Viewer", "author": "Bingle", "description": "A simple shader for viewing the burning ship fractal with antialiasing and shading. Use WASD to move around and arrow keys to zoom.", "tags": ["fractal", "interactive"], "time_retrieved": "2024-05-15T23:20:00.216893", "image_code": "//#define GRID\n#define SHADE\n\n// Max fractal iterations\n#define MAXITERS 120\n// Anti-aliasing (will compute (AA*2+1)^2 samples, so 1 for 0, 9 for 1, 25 for 2...)\n#define AA 1\n\n// AA breaks down near precision-limit levels of zoom\n// Also, if the AA looks like barf, you're probably looking at a very noisy boundary.\n\nvec4 f(vec4 p){\n    return vec4(p.x*p.x-p.y*p.y+p.z,abs(2.0*p.x*p.y)+p.w,p.zw);\n    // Remove the \"abs\" (keep the parentheses) for a mandelbrot fractal!\n}\n\nvec2 UV(vec2 px,vec3 iResolution,vec4 cam){\n    return (px-0.5*iResolution.xy)/iResolution.y*cam.z-cam.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragCoord.y = iResolution.y-fragCoord.y; // Mirror vertically except im lazy (and who's gonna stop me)\n    \n    vec4 cam = texelFetch(iChannel0,TEXEL_CAM,0);\n    \n    float pxSize = 1.0/iResolution.y*cam.z;\n    float gridSize = pow(2.0,round(log2(0.25*cam.z)));\n    \n    vec2 uv = UV(fragCoord,iResolution,cam);\n    \n    float val = 0.0;\n    float iters = 0.0;\n    for (int x=0-AA;x<1+AA;x++){\n        for (int y=0-AA;y<1+AA;y++){\n            vec4 p = (uv+(0.5/float(AA))*pxSize*vec2(x,y)).xyxy; // I chose 0.333 arbitrarily, as I needed a value large enough to produce nice antialiasing but small enough to not just blur everything.\n            for (int i=0;i<MAXITERS;i++){\n                p = f(p);\n                if (isinf(p.x) || isinf(p.y)){\n                    iters+=float(i);\n                    break;\n                }\n            }\n            if (length(p.xy)<4.0){\n                val+=1.0;\n            }\n        }\n    }\n    \n    float pxCount = float((2*AA+1)*(2*AA+1));\n    \n    val /= pxCount; // Because we do 9 antialiasing samples\n    iters /= pxCount;\n    \n    vec3 col = vec3(val);\n    #ifdef SHADE\n    col = mix(2.0*vec3(0,0,iters/float(MAXITERS)),col,val);\n    #endif\n    \n    #ifdef GRID\n    vec2 offset = UV(fragCoord-vec2(1.0),iResolution,cam);\n    if (offset.x!=uv.x && offset.y!=uv.y){ // Check if we're hitting precision limits\n        float halfCell = 0.5*gridSize;\n        if (mod(uv.x-halfCell,gridSize)>=halfCell && mod(offset.x-halfCell,gridSize)<halfCell){\n            col+=vec3(0.0,0.5,0.0);\n        }\n        if (mod(uv.y-halfCell,gridSize)>=halfCell && mod(offset.y-halfCell,gridSize)<halfCell){\n            col+=vec3(0.0,0.5,0.0);\n        }\n    }\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define  KEY_LEFT 37\n#define    KEY_UP 38\n#define KEY_RIGHT 39\n#define  KEY_DOWN 40\n\n#define     KEY_A 65\n#define     KEY_D 68\n#define     KEY_S 83\n#define     KEY_W 87\n\n// Zooming is framerate dependant. I can't figure out how to uncouple zooming from the framerate effectively.\n// One would think simply multiplying ZOOMFAC by the timestep would work, but what if the timestep is greater than 1? I know such a situation is absurd, but it proves that this method is flawed. I'm not sure how to fix this.\n#define ZOOMFAC 0.02\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    ivec2 iCoord = ivec2(fragCoord);\n    vec4 data = texelFetch(iChannel0,iCoord,0);\n    \n    if (iCoord == TEXEL_CAM){\n        \n        // (X position, Y position, Zoom, Unused)\n        \n        float moveScale = iTimeDelta*data.z;\n        if (texelFetch(iChannel1,ivec2(KEY_W,0),0).r>0.5){\n            data.y+=moveScale;\n        }\n        if (texelFetch(iChannel1,ivec2(KEY_S,0),0).r>0.5){\n            data.y-=moveScale;\n        }\n        if (texelFetch(iChannel1,ivec2(KEY_A,0),0).r>0.5){\n            data.x+=moveScale;\n        }\n        if (texelFetch(iChannel1,ivec2(KEY_D,0),0).r>0.5){\n            data.x-=moveScale;\n        }\n        \n        if (texelFetch(iChannel1,ivec2(KEY_UP,0),0).r>0.5){\n            data.z*=(1.0-ZOOMFAC);\n        }\n        if (texelFetch(iChannel1,ivec2(KEY_DOWN,0),0).r>0.5){\n            data.z/=(1.0-ZOOMFAC);\n        }\n        \n        if (texelFetch(iChannel1,ivec2(KEY_LEFT,0),0).r>0.5){\n            data.z*=(1.0-3.0*ZOOMFAC);\n        }\n        if (texelFetch(iChannel1,ivec2(KEY_RIGHT,0),0).r>0.5){\n            data.z/=(1.0-3.0*ZOOMFAC);\n        }\n        \n        if (data.z<=0.0 || iFrame==0){\n            data = vec4(0.5,0.5,2.5,0.0);\n        }\n        \n        data.x = clamp(data.x,-6.0,7.0);\n        data.y = clamp(data.y,-3.0,4.0);\n        \n        data.z = min(data.z,9.0);\n    }\n    \n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TEXEL_CAM ivec2(0,0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McKGzG.jpg", "access": "api", "wgpu-test": "error"}
{"id": "McdSzr", "name": "Subpixel Anti-Aliasing", "author": "beans_please", "description": "looks kinda weird tbh, am I doing something wrong?", "tags": ["text", "antialiasing", "rendering", "subpixel", "spaa"], "time_retrieved": "2024-05-15T23:20:00.671606", "image_code": "const float render_res = 65.;\n\nvec3 render(vec2 coord)\n{\n    vec2 uv = 4. * screen_to_uv_fit(coord, vec2(render_res));\n    uv.x += .22 * iTime;\n    return vec3(cos(uv.x) * sin(uv.y) < sin(TAU * .03 * iTime));\n}\n\nvec3 discrete_render(ivec2 icoord)\n{\n    vec2 coord = vec2(icoord) + .5;\n    vec3 col = vec3(0);\n    \n    col.r += render(coord + vec2(-.333, -.333)).r;\n    col.r += render(coord + vec2(-.333, 0)).r;\n    col.r += render(coord + vec2(-.333, .333)).r;\n    \n    col.g += render(coord + vec2(0, -.333)).g;\n    col.g += render(coord + vec2(0, 0)).g;\n    col.g += render(coord + vec2(0, .333)).g;\n    \n    col.b += render(coord + vec2(.333, -.333)).b;\n    col.b += render(coord + vec2(.333, 0)).b;\n    col.b += render(coord + vec2(.333, .333)).b;\n    \n    return col * .333;\n}\n\nvec3 view_transform(vec3 col)\n{\n    // avoid any negative values before using power functions\n    col = max(col, 0.);\n\n    // OETF (Linear BT.709 I-D65 to sRGB 2.2)\n    col = pow(col, vec3(1. / 2.2));\n    col = clamp(col, 0., 1.);\n\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = screen_to_uv_fit(frag_coord, iResolution.xy);\n    vec3 col = discrete_render(ivec2(floor(uv * render_res * .5)));\n\n    // view transform\n    col = view_transform(col);\n\n    // output\n    frag_col = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "#define SHADERTOY 0\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*_________________ math utils ________________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n// (heavily modified)\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_on_circle()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_on_sphere()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_on_hemisphere(vec3 normal)\n{\n    vec3 v = random_on_sphere();\n    return v * sign(dot(v, normal));\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 v = random_in_sphere();\n    return v * sign(dot(v, normal));\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n\n\n/*______________ halton sequence ______________*/\n\n// * idx starts at 1\nfloat halton(int base, int idx)\n{\n    float result = 0.;\n    float digit_weight = 1.;\n    while (idx > 0)\n    {\n        digit_weight /= float(base);\n        result += float(idx % base) * digit_weight;\n        idx /= base;\n    }\n    return result;\n}\n\n// * idx starts at 1\nvec2 halton_2d(int idx)\n{\n    return vec2(halton(2, idx), halton(3, idx));\n}\n\n// * idx starts at 1\nvec3 halton_3d(int idx)\n{\n    return vec3(halton(2, idx), halton(3, idx), halton(5, idx));\n}\n\n// * idx starts at 1\nvec4 halton_4d(int idx)\n{\n    return vec4(\n        halton(2, idx),\n        halton(3, idx),\n        halton(5, idx),\n        halton(7, idx)\n    );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McdSzr.jpg", "access": "api", "wgpu-test": "error"}
{"id": "McdXzn", "name": "Hemispherical raymarched AO", "author": "djancool", "description": "Hemispherical Ambient Occlusion using raymarching. We raymarch against the heightmap instead of random samples as random samples can give false negatives", "tags": ["ao", "ambientocclusion", "hemisphere"], "time_retrieved": "2024-05-15T23:20:01.355740", "image_code": "// Fork of \"Hemispherical AO\" by djancool. https://shadertoy.com/view/MftSzn\n// 2024-04-19 10:51:41\n\n//#define randomDirPerPixel\n\nvec3 hash3( uvec3 x )\n{\n    const uint k = 1103515245U;\n\n    x = ((x >> 8U) ^ x.yzx) * k;\n    x = ((x >> 8U) ^ x.yzx) * k;\n    x = ((x >> 8U) ^ x.yzx) * k;\n\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nvec3 rndHemiDir(vec3 normal, uvec3 index)\n{\n    vec3 rnd = 2.0 * (0.5 - hash3(index));\n    rnd = tan(rnd);\n    rnd = normalize(rnd);\n\n    // Uniform distribution\n    return rnd * sign(dot(normal, rnd));\n\n    // Cosine weighted distribution // We will have les samples on angles, wich makes them darker, wich simulates lambertian\n    return normalize(normal + rnd);\n}\n\nvec3 uvToPos(vec2 uv)\n{\n    vec3 pos = vec3(0.0);\n    pos.xy = uv;\n    pos.z = texture(iChannel0, uv).r / 1.0;\n    \n    return pos;\n}\n\nvec3 getNormal(vec2 uv)\n{\n    float pixelSize = 5.0 / iChannelResolution[0].r; // use higher number than 1/resolution to smooth out normal to reduce artifacts\n\n    vec3 pos_0 = uvToPos(uv);\n    vec3 pos_x = uvToPos(uv + vec2(pixelSize, 0.0));\n    vec3 pos_y = uvToPos(uv + vec2(0.0, pixelSize));\n    \n    vec3 normal = normalize(cross(pos_0 - pos_x, pos_0 - pos_y));\n    return normal;\n}\n\nfloat getAO(vec2 uv, vec2 fragCoord)\n{\n    const float sampleDist = 0.3;\n    const int sampleCount = 100;\n\n    vec3 position = uvToPos(uv);\n    vec3 normal = getNormal(uv);\n    \n    float AO = 0.0;\n    \n    for(int i = 0; i < sampleCount; i++)\n    {\n        #ifdef randomDirPerPixel\n            uvec3 index = uvec3(uvec3(i, i + 50, i + 100) + uvec3(fragCoord, 0.0));\n        #else\n            uvec3 index = uvec3(uvec3(i, i + 50, i + 100));\n        #endif\n        vec3 sampleDir = rndHemiDir(normal, index);\n        \n        bool isOccluded = false;\n        \n        for(int j = 1; j < 5; j++)\n        {\n            vec3 samplePos = position + sampleDir / 5.0 * float(j) * sampleDist;\n            float sampleHeight = uvToPos(samplePos.xy).z;\n            \n            if(samplePos.z < sampleHeight) \n           {\n               AO += 1.0;\n               break;\n            }\n        }\n\n    }\n    \n    return 1.0 - AO / float(sampleCount);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y * 0.75;\n\n    float AO = getAO(uv, fragCoord);\n\n    fragColor = pow(vec4(AO), vec4(1.0 / 2.2));\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McdXzn.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MftSzn", "name": "Hemispherical AO", "author": "djancool", "description": "Hemispherical Ambient Occlusion", "tags": ["ao", "ambientocclusion", "hemisphere"], "time_retrieved": "2024-05-15T23:20:02.073366", "image_code": "//#define randomDirPerPixel\n\nvec3 hash3( uvec3 x )\n{\n    const uint k = 1103515245U;\n\n    x = ((x >> 8U) ^ x.yzx) * k;\n    x = ((x >> 8U) ^ x.yzx) * k;\n    x = ((x >> 8U) ^ x.yzx) * k;\n\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nvec3 rndHemiDir(vec3 normal, uvec3 index)\n{\n    vec3 rnd = 2.0 * (0.5 - hash3(index));\n    rnd = tan(rnd);\n    rnd = normalize(rnd);\n\n    // Uniform distribution\n    return rnd * sign(dot(normal, rnd));\n\n    // Cosine weighted distribution // We will have les samples on angles, wich makes them darker, wich simulates lambertian\n    return normalize(normal + rnd);\n}\n\nvec3 uvToPos(vec2 uv)\n{\n    vec3 pos = vec3(0.0);\n    pos.xy = uv;\n    pos.z = texture(iChannel0, uv).r / 1.0;\n    \n    return pos;\n}\n\nvec3 getNormal(vec2 uv)\n{\n    float pixelSize = 5.0 / iChannelResolution[0].r; // use higher number than 1/resolution to smooth out normal to reduce artifacts\n\n    vec3 pos_0 = uvToPos(uv);\n    vec3 pos_x = uvToPos(uv + vec2(pixelSize, 0.0));\n    vec3 pos_y = uvToPos(uv + vec2(0.0, pixelSize));\n    \n    vec3 normal = normalize(cross(pos_0 - pos_x, pos_0 - pos_y));\n    return normal;\n}\n\nfloat getAO(vec2 uv, vec2 fragCoord)\n{\n    const float sampleDist = 0.3;\n    const int sampleCount = 100;\n\n    vec3 position = uvToPos(uv);\n    vec3 normal = getNormal(uv);\n    \n    float AO = 0.0;\n    \n    for(int i = 0; i < sampleCount; i++)\n    {\n        #ifdef randomDirPerPixel\n            uvec3 index = uvec3(uvec3(i, i + 50, i + 100) + uvec3(fragCoord, 0.0));\n        #else\n            uvec3 index = uvec3(uvec3(i, i + 50, i + 100));\n        #endif\n    \n        vec3 samplePos = rndHemiDir(normal, index) * sampleDist * hash3(index + 100u).x + position;\n        float sampleHeight = uvToPos(samplePos.xy).z;\n        \n        if(samplePos.z < sampleHeight) AO += 1.0;\n    }\n    \n    return 1.0 - AO / float(sampleCount);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y * 0.75;\n\n    float AO = getAO(uv, fragCoord);\n\n    fragColor = pow(vec4(AO), vec4(1.0 / 2.2));\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MftSzn.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "4ctSzn", "name": "scrolling shadertoy", "author": "ianertson", "description": "test", "tags": ["test"], "time_retrieved": "2024-05-15T23:20:02.122124", "image_code": "#define R iResolution.xy\n\nfloat chr(vec2 p, int c) {\n    if (c == 32) return 0.0;\n    p = (((p-vec2(0, 1))+vec2(float(int(1.0+float(c-97))),\n    int(-6 - (c > 111 ? 1 : 0))))/16.);\n    return texture(iChannel0, p).x;\n}\n\n\n#define TEXT(P, CHARS)\\\n{\\\n  int chars[] = int[] CHARS;\\\n  int len = chars.length();\\\n  vec2 id = floor((P)*(float(len/2)+1.));\\\n  vec2 lv = fract((P)*(float(len/2)+1.));\\\n  int idx = int(id.x);\\\n  col += (idx < 0 || idx >= len || abs(lv.x-0.9)<0.1 || abs(lv.y-0.9)<0.1) ? 0.0 : \\\n      chr(lv, chars[idx]);\\\n}\n\nvoid mainImage(out vec4 o, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = fc.xy/R.y;\n  uv.y -= 0.15*iTime;\n  TEXT(uv, (115, 104, 97, 100, 101, 114, 116, 111, 121))\n  o = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ctSzn.jpg", "access": "api", "wgpu-test": "error"}
{"id": "Mf3Xzr", "name": "NotSoGreeeen - Python turtle", "author": "NotSoGreeeen", "description": "A simple drawing program, PLEASE feel free to use this, as well as messing around with the sample code\nCommands:\nforwards(float);\nrotate(float);", "tags": ["turtle"], "time_retrieved": "2024-05-15T23:20:02.647952", "image_code": "#define MAX_LENGTH 1000\n\nvec2 lines[MAX_LENGTH];\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\tfloat c = length(pa - h * ba);\n    return (1. - smoothstep(.0, .035, abs(c)));\n} //create the line segments\n\nint index = 1;\nfloat rotation = 0.;\n\nvoid forwards(float dist) {\n    vec2 coords;\n    vec2 prevCoords = lines[index - 1];\n    float rad = radians(rotation);\n    float vecX = dist * cos(rad);\n    float vecY = dist * sin(rad);\n    coords = prevCoords + vec2(vecX, vecY);\n    lines[index] = coords;\n    index++;\n}\n\nvoid rotate(float dist) {\n    rotation -= dist;\n    rotation = mod(rotation, 360.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // \"Libraries\": top centers coordinate grid, bottom creates a blank canvas on that grid\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 color = vec3(0.);\n    uv *= 4.;\n    \n    \n    //example code:\n    for (int i = 1; i <= 2; i++) {\n        rotate(-30.);\n        forwards(2.);\n        rotate(135.);\n        forwards(4.);\n        rotate(135.);\n        forwards(2.);\n        rotate(-30.);\n        forwards(1.);\n        rotate(-30.);\n        forwards(1.);\n    }\n    \n    \n    for (int i = 1; i < index; i++) {\n        float line = line_segment(uv, lines[i], lines[i - 1]) - 0.;\n        color += line;\n    } //draw each point as a line\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mf3Xzr.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "mssfW4", "name": "Fork Plastic Cr chelley 145", "author": "chelley", "description": "iteration from Wasp Blanket https://www.shadertoy.com/view/NlVBz1", "tags": ["feedback"], "time_retrieved": "2024-05-15T23:20:03.040530", "image_code": "\n// Plastic Cream\n\n// i was playing with Conway's game of life cellular automaton\n// thinking i had an intuition for a smooth fading version\n// with a lifetime gradient and a neighbor ratio\n\n// found by accident that it can make reaction diffusion patterns\n// got overwhelmed but couldn't posted another turing pattern feedback\n// so i went a bit too far and now it's weird enough as i like it\n\n// iteration from Wasp Blanket https://www.shadertoy.com/view/NlVBz1\n\n#define T(uv) abs(texture(iChannel0,uv).b)\n#define N(v) normalize(v)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 frame = texture(iChannel0, uv);\n    \n    // tints\n    vec3 tint = .1 + .5 * cos(vec3(5,8,10)*5. );\n    fragColor = vec4(frame.r * tint, 1);\n    tint = .5 + .5 * cos(vec3(1,2,3)*5. + length(uv-.5)*2. + 3.);\n    fragColor.rgb += frame.g * tint;\n    \n    // normal\n    float height = 0.;\n    vec3 unit = vec3(10./iResolution.xy, 0);\n    vec3 normal = normalize(vec3(T(uv+unit.xz)-T(uv-unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 T(uv) * height));\n    \n    // light\n    fragColor += vec4(.5) * clamp(dot(normal, N(vec3(-5,8,1))), 0., 1.);\n    fragColor += vec4(.5) * pow(clamp(dot(normal, N(vec3(-1,1,2))), 0., 1.), 20.);\n    \n    // shadows\n    fragColor -= vec4(0.5) * clamp(dot(normal, N(vec3(0,-4,1))), 0., 1.);\n    fragColor *= pow(max(abs(frame.b)-.02,.0), .5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float speed = 1.;\nconst float turbulences = 1.;\nconst float attraction = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 1)\n    {\n        fragColor = vec4(hash23(vec3(fragCoord, 0.)), 0, 0);\n        return;\n    }\n\n    // coordinates\n    vec2 uv = fragCoord/R;\n    vec2 mouse = (iMouse.xy - R.xy / 2.)/R.y;\n    vec2 p = (fragCoord.xy - R.xy / 2.)/R.y;\n    vec2 offset = vec2(0);\n    float dist = length(p);\n    \n    // turbulences\n    float noise = fbm(vec3(p * 3., dist-iTime*.1*speed));\n    noise = pow(abs(noise), 0.5);\n    float angle = noise * 6.28;\n    offset += turbulences * vec2(cos(angle), sin(angle));\n\n    // attraction\n    offset += attraction * normalize(p) * sin(dist * 9. + iTime);\n    \n    float dt = 30. * iTimeDelta;\n    \n    // displace frame buffer\n    vec4 frame = texture(iChannel0, uv + dt * offset * speed / R);\n    \n    // edge spawn\n    bool spawn = fragCoord.x < 1. || fragCoord.x > R.x-1.\n              || fragCoord.y < 1. || fragCoord.y > R.y-1.\n              || (iMouse.z > .0 && length(p-mouse) < 50./R.y);\n    \n    // spawn from noise\n    vec2 rng = hash23(vec3(fragCoord, iFrame));\n    if (spawn) frame = vec4(step(0.5, rng.x),step(0.5, rng.y),0,0);\n    \n    // neighbor values\n    vec2 neighbors = vec2(0);\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for (float y = -1.; y <= 1.; ++y)\n        {\n            if (x == 0. && y == 0.) continue;\n            neighbors += texture(iChannel0, uv+vec2(x,y)/R).rg;\n        }\n    }\n    \n    // animation fade\n    frame.r += 4.0 * (neighbors.r > 4.0 ? 1. : -1.) * iTimeDelta;\n    frame.g += 4.0 * (neighbors.g > 4.0 ? 1. : -1.) * iTimeDelta;\n    \n    fragColor = vec4(clamp(frame.rg, 0., 1.), noise, 1.);//, frame.a + (neighbors.r + neighbors.g) * iTimeDelta * .1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}\n\nfloat fbm (vec3 seed)\n{\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 3; ++i) {\n        seed += result / 2.;\n        result += gyroid(seed/a)*a;\n        a /= 2.;\n    }\n    return result;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/mssfW4.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "4XSSRD", "name": "Fork Displaceme chelley 290", "author": "chelley", "description": "Displacement mapping with chromatic dispersion. The displacement vectors are supplied by an underlying dynamical system. Click to paint.", "tags": ["displacement", "chromatic", "aberration", "mapping", "dispersion"], "time_retrieved": "2024-05-15T23:20:03.765683", "image_code": "// displacement amount\n#define DISP_SCALE 2.0\n\n// chromatic dispersion samples\n#define SAMPLES 128\n\n// contrast\n#define SIGMOID_CONTRAST 12.0\n\n// channels to use for displacement, either xy or zw\n#define CH xy\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.6)));    \n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n/*\n\tThis function supplies a weight vector for each color channel.\n\tIt's analogous to (but not a physically accurate model of)\n\tthe response curves for each of the 3 cone types in the human eye.\n\tThe three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1/3.\n    Here are some other potential terms for the green weight that \n\tintegrate to 1/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https://oeis.org/A002457\n*/\nvec3 sampleWeights(float i) {\n\treturn vec3(1.,1.,1.);\n}\n\nvec3 sampleDisp(vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        col += sw * texture(iChannel1, uv + dispNorm * disp * wl).xyz;\n        wl  += SD;\n    }\n    \n    // For a large enough number of samples,\n    // the return below is equivalent to 3.0 * col * SD;\n    return col / denom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec2 d   = texture(iChannel0, uv).CH;\n    vec2 d_n = texture(iChannel0, fract(uv+n)).CH;\n    vec2 d_e = texture(iChannel0, fract(uv+e)).CH;\n    vec2 d_s = texture(iChannel0, fract(uv+s)).CH;\n    vec2 d_w = texture(iChannel0, fract(uv+w)).CH; \n\n    // antialias our vector field by blurring\n    vec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n\n    float ld = length(db);\n    vec2 ln = normz(db);\n\n\tvec3 col = sampleDisp(uv, ln, DISP_SCALE * ld);\n    \n    fragColor = vec4(contrast(col), 1.0);\n\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    A fracturing dynamical system\n\tsee: https://www.shadertoy.com/view/MsyXRW\n*/\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0623\n#define W0 -8.0\n#define W1 0.5\n#define TIMESTEP 0.1\n#define ADVECT_DIST 3.0\n#define DV 0.70710678\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\n#define SQRT_3_OVER_2 0.86602540378\n#define SQRT_3_OVER_2_INV 0.13397459621\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_v) * SQRT_3_OVER_2_INV + (x_h + x_d) * SQRT_3_OVER_2);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_h) * SQRT_3_OVER_2_INV + (x_v + x_d) * SQRT_3_OVER_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n    \n    const float vx = 0.5;\n    const float vy = SQRT_3_OVER_2;\n    const float hx = SQRT_3_OVER_2;\n    const float hy = 0.5;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 au = advect(u.xy, vUv, texel);\n    vec4 av = advect(u.zw, vUv, texel);\n    \n    vec2 dv = av.zw + TIMESTEP * ma;\n    vec2 du = au.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) / 200.0);\n        du += 0.2 * m * normz(d);\n    }\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    // initialize with noise\n    if((length(u) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.5) + vec4(init.xy, init.xy));\n    } else {\n        du = length(du) > 1.0 ? normz(du) : du;\n        fragColor = vec4(du, dv);\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n    A fluid-like dynamical system\n\tsee: https://www.shadertoy.com/view/XddSRX\n*/\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n// reverse advection\nvec4 advect(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    const float _G0 = 0.25; // center weight\n    const float _G1 = 0.128; // edge-neighbors\n    const float _G2 = 0.0615; // vertex-neighbors\n    \n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(aUv));\n    vec4 uv_n =  texture(iChannel0, fract(aUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(aUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(aUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(aUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/5.9; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    const float cs = -1.0;  // curl scale\n    const float ls = 3.0;  // laplacian scale\n    const float ps = 1.0;  // laplacian of divergence scale\n    const float ds = -12.0; // divergence scale\n    const float dp = -6.0; // divergence update scale\n    const float pl = 0.3;   // divergence smoothing\n    const float ad = 6.0;   // advection distance scale\n    const float pwr = 1.0;  // power when deriving rotation angle from curl\n    const float amp = 1.0;  // self-amplification\n    const float upd = 0.99;  // update smoothing\n    const float sq2 = 0.6;  // diagonal weight\n    \n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(vUv));\n    vec4 uv_n =  texture(iChannel0, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(vUv+se));\n    \n    // uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n    fragColor = vec4(abd);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4XSSRD.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "lc3XRr", "name": "The Wandering Circle", "author": "arben", "description": "The Wandering Circle", "tags": ["circle", "wandering"], "time_retrieved": "2024-05-15T23:20:04.200502", "image_code": "#define C vec2(0.5,0.5)\n#define R 0.3\n#define pi 3.141592\n#define half_pi (pi/2.0)\n#define r_scale vec2(0.2,0.4)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar=float(iResolution.x/iResolution.y);\n\n    uv.x = uv.x*ar;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 c=C + 0.5*cos(iTime*3.0)*sin(iTime/5.0-half_pi);\n    float r=r_scale.x+r_scale.y*(0.5+0.5*sin(iTime));\n    //float r=R/2.;\n    float k=cos(pi);\n    vec3 col;\n    float d=length(c-uv);\n    if(abs(d-r)<0.01)\n      col=vec3(1.,1.,1.);\n    else\n      col=vec3(0.,0.,0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lc3XRr.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Mc3Xzn", "name": "Fork Previous f supernlogn 891", "author": "supernlogn", "description": "Simple example with the current frame beeing modified by the previous one", "tags": ["frame", "backbuffer", "previous"], "time_retrieved": "2024-05-15T23:20:04.236008", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 draw = texture(iChannel0,uv);\n    vec4 draw2 = texture(iChannel1,uv);\n    fragColor = vec4(abs(draw2.rgb - draw.rgb),1.);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 draw = texture(iChannel0,uv);\n    fragColor = draw;\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mc3Xzn.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "MfG3Dy", "name": "Fork Terrain fr juk 300", "author": "juk", "description": "Fun to switch to webcam", "tags": ["terrain", "erosion"], "time_retrieved": "2024-05-15T23:20:04.270453", "image_code": "Main {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    Q = (.5+1.2*(n.x))*sin(5.*(n.y+e.x-s.y-w.x)+vec4(3,2.3,1.4,0));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)", "buffer_a_code": "Main {\n    \n    U -= A(U).xy;\n    \n    Q = A(U);\n    \n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    vec4 m = 0.25*(n+e+s+w);\n    m = mix(Q,m,vec4(1,1,1.,1));\n    vec2 v = vec2(e.z-w.z,n.z-s.z);\n    if (length(v)>0.)\n    Q.xy = mix(m.xy,normalize(v),.01);\n    Q.w = .25*(n.y+e.x-s.y-w.x);\n    Q.z = m.w+100.*B(U).z;\n    \n    if (iFrame<1) Q = B(U);\n    \n\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MfG3Dy.jpg", "access": "api", "wgpu-test": "error"}
