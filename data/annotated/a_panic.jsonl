{"id": "MdKGzy", "name": "Zzushi", "author": "Daedelus", "description": "sushi inspired by gyabo's tokyo demofest 2015 demonstration\n", "tags": ["sushiraymarchcheap"], "time_retrieved": "2024-05-15T23:13:59.100595", "image_code": "void R(inout vec2 plane, float angle)\n{\n    float sa = sin(angle);\n    float ca = cos(angle);\n    plane *= mat2(ca, -sa, sa, ca);\n}\n\n// Repeat only a few times: from indices <start> to <stop>\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat length8(vec3 p)\n{\n    vec3 m = pow(p, vec3(8.0));\n    return pow(m.x + m.y + m.z, 0.125);\n}\nfloat length6(vec3 p)\n{\n    vec3 m = pow(p, vec3(6.0));\n    return pow(m.x + m.y + m.z, 0.1666);\n}\nfloat length4(vec3 p)\n{\n    vec3 m = pow(p, vec3(4.0));\n    return pow(m.x + m.y + m.z, 0.25);\n}\nfloat length2(vec3 p)\n{\n    vec3 m = p * p;\n    return sqrt(m.x + m.y + m.z);\n}\n\nfloat topping(vec3 point)\n{\n    const float RADIUS = 2.0;\n    const float THICKNESS = 0.1;\n    \n    point.y -= RADIUS - 0.35;\n    \n    float outer = length(point) - RADIUS;\n    float box = sdBox(point, vec3(0.3, 3.0 * RADIUS, 0.5));\n    float inner = length(point) - RADIUS + THICKNESS;\n    \n    return max(-inner, max(box, outer));\n}\n\nfloat rice(vec3 point)\n{\n\tfloat seed = pModInterval1(point.z, 0.2, -1.0, 1.0);\n    return length2(point) - 0.3;\n}\n\nfloat plank(vec3 point)\n{\n    point.y -= 0.35;\n    float main = sdBox(point, vec3(1.2, 0.05, 0.8));\n    point.y -= 0.2;\n    point.x = abs(point.x) - 0.6;\n    float legs = sdBox(point, vec3(0.1, 0.1, 0.8));\n    return min(main, legs);\n}\n\nfloat filling( vec3 point){\n    return sdBox(point, vec3(0.1, 0.25, 0.1));\n        }\nfloat rice_cylinder( vec3 point){\n \tfloat height  = abs(point.y) - 0.2;   \n    return max(height, length(vec3 (point.x, 0.0, point.z)) - 0.25);\n}\nfloat seaweed( vec3 point){\n \tfloat height  = abs(point.y) - 0.19;   \n    return max(height, length(vec3 (point.x, 0.0, point.z)) - 0.27);\n}\n\n        \n\n\nvec2 sushi1(vec3 point, float a, float id ){\n        float b = rice(point);\n        float c = topping(point);\n        if(b<a)\n        {\n            a = b;\n            id = 1.0;\n        }\n        if(c<a)\n        {\n            a = c;\n            id = 2.0;\n        }\n        return vec2(a, id);\n    }\nvec2 sushi2 (vec3 point, float a, float id){\n    float d = filling(point);\n    float e = rice_cylinder(point);\n    float f = seaweed(point);\n    if (d<a){\n        a =d;\n        id= 2.;\n    }\n    if (e<a){\n    \ta =e;\n        id = 1.;\n    }\n    if (f < a){\n    \ta = f;\n        id = 3.;\n    }\n    return vec2(a , id);    \n    \n    \n    }\n\nvec2 fField(vec3 point)\n{\n    float a = plank(point);\n    float id = 0.0;\n    \n\tvec2 sushi_2 = sushi2(point, a, id);    \n    vec2 sushi_1 = sushi1(point, a, id);\n\tfloat b = sushi_2.x;\n    float id2 = sushi_2.y;\n    a = sushi_1.x;\n    id = sushi_1.y;\n\t\n    float w = sin(iTime) * 0.5 +0.5;\n    if (w < 0.5){ id = id2; };\n    float outa = mix(b, a, w);\n    return vec2(outa, id);\n}\n\n            \n            \nvec3 grad(vec3 p) {\n\tvec2 e = vec2(0.01, 0.0);\n\treturn (vec3(fField(p+e.xyy).x, fField(p+e.yxy).x, fField(p+e.yyx).x) - fField(p).x) / e.x;\n}\n\nconst int MAX_STEPS = 12;\nconst float NEAR_CLIP = 1.5;\nconst float FAR_CLIP = 5.0;\nconst float EPSILON = 0.03;\nconst float FOV = 0.3;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2.0 - 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // pixelate!\n    // uv = floor(uv * 25.0) / 25.0;\n    \n    vec3 origin = vec3(0.0, 0.0, -4.0);\n    vec3 direction = vec3(0.0, 0.0, 1.0);\n    R(direction.xz, uv.x * FOV);\n    R(direction.yz, uv.y * FOV);\n    \n    R(direction.yz, -0.4);\n    R(origin.yz, -0.4);\n    R(direction.xz, iTime);\n    R(origin.xz, iTime);\n    \n    float dist = NEAR_CLIP;\n    float id;\n    for(int i = 0 ; i < MAX_STEPS ; ++i)\n    {\n        vec2 d = fField(origin + direction * dist);\n        if(d.x < EPSILON)\n            break;\n        dist += d.x;\n        id = d.y;\n        if(dist > FAR_CLIP)\n            break;\n    }\n    vec3 color;\n    if(id >= 3.0)\n        color = vec3(0.2, 0.8, 0.3);\n\telse if(id >= 2.0)\n\t\tcolor = vec3(0.6, 0.1, 0.15);\n    else if (id >= 1.0)\n\t\tcolor = vec3(0.8, 0.8, 0.75);\n    else\n\t\tcolor = vec3(0.4, 0.15, 0.05);\n        \n\tvec3 isect = origin + direction * dist;\n    vec3 normal = grad(isect);\n    \n    vec3 sunDir = normalize(vec3(0.5, -1.0, 0.4));\n    float sun = max(0.0, dot(normal, sunDir));\n    float bounce = max(0.0, dot(normal, vec3(-0.3, 0.7, 0.3)));\n    float fill = max(0.0, dot(normal, vec3(-0.3, -0.7, -0.5)));\n    \n    vec3 ambient = vec3(0.3, 0.4, 0.6);\n    vec3 sunCl = sun * vec3(1.0, 0.7, 0.3) * 2.0;\n    vec3 bounceCl = bounce * vec3(1.0, 0.8, 0.2);\n    vec3 fillCl = fill * vec3(0.0, 0.2, 0.2);\n    \n    vec3 diffCl = sunCl + bounceCl + fillCl;\n    float shadow = fField(isect + sunDir * 0.2).x;\n    if(shadow < 0.04)\n        diffCl = vec3(0.0);\n    \n    // float fog = 1.0 / (-0.5 + dist);\n    float fog = 1.0 - ((dist - NEAR_CLIP) / (FAR_CLIP - NEAR_CLIP));\n\tfragColor = vec4((diffCl + ambient) * color * fog, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKGzy.jpg", "access": "api", "wgpu-test": "panic"}
{"id": "MdKSWm", "name": "Post-mortem Death Star", "author": "s23b", "description": "Use the mouse to rotate\n\nI will try to improve the performance later...", "tags": ["raymarching", "starwars", "deathstar"], "time_retrieved": "2024-05-15T23:13:59.127505", "image_code": "#define PI 3.14159265359\n#define SPHERES 6\n#define REFLECTIONS 0\n\n#define saturate(x) clamp(x, 0., 1.)\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\nfloat hash(vec3 uv) {\n  float f = fract(cos(sin(dot(uv ,vec3(.009123898,.00231233, .00532234))) * 480.512353) * 11111.5452313);\n    return f;\n}\n\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 8; ++i) {\n        f += noise((uv + 10.) * vec3(r, r, r)) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// distance function\nfloat map(vec3 p) {\n    float sphere = length(p) - 1.;\n    float f = fbm(p * vec3(1,3,3));\n    sphere = max(f - p.x / 3.  - .6, sphere);\n    sphere = max(-length(p - vec3(1.)) + .85, sphere);\n    sphere = max(sphere, -abs(p.y) + .01);\n    sphere = min(sphere, -length(p) + 5.);\n    return sphere;\n}\n\n// raymarching function\nfloat trace(vec3 o, vec3 r, int steps) {\n    float t = 0.;\n    for (int i = 0; i < 100; ++i) {\n        float d = map(o + r * t);\n        t += d;\n        if (d < .0001 || t > 10. || i > steps) break;\n    }\n    return t;\n}\n\n\nvec3 tex(vec2 uv) {\n    vec3 c = vec3(0);\n    if (abs(abs(uv.y - .5) - .22) > .2 || fract(uv.y * 10.) < .1) {\n        c = vec3(.25);\n    } else {\n        float l = floor(uv.y * 10.);\n        c = vec3(\n            smoothstep(.6, .7, noise(vec3(uv.x * 300.,1, l))) / 8. + .125\n        );\n    }\n    return c;\n}\n\n// apply texture ( fbm + stripes )\nvec3 texSphere(vec3 p) {\n    float l = length(p);\n    float ratio = smoothstep(.99, 1.01, l);\n    p = normalize(p);\n    vec2 uv = vec2(.5 + atan(p.z, p.x) / PI / 2., .5 - asin(p.y) / PI);\n    vec3 c = mix(vec3(fbm(p * 20.) / 10. + .125), tex(uv), ratio);\n    return c * (.5 + smoothstep(0., .002, abs(l - .89)) / 4. + smoothstep(0., .005, abs(l - .99)) / 4.);\n}\n\n// rendering function: o - ray origin, r - ray vector, dist - distance traveled, steps - raymarching iterations\nvec3 render(inout vec3 o, inout vec3 r, inout float dist, in int steps) {\n    \n    // march to first object\n    float f = trace(o, r, steps);\n    \n    // get intersection point\n    vec3 p = o + f * r;\n    \n    // get normal vector\n    vec2 eps = vec2(0, .0001);\n    vec3 normal = normalize(vec3(\n    \tmap(p + eps.yxx) - map(p - eps.yxx),\n    \tmap(p + eps.xyx) - map(p - eps.xyx),\n    \tmap(p + eps.xxy) - map(p - eps.xxy)\n\t));\n    \n    // light source\n    vec3 ls = vec3(0, 0, 2);\n    ls.xz *= rot(iTime * .1);\n    ls.xy *= rot(.3);\n    vec3 light = normalize(ls);\n    \n    // reflection point\n    vec3 ref = reflect(r,normal);\n    \n    vec3 color = vec3(0);\n    \n    if (length(p) < 2.) {\n        // add ambient light (hue from angle)\n        color += saturate(texSphere(p) * dot(p,p));\n\n        // calculate shadow\n        float s = trace(p + light * .01, light, steps);\n\n        if (s > 1.) {\n\t\n            // add diffuse light\n            color += vec3(dot(normal, light)) * .5;\n\n            // add specular light\n            //color += saturate(vec3(pow(saturate(dot(light, ref)), 8.)) / 2.);\n            \n        }\n    } else {\n        vec3 np = p;\n        np.xz *= rot(-iTime* .1);\n        np.xy *= rot(-.3);\n        color = smoothstep(.9, 1., vec3(noise(np * 10.)));\n        color += vec3(pow(saturate(dot(normal, -light)), 100.));\n    }\n        \n    // new origin becomes the point hit\n    o = p;\n    \n    // new ray vector becomes the reflection vector\n    r = normalize(ref);\n    \n    // go a bit further on the ray, so we don't hit the same surface\n    o += r * .1;\n    \n    // add marched distance to distance traveled\n    f = max(0., f);\n    dist += f;\n    \n    // return divided by the fog\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // transform viewport coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // ray from screen coordinates\n    vec3 r = normalize(vec3(uv, 3.));\n    \n    // eye for origin\n    vec3 o = vec3(0, 0, -4);\n    \n    // transform mouse coordinates\n    vec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n\n    mouse *= PI * 2.;\n    \n    // rotate camera around the center\n    float a = (iMouse.z > 0.) ? -mouse.y : .3;\n    o.yz *= rot(a);\n    r.yz *= rot(a);\n    a = (iMouse.z > 0.) ? -mouse.x : 3.2;// + iTime * .5;\n    o.xz *= rot(a);\n    r.xz *= rot(a);\n    \n    float f = 0.;\n    int steps = 100;\n    \n    // render scene\n    vec3 c = render(o, r, f, steps);\n    \n    // render reflections\n    for (int i = 0; i < REFLECTIONS; ++i) {\n        steps /= 2;\n    \tc += c * render(o, r, f, steps);\n    }\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKSWm.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdKXz1", "name": "Too much Acid", "author": "innovati", "description": "Too much acid", "tags": ["acid", "trip"], "time_retrieved": "2024-05-15T23:14:02.109474", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  fragColor = mod(min(vec4(0.4, 0.4, 1.3, (gl_FragCoord.x / iResolution.x)), reflect(sign(mod(vec4(1.2, 0.3, (1.6 - (1.2 + 0.7)), 0.7), asin(vec4(0.2, 1.2, 1.8, 1.4)))), sin(mod(min(reflect(reflect(min(step(step(vec4(float(iFrame), 0.8, (1.1 * 0.4), (0.8 - degrees(0.3))), step(vec4((iTime + float(iFrame)), tan(1.3), 0.1, 0.6), min(cos(sqrt(mod(vec4(0.7, iTime, iTime, float(iFrame)), atan(vec4(((gl_FragCoord.y / iResolution.y) + float(iFrame)), (0.6 - 1.9), 0.2, ((0.4 + iTime) * 1.6)))))), vec4((0.4 * (gl_FragCoord.x / iResolution.x)), 1.5, iTime, radians(0.5))))), mod(mod(vec4(1.5, 1.9, (gl_FragCoord.y / iResolution.y), 0.6), max(vec4(1.2, 0.2, 1.3, iTime), vec4((gl_FragCoord.y / iResolution.y), 0.1, 0.1, 1.7))), degrees(vec4(float(iFrame), 0.2, (0.3 * 1.9), (reflect(ceil((0.3 - 0.4)), (1.4 + (acos(0.0) + (gl_FragCoord.y / iResolution.y)))) - 1.9))))), log(asin(reflect(min(min(pow(vec4(reflect(0.4, (gl_FragCoord.y / iResolution.y)), reflect((gl_FragCoord.x / iResolution.x), (gl_FragCoord.y / iResolution.y)), 1.4, 1.5), tan(vec4((gl_FragCoord.y / iResolution.y), ((1.8 * sign(1.1)) - (gl_FragCoord.x / iResolution.x)), iTime, ((gl_FragCoord.y / iResolution.y) * (0.3 * 0.0))))), vec4(iTime, (1.9 / 1.6), ((0.5 - (gl_FragCoord.y / iResolution.y)) * (gl_FragCoord.x / iResolution.x)), 0.4)), vec4(log2(1.6), (float(iFrame) * 1.4), degrees(float(iFrame)), 0.5)), vec4((0.3 * 0.7), float(iFrame), 0.1, 1.5))))), vec4(0.0, (1.5 / 0.5), 0.8, float(iFrame))), vec4((0.5 + 1.3), 1.6, (1.4 * ((gl_FragCoord.x / iResolution.x) / 0.8)), 1.1)), atan(sin(ceil(reflect(step(vec4(float(iFrame), reflect(iTime, ((gl_FragCoord.y / iResolution.y) + 1.4)), 1.8, (exp(1.8) - (1.6 * 0.7))), step(vec4(1.7, (float(iFrame) * 0.4), (iTime * 0.6), 1.9), acos(vec4(1.4, 1.7, (gl_FragCoord.y / iResolution.y), (1.0 - 1.6))))), exp2(sqrt(min(vec4(1.0, 0.0, reflect((1.8 - 1.6), 1.7), (1.5 - (sin(iTime) / 0.1))), floor(abs(asin(vec4(0.2, floor(1.8), float(iFrame), (gl_FragCoord.x / iResolution.x))))))))))), vec4(((((0.1 - ceil(((((1.5 + 0.1) + 0.7) * ((1.8 / float(iFrame)) * 1.2)) * ((0.5 - min(0.0, iTime)) - 1.2)))) + 0.1) + degrees(normalize(0.8))) * 0.4), ((gl_FragCoord.x / iResolution.x) - 1.0), 1.4, 1.2))), vec4((0.0 / 0.0), 1.3, (atan(0.4, 0.2) * 1.2), (gl_FragCoord.y / iResolution.y)))))), vec4(0.7, 1.4, 0.0, float(iFrame)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKXz1.jpg", "access": "api", "wgpu-test": "panic"}
{"id": "MdKXzc", "name": "Supernova remnant", "author": "Duke", "description": "Based on [url=https://www.shadertoy.com/view/MsVXWW]Dusty nebula 4[/url] Added emission light to the filaments. I continue to think about how to animate this shader.", "tags": ["cloud", "star", "space", "nebula", "supernova", "dust", "remnant", "filament"], "time_retrieved": "2024-05-15T23:14:09.439495", "image_code": "// \"Supernova remnant\" by Duke\n// https://www.shadertoy.com/view/MdKXzc\n//-------------------------------------------------------------------------------------\n// Based on \"Dusty nebula 4\" (https://www.shadertoy.com/view/MsVXWW) \n// and \"Protoplanetary disk\" (https://www.shadertoy.com/view/MdtGRl) \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n#define DITHERING\n#define BACKGROUND\n\n//#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(vec3 p)\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n\nfloat Disk( vec3 p, vec3 t )\n{\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.5);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.9;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n    float final = Disk(p.xzy,vec3(2.0,1.8,1.25));\n    final += fbm(p*90.);\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*3.0;\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.07;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n\tfor (int i=0; i<64; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n\t    if(td>0.9 || d<0.1*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n        \n        // evaluate distance function\n        float d = map(pos);\n\t\t       \n\t\t// change this string to control density \n\t\td = max(d,0.0);\n        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // the color of light \n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        \n        sum.rgb+=(vec3(0.67,0.75,1.00)/(lDist*lDist*10.)/80.); // star itself\n        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.08)/30.); // bloom\n        \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n            \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2;\t\n            \n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.2;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n\n        #ifdef DITHERING\n        //idea from https://www.shadertoy.com/view/lsj3Dw\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        uv.y*=120.;\n        uv.x*=280.;\n        d=abs(d)*(.8+0.08*texture(iChannel2,vec2(uv.y,-uv.x+0.5*sin(4.*iTime+uv.y*4.0))).r);\n        #endif \n\t\t\n        // trying to optimize step size near the camera and near the light source\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),1.0), 0.01);\n        \n\t}\n    \n    // simple scattering\n\tsum *= 1. / exp( ld * 0.2 ) * 0.6;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    // stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n   \n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(sum.xyz*2.2),1.0);\n\t#else\n    fragColor = vec4(sum.xyz,1.0);\n\t#endif\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKXzc.jpg", "access": "api", "wgpu-test": "incomplete"}
{"id": "MdKyDy", "name": "Surprise!", "author": "neurom", "description": "I made this for the wild compo revision 2018. You can drag the light around with the mouse.", "tags": ["raymarching", "space", "stars", "kindersurprise", "easteregg"], "time_retrieved": "2024-05-15T23:14:09.768768", "image_code": "#define time iTime\n\n#define PI acos(-1.0)\n#define TAU (2.*PI)\n\nvec3 v01 = vec3(0.0, 1.0, 0.1);\n\n// Taken from the book of shaders\nfloat random (vec2 st) {\n    return fract(sin(dot(st,vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat random (float st) { return random(vec2(st)); }\n\nfloat frandom (vec2 st) {\n\tvec2 t = fract(st);\n\tvec2 a = floor(st);\n\tvec2 b =  ceil(st);\n\treturn mix(\n\t\tmix(random(vec2(a.x, a.y)), random(vec2(b.x, a.y)), t.x),\n\t\tmix(random(vec2(a.x, b.y)), random(vec2(b.x, b.y)), t.x),\n\t\tt.y); \n}\n\nfloat sat(float n) { return clamp(n, 0.0, 1.0); }\nvec3 sat(vec3 n) { return clamp(n, v01.xxx, v01.yyy); }\n\nvec2 rotate(inout vec2 p, float a) {\n\tp = p*cos(a) - vec2(p.y, -p.x)*sin(a);\n\treturn p;\n}\n\n\nvec4 egg = vec4(0, 0., 30., 8.);\n\nfloat sphere(vec3 point, vec3 p, float r) {\n\treturn distance(point, p) - r;\n}\n\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat box(vec3 point, vec3 p, vec3 r) {\n\treturn vmax(abs(point - p) - r);\n}\t\n\nfloat rod(vec2 point, vec2 c, float r) {\n\treturn distance(point, c) - r;\n}\n\n\nint mi = 0;\nfloat map(vec3 point) {\n\tvec3 op = point.xyz;\n\tpoint.y += 4.;\n\n\tvec3 p1 = point.xyz;\n\n\tif (p1.y > egg.y) {\n\t\tp1.y /=2.;\n\t}\n\n\tfloat result = sphere(p1, egg.xyz, egg.w);\n\n\tvec3 p2 = point.xyz;\n\tp2 -= egg.xyz;\n\trotate(p2.xz, time/2.);\n\trotate(p2.xy, -TAU/10.);\n\tp2 += egg.xyz;\n\n\n\n\tfloat d = -box(p2, egg.xyz + v01.yxx*10.15*(1.5 + 0.5*sin(time*1.)), vec3(8., 30, 10.));\n\t// d = max(d, -sphere(p1, egg.xyz, egg.w*0.93));\n\t\n\td = max(d, -sphere(p1, egg.xyz, egg.w*0.93));\n    if (d > result) { result = d; mi = 1; }\n\t\n\n\n\tp1 = op.xyz;\n\t\n\tp1.y = p1.y*p1.y/12.;\n\n\td = sphere(p1, egg.xyz, egg.w*.7);\n\td = min(d, max(box(p1, egg.xyz, vec3(10., .25, 10.)), rod(p1.xz, egg.xz, egg.w*.715)));\n\n    if (d < result) { result = d; mi = 2; }\n\n\treturn result;\n}\n\n\nvec3 hsv2rgb(float h, float s, float v) {\n\tvec3 p = sat(abs(fract(vec3(3.0, 2.0, 1.0)/3.0 + h)*6.0 - 3.0) - 1.0);\n\treturn v*mix(p, vec3(1.0), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.x;\n\n\tvec3 camP = vec3(0), rayD = normalize(vec3(uv, 1.));\n\n\tfloat marched = 0.01, d, far = distance(egg.xyz, camP) + egg.w*2.;\n\tvec3 p;\n\n\tfor (int i = 0; i < 300; ++i) {\n\t\tp = camP + rayD*marched;\n\t\td = map(p);\n\t\tmarched += d;\n\n\t\tif (abs(d) < 0.001 || d > far) break;\n\t}\n\n\n\n\n\tfloat starT = random(uv)*time*2.;\n\tfloat value = 4.*mix(\n\t\tpow(random(uv + floor(starT)), 120.),\n\t\tpow(random(uv +  ceil(starT)), 120.),\n\t\tfract(starT));\n\n\tvalue *= (pow(frandom((uv * 7. + time/8.)) + 0.2, 4.));\n\tvec3 c = hsv2rgb(0.7133, 0.9, value);\n\n\n\tif (marched < far) {\n        vec3 normal = normalize(vec3(\n\t\t\tmap(p + v01.zxx),\n            map(p + v01.xzx),\n            map(p + v01.xxz)\n        ));\n        \n        vec2 m = (2.*iMouse.xy - iResolution.xy) / iResolution.x;\n\n        vec3 lightDir = normalize(vec3(2.*m, -1.));\n\n\n\t\tif (mi == 0) {\n\t\t\tc = vec3(1.0);\n\t\t\tif (p.y + sin(p.x*2. + time*10.) < -3.) {\n\t\t\t\tc.gb *= 0.;\n\t\t\t}\n\n\t\t\tvec3 egg2p = p - egg.xyz;\n\t\t\tfloat u = atan(egg2p.z, egg2p.x) + time/1.5;\n\t\t\tnormal = normalize(normal + 2.*normalize(egg2p)*frandom(vec2(u*79. + p.y*20., random(floor(u*10. + p.y*2.))*4. + u*5. + p.y*2.)));\n            \n\t\t\tc += pow(dot(rayD, reflect(lightDir, normal)) + 0.1, 13.)*.05;\n            \n\t\t\tc *= sat(dot(normal, lightDir));\n            \n\t\t} else if (mi == 1) {\n\t\t\tc = vec3(.3, .2, 0.13);\n\t\t\tc *= dot(normal, lightDir);\n\t\t\t\n\t\t} else if (mi == 2) {\n\t\t\tc = vec3(1., .8, 0.3);\n\t\t\tc += pow(dot(rayD, reflect(lightDir, normal)), 50.)*1.;\n\t\t\tc *= dot(normal, lightDir);\n\t\t\t\n\t\t} else {\n\t\t\tc += 0.5; // This is just so I can see which material indexes I missed\n\t\t}\n\n\t}\n\n\tfragColor = vec4(c, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyDy.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdKyRw", "name": "kaleidoscopic iterative function", "author": "wyatt", "description": "many thanks to iq and his tutorials ", "tags": ["raymarching", "kifs"], "time_retrieved": "2024-05-15T23:14:09.814781", "image_code": "vec4 light;\nfloat ui;\nmat2 m,n,nn;\nfloat map (vec3 p) {\n    float d = length(p-light.xyz)-light.w;\n    d = min(d,max(10.-p.z,0.));\n    float t = 2.5;\n    for (int i = 0; i < 13; i++) {\n        t = t*0.66;\n        p.xy = m*p.xy;\n        p.yz = n*p.yz;\n        p.zx = nn*p.zx;\n        p.xz = abs(p.xz) - t;\n\n    }\n    d = min(d,length(p)-1.4*t);\n\n    return d;\n}\nvec3 norm (vec3 p) {\n    vec2 e = vec2 (.001,0.);\n    return normalize(vec3(\n        map(p+e.xyy) - map(p-e.xyy),\n        map(p+e.yxy) - map(p-e.yxy),\n        map(p+e.yyx) - map(p-e.yyx)\n    ));\n}\nvec3 dive (vec3 p, vec3 d) {\n    for (int i = 0; i < 20; i++) {\n        p += d*map(p);\n    }\n    return p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v = fragCoord/iResolution.xy*2.-1.;\n\tv.x *= iResolution.x/iResolution.y;\n    ui = 100.*iTime;\n    float y = -0.001*ui;\n    m = mat2(sin(y),cos(y),-cos(y),sin(y));\n    y = 0.0035*ui;\n    n = mat2(sin(y),cos(y),-cos(y),sin(y));\n    y = 0.0023*ui;\n    nn = mat2(sin(y),cos(y),-cos(y),sin(y));\n    vec3 r = vec3(0,0,-15.+2.*sin(0.01*ui));\n    light = vec4(10.*sin(0.01*ui),2,-23,1);\n    vec3 d = normalize(vec3(v,5.));\n    vec3 p = dive(r,d);\n    d = normalize(light.xyz-p);\n    vec3 no = norm(p);\n    vec3 col = vec3(.7,.8,.9);\n    vec3 bounce = dive(p+0.01*d,d);\n    col = mix(col,vec3(0),dot(no, normalize(light.xyz-p)));\n    if (length(bounce-light.xyz) > light.w+0.1) col *= 0.2;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyRw.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdKyWd", "name": "Hello world with Mandelbrot", "author": "darkeclipz", "description": "Mandelbrot set! First time programming with GLSL / shaders.", "tags": ["mandelbrot"], "time_retrieved": "2024-05-15T23:14:09.851446", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord/iResolution.y - vec2(1.15, .5);\n    vec2 c = 2.3*p; vec2 z = vec2(0); float i = 0., t; t = iTime;\n    float lim = 32.;\n    \n    for(; z.x*z.x < 12. && ++i < lim ;)\n        z = mat2(z, -z.y, z.x) * z + c;\n    \n    fragColor = vec4((.5 + .5*cos(t+p.xyx+vec3(0,2,4))) * i / lim, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyWd.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdKyWy", "name": "Helical Frame", "author": "dr2", "description": "Hollow twisted helix (mouseable, optional antialiasing)", "tags": ["helix", "frame", "structure"], "time_retrieved": "2024-05-15T23:14:09.888503", "image_code": "// \"Helical Frame\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing (0/1 - off/on)\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, a, aa, gz;\n  q = p;\n  aa = atan (q.z, q.x) / (2. * pi);\n  a = 0.5 * sign (q.z) - aa;\n  q.y = mod (q.y + 2. * a + 1., 2.) - 1.;\n  d = PrBoxAn2Df (Rot2D (vec2 (length (q.xz) - 4., q.y), 6. * pi * aa), vec2 (0.5), 0.05);\n  gz = dot (q.zx, sin (2. * pi * ((floor (32. * a) + 0.5) / 32. + vec2 (0.25, 0.))));\n  q.xy = Rot2D (vec2 (dot (q.xz, sin (2. * pi * (vec2 (0.25, 0.) - a))) + 4., q.y), 6. * pi  * a);\n  d = max (d, - min (PrBox2Df (vec2 (q.x, gz), vec2 (0.35, 0.25)),\n     PrBox2Df (vec2 (q.y, gz), vec2 (0.35, 0.25))));\n  return 0.6 * d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.2, 3. * h);\n    if (sh < 0.001) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    sh = ObjSShadow (ro, ltDir);\n    col = vec3 (0.7, 0.6, 0.6) * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       0.4 * vec3 (0.7, 0.7, 1.) * smoothstep (0.5, 0.8, sh) *\n       pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else {\n    col = vec3 (0.6, 1., 0.6) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  } else {\n    az += 0.1 * pi * tCur;\n    el += 0.35 * pi * sin (0.07 * pi * tCur);\n  }\n  el = clamp (el, -0.35 * pi, 0.35 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -20.);\n  zmFac = 5. + 2. * sin (0.05 * pi * tCur);\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (-1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w)\n{\n  return max (PrBox2Df (p, vec2 (b + w)), - PrBox2Df (p, vec2 (b - w)));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyWy.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdKyzw", "name": "electric grid", "author": "laserdog", "description": "Testing an effect for an RTS game i'm working on. Borrowed some ideas from srtuss' digital brain.", "tags": ["game"], "time_retrieved": "2024-05-15T23:14:09.928323", "image_code": "vec2 rand2(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\nfloat voronoi(in vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tfloat minDistance = 1.;\n    \n\tfor(int j = -1; j <= 1; j ++)\n\t{\n\t\tfor(int i = -1; i <= 1; i ++)\n\t\t{\n\t\t\tvec2 b = vec2(i, j);\n            vec2 rand = .5 + .5 * sin(iTime * 3. + 12. * rand2(p + b));\n\t\t\tvec2 r = vec2(b) - f + rand;\n\t\t\tminDistance = min(minDistance, length(r));\n\t\t}\n\t}\n\treturn minDistance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n\tvec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    float val = pow(voronoi(uv * 8.) * 1.25, 7.) * 2.;\n    float gridLineThickness = 2. / iResolution.y;\n    vec2 grid = step(mod(uv, .1), vec2(gridLineThickness));    \n\n    fragColor = vec4(0., val * (grid.x + grid.y), 0., 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyzw.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdKyzy", "name": "Scanner screen", "author": "Abvadabra", "description": "Shader for scanner's screen", "tags": ["noise", "screen"], "time_retrieved": "2024-05-15T23:14:09.960587", "image_code": "float rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bg = texture(iChannel0, uv);\n    \n    vec3 col = bg.rgb;\n\tcol *= vec3(.6, 1., .6);\n    \n    col += sin(uv.y * 700.) * 0.15;\n    \n    float y = fract(-iTime / 2.);\n    float b = 0.002;\n    col += (smoothstep(y - b, y, uv.y) - smoothstep(y, y + b, uv.y)) * abs(sin((uv.y + iTime) * 1.)) * .5;\n    \n    float p = fract(-iTime / 4.);\n    float s = 0.2;\n    float d = smoothstep(p - s, p, uv.y) - smoothstep(p, p + s, uv.y);\n    col += noise((uv * 1000. + iTime * 10.) * 5.) * (0.1  + 0.2 * d);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyzy.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlBW7", "name": "Volatile Sphere of Cubes", "author": "knarkowicz", "description": "100% pure code without artificial textures", "tags": ["raymarching", "sdf", "cube", "sphere"], "time_retrieved": "2024-05-15T23:14:09.997559", "image_code": "const float MATH_PI = float( 3.14159265359 );\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat RoundBox( vec3 p, vec3 b, float r )\n{\n\treturn length( max( abs( p ) - b, 0.0 ) ) - r;\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat RepeatAngle( inout vec2 p, float n ) \n{\n\tfloat angle = 2.0 * MATH_PI / n;\n\tfloat a = atan( p.y, p.x ) + angle / 2.0;\n\tfloat r = length( p );\n\tfloat c = floor( a / angle );\n\ta = mod( a, angle ) - angle / 2.;\n\tp = vec2( cos( a ), sin( a ) ) * r;\n\treturn c;\n}\n\nvoid Rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Scene( vec3 p )\n{\n    float a = p.x;\n    p.x = -p.y;\n    p.y = a;\n    \n    Rotate( p.yz, iTime );    \n    \n    // sphere\n    float ret = Sphere( p, 0.6 );\n    for ( float i = -5.0; i < 6.0; ++i )\n    {\n        float theta   = ( i / 6.0 ) * MATH_PI * 0.5;\n        float boxNum  = 12.0;\n        float radius  = cos( theta ) * 0.7;\n        float boxSize = abs( radius ) * 0.12;\n        float boxOffset = -sin( theta ) * 0.7;\n                \n        Rotate( p.yz, MATH_PI / ( 2.0 * boxNum ) );\n        \n        vec3 t = p;\t\t\n\t\tfloat boxLen = 0.15 + sin( iTime * 2.0 ) * 0.1;        \n    \tt = p + vec3( boxOffset, 0.0, 0.0 );\n    \tRepeatAngle( t.yz, boxNum );\n    \tt.y -= radius;\n        Rotate( t.xy, -theta );\n    \tret = Union( ret, RoundBox( t, vec3( boxSize, boxLen, boxSize ), 0.02 ) );\n        \n\t\tt = p;\n\t\tboxLen = 0.15 + sin( iTime * 3.0 ) * 0.1;        \n\t\tRotate( p.yz, MATH_PI / boxNum );\n    \tt = p + vec3( boxOffset, 0.0, 0.0 );\n    \tRepeatAngle( t.yz, boxNum );\n    \tt.y -= radius;\n        Rotate( t.xy, -theta );\n    \tret = Union( ret, RoundBox( t, vec3( boxSize, boxLen, boxSize ), 0.02 ) );\n    }\n    \n    // debris\n    vec3 t = p;\n    t.y = abs( t.y + 0.3 * sin( 1.7 * iTime ) );\n    t.z = abs( t.z );\n    t -= vec3( 0.8, 1.0, 1.0 );\n    Rotate( t.xz, iTime );    \n\tRotate( t.xy, -0.25 );\n    ret = Union( ret, RoundBox( t, vec3( 0.01 ), 0.005 ) );\n    \n    Rotate( p.xy, 0.1 * iTime );\n    Rotate( p.yz, MATH_PI * 0.25 );\n    t = p;\n    t.y = abs( t.y + 0.3 * sin( 1.7 * iTime ) );\n    t.z = abs( t.z );\n    t -= vec3( 0.8, 1.0, 1.0 );\n    Rotate( t.xz, iTime );    \n\tRotate( t.xy, -0.25 );    \n    ret = Union( ret, RoundBox( t, vec3( 0.01 ), 0.005 ) );    \n\n\treturn ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 1.0;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 normal = vec3(\n\t    Scene( pos + eps.xyy ) - Scene( pos - eps.xyy ),\n\t    Scene( pos + eps.yxy ) - Scene( pos - eps.yxy ),\n\t    Scene( pos + eps.yyx ) - Scene( pos - eps.yyx ) );\n\treturn normalize( normal );\n}\n\nvec3 KeyColor = vec3( 1.0, 0.98, 0.94 );\nvec3 FillColor = vec3( 0.09, 0.19, 0.25 ); \n\nvec3 Sky( vec3 rayDir )\n{\n    vec3 skyPos     = rayDir;\n    vec2 skyAngle   = vec2( atan( skyPos.z, skyPos.x ), acos( skyPos.y ) );\n\n    vec3 color = KeyColor * mix( 1.0, 0.4, smoothstep( 0.0, 1.0, saturate( 1.5 * skyPos.y + 0.1 ) ) );\n    color = mix( color, FillColor, smoothstep( 0.0, 1.0, saturate( -1.5 * skyPos.y - 0.1 ) ) );\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n    vec3 rayOrigin\t= vec3( 0.0, -0.2, -3.0 );\n\tvec3 rayDir \t= normalize( vec3( p.xy, 2.0 ) ); \n\n\tvec3 color = Sky( rayDir );\n\tfloat t = CastRay( rayOrigin, rayDir );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos );\n        vec3 lightDir = normalize( vec3( 0.5, 0.5, -1.0 ) );\n            \n        // ambient, diffuse and specular\n        color = 0.8 * mix( FillColor, KeyColor, 0.5 * normal.y + 0.5 );\n        float specOcc = 0.3 + 0.7 * smoothstep( 0.0, 1.0, saturate( 2.0 * length( pos.xy ) ) );\n        float fresnel = saturate( pow( 1.4 + dot( rayDir, normal ), 5.0 ) ) * specOcc;\n        color += 0.5 * Sky( normal ) * mix( 0.1, 1.0, fresnel );\n        color += 0.3 * KeyColor * saturate( dot( normal, lightDir ) );\n        color *= 0.85;\n    }\n    else\n    {\n        // sphere shadow\n        float planeT = -( rayOrigin.y + 1.2 ) / rayDir.y;\n        if ( planeT > 0.0 )\n        {\n            vec3 p = rayOrigin + planeT * rayDir;\n            \n            float radius = max( 0.15 + sin( iTime * 2.0 ) * 0.1, 0.15 + sin( iTime * 3.0 ) * 0.1 );\n            color *= 0.7 + 0.3 * smoothstep( 0.0, 1.0, saturate( length( p + vec3( 0.0, 1.0, 0.0 ) ) - radius ) );\n        }\t\t\n    }\n    \n    float vignette = q.x * q.y * ( 1.0 - q.x ) * ( 1.0 - q.y );\n    vignette = saturate( pow( 32.0 * vignette, 0.05 ) );\n    color *= vignette;\n        \n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlBW7.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlcDB", "name": "Voronoi : Hexagons to polygons", "author": "qmuntada", "description": "Simple addition to Iq shader : https://www.shadertoy.com/view/MslGD8", "tags": ["voronoi", "hexagons", "polygons"], "time_retrieved": "2024-05-15T23:14:10.040991", "image_code": "// Created by inigo quilez - iq/2013\n// Modified by qmuntada (2017)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n\tvec3 m = vec3(8.0);\n    for(int j=-1; j<=1; j++)\n    for(int i=-1; i<=1; i++)\n    {\n        vec2  g = vec2(float(i), float(j));\n        vec2  o = hash(n + g) * (cos(iTime) + 1.0) / 2.0;\n        \n        if (mod(n.x, 2.0) - float(i) == -1.0 || mod(n.x, 2.0) - float(i) == 1.0)\n            o.y += 0.5;\n        \n       \tvec2  r = g - f + o;\n        \n\t\tfloat d = dot(r, r);\n        if(d < m.x)\n            m = vec3(d, o);\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    \n    // computer voronoi patterm\n    vec2 c = voronoi( (14.0+6.0*sin(0.2*iTime))*p );\n\n    // colorize\n    vec3 col = 0.5 + 0.5 * cos(c.y * 3.0 + vec3(0.0,1.0,2.0) );\t\n    col *= clamp(1.0 - 0.5 * c.x * c.x, 0.0, 1.0);\n    col -= (1.0-smoothstep( 0.05, 0.05, c.x));\n\t\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlcDB.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlcDS", "name": "Rounded Voro Rocks", "author": "Dain", "description": "\nThis is Shane's 3d Celltile modified to use Fabrice's rounded voronoi formula.\nAlso tries to vary rock size etc\n\nShanes Cellular Tile Tunnel:\nhttps://www.shadertoy.com/view/MscSDB\nRounded Voronoi:\nhttps://www.shadertoy.com/view/ll3GRM\n", "tags": ["voronoi", "cell", "trabeculae", "celltile"], "time_retrieved": "2024-05-15T23:14:14.773468", "image_code": "\n/*\n//Dain: this is mostly Shane's Cellular Tile Tunnel:  https://www.shadertoy.com/view/MscSDB\n\n//I marked the stuff I changed with a comment followed by my name\n\n    Cellular Tiled Tunnel\n    ---------------------\n    \n    I've always liked the look of a 2nd order Voronoi surface. IQ's Leizex demo is a great\n\tprerendered example, and for anyone who can remember, Tomasz Dobrowolski's Suboceanic\n\twas cutting edge back in the day.\n\n\tAnyway, I've always wanted to get a proper example working in a shader... Yeah, I need\n\tbigger dreams. :) Unfortunately, I kind of realized that it wasn't going to be possible \n\tuntil GPUs become even faster than they already are, so I figured I'd try the next best \n\tthing and come up with a way to emulate the look with something cheap. This is the \n\tresult. It's not perfect, but it looks surprisingly similar.\n\n\tThe regular 2nd order Voronoi algorithm involves a \"lot\" of operations. In general,\n\t27 cell checks - all involving a bunch of vector arithmetic, fract, sin, floor, \n\tcomparisons, etc... It's possible to cut down on cell checks, perform a bunch of\n\toptimizations, etc, but it's still too much work for a raymarcher.\n\n\tThe surface here is produced via a repeat 3D tile approach. The look is achieved by \n\tperforming 2nd order distance checks on the tiles. I used a highly scientific approach\n\twhich involved crossing my fingers, doing the distance checks and hoping for the best. :)\n\tAmazingly, it produced the result I was looking for.\n\n\tI covered the tile construction in other \"cell tile\" examples, so I'll spare you the \n\tdetails, but it's pretty simple. The only additions here are the second order distance\n\tchecks.\n\n\tIn order to show the surface itself, I've made the example geometric looking - I hope\n\tyou like brown, or whatever color that is. :) Note that individual cell regions are \n\tcolored\tdifferently. I did that to show that it could be done, but I'm not convinced \n\tthat it adds to the aesthetics in any meaningful way.\n\n\tAnyway, I have a few more interesting examples that I'll put up pretty soon.\n\t\n    Related examples: \n\n    Cellular Tiling - Shane\n    https://www.shadertoy.com/view/4scXz2\n\n\t// For comparison, this example uses the standard 2nd order Voronoi algorithm. For fun,\n\t// I dropped the cell tile routine into it and it ran a lot faster.\n\tVoronoi - rocks - iq\n\thttps://www.shadertoy.com/view/MsXGzM\n\n\trgba leizex - Inigo Quilez\n\thttp://www.pouet.net/prod.php?which=51829\n\thttps://www.youtube.com/watch?v=eJBGj8ggCXU\n\thttp://www.iquilezles.org/prods/index.htm\n\n\tTomasz Dobrowolski - Suboceanic\n\thttp://www.pouet.net/prod.php?which=18343\n\n*/\n\n#define PI 3.14159265358979\n#define FAR 50. // Maximum allowable ray distance.\n\n// Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// 2x2 matrix rotation.\nmat2 rot2(float a){\n    \n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n\n// The cellular tile routine. Draw a few objects (four spheres, in this case) using a minumum\n// blend at various 3D locations on a cubic tile. Make the tile wrappable by ensuring the \n// objects wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as three spheres. If you sum the total \n// instruction count here, you'll see that it's way, way lower than 2nd order 3D Voronoi.\n// Not requiring a hash function provides the biggest benefit, but there is also less setup.\n// \n// The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n// surface layer on a lot of 3D objects for little cost.\n//\n//Dain: for alternative rocks\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat drawSphere(in vec3 p){\n    \n    //Dain: warp space with sin so the rocks are of varying size\n    p += sin(p);\n    \n    // Anything that wraps the domain will suffice, so any of the following will work.\n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);    \n    p = fract(p)-.5;    \n    \n    //Dain: a few alternative rock styles\n    //return abs(p.x) + abs(p.y) + abs(p.z);   //big sharp rocks\n\t//return abs(sdBox(p, vec3(0.9, .10, 0.82))); //long jagged rocks\n    \n    return dot(p, p);\n    \n    // Other metrics to try.\n    \n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.5));\n    \n    //p = abs(fract(p)-.5);\n    //return max(max(p.x, p.y), p.z);\n    \n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    //p = abs(fract(p)-.5);\n    //return max(max(p.x - p.y, p.y - p.z), p.z - p.x);\n    //return min(min(p.x - p.y, p.y - p.z), p.z - p.x);\n    \n}\n//Dain: alternative shape that makes big jagged rocks(not used)\nfloat drawOct(in vec3 p){\n   // p += sin(p);\n    p = fract(p)-.5; \n    return abs(p.x) + abs(p.y) + abs(p.z);   //big sharp rocks\n}\n// Faster (I'm assuming), more streamlined version. See the comments below for an expanded explanation.\n// The function below is pretty quick also, and can be expanded to include more spheres. This one\n// takes advantage of the fact that only four object need sorting. With three spheres, it'd be even\n// better.\nfloat cellTile(in vec3 p){\n  //  p *= 2.0;\n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawSphere(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawSphere(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .4, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawSphere(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    //Dain: get 3 closest and use Fabrice's smooth voronoi \n    float m =  min(v.x, v.y);\n    float m2 = min(v.z, v.w);\n    float m3 = max(v.z, v.w);\n    \n    //Dain: if you want a more euclidean distance..\n   // m = sqrt(m);\n   // m2 = sqrt(m2);\n   // m3 = sqrt(m3);\n    \n    //Dain: use Fabrice's formula to produce smooth result\n    return min(2./(1./max(m2 - m, .001) + 1./max(m3 - m, .001)), 1.)*2.5;\n    \n  \n}\n\n/*\n// Draw some spheres throughout a repeatable cubic tile. The offsets were partly based on \n// science, but for the most part, you could choose any combinations you want. Note the \n// normalized planar positional roation between sphere rendering to really mix things up. This \n// particular function is used by the raymarcher, so involves fewer spheres.\n//\nfloat cellTile(in vec3 p){\n\n    // Storage for the closest distance metric, second closest and the current\n    // distance for comparisson testing.\n    //\n    // Set the maximum possible value - dot(vec3(.5), vec3(.5)). I think my reasoning is\n    // correct, but I have lousy deductive reasoning, so you may want to double check. :)\n    vec3 d = (vec3(.75)); \n   \n    \n    // Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    // Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53));\n    d.x = min(d.x, d.z); //d.y = max(d.x, min(d.y, d.z)); // Not needed on the first iteration.\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n     \n\t// More spheres means better patterns, but slows things down.\n    //p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    //d.z = drawSphere(p - vec3(.48, .29, .2));\n    //d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    //p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    //d.z = drawSphere(p - vec3(.06, .87, .78));\n    //d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z); \n\t\n\n    \n    // Returning what I'm hoping is a normalized result. Not that it\n    // matters too much, but I'd like it normalized.\n    // 2.66 seems to work, but I'll double check at some stage.\n    // d.x: Minimum distance. Regular round Voronoi looking.\n    // d.y - d.x - Maximum minus minimum, for that beveled Voronoi look.\n    //\n    return (d.y - d.x)*2.66; \n    //return 1. - d.x*2.66;\n    //return 1. - sqrt(d.x)*1.63299; // etc.\n\n    \n}\n*/\n\n// Just like the function above, but used to return the regional cell ID...\n// kind of. Either way, it's used to color individual raised sections in\n// the same way that a regular Voronoi function can. It's only called once,\n// so doesn't have to be particularly fast. It's kept separate to the\n// raymarched version, because you don't want to be performing ID checks\n// several times a frame when you don't have to. By the way, that applies\n// to identifying any object in any scene.\n//\n// By the way, it's customary to bundle the respective distance and cell\n// ID into a vector (vec3(d.x, d.y, cellID)) and return that, but I'm \n// keeping it simple here.\n//\nint cellTileID(in vec3 p){\n    \n    int cellID = 0;\n    \n    // Storage for the closest distance metric, second closest and the current\n    // distance for comparisson testing.\n    vec3 d = (vec3(.75)); // Set the maximum.\n    \n    // Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    // Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53)); if(d.z<d.x) cellID = 1;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11)); if(d.z<d.x) cellID = 2;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06)); if(d.z<d.x) cellID = 3;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n   \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64)); if(d.z<d.x) cellID = 4;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n/* \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere2(p - vec3(.48, .29, .2)); if(d.z<d.x) cellID = 5;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere2(p - vec3(.06, .87, .78)); if(d.z<d.x) cellID = 6;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z); \n*/ \n    \n    return cellID;\n    \n}\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ float s = sin(z/24.)*cos(z/16.); return vec2(s*9., 0); }\n\n// Standard tunnel distance function with some perturbation thrown into the mix. A tunnel is just a tube \n// with a smoothly shifting center as you traverse lengthwise. The walls of the tube are perturbed by the\n// cheap 3D surface function I described above.\nfloat map(vec3 p){\n\n    \n    float sf = cellTile(p/2.5);\n    \n    // Tunnel bend correction, of sorts. Looks nice, but slays framerate, which is disappointing. I'm\n    // assuming that \"tan\" function is the bottleneck, but I can't be sure.\n    //vec2 g = (path(p.z + 0.1) - path(p.z - 0.1))/0.2;\n    //g = cos(atan(g));\n    p.xy -= path(p.z);\n    //p.xy *= g;\n  \n    // Round tunnel.\n    // For a round tunnel, use the Euclidean distance: length(p.xy).\n    return 1.- length(p.xy*vec2(0.5, 0.7071)) + (0.5-sf)*.35;\n\n    \n/*\n    // Rounded square tunnel using Minkowski distance: pow(pow(abs(tun.x), n), pow(abs(tun.y), n), 1/n)\n    vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    tun = pow(tun, vec2(8.));\n    float n =1.-pow(tun.x + tun.y, 1.0/8.) + (0.5-sf)*.35;\n    return n;//min(n, p.y + FH);\n*/\n    \n/*\n    // Square tunnel.\n    // For a square tunnel, use the Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\n    float n = 1.- max(tun.x, tun.y) + (0.5-sf)*.5;\n    return n;\n*/\n \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 96; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. By the way, there is an \n// aesthetic difference between this and the regular six tap version. Sometimes, it's noticeable,\n// and other times, like this example, it's not.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n/*\n// Oldschool hatching effect. Interesting under the right circumstances.\nvec3 ch(in vec3 col, in vec2 fragCoord){\n    \n    vec3 fColor = col;\n    \n    float lum = dot(col, vec3(.299, .587, .114));// length(col);\n\tfloat mx = 1./7.; // 1.732/7.;\n    \n    float rgt = fragCoord.x + fragCoord.y;\n    float lft = fragCoord.x - fragCoord.y;\n    \n    fColor = col*4.; col *= .6;\n    \n    if (lum < mx*6. && mod(rgt, 8.) == 0.) fColor = col;\n    if (lum < mx*5. && mod(lft, 8.) == 0.) fColor = col;\n    if (lum < mx*4. && mod(rgt, 4.) == 0.) fColor = col;\n    if (lum < mx*3. && mod(lft, 4.) == 0.) fColor = col;\n    if (lum < mx*2. && mod(rgt, 2.) == 0.) fColor = col;\n    if (lum < mx*1. && mod(lft, 2.) == 0.) fColor = col;\n    \n    return min(fColor, 1.);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, iTime*6.);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0.0, 0.125, 4.125);// Put it a bit in front of the camera.\n\tvec3 light_pos2 = camPos + vec3(0.0, 0.0, 8.0);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\tlight_pos2.xy += path(light_pos2.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2( path(lookAt.z).x/32. )*rd.xy;\n\t\t\n    // Standard ray marching routine.\n    float t = trace(camPos, rd);\n\t\n    // The final scene color. Initated to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n\t\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = calcNormal(sp);\n        \n        // Texture scale factor.\n        const float tSize0 = 1./1.; \n        const float tSize1 = 1./1.;\n    \t\n    \t// Texture-based bump mapping.\n\t    //if (sp.y<-(FH-0.005)) sn = doBumpMap(iChannel1, sp*tSize1, sn, 0.025); // Floor.\n\t    //else sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.025); // Walls.\n        \n        sn = doBumpMap(iChannel1, sp*tSize0, sn, 0.02);\n        //sn = doBumpMap(sp, sn, 0.01);\n\t    \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\t    vec3 ld2 = light_pos2-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDdist = max(length(ld), 0.001);\n\t    float lDdist2 = max(length(ld2), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDdist;\n\t    ld2 /= lDdist2;\n\t    \n\t    // Light attenuation, based on the distances above. In case it isn't obvious, this\n        // is a cheap fudge to save a few extra lines. Normally, the individual light\n        // attenuations would be handled separately... No one will notice, or care. :)\n\t    float atten = 1./(1. + lDdist*.125 + lDdist*lDdist*.05);\n        float atten2 =  1./(1. + lDdist2*.125 + lDdist2*lDdist2*.05);\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.75;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 64.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 64.);\n    \t\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n \n        \n        vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n        \n        //texCol = min(texCol*1.5, 1.);\n        //texCol = vec3(1)*dot(texCol, vec3(0.299, 0.587, 0.114));\n        //texCol = smoothstep(-.0, .6, texCol); // etc.\n        \n        //texCol = texCol*vec3(1., .5, .2); \n        int id = cellTileID(sp/2.5);\n        if(id == 4) texCol = texCol*vec3(1., .5, .3); \n        if(id == 3) texCol = texCol*.5 + texCol*vec3(.5, .25, .15); \n        \n    \t\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.75+0.25; \n    \t\n        //Dain: put some green in the cracks\n        vec3 crevColor = tex3D(iChannel2, sp*tSize0, sn);\n        texCol = mix(texCol, crevColor, pow(1.0 - crv, 16.0));\n       // ambience *= crv;\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        //\n        // Shiny.\n        sceneCol = (texCol*(diff + ambience + spec) + spec*vec3(.7, .9, 1))*atten;\n        sceneCol += (texCol*(diff2 + ambience + spec2) + spec2*vec3(.7, .9, 1))*atten2;\n        //\n        // Other combinations:\n        //\n        // Glow.\n        //float gr = dot(texCol, vec3(0.299, 0.587, 0.114));\n        //sceneCol = (gr*(diff + ambience*0.25) + spec*texCol*2. + fre*crv*texCol.zyx*2.)*atten;\n        //sceneCol += (gr*(diff2 + ambience*0.25) + spec2*texCol*2. + fre*crv*texCol.zyx*2.)*atten2;\n        \n        // Shading.\n        sceneCol *= shading*ao;\n        \n        //Dain: turned off the lines to show the smooth surface\n        // Drawing the lines on the surface.      \n       // sceneCol *= clamp(abs(curve(sp, 0.035)), .0, 1.)*.5 + 1.;  // Glow lines.\n       // sceneCol *= 1. - smoothstep(0., 4., abs(curve(sp, 0.0125)))*vec3(.82, .85, .88); // Darker.\n\t   \n\t\n\t}\n    \n    // Some simple post processing effects.\n    //float a = dot(sceneCol, vec3(0.299, 0.587, 0.114));\n    //sceneCol = min(vec3(a*3., pow(a, 2.5)*2., pow(a, 6.)), 1.); // Fire palette.\n    //sceneCol = floor(sceneCol*15.999)/15.; // Oldschool effect.  \n    // Oldschool hatching effect. Uncomment the \"ch\" function to use this one.\n    //sceneCol = ch(clamp(sceneCol, 0., 1.), fragCoord); \n\t\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n    \n\t\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlcDS.jpg", "access": "api", "wgpu-test": "error"}
{"id": "Mdlcz4", "name": "diamonds", "author": "thaga", "description": ".", "tags": ["sb69"], "time_retrieved": "2024-05-15T23:14:14.805605", "image_code": "vec3 diamond(vec2 center, float size, vec2 fragCoord)\n{\n    vec2 offs = (fragCoord.xy - center) / size;\n    vec2 dist = abs(offs);\n    float R = -0.5 * offs.x - 0.866 * offs.y + 0.3;\n    float G = -0.5 * offs.x + 0.866 * offs.y + 0.3;\n    float B =  0.9 * offs.x + 0.6 * offs.y + 0.7;\n    return vec3(R, G, B) * (1.0 - smoothstep(0.45, 0.5, dist.x + dist.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 bgColor = vec3(0.2, 0.1, 0.6);\n    \n    vec3 c = vec3(0.0);\n    for (float i = 0.0; i < 16.0; i += 1.0) {\n        float size = iResolution.y / (5.4 + 2.0 * cos(i*23.3));\n        float x = iResolution.x * 0.06 * (i + 1.02 * cos(i*24.3));\n        float y = iResolution.y * (0.3 + 0.1 * sin(i*2.2) + 0.0002 * iTime * size);\n        c += diamond(vec2(x, y), size, fragCoord.xy);    \n    }\n        \n    fragColor.rgb = bgColor + c;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdlcz4.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlfD7", "name": "2D Rotation Visualisation", "author": "gilesruscoe", "description": "The relationship between 2D rotation and sin/cos", "tags": ["2d", "math", "visualization", "lines", "sin", "cos", "curve", "dots", "rotation", "visualisation", "points", "vectors"], "time_retrieved": "2024-05-15T23:14:14.840565", "image_code": "#define AA 6.0 / iResolution.y\n#define SIZE 0.75\n\nfloat disk(vec2 uv, vec2 center, float radius)\n{\n    float d = length(uv - center);\n    return smoothstep(d, d + 0.01, radius);\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b, float width)\n{\n    vec2 pa = uv - a;\n    vec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\t\n\treturn 1.0 - smoothstep(-AA, AA, length(pa - ba * h) - width);\n}\n\nfloat cosLine(vec2 uv, float width)\n{\n    return smoothstep(AA, -AA, length(cos(iTime - uv.x) - uv.y) - width);\n}\n\nfloat sinLine(vec2 uv, float width)\n{\n    return smoothstep(AA, -AA, length(sin(iTime - uv.y) - uv.x) - width);\n}\n\nfloat circle(vec2 uv, vec2 center, float radius)\n{\n    return smoothstep(AA, -AA, abs(length(uv - center)-radius));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //Uvs\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y / SIZE;\n    \n    //Cos and Sin waves power the rotation angle\n    float sinx = sin(iTime);\n    float cosx = cos(iTime);\n    \n    //Lines showing indivisual axis movements\n    float lineSX = line(uv, vec2(sinx, -1.0), vec2(sinx, 1.0), 0.005);\n    float lineCX = line(uv, vec2(-1.0, cosx), vec2(1.0, cosx), 0.005);\n    \n    //Points of interest\n    vec2 pRot = vec2(sinx, cosx);\n    vec2 pOrigin = vec2(0);\n    float p0 = disk(uv, pOrigin, 0.04);\n    float p1 = disk(uv, vec2(sinx, 0.0), 0.03);\n    float p2 = disk(uv, vec2(0.0, cosx), 0.03);\n    float p3 = disk(uv, pRot, 0.04);\n    \n    //Lazy single channel colours...\n    fragColor = vec4(0.1);\n\tfragColor.x += max(lineSX, p1);\n    fragColor.y += max(lineCX, p2);\n    float rotLine =  max(p3 + p0, line(uv, pOrigin, pRot, 0.01));\n    fragColor.xyz += max(rotLine, circle(uv, pOrigin, 1.0));\n    fragColor.xyz += cosLine(uv, 0.005) * 0.25;\n    fragColor.xyz += sinLine(uv, 0.005) * 0.25;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfD7.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlfDH", "name": "cylinders to boxes?", "author": "lahwran", "description": "trying to convert cylinders to boxes but not sure exactly what distance function to change yet\n\nso far just screwing things up\n\n(clarification: not OC, just trying to change iq's shader)", "tags": ["procedural"], "time_retrieved": "2024-05-15T23:14:17.302594", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Try 4, 15, 30 samples if yo have a powerful machine\n\n#define VIS_SAMPLES 1\n\nfloat controlledTime() {return iTime*0.04;}\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\n\nfloat gAnimTime;\nfloat map( vec2 p ) \n{\n\tfloat f = textureLod( iChannel0, p/iChannelResolution[0].xy, 0.0 ).x;\n\t\n\tf *= sqrt( textureLod( iChannel2, (0.03*p + 2.0*gAnimTime)/256.0, 0.0 ).x );\n\treturn 22.0*f;\n}\n\nvec3 calcNormal( in vec3 pos, in float ic )\n{\n\treturn mix( normalize(vec3(pos.x,0.0,pos.z)), vec3(0.0,1.0,0.0), ic );\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    // traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<400; i++ ) \n\t{\n\n\t\tfloat ma = map(pos);\n\t\t\n        // intersect capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n            // cylinder\t\t\t\n\t\t\tfloat s = (-b - sqrt( h ))/a;\n\t\t\tif( s>0.0 && (ro.y+s*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = vec4( s, 0.0, pos );\n    \t\t\tbreak; \n\t\t\t}\n            // cap\t\t\t\n\t\t\ts = (ma - ro.y)/rd.y;\n\t\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t\t{\n\t\t\t\tres = vec4( s, 1.0, pos );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris*0.3;\n        pos += mm*rs;\n\t}\n\n\n\treturn res;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\tfloat t = -1.0;\n\tfloat res = 1.0;\n\t\n    // first step we check noching\t\n\tvec2 mm = step( dis.xy, dis.yx ); \n\tdis += mm * ris;\n    pos += mm * rs;\n\t\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<16; i++ ) \n\t{\n\t\tfloat ma = map(pos);\n\t\t\n        // test capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n\t\t\tfloat t = (-b - sqrt( h ))/a;\n\t\t\tif( (ro.y+t*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = 0.0;\n    \t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\treturn res;\n}\n\nvec3 cameraPath( float t )\n{\n    // procedural path\t\n    vec2 p  = 200.0*sin( 0.01*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p += 100.0*sin( 0.02*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 15.0 + 4.0*sin(0.05*t);\n\t\n\t// collision\n\tfloat h;\n\th  = map( p+vec2(-1.0, 0.0) );\n\th += map( p+vec2( 1.0, 0.0) );\n\th += map( p+vec2( 0.0, 1.0) );\n\th += map( p+vec2( 0.0,-1.0) );\n\th /= 4.0;\n\th += 5.0;\n\ty = max( y, h );\n\n\treturn vec3( p.x, y, p.y );\n}\n\nvec4 texcyl( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, vec2(p.y,0.5+0.5*atan(n.x,n.z)/3.14) );\n\tvec4 y = texture( sam, p.xz );\n\treturn mix( x, y, abs(n.y) );\n}\n\nvec3 desat( in vec3 col, float a )\n{\n    return mix( col, vec3(dot(col,vec3(0.333))), a );\n}\n\nvec3 lig = normalize(vec3(-0.7,0.25,0.6));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n        // background color\t\n\t\tfloat sun = clamp( dot( rd, lig ), 0.0, 1.0 );\n\n\t\tvec3 bgcol = vec3(0.9,0.9,0.8) + 0.3*pow(sun,4.0)*vec3(1.0,1.0,0.0);\n\n        // raytrace\n        vec3 col = bgcol;\n\t\tvec4 res = castRay( ro, rd );\n        vec2 vos = res.zw;\n        float t = res.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + rd*t;\n\t\t\tfloat id  = hash1( vos );\n\t\t\tvec3  nor = calcNormal( fract(pos)-0.5, res.y );\n\t\t\tfloat h = map(vos);\n\n            // material color\t\t\t\n\t\t\tvec3 mate1 = 0.5 + 0.45*sin( 3.14*id + 0.8 + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate2 = 0.5 + 0.45*sin( 6.28*id + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate = mix( mate1, mate2, smoothstep( 9.0, 11.0, h) );\n\t\t\t\n\t\t\tvec3 uvw = pos - vec3(0.0,h,0.0);\n\t\t\tvec3 tex = texcyl( iChannel3, 0.2*uvw + 13.1*hash1(id), nor ).xyz;\n\t\t\tmate *= 0.2+4.0*pow( desat(tex,0.3), vec3(2.0) );\n            mate *= 1.5*sqrt(texture( iChannel0, pos.xz/iChannelResolution[0].xy ).xyz);\n            mate *= 0.02 + 0.98*smoothstep( 0.1,0.11, hash1(id) );\t\n\t\t\t\n            // material cheap/wrong bump\t\t\t \n            vec3 bn = -1.0 + 2.0*texcyl( iChannel1, 0.2*uvw*vec3(1.0,0.2,1.0) + 13.1*hash1(id), nor ).xyz;\n            //nor = normalize(nor + 0.45*bn*(1.0-0.5*nor.y) );\n\t\t\t\n\t\t\t// procedural occlusion\n\t\t\tfloat occ = nor.y*0.75;\n\t\t\tocc += 0.5*clamp( nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp(-nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2(-1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp( nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0, 1.0)) );\n\t\t\tocc += 0.5*clamp(-nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0,-1.0)) );\n\t\t\tocc = 0.2 + 0.8*occ;\n\t\t\tocc *= pow( clamp((0.1+pos.y)/(0.1+map(floor(pos.xz))),0.0,1.0),2.0);\n\t\t\tocc = occ*0.5+0.5*occ*occ;\n\t\t\tfloat rim = pow( clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),5.0 );\n \n            //-------------\n            // lighitng\n            //-------------\n\t\t\tfloat amb = 1.0;\n            //-------------\n\t\t\tfloat bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z)) ), 0.0, 1.0 ) * clamp(1.0-pos.y/20.0,0.0,1.0);;\n            //-------------\n\t\t\tfloat sha = 0.0;\n\t\t\tfloat dif = dot( nor, lig );\n\t\t\tif( dif<0.0 ) dif=0.0; else sha = castShadowRay( pos, lig );\n            float spe = pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0 ),3.0 );\n            //-------------\n\t\t\tvec3 lin  = 3.00*vec3(1.0,1.0,1.0)*0.7*sqrt(dif)*sha;\n\t\t\t     lin += 0.40*vec3(0.4,1.0,1.7)*amb*occ;\n\t\t\t     lin += 0.60*vec3(0.8,0.5,0.3)*bac*occ;\n\t\t\t\n\t\t\tcol = mate * lin + tex.x*1.5*vec3(1.0,1.0,1.0)*(0.3+0.7*rim)*spe*dif*sha;\n\n            // tone mapping\t\t\t\n\t\t\tcol *= 1.1 + 0.5*dot( rd, lig );\n\n            // fog\n            float ff = 1.0 - smoothstep( 0.0, 1.0, pow(t/160.0,1.8) );\n\t\t\tcol = mix( col, bgcol, 1.0-ff );\n\t\t}\n\t\tcol += 0.2*pow(sun,8.0)*vec3(1.0,0.7,0.2);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n    gAnimTime = controlledTime();\n    \n\t// montecarlo\t\n\tvec3 tot = vec3(0.0);\n    #if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n        float time = 4.0*controlledTime() + 50.0*mo.x;\n    #else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n\t\tvec4 rr = texture( iChannel1, (fragCoord.xy+floor(256.0*hash2(float(a))))/iChannelResolution[1].xy );\n        vec2 p = -1.0 + 2.0*(fragCoord.xy+rr.xz) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n\t\t#if VIS_SAMPLES>3\n        float time = 4.0*(controlledTime() + 1.0*(0.4/24.0)*rr.w) + 50.0*mo.x;\n\t\t#else\n        float time = 4.0*(controlledTime()) + 50.0*mo.x;\n\t\t#endif\n    #endif\t\n\n\t\t// camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time+5.0 ); ta.y = ro.y - 5.5;\n        float cr = 0.2*cos(0.1*time*0.5);\n\t\n        // build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        // dof\n        #if VIS_SAMPLES>2\n        vec3 fp = ro + rd * 17.0;\n        ro += (uu*(-1.0+2.0*rr.y) + vv*(-1.0+2.0*rr.w))*0.035;\n        rd = normalize( fp - ro );\n        #endif\n\n\n        vec3 col = render( ro, rd );\n        \n\t\ttot += col;\n\t}\n\ttot /= float(VIS_SAMPLES);\n\t\n\n\t// gamma\t\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n\t// vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( tot, 1.0 );\n}\n    \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 cam = cameraPath( controlledTime() );\n\n    gAnimTime = controlledTime()*0.2;\n\n    vec3 ro = fragRayOri + cam + vec3(0.0,-2.0,0.0);\n    vec3 rd = fragRayDir*vec3(-1.0,1.0,-1.0);\n    vec3 col = render( ro, rd );\n\n    // gamma\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.44) );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfDH.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MdlfDj", "name": "Bezier Colors", "author": "joshforisha", "description": "A demo of color-shifting using bezier curves.", "tags": ["bezier"], "time_retrieved": "2024-05-15T23:14:18.076750", "image_code": "vec3 green = vec3(0.0, 1.0, 0.0);\nvec3 pinkSalmon = vec3(1.000, 0.589, 0.718);\nvec3 white = vec3(1.0, 1.0, 1.0);\nvec3 wisteria = vec3(0.620, 0.402, 0.694);\n\nfloat cerp (float a, float b, float c, float d, float u) {\n    return (a * pow(1.0 - u, 3.0)) +\n        (3.0 * b * pow(1.0 - u, 2.0) * u) +\n        (3.0 * c * (1.0 - u) * pow(u, 2.0)) +\n        (d * pow(u, 3.0));\n}\n\nfloat cirp (vec4 v, float t) {\n    return v[0]*pow(t, 3.0) + v[1]*pow(t, 2.0) + v[2]*t + v[3];\n}\n\nvec4 infl (float a, float b, float c, float d) {\n    return vec4(\n        d - 3.0*c + 3.0*b - a,\n        3.0*c - 6.0*b + 3.0*a,\n        3.0*b - 3.0*a,\n        a\n    );\n}\n\nfloat slope (float a, float b, float c, float t) {\n    return 1.0 / (3.0*a*pow(t, 2.0) + 2.0*b*t + c);\n}\n\nfloat cubicBezier (vec4 curve, float u) {\n    vec4 ix = infl(0.0, curve[0], curve[2], 1.0);\n    vec4 iy = infl(0.0, curve[1], curve[3], 1.0);\n    \n    float v = u;\n    int nRefinements = 10;\n    for (int i = 0; i < nRefinements; i++) {\n        float x = cirp(ix, v);\n        float slp = slope(ix[0], ix[1], ix[2], v);\n        v = clamp(v - ((x - u) * slp), 0.0, 1.0);\n    }\n    \n    return cirp(iy, v);\n}\n\nfloat plot (float val, float pct) {\n    return smoothstep(pct - 0.02, pct, val) -\n           smoothstep(pct, pct + 0.02, val);\n}\n\n// CURVES!\nvec4 easeInOutCirc = vec4(0.785, 0.135, 0.15, 0.86);\nvec4 easeInOutCubic = vec4(0.645, 0.045, 0.355, 1.000);\nvec4 easeInOutExpo = vec4(1.0, 0.0, 0.0, 1.0);\nvec4 easeInOutQuad = vec4(0.455, 0.03, 0.515, 0.955);\nvec4 easeInOutQuart = vec4(0.77, 0.0, 0.175, 1.0);\nvec4 easeInOutQuint = vec4(0.86, 0.0, 0.07, 1.0);\nvec4 easeInOutSine = vec4(0.445, 0.05, 0.55, 0.95);\n\nvec4 easeInCirc = vec4(0.6, 0.04, 0.98, 0.335);\nvec4 easeInCubic = vec4(0.55, 0.055, 0.675, 0.19);\nvec4 easeInExpo = vec4(0.95, 0.05, 0.795, 0.035);\nvec4 easeInQuad = vec4(0.55, 0.085, 0.68, 0.53);\nvec4 easeInQuart = vec4(0.895, 0.03, 0.685, 0.22);\nvec4 easeInQuint = vec4(0.755, 0.05, 0.855, 0.06);\nvec4 easeInSine = vec4(0.47, 0.0, 0.745, 0.715);\n\nvec4 easeOutCirc = vec4(0.075, 0.82, 0.165, 1.0);\nvec4 easeOutCubic = vec4(0.215, 0.61, 0.355, 1.0);\nvec4 easeOutExpo = vec4(0.19, 1.0, 0.22, 1.0);\nvec4 easeOutQuad = vec4(0.25, 0.46, 0.45, 0.94);\nvec4 easeOutQuart = vec4(0.165, 0.84, 0.44, 1.0);\nvec4 easeOutQuint = vec4(0.23, 1.0, 0.32, 1.0);\nvec4 easeOutSine = vec4(0.39, 0.575, 0.565, 1.0);\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Change this to any of the above curves:\n\tvec4 curve = easeInOutQuad;\n\n\t// Set speed, in seconds:\n\tfloat speed = 2.0;\n    \n    vec2 st = fragCoord.xy / float(iResolution);\n    float t = 1.0 - abs((mod(iTime, 2.0 * speed) - speed) / speed);\n    float timed = cubicBezier(curve, t);\n    float plotted = plot(st.y * 1.778, cubicBezier(curve, st.x));\n    float indicated = plot(st.x, t);\n    \n    vec3 baseColor = mix(wisteria, pinkSalmon, timed);\n    vec3 bgColor = mix(baseColor, white, indicated);\n    vec3 color = mix(bgColor, green, plotted);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfDj.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlfRj", "name": "buildings + train", "author": "antoineMoPa", "description": "Some 2D city made mostly from sine waves.\n\nMade some months ago, I made it public now, there may be some bugs on some GPUs.\n\nYou should see a train, buildings, stars.", "tags": ["2d", "city", "train", "buildings"], "time_retrieved": "2024-05-15T23:14:19.748047", "image_code": "uniform float time;\n\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define shadertoy 1\n\n#ifdef shadertoy\n#define time iTime\n#endif\n#ifndef shadertoy\nuniform float iTime;\nvarying vec2 UV;\nuniform vec3 iResolution;\n#endif\n\nvec4 buildings(vec2 pos){\n\tvec4 col = vec4(0.0);\n    \n    float roof = 0.1;\n    float bx = pos.x * 20.0;\n    float x = 0.05 * floor(bx - 4.0);\n    // BX = Position relative to building left\n    bx = mod(bx,1.0);\n  \n    // Build pseudorandom rooftop line\n    roof += 0.06 * cos(x * 2.0);\n\troof += 0.1 * cos(x * 23.0);\n\troof += 0.02 * cos(x * 722.0 );\n\troof += 0.03 * cos(x * 1233.0 );\n\t\n    roof += 0.06;\n    \n    if(pos.y < roof && pos.y > 0.0 && bx > 0.1 * cos(20.0 * pos.x)){\n    \tcol.b += 0.4;\n        \n        // Draw windows\n        float window = abs(sin(200.0 * pos.y));\n        window *= abs(sin(20.0 * bx));\n        \n        // type 1 window\n        if(mod(2023.0 * x,2.0) < 0.5){\n          \twindow = floor(1.3 * window);\n        \tcol.rgb += 1.5 * window * vec3(0.9,0.9,0.9);\n        }\n        // type 2 window\n        else if(mod(2983.0 * x,2.0) < 1.3){\n        \tcol.rb += window;\n        }\n        else {\n            if(window > 0.5){\n            \tcol.rg += 0.8;\n           \t}\n        }\n      \tcol.a = 1.0;\n    }\n\n    return col;\n}\n\nvec4 train(vec2 pos){\n\tvec4 col = vec4(0.0);\n    \n    float base = 0.01 * cos(pos.x * 7.0 + time * PI2) + 0.02;\n    \n\n    col.r += base;\n   \t\n    if(pos.y > 0.0){\n        pos.y -= base;\n        // track\n        if(pos.y < 0.01){\n            // Actual track\n            if(pos.y > -0.005){\n                col.rg += 0.1;\n                col.a = 1.0;\n            }\n            // supports\n            else if(cos(4.0 * (pos.x * 7.0 + time * PI2)) < -0.8){\n            \tcol.rg += 0.1;\n                col.a = 1.0;\n            }\n            \n        }\n        // train\n        else if(pos.y < 0.04 && pos.x < 0.3){\n            bool in_y_range = pos.y < 0.02 || pos.y > 0.03;\n              \t\n            if(pos.x < -0.01){\n                // Delimit wagons\n                if(pos.x > -0.02 || cos(pos.x * 100.0) < 0.9){\n\n                    if(pos.y < 0.018 && pos.y > 0.014 && pos.x < -0.02){\n                        col.r += 1.0;\t\n                        col.a = 1.0;\n                    }\n\n                    // windows\n                    else if(!in_y_range && pos.x > 0.01){\n                        col.a = 0.0;\n                    } else if(in_y_range || (cos(pos.x * 400.0) < 0.0) ){\n                        col.rgb += 0.5;\n                        col.a = 1.0;\n                    }\n                }\n            } else if (pos.x < 0.01) {\n                // Front of the train\n                // function: 1-x^3\n                // Make a suitable x and y axis to plot the function\n                float xx = (pos.x + 0.01)/ 0.02;\n                float yy = (pos.y - 0.02) / 0.02;\n                float func = 1.0 - pow(xx, 3.0);\n                \n                if(yy < func){\n                \tcol.rgb += 0.5;\n                    col.a = 1.0;\n                }\n            }\n        }\n    }\n    \n    return col;\n}\n\nvec4 stars(vec2 pos){\n\tvec4 col = vec4(0.0);\n  \tfloat threshold = -0.999;\n\tpos *= 1.0;\n  \tif(1.0 * cos(pos.x * 1000.0) + 1.0 * cos(30000.0 * pos.x + cos(10000.0 * pos.y)) < threshold){\n      \tif(cos(pos.y * 100.0 + 10000.0 * cos(pos.x * 10.0)) < threshold){\n      \t\tcol += 1.0;\n          \tcol.a = 1.0;\n        }\n    }\n  \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n\tvec4 col = vec4(0.0);\n    \n    vec2 pos = uv - vec2(0.5);\n    \n    pos.y += 0.3;\n    \n    vec2 water = vec2(0.0);\n    \n    // Offset for water waves\n    water.x += 0.003 * cos(pos.y * 150.0 + time * PI2);\n    water.x += 0.001 * cos(pos.y * 250.0 +  time * PI2);\n    water.x += 0.001 * cos(pos.y * 4050.0 + time * PI2);\n    \n    col += 0.6 * buildings(pos + vec2(time * 0.2, 0.0)); // Buildings\n    col += 0.3 * buildings(pos * vec2(1.0, -1.0) + vec2(time * 0.2, 0.0) + water); // Reflection of buildings\n    \n    vec4 t = train(pos);\n    col = t.a * t + (1.0 - t.a) * col; // Train\n    t = train(pos * vec2(1.0, -1.0) + water); // Reflection of train\n    t.a *= 0.3;\n    col = t.a * t + (1.0 - t.a) * col;\n    \n    \n    // Sky + water color\n  \tif(col.a < 0.1){\n        if(pos.y < 0.0){\n            col.b += 0.2;\n        } else {\n            col.rgb += vec3(0.1,0.1,0.3);\n            col += stars(pos);\n        }\n    }\n  \n    // Plane\n    if(pos.x < -0.1 && pos.y > 0.6 && pos.y < 0.602){\n    \tcol.rgb += 0.22 +\n            0.1 * cos(pos.x + iTime) + \n            0.03 * cos(pos.x * 200.0 + 10.0 * iTime);\n    }\n    \n    float d = distance(pos,vec2(-0.1, 0.6));\n    \n    if(d < 0.005){\n    \tcol.r += (1.0 - d/0.01) * (pow(cos(time * PI),30.0)  + 0.5);\n    \tcol.b += (1.0 - d/0.01) * (pow(cos(time * PI + 1.0),30.0)  + 0.5);\n    }\n    \n    col.a = 1.0;\n    \n\tfragColor = col;\n}\n\n#ifndef shadertoy\nvoid main(){\n    vec2 uv = UV * iResolution.xy;\n    vec4 col;\n\n    mainImage(col, uv);\n\n    gl_FragColor = col;\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfRj.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MdlfRl", "name": "Closely Watched Dolphins", "author": "dr2", "description": " Dolphins in a hexagonal crystal reef. The default view tracks the nearest dolphin;\n override using the mouse.\n", "tags": ["raymarch", "voxel", "hexagon", "bubble", "underwater", "dolphin"], "time_retrieved": "2024-05-15T23:14:24.061546", "image_code": "// \"Closely Watched Dolphins\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrSphAnDf (vec3 p, float r, float w);\nfloat PrEllipsDf (vec3 p, vec3 r);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_FISH 2\n#define SQRT3 1.73205\n\nvec3 fishPos[N_FISH], vuPos, sunDir, cHit, cHitP, qnHit, qHit;\nfloat fishAngH[N_FISH], fishAngV[N_FISH], fishAngI, tCur, dstFar;\nint idObj;\nconst float hcScale = 20.;\nconst vec3 hcSize = vec3 (0.5 * SQRT3, 1., 1.3);\nconst vec3 bcSize = vec3 (0.5, 1., 0.5);\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (4. * sin (0.08 * t) + 1.5 * sin (0.11 * t),\n     2. * sin (0.09 * t) + 0.4 * sin (0.13 * t), t);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec2 c, r, dr;\n  c = vec2 ((2. / SQRT3) * p.x, p.y);\n  r = floor (c);\n  r += mod (vec2 (r.x, r.y + step (2., mod (r.x + 1., 4.))), 2.);\n  dr = c - r;\n  r += step (1., 0.5 * dot (abs (dr), vec2 (SQRT3, 1.))) * sign (dr) * vec2 (2., 1.);\n  return r;\n}\n\nbool HexCellFull (vec3 p)\n{\n  float hs, hb;\n  p = (p * hcSize).yzx / hcScale;\n  p.xy -= TrackPath (p.z).xy;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  hs = length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1;\n  hb = 4. - p.y;\n  idObj = (hs > hb) ? 0 : 1;\n  return (min (hs, hb) < 0.);\n}\n\nfloat HexVolRay (vec3 ro, vec3 rd)\n{\n  vec3 ht, htt, w;\n  vec2 hv[3], ve;\n  float dHit, ty, dy;\n  ro *= hcScale;\n  cHit = vec3 (PixToHex (ro.zx), floor (ro.y / hcSize.z + 0.5));\n  hv[0] = vec2 (0., 1.);\n  hv[1] = vec2 (1., 0.5);\n  hv[2] = vec2 (1., -0.5);\n  for (int k = 0; k < 3; k ++)\n     hv[k] *= sign (dot (hv[k], vec2 (0.5 * SQRT3 * rd.z, rd.x)));\n  dy = sign (rd.y);\n  qnHit = vec3 (0.);\n  dHit = dstFar * hcScale + 0.01;\n  for (int j = 0; j < 200; j ++) {\n    w = ro - (cHit * hcSize).yzx;\n    ht.z = 1e6;\n    for (int k = 0; k < 3; k ++) {\n      ve = vec2 (0.5 * SQRT3 * hv[k].x, hv[k].y);\n      htt = vec3 (hv[k], (1. - dot (ve, w.zx)) / dot (ve, rd.zx));\n      if (htt.z < ht.z) ht = htt;\n    }\n    ty = (0.5 * dy * hcSize.z - w.y) / rd.y;\n    cHitP = cHit;\n    if (ht.z < ty) cHit.xy += 2. * ht.xy;\n    else cHit.z += dy;\n    if (HexCellFull (cHit)) {\n      if (ht.z < ty) {\n        qnHit = - vec3 (0.5 * SQRT3 * ht.x, ht.y, 0.);\n        dHit = ht.z;\n      } else {\n        qnHit = - vec3 (0., 0., dy);\n        dHit = ty;\n      }\n      break;\n    }\n  }\n  return dHit / hcScale;\n}\n\nfloat HexFaceDist (vec3 p)\n{\n  vec4 h[4];\n  vec3 cNeb, vh;\n  float d;\n  p = p.zxy * hcScale - cHitP * hcSize;\n  p.z *= 2. / hcSize.z;\n  h[0] = vec4 (0., 1., 0., 1.);\n  h[1] = vec4 (1., 0.5, 0., 1.);\n  h[2] = vec4 (1., -0.5, 0., 1.);\n  h[3] = vec4 (0., 0., 0.5, 0.5 * hcSize.z);\n  d = 1e5;\n  for (int k = 0; k < 4; k ++) {\n    vh = h[k].xyz;\n    cNeb = cHitP + 2. * vh;\n    if (cNeb != cHit && HexCellFull (cNeb))\n\td = min (d, h[k].w - dot (vh * hcSize, p));\n    cNeb = cHitP - 2. * vh;\n    if (cNeb != cHit && HexCellFull (cNeb))\n\td = min (d, h[k].w + dot (vh * hcSize, p));\n  }\n  return d;\n}\n\nvec3 HexVolCol (vec3 p, float edgDist, float dHit)\n{\n  vec3 col;\n  col = HsvToRgb (vec3 (Hashfv2 (cHit.xy), 0.5, 1.));\n  col.r *= 0.1 + 0.9 * smoothstep (-0.5, 0.5, p.y) *\n     (1. - smoothstep (0., 5., dHit));\n  if (qnHit.z != 0.) col *= 0.7 + 0.3 * smoothstep (0., 0.7, abs (edgDist));\n  return col;\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  p = 10. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (p.x * 2. + t * 0.77 + sin (p.y * 0.73 - t)) +\n     sin (p.y * 0.81 - t * 0.89 + sin (p.x * 0.33 + t * 0.34)) +\n     (sin (p.x * 1.43 - t) + sin (p.y * 0.63 + t)) * 0.5;\n  h *= smoothstep (0.5, 1., rd.y) * 0.04;\n  return h;\n}\n\nfloat EdgeDist (vec3 p)\n{\n  vec2 dh;\n  float d;\n  p *= hcScale;\n  dh = p.zx - cHit.xy * vec2 (0.5 * SQRT3, 1.);\n  if (qnHit.z == 0.) {\n    d = abs (fract (p.y / hcSize.z) - 0.5) * hcSize.z;\n    dh -= qnHit.xy * dot (dh, qnHit.xy);\n    d = min (d, abs (length (dh) - 1. / SQRT3));\n  } else {\n    dh = abs (dh);\n    d = max (0.5 * dot (dh, vec2 (SQRT3, 1.)), dh.y) - 1.;\n  }\n  return d;\n}\n\nfloat FishDf (vec3 p)\n{\n  vec3 q;\n  float dMin, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye, d;\n  p.x = abs (p.x);\n  p.z -= 2.;\n  p.yz = Rot2D (p.yz, 0.2 * fishAngI);\n  q = p;\n  q.z -= -0.6;\n  dBodyF = PrEllipsDf (q, vec3 (0.7, 0.8, 2.4));\n  q = p;\n  q.z -= -1.2;\n  q.yz = Rot2D (q.yz, fishAngI);\n  q.z -= -1.6;\n  dBodyB = PrEllipsDf (q, vec3 (0.35, 0.5, 2.5));\n  q.z -= -2.2;\n  q.yz = Rot2D (q.yz, 2. * fishAngI);\n  q.xz -= vec2 (0.5, -0.5);\n  q.xz = Rot2D (q.xz, 0.4);\n  dFinT = PrEllipsDf (q, vec3 (0.8, 0.07, 0.4));\n  q = p;\n  q.yz -= vec2 (-0.3, 1.7);\n  q.yz = Rot2D (q.yz, 0.1);\n  q.y = abs (q.y) - 0.04;\n  dMouth = PrEllipsDf (q, vec3 (0.25, 0.12, 0.6));\n  q = p;\n  q.yz -= vec2 (0.7, -1.);\n  q.yz = Rot2D (q.yz, 0.6);\n  dFinD = PrEllipsDf (q, vec3 (0.05, 1., 0.35));\n  q = p;\n  q.xy = Rot2D (q.xy, 0.8);\n  q.xz -= vec2 (0.7, -0.1);\n  q.xz = Rot2D (q.xz, 0.6);\n  dFinP = PrEllipsDf (q, vec3 (0.9, 0.04, 0.3));\n  q = p;\n  q -= vec3 (0.4, -0.1, 1.1);\n  dEye = PrEllipsDf (q, vec3 (0.11, 0.15, 0.15));\n  idObj = 11;\n  dMin = SmoothMin (dBodyF, dBodyB, 0.3);\n  dMin = SmoothMin (dMin, dFinT, 0.1);\n  dMin = SmoothMin (dMin, dMouth, 0.15);\n  dMin = SmoothMin (dMin, dFinD, 0.02);\n  dMin = SmoothMin (dMin, dFinP, 0.02);\n  if (dEye < dMin) idObj = 12;\n  dMin = SmoothMin (dMin, dEye, 0.01);\n  qHit = q;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qHitA;\n  float dMin, d, szFac;\n  int idObjA;\n  szFac = 8.;\n  dMin = dstFar * szFac;\n  for (int k = 0; k < N_FISH; k ++) {\n    q = (p - fishPos[k]) * szFac;\n    q.xz = Rot2D (q.xz, fishAngH[k]);\n    q.yz = Rot2D (q.yz, fishAngV[k]);\n    d = FishDf (q);\n    if (d < dMin) {\n      idObjA = idObj;\n      qHitA = qHit;\n      dMin = d;\n    }\n  }\n  idObj = idObjA;\n  qHit = qHitA;\n  return dMin / szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 1.;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.08 * (1. + 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nfloat BubDf (vec3 p, vec3 vr)\n{\n  float s, d, a;\n  vr -= 0.5;\n  s = fract (64. * dot (vr, vec3 (1.)));\n  d = 0.1 * s * abs (vr.x * sin (3. * pi * s * (tCur + vr.y)));\n  a = 0.03 * pi * vr.z * tCur;\n  p.xz -= d * vec2 (cos (a), sin (a));\n  p.y -= bcSize.y * vr.x;\n  return PrSphDf (p, 0.01 * (1. - 0.7 * s));\n}\n\nconst vec3 bHash = vec3 (1., 57., 113.);\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cId, vr, s;\n  float dHit, d;\n  dHit = 0.1;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + rd * dHit;\n    p.y -= 0.5 * tCur;\n    cId = floor (p / bcSize);\n    vr = Hashv3f (dot (cId, bHash));\n    d = (vr.x > 0.5) ? BubDf (p - bcSize * (cId + 0.5), vr) : dstFar;\n    s = (bcSize * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (min (min (s.x, s.y), s.z)) + 0.01);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat BObjDf (vec3 p)\n{\n  vec3 cId, vr;\n  cId = floor (p / bcSize);\n  vr = Hashv3f (dot (cId, bHash));\n  return BubDf (p - bcSize * (cId + 0.5), vr);\n}\n\nvec3 BObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  p.y -= 0.5 * tCur;\n  v = vec4 (BObjDf (p + e.xxx), BObjDf (p + e.xyy),\n     BObjDf (p + e.yxy), BObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat CageDf (vec3 p)\n{\n  p.xz = Rot2D (Rot2D (p.xz, 2. * pi * 0.5/12.), 2. * pi * (floor (12. *\n     ((length (p.xz) > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.)) + 0.5) / 12.);\n  p.z = abs (p.z);\n  return max (PrSphAnDf (p, 0.05, 0.0001),\n     min (abs (mod (p.y, 0.019) - 0.0095) - 0.0001,\n     dot (p.xz, vec2 (sin (0.04 * 2. * pi / 24.), cos (0.04 * 2. * pi / 24.)))));\n}\n\nfloat CObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = CageDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 4. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = (clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.)) *\n     (1. - smoothstep (0.4, 0.6, rd.y));\n  return vec3 (0.3, 1., 1.) * (0.1 + 0.225 * (rd.y + 1.) * (rd.y + 1.)) *\n     (1. + 0.06 * gd);\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec2 q, qq, a1, a2;\n  float c, tt;\n  q = vec2 (dot (p.yzx, n), dot (p.zxy, n));\n  q = 2. * pi * mod (q, 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (float k = 1.; k <= 7.; k ++) {\n    tt = t * (1. + 1. / k);\n    a1 = tt - qq;\n    a2 = tt + qq;\n    qq = q + tt + vec2 (cos (a1.x) + sin (a2.y), sin (a1.y) + cos (a2.x));\n    c += 1. / length (q / vec2 (sin (qq.x), cos (qq.y)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj, dstBub, dstCage, dHit, dEdge, sh, diff, h, dFade, dm;\n  dHit = HexVolRay (ro, rd);\n  if (idObj == 0) dHit = dstFar;\n  dstObj = ObjRay (ro, rd);\n  dstBub = BObjRay (ro, rd);\n  if ((ro + dstBub * rd).y > 4.) dstBub = dstFar;\n  dstCage = CObjRay (ro - vuPos, rd);\n  bgCol = BgCol (rd);\n  col = bgCol;\n  dm = min (dstCage, dstObj);\n  if (min (min (dstBub, dm), dHit) < dstFar) {\n    if (min (dstBub, dm) < dHit) {\n      if (dm < dstBub) {\n        if (dstObj < dstCage) {\n          ro += dstObj * rd;\n          vn = ObjNf (ro);\n          if (idObj == 11) col = vec3 (0.6, 0.6, 1.) *\n             (1. - 0.4 * smoothstep (-0.5, -0.4, vn.y));\n          else if (idObj == 12) col = vec3 (1., 0.8, 0.2) *\n             step (0.05, length (qHit.yz - vec2 (-0.02, 0.05)));\n          col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n             0.1 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n          dHit = dstObj;\n          dFade = 0.2;\n        } else {\n          ro += dstCage * rd;\n          vn = - normalize (ro - vuPos);\n          col = vec3 (0.35, 0.3, 0.3) * (0.6 + 0.4 * max (dot (vn, sunDir), 0.));\n          dHit = dstCage;\n          dFade = 0.2;\n        }\n      } else {\n        ro += dstBub * rd;\n        vn = BObjNf (ro);\n        col = mix ((0.5 - 0.5 * dot (rd, vn)) * vec3 (0.4, 0.6, 0.8),\n           BgCol (reflect (rd, vn)), 0.5) +\n           0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n        dHit = dstBub;\n        dFade = 0.05;\n      }\n    } else {\n      ro += rd * dHit;\n      vn = qnHit.yzx;\n      dEdge = EdgeDist (ro);\n      h = smoothstep (0., 0.1, HexFaceDist (ro));\n      col = HexVolCol (ro, dEdge, dHit) * (0.7 + 0.3 * h);\n      diff = clamp (dot (sunDir, vn), 0., 1.);\n      sh = (diff > 0. && HexVolRay (ro + 0.001 * vn, sunDir) < dstFar) ? 0.6 : 1.;\n      sh = min (sh, ObjSShadow (ro, sunDir));\n      col = col * (0.2 + 0.8 * sh * diff) + 0.2 * sh * step (0.1, diff) *\n         pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);        \n      dFade = 0.05;\n      col += 0.3 * TurbLt (0.8 * ro, abs (vn), 0.3 * tCur) *\n         smoothstep (-0.3, -0.1, vn.y);\n    }\n    col = mix (col, bgCol, smoothstep (dFade, 0.85, dHit / dstFar));\n  } else col = bgCol + WatShd (rd);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd, u, fpNear;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, vMov, vFish, tGap, t, a, d, f, aHlx, fHlx, fDist;\n  bool fishLook;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  fishLook = true;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.95 * pi * mPtr.y;\n    fishLook = false;\n  }\n  dstFar = 15.;\n  zmFac = 1.8;\n  vMov = 0.5;\n  aHlx = 0.45;\n  fHlx = 0.2 * vMov;\n  fpF = TrackPath (vMov * tCur + 0.5);\n  fpB = TrackPath (vMov * tCur - 0.5);\n  vuPos = 0.5 * (fpF + fpB);\n  vuPos.xy += 0.6 * aHlx * vec2 (cos (fHlx * tCur), sin (fHlx * tCur));\n  ro = vuPos;\n  if (! fishLook) {\n    vd = fpF - fpB;\n    t = length (vd);\n    if (t > 0.) vd = normalize (vd);\n    ori = vec2 (el + sin (vd.y), az + ((t > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n            mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  }\n  vFish = 1.;\n  tGap = 2. * dstFar / (float (N_FISH) * vFish);\n  fDist = dstFar;\n  for (int k = 0; k < N_FISH; k ++) {\n    t = tGap * ((float (k) + floor (ro.z / (tGap * vFish) + 0.5)) -\n       mod (tCur / tGap, 1.));\n    fpF = TrackPath (t * vFish + 0.2);\n    fpB = TrackPath (t * vFish - 0.2);\n    fishPos[k] = 0.5 * (fpF + fpB);\n    fishPos[k].xy -= aHlx * vec2 (cos (fHlx * t), sin (fHlx * t));\n    vd = fpF - fpB;\n    t = length (vd);\n    if (t > 0.) vd = normalize (vd);\n    fishAngH[k] = pi + ((t > 0.) ? atan (vd.x, vd.z) : 0.5 * pi);\n    fishAngV[k] = - sin (vd.y);\n    if (fishLook) {\n      d = length (fishPos[k] - ro);\n      if (d < fDist) {\n        fDist = d;\n        fpNear = fishPos[k];\n      }\n    }\n  }\n  if (fishLook) {\n    vd = normalize (fpNear - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  }\n  fishAngI = 0.15 * sin (pi * tCur);\n  uv += sin (2. * pi * (5. * uv + 0.5 * sin (0.4 * pi * tCur))) / canvas.y;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (cos (0.002 * pi * tCur), 2., sin (0.002 * pi * tCur)));\n  fragColor = vec4 (pow (clamp (ShowScene (ro, rd), 0., 1.), vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrSphAnDf (vec3 p, float r, float w)\n{\n  return abs (length (p) - r) - w;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (vec3 (p, p + 1., p + 2.)) *\n     vec3 (cHashM, cHashM * 0.43, cHashM * 0.37));\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) -\n     Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfRl.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MdlfRr", "name": "Mad Wave", "author": "metabog", "description": "Messing around trying to make a chaotic waveform. ", "tags": ["wave", "chaos", "scope", "mad"], "time_retrieved": "2024-05-15T23:14:24.091466", "image_code": "#define ITERMAX 18\n\nfloat solve(float x, float ex)\n{\n    float val = 0.0;\n    for(int i = 0; i<ITERMAX;i++)\n    {\n        val = cos(val*val*1.5)+x*sin(val+ex) + val*0.4;\n    }\n    \n    return clamp(abs(val),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float funcval = solve(uv.x+0.25,iTime);\n    \n    //float scope_intensity = 1.0 - clamp(abs(funcval-uv.y)*16.0,0.0,1.0f);\n    float scope_intensity = clamp((funcval-uv.y)*16.0,0.0,1.0);;\n    \n\tfragColor = vec4(vec3(1.0)*scope_intensity,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfRr.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlfRS", "name": "Filter Faux-Bode", "author": "notlion", "description": "Trying out some functions for a fake bode plot", "tags": ["fake", "filter", "plot", "bode"], "time_retrieved": "2024-05-15T23:14:24.127600", "image_code": "float br(float cut, float res, float t) {\n  return max(0.0, 0.5 - (1.0 - res) / (20.0 * abs(t - cut)));\n}\n\nfloat bp(float cut, float res, float t) {\n  float d = t - cut;\n  float r1 = pow(0.33 / res, 1.75);\n  d = 1.0 / (res * 30.0 * max(0.0, (abs(d) + r1 * 0.11) / res));\n  d = d * (1.6 + 0.2 * res);\n  return 0.2 + 0.8 * sin(r1 * d * 3.14159) * res;\n}\n\nfloat lp(float cut, float res, float t) {\n  float d = cut - t + 0.13;\n  float g = 0.5 - 1.0 / (30.0 * max(0.0, d));\n  d = 0.5 - 1.0 / (res * 30.0 * max(0.0, d / res));\n  d = clamp(d * (1.6 + 0.2 * res), 0.0, 1.0);\n  g += sin(d * 3.14159) * (1.0 - d) * res * 1.36;\n  return g;\n}\n\nfloat hp(float cut, float res, float t) {\n  float d = t - cut + 0.13;\n  float g = 0.5 - 1.0 / (30.0 * max(0.0, d));\n  d = 0.5 - 1.0 / (res * 30.0 * max(0.0, d / res));\n  d = clamp(d * (1.6 + 0.2 * res), 0.0, 1.0);\n  g += sin(d * 3.14159) * (1.0 - d) * res * 1.36;\n  return max(0.0, g);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  float t = iTime;\n  float cut = 0.5 * (1.0 + sin(t));\n  float res = 0.5 * (1.0 + cos(t * 2.3563));\n\n  vec2 p = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n  p.y *= -1.0;\n  float lpa = max(0.0, 0.5 * (p.x + p.y));\n  float hpa = max(0.0, -0.5 * (p.x + p.y));\n  float bpa = max(0.0, 0.5 * p.x - 0.5 * p.y);\n  float bra = max(0.0, 0.5 * p.y - 0.5 * p.x);\n\n  vec3 c = vec3(0.0);\n  c.r += float(uv.x < br(cut, res, uv.y)) * bra;\n  c.g += float(uv.x < bp(cut, res, uv.y)) * bpa;\n  c.b += float(uv.x < hp(cut, res, uv.y)) * hpa;\n  c += float(uv.x < lp(cut, res, uv.y)) * lpa * 0.33;\n\n  c += float(uv.x < max((br(cut, res, uv.y)) * bra,\n                        max((bp(cut, res, uv.y)) * bpa,\n                            max(hp(cut, res, uv.y) * hpa,\n                                (lp(cut, res, uv.y)) * lpa)))) *\n       0.33;\n\n  fragColor = vec4(c * 0.5, 1.0);\n\n  float handle = smoothstep(20.0, 18.0, distance(fragCoord.xy, iMouse.xy));\n  fragColor = mix(fragColor, vec4(1.0, 0.5, 0.0, 1.0), handle);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfRS.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlfWM", "name": "Fractal Furball Monster", "author": "soma_arc", "description": "WATCHING YOU.\nYou can move the camera with your mouse.\nFur shader is based on  \"furball\" by simesgreen.\nhttps://www.shadertoy.com/view/XsfGWN", "tags": ["3d", "fractal", "fur"], "time_retrieved": "2024-05-15T23:14:27.272188", "image_code": "// 2017 @soma_arc\n\nconst int OBJ_FUR = 0;\nconst float MARCH_THRESHOLD = 0.1;\nconst int MAX_KLEIN_ITARATION = 50;\nconst int TRACE_DEPTH = 6;\nconst float SAMPLE_NUM = 2.;\nfloat iTime2;\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n    return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst float GAMMA = 2.2;\nvec3 degamma(vec3 rgb) {\n    return vec3((min(pow(rgb.r, GAMMA), 1.)),\n                (min(pow(rgb.g, GAMMA), 1.)),\n                (min(pow(rgb.b, GAMMA), 1.)));\n}\n\n// Fur Rendering code is based on \"furball\" by simesgreen.\n// https://www.shadertoy.com/view/XsfGWN\nconst float uvScale = 1.0;\nconst float colorUvScale = 0.1;\nconst float furDepth = 0.4;\nconst int furLayers = 64;\nconst float rayStep = furDepth*2.0 / float(furLayers);\nconst float furThreshold = 0.4;\nconst float shininess = 90.0;\n\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec2 cartesianToSpherical(vec3 p, vec4 ball)\n{\t\n    vec3 ballPos = p - ball.xyz;\n    float r = length(ballPos);\n\n    float depth = furDepth * ball.w;\n\tfloat t = (r - (ball.w - depth)) / depth;\t\n\tballPos = rotateX(ballPos.zyx, -cos(iTime*1.5)*t*t*0.2).zyx;\t// curl\n\n\tballPos /= r;\t\n\tvec2 uv = vec2(atan(ballPos.y, ballPos.x), acos(ballPos.z));\n\n\tuv.y -= t*t*0.1;\t// curl down\n\treturn uv;\n}\n\nfloat furDensity(vec3 pos, vec4 ball, out vec2 uv)\n{\n\tuv = cartesianToSpherical(pos.xzy, ball.xzyw);\t\n\tvec4 tex = textureLod(iChannel0, uv*uvScale, 0.0);\n\n    float threshold = ball.w * furThreshold;\n\t// thin out hair\n\tfloat density = smoothstep(furThreshold, 1., tex.x);\n\t\n    float depth = ball.w * furDepth;\n\tfloat r = length(pos - ball.xyz);\n\tfloat t = (r - (ball.w - depth)) / depth;\n\t\n\t// fade out along length\n\tfloat len = tex.y;\n\tdensity *= smoothstep(len, len-0.2 , t);\n\n\treturn density;\t\n}\n\nvec3 furNormal(vec3 pos, vec4 ball, float density)\n{\n    float eps = 1.;\n    vec3 n;\n\tvec2 uv;\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), ball, uv ) - density;\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), ball, uv ) - density;\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), ball, uv ) - density;\n    return normalize(n);\n}\n\nvec3 furShade(vec3 pos, vec4 ball, vec2 uv, vec3 ro, float density, vec3 mColor){\n\tconst vec3 L = vec3(0, 1, 0);\n\tvec3 V = normalize(ro - pos);\n\tvec3 H = normalize(V + L);\n\n\tvec3 N = -furNormal(pos, ball, density);\n\n\tfloat diff = max(0.0, sqrt(1. - dot(N, L)* dot(N, L)));\n\tfloat spec = pow(max(0.0, sqrt(1. - dot(N, H) * dot(N, H)) ), shininess);\n\n\tvec3 color = degamma(textureLod(iChannel1, uv*colorUvScale, 0.0).xyz);\n\n    float depth = furDepth * ball.w;\n\tfloat r = length(pos - ball.xyz);\n\tfloat t = (r - (ball.w - depth)) / depth;\n\tt = clamp(t, 0.0, 1.0);\n\tfloat i = t*0.5+0.5;\n\t\t\n\treturn color*diff*i +vec3(0) * vec3(spec*i);\n}\n\n\n\nconst float schottkyRadius = 300.;\nvec4 schottky1 = vec4(300, 300, 0, schottkyRadius);\nvec4 schottky2 = vec4(300, -300, 0, schottkyRadius);\nvec4 schottky3 = vec4(-300, 300, 0, schottkyRadius);\nvec4 schottky4 = vec4(-300, -300, 0, schottkyRadius);\nvec4 schottky5 = vec4(0, 0, 424.26, schottkyRadius);\nvec4 schottky6 = vec4(0, 0, -424.26, schottkyRadius);\n\nvec3 sphereInvert(vec3 pos, vec4 sphere){\n\tvec3 diff = pos - sphere.xyz;\n    float d = length(diff);\n\treturn (diff * sphere.w * sphere.w)/(d * d) + sphere.xyz;\n}\n\nvec3 g_pos;\nfloat loopNum = 0.;\nvec4 baseSphere = vec4(0, 0, 0, 115);\nfloat g_baseRadius;\nfloat distKlein(vec3 pos){\n    float scalingFactor= 0.1;\n    loopNum = 0.;\n    float dr = 1.;\n    bool loopEnd = true;\n    for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n        loopEnd = true;\n        if(distance(pos, schottky1.xyz) < schottky1.w){\n            vec3 diff = (pos - schottky1.xyz);\n            dr *= (schottky1.w * schottky1.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky1);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky2.xyz) < schottky2.w){\n            vec3 diff = (pos- schottky2.xyz);\n            dr *= (schottky2.w * schottky2.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky2);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky3.xyz) < schottky3.w){\n            vec3 diff = (pos- schottky3.xyz);\n            dr *= (schottky3.w * schottky3.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky3);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky4.xyz) < schottky4.w){\n            vec3 diff = (pos- schottky4.xyz);\n            dr *= (schottky4.w * schottky4.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky4);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky5.xyz) < schottky5.w){\n            vec3 diff = (pos- schottky5.xyz);\n            dr *= (schottky5.w * schottky5.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky5);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky6.xyz) < schottky6.w){\n            vec3 diff = (pos- schottky6.xyz);\n            dr *= (schottky6.w * schottky6.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky6);\n            loopEnd = false;\n            loopNum++;\n        }\n        if(loopEnd == true) break;\n    }\n    g_pos = pos;\n  \tg_baseRadius = baseSphere.w / abs(dr);\n    return (length(pos) - baseSphere.w) / abs(dr) * scalingFactor;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n    float imagePlane = (height * .5) / tan(fov * .5);\n    vec3 v = normalize(target - eye);\n    vec3 xaxis = normalize(cross(v, up));\n    vec3 yaxis =  normalize(cross(v, xaxis));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n    return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat distFunc(vec3 p){\n    return distKlein(p);\n}\n\nconst vec2 d = vec2(0.01, 0.);\nvec3 getNormal(const vec3 p){\n    return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),\n                          distFunc(p + d.yxy) - distFunc(p - d.yxy),\n                          distFunc(p + d.yyx) - distFunc(p - d.yyx)));\n}\n\nconst int MAX_MARCHING_LOOP = 1000;\nint march(const vec3 origin, const  vec3 ray, const float threshold,\n           float t0, float t1,\n           out vec3 intersection){\n    vec3 rayPos = origin + t0 * ray;\n    float dist;\n    float rayLength = t0;\n    for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n        if(rayLength > t1) break;\n        dist = distFunc(rayPos);\n        rayLength += dist;\n        rayPos = origin + ray * rayLength ;\n        if(dist < threshold) {\n        \tintersection = rayPos;\n            return OBJ_FUR;\n        }\n    }\n    return -1;\n}\n\nbool intersectSphere(vec4 sphere, \n                     vec3 rayOrigin, vec3 rayDir,\n                     out float t0, out float t1){\n  \tvec3 v = rayOrigin - sphere.rgb;\n  \tfloat b = dot(rayDir, v);\n  \tfloat c = dot(v, v) - sphere.w * sphere.w;\n  \tfloat d = b * b - c;\n  \tif(d >= 0.){\n    \tfloat s = sqrt(d);\n    \tfloat tmin = -b - s;\n        float tmax = -b + s;\n            if(tmin < tmax) {\n            \tt0 = tmin;\n                t1 = tmax;\n            } else {\n            \tt0 = tmax;\n                t1 = tmin;\n            }\n      \t\treturn true;\n    \t\n  \t}\n  \treturn false;\n}\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 2. * PI;\nvec2 equirectangularCoord(const vec3 coordOnSphere){\n    vec3 dir = (coordOnSphere);\n    float l = atan(dir.z, dir.x);\n    if (l < 0.) l += TWO_PI;\n    return vec2(l, abs(acos(dir.y) -PI));\n}\n\nbool inEqui(vec2 a, vec2 b, float threshold){\n\treturn (distance(a, b) < threshold ||\n            distance(a , b + vec2(TWO_PI, 0)) < threshold||\n            distance(a , b - vec2(TWO_PI, 0)) < threshold);\n}\n\nvec3 calcColor(vec3 eye, vec3 ray){\n    vec3 originalEye = eye;\n    vec4 l = vec4(0);\n    float coeff = 1.;\n    float t0, t1;\n    bool intersect =  intersectSphere(vec4(0,0,0, 310.), eye, ray, t0, t1);\n    if(intersect == false) return l.rgb; \n\tif(t0 < 0.) t0 = 0.;\n    for(int rayDepth = 0 ; rayDepth < TRACE_DEPTH ; rayDepth++){\n\t\tvec3 intersection, normal;\n    \tint objId = march(eye, ray, MARCH_THRESHOLD, t0, t1, intersection);\n    \tif(objId != -1){\n\t\t\tnormal = getNormal(intersection);\n\n\t\t\tvec4 c = vec4(0.0);        \n        \tvec3 pos = intersection;\n        \n        \tfloat ballRadius = g_baseRadius;\n        \tvec4 ball = vec4(intersection - normal * ballRadius, ballRadius);\n        \tfloat depth = ballRadius * furDepth;\n        \tfloat rstep = depth*2.0 / float(furLayers);\n\n\t\t\t// render eye        \n            vec2 eqc = equirectangularCoord(normalize(intersection - ball.xyz));\n        \tvec2 v = equirectangularCoord(normalize(normalize(originalEye - ball.xyz)));\n        \tvec2 left = v - vec2(.23 , -0.1);\n        \tvec2 right = v + vec2(.23, 0.1);\n            if(inEqui(eqc, left, .1)){\n        \t    c = vec4(0, 0, 0, 1);\n                c.rgb *= c.a;\n\t\t\t\tl = l + c * (1.0 - l.a);\n            \tbreak;\n            }else if(inEqui(eqc, left, .2)){\n            \tc = vec4(1);\n                c.rgb *= c.a;\n\t\t\t\tl = l + c * (1.0 - l.a);\n                break;\n            }\n            if(inEqui(eqc, right, .1)){\n           \t\tc = vec4(0, 0, 0, 1);\n                c.rgb *= c.a;\n\t\t\t\tl = l + c * (1.0 - l.a);\n            \tbreak;\n            }else if(inEqui(eqc, right, .2)){\n            \tc = vec4(1);\n                c.rgb *= c.a;\n\t\t\tl = l + c * (1.0 - l.a);\n                break;\n            }\n            //dummy\n            vec3 matColor = vec3(0);\n            // render fur\n\t\t\tfor(int i=0; i<furLayers; i++) {\n\t\t\t\tvec4 sampleCol;\n\t\t\t\tvec2 uv;\n\t\t\t\tsampleCol.a = furDensity(pos, ball, uv);\n\t\t\t\tif (sampleCol.a > 0.0) {\n\t\t\t\t\tsampleCol.rgb = furShade(pos, ball, uv, eye, sampleCol.a, matColor);\n\n\t\t\t\t\tsampleCol.rgb *= sampleCol.a;\n\t\t\t\t\tc = c + sampleCol*(1.0 - c.a);\n\t\t\t\t\tif (c.a > 0.99) break;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tpos += ray*rstep;\n\t\t\t}\n        \tc = clamp(c, 0., 1.);            \n            \n        \tc.rgb *= c.a;\n\t\t\tl = l + c * (1.0 - l.a);\n        \tfloat tmin, tmax;\n        \tintersectSphere(ball, eye, ray, tmin, tmax);\n        \teye = eye + ray * (tmax + ball.w * 0.2);\n        \tt0 = 0.;\n    \t} else {\n        \tvec4 c = vec4(0, 0, 0, 1);\n        \tc.rgb *= c.a;\n\t\t\tl = l + c * (1.0 - l.a);\n    \t\tbreak;\n    \t}\n    \tif (l.a > 0.99) break;\n    }\n    return l.rgb;\n}\n\nvec3 eye = vec3(300 , 0., 550 );\nconst vec3 target = vec3(0, 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 sum = vec3(0);\n    float t = iTime * .5;\n    iTime2 = iTime;\n    float dist = 500. + -iMouse.x;\n    float height = 100. + iMouse.y;\n\n    eye = vec3(dist * cos(t) , height, \n               dist * sin(t) );\n\n    \n    float start = 0.;\n    float dur = 1.; \n\tschottky1.w = mix(0., schottkyRadius, expEasingIn(scene(t, start, dur)));\n   \tschottky5.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + .5, dur)));\n\tschottky2.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 2. * .5, dur)));\n\tschottky4.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 3. * .5, dur)));\n    schottky3.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 4. * .5, dur)));\n\tschottky6.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 5. * .5, dur)));\n\tdur = dur * 6.;\n    \n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(eye, ray);\n\t}\n\tvec3 col = (sum/SAMPLE_NUM);\n\n\tfragColor = vec4(gammaCorrect(col), 1.);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfWM.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Mdlfzf", "name": "Color conversion test", "author": "thykka", "description": "Mixing color in Lab space", "tags": ["color", "gradient"], "time_retrieved": "2024-05-15T23:14:27.345518", "image_code": "vec3 rgb2xyz (in vec3 rgb) {\n    float r = rgb.r;\n\tfloat g = rgb.g;\n\tfloat b = rgb.b;\n\n\tr = r > 0.04045 ? pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tfloat x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tfloat y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tfloat z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n    \n    vec3 xyz = vec3(\n        (r * 0.4124) + (g * 0.3576) + (b * 0.1805) * 100.0,\n        (r * 0.2126) + (g * 0.7152) + (b * 0.0722) * 100.0,\n        (r * 0.0193) + (g * 0.1192) + (b * 0.9505) * 100.0\n    );\n    return(xyz);\n}\n\nvec3 xyz2lab (in vec3 xyz) {\n\tfloat x = xyz.x / 95.047;\n\tfloat y = xyz.y / 100.0;\n\tfloat z = xyz.z / 108.883;\n\n\tx = x > 0.008856 ? pow(x, 1.0 / 3.0) : (7.787 * x) + (16.0 / 116.0);\n\ty = y > 0.008856 ? pow(y, 1.0 / 3.0) : (7.787 * y) + (16.0 / 116.0);\n\tz = z > 0.008856 ? pow(z, 1.0 / 3.0) : (7.787 * z) + (16.0 / 116.0);\n\n    vec3 lab = vec3((116.0 * y) - 16.0, 500.0 * (x - y), 200.0 * (y - z));\n    return(lab);\n}\n\nvec3 rgb2lab(in vec3 rgb) {\n    vec3 xyz = rgb2xyz(rgb);\n    vec3 lab = xyz2lab(xyz);\n    return(lab);\n}\n\nvec3 xyz2rgb (in vec3 xyz) {\n\tfloat x = xyz.x / 100.0;\n\tfloat y = xyz.y / 100.0;\n\tfloat z = xyz.z / 100.0;\n\t\n    \n\tfloat r = (x *  3.2406) + (y * -1.5372) + (z * -0.4986);\n\tfloat g = (x * -0.9689) + (y *  1.8758) + (z *  0.0415);\n\tfloat b = (x *  0.0557) + (y * -0.2040) + (z *  1.0570);\n\n\tr = r > 0.0031308 ? ((1.055 * pow(r, 1.0 / 2.4)) - 0.055) : r * 12.92;\n\tg = g > 0.0031308 ? ((1.055 * pow(g, 1.0 / 2.4)) - 0.055) : g * 12.92;\n\tb = b > 0.0031308 ? ((1.055 * pow(b, 1.0 / 2.4)) - 0.055) : b * 12.92;\n\n\tr = min(max(0.0, r), 1.0);\n\tg = min(max(0.0, g), 1.0);\n\tb = min(max(0.0, b), 1.0);\n\n\treturn(vec3(r, g, b));\n}\n\nvec3 lab2xyz (in vec3 lab) {\n    float l = lab.x;\n\tfloat a = lab.y;\n\tfloat b = lab.z;\n\n  \tfloat y = (l + 16.0) / 116.0;\n\tfloat x = a / 500.0 + y;\n\tfloat z = y - b / 200.0;\n\n\tfloat y2 = pow(y, 3.0);\n\tfloat x2 = pow(x, 3.0);\n\tfloat z2 = pow(z, 3.0);\n\n  \ty = y2 > 0.008856 ? y2 : (y - 16.0 / 116.0) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16.0 / 116.0) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16.0 / 116.0) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100.0;\n\tz *= 108.883;\n\n\treturn(vec3(x, y, z));\n}\nvec3 lab2rgb (in vec3 lab) {\n    vec3 xyz = lab2xyz(lab);\n    vec3 rgb = xyz2rgb(xyz);\n    return(rgb);\n}\n\nconst vec3 lab0 = vec3(  20.0, 100.0,  -50.0);\nconst vec3 lab1 = vec3( 100.0,  50.0,  -50.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 A; // First gradient point.\n    if(iMouse.z > 0.0) {\n        A = vec2(iMouse);\n    } else {\n        A = vec2(\n            (sin(iTime * 0.1) * 0.5 + .5) * iResolution.x,\n            (cos(iTime * 0.3) * 0.5 + .5) * iResolution.y\n        );\n    }\n    vec2 B = vec2(\n        (sin(-iTime * -0.2) * 0.5 + .50) * iResolution.x,\n        (-cos(iTime * -0.1) * 0.5 + .50) * iResolution.y\n    ); // Second gradient point.\n\n    vec2 V = B - A;\n    \n    float s = dot(fragCoord.xy-A, V) / dot(V, V); // Vector projection.\n    //s = clamp(s, 0.0, 1.0); // Saturate scaler.\n    \n    // color = pow(color, vec3(1.0/1.0)); // sRGB gamma encode.\n    fragColor = vec4(lab2rgb(vec3(\n        (sin(iTime / (s + 10.0) * 4.2) + 1.0) * 25.0 + 25.0,\n        sin(asin(fragCoord.x / iResolution.x * 1.0) * cos(iTime * 2.2)) * 100.0,\n        sin(acos(fragCoord.y / iResolution.y * 1.1) * 0.0-s * 6.283) * 100.0\n    )), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdlfzf.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "Mdlfzj", "name": "Sketch_TriLattice5", "author": "cexlearning", "description": "TriLattice5copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "time_retrieved": "2024-05-15T23:14:27.383804", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 uv2tri(vec2 uv)\n{\n    float sx = uv.x - uv.y / 2.0; // skewed x\n    float sxf = fract(sx);\n    float offs = step(fract(1.0 - uv.y), sxf);\n    return vec2(floor(sx) * 2.0 + sxf + offs, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.y * 8.0;\n    uv.y += iTime;\n\n    float t = iTime * 0.8;\n    float tc = floor(t);\n    float tp = smoothstep(0.0, 0.8, fract(t));\n\n    vec2 r1 = vec2(floor(uv.y), tc);\n    vec2 r2 = vec2(floor(uv.y), tc + 1.0);\n    float offs = mix(rand(r1), rand(r2), tp);\n\n    uv.x += offs * 8.0;\n\n    vec2 p = uv2tri(uv);\n    float ph = rand(floor(p)) * 6.3 + p.y * 0.2;\n    float c = abs(sin(ph + iTime));\n\n    fragColor = vec4(c, c, c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdlfzj.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlfzS", "name": "28/100", "author": "yahe", "description": "Play with Bezier curve", "tags": ["bezier"], "time_retrieved": "2024-05-15T23:14:28.527825", "image_code": "const float Pi = 3.1415926535;\n\nfloat Point(vec2 uv, vec2 P)\n{\n    return smoothstep(0.035, 0.005, distance(uv, P));   \n}\n\nfloat cbrt(float x)\n{\n    return sign(x) * pow(abs(x), 1.0/3.0);\n}\n\n// http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Solve cubic ax^3 + bx^2 + cx + d = 0 \n// Returns amount of roots\nint SolveCubic(vec4 coeffs, out vec3 roots)\n{\n    int nS = 0;  \n    // normal form: x^3 + Ax^2 + Bx + C = 0 \n    vec4 N = coeffs / coeffs[0];\n\n    // substitute x = y - A/3 \n    // depressed cubic: x^3 + px + q = 0 \n    float sqA = N[1]*N[1];\n    float p = (N[2] - sqA/3.0) / 3.0;\n    float q = ( (N[1] * sqA)/13.5 - (N[1] * N[2])/3.0 + N[3]) * 0.5;\n\n    // Use Cardano's formula \n    float cbP = p * p * p;\n    float D = q * q + cbP;\n\n    if (abs(D) < 1e-20)\n    {\n\t\tif (q == 0.0)  \n            nS = 1;\n\t\t   \n\t\telse // one single and one double solution\n\t\t{\n\t\t    float u = cbrt(-q);\n\t\t    roots[0] = 2.0 * u;\n\t\t    roots[1] = -u;\n\t\t    nS = 2;\n\t\t}\n    }\n    \n    else if (D < 0.0) // Casus irreducibilis: three real solutions\n    {\n\t\tfloat phi = acos(-q / sqrt(-cbP)) / 3.0;\n\t\tfloat t = 2.0 * sqrt(-p);\t\n\t\troots[0] = t * cos(phi);\n\t\troots[1] = -t * cos(phi + Pi/3.0);\n\t\troots[2] = -t * cos(phi - Pi/3.0);\n\t\tnS = 3;\n    }\n    \n    else // one real solution \n    {\n\t\tfloat sqrtD = sqrt(D);\n\t\troots[0] = cbrt(sqrtD - q) - cbrt(sqrtD + q);\n\t\tnS = 1;\n    }\n\n    roots -= N[1] / 3.0;\n    \n    return nS;\n}\n\nvec2 QuadraticBezier(float t, vec2 p0, vec2 p1, vec2 p2)\n{\n\treturn mix((mix(p0, p1, t)),(mix(p1, p2, t)), t);\n}\n\n// x is a point\n// {a, b, c} are the control points\nfloat DistanceQuadraticBezier(vec2 x, vec2 a, vec2 b, vec2 c)\n{\n    float aa = dot(a,a);\tfloat bc = dot(b,c);\tfloat cc = dot(c,c);\n    float ab = dot(a,b);\tfloat bb = dot(b,b);   \tfloat cx = dot(c,x);\n    float ac = dot(a,c);\tfloat bx = dot(b,x);\n    float ax = dot(a,x);\n           \n    // Cubic coefficients\n    float cu = 4.0*(aa + cc) + 16.0*(bb - ab - bc) + 8.0*ac;\n    // Quadratic coefficients\n\tfloat qu = 12.0*(bc - ac - aa) - 24.0*bb + 36.0*ab;\n    // Linear coefficients\n    float li = 4.0*(ac - ax - cx) + 8.0*(bx + bb) + 12.0*aa - 24.0*ab;\n    // Constant terms\n    float C = 4.0*(ab + ax - aa - bx);\n    vec3 roots;\n    vec4 coeffs = vec4(cu, qu, li, C);\n    \n    int nS = SolveCubic(coeffs, roots);  \n    float t;\n\n   \tfloat Dist1 = distance(x, QuadraticBezier(clamp(roots.x, 0.0, 1.0), a, b, c));\n    float Dist2 = distance(x, QuadraticBezier(clamp(roots.y, 0.0, 1.0), a, b, c));\n    float Dist3 = distance(x, QuadraticBezier(clamp(roots.z, 0.0, 1.0), a, b, c));\n    \n    return min(Dist3, min(Dist1, Dist2));\n}                 \n\nvec2 Mouse()\n{\n    vec2 a = 2.0 *(iMouse.xy / iResolution.xy) - 1.0;\n    a.x *= iResolution.x / iResolution.y;\n    return a;\n    \n}\n\nvec3 Curves(vec2 uv)\n{\n    float t = iTime * 7.0;\n    \n    float P = 0.0;\n    vec3 L = vec3(0.0);\n    \n    vec2 p0 = vec2(uv.x, -1.);\n    \n    for (float i = 0.0; i < 50.; i++) {\n    \n    vec2 p2 = vec2(1.5*sin(t*.5+i), 1.5*cos(t*.1+i)); \n    vec2 p4 = -p2;\n    vec2 p5 = vec2(-p2.y, p2.x);\n        \n        vec2 p = vec2(1.5*sin((t*0.04+i)), sin((t*.1+i) - 1.));\n    \tfloat d1 = smoothstep(0.02, 0.00, DistanceQuadraticBezier(uv, p0, p2, p));\n    \tfloat d2 = smoothstep(0.03, 0.00, DistanceQuadraticBezier(uv, p0, p4, p));\n    \tfloat d3 = smoothstep(0.05, 0.00, DistanceQuadraticBezier(uv, p0, p5, p));\n        \n    vec3 L1 = d1 * vec3(0.2 , 0.4, 0.4+ .5*sin(i));\n    vec3 L2 = d2 * vec3(0.3, 0.2, 0.4+ .2*cos(i));\n        \n        L += L1 + L2;\n    }\n    \n    return P + L;\n}   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = 2.0*p - 1.0;\n    q.x *= iResolution.x / iResolution.y;   \n    \n    vec3 col = vec3(0.15, 0.15, 0.19);\n    col = max(col, Curves(q));\n       \n    col = sqrt(col) * .7;\n    col = col * (1.0 - 0.2*dot(q,q));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfzS.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlGWM", "name": "Simplex Hills", "author": "nikat", "description": "Simple raymarching through simplex value noise terrain.", "tags": ["3d", "raymarching", "terrain", "simplexnoise", "valuenoise"], "time_retrieved": "2024-05-15T23:14:28.569177", "image_code": "/* Created by Nikita Miropolskiy, nikat/2013\n */\n\nfloat random(vec2 c) {\n\treturn fract(sin(dot(c, vec2(115., 363.)))*1024.0);\n}\n\nfloat simplexvalue2d(vec2 p) {\n\t\tp*=4.0;\n\t\tfloat h = sqrt(0.33333);\n\t\tfloat z = p.y*h;\n\t\tvec2 q = vec2(z+z, p.x - z);\n\t\tvec2 f = fract(q);\n\t \tvec2 i = floor(q);\n\t \tfloat d = f.x+f.y-1.0;\n\t\tfloat r;\n\t\t\n\t\tif (d > 0.0) {\n\t\t\tr =  random(i + vec2(-1.0, 1.0))*(1.0-f.x)\n\t\t\t       + random(i)*(1.0-f.y)\n\t\t\t       + random(i + vec2( 0.0, 1.0))*d;\n\t\t} else {\n\t\t\tr =  random(i)*f.x\n\t\t\t       + random(i + vec2(-1.0, 1.0))*f.y\n\t\t\t       - random(i + vec2(-1.0, 0.0))*d;\n\t\t}\n\t\t\n\t\t//r = sqrt(r);\n\t\t//r = (3.0 - 2.0*r)*r*r;\n\t\tr = (10.0 - r*(15.0 - 6.0*r))*r*r*r;\n\t\treturn  r;\n}\n\nfloat raymarche(vec3 origin, vec3 direction)\n{\n\tfloat delt = 0.01;\n    float mint = 0.001;\n    float maxt = 4.0;\n    for( float t = mint; t < maxt; t += delt )\n    {\n        vec3 p = origin + direction*t;\n        float h = 0.3*simplexvalue2d( p.xz );\n        if( p.y < h )\n        {\n            return 0.3+0.7*simplexvalue2d( p.xz );\n        }\n    }\n    return 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pix = 2.0*fragCoord.xy - iResolution.xy;\n\tvec2 p = pix/iResolution.x;\n\tvec2 q = pix/iResolution.xy;\n\t\n\tfloat time = iTime*0.3;\n\t\n\tvec3 org = vec3(0.0,1.,-time);\n\tvec3 dir = (vec3(p.x*1.6+sin(time),-1.0+p.y,-1.5));\n\t\n\tfloat f = raymarche(org,dir);\n\n\tvec3 c;\n\tc = vec3(f);\n\t\n\tfloat vignet = sqrt(sqrt((q.x*q.x-1.0)*(q.y*q.y-1.0)));\n\tc *= vignet;\n\t\n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlGWM.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlSRM", "name": "KIFS", "author": "EvilRyu", "description": "A menger spone..", "tags": ["3d", "raymarching", "fractal", "kifs"], "time_retrieved": "2024-05-15T23:14:28.611612", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Try KIFS...\n\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n void rx(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.y = c * q.y - s * q.z;  \n  \tp.z = s * q.y + c * q.z; \n }  \n\n void rz(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x - s * q.y;  \n  \tp.y = s * q.x + c * q.y; \n }  \nfloat plane(vec3 p, float y) {\n    return length(vec3(p.x, y, p.z) - p);\n}\n\n// folding hex from nimitz: https://www.shadertoy.com/view/XtdGDB\nvec2 fold(vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.5, 0.8657);\n    const vec2 pl2 = vec2(-0.8657, 0.4);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    return p;\n}\n\nvec3 mat=vec3(0.0);\nbool bcolor = false;\n\nfloat menger_spone(in vec3 z0){\n\tvec4 z=vec4(z0,1.0);\n    vec3 offset = vec3(0.785,1.1,0.46);\n    float scale = 2.46;\n\tfor (int n = 0; n < 4; n++) {\n\t\tz = abs(z);\n\t\tif (z.x<z.y)z.xy = z.yx;\n\t\tif (z.x<z.z)z.xz = z.zx;\n\t\tif (z.y<z.z)z.yz = z.zy;\n\t\tz = z*scale;\n\t\tz.xyz -= offset*(scale-1.0);\n       \tif(bcolor && n==2)\n            mat+=vec3(0.5)+sin(z.xyz)*vec3(1.0, 0.24, 0.245);\n\t\tif(z.z<-0.5*offset.z*(scale-1.0))\n            z.z+=offset.z*(scale-1.0);\n\t}\n\treturn (length(max(abs(z.xyz)-vec3(1.0),0.0))-0.05)/z.w;\n}\n\n vec3 f(vec3 p){ \n     ry(p,iTime*0.4);\n     float d1 = plane(p, -0.8);\n     p.xz = fold(p.xz);\n\n     float d2 = menger_spone(p);\n     if(d1 < d2)\n     {\n         return vec3(d1, 0.0, 0.0);\n     }\n     else\n     {\n         return vec3(d2, 1.0, 0.0);\n     } \n } \n\n float ao(vec3 p, vec3 n){ \n \tfloat ao=0.0,sca=1.0; \n \tfor(float i=0.0;i<20.0;++i){ \n \t\tfloat hr=0.05+0.015*i*i; \n \t\tao+=(hr-f(n*hr+p).x)*sca; \n \t\tsca*=0.75; \n \t} \n \treturn 1.0-clamp(ao,0.0,1.0); \n } \n\n\nfloat rand(vec2 t){\n\treturn fract(sin(dot(t*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n     float s=1.0,h=0.0; \n     float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001){s=0.0;break;} \n         s=min(s, k*h/t); \n         t+=abs(h);\n     } \n     return clamp(s*0.9+0.1, 0.0, 1.0); \n} \n vec3 nor(vec3 p){ \n \tvec3 e=vec3(0.0001,0.0,0.0); \n \treturn normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n \t\t\t\t\t\t  f(p+e.yxy).x-f(p-e.yxy).x, \n \t\t\t\t\t\t  f(p+e.yyx).x-f(p-e.yyx).x)); \n } \n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 res = vec3(-1.0);\n\tvec3 h = vec3(1.0);\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h.x<0.003 || t>30.0 ){\n\t\t}else {\n        \th = f(ro + rd*t);\n        \tres = vec3(t,h.yz);\n        \tt += abs(h.x);\n\t\t}\n    }\n\tif( t>30.0 ) res=vec3(-1.0);\n    return res;\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\n    vec3 ta = vec3(0,0.08,0.);\n    vec3 ro = vec3(1., 1.4, -3.);\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(3., 5.,-2.8)); \n    vec3 sun = vec3(1.64, 1.27, 0.99); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-1.0)*vec3(0.5, 0.9, 1.5);\n\n    float sc=clamp(dot(sundir, rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(sc,50.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           bcolor = true;\n           mat=vec3(0.0);\n           vec3 n=nor(p);\n           mat/=6.0;\n           bcolor = false;\n           float occ = ao(p, n); \n           float shadow = softshadow(p, sundir, 50.0);\n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 20.0)); \n\n           vec3 lin = 5.5 * sun * dif; \n           lin += 0.8 * bac * sun * occ; \n           lin += 0.6 * sky * skycolor * occ; \n           lin += 2.0 * spe * occ; \n\n           col = shadow * lin *(vec3(0.6, 0.8, 0.9)*(1.0-res.y)+mat*res.y) *  0.2; \n \t\t   col = mix(col,bg, 1.0-exp(-0.003*res.x*res.x)); \n    } \t\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -1.);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.8);  // vigneting\n \tfragColor.xyz = col; \n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlSRM.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlSWN", "name": "celestialBlob_01", "author": "entropynine", "description": "modification of \"Glass Eel\" by Kali", "tags": ["3dblob"], "time_retrieved": "2024-05-15T23:14:28.651771", "image_code": "//\"Glass Eel\" by Kali\n\n#define lightcol1 vec3(1.,.5,.5)\n#define lightcol2 vec3(.5,.5,1.)\n\n\n\n//Distance Field\nfloat de(vec3 p) {\n\tp+=sin(p*10.+iTime*10.)*.012;\n\tfloat rot=p.z-iTime*3.;\n\tp.x+=sin(p.z-iTime*3.)*1.1+p.z*.5;\n\tp.y+=cos(p.z*.5-iTime*2.)*.8-1.5+p.z*.4;\n\tp.z-=5.;\n\tp.xy*=mat2(cos(rot),cos(rot),-sin(rot),cos(rot));\n\tfloat sc=max(1.,pow(abs(p.z),5.)*.000002);\n\tp*=sc;\n\tfloat d=((length(p.xy)-.3)-length(cos(p*20.))*.03-length(cos(p*10.))*.05);\n\td=min(max(-p.z,d),length(p*vec3(1.,1.,1.4))-.47);\n\treturn d*.5/sc;\n}\n\n// finite difference normal\nvec3 normal(vec3 pos) {\n\tvec3 e = vec3(0.0,0.002,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(pos+e.yxx)-de(pos-e.yxx),\n\t\t\tde(pos+e.xyx)-de(pos-e.xyx),\n\t\t\tde(pos+e.xxy)-de(pos-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime*.6; \n\n\t//camera\n\tvec2 uv = fragCoord.xy / iResolution.xy *2. - vec2(1.);\n\tvec2 coord=uv;\n\tcoord.y *= iResolution.y / iResolution.x;\n\tcoord.xy*=mat2(cos(time),sin(time),-sin(time),cos(time));\n\tfloat fov=.5;\n\tvec3 from = vec3(-3.,-1.,sin(time)*4.-1.);\n\n\t//vars\n\tfloat totdist=0.;\n\tfloat distfade=1.;\n\tfloat glassfade=1.;\n\tfloat intens=1.;\n\tfloat maxdist=30.;\n\tfloat vol=0.;\n\tvec3 spec=vec3(0.);\n\tvec3 dir=normalize(vec3(coord.xy*fov,1.)); \n\tfloat ref=0.;\n\tvec3 light1=normalize(vec3(sin(time),sin(time*2.)*.5,1.5));\n\tvec3 light2=normalize(vec3(sin(time+2.),sin((time+2.)*2.)*.5,1.5));\n\n\t//march\n\tfor (int r=0; r<120; r++) {\n\t\tvec3 p=from+totdist*dir;\n\t\tfloat d=de(p);\n\t\tfloat distfade=exp(-5.*pow(totdist/maxdist,1.2));\n\t\tintens=min(distfade,glassfade);\n\n\t   if (totdist<maxdist) {\n\n\t\t// refraction\n\t\tif (d>0.0 && ref>.5) {\n\t\t\tref=0.;\n\t\t\tvec3 n=normal(p);\n\t\t\tif (dot(dir,n)<-0.5) dir=normalize(refract(dir,n,1./.85));\n\t\t\tvec3 refl=reflect(dir,-n);\n\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),40.);\n\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),40.);\n\t\t\tspec*=intens;\n\t\t\tspec*=glassfade;\n\t\t}\n\t\tif (d<0.0 && ref<.5) {\n\t\t\tref=1.;\n\t\t\tvec3 n=normal(p);\n\t\t\tif (dot(dir,n)<0.) dir=normalize(refract(dir,n,.85));\n\t\t\tvec3 refl=reflect(dir,n);\n\t\t\tglassfade*=.6;\n\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),50.);\n\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),50.);\n\t\t\tspec+=pow(max(dot(refl,vec3(0.,0.,-1.)),0.0),50.)*3.;\n\t\t\t\n\t\t}\n\t\t\n\t\ttotdist+=max(0.001,abs(d)); //advance ray \n\t   }\n\t\tvol+=max(0.,.6-d)*intens; //glow\n\t}\n\t\n\tvol*=.025;\n\tvec3 col=vec3(vol*vol,vol*.9,vol*vol*vol)+vec3(spec)*.5+.13;\n\n\t//lights\n\tvec3 tcoor=vec3((dir.xy*(2.-sin(time)*.8))+sin(coord.xy*20.+iTime*10.)*.007,1.);\n\tvec3 li=vec3(0.15);\n\tcol+=2.*lightcol1*pow(max(0.,max(0.,dot(normalize(tcoor+vec3(0.15,.1,0.)),light1))),500.)*glassfade; \n\tcol+=2.*lightcol2*pow(max(0.,max(0.,dot(normalize(tcoor+vec3(0.15,.1,0.)),light2))),500.)*glassfade; \n\tli+=lightcol1*pow(max(0.,max(0.,dot(normalize(tcoor),light1))),40.)*glassfade; \n\tli+=lightcol2*pow(max(0.,max(0.,dot(normalize(tcoor),light2))),40.)*glassfade; \n\t//background\n\tcol+=li*.3+li*5.*pow(texture(iChannel0,tcoor.xy*vec2(.5+(1.+cos(time))*.5,1.)+time).x,1.7)*glassfade*vec3(.3,1.,.3)*max(0.,1.-length(coord));\n\t\n\tcol*=1.-pow(max(0.,max(abs(uv.x),abs(uv.y))-.8)/.2,10.); //borders\n\n\t//color adjust\t\n\tcol=pow(col,vec3(1.2,1.1,1.));\n\tcol*=vec3(1.,.8,1.);\n\n\tcol*=min(1.,time); //fade in\n\tfragColor = vec4(col,1.0);\t\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlSWN.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlXDj", "name": "redpulse", "author": "dirkadirkadan", "description": "fun", "tags": ["heartbeat", "functionplot"], "time_retrieved": "2024-05-15T23:14:28.698546", "image_code": "", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXDj.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MdlXRB", "name": "Trivial 2D Lighting Bumpmapping", "author": "KrunoSaho", "description": "Procedurally generates a perturbed normal via partial derivatives using the dFdx, dFdy functions that take noise as input. My main goal was to trivialise lighting as much as possible for my game, as it is 2D, orthographic, and using a birds eye view.", "tags": ["procedural", "2d", "bumpmapping"], "time_retrieved": "2024-05-15T23:14:28.711785", "image_code": "", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXRB.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MdlXRj", "name": "AMERICA", "author": "TylerGlaiel", "description": "Happy 4th!", "tags": ["flag"], "time_retrieved": "2024-05-15T23:14:28.728475", "image_code": "#define antialias 8.0\n\n//official colors from http://en.wikipedia.org/wiki/Flag_of_the_United_States#Colors\n#define white 1.0, 1.0, 1.0\n#define red   .698, .132, .203\n#define blue  .234, .233, .430\n\n#define sky    0.086,  0.662, 0.788\n\nvec4 star(vec2 uv){\n\tuv -= vec2(.5, .5);\n\tuv *= .65;\n\tuv.x *= 2.0;\n\tvec2 polar = vec2(atan(uv.x, uv.y), length(uv));\n\tpolar.x /= 2.0*3.141592;\n\t\n\tpolar.x += .5;\n\t\n\tfloat triangle = polar.y*3.1415*2.0*(fract(polar.x*10.0)-.5) * -sign(fract(polar.x*5.0)-.5);\n\t\n\t//triangle = cos(polar.x*5.0*2.0*3.1415);\n\t\n\treturn polar.y > (triangle*.6+1.0)*.2 ? vec4(blue,1) : vec4(white,1);\n}\n\nvec2 warp(vec2 uv){\n\tuv.y += sin(-iTime*5.0 + uv.x*uv.x*10.0)*.2*uv.x - uv.x*.3;\n\tuv.x += uv.y*.05;\n\treturn uv;\n}\n\nvec4 fsample(vec2 coord){\n\tvec2 uv = coord / iResolution.xy;\n\tuv *= vec2(1.05, 1.2);\n\tuv -= vec2(0.05, 0.025);\n\t\n\tuv = warp(uv);\n\t\n\tvec4 color = vec4(white, 1);\n\t\n\tif(uv.x < .4 && uv.y > 6.0/13.0){\n\t\tcolor = vec4(blue, 1);\n\t\t\n\t\t//stars\n\t\tvec2 uv_star = (uv+vec2(0.0, 6.0/13.0)) / vec2(.4, 6.0/13.0);\n\t\t\n\t\t\n\t\tfloat indexxmax = 6.0;\n\t\tfloat indexxmin = 0.0;\n\t\t\n\t\tif(fract(uv_star.y*9.0*.5) < .5){\n\t\t\tuv_star.x += .5/6.0;\n\t\t\tindexxmin = 5.0;\n\t\t\tindexxmin = 1.0;\n\t\t}\n\t\t\n\t\tfloat indexy = floor(uv_star.y*9.0);\n\t\tfloat indexx = uv_star.x*6.0;\n\t\t\n\t\t\n\t\tuv_star.y -= floor(uv_star.y*9.0)/9.0;\n\t\tuv_star.y *= 9.0;\n\t\t\n\t\t\n\t\tuv_star.x -= floor(uv_star.x*6.0)/6.0;\n\t\tuv_star.x *= 6.0;\n\t\t\n\t\t\n\t\tif(indexx > indexxmin && indexx < indexxmax && indexy > 18.0 && indexy < 28.0){\n\t\t\tcolor = star(uv_star);\n\t\t}\n\t} else {\n\t\t//stripes\n\t\tif(fract(uv.y*6.5) < .5){\n\t\t\tcolor = vec4(red, 1);\n\t\t}\n\t\t\n\t}\n\t\n\tif(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0){\n\t\tcolor = vec4(sky,1);\n\t}\n\t\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t//do anti alias\n\tvec4 accum = vec4(0,0,0,0);\n\t\n\tfloat ct = 0.0;\n\n\tfor(float x = -.5+.5/antialias; x <= .5-.25/antialias; x += 1.0/antialias){\n\t\tfor(float y = -.5+.5/antialias; y <= .5-.25/antialias; y += 1.0/antialias){\n\t\t\tvec2 off = vec2(x, y);\n\t\t\taccum += fsample(fragCoord.xy + off);\n\t\t\tct += 1.0;\n\t\t}\n\t}\n\n\tfragColor = accum/ct;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXRj.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlXRS", "name": "Noise animation - Flow", "author": "nimitz", "description": "Playing with different ways of animating noise. In this version, the noise is made using a technique similar to \"flow noise\" (maybe it even qualifies as flow noise)", "tags": ["procedural", "2d", "noise"], "time_retrieved": "2024-05-15T23:14:29.526069", "image_code": "// Noise animation - Flow\n// 2014 by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/MdlXRS\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n\n//Somewhat inspired by the concepts behind \"flow noise\"\n//every octave of noise is modulated separately\n//with displacement using a rotated vector field\n\n//normalization is used to created \"swirls\"\n//usually not a good idea, depending on the type of noise\n//you are going for.\n\n//Sinus ridged fbm is used for better effect.\n\n#define time iTime*0.1\n#define tau 6.2831853\n\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat grid(vec2 p)\n{\n\tfloat s = sin(p.x)*cos(p.y);\n\treturn s;\n}\n\nfloat flow(in vec2 p)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i < 7.;i++ )\n\t{\n\t\tbp += time*1.5;\n\t\tvec2 gr = vec2(grid(p*3.-time*2.),grid(p*3.+4.-time*2.))*0.4;\n\t\tgr = normalize(gr)*0.4;\n\t\tgr *= makem2((p.x+p.y)*.3+time*10.);\n\t\tp += gr*0.5;\n\t\t\n\t\trz+= (sin(noise(p)*8.)*0.5+0.5) /z;\n\t\t\n\t\tp = mix(bp,p,.5);\n\t\tz *= 1.7;\n\t\tp *= 2.5;\n\t\tp*=m2;\n\t\tbp *= 2.5;\n\t\tbp*=m2;\n\t}\n\treturn rz;\t\n}\n\nfloat spiral(vec2 p,float scl) \n{\n\tfloat r = length(p);\n\tr = log(r);\n\tfloat a = atan(p.y, p.x);\n\treturn abs(mod(scl*(r-2./scl*a),tau)-1.)*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tp*= 3.;\n\tfloat rz = flow(p);\n\tp /= exp(mod(time*3.,2.1));\n\trz *= (6.-spiral(p,3.))*.9;\n\tvec3 col = vec3(.2,0.07,0.01)/rz;\n\tcol=pow(abs(col),vec3(1.01));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXRS.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlXWf", "name": "Dining room", "author": "squid", "description": "A dining room, just direct light with shadow + AO. Still a work in progress.Thanks to @movAX13h, @Dave_Hoskins, @eiffie", "tags": ["raymarch"], "time_retrieved": "2024-05-15T23:14:29.585759", "image_code": "", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXWf.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MdlXWr", "name": "Star Tunnel", "author": "P_Malin", "description": "Single pass starfield inspired by old school tunnel effects.\nI wanted to try to render a starfield without any loops or iteration. Each angular segment of space around the viewer generates a random star xy radius from the viewer and z repeat distance.", "tags": ["starfield"], "time_retrieved": "2024-05-15T23:14:31.161796", "image_code": "// Star Tunnel - @P_Malin\n// https://www.shadertoy.com/view/MdlXWr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Single pass starfield inspired by old school tunnel effects.\n// Each angular segment of space around the viewer selects a random star position radius and depth repeat rate.\n\n// Increase pass count for a denser effect\n#define PASS_COUNT 1\n\nfloat fBrightness = 2.5;\n\n// Number of angular segments\nfloat fSteps = 121.0;\n\nfloat fParticleSize = 0.015;\nfloat fParticleLength = 0.5 / 60.0;\n\n// Min and Max star position radius. Min must be present to prevent stars too near camera\nfloat fMinDist = 0.8;\nfloat fMaxDist = 5.0;\n\nfloat fRepeatMin = 1.0;\nfloat fRepeatMax = 2.0;\n\n// fog density\nfloat fDepthFade = 0.8;\n\nfloat Random(float x)\n{\n\treturn fract(sin(x * 123.456) * 23.4567 + sin(x * 345.678) * 45.6789 + sin(x * 456.789) * 56.789);\n}\n\nvec3 GetParticleColour( const in vec3 vParticlePos, const in float fParticleSize, const in vec3 vRayDir )\n{\t\t\n\tvec2 vNormDir = normalize(vRayDir.xy);\n\tfloat d1 = dot(vParticlePos.xy, vNormDir.xy) / length(vRayDir.xy);\n\tvec3 vClosest2d = vRayDir * d1;\n\t\n\tvec3 vClampedPos = vParticlePos;\n\t\n\tvClampedPos.z = clamp(vClosest2d.z, vParticlePos.z - fParticleLength, vParticlePos.z + fParticleLength);\n\t\n\tfloat d = dot(vClampedPos, vRayDir);\n\t\n\tvec3 vClosestPos = vRayDir * d;\n\t\n\tvec3 vDeltaPos = vClampedPos - vClosestPos;\t\n\t\t\n\tfloat fClosestDist = length(vDeltaPos) / fParticleSize;\n\t\n\tfloat fShade = \tclamp(1.0 - fClosestDist, 0.0, 1.0);\n\t\t\n\tfShade = fShade * exp2(-d * fDepthFade) * fBrightness;\n\t\n\treturn vec3(fShade);\n}\n\nvec3 GetParticlePos( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\n\tfloat fAngle = atan(vRayDir.x, vRayDir.y);\n\tfloat fAngleFraction = fract(fAngle / (3.14 * 2.0));\n\t\n\tfloat fSegment = floor(fAngleFraction * fSteps + fSeed) + 0.5 - fSeed;\n\tfloat fParticleAngle = fSegment / fSteps * (3.14 * 2.0);\n\n\tfloat fSegmentPos = fSegment / fSteps;\n\tfloat fRadius = fMinDist + Random(fSegmentPos + fSeed) * (fMaxDist - fMinDist);\n\t\n\tfloat tunnelZ = vRayDir.z / length(vRayDir.xy / fRadius);\n\t\n\ttunnelZ += fZPos;\n\t\n\tfloat fRepeat = fRepeatMin + Random(fSegmentPos + 0.1 + fSeed) * (fRepeatMax - fRepeatMin);\n\t\n\tfloat fParticleZ = (ceil(tunnelZ / fRepeat) - 0.5) * fRepeat - fZPos;\n\t\n\treturn vec3( sin(fParticleAngle) * fRadius, cos(fParticleAngle) * fRadius, fParticleZ );\n}\n\nvec3 Starfield( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\t\n\tvec3 vParticlePos = GetParticlePos(vRayDir, fZPos, fSeed);\n\t\n\treturn GetParticleColour(vParticlePos, fParticleSize, vRayDir);\t\n}\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vScreenUV = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 vScreenPos = vScreenUV * 2.0 - 1.0;\n\tvScreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec3 vRayDir = normalize(vec3(vScreenPos, 1.0));\n\n\tvec3 vEuler = vec3(0.5 + sin(iTime * 0.2) * 0.125, 0.5 + sin(iTime * 0.1) * 0.125, iTime * 0.1 + sin(iTime * 0.3) * 0.5);\n\t\t\t\n\tif(iMouse.z > 0.0)\n\t{\n\t\tvEuler.x = -((iMouse.y / iResolution.y) * 2.0 - 1.0);\n\t\tvEuler.y = -((iMouse.x / iResolution.x) * 2.0 - 1.0);\n\t\tvEuler.z = 0.0;\n\t}\n\t\t\n\tvRayDir = RotateX(vRayDir, vEuler.x);\n\tvRayDir = RotateY(vRayDir, vEuler.y);\n\tvRayDir = RotateZ(vRayDir, vEuler.z);\n\t\n\tfloat fShade = 0.0;\n\t\t\n\tfloat a = 0.2;\n\tfloat b = 10.0;\n\tfloat c = 1.0;\n\tfloat fZPos = 5.0 + iTime * c + sin(iTime * a) * b;\n\tfloat fSpeed = c + a * b * cos(a * iTime);\n\t\n\tfParticleLength = 0.25 * fSpeed / 60.0;\n\t\n\tfloat fSeed = 0.0;\n\t\n\tvec3 vResult = mix(vec3(0.005, 0.0, 0.01), vec3(0.01, 0.005, 0.0), vRayDir.y * 0.5 + 0.5);\n\t\n\tfor(int i=0; i<PASS_COUNT; i++)\n\t{\n\t\tvResult += Starfield(vRayDir, fZPos, fSeed);\n\t\tfSeed += 1.234;\n\t}\n\t\n\tfragColor = vec4(sqrt(vResult),1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, vec3 vRayOrigin, vec3 vRayDir )\n{\n/*\tvec2 vScreenUV = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 vScreenPos = vScreenUV * 2.0 - 1.0;\n\tvScreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec3 vRayDir = normalize(vec3(vScreenPos, 1.0));\n\n\tvec3 vEuler = vec3(0.5 + sin(iTime * 0.2) * 0.125, 0.5 + sin(iTime * 0.1) * 0.125, iTime * 0.1 + sin(iTime * 0.3) * 0.5);\n\t\t\t\n\tif(iMouse.z > 0.0)\n\t{\n\t\tvEuler.x = -((iMouse.y / iResolution.y) * 2.0 - 1.0);\n\t\tvEuler.y = -((iMouse.x / iResolution.x) * 2.0 - 1.0);\n\t\tvEuler.z = 0.0;\n\t}\n\t\t\n\tvRayDir = RotateX(vRayDir, vEuler.x);\n\tvRayDir = RotateY(vRayDir, vEuler.y);\n\tvRayDir = RotateZ(vRayDir, vEuler.z);\n*/\t\n\tfloat fShade = 0.0;\n\t\t\n\tfloat a = 0.2;\n\tfloat b = 10.0;\n\tfloat c = 1.0;\n\tfloat fZPos = 5.0 + iTime * c + sin(iTime * a) * b;\n\tfloat fSpeed = c + a * b * cos(a * iTime);\n\t\n\tfParticleLength = 0.25 * fSpeed / 60.0;\n\t\n\tfloat fSeed = 0.0;\n\t\n\tvec3 vResult = mix(vec3(0.005, 0.0, 0.01), vec3(0.01, 0.005, 0.0), vRayDir.y * 0.5 + 0.5);\n\t\n\tfor(int i=0; i<PASS_COUNT; i++)\n\t{\n\t\tvResult += Starfield(vRayDir, fZPos, fSeed);\n\t\tfSeed += 1.234;\n\t}\n\t\n\tfragColor = vec4(sqrt(vResult),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXWr.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MdlXzj", "name": "vilder_square", "author": "amaurel", "description": "vilder_square", "tags": ["square"], "time_retrieved": "2024-05-15T23:14:31.191785", "image_code": "", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXzj.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MdlXzM", "name": "Persian Carpet", "author": "gleurop", "description": "I really like the color quantization in this one.", "tags": ["procedural", "2d", "fractal"], "time_retrieved": "2024-05-15T23:14:31.206935", "image_code": "", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXzM.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MdlXzN", "name": "Toune Aile", "author": "Patapom", "description": "\"Bisou tunnel with bars\" a.k.a. \"what it feels like when you're a turd rushing to the sewers\"...", "tags": ["tunnel"], "time_retrieved": "2024-05-15T23:14:31.219484", "image_code": "", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXzN.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MdlXzS", "name": "Point within triangle or quad", "author": "Coldberg", "description": "Check if point within triangle or quad", "tags": ["2dpointtrianglequad"], "time_retrieved": "2024-05-15T23:14:31.232725", "image_code": "", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXzS.jpg", "access": "api", "wgpu-test": "error"}
{"id": "MdlyDB", "name": "Multi Material", "author": "aym0", "description": "multi material study\ninspired by https://github.com/petershirley/raytracinginoneweekend", "tags": ["raytracing"], "time_retrieved": "2024-05-15T23:14:33.811357", "image_code": "const float PI = 3.14159265358979323;\nvec2 vTexCoord;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat srand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat rand(float seed){\n    vec2 co = vec2(seed, seed + 100.0);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat srand(float seed){\n    vec2 co = vec2(seed, seed + 100.0);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\nvec3 getRandomVector(vec2 co){\n    \n    vec3 dir = vec3(srand(co + vec2(0.3, -0.3)), srand(co + vec2(-0.2, -0.1)), srand(co + vec2(-0.1, -0.4)));\n    float r = rand(co);\n\n    return r * normalize(dir);\n    \n}\n\nvec2 getRandomVector2(vec2 co) {\n    vec2 dir = vec2(srand(co + vec2(0.3, -0.3)), srand(co + vec2(-0.2, -0.1)));\n    float r = rand(co);\n    \n    return r * normalize(dir);\n}\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction looking at\n};\n\nstruct Sphere {\n    // geometry\n    float r; // radius\n    vec3 c;  // center\n    \n    // material\n    int mat; // 0: lambert, 1: metal\n    vec3 albedo; // for attenuation\n    float fuzz;  // for metal reflection\n    float ref_idx; // for dielectric refraction ratio\n};\n\nstruct Intersection {\n    bool hit;\n    vec3 p;\n    vec3 n;\n    vec3 color;\n    float t;\n    Sphere rec;\n};\n\nvoid scatterLambert(inout Ray R, in Intersection I){\n    R.o = I.p;\n    R.d = I.n + getRandomVector(vTexCoord + R.d.yx * 10.0);\n}\n\nvoid scatterMetal(inout Ray R, in Intersection I) {\n    R.o = I.p;\n    R.d = reflect(R.d, I.n) + I.rec.fuzz * getRandomVector(vTexCoord + R.d.yx * 10.0);;\n}\n\nfloat schlick(float cosine, float ref_idx) {\n    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\nvoid scatterDielectric(inout Ray R, in Intersection I) {\n    vec3 outward;\n    vec3 reflected = reflect(R.d, I.n);\n    float ni;\n    float cosine;\n    float reflect_prob;\n    \n    if (dot(R.d, I.n) > 0.0) {\n        outward = - I.n;\n        ni = I.rec.ref_idx;\n        cosine = dot(R.d, I.n) / length(R.d);\n        cosine = sqrt(1.0 - I.rec.ref_idx * I.rec.ref_idx * (1.0 - cosine * cosine));\n    } else {\n        outward = I.n;\n        ni = 1.0 / I.rec.ref_idx;\n        cosine = - dot(R.d, I.n) / length(R.d);\n    }\n    \n    vec3 refracted = refract(R.d, outward, ni);\n    \n    if (length(refracted) > 0.0) {\n        reflect_prob = schlick(cosine, I.rec.ref_idx);\n    } else {\n        reflect_prob = 1.0;\n    }\n    \n    R.o = I.p;\n    if (rand(vTexCoord + R.d.yx * 10.0) < reflect_prob) {\n        R.d = reflected;\n    } else {\n        R.d = refracted;\n    }\n}\n\nvoid initSphere(inout Sphere s, in float r, in vec3 c) {\n    s.r = r;\n    s.c = c;\n}\n\nvoid setMaterial(inout Sphere s, in int m, in vec3 col, in float f, in float ref) {\n    s.mat = m;\n    s.albedo = col;\n    s.fuzz = f;\n    s.ref_idx = ref;\n}\n\nvoid calcColor(inout Ray R, inout Intersection I) {\n    \n    I.color *= I.rec.albedo;\n    \n    if (I.rec.mat == 0) {\n        scatterLambert(R, I);\n    } else if (I.rec.mat == 1) {\n        scatterMetal(R, I);\n    } else if (I.rec.mat == 2) {\n        scatterDielectric(R, I);\n    }\n    \n}\n\nvoid intersectSphere(inout Ray R, in Sphere S, inout Intersection I){\n    \n    vec3 L = R.o - S.c;\n    \n    float a = dot(R.d, R.d);\n    float b = dot(L, R.d);\n    float c = dot(L, L) - S.r * S.r;\n    \n    float discriminant = b * b - a * c;\n    \n    if (discriminant > 0.0) {\n        float t = (- b - sqrt(discriminant))/a;\n        if (t > 0.001 && t < I.t) {\n            \n            I.p = R.o + t * R.d;\n            I.n = normalize(I.p - S.c);\n            \n            I.t = t;\n            I.hit = true;\n            I.rec = S;\n            \n            return;\n        }\n        t = (- b + sqrt(discriminant))/a;\n        if (t > 0.001 && t < I.t) {\n            \n            I.p = R.o + t * R.d;\n            I.n = normalize(I.p - S.c);\n            \n            I.t = t;\n            I.hit = true;\n            I.rec = S;\n            \n            return;\n        }\n    }\n}\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookAt;\n    vec3 vUp;\n    float fov;\n    float aspect;\n    float aparture;\n    float focus_dist;\n    \n    vec3 lower_left_corner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n    float lens_radius;\n};\n\nvoid initCamera(inout Camera C){\n    C.lens_radius = C.aparture * 0.5;\n    float theta = C.fov * PI / 180.0;\n    float half_height = tan(theta * 0.5);\n    float half_width = C.aspect * half_height;\n    \n    C.w = normalize(C.pos - C.lookAt);\n    C.u = normalize(cross(C.vUp, C.w));\n    C.v = cross(C.w, C.u);\n    \n    C.lower_left_corner = C.pos - half_width * C.focus_dist * C.u - half_height * C.focus_dist * C.v - C.focus_dist * C.w;\n    C.horizontal = 2.0 * half_width * C.focus_dist * C.u;\n    C.vertical = 2.0 * half_height * C.focus_dist * C.v;\n    \n}\n\nvoid createRay(inout Ray R, in Camera C, in float s, in float t) {\n    vec2 rd = C.lens_radius * getRandomVector2(vTexCoord * vec2(s, t));\n    vec3 offset = C.u * rd.x + C.v * rd.y;\n    \n    R.o = C.pos + offset;\n    R.d = C.lower_left_corner + s * C.horizontal + t * C.vertical - R.o;\n    \n}\n\nSphere earth;\nSphere slist[8];\n\nbool hitCheck(inout Ray R, inout Intersection I) {\n    I.hit = false;\n    I.p = vec3(0.0);\n    I.n = vec3(0.0);\n    I.t = 1.0e+30;\n    \n    intersectSphere(R, earth, I);\n    \n    for (int i = 0; i < 8; i++) {\n        intersectSphere(R, slist[i], I);\n    }\n    \n    return I.hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvTexCoord = fragCoord.xy;\n    \n    initSphere(earth, 100.0, vec3(0.0, - 102.0, 0.0));\n    setMaterial(earth, 1, vec3(0.6, 0.6, 0.6), 0.1, 0.0);\n    \n    float st = 2.0 * PI / 8.0;\n    float t = iTime;\n    \n    for (int i = 0; i < 8; i++) {\n        \n        \n        if (mod(float(i), 4.0) == 1.0) {\n            \n            initSphere(slist[i],\n                       0.4,\n                       vec3(cos(t) * sin(3.0 * t + st * float(i)),\n                            sin(t) * cos(4.0 * t + st * float(i)),\n                            cos(t + st *float(i))) * 2.0\n                       );\n            \n            setMaterial(slist[i], 0, vec3(0.2, 0.9, 1.0), 0.0, 0.0);\n            \n        } else if (mod(float(i), 4.0) == 3.0) {\n            \n            initSphere(slist[i],\n                       0.4,\n                       vec3(cos(t) * sin(3.0 * t + st * float(i)),\n                            sin(t) * cos(4.0 * t + st * float(i)),\n                            cos(t + st * float(i))) * 2.0\n                       );\n            \n            setMaterial(slist[i], 0, vec3(1.0, 0.3, 0.3), 0.0, 0.0);\n            \n        } else {\n            \n            initSphere(slist[i],\n                       0.2 * (sin(t) + 1.0) + 0.3,\n                       vec3(cos(t) * sin(4.0 * t + st * float(i)),\n                            sin(t) * cos(4.0 * t + st *float(i)),\n                            cos(t + st * float(i))) * 2.0\n                       );\n            \n            setMaterial(slist[i], 2, vec3(1.0), 0.0, 1.5);\n            \n            \n        }\n        \n        \n    }\n    \n    float size = 2.0 / min(iResolution.x, iResolution.y);\n    \n    float r = 4.0 + 3.5 * sin(t * 0.8);\n    \n    Camera cam;\n    cam.pos = vec3(r * sin(t), 0.5 * cos(t * 0.5) + 0.5, r * cos(t));\n    cam.lookAt = vec3(0.0, 0.0, 0.0);\n    cam.vUp = vec3(0.0, 1.0, 0.0);\n    cam.fov = 60.0;\n    cam.aspect = 4.0/3.0;\n    cam.focus_dist = 4.0;\n    cam.aparture = 0.05;\n    \n    initCamera(cam);\n    \n    Ray ray;\n    Intersection inter;\n    \n    vec3 destColor = vec3(0.0);\n    \n    float rs = 1.1;\n    \n    for (int i = 0; i < 5; i++) {\n        inter.color = vec3(1.0);\n        \n        createRay(ray, cam, p.x + size * srand(rs*t + 0.5), p.y + size * srand(rs*t));\n        \n        rs *= 1.2;\n        \n        if (hitCheck(ray, inter)) {\n            \n            int counter = 0;\n            \n            for (int i = 0; i < 10; i++) {\n                if (hitCheck(ray, inter)) {\n                    calcColor(ray, inter);\n                } else {\n                \tbreak;\n                }\n            }\n            \n        }\n    \n        destColor += inter.color;\n        \n    }\n    \n    destColor /= 5.0;\n    \n    fragColor = vec4(sqrt(destColor.r), sqrt(destColor.g), sqrt(destColor.b), 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlyDB.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlyDn", "name": "Koleidoskopic Distance", "author": "gPlatl", "description": "Show 2d koleidoskopic projection distance.    mouse.x -> changes leave count", "tags": ["2d", "distance", "koleidoskop"], "time_retrieved": "2024-05-15T23:14:33.956106", "image_code": "//----------------------------------------------------------\n// KoleidoskopicDistance.glsl\n// Show 2d koleidoskopic projection distance.    \n// mouse.x -> changes leave count\n// Based on:   \n//  Flower-DF:         https://www.shadertoy.com/view/MldXRN\n//  Ellipse-Distance:  https://www.shadertoy.com/view/4sS3zz\n//----------------------------------------------------------\n\nconst float TWO_PI  = 6.28318530718;\n\n//----------------------------------------------------------\nfloat sdKoleidoskopic(vec2 pos, int N) // calculate distance\n{\n    float st = sin(iTime*0.4);\n\tfloat ka = atan(pos.x, pos.y) / TWO_PI * float(N);\n    return length(pos) - mix(0.6, 0.5+st,abs(fract(ka)-.5));\n}\n//----------------------------------------------------------\nvec3 distanceColors (in float d)         // d=distance \n{\n  vec3 color = vec3(0.1, 0.4, 0.7);      // inner color\n  color = vec3(1.0) - sign(d)*color;     // + outer color\n  color *= 1.0 - exp(-2.0*abs(d));       // distance darken\n  color *= 0.8 + 0.2*cos(120.0*abs(d));  // distance lines \n  color = mix(color, vec3(1.0), 1.-smoothstep(0.0,0.02,abs(d)));  //white frame\n  return color;  \n}\n//----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord*2.0 -iResolution.xy) / iResolution.y;\n    \n    int leaves = 10 - int (10.*iMouse.x / iResolution);\n    \n    float d = sdKoleidoskopic (uv, leaves);    \n\n    fragColor = vec4(distanceColors(d),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlyDn.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlyDs", "name": "Volumetric Stanford Bunny", "author": "SebH", "description": "Volumetric 32x32x32 Stanford Bunny with volumetric lighting, shadow and noise.\nThe shader does not compile on some platform for some reason. Set \"VOLUME_FILTERING_NEAREST 1\" can fix that issue (Thanks Fabrice for the investigation).", "tags": ["voxel", "volumetricscattering", "stanfordbunny"], "time_retrieved": "2024-05-15T23:14:36.685713", "image_code": "// By SebH \n// https://twitter.com/SebHillaire\n// Use mouse left to rotate camera (X axis) and change noise strength (Y axis)\n//\n// Warning: \n// Does not compile on all platforms/driver due to the packedBunny array which is\n// a ugly hacky way to get volume asset texture in shader toy. \n// A right way to do that would be to have loadable textures from weblinks.\n// Set \"VOLUME_FILTERING_NEAREST 1\" can fix that issue.\n//\n\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define uint2 uvec2\n#define uint3 uvec3\n#define uint4 uvec4\n\n////////// Parameters\n\n// Participating media properties. have fun tweaking those :)\nfloat3 scattering = 25.0*float3(0.25,0.5,1.0);\nfloat3 absorption = 0.0 * float3(0.75,0.5,0.0);\n\n// Default noise erosion strength\nfloat erosionStrength = 1.0;\n\n////////// Options\n\n#define VOLUME_FILTERING_NEAREST 0\n\n#define FBM_NOISE 1\n\n#define BASIC_ANIMATED_NOISE 1\n\n//0, 1 or 2\n#define BASIC_ANIMATED_MEDIA 0\n\n\n\n//////////////////////////////////////////////////\n// Bunny volume data\n//////////////////////////////////////////////////\n\n// Packed 32^3 bunny data as 32x32 uint where each bit represents density per voxel\n#define BUNNY_VOLUME_SIZE 32\nconst uint packedBunny[1024] = uint[1024](0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,917504u,917504u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1966080u,12531712u,16742400u,16742400u,16723968u,16711680u,8323072u,4128768u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,6144u,2063360u,16776704u,33553920u,33553920u,33553920u,33553920u,33520640u,16711680u,8323072u,8323072u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,268435456u,402653184u,134217728u,201326592u,67108864u,0u,0u,7168u,2031104u,16776960u,33554176u,33554176u,33554304u,33554176u,33554176u,33554176u,33553920u,16744448u,8323072u,4128768u,1572864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,939524096u,402653184u,478150656u,260046848u,260046848u,260046848u,125832192u,130055680u,67108608u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554176u,16776704u,8355840u,4128768u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,1056964608u,1056964608u,528482304u,528482304u,260046848u,260046848u,260046848u,130039296u,130154240u,67108739u,67108807u,33554375u,33554375u,33554370u,33554368u,33554368u,33554304u,33554304u,16776960u,8330240u,4128768u,393216u,0u,0u,0u,0u,0u,0u,0u,0u,939524096u,1040187392u,1040187392u,520093696u,251658240u,251658240u,260046848u,125829120u,125829120u,130088704u,63045504u,33554375u,33554375u,33554375u,33554407u,33554407u,33554370u,33554370u,33554374u,33554310u,16776966u,4144642u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,15360u,130816u,262017u,4194247u,33554383u,67108847u,33554415u,33554407u,33554407u,33554375u,33554375u,33554318u,2031502u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,262019u,2097151u,134217727u,134217727u,67108863u,33554415u,33554407u,33554415u,33554383u,2097102u,982926u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,524263u,117964799u,127926271u,134217727u,67108863u,16777215u,4194303u,4194303u,2097151u,1048574u,65422u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,31751u,130951u,524287u,252182527u,261095423u,261095423u,59768830u,2097150u,1048574u,1048575u,262143u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,7u,31751u,130959u,503840767u,520617982u,529530879u,261095423u,1048575u,1048574u,1048574u,524286u,524287u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,1799u,32527u,134348750u,1040449534u,1057488894u,520617982u,51380223u,1048575u,1048575u,524287u,524287u,524287u,131070u,65534u,15886u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1536u,3968u,8175u,65535u,1006764030u,1040449534u,1057488894u,50855934u,524286u,524286u,524287u,524287u,524286u,262142u,131070u,65534u,32270u,14u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8160u,8191u,805371903u,2080505854u,2114191358u,101187582u,34078718u,524286u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,32766u,8078u,3590u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8176u,16383u,2013331455u,2080505854u,235143166u,101187582u,524286u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,131070u,32766u,16382u,8070u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8160u,8184u,1879064574u,2013331455u,470024190u,67371006u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,65534u,16382u,8160u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8184u,805322750u,402718719u,134479870u,524286u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8184u,16382u,131071u,262142u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1792u,8184u,16380u,65535u,262143u,524286u,524286u,1048574u,1048574u,1048575u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16376u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8176u,16376u,32767u,262143u,524286u,1048574u,1048574u,1048575u,1048575u,1048575u,1048575u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4032u,8184u,32766u,262142u,524286u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,384u,8184u,32766u,131070u,262142u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,131070u,32766u,16368u,1920u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4080u,32764u,65534u,262142u,524286u,524286u,524286u,1048574u,1048574u,524286u,524286u,524286u,262142u,131070u,32764u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,256u,16376u,32760u,131068u,262140u,262142u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,65532u,16368u,3840u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,32752u,65528u,131068u,262142u,262142u,262142u,262142u,262142u,262142u,262140u,131064u,32752u,7936u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8064u,32736u,65528u,131070u,131070u,131070u,131070u,131070u,131070u,65532u,32752u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3456u,16376u,32764u,65534u,65534u,65534u,32766u,32764u,16380u,4048u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,48u,2680u,8188u,8188u,8188u,8188u,4092u,120u,16u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,120u,248u,508u,508u,508u,248u,240u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,96u,240u,504u,504u,504u,240u,96u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,224u,224u,224u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u);\n\n\nfloat sampleBunny(float3 uvs)\n{\n    float3 voxelUvs = max(float3(0.0),min(uvs*float3(BUNNY_VOLUME_SIZE), float3(BUNNY_VOLUME_SIZE)-1.0));\n    uint3 intCoord = uint3(voxelUvs);\n    uint arrayCoord = intCoord.x + intCoord.z*uint(BUNNY_VOLUME_SIZE);\n\t\n    // Very simple clamp to edge. It would be better to do it for each texture sample\n    // before the filtering but that would be more expenssive...\n    // Also adding small offset to catch cube intersection floating point error\n    if(uvs.x<-0.001 || uvs.y<-0.001 || uvs.z<-0.001 ||\n      uvs.x>1.001 || uvs.y>1.001 || uvs.z>1.001)\n    \treturn 0.0;\n   \n    // 1 to use nearest instead\n#if VOLUME_FILTERING_NEAREST\n    // sample the uint representing a packed volume data of 32 voxel (1 or 0)\n    uint bunnyDepthData = packedBunny[arrayCoord];\n    float voxel = (bunnyDepthData & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n#else\n    uint3 intCoord2 = min(intCoord+uint3(1), uint3(BUNNY_VOLUME_SIZE-1));\n    \n    uint arrayCoord00 = intCoord.x  + intCoord.z *uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord01 = intCoord.x  + intCoord2.z*uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord10 = intCoord2.x + intCoord.z *uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord11 = intCoord2.x + intCoord2.z*uint(BUNNY_VOLUME_SIZE);\n    \n    uint bunnyDepthData00 = packedBunny[arrayCoord00];\n    uint bunnyDepthData01 = packedBunny[arrayCoord01];\n    uint bunnyDepthData10 = packedBunny[arrayCoord10];\n    uint bunnyDepthData11 = packedBunny[arrayCoord11];\n        \n    float voxel000 = (bunnyDepthData00 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel001 = (bunnyDepthData01 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel010 = (bunnyDepthData10 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel011 = (bunnyDepthData11 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel100 = (bunnyDepthData00 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel101 = (bunnyDepthData01 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel110 = (bunnyDepthData10 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel111 = (bunnyDepthData11 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    \n    float3 d = voxelUvs - float3(intCoord);\n    \n    voxel000 = mix(voxel000,voxel100, d.y);\n    voxel001 = mix(voxel001,voxel101, d.y);\n    voxel010 = mix(voxel010,voxel110, d.y);\n    voxel011 = mix(voxel011,voxel111, d.y);\n    \n    voxel000 = mix(voxel000,voxel010, d.x);\n    voxel001 = mix(voxel001,voxel011, d.x);\n    \n    float voxel = mix(voxel000,voxel001, d.z);\n#endif\n    \n    return voxel;\n}\n\n//////////////////////////////////////////////////\n// Volume noise from somewhere...\n//////////////////////////////////////////////////\n\nfloat rand(vec3 co)\n{\n    return -1.0 + fract(sin(dot(co.xy,vec2(12.9898 + co.z,78.233))) * 43758.5453) * 2.0;\n}\n\nfloat linearRand(vec3 uv)\n{\n\tvec3 iuv = floor(uv);\n\tvec3 fuv = fract(uv);\n\t\n\tfloat v1 = rand(iuv + vec3(0,0,0));\n\tfloat v2 = rand(iuv + vec3(1,0,0));\n\tfloat v3 = rand(iuv + vec3(0,1,0));\n\tfloat v4 = rand(iuv + vec3(1,1,0));\n\t\n\tfloat d1 = rand(iuv + vec3(0,0,1));\n\tfloat d2 = rand(iuv + vec3(1,0,1));\n\tfloat d3 = rand(iuv + vec3(0,1,1));\n\tfloat d4 = rand(iuv + vec3(1,1,1));\n\t\n\treturn mix(mix(mix(v1,v2,fuv.x),mix(v3,v4,fuv.x),fuv.y),\n\t\t       mix(mix(d1,d2,fuv.x),mix(d3,d4,fuv.x),fuv.y),\n\t\t\t   fuv.z);\n}\n\nfloat linearRandFBM(vec3 uv)\n{\n\tfloat c = (linearRand(uv * 1.0) * 32.0 +\n\t\t\t   linearRand(uv * 2.0) * 16.0 + \n\t\t\t   linearRand(uv * 4.0) * 8.0 + \n\t\t\t   linearRand(uv * 8.0) * 4.0) / 32.0;\n\treturn c * 0.5 + 0.5;\n}\n\n\n//////////////////////////////////////////////////\n// Cube intersection\n//////////////////////////////////////////////////\n\nfloat3 worldPosTocubePos(float3 worldPos)\n{\n    // cube of world space size 4 with bottom face on the ground y=0\n    return worldPos*0.15 + float3(0.0,-0.5,0.0);\n}\n\n// From https://www.shadertoy.com/view/4s23DR\nbool cube(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0/dir;\n\tvec3 tbot = invR * (-0.5 - org);\n\tvec3 ttop = invR * (0.5 - org);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tnear = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfar = min(t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0;\n}\n\n\n//////////////////////////////////////////////////\n// Main\n//////////////////////////////////////////////////\n\nfloat3 L = 4.0 * float3(1.0,1.0,1.0);// incoming luminance from light (ignoring its shape, etc.)\nfloat3 Lpos = float3(1.0,1.0,1.0);\t// in volumetric cube space\n\n#define extinction  (absorption + scattering)\n\n// all volumetric computation are done once position has been transform into unit cube space\n\n// Get density for a position\nfloat getDensity(float3 cubePos)\n{\n    float density = sampleBunny(cubePos);\n    if(density==0.0) return 0.0;\t// makes things a tad bit faster\n#if FBM_NOISE\n    float3 noiseUV = cubePos*12.0;\n\t#if BASIC_ANIMATED_NOISE\n    noiseUV += iTime * float3(1.0,0.0,0.0);\n\t#endif\n    density = density * max(0.0, 1.25*erosionStrength*linearRandFBM(noiseUV)*4.0-2.0); // more complex FBM noise\n#else\n    float3 noiseUV = cubePos*16.0;\n\t#if BASIC_ANIMATED_NOISE\n    noiseUV += iTime * float3(1.0,0.0,0.0);\n\t#endif\n    density = density * max(0.0, 0.5 + 0.5*erosionStrength*linearRand(noiseUV));\n#endif\n    return density;\n}\n\n// Get transmittance from a direction and distance onto a point (volume shadows)\nfloat3 getShadowTransmittance(float3 cubePos, float sampledDistance, float stepSizeShadow)\n{\n    float3 shadow = float3(1.0);\n    float3 Ldir = normalize(Lpos-cubePos);\n    for(float tshadow=0.0; tshadow<sampledDistance; tshadow+=stepSizeShadow)\n    {\n        float3 cubeShadowPos = cubePos + tshadow*Ldir;\n        float densityShadow = getDensity(cubeShadowPos);\n        shadow *= exp(-densityShadow * extinction * stepSizeShadow);\n    }\n    return shadow;\n}\n\n// Returns the light distance attenuation\nfloat distanceAttenuation(float distance)\n{\n    float lightMaxRadius = 3.0;\n    float linAtt = clamp((lightMaxRadius-distance)/lightMaxRadius,0.0,1.0);\n    linAtt*=linAtt;\t// some \"fake artistic\" attenuation\n    return linAtt/(distance*distance);\n}\n\nvoid mainImage( out float4 fragColor, in float2 fragCoord )\n{    \n\tfloat2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = float4(uv,0.5+0.5*sin(iTime),1.0);\n    float time = iTime;\n    \n\tvec2 mouseControl = iMouse.xy / iResolution.xy;\n    erosionStrength = iMouse.z>0.0 ? mouseControl.y * 4.0 : erosionStrength;\n    \n#if BASIC_ANIMATED_MEDIA==1\n    float r = floor(time);\n    scattering = abs(25.0* float3(rand(float3(r,0.0,1.0)),rand(float3(r,0.0,5.0)),rand(float3(r,0.0,9.0))));\n    absorption = abs(5.0* float3(rand(float3(r,1.0,2.0)),rand(float3(r,1.0,7.0)),rand(float3(r,1.0,7.0))));\n#elif BASIC_ANIMATED_MEDIA==2\n    float r = time*0.2;\n    scattering = abs(25.0* float3(sin(r*1.1),sin(r*3.3),sin(r*5.5)));\n    absorption = abs( 5.0* float3(sin(r*2.2),sin(r*4.4),sin(r*6.6)));\n\n#endif\n    \n    // View diretion in camera space\n    float3 viewDir = normalize(float3((fragCoord.xy - iResolution.xy*0.5) / iResolution.y, 1.0));\n    viewDir*= float3(0.9,1.0,1.0);\n    \n    Lpos = float3(0.85*cos(time*0.55),1.5, 0.85*sin(time*1.0));\n    \n    // Compute camera properties\n    float  camDist = 10.0;\n    float3 camUp = float3(0,1,0);\n    float3 camPos = float3(camDist*cos(time*0.51),8.0, camDist*sin(time*0.51));\n    camPos = iMouse.z<=0.0 ? camPos : float3(camDist*cos(mouseControl.x*10.0),8.0, camDist*sin(mouseControl.x*10.0));\n    float3 camTarget = float3(0,3.0,0);\n    \n    // And from them evaluted ray direction in world space\n    float3 forward = normalize(camTarget - camPos);\n    float3 left = normalize(cross(forward, camUp));\n    float3 up = cross(left, forward);\n    float3 worldDir = viewDir.x*left + viewDir.y*up + viewDir.z*forward;\n    \n    //////////////////////////////////////////////////////////////////////////////////////////\n    //// Render the flat ground with lighting and volumetric shadows\n    float3 color= float3(0.0, 0.0, 0.0);\n    float3 groundIntersection = camPos + worldDir * abs(camPos.y/worldDir.y);\n    float2 groundUv = groundIntersection.xz*0.1;\n    float3 groundTex = texture(iChannel0, groundUv).xyz;\n    if(worldDir.y<0.0)\n    {\n        // ground position to cube space for lighting evaluation\n    \tfloat3 cubeSpacePos= worldPosTocubePos(groundIntersection)+0.5;\n        \n        float3 shadow = getShadowTransmittance(cubeSpacePos,2.0,0.05);\n\n       \tfloat3 Ldir = Lpos-cubeSpacePos;\n        float Ldist = length(Ldir);\n    \tfloat3 LdirNorm = Ldir / max(0.0001, Ldist);\n        float Lattenuation = distanceAttenuation(Ldist);\n        \n        float N00 = texture(iChannel0, groundUv + float2( 0.001, 0.001)).g;\n        float N01 = texture(iChannel0, groundUv + float2( 0.001,-0.001)).g;\n        float N10 = texture(iChannel0, groundUv + float2(-0.001, 0.001)).g;\n        float N11 = texture(iChannel0, groundUv + float2(-0.001,-0.001)).g;\n        float3 N = cross(normalize(float3(1.0,25.0*(N11-N00),1.0)),normalize(float3(1.0,25.0*(N10-N01),-1.0)));\n        \n        color = groundTex * shadow * Lattenuation * L * dot(N,LdirNorm);\n    }\n    \n    //////////////////////////////////////////////////////////////////////////////////////////\n    //// Compute intersection with cube containing the bunny\n    float near = 0.0;\n    float far  = 0.0;\n    float3 cubeSpacePos= worldPosTocubePos(camPos);\n\tif (cube(cubeSpacePos, worldDir, near, far))\n    {\n    \tfloat3 scatteredLuminance = float3(0.0,0.0,0.0);\n        float3 transmittance = float3(1.0);\n        \n        float stepSize = 0.01;\n        for(float t=near; t<far; t+=stepSize)\n        {\n            float3 cubePos = cubeSpacePos + t*worldDir + 0.5;\n            float density = getDensity(cubePos);\n            \n       \t\tfloat stepSizeShadow = 0.1;\n            float3 shadow = getShadowTransmittance(cubePos,1.0, 0.1);\n            \n            \n    \t\tfloat Ldist = length(Lpos-cubePos);\n            float Lattenuation = distanceAttenuation(Ldist);\n\n#if 0\n            // Scattered luminance ignores phase function (assumes L has it baked in)\n            // This is not energy conservative.\n            scatteredLuminance += Lattenuation * shadow * transmittance * density *scattering * stepSize * L;       \n            transmittance *= exp(-density * extinction * stepSize);\n#else\n            // Improved scattering integration. See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n            vec3 S = L * Lattenuation * shadow * density *scattering;\n            vec3 sampleExtinction = max(vec3(0.0000000001), density * extinction);\n            vec3 Sint = (S - S * exp(-sampleExtinction * stepSize)) / sampleExtinction;\n            scatteredLuminance += transmittance * Sint;\n\n            // Evaluate transmittance to view independentely\n            transmittance *= exp(-sampleExtinction * stepSize);\n#endif\n        }\n        \n        // Apply volumetric on scene\n        color = transmittance*color + scatteredLuminance;\n    }\n    \n    \n    \n    fragColor = float4(pow(color, float3(1.0/2.2)),1.0); // simple linera to gamma\n    \n    \n}\n\n\n", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlyDs.jpg", "access": "api", "wgpu-test": "ok"}
{"id": "MdlyR2", "name": "Trip in Tron 2", "author": "ocb", "description": "A try with  reflection, transparency and  glow", "tags": ["raytracing", "transparent", "glow", "reflect"], "time_retrieved": "2024-05-15T23:14:38.779463", "image_code": "// Author: ocb\n// Title: Trip in Tron 2\n// testing reflection, transparency and glow\n\n\n#define PI 3.141592653589793\n\n\n// Global\n// object def\n// sphere A and B\nvec3 sphAO;\nfloat sphAR;\nvec3 sphBO;\nfloat sphBR;\nfloat ground;\n\n\nfloat random (in vec2 _st) { \t\t\t\t\t\t\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))* \n        43758.5453123+iTime*.1);\n}\n\nvec2 truchetPattern(in vec2 st, in float index){\n    \n    if (index > 0.75) {\n        st = vec2(1.) - st;\n    } else if (index > 0.5) {\n        st = vec2(1.0-st.x,st.y);\n    } else if (index > 0.25) {\n        st = 1.0-vec2(1.0-st.x,st.y);\n    }\n    return st;\n}\n\nbool groundImpact(inout vec3 pos,in float gndSurface, in vec3 N_ray, out vec3 N_normGnd){\n    bool impact = false;\n    \n    float t = ((gndSurface-pos.y)/N_ray.y);\n    if (t > 0.){\n        impact = true;\n\t\tpos = pos + t*N_ray;\n        N_normGnd = vec3(0., 1., 0.);\n    }\n    return impact;\n}\n\n\nfloat sphereImpact(inout vec3 pos, in vec3 sphO, in float sphR, in vec3 ray, out vec3 normSph){\n    \n    float t_dmin = 0.;\n    float taux = 0.;\n    vec3 delta = pos - sphO;\n\n    // Sphere interception\n    // pre-calculation\n    float b = dot(delta, ray);\n    float d = b*b - (dot(delta,delta) - sphR*sphR);\n    if (d >= 0.){\n        float Vd = sqrt(d);\n        float t = min( -b + Vd, -b - Vd ) ;\n        if (t > 0.){\n            t_dmin =  - b;\n    \t\tvec3 pos_dmin = pos + ray*t_dmin;\n   \t\t\ttaux = min(1./( (length(pos_dmin - sphO)/sphR) +.8)-0.8, 1.) + .5*pow(length(pos_dmin - sphO)/sphR,4.);\n            pos = pos + ray*t;\n            normSph = normalize(pos - sphO);\n        }\n    }\n    return taux;\t// return color index for the glow (center and surface)\n}\n\nvec3 groundColor(in vec3 pos){\n    vec3 col= vec3(0.);\n    \n    \tvec2 ipos = floor(vec2(pos.x,pos.z)*.1);  // integer\n    \tvec2 fpos = fract(vec2(pos.x,pos.z)*.1);  // fraction\n\t\tvec2 tile = truchetPattern(fpos, random( ipos ));\t\t// generate Maze\n        vec2 tileXL = truchetPattern(fract(vec2(pos.x,pos.z)*.1), random( floor(vec2(pos.x,pos.z)*.1) ));\t\t// used for impact effect\n        \n        // Maze\n    \tcol.b += .4*(smoothstep(tile.x-0.05,tile.x,tile.y)-smoothstep(tile.x,tile.x+0.05,tile.y));\n        col.b += .5*(1.-smoothstep(.0,.1,length(tile-fract(iTime*.4))));\t// Head on top of Truchet pattern\n    \t\n        col.rb += .5*(1.-smoothstep(0.,5.*sphAR,length(pos.xz-sphAO.xz)))*(smoothstep(tile.x-0.05,tile.x,tile.y)-\n              \t\t   smoothstep(tile.x,tile.x+0.05,tile.y));\t\t// grid lag below sphere A\n        col.gb += .5*(1.-smoothstep(0.,5.*sphBR,length(pos.xz-sphBO.xz)))*(smoothstep(tile.x-0.05,tile.x,tile.y)-\n              \t\t   smoothstep(tile.x,tile.x+0.05,tile.y));\t\t// grid lag below sphere B\n     \t\n        \n        col += (1.-smoothstep(0.,.02,abs(pos.x)));\t\t\t\t// thin white line (main line)\n        col.rgb += .3*max(0.,1.-atan(abs(pos.x))*2./PI-.1);\t\t// White line glow\n        col.r += (1.-smoothstep(0.,.02,abs(pos.z)));\t\t\t    // thin red line (crossing signal)\n        \n        col.r += max(0.,(1.-smoothstep(0., .6, fract(iTime*.1+pos.x*0.00025)))*((1.-smoothstep(0.,.02,abs(pos.z))) + max(0.,1.-atan(abs(pos.z))*2./PI-.1)));\t//crossing pulse\n        col.b += max(0.,(1.-smoothstep(0., .4, fract(iTime*3.+pos.z*0.01)))*((1.-smoothstep(0.,.02,abs(pos.x))) + max(0.,1.-atan(abs(pos.x))*2./PI-.1)));\t//rapid pulse\n                \n       col.r += 1.*min(.9, smoothstep(0.,1.,(1.-fract(iTime*.1))\n                *( smoothstep(tile.x-0.05,tile.x,tile.y) - smoothstep(tile.x,tile.x+0.05,tile.y)+1.*(1.-smoothstep(.0,.1,length(tileXL-fract(iTime*2.)))) )\n                *(1.-smoothstep(0.,300000.*fract(iTime*.1), pos.x*pos.x+ pos.z*pos.z))*smoothstep(0.,100000.*(fract(iTime*.1)), pos.x*pos.x+ pos.z*pos.z)  ));  //impact\n                                                                      \n       col *= min(.8,10./length(.01*pos))+.2; \t// distance fog\n\n    return col;\n}\n\nvec3 skyColor(in vec3 ray){\n    vec3 col = vec3(0.);\n    col += vec3( max((ray.x+1.)/2.*(-4.*ray.y+1.)/2.,0.),.1*(1.-ray.y),.2*(1.-ray.y) );\n    return col;\n}\n\n\nint ojectReflect(inout vec3 pos, inout vec3 N_ray, inout vec3 color){\n    vec3 posA = pos, posB= pos, N_normPosA = vec3(0.), N_normPosB = vec3(0.);\n    float tauxA, tauxB;\n    bool A_ok = false;\n    bool B_ok = false;\n    \n    tauxA = 1.3*sphereImpact(posA, sphAO, sphAR, N_ray,N_normPosA);\n    tauxB = 1.3*sphereImpact(posB, sphBO, sphBR, N_ray,N_normPosB);\n    \n    A_ok = bool (tauxA);\n    B_ok = bool (tauxB);\n    \n    if (A_ok) {\n        if (B_ok){\n            if (length(posA-pos) < length(posB-pos)){\t\t// A and B are one behind the other\n                \t\t\t\t\t\t\t\t\t\t\t// at the end, both color are mixed\n                color += vec3(0.,tauxB,tauxB);\t\t\t\t// but first, we must get the reflection on the sphere behind.\n                vec3 Sray = reflect(N_ray,N_normPosB);\t\t\t\t\t\t// recursivity would be good\n                if (groundImpact(posB, ground, Sray, N_normPosB) ){\t\t\t// but not allowed by my shader\n       \t\t\t\tcolor += groundColor(posB);\t\t\t\t\t\t\t\t// so here we get the ground or sky reflexion\n    \t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// on the sphere behind\n    \t\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t\t// color is added at the sphere basic color tauxB\n        \t\tcolor += skyColor(Sray);\n   \t\t\t\t}\n                color = mix(vec3(tauxA,0.,tauxA),color,.7);\t\t// finally A and B are mixed\n        \t\tpos = posA;\t\t\t\t\t\t\t\t\t\t// and pos and ray of the front sphere is returned.\n        \t\tN_ray = reflect(N_ray,N_normPosA);\n    \t\t}\n    \t\telse{\n                color += vec3(tauxA,.0,tauxA);\n                vec3 Sray = reflect(N_ray,N_normPosA);\n                if (groundImpact(posA, ground, Sray, N_normPosA) ){\n       \t\t\t\tcolor += groundColor(posA);\n    \t\t\t}\n    \t\t\telse {\t\t// ray goes to the sky\n        \t\tcolor += skyColor(Sray);\n   \t\t\t\t}\n                color = mix(vec3(0.,tauxB,tauxB),color,.7);\n        \t\tpos = posB;\n        \t\tN_ray = reflect(N_ray,N_normPosB);   \n            }\n        }\n        else{\n            color.rb += tauxA;\n        \tpos = posA;\n        \tN_ray = reflect(N_ray,N_normPosA);   \n        }\n    }\n    else if (B_ok){\n        color.gb += tauxB;\n        pos = posB;\n        N_ray = reflect(N_ray,N_normPosB);\n    }\n    \n    return int(A_ok)+int(B_ok);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    // init global object\n    sphAO = vec3(40.*sin(iTime*.4),15.,60.*cos(iTime*.3));\n\tsphAR = 5.;\n\tsphBO = vec3(80.*sin(iTime*.4),16.,40.*cos(iTime*.3));\n\tsphBR = 6.;\n    ground = 0.;\n    \n    // camera def\n    float focal = 1.;\n    float \trau = 15.*(sin(iTime/11.)+1.)+3.*sphAR,\n    \t\talpha = -iTime/5.,\n    \t\ttheta = (sin(iTime/7.)/2.+.5)*(PI/2.-1.2)-.1;\t//rau, alpha, theta camera position   \n\t\n    vec3 camTarget = (sin(iTime*.2)+1.)*.5*sphAO + (sin(iTime*.2+PI)+1.)*.5*sphBO;  //target going from sphA to sphB\n    \n    vec3 screenPos = rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n    \n    vec3 ww = normalize( camTarget - screenPos );\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\tvec3 N_ray = normalize( st.x*uu + st.y*vv + focal*ww );\n\n    vec3 N_normPos = vec3(0.);\n    vec3 pos = screenPos;\n\n    vec3 color = vec3(.0);\n    \n    // get color on transparency path\n    // no object hit, only ground or sky\n    vec3 transPos = pos;    \n    vec3 transColor = vec3(0.);\n    if (groundImpact(transPos, ground, N_ray, N_normPos)){\n        transColor = groundColor(transPos);\n    }\n    else {transColor = skyColor(N_ray);}\n    //-------------------------------\n    \n    // calculate reflection\n    if (ojectReflect(pos, N_ray, color)>0){\t\t// first step ray\n        ojectReflect(pos, N_ray, color);\t\t// if sphere hit, second step ray\n    }\n    //-------------------------------\n    \n    // mix reflection and transparency\n    color = mix(color, transColor, .5);\n    \n    // otherwise no object impacted\n    if (groundImpact(pos, ground, N_ray, N_normPos) ){\n       color += groundColor(pos);\n    }\n    else {\t\t// ray goes to the sky\n        color += skyColor(N_ray);\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlyR2.jpg", "access": "api", "wgpu-test": "ok"}
