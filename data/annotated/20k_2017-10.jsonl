{"id": "4djyzK", "name": "Laplacian", "author": "iq", "description": "Visualization of the Laplacian of a distance field. It measures average rate of of change. So it can be used to detect discontinuities and also rate of curvature of the distance field.", "tags": ["2d", "sdf", "laplacian", "disntancefield"], "likes": 30, "viewed": 1211, "published": "Public API", "date": "1509469600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computes the laplacian of a distance field.\n\n// The Laplacian measures average rate of change at a given location (while gradient measures\n// the direction of maximum change). If compared agains a threshold, you can use is as an\n// edge detector. You can also use it to detect linear sections of the distanec field, where\n// the Laplace is zero, or alternativelly, measure how curved the isolines are (where the\n// laplacian is higher the bigger the curvature).\n\n\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec2 v1, v2, v3;\n\nfloat map( in vec2 p )\n{\n    float d1 = length(p-vec2(-0.6,-0.3))-0.4;\n    float d2 = sdTriangle( v1, v2, v3, p );\n    float d3 = sdBox( p-vec2(1.0,0.5), vec2(0.6,0.2) );\n    return min( d1, min(d2,d3) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    v1 = 0.7*cos( iTime*0.55 + vec2(0.0,1.5) + 0.0 );\n\tv2 = 0.5*cos( iTime*0.50 + vec2(0.0,1.7) + 3.0 );\n\tv3 = 0.8*cos( iTime*0.60 + vec2(0.0,1.6) + 4.0 );\n\n    vec2 e = vec2(2.0/iResolution.y,0.0);\n\tfloat dis = map( p );\n    vec2  gra = vec2(map(p+e.xy)-map(p-e.xy), map(p+e.yx)-map(p-e.yx))/(2.0*e.x);\n    float lap = (map(p+e.xy) + map(p-e.xy) + map(p+e.yx) + map(p-e.yx) - 4.0*map(p))/(e.x*e.x);\n    \n    \n    //vec3 col = vec3(0.9+0.1*gra,0.0);\n\tvec3 col = vec3(1.0,0.7,0.3);\n    if( dis<0.0 ) col = col.zxy;\n    col *= 1.0 - 0.7*exp(-1.5*abs(dis));\n    col *= 0.96 + 0.04*cos(200.0*dis);\n\tcol = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep(0.0,0.01,abs(dis)) );\n    \n  \n    // laplacian display\n    float anim = fract( iTime/8.0 );\n         if( lap<-10.0 ) { if( anim>0.25 ) col  = vec3(1.0,1.0,1.0); }\n    else if( lap> 10.0 ) { if( anim>0.50 ) col  = vec3(1.0,0.8,0.1); }\n    else                 { if( anim>0.75 ) col += vec3(1.0,1.0,1.0)*abs(lap)*0.1; }\n    \n    //col += vec3( abs(lap)*0.1 );\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4djyzK.jpg", "access": "shaders20k", "license": "mit", "functions": [[1126, 1546, 1577, 1577, 1655], [1657, 1657, 1724, 1724, 2325], [2345, 2345, 2369, 2369, 2551], [2553, 2553, 2610, 2610, 3708]]}
{"id": "4l2cRW", "name": "BiCapsule", "author": "zalo", "description": "Also known as a \"Cone Sphere\", this is essentially a capsule with two different radii at each end.  It has a few nice properties (it's the convex hull of two spheres and a subsection of a cone).  Not optimized, but branchless and extensible to an SDF.", "tags": ["sdf", "sphere", "cone", "function", "capsule", "tangent", "bicapsule"], "likes": 10, "viewed": 1256, "published": "Public API", "date": "1508138409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATIONS 128\n#define MIN_DISTANCE .001\n#define NEAR_PLANE    1.\n#define FAR_PLANE    5.\n\nvec3 closestPointToBiCapsule(vec3 pos, vec3 a, vec3 b, float r1, float r2) {\n    //Standard line segment closest point\n    vec3 ba = b - a; float baMagnitude = length(ba);\n    float alpha = (dot(pos - a, ba) / dot(ba, ba));\n    vec3 capsuleSegmentPos = mix(a, b, alpha);\n    \n    //Calculate the offset along segment according to the slope of the bicapsule\n    float pointSphereRadius = r1 - r2; //This collapses the problem into finding the tangent angle for a point/sphere\n    float exsecantLength = ((baMagnitude / abs(pointSphereRadius)) - 1.0) * baMagnitude;\n    float tangentAngle =  acos(1.0 / (exsecantLength + 1.0)); //This is also known as the \"arcexsecant\" function\n    float tangentOffset = length(capsuleSegmentPos - pos) / tan(tangentAngle); //This is adjacent / tan(theta) = opposite\n    tangentOffset *= sign(pointSphereRadius); //Allows it to handle r2 > r1 as well\n    \n    //And back to classic capsule closest point (with lerped radii)\n    float clampedOffsetAlpha = clamp(alpha - tangentOffset, 0.0, 1.0);\n    vec3 bicapsuleSegmentPos = mix(a, b, clampedOffsetAlpha); float bicapsuleRadius = mix(r1, r2, clampedOffsetAlpha);\n  \treturn bicapsuleSegmentPos + (normalize(pos - bicapsuleSegmentPos) * bicapsuleRadius);\n}\n\n\nvec3 offsetToSurface(vec3 pos) {\n    vec3 a = vec3(-0.5, 0.0, 2.0);\n    vec3 b = vec3(0.5 + (sin(iTime)*0.5), (cos(iTime)*0.5), 2.0);\n\n    vec3 closestPoint = closestPointToBiCapsule(pos, a, b, (sin(iTime*3.0)*0.3)+0.3, 0.2);\n    return closestPoint - pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 rayDir = vec3( uv.x - 0.5, (uv.y - 0.5) * iResolution.y / iResolution.x, 0.5 );\n    vec3 toSurfaceOffset;\n    \n    float depth = NEAR_PLANE; float curDist = MIN_DISTANCE; int i;\n\tfor(int i = 0; i < MAX_ITERATIONS; i++) {\n        depth += curDist;\n        toSurfaceOffset = offsetToSurface(rayDir * depth);\n    \tcurDist = length(toSurfaceOffset);\n        \n        if (curDist <= MIN_DISTANCE || depth > FAR_PLANE)\n            break;\n\t}\n\n    if(depth < FAR_PLANE){\n\t\tfragColor = vec4(clamp(dot(vec3(1.0, 1.0, -1.0), -toSurfaceOffset/curDist)*0.5,0.0,1.0)+0.1);\n    }else{\n        fragColor = vec4(0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2cRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 179, 221, 1340], [1343, 1343, 1375, 1375, 1601], [1603, 1603, 1660, 1660, 2318]]}
{"id": "4l2cW1", "name": "Procedural urban landscape 211 c", "author": "FabriceNeyret2", "description": "golfing [/url]https://www.shadertoy.com/view/Xl2yWh[/url]\nSee previous steps in its forum.", "tags": ["procedural", "raymarching", "noise", "city", "2tweets", "short", "buildings", "golf"], "likes": 7, "viewed": 844, "published": "Public API", "date": "1508413923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// golfing https://www.shadertoy.com/view/Xl2yWh\n\n/**/\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec3 p = vec3( iTime, 3, 0 ) *9.,\n         r = iResolution,\n         d = vec3( ( U - .5*r.xy ) / r.y, 1 );\n    float t = .2;\n    for( d.yz *= mat2(4,-3,3,4)*t ; t>.1; t = min( p.y - 8.*t*t , .2 ) )\n        p += t*d, r = ceil(p/3.),\n        t = fract( 4e4* sin(r.x+r.z*17.) );\n    O += p.y / 8.; }\n            \n/**/\n\n            \n            \n            \n/**  // 217 chars\n\n#define mainImage( O,  U )                             \\\n    vec3 p = vec3( iTime, 3, 0 ) *9.,                  \\\n         r = iResolution,                              \\\n         d = vec3( ( U - .5*r.xy ) / r.y, 1 );         \\\n    float t = 1., v;                                   \\\n    for( d.yz *= mat2(.8,-.6,.6,.8) ; t>.1; p += t*d ) \\\n        v = p.y, r = ceil(p/3.),                       \\\n        t = fract( 4e4* sin(r.x+r.z*17.) ),            \\\n        t = min( v - 8.*t*t , .2 );                    \\\n    O += v / 8.\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2cW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 56, 92, 92, 393]]}
{"id": "4l2yDh", "name": "one way portal 2", "author": "ollj", "description": "fork of \nhttps://www.shadertoy.com/view/lsSGRz\nlearning how they did it.", "tags": ["4d", "portal", "bioshock"], "likes": 9, "viewed": 596, "published": "Public API", "date": "1508388162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//sign 3d portal (one way) single pass 2\n//https://www.shadertoy.com/view/lsSGRz\n\n//was a bit messy, cleaned it up a lot.\n\n//one lazy thing here is that it uses n states, buffers\n//so it just assumes that it will pass the portal only once per cycle\n// at the same spots on he cycle.\n\n//turns few things make an objectID gBuffer more complicated\n//than a portal.\n//the main problem is measuring a distance gradient trough a portal\n//basically doublles the number of measures\n//OR\n//you first trace the portal, use it as a bounding volume (leaf portal duh)\n//and stop parching ON the portal, which adds a trace and +1 step.\n// the trace is kinda done heuristically anyways\n// , where it suffers lipschitz issies.\n// so, this needs an explicit portal tracer as primary BVH.\n\n//todo, needs tracer BV\n//to know when a ray passes the portal and when not!\n//i tried stuff, and mostly made it worse than better\n\n//spin speed of portal around vertical axis.\n#define portalSpinZ iTime*2.\n\n//smaller steps or simpler geometry for better continuity.\n//makes portal a circle.\n//#define doGoodLipschitz\n\n//the lazy lipschitz adjustment\n#define understepRm .5\n\n#define zFar  400.\n#define iterRm 180\n\n#define SPECULAR\n\n//this is shitty occlusion, in a dicsontinuous set, poorly cotained.\n#define iterShadow 1\n\n//.x is radius .y is thickness of portal \"wall\"\n\n#define portalRing vec2(22.,1.)\n//#define portalRing vec2(22.,152./iResolution.y)\n//hairlined /iResolution\n//because it is a curved thing with bad lipschitz\n\n\n//glow completely fails along the portal discontinuity\n//well, glow is always good ad shwing bad lipschits\n//, so it stays as a debugger.\n//#define GLOW 1\n// Increase for bigger glow effect (which also gets a little bugged...)!\n#define GLOW_AMOUNT 9.*portalRing.x/understepRm\n//clearly glow was an attempt at hiding discontinuities\n\n//i tried to fix some continuity cases trough the portal\n//and made it worse, introcused more discontinuities than it removed.\n#define TheHartdWay\n\n/*\ntodo, this could use bool;if linesegment intersets portal surface,\n//even with sign check (portal normal)\n\n//portal surface is defined by;\ncenter, radius, normal\n\nif (line intersetcs plane)\n- this is bool, because parallel case is common\n- if (intersection distance < line segment length)\n- - if (intersection point is inside circle)\n- - - portal direction resolve\n- - - lets say a portal is a delta_world, but with sign\n- - - still need to resolve direction of portal with portal normal\n- - - should be sign of dot of directions!\n*/\n\n\n\n/*\nportal gun is one way portals!\na portal bun places 2 one-way portals in 2 different locales.\none way portalsd have some inherent backfacing-problems.\n2-way portals do not have that!\n\nlets assume a portal gun places 2 2-way portals.\nthe front side of one portal\n connects to the back side of the other portal\n\nsuch doubly-linked portals may change worlds OR locales OR both!\nthey likely only have a deltaPos and deltaRotation\n, linking 2 places in the same \"world\"\n\nwell, actually. \"world\" is just a \"lcale\" parameter.\n*/\n\n/*\nintersecting portal problem:\n- includes partially intersecting and coplanar portals)\n- excludes portal velocity movement sum problems.\n\nwhen a ray hits one portal, it must stop ON the portal\n- (problem of rounding errors here)\non that point it must intersect with all other portals.\n- the [order of portals] is relevant here, resolves catch22 things.\n*/\n\n//Find distance to intersection of plane along ray\n\n/*\n\n//plane tracing functions could possibly result in higher recision\n// but for now I doubt it much of a difference\n\n//return signed distance of u to plane (n,d)\n//[u]=point to measure plane distance to\n//[n]=plane normal, length set to 1.\n//[m]=plane distance to vec3(0)\nfloat dPlane(vec3 u,vec3 n,float m){return dot(u,n)+m;}\n\n\n\n\nfloat ass(vec3 n,float m,vec3 u,vec3 t)\n{float e=dot(n,t)\n;if(e==.0)return .0;//ray is parallel to plane\n;float d=-(dot(n,u+m)/e)\n;if(d<length(t))return .0;//plane is too far away\n;u+=t*e;//u is intersection point\n;return 1.;    \n}\n\n//return direction of intersection of ray with plane\n// 0= no intersection\n//+1= intersecting from positive space\n//-1= intersection from negative space\nfloat ass2(vec3 u,vec3 t,vec3 n,float m){\n float d0=sign(dot(u  ,n)+m);\n float d1=sign(dot(u+t,n)+m);  \n if (d0!=d1)return d0;//return intersection direction.\n return .0;}//no intersection\n\n\n*/\n\n//[n]PlaneNormal\n//[m]PlaneDistance (badly explained, distance to what)\n//[u]RayOrigin\n//[t]RayDirection\n//return distacne from origin to intersection.\nfloat gPRxZ(vec3 n,float m,vec3 u,vec3 t){\n    return -(dot(n,u+m)/dot(n,t));}\n\n//curDist, curMat , dist,mat\nvec2 fUnionMat(vec2 dm,vec2 en){return mix(dm,en,step(en.x,dm.x));}\n\nfloat boxR(vec3 p,vec3 b)\n{return length(max(abs(p)-b,.0));}\n\nfloat pTorus(vec3 p, vec2 t)\n{vec2 q=vec2(length(p.xz)-t.x,p.y);return length(q)-t.y;}\n\n\n//return polar of carthesian input; carthesian to polar: returned .x=distance to vec2(0); .y=angle in radians\nvec2 c2p(vec2 c){return vec2(length(c),atan(c.y,c.x));}\n//return carthesian of polar input; polar to carthesian: p.x=distance to vec2(0); p.y=angle in radians\nvec2 p2c(vec2 p){return vec2(p.x*cos(p.y),p.x*sin(p.y));}\n//lame simple rotation\nmat2 r2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\n\n//polar deformation to \"star shape\" (with bad lipschitz)\nvec2 wobble(vec2 u){\n#ifdef doGoodLipschitz\n ;return u;\n#endif\n ;u=c2p(u);\n ;float a=cos((u.y+iTime)*13.)*2.\n ;float b=cos((u.y+iTime)* 5.)*3.\n ;u.x+=mix(a,b,sin(iTime)*.5+.5)\n;return p2c(u);}\n\n\n\nfloat pTorus2(vec3 p, vec2 t){\n p.xy*=r2(portalSpinZ);//we spin locally.\n p.xz=wobble(p.xz);//we deform the gradient into a \"star shape\"\n return pTorus(p,t);}\n\n\n\nfloat gdo(float w, vec3 p, inout float m)\n{vec2 dm=vec2(16.+p.z,1)\n;if (w==0.\n){dm=fUnionMat(dm,vec2(length(p+vec3(24,22,4))-11.,4.))\n ;dm=fUnionMat(dm,vec2(boxR(  p+vec3(6,-35,4),vec3(4,4,11)),4.))\n ;dm=fUnionMat(dm,vec2(boxR( p+vec3(19,-15,0),vec3(4,4,15)),4.))\n ;dm=fUnionMat(dm,vec2(boxR(p+vec3(-12,20,12),vec3(7     )),4.))\n;}else{dm.y=2.\n ;dm=fUnionMat(dm,vec2(boxR(p+vec3( 15,35, 6),vec3(4,12,9 )),5.))\n ;dm=fUnionMat(dm,vec2(boxR(p+vec3(-10,35,10),vec3(15,3,5 )),5.))\n ;dm=fUnionMat(dm,vec2(boxR(p+vec3( 15,-35,6),vec3(12,6,15)),5.))\n;}\n;dm.x-=1.\n;m=dm.y;\n;return dm.x;\n}\n//above is only occluding things\n//below also includes non-occluding things \n//fullbright light sources of the same color do not occlude another.\nfloat gd(float w, vec3 p, inout float m)\n{vec2 dm=vec2(16.+p.z,1)\n;dm.x=gdo(w,p,m);\n;dm.y=m\n;dm=dm=fUnionMat(dm,vec2(pTorus2(p,portalRing),3.));\n;m=dm.y;\n;return dm.x;}\n\nvec3 dg(float w, vec3 p){const vec2 e=vec2(.01,0)\n;float m;return normalize(vec3( \n(gd(w,p-e.xyy,m)-gd(w,p+e.xyy,m)),\n(gd(w,p-e.yxy,m)-gd(w,p+e.yxy,m)),\n(gd(w,p-e.yyx,m)-gd(w,p+e.yyx,m))));}\n\n\n//main problem of this one is that it changes \"worlds\"\n// AFTER calculating step distance!\n//[u]=CameraPosition (consant within this raymarcher)\n//[t]=rayDirection\n//[v]=traversed point alnog ray\n//[r]=distance along ray\n//[e]=last step length\nbool changeWorlds(vec3 u,vec3 t,vec3 v,float r,inout float e){\n    ;t.xy*=r2(portalSpinZ)      \n    ;u.xy*=r2(portalSpinZ)   \n    ;v.xy*=r2(portalSpinZ)//rotare portal over time around .z axis\n    \n    ;return\nlength(wobble(v.xz))<portalRing.x//intersection is inside portal-shape\n     &&\n        (v.xy).y>.0 &&\n        (u+t*(r+e)).y<.0;}\n\n\n\n\n//[n]PlaneNormal\n//[u]RayOrigin\n//[t]RayDirection\n//return distacne from origin to intersection.\nfloat gPRxZ(vec3 n,vec3 u,vec3 t){\n    return -(dot(n,u)/dot(n,t));}\nfloat gPRxZ(vec2 n,vec2 u,vec2 t){\n    return -(dot(n,u)/dot(n,t));}\n//second life wiki geometric\n//\n//calculate intersection of ray from [a] to [m.xy] \n//and plane with notmal [n] and distance [d]to vec2(0)\n//from there move AWAY from [a]\n//, in the direction of the surface normal, by [c]\n//return that point \"BEHIND\" the intersection point.\nvec3 pointBehindBound(vec3 n,float d,vec3 a,vec3 b,float c){\n n=normalize(n);//save\n vec3 i=a+(b-a)*gPRxZ(n,a+n*d,(b-a));\n i-=n*sign(dot(a,n)+d)*c;//stop a little bit behind the plane.\n //i+=normalize(b-a)*c;//same, but point is on ray [m]\n return i;}\nvec2 pointBehindBound(vec2 n,float d,vec4 m,float c){\n n=normalize(n);//save\n vec2 i=m.zw+(m.xy-m.zw)*gPRxZ(n,m.zw+n*d,(m.xy-m.zw));\n i-=n*sign(dot(m.zw,n)+d)*c;//stop a little bit behind the plane.\n //i+=normalize(m.xy-m.zw)*c;//same, but point is on ray [m]\n return i;}\n//this is intended tor teleporters\n//, where 4 permutations of \"normal\" and \"distance\" are relevant.\n/*\nexample use:\n vec2 planeNormal=normalize(vec2(1,5));\n float planeDist=-1.;   \n c.g=dot(u,planeNormal)-1.+planeDist;//draw signed boundary\n vec2 intersect=pointBehindBound(planeNormal,planeDist,m,.5);\n c.b=length(u-intersect)-.5;//draw blue around \"intersect\"\n*/\n\n\n\n//oh wow, whos idea is it to make a raymarcher routine with a portal\n//that accumulates a distance to a camera\n//wehen the portal makes that distance all but eulidean!\n//\n//get world,rayOrigin,rayDirection\n//r.x distance gets a birt skewed when passing portals.\n//u is the real ray position to be returned\n\n\n#ifdef TheHartdWay\n\n//get world,rayOrigin,rayDirection\nvec4 raymarch(float w,inout vec3 u,inout vec3 t)\n{vec4 r=vec4(0,0,w,1000.)//return vec4(distance,materialId,world,glow)\n;vec3 v;//we need u for a final return on t!\n//;vec3 x=u;\n;bool bb=false;\n;for(int i=0;i<iterRm;i++\n){\n ;if(!bb)v=u+t*r.x//move v along ray. //can not be delayed (easily)\n ;float e=gd(r.z,v,r.y)*understepRm\n #ifdef GLOW\n  ;if(r.y==3.)r.w=min(r.w,e)\n #endif\n ;bb=changeWorlds(u,t,v,r.x,e);\n ;if(bb\n ){\n\n  ;v=pointBehindBound(vec3(vec2(0,-1)*r2(-portalSpinZ),0),.0,v,v-t,\n                      .001\n                     //5.1\n                    //  iMouse.x*10./iResolution.x-5.  \n                     );\n  //e= makes t somehow worse:\n  //;e=gd(r.z,v,r.y)*understepRm;//needs new measure on other side of portal!\n  ;if(gd(r.z,v,r.y)*understepRm<-.1)break;\n   // e=.0001;\n        ;r.z=mod(r.z+1.,2.);//swap worlds\n ;}\n r.x+=e\n;}\n;t*=r.x\n;u+=t\n;r.y=mix(0.,r.y,step(r.y,zFar))//seems to have no effect\n;return vec4(r.x,r.y,r.z,r.w);}\n\n#else\n\nvec4 raymarch(float w,inout vec3 u,inout vec3 t)\n{vec4 r=vec4(0,0,w,1000.)//return vec4(distance,materialId,world,glow)\n;for(int i=0;i<iterRm;i++\n){\n ;vec3 v=u+t*r.x//vector from [cameraOrigin] to [point]\n ;float e=gd(r.z,v,r.y)*understepRm\n #ifdef GLOW\n  ;if(r.y==3.)r.w=min(r.w,e)\n #endif \n ;if(changeWorlds(u,t,v,r.x,e)){\n   r.z=mod(r.z+1.,2.)//swap worlds\n ;}    \n ;r.x+=e\n;}\n;t*=r.x\n;u+=t\n;r.y=mix(0.,r.y,step(r.y,zFar))//seems to have no effect\n;return vec4(r.x,r.y,r.z,r.w);}\n\n#endif\n\n\n#if iterShadow>0\n//yeah, this shadow function is pretty defunct.\n//world,lightsource,lightDirection\nfloat shadow(float world, vec3 from, vec3 increment)\n{\n\tconst float minDist = 1.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n\tfor(int i = 0; i < iterShadow; i++) {\n\t\tfloat m;\n        float h = gd(world, from + increment * t,m);\n        if(h < minDist)\n            return 0.0;\n\t\t\n\t\tres = min(res, 4.0 * h / t);\n        t += 1.4;\n    }\n    return res;}\n#endif\n\n#define sat(a) clamp(a,0.,1.)\n#define u5(a) ((a)*.5+.5)\n\nvec3 getPixel(float w,vec3 u,vec3 t){\n;vec4 c=raymarch(w,u,t);\n;vec3 n = dg(c.z,u)\n;vec3 lightPos = -normalize(u + vec3(0,0,-4))\n;float dif = u5(max(.0,dot(n,-lightPos)))\n,s= \n#if iterShadow>0\n u5(shadow(c.z, u,lightPos))\n#else\n 1.\n#endif\n,spe=.0\n#ifdef SPECULAR\n ;if (dot(n,-lightPos)>.0)spe=pow(max(.0,dot(reflect(-lightPos,n),normalize(-t))),5.)\n#endif\n//gBuffer materialId resolve\n;vec3 m=vec3(0)\n;if(c.y==1.\n){m=mix(vec3(1,.1,.2),vec3(1,.3,.6),sin(u.x)*sin(u.y))\n  *sat((100.-length(u.xy))/100.);\n}else if(c.y==2.\n){m=mix(vec3(.1,.2,1),vec3(.5,.5,1),sin(u.x))\n *sat((100.-length(u.xy))/100.);\n}else if(c.y==3.)m=vec3(1,1,1)\n;else if(c.y==4.)m=(fract(u.x/3.0)<.5?vec3(1,.1,.2):vec3(1,.3,.6))\n;else if(c.y==5.)m=(fract(u.x/3.0)<.5?vec3(.1,.4,1):vec3(.4,.6,1))\t\n;return mix(vec3(0,1,0),(m*dif+vec3(spe))*s, sat(c.w/GLOW_AMOUNT));\n;}\n\n//basic most intuitive \"look at\" camera\"\n//[u]=relative ScreenPosition.xy range [-1..1] u=vec2(0) is central\n//[t]=camera looking direction=Target-CamPosition\nvec3 camLookAt(vec2 u,vec3 t){t=normalize(t)\n;vec3 o=normalize(cross(t,vec3(0,0,1)));\n;vec3 l=normalize(cross(o,t));//2times normalize(cross()) is slow.\n;return normalize(u.x*o+u.y*l+2.5*t );}\n\nvoid mainImage( out vec4 o, in vec2 p){o=vec4(0);//for compatibility\n;p=p.xy/iResolution.xy\n;p=-1.0+2.0*p\n;p.x*=-iResolution.x/iResolution.y\n//;vec2 mo=iMouse.xy/iResolution.xy;\n\n;float d=50.,tim=iTime*.5\n;vec3 t=vec3(cos(tim)*8.\n            ,sin(tim+2.)*12.,4.)//cam target\n;vec3 u=vec3(50.+cos(tim)*d\n                ,sin(tim)*d*1.5,4.);//cam position\n;t=camLookAt(p,t-u);\n//aw man, the transition between worlds is a scripted timer.\n;float w;\n;if(cos(-iTime/4.)>.0)w=.0;else w=1.\n;o=vec4(getPixel(w,u,t),1);}\n \n/*\non \"4d\"\n-\nthe \"w\" parameter is basically a 4th dimension\n, here it is a boolean (for implicity) \n  but it could be generalized to a float.\nThan it would be an \"ease in\" to how 4d space works\n and how i4d space can be used to simulate portals.\n-\neg: rotations in 4d are double-quaterions=octonions.\njust like you measure the distance to two 3d gradients (double 3d space)\n, when they overlap, due to a portal that connects them.\neeg: 4d rotations are not necessarily coplanar\n, 4d rotations are more likely fibrations around a torus surface.\n-\neg: the camera moves in 1 circle trough 4d space\n, which is 2 overlapping circles in 3d space.\nthis is actually a problem for root solving polinomials of degree higher than 5.\n- - you must do 2 full rotations to return to your origina position.\n- - this ambiguity makes it impossibly \n- -  to analytically solve polynomials of degree higher than 4\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2yDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4373, 4525, 4567, 4567, 4603], [4605, 4634, 4666, 4666, 4701], [4703, 4703, 4730, 4730, 4763], [4765, 4765, 4795, 4795, 4851], [4854, 4964, 4981, 4981, 5019], [5020, 5123, 5140, 5140, 5180], [5181, 5204, 5221, 5221, 5268], [5270, 5327, 5347, 5347, 5519], [5523, 5523, 5553, 5553, 5681], [5685, 5685, 5728, 5728, 6264], [6265, 6411, 6453, 6453, 6579], [6581, 6581, 6606, 6606, 6771], [6774, 7018, 7080, 7080, 7356], [7361, 7458, 7492, 7492, 7526], [7527, 7527, 7561, 7561, 7595], [7596, 7871, 7931, 7931, 8122], [8123, 8123, 8176, 8176, 8394], [8764, 11088, 11125, 11125, 11922], [11924, 12083, 12113, 12113, 12275], [12277, 12277, 12316, 12316, 12788]]}
{"id": "4l2yWw", "name": "FruitMachine", "author": "Del", "description": "Fruit Machine Work in Progress... :)\n", "tags": ["raymarch", "font", "fruitmachine"], "likes": 8, "viewed": 181, "published": "Public", "date": "1508811793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// fruit machine reels added by Del\n\n\n#define AA 1   // make this 1 is your machine is too slow\n\n#define PI 3.1415926\n#define DEG2RAD ((PI * 2.0) / 360.0)\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\n\n//---------------------------------------------------------\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n\n\n#define XP 0.0\n#define ZP 0.0\n#define HEIGHT 0.4\n#define FONTTHICKNESS 0.1\n#define INNER 1.9\n\nstruct ReelData\n{\n  float rot;\n};\n\nvec3 p00 = vec3(XP, 2.7, ZP);\n\nReelData dat[4] = ReelData[4](\n    ReelData(0.0),\n    ReelData(0.0),\n    ReelData(0.0),\n    ReelData(0.0)\n);\n    \n// crap stuff\n// dirty... not sure if I am doing this correctly...\nvec4 SampleFontTex(vec2 uv,float xoff)\n{\n    uv = uv.yx;\n    uv.x = -uv.x;\n//    uv += 0.04;\n    uv.x += 0.04 + (0.25 * xoff);\n    uv *= 0.25;\n    vec2 fl = floor(uv + 0.5);\n    uv = fl + fract(uv+0.5)-0.5;\n    \n    // Sample the font texture. Make sure to not use mipmaps.\n    // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n    //return texture(iChannel0, (uv+0.5)*((1.0/16.0)*8.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.00001);\n    return texture(iChannel0, uv, -100.0) + vec4(0.0, 0.0, 0.0, 0.00001);\n}\n\n\n//------------------------------------------------------------------\n\nvec2 reel (in vec3 pos)\n{\n   \tfloat _mat1 = 230.0;\t// tower\n\tfloat _mat2 = 20.0;\t// font\n\n    float sv = 4.0 * sin(pos.y*0.1+dat[1].rot*0.01);\n    \n    float cval = abs(pos.y)*12.0;\n    \n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\n    float _index = pModInterval1(pos.y,1.0,-3.0,3.0);\n    int index = int(abs(_index)) % 4;\n    \n//\tpos = rotateY (pos,sv );\t// sin movement (pixel)\n    \n    pos = rotateY (pos, 180.0*DEG2RAD + sin(dat[index].rot*0.02));\t// sin movement (reel)\n////\tpos = rotateY (pos,  DEG2RAD*dat[index].rot);\t// spin\n    \n    float innercylinderdist = sdCylinder(pos,vec2(INNER,HEIGHT));\n    float d1 = sdCylinder(pos,vec2(INNER+FONTTHICKNESS,HEIGHT));\n \t// Load the font texture's distance field.\n\tvec4 _c = SampleFontTex( vec2(atan(pos.x,pos.z), 0.5+(pos.y*0.75)) / PI, 13.0);\n    float letterDistField = _c.w - 0.5+1.0/256.0;\n    d1 = max(letterDistField,d1);\n    \n    vec2 res = vec2( d1, _mat2 + cval);\n    \n    d1 = sdCylinder(pos,vec2(INNER-0.01,HEIGHT+0.1));\n    res.x = opS(res.x, d1 );\n    \n    res = opU(res, vec2( d1, _mat1 ) );\n    return res;\n    \n}\n\n\n\n\n\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( sdPlane(pos), 1.0 ); \t\t\t// floor (checker)\n    pos = rotateX (pos-p00,  DEG2RAD*270.0);\n    res =  opU(res,reel(pos));\n\n    // More accuracy (substepping)\n\tres.x *= 0.85;\n  \treturn res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n       \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.4, 0.2, 0.9) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(0.5*pos.z) + floor(0.5*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n#if 1\n        // lighting        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n#endif\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    if (iMouse.z<0.5)\n        mo = vec2((180.0 * DEG2RAD)/6.0,0.0);\n            \n\tfloat time = iTime;\n    dat[0].rot += time*25.0;\n    dat[1].rot += time*50.0;\n    dat[2].rot += time*75.0;\n    dat[3].rot += time*100.0;\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        //vec3 ro = vec3( 6.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 6.5*sin(0.1*time + 6.0*mo.x) );\n        \n\t\tfloat ang = 180.0 * DEG2RAD;        \n        vec3 ro = vec3( 6.5*cos(ang+(6.0*mo.x)), 4.0 + 2.0*mo.y, 6.5*sin(ang+(6.0*mo.x)) );\n        vec3 ta = vec3( 0.0, 2.0, 0.0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2yWw.jpg", "access": "shaders20k", "license": "mit", "functions": [[1238, 1308, 1333, 1333, 1348], [1350, 1350, 1386, 1386, 1485], [1486, 1556, 1589, 1589, 1615], [1617, 1617, 1647, 1647, 1680], [1682, 1682, 1712, 1712, 1741], [1743, 1743, 1767, 1767, 1899], [1901, 1998, 2071, 2071, 2357], [2360, 2473, 2523, 2523, 2915], [2918, 2978, 3009, 3009, 3115], [3116, 3116, 3147, 3147, 3254], [3255, 3255, 3286, 3286, 3392], [3670, 3737, 3777, 3777, 4296], [4299, 4369, 4394, 4394, 5502], [5509, 5509, 5534, 5534, 5743], [5745, 5745, 5785, 5785, 6115], [6118, 6118, 6192, 6192, 6452], [6454, 6454, 6486, 6486, 6925], [6927, 6927, 6969, 6969, 7268], [7270, 7270, 7309, 7309, 8891], [8893, 8893, 8945, 8945, 9121], [9123, 9123, 9180, 9180, 10470]]}
{"id": "4lBcRm", "name": " Atmospheric spherical", "author": "ollj", "description": "fork of:\nhttps://www.shadertoy.com/view/XtGXWV\n\nimproved but still has a lot of redundancy in it.", "tags": ["sphere", "planet", "scattering", "spherical", "rayleigh", "atmospherics", "mie", "polat"], "likes": 21, "viewed": 1039, "published": "Public API", "date": "1507836534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//ad 3d atmospheric scattering\n//self  : https://www.shadertoy.com/view/4lBcRm\n//parent: https://www.shadertoy.com/view/XtGXWV\n//looks like its very cobbled together, i cleaned it up a but\n//but a lot of it is still redundant.\n\nvec3 lightPosition0 = vec3(1,0,0);\n\n//this atmospheric scatttering is an O(n*O(m*2)) complexity nested loop\n#define iterScatteringOut  20.\n#define iterScatteringIn   20.\n\n//#define eps\t\t\t0.00001\n#define pi\t\t\t\tacos(-1.)\n//why would it need pi*4 ????\n#define pit4 \t\t\t12.566370614359172953850573533118\n\n//atmospheric scattering parameters\n#define PLANET_RADIUS     6.36\n#define ATMOSPHERE_RADIUS 6.42\n#define H0Rayleigh        .13333\n#define H0Mie             .02\n#define KRayleigh         vec3(.058,.135,.331)\n#define KMie              .21\n\n//lib.common\n#define dd(a) dot(a,a)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n\n//carthesian to sphere (and back)\nvec3 c2s(vec3 v){float r=length(v)\n;return vec3(r, atan(v.x,v.z),acos(v.y/r));}\nvec3 s2c(vec3 v)\n{return v.x*vec3(sin(v.z)*sin(v.y),cos(v.z),sin(v.z)*cos(v.y));}\n\n//ray sphere intersection\nvec2 rsiab(vec3 p, vec3 v){return vec2(dd(v),dot(p,v)*2.00001);}\n//2.00001 ommits left shift optimitation issues.\n//return closest intersection of ray and sphere\nvec3 irs(vec3 p,vec3 v,float r){;vec2 a=rsiab(p,v);\n;return p-v*(a.y+sqrt(a.y*a.y-4.*a.x*(dd(p)-r*r)))*.5/a.x;}\n//return distance to ray-sphere interection(s).\nfloat irsfd(vec3 p,vec3 v,float r){vec2 a=rsiab(p,v);\n;return -.5*(a.y+sqrt(a.y*a.y-4.*a.x*dd(p)-r*r))/a.x;}\nvec2 irsfd2(vec3 p,vec3 v,float r){vec2 a=rsiab(p,v);\n;return (vec2(-1,1)*sqrt(a.y*a.y-4.*a.x*(dd(p)-r*r))-a.y)*.5/a.x;}\n\n//scat() is an O(n*O(m*2)) complexity nested loop\n//scatS() is an inner loop of scat()\n//and it is iterated over twice\n//,which seems VERY inefficient and optimizable\n//as in, it interpolates over 2 loops\n// , instead of interpolating within the loop\nvec4 scatS(vec3 a,vec3 b,vec4 k,vec2 o)\n{vec3 s=(b-a)/iterScatteringOut,u=a+s*.5;vec2 r=vec2(0)\n;for(float i=.0;i<iterScatteringOut; ++i\n){float h=(length(u)-PLANET_RADIUS)/(ATMOSPHERE_RADIUS-PLANET_RADIUS)\n ;h=max(.0,h);r+=exp(-h/o);u+=s;\n}r*=length(s);return r.xxxy*k*pit4;}\n\n//a,b,k,h0,lightDir\nvec4 scat(vec3 a,vec3 b,vec4 k,vec2 o,vec3 d)\n{;vec3 s=(b-a)/iterScatteringIn,u=a+s*.5;float stepLength=length(s);\n;vec4 rr=vec4(0)\n;for(float i=.0;i<iterScatteringIn;++i\n){float h=(PLANET_RADIUS-length(u))/(ATMOSPHERE_RADIUS-PLANET_RADIUS)\n ;rr+=exp(-scatS(u,irs(u,-d,ATMOSPHERE_RADIUS),k,o)\n          -scatS(u,a                          ,k,o)\n         )*exp(min(.0,h)/o).xxxy;u+=s;\n}return rr*stepLength*k;}\n\nfloat RayleighPhase(float m){return (3./4.)*(1.+m*m);}\n\nfloat MiePhase(float m){const float g=-.99,h=g*g\n;return (3.*(1.-h)/(2.*(2.+h)))*(1.+m*m)/pow((1.+h-2.*g*m),3./2.);}\n\nvec3 tldg(vec3 l){float t=-.16+iTime\n;return normalize(vec3(l.x*cos(t)+l.y*sin(t)\n,l.x*(-sin(t))+l.y *cos(t),.0));}\n\nvec4 scatter(vec2 u){u.y=1.-u.y\n;vec3 s=vec3(1,(u.x*2.-1.)*pi,u.y*pi),d=s2c(s);s=vec3(.0,PLANET_RADIUS,.0)\n;return 10.*scat(s,s+d*irsfd2(s,d,ATMOSPHERE_RADIUS).y\n,vec4(KRayleigh,KMie),vec2(H0Rayleigh,H0Mie)\n,tldg(normalize(lightPosition0.xyz)));}\n\nfloat ratio(){return mix(iResolution.x/iResolution.y\n                        ,iResolution.y/iResolution.x\n                   ,step(iResolution.x,iResolution.y));}\n\nvoid mainImage( out vec4 o, in vec2 v )\n{vec2 u=v/iResolution.xy\n;u.y=1.-u.y\n;vec3 sphericalDirection=vec3(1,(u.x*2.-1.)*pi,u.y*pi)\n;vec3 d = s2c(sphericalDirection)\n;vec3 l=normalize(lightPosition0.xyz)//sunDirection\n;vec3 tld=tldg(l);\n;vec3 s=vec3(.0,PLANET_RADIUS, .0)\n;vec3 atmospherePos=s+d*irsfd2(s,d,ATMOSPHERE_RADIUS).y\n;const float fov=90.;//looks aas if this was cobbled from many souces. \n;vec2 w=u2((v+.5)/iResolution.xy)*vec2(ratio(),-1);    \n;vec2 p=w*tan(fov*pi/360.0);\n;vec3 rayOrigin=vec3(0); \n;vec3 rayDirection=normalize(vec3(p,-1)-rayOrigin)\n//above is equal to Vec3f(w,-1); \n;vec2 f=c2s(rayDirection).yz/pi;f.x=u5(f.x);\n;vec4 c=scatter(f);\n;float t=-.16 +iTime\n;vec3 sunPos=vec3(l.x*cos(t)+l.y*sin(t),-l.x*sin(t)+l.y*cos(t),.0)\n;float m=dot(d,-sunPos)      \n;o=vec4(c.xyz*RayleighPhase(m)+c.www*MiePhase(m),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBcRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[856, 890, 907, 907, 969], [970, 970, 988, 988, 1051], [1053, 1079, 1106, 1106, 1143], [1144, 1241, 1273, 1273, 1352], [1353, 1401, 1436, 1436, 1509], [1510, 1510, 1545, 1545, 1630], [1632, 1883, 1924, 1924, 2159], [2161, 2181, 2228, 2228, 2590], [2592, 2592, 2621, 2621, 2646], [2648, 2648, 2672, 2672, 2764], [2766, 2766, 2784, 2784, 2881], [2883, 2883, 2904, 2904, 3129], [3131, 3131, 3145, 3145, 3293], [3295, 3295, 3336, 3336, 4130]]}
{"id": "4lBcWh", "name": "Intel HD4400 precision bug", "author": "rohtie", "description": "When the trig functions get a higher input than 12865. it affects the precision significantly.\n\nPlease comment if your graphics card is also affected by this!", "tags": ["bug"], "likes": 0, "viewed": 98, "published": "Public", "date": "1508313296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float time = 12865. + iTime;\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv.x += sin(uv.y * 10. + time);\n    \n    fragColor = vec4(smoothstep(0., 0.1, length(uv) - 0.4));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBcWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 308]]}
{"id": "4lBczV", "name": "Test ground", "author": "luluco250", "description": "I have no idea how to do 3D, this is just a test.", "tags": ["3d", "ground", "vaporwave"], "likes": 3, "viewed": 198, "published": "Public", "date": "1509153314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 colorA = vec3(0.8, 0.3, 0.5);\nconst vec3 colorB = vec3(0.1, 0.4, 0.8);\nconst vec3 colorC = vec3(0.3, 0.8, 0.5);\n\nfloat checker(vec2 coord) {\n    coord = mod(floor(coord), 2.0);\n    return mod(coord.x + coord.y, 2.0);\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    color = vec4(0.0);\n    \n    vec3 cam = vec3(uv * 2.0 - 1.0, 1.0);\n    \n    vec2 cam_uv = cam.xz / cam.y * 2.0;\n    cam_uv.y -= iTime;\n    \n    float ground = uv.y < 0.5 ? checker(cam_uv) : 0.0;\n    \n    color.rgb += mix(colorA, colorB, ground * (1.0 - uv.y) * 0.75);\n    \n    float vignette = smoothstep(0.5, 1.0, distance(uv, vec2(0.5)));\n    \n    color.rgb = mix(color.rgb, colorC, vignette);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBczV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 151, 151, 229], [231, 231, 275, 275, 744]]}
{"id": "4lByz3", "name": "Mandelbrot - Tarea 1", "author": "Benrod", "description": "Tarea 1.", "tags": ["2d", "mandelbrot"], "likes": 0, "viewed": 62, "published": "Public", "date": "1509412614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265358979323846264;\nconst float threshold = 200000.0;\nconst float color_scale = 2.0;\nconst int max_colors = 50;\nconst float inverse_max_colors = 1.0 / float(max_colors);\n\n#define cx_mul(a) vec2(a.x*a.x-a.y*a.y, a.x*a.y + a.y*a.x)\n\nvec4 color_ramp(int i) {\n    // Running the index through cos creates a continous ramp.\n    float normalized_mod = mod(float(i), float(max_colors)) * inverse_max_colors;\n\tfloat normalized_cos = (cos(normalized_mod * 2.0 * PI) + 1.0) * 0.5;\n    i = int(float(max_colors) * normalized_cos);\n\n    float factor = float(i) / float(max_colors);\n    float inverse_factor = 1.0 - factor;\n    // An arbritrary ramp of colors\n    return vec4(sqrt(sqrt(factor)), factor, inverse_factor * 0.5, 1.0);\n}\n\nvec4 color_from_ramp(int i, float f) {\n\tvec4 first = color_ramp(i);\n\tvec4 second = color_ramp(i + 1);\n    return first * (1.0 - f) + second * f;\n}\n\nvec4 color_from_iteration(vec2 z, int i) {\n    // Continuous coloring\n    float s = float(i) + log2(log(threshold)) - log2(log(length(z)));\n    s *= color_scale;\n    int first = int(floor(s));\n    return color_from_ramp(first, s - float(first));\n}\n\n\nvoid mainImage( out vec4 f, in vec2 pixel_xy )\n{\n    float n = 0.;\n    \n    // Lugar de acercamiento de la vista\n    vec2 focus = vec2(-.745, .186);\n    vec2 c = focus + 3. * (pixel_xy / iResolution.y - .5) * pow(.01, 1. + cos(.2 * iTime)), \n         z = c * n;\n    int iteraciones_de_borde = 128;\n    \n    int final_i;\n    for (int i = 0; i < iteraciones_de_borde; i++) {\n        final_i = i;\n\n        if (length(z) >= threshold) {\n            break;\n        }\n\n        // z^P + c, P = 2  gives us  z^2 + c\n        z = cx_mul(z) + c;\n    }\n    // Generacion de la representaciÃ³n de Mandelbrot en la dimension de colores RGBA\n    f = color_from_iteration(z, final_i);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lByz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[255, 255, 279, 342, 744], [746, 746, 784, 784, 892], [894, 894, 936, 963, 1141], [1144, 1144, 1192, 1192, 1814]]}
{"id": "4lByzR", "name": "Ellipse intersection test", "author": "jon_valdes", "description": "Quick test for fast sphere-grid intersection based on the projected sphere's ellipse major and minor axes", "tags": ["ellipse"], "likes": 2, "viewed": 143, "published": "Public", "date": "1507068340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytic projection of a sphere to screen pixels. \n\n// Spheres in world space become ellipses when projected to the camera view plane. In fact, these\n// ellipses can be analytically determined from the camera parameters and the sphere geometry,\n// such that their exact position, orientation and surface area can be compunted. This means that,\n// given a sphere and a camera and buffer resolution, there is an analytical formula that \n// provides the amount of pixels covered by a sphere in the image. This can be very useful for\n// implementing LOD for objects based on their size in screen (think of trees, vegetation, characters\n// or any other such complex object).\n\n// This shaders implements this formula, and provides too the center and axes of the ellipse\n\n// More info, here: http://www.iquilezles.org/www/articles/sphereproj/sphereproj.htm\n\n// ---------------------------------------------------------------------------------------------\n\nstruct ProjectionResult\n{\n    vec2  center;\n    float axisMinor;\n    float axisMajor;\t\n\tfloat a, b, c, d, e, f;\n};\n\nProjectionResult projectSphere( /* sphere        */ in vec4 sph, \n\t\t\t\t                /* camera matrix */ in mat4 cam,\n\t\t\t\t\t\t\t    /* projection    */ in float fle )\n{\n    // transform to camera space\t\n\tvec3  o = (cam*vec4(sph.xyz,1.0)).xyz;\n\t\n    float r2 = sph.w*sph.w;\n\tfloat z2 = o.z*o.z;\t\n\tfloat l2 = dot(o,o);\n\t\t\n\t\n    float l = length(o.xy);\n\t\n\t// axis\n\tfloat axa = fle*sqrt(-r2*(r2-l2)/((l2-z2)*(r2-z2)*(r2-z2)))*l;\n\tfloat axb = fle*sqrt(-r2*(r2-l2)/((l2-z2)*(r2-z2)*(r2-l2)))*l;\n\n\t\n\t// center\n\tvec2  cen = fle*o.z*o.xy/(z2-r2);\n\n\treturn ProjectionResult(\n\t\t\t\t\t\t\t cen, min(axa, axb), max(axa, axb), \n                     /* implicit ellipse f(x,y) = aÃÂ·xÃÂ² + bÃÂ·yÃÂ² + cÃÂ·xÃÂ·y + dÃÂ·x + eÃÂ·y + f = 0 */\n                     /* a */ r2 - o.y*o.y - z2,\n                     /* b */ r2 - o.x*o.x - z2,\n                     /* c */ 2.0*o.x*o.y,\n                     /* d */ 2.0*o.x*o.z*fle,\n                     /* e */ 2.0*o.y*o.z*fle,\n                     /* f */ (r2-l2+z2)*fle*fle );\n}\n\n\nvec2 toNormalizedCoords(vec2 pos){\n\treturn vec2(-iResolution.xy + 2.0*pos) / iResolution.y;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = toNormalizedCoords(fragCoord);\n\t\n\tfloat fov = 1.0;\n\t\n\tfloat an = 12.0 + 0.5*iTime + 10.0*iMouse.x/iResolution.x;\n\tvec3 ro = vec3( 3.0*cos(an), 0.0, 3.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + fov*ww );\n\tmat4 cam = mat4( uu.x, uu.y, uu.z, 0.0,\n\t\t\t\t\t vv.x, vv.y, vv.z, 0.0,\n\t\t\t\t\t ww.x, ww.y, ww.z, 0.0,\n\t\t\t\t\t -dot(uu,ro), -dot(vv,ro), -dot(ww,ro), 1.0 );\n\t\n\tvec4 sph1 = vec4(-2.0, 1.0,0.0,1.1);\n\tvec4 sph2 = vec4( 3.0, 1.5,1.0,1.2);\n\tvec4 sph3 = vec4( 1.0,-1.0,1.0,1.3);\n\n\t\n\tvec3 col = vec3(0.0);\n\n    //-------------------------------------------------------\n\t\n\tProjectionResult res = projectSphere( sph3, cam, fov );\n\n\t//-------------------------------------------------------\n    \n    float cellX = floor(fragCoord.x / 32.) * 32.;\n    float cellY = floor(fragCoord.y / 32.) * 32.;\n    \n    vec2 cellCenter = toNormalizedCoords( vec2(cellX,cellY) + vec2(16));\n    float cellBoundingRadius = sqrt(8. / iResolution.y);\n    float cellToSphereCenterDist = length(res.center - cellCenter);\n    \n    \n\t// Draw conservative inside region\n    \n    if(cellToSphereCenterDist < cellBoundingRadius+res.axisMajor){\n        col += vec3(0.7,0,0);   \n    }\n    \n\t// Draw trivial accept region\n    if(cellToSphereCenterDist < 8./iResolution.x + res.axisMinor){\n        col = mix(col, vec3(0.7,1.7,1.0), 0.5);   \n    }\n\n    // Draw inner circle\n    if(abs(length(p - res.center) - res.axisMinor) < 0.005){\n     \tcol = vec3(1.3,1.0,1.3);   \n    }\n    \n    // Draw outer circle\n    if(abs(length(p - res.center) - res.axisMajor) < 0.005){\n     \tcol = vec3(1.,0.3,0.3);   \n    }\n\n    float v = res.a * p.x * p.x + res.b * p.y * p.y + res.c * p.x * p.y + res.d * p.x + res.e * p.y + res.f;\n\tif(v>0.){\n\t\tcol = mix(col, vec3(0.6,0.6,1.7), 0.5);\n\t}\n    \n    // Draw grid\n    if( (abs(fragCoord.x - cellX) < 1.) ||\n        (abs(fragCoord.y - cellY) < 1.)){\n        col = mix(col, vec3(0.6), 0.5);\n        \n    }\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lByzR.jpg", "access": "shaders20k", "license": "mit", "functions": [[1933, 2147, 2313, 2347, 3153], [3156, 3156, 3190, 3190, 3254], [3256, 3256, 3313, 3313, 5429]]}
{"id": "4lfyWs", "name": "spherical barcode thing", "author": "Tuxic", "description": "I wanted to have fun in spherical coords", "tags": ["procedural", "2d", "generative"], "likes": 5, "viewed": 429, "published": "Public API", "date": "1506894880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) {\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*(43758.5453 + iTime));\n}\n\nfloat random( vec2 p ) {\n\treturn fract(sin(dot(p,vec2(269.5,183.3)))*(43758.5453 + iTime / 5.0));\n}\n\nmat2 rotate2d(float _angle){\n\treturn mat2(cos(_angle),-sin(_angle),\n\t\t\t\tsin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 pos = vec2(0.5, 0.5) - uv;\n    pos.x *= iResolution.x / iResolution.y;\n\tfloat r = length(pos) * 16. - cos(iTime) / 2.0;\n\tfloat a = atan(pos.y,pos.x);\n\tfloat currentLine = floor(r);\n\tvec2 sphericalPos = vec2(cos(a), sin(a)) / 2.0;\n\tsphericalPos = sphericalPos * rotate2d(random(vec2(currentLine,0)) * sin(iTime) * 2.);\n\tfloat value = step(1., mod(currentLine, 2.0));\n\tfloat color = step(0.15, abs(random(vec2(floor((sphericalPos.x + sphericalPos.y) * 36. * currentLine), currentLine))));\n\tvec4 col = vec4(color, color, color, 1) / 2.0;\n\tvec4 modifier = vec4(abs(cos(iTime)), uv * rotate2d(random(vec2(currentLine,0))), 1);\n\tcol += modifier;\n\tif(currentLine < 2.) col = modifier;\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 124], [126, 126, 150, 150, 225], [227, 227, 255, 255, 326], [328, 328, 385, 385, 1131]]}
{"id": "4ljcRW", "name": "Worming", "author": "duvengar", "description": "Having fun with another variation on the Truchet Theme. Inspired and derived from [url=https://www.shadertoy.com/view/llfyWX]Simple_animated_Truchet[/url] by @Shane\nMouse control the flow direction.", "tags": ["2d", "truchet", "flow", "polar", "worm"], "likes": 12, "viewed": 269, "published": "Public", "date": "1507653240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Worming by julien Vergnaud @duvengar-2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ====================================================================\n\n// Derived from Simple_animated_Truchet by @Shane\n// [url]https://www.shadertoy.com/view/llfyWX[/url]\n\n// Mouse control direction\n\n\n#define PI     3.14159265359\n#define TWO_PI (PI*2.)\n\n// vec2 to float hash function taken from @Shane - Based on IQ's original.\n\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.867)))*43758.5453); }\n\n// Standard 2D rotation formula.\n\nmat2 rot(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// polynomial smooth min\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\n\n//distance field circle\n\nfloat df_circle(vec2 pos, float rad){\n\n    return (length(pos)-rad);  \n}\n\n\n\n\n\nvoid mainImage( out vec4 c, in vec2 uv )\n{\n    \n    // I   //  Screen coordinates is formated to go from -1. to 1.\n    \n\tvec2 p = -1.+ 2.* uv / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n    \n      \n   \n    // II  //  Moove & Rescale screen space\n    \n    p *= 1. + dot(p, p)*.05;        // fish eye\n    p += vec2(.0, iTime/12.);       // moove along Y axis\n    p *= .7*floor(iResolution.x/200.); // rescale space\n \n    \n \t// III //  Make truchet lines\n           //  store tile id & Divide screen into grid \n    \t   //  & store direction in a checkerboard way.\n\t\n    vec2 id = floor(p);\n    \n           // replacing Shane's float dir = sign(mod(id.x + id.y, 2.) - .5);\n           // The sign() seems to be dispensable\n    \n    float dir = mod(id.x + id.y, 2.)-.5;  \n    p = fract(p) - .5;  // or // p -= id + .5; \n        \n           //  Truchet tiles orientation randomisation\n    \n\tp.y *= hash21(id) > .5 ? 1. : -1.;\n    \n           //  Applying symetry on diagonal axis to avoid drawing two arcs\n           //  Tricks form @shane\n    \n    p *= sign(p.x + p.y);\n      \n           //  Drawing the two arc's strokes directly with a tickness of t\n           //  The tricks to draw a contour was taken from a @FabriceNeyret2 \n           //  comment in this shader https://www.shadertoy.com/view/MtXyWX\n    \n    p              -= .5; \n    float t         = .12; \n    float t2        = .05;    \n    float line      = abs(length(p ) - .5) - t *1.5 ;\n    float line_str  = abs(length(p ) - .5) - t2 * .3;\n    float line_out  = max(line, -line -.01);\n    float line_glow = abs(length(p ) - .5) - t2 * 2.;\n      \n           //  Adjusting the arcs clarity (I don't know how to call that)\n    \n    line     = 1. - smoothstep(.01,.1, sqrt(line));\n    line_str = 1. - smoothstep(.01,.3, sqrt(line_str));\n    line_glow = 1. - smoothstep(.01,.5, sqrt(line_glow));\n  \n    // IV  //  RENDER CHAIN\n    \n            //  Animate flow\n     \n    vec2 pos = p ;\n    \n    if(iMouse.z > 0.){\n    \tfloat m = smoothstep(.0,-1. + 2. * iResolution.x, -1. + 2. * iMouse.x);\n        m*= 20.;\n    \tpos *= rot(m*dir);\n    }else{\n        pos *= rot(iTime*dir);\n    }\n\n            //  Part into cells  & convert into polar coordinates\n     \n    const float num = 16.;                       // partitions number\n    float ang = atan(pos.y, pos.x);              // Pixel angle.               \n    float ctr = floor(ang / TWO_PI * num ) + .5; // the cell center.\n\n    pos  = rot(ctr  *(PI*2.) / num) *pos;        // Converting to polar coordinates\n \t \n    pos.x -= .5;                                 // p.x = radius, p.y = angle.\n                                                 // Translate coordinates\n    \n            //  render the objects in each slices\n      \n              \n    float ring2 = smoothstep(0.0, .01, df_circle(pos, .165)); \n    \n        \n    \n    ///////////////////////////////////////////////////////////////////////////////\n    \n   \n    \n    // V  //   Coloring\n    \n    float tex = .7 * sin(2. * cos(3. * uv.x + uv.y) - hash21(uv));     \n \n\n  \n    c = vec4(.0);\n \n    c = .1*vec4(tex-.5);                                              // small amout off texture\n    \n    c += vec4(line -smoothstep(.0,.08,line_out*cos(sin(ang*45.))));   // base shape \n    \n    c += mix(vec4(.2, .9, .8, 1.),c, .2);                             //base color\n    c += mix(vec4(.2, .9, .8, 1.),c, .2); \n     \n    c += .45*vec4(cos(sin(ang)));                                     // base lighting based on angle  \n    c *= .45*vec4(cos(sin(ang))); //\n    \n    c *= mix(c,vec4(cos(sin(ang*5.)),cos(sin(ang*5.)),1.,1.),.5);     // more color based angle\n                   \n    c += line * vec4(cos(sin(ang*2.)), .0, 0., 0.);                   // angle*2 is red\n    c *= 1.-ring2+(line_str*cos(sin(ang*10.)));\n    c *= .5 + vec4(.2,.9,.7,.0);                                      // color balance\n    \n    c+= (smoothstep(-.1,.7,tex*line_out));                            // backgground texture\n    c -= .4*mix(c,vec4(-.1*cos(sin(ang*3.)),.1,-.1*cos(sin(ang*3.)),1.),.5); \n     vec2 uu  = 1. - 2. * uv / iResolution.xy;                        // vigneting\n    float v  = 1. - smoothstep(.7, 1.4, length(uu*uu*uu)) * 2.;\n    c *= vec4(v);   \n    c = mix(c,vec4(.0,.0,.1,1.),.3);\n    c += .4*vec4(smoothstep(.0,.9,line_glow*ring2));                  // a bit of glow\n    c /= .7/pow(c,c);                                                 // lighten more\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljcRW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[390, 466, 487, 487, 551], [553, 587, 608, 608, 666], [668, 694, 735, 735, 842], [844, 869, 906, 906, 941], [947, 947, 989, 1061, 5380]]}
{"id": "4ljcWm", "name": "Unity BRDF", "author": "dmemes", "description": "Unity standard BRDF, available at https://unity3d.com/get-unity/download/archive (UnityStandardBRDF.cginc). Based off Disney's work.\nI'm still trying to learn how it works.\nmouse left->right: increasing smoothness\nmouse top->bottom: increasing metallic", "tags": ["brdf", "unity"], "likes": 7, "viewed": 905, "published": "Public", "date": "1508838692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.141592654\n#define INV_PI 0.3183098862\n#define DielectricSpec vec4(0.22, 0.22, 0.22, 0.779)\n#define CellSize (1.0 / 3.0)\n#define LightColor vec3(1.0, 1.0, 1.0)\n// Border in pixels\n#define Border 1.0\n#define GridLayout 0\n#define Ambient vec3(.2)\n\nfloat Pow5(float x) {\n    return x*x*x*x*x;\n}\nvec3 DiffuseAndSpecularFromMetallic (vec3 albedo, float metallic, out vec3 specColor, out float oneMinusReflectivity) {\n    specColor = mix (DielectricSpec.rgb, albedo, metallic);\n    float oneMinusDielectricSpec = DielectricSpec.a;\n    oneMinusReflectivity = oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n    return albedo * oneMinusReflectivity;\n}\n\nfloat SmithJointGGXVisibility(float NdotL, float NdotV, float roughness) {\n    // Approximation (simplify sqrt)\n    float a = roughness;\n    float lambdaV = NdotL * (NdotV * (1.0 - a) + a);\n    float lambdaL = NdotV * (NdotL * (1.0 - a) + a);\n\n    return 0.5 / (lambdaV + lambdaL + 1e-5);\n}\nfloat GGX(float NdotH, float roughness) {\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0;\n    return INV_PI * a2 / (d * d + 1e-7);\n}\nvec3 Fresnel(vec3 F0, float cosA) {\n    float t = Pow5(1.0 - cosA); // ala Schlick interpoliation\n    return F0 + (1.0 - F0) * t;\n}\nvec3 FresnelLerp(vec3 F0, vec3 F90, float cosA) {\n    float t = Pow5 (1.0 - cosA); // ala Schlick interpoliation\n    return mix(F0, F90, t);\n}\n\nfloat DisneyDiffuse(float NdotV, float NdotL, float LdotH, float perceptualRoughness){\n    float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    float lightScatter   = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotL));\n    float viewScatter    = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotV));\n\n    return lightScatter * viewScatter;\n}\n\nvec3 Background(vec3 rd, vec3 light){\n    vec3 col = vec3(0.0);\n    \n    float y = max(rd.y,0.0);\n    col = vec3(pow(1.0-y,2.0), 1.0-y, 0.6+(1.0-y)*0.4);\n    \n    if (y < 0.1)\n    \tcol = mix(col, vec3(0.5), clamp(-(y - .1) * 10.0, 0.0, 1.0));\n    \n    float sun = dot(rd, light);\n    if (sun > 0.0)\n        col += vec3(pow(sun, 5.0));\n        \n    return col;\n}\n\nvec3 BRDF(vec3 albedo, float metallic, float  smoothness, vec3 normal, vec3 view, vec3 light){\n    float oneMinusReflectivity;\n    vec3 specular;\n    vec3 diffuse = DiffuseAndSpecularFromMetallic(albedo, metallic, specular, oneMinusReflectivity);\n    \n    vec3 halfdir = normalize(view + light);\n    float nv = abs(dot(normal, view));\n    \n    float nl = saturate(dot(normal, light));\n    float nh = saturate(dot(normal, halfdir));\n    float lv = saturate(dot(light, view));\n    float lh = saturate(dot(light, halfdir));\n    \n    float diff = DisneyDiffuse(nv, nl, lh, 1.0 - smoothness) * nl;\n    float roughness = (1.0 - smoothness) * (1.0 - smoothness);\n\t\n    roughness = max(.002, roughness);\n    float V = SmithJointGGXVisibility(nl, nv, roughness);\n    float D = GGX(nh, roughness);\n    \n    float spec = V * D * PI;\n    spec = max(0.0, spec * nl);\n    \n    float surfaceReduction = 1.0 / (roughness * roughness + 1.0);\n    vec3 grazing = vec3(saturate(smoothness + oneMinusReflectivity));\n    \n    // vec3 reflected = Background(reflect(view,normal), light); TODO\n    \n    return \n        diffuse * (Ambient + diff * LightColor)\n        + spec * specular * LightColor * Fresnel(specular, lh);\n        + surfaceReduction * specular * FresnelLerp(specular, grazing, nv);\n}\n\nvec2 RaySphere(in vec3 ro, in vec3 rd, in float rad) {\n\tfloat b = 2.0 * dot(ro, rd);\n    float c = dot(ro,ro) - rad*rad;\n    float det = b*b - 4.0 * c;\n    if (det > 0.0){\n        det = sqrt(det);\n        vec2 i = vec2(0.5 * (-b - det), 0.5 * (-b + det));\n    \tif (i.x > i.y) return i.yx;\n        return i.xy;\n    }\n    return vec2(-1.0, -1.0);\n}\nvec3 trace(vec3 ro, vec3 rd, float radius, vec3 albedo, float metallic, float smoothness){\n    vec3 light = normalize(\n        vec3(\n            sin(iTime),\n            cos(iTime),\n            -(1.0-sin(iTime * 1.2 + .5) * cos(iTime * .5)*.5+.5)));\n    \n    vec2 intersect = RaySphere(ro, rd, radius);\n    \n    if (intersect.x > 0.0 && intersect.y > 0.0){\n        vec3 normal = normalize(ro + rd * intersect.x);\n        \n        return BRDF(albedo, metallic, smoothness, normal, rd, light);\n    }\n    \n    return Background(rd, light);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = fragCoord;\n    vec2 size;\n    float metallic, smoothness;\n    \n    vec3 albedo = vec3(\n        sin(iTime),\n        cos(iTime* 1.1),\n        sin(iTime * .8 - .5)) * .5 + .5;\n    \n    #if GridLayout\n    size = iResolution.xy * CellSize;\n    vec2 cell = floor(coord / size);\n    \n    metallic = cell.x * CellSize;\n    smoothness = 1.0 - cell.y * CellSize\n    \n    coord = mod(coord, size);\n    \n    \n    if (coord.x < Border || coord.x > size.x - Border || coord.y < Border || coord.y > size.x - Border){\n        fragColor = vec4(albedo, 1.0);\n        return;\n    }\n    #else\n    size = iResolution.xy;\n    metallic = 1.0 - iMouse.y / iResolution.y;\n    smoothness = iMouse.x / iResolution.x;\n    #endif\n    \n\tvec3 rd = vec3(coord / size, 0.0);\n    rd = rd * 2.0 - 1.0;\n    rd.y *= size.y / size.x;\n    rd = normalize(vec3(rd.xy, 1.0));\n    \n    vec3 color = trace(vec3(0.0, 0.0, -2.5), rd, 1.0, albedo, metallic, smoothness);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljcWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 297, 318, 318, 342], [343, 343, 462, 462, 706], [708, 708, 782, 819, 998], [999, 999, 1040, 1040, 1171], [1172, 1172, 1207, 1207, 1303], [1304, 1304, 1353, 1353, 1446], [1448, 1448, 1534, 1534, 1812], [1814, 1814, 1851, 1851, 2175], [2177, 2177, 2271, 2271, 3453], [3455, 3455, 3509, 3509, 3801], [3802, 3802, 3892, 3892, 4339], [4341, 4341, 4398, 4398, 5380]]}
{"id": "4ljcWw", "name": "Atmosphere Scattering Optimized", "author": "bobcao3", "description": "Adapted from https://www.shadertoy.com/view/ldS3Wm\n\nAn optimized version, uses much less samples (32 times less iterations, similar result)", "tags": ["3d", "scattering"], "likes": 4, "viewed": 343, "published": "Public", "date": "1508812268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ============\nconst float R0 = 600e3;\nconst float Ra = 670e3;\nconst int steps = 2;\nconst int stepss = 2;\nconst float g = .76;\nconst float g2 = g * g;\nconst float Hr = 15e3;\nconst float Hm = 2.6e3;\nconst vec3 I = vec3(10.0);\n\n#define t iTime\n\nconst vec3 C = vec3(0., -R0, 0.);\nconst vec3 bM = vec3(31e-6);\nconst vec3 bR = vec3(5.8e-6, 13.5e-6, 33.1e-6);\nvec3 Ds = normalize(vec3(0., .09, -1.));\n\n\nvoid densities(in vec3 pos, out float rayleigh, out float mie) {\n\tfloat h = length(pos - C) - R0;\n\trayleigh =  exp(-h/Hr);// + exp(-max(0.0, (h - 35e3)) /  5e3) * exp(-max(0.0, (35e3 - h)) / 15e3) * 0.2;\n\tmie = exp(-h/Hm);\n}\n\nfloat escape(in vec3 p, in vec3 d, in float R) {\n\tvec3 v = p - C;\n\tfloat b = dot(v, d);\n\tfloat c = dot(v, v) - R*R;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return -1.;\n\tfloat det = sqrt(det2);\n\tfloat t1 = -b - det, t2 = -b + det;\n\treturn (t1 >= 0.) ? t1 : t2;\n}\n\n// this can be explained: http://www.scratchapixel.com/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 scatter(vec3 o, vec3 d) {\n\tfloat L = escape(o, d, Ra);\t\n\tfloat mu = dot(d, Ds);\n\tfloat opmu2 = 1. + mu*mu;\n\tfloat phaseR = .0596831 * opmu2;\n\tfloat phaseM = .1193662 * (1. - g2) * opmu2 / ((2. + g2) * pow(1. + g2 - 2.*g*mu, 1.5));\n\t\n\tfloat depthR = 0., depthM = 0.;\n\tvec3 R = vec3(0.), M = vec3(0.);\n    \n    float u0 = -(L - 100.0) / (1.0 - exp2(float(steps)));\n    \n\tfor (int i = 0; i < steps; ++i) {\n        float dl = u0 * exp2(float(i));\n\t\tfloat l = - u0 * (1.0 - exp2(float(i + 1)));\n\t\tvec3 p = o + d * l;\n\n\t\tfloat dR, dM;\n\t\tdensities(p, dR, dM);\n\t\tdR *= dl; dM *= dl;\n\t\tdepthR += dR;\n\t\tdepthM += dM;\n\n\t\tfloat Ls = escape(p, Ds, Ra);\n\t\tif (Ls > 0.) {\n\t\t\tfloat dls = Ls / float(stepss);\n\t\t\tfloat depthRs = 0., depthMs = 0.;\n\t\t\tfor (int j = 0; j < stepss; ++j) {\n\t\t\t\tfloat ls = float(j) * dls;\n\t\t\t\tvec3 ps = p + Ds * ls;\n\t\t\t\tfloat dRs, dMs;\n\t\t\t\tdensities(ps, dRs, dMs);\n\t\t\t\tdepthRs += dRs;\n\t\t\t\tdepthMs += dMs;\n\t\t\t}\n            depthRs *= dls;\n            depthMs *= dls;\n\t\t\t\n\t\t\tvec3 A = exp(-(bR * (depthRs + depthR) + bM * (depthMs + depthM)));\n\t\t\tR += A * dR;\n\t\t\tM += A * dM;\n\t\t} else {\n\t\t\treturn vec3(0.);\n\t\t}\n\t}\n\t\n\treturn I * (R * bR * phaseR + M * bM * phaseM);\n}\n\nvoid ACEStonemap(inout vec3 color) {\n\tconst float a = 2.51f;\n\tconst float b = 0.03f;\n\tconst float c = 2.43f;\n\tconst float d = 0.59f;\n\tconst float e = 0.14f;\n\tcolor = (color*(a*color+b))/(color*(c*color+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tDs = normalize(vec3(iMouse.x / iResolution.x - .5, sin(t * 0.5), cos(t * 0.5)));\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 O = vec3(0., 0., 0.);\n\tvec3 D = normalize(vec3(uv, -2.));\n\t\n\tfloat att = 1.;\n    if (D.y < 0.0) {\n        D.y = 0.0016 / (-D.y + 0.04) - 0.04;\n    }\n\n    vec3 color = att * scatter(O, D);\n\tACEStonemap(color);\n\tfragColor = vec4(pow(color, vec3(.454545)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljcWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 398, 462, 462, 622], [624, 624, 672, 672, 886], [888, 1028, 1058, 1058, 2205], [2207, 2207, 2243, 2243, 2417], [2419, 2419, 2476, 2476, 2921]]}
{"id": "4ljXRc", "name": "dithering: i32uni to i16tri hash", "author": "hornet", "description": "test of idea by Sebastian Sylvan: https://twitter.com/ssylvan/status/922710051269120000\ncalc single 32bit hash, use lower/upper 16bits separately (see n2rand_split())\nint-hash stolen from the awesome Marc B Reynolds, https://www.shadertoy.com/view/4dlcR4", "tags": ["noise", "dithering"], "likes": 6, "viewed": 247, "published": "Public", "date": "1508845296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_BUCKETS = 32;\nconst int ITER_PER_BUCKET = 1024;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\n\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat truncate( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\n// each dim is defective when zero\nuint hash(uint x, uint y)\n{\n    #define W0 0x3504f333u   // 3*2309*128413 \n\t#define W1 0xf1bbcdcbu   // 7*349*1660097 \n\t#define M  741103597u    // 13*83*686843\n\n  \tx *= W0;   // x' = Fx(x)\n  \ty *= W1;   // y' = Fy(y)\n  \tx ^= y;    // combine\n    x *= M;    // MLCG constant\n  \treturn x;\n}\nfloat hash_st( vec2 uv )\n{\n    uvec2 p = uvec2( uv * iResolution.xy );\n  \tuint h = hash( p.x, p.y );\n  \n  \tuint h_lo = (h & 0x0000ffffu);\n  \tuint h_hi = (h & 0xffff0000u)>>16;\n    \n    float f0 = float(h_lo) / 65536.0;\n    float f1 = float(h_hi) / 65536.0;\n    \n    return f0+f1-1.0;\n}\nfloat n2rand_split( vec2 n )\n{\n\tfloat t = fract( iTime );\n    return hash_st( n + 83.0*t)*0.5+0.5;\n}\n\n\n// ====\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\nfloat n2rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\nfloat n3rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\treturn (nrnd0+nrnd1+nrnd2) / 3.0;\n}\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n}\n\nfloat n8rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    \n    float nrnd4 = nrand( n + 0.19*t );\n    float nrnd5 = nrand( n + 0.23*t );\n    float nrnd6 = nrand( n + 0.29*t );\n    float nrnd7 = nrand( n + 0.31*t );\n    \n\treturn (nrnd0+nrnd1+nrnd2+nrnd3 +nrnd4+nrnd5+nrnd6+nrnd7) / 8.0;\n}\n\n// ====\n\nfloat histogram( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( truncate(t,NUM_BUCKETS_F), truncate(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)/ITER_PER_BUCKET_F;\n\t\t\n\t\tfloat r;\n\t\tif ( iter < 2 )\n\t\t\tr = 0.0; //n1rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<3 )\n\t\t\tr = n2rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<4 )\n\t\t\tr = n2rand_split( vec2(uv.x,0.5) + seed );\n\t\telse\n\t\t\tr = 0.0; //n8rand( vec2(uv.x,0.5) + seed );\n\t\t\n\t\tbucketval += step(bucket.x,r) * step(r,bucket.y);\n\t}\n\tbucketval /= ITER_PER_BUCKET_F;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y / height, bucketval );\n    float v1 = step( (uv.y-1.0/iResolution.y) / height, bucketval );\n    float v2 = step( (uv.y+1.0/iResolution.y) / height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\n\n// ====\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat o;\n    int idx;\n    vec2 uvrange;\n\tif ( uv.x < 1.0/4.0 )\n\t{\n\t\t//o = n1rand( uv );\n        //idx = 1;\n        //uvrange = vec2( 0.0/4.0, 1.0/4.0 );\n\t}\n\telse if ( uv.x < 2.0 / 4.0 )\n\t{\n\t\to = n2rand( uv );\n        idx = 2;\n        uvrange = vec2( 1.0/4.0, 2.0/4.0 );\n\t}\n\telse if ( uv.x < 3.0 / 4.0 )\n\t{\n\t\to = n2rand_split( uv );\n        idx = 3;\n        uvrange = vec2( 2.0/4.0, 3.0/4.0 );\n\t}\n\telse\n\t{\n\t\t//o = n8rand( uv );\n        //idx = 4;\n        //uvrange = vec2( 3.0/4.0, 4.0/4.0 );\n\t}\n\n    //display histogram\n    if ( uv.y < 1.0 / 4.0 )\n\t\to = 0.125 + histogram( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );\n    \n\t//display lines\n\tif ( abs(uv.x - 1.0/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 2.0/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 3.0/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.y - 1.0/4.0) < 0.002 ) o = 0.0;\n\n\t\n\tfragColor = vec4( vec3(o), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljXRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 253, 276, 276, 344], [345, 389, 431, 431, 475], [476, 506, 542, 542, 566], [568, 603, 630, 630, 892], [893, 893, 919, 919, 1178], [1179, 1179, 1209, 1209, 1279], [1282, 1291, 1315, 1315, 1395], [1396, 1396, 1420, 1420, 1550], [1551, 1551, 1575, 1575, 1747], [1748, 1748, 1772, 1772, 1987], [1989, 1989, 2013, 2013, 2419], [2421, 2430, 2510, 2510, 3355], [3357, 3366, 3423, 3423, 4324]]}
{"id": "4ljyD1", "name": "First Spiral", "author": "dickie", "description": "first experiment with shader toy, just trying it out :)", "tags": ["spiral"], "likes": 0, "viewed": 90, "published": "Public", "date": "1508418484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.141592\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float turns = 4.0 ;\n    float speed = -0.333;\n    bool invert = false;\n    \n    \n\tvec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    float angle = atan(uv.y, uv.x) / (2.*M_PI);\n    angle = fract(angle + (iTime * speed));\n    \n\t\n    float dist = length(uv);\n    float waves = fract( dist  * turns) ;\n    \n    float spiral = (abs(angle - waves)  - 0.5) * 2.0;\n    spiral = (spiral*spiral * spiral * spiral);\n\t\n    if(!invert)\n        spiral = 1.0 - spiral;\n    \n    spiral *= clamp(dist * (turns / 2.0), 0.0,1.0);\n\tfragColor = vec4(spiral);\n}\n\n\n/*\n\n#define M_PI 3.141592\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float turns = 4.0;\n    float speed = 0.333;\n    \n    //float pinch = 1.05;\n    // experimenting with pinching but it's way more relaxing without\n    float pinch = 1.0; // change to 1.1 or greater to see pinches\n    float pinches = 10.0;\n    float pinchSpeed = 0.5;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = ((uv.x - 0.5) / (iResolution.y / iResolution.x)) + 0.5;\n    \n    float angle = ((atan(uv.y - 0.5, uv.x - 0.5) / M_PI) + 1.0) * 0.5;\n    angle = fract(angle + (iTime * speed) );\n    \n    float pinchPoints = pow(abs(0.5 - fract(angle * pinches)) * 2.0, 2.0);\n    pinchPoints = mix( 1.0, mix( pinch, 1.0, sin(iTime * pinchSpeed)), pinchPoints);\n\t\n    float dist = distance(uv, vec2(0.5,0.5));\n    float waves = fract( dist * pinchPoints * turns) ;\n    \n    float spiral = abs(abs(angle - waves)  - 0.5) * 2.0;\n    spiral = 1.0 - pow(spiral, 2.0);\n    spiral *= clamp(dist * (turns / 2.0), 0.0,1.0);\n    float result = spiral;\n    //float result = waves;\n    fragColor = vec4(result, result, result,1.0);\n\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljyD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 644]]}
{"id": "4ljyRK", "name": "Primes - Gaussian", "author": "iq", "description": "Gaussian primes: [url]http://mathworld.wolfram.com/GaussianPrime.html[/url]", "tags": ["2d", "gaussian", "prime", "primes"], "likes": 4, "viewed": 702, "published": "Public API", "date": "1509251994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2017\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// Gaussian primes: http://mathworld.wolfram.com/GaussianPrime.html\n//\n// Regular primes: https://www.shadertoy.com/view/4slGRH\n\nbool isPrime( int x )\n{\n\tif( x==1 ) return false;\n\tif( x==2 ) return true;\n\tif( x==3 ) return true;\n\tif( x==5 ) return true;\n\tif( x==7 ) return true;\n\tif( (x&1)==0 ) return false;\n\tif( (x%3)==0 ) return false;\n\tif( (x%5)==0 ) return false;\n\n    int xm = 1 + int(sqrt(float(x)));\n    \n\tint y = 7;\n\tfor( int i=0; i<100; i++ ) // count up to 3000 (100*30). See  http://www.iquilezles.org/blog/?p=1558\n\t{\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm    ) return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t}\n\t\n\treturn true;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = exp2( -(2.0 + 2.0*cos(6.2831*iTime/20.0)) );\n    ivec2 p = ivec2( floor((fragCoord-iResolution.xy*0.5)*s) );\n    \n    p = abs(p);\n    \n    \n    bool isPr = false;\n    \n    if( p.x==0 ) \n    {\n        isPr = isPrime(p.y) && ((p.y&3)==3);\n    }\n    else if( p.y==0 ) \n    {\n        isPr = isPrime(p.x) && ((p.x&3)==3);\n    }\n    else\n    {\n        isPr = isPrime(p.x*p.x+p.y*p.y);\n    }\n    \n    if( p.x==1 && p.y==1 ) isPr = true;\n    \n    fragColor = vec4( isPr?vec3(0.5,1.0,0.0):vec3(0.0), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljyRK.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[597, 726, 749, 749, 1779], [1783, 1783, 1840, 1840, 2354]]}
{"id": "4ljyWD", "name": "âspheres", "author": "brackss1", "description": "There are only infinite spheres.", "tags": ["3d"], "likes": 0, "viewed": 59, "published": "Public", "date": "1508640255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float radius = .1, EPS = .001;\n\nfloat getNLP(float x){\n    \n    return (fract(x)<.1)? floor(x) : ceil(x);\n}\n\nvec3 getNLP(vec3 p){\n    \n    return vec3(getNLP(p.x), getNLP(p.y), getNLP(p.z));\n}\n\nfloat sphereDist(vec3 p){\n    \n    return length(p - getNLP(p)) - radius;\n}\n\nfloat distFunc(vec3 p){\n    \n    return sphereDist(p);\n}\n\nvec3 normal(vec3 p){\n    \n    return normalize(vec3(\n        distFunc(p + vec3(EPS, 0., 0.)) - distFunc(p),\n        distFunc(p + vec3(0., EPS, 0.)) - distFunc(p),\n        distFunc(p + vec3(0., 0., EPS)) - distFunc(p)\n    ));\n}\n\nvec3 trace(vec3 origin, vec3 ray){\n    \n    ray = normalize(ray);\n    \n    vec3 p = origin;\n    \n    for(int i = 0; i < 32; ++i)\n         p += distFunc(p) * ray;\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime/10.+10.;\n    \n    vec3 origin = vec3(t, 0., .1);\n    vec3 ray = vec3(uv, 5.);\n    vec3 light = normalize(vec3(-1., -1., 1.));\n    \n    vec3 p = trace(origin, ray);\n    \n    if(distFunc(p) < EPS){\n        float d = dot(normal(p), -light);\n        fragColor = vec4(1., vec3(d));\n    }\n    else\n        fragColor =  vec4(0., 0., 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljyWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 60, 60, 113], [115, 115, 135, 135, 198], [200, 200, 225, 225, 275], [277, 277, 300, 300, 333], [335, 335, 355, 355, 561], [563, 563, 597, 597, 745], [747, 747, 804, 804, 1265]]}
{"id": "4llcWs", "name": "Dunes (Learning Raymarching)", "author": "avant_bard", "description": "Atrocious implementation of IQ's raymarching tutorial", "tags": ["raymarching", "learning", "first"], "likes": 0, "viewed": 90, "published": "Public", "date": "1506989152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f( float x, float y ){\n\treturn sin(x * 0.5) + sin(y * sin(-iTime*0.1) * 0.5)+ 1.5+0.5 *sin(x*0.01)*6.0;\n}\n\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float b = 23.6;\n    float fogAmount = 1.0 - exp( -distance*b );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  =  vec3(1.0,0.9,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 castRay( const vec2 uv, const vec3 ro, const vec3 rd )\n{\t\n\n    const float delt = 0.01f;\n    const float mint = 0.001f;\n    const float maxt = 20.0f;\n    for( float t = mint; t < maxt; t += delt )\n    {\n        vec3 p = ro + rd*t;\n        if( p.y <  f( p.x, p.z ) )\n        {\n            vec3 rgb = texture(iChannel0, p.xz * 0.5 + vec2(sin(p.x*14.0), cos(p.x * 14.435)+ iTime*1.0)).xyz * (0.4+ p.y * 0.5) ;\n\t\t\trgb = applyFog( rgb, delt, rd, vec3(0,0,-1.0));\n\t\t\t return rgb;\n        }\n    }\n    return vec3(0.3 + uv.x * 0.5, 0.6, 0.9) ;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 fp = 0.5-(uv-0.5);\n\tvec4 m = iMouse / iResolution.xxxx;\n\n\tvec3 o = vec3(3.0 + 4.0 * sin(iTime*0.4), 5.0,-20.0);\n    \n\tvec3 ct = vec3(3.0 + m.x * 100.0, 0.0, 30.0 +  m.x*300.0);\n    vec3 wup = vec3(0.0, 1.0, 0.0);\n\tvec3 cr = normalize(cross(wup, o));\n    vec3 cd = normalize(ct - o);\n\tvec3 cu = cross(cd, cr);\n    vec3 rayDir = normalize(cr * fp.x + cu * fp.y + cd);\n\n\n\tvec3 rc = castRay(uv, o,rayDir);\n\n\tfragColor = vec4(rc, 1.0);\n\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 111], [114, 114, 359, 359, 572], [575, 575, 636, 636, 1117], [1121, 1121, 1178, 1178, 1660]]}
{"id": "4lscDl", "name": "Mandelbrot - Julia ", "author": "CodingDuff", "description": "Shader mandelbrot", "tags": ["mandelbrotjulia"], "likes": 0, "viewed": 64, "published": "Public", "date": "1506979009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( 2.0*fragCoord.xy-iResolution.xy )/iResolution.y;\n    float MAX_ITERATION = 25.0;\n    float mx = iMouse.x/iResolution.x*2.0 - 0.5;\n    float my = iMouse.y/iResolution.y*2.0 - 0.5;\n    float c_r = mx*sin(iTime*0.5);    \n    float c_i = my*cos(iTime*0.5);\n    float z_r = uv.x;\n    float z_i = uv.y;\n    \n    float l;\n    float i;\n    while ( l < 4.0 && i < MAX_ITERATION )\n    { \n        float tmp = z_r;\n        z_r = pow( z_r, 2.0 ) - pow( z_i, 2.0 ) + c_r;\n        z_i = 2.0*z_i*tmp + c_i;\n            \n        l = pow(z_r, 2.0)+pow( z_i, 2.0 );\n        i++;\n    }\n    \n    if ( i < MAX_ITERATION )\n    {        \n    \tfragColor = vec4( i / MAX_ITERATION, 0.0, 0.0, 0.0 ); \n    }\n    else\n    {\n        fragColor = vec4( l*0.1, l*0.2, l, 0.0 ); \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lscDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 824]]}
{"id": "4lScRW", "name": "Mandelbrot gradient (+glitch)", "author": "yqy", "description": "Because this platform does not support UI, change consts in code.", "tags": ["fractal", "mandelbrot", "glitch"], "likes": 0, "viewed": 124, "published": "Public", "date": "1507552774", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float param1 = 128.f;\nconst float param2 = 16.f;\nconst float ln = 1.f;\nconst float d_u = 0.f;\nconst int mode = 0;\nconst int color = 0;\nconst int hole = 1;\n\nconst float PI = radians(180.f);\nconst float TAU = radians(360.f);\n\n#define div(a, b) int((a) / (b))\n#define sqr(a) ((a) * (a))\n#define cub(a) (sqr(a) * (a))\n\n#define map3(f, v) vec3(f((v).x), f((v).y), f((v).z))\n\nint   idiv (int a, int b) { return a/b + (a%b>0?1:0); }\nint   imod (int a, int b) { return a>=0 ? a%b : b-1+(a+1)%b; }\nfloat add2 (vec2 a) { return a.x + a.y; }\nfloat sub2 (vec2 a) { return a.x - a.y; }\nbool  bxor2(bvec2 a) { return a.x ^^ a.y; }\nvec2  flip2(vec2 a) { return vec2(a.y, a.x); }\n\nvec2 cx_conj(vec2 a) { return vec2(a.x, -a.y); }\nvec2 cx_inv (vec2 a) { return cx_conj(a) / add2(a*a); }\nvec2 cx_mul (vec2 a, vec2 b) { return vec2(sub2(a*b), add2(a*flip2(b))); }\nvec2 cx_div (vec2 a, vec2 b) { return cx_mul(a, cx_conj(b)); }\n\nvec3 hsv2rgb(float h, float s, float v) {\n    h = fract(h) * 6.f;\n    float c = v * s;\n    float x = c * (1.f - abs(mod(h, 2.f) - 1.f));\n    float m = v - c;\n\n    #define ret(a, b, c)\\\n        return vec3(a + m, b + m, c + m)\n\n    switch (int(h)) {\n        case 0: ret(c, x, 0.f);\n        case 1: ret(x, c, 0.f);                                                                                                          \n        case 2: ret(0.f, c, x);                                                                                                          \n        case 3: ret(0.f, x, c);                                                                                                          \n        case 4: ret(x, 0.f, c);                                                                                                          \n        case 5: ret(c, 0.f, x);                                                                                                          \n    }                                                                                                                                  \n                                                                                                                                       \n    #undef ret                                                                                                                         \n}                                                                                                                                      \n                                                                                                                                       \nvec3 lab2xyz(float l, float a, float b) {                                                                                              \n    const vec3 w = vec3(0.95047f, 1.f, 1.08883f);                                                                                          \n    vec3 c = vec3((l + 16.f) / 116.f)                                                                                                      \n           + vec3(a / 500.f, 0.f, -b / 200.f);                                                                                               \n    #define f(t)\\\n        t > 6.f / 29.f\\\n            ? cub(t)\\\n            : (116.f * t - 16.f) * 27.f / 24389.f\n    return w * map3(f, c);                                                                                                             \n    #undef f                                                                                                                           \n}                                                                                                                                      \n                                                                                                                                       \nvec3 lab2rgb(float l, float a, float b) {\n    const mat3 m = mat3(\n         3.2404542f, -1.5371385f, -0.4985314f,\n        -0.9692660f,  1.8760108f,  0.0415560f,\n         0.0556434f, -0.2040259f,  1.0572252f\n    );\n    #define f(t)\\\n        t > 0.00304f\\\n            ? 1.055f * pow(t, 1.f / 2.4f) - 0.055f\\\n            : 12.92f * t\n    vec3 c = lab2xyz(l, a, b) * m;\n    return map3(f, c);\n    #undef f\n}\n\nvec3 labhsv(float h, float s, float v) {\n    h *= TAU;\n    s *= 100.f;\n    v *= 100.f;\n    return lab2rgb(v, s * sin(h), s * cos(h));\n}\n\nfloat foo1(float a, float b)\n{\n    return sqr(a)+sqr(b);\n}\n\nfloat foo(float a, float b)\n{\n    float c = log(sqr(a) + sqr(b));\n    if (hole == 0)\n        c = abs(c);\n    return log(c);\n}\n\nfloat mandel(vec2 c, int n)\n{\n    float res_r = 0.0f;\n    float res_i = 0.0f;\n    float res_r_tmp;\n    int i = 0;\n    while (foo1(res_r, res_i) < param2 && (i < n))\n    {\n        res_r_tmp = res_r;\n        res_r = sqr(res_r) - sqr(res_i) + c.x;\n        res_i = 2.0f * res_r_tmp * res_i + c.y;\n        ++i;\n    }\n    if (ln == 1.f)\n        return foo(res_r, res_i);\n    else\n        return float(i+1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pp = fragCoord.xy / iResolution.xy;\n    pp.x = pp.x * 4.f - 8.f/3.f;\n    pp.y = pp.y * 8.f/3.f - 4.f/3.f;\n    float d = d_u == 0.f ? log(abs(sin(iTime)))/10000000.f : d_u;\n    float m = mandel(pp, int(param1)) / param1;\n    float mx = mandel(pp + vec2(d, 0.f), int(param1)) / param1;\n    float my = mandel(pp + vec2(0.f, d), int(param1)) / param1;\n    float grad = atan((m - mx) / d, (m - my) / d);\n    if (color == 1)\n    {\n        m *= param1;\n        mx *= param1;\n        my *= param1;\n    }\n    vec3 c;\n    if (mode == 0)\n        c = labhsv(m, abs(m-mx)/d, abs(m-my)/d);\n    else if (mode == 1)\n        c = lab2rgb(m, 100.f*(m-mx)/d, 100.f*(m-my)/d);\n    else\n        c = labhsv(m, 0.8f, abs(grad)/PI);\n    fragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lScRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[376, 376, 403, 403, 431], [432, 432, 459, 459, 494], [495, 495, 516, 516, 536], [537, 537, 558, 558, 578], [579, 579, 601, 601, 622], [623, 623, 644, 644, 669], [671, 671, 693, 693, 719], [720, 720, 742, 742, 775], [776, 776, 806, 806, 850], [851, 851, 881, 881, 913], [915, 915, 956, 956, 2295], [2566, 2566, 2607, 2607, 3511], [3782, 3782, 3823, 3823, 4185], [4187, 4187, 4227, 4227, 4322], [4324, 4324, 4354, 4354, 4382], [4384, 4384, 4413, 4413, 4509], [4511, 4511, 4540, 4540, 4913], [4915, 4915, 4972, 4972, 5716]]}
{"id": "4lScRy", "name": "Frozen Swamp", "author": "aiekick", "description": "Frozen Swamp", "tags": ["3d", "fractal", "julia", "sss", "distance", "field", "frozen", "swamp"], "likes": 9, "viewed": 576, "published": "Public API", "date": "1508950141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n// link : https://www.shadertoy.com/view/lt2yWw\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t * .1), sin(t * .1)) * 3.;\n}\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.1415926535 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat fractus(vec2 p, vec2 v)\n{\n\tvec2 z = p;\n    vec2 c = v;\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<5.;i++)\n    {\n        h *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n\treturn sqrt(k/h)*log(k);   \n}\n\nvec4 dfFractus(vec3 p)\n{\n\tfloat st = 5.;\n    \n    float id = floor(p.z / st);\n    \n    float a = fullAtan(p.xy);\n    \n    vec2 c;\n    c.x = mix(0.2, -0.5, cos(a * 4. + id));\n    c.y = mix(0.5, 0.0, sin(a * 3. + id));\n    \n    p.z = mod(p.z, st) - st * .5;\n    \n    float path = length(p.xy) - 3.;\n    \n    vec2 rev = vec2(path, p.z);\n    float aa = a + id;\n    rev *= mat2(cos(aa),-sin(aa),sin(aa),cos(aa));\n\t\n\treturn vec4(fractus(rev, c) - 0.05, rev, 20.0);;\n}\n\nvec2 getTunnelPath(float t, vec2 s)\n{\n\tvec2 p = vec2(cos(t*0.2), sin(t*-0.2)) * s * 2.;\n\tt *= 0.1;\n\tp *= mat2(cos(t),-sin(t),sin(t), cos(t));\n\treturn p;\n}\n\nfloat getTutu(vec3 p)\n{\n    //p.x = mod(p.x+2.5, 5.)-2.5;\n\treturn length(p.xy)-0.5; // thick\n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(0.6,0.8,1.), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvec4 minObj(vec4 a, vec4 b)\n{\n\tif (a.x < b.x) \n        return a;\n    return b;\n}\n\nvec4 df(vec3 p)\n{\n    // texture here get a error on some gpu, get a gradient in loop error.\n    // textureLod is ok\n    vec3 tex = textureLod(iChannel0, p.xz * 0.5, 0.).rgb;\n    float disp = dot(tex, vec3(0.01));\n    \n    vec2 q = p.xy + path(p.z);\n    \n    float plane = q.y + cos(q.x * .1) - 0.8 + disp;\n\n    p.xy -= getTunnelPath(p.z,vec2(0.2,0.2));\n    float tutu = getTutu(p * vec3(0.2,0.5,1));\n    \n    vec4 ftus = dfFractus(p);\n    \n    vec4 ground = vec4(max(plane,-min(ftus.x-0.1,tutu)),0,0,10.);\n    \n    return minObj(ground, ftus);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float ms) \n{\n\tvec3 n = nor(surfPoint,0.0001); \n\treturn df(surfPoint - n * ms).x/ms;\n}\n\n// from shane shaders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    p = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane shaders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n// shading func\nvec3 shadeGround(vec3 ro, vec3 rd, float d, vec3 ld, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\n\tvec3 n = nor(p, 0.1);\t\t\n    \n    n = doBumpMap(iChannel0, p*.5, n, 0.005);\n\t\n\tvec3 refl = reflect(rd,n);\t\n\t\n\tfloat amb = 0.6; \t\t\t\t\t\t\t\t\t\t\t\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.); \t\n\tfloat sss = 1. - SubDensity(p, 1.); \t\t\t\t\t\t\n\t\n    return vec3(\n        (diff + fre + spe * 2.) * amb * li,\n        (diff + fre + sss) * amb * li + spe * 1.2,\n        (diff + fre - spe * 0.2 + sss * .8) * amb * li\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vars\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 mo = iMouse.xy;\n\tfloat time = iTime * 5.;\n\t\n\tvec3 col = vec3(0);\n            \n\tvec3 ro = vec3(0,0,time);\n\tro.xy += getTunnelPath(ro.z,vec2(0.2,0.2));\n    \n\tvec3 lp = ro + vec3(0,2,5);\n\t\n    vec3 cv = ro + vec3(0,0,1);\n    cv.xy += getTunnelPath(cv.z,vec2(0.2,0.2));\n    \n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n    \n  \tvec2 uv = (g+g-si)/si.y;\n   \tvec3 rd = normalize(z + uv.x*x + uv.y*y);\n\n\tfloat md = 100.;\n\n    float accum = 0.0;\n    \n\tfloat s = 1., d = 0.;\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (d*d/s > 1e6 || d > md) break;\n\t\ts = df(ro+rd*d).x;\n\t\td += s * .2;\n        accum += 0.002;\n\t}\n\t\n    vec3 ld = normalize(lp - ro-rd*d);\n\t\n    vec3 sky = GetSky(rd, ld, vec3(1.5));\n    \n    if (d < md)\n    {\n        vec3 p = ro+rd*d; // surf point\n        vec3 mat = vec3(0.6,0.8,1.);\n        vec4 dfMat = df(p);\n        vec3 n = nor(p, 0.1);\n       \tfloat incl = acos(dot(n, vec3(0,1,0)));\n        vec3 refl = reflect(rd,n);\t\n\n        if (dfMat.w > 19.5) // fractus\n        {\n            vec3 tex = texture(iChannel1, dfMat.yz).rgb;\n\t\t\tvec3 tex1 = texture(iChannel1, dfMat.yz+0.1).rgb;\n\n            n += (tex1-tex);\n            \n            float amb = 0.6; \t\t\t\t\t\t\t\t\t\t\t\n            float diff = clamp( dot(n, ld), 0.0, 1.0 ); \t\t\t\t\n            float fre = pow( clamp( 1. + dot(n, rd),0.0,1.0), 4. ); \t\t\n            float spe = pow(clamp( dot(refl, ld), 0.0, 1.0 ),16.); \t\n\n            col = (tex * diff * .8 + fre * .1 + mat * spe * .8 );\n       \n            // snow\n            vec3 texSnow = texture(iChannel0, p.xz*.2).rgb;\n            texSnow = smoothstep(texSnow+0.5, texSnow, vec3(0.7));\n            col = mix(col, vec3(0.9,0.9,1.0), 0.2+smoothstep(texSnow.r, 0.0, incl)*.8);\n        }\n        else if (dfMat.w > 9.5) // ground\n        {\n            // sub surface\n            for (float i = 0.; i < 1.; i+=0.1)\n            {\n                float y = shadeGround(p, rd, i, ld, i).y;\n                mat = blackbody(1000. + y * 900.).bgr * 0.8;\n                col = min(mix(col, y * mat, i), vec3(2.));\n            }\n\n            // surface\n            vec2 xz = shadeGround(ro, rd, d, ld, 1.).xz;\n            mat = blackbody(2000. + xz.x * 3. * 900.).bgr * 0.2;\n            col = mix(col, xz.x * 3. * mat, 0.7);\n\n            // snow\n            vec3 texSnow = texture(iChannel0, p.xz*.2).rgb;\n            texSnow = smoothstep(texSnow+0.5, texSnow, vec3(.7));\n            col = mix(col, vec3(0.9,0.9,1.0) * xz.y, smoothstep(texSnow.r, 0.0, incl));\n        }\n    }\n    \n\tcol = mix(col, sky, 1.0-exp(-0.01*d*d));\n\n    col = sqrt(col * col * .8);\n\n    col += accum * (1.0-exp(-0.01*d*d));\n    \n\tvec2 v = g/si;\n    col *= 0.5 + 0.5*pow( 16.0*v.x*v.y*(1.0-v.x)*(1.0-v.y), 0.25 ); // iq vignette\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lScRy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 262, 282, 282, 329], [331, 331, 355, 355, 438], [440, 440, 471, 471, 717], [719, 719, 743, 743, 1180], [1182, 1182, 1219, 1219, 1336], [1338, 1338, 1361, 1395, 1432], [1434, 1629, 1686, 1686, 1971], [1973, 1973, 2002, 2002, 2053], [2055, 2055, 2072, 2171, 2601], [2603, 2603, 2637, 2637, 2849], [2851, 3072, 3100, 3100, 3425], [3427, 3509, 3554, 3554, 3627], [3629, 3805, 3856, 3856, 4030], [4032, 4241, 4304, 4304, 4666], [4668, 4684, 4748, 4748, 5305], [5307, 5307, 5364, 5376, 8245]]}
{"id": "4lSyRc", "name": "Mandelheart Fade", "author": "sCooZy", "description": "90Â° turned mandelbrot set using z = z^2 + z + c animated as a fading heart.", "tags": ["fractal", "mandelbrot", "fade"], "likes": 3, "viewed": 103, "published": "Public", "date": "1509436245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int iterationLimit = 50;\nconst float pi = 3.141592653;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x / iResolution.y * 2.0 - iResolution.x/iResolution.y;\n\tfloat y = fragCoord.y / iResolution.y * 2.0 - 1.0;\n    float offset = (sin(iTime) + 1.0) / 2.0;\n    float zoom = 1.0 + offset;\n\n    vec2 point = vec2(x,y - 0.21*offset);\n    point = point * 5.0 / zoom;\n    \n    mat3 rotMatrix;\n\trotMatrix[0] = vec3(cos(pi/2.0),-sin(pi/2.0),0);\n    rotMatrix[1] = vec3(sin(pi/2.0),cos(pi/2.0),0);\n    rotMatrix[2] = vec3(0,0,1);\n    \n    point = vec2(rotMatrix * vec3(point,1.0));\n    \n    vec2 z = vec2(0.0,0.0);\n    vec2 z2 = vec2(0.0,0.0);\n    float z2Scale = offset;\n    float zScale = sin(iTime+pi/2.0);\n    for (int i = 0; i<iterationLimit; i++)\n    {\n        if (length(z) > 4.0)\n        {\n            float greyscale = float(i) / float(iterationLimit);\n            fragColor = vec4(greyscale,0,0,1.0);\n            return;\n        }\n        z2.x = z.x * z.x - z.y * z.y;\n        z2.y = 2.0 * z.y * z.x;\n        z = z2Scale*z2 +  zScale*z + point;\n    }\n    fragColor = vec4(1.0,0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 119, 119, 1132]]}
{"id": "4lSyRm", "name": "Simplex Frustum Tracing", "author": "paniq", "description": "crossing planes indicate outer and inner near and far depths of 3-simplex within frustum. Inner boundaries show 100% occlusion. The segments between outer and inner planes enclose a part of the surface.", "tags": ["intersection", "simplex", "tetrahedron", "frustum"], "likes": 16, "viewed": 769, "published": "Public API", "date": "1507831490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simplex Frustum Tracing\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// for a description of the algorithm performed on spheres see\n// https://gist.github.com/paniq/6c7a465b841dc2c87294c61108370389\n\n// note that this version is very verbose and purposefully lacks \n// any form of optimization for the sake of education.\n\nconst vec3 simplex_init_center = vec3(0.0, 0.0, 3.0);\nconst vec2 min_frustum_half_size = vec2(1.77778,1.0)/30.0;\nconst vec2 max_frustum_half_size = vec2(1.77778,1.0)/6.0;\n\nconst int bound_none = 0;\nconst int bound_ray = 1;\nconst int bound_volume = 2;\nconst int bound_plane = 3;\n\nvec2 frustum_center;\nvec2 frustum_half_size;\nvec3 simplex_vertex[4];\nvec2 frustum_corners[4];\nvec3 frustum_ray_dirs[4];\nvec3 frustum_planes[4];\nvec2 simplex_ray_hits[4]; // these are scalars along the ray direction\nbvec2 simplex_has_polytope[4];\nvec3 polytope_near[4];\nvec3 polytope_far[4];\nbvec2 simplex_has_bound;\nvec3 simplex_near;\nvec3 simplex_far;\nvec2 outer_bound;\nvec2 inner_bound;\nivec2 outer_bound_type;\nivec2 inner_bound_type;\n\n// check only the horizontal frustum planes\nfloat dFrustumH(vec3 p) {\n    return max(\n        dot(p, frustum_planes[0]),\n        dot(p, frustum_planes[2]));    \n}\n\n// check only the vertical frustum planes\nfloat dFrustumV(vec3 p) {\n    return max(\n        dot(p, frustum_planes[1]),\n        dot(p, frustum_planes[3]));    \n}\n\nfloat dFrustum(vec3 p) {\n    return max(\n        dFrustumH(p),\n        dFrustumV(p));\n}\n\n// versor (unit quaternion) from axis and angle\nvec4 versor(vec3 axis, float angle) {\n    float a = angle * 0.5;\n    return vec4(axis * sin(a), cos(a));\n}\n\n// invert rotation\nvec4 conjugate(vec4 q) {    \n    return vec4(-q.xyz, q.w);\n}\n\n// rotate point by versor\n// q (t) * V * q (t) ^-1\nvec3 rotate(vec4 q, vec3 p) {\n    vec3 t = cross(q.xyz,p) * 2.0;\n    return p + q.w * t + cross(q.xyz, t);    \n}\n\n// compute the barycentric transform matrix\nmat3 compute_bary_transform(vec3 p[4]) {\n    vec3 e[6];\n    e[0] = p[2] - p[1];\n    e[1] = p[0] - p[2];\n    e[2] = p[1] - p[0];\n    e[3] = p[1] - p[3];\n    e[4] = p[2] - p[3];\n    e[5] = p[0] - p[3];\n    mat3 m = mat3(\n    \tcross(e[0], e[3]),\n    \tcross(e[1], e[4]),\n    \tcross(e[2], e[5]));\n    float invdet = 1.0/dot(m[0], e[1]);\n    // premultiply the plane orthogonals by the inverse determinant\n    return m * invdet;\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec4 to_bary(vec3 p3, mat3 m, vec3 t) {\n    // weights are scaled distance of point to individual planes\n    vec3 w = (t - p3) * m;\n    float ww = 1.0 - w.x - w.y - w.z;\n    return vec4(w, ww);    \n}\n\nvec3 from_bary(vec3 p[4], vec4 w) {\n\treturn p[0] * w.x + p[1] * w.y + p[2] * w.z + p[3] * w.w;\n}\n\nvec3 normal_from_bary(mat3 m, vec4 w) {\n    return normalize(m * (w.w - w.xyz));\n}\n\nstruct Hit {\n    // ray scalar\n    float t;\n    // barycenter\n    vec4 b;\n    // normal\n    vec3 n;\n};\n\n// return normal of nearest plane in barycentric coordinates\nvec4 select_plane_normal(vec4 b) {\n    float lc = min(min(b.x, b.y), min(b.z, b.w));\n    return step(b, vec4(lc));\n}\n\n// return the intersection of ray and tetrahedron\n// as well as the barycentric coordinates and normals of the hit points\nbool iSimplex3(vec3 p[4], vec3 ro, vec3 rd, \n\tout Hit near, out Hit far) {\n    \n    mat3 m = compute_bary_transform(p);\n    \n    // convert ray endpoints to barycentric basis\n    vec4 r0 = to_bary(p[3], m, ro);\n    vec4 r1 = to_bary(p[3], m, ro + rd);\n\n    // build barycentric ray direction from endpoints\n    vec4 brd = r1 - r0;\n    \n    // compute ray scalars for each plane\n    vec4 t = -r0/brd;\n    \n    // valid since GL 4.1\n    near.t = -1.0 / 0.0;\n    far.t = 1.0 / 0.0;\n    for (int i = 0; i < 4; ++i) {\n        // equivalent to checking dot product of ray dir and plane normal\n        if (brd[i] < 0.0) {\n            far.t = min(far.t, t[i]);\n        } else {\n            near.t = max(near.t, t[i]);\n        }\n    }\n    \n    if ((far.t <= 0.0) || (far.t <= near.t))\n        return false;\n    near.b = r0 + brd * near.t;\n    far.b = r0 + brd * far.t;\n\n    vec4 n0 = select_plane_normal(near.b);\n    vec4 n1 = select_plane_normal(far.b);\n    near.n = normal_from_bary(m, n0);\n    far.n = normal_from_bary(m, n1);\n    return true;\n}\n\n// d0: dot((p0,1), plane)\n// d1: dot((p1,1), plane)\nvec3 intersect_plane_edge(vec4 plane, float d0, float d1, vec3 p0, vec3 p1) {\n    float D = d1 - d0;\n    float t = ((D == 0.0)?0.0:(-d0/D));\n    return p0 * (1.0 - t) + p1 * t;\n}\n\n#define INTERSECT1(I,A,B) p[I] = intersect_plane_edge(plane, d[A], d[B], v[A], v[B])\n#define INTERSECT3(R,A,B,C) INTERSECT1(0,R,A); INTERSECT1(1,R,B); INTERSECT1(2,R,C); return 3;\n#define INTERSECT4(L1,L2,R1,R2) INTERSECT1(0,L1,R1); INTERSECT1(1,L1,R2); INTERSECT1(2,L2,R2); INTERSECT1(3,L2,R1); return 4;\n\n// slice a 3-simplex by a plane to return 0, 3 or 4 points describing\n// the resulting polytope embedded in 3-space.\n// with support for dynamic indexing, one can store the index map in a table\nint simplex3_slice(vec3 v[4], vec4 plane, out vec3 p[4]) {\n    float d[4];\n    for (int i = 0; i < 4; ++i) {\n        d[i] = dot(vec4(v[i],1.0), plane);\n    }\n    int idx = \n          ((sign(d[0]) < 0.0)?0:1)\n        + ((sign(d[1]) < 0.0)?0:2)\n        + ((sign(d[2]) < 0.0)?0:4)\n        + ((sign(d[3]) < 0.0)?0:8);\n    idx = (idx > 7)?(15 - idx):idx;\n    if (idx == 1) {\n        // 3 2 1| 0\n        INTERSECT3(0,1,2,3);\n    } else if (idx == 2) {\n        // 3 2 0 | 1\n        INTERSECT3(1,0,2,3);\n    } else if (idx == 3) {\n        // 3 2 | 1 0\n        INTERSECT4(0,1,2,3);\n    } else if (idx == 4) {\n        // 3 1 0 | 2\n        INTERSECT3(2,0,1,3);\n    } else if (idx == 5) {\n        // 3 1 | 2 0\n        INTERSECT4(0,2,1,3);\n    } else if (idx == 6) {\n        // 2 1 | 3 0\n        INTERSECT4(0,3,1,2);\n    } else if (idx == 7) {\n        // 2 1 0 | 3\n        INTERSECT3(3,0,1,2);\n    } else {\n        // | 3 2 1 0\n        return 0;        \n    }    \n}\n\n#define INTERSECT2(R,A,B) INTERSECT1(0,R,A); INTERSECT1(1,R,B); return 2;\n\n// d0: dot((p0,1), plane)\n// d1: dot((p1,1), plane)\nvec2 intersect_plane_edge(vec3 plane, float d0, float d1, vec2 p0, vec2 p1) {\n    float D = d1 - d0;\n    float t = ((D == 0.0)?0.0:(-d0/D));\n    return p0 * (1.0 - t) + p1 * t;\n}\n\n// slice a 2-simplex by a 2-plane to return 0 or 2 points describing\n// the resulting line.\n// with support for dynamic indexing, one can store the index map in a table\nint simplex2_slice(vec2 v[3], vec3 plane, out vec2 p[2]) {\n    float d[3];\n    for (int i = 0; i < 3; ++i) {\n        d[i] = dot(vec3(v[i],1.0), plane);\n    }\n    int idx = \n          ((sign(d[0]) < 0.0)?0:1)\n        + ((sign(d[1]) < 0.0)?0:2)\n        + ((sign(d[2]) < 0.0)?0:4);\n    idx = (idx > 3)?(7 - idx):idx;\n    if (idx == 1) {\n        // 2 1 | 0\n        INTERSECT2(0,1,2);\n    } else if (idx == 2) {\n        // 2 0 | 1\n        INTERSECT2(1,0,2);\n    } else if (idx == 3) {\n        // 1 0 | 2\n        INTERSECT2(2,0,1);\n    } else {\n        // | 2 1 0\n        return 0;       \n    }\n}\n\n// for a polytope formed by intersection of frustum plane\n// and tetrahedron, return the nearest and farthest vertex\n// of the polytope relative to the screen plane\nvoid intersect_plane_simplex(int mc, vec3 plane, vec3 v[4], \n\tout vec3 near, out vec3 far, out bvec2 has_bounds) {\n    vec3 p[4];\n\tint count = simplex3_slice(v, vec4(plane, 0.0), p);\n    if (count == 0) {\n        has_bounds = bvec2(false);\n        return;\n    }\n    near = far = p[0];\n    for (int i = 1; i < 4; ++i) {\n        if (i >= count)\n            continue;\n        if (p[i].z < near.z)\n            near = p[i];\n        if (p[i].z > far.z)\n            far = p[i];\n    }\n    if (mc == 0) {\n        has_bounds[0] = (dFrustumV(near) <= 0.0);\n        has_bounds[1] = (dFrustumV(far) <= 0.0);\n    } else {\n        has_bounds[0] = (dFrustumH(near) <= 0.0);\n        has_bounds[1] = (dFrustumH(far) <= 0.0);\n    }\n}\n\nvec2 lissajous(float t, float a, float b) {\n    return vec2(sin(a*t), sin(b*t));\n}\n\nvoid compute_bounds() {\n    outer_bound_type = ivec2(bound_none);\n    inner_bound_type = ivec2(bound_none);\n    outer_bound = vec2(1.0/0.0,-1.0/0.0);\n    inner_bound = vec2(-1.0/0.0,1.0/0.0);\n    \n    // check volume bounds first\n    // those are always the closest\n    if (simplex_has_bound[0]) {\n        outer_bound[0] = simplex_near.z;\n        outer_bound_type[0] = bound_volume;\n    } else {\n        // check polytope bounds next\n        for (int i = 0; i < 4; ++i) {\n            if (simplex_has_polytope[i][0]\n                && (polytope_near[i].z < outer_bound[0])) {\n                outer_bound[0] = polytope_near[i].z;\n                outer_bound_type[0] = bound_plane;\n            }\n        }\n        // also check for ray hits\n        for (int i = 0; i < 4; ++i) {\n            if (simplex_ray_hits[i].x >= 0.0) {\n                vec3 p = frustum_ray_dirs[i] * simplex_ray_hits[i].x;\n                if (p.z < outer_bound[0]) {\n                    outer_bound[0] = p.z;\n                    outer_bound_type[0] = bound_ray;\n                }\n            }\n        }\n    }\n    // don't need to continue if we couldn't find a nearest depth\n    if (outer_bound_type[0] == bound_none) return;\n    \n    // check volume bounds first\n    if (simplex_has_bound[1]) {\n        outer_bound[1] = simplex_far.z;\n        outer_bound_type[1] = bound_volume;\n    } else {\n        // check polytope bounds next\n        for (int i = 0; i < 4; ++i) {\n            if (simplex_has_polytope[i][1]\n                && (polytope_far[i].z > outer_bound[1])) {\n                outer_bound[1] = polytope_far[i].z;\n                outer_bound_type[1] = bound_plane;\n            }\n        }\n        // also check for ray hits\n        for (int i = 0; i < 4; ++i) {\n            if (simplex_ray_hits[i].y >= 0.0) {\n                vec3 p = frustum_ray_dirs[i] * simplex_ray_hits[i].y;\n                if (p.z > outer_bound[1]) {\n                    outer_bound[1] = p.z;\n                    outer_bound_type[1] = bound_ray;\n                }\n            }\n        }\n    }    \n    \n    // we have an interior interval if all four corners\n    // hit the simplex\n    \n    int hits = 0;\n    for (int i = 0; i < 4; ++i) {\n        if (simplex_ray_hits[i].x >= 0.0) {\n            hits++;\n        }    \n    }\n    \n    if (hits == 4) {\n        for (int i = 0; i < 4; ++i) {\n            if (simplex_ray_hits[i].x >= 0.0) {\n                vec3 p0 = frustum_ray_dirs[i] * simplex_ray_hits[i].x;\n                vec3 p1 = frustum_ray_dirs[i] * simplex_ray_hits[i].y;\n                if (p0.z > inner_bound[0]) {\n                    inner_bound[0] = p0.z;\n                    inner_bound_type[0] = bound_ray;                \n                }\n                if (p1.z < inner_bound[1]) {\n                    inner_bound[1] = p1.z;\n                    inner_bound_type[1] = bound_ray;\n                }\n            }\n        }\n    }\n    \n    // if the interval is negative, we can't use it\n    if (inner_bound[1] < inner_bound[0]) {\n        inner_bound_type[0] = bound_none;\n    }    \n}\n\nvoid setup_globals(float t) {\n    // move the frustum around\n    frustum_center = lissajous(t*0.07, 2.0, 1.0)*0.1;\n    // vary the frustum aperture\n    frustum_half_size = mix(\n        min_frustum_half_size,\n\t\tmax_frustum_half_size,\n        cos(t*0.13)*0.5+0.5);\n    \n    // transform our simplex a bit\n    vec2 simplex_offset = lissajous(t*0.2, 5.0, 4.0)*0.3;\n    vec3 simplex_center = simplex_init_center + vec3(simplex_offset, 0.0);\n    vec3 simplex_scale = vec3(\n        mix(0.2,1.0,cos(t*0.35)*0.5+0.5),\n        mix(0.2,1.0,cos(t*0.292)*0.5+0.5),\n        1.0);\n    vec4 simplex_rotation = versor(normalize(vec3(1.0)), t*0.2);\n    vec2 S = vec2(1.0, -1.0);\n    simplex_vertex[0] = rotate(simplex_rotation, S.xxx * simplex_scale) + simplex_center;\n    simplex_vertex[1] = rotate(simplex_rotation, S.xyy * simplex_scale) + simplex_center;\n    simplex_vertex[2] = rotate(simplex_rotation, S.yxy * simplex_scale) + simplex_center;\n    simplex_vertex[3] = rotate(simplex_rotation, S.yyx * simplex_scale) + simplex_center;\n    \n    simplex_near = simplex_far = simplex_vertex[0];\n    for (int i = 1; i < 4; ++i) {\n        if (simplex_vertex[i].z < simplex_near.z)\n            simplex_near = simplex_vertex[i];\n        if (simplex_vertex[i].z > simplex_far.z)\n            simplex_far = simplex_vertex[i];\n    }\n    \n    vec3 frustum_extents = vec3(frustum_half_size,-frustum_half_size.x);\n    frustum_corners[0] = frustum_center + frustum_extents.xy;\n    frustum_corners[1] = frustum_center + frustum_extents.zy;\n    frustum_corners[2] = frustum_center - frustum_extents.xy;\n    frustum_corners[3] = frustum_center - frustum_extents.zy;\n\n    for (int i = 0; i < 4; ++i) {\n        frustum_ray_dirs[i] = normalize(vec3(frustum_corners[i],1.0));\n    }\n    \n    for (int i = 0; i < 4; ++i) {\n        Hit h0, h1;\n        vec2 hits;\n        if (iSimplex3(simplex_vertex, vec3(0.0), frustum_ray_dirs[i], h0, h1)) {\n            hits = vec2(h0.t, h1.t);\n        } else {\n            hits = vec2(-1.0);\n        }\n\t\tsimplex_ray_hits[i] = hits;\n    }\n    \n    frustum_planes[0] = normalize(cross(frustum_ray_dirs[1],frustum_ray_dirs[0]));\n    frustum_planes[1] = normalize(cross(frustum_ray_dirs[2],frustum_ray_dirs[1]));\n    frustum_planes[2] = normalize(cross(frustum_ray_dirs[3],frustum_ray_dirs[2]));\n    frustum_planes[3] = normalize(cross(frustum_ray_dirs[0],frustum_ray_dirs[3]));\n\n    simplex_has_bound[0] = (dFrustum(simplex_near) < 0.0);\n    simplex_has_bound[1] = (dFrustum(simplex_far) < 0.0);\n    \n    intersect_plane_simplex(0, frustum_planes[0], \n\t\tsimplex_vertex, polytope_near[0], polytope_far[0], simplex_has_polytope[0]);\n    intersect_plane_simplex(1, frustum_planes[1], \n\t\tsimplex_vertex, polytope_near[1], polytope_far[1], simplex_has_polytope[1]);\n    intersect_plane_simplex(0, frustum_planes[2], \n\t\tsimplex_vertex, polytope_near[2], polytope_far[2], simplex_has_polytope[2]);\n    intersect_plane_simplex(1, frustum_planes[3], \n\t\tsimplex_vertex, polytope_near[3], polytope_far[3], simplex_has_polytope[3]);\n    \n\tcompute_bounds();    \n   \n}\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nconst float max_frustum_depth = 5.0;\nconst vec3 light_dir = normalize(vec3(-1.0, -1.0, 1.0));\nconst vec3 backlight_dir = normalize(vec3(0.8, 1.0, -1.0));\n\n\nfloat checkers(vec4 p) {\n    vec4 q = floor(p);\n    return mod(q.x + q.y + q.z + q.w, 2.0);\n}\n\nvoid paint_simplex(vec3 ro, vec3 rd) {\n    Hit h0, h1;\n    if (iSimplex3(simplex_vertex, ro, rd, h0, h1)) {\n        add_field(-1.0);\n        vec3 dist = rd * h0.t;\n        float df = dFrustum(ro + dist);\n        vec3 far_dist = rd * h1.t;\n        float far_df = dFrustum(ro + far_dist);\n        vec3 normal;\n        bool backface = false;\n        vec4 bary;\n        if ((df < 0.0)||(far_df > 0.0)) {\n            normal = h0.n;\n            bary = h0.b;\n        } else {\n            backface = true;\n            dist = far_dist;\n            df = far_df;\n            normal = h1.n;\n            bary = h1.b;\n        }\n        vec3 color = vec3(0.0, 0.05, 0.1);\n        float lit = max(dot(normal, light_dir), 0.0);\n        float backlit = max(dot(normal, backlight_dir), 0.0);\n        color += lit * vec3(1.0,0.9,0.8);\n        color += backlit * vec3(1.0);\n        color *= vec3(mix(0.5,1.0,checkers((bary - 0.5) * 3.99)));\n        if (df < 0.0) {\n            if (backface) {\n                color *= vec3(0.7,0.9,1.0);\n            }                \n        }\n        color = pow(color, vec3(0.5));\n        color = mix(color, vec3(1.0), float(df > 0.0)*0.8);\n        color = mix(vec3(0.0), color, clamp((abs(df)-AAINV*1.5)*AA,-1.0,1.0)*0.5+0.5);\n        set_source_rgb(color);\n\t    fill();\n\t    new_path();\n    }\n}\n\nvoid paint_simplex_zx() {\n    vec2 pt = get_origin();\t\n    paint_simplex(\n        vec3(-pt[1], 2.0, pt[0]),\n        vec3(0.0, -1.0, 0.0));    \n}\n\nvoid paint_simplex_zy() {\n    vec2 pt = get_origin();\t\n    paint_simplex(\n        vec3(2.0, pt[1], pt[0]),\n        vec3(-1.0, 0.0, 0.0));    \n}\n\nvoid paint_simplex_xy() {\n    vec2 pt = get_origin();\t\n    paint_simplex(\n        vec3(pt[0], pt[1], -2.0),\n        vec3(0.0, 0.0, 1.0));\n}\n\nvoid paint_frustum_edges(vec2 pt[4]) {\n    for (int i = 0; i < 4; ++i) {\n\t\tmove_to(0.0, 0.0);\n\t\tline_to(pt[i]);\n    }\n    move_to(pt[0]);\n    for (int i = 1; i < 4; ++i) {\n\t\tline_to(pt[i]);\n    }    \n    close_path();\n}\n\nvoid paint_frustum_zx() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[2],-corner[0]);\n\t}\n    paint_frustum_edges(pts);\n}\nvoid paint_frustum_zy() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[2],corner[1]);\n\t}\n    paint_frustum_edges(pts);\n}\nvoid paint_frustum_xy() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[0],corner[1]);\n\t}\n    paint_frustum_edges(pts);\n}\n\nvec3 bound_color(int bound) {\n    if (bound == bound_volume) {\n        return vec3(1.0,0.0,0.5);\n    } else if (bound == bound_plane) {\n        return vec3(0.0,0.5,1.0);\n    } else if (bound == bound_ray) {\n        return vec3(1.0,0.5,0.0);\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvoid paint() {\n    float t = iTime;\n    setup_globals(t);    \n        \n    float rdot = AAINV*8.0;\n\n    scale(0.4);\n\t\n    save(topview);\n    translate(-1.0,0.9);\n    save(topviewctx);\n    paint_simplex_zx();\n    if (outer_bound_type[0] != bound_none) {\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[1],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[1],1.0) * inner_bound[1];\n            set_source_rgba(1.0,0.5,0.0,0.3);\n            move_to(p0.z, -p0.x);\n            line_to(p1.z, -p1.x);\n            line_to(p2.z, -p2.x);\n            line_to(p3.z, -p3.x);\n            close_path();\n            set_line_width(0.2);\n            fill();\n        }        \n        vec3 p0 = vec3(frustum_corners[1],1.0) * outer_bound[0];\n        vec3 p1 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n        vec3 p2 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n        vec3 p3 = vec3(frustum_corners[1],1.0) * outer_bound[1];\n        set_line_width_px(1.0);\n        set_source_rgb(bound_color(outer_bound_type[0]));\n\t\tmove_to(p0.z, -p0.x); \n        line_to(p1.z, -p1.x);\n\t\tstroke();\n        set_source_rgb(bound_color(outer_bound_type[1]));\n\t\tmove_to(p2.z, -p2.x); \n        line_to(p3.z, -p3.x);\n\t\tstroke();        \n    }\n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_zx();\n    stroke();\n    set_source_rgb(0.0,0.5,1.0);\n    for (int i = 0; i < 4; ++i) {\n        if (i == 2) continue;\n        if (simplex_has_polytope[i][0]) {\n            circle(polytope_near[i].z, -polytope_near[i].x, rdot);\n        }\n        if (simplex_has_polytope[i][1]) {\n            circle(polytope_far[i].z, -polytope_far[i].x, rdot);\n        }\n    }\n    fill();                    \n    set_source_rgb(1.0,0.0,0.5);\n    if (simplex_has_bound[0])\n    \tcircle(simplex_near.z, -simplex_near.x, rdot);\n    if (simplex_has_bound[1])\n\t    circle(simplex_far.z, -simplex_far.x, rdot);\n    fill();                  \n    restore(topview);\n\t\n    save(sideview);\n    translate(-1.0,-1.6);\n    save(sideviewctx);\n    paint_simplex_zy();\n    if (outer_bound_type[0] != bound_none) {\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[3],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[3],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            set_source_rgba(1.0,0.5,0.0,0.3);\n            move_to(p0.zy);\n            line_to(p1.zy);\n            line_to(p2.zy);\n            line_to(p3.zy);\n            close_path();\n            set_line_width(0.2);\n            fill();\n        }                \n        vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n        vec3 p1 = vec3(frustum_corners[3],1.0) * outer_bound[0];\n        vec3 p2 = vec3(frustum_corners[3],1.0) * outer_bound[1];\n        vec3 p3 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n        set_line_width_px(1.0);\n        set_source_rgb(bound_color(outer_bound_type[0]));\n\t\tmove_to(p0.zy); \n        line_to(p1.zy);\n\t\tstroke();\n        set_source_rgb(bound_color(outer_bound_type[1]));\n\t\tmove_to(p2.zy); \n        line_to(p3.zy);\n\t\tstroke();        \n    }    \n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_zy();\n    stroke();\n    set_source_rgb(0.0,0.5,1.0);\n    for (int i = 0; i < 4; ++i) {\n        if (simplex_has_polytope[i][0]) {\n            circle(polytope_near[i].z, polytope_near[i].y, rdot);\n        }\n        if (simplex_has_polytope[i][1]) {\n            circle(polytope_far[i].z, polytope_far[i].y, rdot);\n        }\n    }\n    fill();\n    set_source_rgb(1.0,0.0,0.5);\n    if (simplex_has_bound[0])\n    \tcircle(simplex_near.z, simplex_near.y, rdot);\n    if (simplex_has_bound[1])\n\t    circle(simplex_far.z, simplex_far.y, rdot);\n    fill();    \n    restore(sideview);\n    \n\tsave(backview);\n    translate(-2.5,-0.4);\n    save(backviewctx);\n    paint_simplex_xy();\n    if (outer_bound_type[0] != bound_none) {\n        {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * outer_bound[1];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * outer_bound[1];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * outer_bound[1];\n            set_source_rgba(vec4(bound_color(outer_bound_type[1]),0.3));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();\n        }        \n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * inner_bound[1];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * inner_bound[1];\n            set_source_rgba(vec4(bound_color(inner_bound_type[1]),0.3));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();            \n        }\n        {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * outer_bound[0];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * outer_bound[0];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * outer_bound[0];\n            set_source_rgb(bound_color(outer_bound_type[0]));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();\n        }\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * inner_bound[0];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * inner_bound[0];\n            set_source_rgb(bound_color(inner_bound_type[1]));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();            \n        }        \n    }\n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_xy();\n    stroke();\n    set_source_rgb(1.0,0.0,0.5);\n    if (simplex_has_bound[0])\n    \tcircle(simplex_near.x, simplex_near.y, rdot);\n    if (simplex_has_bound[1])\n\t    circle(simplex_far.x, simplex_far.y, rdot);\n    fill();    \n    restore(backview);\n\n    for (int i = 0; i < 4; ++i) {\n        vec2 dists = simplex_ray_hits[i];\n        restore(backviewctx);\n        set_source_rgb(0.0,0.5,1.0);\n        if (simplex_has_polytope[i][0]) {            \n            circle(polytope_near[i].x, polytope_near[i].y, rdot);\n        }\n        if (simplex_has_polytope[i][1]) {\n            circle(polytope_far[i].x, polytope_far[i].y, rdot);\n        }        \n        fill();                    \n        if (dists.x > 0.0) {\n\t        vec3 enter = frustum_ray_dirs[i] * dists.x;\n            vec3 leave = frustum_ray_dirs[i] * dists.y;\n\t\t    restore(backviewctx);\n            set_source_rgb(1.0,0.5,0.0);\n            circle(enter.x, enter.y, rdot);\n            circle(leave.x, leave.y, rdot);\n            fill();\n            if (i < 2) {\n\t\t\t    restore(topviewctx);\n                set_source_rgb(1.0,0.5,0.0);\n                circle(enter.z, -enter.x, rdot);\n                circle(leave.z, -leave.x, rdot);\n                fill();\n            }\n            if ((i == 0)||(i == 3)) {\n\t\t\t    restore(sideviewctx);\n                set_source_rgb(1.0,0.5,0.0);\n                circle(enter.z, enter.y, rdot);\n                circle(leave.z, leave.y, rdot);\n                fill();                \n            }\n        }\n    }\n    \n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = sqrt(_color);\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    c.rgb = c.rgb*abs(c.rgb);\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSyRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1073, 1117, 1142, 1142, 1235], [1237, 1279, 1304, 1304, 1397], [1399, 1399, 1423, 1423, 1486], [1488, 1536, 1573, 1573, 1642], [1644, 1663, 1687, 1687, 1723], [1725, 1776, 1805, 1805, 1888], [1890, 1934, 1974, 1974, 2358], [2360, 2492, 2531, 2596, 2691], [2693, 2693, 2728, 2728, 2789], [2791, 2791, 2830, 2830, 2873], [2979, 3040, 3074, 3074, 3156], [3158, 3280, 3354, 3354, 4319], [4321, 4373, 4450, 4450, 4551], [4860, 5054, 5112, 5112, 6006], [6083, 6135, 6212, 6212, 6313], [6315, 6484, 6542, 6542, 7074], [7076, 7241, 7355, 7355, 7955], [7957, 7957, 8000, 8000, 8039], [8041, 8041, 8064, 8064, 11089], [11091, 11091, 11120, 11151, 14140], [19952, 20173, 20197, 20197, 20266], [20268, 20268, 20306, 20306, 21578], [21580, 21580, 21605, 21605, 21724], [21726, 21726, 21751, 21751, 21869], [21871, 21871, 21896, 21896, 22010], [22012, 22012, 22050, 22050, 22231], [22233, 22233, 22258, 22258, 22458], [22459, 22459, 22484, 22484, 22683], [22684, 22684, 22709, 22709, 22908], [22910, 22910, 22939, 22939, 23197], [23199, 23199, 23213, 23213, 31342], [31496, 31556, 31583, 31583, 31609], [31611, 31671, 31692, 31692, 31799], [31801, 31801, 31838, 31838, 31924], [31926, 31926, 31972, 31972, 32005], [32007, 32145, 32173, 32173, 32633], [32661, 32661, 32680, 32680, 32713], [32715, 32715, 32733, 32733, 32766], [32768, 32768, 32792, 32792, 32896], [32898, 32898, 32915, 32915, 32936], [32938, 32938, 32965, 32987, 33270], [33272, 33272, 33300, 33300, 33534], [33536, 33536, 33560, 33560, 33646], [33648, 33648, 33675, 33675, 33888], [33890, 33890, 33916, 33916, 34144], [34146, 34146, 34168, 34168, 34294], [34296, 34296, 34316, 34316, 34376], [34378, 34378, 34410, 34410, 34437], [34439, 34439, 34460, 34460, 34482], [34484, 34484, 34508, 34508, 34568], [34570, 34570, 34604, 34604, 34628], [34630, 34630, 34644, 34644, 34708], [34710, 34710, 34736, 34736, 34774], [34776, 34776, 34802, 34802, 34829], [34831, 34831, 34854, 34854, 34949], [34951, 34951, 34975, 34975, 35044], [35046, 35046, 35071, 35071, 35118], [35120, 35120, 35137, 35137, 35250], [35252, 35252, 35275, 35275, 35404], [35406, 35406, 35434, 35434, 35562], [35564, 35564, 35588, 35588, 35728], [35730, 35730, 35768, 35768, 35902], [35904, 35904, 35941, 35941, 35976], [35978, 35978, 36005, 36005, 36055], [36057, 36057, 36087, 36087, 36143], [36145, 36145, 36174, 36174, 36355], [36357, 36357, 36379, 36379, 36546], [36548, 36548, 36561, 36561, 36600], [36602, 36602, 36632, 36632, 36661], [36663, 36663, 36696, 36696, 36753], [36755, 36755, 36781, 36781, 36831], [36833, 36833, 36854, 36854, 36919], [36921, 36921, 36945, 36945, 37028], [37030, 37030, 37045, 37045, 37086], [37088, 37088, 37104, 37104, 37142], [37144, 37144, 37162, 37162, 37219], [37221, 37221, 37251, 37251, 37651], [37653, 37653, 37711, 37711, 37749], [37751, 37751, 37780, 37780, 37816], [37818, 37818, 37866, 37866, 37897], [37899, 37899, 37933, 37933, 37992], [37994, 37994, 38071, 38071, 38236], [38238, 38238, 38315, 38315, 38395], [38397, 38397, 38473, 38473, 38589], [38591, 38591, 38667, 38667, 38745], [38747, 38747, 38785, 38785, 38819], [38821, 38821, 38843, 38843, 38889], [38891, 38891, 38918, 38918, 38962], [38964, 38964, 39013, 39013, 39274], [39276, 39276, 39349, 39349, 39403], [39405, 39405, 39437, 39437, 39473], [39475, 39475, 39531, 39531, 39587], [39589, 39589, 39619, 39619, 39712], [39713, 39713, 39753, 39753, 39776], [39778, 39824, 39863, 39863, 41019], [41021, 41021, 41051, 41051, 41153], [41155, 41155, 41207, 41207, 41247], [41249, 41249, 41271, 41271, 41322], [41324, 41324, 41356, 41356, 41378], [41380, 41395, 41417, 41417, 41709], [41711, 41711, 41743, 41743, 41765], [41767, 41767, 41786, 41786, 41818], [41867, 41930, 41972, 41972, 42038], [42040, 42110, 42161, 42161, 42513], [42515, 42549, 42595, 42595, 43107], [43109, 43178, 43224, 43224, 43730], [43732, 43732, 43765, 43765, 43981], [43983, 43983, 44042, 44042, 44087], [44089, 44089, 44132, 44132, 44193], [44195, 44195, 44237, 44237, 44279], [44281, 44341, 44398, 44398, 44597]]}
{"id": "4lSyzm", "name": "paper latern analysis", "author": "ollj", "description": "fork of \nhttps://www.shadertoy.com/view/Md3XDB\nsimplified, asin, textures removed.", "tags": ["sss", "glow", "scattering", "polar", "paper", "latitude", "lantern", "longidude"], "likes": 1, "viewed": 463, "published": "Public API", "date": "1507841138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//parent: https://www.shadertoy.com/view/Md3XDB\n// Paper Lantern created by SeongWan Kim (kaswan / twitter @idgmatrix)\n// Thanks to iq and @kevinroast \n// shadow and glow effect codes from http://www.kevs3d.co.uk/dev/shaders/distancefield6.html\n\n//heuristic epsilon tolerance\n#define eps .005\n//iterate raymarching\n#define iterGd 256.\n//iterate ambient occlusion\n#define iterAO 4.\n//iterate SubSurfaceScatter\n#define iterSss 5.\n//iterate shadow \n#define iterShadow 32.\n\n//hard shadows do not work here. illusion fails\n#define doSoftShadow\n\n#define lightColor vec3(1.2,1.,.5)\n#define sssColor vec3(1.9 + 0.1 * abs(sin(iTime * 6.0)), 1.3, 0.5)\n\n\nmat2 r2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\n//above performed much slower than below:\nvec2 r2(vec2 p,float a){return p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}\n\n\nfloat sphere(vec3 u)\n{float t=iTime*.5//spin speed\n;vec2 rims=vec2(5,8)//number ofscafold-hoops.\n;u.xz=r2(u.xz,t)//spin axis\n;float d=length(u)\n;vec2 l=abs(sin(vec2(atan(u.z,u.x),asin(u.y/d))*rims)*.15)\n;return d+l.x*l.y-1.;}\n\nfloat cylinder(vec3 u,vec3 c){return length(u.xz-c.xy)-c.z;}\n\nfloat paperLantern(vec3 u)\n{return max(sphere(u), -cylinder(u, vec3(0,0,.45)));}\n\n//endless plane and its matrial BHV\nfloat plane(vec3 pos, vec4 n,inout bool p)\n{float d=dot(pos,n.xyz)-n.w\n;if(d<eps)p=true\n;return d;}\n\nfloat gd(vec3 pos,out bool p){p=false\n;float d=paperLantern(pos)\n;d=min(d,plane(pos,vec4( 0,1, 0,-1.2),p))\n;d=min(d,plane(pos,vec4( 0,0,-1,-9.),p))\n//p is broken on above plane. no clue why.\n;d=min(d,plane(pos,vec4( 1,0, 0, -6.),p))\n;d=min(d,plane(pos,vec4(-1,0, 0, -6.),p))\n;return d;}\n\nfloat calcAO(vec3 u,vec3 n)\n{float r=.0,w=1.;bool p=false//if material is off the ball plane\n;for(float i=1.;i<iterAO;i++\n){float d=float(i)*.2;r+=w*(d-gd(u+n*d,p));w*=.5;\n}return 1.-clamp(r,.0,1.);}\n\nfloat calcSSS(vec3 u,vec3 t){float r=.0,w=.5//accumulator,weights\n;for(float i=1.;i<iterSss;i++){float d=pow(float(i),2.5)*eps*32.\n ;r -=w*min(.0,sphere(u+t*d));w*=.9;}return clamp(r, 0.0, 1.0);}\n\n#ifdef doSoftShadow\n//LightSource,LightDirection,ShadowHardness\nfloat shadow(vec3 u,vec3 t,float h){bool b=false\n;float a=1.,w=.12//accumulator,weights\n;for(float i=.0;i<iterShadow;i++\n){float d= gd(u+t*w,b); a=min(a,h*d/w);w+=d;if(w>5.)break; \n}return clamp(a,.0,1.);}\n#else\nfloat shadow(vec3 u, vec3 t,float h){bool b=false;\n;vec3 p=u+t*.12\n;for(float i =.0;i<iterShadow;i++\n){float d=gd(p,b)\n ;if (d<eps)return .0;p+=t*d;}return 1.;}\n#endif\n\nvoid mainImage(out vec4 o,vec2 u)\n{u=u.xy/iResolution.xy\n;u=u*2.-1.\n;u.x*=iResolution.x/iResolution.y\n;vec3 t=normalize(vec3(u,-2.)-vec3(0,0,-5))\n;vec3 s=-2.*vec3(sin(iTime*.5),-1.5,cos(iTime*.5))\n//;vec3 s = vec3(-2.0, 3.0, -2.0)\n;vec3 p = vec3(0,0,-5.)\n;float d\n;bool b=false\n//oh no, this is bad style, a return in the mainImage loop.\n;for (float i=.0;i<iterGd;i++\n){d=gd(p,b)\n ;if(d<eps//hit surface\n ){vec2 e= vec2(eps,0)\n  ;vec3 n=normalize(vec3(gd(p+e.xyy,b)-gd(p-e.xyy,b)\n  ,gd(p+e.yxy,b)-gd(p-e.yxy,b),gd(p+e.yyx,b)-gd(p-e.yyx,b)))\n  ;vec3 l=normalize(s-p)//light direction\n  ;vec3 c=max(dot(n,l),.0)*lightColor*.5\n      \n      //texturing disabled, and also sligly damaged.\n  //;if (b) {\n  ;if (true) {//same texture for all,\n       // ;vec4 tex\n                //because i sligthly broke the textureID code here.\n            \t//vec4 c;\n\t\t\t\t//tex = texture(iChannel0, u.yz * 0.2) * abs(n.x);\n            \t//tex += texture(iChannel0, u.zx * 0.2) * abs(n.y);\n            \t//tex += texture(iChannel0, u.xy * 0.2) * abs(n.z);\n                \n                c *= vec3(1.0, 0.45, 0.1);\n  }else{\n       // ;vec4 tex\n                //vec2 u = vec2(longitude, latitude); \n\t\t\t\t//tex = texture(iChannel1, u * 1.0);\n                \n                c += 0.08;\n  }\n  ;c*=shadow(p,l,8.)*1.5\n  ;c=mix(c,sssColor,calcSSS(p,t))\n  //;c =mix(l,sssColor,calcSSS(p,t))//silly one\n  ;c+=calcAO(p,n)*.3\n  ;o=vec4(c,1.)\n  ;return;//bad style to have a return in [void MainImage]\n  }\n  p+=d*t;\n }o=vec4(1,.2,0,1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSyzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[470, 644, 661, 661, 708], [709, 751, 775, 775, 816], [819, 819, 841, 841, 1044], [1046, 1046, 1076, 1076, 1106], [1108, 1108, 1136, 1136, 1188], [1190, 1226, 1270, 1270, 1325], [1327, 1327, 1357, 1357, 1613], [1615, 1615, 1644, 1644, 1814], [1816, 1816, 1845, 1845, 2011], [2458, 2458, 2493, 2493, 3960]]}
{"id": "4t2cDD", "name": "Procedural urban landscape 2", "author": "FabriceNeyret2", "description": "variant of [/url]https://www.shadertoy.com/view/4l2cW1[/url] \ngolfing PrzemyslawZaworski's  [/url]https://www.shadertoy.com/view/Xl2yWh[/url]\n", "tags": ["procedural", "raymarching", "noise", "city", "2tweets", "short", "buildings", "golf"], "likes": 31, "viewed": 1109, "published": "Public API", "date": "1508672124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://www.shadertoy.com/view/4l2cW1\n// golfing PrzemyslawZaworski's https://www.shadertoy.com/view/Xl2yWh\n\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec3 p = vec3( iTime, 3, 0 ) *9.,\n         r = iResolution,\n         d = vec3( ( U - .5*r.xy ) / r.y, 1 );\n    float t = .2;\n    for( d.yz *= mat2(4,-3,3,4)*t ; t>.1; t = min( p.y - 8.*t*t , .2 ) )\n        p += t*d, r = ceil(p/3.),\n        O += t = fract( 4e4* sin(r.x+r.z*17.) );\n    O/=2e2; }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2cDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 125, 161, 161, 460]]}
{"id": "4t2cDW", "name": "AlphaTower", "author": "Del", "description": "A quick Alpha Tower for you all! :) Enjoy!\n\nfixed the glitch by adding the substepping :)", "tags": ["raymarch", "font"], "likes": 10, "viewed": 501, "published": "Public API", "date": "1508641219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// tower & fruit machine reels added by Del\n\n\n#define AA 1   // make this 1 is your machine is too slow\n\n#define PI 3.1415926\n#define DEG2RAD ((PI * 2.0) / 360.0)\nfloat tBlend = -1.0;\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\n\n//---------------------------------------------------------\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n\n\n#define XP 0.0\n#define ZP 0.0\n#define HEIGHT 0.4\n#define FONTTHICKNESS 0.1\n#define INNER 1.9\n\nstruct ReelData\n{\n  float rot;\n};\n\nvec3 p00 = vec3(XP, 2.7, ZP);\n\nReelData dat[4] = ReelData[4](\n    ReelData(0.0),\n    ReelData(0.0),\n    ReelData(0.0),\n    ReelData(0.0)\n);\n    \n// crap stuff\n// dirty... not sure if I am doing this correctly...\nvec4 SampleFontTex(vec2 uv,float xoff)\n{\n    uv = uv.yx;\n    uv.x = -uv.x;\n//    uv += 0.04;\n    uv.x += 0.04 + (0.25 * xoff);\n    uv *= 0.25;\n    vec2 fl = floor(uv + 0.5);\n    uv = fl + fract(uv+0.5)-0.5;\n    \n    // Sample the font texture. Make sure to not use mipmaps.\n    // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n    //return texture(iChannel0, (uv+0.5)*((1.0/16.0)*8.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.00001);\n    return texture(iChannel0, uv, -100.0) + vec4(0.0, 0.0, 0.0, 0.00001);\n}\n\n\n//------------------------------------------------------------------\n\nvec2 reel (in vec3 pos)\n{\n   \tfloat _mat1 = 230.0;\t// tower\n\tfloat _mat2 = 20.0;\t// font\n\n    float sv = 4.0 * sin(pos.y*0.1+dat[1].rot*0.01);\n    \n    float cval = abs(pos.y)*12.0;\n    \n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\n    float _index = pModInterval1(pos.y,1.0,-3.0,3.0);\n    int index = int(abs(_index)) % 4;\n    \n\tpos = rotateY (pos,sv );\t// sin movement (pixel)\n    \n//    pos = rotateY (pos, sin(dat[index].rot*0.02));\t// sin movement (reel)\n//\tpos = rotateY (pos,  DEG2RAD*dat[index].rot);\t// spin\n    \n    float innercylinderdist = sdCylinder(pos,vec2(INNER,HEIGHT));\n    float d1 = sdCylinder(pos,vec2(INNER+FONTTHICKNESS,HEIGHT));\n \t// Load the font texture's distance field.\n\tvec4 _c = SampleFontTex( vec2(atan(pos.x,pos.z), 0.5+(pos.y*0.75)) / PI, 13.0);\n    float letterDistField = _c.w - 0.5+1.0/256.0;\n    d1 = max(letterDistField,d1);\n    \n    vec2 res = vec2( d1, _mat2 + cval);\n    \n    d1 = sdCylinder(pos,vec2(INNER-0.01,HEIGHT+0.1));\n    res.x = opS(res.x, d1 );\n    \n    res = opU(res, vec2( d1, _mat1 ) );\n    return res;\n    \n}\n\n\n\n\n\n//------------------------------------------------------------------\n// old alpha tower version...\nconst vec3 p01 = vec3(XP+0.0,5.95, ZP+0.0);\n\nvec4 SampleFontTex(vec2 uv)\n{\n    vec2 fl = floor(uv + 0.5);\n    uv = fl + fract(uv+0.5)-0.5;\n    // Sample the font texture. Make sure to not use mipmaps.\n    // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n    return texture(iChannel0, (uv+0.5)*((1.0/16.0)*8.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.00001);\n}\n\nvec2 _maptower( in vec3 pos )\n{\n\tvec3 r1, r2;\n\tfloat d1 = 0.0f;\n\tfloat d2 = 0.0f;\n\tfloat _mat1 = 230.0;\t// tower\n\tfloat _mat2 = 48.0;\t// font\n       \n\tvec2 res = vec2( sdPlane(pos), 1.0 ); \t\t\t// floor (checker)\n    \n\tr1 = rotateY (pos-p01,  dat[0].rot*0.02);\n\tr1 = rotateX (r1,  DEG2RAD*0.0);\n    d1 = sdCylinder(r1,vec2(1.90,6.0));\n    res = opU(res, vec2( d1, _mat1 ) );\n\n    d1 = sdCylinder(r1,vec2(2.0,6.0));\n \t// Load the font texture's distance field.\n\tvec4 _c = SampleFontTex( vec2(atan(r1.x,r1.z), r1.y) / PI);\n    float letterDistField = _c.w - 0.5+1.0/256.0;\n    d1 = max(letterDistField,d1);\n    \n    float cval = pos.y*30.0;\n    res = opU(res, vec2( d1, _mat2+ cval)  );\n    \n    // More accuracy (substepping)\n\tres.x *= 0.85;\n    \n\treturn res;\n}\n\n\n\nvec2 map( in vec3 pos )\n{\n    \n    vec2 res = vec2( sdPlane(pos), 1.0 ); \t\t\t// floor (checker)\n\n    vec2 res2 = res;\n    res2 =  opU(res2,_maptower(pos));\n    \n\n    pos = rotateX (pos-p00,  DEG2RAD*270.0);\n\n    res =  opU(res,reel(pos));\n\n    // More accuracy (substepping)\n\tres.x *= 0.85;\n\n    // blend the scenes...\n    return mix(res2, res, tBlend);\n    \n    \n//\tres.x *= 0.85;\n//\treturn res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n       \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(0.5*pos.z) + floor(0.5*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n#if 1\n        // lighting        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n#endif\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    if (iMouse.z<0.5)\n        mo = vec2((180.0 * DEG2RAD)/6.0,0.0);\n    \n\t// blend...\n\ttBlend = cos(iTime*0.4);\n    tBlend*=2.0f;\n    \n    tBlend = clamp(tBlend,0.0,1.0);\n        \n\tfloat time = iTime;\n    dat[0].rot += time*25.0;\n    dat[1].rot += time*50.0;\n    dat[2].rot += time*75.0;\n    dat[3].rot += time*100.0;\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        //vec3 ro = vec3( 6.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 6.5*sin(0.1*time + 6.0*mo.x) );\n        \n\t\tfloat ang = 180.0 * DEG2RAD;        \n        vec3 ro = vec3( 6.5*cos(ang+(6.0*mo.x)), 4.0 + 2.0*mo.y, 6.5*sin(ang+(6.0*mo.x)) );\n        vec3 ta = vec3( 0.0, 2.0, 0.0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2cDW.jpg", "access": "shaders20k", "license": "mit", "functions": [[1267, 1337, 1362, 1362, 1377], [1379, 1379, 1415, 1415, 1514], [1515, 1585, 1618, 1618, 1644], [1646, 1646, 1676, 1676, 1709], [1711, 1711, 1741, 1741, 1770], [1772, 1772, 1796, 1796, 1928], [1930, 2027, 2100, 2100, 2386], [2389, 2502, 2552, 2552, 2944], [2947, 3007, 3038, 3038, 3144], [3145, 3145, 3176, 3176, 3283], [3284, 3284, 3315, 3315, 3421], [3699, 3766, 3806, 3806, 4325], [4328, 4398, 4423, 4423, 5513], [5519, 5663, 5692, 5692, 6028], [6030, 6030, 6061, 6061, 6788], [6792, 6792, 6817, 6817, 7189], [7191, 7191, 7231, 7231, 7561], [7564, 7564, 7638, 7638, 7898], [7900, 7900, 7932, 7932, 8371], [8373, 8373, 8415, 8415, 8714], [8716, 8716, 8755, 8755, 10337], [10339, 10339, 10391, 10391, 10567], [10569, 10569, 10626, 10626, 12015]]}
{"id": "4t2cRW", "name": "Birthday Cake", "author": "starea", "description": "Birthday cake for my MSRA mentor, Zhiwei Li.\nBorrowed much code from iq's Raymarching Tutorial long time ago.\nCannot find my source code before compression :-(\n", "tags": ["birthday", "cake"], "likes": 0, "viewed": 405, "published": "Public API", "date": "1507653553", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float u(vec3 c){return c.y;}\nfloat v(vec3 c,vec2 d){vec2 e=abs(vec2(length(c.xz),c.y))-d;return min(max(e.x,e.y),0.)+length(max(e,0.));}\nfloat w(in vec3 c,in vec3 d){vec2 e=vec2(length(c.xz),c.y);\nfloat f,g;f=-c.y-d.z;g=max(dot(e,d.xy),c.y);return length(max(vec2(f,g),0.))+min(max(f,g),0.);}\nvec2 x(vec2 c,vec2 d){return c.x<d.x?c:d;}vec2 y(float c){vec2 d=vec2(c);d=vec2(dot(d,vec2(127.1,311.7)),\n                                                                                dot(d,vec2(269.5,183.3)));\n                     return -1.+2.*fract(sin(d)*43758.5453123);}\nvec2 z(in vec3 c){vec2 d=x(vec2(u(c),1),vec2(v(c-vec3(0),vec2(1,.6)),31.9));for(float e=-.5;e<=.5;e+=.5){\n    float f,g;f=e;g=abs(e)<.1?.1:.2;d=x(d,vec2(v(c-vec3(-.5+g,0,f),vec2(.05,.8)),55));d=x(d,\n                vec2(w(c-vec3(-.5+g,.9+y(iTime).x/1e2,f),vec3(.5,.08,.1)),30));}\n                  for(float e=0.;e<=.5;e+=.25)for(float f=-.25;f<=.25;f+=.25){\n                      float g,h;g=abs(f)<.1?-.1:0.;h=0.;d=x(d,vec2(v(c-vec3(e+g,0,f+h),\n                                                                     vec2(.02,.8)),50));\n                      d=x(d,vec2(w(c-vec3(e+g,.85+y(iTime).x/1e2,f+h),vec3(.4,.03,.06)),30));}\n                  return d;}vec2 A(in vec3 c,in vec3 d){float e,f,i,j,k;e=1.;f=20.;i=.002;j=e;k=-1.;\n                                                        for(int l=0;l<50;l++){vec2 m=z(c+d*j);if(m.x<i||j>f)break;j+=m.x;k=m.y;}if(j>f)k=-1.;return vec2(j,k);}float B(in vec3 c,in vec3 d,in float e,in float f){float g,h;g=1.;h=e;for(int i=0;i<16;i++){float j=z(c+d*h).x;g=min(g,8.*j/h);h+=clamp(j,.02,.1);if(j<.001||h>f)break;}return clamp(g,0.,1.);}vec3 C(in vec3 c){vec3 d,e;d=vec3(.001,0,0);e=vec3(z(c+d.xyy).x-z(c-d.xyy).x,z(c+d.yxy).x-z(c-d.yxy).x,z(c+d.yyx).x-z(c-d.yyx).x);return normalize(e);}float D(in vec3 c,in vec3 d){float e,f;e=0.;f=1.;for(int g=0;g<5;g++){float h,j;h=.01+.12*float(g)/4.;vec3 i=d*h+c;j=z(i).x;e+=-(j-h)*f;f*=.95;}return clamp(1.-3.*e,0.,1.);}vec3 E(in vec3 c,in vec3 d){vec3 e=vec3(.8,.9,1);vec2 f=A(c,d);float g,h;g=f.x;h=f.y;if(h>-.5){vec3 i,j,k,m,t;i=c+g*d;j=C(i);k=reflect(d,j);e=.45+.3*sin(vec3(.05,.08,.1)*(h-1.));if(h<1.5){float l=mod(floor(5.*i.z)+floor(5.*i.x),2.);e=.4+.1*l*vec3(1);}float l,n,o,p,q,r,s;l=D(i,j);m=normalize(vec3(-.6,.7,-.5));n=clamp(.5+.5*j.y,0.,1.);o=clamp(dot(j,m),0.,1.);p=clamp(dot(j,normalize(vec3(-m.x,0,-m.z))),0.,1.)*clamp(1.-i.y,0.,1.);q=smoothstep(-.1,.1,k.y);r=pow(clamp(1.+dot(j,d),0.,1.),2.);s=pow(clamp(dot(k,m),0.,1.),16.);o*=B(i,m,.02,2.5);q*=B(i,k,.02,2.5);t=vec3(0);t+=1.2*o*vec3(1,.9,.6);t+=1.2*s*vec3(1,.9,.6)*o;t+=.3*n*vec3(.5,.7,1)*l;t+=.4*q*vec3(.5,.7,1)*l;t+=.3*p*vec3(.25)*l;t+=.4*r*vec3(1)*l;t+=.02;e=e*t;e=mix(e,vec3(.8,.9,1),1.-exp(-5e-4*g*g));}return vec3(clamp(e,0.,1.));}mat3 F(in vec3 c,in vec3 d,float e){vec3 f,g,h,i;f=normalize(d-c);g=vec3(sin(e),cos(e),0);h=normalize(cross(f,g));i=normalize(cross(h,f));return mat3(h,i,f);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 c,d,e;\n    c=fragCoord.xy/iResolution.xy;d=-1.+2.*c;d.x*=iResolution.x/iResolution.y;e=iMouse.xy/iResolution.xy;\n    float f=15.+iTime;vec3 g,h,j,k;\n    g=vec3(-.5+3.2*cos(.1*f+6.*e.x),1.+2.*e.y,.5+3.2*sin(.1*f+6.*e.x));h=vec3(-.5,-.4,.5);\n    mat3 i=F(g,h,0.);j=i*normalize(vec3(d.xy,2.5));k=E(g,j);k=pow(k,vec3(.4545));\n    fragColor=vec4(k,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2cRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 28], [29, 29, 52, 52, 136], [137, 137, 166, 166, 292], [293, 293, 315, 315, 335], [335, 335, 351, 351, 570], [571, 571, 589, 589, 1230], [1230, 1230, 1258, 1258, 1462], [1462, 1462, 1513, 1513, 1653], [1653, 1653, 1671, 1671, 1804], [1804, 1804, 1833, 1833, 1977], [1977, 1977, 2005, 2005, 2764], [2764, 2764, 2800, 2800, 2922], [2925, 2925, 2982, 2982, 3340]]}
{"id": "4t2cWh", "name": "TheSkyWasSoPurple", "author": "Del", "description": "Purpleness", "tags": ["spiral", "radial", "frig"], "likes": 12, "viewed": 299, "published": "Public", "date": "1508370178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.141592\n\n// tweaked version of this by 'bmodone' - https://www.shadertoy.com/view/4llcDH\n// updated a bit since fabrice kindly commented :)\n\nfloat radial(vec2 uv, float offset, float repeat)\n{\n    float a = mod((atan(uv.y, uv.x) + M_PI + (offset * 2.0 * M_PI)) * repeat / M_PI, 2.0);\n    return min(a, 2.0 - a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord -.5 * iResolution.xy )/ iResolution.y;\n       \n    float _d = length(uv); \n \tfloat d = _d - 0.75;\n    float off = _d;\n    float a = radial(uv, sin(off*6.0-iTime*0.8)*0.161, 7.0) - 0.9;\n\n    d = off - d*d+d+a*a+d;\n    float m = _d+d+off;\n    \n    vec3 col = mix(vec3(0.1, 0.1, 0.19), vec3(0.18, 0.13, 0.31), m);\n    col = (col-off*off)+d+a;\n    \n    vec3 backg = vec3(0.32,0.1,0.68);\n    \n    float m2 = col.r+col.g+col.b*0.25;\n    col = mix(backg,col,m2);\n    col *= _d-0.01;\n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2cWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 155, 206, 206, 327], [329, 329, 386, 386, 923]]}
{"id": "4t2cz1", "name": "Arabian Nights", "author": "riouxld", "description": "test", "tags": ["raymarching"], "likes": 4, "viewed": 153, "published": "Public", "date": "1507507859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 400;\n\nconst float EARTH_RADIUS = 1500.0;\n\nconst float MOON_RADIUS = 30.0;\nconst vec3 MOON_POSITION = vec3(0.0, 100.0,540.0);\n\nconst int OCTAVE_OCEAN = 5;\nconst float PERSISTENCE_OCEAN = 0.5;\nconst vec2 FREQUENCY_OCEAN = vec2(2.2, 2.2);\nconst float AMPLITUDE_OCEAN = 0.05;\nconst vec2 SPEED_OCEAN = vec2(1.4,1.5);\n\nconst int OCTAVE_LAND = 2;\nconst float PERSISTENCE_LAND = 0.70;\nconst vec2 FREQUENCY_LAND = vec2(0.15, 0.15);\nconst float AMPLITUDE_LAND =2.0;\nconst vec2 SPEED_LAND = vec2(0.0);\n\n\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 550.0;\nconst float EPSILON = 0.005;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n    \n    vec3 diffuse;\n    vec3 specular;\n    \n    float constant;\n    float linear;\n    float quadratic;\n};\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    \n    float shininess;\n};\n    \nstruct Sphere {\n    float radius;\n    vec3 center;\n    Material material;\n};\n    \n\nstruct Intersect {\n    float depth;\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\n\n/*\nfloat noise( in vec2 x )\n{\n    #if 0\n    \n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = p.xy + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, 1.0);\n    \n    #else\n    \n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy;\n\tvec2 rgA = texelFetch( iChannel0, (uv+ivec2(0,0))&255, 0 ).yx;\n    vec2 rgB = texelFetch( iChannel0, (uv+ivec2(1,0))&255, 0 ).yx;\n    vec2 rgC = texelFetch( iChannel0, (uv+ivec2(0,1))&255, 0 ).yx;\n    vec2 rgD = texelFetch( iChannel0, (uv+ivec2(1,1))&255, 0 ).yx;\n    vec2 rg = mix( mix( rgA, rgB, f.x ),\n                   mix( rgC, rgD, f.x ), f.y );\n    return mix( rg.x, rg.y, 1.0 );\n    \n    #endif\n}\n*/\nfloat random (vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n/*\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix( hash(p+vec2(0,0)), \n                        hash(p+vec2(1,0)),f.x),\n                   mix( hash(p+vec2(0,1)), \n                        hash(p+vec2(1,1)),f.x),f.y);\n}\n\n*/\n\n\nfloat octaveNoise (vec2 st, int octaves, float persistence, vec2 frequency, float amplitude, vec2 speed) {\n    float total = 0.0;\n    vec2 freq = frequency;\n    float amp = amplitude;\n    \n    for(int i=0;i<octaves;i++) {\n        total += noise(vec2(st.x * freq.x-speed.x*iTime, st.y * freq.y+speed.y*iTime)) * amp;\n        amp *= persistence;\n        freq.x *= 2.4;\n        freq.y *= 2.5;\n    }\n    \n    return total;\n}\n\n\nconst Sphere sphereMoon = Sphere(MOON_RADIUS, MOON_POSITION,\n                             Material( vec3(0.05, 0.05, 0.05),\n                                vec3(1.0, 1.0, 1.0),\n                                0.1*vec3(1.0, 1.0, 1.0),\n                                0.1));\n\n\nconst Sphere sphereOcean = Sphere(EARTH_RADIUS, vec3(0.0, -EARTH_RADIUS-2.5,0.0),\n                             Material( vec3(0.07, 0.45, 0.4),\n                                  vec3(0.07, 0.45, 0.4),\n                                  vec3(1.0, 1.0, 1.0),\n                                  0.6));\n\nconst Sphere sphereLand = Sphere(EARTH_RADIUS-1.22, vec3(0.0, -EARTH_RADIUS-2.5,0.0),\n                             Material( vec3(0.55, 0.27, 0.1),\n                                   0.75*vec3(0.55, 0.27, 0.1),\n                                   0.1*vec3(1.0, 1.0, 1.0),\n                                  0.05));\n\nfloat moonSDF(vec3 samplePoint, Sphere sphere) {\n    return length(samplePoint-sphere.center + vec3(sin(iTime)/3.0,1.2+sin(iTime)/6.0,cos(iTime)/4.0)) - sphere.radius;\n}\n\nfloat oceanSDF(vec3 samplePoint, Sphere sphere) {\n    return length(samplePoint-sphere.center) \n        - sphere.radius -octaveNoise (samplePoint.xz, OCTAVE_OCEAN, PERSISTENCE_OCEAN, FREQUENCY_OCEAN, AMPLITUDE_OCEAN, SPEED_OCEAN);\n}\n\nfloat landSDF(vec3 samplePoint, Sphere sphere) {\n    return length(samplePoint-sphere.center) \n        - sphere.radius -octaveNoise (samplePoint.xz, OCTAVE_LAND, PERSISTENCE_LAND, FREQUENCY_LAND, AMPLITUDE_LAND, SPEED_LAND);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    return min(min(oceanSDF(samplePoint, sphereOcean),landSDF(samplePoint, sphereLand)),moonSDF(samplePoint, sphereMoon));\n}\n\n\nfloat shortestDistanceToSurface(Ray ray) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(ray.origin + depth * ray.direction);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nfloat shortestDistanceToLand(Ray ray) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = landSDF(ray.origin + depth * ray.direction, sphereLand);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n            \nvec3 calcNormal(vec3 p) {\n    \n    float ref = sceneSDF(p);\n    return normalize(vec3(\n        ref - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        ref - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        ref - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(Ray ray, Intersect intersection, Light light) {\n    vec3 N = intersection.normal;\n    vec3 L = normalize(light.position - intersection.position);\n    vec3 V = normalize(ray.origin - intersection.position);\n    vec3 R = normalize(reflect(-L, intersection.normal));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0);\n    } \n    \n    float Ldist = length(light.position - intersection.position);\n    float attenuation = 1.0 / (light.constant + light.linear * Ldist + \n                                   light.quadratic * (pow(Ldist,2.0)));\n    \n    vec3 diffuse = light.diffuse*intersection.material.diffuse * dotLN;\n    \n    if (shortestDistanceToLand(Ray(intersection.position + EPSILON*intersection.normal, L))!=MAX_DIST)\n    {\n        return 0.3*diffuse;\n    }\n    \n    if (dotRV < 0.0) {\n        return diffuse;\n    }\n    \n    vec3 specular = light.specular*intersection.material.specular * pow(dotRV, intersection.material.shininess * 128.0);\n    \n    return (diffuse+specular)*attenuation;\n    \n}\n    \n\nvec3 phongIllumination(Ray ray, Intersect intersection) {\n    \n    vec3 ambient =  0.4*vec3(1.0)*intersection.material.ambient;\n    \n    vec3 color = ambient;\n\n    Light light2 = Light( \n     MOON_POSITION+vec3(MOON_RADIUS, 15.0,-60.0),\n     vec3(1.0, 1.0, 1.0),\n     vec3(1.0, 1.0, 1.0),\n     1.0,\n     0.0000007,\n     0.000000002);\n    \n    color += phongContribForLight(ray, intersection, light2);\n    \n    return color;\n}\n\nvec3 rayTracer(Ray ray)\n{\n    float dist = shortestDistanceToSurface(ray);\n\n    if (dist > MAX_DIST - EPSILON) {\n        return vec3(0.02,0.0,0.1);\n    }\n    \n    vec3 p = ray.origin + dist * ray.direction;\n    Intersect intersection = Intersect(dist, p, calcNormal(p), \n                                       Material(vec3(0.0), \n                                                vec3(0.0), \n                                                vec3(0.0),\n                                                0.0));\n    \n    if (moonSDF(p, sphereMoon)<= EPSILON) intersection.material = sphereMoon.material;\n    if (oceanSDF(p, sphereOcean)<=EPSILON) intersection.material = sphereOcean.material;\n    if (landSDF(p, sphereLand)<=EPSILON) intersection.material = sphereLand.material;\n    \n    \n    return phongIllumination(ray, intersection);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= aspectRatio;\n    \n    vec3 eye = vec3(0.0, 0.25, -1.0);\n    Ray ray = Ray(eye,normalize(vec3(uv.x, uv.y, 0.0)-eye));\n    \n    fragColor = vec4(rayTracer(ray), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2cz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1099, 1850, 1874, 1874, 1992], [1994, 1994, 2017, 2017, 2359], [2360, 2802, 2908, 2908, 3222], [4112, 4112, 4160, 4160, 4281], [4283, 4283, 4332, 4332, 4515], [4517, 4517, 4565, 4565, 4743], [4745, 4745, 4779, 4779, 4904], [4907, 4907, 4949, 4949, 5276], [5278, 5278, 5317, 5317, 5655], [5669, 5669, 5694, 5694, 5929], [5932, 5932, 6005, 6005, 7024], [7031, 7031, 7088, 7088, 7456], [7458, 7458, 7483, 7483, 8290], [8292, 8292, 8349, 8349, 8650]]}
{"id": "4t2czK", "name": "cheap Hamiltonian blur ", "author": "FabriceNeyret2", "description": "sum MIPmap LODs with weight m^i    with m = yMouse*2 or animated range [0,2]  (bottom-left : back to auto).\nNote that m ~ 0.7 is quite improving the original.\nRadial blur is xMouse>.5.", "tags": ["blur", "filter", "integration", "gpmipmap"], "likes": 8, "viewed": 605, "published": "Public API", "date": "1509294190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         M = iMouse.xy;\n\tU /= R;\n    if (length(M)>10.) M/=R; else M = .5 + .5* cos(iTime*vec2(.5,1));\n    O-=O;\n    float s=0., w, l = 2.*M.y ;\n    if (M.x > .5) l *= smoothstep(0.,1.,length(2.*U-1.) );  \n    \n    for (float i=0.; i<9.; i++) {\n        w = pow(l,i);\n        O += w * textureLod(iChannel0, U, i );\n        s += w;\n    }\n    O = O/s;\n    \n    O += smoothstep(1./R.y, -1./R.y,  length( U - vec2(1, l/2.) ) - .02);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2czK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 497]]}
{"id": "4t2yW1", "name": "TorusThingy_0", "author": "balkhan", "description": " ", "tags": ["3d", "raymarch", "torus"], "likes": 24, "viewed": 318, "published": "Public", "date": "1508404339", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t10.\n#define PI\t\t\t3.14\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    pos.z = 4.5+1.5*sin(t*10.);    \n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    if (inter.y <= FAR)\n        col.xyz = ret_col*(1.-inter.x*.0025);\n    else\n        col *= 0.;\n    col += h*.005125;\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    rotate(p.xz, 1.57-.5*iTime);\n    rotate(p.yz, 1.57-.5*iTime);\n    vec2 q = vec2(length(p.xy)-2.,p.z);\n    \n    var =\n        step(cos(floor( (atan(p.x,p.y))*10.)/1.+iTime*1.)*3.14, atan(q.x, p.z ))\n        *\n        step(atan(q.x, p.z )-2., cos(floor( (atan(p.x,p.y))*10.)/1.+iTime*1.)*3.14)\n        ;\n    \n    ret_col = 1.-vec3(.5-var*.5, .5, .3+var*.5);\n    mind = mylength(q)-.5-.1*var;\n    h += vec3(.5,.8,.5)*(var!=0.?0.:1.)*vec3(1.)*.0125/(.01+(mind-var*.1)*(mind-var*.1) );\n    h += vec3(.5,.8,.5)*(var!=0.?1.:0.)*vec3(1.)*.0125/(.01+mind*mind);\n    \n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n    \n    p = p*p*p*p;\n    p = p*p;\n    ret = (p.x+p.y);\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2yW1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[427, 568, 611, 611, 1019], [1021, 1021, 1042, 1042, 1664], [1666, 1666, 1698, 1698, 2109], [2111, 2111, 2135, 2135, 2253], [2255, 2269, 2309, 2309, 2384], [2386, 2386, 2414, 2414, 2522], [2524, 2524, 2546, 2546, 2752], [2754, 2754, 2804, 2804, 3067]]}
{"id": "4tBcWz", "name": "Aurora Curtains", "author": "dr2", "description": "Aurora - see source for details", "tags": ["aurora"], "likes": 17, "viewed": 1123, "published": "Public API", "date": "1508151889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Aurora Curtains\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n The curtain forms seen in the aurora borealis (and australis) are presumably \n due to wavelike fluctuations in the magnetosphere. Here the auroral effect is \n achieved using the same technique as for ocean waves (rather than the more \n complicated scheme in nimitz's \"Auroras\"). Reminds me of the view near Denali, \n with enhanced brightness and some speedup (plus you don't have to go out in the \n cold late at night to see it). Mousing encouraged.\n*/\n\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec3 HsvToRgb (vec3 c);\n\nfloat tCur;\nconst float pi = 3.14159;\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 t;\n  float wFreq, wAmp, ht;\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t = 0.05 * tCur * vec2 (1., -1.);\n    t4 = (p.xyxy + t.xxyy) * wFreq;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    ht += wAmp * dot (pow (1. - sqrt (v4.xz * v4.yw), vec2 (8.)), vec2 (1.));\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec4 AurCol (vec3 ro, vec3 rd)\n{\n  vec4 col, mCol;\n  vec3 p, dp;\n  float ar;\n  dp = rd / rd.y;\n  p = ro + (40. - ro.y) * dp;\n  col = vec4 (0.);\n  mCol = vec4 (0.);\n  for (float ns = 0.; ns < 50.; ns ++) {\n    p += dp;\n    ar = 0.05 - clamp (0.06 * WaveHt (0.01 * p.xz), 0., 0.04);\n    mCol = mix (mCol, ar * vec4 (HsvToRgb (vec3 (0.34 + 0.007 * ns, 1., 1. - 0.02 * ns)), 1.), 0.5);\n    col += mCol;\n  }\n  return col;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  vec3 rds;\n  rds = floor (2000. * rd);\n  rds = 0.00015 * rds + 0.1 * Noisefv3 (0.0005 * rds.yzx);\n  for (int j = 0; j < 19; j ++) rds = abs (rds) / dot (rds, rds) - 0.9;\n  return 0.3 * vec3 (1., 1., 0.9) * min (1., 0.5e-3 * pow (min (6., length (rds)), 5.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 aCol;\n  vec3 col;\n  float dstWat, rFac;\n  rFac = 1.;\n  if (rd.y < 0.) {\n    dstWat = - ro.y / rd.y;\n    ro += dstWat * rd;\n    rd = reflect (rd, VaryNf (3. * ro + 0.2 * tCur, vec3 (0., 1., 0.),\n       0.5 * (1. - smoothstep (10., 30., dstWat))));\n    rFac = 0.8;\n  }\n  if (rd.y < 0.04 * Fbm1 (32. * atan (rd.x, - rd.z)) + 0.01) col = vec3 (0.1, 0.1, 0.12);\n  else {\n    aCol = AurCol (ro, rd);\n    col = rFac * ((1. - 0.5 * aCol.a) * SkyCol (rd) + 0.6 * aCol.rgb);\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 uv, ori, ca, sa;\n  float el, az;\n  uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 0.8 * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    az += 0.5 * pi * sin (0.005 * pi * tCur);\n    el += 0.05 * pi * sin (0.007 * pi * tCur);\n  }\n  el = clamp (el, -0.35 * pi, 0.1 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 2., -4.);\n  rd = vuMat * normalize (vec3 (uv, 2.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p); \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBcWz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[123, 756, 779, 779, 1309], [1311, 1311, 1343, 1343, 1729], [1731, 1731, 1754, 1754, 2016], [2018, 2018, 2053, 2053, 2579], [2581, 2581, 2637, 2637, 3445], [3479, 3479, 3503, 3503, 3556], [3558, 3558, 3582, 3582, 3712], [3714, 3714, 3738, 3738, 3958], [3960, 3960, 3985, 3985, 4132], [4134, 4134, 4159, 4159, 4345], [4347, 4347, 4372, 4372, 4597], [4599, 4599, 4621, 4621, 4775], [4777, 4777, 4806, 4806, 5022], [5024, 5024, 5063, 5063, 5243], [5245, 5245, 5269, 5269, 5405]]}
{"id": "4tByzD", "name": "Raymarching simple - 1st script", "author": "CodingDuff", "description": "First implementation of raymarching, Maybe some improvements are needed...", "tags": ["simpleraymarching"], "likes": 1, "viewed": 147, "published": "Public", "date": "1507896506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**** Constants ****/ \n#define MAXIMUM_RAY_STEPS 255\n#define EPSILON 0.0001\n#define MIN_DIST 0.001\n#define MAX_DIST 300.0\n\nstruct PhongMaterial\n{\n    vec3 diffColor;\n    float spec;\n    bool receiveShadows;\n};\n\n    \n/**** Eye Vector ****/\n/**** uv -> [-1,1]^2, screenspace ****/\n/**** fov -> R, angle in degree   ****/\n/**** returns normalized direction vector through camera ****/\nvec3 getEyeVector(vec2 uv, float fov)\n{\n    float theta = tan(radians(fov/2.0));\n\treturn normalize(vec3(uv.x*theta, uv.y*theta, -1.0));\n}\n\n/**** View Matrix ****/\n/**** https://people.freedesktop.org/~idr/glu3/glu3_8h.html ****/\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 fp = normalize(cross(f, up));\n    vec3 u = cross(fp, f);\n    return mat4(\n        vec4(fp, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n/**** Distance field functions ****/\n/*** http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm ***/\n/**** Sphere SDF ****/\nfloat sdfSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\n/**** RoundBox SDF ****/\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n/**** Smooth Interpolation ****/\n/*** http://iquilezles.org/www/articles/smin/smin.htm ***/\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n/**** Scene SDF ****/\nfloat sdfScene(vec3 p)\n{\n    float s = sdfSphere(p,((sin(iTime)/2.0)+1.0) );\n    float r = udRoundBox(p, vec3(.5), 0.01);\n    float x = p.y+2.0;\n    \n  \tfloat d = smin(r, s, 10.0);\n    \n    return min(d,x);\n}\n\n/**** Gradient estimated normal ****/ \n/*** https://en.wikipedia.org/wiki/Gradient ***/\nvec3 gradientNormal(vec3 p) \n{\n    return normalize(vec3(\n        sdfScene( vec3( p.x + EPSILON, p.y, p.z )) - sdfScene( vec3( p.x - EPSILON, p.y, p.z )),\n        sdfScene( vec3( p.x, p.y + EPSILON, p.z )) - sdfScene( vec3( p.x, p.y - EPSILON, p.z )),\n        sdfScene( vec3( p.x, p.y, p.z + EPSILON )) - sdfScene( vec3( p.x, p.y, p.z - EPSILON ))\n    ));\n}\n\n/**** Raymarching ****/\nfloat rayMarch(vec3 o, vec3 dir)\n{\n    // Create array of 2 float that store [0] -> current distance value, [1] ->  last distance value\n    vec2 dist = vec2(MIN_DIST,MIN_DIST);\n    \n    for(int i = 0; i < MAXIMUM_RAY_STEPS; i++)\n    { \n        // Get last dist point on the direction array\n        vec3 p = o + dir * dist.y;\n\n        // Determine minimal distance from all objects in the scene\n        dist.x = sdfScene(p);\n        \n        // Are we touching an object ?\n        if(dist.x < EPSILON)\n        {\n           // Yes so return last depth\n           return dist.y;\n        }\n        \n        dist.y += dist.x;\n        \n        // Is there any object in the scene ?\n        if(dist.y >= MAX_DIST)\n        {\n            return MAX_DIST;\n        }\n    }\n    \n    // All steps have been finished without object collision\n    // Then return max distance\n    return MAX_DIST;\n}\n\n/**** Determines Classic Phong lighting calculation ****/ \n/**** https://en.wikipedia.org/wiki/Phong_reflection_model ****/\nvec3 phongIllumination(PhongMaterial mat, vec3 p, vec3 viewDir)\n{\n    /*** Ambient Light ***/\n    vec3 k_a = vec3(1.0); // Ambient reflection constant\n    vec3 c_a = vec3(0.08) * k_a; // Ambient intensity color\n    \n    /*** One non-directionnal light ***/\n    vec3 p_1stLight = vec3(cos(iTime), 1.0, sin(iTime)) * 10.0; // 1st light position\n    vec3 i_1stLight = vec3(.8, .8, .8); // 1st light intensity\n    \n    /*** Angular calculations ***/\n    vec3 N = gradientNormal(p); // Calculate gradient normal\n    vec3 l = p_1stLight - p; // Light direction\n    vec3 L = normalize(l); // Normalized light direction\n    vec3 V = normalize(-viewDir); // Vector p to cam\n    vec3 R = normalize(reflect(-L, N)); // Reflect vector\n    \n    // Diffuse normal\n    vec3 k_d = mat.diffColor;\n    \n    /*** Diffuse ***/\n    float LN = clamp(dot(L, N), 0.0, 1.0);\n    \n    /*** Specular ***/\n    float kSpec = 256.0;\n    float RV = clamp(dot(R, V), 0.0, 1.0);\n    float spec = mat.spec * pow(RV, kSpec);\n    \n    /*** shadows ***/\n    if(mat.receiveShadows)\n    {      \n        vec3 ps = p + N * MIN_DIST * 200.0;\n        float sDist = rayMarch(ps, normalize(p_1stLight - ps));\n        if(sDist < length(ps - p_1stLight) ) k_d *= 0.2;\n    }\n    \n    /*** Attenuation ***/\n   \tfloat dl = length(l);\n    float c_1 = 0.1;\n    float c_2 = 0.0005;\n\tfloat c_3 = 0.000007;\n    \n    float fatt = min(1.0 / (c_1 + c_2*dl + c_3*dl*dl), 1.0);\n    \n    return c_a + i_1stLight * LN * k_d + spec;\n}\n\n/**** Main Function ****/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    /*** Centering ***/\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \tuv*=2.0;\n    uv-=1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    /*** Camera settings ***/\n    vec3 viewDir = getEyeVector(uv, 45.0);\n    vec3 camPos = vec3(0.68, 0.42, 0.60) * 5.0;\n    \n    /*** Camera Transformation ***/\n    mat4 viewToWorld = viewMatrix(camPos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\t\n    /*** Raymarching ***/\n    float hitDist = rayMarch(camPos, worldDir);\n\n    /*** Didn't hit anything ***/\n    if ( hitDist > MAX_DIST - EPSILON ) {\n        fragColor = vec4(0.0);\n\t\treturn;\n    }\n    \n    /*** Sphere mat ***/\n    PhongMaterial sMat;\n    sMat.spec = 0.8;    sMat.diffColor = vec3(0.0, 1.0, .4); sMat.receiveShadows = false;\n\n    /*** Plane mat ***/\n    PhongMaterial pMat;\n    pMat.spec = .0;    pMat.diffColor = vec3(0.176, 0.6, 0.584); pMat.receiveShadows = true;\n   \n    \n    /**** Lighting ***/\n    vec3 p = camPos + worldDir * hitDist;\n    \n    vec3 color;\n    \n    PhongMaterial mat;\n    if(p.y > -2.0+MIN_DIST)\n    {\n        mat = sMat;\n    }\n    else\n    {\n        mat = pMat;\n    }\n    color = phongIllumination(mat, p, worldDir);\n    \n    // vignetting\n//    color *= 1.0-length(uv) * 0.15,\n        \n    fragColor = vec4(color,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tByzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 382, 421, 421, 519], [521, 611, 660, 660, 889], [891, 1032, 1066, 1066, 1090], [1092, 1117, 1160, 1160, 1200], [1201, 1293, 1334, 1334, 1405], [1406, 1428, 1452, 1452, 1636], [1638, 1726, 1756, 1756, 2083], [2085, 2109, 2143, 2244, 2991], [2993, 3117, 3182, 3210, 4588], [4590, 4616, 4671, 4695, 5988]]}
{"id": "4tByzm", "name": "Half-Space Frustum Tracing", "author": "paniq", "description": "crossing planes indicate outer and inner depths of plane within frustum. Inner boundaries show 100% occlusion. The segments between outer and inner planes enclose a part of the surface.", "tags": ["intersection", "plane", "frustum"], "likes": 3, "viewed": 575, "published": "Public API", "date": "1507853673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Half-Space Frustum Tracing\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// note that this version is very verbose and purposefully lacks \n// any form of optimization for the sake of education.\n\nconst vec2 min_frustum_half_size = vec2(1.77778,1.0)/30.0;\nconst vec2 max_frustum_half_size = vec2(1.77778,1.0)/6.0;\n\nconst float infinity = 1.0/0.0;\n\nvec2 frustum_center;\nvec2 frustum_half_size;\nvec4 plane;\nvec2 frustum_corners[4];\nvec3 frustum_ray_dirs[4];\nvec3 frustum_planes[4];\nfloat plane_ray_hits[4]; // these are scalars along the ray direction\n// range of surface\nvec2 surface;\n// are we inside the solid half-space?\nbool inside;\n\n// check only the horizontal frustum planes\nfloat dFrustumH(vec3 p) {\n    return max(\n        dot(p, frustum_planes[0]),\n        dot(p, frustum_planes[2]));    \n}\n\n// check only the vertical frustum planes\nfloat dFrustumV(vec3 p) {\n    return max(\n        dot(p, frustum_planes[1]),\n        dot(p, frustum_planes[3]));    \n}\n\nfloat dFrustum(vec3 p) {\n    return max(\n        dFrustumH(p),\n        dFrustumV(p));\n}\n\n// versor (unit quaternion) from axis and angle\nvec4 versor(vec3 axis, float angle) {\n    float a = angle * 0.5;\n    return vec4(axis * sin(a), cos(a));\n}\n\n// invert rotation\nvec4 conjugate(vec4 q) {    \n    return vec4(-q.xyz, q.w);\n}\n\n// rotate point by versor\n// q (t) * V * q (t) ^-1\nvec3 rotate(vec4 q, vec3 p) {\n    vec3 t = cross(q.xyz,p) * 2.0;\n    return p + q.w * t + cross(q.xyz, t);    \n}\n\n// assuming ray begins at origin\nfloat iPlane(vec4 plane, vec3 ro, vec3 rd) {\n    float D = dot(plane.xyz, rd);\n    float t = -dot(plane, vec4(ro, 1.0)) / D;\n    return t;\n}\n\nvec2 lissajous(float t, float a, float b) {\n    return vec2(sin(a*t), sin(b*t));\n}\n\nvoid setup_globals(float t) {\n    // move the frustum around\n    frustum_center = lissajous(t*0.07, 2.0, 1.0)*0.1;\n    // vary the frustum aperture\n    frustum_half_size = mix(\n        min_frustum_half_size,\n\t\tmax_frustum_half_size,\n        cos(t*0.13)*0.5+0.5);\n    \n    // transform our simplex a bit\n    vec2 plane_offset = lissajous(t*0.2, 5.0, 4.0)*0.3;\n    vec4 plane_rotation = versor(normalize(vec3(1.0)), t*0.2);\n    vec3 plane_normal = rotate(plane_rotation, vec3(0.0, 0.0, 1.0));\n    plane = vec4(plane_normal, -dot(plane_normal, vec3(plane_offset,3.0)));\n    \n    vec3 frustum_extents = vec3(frustum_half_size,-frustum_half_size.x);\n    frustum_corners[0] = frustum_center + frustum_extents.xy;\n    frustum_corners[1] = frustum_center + frustum_extents.zy;\n    frustum_corners[2] = frustum_center - frustum_extents.xy;\n    frustum_corners[3] = frustum_center - frustum_extents.zy;\n\n    for (int i = 0; i < 4; ++i) {\n        frustum_ray_dirs[i] = normalize(vec3(frustum_corners[i],1.0));\n    }\n    \n    for (int i = 0; i < 4; ++i) {\n\t\tplane_ray_hits[i] = iPlane(plane, vec3(0.0), frustum_ray_dirs[i]);\n    }\n    \n    frustum_planes[0] = normalize(cross(frustum_ray_dirs[1],frustum_ray_dirs[0]));\n    frustum_planes[1] = normalize(cross(frustum_ray_dirs[2],frustum_ray_dirs[1]));\n    frustum_planes[2] = normalize(cross(frustum_ray_dirs[3],frustum_ray_dirs[2]));\n    frustum_planes[3] = normalize(cross(frustum_ray_dirs[0],frustum_ray_dirs[3]));\n    \n    vec2 c = frustum_center;\n    vec2 s = frustum_half_size;\n    float p = plane.x*c.x + plane.y*c.y + plane.z;\n    float q = abs(plane.y*s.y) + abs(plane.x*s.x);\n\tfloat t0 = -plane.w / (p - q);\n\tfloat t1 = -plane.w / (p + q);\n    \n    inside = plane.w < 0.0;\n    \n    float tmin = min(t0, t1);\n    float tmax = max(t0, t1);\n    \n    if (tmin < 0.0) {\n        surface = vec2(tmax, 1.0/0.0);\n    } else {\n    \tsurface = vec2(tmin, tmax);\n    }\n}\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nconst float max_frustum_depth = 5.0;\nconst vec3 light_dir = normalize(vec3(-1.0, -1.0, 1.0));\nconst vec3 backlight_dir = normalize(vec3(0.8, 1.0, -1.0));\n\n\nfloat checkers(vec2 p) {\n    vec2 q = floor(p);\n    return mod(q.x + q.y, 2.0);\n}\n\nvec3 orthogonal(vec3 v) {\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n                               : vec3(0.0, -v.z, v.y);\n}\n\nvoid paint_plane(vec3 ro, vec3 rd) {\n    float t = iPlane(plane, ro, rd);\n    if ((t >= 0.0) && ((ro.z + rd.z * t) < max_frustum_depth)) {\n        add_field(-1.0);\n        vec3 dist = rd * t;\n        float df = dFrustum(ro + dist);\n        vec3 normal = plane.xyz;\n        bool backface = (dot(rd, plane.xyz) > 0.0);\n        if (df > 0.0)\n            return;\n        vec3 color = vec3(0.0, 0.05, 0.1);\n        float lit = max(dot(normal, light_dir), 0.0);\n        float backlit = max(dot(normal, backlight_dir), 0.0);\n        color += lit * vec3(1.0,0.9,0.8);\n        color += backlit * vec3(1.0);\n        \n        vec3 tangent = orthogonal(normal);\n\t\tvec3 bitangent = cross(normal, tangent);\n        vec3 p = ro + dist;\n        color *= vec3(mix(0.5,1.0,checkers(\n            vec2(dot(tangent, p), dot(bitangent, p))*4.0\n        )));\n        if (df < 0.0) {\n            if (backface) {\n                color *= vec3(0.7,0.9,1.0);\n            }                \n        }\n        color = pow(color, vec3(0.5));\n        color = mix(color, vec3(1.0), float(df > 0.0)*0.8);\n        color = mix(vec3(0.0), color, clamp((abs(df)-AAINV*1.5)*AA,-1.0,1.0)*0.5+0.5);\n        set_source_rgb(color);\n\t    fill();\n\t    new_path();\n    }\n}\n\nvoid paint_plane_zx() {\n    vec2 pt = get_origin();\t\n    paint_plane(\n        vec3(-pt[1], 2.0, pt[0]),\n        vec3(0.0, -1.0, 0.0));    \n}\n\nvoid paint_plane_zy() {\n    vec2 pt = get_origin();\t\n    paint_plane(\n        vec3(2.0, pt[1], pt[0]),\n        vec3(-1.0, 0.0, 0.0));    \n}\n\nvoid paint_plane_xy() {\n    vec2 pt = get_origin();\t\n    paint_plane(\n        vec3(pt[0], pt[1], -2.0),\n        vec3(0.0, 0.0, 1.0));\n}\n\nvoid paint_frustum_edges(vec2 pt[4]) {\n    for (int i = 0; i < 4; ++i) {\n\t\tmove_to(0.0, 0.0);\n\t\tline_to(pt[i]);\n    }\n    move_to(pt[0]);\n    for (int i = 1; i < 4; ++i) {\n\t\tline_to(pt[i]);\n    }    \n    close_path();\n}\n\nvoid paint_frustum_zx() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[2],-corner[0]);\n\t}\n    paint_frustum_edges(pts);\n}\nvoid paint_frustum_zy() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[2],corner[1]);\n\t}\n    paint_frustum_edges(pts);\n}\nvoid paint_frustum_xy() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[0],corner[1]);\n\t}\n    paint_frustum_edges(pts);\n}\n\nvoid paint() {\n    float t = iTime;\n    setup_globals(t);    \n        \n    float rdot = AAINV*8.0;\n\n    scale(0.4);\n\t\n    save(topview);\n    translate(-1.0,0.9);\n    save(topviewctx);\n    paint_plane_zx();\n    stroke();\n    {\n        vec3 p0 = vec3(frustum_corners[1],1.0) * surface[0];\n        vec3 p1 = vec3(frustum_corners[0],1.0) * surface[0];\n        vec3 p2 = vec3(frustum_corners[0],1.0) * min(surface[1], max_frustum_depth);\n        vec3 p3 = vec3(frustum_corners[1],1.0) * min(surface[1], max_frustum_depth);\n        vec3 z0 = vec3(frustum_corners[0],1.0) * max_frustum_depth;\n        vec3 z1 = vec3(frustum_corners[1],1.0) * max_frustum_depth;\n        set_line_width_px(1.0);\n        set_source_rgba(1.0,0.5,0.0,0.3);\n        move_to(p0.z, -p0.x);\n        line_to(p1.z, -p1.x);\n        line_to(p2.z, -p2.x);\n        line_to(p3.z, -p3.x);\n        close_path();\n        fill();\n        set_source_rgb(1.0,0.5,0.0);\n        if (inside) {\n            move_to(0.0, 0.0);\n            line_to(p1.z, -p1.x);\n            line_to(p0.z, -p0.x);\n        } else {\n            move_to(z0.z, -z0.x);            \n            line_to(z1.z, -z1.x);\n            line_to(p3.z, -p3.x);\n            line_to(p2.z, -p2.x);\n        }\n        close_path();\n        fill();\n    }\n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_zx();\n    stroke();\n    restore(topview);\n\t\n    save(sideview);\n    translate(-1.0,-1.6);\n    save(sideviewctx);\n    paint_plane_zy();\n    stroke();\n    {\n        vec3 p0 = vec3(frustum_corners[0],1.0) * surface[0];\n        vec3 p1 = vec3(frustum_corners[3],1.0) * surface[0];\n        vec3 p2 = vec3(frustum_corners[3],1.0) * min(surface[1], max_frustum_depth);\n        vec3 p3 = vec3(frustum_corners[0],1.0) * min(surface[1], max_frustum_depth);\n        vec3 z0 = vec3(frustum_corners[3],1.0) * max_frustum_depth;\n        vec3 z1 = vec3(frustum_corners[0],1.0) * max_frustum_depth;\n        set_line_width_px(1.0);\n        set_source_rgba(1.0,0.5,0.0,0.3);\n        move_to(p0.zy);\n        line_to(p1.zy);\n        line_to(p2.zy);\n        line_to(p3.zy);\n        close_path();\n        fill();\n        set_source_rgb(1.0,0.5,0.0);\n        if (inside) {\n            move_to(0.0, 0.0);\n            line_to(p1.zy);\n            line_to(p0.zy);\n        } else {\n            move_to(z0.zy);            \n            line_to(z1.zy);\n            line_to(p3.zy);\n            line_to(p2.zy);\n        }\n        close_path();\n        fill();\n    }    \n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_zy();\n    stroke();\n    restore(sideview);\n    \n\tsave(backview);\n    translate(-2.5,-0.4);\n    save(backviewctx);\n    paint_plane_xy();\n    stroke();    \n    if (surface[0] < max_frustum_depth) {\n        vec3 p0 = vec3(frustum_corners[0],1.0) * surface[0];\n        vec3 p1 = vec3(frustum_corners[1],1.0) * surface[0];\n        vec3 p2 = vec3(frustum_corners[2],1.0) * surface[0];\n        vec3 p3 = vec3(frustum_corners[3],1.0) * surface[0];\n        set_source_rgb(1.0,0.5,0.0);\n        move_to(p0.xy);\n        line_to(p1.xy);\n        line_to(p2.xy);\n        line_to(p3.xy);\n        close_path();\n        set_line_width_px(1.0);\n        stroke();            \n    }\n    if (surface[1] < max_frustum_depth) {\n        vec3 p0 = vec3(frustum_corners[0],1.0) * surface[1];\n        vec3 p1 = vec3(frustum_corners[1],1.0) * surface[1];\n        vec3 p2 = vec3(frustum_corners[2],1.0) * surface[1];\n        vec3 p3 = vec3(frustum_corners[3],1.0) * surface[1];\n        set_source_rgba(1.0,0.5,0.0,0.3);\n        move_to(p0.xy);\n        line_to(p1.xy);\n        line_to(p2.xy);\n        line_to(p3.xy);\n        close_path();\n        set_line_width_px(1.0);\n        stroke();            \n    }    \n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_xy();\n    stroke();\n    restore(backview);\n\n    for (int i = 0; i < 4; ++i) {\n        float dist = plane_ray_hits[i];\n        restore(backviewctx);\n        if ((dist > 0.0) && (dist < max_frustum_depth)) {\n\t        vec3 enter = frustum_ray_dirs[i] * dist;\n\t\t    restore(backviewctx);\n            set_source_rgb(1.0,0.5,0.0);\n            circle(enter.x, enter.y, rdot);\n            fill();\n            restore(topviewctx);\n            set_source_rgb(1.0,0.5,0.0);\n            circle(enter.z, -enter.x, rdot);\n            fill();\n            restore(sideviewctx);\n            set_source_rgb(1.0,0.5,0.0);\n            circle(enter.z, enter.y, rdot);\n            fill();                \n        }\n    }\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = sqrt(_color);\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    c = clamp(c, vec4(0.0), vec4(1.0));\n    c.rgb = c.rgb*c.rgb;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tByzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[669, 713, 738, 738, 831], [833, 875, 900, 900, 993], [995, 995, 1019, 1019, 1082], [1084, 1132, 1169, 1169, 1238], [1240, 1259, 1283, 1283, 1319], [1321, 1372, 1401, 1401, 1484], [1486, 1519, 1563, 1563, 1659], [1661, 1661, 1704, 1704, 1743], [1745, 1745, 1774, 1805, 3650], [9462, 9683, 9707, 9707, 9764], [9766, 9766, 9791, 9791, 9902], [9904, 9904, 9940, 9940, 11129], [11131, 11131, 11154, 11154, 11271], [11273, 11273, 11296, 11296, 11412], [11414, 11414, 11437, 11437, 11549], [11551, 11551, 11589, 11589, 11770], [11772, 11772, 11797, 11797, 11997], [11998, 11998, 12023, 12023, 12222], [12223, 12223, 12248, 12248, 12447], [12449, 12449, 12463, 12463, 16960], [17114, 17174, 17201, 17201, 17227], [17229, 17289, 17310, 17310, 17417], [17419, 17419, 17456, 17456, 17542], [17544, 17544, 17590, 17590, 17623], [17625, 17763, 17791, 17791, 18251], [18279, 18279, 18298, 18298, 18331], [18333, 18333, 18351, 18351, 18384], [18386, 18386, 18410, 18410, 18514], [18516, 18516, 18533, 18533, 18554], [18556, 18556, 18583, 18605, 18888], [18890, 18890, 18918, 18918, 19152], [19154, 19154, 19178, 19178, 19264], [19266, 19266, 19293, 19293, 19506], [19508, 19508, 19534, 19534, 19762], [19764, 19764, 19786, 19786, 19912], [19914, 19914, 19934, 19934, 19994], [19996, 19996, 20028, 20028, 20055], [20057, 20057, 20078, 20078, 20100], [20102, 20102, 20126, 20126, 20186], [20188, 20188, 20222, 20222, 20246], [20248, 20248, 20262, 20262, 20326], [20328, 20328, 20354, 20354, 20392], [20394, 20394, 20420, 20420, 20447], [20449, 20449, 20472, 20472, 20567], [20569, 20569, 20593, 20593, 20662], [20664, 20664, 20689, 20689, 20736], [20738, 20738, 20755, 20755, 20868], [20870, 20870, 20893, 20893, 21022], [21024, 21024, 21052, 21052, 21180], [21182, 21182, 21206, 21206, 21346], [21348, 21348, 21386, 21386, 21520], [21522, 21522, 21559, 21559, 21594], [21596, 21596, 21623, 21623, 21673], [21675, 21675, 21705, 21705, 21761], [21763, 21763, 21792, 21792, 21973], [21975, 21975, 21997, 21997, 22164], [22166, 22166, 22179, 22179, 22218], [22220, 22220, 22250, 22250, 22279], [22281, 22281, 22314, 22314, 22371], [22373, 22373, 22399, 22399, 22449], [22451, 22451, 22472, 22472, 22537], [22539, 22539, 22563, 22563, 22646], [22648, 22648, 22663, 22663, 22704], [22706, 22706, 22722, 22722, 22760], [22762, 22762, 22780, 22780, 22837], [22839, 22839, 22869, 22869, 23304], [23306, 23306, 23364, 23364, 23402], [23404, 23404, 23433, 23433, 23469], [23471, 23471, 23519, 23519, 23550], [23552, 23552, 23586, 23586, 23645], [23647, 23647, 23724, 23724, 23889], [23891, 23891, 23968, 23968, 24048], [24050, 24050, 24126, 24126, 24242], [24244, 24244, 24320, 24320, 24398], [24400, 24400, 24438, 24438, 24472], [24474, 24474, 24496, 24496, 24542], [24544, 24544, 24571, 24571, 24615], [24617, 24617, 24666, 24666, 24927], [24929, 24929, 25002, 25002, 25056], [25058, 25058, 25090, 25090, 25126], [25128, 25128, 25184, 25184, 25240], [25242, 25242, 25272, 25272, 25365], [25366, 25366, 25406, 25406, 25429], [25431, 25477, 25516, 25516, 26672], [26674, 26674, 26704, 26704, 26806], [26808, 26808, 26860, 26860, 26900], [26902, 26902, 26924, 26924, 26975], [26977, 26977, 27009, 27009, 27031], [27033, 27048, 27070, 27070, 27362], [27364, 27364, 27396, 27396, 27418], [27420, 27420, 27439, 27439, 27471], [27520, 27583, 27625, 27625, 27691], [27693, 27763, 27814, 27814, 28166], [28168, 28202, 28248, 28248, 28760], [28762, 28831, 28877, 28877, 29383], [29385, 29385, 29418, 29418, 29634], [29636, 29636, 29695, 29695, 29740], [29742, 29742, 29785, 29785, 29846], [29848, 29848, 29890, 29890, 29932], [29934, 29994, 30051, 30051, 30250]]}
{"id": "4tfcDX", "name": "Torus (cloned) with Twin Shade C", "author": "tgsstdio", "description": "Twin shade of torus with variable sized duo-shade\n\nORIGINAL code of TORUS -https://www.shadertoy.com/view/ll33Wn\nTorus with Twin Shade B - https://www.shadertoy.com/view/lllyDB\nTwin Shade C - https://www.shadertoy.com/view/XtfcDX", "tags": ["toon"], "likes": 2, "viewed": 103, "published": "Public", "date": "1506863956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// USE ANY CUTOFF VALUES YOU LIKE. \n\n#define LIGHT_SHADE_CUTOFF 0.43\n#define DARK_SHADE_CUTOFF 0.15\nconst vec3 TORUS_COLOR = vec3(1.0, 0.5, 0.1);\n\n/// FORK of https://www.shadertoy.com/view/ll33Wn (95% of code is from here)\n/// MY CHANGES due to diffuse toon shading\n\n#define EPSILON 0.0001\n#define MAX_STEPS 500\n#define MIN_DIST 0.0\n#define MAX_DIST 25.0\n\n#define AMBIENT 0.1\n#define EDGE_THICKNESS 0.015\n#define SHADES 4.0\n\nfloat TorusSDF(vec3 samplePoint, vec2 dimensions)\n{\n\treturn length( vec2(length(samplePoint.xz)-dimensions.x,samplePoint.y) )-dimensions.y;\n}\n\nfloat SceneSDF(vec3 samplePoint)\n{\n    return TorusSDF(samplePoint, vec2(1.3, 0.45));\n}\n\nfloat March(vec3 origin, vec3 direction, float start, float stop, inout float edgeLength)\n{\n    float depth = start;\n    \n    for\t(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = SceneSDF(origin + (depth * direction)); // Grab min step\n        edgeLength = min(dist, edgeLength);\n        \n        if (dist < EPSILON) // Hit\n            return depth;\n        \n        if (dist > edgeLength && edgeLength <= EDGE_THICKNESS ) // Edge hit\n            return 0.0;\n        \n        depth += dist; // Step\n        \n        if (depth >= stop) // Reached max\n            break;\n    }\n    \n    return stop;\n}\n\nvec3 RayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - (size / 2.0);\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 EstimateNormal(vec3 point)\n{\n    return normalize(vec3(SceneSDF(vec3(point.x + EPSILON, point.y, point.z)) - SceneSDF(vec3(point.x - EPSILON, point.y, point.z)),\n                          SceneSDF(vec3(point.x, point.y + EPSILON, point.z)) - SceneSDF(vec3(point.x, point.y - EPSILON, point.z)),\n                          SceneSDF(vec3(point.x, point.y, point.z + EPSILON)) - SceneSDF(vec3(point.x, point.y, point.z - EPSILON))));\n}\n\nmat4 LookAt(vec3 camera, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - camera);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    \n    return mat4(vec4(s, 0.0),\n        \t\tvec4(u, 0.0),\n        \t\tvec4(-f, 0.0),\n        \t\tvec4(0.0, 0.0, 0.0, 1));\n}\n\n// NEW CODE HERE (START)\n\n// isLight: true for light shade pattern, false for darker shade pattern\n// uv: normalized uv coordinates\n// cellSize: in pixel size (0, inf)\n// screenRect: screen dimensions in pixels\n// lineWidth: percentage (0 - 1.0)\n// gradientWidth: percentage [0 - 1.0) w.r.t lineWidth\nfloat twinShadeC(bool isLight, vec2 uv, float cellSize, vec2 screenRect, float lineWidth, float gradientWidth)\n{\n   vec2 cellDims = cellSize / iResolution.xy;    \n    \n   vec2 bckSlash = normalize(vec2(screenRect.x / screenRect.y, 1.));\n   vec2 fwdSlash = normalize(vec2(-1, iResolution.y / iResolution.x));      \n  \n   vec2 bottomLeft = floor(uv / cellDims) * cellDims;          \n   vec2 bottomRight = bottomLeft + vec2(cellDims.x, 0.);   \n   \n   vec4 d0, d1;   \n   d0.xy = vec2(dot(fwdSlash, bottomLeft)); // fd0\n   d0.zw = vec2(dot(bckSlash, bottomRight)); // bd0\n    \n   d1.x = dot(fwdSlash, bottomRight); // fd2\n   d1.y = dot(fwdSlash, uv); // fd1\n\n   d1.z = dot(bckSlash, bottomLeft); // bd2    \n   d1.w = dot(bckSlash, uv); // bd1                                   \n\n   vec4 d2 = abs(d1 - d0);    \n    \n   float percent = lineWidth * (0.5 - gradientWidth);\n    \n   vec4 dMinMax = d2.xzxz;\n   dMinMax.xy *= percent;\n   dMinMax.zw *= (1. - percent);    \n   \n   float cutoff = isLight \n       ? dMinMax.z\n       : dMinMax.x;  \n    \n   vec3 compareLeft = vec3(d2.yw, cutoff);\n   vec3 compareRight = vec3(dMinMax.xy, d2.y);\n   \n   bvec3 result = lessThanEqual(compareLeft, compareRight);\n   \n   float color = 0.;    \n   if (any(bvec2(result.x, all(result.yz))))\n   {\n      color = 0.;\n   }\n   else\n   {              \n      vec2 halves = vec2(lineWidth, dMinMax.z + dMinMax.x) * 0.5;       \n\n      vec2 lightMin = d2.xz * halves.x;   \n      \n      vec3 lightGrad = abs(vec3(dMinMax.x, lightMin.x, d2.y) - halves.y);\n\n      vec3 low = vec3(lightGrad.x, dMinMax.x, dMinMax.y);\n      vec3 high = vec3(lightGrad.y, lightMin.xy);\n      vec3 value = vec3(lightGrad.z, d2.y, d2.w);\n       \n      vec3 blending = smoothstep(low, high, value);      \n       \n\n      vec4 shadeLeft = vec4(d2.yw, lightMin.xy);\n      vec4 shadeRight = vec4(lightMin.xy, d2.yw);\n       \n      bvec4 shadeTest = greaterThanEqual(shadeLeft, shadeRight);\n       \n      \n       float factor = 1.;       \n       if (isLight)\n       {                       \n          factor = blending.x;                    \n       }      \n       else \n       {\n          bvec3 darkBlend0 = bvec3(!result.x, shadeTest.zy);\n           \n          //if (!result.x && shadeTest.z && shadeTest.y)\n          if (all(darkBlend0))\n   \t      {\n       \t\t factor = blending.y; \n  \t\t  }                                   \n           \n          bvec3 darkBlend1 = bvec3(!result.y, shadeTest.wx);\n           \n          //if (!result.y && shadeTest.w && shadeTest.x)\n          if (all(darkBlend1))\n   \t      {\n       \t\t factor = blending.z; \n  \t\t  } \n           \n          if (all(shadeTest.wz))\n    \t  // if (shadeTest.w && shadeTest.z)\n    \t  {         \n    \t     factor = clamp(blending.y * blending.z, 0., 1.0); \n          }            \n       }              \n       \n       color = factor;\n   }\n   return color;\n}\n\n\nvec3 ComputeLighting(vec3 point, vec2 uv, vec3 lightDir, vec3 lightColor,\n\tfloat cellSize, vec2 screenRect, float lineWidth, float gradientWidth)\n{\n    vec3 color = vec3(AMBIENT);\n    float diffuse = dot(EstimateNormal(point), normalize(lightDir));\n    float colorIntensity = ceil(diffuse * SHADES) / SHADES;\n    colorIntensity = max(colorIntensity, AMBIENT);    \n   \n    if (diffuse >= LIGHT_SHADE_CUTOFF)        \n    \tcolor = lightColor * colorIntensity;\n    else if (diffuse >= DARK_SHADE_CUTOFF) \n    {\n\t\tfloat lightShade =twinShadeC(\n            true,\n            uv,\n            cellSize,\n            screenRect,\n            lineWidth,\n            gradientWidth\n        );        \n        color = lightShade * colorIntensity * lightColor;\n    }\n     else\n     {\n      \tfloat darkShade = twinShadeC(\n            false,\n            uv,\n            cellSize,\n            screenRect,\n            lineWidth,\n            gradientWidth\n        );     \n        color = darkShade * colorIntensity * lightColor;\n     }\n    return color;\n}\n\n// SHOULD BE SQUARE ON SCREEN NOT RECTANGULAR\n#define SUBDIVISION_LOOP_IN_SECS 18.0\n#define NO_OF_DIVISIONS 4\n\n#define MID_POINT 0.4\n#define TWO_PI 6.283185307179586476925286766559\n#define FREQUENCY 0.255\n#define RANGE_OF_TRIG_FUNC 0.2\n\n#define GRAD_MID_POINT 0.25\n#define GRAD_FREQUENCY 0.155\n#define GRAD_RANGE_OF_TRIG_FUNC 0.2\n\n// NEW CODE HERE (END)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = RayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 origin = vec3(sin(iTime) * 9.0, (sin(iTime * 2.0) * 4.0) + 6.0, cos(iTime) * 9.0);\n    mat4 viewTransform = LookAt(origin, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    viewDir = (viewTransform * vec4(viewDir, 0.0)).xyz;\n    \n    float edgeLength = MAX_DIST;\n    float dist = March(origin, viewDir, MIN_DIST, MAX_DIST, edgeLength);\n    \n    if (dist > MAX_DIST - EPSILON) // No hit\n    {\n        fragColor = vec4(0.6);\n        return;\n    }\n    \n    if (dist < EPSILON) // Edge hit\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec3 hitPoint = origin + (dist * viewDir);\n    vec3 lightDir = vec3(sin(iTime * 2.0) * 6.0, 4.0, sin(iTime * 1.25) * 5.0);\n   \n    // SELECTING CELL SIZE\n    float gapTimeStep = mod(iTime, SUBDIVISION_LOOP_IN_SECS) / SUBDIVISION_LOOP_IN_SECS;\n\n    float sections[4] = float[](    \n        4.,\n        8.,\n        12.,\n        16.\n   ); \n    \n   float lineWidth = MID_POINT + RANGE_OF_TRIG_FUNC * sin( FREQUENCY * TWO_PI * iTime);    \n    \n   float gradientWidth = GRAD_MID_POINT + GRAD_RANGE_OF_TRIG_FUNC * sin( GRAD_FREQUENCY * TWO_PI * iTime);    \n\n   float cellSize = sections[int(gapTimeStep * float(NO_OF_DIVISIONS))];     \n   \n   vec2 uv = fragCoord.xy / iResolution.xy; \n   vec3 color = ComputeLighting(hitPoint, uv, lightDir, TORUS_COLOR, cellSize, iResolution.xy, lineWidth, gradientWidth);\n    \n   fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfcDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 426, 477, 477, 567], [569, 569, 603, 603, 656], [658, 658, 749, 749, 1266], [1268, 1268, 1325, 1325, 1451], [1453, 1453, 1486, 1486, 1889], [1891, 1891, 1939, 1939, 2154], [2182, 2457, 2569, 2569, 5309], [5312, 5312, 5459, 5459, 6346], [6679, 6703, 6760, 6760, 8216]]}
{"id": "4tjcWR", "name": " kerning neighborhood #DF4 b", "author": "ollj", "description": "fork of \nhttps://www.shadertoy.com/view/Xt23zG\nimproved compatibility\n\nproof of concept of multisampling tessellations", "tags": ["tesselation", "overlapping", "halfspace", "kerning", "kerning"], "likes": 6, "viewed": 640, "published": "Public API", "date": "1508232314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//mod 3d seamless overlapping tile proof of concept tomkh 2017-09\n//self  : https://www.shadertoy.com/view/4tjcWR\n//parent: https://www.shadertoy.com/view/Xt23zG\n// was for tomkh's educational purposes\n// Extended from tomkh's previous attempt: llSGRy\n// tomkh@2015\n\n//there was not much to optimize\n//biggest change was to not use global array of mat3\n//i did not want to touch the camera and all its rotations\n//a lot is overly explicit, not wwong, just harder to edit.\n\n//this one failed at implementing AO\n\n#define doMouseLook\n//rotations in this are overly explicit, therefore camera sucks\n\n#define SCENE 3\n//   0 = centered bboxes\n//   1 = centered decorated bboxes\n//   2 = non-centered bboxes\n//   3 = non-centered decorated\n\n#define OVERLAP_SCENE 2\n//   0 = coins\n//   1 = pipes\n//   2 = tori\n//   To show nothing just comment out OVERLAP.\n\n\n// Enable to debug distance field:\n#define DEBUG_MODE 1\n//   0 = no debug\n//   1 = show DF plane\n//   2 = show all DF slices\n\n\n// Enable to test overlap (must be less than 0.5):\n#define OVERLAP 0.1\n\n#define floor_plane -5.\n\n// Enable experimental AO (bad, broken,shitty)\n//#define TEST_AO\n\n\n#define VIEW_DIST 1\n//   0 = short distance\n//   1 = middle\n//   2 = far\n\n#if VIEW_DIST == 0\n\tconst int ray_steps = 160;\n\tconst float dist_max = 20.0;\n\tconst float fog_start = 25.0;\n\tconst float fog_density = 0.05;\n\tconst float cam_dist = 20.0;\n\tconst float cam_tilt = -.2;\n#elif VIEW_DIST == 1\n\tconst int ray_steps = 80;\n\tconst float dist_max = 20.0;\n\tconst float fog_start = 25.0;\n\tconst float fog_density = 0.05;\n\tconst float cam_dist = 30.0;\n\tconst float cam_tilt = -.4;\n#else\n\tconst int ray_steps = 80;\n\tconst float dist_max = 200.0;\n\tconst float fog_start = 100.0;\n\tconst float fog_density = 0.02;\n\tconst float cam_dist = 80.0;\n\tconst float cam_tilt = -.4;\n#endif\n\n\n// Tile space:\n#define tSpace 2.\n\n//mat3 tori_rot[2];\n\n// P-----+-----Q\n// |     |     |\n// |  A--|--B  |\n// |  |p |  |  |\n// +-----+-----+\n// |  |  |  |  |\n// |  C--|--D  |\n// |     |     |\n// R-----+-----S\n// Say we want to find DF(p) = a distance field for \"p\",\n// and \"p\" is inside ABCD boundary, where A,B,C,D are our tile centers.\n// We have to assume max/min height.\n// We call \"frame\", a bounding area of everything outside PQRS (estimated using max/min height).\n// Algorithm:\n//   For \"p\" we evaluate DF for 4 tiles: A,B,C,D\n//   (possibly with early-out optimization with rough distance estimation)\n//   and we bound it additionally to distance to PQRS frame.\n//\n//comment by ollj, above is neat, has its uses\n//, is likely smarter if you want to mix 2 adjacent tiles\n//, but i know a better way;\n//a 2d quater tile is (within) 4 larger offset tiles, all seamless.\n// just 4x sample 4 exclusive tesselations with offset.\n//, whos cotners are onm the lines or centers of other tesselations.\n//gives a cleaner gradient.\n\nfloat dist2frame(vec3 p, float b)\n#ifdef OVERLAP\n{p=vec3(tSpace*(1.-OVERLAP)-abs(p.xz),max(0.,abs(p.y)-b));\n#else\n{p=vec3(tSpace-abs(p.xz),max(0.,abs(p.y)-b));\n#endif\n return length(vec2(min(p.x,p.y),p.z));\n}\n\n//lib.shapes\nfloat dBox2(vec3 p,vec3 b)//rounded box\n{return length(vec3(max(vec3(0),abs(p)-b)));}\n\nfloat dPipe(vec3 p,float r,float h)\n{r=length(p.xz)-r\n;h=max(.0,abs(p.y)-h)\n;return length(vec2(r,h));}\n\nfloat dCyl(vec3 p, float r, float h)\n{r=max(.0,length(p.xz)-r)\n;h=max(.0,abs(p.y)-h)\n;return length(vec2(r,h));}\n \n vec3 sc3(float a){return vec3(cos(a),0,sin(a));}  \n//evaluate tile contnent\nfloat gt(vec3 p, vec3 q,vec2 d,mat3 tr0,mat3 tr1)\n{q.xz+=d\n;p.xz-=(d-.5)*tSpace\n;float a,t=iTime*.25,s=sin(q.x+t)*sin(q.z+t*.33);\n#ifdef OVERLAP\n ;float r=tSpace*(.5 + OVERLAP);\n #if OVERLAP_SCENE == 0\n  ;a=dCyl(vec3(p.x,p.y-s*.25,p.z),r-.25,.0)-.25;\n #elif OVERLAP_SCENE == 1\n  ;a=dPipe(vec3(p.x,p.y-s*2.0,p.z),r-.25,1.75)-.25;\n #else\n  ;mat3 m=(mod(q.x*.17 + q.z*.71,2.0)<1.0) ? tr0:tr1;\n  ;a=dPipe(vec3(p.x,p.y-s*3.0,p.z)*m,r-.25,.0)-.25;\n #endif\n#else\n ;a=1e32;\n#endif\n#if SCENE>=2\n  ;s=4.-abs(s)*3.9;\n  ;vec3 u=p+sc3((q.x+q.z)*3.+t*1.11)*.5;\n  ;a=min(a,dBox2(u,vec3(.25,s,.25))-.025);\n #if SCENE==3\n  //;if (dist > .3) return dist - .1; // simple early-out optimziation\n  ;a=min(a,dBox2(u-vec3(0,s*.3,0),vec3(.25,0,.25))-.1)\n  ;a=min(a,dBox2(u-vec3(0,s*.6,0),vec3(.25,0,.25))-.1)\n #endif\n#else\n ;s=4.-abs(s)*3.8;\n ;float u=.2+abs(cos(q.x+t*.5)*cos(q.z+t*.66))*.7;\n ;a=min(a,dBox2(p,vec3(u,s,u))-.025);\n #if SCENE == 1\n  //;if (dist > .2) return dist - .1; // simple early-out optimziation\n  ;a=min(a,dBox2(p,vec3(u+.1,s-.1,  .1))-.025);\n  ;a=min(a,dBox2(p,vec3(  .1,s-.1,u+.1))-.025);\n #endif\n#endif\n;return a;}\n \nfloat gd(vec3 p,mat3 a,mat3 b)\n{vec3 c=vec3(floor(p.xz/tSpace),.0).xzy;//tile address\n;p=vec3((fract(p.xz/tSpace)-.5)*tSpace,p.y).xzy//logal coord\n;float r=dist2frame(p,4.25)\n;r=min(r,gt(p,c,vec2(0  ),a,b));\n;r=min(r,gt(p,c,vec2(1,0),a,b));\n;r=min(r,gt(p,c,vec2(0,1),a,b));\n;r=min(r,gt(p,c,vec2(1  ),a,b));\n;r=min(r,abs(p.y-floor_plane));\n;return r;}\n\nvec3 get_normal(vec3 p,mat3 a,mat3 b){const vec2 e=vec2(1e-3,0)\n;return normalize(vec3(gd(p+e.xyy,a,b)-gd(p-e.xyy,a,b)\n,gd(p+e.yxy,a,b)-gd(p-e.yxy,a,b),gd(p+e.yyx,a,b)-gd(p-e.yyx,a,b)));}\n\n// TODO: implement better AO\nfloat get_ao(vec3 u,vec3 n,mat3 tr0,mat3 tr1){\n#ifdef TEST_AO\n;u+=n*.1;\n;float d=gd(u,tr0,tr1),l=.0\n;d=d*d;l+=d\n;for(int i=0;i<3;i++){u+=n*d;d=gd(u,tr0,tr1);d=d*d;l+=d;}\n;return clamp(0.0,1.0,l*1.5);}\n#else\nreturn 1.;}\n#endif\n\n//this one gor convoluted.\nvec3 trace(vec3 u, vec3 t,mat3 tr0,mat3 tr1){\n#if DEBUG_MODE != 2\n;float l,d;\n;const float e=.001;\n;vec3 p=u\n;for(int k=0; k<ray_steps; ++k\n){d=gd(p,tr0,tr1)\n ;if(d<e||d>d)break\n ;p+=d*t\n ;l+=d\n;}\n //;vec3 s=normalize(vec3(.1,1.0,-.3));\n;float m=(iMouse.x/iResolution.x-.5)+1.\n,cShad=.0,cSpec=.0;\n;vec3 s=normalize(vec3(cos(m),2.,-sin(m)))\n,cDiff=vec3(1)\n,n=get_normal(p,tr0,tr1)\n;if(d<e\n){if(p.y<floor_plane+e*2.\n ){float d=(u.y-floor_plane)/-t.y\n  ;vec3 hit=u+t*d\n  ;float p=mod(floor(hit.x/tSpace)+floor(hit.z/tSpace),2.)//pattern\n  ;cDiff=mix(vec3(.6,.4,.6),vec3(.6,.6,.8),p)\n ;}\n ;cShad=max(0.,dot(n, s))//;cShad=(1.-d/e)*dot(n,s);\n *get_ao(p,n,tr0,tr1)\n ;cSpec=max(0.0,dot(n, m - n*dot(n,s)*2.))\n ;cSpec=pow(cSpec,32.0)*.25\n;}\n;vec3 a=mix(vec3(0,.1,.3),vec3(1,1,.9),cShad)*cDiff+vec3(1)*cSpec;\n// Test ray with cut_plane:\n#if DEBUG_MODE == 1\n;float mm=(iMouse.y/iResolution.y-.1)*8.\n;mm=max(0.,mm)\n;if(t.y*sign(u.y-mm)<.0\n){float d=(u.y-mm)/-t.y\n ;if(d<l\n ){vec3 h=u+t*d\n  ;h.x=gd(h,tr0,tr1)\n  ;vec3 b=mix(vec3(.2,.4,.6),vec3(.2,.2,.4),fract(h.x*5.0));//distant color\n  ;b*=1./(max(.0,h.x)+.001);//;b=min(vec3(1),b);\n  ;a=mix(a,b,.25)\n  ;l=d;}}\n#endif\n;a=mix(vec3(.8),a,1./exp(max(.0,l-fog_start)*fog_density));//fog\n#else\n;vec3 a=vec3(0,.1,.3)\n;for(float i=4.;i>=.0;i-=.1//i used to be called \"cutPlane\"\n){if(t.y*sign(u.y-i)<.0\n ){float d=(u.y-i)/-t.y\n  ,h=gd(u+t*d,tr0,tr1)\n  ;vec3 b=.1*mix(vec3(2,4,6),vec3(2,2,4),fract(h*5.0));//distant color\n  ;b*=1./(max(.0,h)+.05)\n  ;a+=b*.02*i*.25;}}\n#endif\n;return a;}\n\n\n//axisAngleTomat2\nmat3 aatm(float a,vec3 r){float c=cos(a)\n;vec3 t=(1.-c)*r,u=sin(a)*r;return mat3\n(t.x*r.x+c  ,t.x*r.y+u.z,t.x*r.z-u.y\n,t.x*r.y-u.z,t.y*r.y+c  ,t.y*r.z+u.x\n,t.x*r.z+u.y,t.y*r.z-u.x,t.z*r.z+c );}\n\nvoid mainImage( out vec4 o, in vec2 u )\n{u=(u.xy-iResolution.xy*0.5)/iResolution.x\n;float t = iTime*.25\n#ifdef doMouseLook\n;float a=iMouse.x/iResolution.x * 2.-1.\n#else\n;float a=-.2\n#endif\n;a+=cos(t)*.05;\n;float c=cos(a),s=sin(a)\n;vec3 p=vec3(-cam_dist*s,0,-cam_dist*c)\n;vec3 n = normalize(vec3(u,1))\n;n=vec3(n.x*c+n.z*s,n.y,-n.x*s+n.z*c)\n#ifdef doMouseLook\n //;a=iMouse.y/iResolution.y*2.+sin(t*(2./3.))*.2-2.\n#endif\n;a=cam_tilt;\n;c=cos(a);\n;s=sin(a);\n;p=vec3(p.x,p.y*c+p.z*s,-p.y*s+p.z*c);\n;n=vec3(n.x,n.y*c+n.z*s,-n.y*s+n.z*c);\n;mat3 tr0,tr1;\n#if defined(OVERLAP) && OVERLAP_SCENE == 2\n ;tr0=aatm(t   ,normalize(vec3(.5,.2, .3)));\n ;tr1=aatm(t+2.,normalize(vec3(.3,.7,-.2)));\n#endif\n;o=vec4(trace(p,n,tr0,tr1),1);}\n\n\n\n/*\n[halfspace tapping] link collection (v3) (may only be correlated, not even using the method, but SHOULD use the method)\n//\nsawblade serrated disk inversion  \nhttps://www.shadertoy.com/view/4t3fz7\nparent of the above is below\nhttps://www.shadertoy.com/view/XtSczV\n//\nwhich contains links to\ni tried to make this a sawblade\n, and noticed that i would need an insideout rounded box gradient for this: \nhttps://www.shadertoy.com/view/4t3fz7 \n//\nwe need a label for this [overlapping tile/slice] [typesetting] [CircleOfConfusion] \nstuff first time i see it in polar coordinates: \nprevious instances where linear or square lattice (and often only partially overlappin CoC's) \nhttps://www.shadertoy.com/view/4tjcWR\nhttps://www.shadertoy.com/view/MlscWn \n//\nI suggest [halfspace tapping]\n, where CoC implies bokeh, this generalizes it to \"overlapping of dark areas with lit areas\" \nthat may even not overlap completely (or at not overlap at all) :\ntoon clouds (very similar to / MlscWn ):\nhttps://www.shadertoy.com/view/4t23RR\nhttps://www.shadertoy.com/view/MltyR7 \nhttps://www.shadertoy.com/view/ltVcWt\nconcept of a non-monoispaced tree structure (branching a dualGlpyhString into 2 non monospaced sub-glyphs, branchless tree element)\nhttps://www.shadertoy.com/view/ltVcWt\n//\nolder and simpler [halfspace] shaders, closer to \nhttps://www.shadertoy.com/view/Md2cWK\nmodulo-gears:\nhttps://www.shadertoy.com/view/Msl3Rn\npavement:\nhttps://www.shadertoy.com/view/XsKXz3\npolar grid motion does 3-tap, and wopuld be great for half-space overlap:\nhttps://www.shadertoy.com/view/XtcfRH\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjcWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1869, 2843, 2893, 2893, 5357], [5366, 5393, 5438, 5438, 6910], [6913, 6931, 6957, 6957, 7124], [7126, 7126, 7167, 7167, 7843]]}
{"id": "4tjyDD", "name": "Hexagonal Polkadot Bounce", "author": "AdmiralPotato", "description": "Today I learned how to work with a dot product.", "tags": ["2d"], "likes": 2, "viewed": 408, "published": "Public API", "date": "1508751777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = atan(1.0) * 4.0;\nconst float TAU = atan(1.0) * 8.0;\n\nconst float rad60 = (atan(1.0) * 4.0) / 3.0;\nconst float rad120 = (atan(1.0) * 4.0) / 1.5;\nconst vec2 vec000 = vec2(1.0, 0.0);\nconst vec2 vec060 = vec2(cos(rad60), sin(rad60));\nconst vec2 vec120 = vec2(cos(rad120), sin(rad120));\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float scale = 10.0;\n    scale *= (cos(iTime * TAU / 8.0) + 1.0);\n\n    fragColor = vec4(0.0);\n    \n    float polkadotMask = 0.0;\n    \n    polkadotMask += cos(abs(dot(pos, vec000)) * scale * TAU);\n    polkadotMask += cos(abs(dot(pos, vec060)) * scale * TAU);\n    polkadotMask += cos(abs(dot(pos, vec120)) * scale * TAU);\n    \n    \n    fragColor.rg = polkadotMask * mouse;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjyDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 358, 358, 867]]}
{"id": "4tjyR1", "name": "Simplest sunset", "author": "azymohliad", "description": "One of my first shaders. Made as an excercise for thebookofshaders.com", "tags": ["procedural", "2d"], "likes": 3, "viewed": 248, "published": "Public", "date": "1507445966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 coord;\n\n\nfloat plot_sun(vec2 center, float radius) {\n    return 1.0 - smoothstep(radius * 0.7, radius * 1.1, distance(coord, center));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    coord = fragCoord.xy/iResolution.yy;\n    \n    // Sea parameters\n    bool is_sea = false;    \n    float sea_line = 0.3;\n\n    // Sun parameters\n\tfloat sun_size = 0.1;\n    \n    vec2 sun_pos;\n    sun_pos.x = 0.9;\n    sun_pos.y = 1.0 - fract(iTime * 0.1);\n    \n\tvec3 sun_color;\n    sun_color.r = 1.000;\n    sun_color.g = clamp(sun_pos.y * 1.2, 0.3, 1.0);\n    sun_color.b = clamp(sun_pos.y * 1.0, 0.2, 1.0);\n    \n    // Sky parameters\n\tvec3 sky_color = vec3(0.5, 0.6, 0.9);\n    \n    if (coord.y < sea_line) {\n    \tcoord.y = sea_line + (sea_line - coord.y) / 4.0;   \n        is_sea = true;\n    }\n    \n    float ratio = pow(abs(1.0 - distance(coord, sun_pos)), 1.5);\n\n    vec3 color;\n    color = mix(sky_color, sun_color, ratio);\n    color = mix(color,sun_color, plot_sun(sun_pos, sun_size));\n    if (is_sea) color -= 0.02;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjyR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 57, 57, 141], [144, 144, 201, 201, 1061]]}
{"id": "4tjyRz", "name": "Drawing pencil", "author": "josemorval", "description": "A simple pencil drawing a curve. Based on https://es.pinterest.com/pin/353603008234410610/", "tags": ["2d", "simple", "line", "curve", "draw", "pencil", "art", "minimal"], "likes": 8, "viewed": 286, "published": "Public", "date": "1507204111", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const mat2 rot180 = mat2(cos(3.14159),sin(3.14159),-sin(3.14159),cos(3.14159));\n\nvec3 rgbcol(float r, float g, float b){\n  return vec3(r,g,b)/256.;\n}\n\nfloat sineCurve(vec2 p){\n  return p.x-sin(3.*p.y-8.*iTime);\n}\n\nvec2 gradSineCurve(vec2 p){\n  vec2 h = vec2( 0.1, 0.0 );\n    return vec2( sineCurve(p+h.xy) - sineCurve(p-h.xy),\n                 sineCurve(p+h.yx) - sineCurve(p-h.yx) )/(2.0*h.x);\n}\n\nfloat boxRegion(vec2 p,float a, float b){\n  return min(1.-abs(a*p.x),1.-abs(b*p.y));\n}\n\nfloat pseudoCircle(vec2 p,float r, float alpha){\n  float f = pow(abs(p.x),alpha)+pow(abs(p.y),alpha);\n  return r-pow(abs(f),1./alpha);\n}\n\nfloat triangle(vec2 p,float a,float b){\n  return min(p.y,min(p.x-p.y+0.5,-p.x-p.y+0.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n  float angle = sin(8.*iTime);\n  mat2 m = mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n\n  vec2 p = fragCoord.xy/iResolution.xy-0.5;\n  p.x*=iResolution.x/iResolution.y;\n  p*=0.5;\t\n  \n  //Curve\n  vec2 pcurve = 10.*p;\n  float lineCurve = abs(sineCurve(pcurve));\n  vec2 gradLineCurve = gradSineCurve(pcurve);\n  lineCurve = lineCurve/length(gradLineCurve);\n  lineCurve = smoothstep(0.025,0.04,lineCurve)+step(0.,-pcurve.y);\n  lineCurve = clamp(lineCurve,0.,1.);\n\n  //Base pencil\n  vec3 colBasePencil;\n\n  float height = cos(8.*iTime);\n  height*=height;\n\n  vec2 ppencil = (m*(p-vec2(0.0,0.05*height+0.07)));\n  float basePencil = boxRegion(ppencil,15.,5.);\n  basePencil = step(0.5,basePencil);\n  basePencil = max(step(0.,pseudoCircle(30.*ppencil+vec2(0.,-3.),1.,2.5)),basePencil);\n\n  float bandcircle = step(0.,length(ppencil)-0.05)*step(0.,0.07-length(ppencil));\n  colBasePencil = vec3(1.0)*basePencil;\n  colBasePencil = mix(colBasePencil,rgbcol(102.,204.,255.),bandcircle);\n  colBasePencil = mix(colBasePencil,0.85*colBasePencil,step(0.02,-ppencil.x)*basePencil);\n\n  //Corner pencil\n  vec3 colCornerPencil;\n  float cornerPencil = step(0.,triangle(vec2(15.,12.)*(rot180*ppencil+vec2(0.,-0.1)),1.,2.));\n\n  colCornerPencil = rgbcol(244.,240.,194.)*cornerPencil;\n  colCornerPencil = mix(colCornerPencil,rgbcol(102.,204.,255.),step(0.125,-ppencil.y)*cornerPencil);\n  colCornerPencil = mix(colCornerPencil,0.85*colCornerPencil,step(0.0,-ppencil.x-0.6*ppencil.y-0.08)*cornerPencil);\n\n  //Layer combination\n  vec3 col = rgbcol(45.,53.,89.);\n  col = mix(rgbcol(102.,204.,255.),col,lineCurve);\n  col = mix(col,colBasePencil,basePencil);\n  col = mix(col,colCornerPencil,cornerPencil);\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 149], [151, 151, 175, 175, 212], [214, 214, 241, 241, 396], [398, 398, 439, 439, 484], [486, 486, 534, 534, 622], [624, 624, 663, 663, 714], [716, 716, 772, 772, 2480]]}
{"id": "4tScRD", "name": "unrealistic eye", "author": "ollj", "description": "fork of \nhttps://www.shadertoy.com/view/XsfGWj\n\nEyeball R&D for Blitz Games Studios (which, sadly, closed today, hence me sharing this). Loosely based on Jorge Jimenez's Siggraph 2012 paper.", "tags": ["raytracing", "raymarching", "subsurfacescattering", "eye"], "likes": 6, "viewed": 723, "published": "Public API", "date": "1507580828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ben Weston - 15/08/2013\n\n/*\n-Eye ball effects:\nRay-marched shape\nRay-traced iris refraction\nFake photon mapping on iris\nSubsurface scattering on sclera\nHDR reflections with fresnel\nEyelid reflection occlusion\nEyelid ambient occlusion\nProcedural textures\nProcedural animation\n*/\n\n#define SpinningEye\n#define doFresnel\n#define doSpecular\n#define doAOEyelids\n\n// ------- EDIT THESE THINGS! -------\n\n// Constants\n#define tau 6.28318530717958647692\n\n#define u5(a) ((a)*.5+.5)\n\n// Precision controls\nconst float eps =.003;\nconst float eps1=eps*.5;//firstderivative epsilon should be smaller.\nconst float shadowOffset = .1;\nconst int traceDepth = 100; // takes time\n\n\n\n// Camera (also rotated by mouse)\nconst vec3 CamPos = vec3(0,0.0,-250.0);\nconst vec3 CamLook = vec3(0,0,0);\nconst float CamZoom = 10.0;\n//const float NearPlane = 0.0; // actually not needed\nconst float drawDistance = 1000.0;\nconst vec3 cSky = vec3(.4,.25,.2);//fillLightColour*.5;//vec3(.1,.3,.5);\n// Eye params\nconst float IrisAng    =tau/12.;\nconst float PupilAng   = (1.6*IrisAng/5.0);\nconst float EyeRadius  = 10.0;\nconst float BulgeRadius= 6.0; // used for photon trace, must be bigger than EyeRadius*sin(IrisAng)\n\n\n\n\n// KEY CONTROLS - (click on eye to give keyboard focus)\nconst int Key_M = 77; // mouse controls camera / eye direction\nconst int Key_E = 69; // refraction on/off\nconst int Key_P = 80; // photon mapping on/off\nconst int Key_L = 76; // change photon mapping technique (both fake, but one is imitating reality and the other is prettier)\nconst int Key_S = 83; // subsurface scattering on/off\nconst int Key_A = 65; // ambient occlusion on/off\nconst int Key_R = 82; // reflection on/off\nconst int Key_O = 79; // reflection eyelid occlusion on/off\nconst int Key_C = 67; // iris colour\nconst int Key_N = 78; // iris normal\n\n// Lights\n#if 0\n\t// High-contrast light edge-on\n\tconst vec3 lightDir = vec3(-2,2,.5);\n\tconst vec3 lightColour = vec3(1.0);\n\tconst vec3 fillLightDir = vec3(0,1,0);\n\tconst vec3 fillLightColour = vec3(.65,.7,.8)*.7;//vec3(.15,.2,.25);\n#else\n\t// more neutral \"good\" lighting (doesn't show off the effects)\n\tconst vec3 lightDir = vec3(-2,2,-1);\n\tconst vec3 lightColour = vec3(.83,.8,.78);\n\tconst vec3 fillLightDir = vec3(0,1,0);\n\tconst vec3 fillLightColour = vec3(.65,.7,.8);\n#endif\n\n\n\nvec2 Noise2( in vec3 x )\n{vec3 p = floor(x.xzy)\n;vec3 f = fract(x.xzy);f=f*f*(3.0-2.0*f);\n//vec3f2=f*f;f=f*f2*(10.0-15.0*f+6.0*f2);\n;vec2 u = (p.xy+vec2(37.0,17.0)*p.z) + f.xy\n;vec4 rg=textureLod( iChannel0,(u+.5)/256.,.0 )\n;return mix(rg.yw,rg.xz,f.z );}\n\t\t\nfloat Noise( in vec3 x ){return Noise2(x).x;}\n\n\n\n// Gamma correction\n#define GAMMA (2.2)\n// simulate a monitor, converting colour values into light values\nvec3 ToLinear(in vec3 col){return pow( col, vec3(GAMMA));}\n// convert back into colour values, so the correct light will come out of the monitor\nvec3 ToGamma( in vec3 col ){return pow( col, vec3(1./GAMMA));}\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle)\n{float keyVal = texture( iChannel3,vec2((float(key)+.5)/256.0,toggle?.75:.25 )).x\n;return (keyVal>.5)?true:false;}\n\nvec3 SkyDome(vec3 rd)\n{return mix(ToLinear(cSky)*2.0*Noise(rd)\n,vec3(8),smoothstep(.8,1.,rd.y/max((rd.x+1.),abs(rd.z))));}\n\n\nvec4 ComputeEyeRotation()\n{vec2 rot\n;if(!ReadKey(Key_M,true)&&iMouse.w>.00001\n)rot = .25*vec2(1.0,1.0)*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x\n;else\n{;float time = iTime*.5\n ;time+= Noise(vec3(0,time,0));\n //add noise to time (this adds SO MUCH character!)\n ;float flick = floor(time)+smoothstep(0.0,0.05,fract(time))\n //itnrpolates over noise to animate.\n ;rot=vec2(.2,.1)*tau\n *(texture(iChannel0, vec2((flick+.5)/256.,.5), -100.).rb-.5)\n;}\n;return vec4(cos(rot.x),sin(rot.x),cos(rot.y),sin(rot.y));}\n\n\nvec3 ApplyEyeRotation( vec3 u,vec4 r)\n{u.yz=r.z*u.yz+r.w*u.zy*vec2(1,-1)\n;u.xz=r.x*u.xz+r.y*u.zx*vec2(1,-1);return u;}\n\n// Shape\nfloat gd( vec3 u, vec4 r){u=ApplyEyeRotation(u,r);\n;vec2 s = vec2(length(u.xy),u.z);//slice\n;float aa=atan(s.x,-s.y);\n;float b = cos(tau*.2*aa/IrisAng);//iris bulge\n;b=b*.8-.8;\n;b*=smoothstep(tau*.25,0.0,aa);\t\n;b+=cos(tau*.25*aa/IrisAng)*.5*smoothstep(-.02,.1,IrisAng-aa); // slightly softer\n;return length(s)-EyeRadius-b;}\n\n\nfloat GetEyelidMask(vec3 u,vec4 r){\n;vec3 v=u;\n;float t=-.1;\n#ifdef SpinningEye\n;t=iTime*.3\n#endif\n;v.xy=cos(t)*u.xy+sin(t)*u.yx*vec2(1,-1);\n;float highLid=tan(max(tau*.05,asin(r.w)+IrisAng+.05));\n;float lowLid=tan(tau*.1);\n;float b=smoothstep(.0,.02,abs(Noise(vec3(iTime*.2,0,0))-.5 ))//blink\n;highLid*=b;\n;lowLid *=b;\n;return min((-v.z-2.0)-(-v.y/lowLid)\n           ,(-v.z-2.0)-(v.y/highLid));}\n\t\nfloat GetIrisPattern( vec2 u )\n{return Noise(vec3(10.*u/pow(length(u),.7), 0));}\n\n//return some noisy bumps for natural specular.\nvec3 bumps(vec3 p,float m){vec3 b=vec3(.7*Noise2(p*3.),0)\n;b.z=sqrt(1.-dot(b.xy,b.xy));return mix(vec3(0,0,1),b,m);}\n\nvec3 sss(vec3 n,vec3 lightDirN){\n;float ndotl=dot(n,lightDirN);\n;vec3 l=pow(ToLinear(vec3(.5,.3,.25)),vec3(mix( 3.,0.,smoothstep(-1.,.2,ndotl))));\n//\tfloat subsurface = max(0.0,-2.0*ndotl*EyeRadius);\n//\tl = pow(ToLinear(vec3(.5,.3,.25)),vec3(subsurface*.2)); // more intense the further light had to travel\n//fake,because that^ approximation gives a hard terminator\n;if(ReadKey( Key_S, true ))l=vec3(max(0.0,ndotl))\n//l = mix( l, vec3(max(0.0,ndotl)), 0.5 );\n;return l;}\n\nfloat vein(vec3 u,float a){\n;float t = atan(u.x,u.y)+Noise(u*1.)*tau*.03;\n;float v=(sin(t*60.)*.5+.5);\n;v*=v;\n;v*=u5(sin(t*13.));\n;return a*v*v*.5;}\n  \n\n#define u5(a)  ((a)*.5+.5)\n#define u25(a) ((a)*.25+.25)\n#define ss01(a) smoothstep(0.,1.,a)\n\n//iris photon sss?\n//irisAs() is subroutine of irisAs()\n//irisB is faster; -1 less normalize(sqrt())...\nvec3 irisAs(vec3 o,vec3 l){float d=dot(o,l)\n;return normalize(l+o*(cos(acos(d)/1.33)-d));}\n//return photonsFL and set photonsL of an iris\n//ppos,localLightDir,localFillLightDir,irisNorm,photonsL,rad\nfloat irisA(vec3 u,vec3 l,vec3 m,vec3 n,out float p,float r){\n;vec3 o=normalize(vec3(u.xy,-sqrt(max(.0,BulgeRadius*BulgeRadius-r*r)) ));\n//;l.z = -cos(acos(-l.z)/1.33); //debug visualize isolines\n//;m.z = -cos(acos(-m.z)/1.33); //debug visualize isolines\n;p=ss01(dot(n,irisAs(o,l)));//soften terminator\n;return u5(dot(n,irisAs(o,m)));}\nfloat irisB(vec3 u,vec3 l,vec3 m,vec3 n,out float p,float r){\n//reasonable match to the dark crescent effect seen in photos and offline photon mapping, but it looks wrong to me.\n;l.z=-cos(acos(-l.z)/1.5);;l=normalize(l);\n;m.z=-cos(acos(-m.z)/1.5);;m=normalize(m); \n;p=ss01(dot(n,l)); // soften the terminator\n;p*=.3+.7*smoothstep( 1.2,.9,length(u.xy/r+.2*l.xy/(l.z-.05)) );\n;return(dot(n,m)*.5+.5);}\n\n\n//[er]EyeRotation\nvec3 Shading(vec3 u,vec3 n,vec3 rd, vec4 er ){\n;vec3 view = normalize(-rd);\n\n;vec2 elm = vec2(GetEyelidMask(u, er),u.x/tan(tau*.23));\n;bool b=elm.x<0.0||(-u.z-3.0)<(u.x/tan(tau*.23));\n;b=any(lessThan(elm,vec2(0.,u.z+3.)));\n;if(b)return ToLinear(cSky);\n\t\n\t\n    //\n\tvec3 pos=ApplyEyeRotation(u,er);\t\n\tfloat ap=atan(length(pos.xy)/-pos.z);\n    ap+=tau*u25(sign(-ap));//if(ap<.0)ap+=tau/2.;\n\t\n // refract ray\n ;vec3 iR=ApplyEyeRotation(-view,er);\n ;vec3 localNorm=ApplyEyeRotation(n,er);\n ;if(!ReadKey(Key_E,true)){        \n  ;float a=dot(iR,localNorm)\n  ;iR+=localNorm*(cos(acos(a)*1.33)-a);}\n ;iR=normalize(iR)\t\n //intersect with plane\n ;float planeDist = -cos(IrisAng)*EyeRadius\n ;float t = (planeDist-pos.z)/iR.z\n ;vec3 ppos=t*iR+pos\n //polar coord map\n ;float r = length(ppos.xy)\n ;float irisr = EyeRadius*sin(IrisAng)\n ;vec3 rn=vec3(.001,0,0);rn.xy=vec2//irisNorm (initially its eps)\n (GetIrisPattern(ppos.xy-rn.xy)-GetIrisPattern(ppos.xy+rn.xy)\n ,GetIrisPattern(ppos.xy-rn.yx)-GetIrisPattern(ppos.xy+rn.yx));\n ;rn.xy+=-.01*normalize(ppos.xy)*sin(1.*tau*r/irisr)//add bumps\n ;rn.z=-.15// scale bumps\n ;rn =normalize(rn);\n ;if(ReadKey(Key_N,true))rn=-vec3(0,0,1);\n\t\t\n // crudely sampling the photon mapping density lighting\n //apply lighting with this modified normal\n ;vec3 ln = normalize(lightDir)\n ;vec3 l=ApplyEyeRotation(ln,er)\n //Bend light imitate of offline photon-mapping:\n // Jimenez's paper makes this seem very complex\n // ,because their mapping used a non-flat receiver\n // With neglible self-shadowing, the main effect condenses to; [multiply by a normal]\n //  We would get better results by using the actual normal.\n ;vec3 m=ApplyEyeRotation(normalize(fillLightDir),er);//is needed later on\n ;float photonsL, photonsFL;//iris photon party\n ;if(!ReadKey(Key_P,true)){\n  ;if(!ReadKey(Key_L,true)){\n  ;photonsFL=irisA(ppos,l,m,rn,photonsL,r)\n ;}else{\n  ;photonsFL=irisB(ppos,l,m,rn, photonsL,irisr)\n ;}\n }else{\n ;photonsL = max( 0.0, dot(rn,l) ) \n ;photonsFL = .5+.5*dot(rn,l);}\n;vec3 ambientOcclusion = vec3(1),eyelidShadow = vec3(1);\n#ifdef doAOEyelids\nif(!ReadKey(Key_A,true)){\n ;float elms=smoothstep(5.,0.,elm.x)\n ;ambientOcclusion = mix( vec3(1),ToLinear(vec3(.8,.7,.68)),pow(elms,1.) );\n ;float gelm=smoothstep(2.,-2.,GetEyelidMask(u+lightDir*1.0,er));\n ;eyelidShadow=mix(vec3(1),ToLinear(vec3(.8,.7,.68)),gelm);}\n#endif\nvec3 pl=photonsL *ToLinear(lightColour);\nvec3 fl=photonsFL*ToLinear(fillLightColour);\n;fl*=ambientOcclusion\n;l*=eyelidShadow\n//iris color base: \n;float pupilr = EyeRadius*sin(PupilAng);\n;float irisPattern = GetIrisPattern(ppos.xy); // reduce contrast of this now we have actual lighting!\n//;vec3 iris=mix(mix( vec3(.3,.1,.1)*.5+.5*vec3(.6,.4,.1), vec3(.6,.4,.1), irisPattern ) // hazel\n//         ,mix(vec3(.2,.2,.2)*.5+.5*vec3(.5,.45,.2), vec3(.5,.45,.2), irisPattern );//...\n//;vec3 iris=mix(mix( vec3(.1,.1,.4), vec3(.7,.9,1), irisPattern ) // blue\n//\t\t   ,mix( vec3(.1,.1,.4), vec3(.3,.4,.7), irisPattern )\n//         ,smoothstep(pupilr*2.0,irisr,r));\n\n;float ssass= mix(smoothstep(pupilr,irisr,r),Noise(ppos),.7)\n;vec3 sexp=2.*vec3(1.2-sqrt(irisPattern));\n;sexp =pow(vec3(.65,.82,.85),sexp);\n;vec3 iris=ToLinear(mix(sexp,vec3(1,.5,.2),.7*ssass*ssass));\n;if ( ReadKey( Key_C, true ) )iris = vec3(1);\n;iris*=pow(smoothstep(irisr+1.,irisr-1.5,r),GAMMA)//darken outer\n;iris*=pl+fl//iris occlusion\n;iris*=smoothstep(pupilr-.01,pupilr+.5,r)//darken pupil\n;float veins=vein(pos,smoothstep(IrisAng,tau*.2,ap))\n;vec3 sclera=ToLinear(mix(vec3(1,.98,.96),vec3(.9,.1,0),veins))\n#ifndef doSss\n;pl=sss(n,ln)\n#endif\n;pl*=ToLinear(lightColour)*eyelidShadow; \n;fl=ToLinear(fillLightColour)*u5(dot(n,m))\n;fl*=ambientOcclusion\n;float bsi=smoothstep(-.1,.1,ap-IrisAng)//BlendScaleraIris\n;vec3 ir=mix(iris,sclera*(pl+fl),bsi)//this ir has a different context than the other iR!\n// eyelid ambient occlusion/radiosity\n//;if ( !ReadKey( Key_A, true ))\n//r*= mix(vec3(1),ToLinear(vec3(.65,.55,.55)),exp2(-elm.x*2.));\n//r*= mix(vec3(1),ToLinear(vec3(.8,.7,.68)),pow(smoothstep( 5.,.0,elm.x ),1.));\n// bumps - in specular only to help sub-surface scattering look smooth\n;vec3 bump=bumps(pos,bsi)\n;n.xy+=bump.xy*.1\n;n=normalize(n)\t\n//reflection map\n;float ndoti=dot(view,n);vec3 reflection=SkyDome(-view+2.0*ndoti*n);\n;float glossiness=mix(.7,1.,bump.z);\n#ifdef doFresnel\n;float fresnel=mix(.04*glossiness,1.,pow(1.-ndoti,5.));\n;if(!ReadKey(Key_R,true))ir=mix(ir,reflection,fresnel);\n#endif\n//ideally fressnel commutes before specular,simple model sums anyways.\n#ifdef doSpecular   \n;vec3 h = normalize(view+lightDir);\n;float specular = pow(max(0.0,dot(h,n)),2000.0);\n;reflection+=specular*32.*glossiness*ToLinear(lightColour);\n#endif    \n;if(!ReadKey(Key_O,true))\n{float g=GetEyelidMask(normalize(u+rd*2.)*EyeRadius,er);\n ;reflection*=smoothstep(.8,1.,g);}\n//anti-alias the edge\n;float mask2=max(-elm.x,u.z+3.+u.x/tan(tau*.23));\n;mask2=smoothstep(.0,.3,-mask2)\n;return mix(ToLinear(cSky),ir,mask2);}\n\n//y=er\nfloat Trace(vec3 u,vec3 t, vec4 y){float r=.0,d=1.\n;for(int i=0;i<traceDepth;i++\n){\n// ;bool b= abs(r-.5*(drawDistance))>drawDistance////drawDistance>r||r>.0\n//if(abs(s-.5*(b-a))<b-a)==if(b<s||s<a)   \n//;b=abs(d)<eps1||b\n ;bool b=any(lessThan(vec2(abs(d),drawDistance),vec2(eps1,abs(r-.5*drawDistance)))) \n ;if(b)continue\n ;d=gd(u+t*r,y);r= r+d;}return r;}//vec4(ro+rd*r,d);\n\n// get normal\nvec3 GetNormal(vec3 p,vec4 r){const vec2 d=vec2(eps1,0)\n;return normalize(vec3(gd(p+d.xyy,r)-gd(p-d.xyy,r)\n,gd(p+d.yxy,r)-gd( p-d.yxy,r),gd(p+d.yyx,r)-gd( p-d.yyx,r)));}\t\t\t\t\n\n// camera function by TekF\n// compute ray from camera parameters\nvec3 GetRay(vec3 d,float z, vec2 u)//dir,zoom,uv\n{u-=.5;;u.x*=iResolution.x/iResolution.y\n;d=z*normalize(d)\n;vec3 r=normalize(cross(vec3(0,1,0),d));//right\n;vec3 p=normalize(cross(d,r));//up\n;return d+r*u.x+p*u.y;}\n\nvoid mainImage(out vec4 o,in vec2 u){o.w=1.;u=u/iResolution.xy\n;vec3 p=CamPos,t=CamLook\n;vec2 camRot=.5*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x\n;if(!ReadKey(Key_M,true))camRot=vec2(0)\n;p.yz=cos(camRot.y)*p.yz+sin(camRot.y)*p.zy*vec2(1,-1);\n;p.xz=cos(camRot.x)*p.xz+sin(camRot.x)*p.zx*vec2(1,-1);\n;vec4 r=ComputeEyeRotation();\n//underground camera:\n//;if(gd(p,er)<=0.){o=vec4(0);return;}\n;t=GetRay(t-p,CamZoom,u);\n//This is where I would put my zNears, if I had any!\n//;p+=t*(NearPlane/CamZoom);\n;t=normalize(t);\n;float q=Trace(p,t,r)\n;o.xyz=ToLinear(cSky)\n;if(q>.0&&q<drawDistance\n){p+=q*t\n ;vec3 n=GetNormal(p,r)\n ;float s=1.;// shadow test\n //;if(Trace(p+lightDir*shadowOffset,lightDir,r)\n // <drawDistance)s=.0;\n  o.xyz=Shading(p,n,t,r );\n  //o.xyz=mix(cSky,result,exp(-t*t*.000001) );//fog\n  ;o.xyz=ToGamma(o.xyz)\n  //;o.w=1.;\n;}}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tScRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1804, 2285, 2311, 2311, 2540], [2544, 2544, 2569, 2569, 2589], [2633, 2699, 2726, 2726, 2757], [2758, 2844, 2872, 2872, 2906], [2908, 2994, 3031, 3031, 3144], [3146, 3146, 3169, 3169, 3268], [3271, 3271, 3298, 3298, 3781], [3784, 3784, 3823, 3823, 3902], [3904, 3913, 3939, 3939, 4236], [4239, 4239, 4274, 4274, 4635], [4638, 4638, 4670, 4670, 4718], [4720, 4768, 4795, 4795, 4884], [4886, 4886, 4918, 4918, 5356], [5358, 5358, 5385, 5385, 5506], [5604, 5708, 5735, 5735, 5798], [5799, 5907, 5968, 5968, 6242], [6243, 6243, 6304, 6420, 6642]]}
{"id": "4tscWS", "name": "RayMarching_Part 3", "author": "guyue", "description": "ç¬¬ä¸æ¬¡", "tags": ["raymarching"], "likes": 0, "viewed": 59, "published": "Public", "date": "1506939323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_RAY_SCALE = 255;\nconst float MAX_DIST = 100.0;\nconst float MIN_DIST = 0.0;\nconst float SCALE = 0.0001;\n\nfloat cubeSDF(vec3 p){\n\n    vec3 d = abs(p)-vec3(1.0,1.0,1.0);\n    \n    float insideDistance  = min(max(d.x,max(d.y,d.z)),0.0);\n  \n    float outsideDistance = length(max(d,0.0));\n    \n    return insideDistance+outsideDistance;\n\n}\n\n\nfloat sphereSDF(vec3 p){\n\n  \n   return length(p)-1.0;\n\n}\n\n\nfloat sceneSDF(vec3 p){\n\n\n   return cubeSDF(p)-0.1;\n  \n\n}\n\n\nfloat ShortestDistanceToObjSurface(vec3 eye, vec3 rayDir,float start,float end){\n\n       float depth = start;\n    \n    \n    for(int i = 0;i<MAX_RAY_SCALE;i++){\n        \n        float dist = sceneSDF(eye+rayDir*depth);\n        \n        if(dist<SCALE){\n        \n         return depth;        \n        }\n        depth+=dist;\n        \n        if(depth>=end){\n        \n        return end;\n        \n        }\n\n    }\n   \n     return end;\n}\n\n\n\nvec3 RayDir(vec2 size,vec2 fragcood){\n\n    vec2 xy = fragcood-size/2.0;\n    \n    float z = size.y+500.0;\n    \n    return normalize(vec3(xy,-z));\n   \n\n    \n    \n}\n\n\nvec3 createNormal(vec3 p){\n\nreturn normalize(vec3(\n\n    sceneSDF(vec3(p.x+SCALE,p.y,p.z))-sceneSDF(vec3(p.x-SCALE,p.y,p.z)),\n    sceneSDF(vec3(p.x,p.y+SCALE,p.z))-sceneSDF(vec3(p.x,p.y-SCALE,p.z)),\n    sceneSDF(vec3(p.x,p.y,p.z+SCALE))-sceneSDF(vec3(p.x,p.y,p.z-SCALE))\n\n));\n\n}\n\n\n\n\nvec3 PhongLight(vec3 k_d,vec3 k_s,vec3 eye,vec3 p,vec3 LightPos,vec3 LightColor,float alpha){\n    \n     vec3 N = createNormal(p);\n     vec3 L = normalize(LightPos-p);\n     vec3 V = normalize(eye-p);\n     vec3 R = normalize(reflect(-L,N));\n     \n     float LdotN = max(dot(L,N),0.0);\n    \n     float RdotN = max(dot(R,N),0.0);\n    \n    if(LdotN<0.0){\n    \n       return vec3(0.0,0.0,0.0);\n        \n    }\n    \n    if(RdotN<0.0){\n    \n       \n       return LightColor*LdotN*k_d;\n        \n    }\n    \n    \n    \n    \n    return LightColor*LdotN*k_d+pow(RdotN,alpha)*k_s;\n\n\n\n\n}\n\n\nvec3 PhongLightPosColor(vec3 k_d,vec3 k_a,vec3 k_s,vec3 eye,vec3 p,float alpha){\n        \n    vec3 color = k_a*vec3(0.5,0.5,0.5);\n    \n    vec3 LightPos1 = vec3(4.0*sin(iTime),2.0,4.0*cos(iTime));\n    \n    vec3 LightColor1 = vec3(0.2,0.2,0.2);\n    \n    color+= PhongLight(k_d, k_s, eye, p, LightPos1, LightColor1, alpha);\n    \n    \n\n\nreturn color;\n\n\n\n}\n\n\n\nmat4 ViewMatri(vec3 eye,vec3 center,vec3 up){\n    vec3 f = normalize(center-eye);\n    vec3 s = normalize(cross(f,up));\n    vec3 u = cross(s,f);\n\nreturn mat4(\n    \n    vec4(s,0.0),\n    vec4(u,0.0),\n    vec4(-f,0.0),\n    vec4(0.0,0.0,0.0,1.0)\n\n\n\n);\n\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(8.0, 5.0,7.0);\n    \n    \n    vec3 dir = RayDir(iResolution.xy,fragCoord);\n   \n\n    \n    mat4 viewtoworld = ViewMatri(eye,vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0));\n    \n    vec3 worldView =(viewtoworld*vec4(dir,0.0)).xyz;\n    \n    float dis = ShortestDistanceToObjSurface(eye,worldView,MIN_DIST,MAX_DIST);\n    \n    vec3 surface = eye+worldView*dis;\n  \n    float alpha = 10.0;\n    \n    vec3 LightColor = vec3(0.4,0.3,0.8);\n    \n    vec3 k_d = vec3(0.5,0.6,0.9);\n    \n    vec3 k_a = vec3(0.2,0.2,0.2);\n    \n    vec3 k_s = vec3(1.0,1.0,1.0);\n    \n    if(dis>50.0){\n    \n      fragColor = vec4(0.0,0.0,0.0,1.0);\n     return;\n    \n    }\n    \n       vec3 col =  PhongLightPosColor( k_d, k_a,k_s,eye,surface, alpha);\n        //  vec3 col =  vec3(1.0,0.3,0.0);\n        fragColor = vec4(col,1.0);\n    \n   // fragColor = vec4(1.0,0.3,0.0,1.0);\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tscWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 140, 140, 347], [350, 350, 374, 374, 406], [409, 409, 432, 432, 466], [469, 469, 549, 549, 901], [905, 905, 942, 942, 1066], [1069, 1069, 1095, 1095, 1346], [1351, 1351, 1444, 1444, 1921], [1924, 1924, 2004, 2004, 2276], [2280, 2280, 2325, 2325, 2529], [2535, 2535, 2592, 2592, 3535]]}
{"id": "4tSyRW", "name": "Glow Andii ", "author": "Andii", "description": "Glow", "tags": ["glow"], "likes": 0, "viewed": 397, "published": "Public API", "date": "1507546248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 alphaSub(vec4 color, vec4 colorBg, float dist, float size)\n{\n \t\n    float add = 0.0 + ((dist-(size/5.0))/(size/5.0));\n    \n   \tfloat maxr = max(color.r, colorBg.r);\n    float maxg = max(color.g, colorBg.g);\n    float maxb = max(color.b, colorBg.b);\n    \n    \n    if(maxr == colorBg.r)\n    {\n    \tcolor.r += add; \n        if(color.r > colorBg.r)\n        \tcolor.r = colorBg.r;\n    }\n    \n    else{\n    \tcolor.r -= add; \n        if(color.r < colorBg.r)\n            color.r = colorBg.r;\n    }\n    \n    \n    if(maxg == colorBg.g)\n    {\n    \tcolor.g += add; \n        if(color.g > colorBg.g)\n        \tcolor.g = colorBg.g;\n    }\n    \n    else{\n    \tcolor.g -= add; \n        if(color.g < colorBg.g)\n            color.g = colorBg.g;\n    }\n    \n     if(maxb == colorBg.b)\n    {\n    \tcolor.b += add; \n        if(color.b > colorBg.b)\n        \tcolor.b = colorBg.b;\n    }\n    \n    else{\n    \tcolor.b -= add; \n        if(color.b < colorBg.b)\n            color.b = colorBg.b;\n    }\n \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = vec4(0,0,0,0);\n    vec4 colorBg = vec4(0,1.0*sin(iTime),0.6*sin(iTime),1);\n    \n    float dist = distance(fragCoord.xy+150.0*sin(iTime*0.4),iResolution.xy/2.0);\n \tfloat size = 120.0;\n    float glowIntense = 3.8;\n    \n    if(dist <= size)\n    {\n        color = vec4(1,1,0,1);\n        if(dist < size/glowIntense)\n        {\n        \tcolor += 0.0 - ((dist-60.0)/40.0);\n        }\n        else if(dist >= size/glowIntense)\n        {\n            vec4 glowVal = vec4(0.01);\n            color = alphaSub(color, colorBg, dist, size);\n        }\n    }\n    else\n    {\n    \tcolor = colorBg;   \n    }\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSyRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 66, 66, 992], [994, 994, 1051, 1051, 1728]]}
{"id": "4tSyzD", "name": "3-Simplex Intersection", "author": "paniq", "description": "efficient and robust intersection of 3-simplex and ray by converting the ray to barycentric basis.", "tags": ["raytracing", "ray", "intersection", "tetrahedron"], "likes": 18, "viewed": 868, "published": "Public API", "date": "1507586929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DEBUG_LIGHT 0\n#define DEBUG_NORMAL 0\n\n// compute the barycentric transform matrix\nmat3 compute_bary_transform(vec3 p[4]) {\n    vec3 e[6];\n    e[0] = p[2] - p[1];\n    e[1] = p[0] - p[2];\n    e[2] = p[1] - p[0];\n    e[3] = p[1] - p[3];\n    e[4] = p[2] - p[3];\n    e[5] = p[0] - p[3];\n    mat3 m = mat3(\n    \tcross(e[0], e[3]),\n    \tcross(e[1], e[4]),\n    \tcross(e[2], e[5]));\n    float invdet = 1.0/dot(m[0], e[1]);\n    // premultiply the plane orthogonals by the inverse determinant\n    return m * invdet;\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec4 to_bary(vec3 p3, mat3 m, vec3 t) {\n    // weights are scaled distance of point to individual planes\n    vec3 w = (t - p3) * m;\n    float ww = 1.0 - w.x - w.y - w.z;\n    return vec4(w, ww);    \n}\n\nvec3 from_bary(vec3 p[4], vec4 w) {\n\treturn p[0] * w.x + p[1] * w.y + p[2] * w.z + p[3] * w.w;\n}\n\nvec3 normal_from_bary(mat3 m, vec4 w) {\n    return normalize(m * (w.w - w.xyz));\n}\n\nstruct Hit {\n    // ray scalar\n    float t;\n    // barycenter\n    vec4 b;\n    // normal\n    vec3 n;\n};\n\n// return normal of nearest plane in barycentric coordinates\nvec4 select_plane_normal(vec4 b) {\n    float lc = min(min(b.x, b.y), min(b.z, b.w));\n    return step(b, vec4(lc));\n}\n\n// return the intersection of ray and tetrahedron\n// as well as the barycentric coordinates and normals of the hit points\nbool iSimplex3(vec3 p[4], vec3 ro, vec3 rd, \n\tout Hit near, out Hit far) {\n    \n    mat3 m = compute_bary_transform(p);\n    \n    // convert ray endpoints to barycentric basis\n    vec4 r0 = to_bary(p[3], m, ro);\n    vec4 r1 = to_bary(p[3], m, ro + rd);\n\n    // build barycentric ray direction from endpoints\n    vec4 brd = r1 - r0;\n    \n    // compute ray scalars for each plane\n    vec4 t = -r0/brd;\n    \n    // valid since GL 4.1\n    near.t = -1.0 / 0.0;\n    far.t = 1.0 / 0.0;\n    \n#if 0\n    for (int i = 0; i < 4; ++i) {\n        // equivalent to checking dot product of ray dir and plane normal\n        if (brd[i] < 0.0) {\n            far.t = min(far.t, t[i]);\n        } else {\n            near.t = max(near.t, t[i]);\n        }\n    }\n#else\n    // loopless, branchless alternative\n    // equivalent to checking dot product of ray dir and plane normal    \n    bvec4 comp = lessThan(brd, vec4(0.0));\n    vec4 far4 = mix(vec4(far.t), t, comp);\n    vec4 near4 = mix(t, vec4(near.t), comp);\n    far.t = min(min(far4.x,far4.y),min(far4.z,far4.w));\n    near.t = max(max(near4.x,near4.y),max(near4.z,near4.w));\n#endif\n    \n    if ((far.t <= 0.0) || (far.t <= near.t))\n        return false;\n    near.b = r0 + brd * near.t;\n    far.b = r0 + brd * far.t;\n\n    vec4 n0 = select_plane_normal(near.b);\n    vec4 n1 = select_plane_normal(far.b);\n    near.n = normal_from_bary(m, n0);\n    far.n = normal_from_bary(m, n1);\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = iTime * 0.1;\n    float d = 2.5;\n\tcamPos = vec3(d*sin(an),1.0,d*cos(an));\n    camTar = vec3(0.0,-0.3,0.0);\n}\n\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 feet_curve(float t) {\n    float subt = mod(t, 3.0);\n    float x = sin(radians(min(subt*180.0,180.0)));\n    float a0 = radians((t - subt)/3.0 * 30.0);\n    float a1 = a0 + radians(30.0);\n    float a = mix(a0, a1, min(subt,1.0));\n\treturn vec3(cos(a),sin(a),mix(-1.0,-0.8,x));\n}\n\nvec3 calc_intersection( in vec3 ro, in vec3 rd ) {\n    ro = ro.zxy;\n    rd = rd.zxy;\n    vec3 p[4];\n    float ti = iTime * 8.0;\n    p[0] = feet_curve(ti);\n    p[1] = feet_curve(ti + 12.0 + 1.0);\n    p[2] = feet_curve(ti + 24.0 + 2.0);\n    // do a little spring animation\n    ti = iTime * 4.0;\n    vec2 cuv = hash21(float(int(ti / 5.0))) * 2.0 - 1.0;\n    ti = mod(ti, 5.0) * 2.0;\n    float rk = (10.0 - ti) / (1.0 + (10.0 - ti));\n    float spr = clamp(rk * ((8.0 - sin(ti * 8.0) / (ti * ti))/8.0), 0.0, 2.0);\n    p[3] = vec3(mix(vec2(0.0), cuv, spr), mix(-0.7, 0.5, spr));\n    \n    vec3 l = normalize(vec3(1.0, -1.0, -1.0));\n    \n    float plane_t = -(ro.z + 1.0) / rd.z;\n    \n    Hit h0, h1;\n    if (iSimplex3(p, ro, rd, h0, h1)) {\n        vec4 c = (h0.t > 0.0)?h0.b:h1.b;\n        \n        float lit = 0.2 + 0.8 * max(0.0, dot(-l, h0.n));\n        \n#if DEBUG_LIGHT            \n        return\n              c.x * vec3(1.0, 0.0, 0.0)\n        \t+ c.y * vec3(0.0, 1.0, 0.0)\n            + c.z * vec3(0.0, 0.0, 1.0)\n            + c.w * vec3(1.0, 0.0, 1.0)\n        ;\n#elif DEBUG_NORMAL\n        return h0.n*0.5+0.5;\n#else\n        return lit * (\n              c.x * vec3(0.0, 1.0, 0.5)\n        \t+ c.y * vec3(1.0, 0.5, 0.0)\n            + c.z * vec3(1.0, 0.0, 0.5)\n            + c.w * vec3(0.5, 0.0, 1.0)\n        );\n#endif           \n    } else if (plane_t > 0.0) {\n\t    vec3 plane_p = ro + rd * plane_t;\n        float sh = iSimplex3(p, plane_p, -l, h0, h1)?0.2:0.5;\n        return vec3(sh) * abs(rd.z);\n    } else {        \n        return vec3(0.0);\n    }\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    col = calc_intersection( ro, rd );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSyzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 90, 130, 130, 514], [516, 648, 687, 752, 847], [849, 849, 884, 884, 945], [947, 947, 986, 986, 1029], [1135, 1196, 1230, 1230, 1312], [1314, 1436, 1510, 1510, 2861], [2863, 2938, 3021, 3021, 3144], [3147, 3147, 3174, 3174, 3209], [3211, 3302, 3324, 3324, 3437], [3439, 3439, 3465, 3465, 3718], [3720, 3720, 3770, 3770, 5265], [5267, 5267, 5331, 5331, 5509], [5511, 5511, 5568, 5568, 6142]]}
{"id": "ldVGDV", "name": "vt3", "author": "victor", "description": "test3", "tags": ["test"], "likes": 2, "viewed": 70, "published": "Public", "date": "1508268782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col=vec3(.0);\n  \n    float off=iTime*.12;\n    float amp=sin(uv.x*5.);\n    float amp2=sin(uv.x*1.);\n    \n    col.x=pow(1.-distance(vec2(uv.x, (sin((uv.x+off)*40.)*.25*amp-uv.y+0.5)*amp2), uv),3.);\n    \n    //if(col.x>.9) \n    col.y=pow(1.-distance(uv,vec2(.0)),2.);\n    \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 418]]}
{"id": "ll2cRy", "name": "manyBluePoints", "author": "nigel_kozlowski", "description": "Many blue points", "tags": ["manybluepoints"], "likes": 0, "viewed": 64, "published": "Public", "date": "1509057097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// get factor between 0. and 1. \n// increasing during first second \n// and decreasing during second second periodicaly\nfloat getTimeWaveFactor () {\n\treturn mod(iTime, 2.0) < 1. ? mod(iTime, 1.) : 1. - mod(iTime, 1.);\n}\n\n// ex: div(553, 100) = 500\nfloat div (float a, float b) {\n\treturn a - mod(a, b); \n}\n\n// get the closest float from @coord\n// with specified @space\n// ex: closest(18., 5.) = 20.\nfloat closest (float coord, float space) {\n    return mod(coord, space) > space / 2. ? \n        div(coord, space) + space\n        : div(coord, space);\n}\n\n// get the closest point from @point\n// in a @grid\nvec2 closestPointInGrid(vec2 point, vec2 grid) {\n    return vec2(closest(point.x, grid.x), closest(point.y, grid.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // generate gri\n    vec2 grid = vec2(1000., 1000.) / iTime;\n    float patternSize = 500. / iTime;\n    \n    float timeWaveFactor = max(getTimeWaveFactor(), 0.01);\n\tfloat radius = timeWaveFactor * patternSize;\n    \n\t// distance between the closest point and the current pixel\n    vec2 closestPoint = closestPointInGrid(fragCoord.xy, grid);\n\tfloat distanceCPToPixel = distance(closestPoint, fragCoord.xy);\n\t\n\t// blue color factor\n\tfloat blue = (radius - distanceCPToPixel) / radius;\n\tfragColor = vec4(\n        0., \n    \t0., \n    \tblue, \n        1.\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2cRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 119, 147, 147, 218], [220, 247, 277, 277, 303], [305, 397, 439, 439, 549], [551, 602, 650, 650, 721], [723, 723, 780, 800, 1338]]}
{"id": "ll2cRz", "name": "x^y = y^x  (:P)", "author": "timeiskey", "description": "i saw iqs video on this function and decided to try my own.\nan integer grid would be nice\n", "tags": ["iq"], "likes": 0, "viewed": 57, "published": "Public", "date": "1507269581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float shade = 1.0;\n    \n    vec2 bottomPoint = vec2( 0.0, 0.0 );\n    \n    float modifier = iTime * 4.0;\n    float distanceToBottomPoint = length( pow( uv.x * modifier, uv.y * modifier ) - pow( uv.y * modifier, uv.x * modifier ) );\n    float tolerance = 5.0;\n    \n    shade *= smoothstep( -tolerance, tolerance, distanceToBottomPoint );\n\n    fragColor = vec4( shade, shade, shade, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2cRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 493]]}
{"id": "ll2czG", "name": "Hypno1", "author": "scarletshark", "description": "Just messing around until I felt dizzy.", "tags": ["2d", "plasma", "golf"], "likes": 1, "viewed": 153, "published": "Public", "date": "1509042899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rd(x) cos(x * 3.) + cos((x + .3) * 3.6) * 1.1\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 r = iResolution.xy;\n    float t = iTime;\n    vec2 s = (f / r.xy - .5) * 2. * 10.;\n    s.y *= r.y / r.x;\n    float m = sqrt(s.x * s.x + s.y * s.y);\n    float x = rd(log(m) + t * -.4) * 4.;\n    x += rd(m + t * .5);\n    x += rd(log(abs(sin(atan(s.y, s.x))) + 3.) + t * .1) * 30.;\n    x *= smoothstep(.2, 1., m); \n    c = mix(vec4(.7), vec4(.1), clamp(cos(x), 0., 1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2czG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 96, 96, 473]]}
{"id": "ll2yWh", "name": "SecondSpiral", "author": "dickie", "description": "iteration of the first spiral\n\n'Find a quiet place and sit comfortably on the ground with your back straight\nMake sure you are in a very comfortable position\nSo you can let yourself go completely'", "tags": ["spiral"], "likes": 1, "viewed": 123, "published": "Public", "date": "1508430714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float turns = 4.0 ;\n    float speed = -0.333;\n    float width = 0.666;\n    \n    \n    float colorSpeed \t\t= -0.25;\n    float colorSaturation \t= 0.4; \t// saturation\n    float colorValue \t\t= 0.8; \t// brightness\n    \n\tvec2 uv = ( fragCoord - .5*iResolution.xy )/ iResolution.y;\n    \n    float angle = atan(uv.y, uv.x) / (6.283);\n    angle = fract(angle + (iTime * speed));\n    \n\t\n    float dist = length(uv);\n    float waves = fract( dist  * turns) ;\n    \n    float spiral = angle - waves;\n    //float spiral = (abs(angle - waves) - 0.5 )* 2.0  ;\n    //spiral = step((spiral*spiral), 0.1);\n\n    float spiralX = 1.0 - ((spiral - (0.5 * sign(spiral)) ) + 0.5);\n    \n    //spiral = abs((abs(spiral) - 0.5 )* 2.0  );\n    \n    spiral = step(spiralX, width);\n\n    float gradSpiral = spiral * clamp(dist * (turns / 4.0), 0.0,1.0);\n    \n    gradSpiral -= (spiralX * 0.25);\n   \tvec3 rainbow = hsv2rgb(vec3(gradSpiral - (iTime * colorSpeed), colorSaturation, colorValue)) ;\n  \tfragColor = vec4( rainbow * spiral , 1.0);\n\n\n}\n\n\n\n\n/*\nhsv2rgb from https://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n*/\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2yWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [193, 193, 250, 250, 1263]]}
{"id": "ll2yWw", "name": "Polygonal area light", "author": "morphiumsuchtig", "description": "This is the adaptation of my method of algebraic approximation of polygonal area lights for real-time shading  (https://github.com/bad3p/PAL/blob/master/Docs/PolygonalAreaLights_09081016.pdf).", "tags": ["arealight"], "likes": 5, "viewed": 285, "published": "Public", "date": "1508948738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nmat4 rotationMatrix(float x, float y, float z)\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 translationMatrix(float x, float y, float z)\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n  \t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,  y, z, 1.0 );\n\n}\n\n\nmat4 perspectiveMatrix(float fov, float aspect, float near, float far)\n{\n    float f = abs(tan(3.1415926 * 0.5 - 0.5 * fov));\n    f = 1.0 / tan(fov * 3.1415926/ 180.0 / 2.0);\n    float invRange = 1.0 / (near - far);\n\treturn mat4\n\t(\n      f/aspect, 0.0, 0.0, 0.0,\n      0.0, f, 0.0, 0.0,\n      0.0, 0.0, (near + far) * invRange, -1.0,\n      0.0, 0.0, near * far * invRange * 2.0, 0.0\n    );\n}\n\nbool rayPlaneIntersection(vec3 planeNormal, vec3 pointOnPlane, vec3 rayOrigin, vec3 rayDirection, out vec3 wordIntersection)\n{\n\tvec3 w = rayOrigin - pointOnPlane;\n\tfloat s = -dot( planeNormal, w ) / dot( planeNormal, rayDirection );\n    wordIntersection = rayOrigin + rayDirection * s;\n\treturn ( s < 0.0 );\n}\n\nfloat signTest(vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool pointInsideTriangle(vec2 pt, vec2 v0, vec2 v1, vec2 v2)\n{    \n    bool b1, b2, b3;\n\n    b1 = signTest(pt, v0, v1) < 0.0;\n    b2 = signTest(pt, v1, v2) < 0.0;\n    b3 = signTest(pt, v2, v0) < 0.0;\n\n    return ((b1 == b2) && (b2 == b3));\n}\n\n//--------------------------------------------------------------------------------\n\nconst vec3 planeNormal = normalize( vec3( 0.0, 1.0, 0.0 ) ) ;\nconst vec3 pointOnPlane = vec3( 0.0, -0.33, 0.0 );\n\nconst float areaLightIntensity = 2.0;\nconst vec4 areaLightColor = vec4( 0.97, 0.93, 0.11, 1.0 );\nconst vec4 ambientColor = vec4( 0.25, 0.25, 0.25, 1.0 );\n\nconst vec4 areaLightNormal = vec4( 0.0, 0.0, 1.0, 0.0 );\n\nconst vec4[] areaLightVertices = vec4[] \n(\n    vec4( 0.0, 0.0, 0.0, 1.0 ),\n\tvec4( -0.500, -0.500, 0.0, 1.0 ),\n\tvec4( -0.500, 0.500, 0.0, 1.0 ),\n\tvec4( 0.500, 0.500, 0.0, 1.0 ),//3\n\tvec4( 0.500, -0.500, 0.0, 1.0 ),\n\tvec4( 2.0, 0.000, 0.0, 1.0 ),//5\n\tvec4( 0.000, 2.0, 0.0, 1.0 ),\n\tvec4( -2.0, 0.000, 0.0, 1.0 ),\n\tvec4( 0.000, -2.0, 0.0, 1.0 ),\n\tvec4( 0.000, 0.000, 0.0, 1.0 )//9\n);\n\nconst int[] areaLightIndices = int[]\n(\n\t5, 3, 9,\n\t3, 6, 9,\n\t6, 2, 9, \n\t2, 7, 9, \n\t7, 1, 9, \n\t1, 8, 9, \n\t8, 4, 9, \n\t4, 5, 9     \n);\n\n//--------------------------------------------------------------------------------\n\nvoid getWorldRay(mat4 screenToWorldSpaceMatrix, vec2 fragCoord, out vec3 worldRayOrigin, out vec3 worldRayDir)\n{\n    vec4 screenPos1 = vec4( fragCoord.xy / iResolution.xy * 2.0 - 1.0, 0.0, 1.0 );\n    vec4 screenPos2 = vec4( fragCoord.xy / iResolution.xy * 2.0 - 1.0, -0.5, 1.0 );\n    \n    vec4 worldPos1 = screenToWorldSpaceMatrix * screenPos1;\n    vec4 worldPos2 = screenToWorldSpaceMatrix * screenPos2;\n    \n    worldPos1 /= worldPos1.w;\n    worldPos2 /= worldPos2.w;\n\n    worldRayOrigin = worldPos1.xyz;\n    worldRayDir = normalize( worldPos2.xyz - worldPos1.xyz );\n}\n\nvec3 getPointInBasis(vec3 p, vec3 b0, vec3 bx, vec3 by, vec3 bz)\n{\n    vec3 pb = p - b0;\n    return vec3( dot( pb, bx ), dot( pb, by ), dot( pb, bz ) );\n}\n\nfloat cross2(vec2 u, vec2 v)\n{\n    return u.x * v.y - u.y * v.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 cameraMatrix = translationMatrix( 0.0, 3.0, 6.0 ) * rotationMatrix( -0.2 - iMouse.y * 0.001, 0.0, 0.0 );    \n    mat4 projectionMatrix = perspectiveMatrix(70.0, iResolution.x/iResolution.y, 0.01, 10.0 );\n    mat4 screenToWorldSpaceMatrix = cameraMatrix * inverse( projectionMatrix );\n    \n    vec3 worldRayOrigin;   \n    vec3 worldRayDir;\n    \n    getWorldRay( screenToWorldSpaceMatrix, fragCoord, worldRayOrigin, worldRayDir );\n    \n    // raycasting against plane\n    \n    vec3 worldPos1;\n    bool planeRaycastResult = rayPlaneIntersection( planeNormal, pointOnPlane, worldRayOrigin, worldRayDir, worldPos1 );\n    \n    // raycasting against area light triangles\n    \n    mat4 areaLightMatrix = translationMatrix( 0.0, 3.0 + sin(iTime), -1.0 ) * \n        rotationMatrix( 0.5 * sin( iTime ), 0.0, 0.0 ) *\n        rotationMatrix( 0.0, iTime * 0.25, 0.0 ) *\n        rotationMatrix( 0.0, 0.0, iTime );\n    mat4 invertedAreaLightMatrix = inverse( areaLightMatrix );\n    \n    bool areaLightRaycastResult = false;    \n    vec3 worldPos2 = worldPos1;\n    vec3 n = normalize( ( areaLightMatrix * areaLightNormal ).xyz );\n    float normalCondition = dot( planeNormal, n );\n    float polygonArea = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        int i0 = areaLightIndices[i*3];\n        int i1 = areaLightIndices[i*3+1];\n        int i2 = areaLightIndices[i*3+2];\n        \n        vec3 v0 = ( areaLightMatrix * areaLightVertices[i0] ).xyz;        \n        \n        vec3 worldPos;\n        bool triangleRaycastResult = false;\n        if( rayPlaneIntersection( n, v0, worldRayOrigin, worldRayDir, worldPos ) )\n        {        \n        \tvec4 localPos = invertedAreaLightMatrix * vec4( worldPos.xyz, 1.0 );\n\n        \ttriangleRaycastResult = pointInsideTriangle( localPos.xy, areaLightVertices[i0].xy, areaLightVertices[i1].xy, areaLightVertices[i2].xy );\n            if( triangleRaycastResult )\n            {                \n        \t\tareaLightRaycastResult = true;\n                worldPos2 = worldPos;\n            }\n        }\n        \n        // diffuse light contribution from triangle \n                \n        if( !triangleRaycastResult && planeRaycastResult && normalCondition < 0.9999 )\n        {\n            vec3 v1 = ( areaLightMatrix * areaLightVertices[i1] ).xyz;\n        \tvec3 v2 = ( areaLightMatrix * areaLightVertices[i2] ).xyz;            \n            \n            vec3 c = (v0 + v1 + v2) / 3.0;\n            vec3 bz = normalize( c - worldPos1 );\n            \n            float sideEffect = dot( bz, n );            \n            if( sideEffect > 0.0 )\n            {            \n            \tvec3 by = vec3( bz.y, bz.z, -bz.x );\n            \tvec3 bx = normalize( cross( by, bz ) );\n            \tby = normalize( cross( bz, bx ) );\n            \n            \tvec3 lv0 = getPointInBasis( v0, worldPos1, bx, by, bz );\n            \tvec3 lv1 = getPointInBasis( v1, worldPos1, bx, by, bz );\n            \tvec3 lv2 = getPointInBasis( v2, worldPos1, bx, by, bz );\n            \n            \tlv0.xy /= lv0.z;\n            \tlv1.xy /= lv1.z;\n            \tlv2.xy /= lv2.z;\n            \n            \tpolygonArea += 0.5 * cross2( lv1.xy-lv0.xy, lv2.xy-lv0.xy );                \n            }\n        }\n    }\n    \n    float localIntensity = polygonArea * areaLightIntensity;\n    vec4 planeColor = ambientColor + areaLightColor * localIntensity;\n    \n    vec4 areaLightColor = mix( \n        areaLightColor, \n        areaLightColor * 0.5, \n        step( 0.0, dot( n, worldRayDir ) )\n    );\n    \n    if( planeRaycastResult )\n    {\n        if( areaLightRaycastResult )\n        {\n            float worldDist1 = distance( worldRayOrigin, worldPos1.xyz );\n    \t\tfloat worldDist2 = distance( worldRayOrigin, worldPos2.xyz );\n            \n            fragColor = mix(\n        \t\tplaneColor,\n        \t\tareaLightColor,\n        \t\tfloat(worldDist1>worldDist2)\n    \t\t);\n        }\n        else\n        {\n            fragColor = planeColor;\n        }\n    }\n    else if( areaLightRaycastResult )\n    {\n        fragColor = areaLightColor;\n    }\n    else\n    {\n        fragColor = vec4( 0, 0, 0, 1 );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2yWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 49, 49, 406], [408, 408, 459, 459, 573], [576, 576, 648, 648, 967], [969, 969, 1095, 1095, 1277], [1279, 1279, 1322, 1322, 1398], [1400, 1400, 1462, 1462, 1641], [2568, 2652, 2764, 2764, 3222], [3224, 3224, 3290, 3290, 3378], [3380, 3380, 3410, 3410, 3446], [3448, 3448, 3505, 3505, 7580]]}
{"id": "llBcDz", "name": "SolarEclipse", "author": "TheOnlyaaa", "description": "learn from others", "tags": ["2d"], "likes": 4, "viewed": 424, "published": "Public API", "date": "1508211102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// learn from http://glslsandbox.com/e#42084.1\n\n/*\nfloat circle(vec2 center, vec2 pos, float scale)\n{\n \treturn length(center - pos) * scale;   \n}\n\nvec3 sun(vec2 center, vec2 pos)\n{\n \tfloat t = 1.0 - smoothstep(0.2, 1.0, circle(center, pos, 2.0) );\n   \tvec3 fc = t * vec3( 4.0, 2.0, 1.0);\n    return fc;\n}\n\nvec3 moon(vec2 center, vec2 pos)\n{\n \tfloat t = 1.0 - smoothstep(0.1, 1.0, circle(center, pos, 2.2) );\n    vec3 fc = t * vec3( 100.0, 100.0, 200.0 );\n    return fc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 s = sun( vec2( 0.0, 0.0), uv );\n    vec3 m = moon( vec2( sin(iTime * 0.3) * 0.7, 0.0), uv );\n\tfragColor = vec4( s - m,1.0);\n}\n*/\n    \n// more concise\n#define circle( c, p, s ) length(p - c) * s\n#define sun(c, p) smoothstep(1., 0.2, circle(c, p, 2.)) * vec4( 4, 2, 1, 0)\n#define moon(c, p) smoothstep(1., 0.1, circle(c, p, 2.2)) * vec4( 100, 100, 200, 0)\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    U = (U - 0.5 * iResolution.xy) / iResolution.y;\n    \n    O = sun(vec2(0, 0), U) \n        - moon(vec2(0, 0), U + vec2(0.7 * sin(0.3 * iTime), 0)) \n        + vec4( 0.3, 0.3, 0.3, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[745, 966, 1005, 1005, 1192]]}
{"id": "llBcWR", "name": "Volumetric particles (186 c)", "author": "PrzemyslawZaworski", "description": "Random white dots -> it is not a bug, it is a feature :)", "tags": ["procedural", "3d", "raymarching", "fractal", "volume", "clouds", "particles", "volumetric", "spheretracing", "art", "golf", "twotweet"], "likes": 7, "viewed": 262, "published": "Public", "date": "1508174045", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License https://opensource.org/licenses/MIT\n// Copyright Â© 2017 Przemyslaw Zaworski\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n#define s for (int i = 0; i ++< 50;) \nvoid mainImage(out vec4 c, vec2 f) {\t\t\t\t\t\t\t\t\t\t\t\\\ns\n{\n    c.w+=.1;\n\tvec3 p=c.w*vec3(f/iResolution.xy,2);p.y+=.2*iTime;\n\ts p = vec3(1.25,1.07,1.29)*abs(p/dot(p,p)-vec3(.95,.91,.67));\n\tc.xyz+=p/50.;\n}}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBcWR.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1163, 1199, 1199, 1360]]}
{"id": "llBczw", "name": " Rocket In The Skies", "author": "ollj", "description": "fork of:\nhttps://www.shadertoy.com/view/4tyXWt", "tags": ["volume", "cloud", "scattering", "smoke", "rocket", "bounding", "deferred"], "likes": 8, "viewed": 550, "published": "Public API", "date": "1507882333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//sign 3d Rocket In The Skies deferred volume marching\n\n//self  : https://www.shadertoy.com/view/llBczw\n//parent: https://www.shadertoy.com/view/4tyXWt\n\n\n/*\na lot of entities here are very priimitive and coarse:\n- shapes\n- rotations\nBut hats not the point here. \nThis is more aboud compositioning smoke and solids and a background\nit has basic g-buffering, by first measuring 2 distances\n, within 2 bounding volumes; vec2 d=vec2(gds(p,t),gdt(p,t))\n as first step before calculating colors.\n*/\n\n// Constants\n#define pi acos(-1.)\n\n// Time Scaling\n#define tim iTime*0.1\n#define rocketRotation 1.5*sin(0.9*tim) \n\n#define cSun vec3(1)\n#define cSky vec3(.5,.8,.99)\n#define cAmb vec3(.4)\n\n//octaves of smoke volumes\n#define octavesSmoke 12\n\n//Raymarching solid\n#define minPrimStepSize .1\n#define iterRm 100\n//volumeMarching smoke\n#define RmSmokSampleSize .1\n#define iterRmSmoke 50\n//volumeMarching smoke illumination\n#define RmSmokSampleSize2 .2\n#define iterRmSmoke2 5 \n\n#define smokeStart vec3(5,-50,5) \n#define smokeEnd  vec3(5) \n#define smokeThickness 1.\n#define smokeOffset .1\n\n\n//exiting smoke...\n#define oExting 10.\nconst float oScat = 12.5 ;\n\n#define sat(a) clamp(a,.0,1.)\n#define u5(a) ((a)*.5+.5)\n\n#define ma0(a) max(a,.0)\n\nvec2 rot2D(vec2 p,float a)\n{float s=sin(radians(a)),c=cos(radians(a))\n;return p*mat2(c,s,-s,c);}\n//if i ever saw inefficient style\nvec2 frot(const float a,vec2 v){float c= cos(a),s= sin(a)\n;vec2 u=v;v.x=u.x*c+u.y*s;v.y=u.x*-s+u.y*c;return v;}\n\n // replace this by something better\nfloat hash(vec3 p){p=17.*fract( p*0.3183099+.1)\n;return fract(p.x*p.y*p.z*(p.x+p.y+p.z));}\n\nfloat noise(vec3 x)\n{vec3 p=floor(x),f=fract(x);f=f*f*(3.0-2.0*f);return mix\n(mix(mix(hash(p+vec3(0,0,0))\n        ,hash(p+vec3(1,0,0)),f.x)\n    ,mix(hash(p+vec3(0,1,0))\n        ,hash(p+vec3(1,1,0)),f.x),f.y)\n,mix(mix(hash(p+vec3(0,0,1))\n        ,hash(p+vec3(1,0,1)),f.x)\n    ,mix(hash(p+vec3(0,1,1))\n        ,hash(p+vec3(1,1,1)),f.x),f.y),f.z);}\n\n//return smoke density at [u].\nfloat sampleSmoke(vec3 u)\n{float n=0.,a=1.,f=3.,l=2.\n;for (int i=0;i<octavesSmoke;++i\n){n+=a*noise(f*u+vec3(.0,tim*200.,3.*tim));a/=l;f*=l;}\n;vec3 d=normalize(smokeEnd-smokeStart)\n;u=smokeStart-u;\n;return 2.*sat((n*exp(-2.5*length(u-(dot(u,d))*d))-smokeOffset)\n                *(1.-exp(-.05*length(u))));}\n\n//shape lib\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float r){p-=a,b-=a\n;float h=sat(dot(p,b)/dot(b,b));return length(p-b*h)-r;}\nfloat mBox(vec3 p, vec3 b)\n{return max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);}\nvoid angularRepeat(const float a,inout vec2 v)\n{float t=mod(atan(v.y,v.x)+a*.5,a)-a*.5\n;v=vec2(cos(t),sin(t))*length(v);}\n\n//return distance of p to rocket shape.\n//shape code looks mildly messy, but thats the nature of such.\nfloat dfRocketBody(vec3 p)\n{p.xz=frot(rocketRotation,p.xz)\n;vec3 q=p\n;angularRepeat(pi*.25,q.zx)\n;float d=q.z//body\n;d=max(d,frot(pi*-.125    ,q.yz+vec2(-.7  ,0)).y)\n;d=max(d,frot(pi*-.25 *.75,q.yz+vec2(-0.95,0)).y)\n;d=max(d,frot(pi*-.125*.5 ,q.yz+vec2(-0.4 ,0)).y)\n;d=max(d,frot(pi* .125*.25,q.yz+vec2(+0.2 ,0)).y)\n;d=max(d,frot(pi* .125*.8 ,q.yz+vec2(.55  ,0)).y)\n;d=max(d,-.8-p.x)\n;d-=.5\n;vec3 t=q-vec3(-1.46,0,0)//trusters\n;t.yz=frot(pi*-.2,t.yz)\n;d=min(d,mBox(t,vec3(.1,.4,.27)))\n;d=min(d,mBox(t-vec3(-.09,.0,.0),vec3(.1,.3,.07)));\n;vec3 w=p-vec3(.1,.0,.0)//window\n;angularRepeat(pi*.25,w.xy)\n;w-=vec3(.17,.0,.0)\n;d=min(d,mBox(w,vec3(.03,.2,.55)))\n;return d;}\nfloat dfRocketFins(vec3 u)\n{u.xz=frot(rocketRotation,u.xz)\n;angularRepeat(pi*.5,u.zx)\n;u-=vec3(0,-1.+cos(u.y+.2)*.5,0)\n;u.yz=frot(pi*.25,u.yz)\n;return mBox(u,vec3(.17,.03,3.)*(1.-u.y*.5))*.5;}\nfloat dfRocket(vec3 p)\n{float q=mBox(p,vec3(2.5,.8,.8))\n;if (q>1.)return q\n;return min(dfRocketBody(p),dfRocketFins(p));}\n\n//bounding volumes for smoke and solids\nfloat sampleSmokeCap(vec3 u)\n{return sdCapsule(u,smokeStart,smokeEnd,smokeThickness);}\nfloat sampleRocketCCy(vec3 u)\n{return dfRocket(u-(smokeEnd+vec3(0,2.3,0)));}\n\n//i rarely see worse gBuffers\nbool isIntersectingSmokeShape(vec3 u, float e, out float d)\n{d=sampleSmokeCap(u);return d<e;}\n//return shortest distance to transparent surface (non reflecting smoke\n//return if smoke is visible (z+gBuffer)\nfloat gdt(vec3 u,vec3 t){vec3 p=u;float d=.0,e=.0005,m=minPrimStepSize;\n;for(int i=0;i< iterRm;++i\n){if(isIntersectingSmokeShape(p,e,m))return d\n ;else{e=.00005*d;d+=m;p=d*t+u;}}return -1.;}\n\n//return distance to solid\nfloat gds(vec3 u,vec3 t){vec3 p=u;float d=.0,e=.0005,m;\n;for(int i= 0 ;i<iterRm;++i\n){m=sampleRocketCCy(p);\n    if(m-e<0.)return d\n ;else{e=.0005*d;d+=m;p=d*t+u;}}return -1.;}\n\nfloat getIncidentSunlight(vec3 u,vec3 t){float a=1.,d=.0\n;for(int i=0;i<iterRmSmoke2;++i\n){if(!isIntersectingSmokeShape(u,.005,d))break\n ;a*=exp(-oExting*sampleSmoke(u)*RmSmokSampleSize2);u+=t\n;}return a;}\n\n//rayorigin,raydirection,sundirection\nvec4 calcSmoke(vec3 u,vec3 t,vec3 s)\n{t*=RmSmokSampleSize\n;float d,a=1.;vec3 c=vec3(0)\n;for(int i=0;i<iterRmSmoke;++i\n){if(a<.05||!isIntersectingSmokeShape(u,.005,d))break\n ;float g=sampleSmoke(u)\n ;a*=exp(-oExting*g*RmSmokSampleSize)\n ;c+=a*RmSmokSampleSize*g*oScat*(cAmb+cSun*getIncidentSunlight(u,s));\n ;u+=t;}return vec4(c,a);}\n\n//4x sampling is fine whete curvature=0.\nvec3 calcRocketNormal(vec3 p ){vec2 e=vec2(1,-1)*.5773*.0005\n;return normalize(e.xyy*sampleRocketCCy(p+e.xyy)\n+e.yyx*sampleRocketCCy(p+e.yyx)\n+e.yxy*sampleRocketCCy(p+e.yxy)\n+e.xxx*sampleRocketCCy(p+e.xxx));}\n\n//return color of rocket.\nvec4 calcRocket(in vec3 u,in vec3 t, in vec3 s)\n{vec3 n=calcRocketNormal(u)\n;t=reflect(t,n)\n;vec3 c=vec3(0)\n;float amb=sat(u5(n.y))\n;float dif=sat(dot(n,s))\n;float spe=pow(sat(dot(t,s)),16.)\n;if(dfRocketBody(u)>dfRocketFins(u)\n){if(u.y<smokeEnd.y-.85||u.y>smokeEnd.y+1.34)\n   if (u.y>smokeEnd.y+3.41)c=vec3(.1);\n   else c=vec3(.9);\n  else c=vec3(.1);}\n vec3 r=vec3(0)\n;r+=dif*4.3*vec3(1,.8,.55)\n;r+=spe*7.*vec3(1,.9,.7)*dif+amb\n;return vec4(c*r,.0);}\n\n//raydirection,sundirection\nvec3 calcSkyCol(vec3 t,vec3 s)\n{float d=ma0(dot(t,s)),v=pow(1.-ma0(t.y),5.)*.5\n;vec3 a=v*cSun*.4+cSky;\n;a+=cSun*pow(d, 6.5)*.32\n;a+=cSun*min(pow(d, 1600.),.3)*.65\n;return a;}\n\nvoid mainImage(out vec4 o,vec2 u)\n{u=(u.xy-iResolution.xy * .5)/iResolution.y\n;vec2 m=2.*((iMouse.xy/iResolution.xy)-.5)\n;if(iMouse.xy==vec2(0))m.y=.0\n;vec3 t=vec3(u,1)\n//low precision roatations in deg of camera and light direction\n;t.yz=rot2D(t.yz, 90.*m.y)\n;t.xz=rot2D(t.xz,130.*m.x+180.)\n;t=normalize(t)\n;vec3 p=vec3(0,7,3.*smokeOffset)\n;float lEle=10.*pi/180.\n;float lAzi=90.*pi/180.+tim*20.\n;vec3 s=vec3(cos(lAzi)*cos(lEle),sin(lEle),sin(lAzi)*cos(lEle))\n//2 distances, deferred shading:\n;vec2 d=vec2(gds(p,t),gdt(p,t))\n;if(all(lessThan(vec3(-1,-1,d.y),d.yxx))//if smoke is infront of solid\n){o=               calcSmoke(p+t*d.y,t,s)//dual mix\n ;o=vec4(mix(o.rgb,calcRocket(p+t*d.x,t,s).rgb,o.a),.0);//dual mix\n}else if(d.x>-1.)o=calcRocket(p+t*d.x,t,s)//solid only\n;else if(d.y>-1.)o=calcSmoke(p+t*d.y,t,s);//smoke only\nif (d.x==-1.)o.rgb=mix(o.rgb,calcSkyCol(t,s),o.a);//background\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBczw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1076, 1226, 1254, 1254, 1322], [1323, 1357, 1389, 1389, 1468], [1471, 1507, 1526, 1526, 1597], [1599, 1599, 1620, 1620, 1944], [1946, 1977, 2004, 2004, 2282], [2284, 2296, 2342, 2342, 2408], [2409, 2409, 2437, 2437, 2494], [2495, 2495, 2543, 2543, 2616], [2618, 2721, 2749, 2749, 3385], [3386, 3386, 3414, 3414, 3578], [3579, 3579, 3603, 3603, 3700], [3702, 3742, 3772, 3772, 3828], [3829, 3829, 3860, 3860, 3905], [3907, 3937, 3998, 3998, 4030], [4031, 4144, 4169, 4169, 4334], [4336, 4363, 4388, 4388, 4538], [4540, 4540, 4581, 4581, 4745], [4747, 4785, 4823, 4823, 5116], [5118, 5159, 5190, 5190, 5367], [5369, 5395, 5444, 5444, 5845], [5847, 5875, 5907, 5907, 6049], [6051, 6051, 6086, 6086, 6941]]}
{"id": "llByD1", "name": "noiseGra13dx crunch", "author": "ollj", "description": "crunchy fork of:\nhttps://www.shadertoy.com/view/4dffRH\n\nscaling a matrix with offsets is a bit tricky.", "tags": ["procedural", "3d", "noise", "perlin", "analytic"], "likes": 3, "viewed": 392, "published": "Public API", "date": "1508355679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Computes the analytic derivatives of a 3D Gradient Noise. This can be used for example to compute normals to a\n// 3d rocks based on Gradient Noise without approximating the gradient by having to take central differences. More\n// info here: http://iquilezles.org/www/articles/gradientnoise/gradientnoise.htm\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n\n // replace this by something better. really. do\nvec3 hash(vec3 p)\n{p=vec3(dot(p,vec3(127.1,311.7, 74.7))\n       ,dot(p,vec3(269.5,183.3,246.1))\n       ,dot(p,vec3(113.5,271.9,124.6)))\n;return fract(sin(p)*43758.5453123)*2.-1.;}\nmat3 hash(mat3 p)\n{return mat3(hash(p[0]),hash(p[1]),hash(p[2]));}\nvec3 dots(mat3 a,vec3 w,mat3 b){return vec3\n(dot(a[0],w-b[0]),dot(a[1],w-b[1]),dot(a[2],w-b[2]));}\n//return noiseGra13dx as .x, and its derivatives as .yzw\nvec4 noiseGra13dx(in vec3 x)\n{vec3 p=floor(x),w=fract(x)\n#if 1\n,u=w*w*w*(w*(w*6.-15.)+10.),v=30.*w*w*(w*(w-2.)+1.)//quintic hermite\n#else\n,u=w*w*(3.-2.*w),v=6.*w*(1.-w)//cubic hermite\n#endif    \n//gradients\n,G=hash(p+vec3(0)),F=hash(p+vec3(1))\n;mat3 D=hash(mat3(p,p,p)+mat3(1)),E=hash(mat3(p,p,p)+1.-mat3(1));\n//projections \n;vec3 d=dots(D,w,mat3(1)),e=dots(E,w,1.-mat3(1));\n//interpolations\n;float g=dot(G,w),f=dot(F,w-vec3(1));\n;vec3 h=u.yzx*(g-d.xyx-d.yzz+e.zxy)+d-g,U=u*h,a=d-e\n;mat3 S=D-mat3(G,G,G),W=D-E\n;a.x=(a.x+a.y+a.z)+f-g;\n;float b=u.x*u.y*u.z;\n;return vec4(g+U.x+U.y+U.z+a.x*b// value\n,G*(1.-b)+b*(W[0]+W[1]+W[2]+F)//https://www.shadertoy.com/view/llByD1\n+u.x*(S[0]+u.y*(G-D[0]-D[1]+E[2]))  // derivatives\n+u.y*(S[1]+u.z*(G-D[1]-D[2]+E[0]))\n+u.z*(S[2]+u.x*(G-D[0]-D[2]+E[1]))\n+v*(u.zxy*(g-d.xxy-d.zyz+e.yzx)+h+u.yzx*u.zxy*a.x));}\n\n\n\n\nvoid mainImage( out vec4 o, in vec2 fragCoord ){o=vec4(0);//for compatibility\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\n        vec4 n = noiseGra13dx( 12.0*pos );\n        col = 0.5 + 0.5*((p.x>0.0)?n.yzw:n.xxx);\n\t\t\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\t\n\to = vec4( col, 1.0 );\n}\n\n// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llByD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[972, 1020, 1039, 1039, 1199], [1200, 1200, 1219, 1219, 1266], [1267, 1267, 1299, 1299, 1365], [1366, 1423, 1453, 1453, 2264], [2269, 2269, 2317, 2317, 3678]]}
{"id": "llByzz", "name": "Hexagonal Truchet Weaving", "author": "BigWIngs", "description": "See code for details. Hope you like!", "tags": ["2d", "hexagon", "truchet", "pattern", "knot", "hexagonal", "weave", "celtic"], "likes": 90, "viewed": 2779, "published": "Public", "date": "1507160193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Hexagonal Truchet Weaving\" by Martijn Steinrucken aka BigWings/CountFrolic - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Here is my entry to the unoffical ShaderToy truchet competition ;)\n//\n// There are a few examples of hexagonal truchet on ShaderToy but they all seem to\n// incorporate only curves that jump from one edge of the hexagon to an adjacent edge.\n// This solution incorporates all possible curve jump combinations:\n// 111 (the usual one), 113, 122, 223 and 333\n// \n// A few other things of note:\n// * I render the 3 curves per tile separately and layer them randomly, to get the 'weaving' effect.\n// * In order to minimize small circle islands you can get sometimes I weighted the probabilities\n// of tiles so that the highest probability goes to the 223 tile and the lowest to the 111 tile.\n// * I randomly rotate tiles to get more variation.\n// \n// Things that didn't works so well:\n// I tried making proper uv coordinates for the curves, without mirroring down the middle of \n// the curve but so far haven't come up with anything useful because I keep getting curve ends \n// whose uvs don't match with their neighboring tile. This problem is compounded by the fact \n// that I'm rotating every tile randomly to get a more random look. I know that it is \n// impossible to always have perfect matching UVs but I thought I could come up with a decent\n// looking work around but so far no luck. I'm sure at some point someone will come up with \n// something.\n// I don't like all the if statements in my truchet function but this is the best I could come\n// up without without obfuscating the hell out of things. \n//\n// Credits:\n// Iomateron for his explanation of hexagonal tiling:\n// https://www.shadertoy.com/view/MlXyDl\n// Shane for making this uber cool looking truchet effect:\n// https://www.shadertoy.com/view/4td3zj\n// FabriceNeyret2 for cleaning up my mainImage function.\n\n// weights for the different types of tiles.\n// actual weight is weight-previous weight\n#define W111 .1\n#define W113 .2\n#define W122 .4\n#define W223 .8\n#define W333 1.\n\n#define GRID_SIZE 18.\n//#define REWIRE\n#define VARY_WIDTH\nfloat CURVE_WIDTH= .15;\n\n// some functions\n#define sat(x) clamp(x, 0., 1.)\n#define S(a, b, t) smoothstep(a, b, t)\n\n// some constants\n#define I3   0.333333333\t// 1/3\n#define I6   0.166666666\t// 1/6\n#define R3   1.732050807\t// square root of 3\n#define IR3  0.577350269 \t// the inverse of the square root of 3\n#define HIR3 0.288675134\t// half the inverse of the square root of 3\n#define S60  0.866025404\t// sine of 60 degrees\n#define C60  0.5\n\nfloat Remap01(float a, float b, float t) {\n    return (t-a)/(b-a);\n}\n\nfloat N21(vec2 id) { return fract(sin(id.x*324.23+id.y*5604.342)*87654.53); }\n\nvec4 UvCirc(vec2 uv, float radius, float thickness) {\n\tvec2 st = vec2(atan(uv.x, uv.y), length(uv));\n    \n    float t = thickness/2.;\n    float w = .01;\n    \n    float r1 = radius-t;\n    float r2 = radius+t;\n    \n    float mask = S(t+w, t, abs(radius-st.y));\n    float alpha = S(t+.1, t, abs(radius-st.y));\n    alpha = alpha*alpha*mix(.5, 1., mask);\n    \n    return vec4(st.x*radius, st.y, mask, alpha);\n}\n\nvec4 UvBeam(vec2 uv, float thickness) {\n\tfloat t = thickness/2.;\n    float w = .01;\n    float mask = S(t+w, t, abs(uv.y));\n    float alpha = S(t+.1, t, abs(uv.y));\n    alpha = alpha*alpha*(.5+.5*mask);\n    \n    return vec4(uv.x, uv.y, mask,alpha);\n}\n\nvec3 Truchet(vec2 uv, float n) {\n\tuv-= .5;\n    uv.x /= R3;\n    \n    vec4 v1 = vec4(0);\n    vec4 v2 = vec4(0);\n    vec4 v3 = vec4(0);\n    \n    float w = .15;\n    \n    // get random rotation for each tile\n    // since its only six could probably precompute / do some trickery\n    float r = floor(fract(n*5.)*6.)/6.;\n    r *= 6.28;\n    float s = sin(r);\n    float c = cos(r);\n    mat2 rot = mat2(c, -s, s, c);\n    uv *= rot;\n\t\t\n    if(n<W111) {\n        v1 = UvCirc(uv-vec2(0, I3), I6, CURVE_WIDTH);\t\t// jump 1\n    \tv2 = UvCirc(uv-vec2(HIR3, -I6), I6, CURVE_WIDTH);\t// jump 1\n    \tv3 = UvCirc(uv-vec2(-HIR3, -I6), I6, CURVE_WIDTH);\t// jump 1\n    }\n    else if(n<W113) {\n        v1 = UvCirc(uv-vec2(0, I3), I6, CURVE_WIDTH);\t\t// jump 1\n        v2 = UvCirc(uv-vec2(0, -I3), I6, CURVE_WIDTH);\t\t// jump 1\n        v3 = UvBeam(uv, CURVE_WIDTH);\t\t\t\t\t\t// jump 3\n    }\n    else if(n<W122) {\n        v1 = UvCirc(uv-vec2(-HIR3, -I6), I6, CURVE_WIDTH);\t// jump 1\n        v2 = UvCirc(uv-vec2(IR3, 0), .5, CURVE_WIDTH);\t\t// jump 2\n        v3 = UvCirc(uv-vec2(HIR3, .5), .5, CURVE_WIDTH);\t// jump 2\n    }\n    else if(n<W223) {\n        v1 = UvCirc(uv-vec2(IR3, 0), .5, CURVE_WIDTH);\t\t// jump 2\n        v2 = UvCirc(uv-vec2(-IR3, 0), .5, CURVE_WIDTH);   \t// jump 2  \n        v3 = UvBeam(uv, CURVE_WIDTH);\t\t\t\t\t\t// jump 3\n    } else {\n        mat2 rot60 = mat2(C60, -S60, S60, C60);\n    \tmat2 rot60i = mat2(C60, S60, -S60, C60);\n        \n        v1 = UvBeam(uv, CURVE_WIDTH);\t\t\t\t\t\t// jump 3\n \t\tv2 = UvBeam(uv*rot60, CURVE_WIDTH);\t\t\t\t\t// jump 3\n    \tv3 = UvBeam(uv*rot60i, CURVE_WIDTH); \t\t\t\t// jump 3\n    }\n    \n    float d1 = fract(n*10.);\t\t// expand my random number by taking digits\n    float d2 = fract(n*100.);\n    float d3 = fract(n*1000.);\n    float dMin = min(d1, min(d2, d3));\n    \n    // composite in different orders\n    vec4 v = d1<.166 ? mix(v1, mix(v2, v3, v3.a), max(v2.a, v3.a))\n           : d1<.333 ? mix(v1, mix(v3, v2, v2.a), max(v2.a, v3.a))\n           : d1<.5   ? mix(v2, mix(v1, v3, v3.a), max(v1.a, v3.a))\n           : d1<.666 ? mix(v2, mix(v3, v1, v1.a), max(v1.a, v3.a))\n           : d1<.833 ? mix(v3, mix(v1, v2, v2.a), max(v1.a, v2.a))\n           :           mix(v3, mix(v2, v1, v1.a), max(v1.a, v2.a));     \n\n    v.gr*=0.; // mask out some failed uv experiments\n   \n    return vec3(v.rgb);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = ( u / iResolution.x - .5 ) * GRID_SIZE;\n    float t = iTime * .02,\n          S = sin(t), C = cos(t);\n    u *= mat2(-C, S, S, C);\n    u.x += iTime*1.;\n\t\n    #ifdef VARY_WIDTH\n    CURVE_WIDTH = mix(.05, .25, (sin(u.x+sin(u.y))+sin(u.y*.35))*.25+.5);\n    #endif\n    \n    vec2 s = vec2(1.,R3),\n         a = mod(u     ,s)*2.-s,\n         b = mod(u+s*.5,s)*2.-s;\n\n    u /= s;\n    \n    float da = dot(a, a);\n\tfloat db = dot(b, b);\n    \n    vec2 id = da < db \n                  ? floor(u) \n                  : floor(u+=.5)-.5;\n    \n    \n    float n = N21(id);\n    #ifdef REWIRE\n    n = N21(id+vec2(floor(iTime*.1+n)));\n    #endif\n    O = Truchet(fract(u), n).rgbb;\n    \n    float outline = S(.7, 1.2, min(da, db));\n    O.b = max(O.b, outline*.5);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llByzz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2347, 2673, 2715, 2715, 2741], [2743, 2743, 2763, 2763, 2820], [2822, 2822, 2875, 2875, 3227], [3229, 3229, 3268, 3268, 3478], [3480, 3480, 3512, 3512, 5774], [5776, 5776, 5814, 5814, 6562]]}
{"id": "lljcR1", "name": "Volume marching", "author": "ollj", "description": "fork of https://www.shadertoy.com/view/lss3zr", "tags": ["volume", "raycasting", "lightscattering", "cloud"], "likes": 8, "viewed": 676, "published": "Public API", "date": "1507518802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//noise\nfloat h11(float n){return fract(sin(n)*43758.5453);}\nfloat noise(in vec3 x){vec3 p=floor(x),f=fract(x)\n;f=f*f*(3.-2.*f);float n=p.x+p.y*57.+113.*p.z\n;return mix(mix(mix(h11(n+  .0),h11(n+  1.),f.x),\n                mix(h11(n+ 57.),h11(n+ 58.),f.x),f.y),\n            mix(mix(h11(n+113.),h11(n+114.),f.x),\n                mix(h11(n+170.),h11(n+171.),f.x),f.y),f.z);}\nconst mat3 m=mat3(0,8,6,-8,3,-4,-6,-4, 6 )*.1;//fbm rotation matrix\nfloat fbm(vec3 p){float f=.5*noise(p)\n;p*=m*2.02;f+=.25*noise(p)\n;p*=m*2.03;f+=.125*noise(p)\n;return f;}\n\n\n//distanceFieldGadient that we volume march trough\nfloat gdVolume(vec3 p){return.1-length(p)*.05+fbm(p*.3);}\n\n//I could define everything as a very dense cloud\n//and volume march it, but that seems inefficient.\n//doing deferred shading of cloud and npn-cloud (special cases) \n//is not much simpler though, or is it\n//yes the second approah is simpler, more flexible and more hacky.\n\n//Volume marching iterations, outer and inner loop\n//outerLoop<=64 samples along viewRay\n//innerLoop<= 6 samples along LightDirection\n#define iterMarchVolume vec2(64,6)\n\n//(orange) color of least scattered light in (earths) athmosphere\n//depends on pollution\n#define clAmbi vec4(.9,.6,.1,1)\n//(bue sky color) color of most scattered light in (earths) athmosphere\n#define cDiff vec4(1.-clAmbi.xyz,1)\n//HDR usually over-ambolidies this to white.\n//ie, even the red ammount of scattered light is (nearly)maxed.\n#define clDiff vec4(pow(cDiff.xyz,vec3(cos(iTime*.5+.5))),1)\n\n//brightness scale of lit parts of cloud\n#define cloudBright 90.\n//brightness scale of occluded parts of cloud\n#define cloudDark 60.\n//aboove 2 values also scale the .rgb of orangeBlue scatter.\n\n//return color of volumeMarching (trough a cloud)\n//[u]RayOrigin\n//[t]RayDirection\n//[s]SunlightDirection (parallel, infinite distance)\nvec4 MarchVolume(vec3 u,vec3 t,vec3 s){\n;t=normalize(t);//save>sorry\n;vec4 c=vec4(0)//return vaslue\n;const vec2 stepn=vec2(40,20)/iterMarchVolume;//2 loop params\n;float a=1.,b=110.//diminishing accumulator//absorbtion\n;for(float i=.0;i<iterMarchVolume.x;i++)\n{;float d=gdVolume(u)\n ;if(d>0.)\n {;d=d/iterMarchVolume.x\n  ;a*=1.-d*b\n  ;if(a<=.01)break\n  ;float Tl=1.\n  ;for(float j=.0;j<iterMarchVolume.y; j++)\n  {;float l=gdVolume(u+normalize(s)*float(j)*stepn.y)\n   //todo, also calculate occlusion of a non-clud distance field.\n   ;if(l>0.)\n    Tl*=1.-l*b/iterMarchVolume.x\n   ;if(Tl<=.01)break;}\n  ;c+=clDiff*cloudDark*d*a//light.diffuse\n  ;c+=clAmbi*cloudBright*d*a*Tl;//light.ambbience\n ;}\n ;u+=t*stepn.x;}    \n;return max(c,(cDiff*cDiff));//;return c\n;}\n\nvoid mainImage( out vec4 o, in vec2 u){\n;u=u.xy/iResolution.xy\n;u=u*2.-1.\n;u.x *= iResolution.x/ iResolution.y;\n;vec2 mo\n;if(iMouse.z>0.)mo=iMouse.xy/iResolution.xy*2.-1.\n;else            mo=vec2(iTime*.1,cos(iTime*.25)*3.)\n;vec3 org=25.*normalize(vec3(cos(2.75-3.*mo.x),.7-(mo.y-1.0),sin(2.75-3.*mo.x)))\n;vec3 ta=vec3(0,1,0)\n;vec3 ww=normalize(ta-org)\n;vec3 uu=normalize(cross(ta,ww))\n;vec3 vv=normalize(cross(ww,uu))\n;vec3 di=normalize(u.x*uu+u.y*vv+1.5*ww)\n;vec3 s=vec3(1,0,0)//sinLightDirection\n;o=MarchVolume(org,di,s);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljcR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 9, 28, 28, 61], [62, 62, 85, 85, 373], [420, 442, 460, 460, 546], [549, 600, 623, 623, 657], [1697, 1833, 1872, 1872, 2590], [2592, 2592, 2631, 2631, 3119]]}
{"id": "lljcRw", "name": "Morphing Primitives", "author": "Fading_Pixel", "description": "A raymarcher that implements a function to morph the signed distance function between different primitives", "tags": ["3d", "raymarch", "primitives"], "likes": 1, "viewed": 141, "published": "Public", "date": "1508018612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float EPSILON = 0.001;\nint MAX_STEPS = 100;\nfloat MAX_DIST = 100.0;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat boxSDF(vec3 p, vec3 size, float r) {\n    vec3 d = abs(p) - (size / 2.0) + r;\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance - r;\n}\n\nfloat cylSDF(vec3 p, float h, float r) {\n    float a = abs(p.y) - (h/2.0);\n    float b = length(p.xz)-r;\n    if (b > 0.0 && a > 0.0) {\n    \treturn length(vec2(a,b));\n    }\n    \n    return max(a,b);\n}\n\nfloat coneSDF(vec3 p, float h, float r) {\n    float r2 = ((h/2.0)-p.y)/h;\n    r2 *= r;\n    r2 = clamp(r2,0.0,r);\n    return cylSDF(p,h,r2);\n}\n\nfloat sphereSDF(vec3 p, float size) {\n    return length(p) - size;\n}\n\nfloat morph(float SDF1, float SDF2, float m) {\n    return SDF1 + ((SDF2-SDF1)*m);\n}\n\nfloat sceneSDF(vec3 p) {\n    float sdf = MAX_DIST;\n    float a = max(sphereSDF(p-vec3(2.0,0.0,0.0),1.0),boxSDF((p-vec3(2.0,0.0,0.0)),vec3(1.4,1.4,1.4),0.0));\n    float b = coneSDF(p-vec3(2.0,0.0,0.0),1.4,0.6);;\n    float c = morph(b,a,(1.0+sin(iTime))*0.5);\n    sdf = min(sdf,c);\n    a = min(sdf,boxSDF(rotateZ(p.y*cos(iTime))*(p+vec3(2.0,0.0,0.0)),vec3(1.4,1.4,1.4),0.2));\n    b = min(sdf,boxSDF(rotateY(p.y+sin(iTime*2.0))*(p+vec3(2.0,0.0,0.0)),vec3(1.4,1.4,1.4),0.2));\n    c = morph(a,b,(1.0+sin(iTime))*0.5);\n    sdf = min(sdf,c);\n    a = boxSDF(p,vec3(1.4,1.4,1.4),0.0);\n    b = cylSDF(p,1.4,0.6);\n    c = morph(a,b,(1.0+sin(iTime))*0.5);\n    sdf = min(sdf,c);\n    return sdf;\n}\n\nfloat March(vec3 Dir, vec3 eye) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sceneSDF(eye + (Dir*depth));\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 interp(vec3 a,vec3 b,float t) {\n    return a + ((b-a)*t);\n}\n\nvec3 Light(vec3 p, vec3 eye, vec3 Amb, vec3 Diff, vec3 Spec) {\n    float IntensitySpec = 0.4;\n    float IntensityDiff = 0.4;\n    float shine = 10.0;\n    vec3 source = vec3(sin(2.0*iTime)*3.0,cos(2.0*iTime)*3.0,sin(iTime)*cos(iTime)*4.0);\n    //source = vec3(0.0,0.0,0.0);\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(source - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    Amb = interp(N,Amb,(1.0+cos(iTime))/2.0);\n    vec3 col = Amb * 0.5;\n    if (dot(L,N) < 0.0) {\n        return col;\n    }\n    if (dot(R,V) < 0.0) {\n        col += (Diff * IntensityDiff * dot(L,N));\n        return col;\n    }\n    col += (Diff * IntensityDiff * dot(L,N));\n    col += (Spec * pow(dot(R,V),shine));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = vec3(sin(iTime)*5.0,cos(iTime)*5.0,6.5);\n    vec3 center = vec3(0.0,0.0,0.0);\n    vec3 up = vec3(0.0,1.0,0.0);\n    mat3 Matrix = viewMatrix(eye,center,up);\n    vec3 dir = rayDirection(45.0,iResolution.xy,fragCoord);\n    float mDist = March(Matrix * dir,eye);\n    vec3 point = eye + (mDist * (Matrix * dir));\n    vec3 light = Light(point, eye, vec3(0.5,0.0,0.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0));\n    if (mDist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    fragColor = vec4(light, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljcRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 96, 96, 243], [245, 245, 272, 272, 419], [421, 421, 448, 448, 595], [597, 597, 639, 639, 846], [848, 848, 888, 888, 1047], [1049, 1049, 1090, 1090, 1190], [1192, 1192, 1229, 1229, 1260], [1262, 1262, 1308, 1308, 1345], [1347, 1347, 1371, 1371, 2030], [2032, 2032, 2065, 2065, 2370], [2372, 2372, 2437, 2437, 2569], [2571, 2571, 2600, 2600, 2910], [2912, 2912, 2961, 2996, 3127], [3129, 3129, 3165, 3165, 3193], [3195, 3195, 3257, 3257, 3938], [3940, 3940, 3997, 3997, 4549]]}
{"id": "lljcWR", "name": "Moving-Circle", "author": "nhoughto", "description": "test", "tags": ["movingcircle"], "likes": 1, "viewed": 62, "published": "Public", "date": "1508342634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 circle(vec2 uv, vec2 pos, float rad, vec3 color){\n    float d = length(pos - uv) - rad;\n    float t = clamp(d, 0.0, 1.0);\n    return vec4(color, 1.0-t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    float speed = 4.0;\n\tvec4 backGround = vec4(0.9, 0.8, 0.7, 1.0);\n    float radius = iResolution.y * 0.1;\n    float turnRadius = 100.0;\n    vec2 center = vec2(0.5 * iResolution.x + (turnRadius * cos(speed * iTime)), \n                       0.5 * iResolution.y +(turnRadius * sin(speed * iTime)));\n    \n    vec3 shapeColor = vec3(0.3, 0.73, 0.14);\n    vec4 shape = circle(uv, center, radius, shapeColor);\n    fragColor = mix(backGround, shape, shape.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljcWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 159], [161, 161, 218, 218, 700]]}
{"id": "lljczD", "name": "Round_trips", "author": "duvengar", "description": "Double truchet flow with inverted direction. derived from [url=https://www.shadertoy.com/view/llfyWX]Simple_animated_Truchet[/url] by @Shane\nMouse control the flow direction.", "tags": ["2d", "truchet", "flow", "polar"], "likes": 16, "viewed": 290, "published": "Public", "date": "1507786269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Round_trips by julien Vergnaud @duvengar-2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ====================================================================\n\n// Derived from Simple_animated_Truchet by @Shane\n// [url]https://www.shadertoy.com/view/llfyWX[/url]\n\n// Mouse control direction\n\n\n#define PI     3.14159265359\n#define TWO_PI (PI*2.)\n\n// vec2 to float hash function taken from @Shane - Based on IQ's original.\n\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.867)))*43758.5453); }\n\n// Standard 2D rotation formula.\n\nmat2 rot(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\n\n//distance field dot\n\n\n\nfloat df_circle(vec2 pos, float rad){\n\n float shp  = length(pos) -rad;\n  \n    return   shp;\n}\n\n\n\n\nvoid mainImage( out vec4 c, in vec2 uv )\n{\n    \n    // I   //  Screen coordinates is formated to go from -1. to 1.\n    \n\tvec2 p = -1.+ 2.* uv / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n    \n      \n   \n    // II  //  Moove & Rescale screen space\n    \n    p *= 1. + dot(p, p)*.05;        // fish eye\n    p += vec2(.0, iTime/12.);       // moove along Y axis\n    //p *= .7*floor(iResolution.x/200.); // rescale space\n    p*=3.;\n    \n \t// III //  Make truchet lines\n           //  store tile id & Divide screen into grid \n    \t   //  & store direction in a checkerboard way.\n\t\n    vec2 id = ceil(p);\n    \n    float dir = mod(id.x + id.y, 2.) * 2. -1.;  \n    \n    \n    p = fract(p) - .5;  // or // p -= id + .5; \n        \n           //  Truchet tiles orientation randomisation\n    float r =  hash21(id) > .5 ? 1. : -1.;\n    \n\tp.y *= r;\n    \n           //  Applying symetry on diagonal axis to avoid drawing two arcs\n           //  Tricks form @shane\n    \n    p *= sign(p.x + p.y);\n      \n           //  Drawing the two arc's strokes directly with a tickness of t\n           //  The tricks to draw a contour was taken from a @FabriceNeyret2 \n           //  comment in this shader https://www.shadertoy.com/view/MtXyWX\n    \n    p -= .5; \n\n    // IV  //  RENDER\n    \n           //  Animate flow\n     \n    vec2 pos  = p ;\n    vec2 pos2 = p ;\n    vec2 pos3 = p ;  \n \n    if(iMouse.z > 0.){\n    \tfloat m = smoothstep(.0,-1. + 2. * iResolution.x, -1. + 2. * iMouse.x);\n        m*= 20.;\n    \tpos  *= rot(m *  dir);\n        pos2 *= rot(m * -dir);\n        pos3 *= rot(-5.*dir * r);        // magic tricks here*\n    \n    }else{\n        pos  *= rot(iTime *  dir);\n        pos2 *= rot(iTime * -dir);\n        pos3 *= rot(-5.*r * dir);      // magic tricks here\n    \t\t\t\t\t\t       // * use the random state r to flip again the sections\n    \t\t\t\t\t\t       // and get the inner / outer truchet together.   \n    }\n           //  Part into cells  & convert into polar coordinates\n     \n    const float num = 8.;                              // partitions number\n    \n    float ang  = atan(pos.y, pos.x);                   // Pixel angle  \n    float ang2 = atan(pos2.y, pos2.x);                 // pixel angle with opposite rotation\n    float ang3 = atan(pos3.y, pos3.x);                 // offset angle WITHOUT animation\n                                                \n    float ctr  = ceil(ang / TWO_PI * num) -.5;         // the cell centers.\n    float ctr2 = ceil(ang2 / TWO_PI * num )-.5;\n    \n          pos  = rot(ctr  * TWO_PI / num) * pos;        // Converting to polar coordinates\n          pos2 = rot(ctr2 * TWO_PI / num) * pos2;       //\n          pos.x  -= .5;                                 // p.x = radius, p.y = angle.\n          pos2.x -= .5;                                 // Translate coordinates\n    \n      \n           //  render the objects\n \n    float t = .084;                                      // thickness\n    float rd = .1;                                     // offset value added on each side of \n                                                         // the original truchet line\n    \n    vec2 p1  = vec2(sin(ang3) *  rd,cos(ang3) * -rd);    // Two mirored points\n    vec2 p2  = p1*vec2(-1);                              // inner or outer around ang2 (main angle)\n   \n    float line1 = abs(length(p - p1) - .5) - t ;         // two lines\n          line1 = 1. - smoothstep(.01,.2, sqrt(line1));  // abs() draw the contour\n    \n    float line2 = abs(length(p - p2) - .5) - t ;    \n          line2 = 1. - smoothstep(.01,.2, sqrt(line2));\n    \n    float line3 = abs(length(p ) - .5) - .005 ;    \n          line3 = 1. - smoothstep(.01,.2, sqrt(line3));\n                   \t\t\t\t\t\t\t\t\t\t                 \n    float ball1 = smoothstep(.01, .02, df_circle(pos  + vec2(r * dir * .1, .0) , .025)); // two balls\n    float ball2 = smoothstep(.01, .02, df_circle(pos2 - vec2(r * dir * .1, .0) , .03));\n        \n    // V   //   Coloring\n\t\n    \n    c= vec4(.1);\n  \n    c  = vec4(line2 *cos(sin(r * ang))      + line1 * cos(sin(r * ang2)));        // first two opposite gradient\n    c *= vec4(line2 *cos(sin(r * ang * 2.)) + line1 * cos(sin(r * ang * 2.)));    // second two gradient  \n    c *= .3 + line1;\n    c -= .1 * sin(2. * cos(8. * uv.x + uv.y) - hash21(uv));                       // texture\n    c += 1.-ball1;                                                                // balls\n    c *= 1.*ball2+.2;\n    c += line3;\n    vec2 uu  = 1. - 2. * uv / iResolution.xy;                                     // vigneting\n    float v  = 1. - smoothstep(.7, 1.4, length(uu*uu));\n   \n    c *= vec4(v); \n    c+= vec4(.0,.0,.07,1.);\n    \n    //c = vec4(ball1);\n    \n    //c = vec4(line3);\n \n    \n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljczD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[394, 470, 491, 491, 555], [557, 591, 612, 612, 670], [675, 699, 736, 736, 792], [797, 797, 839, 911, 5497]]}
{"id": "lljczV", "name": "plotting: continuous interval", "author": "hornet", "description": "random test on forcing a continuous plot by checking neighbourhood-interval.\n\n( see also https://www.shadertoy.com/view/4sB3zz )", "tags": ["interval"], "likes": 9, "viewed": 464, "published": "Public", "date": "1509442708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f( float x, int idx )\n{\n    float t = x + sin(iTime);\n\n    if ( idx == 2 )\n    \treturn sin(t*t*t)*sin(t);\n    else if ( idx == 1 )\n    \treturn step( fract(t), 0.5 ) - 0.5;\n    else\n    {\n        //return fract(t);\n        //return 0.1 * tan( t );\n        return texture(iChannel0, vec2(0.2*t,0.5)).r - 0.5;\n    }\n}\n\nfloat eval_step( vec2 uv, int idx )\n{\n    //note: evaluate function at pixel-edges\n    //      +-------+\n\t//      |       |\n\t//      x0  x  x1\n\t//      |       |\n\t//      +-------+\n    float dx = 0.5 * dFdx( uv.x );\n    float x0 = uv.x - dx;\n    float x1 = uv.x + dx;\n    float y0 = f( x0, idx );\n    float y1 = f( x1, idx );\n\n    //note: determine if center is within the interval, y0 < uv.y < y1\n    float mn = min(y0,y1);\n    float mx = max(y0,y1);\n    float w = dFdy(uv.y);\n    float c = step( mn-w, uv.y ) * step( uv.y, mx+w );\n\n    return c;\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ab=b-a,ap=p-a;\n    return length(ap-ab*clamp(dot(ab,ap)/dot(ab,ab), 0.0, 1.0));\n}\nfloat eval_dist( vec2 uv, int idx )\n{\n    //note: evaluate function at pixel-edges\n    //      +-------+\n\t//      |       |\n\t//      x0  x  x1\n\t//      |       |\n\t//      +-------+\n    float dx = 0.5 * dFdx( uv.x );\n    float x0 = uv.x - dx;\n    float x1 = uv.x + dx;\n    float y0 = f( x0, idx );\n    float y1 = f( x1, idx );\n\n    //note: calculate distance to line-segment (x0,y0)<->(x1,y1)\n    //      +-------+\n\t//      |    /-x1\n    //      |  -x   |\n\t//     x0-/     |\n\t//      +-------+\n    float d = sd_segment( uv, vec2(x0,y0), vec2(x1,y1) );\n    return smoothstep( dFdy(uv.y), 0.0, d );\n}\n\n\nfloat eval( vec2 uv, int idx )\n{\n    //return eval_step( uv, idx );\n    return eval_dist( uv, idx );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y;\n    int idx = int(  floor( 3.0*uv.y ) );\n    uv = vec2(uv.x, fract( uv.y*3.0) );\n    uv = vec2(8.0,3.0) * (uv - vec2(0.0, 0.5));\n    uv += vec2( 0.2 * cos(iTime), 0.2 * sin(1.1*iTime) );\n\n    float c = eval( uv, idx );\n\n    vec3 col = vec3( 0.125 + 0.65 * c );\n        \n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljczV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 320], [322, 322, 359, 502, 871], [873, 873, 915, 915, 1006], [1007, 1007, 1044, 1187, 1604], [1607, 1607, 1639, 1674, 1709], [1711, 1711, 1768, 1768, 2115]]}
{"id": "lljczz", "name": "vortex field (flow/magnetic)", "author": "FabriceNeyret2", "description": "display vortex field.   velocity vectors are painted as ellipses (could be used to display tensors).\n\nMouse control. (bottom left for autodemo)\nTry changing JIT (jittering), N (neighborhood overflow), n (sampling), dt (V scaling). ", "tags": ["field", "ellipsoid", "vortex", "short", "vectorfield", "irrotational", "tensor", "flowfield", "curlfree"], "likes": 37, "viewed": 1336, "published": "Public API", "date": "1507279761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define vort(p) vec2( -(p).y, (p).x ) / dot(p,p)      // field around a vortex\n#define srnd(p) ( 2.* fract( 4e4* sin( 1e3* mat2(1,7.1,-5.1,2.3) * (p) )) -1. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n#define JIT true                                      // jittering on or off\n   float n = 20.,                                     // number of cells = 2n x 2n.Rx/Ry\n        dt = 1./60.;                                  // is indeed dt * vortex strenght\n    vec2 R = iResolution.xy,\n         u = (U+U-R)/R.y,                             // normalized coordinates\n         M = iMouse.xy,                               // mouse control or autodemo\n         m = length(M)>10. ? (M+M-R)/R.y : vec2(sin(iTime),.2*cos(iTime/3.71)),\n         p = floor(u*n+.5) / n;                       // cell center (NB: we should deffered /n )\n    O-=O;\n    \n int N = 3;                                           // odd. Neighborhood size = NxN   \n for( int i=0; i<N*N; i++)                            // allows overflow to neighbor cell\n {\n    vec2 P = p + vec2( i%N -N/2, i/N -N/2 ) / n;      // cell coordinate in neighborhood\n    if (JIT) P += .2* srnd( round(P*n) ) / n ;        // jittering (round: for precision issues)\n    vec2 X = u-P,                                     // local coordinate\n         V =  vort(P-m) - vort(P+m);                  // field at P caused by vortex pair at +- m\n    \n    float l = length(V),\n         r1 = dt * l, r2 = 2./R.y;                    // ellipse radii ~ ( |V|dt , 1 pixel )\n    V /= l;\n    mat2 Q = mat2( V / r1, vec2(-V.y,V.x) / r2 ) ;    // ellipse equation: lenght(Q.X) = const\n                                                      // main axis = V\n    O += smoothstep(2., 0., length(X*Q) ) ;           // display ellipse (use dot(l,l) for sharper)\n  //O += max(0., 1. - .5* length(X*Q) ) ;           \n }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljczz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 198, 198, 1836]]}
{"id": "lljyW1", "name": "STExos 2) Segment", "author": "ttoinou", "description": "Second Shadertoy exercise : compute the distance to a line/segment and barycentric coefficient", "tags": ["stexos"], "likes": 0, "viewed": 80, "published": "Public", "date": "1508445784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// First exercise here : https://www.shadertoy.com/view/Mt2cDh\n\nvoid mainImage(\n    out vec4 color,\n    in vec2 coord \n) {\n    float zoom = (cos(iTime*3.)+1.1)/(2.*iResolution.x); // line will be 2px thick minimum\n    \n    float distLinePixels;\n    \n    float baryCoeff; // all real values\n    //unitless (0 means \"stay at A\", 1 means \"go from A to B\")\n    \n    // v(ZW) means vector from Z to W, equals W-Z\n    // Â· is dot product\n    \n    // Exo 2 : a line is defined by going through two points A and B with A != B\n    \n    vec2 A = iResolution.xy/2.;\n    vec2 B = iMouse.xy;\n    \n    // H in (AB) <=> there exist one t such as v(AH) = t * v(AB)\n    // so t is AH/AB (algebraic ! i.e. keeping the sign)\n    \n    // t = 0 => M=A\n    // t = 1 => M=B\n    // t is called a barycentric coefficient\n    \n    // for every M in the plane, there exist only one point H such as\n    // v(AM) = v(AH) + v(HM) && v(HM)Â·v(AB)=0 ( perpendicular )\n    \n    vec2 AB = B - A;\n    vec2 AM = coord - A;\n    \n    // v(AM)Â·v(AB) = v(AH)Â·v(AB) + v(HM)Â·v(AB) = v(AH)Â·v(AB) by construction\n    baryCoeff = dot(AM,AB)/dot(AB,AB);\n    \n    // segment when mouse pressed\n    // line otherwise\n    if(iMouse.z > .5)\n        baryCoeff = clamp(baryCoeff,0.,1.);\n    \n    vec2 HM = AM - baryCoeff*AB;\n    distLinePixels = length(HM);\n    \n    \n\tcolor.rgb = mix(\n          // red / blue mix, be sure to not go out of [0,1]\n          mix( vec3(1.,.0,.0) , vec3(.0,.0,1.) , clamp(baryCoeff,0.,1.) )\n          // white\n        , vec3(1.)\n        , clamp(1. - abs( pow(distLinePixels/iResolution.x,1.5) /zoom),0.,1.)\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljyW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 64, 122, 122, 1597]]}
{"id": "lljyWm", "name": "Hot Julia Revolute", "author": "aiekick", "description": "Hot Julia Revolute", "tags": ["julia", "sss", "hot", "revolute"], "likes": 34, "viewed": 778, "published": "Public API", "date": "1508938051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n// link : https://www.shadertoy.com/view/lljyWm\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.1415926535 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat fractus(vec2 p, vec2 v)\n{\n\tvec2 z = p;\n    vec2 c = v;\n\tfloat k = 1., h = 1.0;    \n    float t = (sin(iTime * .5)*.5+.5) * 5.;\n    for (float i=0.;i<5.;i++)\n    {\n        if (i > t) break;\n        h *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n    float d = sqrt(k/h)*log(k);\n    \n    // next iteration\n    if (k > 4.)\n    \tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    h *= 4.*k;\n    k = dot(z,z);\n    float d1 = sqrt(k/h)*log(k);\n    \n    // df blending\n\treturn mix(d, d1, fract(t));\n}\n\nvec2 dfFractus(vec3 p)\n{\n\tfloat a = fullAtan(p.xz); // axis y\n    \n    vec2 c;\n    c.x = mix(0.2, -0.5, sin(a * 2.));\n    c.y = mix(0.5, 0.0, sin(a * 3.));\n    \n    float path = length(p.xz) - 3.;\n    \n    vec2 rev = vec2(path, p.y);\n    float aa = a + iTime;\n    rev *= mat2(cos(aa),-sin(aa),sin(aa),cos(aa)); // rot near axis y\n\t\n\treturn vec2(fractus(rev, c) - 0.1, 2);\n}\n\nvec2 df(vec3 p)\n{\n\treturn dfFractus(p);\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint).x*1.5;\n\t}\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    p = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.01, 0.03);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(80.*sb+320.);\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\t//n = doBumpMap(iChannel0, p, n, 0.019);\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.23; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p,8.); \t\t\t\t\t\t\t// one step sub density of df\n\treturn vec4(\n        (diff + fre + bb.x * sss * 0.5) * amb * li + spe * 1.2, \n        (diff + fre + bb * sb * 0.8 + sss * 0.5) * amb * li + spe * 1.2 \t\n    );\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    float t = iTime;\n    \n    float ca = 0.;\n    float cd = 2.4;\n    float ce = 2.;\n    \n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord-si)/si.y;\n\n\tvec3 ro = vec3(cos(ca),ce,sin(ca)) * cd;\n  \tvec3 cv = vec3(0,-3,0);\n\tvec3 rd = cam(uv, ro, cv, t);\n       \n\tfloat md = 15., s = 1., d = 1.;\n\t\n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        if (s<0.2*log(d*d/s/500.)||d>md) break;\n        s = df(ro+rd*d).x;\n\t\td += s *0.2;\n    }\n\t\n    if (d<md)\n\t\tfragColor.rgb = mix(\n            shade(ro, rd, d, ro, 1.2).yzw, \n            vec3(0), \n            1.-exp(-0.02*d*d));\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljyWm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 262, 286, 286, 369], [371, 371, 402, 402, 942], [944, 944, 968, 968, 1317], [1319, 1319, 1336, 1336, 1360], [1362, 1362, 1399, 1399, 1611], [1613, 1834, 1862, 1862, 2187], [2189, 2271, 2328, 2328, 2556], [2558, 2558, 2594, 2594, 2729], [2731, 2907, 2958, 2958, 3132], [3134, 3343, 3406, 3406, 3768], [3770, 3770, 3828, 3828, 4721], [4723, 4723, 4769, 4769, 4938], [4940, 4940, 4997, 4997, 5632]]}
{"id": "lljyz1", "name": "Attracted Points", "author": "Chris_M_Thomasson", "description": "A rotating attracting agent in a static vector field. Trying to improve my crude coloring by creating more angles to interpolate from...\n\n", "tags": ["fractal", "pulse", "grid", "math", "field", "vector", "dynamic", "art", "attraction"], "likes": 2, "viewed": 179, "published": "Public", "date": "1507523790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nPre-Alpha Vector Field by Chris M. Thomasson ver:0.0.2\nThe code is basic, and the math can be streamlined.\nThis is a basic experiment, not thinking of sheer performance yet.\n___________________________________*/\n\n// Circle Attraction\n\n\n// The number of points in the spiral\n#define CT_N 5\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// A vector field point\nstruct ct_vfpoint\n{\n    vec2 p;\n    float m;\n};\n\n\n// Our global per-pixel points\nct_vfpoint g_vfp[CT_N * CT_N + 1];\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec2 ct_vfield_normal(\n    in vec2 p,\n    float npow\n){\n    vec2 g = vec2(0.0, 0.0);\n    \n    const int imax = CT_N * CT_N + 1;\n    \n    for (int i = 0; i < imax; ++i)\n    {\n        vec2 dif = g_vfp[i].p - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1];\n        float mass = pow(sum, npow);\n        \n      \tg[0] = g[0] + g_vfp[i].m * dif[0] / mass;\n      \tg[1] = g[1] + g_vfp[i].m * dif[1] / mass;\n    }\n    \n    return normalize(g);\n}\n\nfloat ct_normal_pi(\n    in vec2 z\n){\n    float a = atan(z[1], z[0]);\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\nfloat ct_normal_mod_pi(\n    in vec2 z\n){\n    float a = atan(z[1], z[0]);\n    if (a < 0.0) a += 6.28318;\n    return mod(a, 1.0);\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    vec2 vn = ct_vfield_normal(z, npow);\n\tfloat vnpin = ct_normal_pi(vn);\n    float blah = length(vn);\n    \n    if (blah < .001)\n    {\n       return vec4(.9, .2, .1, 1.0);\n    }\n\n    // trying to get more angles...\n    return vec4(\n        mod(vnpin * 7.0 + vn.x, 1.0),\n        mod(vnpin * 11.0 + vn.y, 1.0), \n        mod(vnpin * 5.0 + (vn.x * vn.y), 1.0),\n        1.0\n    );\n}\n\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){\n    const int n = CT_N;\n    \n    for (int x = 0; x < n; ++x)\n    {\n    \tfloat xr = float(x) / float(n - 1);\n        \n        for (int y = 0; y < n; ++y)\n    \t{\n            float yr = float(y) / float(n - 1);\n        \n        \tg_vfp[x + y*n] = ct_vfpoint(\n                vec2((-1.0 + xr * 2.0),\n                     -1.0 + yr * 2.0), \n                1.0\n            );\n        }\n    }\n    \n    g_vfp[n * n] = ct_vfpoint(\n    \tvec2(\n            cos(iTime * .5) * .85, \n            sin(iTime * .5) * .85),\n        \t-10000000.0\n   \t\t);\n    \n    return ct_vpixel(c, c, 128, 4.5 + abs(sin(iTime * 2.5)) * 3.0);\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(0.0, 0.0, 1.68 - abs(cos(iTime * .5)) * .25);\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljyz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 404, 456, 456, 616], [619, 723, 775, 775, 1464], [1467, 1467, 1529, 1529, 1637], [1782, 1845, 1900, 1900, 2290], [2292, 2292, 2328, 2328, 2425], [2427, 2427, 2467, 2467, 2556], [2559, 2585, 2665, 2665, 3043], [3046, 3066, 3121, 3121, 3730], [3733, 3747, 3808, 3808, 4113]]}
{"id": "lllcWl", "name": "Rhombus Psyco", "author": "themasmo", "description": "A simple effect with sin,cos function.", "tags": ["rhombus", "rotatebeam"], "likes": 0, "viewed": 87, "published": "Public", "date": "1507027813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 p, float ang){\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.y * c - p.x * s, p.y * s + p.x * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p =1.0*(fragCoord.xy / iResolution.xy)-0.5;\n\t\n   \n\tp*=(20.0+80.0*(iMouse.x/iResolution.x));\n\tp*=sin(p.x)+cos(p.y);\n\tvec2 pp=vec2(p.x,p.y);\n\tpp=rotate(pp,iTime*2.0);\n\tvec3 cc=vec3(pp.x,pp.y,(pp.x+pp.y)/2.0);\n\t\n    \n    fragColor = vec4(cc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 126], [128, 128, 185, 185, 437]]}
{"id": "llScDz", "name": "preAlpha Vector Field v:0.0.3", "author": "Chris_M_Thomasson", "description": "Fwiw, another experimental vector field with the ability to click and drag an attracting point around the dynamically generated field. This is the first time I used the iMouse uniform in ShaderToy. I can see many possibilities. Still new at this.", "tags": ["2d", "fractal", "math", "space", "field", "dynamics", "vector", "art", "trigonometry"], "likes": 2, "viewed": 309, "published": "Public", "date": "1508208494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nPre-Alpha Vector Field by Chris M. Thomasson ver:0.0.3\nThe code is basic, and the math can be streamlined.\nThis is a basic experiment, not thinking of sheer performance yet.\n\nCreate an attractor by clicking and dragging it around.\n___________________________________*/\n\n\n// The number of points in the spiral\n#define CT_N 5\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// A vector field point\nstruct ct_vfpoint\n{\n    vec2 p;\n    float m;\n};\n\n\n// Our global per-pixel points\nct_vfpoint g_vfp[CT_N + 1];\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec2 ct_vfield_normal(\n    in vec2 p,\n    float npow\n){\n    vec2 g = vec2(0.0, 0.0);\n    \n    const int imax = CT_N + 1;\n    \n    for (int i = 0; i < imax; ++i)\n    {\n        vec2 dif = g_vfp[i].p - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1];\n        float mass = pow(sum, npow);\n        \n      \tg[0] = g[0] + g_vfp[i].m * dif[0] / mass;\n      \tg[1] = g[1] + g_vfp[i].m * dif[1] / mass;\n    }\n    \n    return normalize(g);\n}\n\n\nfloat ct_normal_pi(\n    in vec2 z,\n    in float sa\n){\n    float a = atan(z[1], z[0]) + sa;\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    vec2 vn = ct_vfield_normal(z, npow);\n    \n    float a = cos(iTime * .25) * 3.14;\n\n    vec2 rc = vec2(\n        vn[0] * cos(a) - vn[1] * sin(a),\n        vn[0] * sin(a) + vn[1] * cos(a)\n    );\n    \n    float npi = ct_normal_pi(vn, a);\n    \n    float blah = length(vn);\n    \n    if (blah < .01)\n    {\n        //return vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    \n    float scale = float(CT_N);// + abs(cos(iTime * .5)) * 6.0;\n    \n    return vec4(\n        mod(npi * scale, 1.0), \n        mod(npi * scale, 1.0), \n        mod(npi * scale, 1.0),\n        1.0\n    );\n}\n\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){\n    const int n = CT_N;\n    float scale = 1.0;\n    \n    for (int x = 0; x < n; ++x)\n    {\n        int y = 0;\n        float xr = float(x) / float(n);\n        float angle = xr * 6.28;// + cos(iTime * .02) * 5.0;\n        \n        g_vfp[x] = ct_vfpoint(\n            vec2(cos(angle), sin(angle)), \n            1.0\n        );\n    }\n    \n    if (iMouse.z > 0.0)\n    {\n        vec2 cm = ct_plane2d_project(plane, vec2(iMouse));\n        g_vfp[n] = ct_vfpoint(\n            cm, \n            -1.6\n        );\n    }\n    \n    return ct_vpixel(c, c, 128, 2.0 + abs(cos(iTime * 3.0)));\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        0.0, \n        0.0, \n        2.0 + cos(iTime * 1.0) * abs(sin(iTime * .5))\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llScDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[328, 439, 491, 491, 651], [654, 758, 810, 810, 1499], [1502, 1502, 1564, 1564, 1672], [1810, 1873, 1928, 1928, 2311], [2314, 2314, 2367, 2367, 2469], [2472, 2498, 2578, 2578, 3134], [3137, 3157, 3212, 3212, 3783], [3786, 3800, 3861, 3861, 4210]]}
{"id": "llScR1", "name": "Quadtripophobic Tentacle", "author": "visy", "description": "As seen in our 4k intro \"Quadtripophobia\" by Quadtrip", "tags": ["raymarching", "orennayardiffuse"], "likes": 55, "viewed": 2937, "published": "Public API", "date": "1507390101", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float NEAR_CLIPPING_PLANE=.005;\nfloat FAR_CLIPPING_PLANE=1000.;\nint NUMBER_OF_MARCH_STEPS=500;\nfloat EPSILON=.1;\nfloat DISTANCE_BIAS=.2;\nfloat t = 0.;\n\nfloat fly = 1.;\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - (s);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid r(inout vec3 pos) {\n    if (pos.z < FAR_CLIPPING_PLANE) {\n        pR(pos.yx,cos(pos.z*.1+pos.z*.1)+t);\n        pR(pos.xy,0.2*sin(pos.z*.2*t*.1));\n    }\n    else pR(pos.yx,cos(pos.z*.1)+t);\n    \n}\n\nvoid r2(inout vec3 pos) {\n   if (pos.z < 2800.+cos(pos.z*2.1+t*5.)*10.) pR(pos.yx,cos(pos.z*cos(t*.002+sin(pos.z*.001+abs(pos.y*.0001)))*.5)+t*.05);\n}\n\nvoid r3(inout vec3 pos) {\n   pR(pos.xy,sin(pos.z*cos(t*.002+sin(pos.z*.001+(pos.z*.01)))*.5)+t*.5);\n}\n\nfloat celli(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\n\nfloat cellTile(in vec3 p){\n    vec4 d; \n    d.x = celli(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = celli(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = celli(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = celli(p - vec3(.2, .82, .64));\n    d.xy = min(d.xz, d.yw);\n    return min(d.x, d.y)*2.66; \n}\n\nfloat hex(vec2 p) {\n    p.x *= 0.57735*2.;\n\tp.y += mod(floor(p.x), 2.)*.5;\n\tp = abs((mod(p, 1.) - .5));\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.) - 1.);\n}\n\nfloat cellTile2(in vec3 p){\n    vec4 d; \n    d.x = celli(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)+hex(p.xy*0.2);\n    d.y = celli(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)+hex(p.yz*0.2);\n    d.z = celli(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)+hex(p.xz*0.2);\n    d.w = celli(p - vec3(.2, .82, .64));\n    d.xy = min(d.xz, d.yw);\n    return min(d.x, d.y)*.5; \n}\nfloat bump(vec3 pos) {\n    float re = 0.;\n\tre += cellTile2(pos*.25) * cellTile2(pos*1.1) * 3. + cellTile2(pos*1.2) * cellTile2(pos*4.4) * .5;\n    return re;\n}\nvec3 hit;\n\nfloat sp(vec3 opos, vec3 pos) {\n\treturn sdSphere(cos(opos*.2),1.1+cos(pos.z*.01+cos(pos.x*1.1)*.1)*.2)*3.91;\n}\n\nvoid rota(inout vec3 pos) {\n    if (fly == 1.) r(pos);\n    if (fly == 0.) r2(pos);\n    if (fly == 2.) r3(pos);\n}\n\nfloat scene1(vec3 pos)\n{\n\trota(pos);\n    float of = .3*sin(pos.z*5.5);\n\treturn sp(pos - vec3(of, -of, cos(pos.z)*.5),pos);\n}\n\nfloat scene2(vec3 pos)\n{\n    vec3 translate = vec3(-0.5*cos(pos.z*.01), -.2*sin(.005*pos.z*cos(pos.z*4.5+pos.z*.5+pos.z*5.)*.1), 0.);\n\trota(pos);\n    hit = pos;\n\treturn sp(pos - translate,pos);\n}\n\nfloat scene(vec3 pos) {\n\treturn min(scene1(pos),scene2(pos));\n}\n\nfloat sceneb(vec3 pos) {\n\treturn min(scene1(pos),scene2(pos))-bump(hit+cos(pos.z*.3)*3.)*1.5;\n}\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    float acc = 0.;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec3 pos = position + direction * total_distance;\n        float result = scene(pos);\n        acc+=cos(result*1.)*.05;\n\n        if(result < EPSILON)\n        {\n            return vec2(total_distance, acc);\n        }\n        \n        total_distance += result * DISTANCE_BIAS;\n        \n        \n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    return vec2(FAR_CLIPPING_PLANE, acc);\n}\n\nvec3 nr(vec3 n) {\n\treturn normalize(n);\n}\n\nvec3 normal( in vec3 pos )\n{\n    vec3 eps = vec3(.3,0.,0.)*EPSILON;\n\tvec3 nor = vec3(\n\t    sceneb(pos+eps.xyy) - sceneb(pos-eps.xyy),\n\t    sceneb(pos+eps.yxy) - sceneb(pos-eps.yxy),\n\t    sceneb(pos+eps.yyx) - sceneb(pos-eps.yyx) );\n\treturn nr(nor);\n}\n\n\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1., max(NdotL, NdotV), step(0., s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));\n  float B = .45 * sigma2 / (sigma2 + .09);\n\n  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;\n}\n\nfloat fader = 1.0;\nfloat fader2 = 1.0;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    // pixel coordinates\n    vec2 uv = (-res + 2.*(fragCoord.xy))/res.y;\n    \n    vec3 direction = nr(vec3(uv, 0.));\n\n    t = iTime+32.;\n    \n    if (fly >= 1.) t-=31.;\n\n    float cz = t*5.9;\n    \n\n    float FOV = t*.1;\n        \n\t    vec3 camera_origin = vec3(0., 1., cz);\n\tvec3 lookAt = vec3(0.,1.,cz+1.);\n    \n    vec3 forward = nr(lookAt-camera_origin);\n    vec3 right = nr(vec3(forward.z, 0., -forward.x ));\n    vec3 up = nr(cross(forward,right));\n\n    \n    vec3 ro = camera_origin;\n    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    vec2 result = raymarch(ro, rd);\n            \n    float fog = pow(1. / (1. + result.x), .2);\n    \n    vec3 icecol = vec3(.6,.6,1.0);\n\tvec3 materialColor = vec3(1.3-result.x*.01*.5,.9-cos(result.x*.1)*.5,1.*.5);\n\n\tmaterialColor -= vec3(.4,4.7,8.0)*(bump(hit)+bump(hit*.2*vec3(1.,1.,4.))*1.5);\n    vec3 intersection = ro + rd*result.x;\n    \n    vec3 nrml = normal(intersection);\n    vec3 light_dir = nr(vec3(sin(result.x*.1),.3,-1.+fly));\n    vec3 ref = reflect( rd, nrml );\n\t\n    if (t > 85.) { materialColor=mix(materialColor,icecol,clamp((t-85.)*0.2,0.,1.8)); }\n\n    float dom = smoothstep( -.1, .9, ref.y);\n    float spe = pow(clamp( dot( ref, light_dir ), 0., 1. ),32.);\n\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,.3*fly,.7*fly)-result.y*.05;\n    \n    vec3 light_color = vec3(1.);\n    vec3 ambient_color = light_color;\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n    vec3 outColor = diffuseLit*fog+dom*.2+spe*.6;\n\tfragColor = vec4(mix(vec3(diffuse),outColor,fader), 1.)*fader2;\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llScR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 201, 201, 228], [230, 230, 262, 262, 304], [306, 306, 330, 330, 506], [508, 508, 533, 533, 658], [660, 660, 685, 685, 761], [763, 763, 786, 786, 823], [825, 825, 851, 851, 1221], [1223, 1223, 1242, 1242, 1374], [1376, 1376, 1403, 1403, 1795], [1796, 1796, 1818, 1818, 1954], [1966, 1966, 1997, 1997, 2076], [2078, 2078, 2105, 2105, 2190], [2192, 2192, 2216, 2216, 2316], [2318, 2318, 2342, 2342, 2513], [2515, 2515, 2538, 2538, 2578], [2580, 2580, 2604, 2604, 2675], [2677, 2677, 2723, 2723, 3266], [3268, 3268, 3285, 3285, 3309], [3311, 3311, 3339, 3339, 3561], [3565, 3565, 3692, 3692, 4163], [4204, 4204, 4259, 4259, 5871]]}
{"id": "llScRz", "name": "Cross Hatching", "author": "jgkling", "description": "Nonphotorealistic rendering.\n\nClick and drag the mouse!", "tags": ["raymarching"], "likes": 19, "viewed": 833, "published": "Public", "date": "1507178518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspired by: https://www.shadertoy.com/view/MsSGD1\n\n// Raymarching params\n#define T_MAX 50.0\n\n// Colors\n#define GRAPHITE_COLOR vec3(0.3)\n#define RED_LINE_COLOR vec3(1.0, 0.41, 0.73)\n#define BLUE_LINE_COLOR vec3(0.58, 0.83, 0.95)\n#define PAPER_COLOR vec3(1.0, 1.0, 0.73)\n\n#define SHADOWS\n#define LIGHT_VEC normalize(vec3(0.0, 0.8, -1.0))\n\n// 3D Noise by IQ\nfloat Noise3D( in vec3 pos )\n{\n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv + 0.5) / 256.0, 0.0).yx;\n    return -1.0 + 2.0 * mix( rg.x, rg.y, f.z );\n}\n\nfloat ComputeFBM( in vec3 pos )\n{\n    float amplitude = 0.25;\n    float sum = 0.0;\n    sum += Noise3D(pos) * amplitude;\n    return clamp(sum, 0.0, 1.0);\n}\n\n// Credit to IQ: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat SDF_Sphere( in vec3 pos, in float radius )\n{\n    return length(pos) - radius;\n}\n\nfloat SDF_Box( in vec3 pos, in vec3 b )\n{\n     return length(max(abs(pos) - b, 0.0));\n}\n\nfloat SDF_Torus( in vec3 pos, in vec2 t)\n{\n    vec2 qos = vec2(length(pos.xz) - t.x, pos.y);\n    return length(qos) - t.y;\n}\n\nfloat SDF_Ellipsoid( in vec3 pos, in vec3 r )\n{\n    return (length( pos / r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat SDF_CappedCylinder( in vec3 pos, in vec2 h )\n{\n  vec2 d = abs(vec2(length(pos.xz), pos.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Cheap, pseudorandom number generator taken from: https://www.shadertoy.com/view/MscSzf\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat SceneMap( in vec3 pos )\n{\n    float sdf = SDF_Sphere(pos - vec3(-0.2, 0.26, 0.0), 0.25);\n    sdf = min(sdf, SDF_Sphere(pos - vec3(-0.8, 0.3, 0.0), 0.125));\n    sdf = min(sdf, SDF_Torus(pos - vec3(0.5, 0.085, 0.0), vec2(0.5, 0.15) * 0.5));\n    sdf = min(sdf, SDF_Box(pos - vec3(0.0, 0.0, 0.0), vec3(4.0, 0.02, 4.0) * 0.5));\n        \n    return sdf;\n}\n\nvec3 ComputeNormal( in vec3 pos )\n{\n    vec2 epsilon = vec2(0.0, 0.001);\n    return normalize( vec3( SceneMap(pos + epsilon.yxx) - SceneMap(pos - epsilon.yxx),\n                            SceneMap(pos + epsilon.xyx) - SceneMap(pos - epsilon.xyx),\n                            SceneMap(pos + epsilon.xxy) - SceneMap(pos - epsilon.xxy)));\n}\n\nvec3 RaymarchScene( in vec3 origin, in vec3 dir )\n{\n    float distance, lastDistance = 10000000.0;\n    const float EDGE_THRESHOLD = 0.015;\n    float dt = 0.01;\n    float t = 0.01;\n    float hitSomething, isOnEdge = 0.0;\n    \n    for(int i = 0; i < 200; i++)\n    {\n        distance = SceneMap(origin + t * dir);\n        \n        // If we get very close to an object and we also moved away since the last iteration\n        if (distance < EDGE_THRESHOLD && distance > lastDistance + 0.00001)\n        {\n            hitSomething = 1.0;\n            isOnEdge = 1.0;\n            break;\n        }\n        \n        if(distance < 0.001)\n        {\n            hitSomething = 1.0;\n            break;\n        }\n        else if (t > T_MAX)\n        {\n            break;\n        }\n        \n        t += distance;\n        lastDistance = distance;\n    }\n    return vec3(t, hitSomething, isOnEdge);\n}\n\nvec3 GetBackgroundColor( in vec2 coord )\n{\n    // Blue notebook paper lines\n    vec3 col = PAPER_COLOR;\n    \n    /*\n    bool isOnRedLine = false;\n    if (coord.x <= 86.5 && coord.x >= 85.0) // red notebook paper line\n    {\n        col *= RED_LINE_COLOR;\n        isOnRedLine = true;\n    }*/\n    \n    if (mod(coord.y, 20.0) <= 1.0 && mod(coord.y, 20.0) >= -1.0)\n    {\n        col *= BLUE_LINE_COLOR;\n        /*if (isOnRedLine) // mix the red and blue ink if the lines intersect\n        {\n            col *= RED_LINE_COLOR;\n        }*/\n        \n    }\n    \n    \n    // Accounting for the mottling in paper\n    float mottling = ComputeFBM(vec3(coord, 0.0) * 3.0) * 0.4;\n    \n    return mix(col, vec3(0.0, 0.0, 0.0), pow(mottling, 0.8));\n}\n\nvec3 GetHatchingColor( in vec2 coord, in float lightIntensity, in vec3 camRight, in vec3 camUp, in bool isGradientEnabled, in float doOffsetHatching )\n{    \n    vec3 hatchingColor = GetBackgroundColor(coord);\n    \n    // Make the hatching look more consistent at full resolution\n    coord = coord / iResolution.xy * 1024.0;\n    \n    // Just catch a flag saying we want to jitter the hatching-\n    // For example, make the outline or shadow hatching look\n    // noncontinuous with any nearby dark hatching\n    coord += vec2(75.0, 15.0) * doOffsetHatching;\n    \n    float lineWidth, lineFreq, hatching;\n    \n    float thresh1 = 0.5;\n    float thresh0 = thresh1 + 0.075;\n    float thresh2 = thresh1 - 0.1;\n    float thresh3 = 0.2;\n    float thresh4 = thresh3 - 0.1;\n    \n    // This code could probably be a lot less verbose but oh well\n    \n    // Threshold 1\n    lineWidth = 0.015 * (0.5 * sin((coord.x - 0.25 * coord.y) * 0.04167 + 0.15 * (coord.x + coord.y)) + 0.5) + 1.0;\n    lineFreq = 10.0;\n    hatching = mod(coord.x + coord.y * 0.15 * (sin(abs(coord.y + coord.x) * 0.00390625 * 0.75)), lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh1)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh0)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh0 - lightIntensity) / (thresh0 - thresh1);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }\n    }\n    \n    \n    // Threshold 2\n    lineWidth = 1.0 * (0.5 * sin((coord.x + 0.75 * coord.y) * 0.0625 + 0.15 * (coord.x - 0.5 * coord.y)) + 0.5) + 1.0;\n    lineFreq = 14.0;\n    hatching = mod(coord.x + coord.y, lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh2)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t   hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh1)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh1 - lightIntensity) / (thresh1 - thresh2);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }\n    }\n    \n    // Threshold 3\n    lineWidth = 1.0 * (0.5 * sin((coord.x + 1.0 * coord.y) * 0.03125 + 0.15 * (coord.x - 1.5 * coord.y)) + 0.5) + 1.5;\n    lineFreq = 8.0;\n    hatching = mod(coord.x - 0.75 * coord.y, lineFreq) + 2.0 * (rand(coord.x + 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh3)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh2)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh2 - lightIntensity) / (thresh2 - thresh3);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }        \n    }\n    \n    \n    // Threshold 4\n    lineWidth = 1.25;\n    lineFreq = 7.0;\n    hatching = mod(coord.x + 0.15 * coord.y, lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh4)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh3)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh3 - lightIntensity) / (thresh3 - thresh4);\n       \t       weight = pow(weight, 2.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }  \n    }\n    return hatchingColor;\n    \n}\n\n// Credit to IQ: http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat SoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.05;\n    while(t <= 10.0)\n    {\n        float h = SceneMap(ro + rd * t);\n        if (h < 0.001)\n        {\n            return 0.0;\n        }\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;\n}\n\n// \"Plasma\": Compute ray jitter using \"plasma\": http://lodev.org/cgtutor/plasma.html\nfloat Plasma( in vec2 sp, in float timeStutter )\n{    \n    float plasma = 0.5 * sin(sp.x * 8.0 + timeStutter) + 0.5;\n    plasma *= 0.5 * sin((sp.x + sp.y) * 8.0 + timeStutter) + 0.5;\n    plasma *= 0.5 * sin(length(sp) * 15.0 + timeStutter) + 0.5;\n    return plasma;\n}\n\nvec3 CastRay( in vec2 sp, in vec3 origin, out vec3 camRight, out vec3 camUp ) // need the camRight vector in the hatching color function\n{\n    // Compute local camera vectors\n    vec3 refPoint = vec3(0.0, 0.4, 0.0);\n    vec3 camLook = normalize(refPoint - origin);\n    camRight = normalize(cross(camLook, vec3(0.0, 1.0, 0.0)));\n    camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = refPoint + sp.x * camRight + sp.y * camUp;\n    return normalize(rayPoint - origin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 screenPoint = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Compute ray direction\n    float radius = 4.0;\n    float speed = 0.015625;\n    \n    // Animate camera or time-based\n    //vec3 rayOrigin = vec3(cos(iMouse.x * speed) * radius, -5.0 * ((iMouse.y / iResolution.y) - 0.8), sin(iMouse.x * speed) * radius);\n    vec3 rayOrigin = vec3(cos(iTime * speed * 16.0 + 3.14) * radius, 1.0, sin(iTime * speed * 16.0 + 3.14) * radius);\n    vec3 camRight, camUp;\n    vec3 rayDirection = CastRay(screenPoint, rayOrigin, camRight, camUp);\n    \n    // Compute ray jitter using fake noise stuff using sin() - see the Plasma() function\n    float timeStutter = floor(iTime * 12.0) * 16.0;\n    timeStutter = mod(timeStutter, 2048.0); // the plasma function broke when iTime reached high values, mod every 2^24\n    \n    const bool isGradientEnabled = true;\n    \n    // Compute a direction to offset the .xy component of each ray via a gradient\n    vec2 fragSize = 1.0 / iResolution.xy;\n    vec2 offsetDir = normalize(vec2(cos(cos(iTime * 2.0)), sin(cos(iTime * 2.0)))) * 0.75;\n    rayDirection.xy += max(Plasma(screenPoint, timeStutter), 0.05) * offsetDir * 0.00390625; // that's 1 / 256\n    \n    vec3 result = RaymarchScene(rayOrigin, rayDirection);\n    \n    if (result.y > 0.0)\n    {\n        vec3 isectPoint = rayOrigin + result.x * rayDirection;\n        vec3 normal = ComputeNormal(isectPoint);\n        float lightIntensity = clamp(dot(normal, LIGHT_VEC), 0.0, 1.0);\n        \n        vec3 col;\n        \n        // Compute shadows\n        float shadowing = 1.0;\n        #ifdef SHADOWS\n            shadowing= SoftShadow(isectPoint, LIGHT_VEC, 7.0);\n        #endif\n        \n        // Shade depending on whether or not we are on an outline\n        col = mix(GetHatchingColor(fragCoord.xy, min(shadowing, lightIntensity), camRight, camUp, isGradientEnabled, 0.0),\n                  GetHatchingColor(fragCoord.xy, 0.0, camRight, camUp, isGradientEnabled, 0.0),\n                  result.z);\n        \n        fragColor = vec4(col, 1.0);\n    }\n    else // we miss geometry completely\n    {\n        fragColor = vec4(GetBackgroundColor(fragCoord.xy), 1.0);\n    }\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llScRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 359, 389, 389, 642], [644, 644, 677, 677, 798], [800, 885, 935, 935, 970], [972, 972, 1013, 1013, 1059], [1061, 1061, 1103, 1103, 1185], [1187, 1187, 1234, 1234, 1300], [1302, 1302, 1354, 1354, 1461], [1463, 1553, 1574, 1574, 1615], [1617, 1617, 1648, 1648, 1972], [1974, 1974, 2009, 2009, 2311], [2313, 2313, 2364, 2364, 3193], [3195, 3195, 3237, 3270, 3928], [3930, 3930, 4082, 4082, 8098], [8100, 8180, 8233, 8233, 8484], [8486, 8571, 8621, 8621, 8838], [8840, 8840, 8978, 9014, 9327], [9329, 9329, 9386, 9386, 11562]]}
{"id": "llScWw", "name": "Frozen Ground", "author": "aiekick", "description": "tried to do a frozen ground :)", "tags": ["ground", "frozen"], "likes": 21, "viewed": 620, "published": "Public API", "date": "1508777619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n// link : https://www.shadertoy.com/view/llScWw\n\n#define path(t) sin(t * 0.1) * 2.\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(0.6,0.8,1.), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvec4 df(vec3 p)\n{\n    vec3 tex = texture(iChannel0, p.xz * 0.5).rgb;\n    float disp = dot(tex, vec3(0.01));\n    \n    p.xy += path(p.z);\n    \n    float plane = p.y + cos(p.x * .1) - 0.8 + disp;\n\n    return vec4(plane, vec3(0));\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float ms) \n{\n\tvec3 n = nor(surfPoint,0.0001); \n\treturn df(surfPoint - n * ms).x/ms;\n}\n\n// from shane shaders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    p = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane shaders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n// shading func\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 ld, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\n\tvec3 n = nor(p, 0.1);\t\t\n    \n    n = doBumpMap(iChannel0, p*.5, n, 0.005);\n\t\n\tvec3 refl = reflect(rd,n);\t\n\t\n\tfloat amb = 0.6; \t\t\t\t\t\t\t\t\t\t\t\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.); \t\n\tfloat sss = 1. - SubDensity(p, 1.); \t\t\t\t\t\t\n\t\n    return vec3(\n        (diff + fre + spe * 2.) * amb * li,\n        (diff + fre + sss) * amb * li + spe * 1.2,\n        (diff + fre - spe * 0.2 + sss * .8) * amb * li\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vars\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 mo = iMouse.xy;\n\tfloat time = iTime * 1.2;\n\t\n\tvec3 col = vec3(0);\n            \n\tvec3 ro = vec3(0,0,time);\n\tro.xy -= path(ro.z);\n    \n\tvec3 lp = ro + vec3(0,2,5);\n\t\n    vec3 cv = ro + vec3(0,-.3,1);\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n    \n  \tvec2 uv = (g+g-si)/si.y;\n   \tvec3 rd = normalize(z + uv.x*x + uv.y*y);\n\n\tfloat md = 100.;\n\n\tfloat s = 1., d = 0.;\n\tfor (float i=0.; i<80.; i++)\n\t{\n\t\tif (d*d/s > 1e6 || d > md) break;\n\t\ts = df(ro+rd*d).x;\n\t\td += s * 0.8;\n\t}\n\t\n    vec3 ld = normalize(lp - ro-rd*d);\n\t\n    vec3 sky = GetSky(rd, ld, vec3(1.5));\n    \n    if (d < md)\n    {\n        vec3 p = ro+rd*d; // surf point\n        vec3 mat = vec3(0.3,0.5,0.8);\n        \n        // sub surface\n        for (float i = 0.; i < 1.; i+=0.1)\n        {\n            float y = shade(p, rd, i, ld, i).y;\n            mat = blackbody(1000. + y * 900.).bgr * 0.8;\n            col = mix(col, y * mat, i);\n        }\n        \n        // surface\n        float x = shade(ro, rd, d, ld, 3.).x;\n        mat = blackbody(2000. + x * 900.).bgr * 0.2;\n        col = mix(col, x * mat, 0.7);\n    \t\n        // snow\n        vec3 tex = texture(iChannel0, p.xz*.2).rgb;\n        tex = smoothstep(tex+0.5, tex, vec3(.7));\n    \tfloat z = shade(ro, rd, d, ld, 1.).z;\n        col = mix(col, vec3(0.9,0.9,1.0) * z, tex.r);\n    }\n    \n\tcol = mix(col, sky, 1.0-exp(-0.01*d*d));\n\n    col = sqrt(col * col * .8);\n\n\tvec2 v = g/si;\n    col *= 0.5 + 0.5*pow( 16.0*v.x*v.y*(1.0-v.x)*(1.0-v.y), 0.25 ); // iq vignette\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llScWw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[297, 492, 549, 549, 834], [836, 836, 853, 853, 1064], [1066, 1066, 1100, 1100, 1312], [1314, 1535, 1563, 1563, 1888], [1890, 1972, 2017, 2017, 2090], [2092, 2268, 2319, 2319, 2493], [2495, 2704, 2767, 2767, 3129], [3131, 3147, 3205, 3205, 3762], [3764, 3764, 3821, 3833, 5478]]}
{"id": "llScz3", "name": "isinf test", "author": "gyabo", "description": "isinf support WebGL2.0.", "tags": ["isinf"], "likes": 1, "viewed": 74, "published": "Public", "date": "1509484931", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float finf = 1.0 / clamp(uv.x, 0.0, 1.0);\n    if(isinf(finf)) {\n\t\tfragColor = vec4(1, 0, 0, 1);\n    } else {\n        fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llScz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 285]]}
{"id": "llSczw", "name": " Intergalactics", "author": "ollj", "description": "fork of:\nhttps://www.shadertoy.com/view/llBXzW\n\nmore compatibility:\n- no ichannel textures (crappy hash instead)\n- ni gloval mutables (#define instead)", "tags": ["planet", "scattering", "atmospheric"], "likes": 6, "viewed": 539, "published": "Public API", "date": "1507879974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//parent: https://www.shadertoy.com/view/llBXzW\n//self  : https://www.shadertoy.com/view/llBXzW\n//ad 3d scatter planet atmosphere 3d\n\n/* -------------------------------\n  \n  Shaders used\n  'Atmospheric Scattering Sample' from \n  https://www.shadertoy.com/view/lslXDr - gltracy\n\n  cloud coverage from '2d Fast Clouds' \n  https://www.shadertoy.com/view/XsjSRt - Sinuousity\n\n  smooth and cheap 3d starfield from 'Fancy ties' \n  https://www.shadertoy.com/view/ltfGDs - nimitz\n\n  Fisheye lens effect from 'Cypher'\n  https://www.shadertoy.com/view/MlsGRS - dila\n\n  sun-sunIntensity from 'Kepler 256o'\n  https://www.shadertoy.com/view/XsjGRd - otaviogood\n\n  --------------------------------- */\n\nconst float fov = 1.5;\n//Global material id (keeps code cleaner)\nfloat matid = 0.;\n\n// math const\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nconst float MAX = 10000.0;\n\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 15.0;\n\n\n// scatter const\nconst float K_R = 0.166;\nconst float K_M = 0.0025;\nconst float E = 14.3; \t\t\t\t\t\t// light intensity\nconst vec3  C_R = vec3( 0.3, 0.7, 1.0 ); \t// 1 / wavelength ^ 4\nconst float G_M = -0.85;\t\t\t\t\t// Mie g\n\nconst float R = 2.0;\nconst float R_INNER = 1.8;\nconst float SCALE_H = 4.0 / ( R - R_INNER );\nconst float SCALE_L = 1.0 / ( R - R_INNER );\n\nconst int NUM_OUT_SCATTER = 10;\nconst float FNUM_OUT_SCATTER = 10.0;\n\nconst int NUM_IN_SCATTER = 10;\nconst float FNUM_IN_SCATTER = 10.0;\n#define time iTime*1.3\nconst float eps = 0.001;\n\n//2d Fast Clouds const\n//SETTINGS//\nconst float timeScale = 30.0;\nconst float cloudScale = 0.5;\nconst float skyCover = 0.6; //overwritten by mouse x drag\nconst float softness = 0.2;\nconst float brightness = 1.0;\nconst int noiseOctaves = 8;\nconst float curlStrain = 3.0;\n//SETTINGS//\n\nvec3 light = normalize(vec3(-.5, 0.2, -0.2));\n\nfloat pi = 3.14159265359;\n\n#define radian  (time*pi)/180.0 \n#define mx  iMouse.x/55.\n#define my  iMouse.y/55.\n\n#define ry  mat3(cos(radian*32.-mx), 0.0,-sin(radian*32.-mx),\\\n\t\t\t   0.0, 1.0, 0.0, \\\n\t\t\t   sin(radian*32.-mx), 0.0, cos(radian*32.-mx)  )\n     \n#define rx  mat3(1.0, 0.0, 0.0,\\\n\t\t\t   0.0, cos(radian*13.-my), sin(radian*13.-my), \\\n\t\t\t   0.0,-sin(radian*13.-my), cos(radian*13.-my) )\n// ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// ray intersects sphere\n// e = -b +/- sqrt( b^2 - c )\nvec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( MAX, -MAX );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\n// Mie\n// g : ( -0.75, -0.999 )\n//      3 * ( 1 - g^2 )               1 + c^2\n// F = ----------------- * -------------------------------\n//      2 * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn 1.5 * a / b;\n}\n\n// Reyleigh\n// g : 0\n// F = 3/4 * ( 1 + c^2 )\nfloat phase_reyleigh( float cc ) {\n\treturn 0.75 * ( 1.0 + cc );\n}\n\nfloat density( vec3 p ){\n\treturn exp( -( length( p ) - R_INNER ) * SCALE_H );\n}\n\nfloat optic( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {\n\t\tsum += density( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * SCALE_L;\n\t\n\treturn sum;\n}\n//from 'Atmospheric Scattering Sample'\n//https://www.shadertoy.com/view/lslXDr - gltracy\nvec3 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n\tvec3 sum = vec3( 0.0 );\n\tfor ( int i = 0; i < NUM_IN_SCATTER; i++ ) {\n\t\tvec2 f = ray_vs_sphere( v, l, R );\n\t\tvec3 u = v + l * f.y;\n\t\t\n\t\tfloat n = ( optic( p, v ) + optic( v, u ) ) * ( PI * 4.0 );\n\t\t\n\t\tsum += density( v ) * exp( -n * ( K_R * C_R + K_M ) );\n\n\t\tv += step;\n\t}\n\tsum *= len * SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn sum * ( K_R * C_R * phase_reyleigh( cc ) + K_M * phase_mie( G_M, c, cc ) ) * E;\n}\n//Random function\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n//Noise function\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n//From Dave_Hoskins\nvec2 hash22(vec2 p){\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec3 hash33(vec3 p){\n\tp  = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p += dot(p.yzx, p.xyz  + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p.x * p.z * 95.4337, p.x * p.y * 97.597, p.y * p.z * 93.8365));\n}\n//--------------------Utility, Domain folding and Primitives---------------------\nfloat tri(in float x){return abs(fract(x)-.5);}\n//smooth and cheap 3d starfield\n//from 'Fancy ties'\n//https://www.shadertoy.com/view/ltfGDs - nimitz\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*.85*fov;\n    \n    //Triangular deformation (used to break sphere intersection pattterns)\n    p.x += (tri(p.z*50.)+tri(p.y*50.))*0.006;\n    p.y += (tri(p.z*50.)+tri(p.x*50.))*0.006;\n    p.z += (tri(p.x*50.)+tri(p.y*50.))*0.006;\n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        float rn = hash33(id).z;\n        float c2 = 1.-smoothstep(-0.2,.4,length(q));\n        c2 *= step(rn,0.005+i*0.014);\n        c += c2*(mix(vec3(1.0,0.75,0.5),vec3(0.85,0.9,1.),3.*rn*30.)*0.5 + 0.5);\n        p *= 1.15;\n    }\n    \n    return c*c*1.5*6.;\n}\n\nfloat distanceFunction(vec3 pos){\n    return length(pos) - R_INNER;\n}\n \nvec3 getNormal(vec3 p)\n{\n    const float d = eps;\n    return\n        normalize\n        (\n            vec3\n            (\n                distanceFunction(p+vec3(d,0.0,0.0))-distanceFunction(p+vec3(-d,0.0,0.0)),\n                distanceFunction(p+vec3(0.0,d,0.0))-distanceFunction(p+vec3(0.0,-d,0.0)),\n                distanceFunction(p+vec3(0.0,0.0,d))-distanceFunction(p+vec3(0.0,0.0,-d))\n            )\n        );\n}\n \n\n\nfloat saturate(float num)\n{\n    return clamp(num,0.0,1.0);\n}\n\nfloat noised(vec2 uv)\n{\n    uv*=9.;\n    return sin(uv.x)+cos(uv.y+dot(uv.x,uv.y));\n    //return texture(iChannel0,uv).r;\n}\n\nvec2 rotate(vec2 uv)\n{\n    uv = uv + noised(uv*0.2)*0.005;\n    float rot = curlStrain;\n    float sinRot=sin(rot);\n    float cosRot=cos(rot);\n    mat2 rotMat = mat2(cosRot,-sinRot,sinRot,cosRot);\n    return uv * rotMat;\n}\n\nfloat fbm (vec2 uv)\n{\n    float rot = 1.57;\n    float sinRot=sin(rot);\n    float cosRot=cos(rot);\n    float f = 0.0;\n    float total = 0.0;\n    float mul = 0.5;\n    mat2 rotMat = mat2(cosRot,-sinRot,sinRot,cosRot);\n    \n    for(int i = 0;i < noiseOctaves;i++)\n    {\n        f += noised(uv+iTime*0.00015*timeScale*(1.0-mul))*mul;\n        total += mul;\n        uv *= 3.0;\n        uv=rotate(uv);\n        mul *= 0.5;\n    }\n    return f/total;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (fragCoord.xy*2.0 -iResolution.xy) / iResolution.y;\n    vec3 camPos = vec3(0.0, 0.0, -3.0-sin(time*.5)*.5) * rx*ry;\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Fisheye lens effect from 'Cypher'\n\t//https://www.shadertoy.com/view/MlsGRS - dila\n    vec3 eye = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33)); \n    //camDir *= rx*ry;//*ry;//*rx;\n    //camUp  *= rx*ry;//*ry;//*rx;\n\n    vec3 camSide = cross(camDir, camUp);\n    float focus = 1.5;\n\n    vec3 rayDir;// =  normalize(camSide*pos.x + camUp*pos.y + camDir*focus)*rx*ry;  \n    eye*=rx*ry;\n    float t = 0.0, d;\n    rayDir=eye;\n    vec3 posOnRay = camPos;\n    float dense = 16.0;\n    \n    //sun-sunIntensity from 'Kepler 256o'\n    //https://www.shadertoy.com/view/XsjGRd - otaviogood\n    vec3 localRay = normalize(rayDir);\n    float sunIntensity = 1.0 - (dot(localRay, light) * 0.5 + 0.5);\n    //sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n    sunIntensity = 0.2 / sunIntensity;\n    sunIntensity = min(sunIntensity, 40000.0);\n    sunIntensity = max(0.0, sunIntensity - 3.0);\n    //////////////////////////////////////////////////\n    \n    for(int i=0; i<32; ++i){\n        d = distanceFunction(posOnRay);\n        t += d;\n        posOnRay = camPos + t*rayDir;\n        if(d < eps){ break; }\n    }\n    \n  \n    vec3 normal = getNormal(posOnRay);\n    vec2 e = ray_vs_sphere( camPos, rayDir, R );\n\t\n\tvec2 f = ray_vs_sphere( camPos, rayDir, R_INNER );\n\te.y = min( e.y, f.x );\n    //////////////////////\n    vec2 screenUv = fragCoord.xy/iResolution.xy;\n    vec2 uv2 = fragCoord.xy/(40000.0*cloudScale);\n    \n    float mouseXAffect = (iMouse.x/iResolution.x);\n    \n    float cover = 0.55;\n    \n    float bright = brightness*(1.8-cover);\n    \n    //cloud coverage from '2d Fast Clouds' \n    //https://www.shadertoy.com/view/XsjSRt - Sinuousity\n    float color1 = fbm((posOnRay.yz*.015)-0.5+iTime*0.00004*timeScale);  //xz\n    float color2 = fbm((posOnRay.zy*.015)-10.5+iTime*0.00002*timeScale); //yz\n    \n    float clouds1 = smoothstep(1.0-cover,min((1.0-cover)+softness*2.0,1.0),color1);\n    float clouds2 = smoothstep(1.0-cover,min((1.0-cover)+softness,1.0),color2);\n    \n    float cloudsFormComb = saturate(clouds1+clouds2);\n    \n    vec4 skyCol = vec4(0.6,0.8,1.0,1.0);\n    float cloudCol = saturate(saturate(1.0-pow(color1,1.0)*0.2)*bright);\n    vec4 clouds1Color = vec4(cloudCol,cloudCol,cloudCol,1.0);\n    vec4 clouds2Color = mix(clouds1Color,skyCol,0.25);\n    vec4 cloudColComb = mix(clouds1Color,clouds2Color,saturate(clouds2-clouds1));\n    vec4 clouds = vec4(0.0);\n\tclouds = mix(skyCol,cloudColComb,cloudsFormComb);\n\tvec3 I = in_scatter( camPos, rayDir, e, light );\n    \n    if(abs(d) < eps){\n        float diffuse = clamp( dot(normal, light), 0.015, 1.);\n        float specular = 1.5*pow(clamp(dot(reflect(rayDir, normal), light), 0., 1.), 30.);\n        vec3 brdf = 1.5*vec3(.10, .11, .11);\n        float fre = 0.1*pow(clamp(1. + dot(normal, rayDir), 0., 1.), 2.);\n        brdf += 1.30*diffuse*vec3(1., .9, .75);\n        vec3 spe = vec3(1.0,0.8,0.7)*specular;\n        fragColor = vec4((I*.025)+clouds.rgb*diffuse+spe+brdf*fre, 1.0);  //+specular2+fre+brdf\n    } else {\n        fragColor = vec4(0.0);\n        fragColor.rgb+=stars(rayDir*.35); //.4\n        fragColor.rgb+=I;\n        fragColor.rgb += sunCol*(sunIntensity*.0025);\n    }\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSczw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2202, 2219, 2267, 2267, 2443], [2445, 2500, 2549, 2549, 2732], [2734, 2929, 2976, 2976, 3132], [3134, 3180, 3214, 3214, 3245], [3247, 3247, 3271, 3271, 3326], [3328, 3328, 3359, 3359, 3585], [3586, 3675, 3728, 3728, 4297], [4298, 4316, 4336, 4336, 4403], [4404, 4421, 4442, 4442, 4639], [4640, 4660, 4680, 4680, 4835], [4837, 4837, 4857, 4857, 5052], [5053, 5135, 5157, 5157, 5182], [5183, 5284, 5307, 5307, 5959], [5961, 5961, 5994, 5994, 6030], [6033, 6033, 6057, 6057, 6448], [6453, 6453, 6480, 6480, 6513], [6515, 6515, 6538, 6538, 6637], [6639, 6639, 6661, 6661, 6859], [6861, 6861, 6882, 6882, 7301], [7304, 7304, 7361, 7361, 10829]]}
{"id": "llSyDh", "name": "Hexagonal Maze Flow", "author": "Shane", "description": "A Truchet pattern flowing through a hexagonal maze. It's a 2D effect rendered in a faux 3D style.", "tags": ["hexagon", "truchet", "flow", "geometry", "pattern", "polar"], "likes": 229, "viewed": 9503, "published": "Public API", "date": "1508593594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tHexagonal Maze Flow\n\t-------------------\n\n\tI've been playing around with hexagonal grids lately. It's possible to make all kinds of\n\tinteresting things with them. I'll eventually tire of hexagons and get back to what I'm \n\tsupposed to be doing, but for now, here's a maze with a flowing polkadot snake-like\n\tpattern running through it... I'm not really sure what it is either. :)\n\n\tIt has an impossible geometry feel to it, and is rendered in an oldschool kind of game\n\tstyle. It was pretty easy to produce: Obtain some hexagonal grid cell coordinates and \n\tcorresponding ID, render some lines, shapes, and a few arcs for the Truchet component,\n\tapply some shading, etc.\n\t\n\tIt was more of an exercise in applying layers in the right order than anything else. One \n\tof the things that might be of interest is the flowing Truchet pattern. Producing a \n\tflowing hexagonal Truchet isn't much different to producing a square one. In fact, it's\n\teasier - in the sense that you don't have to reverse directions from cell to cell. \n\n\tHowever, one of the downsides is that it's not immediately obvious how to apply UV \n\tcoordinates - I think BigWings mentioned this, and I concur. :) I got around the problem\n\tby ensuring that the texture pattern had the appropriate symmetry and applying hybrid \n\tpolar coordinates. By that, I mean, I wrapped the polar angles across the arc boundaries\n\tand used that for one coordinate, then used the Truchet distance field itself for the \n\tother...\n\n    Roughly speaking, it's not much different to a circle: In that situation, you use the \n\tfamiliar polar coordinates (r = length(u), a = atan(u.y, u.x)). The only difference in \n\tthis case is that you use a modified radial coordinate (r = min(min(r1, r2), r3)) - or \n\tto put it another way, you use the distance field value... It's a bit difficult to \n\texplain, but easy to perform. When I get time, I'm going to produce a more robust Truchet \n\ttexturing example.\n\t\n\n\tRelated references:\n\n\t// You can't do a hexagonal grid example without referencing this. :) Very stylish.\n\tHexagons - distance - iq\n\thttps://www.shadertoy.com/view/Xd2GR3\n\t\n\n\t// Simpler hexagonal grid example that attempts to explain the grid setup used to produce \n\t// the pattern here.\n\t//\n\tMinimal Hexagonal Grid - Shane\n\thttps://www.shadertoy.com/view/Xljczw\n\n*/\n\n// Interlaced variation - Interesting, but patched together in a hurry.\n//#define INTERLACING\n\n// A quick hack to get rid of the winding overlay - in order to show the maze only.\n//#define MAZE_ONLY\n\n\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.173, 289.927)))*43758.5453); }\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following.\nfloat hex(in vec2 p){\n    \n    p = abs(p);\n    \n    // Below is equivalent to:\n    //return max(p.x*.5 + p.y*.866025, p.x); \n\n    return max(dot(p, s*.5), p.x); // Hexagon.\n    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything - in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point. Note that a random constant has been added to \n    // \"hC.zw\" to further distinguish it from \"hC.xy.\"\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(.5, 1));\n    \n}\n\n// Dot pattern.\nfloat dots(in vec2 p){\n    \n\tp = abs(fract(p) - .5);\n    \n    return length(p); // Circles.\n    \n    //return (p.x + p.y)/1.5 + .035; // Diamonds.\n    \n    //return max(p.x, p.y) + .03; // Squares.\n    \n    //return max(p.x*.866025 + p.y*.5, p.y) + .01; // Hexagons.\n    \n    //return min((p.x + p.y)*.7071, max(p.x, p.y)) + .08; // Stars.\n    \n    \n}\n\n\n// Distance field for the arcs. I think it's called poloidal rotation, or something like that.\nfloat dfPol(vec2 p){\n     \n    return length(p); // Circular arc.\n    \n    // There's no rule that says the arcs have to be rounded. Here's a hexagonal one.\n    //return hex(p);\n    \n    // Dodecahedron.\n    //return max(hex(p), hex(r2(3.14159/6.)*p));\n    \n    // Triangle.\n    //return max(abs(p.x)*.866025 - p.y, p.y);\n    \n}\n\n\n// Truchet pattern distance field.\nfloat df(vec2 p, float dir){\n     \n    // Weird UV coordinates. The first entry is the Truchet distance field itself,\n    // and the second is the polar angle of the arc pixel. The extra \".1\" is just a bit\n    // of mutational scaling, or something... I can't actually remember why it's there. :)\n    vec2 uv = vec2(p.x + .1, p.y);//*vec2(1, 1); // Scaling.\n    \n    // A checkered dot pattern. At present the pattern needs to have flip symmetry about\n    // the center, but I'm pretty sure regular textures could be applied with a few\n    // minor changes. Due to the triangular nature of the Truchet pattern, factors of \"3\"\n    // were necessary, but factors of \"1.5\" seemed to work too. Hence the \"4.5.\"\n    return min(dots(uv*4.5), dots(uv*4.5 + .5)) - .3;\n    \n}\n\n\n// Polar coordinate of the arc pixel.\nfloat getPolarCoord(vec2 q, float dir){\n    \n    // The actual animation. You perform that before polar conversion.\n    q = r2(iTime*dir)*q;\n    \n    // Polar angle.\n    const float aNum = 1.;\n    float a = atan(q.y, q.x);\n   \n    // Wrapping the polar angle.\n    return mod(a/3.14159, 2./aNum) - 1./aNum;\n   \n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // I didn't feel like tayloring the antiasing to suit every resolution, which can get tiring, \n    // so I've put a range on it. Just for the record, I coded this for the 800 by 450 pixel canvas.\n    float res = clamp(iResolution.y, 300., 600.); \n    \n    // Aspect correct screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/res;\n    \n    // Scaling and moving the screen coordinates.\n    vec2 sc = u*4. + s.yx*iTime/8.;\n    \n    // Converting the scaled and translated pixels to a hexagonal grid cell coordinate and\n    // a unique coordinate ID. The resultant vector contains everything you need to produce a\n    // pretty pattern, so what you do from here is up to you.\n    vec4 h = getHex(sc); // + s.yx*iTime/2.\n    \n    // Obtaining some offset values to do a bit of cubic shading. There are probably better ways\n    // to go about it, but it's quick and gets the job done.\n    vec4 h2 = getHex(sc - 1./s);\n    vec4 h3 = getHex(sc + 1./s);\n    \n    // Storing the hexagonal coordinates in \"p\" to save having to write \"h.xy\" everywhere.\n    vec2 p = h.xy;\n    \n    // The beauty of working with hexagonal centers is that the relative edge distance will simply \n    // be the value of the 2D isofield for a hexagon.\n    //\n    float eDist = hex(p); // Edge distance.\n    float cDist = dot(p, p); // Relative squared distance from the center.\n\n    \n    // Using the identifying coordinate - stored in \"h.zw,\" to produce a unique random number\n    // for the hexagonal grid cell.\n    float rnd = hash21(h.zw);\n    //float aRnd = sin(rnd*6.283 + iTime*1.5)*.5 + .5; // Animating the random number.\n    \n    #ifdef INTERLACING\n    // Random vec3 - used for some overlapping.\n    //vec3 lRnd = vec3(rnd*14.4 + .81, fract(rnd*21.3 + .97), fract(rnd*7.2 + .63));\n    vec3 lRnd = vec3(hash21(h.zw + .23), hash21(h.zw + .96), hash21(h.zw + .47));\n    #endif\n    \n    // It's possible to control the randomness to form some kind of repeat pattern.\n    //rnd = mod(h.z + h.w, 2.);\n    \n\n    // Redundant here, but I might need it later.\n    float dir = 1.;\n    \n\n    \n    // Storage vector.\n    vec2 q;\n    \n    \n    // If the grid cell's random ID is above a threshold, flip the Y-coordinates.\n    if(rnd>.5) p.y = -p.y;\n        \n    \n\n    // Determining the closest of the three arcs to the current point, the keeping a copy\n    // of the vector used to produce it. That way, you'll know just to render that particular\n    // decorated arc, lines, etc - instead of all three. \n    const float r = 1.;\n    const float th = .2; // Arc thickness.\n    \n    // Arc one.\n    q = p - vec2(0, r)/s;\n    vec3 da = vec3(q, dfPol(q));\n    \n    // Arc two. \"r2\" could be hardcoded, but this is a relatively cheap 2D example.\n    q = r2(3.14159*2./3.)*p - vec2(0, r)/s;\n    vec3 db = vec3(q, dfPol(q));\n\n     // Arc three. \n    q = r2(3.14159*4./3.)*p - vec2(0, r)/s;\n    vec3 dc = vec3(q, dfPol(q));\n    \n    // Compare distance fields, and return the vector used to produce the closest one.\n    vec3 q3 = da.z<db.z && da.z<dc.z? da : db.z<dc.z ? db : dc;\n    \n    \n    // TRUCHET PATTERN\n    //\n    // Set the poloidal arc radius: You can change the poloidal distance field in \n    // the \"dfPol\" function to a different curve shape, but you'll need to change\n    // the radius to one of the figures below.\n    //\n    q3.z -= .57735/2. + th/2.;  // Circular and dodecahedral arc/curves.\n    //q3.z -= .5/2. + th/2.;  // Hexagon curve.\n    //q3.z -= .7071/2. + th/2.;  // Triangle curve.\n    \n    q3.z = max(q3.z, -th - q3.z); // Chop out the smaller radius. The result is an arc.\n    \n    // Store the result in \"d\" - only to save writing \"q3.z\" everywhere.\n    float d = q3.z;\n    \n    // If you'd like to see the maze by itself.\n    #ifdef MAZE_ONLY\n    d += 1e5;\n    #endif\n    \n    // Truchet border.\n    float dBord = max(d - .015, -d);\n    \n\n    \n \n    \n    // MAZE BORDERS\n    // Producing the stright-line arc borders. Basically, we're rendering some hexagonal borders around\n    // the arcs. The result is the hexagonal maze surrounding the Truchet pattern.\n    q = q3.xy;\n    const float lnTh = .05;\n    q = abs(q);\n    \n    float arcBord = hex(q);\n    //float arcBord = length(q); // Change arc length to \".57735.\"\n    //float arcBord = max(hex(q), hex(r2(3.14159/6.)*q)); // Change arc length to \".57735.\"\n    \n    // Making the hexagonal arc.\n    float lnOuter = max(arcBord - .5, -(arcBord - .5 + lnTh)); //.57735\n    \n    \n    #ifdef INTERLACING\n    float ln = min(lnOuter, (q.y*.866025 + q.x*.5, q.x) - lnTh);\n    #else\n    float ln = min(lnOuter, arcBord - lnTh);\n    #endif\n    float lnBord = ln - .03; // Border lines to the maze border, if that makes any sense. :)\n     \n    \n   \n    \n    ///////\n    // The moving Truchet pattern. The polar coordinates consist of a wrapped angular coordinate,\n    // and the distance field itself.\n    float a = getPolarCoord(q3.xy, dir);\n    float d2 = df(vec2(q3.z, a), dir); \n    \n    // Smoothstepped Truchet mask.\n    float dMask = smoothstep(0., .015, d);\n    ///////\n    \n    // Producing the background with some subtle gradients.\n    vec3 bg =  mix(vec3(0, .4, .6), vec3(0, .3, .7), dot(sin(u*6. - cos(u*3.)), vec2(.4/2.)) + .4); \n    bg = mix(bg, bg.xzy, dot(sin(u*6. - cos(u*3.)), vec2(.4/2.)) + .4);\n    bg = mix(bg, bg.zxy, dot(sin(u*3. + cos(u*3.)), vec2(.1/2.)) + .1);\n   \n    #ifdef INTERLACING\n    // Putting in background cube lines for the interlaced version.\n    float hLines = smoothstep(0., .02, eDist - .5 + .02);\n    bg = mix(bg, vec3(0), smoothstep(0., .02, ln)*dMask*hLines);\n    #endif\n    \n    // Lines over the maze lines. Applying difference logic, depending on whether the \n    // pattern is interlaced or not.\n    const float tr = 1.;\n\n    float eDist2 = hex(h2.xy);\n    float hLines2 = smoothstep(0., .02, eDist2 - .5 + .02);\n    #ifdef INTERLACING\n    if(rnd>.5 && lRnd.x<.5) hLines2 *= smoothstep(0., .02, ln);\n    if(lRnd.x>.5) hLines2 *= dMask;\n    #else\n    if(rnd>.5) hLines2 *= smoothstep(0., .02, ln);\n    hLines2 *= dMask;\n    #endif\n    bg = mix(bg, vec3(0), hLines2*tr);\n    \n    float eDist3 = hex(h3.xy);\n    float hLines3 = smoothstep(0., .02, eDist3 - .5 + .02);\n    #ifdef INTERLACING\n    if(rnd<=.5 && lRnd.x>.5) hLines3 *= smoothstep(0., .02, ln);\n    if(lRnd.x>.5) hLines3 *= dMask;\n    #else\n    if(rnd<=.5) hLines3 *= smoothstep(0., .02, ln);\n    hLines3 *= dMask;\n    #endif\n    bg = mix(bg, vec3(0), hLines3*tr);\n\n\n    // Using the two off-centered hex coordinates to give the background a bit of highlighting.\n    float shade = max(1.25 - dot(h2.xy, h2.xy)*2., 0.);\n    shade = min(shade, max(dot(h3.xy, h3.xy)*3. + .25, 0.));\n    bg = mix(bg, vec3(0), (1.-shade)*.5); \n    \n    // I wanted to change the colors of everything at the last minute. It's pretty hacky, so\n    // when I'm feeling less lazy, I'll tidy it up. :)\n    vec3 dotCol = bg.zyx*vec3(1.5, .4, .4);\n    vec3 bCol = mix(bg.zyx, bg.yyy, .25);\n    bg = mix(bg.yyy, bg.zyx, .25);\n    \n\n    // Under the random threshold, and we draw the lines under the Truchet pattern.\n    #ifdef INTERLACING\n    if(lRnd.x>.5){\n       bg = mix(bg, vec3(0), (1. - smoothstep(0., .015, lnBord)));\n       bg = mix(bg, bCol, (1. - smoothstep(0., .015, ln))); \n       // Center lines.\n       bg = mix(bg, vec3(0), smoothstep(0., .02, eDist3 - .5 + .02)*tr);\n    }\n    #else\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .015, lnBord)));\n    bg = mix(bg, bCol, (1. - smoothstep(0., .015, ln)));\n    #endif\n\n   \n    \n    // Apply the Truchet shadow to the background.\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .07, d))*.5);\n    \n    \n    // Place the Truchet field to the background, with some additional shading to give it a \n    // slightly rounded, raised feel.\n    //vec3 col = mix(bg, vec3(1)*max(-d*3. + .7, 0.), (1. - dMask)*.65);\n    // Huttarl suggest slightly more shading on the snake-like pattern edges, so I added just a touch.\n    vec3 col = mix(bg, vec3(1)*max(-d*9. + .4, 0.), (1. - dMask)*.65);\n\n\n    \n    // Apply the moving dot pattern to the Truchet.\n    //dotCol = mix(dotCol, dotCol.xzy, dot(sin(u*3.14159*2. - cos(u.yx*3.14159*2.)*3.14159), vec2(.25)) + .5);\n    col = mix(col, vec3(0), (1. - dMask)*(1. - smoothstep(0., .02, d2)));\n    col = mix(col, dotCol, (1. - dMask)*(1. - smoothstep(0., .02, d2 + .125)));\n    \n    // Truchet border.\n    col = mix(col, vec3(0), 1. - smoothstep(0., .015, dBord));\n    \n    #ifdef INTERLACING\n    // Over the random threshold, and we draw the lines over the Truchet.\n    if(lRnd.x<=.5){\n        col = mix(col, vec3(0), (1. - smoothstep(0., .015, lnBord)));\n        col = mix(col, bCol, (1. - smoothstep(0., .015, ln)));  \n        // Center lines.\n        col = mix(col, vec3(0), smoothstep(0., .02, eDist2 - .5 + .02)*tr);\n    }\n    #endif\n\n        \n    \n    \n    // Using the offset hex values for a bit of fake 3D highlighting.\n    //if(rnd>.5) h3.y = -h3.y; // All raised edges. Spoils the mild 3D illusion.\n    #ifdef INTERLACING\n    float trSn = max(dMask, 1. - smoothstep(0., .015, lnBord))*.75 + .25;\n    #else\n    float trSn = dMask*.75 + .25;\n    #endif\n    col = mix(col, vec3(0), trSn*(1. - hex(s/2.+h2.xy)));\n    col = mix(col, vec3(0), trSn*(1. - hex(s/2.-h3.xy)));\n \n    \n    // Using the edge distance to produce some repeat contour lines. Standard stuff.\n    //if (rnd>.5) h.xy = -h.yx;\n    //float cont = clamp(cos(hex(h.xy)*6.283*12.)*1.5 + 1.25, 0., 1.);\n    //col = mix(col, vec3(0), (1. - smoothstep(0., .015, ln))*(smoothstep(0., .015, d))*(1.-cont)*.5);\n    \n    \n    // Very basic hatch line effect.\n    float gr = dot(col, vec3(.299, .587, .114));\n    float hatch = (gr<.45)? clamp(sin((sc.x - sc.y)*3.14159*40.)*2. + 1.5, 0., 1.) : 1.;\n    float hatch2 = (gr<.25)? clamp(sin((sc.x + sc.y)*3.14159*40.)*2. + 1.5, 0., 1.) : 1.;\n\n    col *= min(hatch, hatch2)*.5 + .5;    \n    col *= clamp(sin((sc.x - sc.y)*3.14159*80.)*1.5 + .75, 0., 1.)*.25 + 1.;  \n    \n \n    // Subtle vignette.\n    u = fragCoord/iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .125) + .25;\n    // Colored variation.\n    //col = mix(pow(min(vec3(1.5, 1, 1)*col, 1.), vec3(1, 3, 16)), col, \n            //pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .25)*.75 + .25);    \n    \n\n    \n    // Rough gamma correction.    \n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSyDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2738, 2795, 2816, 2816, 2880], [2883, 2916, 2936, 2936, 2994], [2997, 3173, 3194, 3194, 3352], [3354, 4044, 4064, 4444, 5252], [5254, 5270, 5292, 5292, 5621], [5624, 5719, 5739, 5739, 6047], [6050, 6085, 6113, 6381, 6852], [6855, 6893, 6932, 7008, 7209], [7211, 7211, 7265, 7466, 17559]]}
{"id": "llSyRh", "name": "Vector Tile", "author": "Chris_M_Thomasson", "description": "Here is another simple pre-alpha try at an animation of my vector field adventure in GLSL. It creates a bit of a tiling effect, or a sort of Voronoi diagram in a sense.\n\nhttps://plus.google.com/101799841244447089430/posts/8ryLwvr9L4K", "tags": ["fractal", "math", "space", "field", "vector", "tile", "art", "trigonometry"], "likes": 0, "viewed": 145, "published": "Public", "date": "1507336233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nPre-Alpha Vector Field by Chris M. Thomasson ver:0.0.1\nThe code is basic, and the math can be streamlined.\nThis is a basic experiment, not thinking of sheer performance yet.\n___________________________________*/\n\n\n// The number of points in the spiral\n#define CT_N 4\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// A vector field point\nstruct ct_vfpoint\n{\n    vec2 p;\n    float m;\n};\n\n\n// Our global per-pixel points\nct_vfpoint g_vfp[CT_N * CT_N];\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec2 ct_vfield_normal(\n    in vec2 p,\n    float npow\n){\n    vec2 g = vec2(0.0, 0.0);\n    \n    const int imax = CT_N * CT_N;\n    \n    for (int i = 0; i < imax; ++i)\n    {\n        vec2 dif = g_vfp[i].p - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1];\n        float mass = pow(sum, npow);\n        \n      \tg[0] = g[0] + g_vfp[i].m * dif[0] / mass;\n      \tg[1] = g[1] + g_vfp[i].m * dif[1] / mass;\n        \n        \n    }\n    \n    return normalize(g);\n}\n\nfloat ct_normal_pi(\n    in vec2 z\n){\n    float a = atan(z[1], z[0]);\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    vec2 vn = ct_vfield_normal(z, npow);\n    float npi = ct_normal_pi(vn);\n    \n    float blah = length(vn);\n    \n    if (blah < .01)\n    {\n        return vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    \n    return vec4(\n        vn[0] * npi, vn[1] * npi * 2.0, vn[0] * vn[1] * npi * 3.0,\n        1.0\n    );\n}\n\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){\n    const int n = CT_N;\n    \n    for (int x = 0; x < n; ++x)\n    {\n    \tfloat xr = float(x) / float(n - 1);\n        \n        for (int y = 0; y < n; ++y)\n    \t{\n            float yr = float(y) / float(n - 1);\n        \n        \tg_vfp[x + y*n] = ct_vfpoint(\n                vec2((-1.0 + xr * 2.0) + cos(yr * iTime),\n                     -1.0 + yr * 2.0), \n                1.0\n            );\n        }\n    }\n    \n    return ct_vpixel(c, c, 128, 2.0 + abs(cos(iTime * 3.0)) * 7.14);\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(0.0, 0.0, 1.618);\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSyRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 382, 434, 434, 594], [597, 701, 753, 753, 1442], [1445, 1445, 1507, 1507, 1615], [1756, 1819, 1874, 1874, 2278], [2280, 2280, 2316, 2316, 2413], [2416, 2442, 2522, 2522, 2819], [2822, 2842, 2897, 2897, 3377], [3380, 3394, 3455, 3455, 3732]]}
{"id": "llSyRR", "name": "truchet marbles copy", "author": "abje", "description": "copy of shaus shader, but it goes in random directions", "tags": ["copy", "cubictruchet"], "likes": 14, "viewed": 659, "published": "Public API", "date": "1507142114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat torus(vec3 p, vec2 r) {\n    return length(vec2(abs(abs(length(p.xy)-r.x)-0.08),abs(p.z)-0.08))-r.y;\n}\n\nfloat square(vec3 p, vec2 r) {\n    return length(vec2(abs(max(abs(p.x),abs(p.y))-r.x),p.z))-r.y;\n}\n\nfloat map(vec3 p) {\n    \n    vec3 p2 = mod(p,2.0)-1.0;\n    vec3 floorpos = floor(p*0.5);\n    float len = 1e10;\n    \n    vec3 flipping = floor(hash33(floorpos)+0.5)*2.0-1.0;\n    flipping.z = 1.0;//mod(dot(floor(floorpos.xy),vec2(1)),2.0)*2.0-1.0;\n    //flipping.z = mod(floor(floorpos.x/2.0),2.0)*2.0-1.0;\n    //flipping.z = mod(floor(floorpos.y/2.0),2.0)*2.0-1.0;\n    \n    vec3 p3 = p2*flipping;\n    mat3 truchet = mat3(\n        vec3(p3.xy+vec2(-1, 1),p3.z),\n        vec3(p3.zx+vec2( 1, 1),p3.y),\n        vec3(p3.yz+vec2(-1,-1),p3.x)\n    );\n    \n    vec3 lens = vec3(\n        torus(truchet[0],vec2(1.0,0.02)),\n        torus(truchet[1],vec2(1.0,0.02)),\n        torus(truchet[2],vec2(1.0,0.02))\n    );\n    \n    vec3 mask = vec3(lessThanEqual(lens,min(lens.yzx,lens.zxy)));\n    \n    int num = int(dot(mask,vec3(0,1,2)));\n    \n    vec3 p4 = truchet[num];\n    \n    float dir = mod(dot(floorpos.xy,vec2(1)),2.0)*2.0-1.0;\n    \n    p4 = vec3(mod(dir*(atan(p4.x,p4.y)/6.28*6.0)+iTime*0.5,1.0/6.0)-0.5/6.0,\n              (length(p4.xy)-1.0),p4.z);\n    \n    return min(dot(lens,mask),length(p4)-0.1);\n}\n\nvec3 findnormal(vec3 p, float len) {\n    vec2 eps = vec2(0.01,0.0);\n    \n    return normalize(vec3(\n        len-map(p-eps.xyy),\n        len-map(p-eps.yxy),\n        len-map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(iTime*0.5)+vec3(0.001,0.002,0.003);\n    vec3 rd = normalize(vec3(uv,1.0));\n    bool hit = false;\n    float dist = 0.0;\n    float len;\n    for (int i = 0; i < 99; i++) {\n        len = map(ro);\n        ro += rd*len;\n        dist += len;\n        if (len < 0.001||dist>10.0) {\n            hit = len < 0.001;\n            break;\n        }\n    }\n    if (hit) {\n\t\tfragColor = vec4(findnormal(ro,len)*0.5+0.5,1.0);\n        fragColor /= (dist*dist*0.05+1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSyRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 192, 214, 214, 323], [325, 325, 354, 354, 432], [434, 434, 464, 464, 532], [534, 534, 553, 553, 1625], [1627, 1627, 1663, 1663, 1814], [1816, 1816, 1873, 1873, 2420]]}
{"id": "llSyWD", "name": "Torus_Thingy_1", "author": "balkhan", "description": "geometric exercise", "tags": ["3d", "raymarch", "torus"], "likes": 37, "viewed": 1121, "published": "Public", "date": "1508740321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\nfloat\tmind;\nfloat\tming;\nfloat\tmint;\nfloat\tminl;\n\nconst vec3\tteal   = vec3(0.3 , .7, .9);\nconst vec3\torange = vec3(0.95, .5, .1);\n\n#define I_MAX\t\t100.\n#define E\t\t\t0.0001\n#define FAR\t\t\t30.\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\n#define PI 3.14159\n#define TAU PI*2.\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = abs(iTime*.125); // my phone forces me to do this, idk why iTime is -iTime on phone\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0+cos(t*5.), .0+sin(t*5.)*.5, .0);\n\n    pos.z = 20.*exp(-t*5.)+10.+.5*sin(t*10.);    \n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    float\tid = (mind == ming ? 1. : 0.)+(mind == mint ? 2. : 0.)+(mind == minl ? 3. : 0.);\n    if (inter.y <= FAR)\n        col.xyz = ret_col*(1.-inter.x*.025);\n    else\n        col *= 0.;\n    col += h;\n\tcol *= clamp((1.5-length(uv)), .5, 1.);\n    col *= clamp((1.1-length(uv)), .0, 1.);\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    mind = 1e5;\n    ming = 1e5;\n    mint = 1e5;\n\tminl = 1e5;\n\n    rotate(p.xz, 1.57-.15*iTime);\n    rotate(p.yz, 1.57-.125*iTime);\n    vec3 op = p;\n    float\tvar = (atan(p.x, p.z)+ PI)/(TAU);\n    var = var*40.;\n    p.xz = modA(p.xz, 40.);\n    p.xz -= vec2(8., .0);\n\n    rotate(p.xy, iTime*.25*(mod(var-.5, 2.) <= 1. ? 1. : -1.));\n    vec2 q = vec2(length(p.xy)-4.,p.z);\n    mind = mylength(q)-.05;\n\n    float vir = (atan(p.x, p.y)+ PI)/(TAU);\n    var = vir*30.;\n    p.xy = modA(p.xy, 30.)-vec2(.0,.0);\n    p.xz -= vec2(4., .0);\n    q = vec2(length(p.zx)-0.25, p.y-.0);\n    ming = mylength(q)-.05;\n    mind = min(mind, ming);\n\n    float as = (mind == ming ? 1. : 0.);\n    ret_col = step(as, .0)*vec3(.2, .7, .4) + step(1., as)*vec3(.5, .2, .8);\n    rotate(p.xz, iTime*1.5*(mod(var, 2.) <= 1. ? 1. : -1.)*(mod(vir, 2.) <= 1. ? 1. : -1.));\n    p.xz = modA(p.xz, 20.)-vec2(.0,-.0);\n    p.xy -= vec2(.25, .0);\n    q = vec2(length(p.xy)-.1, p.z);\n    mint = mylength(q)-.02;\n    mind = min(mind, mint);\n    as = (mind == mint ? 1. : 0.);\n    if (as  == 1.)\n    ret_col = teal;\n    \n    // dodecahedron\n    rotate(op.zx, iTime*.5);\n    op.xz = modA(op.xz, 25.);\n    op -= vec3(6., .0, 0.);\n    op /= 1.732; //sqrt(3.)\n    vec3\tb = vec3(.075);\n\tminl = max(max(abs(op.x)+.5*abs(op.y)-b.x, abs(op.y)+.5*abs(op.z)-b.y), abs(op.z)+.5*abs(op.x)-b.z);\n    b *= .95;\n    minl = max(minl, \n           -max(max(abs(op.x)+.5*abs(op.y)-b.x, abs(op.y)-.5*abs(op.z)-b.y), abs(op.z)+.5*abs(op.x)-b.z)\n               );\n    minl = max(minl, \n           -max(max(abs(op.x)-.5*abs(op.y)-b.x, abs(op.y)+.5*abs(op.z)-b.y), abs(op.z)+.5*abs(op.x)-b.z)\n               );\n    minl = max(minl, \n           -max(max(abs(op.x)+.5*abs(op.y)-b.x, abs(op.y)+.5*abs(op.z)-b.y), abs(op.z)-.5*abs(op.x)-b.z)\n               );\n    // end dodecahedron\n\n    mind = min(mind, minl);\n\n    as = mind == minl ? 1. : 0.;\n\n    if (as == 1.)\n    ret_col = orange;\n    \n    h += .036125*orange/(pow(minl, 25.)+.5);\n\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\tfloat dinamyceps = E;\n\tfor (float i = -1.; i < I_MAX; ++i)\n\t{\n\t\tp = pos + dir * dist.y;\n\t\tdist.x = scene(p);\n\t\tdist.y += dist.x*1.;\n        dinamyceps = -dist.x+(dist.y)/(1500.);\n        // log trick from aiekick\n\t    if (log(dist.y*dist.y/dist.x/1e5)>0. || dist.x < dinamyceps || dist.y > FAR)\n        {\n            break;\n        }\n\t    s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n    \n    p = p*p*p*p;\n    p = p*p;\n    ret = (p.x+p.y);\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSyWD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[617, 726, 759, 759, 890], [1004, 1226, 1254, 1254, 1579], [1581, 1629, 1672, 1672, 2355], [2357, 2357, 2378, 2378, 4367], [4369, 4369, 4401, 4401, 4885], [4887, 4887, 4911, 4911, 5029], [5031, 5045, 5085, 5085, 5160], [5162, 5162, 5190, 5190, 5298], [5300, 5300, 5322, 5322, 5528], [5530, 5530, 5580, 5580, 5843]]}
{"id": "llsyWl", "name": "Quadratic Wedge Bounding", "author": "paniq", "description": "Bounding a bivariate convex quadratic function with a wedge (equivalent to the planes of a frustum) to find slopes and contact points of the wedge.", "tags": ["quadratic", "frustum", "tangent", "bounding", "wedge"], "likes": 4, "viewed": 508, "published": "Public API", "date": "1507026736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\ngeneral approach to finding tangent wedges:\n\nwe're looking to solve the slope factor q for the linear function q*x = y\nfor the convex bivariate homogeneous equation\n\nf(x,y) = 0\n\n1. substitute y in f(x,y) with q*x to turn it into a univariate g(x)\n2. solve first derivative g'(x) = q for x\n3. substitute into g(x) the solution for x to receive h()\n4. solve h() = 0 for q to receive two solutions\n\nnow q0,q1 describe the two bounding slopes\n\nsubstitute q0,q1 into the solution for x to receive x0,x1\nthen your two contact points are (x0, q0*x0) and (x1, q1*x1)\n\nThis problem also expands to 3D. For a 3D solution, you\nneed to work with two wedges (a perspective frustum).\n\nfor each wedge\n\n1. substitute y|x in f(x,y,z) with q*z, to turn it into a bivariate g(x|y,z)\n2. solve partial derivatives dg(x|y,z)/dx|y = 0 and dg(x|y,z)/dz = q for x|y and z\n3. substitute into g(x|y,z) the solutions for x|y and z to receive h()\n4. solve h() = 0 for q to receive two solutions\n\nSpecial note for quadratics:\nYou can reconstruct the screenspace ellipse that bounds the quadratic\nfrom four points and two normals. The resulting equations can likely\nbe crunched down by getting rid of the intermediates, but I yet lack\nthe intuition for a direct solution.\n\n*/\n\n\nstruct surface2x2 {\n    float c[6];\n};\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// compute the value for the given position (x y z)\nfloat surface2x2_eval(surface2x2 surf, vec2 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n    return A*p.x*p.x + B*p.y*p.y + C*p.x*p.y + D*p.x + E*p.y + F;\n}\n\n// for a convex bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// compute the bounding tangential points of a wedge with its apex at origin\n// and return the slope coefficients for both wedge lines\nvec2 surface2x2_proj_bounds(surface2x2 surf, out vec2 p0, out vec2 p1) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n    float f = 1.0 / (E*E - 4.0*B*F - 1.0);\n    float s = -D*E + 2.0*C*F;\n    float t = sqrt(-4.0*(4.0*A*B - C*C)*F*F + D*D + 4.0*(B*D*D - C*D*E + A*E*E - A)*F);\n\tfloat q0 = (s - t)*f;\n    float q1 = (s + t)*f;\n    float x0 = -0.5*((E - 1.0)*q0 + D)/(B*q0*q0 + C*q0 + A);\n    float x1 = -0.5*((E - 1.0)*q1 + D)/(B*q1*q1 + C*q1 + A);\n    p0 = vec2(x0, q0*x0);\n    p1 = vec2(x1, q1*x1);\n    return vec2(q0, q1);\n}\n    \n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    float scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n// save current source color, stroke width and starting\n// point from active context.\nContext save();\n// restore source color, stroke width and starting point\n// to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\nsurface2x2 surf;\nfloat fieldf(vec2 p) {\n    return surface2x2_eval(surf, p);\n}\n\nvoid paint() {\n    float t = iTime;\n    \n    // clear screen\n    \n    set_source_rgb(vec3(0.0,0.0,0.5));\n    clear();\n\n    // normal\n    vec2 n = vec2(cos(t),sin(t));\n    \n    // ellipse scaling\n    vec2 s = vec2(0.8 - 0.7 * abs(cos(t * 0.2)), 0.5 - 0.4 * abs(sin(t * 0.2)));\n    \n    vec2 ofs = vec2(1.0, 0.0) + n*0.5;\n        \n    float A = 1.0/(s.x*s.x);\n    float B = 1.0/(s.y*s.y);\n    float C = -1.0;\n    surf.c[0] = A;\n    surf.c[1] = B;\n    surf.c[2] = 0.0;\n    surf.c[3] = -2.0*A*ofs.x;\n    surf.c[4] = -2.0*B*ofs.y;\n    surf.c[5] = A*ofs.x*ofs.x + B*ofs.y*ofs.y + C;\n    \n    vec2 p0, p1;\n    vec2 xgrad = surface2x2_proj_bounds(surf, p0, p1);\n    \n    translate(-1.0, 0.0);\n    \n    set_line_width_px(1.3);\n    set_source_rgb(vec3(1.0));\n    move_to(-10.0, xgrad[0] * -10.0);\n    line_to(10.0, xgrad[0] * 10.0);\n    move_to(-10.0, xgrad[1] * -10.0);\n    line_to(10.0, xgrad[1] * 10.0);\n    stroke();\n    \n    // fill ellipse\n    graph2D(fieldf);\n    set_source_rgb(hsl(0.0, 1.0, 0.5));\n    fill_preserve(); // don't reset shape    \n    set_source_rgb(vec3(1.0));\n   \tstroke();\n\n    circle(p0, 0.02);\n    fill();\n    circle(p1, 0.02);\n    fill();\n\n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    ScreenH = min(iResolution.x,iResolution.y);\n    AA = ScreenH*0.4;\n    AAINV = 1.0 / AA;\n\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n    \n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        1.0,\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;    \n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;    \n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);    \n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape.x * 6.0, \n            1.0, (_stack.shape.x>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;    \n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA, 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);    \n\treturn wa * wb; //min(wa,wb);    \n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale/AA;\n}\n\nfloat get_gradient_eps() {\n    return _stack.scale/AA;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o += s;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    add_field(max(dmin.xz, dmin.yw) + length2(dmax));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    add_field(length2(pa - ba.xyxy*h.xxyy));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis; // * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    add_field(vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw)));\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord);\n    \n    paint();\n    \n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsyWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1290, 1421, 1469, 1469, 1665], [1667, 1888, 1960, 1960, 2499], [7156, 7257, 7279, 7279, 7318], [7320, 7320, 7334, 7334, 8484], [8661, 8721, 8748, 8748, 8774], [8776, 8836, 8857, 8857, 8966], [8968, 8968, 9005, 9005, 9091], [9093, 9093, 9139, 9139, 9172], [9174, 9282, 9310, 9310, 9858], [9886, 9886, 9905, 9905, 9938], [9940, 9940, 9958, 9958, 9991], [9993, 9993, 10017, 10017, 10085], [10087, 10087, 10103, 10103, 10124], [10126, 10126, 10153, 10175, 10256], [10258, 10258, 10286, 10286, 10520], [10522, 10522, 10546, 10546, 10626], [10628, 10628, 10655, 10655, 10861], [10863, 10863, 10889, 10889, 11123], [11125, 11125, 11147, 11147, 11273], [11275, 11275, 11296, 11296, 11352], [11354, 11354, 11378, 11378, 11438], [11440, 11440, 11474, 11474, 11498], [11500, 11500, 11514, 11514, 11578], [11580, 11580, 11606, 11606, 11638], [11640, 11640, 11666, 11666, 11687], [11689, 11689, 11713, 11713, 11786], [11788, 11788, 11813, 11813, 11860], [11862, 11862, 11879, 11879, 11923], [11925, 11925, 11948, 11948, 12075], [12077, 12077, 12101, 12101, 12241], [12243, 12243, 12281, 12281, 12419], [12421, 12421, 12458, 12458, 12493], [12495, 12495, 12524, 12524, 12704], [12706, 12706, 12728, 12728, 12792], [12794, 12794, 12807, 12807, 12846], [12848, 12848, 12878, 12878, 12907], [12909, 12909, 12942, 12942, 12987], [12989, 12989, 13015, 13015, 13045], [13047, 13047, 13068, 13068, 13133], [13135, 13135, 13159, 13159, 13242], [13244, 13244, 13259, 13259, 13300], [13302, 13302, 13318, 13318, 13356], [13358, 13358, 13376, 13376, 13433], [13435, 13435, 13465, 13465, 13490], [13492, 13492, 13550, 13550, 13589], [13591, 13591, 13620, 13620, 13656], [13658, 13658, 13706, 13706, 13737], [13739, 13739, 13773, 13773, 13832], [13834, 13834, 13856, 13856, 13902], [13904, 13904, 13931, 13931, 13975], [13977, 13977, 14009, 14009, 14198], [14200, 14200, 14256, 14256, 14299], [14301, 14301, 14331, 14331, 14424], [14425, 14425, 14465, 14465, 14488], [14490, 14490, 14512, 14512, 14563], [14565, 14565, 14597, 14597, 14619], [14621, 14636, 14658, 14658, 14876], [14878, 14878, 14910, 14910, 14932], [14934, 14934, 14953, 14953, 14985], [15034, 15068, 15114, 15114, 15627], [15629, 15698, 15744, 15744, 16264], [16266, 16266, 16299, 16299, 16465], [16467, 16467, 16526, 16526, 16571], [16573, 16573, 16616, 16616, 16677], [16679, 16679, 16721, 16721, 16758], [16760, 16820, 16877, 16877, 16944]]}
{"id": "llSyzK", "name": "Invertible Edges CSG Iterator", "author": "paniq", "description": "implementation for a ray cursor that allows to iterate through all solutions of a series of CSG computations on 1d invertible features. each skip, all computations have to be reperformed. The ray may terminate when a backward facing edge is encountered.", "tags": ["csg", "iteration", "interval", "rules", "invertible"], "likes": 4, "viewed": 670, "published": "Public API", "date": "1509180104", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Invertible Edges CSG Iterator\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// we perform CSG via marching invertible edges.\n\n// row 1-3: (a OR c) OR b\n// row 4-6: !(a OR c) OR !b\n// row 7-9: (a OR c) AND b\n// row 10-12: !(a OR c) AND !b\n// row 13-18: (a OR c) AND !b\n\n// location of nearest feature on right side\n// sign indicates whether we are inside or outside volume\n// positive: outside; negative: inside\n#define Edge float\n\nconst float infinity = 1.0/0.0;\n\n// constructs an edge from a given range and the current ray position\n// ray t must be greater than zero.\nEdge edge_new(vec2 range, float t) {\n    if (range.x > t) {\n    \treturn range.x; \n\t} else if (range.y > t) {\n        return -range.y;\n    } else {\n        return infinity;\n    }\n}\n\nEdge csg_not(Edge x) {\n    return -x;\n}\n\nEdge csg_or(Edge a, Edge b) {\n    return min(a,b);\n}\n\nEdge csg_and(Edge a, Edge b) {\n    return max(a,b);\n}\nEdge csg_andn(Edge a, Edge b) {\n    return -min(a,b);\n}\nEdge csg_orn(Edge a, Edge b) {\n    return -max(a,b);\n}\nEdge csg_and_not(Edge a, Edge b) {\n    return max(a,-b);\n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// source channel for texture font\n#define font_texture_source iChannel1\n// draw a letter with the given texture coordinate\nvoid letter(ivec2 l);\nvoid letter(int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n//////////////////////////////////////////////////////////\n\nvoid draw_ranges(float y, vec2 d, vec2 a, vec2 b, Edge c, float h1, float h2) {\n    rectangle(a.x, y, a.y - a.x, 0.09);\n    set_source_rgba(hsl(h1,0.8,0.8,0.5));\n    fill_preserve(); \n    set_source_rgb(hsl(h1,1.0,0.4));\n\tstroke();\n\trectangle(b.x, y + 0.01, b.y - b.x, 0.07);\n    set_source_rgba(hsl(h2,0.8,0.8,0.5));\n    fill_preserve(); \n    set_source_rgb(hsl(h2,1.0,0.4));\n\tstroke();\n\trectangle(d.x, y + 0.01, d.y - d.x, 0.07);\n    set_source_rgba(hsl((h1 + h2)*0.5,0.8,0.8,0.5));\n    fill_preserve(); \n    set_source_rgb(hsl((h1 + h2)*0.5,1.0,0.4));\n\tstroke();    \n    if (c > 0.0) {\n    \trectangle(c, y + 0.025, 0.1, 0.04);\n        set_source_linear_gradient(vec4(vec3(0.0),1.0), vec4(0.0), vec2(c,0.0), vec2(c+0.1, 0.0));\n\t    fill();\n    } else {\n        c = -c;\n    \trectangle(c - 0.1, y + 0.025, 0.1, 0.04);\n        set_source_linear_gradient(vec4(vec3(0.0),1.0), vec4(0.0), vec2(c,0.0), vec2(c-0.1, 0.0));\n\t    fill();\n    }\n}\n\nvoid paint_hit(float y, float t) {\n    set_source_rgb(vec3(0.0));\n    if (t == infinity) {\n        circle(2.5, y + 0.045, 0.025);\n        stroke();\n    } else {\n    \tcircle(t, y + 0.045, 0.025);\n    \tfill();\n    }\n}\n\nvoid paint() {\n    float t = iTime;\n\n    // clear screen with a subtle gradient\n    set_source_rgb(vec3(1.0));\n    clear();\n    \n    set_line_width_px(1.3);\n\tset_source_rgb(vec3(0.0));\n    \n    translate(-1.2,0.0);\n    \n    float h = 0.11;\n    float y = 1.0 - h;\n    \n    float d = (iMouse.z > 0.5)?get_query().x:abs(sin(t*0.1)*2.0);\n    move_to(d, -1.0);\n    line_to(d, 1.0);\n\tstroke();\n    \n    vec2 r = vec2(0.0,0.5)-0.25 + 0.8;\n    vec2 r3 = r + 1.2;\n#if 0\n#define DRAW_RANGE(OP,H1,H2,R0,R1,R2) draw_ranges(y, R0, R1, R2, OP(edge_new(R1,d), edge_new(R2,d)), H1, H2); y = y - h;\n#else\n#define DRAW_RAY_HIT(OP,R0,R1,R2) { float t = d; for (int i = 0; i < 5; ++i) { float d = OP(csg_or(edge_new(R1,t),edge_new(R0,t)), edge_new(R2,t)); if (d <= 0.0) break; t = d; if (t == infinity) break; } paint_hit(y, t); }\n#define DRAW_RANGE(OP,H1,H2,R0,R1,R2) draw_ranges(y, R0, R1, R2, OP(csg_or(edge_new(R1,d),edge_new(R0,d)), edge_new(R2,d)), H1, H2); DRAW_RAY_HIT(OP,R0,R1,R2); y = y - h;\n#endif\n    DRAW_RANGE(csg_or, 0.0, 0.3, r3, r-0.5,r+0.5);\n    DRAW_RANGE(csg_or, 0.0, 0.3, r3, r-0.1,r+0.1);\n    DRAW_RANGE(csg_or, 0.0, 0.3, r3, r, r*0.6+0.32);\n    DRAW_RANGE(csg_orn, 0.0, 0.3, r3, r*0.6+0.32, r);\n    DRAW_RANGE(csg_orn, 0.0, 0.3, r3, r+0.1,r-0.1);\n    DRAW_RANGE(csg_orn, 0.0, 0.3, r3, r+0.5,r-0.5);\n    DRAW_RANGE(csg_and, 0.6, 0.15, r3, r-0.5,r+0.5);\n    DRAW_RANGE(csg_and, 0.6, 0.15, r3, r-0.1,r+0.1);\n    DRAW_RANGE(csg_and, 0.6, 0.15, r3, r, r*0.6+0.32);\n    DRAW_RANGE(csg_andn, 0.6, 0.15, r3, r*0.6+0.32, r);\n    DRAW_RANGE(csg_andn, 0.6, 0.15, r3, r+0.1,r-0.1);\n    DRAW_RANGE(csg_andn, 0.6, 0.15, r3, r+0.5,r-0.5);\n    DRAW_RANGE(csg_and_not, 0.8, 0.4, r3, r-0.5,r+0.5);\n    DRAW_RANGE(csg_and_not, 0.8, 0.4, r3, r-0.1,r+0.1);\n    DRAW_RANGE(csg_and_not, 0.8, 0.4, r3, r, r*0.6+0.32);\n    DRAW_RANGE(csg_and_not, 0.8, 0.4, r3, r*0.6+0.32, r);\n    DRAW_RANGE(csg_and_not, 0.8, 0.4, r3, r+0.1,r-0.1);\n    DRAW_RANGE(csg_and_not, 0.8, 0.4, r3, r+0.5,r-0.5);    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(int lx, int ly) {\n    letter(ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 604, 640, 640, 783], [785, 785, 807, 807, 824], [826, 826, 855, 855, 878], [880, 880, 910, 910, 933], [934, 934, 965, 965, 989], [990, 990, 1020, 1020, 1044], [1045, 1045, 1079, 1079, 1103], [7069, 7129, 7208, 7208, 8066], [8068, 8068, 8102, 8102, 8283], [8285, 8285, 8299, 8299, 10257], [10434, 10494, 10521, 10521, 10547], [10549, 10609, 10630, 10630, 10737], [10739, 10739, 10776, 10776, 10862], [10864, 10864, 10910, 10910, 10943], [10945, 11083, 11111, 11111, 11571], [11599, 11599, 11618, 11618, 11651], [11653, 11653, 11671, 11671, 11704], [11706, 11706, 11730, 11730, 11834], [11836, 11836, 11853, 11853, 11874], [11876, 11876, 11903, 11925, 12208], [12210, 12210, 12238, 12238, 12472], [12474, 12474, 12498, 12498, 12584], [12586, 12586, 12613, 12613, 12826], [12828, 12828, 12854, 12854, 13082], [13084, 13084, 13106, 13106, 13232], [13234, 13234, 13254, 13254, 13314], [13316, 13316, 13348, 13348, 13375], [13377, 13377, 13398, 13398, 13420], [13422, 13422, 13446, 13446, 13506], [13508, 13508, 13542, 13542, 13566], [13568, 13568, 13582, 13582, 13646], [13648, 13648, 13674, 13674, 13712], [13714, 13714, 13740, 13740, 13761], [13763, 13763, 13786, 13786, 13881], [13883, 13883, 13907, 13907, 13976], [13978, 13978, 14003, 14003, 14050], [14052, 14052, 14069, 14069, 14182], [14184, 14184, 14207, 14207, 14336], [14338, 14338, 14366, 14366, 14494], [14496, 14496, 14520, 14520, 14660], [14662, 14662, 14700, 14700, 14834], [14836, 14836, 14873, 14873, 14908], [14910, 14910, 14937, 14937, 14987], [14989, 14989, 15019, 15019, 15075], [15077, 15077, 15106, 15106, 15287], [15289, 15289, 15311, 15311, 15478], [15480, 15480, 15493, 15493, 15532], [15534, 15534, 15564, 15564, 15593], [15595, 15595, 15628, 15628, 15685], [15687, 15687, 15713, 15713, 15763], [15765, 15765, 15786, 15786, 15851], [15853, 15853, 15877, 15877, 15960], [15962, 15962, 15977, 15977, 16018], [16020, 16020, 16036, 16036, 16074], [16076, 16076, 16094, 16094, 16151], [16153, 16153, 16183, 16205, 16587], [16589, 16589, 16647, 16647, 16685], [16687, 16687, 16716, 16716, 16752], [16754, 16754, 16802, 16802, 16833], [16835, 16835, 16869, 16869, 16928], [16930, 16930, 17007, 17007, 17172], [17174, 17174, 17251, 17251, 17331], [17333, 17333, 17409, 17409, 17525], [17527, 17527, 17603, 17603, 17681], [17683, 17683, 17721, 17721, 17755], [17757, 17757, 17779, 17779, 17825], [17827, 17827, 17854, 17854, 17898], [17900, 17900, 17922, 17922, 18316], [18318, 18318, 18347, 18347, 18375], [18377, 18377, 18426, 18426, 18687], [18689, 18689, 18762, 18762, 18816], [18818, 18818, 18850, 18850, 18886], [18888, 18888, 18944, 18944, 19000], [19002, 19002, 19032, 19032, 19125], [19126, 19126, 19166, 19166, 19189], [19191, 19237, 19276, 19276, 20432], [20434, 20434, 20464, 20464, 20566], [20568, 20568, 20620, 20620, 20660], [20662, 20662, 20684, 20684, 20735], [20737, 20737, 20769, 20769, 20791], [20793, 20808, 20830, 20830, 21122], [21124, 21124, 21156, 21156, 21178], [21180, 21180, 21199, 21199, 21231], [21280, 21343, 21385, 21385, 21451], [21453, 21523, 21574, 21574, 21926], [21928, 21962, 22008, 22008, 22520], [22522, 22591, 22637, 22637, 23143], [23145, 23145, 23178, 23178, 23394], [23396, 23396, 23455, 23455, 23500], [23502, 23502, 23545, 23545, 23606], [23608, 23608, 23650, 23650, 23692], [23694, 23754, 23811, 23811, 24010]]}
{"id": "llXyWs", "name": "Color variations", "author": "lsdlive", "description": "Multiple variation of the same geometry.\n\nBased on the codes I experimented during the sha17a competition.", "tags": ["raymarching"], "likes": 2, "viewed": 116, "published": "Public", "date": "1506947318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Y vec3\n\nvoid mainImage(out vec4 l, in vec2 m)\n{\n\tY v = Y(m / iResolution.xy - .5, -1);\n\tv.x *= 1.7;\n\n\tY p = v - iTime*9., b = Y(.4, -.8, .5);\n\n\tY q;\n\tfloat i = 32., e = 1.;\n\tfor (; .1 < e*i; i--) {\n\n\t\tY q = p;\n\t\tq.xz *= mat2(.3, b);\n\t\tq = abs(mod(q, 10.) - 5.);\n\n\t\tY g = max(q.xyz, q.yzx);\n\t\te = min(min(g.x, g.y), g.z)\n\t\t\t- .5;\n\n\t\tp += v * e;\n\t}\n\n\tfloat numView = 12.;\n\tfloat totalTime = 25.;\n\tfloat timeline = mod(iTime, totalTime);\n\n\tfloat timePerView = totalTime / numView;\n\n\tif (timeline > 0. && timeline < timePerView)\n\t\tl.xyz = -v + e + Y(i / 12.);\n\n\tif (timeline > timePerView && timeline < 2.*timePerView)\n\t\tl.xyz = -sqrt(v) * sqrt(e) + Y(i);\n\n\tif (timeline > 2.*timePerView && timeline < 3.*timePerView)\n\t\tl.xyz = mix(p, -v, i);\n\n\tif (timeline > 3.*timePerView && timeline < 4.*timePerView)\n\t\tl.xyz = Y(i * e*12.);\n\n\tif (timeline > 4.*timePerView && timeline < 5.*timePerView)\n\t\tl.xyz = Y(85.) + p * e;\n\n\tif (timeline > 5.*timePerView && timeline < 6.*timePerView)\n\t\tl.xyz = v * v * i;\n\n\tif (timeline > 6.*timePerView && timeline < 7.*timePerView)\n\t\tl.xyz = v + e + Y(i / 12.);\n\n\tif (timeline > 7.*timePerView && timeline < 8.*timePerView)\n\t\tl.xyz = mix(v, 1. - p, i);\n\n\tif (timeline > 8.*timePerView && timeline < 9.*timePerView)\n\t\tl.xyz = -v * e;\n\n\tif (timeline > 9.*timePerView && timeline < 10.*timePerView)\n\t\tl.xyz = mix(p, b, i);\n\n\tif (timeline > 10.*timePerView && timeline < 11.*timePerView)\n\t\tl.xyz = p * v * i / 6.;\n\n\tif (timeline > 11.*timePerView && timeline < 12.*timePerView)\n\t\tl.xyz = Y(e*e);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 55, 55, 1528]]}
{"id": "lt2cDR", "name": "WavyLine", "author": "nhoughto", "description": "Sinusoidal Line", "tags": ["sinline"], "likes": 0, "viewed": 88, "published": "Public", "date": "1508342607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat frequency = 10.0, epsilon = 0.01, amplitude = 0.4, translation = 0.5, waveSpeed = 2.0;\n\nbool within(float y, float sinX){\n    if(abs(y - sinX) < epsilon){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nvec4 drawLine(vec2 fragCoord){\n    vec4 backGround = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    if(within(uv.y, amplitude * sin(waveSpeed * iTime + frequency * uv.x) + translation)){\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }else{\n      \treturn backGround;   \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = drawLine(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2cDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 128, 128, 223], [225, 225, 255, 255, 525], [527, 527, 584, 584, 620]]}
{"id": "lt2cWh", "name": "Interesting Fractal Generator", "author": "DJDoomz", "description": "Is this method widely known on this website? I don't think I've seen it before, but I haven't been here that long.", "tags": ["fractal"], "likes": 2, "viewed": 499, "published": "Public API", "date": "1508859114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nthis code seems to be wildly chaotic... just modify some of the parameters and see what kind of neat effects you get!\n*/\n\n//main idea from:\n//http://www.pouet.net/topic.php?which=10164\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    \n    vec3 x = vec3(f/iResolution.xy*128.+iTime,0);\n    \n    //float c = (sin(iTime/4.+f.x/64.) + sin(iTime/4.+f.y/64.))/16. + .2 ;\n    \n    float c = .01;\n\t\n    for(int i = 0; i < 24; i++) //mess around w/ number of iterations!\n    {\n        x.y+=x.x;\n        x.y/=2.;\n        \n        if(fract(x.x+x.y) > c)\n        {\n            x.z++;\n            x.x-=2.*sin(iTime/25.); //this is where all the \"movement\" comes from \n            x.z*=2.;\n        }\n        x.x-=x.y;\n    }\n    fragColor = vec4(.5 + .5* cos(6.28*(vec3(2,2,1)*x.z+vec3(1,.333,-.333))) ,0); //don't like this palette, but it works for now\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2cWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 188, 237, 237, 849]]}
{"id": "lt2yDw", "name": "Training for shader showdown ", "author": "lamogui", "description": "Just refreshing memory for Paris Shader Showdow 2 https://www.facebook.com/events/172824569940299/", "tags": ["shader", "showdown"], "likes": 1, "viewed": 175, "published": "Public", "date": "1508867087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.141592\n\nvec2 mat_uv;\n\nfloat sphere(vec3 p)\n{\n    vec3 q = normalize(p);\n    vec2 uv = vec2(atan(q.z, q.x) / (2.0 * PI), acos(q.y) / PI);\n    mat_uv = uv;\n    float d = texture(iChannel0, uv).x;\n    return length(p) - (1.0 + d * 0.1 + 0.1 * sin(p.y * 10. + iTime * 10.0) + 0.1 * cos(10.0 * p.x * p.z + iTime * 10.0));\n}\n\nmat3 rotateX(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3( c, -s, 0.0,\n               \t s, c, 0.0,\n                 0.0 ,0.0 , 1.0);\n}\n\n\nmat3 rotateY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3( s, 0.0, c,\n               \t 0.0, 1.0, 0.0,\n                 c ,0.0 , -s);\n}\n\nvec2 modA(vec2 v, float n)\n{\n    float l = length(v);\n    float a = atan(v.y, v.x);\n    float an = a / n;\n    a = mod(a, an) - an * 0.5;\n    return l * vec2(cos(an), sin(an));\n}\n\n\nfloat map(vec3 p)\n{\n    p = mod(p, vec3(5.0)) - 2.5;\n\t//p.xz = modA(p.xz, 5.0);\n    \n    //p.x -= 2.5;\n    p = rotateY(iTime) * p;   \n    return sphere(p);\n}\n\nvec3 rm(vec3 ro, vec3 rd)\n{\n    vec3 p = ro;\n\tfor (int i = 0; i < 128; ++i)\n    {\n        float d = map(p);\n        if (abs(d) < 0.001 || d > 1000.0)\n            break;\n        p += rd * d * 0.6;\n    }\n    return p;\n}\n\nvec3 grad(vec3 p)\n{\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3( map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -6.0 + iTime * 10.0);\n    vec3 rd = vec3(uv, 0.5 -  length(uv));\n    rd = rotateY(PI * sin(iTime)) * rd; \n    \n    vec3 p = rm(ro, rd);\n    \n    float d = distance(ro, p);\n    vec3 n = grad(p);\n    \n    vec3 color = vec3(exp(-d * 0.1));\n    color *= n * 0.5 + 0.5;\n    //color *= texture(iChannel0, mat_uv).xyz; //* (abs(dot(-n, vec3(0.0, 0.0, 1.0))));\n    \n      \n     p = rm(p + n * 0.01, reflect(rd,n));\n     n = grad(p);\n     color = mix(color, n * 0.5 + 0.5, 0.3);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2yDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 58, 58, 332], [334, 334, 357, 357, 494], [497, 497, 520, 520, 657], [659, 659, 687, 687, 836], [839, 839, 858, 858, 996], [998, 998, 1025, 1025, 1215], [1217, 1217, 1236, 1236, 1463], [1465, 1465, 1522, 1522, 2173]]}
{"id": "ltBcDh", "name": "Hello Shader", "author": "2YY", "description": "My first Shadertoy.", "tags": ["2d"], "likes": 0, "viewed": 83, "published": "Public", "date": "1508339313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv, sin(iTime)*0.5+0.5, 1.0); // sin ã¯ -1ã1 ã ããè²å¤ã¯ 0ã1 ãªã®ã§ãã¹ã±ã¼ã«å¤æãã¦ããã\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBcDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 238]]}
{"id": "ltBczw", "name": "reflection & sparkling 3", "author": "ollj", "description": "Mirrors are micro-mountains! Descartes reflection results from interferences. Huygens:\"any point scatters in every directions\". \nMouse: incident direction. SPACE: show energy vs wavefronts NB: we are monofrequency (i.e. laser), thus sparkle", "tags": ["physics", "optic", "quantumphysics", "huygens", "interferrence"], "likes": 4, "viewed": 1058, "published": "Public API", "date": "1507881254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//parent: https://www.shadertoy.com/view/4sSBRd\n//single pass buffer variant\n//supersampling distance to a surface is a lazy approach.\n\n//uses 2 cos() octaves instead of a noise buffer\n// --- simulating reflection on a micro-relief + sparkling (due to mono-frequency)\n// optimized version of https://www.shadertoy.com/view/4dBBRc\n// relief and phases on it are now precomputed in BufA\n\n// report constants in all buffers\nfloat k = 150.,                                       // wavenumber\n      iterS = 200.; // R.x                                // sampling \n// report constants in all buffers\nfloat z = .03;                                    // relief amplitude\n\n\n#define u5(a) ((a)*.2+.2)\n//#define TT(x)        .1 + z * textureLod(iChannel0,vec2(.5*x,.75),0.).g     // relief\n#define TT(x)      u5(sin(x*7.)+sin(x*13.))*.3+.1\n#define W(P)         k*( dot(P,D) - .1*iTime )                             // incident phase\n\nvec4 mainImage2 (vec2 U ){\n    U*=iResolution.xy;\n    if (U.y >= 1.) return vec4(0);                        // we precompute only a 1D function.\nvec4 O=vec4(0);\n    vec2 D = normalize(vec2(1,-5)), d=vec2(0),\n         R = iResolution.xy,\n         C = vec2(R.x/R.y/2.,.1);                 // pivot for in-out rays\n     \n    if (length(iMouse.xy)>10.) D = -normalize(iMouse.xy-C*R.y); // tune incident direction\n   \n \n    U = -1. + 3.5 *U/R.x; // match exploration loop  for (float x=-1.; x< 2.5;)\n    vec2 P = vec2( U.x, TT(U.x) );\n    O.x = P.y;      // terrain height \n    O.y = W( P );   // phase at each terrain point\n    return O;\n}\n\nvec4 T(float x,float y){ \n    vec2 ass=fract(vec2( (x+1.)/3.5, .5/y) );\n    return mainImage2(ass);\n//texture(iChannel0, fract(vec2( (x+1.)/3.5, .5/y) )) ;\n}\n                          \n\n// precomputed relief+phase\n\n#define W(P)         k*( dot(P,D) - .1*iTime )                             // incident phase\n#define M(P)       ( .7 + .3* cos(k*cross2(U-C,D)) )                       // dashing\n#define cross2(a,b) ( (a).x*(b).y - (b).x*(a).y )\n#define draw(v)      clamp(1.* (v) -0., 0., 1.)                            // draw wave\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.) // keyboard\n\n// --- precompute relief and phases on it ( on a range larger than the window )\n\n\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 d = vec2(0),\n         R = iResolution.xy,\n         C = vec2(R.x/R.y/2.,.1),                     // pivot for in-out rays\n         D = length(iMouse.xy)<10. ? normalize(vec2(1,-5))  // incident direction\n                                   : -normalize(iMouse.xy-C*R.y); // mouse tuning\n\tU /= R.y;\n    O -= O;\n    \n\n    if (U.y < T(U.x,R.y).x) { O ++; return; }             // relief\n    \n    O.g = draw( .7 * cos(W(U)) * M(U) )               // incident wavefronts\n        + smoothstep(2./R.y,.0,abs(cross2(U-C,D)));   // incident direction\n   \n    for (float x=-1.; x< 2.5; x+=1./iterS) {              // sum scattering from each terrain point\n        vec2 P = vec2( x, T(x,R.y).x);\n        float W = T(x,P.y).y,\n              l = length(U-P);\n        d += cos( k*l + W +vec2(0,1.5708) ) * 2.5 / l / iterS; //  * M(P) \n    }\n    O.r =   draw( !keyToggle(32)                      // diffracted wavefronts\n                 ? max(d.x,0.) : length(d));          // wavefront vs amplitude   \n    O.rb += smoothstep(4./R.y,.0,abs(cross2(vec2(2.*C.x-U.x,U.y)-C,D))); // reflected direction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBczw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[693, 925, 951, 951, 1560], [1562, 1562, 1586, 1586, 1719], [2182, 2266, 2304, 2304, 3398]]}
{"id": "ltByRV", "name": "2D Section Experiment", "author": "aiekick", "description": "use mouse to contro;l section", "tags": ["2d", "experiment", "section"], "likes": 2, "viewed": 391, "published": "Public API", "date": "1509192805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on the shader Ellipse - Distance of iq : https://www.shadertoy.com/view/4sS3zz\n\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml\nfloat _mix(float inf, float sup, float ratio)\n{\n\treturn inf * (1.-ratio) + sup * ratio;\n}\n\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml\nfloat _smoothStep(float inf, float sup, float ratio)\n{\n\tfloat t = clamp((ratio - inf) / (sup - inf), 0.0, 1.0);\n    //return t * t * (3.0 - 2.0 * t);\n    return t / t / (4.0 - 2.0 * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y*1.;\n\n    float t = sin(iTime)*.49+.49; // tip by riouxld\n    \n    float n = floor(10. * t);\n    float a = atan( p.y, p.x ) / 3.14159 / 2.0 * n;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float d = length(min(abs(p),0.0) + length(max(abs(p),0.0))) - 0.5 - _smoothStep(m.x,m.y, abs(fract(a)-.5)) * .5;\n   \t\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*abs(d)+iTime*10.);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltByRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 160, 207, 207, 249], [251, 329, 383, 383, 516], [518, 518, 575, 575, 1182]]}
{"id": "ltjcDh", "name": "zoomer bars", "author": "tourgen", "description": "experimenting with step(), timer input, and clamp", "tags": ["2d"], "likes": 1, "viewed": 114, "published": "Public", "date": "1508439307", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float M_PI = acos( -1.0 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float phase = 8.0 * M_PI + 4.0 * sin( iTime * 9.0  + 7.0 * uv.x + 3.0 * uv.y );\n    uv = abs( uv + vec2( -0.5, -0.5 ) );\n    float r = cos( phase * uv.x * M_PI );\n    float t = cos( phase * uv.y * M_PI );\n    float p = clamp( r, 0.2, 0.7 );\n    float q = clamp( t, 0.2, 0.7 );\n    float r_color = max( p, q );\n    float g_color =  step( 0.5, p );\n    float b_color =  step( 0.5, q );\n    \n    fragColor = vec4( r_color, g_color, b_color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjcDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 91, 91, 589]]}
{"id": "ltjczK", "name": "Visual Complex", "author": "rigel", "description": "Just a study on complex functions and a visualisation technique called [url=https://en.wikipedia.org/wiki/Domain_coloring]domain coloring[/url]", "tags": ["2d", "domain", "plane", "complex", "functions", "coloring"], "likes": 21, "viewed": 826, "published": "Public API", "date": "1509395286", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Rigel \n// licence: https://creativecommons.org/licenses/by/4.0/\n// link: https://www.shadertoy.com/view/ltjczK\n\n\n/*\nWhen you graph a real function y=f(x) you need a plane (2D). When you \ngraph a complex function w=f(z), to see the relationship between \nthe input complex plane (2D) and the output complex plane (2D), you need 4D. \nBecause humans are not able to see in 4D one technique to visualize \nthese functions is to use color hue, and saturation as the two extra \ndimensions. This technique is called domain coloring. \nhttps://en.wikipedia.org/wiki/Domain_coloring\n\nIn case you know nothing about complex numbers, or need a refresher\nthis youtube serie is very good !\nhttps://www.youtube.com/watch?v=T647CGsuOVU\n*/\n\n#define speed iTime*.05\n\nvec2 toCarte(vec2 z) { return z.x*vec2(cos(z.y),sin(z.y)); }\nvec2 toPolar(vec2 z) { return vec2(length(z),atan(z.y,z.x)); }\n\n// All the following complex operations are defined for the polar form \n// of a complex number. So, they expect a complex number with the \n// format vec2(radius,theta) -> radius*eË(i*theta).\n// The polar form makes the operations *,/,pow,log very light and simple\n// The price to pay is that +,- become costly :/ \n// So I switch back to cartesian in those cases.\nvec2 zmul(vec2 z1,vec2 z2) { return vec2(z1.x*z2.x,z1.y+z2.y); }\nvec2 zdiv(vec2 z1, vec2 z2) { return vec2(z1.x/z2.x,z1.y-z2.y); }\nvec2 zlog(vec2 z) { return toPolar(vec2(log(z.x),z.y)); }\nvec2 zpow(vec2 z, float n) { return vec2(exp(log(z.x)*n),z.y*n); }\nvec2 zpow(float n, vec2 z) { return vec2(exp(log(n)*z.x*cos(z.y)),log(n)*z.x*sin(z.y)); }\nvec2 zpow(vec2 z1, vec2 z2) { return zpow(exp(1.),zmul(zlog(z1),z2)); }\nvec2 zadd(vec2 z1, vec2 z2) { return toPolar(toCarte(z1) + toCarte(z2)); }\nvec2 zsub(vec2 z1, vec2 z2) { return toPolar(toCarte(z1) - toCarte(z2)); }\n\n//sinz, cosz and tanz came from -> https://www.shadertoy.com/view/Mt2GDV\nvec2 zsin(vec2 z) {\n   z = toCarte(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return toPolar(vec2(sin(z.x)*cosh,cos(z.x)*sinh));\n}\n\nvec2 zcos(vec2 z) {\n   z = toCarte(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return toPolar(vec2(cos(z.x)*cosh,-sin(z.x)*sinh));\n}\n\nvec2 ztan(vec2 z) {\n    z = toCarte(z);\n    float e1 = exp(z.y);\n    float e2 = exp(-z.y);\n    float cosx = cos(z.x);\n    float sinh = (e1 - e2)*0.5;\n    float cosh = (e1 + e2)*0.5;\n    return toPolar(vec2(sin(z.x)*cosx, sinh*cosh)/(cosx*cosx + sinh*sinh));\n}\n\nvec2 zeta(vec2 z) {\n   vec2 sum = vec2(.0);\n   for (int i=1; i<20; i++) \n       sum += toCarte(zpow(float(i),-z));\n   return toPolar(sum);\n}\n\nvec2 lambert(vec2 z) {\n   vec2 sum = vec2(.0);\n   for (int i=1; i<15; i++)\n      sum += toCarte(zdiv(zpow(z,float(i)),zsub(vec2(1.,.0),zpow(z,float(i)))));\n   return toPolar(sum);\n}\n\nvec2 mandelbrot(vec2 z) {\n   vec2 sum = vec2(.0);\n   vec2 zc = toCarte(z);\n   for (int i=1; i<11; i++) \n       sum += toCarte(zpow(toPolar(sum),2.)) + zc;\n   return toPolar(sum);\n}\n\nvec2 julia(vec2 z) {\n    vec2 sum = toCarte(zpow(z,2.));\n    // the julia set is connected if C is in the mandelbrot set and disconnected otherwise\n    // to make it interesting, C is animated on the boundary of the main bulb\n    // the formula for the boundary is 0.5*eË(i*theta) - 0.25*eË(i*2*theta) and came from iq\n    // http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm\n    float theta = fract(speed)*2.*6.2830;\n    vec2 c = toCarte(vec2(0.5,.5*theta)) - toCarte(vec2(0.25,theta)) - vec2(.25,.0);\n    for (int i=0; i<7; i++) sum += toCarte(zpow(toPolar(sum),2.)) + c;\n    return toPolar(sum);\n}\n\nvec2 map(vec2 uv) {\n  \n\tfloat t = floor(mod(speed,10.));\n  \n\t//t = 7.;\n\tfloat s = t == 1.? 4.  : t==5.? .6: t==4.? 6. : t==5.? 2.5 : t== 9. ? 13. : 3.;  \n   \n    uv *= s + s*.2*cos(fract(speed)*6.2830);\n    \n    vec2 fz, z = toPolar(uv); \n    \t\n    \t // z + 1 / z - 1\n\tfz = t == 0. ? zdiv(zadd(z,vec2(1.0)),zsub(z,vec2(1.0,.0)) ) :\n         // formula from wikipedia https://en.m.wikipedia.org/wiki/Complex_analysis\n\t\t // fz = (zË2 - 1)(z + (2-i))Ë2 / zË2 + (2+2i)\n\t\t t == 1. ? zdiv(zmul(zsub(zpow(z,2.),vec2(1.,0)),zpow(zadd(z,toPolar(vec2(2.,-1.))),2.)),zadd(zpow(z,2.),toPolar(vec2(2.,-2.)))) :\n\t\t // z^(3-i) + 1.\n\t\t t == 2. ? zadd(zpow(z,vec2(3.,acos(-1.))),vec2(1.,.0)) :\n\t\t // tan(z^3) / z^2\n\t\t t == 3. ? zdiv(ztan(zpow(z,3.)),zpow(z,2.)) :\n\t\t // tan ( sin (z) )\n\t\t t == 4. ? ztan(zsin(z)) :\n\t\t // sin ( 1 / z )\n\t\t t == 5. ? zsin(zdiv(vec2(1.,.0),z)) :\n\t\t // the usual coloring methods for the mandelbrot show the outside. \n\t\t // this technique allows to see the structure of the inside.\n\t\t t == 6. ? mandelbrot(zsub(z,vec2(1.,.0))) : \n         // the julia set \n\t\t t == 7. ? julia(z) :\n\t\t //https://en.m.wikipedia.org/wiki/Lambert_series\n\t\t t == 8. ? lambert(z) :\n\t\t // this is the Riemman Zeta Function (well, at least part of it... :P)\n\t\t // if you can prove that all the zeros of this function are \n    \t // in the 0.5 + iy line, you will win:\n\t\t // a) a million dollars ! (no, really...)\n\t\t // b) eternal fame and your name will be worshiped in history books\n\t\t // c) you will uncover the deep and misterious connection between PI and the primes\n\t\t // https://en.m.wikipedia.org/wiki/Riemann_hypothesis\n    \t // https://www.youtube.com/watch?v=rGo2hsoJSbo\n         zeta(zadd(z,vec2(8.,.0)));\n   \n \n\treturn toCarte(fz);  \n}\n\nvec3 color(vec2 uv) {\n    float a = atan(uv.y,uv.x);\n    float r = length(uv);\n    \n    vec3 c = .5 * ( cos(a*vec3(2.,2.,1.) + vec3(.0,1.4,.4)) + 1. );\n\n    return c * smoothstep(1.,0.,abs(fract(log(r)-iTime*.1)-.5)) // modulus lines\n             * smoothstep(1.,0.,abs(fract((a*7.)/3.14+(iTime*.1))-.5)) // phase lines\n             * smoothstep(11.,0.,log(r)) // infinity fades to black\n             * smoothstep(.5,.4,abs(fract(speed)-.5)); // scene switch\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t vec2 uv = (fragCoord.xy - iResolution.xy *.5)/iResolution.y;\n     fragColor = vec4( color(map(uv)), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjczK.jpg", "access": "shaders20k", "license": "cc-by-sa-3.0", "functions": [[124, 758, 780, 780, 818], [819, 819, 841, 841, 881], [883, 1247, 1275, 1275, 1311], [1312, 1312, 1341, 1341, 1377], [1378, 1378, 1397, 1397, 1435], [1436, 1436, 1464, 1464, 1502], [1503, 1503, 1531, 1531, 1592], [1593, 1593, 1622, 1622, 1664], [1665, 1665, 1694, 1694, 1739], [1740, 1740, 1769, 1769, 1814], [1816, 1889, 1908, 1908, 2088], [2090, 2090, 2109, 2109, 2290], [2292, 2292, 2311, 2311, 2551], [2553, 2553, 2572, 2572, 2693], [2695, 2695, 2717, 2717, 2876], [2878, 2878, 2903, 2903, 3058], [3060, 3060, 3080, 3080, 3672], [3674, 3674, 3693, 3693, 5410], [5412, 5412, 5433, 5433, 5872], [5874, 5874, 5930, 5930, 6041]]}
{"id": "ltjyDR", "name": "noiseVal13dx Crunch", "author": "ollj", "description": "code golfing fork of\nhttps://www.shadertoy.com/view/XsXfRH\ncould make it easier to swivel-permute the values of noiseVcDx()\n, to a point where it may return a mat4 instead of a vec4,\nthat makes it a \"noise43\" with derivatives?", "tags": ["procedural", "noise", "perlin", "analytic", "automatic", "dervivative", "differentiation"], "likes": 4, "viewed": 438, "published": "Public API", "date": "1508278320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self: https://www.shadertoy.com/view/ltjyDR\n//hash 3d v13 wihth derivatives (iq) \n\n//parent: https://www.shadertoy.com/view/XsXfRH\n\n/*\nComputes the analytic derivatives of a 3D Value Noise. \nThis can be used for example to compute normals to \n3d rocks based on Value Noise \nwithout approximating the gradient via 4* or 6* sampling\nsee: https://www.shadertoy.com/view/XttSz2)\n\nValue    Noise 2D, dx: https://www.shadertoy.com/view/4dXBRH\nGradient Noise 2D, dx: https://www.shadertoy.com/view/XdXBRH\nValue    Noise 3D, dx: https://www.shadertoy.com/view/XsXfRH\nGradient Noise 3D, dx: https://www.shadertoy.com/view/4dffRH\nValue    Noise 2D    : https://www.shadertoy.com/view/lsf3WH\nValue    Noise 3D    : https://www.shadertoy.com/view/4sfGzS\nGradient Noise 2D    : https://www.shadertoy.com/view/XdXGW8\nGradient Noise 3D    : https://www.shadertoy.com/view/Xsl3Dl\nSimplex  Noise 2D    : https://www.shadertoy.com/view/Msf3WH\n*/\n\n//open question; is there any good replacement for hash()\n//especially the one that takes a mat3 and returns a vec3;\n\n // replace this by something better\nfloat hash(vec3 p)\n{p=50.0*fract(p*.3183099+vec3(.71,.113,.419))\n;return fract(p.x*p.y*p.z*(p.x+p.y+p.z))*2.-1.;}\n\n//any better way to mix the above and the below function?\nvec3 hash(mat3 p){return vec3(hash(p[0]),hash(p[1]),hash(p[2]));}\n\n\n// return value noise (cubic sampling) as .x\n//, and analytic 1st_derivatives (difference to nearby x) as .yzw\nvec4 noiseVcDx(vec3 x){vec3 p=floor(x),w=fract(x)   \n#if 1\n ;vec3 u=w*w*w*(w*(w*6.-15.)+10.)// quintic hermite interpolation (3*1*1 binomial)  \n ,n=30.*w*w*(w*(w-2.)+1.)\n//higher degree hermites can have FASTER gradient descents\n//for newer hardware with longer pipelines, with more iterations.\n#else\n ;vec3 u=w*w*(3.-2.*w)//cubic hermite interpolation (2*1 binomial)\n ,n=6.*w*(1.-w)//likely faster on older hardware, with less iterations\n#endif   \n;float a=hash(p+vec3(0))//smallest corner coefficient\n,      h=hash(p+vec3(1))//largest  corner coefficient\n;vec3 b=hash(   mat3(1)+mat3(p,p,p))//3 corners that are adjacent to smallest corner\n,     c=hash(1.-mat3(1)+mat3(p,p,p))//3 corners that are adjacent to largest  corner//8 cube corners\n,k=b-a,l=a-b.xyx-b.yzz+c.zxy,v=((l*u).zxy+k)*u//+9 coefficients in 3 vectors.\n;b-=c;h+=b.x+b.y+b.z-a//modify b to modify h\n;return vec4(a+v.x+v.y+v.z+h*u.x*u.y*u.z, n*(l*u.yzx+l.zxy*u.zxy+h*u.yzx*u.zxy+k) );}\n//automatic differentiation by iq, crunched by ollj.\n\n//===============================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\n        vec4 n = noiseVcDx( 12.0*pos );\n        col = 0.5 + 0.5*((p.x>0.0)?n.yzw:n.xxx);\n\t\t\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\t//fragColor = vec4(col, 1.0 );\n\tfragColor = vec4(1.-col, 1.0 );//inverse universe\n}\n\n/*\n The MIT License\n Copyright Â© 2017 Inigo Quilez\nPermission is hereby granted, free of charge\n, to any person obtaining a copy of this software \nand associated documentation files (the \"Software\")\n, to deal in the Software without restriction\n, including without limitation the rights to use\n, copy, modify, merge, publish, distribute, sublicense\n, and/or sell copies of the Software\n, and to permit persons to whom the Software is furnished to do so\n, subject to the following conditions: \nThe above copyright notice and this permission notice \nshall be included in all copies or substantial portions \nof the Software. THE SOFTWARE IS PROVIDED \"AS IS\"\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED\n, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\n, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT\n. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS \nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY\n, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE\n, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE \nOR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjyDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1050, 1086, 1106, 1106, 1199], [1201, 1259, 1277, 1277, 1324], [1327, 1438, 1461, 1461, 2389], [2444, 2543, 2600, 2600, 3990]]}
{"id": "ltScDh", "name": "Nostaligia", "author": "digorydoo", "description": "This is a very simple demo.", "tags": ["2ddemoscrolltext"], "likes": 3, "viewed": 96, "published": "Public", "date": "1508342230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float grid (vec2 screenPos)\n{\n    float x = mod (screenPos.x - 0.024, 0.2);\n    float y = mod (screenPos.y - 0.024, 0.2);\n    return (x < 0.15 && y < 0.15) ? 1.0 : 0.0;\n}\n\nfloat background (vec2 screenPos, float t)\n{\n    float a = cos (3.0 * screenPos.x + 1.75);\n    float b = sin (3.0 * screenPos.y);\n    float c = cos (a + sin (b + t));\n    float d = sin (b + cos (a + t));\n    float e = 2.0 * cos (4.0 * c + t) * sin (4.0 * d + t);\n    return (c + d) * e * 0.5; //  + 0.1 * grid (screenPos);\n}\n\nvec3 palette (float g)\n{\n    if (g < 0.0)\n    {\n        return vec3 (0.0, 0.0, 0.0);\n    }\n    else if (g < 0.5)\n    {\n        float p = g / 0.5;\n        float q = 1.0 - p;\n        vec3 c1 = vec3 (1.0, 0.5, 0.0);\n        vec3 c2 = vec3 (0.0, 0.0, 1.0);\n        return p * c1 + q * c2;\n    }\n    else\n    {\n        float p = (g - 0.5) / 0.5;\n        float q = 1.0 - p;\n        vec3 c1 = vec3 (0.0, 0.0, 1.0);\n        vec3 c2 = vec3 (0.5, 1.0, 0.0);\n        return p * c1 + q * c2;\n    }\n}\n\nint LETTER_A[7] = int[](6, 9, 9, 15, 9, 9, 9);\nint LETTER_B[7] = int[](14, 9, 9, 14, 9, 9, 14);\nint LETTER_C[7] = int[](7, 8, 8, 8, 8, 8, 7);\nint LETTER_D[7] = int[](14, 9, 9, 9, 9, 9, 14);\nint LETTER_E[7] = int[](15, 8, 8, 14, 8, 8, 15);\nint LETTER_F[7] = int[](15, 8, 8, 14, 8, 8, 8);\nint LETTER_G[7] = int[](7, 8, 8, 11, 9, 9, 7);\nint LETTER_H[7] = int[](9, 9, 9, 15, 9, 9, 9);\nint LETTER_I[7] = int[](2, 0, 0, 6, 2, 2, 15);\nint LETTER_J[7] = int[](15, 1, 1, 1, 2, 2, 12);\nint LETTER_K[7] = int[](9, 10, 12, 12, 10, 9, 9);\nint LETTER_L[7] = int[](8, 8, 8, 8, 8, 8, 15);\nint LETTER_M[7] = int[](9, 15, 9, 9, 9, 9, 9);\nint LETTER_N[7] = int[](9, 13, 11, 9, 9, 9, 9);\nint LETTER_O[7] = int[](6, 9, 9, 9, 9, 9, 6);\nint LETTER_P[7] = int[](14, 9, 9, 14, 8, 8, 8);\nint LETTER_Q[7] = int[](6, 9, 9, 9, 9, 11, 7);\nint LETTER_R[7] = int[](14, 9, 9, 14, 9, 9, 9);\nint LETTER_S[7] = int[](7, 8, 8, 6, 1, 1, 14);\nint LETTER_T[7] = int[](4, 15, 4, 4, 4, 4, 3);\nint LETTER_U[7] = int[](9, 9, 9, 9, 9, 9, 6);\nint LETTER_V[7] = int[](9, 9, 9, 9, 9, 5, 3);\nint LETTER_W[7] = int[](9, 9, 9, 9, 9, 15, 9);\nint LETTER_X[7] = int[](9, 9, 9, 6, 9, 9, 9);\nint LETTER_Y[7] = int[](9, 9, 5, 6, 2, 2, 12);\nint LETTER_Z[7] = int[](15, 1, 2, 6, 4, 8, 15);\n\nfloat letter (vec2 screenPos, int offset, int arr[7])\n{\n    float t = mod (iTime, 26.0);\n    float xoff = 1.4 + 0.19 * float (offset) - 0.4 * t;\n    float x = (screenPos.x - xoff)*7.0;\n    float y = (screenPos.y - 0.03)*7.0;\n    \n    if (x < 0.0 || x >= 1.0 || y < 0.0 || y >= 1.0)\n    {\n        return 0.0;\n    }\n    else\n    {\n        int px = 3 - int (floor (x * 4.0));\n        int py = 6 - int (floor (y * 7.0));\n        int val = arr[py];\n        int bit = (1 << px) & val;\n        return (bit > 0 ? 1.0 : 0.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.y / iResolution.x;\n    screenPos.x /= ratio;\n    screenPos.x -= 0.5 * (iResolution.x - iResolution.y)\n        / iResolution.y;\n    \n    float g =\n        letter (screenPos,  0, LETTER_T) +\n        letter (screenPos,  1, LETTER_H) +\n        letter (screenPos,  2, LETTER_I) +\n        letter (screenPos,  3, LETTER_S) +\n\n        letter (screenPos,  5, LETTER_I) +\n        letter (screenPos,  6, LETTER_S) +\n\n        letter (screenPos,  8, LETTER_A) +\n\n        letter (screenPos, 10, LETTER_V) +\n        letter (screenPos, 11, LETTER_E) +\n        letter (screenPos, 12, LETTER_R) +\n        letter (screenPos, 13, LETTER_Y) +\n\n        letter (screenPos, 15, LETTER_S) +\n        letter (screenPos, 16, LETTER_I) +\n        letter (screenPos, 17, LETTER_M) +\n        letter (screenPos, 18, LETTER_P) +\n        letter (screenPos, 19, LETTER_L) +\n        letter (screenPos, 20, LETTER_E) +\n\n        letter (screenPos, 22, LETTER_D) +\n        letter (screenPos, 23, LETTER_E) +\n        letter (screenPos, 24, LETTER_M) +\n        letter (screenPos, 25, LETTER_O) +\n\n        letter (screenPos, 27, LETTER_F) +\n        letter (screenPos, 28, LETTER_O) +\n        letter (screenPos, 29, LETTER_R) +\n\n        letter (screenPos, 31, LETTER_P) +\n        letter (screenPos, 32, LETTER_U) +\n        letter (screenPos, 33, LETTER_R) +\n        letter (screenPos, 34, LETTER_E) +\n\n        letter (screenPos, 36, LETTER_N) +\n        letter (screenPos, 37, LETTER_O) +\n        letter (screenPos, 38, LETTER_S) +\n        letter (screenPos, 39, LETTER_T) +\n        letter (screenPos, 40, LETTER_A) +\n        letter (screenPos, 41, LETTER_L) +\n        letter (screenPos, 42, LETTER_G) +\n        letter (screenPos, 43, LETTER_I) +\n        letter (screenPos, 44, LETTER_A);\n        \n    vec3 c;\n    \n    if (g > 0.0)\n    {\n        c = vec3 (g, g, g);\n    }\n    else\n    {\n\t    g = background (screenPos, iTime);\n        c = palette (g);\n        c = mix (c, vec3 (\n            0.5 + 0.5 * sin (iTime),\n            0.5 + 0.5 * cos (iTime),\n            0.5),\n        0.5);\n\n        if (screenPos.y < 0.2 || screenPos.y > 0.8)\n        {\n            c.x /= 2.0;\n            c.y /= 2.0;\n            c.z /= 2.0;\n        }\n    }\n    \n    fragColor = vec4 (c, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltScDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 170], [172, 172, 216, 216, 496], [498, 498, 522, 522, 985], [2219, 2219, 2274, 2274, 2743], [2745, 2745, 2802, 2802, 5115]]}
{"id": "ltScDW", "name": "light-blob", "author": "Zoz", "description": "Something i made quickly last night.", "tags": ["2d"], "likes": 3, "viewed": 186, "published": "Public", "date": "1508541831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 C, in vec2 O )\n{\n    vec2 r = iResolution.xy;\n\tvec2 uv = O.xy / r.xy;\n    uv = uv * 2. - 1.; \n    uv.x *= r.x / r.y;\n\n    float a = atan(uv.x, uv.y) + iTime;\n    float d = length(uv) + sin(cos(a * 10.) + a) * .1 + .1;\n    a = iTime;\n    \n    vec3 c = vec3(sin(a), \n                  sin(a*3. + 3.*.2), \n                  sin(a*2.)) * .5 + .5;\n\n    uv.x /= uv.y - 1.11;\n\n\tC = vec4(c / (smoothstep(1., 0., abs(mod(uv.x + .5, 1.)-.5)) * (d*d)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltScDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 473]]}
{"id": "ltSGDG", "name": "Art by Numbers III", "author": "mhnewman", "description": "Inspired by the works of Jackson Pollock", "tags": ["procedural", "art", "pollock", "jackson"], "likes": 22, "viewed": 473, "published": "Public", "date": "1509316755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float duration = 5.0;\nconst float KenBurnsEffect = 1.0;\n\nfloat hash1(float p) {\n    vec3 p3 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash1(vec2 p2, float p) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(float p) {\n    vec3 p3 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat noise1(vec2 p2, float p) {\n    vec2 i = floor(p2);\n    vec2 f = fract(p2);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(hash1(i + vec2(0.0, 0.0), p), \n                               hash1(i + vec2(1.0, 0.0), p), u.x),\n                           mix(hash1(i + vec2(0.0, 1.0), p), \n                               hash1(i + vec2(1.0, 1.0), p), u.x), u.y);\n}\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat fbm1(vec2 p2, float p) {\n    float f = noise1(p2, p); p2 = m * p2;\n    f += 0.5 * noise1(p2, p); p2 = m * p2;\n    f += 0.25 * noise1(p2, p); p2 = m * p2;\n    f += 0.125 * noise1(p2, p); p2 = m * p2;\n    f += 0.0625 * noise1(p2, p); p2 = m * p2;\n    f += 0.03125  * noise1(p2, p);\n    return f / 1.96875 ;\n}\n\n#define range(min, max) mix(min, max, hash1(imageID + (hash += 0.1)))\n#define hsv(hue, sat, val) (val) * (vec3(1.0 - (sat)) + (sat) * (0.5 + 0.5 * cos(6.2831853 * (vec3(hue) + vec3(0.0, 0.33, 0.67)))))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float imageID = floor(iTime / duration);\n    float t = mod(iTime / duration, 1.0);\n    \n    float hash = 0.0;\n    int iter = int(range(5.0, 15.0));\n    float scale = range(2.5, 5.0);\n    float hueBase = range(0.0, 1.0);\n    float huePitch = range(0.1, 0.4);\n    float sat = range(0.4, 0.8);\n    float val = range(0.4, 0.9);\n    float backgroundSat = range(0.2, 0.4);\n    float backgroundVal = range(0.4, 0.8);\n    \n    vec3 a = hsv(hueBase, sat, val);\n    vec3 b = hsv(hueBase + huePitch, sat, val);\n    vec3 c = hsv(hueBase - huePitch, sat, val);\n    \n\tvec2 pos = fragCoord.xy / iResolution.y;\n    pos += 0.2 * KenBurnsEffect * t * (hash2(imageID) - vec2(0.5));\n    pos *= 1.0 + KenBurnsEffect * (t - 0.5) * range(-0.2, 0.2);\n    \n    pos *= scale;\n    vec3 color = hsv(hueBase, backgroundSat, backgroundVal);\n    for (int i = 0; i < iter; ++i) {\n        float id = imageID + 0.05 * float(i);\n        color = mix(color, a, smoothstep(0.02, 0.01, abs(fbm1(pos, id + 0.00))));\n        color = mix(color, b, smoothstep(0.02, 0.01, abs(fbm1(pos, id + 0.01))));\n        color = mix(color, c, smoothstep(0.02, 0.01, abs(fbm1(pos, id + 0.02))));\n        color = mix(color, vec3(1.0), smoothstep(0.02, 0.01, abs(fbm1(pos, id + 0.03))));\n        color = mix(color, vec3(0.0), smoothstep(0.02, 0.01, abs(fbm1(pos, id + 0.04))));\n    }\n   \n    color *= smoothstep(0.0, 0.05, t) * smoothstep(1.0, 0.95, t);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSGDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 85, 85, 217], [219, 219, 250, 250, 396], [398, 398, 419, 419, 554], [556, 556, 588, 588, 937], [990, 990, 1020, 1020, 1302], [1507, 1507, 1562, 1562, 2995]]}
{"id": "ltSyWz", "name": "Gradient Background", "author": "ajlende", "description": "Proof of concept for an animated gradient background", "tags": ["gradient", "animated", "radialgradient"], "likes": 6, "viewed": 322, "published": "Public", "date": "1508192494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n\nstruct RadialGradient\n{\n    float radius;\n    vec4 color;\n    vec2 point;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float w = iResolution.x / 2.;\n    float h = iResolution.y / 2.;\n    \n    float fill = max(iResolution.x, iResolution.y);\n    \n    RadialGradient gradients[] = RadialGradient[](\n\t\tRadialGradient(1.0, vec4(.604,.816,1.00,.7), vec2(0.5 * w * sin(.13 * iTime - 0.44) + w, 0.5 * h * sin(.34 * iTime - 2.41) + h)),\n        RadialGradient(1.0, vec4(.125,.310,.725,.7), vec2(0.5 * w * sin(.93 * iTime - 5.58) + w, 1.0 * h * sin(.82 * iTime - 3.04) + h)),\n        RadialGradient(1.0, vec4(.482,.357,.784,.7), vec2(1.0 * w * sin(.45 * iTime - 2.70) + w, 0.5 * h * sin(.94 * iTime - 5.24) + h)),\n        RadialGradient(1.0, vec4(.580,.702,.988,.7), vec2(1.0 * w * sin(.15 * iTime - 3.59) + w, 1.0 * h * sin(.96 * iTime - 5.11) + h)),\n        RadialGradient(1.0, vec4(.161,.302,.827,.7), vec2(0.5 * w * sin(.35 * iTime - 4.73) + w, 0.5 * h * sin(.42 * iTime - 3.87) + h)),\n        RadialGradient(1.0, vec4(.137,.467,.729,.7), vec2(0.5 * w * sin(.62 * iTime - 4.81) + w, 1.0 * h * sin(.19 * iTime - 1.17) + h)),\n        RadialGradient(1.0, vec4(.114,.686,.925,.7), vec2(1.0 * w * sin(.58 * iTime - 5.13) + w, 0.5 * h * sin(.10 * iTime - 2.08) + h)),\n        RadialGradient(0.5, vec4(.216,.412,.745,.7), vec2(1.5 * w * sin(.12 * iTime - 4.36) + w * 2., 0.5 * h * sin(.08 * iTime - 1.48) + h * 2.)),\n        RadialGradient(0.6, vec4(.616,.792,.992,.7), vec2(1.5 * w * sin(.07 * iTime - 3.94) + w * 2., 0.6 * h * sin(.03 * iTime - 2.03) + h * 2.)),\n        RadialGradient(0.5, vec4(.353,.906,.992,.7), vec2(1.5 * w * sin(.01 * iTime - 3.74) + w * 2., 0.5 * h * sin(.12 * iTime - 0.62) + h * 2.))\n    );\n        \n    vec3 color = vec3(0.);\n        \n    for(int i = 0; i < gradients.length(); ++i)\n    {\n        color = mix(\n            gradients[i].color.rgb,\n            color,\n            gradients[i].color.a * distance(gradients[i].point, fragCoord.xy) / ( fill * gradients[i].radius)\n        );\n    }\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSyWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 219, 219, 2148]]}
{"id": "Ml2cR1", "name": "Equi-Angular Samples", "author": "ollj", "description": "fork of \nhttps://www.shadertoy.com/view/Xdf3zB\nimproved intersectSphere()", "tags": ["raymarching", "media", "homogenous", "equiangular"], "likes": 4, "viewed": 660, "published": "Public API", "date": "1507533079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//ad 3d crepuscular brdf equiangular sampling\n//self  : https://www.shadertoy.com/view/Ml2cR1\n//parent: https://www.shadertoy.com/view/Xdf3zB\n\n// Implementation of equi-angular sampling for raymarching through homogenous media\n// 2013 @sjb3d\n\n#define pi\t\t\t\tacos(-1.)\n#define SIGMA\t\t\t.3\n//this does not count as mutable for loops in old opengl versions?:\n#define iterOcclusion\t(16.*iMouse.y/iResolution.y)\n//todo, try less iterations in peripheral_screenspace fragments.\n//#define iterOcclusion\t(16.)\n#define DIST_MAX\t\t10.\n#define LIGHT_POWER\t\t12.\n#define SURFACE_ALBEDO\t.7\n#define EPS\t\t\t\t.01\n\nfloat hash(float n){return fract(sin(n)*43758.5453123);}\nvoid sampleCamera(vec2 U, vec2 u, out vec3 o, out vec3 t){\n;vec2 filmUv=(U.xy+u)/iResolution.xy\n;float tx=(2.*filmUv.x - 1.0)*(iResolution.x/iResolution.y)\n;float ty=(1.-2.*filmUv.y)\n;float tz=.0\n;o=vec3(0,0,5)\n;t=normalize(vec3(tx,ty,tz)-o);\n}\n\n#define dd(a) dot(a,a)\n\n//return shortest ray-sphere intersection distance and normal.\n//[u]=rayOrigin-sphereCenter\n//[t]=rayDirection\n//[r]=sphereRadius\n//[d]=distance of intersection\n//[n]=normal   of intersection\nvoid intersectSphere(vec3 u,vec3 t,float r,inout float d,inout vec3 n){\n;float a=dd(t),b=2.*dot(u,t),e=dd(u)-r*r,q=b*b-4.*a*e\n;if(q>.0){\n ;float e=.5/a,p=d*.5;vec2 k=vec2(-1,1)*abs(sqrt(q)*e)-b*e\n ;bvec2 a=lessThan(abs(k-p),vec2(p))\n ;     if(a.x)d=k.x\n ;else if(a.y)d=t.y//there are 3 different cases here!!!\n ;if(a.x)n=normalize(u+t*d)\n;}}\n\nvoid intersectScene(vec3 o,vec3 t,inout float r,inout vec3 n){    \n;intersectSphere(o-vec3( .5, .5,.3),t,.3,r,n)\n;intersectSphere(o-vec3( .5,-.5,.3),t,.2,r,n)\n;intersectSphere(o-vec3(-.5, .5,.3),t,.2,r,n)\n;intersectSphere(o-vec3(-.5,-.5,.3),t,.3,r,n)\n;}\n\n\n//[j](i+offset)/iterOcclusion\n//[m]maxDistance\n//[d]accumulator distance \n//[p]accumulator pdf\nvoid sampleScattering(float j,float m,out float d,out float p){\n;float minU=exp(-SIGMA*m) //exp remap u for finite max distance\n;float a=j*(1.-minU)+minU\n;d=-log(a)/SIGMA// sample with pdf proportional to exp(-sig*d)\n;p=SIGMA*a/(1.-minU);}//https://www.shadertoy.com/view/Xdf3zB\n\n//[j](i+offset)/iterOcclusion\n//[m]maxDistance\n//[d]accumulator distance\n//[p]accumulator pdf\n//[u]RayOrigin\n//[t]RayDir\n//[s]LightPos\nvoid sampleEquiAngular(float j,float m,out float d,out float p,vec3 u,vec3 t,vec3 s){\n;float c=dot(s-u,t)//get \"closest point to light along ray\"\n,g=length(u+c*t-s)//distance of [c] to light\n;vec2 h=(vec2(atan(-c/g),atan((m-c)/g)))//get angles of endpoints\n;float e=g*tan(mix(h.x,h.y,j))// get sample\n//looks like slerp(), could be simpler?\n// mixes 2 angles, doing tan(atan()), this must be simpler!\n//looks like a bad coordinate system to do this.\n// possibly convert to polar with vec3(0) at light source!\n;d=c+e\n;p=g/((h.y-h.x)*(g*g+e*e));\n}//https://www.shadertoy.com/view/Xdf3zB\n//[point light case of \"Importance Sampling Techniques for Path Tracing in Participating Media\" by Kulla and Fajardo.]\n\nvoid mainImage( out vec4 o, in vec2 u ){\n;vec3 lightPos=vec3(.8*sin(iTime*7./4.),.8*sin(iTime*5./4.),0)\n;vec3 lightIntensity=vec3(LIGHT_POWER)\n;vec3 surfIntensity =vec3(SURFACE_ALBEDO/pi)\n;vec3 particleIntensity=vec3(1./(4.*pi))\n;vec3 rayOrigin, rayDir\n;sampleCamera(u,vec2(.5),rayOrigin,rayDir)\n;float splitCoord=(iMouse.x==.0)?iResolution.x*.5:iMouse.x;\n;float a=DIST_MAX//diminishing accumulator\n;vec3 n\n;intersectScene(rayOrigin,rayDir,a,n)\n;vec3 surfPos = rayOrigin+a*rayDir\n;vec3 lightVec=lightPos-surfPos\n;vec3 lightDir=normalize(lightVec)\n;vec3 cameraDir=-rayDir    \n    //todo, make subroutine here, must be more optional:\n    //to make it easier to add more lights    \n//BRDF starts around here:\n;float nDotL=dot(n,lightDir)\n;float nDotC=dot(n,cameraDir)\n;if (nDotL*nDotC >.0){;//if(entry and exit are same hemisphere)BRDF\n ;float d=length(lightVec)\n ;float d2=d\n ;vec3 n2\n ;vec3 rayDir = normalize(lightVec)\n ;intersectScene(surfPos + EPS*rayDir, rayDir, d2, n2)\n ;if(d2==d){;//if (not occluded) specularity\n  ;float t=exp(-SIGMA*(d+a))/dot(lightVec,lightVec)\n  ;o.xyz = surfIntensity*lightIntensity*t*abs(nDotL)\n;}}\n;float offset = hash(u.y*iResolution.x + u.x + iTime)\n;for(float i=.0;i<iterOcclusion;++i){;\n ;float v=(i+offset)/iterOcclusion\n ;float x,pdf\n ;if(u.x < splitCoord)sampleScattering (v,a,x,pdf)\n ;else                sampleEquiAngular(v,a,x,pdf,rayOrigin,rayDir,lightPos)\n ;pdf *=iterOcclusion;// adjust for number of ray samples\n // connect to light and check shadow ray\n ;vec3 particlePos=rayOrigin+x*rayDir,lightVec=lightPos-particlePos\n ;float d = length(lightVec),d2=d\n ;vec3 dummy//todo intersectScene without dummy, barely worth it.\n ;intersectScene(particlePos, normalize(lightVec),d2,dummy)\n;if (d2==d){//if (not occluded) crepuscularity\n  ;float t=exp(-SIGMA*(d+x))/dot(lightVec,lightVec)\n  ;o.xyz+=SIGMA*particleIntensity*lightIntensity*t/pdf\n ;}\n;}\n;if (abs(u.x - splitCoord)<1.)o.x = 1.0;// show slider position\n//i improved this one, than reverted it due to an error elsewere\n;o.xyz=pow(o.xyz, vec3(.45));//gamma\n; o.w=1.;\n}\n\n//u,maxDistance,dist,pdf\n//void sampleUniform(float u,float m,out float d,out float p\n//){d=u*m;p=1./m;}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2cR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 593, 613, 613, 649], [650, 650, 708, 708, 894], [920, 1112, 1183, 1183, 1453], [1455, 1455, 1517, 1517, 1708], [1711, 1806, 1869, 1869, 2045], [2086, 2221, 2306, 2306, 2766], [2766, 2926, 2966, 2966, 4990]]}
{"id": "Ml2cRD", "name": "Curve Fitting 2", "author": "twenkid", "description": "A modified version of the shader by Dave_Hoskins - different curve fitting modes are cycling in order to show the differences. More parameters extracted as variables (for blobs/points diameter, line thickness). To be continued.", "tags": ["curvefitting"], "likes": 14, "viewed": 396, "published": "Public", "date": "1507848816", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Modified version of the curve fitting example by Dave_Hoskins:\n//Tags: curvefitting\n//Created by Dave_Hoskins in 2013-Sep-16\n//https://www.shadertoy.com/view/MsXGDj\n//\n//The modified version: Todor Arnaudov, 2017-Oct-12\n//Instead of #defines-s, different curve fitting modes\n//are cycled automatically in order to make the differences apparent.\n\n\n//#define Use_Linear\n//#define Use_Cosine\n//#define Use_Smoothstep\n//#define Use_Cubic\n//#define Use_ThirdOrderSpline\n//#define Use_Catmull_Rom\n\n// The functions use the following format:\n\n// v0----v1--x--v2----v3\n\n// Where 'x' is the fractional diff betweeen v1 and v2.\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n\nint Use_Linear = 0;\nint Use_Cosine =1;\nint Use_Smoothstep = 2;\nint Use_Cubic = 3;\nint Use_ThirdOrderSpline=4;\nint Use_Catmull_Rom=5;\n\nint mode = 0;     //current mode\nint maxmode = 5;  //number of modes\nint divider = 11; //the mode changes on each divider-frame\nfloat blob = 0.033, line = 0.03;\nfloat skew = 8.0, contour = 0.03;\n\n\n#define HASHSCALE .1031\n\n\nfloat Hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------------\nfloat Cubic(float x, float v0,float v1, float v2,float v3) \n{\n\tfloat p = (v3 - v2) - (v0 - v1);\n\treturn p*(x*x*x) + ((v0 - v1) - p)*(x*x) + (v2 - v0)*x + v1;\n}\n\n//--------------------------------------------------------------------------------\nfloat Catmull_Rom(float x, float v0,float v1, float v2,float v3) \n{\n\tfloat c2 = -.5 * v0\t+ 0.5*v2;\n\tfloat c3 = v0\t\t+ -2.5*v1 + 2.0*v2 + -.5*v3;\n\tfloat c4 = -.5 * v0\t+ 1.5*v1 + -1.5*v2 + 0.5*v3;\n\treturn(((c4 * x + c3) * x + c2) * x + v1);\n\t\n//\tOr, the same result with...\n//\tfloat x2 = x  * x;\n//\tfloat x3 = x2 * x;\n//\treturn 0.5 * ( ( 2.0 * v1) + (-v0 + v2) * x +\n//                  (2.0 * v0 - 5.0 *v1 + 4.0 * v2 - v3) * x2 +\n//                  (-v0 + 3.0*v1 - 3.0 *v2 + v3) * x3);\n\n\t\n}\n\n//--------------------------------------------------------------------------------\nfloat ThirdOrderSpline(float x, float L1,float L0, float H0,float H1) \n{\n\treturn \t\t  L0 +.5 *\n\t\t\tx * ( H0-L1 +\n\t\t\tx * ( H0 + L0 * -2.0 +  L1 +\n\t\t\tx * ((H0 - L0)* 9.0\t + (L1 - H1)*3.0 +\n\t\t\tx * ((L0 - H0)* 15.0 + (H1 - L1)*5.0 +\n\t\t\tx * ((H0 - L0)* 6.0\t + (L1 - H1)*2.0 )))));\n}\n\n//--------------------------------------------------------------------------------\nfloat Cosine(float x, float v0, float v1) \n{\n\tx = (1.0-cos(x*3.1415927)) * .5;\n\treturn (v1-v0)*x + v0;\n}\n\n//--------------------------------------------------------------------------------\nfloat Linear(float x, float v0, float v1) \n{\n\treturn (v1-v0)*x + v0;\n}\n\n//--------------------------------------------------------------------------------\nfloat Smoothstep(float x, float v0, float v1) \n{\n\tx = x*x*(3.0-2.0*x);\n\treturn (v1-v0)*x + v0;\n}\n\n//================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; // vec2(0.001, 0.002) ...\n\tuv.x *= iResolution.x/iResolution.y; //aspect ratio\n\t\n\t//float pos = (iTime*.5+uv.x) * 4.0;\n    float pos = (iTime*.5+uv.x) * skew; //10.0;\n    //pos = texture(iChannel0, vec2(floor(pos), 0.0) / iResolution.xy).x;\n    //pos = texture(iChannel0, vec2(uv.x, 0.0) / iResolution.xy).x*100.0;\n    //pos = texture(iChannel0, vec2(uv.x, uv.y)).x*iResolution.x; // / iResolution.xy).x*100.0;\n    //pos = texture(iChannel0, vec2(uv.x, uv.y)/ iResolution.xy).x*200.; // / iResolution.xy).x*100.0;\n    \n\tfloat x  = fract(pos);\n\tfloat v0 = Hash(floor(pos));\n\tfloat v1 = Hash(floor(pos)+1.0);\n\tfloat v2 = Hash(floor(pos)+2.0);\n\tfloat v3 = Hash(floor(pos)+3.0);\n\tfloat f;\n         \n    mode=(iFrame/divider)%maxmode;\n    \n\t/*\n#ifdef Use_Linear\n\tf = Linear(x, v1, v2);\n#elif defined Use_Cosine\n\tf = Cosine(x, v1, v2);\n#elif defined Use_Smoothstep\n\tf = Smoothstep(x, v1, v2);\n#elif defined Use_Cubic\n\tf = Cubic(x, v0, v1, v2, v3);\n#elif defined Use_Catmull_Rom\n\tf = Catmull_Rom(x, v0, v1, v2, v3);\n#elif defined Use_ThirdOrderSpline\n\tf = ThirdOrderSpline(x, v0, v1, v2, v3);\n#endif\n*/\n    switch(mode){\n        case 0: f = Linear(x, v1, v2); break;\n        case 1: f = Cosine(x, v1, v2); break;\n        case 2: f = Smoothstep(x, v1, v2); break;\n        case 3: f = Cubic(x, v0, v1, v2, v3);break;\n        case 4: f = Catmull_Rom(x, v0, v1, v2, v3); break;\n        case 5: f = ThirdOrderSpline(x, v0, v1, v2, v3); break;\n    }\n    \n\n    //line = 0.03, ...\n\t// Blobs...\n\tf = line / abs(f-uv.y); //When f - uv.y is bigger, f gets smaller\n\t//float d =  blob/length((vec2(((uv.x)/9.0*.25), uv.y)-vec2(x+.03, v1)) * vec2(.25,1.0));\n    float d =  blob/length((vec2(((uv.x)/9.0*.25), uv.y)-vec2(x+contour, v1)) * vec2(0.25,1.0));\n    //first half of the blob\n\n\tf = max(f, d*d); //When f is zero, take d and vice-verse\n    \n    \n\t//d = blob/length((vec2(((uv.x)/9.0*.25), uv.y)-vec2(x-.97, v2)) * vec2(.25,1.0));\n    d = blob/length((vec2(((uv.x)/9.0*.25), uv.y)-vec2(x-(1.0-contour), v2)) * vec2(.25,1.0));\n    //second half of the blob\n\tf = max(f, d*d); //When f is zero, take d and vice-verse\n    \n\n    vec3 col = vec3(1.0 - sin(iTime), 0.2 + cos(iTime)/6.0, 0.5 - sin(iTime)/5.0);\n\t//fragColor = vec4(vec3(1.0,.2, .05) * f, 1.0);    \n    fragColor = vec4(col * f, 1.0);\n}", "image_inputs": [{"id": "MlsSzr", "previewfilepath": "https://soundcloud.com/claude-debussy/clair-de-lune", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/claude-debussy/clair-de-lune", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2cRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[876, 1081, 1102, 1102, 1219], [1221, 1304, 1365, 1365, 1463], [1465, 1548, 1615, 1615, 2037], [2039, 2122, 2194, 2194, 2397], [2399, 2482, 2526, 2526, 2586], [2588, 2671, 2715, 2715, 2741], [2743, 2826, 2874, 2874, 2922], [2924, 3007, 3064, 3064, 5385]]}
{"id": "Ml2czm", "name": "spherical voronoise", "author": "mattz", "description": "It's [url]https://www.shadertoy.com/view/Xd23Dh[/url], but on a sphere.", "tags": ["sphere", "voronoise"], "likes": 17, "viewed": 494, "published": "Public", "date": "1508102579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* spherical voronoise, by mattz. \n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n   Use cube-to-sphere projection to do iq's Voronoise on a sphere. See:\n\n     - http://www.iquilezles.org/www/articles/voronoise/voronoise.htm\n     - https://www.shadertoy.com/view/Xd23Dh\n\n   Mouse rotates (or click in bottom left for auto-rotate and demo).\n\n   Keys do things:\n\n\t E - change kernel exponent (when not auto-rotating)\n     R - toggle randomization (when not auto-rotating)\n     P - toggle points\n     W - toggle warp through tangent function\n     C - toggle color/bw\n\n     N,M - change number of points \n\n   Much of the code below could be simplified/optimized. \n\n*/\n\n/* Number of points per edge of the cube face (we will have 6*N^2 points) */\nfloat N = 8.0;\n\n/* Bunch o' settings */\nfloat warp_fraction = 1.0;\nfloat randomize_amount = 1.0;\nfloat enable_color = 1.0;\nfloat enable_points = 1.0;\nfloat voronoi_exp = 1.0;\n\nfloat dot_size = 1.0;\n\n/* Bunch o' other globals. */\nconst float farval = 1e5;\nconst vec3 tgt = vec3(0);\nconst vec3 cpos = vec3(0,0,2.8);\nconst int rayiter = 60;\nconst float dmax = 20.0;\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\nconst float dot_step = 0.005;\n\n/* Magic angle that equalizes projected area of squares on sphere. */\n#define MAGIC_ANGLE 0.868734829276 // radians\n\nfloat warp_theta = MAGIC_ANGLE;\nfloat tan_warp_theta;\n\n\n/* Return a permutation matrix whose first two columns are u and v basis \n   vectors for a cube face, and whose third column indicates which axis \n   (x,y,z) is maximal. */\nmat3 getPT(in vec3 p) {\n\n    vec3 a = abs(p);\n    float c = max(max(a.x, a.y), a.z);    \n\n    vec3 s = c == a.x ? vec3(1.,0,0) : c == a.y ? vec3(0,1.,0) : vec3(0,0,1.);\n\n    s *= sign(dot(p, s));\n    vec3 q = s.yzx;\n    return mat3(cross(q,s), q, s);\n\n}\n\n/* Warp to go cube -> sphere */\nvec2 warp(vec2 x) {\n    return tan(warp_theta*x)/tan_warp_theta;\n}\n\n/* Unwarp to go sphere -> cube */\nvec2 unwarp(vec2 x) {\n    return atan(x*tan_warp_theta)/warp_theta; \n}\n\n/* Return squared great circle distance of two points projected onto sphere. */\nfloat sphereDist2(vec3 a, vec3 b) {\n\t// Fast-ish approximation for acos(dot(normalize(a), normalize(b)))^2\n    return 2.0-2.0*dot(normalize(a),normalize(b));\n}\n\n\n\n/* RGB from hue. */\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n\n/* Get index (0-5) for axis. */\nfloat axisToIdx(vec3 axis) {\n    \n    float idx = dot(abs(axis), vec3(0.0, 2.0, 4.0));\n    if (dot(axis, vec3(1.0)) < 0.0) { idx += 1.0; }\n    \n    return idx;\n    \n}\n\n/* From https://www.shadertoy.com/view/4djSRW */\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nbool wrapCube(in mat3 PT, \n              inout vec2 uvn,\n              out mat3 PTn) {\n    \n    // new uv location might have gone off edge of cube face\n    // ...see if it has by comparing to clamped version\n    vec2 uvn_clamp = clamp(uvn, -1.0, 1.0);\n    vec2 extra = abs(uvn_clamp - uvn);\n\n    // it doesn't make sense to go over both corners so only allow\n    // overflow/underflow in u or v but not both\n    if (min(extra.x, extra.y) > 0.0) {\n        \n        return false;\n        \n    } else {            \n\n        // check if we have gone off starting face\n        float esum = extra.x + extra.y;\n\n        if (esum > 0.0) {\n            // need to re-establish what face we are on\n            vec3 p = PT * vec3(uvn_clamp, 1.0 - esum);\n            PTn = getPT(p);\n            uvn = (p * PTn).xy;\n        } else {\n            // same as starting face\n            PTn = PT;\n        }\n\n        return true;\n        \n    }\n    \n}\n\n\n/* Color the sphere/cube points. */\nvec3 gcolor(vec3 pos) {\n\n    // get permutation matrix \n    mat3 PT = getPT(pos);\n    \n    // project to cube face\n    vec3 cf = pos * PT; \n    \n    // UV is in [-1, 1] range\n    vec2 uv = cf.xy / cf.z; \n    \n    // unwarp from sphere -> cube (approximtion of atan)\n    uv = unwarp(uv);      \n    \n    // for viz only\n    pos /= (dot(pos, PT[2]));\n    \n    // quantize uv of nearest cell\n    vec2 uv_ctr = (floor(0.5*N*uv+0.5) + 0.5)*2.0/N;\n    \n    // for drawing grid lines below\n    vec2 l = abs(mod(uv + 1.0/N, 2.0/N) - 1.0/N)*0.5*N;\n\n    vec3 csum = vec3(0);\n\tfloat wsum = 0.0;\n    \n    float h = mix(2.4, 1.8, warp_fraction) / N;\n    \n    float d1 = 1e5;\n    vec3 p1 = vec3(0);\n\n    // for neighbors in 4x4 neighborhood\n    for (float du=-2.0; du<2.0; ++du) {\n        for (float dv=-2.0; dv<2.0; ++dv) {\n            \n            mat3 PTn;\n            \n            // any time you see 2.0/N it maps from [-1, 1] to [0, N]\n            vec2 uvn = uv_ctr + vec2(du, dv)*2.0/N;\n            \n            if (wrapCube(PT, uvn, PTn)) {\n\n                // now generate a unique id for the cell\n                vec2 ssn = floor((uvn*0.5 + 0.75)*N);\n                float faceid = axisToIdx(PTn[2]);\n                vec3 id = vec3(ssn, faceid);\n                \n                // generate 3 random #'s from id\n                vec3 r = hash33(id);\n                \n                // randomize dot position within cell\n                uvn += (r.xy-0.5)*2.0*(randomize_amount)/N;\n\n                // random material\n                float mn = r.z;\n                \n                // warp cube -> sphere\n                uvn = warp(uvn);\n\n                // can save 1 multiplication over general matrix mult.\n                // because we know last coord is 1\n                vec3 pn = PTn[0]*uvn.x + PTn[1]*uvn.y + PTn[2];\n\n                // update distances if closer\n                float dp = sqrt(sphereDist2(pn, pos));\n                \n                if (dp < d1) {\n                    d1 = dp;\n                    p1 = pn;\n                }\n               \n                float ws = pow(smoothstep(h, 0.0, dp), voronoi_exp);\n\n                csum += ws * mix(vec3(mn), hue(mn), enable_color);\n                wsum += ws;\n\n            }\n            \n        }\n            \n    }\n\n       \n    vec3 c = csum / wsum;\n    \n    c = mix(c, vec3(0), smoothstep(dot_step, 0.0, d1-dot_size)*enable_points);\n    \n    return c;\n\n    \n    \n}\n\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n\n/* Adapted from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm */\nfloat sdCube(vec3 p, float r) {    \n    vec3 d = abs(p) - r;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d,0.0));    \n}\n\n\n\n/* Distance function to scene is a single cube/sphere. */\nvec2 map(in vec3 pos) {\t\n\n    float d = length(pos)-1.0;\n    vec2 rval = vec2(d, 3.0);\n\n    return rval;\n\n}\n\n\n/* IQ's normal calculation. */\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n/* IQ's distance marcher. */\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\n    const float precis = 0.002;   \n    float h=2.0*precis;\n\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;        \n    }    \n\n    if (t > maxd) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n\n\n/* Pretty basic shading function. */\nvec3 shade( in vec3 ro, in vec3 rd ){\n\n    vec2 tm = castRay(ro, rd, dmax);        \n\n    vec3 c;\n\n\n    if (tm.y < 0.0) {\n\n        c = vec3(1.0);\n\n    } else {        \n\n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);\n        \n        \n        vec3 color = gcolor(pos);\n\n        vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * color;\n        vec3 R = 2.0*n*dot(n,L)-L;\n        float spec = 0.3*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n        c = diffamb + spec;\n\n    }\n\n    return c;\n\n}\n\n\n/* Bunch of ASCII keycodes */\nconst float KEY_M = 77.5/256.0;\nconst float KEY_N = 78.5/256.0;\nconst float KEY_P = 80.5/256.0;\nconst float KEY_C = 67.5/256.0;\nconst float KEY_E = 69.5/256.0;\nconst float KEY_R = 82.5/256.0;\nconst float KEY_S = 83.5/256.0;\nconst float KEY_W = 87.5/256.0;\n\n/* Compare key state to default state. */\nfloat keyState(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.75)).x - default_state );\n}\n\n\n/* ...finally! */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float t;\n\n    t = iTime;\n\n    N = pow(2.0, 2.0+keyState(KEY_N, 1.0)+2.0*keyState(KEY_M, 0.0));\n\n    dot_size = 0.18 / N;\n\n    warp_fraction = keyState(KEY_W, 1.0);        \n    randomize_amount = keyState(KEY_R, 1.0);\n    enable_color = keyState(KEY_C, 0.0);\n    enable_points = keyState(KEY_P, 0.0);\n    voronoi_exp = 1.0 + 20.0*keyState(KEY_E, 0.0);\n     \n    // For demonstration, warp_theta varies, but it should just be MAGIC_ANGLE for \"production\" code.\n    warp_theta = max(warp_fraction*MAGIC_ANGLE, 0.001);\n    tan_warp_theta = tan(warp_theta);\n\n  \n    /* Handle mouse motion for rotation. */\n    float thetay = (t-7.0) * 0.1;\n    float thetax = (t-7.0) * 0.05;        \n    \n    vec2 p;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        \n        thetax = (iMouse.y - .5*iResolution.y) * 5.0/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * -10.0/iResolution.x; \n        \n    } else {\n        \n        vec2 p = 0.5 - 0.5*sin( iTime*vec2(1.01,1.71) );\n        randomize_amount = p.y;\n        voronoi_exp = 1.0 + 20.0*pow(p.x, 4.0);\n\n    }\n\n    Rview = mat3(rx,ry,rz)*rotX(thetax)*rotY(thetay);        \n    L = Rview*L;\n\n   \t/* Render. */\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor.xyz = shade(ro, rd);\n\n\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2czm.jpg", "access": "shaders20k", "license": "cc-by-3.0 AND mit", "functions": [[1393, 1566, 1589, 1589, 1819], [1821, 1853, 1872, 1872, 1919], [1921, 1955, 1976, 1976, 2025], [2027, 2107, 2142, 2213, 2266], [2270, 2290, 2309, 2309, 2426], [2429, 2461, 2489, 2489, 2627], [2629, 2725, 2747, 2747, 2857], [2859, 2859, 2945, 3067, 3791], [3794, 3830, 3853, 3885, 6263], [6266, 6292, 6315, 6315, 6436], [6439, 6465, 6488, 6488, 6609], [6612, 6698, 6729, 6729, 6831], [6835, 6893, 6916, 6916, 7000], [7003, 7034, 7066, 7066, 7305], [7308, 7337, 7392, 7392, 7767], [7771, 7808, 7845, 7845, 8317], [8607, 8649, 8697, 8697, 8772], [8775, 8793, 8850, 8850, 10344]]}
{"id": "Ml2czV", "name": "Creepy Smiley", "author": "timeiskey", "description": "more complicated smiley", "tags": ["2d", "soundcloud"], "likes": 1, "viewed": 97, "published": "Public", "date": "1509391656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle( vec2 uv, vec2 pos, float r, float blur )\n{\n\tfloat d = length( pos - uv );\n    float cm = smoothstep( r, r-blur, d );\n    return cm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\tget normalized pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //\tcorrect aspect ratio distortion\n    float ar = iResolution.x / iResolution.y;\n    uv.x *= ar;\n    \n    //\tDRAW\n    vec3 col = vec3( 0.0 );\n    \n    float blr = 0.0042;\n    \n    //\tleft eye\n    float lex = 0.4 * ar;\n    float lem \t= circle( uv, vec2( lex, 0.7 ), 0.1, blr );\t//\twhites\n    float lem2 \t= circle( uv, vec2( lex, 0.6 + sin(iTime * 1.0) * 0.03 ), 0.1, blr );\t//\tlower lid\n    float lem3 \t= circle( uv, vec2( lex, 0.7 + -max( sin(iTime * 1.1) * 0.03, 0.0 ) -0.03), 0.1, blr );\t//\tupper lid\n    float lem4 \t= circle( uv, vec2( lex, 0.65 ), 0.04 + 0.01*sin(iTime), blr );\t//\tpupil\n    //\tcomposite\n    float lec = 0.0;\n    lec += lem3;\n    lec *= lem;\n    lec -= lem2;\n    lec = max( lec, 0.0 );\n    lec += lem4;\n    col += vec3(lec);\n    \n    //\tright eye\n    float rex = 0.6 * ar;\n    float rem \t= circle( uv, vec2( rex, 0.7 ), 0.1, blr );\t//\twhites\n    float rem2 \t= circle( uv, vec2( rex, 0.6 + sin(iTime * 1.0) * 0.03 ), 0.1, blr );\t//\tlower lid\n    float rem3 \t= circle( uv, vec2( rex, 0.7 + -max( sin(iTime * 1.1) * 0.03, 0.0 ) -0.03), 0.1, blr );\t//\tupper lid\n    float rem4 \t= circle( uv, vec2( rex, 0.65 ), 0.04 + 0.01*sin(iTime), blr );\t//\tpupil\n    //\tcomposite\n    float rec = 0.0;\n    rec += rem3;\n    rec *= rem;\n    rec -= rem2;\n    rec = max( rec, 0.0 );\n    rec += rem4;\n    col += vec3(rec);\n    \n    //\tmouth\n\tfloat mx = 0.5 * ar;\n    float mm \t= circle( uv, vec2( mx, 0.4 ), 0.1, blr );\n    float mm2 \t= circle( uv, vec2( mx, 0.5 + sin(iTime * 10.0) * 0.03 ), 0.15, blr );\n    //\tcomposite\n    float mc = 0.0;\n    mc += mm;\n    mc -= mm2;\n    col += vec3(mc);\n    \n    //\tfinal output\n\tfragColor = vec4( col ,1.0);\n}", "image_inputs": [{"id": "lslXDs", "previewfilepath": "https://soundcloud.com/royaltyfreebackgroundmusic/creative-commons-music-movie-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/royaltyfreebackgroundmusic/creative-commons-music-movie-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2czV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 147], [149, 149, 206, 246, 1946]]}
{"id": "Ml2yDw", "name": " Star Nest Fractal MRI 2", "author": "Good", "description": "Experiment with this beautiful, cheap-to-compute fractal.  Inspired by Kali's \"Star Nest\" fork from  Magic Fractal by dgreensp //www.shadertoy.com/view/4ljGDd", "tags": ["fractal"], "likes": 14, "viewed": 308, "published": "Public", "date": "1508869675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAGIC_BOX_ITERS = 12;\nconst float MAGIC_BOX_MAGIC = 0.77;//55;\n\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.288, 0.699, 0.653,\n                    0.069, 0.665, -0.743,\n                    -0.954, 0.260, 0.143);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    // scroll a certain number of screenfuls/second\n    //uv.x += iTime*0.02;\n    \n    float z= iTime*0.05+100.0;    \n    if(iMouse.z>0.){ z += iMouse.x/500.0; }\n\n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.    \n    vec3 p = 0.25*M*vec3(uv, z);\n    \n    float result = magicBox(p);\n    // Scale to taste.  Also consider non-linear mappings.\n    result *= 0.07;\n    float result1 = smoothstep(.4, .51, result);\n    float result2 = smoothstep(.15, .4, result);\n    vec3 c = mix(vec3(.9,.2,.0),vec3(.1,.05,.15), result2);\n    c = mix(c, vec3(0,0,0), result1);\n    fragColor = vec4(c,1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2yDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 74, 98, 273, 855], [857, 1119, 1175, 1253, 2166]]}
{"id": "MlBcD1", "name": "chainception", "author": "abje", "description": "many chains made of chains. [url=https://www.shadertoy.com/user/goneval]My brother[/url]'s idea.", "tags": ["3d", "fractal", "torus"], "likes": 15, "viewed": 503, "published": "Public API", "date": "1508359985", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rotnor(norm) mat2(norm.xy, vec2(-norm.y,norm.x))\n#define rotang(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define pi acos(-1.0)\n#define chains 6.0\n\n#define gammacorrect\n\nfloat torus(vec3 p, float r, float l) {\n    \n    return length(vec2(length(max(abs(p.xy)-vec2(0,l),vec2(0)))-r,p.z));\n}\n\nvec2 torusring(vec3 p) {\n    float len = 1e10;\n    float material;\n    for (float i = 0.0; i < chains; i++) {\n        float i2 = i+iTime;\n        vec2 rot = vec2(cos(i2*pi*2.0/chains),sin(i2*pi*2.0/chains));\n        \n        vec3 p2 = p;\n        p2 = p2 - vec3(rot,0)*3.0;\n        p2.xy*=rotnor(rot);\n        p2.xz*=rotang(i2*pi*0.5);\n        float len2 = torus(p2,0.5,1.5)-0.1;\n        if (len2 < len) {\n            len = len2;\n            material = i;\n        }\n    }\n    return vec2(len,material);\n}\n\nvec2 torusringintorusrings(vec3 p) {\n    vec2 len = vec2(1e10);\n    for (float i = 0.0; i < chains; i++) {\n        float i2 = i+iTime;\n        vec2 rot = vec2(cos(i2*pi*2.0/chains),sin(i2*pi*2.0/chains));\n        \n        vec3 p2 = p;\n        p2 = p2 - vec3(rot,0)*4.0;\n        p2.xy*=rotnor(rot);\n        p2.xz*=rotang(i2*2.0);\n        vec2 len2 = torusring(p2);\n        len2.y += i*chains;\n        if (len.x > len2.x) {\n            len = len2;\n        }\n    }\n    return len;\n}\n\nvec2 map(vec3 p) {\n    vec2 len = torusringintorusrings(p);\n    \n    return len;\n}\n\nvec3 normal(vec3 p) {\n    vec2 eps = vec2(0.01,0.0);\n    \n    return normalize(vec3(\n        map(p+eps.xyy).x-map(p-eps.xyy).x,\n        map(p+eps.yxy).x-map(p-eps.yxy).x,\n        map(p+eps.yyx).x-map(p-eps.yyx).x));\n}\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.131, .130, .1973)\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//shading\nvec4 shade(vec3 p, vec3 d, vec3 objnorm, float depth, float material) {\n    vec3 sun = normalize(vec3(0,0,1));\n    vec3 reflectnorm = reflect(d,objnorm);\n    vec3 color = hash31(material)+0.1;\n    vec4 fragColor = vec4(color*max(0.4,dot(objnorm,-sun)),1.0);\n    fragColor = max(fragColor,(dot(reflectnorm,-sun)-0.9)*12.0);\n    //fragColor = mix(background,fragColor,clamp(3.0-depth*0.05,0.0,1.0));\n    return clamp(fragColor,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0,0,-8);\n    vec3 rd = normalize(vec3(uv,1));\n    float dist = 0.0;\n    \n    bool hit = false;\n    vec2 len;\n    for (int i = 0; i < 100; i++) {\n        len = map(ro);\n        \n        if (len.x < 0.01 || dist > 20.0) {\n            hit = len.x < 0.01;\n            break;\n        }\n        \n        dist += len.x;\n        ro += rd*len.x;\n    }\n    if (hit)\n\tfragColor = shade(ro,rd, normal(ro), dist, len.y);\n    else\n    fragColor = abs(vec4(uv,sin(iTime)*0.5+0.5,1.0))*0.2;\n    \n    #ifdef gammacorrect\n    fragColor = sqrt(fragColor);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBcD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 228, 228, 308], [310, 310, 334, 334, 813], [815, 815, 851, 851, 1294], [1296, 1296, 1314, 1314, 1378], [1380, 1380, 1401, 1401, 1597], [1599, 1712, 1734, 1734, 1852], [1854, 1864, 1935, 1935, 2300], [2302, 2302, 2359, 2359, 2999]]}
{"id": "MlBcz1", "name": "The Long Way Countdown", "author": "Sgw32", "description": "TLW countdown", "tags": ["nixiecountdown"], "likes": 2, "viewed": 474, "published": "Public API", "date": "1507404465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHOW_GRID\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 6.0;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n\n\n\n#define PI\t3.14159265359\n#define SIZE 3.\n\n#define S(t) tan(t.x*0.4+0.7)\n\nfloat hash(in vec3 p)\n{\n\treturn fract(sin(dot(p,vec3(283.6,127.1,311.7))) * 43758.5453);\n}\n\nfloat noise(vec3 p, vec3 fft, vec3 wav){\n\tp.y -= iTime * 2. + 2. * fft.x * fft.y;\n\tp.z += iTime * .4 - fft.z;\n\tp.x += 2. * cos(wav.y);\n\t\n    vec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.-2.*f);\n    \n    vec2 c = vec2(0,1);\n\n    return mix(\n\t\tmix(mix(hash(i + c.xxx), hash(i + c.yxx),f.x),\n\t\t\tmix(hash(i + c.xyx), hash(i + c.yyx),f.x),\n\t\t\tf.y),\n\t\tmix(mix(hash(i + c.xxy), hash(i + c.yxy),f.x),\n\t\t\tmix(hash(i + c.xyy), hash(i + c.yyy),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nfloat fbm(vec3 p, vec3 fft, vec3 wav)\n{\n\treturn .5000 * noise(1. * p, fft, wav) \n\t\t + .2500 * noise(2. * p, fft, wav)\n\t     + .1250 * noise(4. * p, fft, wav)\n\t     + .0625 * noise(8. * p, fft, wav);\n}\n\nfloat rand2(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise2(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand2(b), rand2(b + d.yx), f.x), mix(rand2(b + d.xy), rand2(b + d.yy), f.x), f.y);\n}\n\nfloat fbm2(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 7; i++) {\n        total += noise2(n) * amplitude;\n        n += n;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n//Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\t\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n//Distance to a number\nfloat dfNumber(vec2 origin, float num, vec2 uv)\n{\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 1.0;\n\t\n\tfor(float i = 5.0;i > -1.0;i--)\n\t{\t\n\t\tfloat d = floor(mod(num / pow(10.000001,i),10.));\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+0.9,0.1)*1.1, 0.04,uv));\n\t\t}\n\t\t\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs++;\n\t\t}\t\n\t}\n\treturn dist;\t\n}\n\n//Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n}\n\n\nvec4 tlwnoise(vec2 fragCoord)\n{\n    vec3 fft = vec3(S(vec2(.0,.25)),S(vec2(.5,.25)),S(vec2(1.,.25)));\n\tvec3 wav = vec3(S(vec2(.0,.75)),S(vec2(.5,.75)),S(vec2(1.,.75)));\n\tfloat t  = cos(fft.x * 2. / PI);\n\tfloat ct = cos(t);\n\tfloat st = sin(t);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 vc = (2. * uv - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\t\n\tvc = vec2(vc.x * ct - vc.y * st\n\t\t\t ,vc.y * ct + vc.x * st);\n\n\tvec3 rd = normalize(vec3(.5, vc.x, vc.y));\n\tvec3 c = 2. * vec3(fbm(rd, fft, wav)) * fft.xyz;\n\tc += hash(hash(uv.xyy) * uv.xyx * iTime) * .2;;\n\tc *= .2 * smoothstep(length(uv * .5 - .25), .7, .4);\n\tc = c.xyz*1.;\n    c.x*=2.;\n    c.x*=1.5;\n    c.z*=0.1;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n    // calculate angle of current pixel from origin\n    // atan return values are in [-pi/2, pi/2]\n    // original tutorial uses function atan(p.y, p.x) which gives a horizontal line\n    // in left middle as artefact so i will keep this\n    \n    float a = 0.;\n    if (abs(p.y)<abs(p.x))\n    \ta = acos(p.y/p.x);\n    \n    // distance of point from origin\n    float r = length(p);\n\n    // note that uv are from lower left corner and should be in 0-1\n    // r is in range [0, sqrt(2)]\n    // a is in range [-pi/2, pi/2] so y will be in range [-1/2, 1/2]\n    // 3.1416 = pi\n    // note that texture is mapped twice devided by a horizontal line\n    // spent hours trying to visualize below two line.. no luck ! :-/ :'(\n    uv.x = .2/r; \n    uv.y = a/(3.1416);\n    \n    // add global time for a moving tunnel\n    uv.x = uv.x + iTime/2.0;\n    \n    \n    \n    vec4 col = vec4(0,0,0,1);\n    //vec2 uv = (vec2(atan(p.y,p.x), .2/cc.w))*cc.w;\n   //uv = fragCoord.xy * 1.0 / iResolution.xy;\n   \n    // draw a line, left side is fixed\n    vec2 tq = uv * vec2(2.0,1.0) - iTime*3.0;\n    vec2 t2 = (vec2(1,-1) + uv) * vec2(2.0,1.0) - iTime*3.0; // a second strand\n   \n    // draw the lines,\n//  this make the left side fixed, can be useful\n//  float ycenter = mix( 0.5, 0.25 + 0.25*fbm( t ), uv.x*4.0);\n//    float ycenter2 = mix( 0.5, 0.25 + 0.25*fbm( t2 ), uv.x*4.0);\n    float ycenter = fbm2(tq)*0.5;\n    float ycenter2= fbm2(t2)*0.5;\n\n    // falloff\n    float diff = abs(uv.y - ycenter);\n    float c1 = 0.;\n    c1 = 1.0 - mix(diff*10.0,1.0,0.5);\n   \n    float diff2 = abs(uv.y - ycenter2);\n    float c2 = 1.0 - mix(0.,1.0,diff2*20.0);\n   \n    float c3 = max(c1,c2);\n    if (c3<0.)\n        c3=0.;\n    if (c2<0.)\n        c2=0.;\n    if (c1<0.)\n        c1=0.;\n    \n    col = vec4(c3*0.7,0.4*c3,0.1*c3,1.0); // purple color\n    \n    float time = iTime;\n    time = mod(time, 5.);\n    uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n    \n    \n\tfloat piikit  = 0.5+asin(sin(SIZE*uv.x*6.28))/5.;\n    \n    \n    if (uv.x<(1./(SIZE)))\n    {\n            piikit=0.5;\n    }  \n    \n    \n    if (uv.x>(1.-1./(SIZE)))\n    {\n            piikit=0.5;\n    }    \n    \n    float x1 = uv.x*2.;\n    //float xt = time/10.;\n    float pos = 2.+8.*pow(time,4.);\n   \n    //xx=-pow(xx,2.);\n    \n    //piikit=1.-exp(xx);\n    \n\tfloat flash = 1.;\n                \n\tfloat glow = (flash*0.02)/abs(piikit - uv.y);\n                \n\tcolor = vec3(glow*0.5, glow*0.5, 0);\n\tcolor += vec3(sqrt(glow*0.2));\n    return col + vec4(c,1.)+vec4(color,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - aspect/2.0;\n\t\n\tfloat n = 27.-iDate.z;//+max(0.,0.24-iDate.w/100000.)-1.;\n\t\n\tfloat nsize = numberLength(n);\n\t\n\tvec2 pos = -digitSpacing * vec2(nsize,1.0)/2.0;\n\n\tfloat dist = 1e6;\n\tdist = min(dist, dfNumber(pos, n, uv));\n\t\n\tvec3 color = vec3(0);\n\t\n\tfloat shade = 0.0;\n\t\n\tshade = 0.004 / (dist);\n\t\n\tcolor += vec3(1,0.2,0) * shade;\n    \n    #ifdef SHOW_GRID\n    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n    \n    color *= 0.25+vec3(smoothstep(0.0,64.0 / iResolution.y,grid))*0.75;\n    #endif\n\t\n\tfragColor = tlwnoise(fragCoord)+vec4( color , 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBcz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 265, 288, 288, 355], [357, 357, 397, 397, 822], [824, 824, 863, 863, 1024], [1026, 1026, 1047, 1047, 1116], [1118, 1118, 1140, 1140, 1350], [1352, 1352, 1372, 1372, 1554], [1557, 1587, 1632, 1632, 1810], [1812, 1848, 1900, 1900, 1986], [1988, 2010, 2085, 2085, 2407], [2409, 2444, 2490, 2490, 4758], [4760, 4783, 4832, 4832, 5232], [5234, 5265, 5294, 5294, 5353], [5356, 5356, 5387, 5387, 8604], [8606, 8606, 8664, 8664, 9337]]}
{"id": "MlBczz", "name": "simple grapher", "author": "timeiskey", "description": "it graphs the function implicitly", "tags": ["beginner"], "likes": 0, "viewed": 57, "published": "Public", "date": "1507167511", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159 \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pixelP = fragCoord.xy / iResolution.xy;\n\t\n    vec3 color = vec3( 1.0, 1.0, 1.0 );\n \n    float isNearZeroIfTrue = (pixelP.y * 3.0 - (PI / 2.0)) - sin( pixelP.x * iTime * iTime );\n    \n    color *= smoothstep( 0.0, 0.1, isNearZeroIfTrue );\n \n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBczz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 362]]}
{"id": "MlByDD", "name": "jumping droids", "author": "abje", "description": "droids jumping over a rope. the droids was my brother's idea.", "tags": ["3d", "jump", "droid", "andriod", "sport"], "likes": 6, "viewed": 523, "published": "Public API", "date": "1508604318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rotnor(norm) mat2(norm.xy, vec2(-norm.y,norm.x))\n#define rotang(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define pi acos(-1.0)\n#define chains 3.0\n#define pi acos(-1.0)\n\n#define gammacorrect\n\n//smoothmin function https://www.shadertoy.com/view/Ml3Gz8\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.131, .130, .1973)\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nfloat hash11(float p)\n{\n   float p3 = fract(p * HASHSCALE3.x);\n   p3 += 3.0*p3*(p3+19.19);\n   return fract(2.0*p3*p3); \n}\n\nfloat torus(vec3 p, float r, vec2 l) {\n    \n    return length(vec2(length(max(abs(p.xy)-l,vec2(0)))-r,p.z));\n}\n\nfloat cube(vec3 p, vec3 s) {\n    return length(max(abs(p)-s,vec3(0)));\n}\n\nfloat jumpdroid(vec3 p, float time) {\n    \n    p.y -= 2.5+sin(mod(clamp(time,0.0,1.0)*pi,pi))*3.0;\n    //body\n    float len = cube(p, vec3(0,0.75,0))-1.0;\n    \n    //head\n    len = max(len, max(0.1-abs(p.y-0.75),0.0));\n    vec3 p2 = p-vec3(0,1,0);\n    p2.x = abs(p2.x);\n    p2.xy *= rotang(2.5);\n    p2.y += 1.0;\n    len = min(len, cube(p2,vec3(0,0.2,0))-0.1);\n    \n    //eyes\n    p2 = abs(p-vec3(0,1.15,0))-vec3(0.4,0,0);\n    len = max(len, -length(p2.xy)+0.1);\n    \n    //legs\n    p2 = abs(p-vec3(0,-1.75,0))-vec3(0.5,0,0);\n    len = min(len,cube(p2,vec3(0,0.5,0))-0.25);\n    \n    //arms\n    p2 = p-vec3(0,0.5,0);\n    p2.x = abs(p2.x)-1.4;\n    p2.yz *= rotang(pi*abs(mod(clamp(time*2.0+.5,0.0,2.0)+1.0,2.0)-1.0));\n    p2.y += 0.5;\n    len = min(len,cube(p2,vec3(0,0.5,0))-0.25);\n    return len;\n}\n\nfloat ropedroid(vec3 p, float time) {\n    \n    p.x = abs(p.x)-17.0;\n    p.y -= 2.5;\n    //body\n    float len = cube(p, vec3(0,0.75,0))-1.0;\n    \n    //head\n    len = max(len, max(0.1-abs(p.y-0.75),0.0));\n    vec3 p2 = p-vec3(0,1,0);\n    p2.x = abs(p2.x);\n    p2.xy *= rotang(2.5);\n    p2.y += 1.0;\n    len = min(len, cube(p2,vec3(0,0.2,0))-0.1);\n    \n    //eyes\n    p2 = abs(p-vec3(0,1.15,0))-vec3(0.4,0,0);\n    len = max(len, -length(p2.xy)+0.1);\n    \n    //legs\n    p2 = abs(p-vec3(0,-1.75,0))-vec3(0.5,0,0);\n    len = min(len,cube(p2,vec3(0,0.5,0))-0.25);\n    \n    //arms\n    p2 = p-vec3(1.4,0,0);\n    len = min(len,cube(p2,vec3(0,0.5,0))-0.25);\n    p2 = p-vec3(-1.4,0.4,0);\n    p2.yz *= rotang(time*pi);\n    p2.xy *= rotang(0.5);\n    p2.x += 0.5;\n    len = min(len,cube(p2,vec3(0.5,0.0,0))-0.25);\n    return len;\n}\n\nfloat rope(vec3 p, float time) {\n    p.y -= 2.9;\n    \n    vec2 dir = vec2(cos(time*pi),sin(time*pi));\n    \n    ///the rope shape (too lazy to find out what 15*15 is)\n    float force = (1.0-p.x*p.x/225.0)*5.0;\n    \n    vec2 p2 = dir*(0.4+force);\n    \n    //prevents rope from going in the floor\n    float ground = smin(-p2.x+2.8,0.0,1.0);\n    p2.x += ground;\n    \n    //makes the rope \"drag along the ground\"\n    p2.y -= ground*0.5;\n    \n    return max(length(p.yz+p2)-0.1,abs(p.x)-14.5);\n}\n\nvec2 map(vec3 p) {\n    vec2 len = vec2(1e10,0);\n    \n    vec3 p2 = p + vec3(2,0,0);\n    float person = clamp(floor(p2.x*0.25),-2.0,2.0);\n    p2.x = p2.x - person*4.0-2.0;\n    float time = mod(iTime+hash11(person+floor(iTime*0.5))*0.2,2.0)-1.0;\n    len.x = jumpdroid(p2,time)*0.8;\n    len.y = 4.0;\n    \n    float len2 = ropedroid(p,-iTime-0.55);\n    if (len2 < len.x) {\n        len.x = len2;\n        len.y = 4.0;\n    }\n    \n    len2 = rope(p,-iTime-0.55)*0.7;\n    if (len2 < len.x) {\n        len.x = len2;\n        len.y = 4.2;\n    }\n    return len;\n}\n\nvec3 normal(vec3 p, float len) {\n    vec2 eps = vec2(0.001,0.0);\n    \n    return normalize(vec3(\n        len-map(p-eps.xyy).x,\n        len-map(p-eps.yxy).x,\n        len-map(p-eps.yyx).x));\n}\n\n//shading\nvec4 shade(vec3 p, vec3 d, vec3 objnorm, float depth, float material) {\n    vec3 sun = normalize(vec3(1,1,-1));\n    vec3 reflectnorm = reflect(d,objnorm);\n    vec3 color = hash31(material)+0.1;\n    vec4 fragColor = vec4(color*max(0.4,dot(objnorm,sun)),1.0);\n    fragColor = max(fragColor,(dot(reflectnorm,sun)-0.95)*20.0);\n    //fragColor = mix(background,fragColor,clamp(3.0-depth*0.05,0.0,1.0));\n    return clamp(fragColor,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 cam = vec3(0,3,-14);\n    vec3 ro = cam;\n    vec3 rd = normalize(vec3(uv,1));\n    float dist = 0.0;\n    \n    bool hit = false;\n    vec2 len;\n    for (int i = 0; i < 100; i++) {\n        len = map(ro);\n        \n        if (len.x < 0.01 || dist > 30.0) {\n            hit = len.x < 0.01;\n            break;\n        }\n        \n        dist += len.x;\n        ro += rd*len.x;\n    }\n    if (hit) {\n\t\tfragColor = shade(ro,rd, normal(ro, len.x), dist, len.y);\n    } else {\n        //ray-plane intersection if the raymarching ray doesen't hit\n        float len = (-cam.y/min(rd.y,-0.00001));\n        ro = cam+rd*len;\n        if (len < 1000.0) {//cheap distance field shadowing and texture\n        \tfragColor = texture(iChannel0,ro.xz*0.2)*min(map(ro).x,1.0);\n            return;\n    \t} else {//background if ray-plane intersection doesn't hit\n        \tfragColor = abs(vec4(uv,sin(iTime)*0.5+0.5,1.0))*0.2;\n        }\n    }\n    #ifdef gammacorrect\n    fragColor = sqrt(fragColor);\n    #endif\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlByDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 270, 309, 309, 400], [402, 515, 537, 537, 655], [656, 656, 679, 679, 777], [779, 779, 817, 817, 889], [891, 891, 919, 919, 963], [965, 965, 1002, 1002, 1763], [1765, 1765, 1802, 1802, 2583], [2585, 2585, 2617, 2617, 3074], [3076, 3076, 3094, 3094, 3625], [3627, 3627, 3659, 3659, 3817], [3819, 3829, 3900, 3900, 4265], [4267, 4267, 4324, 4324, 5384]]}
{"id": "MlByRw", "name": "Fast Growing Circle", "author": "Jaxi", "description": "Fast Growing Circle", "tags": ["eclipse"], "likes": 0, "viewed": 75, "published": "Public", "date": "1508104145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the background color to a dark blue using RGB\n    vec3 backgroundColor = vec3(0.25, 0.33, 0.70);\n\n\n    // Define the resolution of the circle\n\tvec2 coordinates = (fragCoord.xy-iResolution.xy*0.9) / iResolution.y;\n    \n    // Define the circle color to a light blue circle using RGB\n    vec3 color = vec3(0.20, 0.83, 0.88);\n    // Define an extra color \n    vec3 extraColor = vec3(0.20, 0.1, 0.88);\n \n    // Define The time the circle takes to finish a cycle\n    float circleTime = fract(iTime*0.99);\n    \n    float cirlceLength = length(coordinates);\n    \n    float thickness = 0.01;\n    \n    float res = 1.0/iResolution.y;\n    \n    color = color * ((smoothstep(circleTime+thickness+res, circleTime+thickness, cirlceLength))); \n    \n    // Set the fragColor using the defined colors above\n    fragColor = vec4(color + backgroundColor + extraColor,  1);\n\n\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlByRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 117, 929]]}
{"id": "MlByz3", "name": "integration: golden ratio", "author": "hornet", "description": "redoing the results of https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\nleft to right: WhiteNoise -> InterleaveGradientNoise -> bad-bluenoise\ntop is the pattern\nmid is average of N patterns\nbottom is using the golden ratio", "tags": ["noise"], "likes": 8, "viewed": 475, "published": "Public", "date": "1509487390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\n// (see also https://www.graphics.rwth-aachen.de/media/papers/jgt.pdf )\nconst float gr = (1.0 + sqrt(5.0)) / 2.0;\nfloat GoldenRatioMultiple( int multiple )\n{\n    return float(multiple) * gr;\n}\n\n//note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\n//note: returns [-intensity;intensity[, magnitude of 2x intensity\n//note: from \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n//      http://advances.realtimerendering.com/s2014/index.html\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\nfloat ScreenSpaceDither( vec2 vScreenPos )\n{\n\t// Iestyn's RGB dither (7 asm instructions) from Portal 2 X360, slightly modified for VR\n\t//vec3 vDither = vec3( dot( vec2( 171.0, 231.0 ), vScreenPos.xy + iTime ) );\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy );\n    return fract( vDither / 91.111 );\n    //vDither.rgb = fract( vDither.rgb / vec3( 103.0, 71.0, 97.0 ) );\n    //return vDither.rgb / 255.0; //note: looks better without 0.375...\n\n    //note: not sure why the 0.5-offset is there...\n    //vDither.rgb = fract( vDither.rgb / vec3( 103.0, 71.0, 97.0 ) ) - vec3( 0.5, 0.5, 0.5 );\n\t//return (vDither.rgb / 255.0) * 0.375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    int idx = int( floor( 3.0 * uv.x ) + 3.0*floor( 3.0 * uv.y ) );\n\n    const int NUM_SAMPLES = 16;\n\tconst float RCP_NUM_SAMPLES_F = 1.0  / float(NUM_SAMPLES);\n\n    float sum = 0.0;\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        if ( idx == 6 )\n        {\n            sum = hash12n( uv + float(iFrame-i) );\n        }\n        if ( idx == 3 )\n        {\n            float rnd = hash12n( uv + float(iFrame-i) );\n            sum += RCP_NUM_SAMPLES_F * rnd;\n        }\n        else if ( idx == 0 )\n        {\n            float rnd = hash12n( uv );\n            \n            float grm = GoldenRatioMultiple( iFrame - i );\n            rnd = fract( rnd + grm );\n            \n            sum += RCP_NUM_SAMPLES_F * rnd;\n        }\n        else if ( idx == 8 )\n        {\n            //note: see https://www.shadertoy.com/view/4sGSDd\n            vec2 fc = fragCoord.xy;\n            fc += vec2(ivec2(1321,1327)*(iFrame-i));\n            vec2 p = fc/iChannelResolution[0].xy;\n            float s0 = texture( iChannel0, p, 0.0).r;\n            float s1 = texture( iChannel0, p, 1.0).r;\n            float rnd = s0 - s1 + 0.5;\n            \n            sum = rnd;\n        }\n        else if ( idx == 5 )\n        {\n            vec2 fc = fragCoord.xy;\n            fc += vec2(ivec2(1321,1327)*(iFrame-i));\n            vec2 p = fc/iChannelResolution[0].xy;\n            float s0 = texture( iChannel0, p, 0.0).r;\n            float s1 = texture( iChannel0, p, 1.0).r;\n            float rnd = s0 - s1 + 0.5;\n            \n            sum += RCP_NUM_SAMPLES_F*rnd;\n        }\n        else if ( idx == 2 )\n        {\n            vec2 fc = fragCoord.xy;\n            vec2 p = fc/iChannelResolution[0].xy;\n            float s0 = texture( iChannel0, p, 0.0).r;\n            float s1 = texture( iChannel0, p, 1.0).r;\n            float rnd = s0 - s1 + 0.5;\n            \n            float grm = GoldenRatioMultiple(iFrame-i);\n            rnd = fract(rnd + grm);\n            \n            sum += RCP_NUM_SAMPLES_F*rnd;\n        }\n        else if ( idx == 7 )\n        {\n            vec2 fc = fragCoord.xy;\n            fc += vec2(-11.0,7.0)*vec2(iFrame-i); //TODO: entirely empirical and likely terrible offset...\n            sum = InterleavedGradientNoise( fc );\n\t\t\t//sum = ScreenSpaceDither( fc );\n        }\n        else if ( idx == 4 )\n        {\n            vec2 fc = fragCoord.xy;\n            fc += vec2(-11.0,7.0)*vec2(iFrame-i); //TODO: entirely empirical and likely terrible offset...\n            \n            float ign = InterleavedGradientNoise( fc );\n            //float ign = ScreenSpaceDither( fc );\n            \n            sum += RCP_NUM_SAMPLES_F * ign;\n        }\n        else if ( idx == 1 )\n        {\n            vec2 fc = fragCoord.xy;\n            //fc += vec2(-11.0,7.0)*vec2(iFrame-i); //TODO: entirely empirical and likely terrible offset...\n            \n            float ign = InterleavedGradientNoise( fc );\n            //float ign = ScreenSpaceDither( fc );\n            \n            float grm = GoldenRatioMultiple(iFrame-i);\n            ign = fract(ign + grm);\n            \n            sum += RCP_NUM_SAMPLES_F*ign;\n        }\n    }\n    \n    fragColor = vec4( vec3(sum), 1.0 );\n    \n    //lines\n    fragColor *= step( 6.0/iResolution.x, 1.0-abs(2.0*fract(3.0*uv.x)-1.0));\n    fragColor *= 0.75+0.25*(step( 5.0/iResolution.y, 1.0-abs(2.0*fract(3.0*uv.y)-1.0)));\n\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlByz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 196, 239, 239, 274], [276, 307, 330, 330, 458], [460, 670, 713, 713, 842], [844, 844, 888, 1056, 1490], [1492, 1492, 1549, 1549, 4936]]}
{"id": "MljcDR", "name": "Study beginner - 02", "author": "woodorl", "description": "Studying Shader", "tags": ["study"], "likes": 4, "viewed": 165, "published": "Public", "date": "1508285474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle (vec2 uv, vec2 p, float r, float blur) {\n    \n    float d = length(uv - p);\n    float c = smoothstep(r, r - blur, d);\n    \n    return c;\n}\n\nfloat Band (float t, float start, float end, float blur){\n\tfloat step1 = smoothstep (start - blur, start + blur, t);\n    float step2 = smoothstep (end + blur, end - blur, t);\n    \n   \treturn step1 * step2;\n}\n\nfloat Rect (vec2 uv, float left, float right, float bottom, float top, float blur) {\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1 * band2;\n}\n\nfloat Smiley (vec2 uv, vec2 p, float size) {\n    uv -= p;\t// translating coordinate system\n    uv /= size; // scaling coordinate system\n    \n    float mask = Circle(uv, vec2(0.), .4, .01);\n    \n    mask -= Circle(uv, vec2(-.08, .08), .05, .01);\n    mask -= Circle(uv, vec2(.08, .08), .05, .01);\n    \n    float mouth = Circle(uv, vec2(0.), .3, .01);\n    mouth -= Circle(uv, vec2(0., 0.1), .33, .01);\n    \n    mask -= mouth;\n    \n    return mask;\n}\n\nfloat remap01 (float a, float b, float t) {\n    return (t-a) / (b-a);\n}\n\nfloat remap (float a, float b, float c, float d, float t) {\n    return remap01 (a, b, t) * (d-c) + c;\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime;\n    \n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n\tfloat mask = 0.;\n    \n    float x = uv.x;\n    \n    //float m = (x-.5)*(x+.5);\n    float m = sin(t + x * 8.) * .1;\n    float y = uv.y - m;\n    \n    float blur = remap(-.5, .5, .01, .25, x);\n    blur = pow(blur * 4., 3.);\n        \n    mask = Rect(vec2(x, y), -.6, .6, -.1, .1, blur);\n    \n    col = vec3(0.6, 0.9, 0.7) * mask;\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljcDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 151], [153, 153, 210, 210, 360], [362, 362, 446, 446, 577], [579, 579, 623, 623, 1025], [1027, 1027, 1070, 1070, 1098], [1100, 1100, 1159, 1159, 1203], [1205, 1205, 1263, 1263, 1785]]}
{"id": "MlSczR", "name": "Worley Fractal Noise", "author": "alexsaen", "description": "worley noise test", "tags": ["noise", "worley"], "likes": 6, "viewed": 551, "published": "Public API", "date": "1507132598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n) {\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nvec2 hash2(vec2 n) {\n \treturn vec2(hash(n.x*23.62-300.0+n.y*34.35),hash(n.x*45.13+256.0+n.y*38.89)); \n}\n\nfloat worley(vec2 c, float time) {\n    float dis = 1.0;\n    for(int x = -1; x <= 1; x++)\n        for(int y = -1; y <= 1; y++){\n            vec2 p = floor(c)+vec2(x,y);\n            vec2 a = hash2(p) * time;\n            vec2 rnd = 0.5+sin(a)*0.5;\n            float d = length(rnd+vec2(x,y)-fract(c));\n            dis = min(dis, d);\n        }\n    return dis;\n}\n\nfloat worley5(vec2 c, float time) {\n    float w = 0.0;\n    float a = 0.5;\n    for (int i = 0; i<5; i++) {\n        w += worley(c, time)*a;\n        c*=2.0;\n        time*=2.0;\n        a*=0.5;\n    }\n    return w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dis = worley5(fragCoord.xy/64.0, iTime);\n    vec3 c = mix(vec3(1.0,0.95,0.5), vec3(0.7,0.0,0.0), dis);\n    fragColor = vec4(c*c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSczR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 60], [62, 62, 82, 82, 165], [167, 167, 201, 201, 524], [526, 526, 561, 561, 736], [738, 738, 795, 795, 942]]}
{"id": "MlSczW", "name": "Bad milk", "author": "canyin", "description": "Modified example from The Book of Shaders", "tags": ["2d"], "likes": 1, "viewed": 62, "published": "Public", "date": "1507811971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec2 Reso = vec2(iResolution.x, iResolution.y);\n\tvec2 st = gl_FragCoord.xy/Reso;\n    float pct = 0.0;\n     \n    float toCenter = distance(st,vec2(sin(iTime*0.9)+1.0,cos(iTime*0.9)+1.0)/2.0) * distance\n\n(st,vec2(cos(iTime*0.9)+1.0,(sin(iTime*0.9)+1.0))/2.0);\n\n     pct = smoothstep(pct, length(toCenter), abs((sin(iTime) + sin( (iTime - -0.19) / 0.37 ) * \n\n0.52 + -0.22))/5.0);\n\n\n    vec3 color = vec3(pow(1.0-pct,.1), sqrt(1.0-pct), pow(1.0-pct+.4,.9));\n\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSczW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 553]]}
{"id": "MlSyDh", "name": "Soft Storm", "author": "leon", "description": "Quick sketch made in 30 minutes. Training for Shader Showdown", "tags": ["storm"], "likes": 7, "viewed": 229, "published": "Public", "date": "1508331197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define STEPS 1./100.\n#define VOLUME_BIAS 0.01\n#define MIN_DIST 0.01\n#define STEP_DAMPING .3\n#define PI 3.14159\n#define TAU PI*2.\n#define red vec3(1.,.2,.1)\n#define orange vec3(0.972, 0.682, 0.227)\n\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\n\nfloat amod (inout vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an/2.;\n    float c = floor(a/an);\n    a = mod(a,an)-an/2.;\n    p.xy = vec2(cos(a),sin(a))*length(p);\n    return c;\n}\n\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\n\nfloat smin (float a, float b, float r) {\n    float h = clamp(.5+.5*(b-a)/r, 0., 1.);\n    return mix(b,a,h)-r*h*(1.-h);\n}\n\nfloat map (vec3 pos) {\n    float scene = 1000.;\n    float dist = length(pos)*.5;\n    dist -= iTime;\n    pos.xz *= rot(dist);\n    pos.yz *= rot(dist*.7);\n    pos.xy *= rot(dist*.5);\n    amod(pos.xz, 4.);\n    pos.x = repeat(pos.x, 1.);\n    pos.y = repeat(pos.y, 2.);\n    scene = min(scene, sdSphere(pos, .25));\n    return scene;\n}\n\nvec3 getNormal (vec3 p) {\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                          map(p+e.yxy)-map(p-e.yxy),\n                          map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvec3 applyCamera (vec3 p) {\n    float t = iTime*.3;\n    p.xz *= rot(t);\n    p.xy *= rot(t*.7);\n    p.yz *= rot(t*.5);\n    return p;\n}\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n\tvec2 uv = (coord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 eye = applyCamera(vec3(uv, -10.));\n    vec3 ray = applyCamera(normalize(vec3(uv, 1.)));\n    \n    vec3 pos = eye;\n    float shade = 0.;\n    for (float i = 0.; i <= 1.; i += STEPS) {\n        float dist = map(pos);\n        if (dist < VOLUME_BIAS) {\n            shade = 1.-i;\n            break;\n        }\n        dist *= STEP_DAMPING + .1 * rng(uv+fract(iTime));\n        dist = max(MIN_DIST, dist);\n        pos += dist * ray;\n    }\n    vec3 normal = getNormal(pos);\n\tcolor = vec4(1);\n    color.rgb = mix(orange, red, dot(normal, vec3(0,0,1))*.5+.5);\n    color.rgb *= shade;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSyDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 223, 223, 290], [291, 291, 311, 311, 361], [362, 362, 396, 396, 418], [419, 419, 455, 455, 477], [479, 479, 519, 519, 690], [692, 692, 725, 725, 749], [751, 751, 791, 791, 871], [873, 873, 895, 895, 1201], [1203, 1203, 1228, 1228, 1419], [1421, 1421, 1448, 1448, 1554], [1556, 1556, 1605, 1605, 2241]]}
{"id": "Mt2cDh", "name": "STExos 1) Line Affine Equation", "author": "ttoinou", "description": "First Shadertoy exercise : compute the distance to a line with two sides using affine equations", "tags": ["stexos"], "likes": 1, "viewed": 79, "published": "Public", "date": "1508442761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(\n    out vec4 color, // in [0,1]^4\n    in vec2 coord   // in [0,iResolution.xy[\n) {\n    float zoom = (cos(iTime*3.)+2.)*10.;// > 0\n    float signedDistLinePixels; // > 0, unit is pixels\n    // algebraic distance, we keep the side info by not using abs()\n    \n    // Exo 1 ax+by+c=0\n    \n    // Method a\n    float a = iMouse.x-40.;\n    float b = -iMouse.y+120.;\n    float c = 140.;\n    \n    // distance to the line defined by (ax+by+c=0)\n    // unit is pixel\n    signedDistLinePixels = (a*coord.x + b*coord.y + c)/sqrt(a*a + b*b);\n    \n    // Method b :\n    // could also be written like this in homogeneous coordinates\n    // + using GLSL special instructions\n    vec3 xy1 = vec3(coord,1.);\n    vec3 abc = vec3(a,b,c);\n    signedDistLinePixels =\n         dot(xy1,abc) // vector dot product\n       / length( // vector Euclidean norm\n           abc.xy  // or vec2(a,b)\n    );\n    \n\tcolor.rgb = mix( // 1-linear interpolation in 3D\n          vec3(1.) // white\n        , signedDistLinePixels < 0. ? vec3(1.,.0,.0) : vec3(.0,.0,1.) // red or blue\n        , clamp( // here the coeff for the interpolation\n            pow(\n                abs( // removing the side info\n                    signedDistLinePixels/iResolution.x // removing the pixels units\n                   *zoom) // make the line thinner or bigger\n              , iMouse.z > .5 ? 1.5 : 1. // smoother gradient when mouse pressed\n            )\n          ,0.,1.) // minimax to put the value in [0,1]\n                  // and not have values others than mix of red white blue\n                  // not mandatory, just a protection\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2cDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 98, 98, 1610]]}
{"id": "Mt2czK", "name": "DLL-Portal Matrices", "author": "ollj", "description": " Matrix deformed portals as bijective Doubly-Linked-Lists\n\nfork of\nhttps://www.shadertoy.com/view/XtjcRV\nfew minor clean ups.\nstretched portals to stress test intersecting portals.", "tags": ["phong", "intersection", "mirror", "portal", "bijection", "lanbert"], "likes": 2, "viewed": 508, "published": "Public API", "date": "1509397824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//sign 3d portals rotating doubly linked shadows \n//self  : https://www.shadertoy.com/view/Mt2czK\n//parent: https://www.shadertoy.com/view/XtjcRV\n\n//use buffers, here only for \"space\" keyboard input.\n#define doBuffer\n#define KEY_SPACE (vec2 (32.5,.5)/256.)\n\n//ichannel0 is for keyboard input\n//, while space, move camera to center fror hall of pirrots position.\n\n//max view distance. (loses its meaning where portals make space noneuclidean)\n#define maxdist 100.\n//iterations trough space between portals\n#define iterRm 200.\n//iterations trough portals (max number of portals trough portals)\n#define iterTp 20\n\n//ollj made all 3 epsilons smaller by *=.1\n//this, fits the small scale of the set better.\n//this also required more [iterRm]\n//epsilon raymarch\n#define epsRm .001\n//epsilon for normal, derivative\n#define epsDx .001\n//epsilon shadows\n#define epsShad .01\n\n//simple lazy fov; 1=parallel projection ; 0=180deg;  \n#define fov .5\n\n//Do intro where the camera drops down, +1exp() to camera movement.\n//#define doCameraDrop\n\n#define portalThickness (cos(iTime)*.1+.1)\n\n//glossyness\n#define scalePhong .2\n\n//background color, sky color or microwave background (scatter max)\n#define cCMB vec4(.3,.5,1,1)\n\n#define lightdir normalize(vec3(-1,1,.5))\n#define lightintensity 1.5\n#define dark vec3(.2,.4,.4)\n#define floorheight -1.5\n\n/*\ni stretched portal scale to test the coonstrains of:\n- more obvious portal scaling distortion \n- - portals are still lipschitz continuous, just not classically euclidean.\n- portals intersecting each other\n- one portal intersecting a solid (the floor)\n- hit space and have the camera be inside the object with the portal on it.\n- - camera close to portal should tepeport the camera RAYS instantly.\n- - even though the camera is static, only its rays are not.\n\n\nCurrently objects to not teleport trough portals\n, they just intersect portals.\nBUT:\nAny object that exists on 2 sides of a portal (crossing a portal)\n is essentially bounding-volume-hierarchy-split in 2 seperate objects\n  for as long as its volume intersects the portal.\n A volume that only tangentially touches the portal is excluded here.\n\ninstead of 2 intersecting objects, a portal face cuts 1 object in 2.\n\nSuch a split object may then have 2 densities and velocities\n on both sides of a portal, to remain continuity along the portal.\nSuch a split object is likely matrix deformed on one side.\n it is no longer a simple shape, but highly deformed.\n\nThis also accounts for portals that exist on 2 sides of a portal\n due to intersecting portals\n To be resolved with a BVH?\n - portal cuts tend to be hierarchical recursive iterations.\n - you would traverse a tree hierarchy to check distances to all cut sub-objects.\n\n\nthere should be a simpler way to do this.\nA portal-relativity, where the portal is considdered static.\n but all else moves relative to the portal.\nYou imagine the world from the POW of a portal.\nthen you either do;\n- Some type of lotenz- transform between portals, keeping all portals relative to another\n- a [portal bounding hierarchy] of portals.\n\ntodo\n, needs quaternion rotation\n, and all the stuff you can extend portals with\n, including a movable camera that gets teleported.\n*/\n\n//material g-buffer enum\n#define background 0.\n#define mPortal1 1.\n#define mPortal2 2.\n#define mFrame 3.\n#define mFloor 4.\n#define mGeometry 5.\n\n#define pi0 6.28318530718\n#define pi  acos(-1.)\n#define pi2 acos(0.)\n\n\nfloat suv(vec2 a){return a.x+a.y;}\nfloat suv(vec3 a){return dot(a,vec3(1));}//dot()can be faster than 2add.\nfloat mav(vec2 a){return max(a.x,a.y);}\nfloat mav(vec3 a){return max(max(a.x,a.y),a.z);}\n\n//dir and up should be a vec4 quaternion instead!\n//not just for performance, but aslso to avoid gimbal locking\nstruct PortalFrame {\n    vec3 c;\n    vec3 dir;\n    vec3 up;\n    vec2 dims;\n}p1, p2;//i am not a fan of global structs here.\n//but portals\n//,that make space noneuclidean are a reasonable exception for nor\n\nfloat boxsdf(vec3 u,vec3 e, out vec3 o){\n e*=.5;o=u/mav(e);return mav(vec3(abs(u)-e));}\n\nfloat cylindersdf(vec3 u,float r,float h,out vec3 o){\n o=u/max(r,h);return max(length(u.xz)-r,max(-u.y,u.y-h));}\n\nvec2 portalsdf(vec3 u,PortalFrame p, out vec3 a){\n vec3 r=u-p.c;\n vec3 w=normalize(cross(p.dir,p.up));\n vec3 v=cross(w,p.dir);\n //above dual crossproduct rotation is slower than quaternion rotation.\n    //but for small angles, this is the fallback of quaternion rotation anyways.\n a=vec3(dot(r,w),dot(r,v),dot(r,p.dir));\n p.dims=p.dims/2.;\n float d=mav(vec3(abs(a.z)-portalThickness*.5,abs(a.xy)-p.dims.xy-portalThickness));\n // float y=all(lessThan(abs(a.xy), p.dims.xy))?portalmat1:mFrame;\n return vec2(d,all(lessThan(abs(a.xy), p.dims.xy))?mPortal1:mFrame);}\n\n//if(distance is smaller than previous) also write textureID\nvoid bgw(inout vec2 d,inout vec3 p,vec3 q,float h,float m){\n if(h<d.x){d=vec2(h,m);p=q;}}\nvoid bgw(inout vec2 d,inout vec3 p,vec3 q,float h){\n bgw(d,p,q,h,mGeometry);}//bgw==buffer-g-write ==write objectID.\n\n//p* and q* are \"portal target bijectuive-switcheroo coordinates.\n//distance field gradient\nvec2 dg(vec3 u,out vec3 p){\n vec3 q1,q2;//potals are structs that will tell you their \"exit coordinates\"\n vec2 d,d1=portalsdf(u,p1,q1),d2=portalsdf(u,p2,q2);\n if(d1.x<d2.x){d=d1;p=q1;\n }else        {p=q2;d=vec2(d2.x, d2.y < 2.5?mPortal2:mFrame);}\n bgw(d,p,u,max(u.y-floorheight,length(u.xz)-10.),mFloor);//floor\n bgw(d,p,u,length(u-vec3(2,0,0))-.8);//sphere, radius of 8\n bgw(d,p,u,cylindersdf(u-vec3(-0.3, -1.5, 0.), 0.1, 1.5, q1));//cylinder\n bgw(d,p,u,boxsdf(u-vec3(0,-.5,-3),vec3(.4,1.7,.4),q1));//box\n bgw(d,p,u,boxsdf(u-vec3(0,-1,3),vec3(5.,.5,.9),q1));//box\n return d;}//.y is a materialID g-buffer\n\n//sphere tracking, raymarching, linear gradient descent\n//i guess for portals you need it to be this explicit\nvec2 gd(vec3 u, vec3 t, out vec3 o) {\n float a=0.;//accumulated distance traveled\n vec2 g=dg(u,o);//gradient at u, save travel sphere.\n for(float i=.0;i<iterRm;i++){\n  a+=g.x;\n  g=dg(u+a*t,o);\n  if(abs(g.x)<epsRm){return vec2(a,g.y);//hit a surface\n  }else if(g.x>maxdist)break;//too far from camera\n }return vec2(maxdist,background);}//not hit anything\n//having o store the position along the ray is infficient.\n//it accumulates more precision loss than it gains.\n\nvec3 normal(vec3 u){vec3 c;vec2 e=vec2(epsDx,0);return normalize(vec3\n(dg(u+e.xyy,c).x-dg(u-e.xyy,c).x\n,dg(u+e.yxy,c).x-dg(u-e.yxy,c).x\n,dg(u+e.yyx,c).x-dg(u-e.yyx,c).x));}\n\nvec2 shaderay(vec3 u,vec3 t,float h) {//origin,dirction,hardness\n vec3 c,n=normal(u);\n vec2 ds=gd(u+epsShad*lightdir,lightdir,c);\n float l=max(0.,dot(n,lightdir))*lightintensity;//lambert\n l*=sign(.5-ds.y)*.5+.5;//l=ds.y<.5?l:0.;    \n float p=pow(max(0.,dot(normalize(lightdir-t),n)),h);//phong\n return vec2(l,p*scalePhong);}\n\n\n//for abstraction and development\n//, texturing patterns are their own functions\nvec3 portalBorderColor(vec3 c){c=step(mod(c,.5),vec3(.25));\n return mix(vec3(.2),vec3(.2,.7,.6),abs(abs(\n #if 0\n  c.x+c.y)+c.z));}//pattern ollj\n #else\n  c.x-c.y)-c.z));}//pattern original\n #endif\n//return checkerboard pattern of point c\nvec3 yellowObjects(vec3 c){c=step(mod(c,.5),vec3(.25));return mix//pattern scaling\n(vec3(1.,.7, .2)//sun-yellow (scatter low)\n,vec3(.4,.8,.4) //leaf-green (scatter medium)\n,abs(abs(c.x-c.z)-c.y));}//3d checkerboard pattern\nvec3 ground(vec3 c){c=step(mod(c,1.),vec3(.25));return mix\n(vec3(.6)\n,vec3(.7)\n//,abs(c.x-c.z));}//2d ground pattern original\n,abs(c.x)-c.z);}//2d ground pattern ollj\n\n//teleport th point trough a portal\nvec4 tp(inout vec3 e,inout vec3 t,inout vec3 c,vec4 o,inout PortalFrame p1,inout PortalFrame p2){\n   vec3 u=normalize(cross(p1.dir,p1.up));\n   vec3 v=cross(u,p1.dir);\n   float x=dot(t,u),y=dot(t,v),z=dot(t,p1.dir);\n   u=normalize(cross(p2.dir, p2.up));\n   v=cross(u,p2.dir);\n   vec2 s=p2.dims/p1.dims;//portal scaling\n   t=normalize(x*u*s.x \n              +y*v*s.y\n              +z*p2.dir);//teleport ray direction\n    //above and below doesnt simplify, because u and v are vec3, .\n   e=p2.c\n    +c.x*u*s.x \n    +c.y*v*s.y \n    -c.z*p2.dir \n    +2.*epsRm*t;//teleport camera position\n return o;}//debug error output color\n//for [max portal levels] or for [disabled portal entrance]\n//given that this calculates the differential between 2 rotations\n//, tp()  begs for quaternions.\n\n#define sc(a) vec2(sin(a),cos(a))\n\nvoid mainImage( out vec4 o, in vec2 fragCoord ){o=vec4(1);\n #ifdef doBuffer\n  float s=texture(iChannel0,KEY_SPACE).r;\n #else\n  float s=0.;\n #endif\n                               \n vec2 aa=sc(clamp(iMouse.y/iResolution.y-.5,-.15,1.)*pi2);\n vec2 cph=sc((iMouse.x/iResolution.x-.35)*pi0)*aa.y;     \n vec3 e=(.01+5.*(1.-s))*vec3(cph.x,aa.x\n       #ifdef doCameraDrop\n        +2.*exp(-iTime)\n       #endif\n       ,cph.y);//camera rotation\n vec3 w=normalize(-e);\n e+=vec3(-.3,.05,0);//eye position, relevant for \"distance to eye\"\n vec3 u=normalize(cross(w,vec3(0,1,0)));\n vec3 v=cross(u,w);\n vec3 t=normalize(fov*w\n                 +(fragCoord.x/iResolution.x-.5)*u\n                  +(fragCoord.y/iResolution.x-.5*iResolution.y/iResolution.x)*v);\n //I have seen worse [camera to ray] functions.\n                         \n float ts=(sin(iTime*.2)+1.)*pi;\n p1=PortalFrame(vec3(0)//center\n               ,normalize(vec3(1,.1*cos(iTime*2.)*sin(ts),.0))//forward\n               ,vec3(0,1,.2*sin(iTime*2.)*cos(ts))//up\n               ,vec2(2,3.+cos(ts*.5)));//scale\n p2=PortalFrame(vec3(-1.5,0,0)//center\n               ,vec3(sc(ts),0).yzx//forward\n               ,vec3(0,1,0)//up\n               ,vec2(3,2));//scale\n //above swivels the parameters of 2 \"portals\"\n // That would mbe much simpler with a quaternion.    \n                                                \n for(int i=0;i<iterTp;i++){\n  vec3 c;//stores position along ray\n  vec2 d=gd(e,t,c);\n  if(d.y<.5){o=cCMB;break;//cBackground\n  }else if(d.y<1.5){o=tp(e,t,c,vec4(.2,.8,1,1),p1,p2);//cPortal1\n  //break;//disable cyan-blue portal entrance\n }else if(d.y<2.5){o=tp(e,t,c,vec4(.8,.2,1,1),p2,p1);//cPortal2   \n  //break;//disable magenta-pink portal entrance \n }else if(d.y<3.5){//cPortalBorder\n  float s=shaderay(e+d.x*t,t,1.).x;\n  o.xyz=max(dark.b,s)*portalBorderColor(c);\n  break;//hit surface\n }else if(d.y<4.5){//floor\n   vec2 s=shaderay(e+d.x*t,t,10.);\n   o=vec4(max(dark.b,s.x)*ground(c)+s.y,1);\n   break;//hit surface\n  }else{//yellow checkered objects       \n  vec2 s=shaderay(e+d.x*t,t,5.4);\n   o.xyz=max(dark.b,s.x)*yellowObjects(c)+s.y;\n  }\n }}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2czK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3201, 3417, 3435, 3435, 3451], [3452, 3452, 3470, 3470, 3493], [3493, 3525, 3543, 3543, 3564], [3565, 3565, 3583, 3583, 3613], [3810, 3933, 3973, 3973, 4020], [4022, 4022, 4075, 4075, 4134], [4136, 4136, 4185, 4185, 4697], [4699, 4760, 4819, 4819, 4849], [4850, 4850, 4901, 4901, 4927], [4968, 5060, 5087, 5087, 5636], [5667, 5777, 5814, 5814, 6112], [6112, 6243, 6263, 6263, 6415], [6417, 6417, 6455, 6481, 6742], [6745, 6826, 6857, 6857, 6956], [7023, 7064, 7091, 7091, 7261], [7261, 7287, 7307, 7307, 7429], [7455, 7491, 7588, 7588, 8086], [8086, 8307, 8355, 8355, 10412]]}
{"id": "Mt2yDD", "name": "Procedural football stadium", "author": "PrzemyslawZaworski", "description": "Who would like to play football with me ? \nSoundcloud track: official UEFA Champions League theme song", "tags": ["procedural", "raymarching", "noise", "hash", "football", "soccer", "sport", "stadium"], "likes": 9, "viewed": 446, "published": "Public", "date": "1508696965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shader code:\n// The MIT License https://opensource.org/licenses/MIT\n// Copyright Â© 2017 Przemyslaw Zaworski\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmat3 rotationX( float x) \n{\n\treturn mat3\n\t(\n\t\t1.0,0.0,0.0,\n\t\t0.0,cos(x),sin(x),\n\t\t0.0,-sin(x),cos(x)\n\t);\n}\n\nmat3 rotationY( float y) \n{\n\treturn mat3\n\t(\n\t\tcos(y),0.0,-sin(y),\n\t\t0.0,1.0,0.0,\n\t\tsin(y),0.0,cos(y)\n\t);\n}\n\nmat3 rotationZ( float y) \n{\n\treturn mat3\n\t(\n\t\tcos(y),sin(y),0.0,\n\t\t-sin(y),cos(y),0.0,\n        0.0,0.0,1.0\n\t);\n}\n\nfloat hash (vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414)))*43758.5453);\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)), dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nvec3 sky (vec3 p) \n{\n\tp.y = max(p.y,0.0);\n    float k = 1.0-p.y;\n\treturn vec3(pow(k,20.0), pow(k,3.0), 0.3+k*0.2);\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat map_audience (vec3 p)\n{\n\tvec2 u = floor(p.xz*0.6);\n\tfloat h = hash(u);\n\th = p.y - 0.1*length(p.xz)*pow(h,sin(iTime*h*20.0)+2.0); ;\n\treturn max( min( h, 0.4), p.y-0.1*length(p.xz));\n}\n\nfloat map_cage (vec3 p)\n{\n\tfloat a =  capsule(p,vec3(-52.5,0,-3.6), vec3(-52.5,3.7,-3.6), 0.2  );\n    float b =  capsule(p,vec3(-52.5,0,3.6), vec3(-52.5,3.7,3.6), 0.2  );\n    float c =  capsule(p,vec3(-52.5,3.7,-3.6), vec3(-52.5,3.7,3.6), 0.2  );\n\tfloat d =  capsule(p,vec3(52.5,0,-3.6), vec3(52.5,3.7,-3.6), 0.2  );\n    float e =  capsule(p,vec3(52.5,0,3.6), vec3(52.5,3.7,3.6), 0.2  );\n    float f =  capsule(p,vec3(52.5,3.7,-3.6), vec3(52.5,3.7,3.6), 0.2  );    \n    return min(a,min(b,min(c,min(d,min(e,f)))));\n}\n\nfloat map (vec3 p)\n{\n \tvec2 u = floor(p.xz*20.0);\n\tfloat h = hash(u);\n\th = p.y - 1.0 * h ;\n   \tif (p.x<55.5 && p.x>-55.5 && p.z<37.0 && p.z>-37.0) return min(max( min( h, 0.1), p.y-1.0 ),map_cage(p));\n\telse return map_audience(p);\n}\n\t\t\t\nvec4 color (vec3 ro)\n{\n\tfloat m = ro.y;\n\tvec4 light_grass = vec4(0.2,m*0.8,0.05,1);\n    vec4 dark_grass = vec4(0.2,m*0.65,0.05,1);\n\tvec4 line1 = vec4 (0.9);\n    vec3 d = hash3(floor(ro.xz*0.6));\n    if (ro.x>=55.5 || ro.x<=-55.5 || ro.z>=37.0 || ro.z<=-37.0) return vec4(d,1);\n    if (ro.x<0.15 && ro.x>-0.15 && ro.z>-34.0 && ro.z<34.0 ) return line1;\n    if (length(ro.xz)<9.0 && length(ro.xz)>8.7) return line1;\n    if (ro.x>52.2 && ro.x<52.5 && ro.z>-34.0 && ro.z<34.0 ) return line1;\n    if (ro.x<-52.2 && ro.x>-52.5 && ro.z>-34.0 && ro.z<34.0 ) return line1;\n    if (ro.z>33.7 && ro.z<34.0 && ro.x>-52.2 && ro.x<52.5) return line1;\n    if (ro.z<-33.7 && ro.z>-34.0  && ro.x>-52.2 && ro.x<52.5) return line1; \n    \n\tif (ro.x>-36.15 && ro.x<-35.85 && ro.z<20.0 && ro.z>-20.0 ) return line1;\n\tif (ro.x>-52.5 && ro.x<-36.15 && ro.z<20.15 && ro.z>19.85) return line1;\n\tif (ro.x>-52.5 && ro.x<-36.15 && ro.z>-20.15 && ro.z<-19.85) return line1;    \n\tif (ro.x>-47.15 && ro.x<-46.85 && ro.z<10.0 && ro.z>-10.0 ) return line1;\n\tif (ro.x>-52.5 && ro.x<-47.15 && ro.z<10.15 && ro.z>9.85) return line1;\n\tif (ro.x>-52.5 && ro.x<-47.15 && ro.z>-10.15 && ro.z<-9.85) return line1;\n    if (length(ro.xz+vec2(40.0,0.0))<9.0 && length(ro.xz+vec2(40.0,0.0))>8.7 && ro.x>-36.0) return line1;\n \n\tif (ro.x<36.15 && ro.x>35.85 && ro.z<20.0 && ro.z>-20.0 ) return line1;\n\tif (ro.x<52.5 && ro.x>36.15 && ro.z<20.15 && ro.z>19.85) return line1;\n\tif (ro.x<52.5 && ro.x>36.15 && ro.z>-20.15 && ro.z<-19.85) return line1;    \n\tif (ro.x<47.15 && ro.x>46.85 && ro.z<10.0 && ro.z>-10.0 ) return line1;\n\tif (ro.x<52.5 && ro.x>47.15 && ro.z<10.15 && ro.z>9.85) return line1;\n\tif (ro.x<52.5 && ro.x>47.15 && ro.z>-10.15 && ro.z<-9.85) return line1;\n    if (length(ro.xz-vec2(40.0,0.0))<9.0 && length(ro.xz-vec2(40.0,0.0))>8.7 && ro.x<36.0) return line1;\n  \n    if (length(ro.xz+vec2(52.5,34.0))<3.0 && length(ro.xz+vec2(52.5,34.0))>2.7 && ro.x>-52.5 && ro.z>-34.0) return line1;\n    if (length(ro.xz-vec2(52.5,34.0))<3.0 && length(ro.xz-vec2(52.5,34.0))>2.7 && ro.x<52.5 && ro.z<34.0) return line1;\n    if (length(ro.xz+vec2(52.5,-34.0))<3.0 && length(ro.xz+vec2(52.5,-34.0))>2.7 && ro.x>-52.5 && ro.z<34.0) return line1;\n    if (length(ro.xz+vec2(-52.5,34.0))<3.0 && length(ro.xz+vec2(-52.5,34.0))>2.7 && ro.x<52.5 && ro.z>-34.0) return line1;\n    \n    if (mod(ro.x,10.0)<5.0) return dark_grass;\n\n\telse return light_grass;\n}\n\t\t\t\nvec4 raymarch (vec3 ro, vec3 rd)\n{\n\tfor (int i=0; i<256; i++)\n\t{\n\t\tfloat t = map(ro);\n        if (ro.x>300.0 || ro.x<-300.0 || ro.z>300.0 || ro.z<-300.0) break;\n\t\tif ( t<0.001 ) return color(ro);\n\t\tro+=t*rd;\n\t}\n\treturn vec4(sky(rd),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 ro,rd;\n    if (iTime<4.0)\n    {\n    \t ro = vec3(-30.0+iTime*15.0,63,-58.0);\n    \t rd = normalize(vec3(uv,2.0)*rotationX(5.4));\n    }\n    else\n    if (iTime<=14.0)\n    {\n         ro = vec3(-100.0+iTime*10.0,15.0+sin(iTime),0.0);\n    \t rd = normalize(vec3(uv,2.0)*rotationY(-1.5)*rotationZ(0.4)*rotationX(sin(iTime*0.5)));\n    }\n    else\n    if (iTime<=22.0)\n    {\n         ro = vec3(0.0,15.0,-70.0+iTime*5.0);    \t\n    \t rd = normalize(vec3(uv,2.0)*rotationX(-0.4)*rotationY(iTime));\n    }    \n    else\n    {\n         ro = vec3(0,63,-58);\n    \t rd = normalize(vec3(uv,2.0)*rotationX(5.4));       \n    }\n\tfragColor = raymarch(ro,rd);\n}", "image_inputs": [{"id": "MdlSWs", "previewfilepath": "https://soundcloud.com/uefa-1/uefa-champions-league", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/uefa-1/uefa-champions-league", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2yDD.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1137, 1164, 1164, 1243], [1245, 1245, 1272, 1272, 1351], [1353, 1353, 1380, 1380, 1465], [1467, 1467, 1489, 1489, 1554], [1556, 1556, 1578, 1578, 1713], [1715, 1715, 1735, 1735, 1831], [1833, 1833, 1883, 1883, 2010], [2012, 2012, 2041, 2041, 2200], [2202, 2202, 2227, 2227, 2718], [2720, 2720, 2740, 2740, 2952], [2957, 2957, 2979, 2979, 5352], [5357, 5357, 5391, 5391, 5596], [5598, 5598, 5655, 5655, 6358]]}
{"id": "Mt2yRm", "name": "4d procedural noise", "author": "afl_ext", "description": "Based on excellent IQ snippet, extended to 4d for fancy effects. Enjoy!", "tags": ["procedural", "noise", "4d"], "likes": 5, "viewed": 278, "published": "Public", "date": "1508068997", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( float n ){\n    return fract(sin(n)*758.5453);\n}\nfloat noise4d(vec4 x){\n\tvec4 p=floor(x);\n\tvec4 f=smoothstep(0.,1.,fract(x));\n\tfloat n=p.x+p.y*157.+p.z*113.+p.w*971.;\n\treturn mix(mix(mix(mix(hash(n),hash(n+1.),f.x),mix(hash(n+157.),hash(n+158.),f.x),f.y),\n\tmix(mix(hash(n+113.),hash(n+114.),f.x),mix(hash(n+270.),hash(n+271.),f.x),f.y),f.z),\n\tmix(mix(mix(hash(n+971.),hash(n+972.),f.x),mix(hash(n+1128.),hash(n+1129.),f.x),f.y),\n\tmix(mix(hash(n+1084.),hash(n+1085.),f.x),mix(hash(n+1241.),hash(n+1242.),f.x),f.y),f.z),f.w);\n}\n\nfloat aBitBetterNoise(vec4 x){\n    // this trick here works for all IQ noises, it makes cost 2x but makes it look a lot lot better\n    // it is not required of course\n    float a = noise4d(x);\n    float b = noise4d(x + .5);                      \n    return (a+b)*.5;\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nvec3 getRay(vec2 UV){\n\tUV = UV * 2.0 - 1.0;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\tmat3 rotmat = rotationMatrix(vec3(1.0, 0.0, 0.0), mouse.y * 2.0 - 1.0);\n\tmat3 rotmat2 = rotationMatrix(vec3(0.0, 1.0, 0.0), mouse.x * 2.0 - 1.0);\n\treturn rotmat * rotmat2 * normalize(vec3(UV.x, - UV.y, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ray = getRay(uv);\n    \n    float val = aBitBetterNoise(vec4(ray * 10.0, iTime));\n\tfragColor = vec4(vec3(val),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2yRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 59], [60, 60, 82, 82, 536], [538, 538, 568, 704, 806], [808, 808, 853, 853, 1281], [1283, 1283, 1304, 1304, 1583], [1585, 1585, 1642, 1642, 1810]]}
{"id": "MtBcR1", "name": "vortex field - 228 chars", "author": "FabriceNeyret2", "description": "simplified & golfed variant of [url]https://www.shadertoy.com/view/lljczz[/url].\nSee comments and extensions there.", "tags": ["field", "ellipsoid", "2tweets", "short", "golf", "tensor"], "likes": 7, "viewed": 576, "published": "Public API", "date": "1507391027", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// simplified & golfed variant of https://www.shadertoy.com/view/lljczz\n\n/**/ // coyote : -10 chars\n\n#define W(p) vec2( -(p).y, p ) / dot(p,p)\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec2 R = iResolution.xy,\n         u = (U+U-R)/R.y,\n         m = vec2( sin(iTime), .2*cos(iTime/3.7) ),\n         P = ceil(u*20.-.5) / 20.,\n         L = R-R + length( m = W(P-m)-W(P+m) );\n    O += length( (u-P) * mat2( m*60./L/L, W(m)*L*R.y/2.) ); }\n\n\n\n             \n/** // more readable version about the maths of physics :\n\n\n#define W(p) vec2( -(p).y, p ) / dot(p,p)\n\n#define mainImage( O , U )                         \\\n    vec2 R = iResolution.xy,                       \\\n         u = (U+U-R)/R.y,                          \\\n         m = vec2( sin(iTime), .2*cos(iTime/3.7) ),\\\n         P = ceil(u*20.-.5) / 20.,                 \\\n         V =  W(P-m) - W(P+m);                     \\\n    float l = length(V);                           \\\n    O += length( (u-P) * mat2( V*60./l, vec2(-V.y,V)*R.y/2.) ) / l\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBcR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 144, 180, 180, 432]]}
{"id": "MtBcRG", "name": "Martin Birth Compo Recreation", "author": "lamogui", "description": "Attempting to recreate martin pedro compo for his show birth of la treve collectif, during the paris shader showdown \n#2 (https://www.facebook.com/events/172824569940299/) Unfortunatly I ran out of time during the compo, so this version is not live coded\n", "tags": ["compo", "recreation", "martin", "birth"], "likes": 1, "viewed": 170, "published": "Public", "date": "1509382746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define mmin(v, d, i) (v.x > d ? vec2(d,i) : v)\n#define ID_SPHERE 1.0\n#define ID_LIGHT 2.0\n#define ID_BLACK 3.0\n#define PI 3.14159265\n\nfloat lc;\n\nfloat sphere(vec3 p, vec3 pos, float id)\n{\n  vec3 q = normalize(p - pos);\n  vec2 uv = vec2(atan(q.z, q.x) / (2.0 * PI), acos(q.y) / PI);\n  float d = 0.15 * textureLod(iChannel0, uv + sin(2.0 * PI * id) * iTime * 0.1 + vec2(id * 0.4), 0.0).x;\n  return length(p - pos) - (0.35)* (1.0 + d * 0.15);\n}\n\nfloat cylinder(vec3 p)\n{\n  return length(p.xz) - 0.2 - 0.1 * lc;\n}\n\nmat3 rotateY(float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(c, 0.0, -s, \n            0.0, 1.0, 0.0, \n              s, 0.0, c);\n}\n\nmat3 rotateZ(float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(c, -s , 0.0, s, c, 0.0 , 0.0 ,0.0 ,1.0);\n}\n\nmat3 rotateX(float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(1.0, 0.0 ,0.0,\n              0.0 , c, -s,\n              0.0, s, c);\n}\n\nfloat modA(inout vec2 v, float n, float len)\n{\n  float l = length(v);\n  float an = PI * 2.0 / n; \n  \n  float a = atan(v.y, v.x);\n  float id = floor(a / an);\n  a = mod(a, an) - an * 0.5;\n  //l = mod(l, len) - len * 0.5;\n  v = vec2(cos(a), sin(a)) * l;\n  return id;\n}\n\nvec2 map(vec3 p)\n{\n  float d = 100000.0;\n  for (int i = 0; i < 8; ++i)\n  {\n    int j = i + int(iTime * .1);\n    vec3 q = rotateY(iTime * (0.1 + 0.3 * fract(0.3 + 0.1451 * float(i)))) * p;\n    float id = modA(q.xz, 10.0 + 4.0 * float(i), 4.0);\n    float x = 1.0 + (float(j) - iTime * .1) * .5 + 0.3 * fract(id * 0.534);\n    d = min(sphere(q, vec3(x, sqrt((x - 1.0) * 0.9) - 0.3 + 0.2 * textureLod(iChannel1, vec2(0.75, fract(id * 0.1554)), 0.0).x, 0.0), fract(id * 0.15614 * float(i))), d);\n  }\n  vec2 v = vec2(d, ID_SPHERE);\n  v = mmin(v, cylinder(p), ID_LIGHT);\n  return v;\n}\n\nvec4 rm(vec3 ro, vec3 rd)\n{\n  vec3 p = ro;\n  vec2 d;\n  float id = ID_BLACK;\n  for (int i = 0; i< 64; ++i)\n  {\n    d = map(p);\n    if (abs(d.x) < 0.001)\n    {\n      id = d.y;\n      break;\n    }\n    else if (d.x > 1000.0)\n      break;\n    p += rd * d.x * 0.9;\n  }\n  return vec4(p, id);\n}\n\nvec3 grad(vec3 p)\n{\n  vec2 e = vec2(0.01, 0.0);\n  return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x, map(p + e.yxy).x - map(p - e.yxy).x, map(p + e.yyx).x - map(p - e.yyx).x));\n}\n\nfloat f(float a)\n{\n  a *= PI;\n  return pow(abs(cos(a)) + abs(sin(a)), -1.0 / 0.05);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float a = -PI / 2.0;\n  vec3 ro = vec3(3.5 * cos(a), 3.0, -2.0 + 3.5 *sin(a));\n  vec3 rd = vec3(uv, 1.0);\n  //rd = rotateY(-PI / 2.0 + a) * rd;\n  rd = rotateX(-0.2) * rd;\n  rd = rotateZ(0.2) * rd;\n  \n  lc = clamp(1.0-f(.05*iTime) - f(iTime + sin(iTime * 3.0)), 0.0, 1.0);\n  vec4 q = rm(ro, rd);\n  vec3 p = q.xyz;\n  float id = q.w;\n  float d = distance(ro, p);\n  \n  vec3 n = grad(p);\n  \n\n  \n  vec3 color;\n  if (id == ID_LIGHT)\n    color = vec3(0.8 + 0.2 * lc);\n  else if (id == ID_SPHERE)\n  {\n    color = vec3(0.1);\n    color *= n * 0.5 + 0.5;\n    vec3 pp = p;\n    q = rm(p + 0.1 * n, reflect(rd, n));\n    p = q.xyz;\n    id = q.w;\n    n = grad(p);\n    if (id == ID_LIGHT)\n      color =  mix(color, vec3(lc) * exp(-0.2*distance(vec2(0.0), pp.xz)), 0.7);\n    else if (id == ID_SPHERE)\n      color = mix(color, 0.15 * (n * 0.5 + 0.5), 0.3);\n  }\n    \n  if (id != ID_LIGHT)\n    color *= exp(-d * 0.1);\n  color = pow(color, vec3(1.0 / 1.1));\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "MslSDs", "previewfilepath": "https://soundcloud.com/nils_frahm/down-down-1", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/nils_frahm/down-down-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBcRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 190, 190, 444], [446, 446, 470, 470, 512], [514, 514, 537, 537, 660], [662, 662, 685, 685, 782], [784, 784, 807, 807, 931], [933, 933, 979, 979, 1198], [1200, 1200, 1218, 1218, 1776], [1778, 1778, 1805, 1805, 2063], [2065, 2065, 2084, 2084, 2251], [2253, 2253, 2271, 2271, 2338], [2340, 2340, 2397, 2397, 3505]]}
{"id": "MtBcWz", "name": "Spiral Test", "author": "mirrorsword", "description": "Simple Spiral example", "tags": ["spiral"], "likes": 6, "viewed": 300, "published": "Public", "date": "1508199128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord - iResolution.xy ) / iResolution.x;\n    float t = iTime * 5.0;\n    uv *= mat2(cos(t),sin(t),-sin(t),cos(t)); // image rotation\n\tfloat theta = (atan(uv.y,uv.x) + 3.14)/6.28;\n    float dist = length(uv)*2.;\n    float spirals = 2.;\n    float value = theta + dist*spirals;\n    value = fract(value);\n    //value = (sin(value*6.28)+1.) * 0.5;\n    fragColor = vec4(value);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBcWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 450]]}
{"id": "MtByDm", "name": "Frozen Tunnel", "author": "aiekick", "description": "Frozen Tunnel", "tags": ["tunnel", "sss", "frozen"], "likes": 13, "viewed": 646, "published": "Public API", "date": "1508782454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n// link : https://www.shadertoy.com/view/MtByDm\n\n#define path(t) sin(t * 0.5) * 1.5\n\nvec4 df(vec3 p)\n{\n    vec3 tex = texture(iChannel0, p.xz * 0.5).rgb;\n    float disp = dot(tex, vec3(0.01));\n    \n    p.xy += path(p.z);\n    \n    float a = cos(p.z * 2.);\n    p.xy *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    float sp = fract(-atan(p.x,p.y)/3.14159*8.+(mod(p.z,1.)-0.5));\n    \n    float tutu = (0.8 - length(p.xy)) * sp + disp;\n\n    return vec4(max(-length(p.xy) + .78, tutu), vec3(0));\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float ms) \n{\n\tvec3 n = nor(surfPoint,0.0001); \n\treturn df(surfPoint - n * ms).x/ms;\n}\n\n// from shane shaders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    p = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane shaders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n// shading func\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 ld, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\n\tvec3 n = nor(p, 0.1);\t\t\n    \n    n = doBumpMap(iChannel0, p*.5, n, 0.005);\n\t\n\tvec3 refl = reflect(rd,n);\t\n\t\n\tfloat amb = 0.6; \t\t\t\t\t\t\t\t\t\t\t\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.); \t\n\tfloat sss = 1. - SubDensity(p, 1.); \t\t\t\t\t\t\n\t\n    return vec3(\n        (diff + fre + spe * 3.) * amb * li,\n        (diff + fre + sss) * amb * li + spe * 1.2,\n        (diff + fre - spe * 0.2 + sss * .8) * amb * li\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vars\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 mo = iMouse.xy;\n\tfloat time = iTime * 1.2;\n\t\n\tvec3 col = vec3(0);\n            \n\tvec3 ro = vec3(0,0,time);\n\tro.xy -= path(ro.z);\n    \n\tvec3 lp = ro + vec3(0,2,5);\n\t\n    vec3 cv = vec3(0,0,ro.z+1.);\n    cv.xy -= path(cv.z);\n    \n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n    \n  \tvec2 uv = (g+g-si)/si.y;\n   \tvec3 rd = normalize(z + uv.x*x + uv.y*y);\n\n\tfloat md = 100.;\n\n\tfloat s = 1., d = 0.;\n\tfor (float i=0.; i<80.; i++)\n\t{\n\t\tif (d*d/s > 1e6 || d > md) break;\n\t\ts = df(ro+rd*d).x;\n\t\td += s * 0.8;\n\t}\n\t\n    vec3 ld = normalize(lp - ro-rd*d);\n\t\n    vec3 mat = vec3(0.3,0.5,0.8);\n    \n    if (d < md)\n    {\n        vec3 p = ro+rd*d; // surf point\n        \n        // sub surface\n        for (float i = 0.; i < 1.; i+=0.1)\n        {\n            float y = shade(p, rd, i, ld, i).y;\n            mat = blackbody(1000. + y * 900.).bgr * 0.8;\n            col = mix(col, y * mat, i);\n        }\n        \n        // surface\n        float x = shade(ro, rd, d, ld, 3.).x;\n        mat = blackbody(1000. + x * 900.).bgr * 0.2;\n        col = mix(col, x * mat, 0.7);\n    }\n    \n\tcol = mix(col, mat, 1.0-exp(-0.01*d*d));\n\n    col = sqrt(col * col * .8);\n\n\tvec2 v = g/si;\n    col *= 0.5 + 0.5*pow( 16.0*v.x*v.y*(1.0-v.x)*(1.0-v.y), 0.25 ); // iq vignette\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtByDm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 298, 315, 315, 699], [701, 701, 735, 735, 947], [949, 1170, 1198, 1198, 1523], [1525, 1607, 1652, 1652, 1725], [1727, 1903, 1954, 1954, 2128], [2130, 2339, 2402, 2402, 2764], [2766, 2782, 2840, 2840, 3397], [3399, 3399, 3456, 3468, 4875]]}
{"id": "MtByRh", "name": "Lensing", "author": "Ebanflo", "description": "based on [url=https://www.shadertoy.com/view/XlfGRj] Star Nest by Kali [/url]. see [url=https://www.shadertoy.com/view/Xd3yWX]here[/url] for realitic lensing.", "tags": ["3d", "blackhole", "starfield", "lensing"], "likes": 45, "viewed": 7002, "published": "Public API", "date": "1507342882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Star Nest by Pablo RomÃÂ¡n Andrioli\n\n// This content is under the MIT License.\n\n#define iterations 12\n#define formuparam 0.57\n\n#define volsteps 10\n#define stepsize 0.2\n\n#define zoom   1.200\n#define tile   1.0\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 1.00\n#define distfading 0.730\n#define saturation 1.0\n\n#define mo (2.0 * iMouse.xy - iResolution.xy) / iResolution.y\n#define blackholeCenter vec3(time*2.,time,-2.)\n#define blackholeRadius 1.2\n#define blackholeIntensity 1.0\n\nfloat iSphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nvec3 iPlane(vec3 ro, vec3 rd, vec3 po, vec3 pd){\n    float d = dot(po - ro, pd) / dot(rd, pd);\n    return d * rd + ro;\n}\n\nvec3 r(vec3 v, vec2 r)//incomplete but ultrafast rotation fcn thnx to rodolphito\n{\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tvec3 from=vec3(0.0, 0.0, -15.0);\n    from = r(from, mo / 10.0);\n    dir = r(dir, mo / 10.0);\n\tfrom+=blackholeCenter;\n\t\n    vec3 nml = normalize(blackholeCenter - from);\n    vec3 pos = iPlane(from, dir, blackholeCenter, nml);\n    pos = blackholeCenter - pos;\n    float intensity = dot(pos, pos);\n    if(intensity > blackholeRadius * blackholeRadius){\n        intensity = 1.0 / intensity;\n    \tdir = mix(dir, pos * sqrt(intensity), blackholeIntensity * intensity);\n    \t\n\t\t//volumetric rendering\n\t\tfloat s=0.1,fade=1.;\n\t\tvec3 v=vec3(0.);\n\t\tfor (int r=0; r<volsteps; r++) {\n\t\t\tvec3 p=from+s*dir*.5;\n\t\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\t\tfloat pa,a=pa=0.;\n\t\t\tfor (int i=0; i<iterations; i++) { \n\t\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\t\tpa=length(p);\n\t\t\t}\n\t\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\t\ta*=a*a; // add contrast\n\t\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t\t//v+=vec3(dm,dm*.5,0.);\n\t\t\tv+=fade;\n\t\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\t\tfade*=distfading; // distance fading\n\t\t\ts+=stepsize;\n\t\t}\n\t\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\t\tfragColor = vec4(v*.01,1.);\t\n    }\n    else fragColor = vec4(0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtByRh.jpg", "access": "shaders20k", "license": "mit", "functions": [[41, 504, 566, 566, 767], [769, 769, 817, 817, 889], [891, 891, 973, 973, 1165], [1167, 1167, 1224, 1252, 2700]]}
{"id": "MtByzh", "name": "Dance floor(?)", "author": "Torumu106", "description": "strange soild is dancing.\nI used Raymarching", "tags": ["raymarching", "shader", "dance"], "likes": 0, "viewed": 111, "published": "Public", "date": "1507355737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.1415926535;\nvec3 col = vec3(1.0, 1.0, 1.0);\nint stop = 0;\nbool needshadow = true;\nvec3 stoppos = vec3(0.0);\nbool needlight = true;\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\nfloat map(vec3 p){\n    float d = length(max(abs(p) - vec3(1.0),0.0));\n    \n    vec3 p1 = p;\n    float the = iTime / 2.1;\n    p1.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    d = smin(d, length(p1 - vec3(1.2,1.2,1.2)) - 0.7 +sin(iTime*3.5*PI)*0.2, 3.0);\n    d = smin(d, length(p1 - vec3(-1.2,1.2,1.2)) - 0.7 +sin(iTime*3.5*PI)*0.2, 3.0);\n    d = smin(d, length(p1 - vec3(1.2,1.2,-1.2)) - 0.7 +sin(iTime*3.5*PI)*0.2, 3.0);\n    d = smin(d, length(p1 - vec3(-1.2,1.2,-1.2)) - 0.7 +sin(iTime*3.5*PI)*0.2, 3.0);\n    if(d < 0.01) col= vec3(0.0, 1.0, 1.0);\n    \n    vec3 p2 = (fract((p + vec3(iTime * 5.0, 0, 0.0))  * 0.2) - 0.5) / 0.2;\n    float d1 = max( abs(length(p) - 36.0) - 0.05, length(p2) - 1.0);\n    if(d1 < 0.01){\n        needlight = false;\n        col = vec3(1.0, 0.0, 0.8);\n    }\n    d = min(d, d1);\n    \n    float plane = dot(p,vec3(0.0, 1.0, 0.0)) + 1.0;\n    if(plane < 0.01 && length(p) > 39.0){\n    \tcol = vec3(0.6, 0.4, 0.8) + vec3(0.85, 1.0, 0.5) * max(0.0, (50.0 - length(vec2(80.0) - vec2(abs(p.x), abs(p.z)))) / 45.0);\n    }\n    d = min(d, plane);\n    \n    float pole = length(vec2(p.x, p.z) - vec2(80.0)) - 3.0;\n    pole = min(pole, length(vec2(p.x, p.z) - vec2(-80.0)) - 3.0);\n    pole = min(pole, length(vec2(p.x, p.z) - vec2(-80.0, 80.0)) - 3.0);\n    pole = min(pole, length(vec2(p.x, p.z) - vec2(80.0, -80.0)) - 3.0);\n    \n    if(pole < 0.01){\n        needlight = false;\n        needshadow = false;\n    \tcol = vec3(0.85, 1.0, 0.5);\n    }\n    d = min(d, pole);\n    \n    return d;\n}\nvec3 grad(vec3 p) {\n    vec2 d = vec2(0.0, 0.001);\n\tfloat dFx = map(p + d.yxx) - map(p - d.yxx);\n\tfloat dFy = map(p + d.xyx) - map(p - d.xyx);\n\tfloat dFz = map(p + d.xxy) - map(p - d.xxy);\n\treturn normalize(vec3(dFx, dFy, dFz));\n}\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p;\n    for(int i = 0; i < 256; ++i){\n    \tp = o + r * t;\n        float d = map(p);\n        if(d < 0.01){\n            stop = 1;\n        \tbreak;\n        }\n        t += d * 0.9;\n    }\n    stoppos = p;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv - vec2(0.0, PI / 5.0), 1.0));\n    \n    float the = iTime / PI;\n    vec3 o = vec3(0.0,10.0, -10.0);\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    o.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    float t = trace(o, r);\n    float light = 1.0;\n    int stopp = stop;\n    if(stop == 1 && needlight){\n    \tvec3 nor = grad(stoppos);\n        light = 0.6 * max(dot(nor, vec3(1.0,0.8,0.4)), 0.0) + 0.3;\n        stop = 0;\n        vec3 col1 = col;\n        trace(stoppos + nor * 0.02, normalize(vec3(1.0,0.7,0.4)));\n        if(stop == 1){\n            if(needshadow){\n                light = 0.1;\n            }\n            col = col1;\n        }\n    }\n    if(stopp == 0){\n    \tcol = vec3(0.2, 0.375, 0.75);\n    }\n    \n    vec3 fc = vec3(light) * col;\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtByzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 185, 185, 256], [257, 257, 275, 275, 1767], [1768, 1768, 1787, 1787, 1998], [1999, 1999, 2027, 2027, 2266], [2267, 2267, 2324, 2324, 3264]]}
{"id": "MtjczK", "name": "Bouncy Mouse Circles", "author": "timeiskey", "description": "mod of distance to mouse. itime controls mod threshold\n\nv 1.1:\n     -aspect ratio distortion mitigation simplified", "tags": ["2d", "mouse"], "likes": 3, "viewed": 95, "published": "Public", "date": "1509374476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\tnormalized coordinate of current pixel\n\tvec2 uv = fragCoord / iResolution.y;\n    vec2 mnc = iMouse.xy / iResolution.y;\n    \n    //\tdetermine smoothing factor\n    float blur = 100.0 / iResolution.y;\n    \n    //\tdraw circles\n    float d = sin( length( mnc - uv ) * 100.0);\n    float thresh = 0.4 + cos(iTime * 101.) * 0.2;\n    float thresh2 = thresh + sin(iTime * 100.0) * 0.3;\n    \n    float c = 0.0;\n    c += smoothstep( thresh+blur,thresh-blur, d );\n    c += smoothstep( thresh2+blur,thresh2-blur, d );\n    \n\tfragColor = vec4( c );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 103, 599]]}
{"id": "MtjyWm", "name": "Julia Revolute Simple", "author": "aiekick", "description": "Julia Revolute Simple", "tags": ["fractal", "julia", "torus", "curve", "wood", "4", "revolute"], "likes": 33, "viewed": 706, "published": "Public API", "date": "1508893117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nvec2 m;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.1415926535 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat fractus(vec2 p, vec2 v)\n{\n\tvec2 z = p;\n    vec2 c = v;\n\tfloat k = 1., h = 1.0;    \n    float t = (sin(iTime * .5)*.5+.5) * 5.;\n    for (float i=0.;i<5.;i++)\n    {\n        if (i > t) break;\n        h *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n    float d = sqrt(k/h)*log(k);\n    \n    // next iteration\n    if (k > 4.)\n    \tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    h *= 4.*k;\n    k = dot(z,z);\n    float d1 = sqrt(k/h)*log(k);\n    \n    // df blending\n\treturn mix(d, d1, fract(t));\n}\n\nvec4 dfFractus(vec3 p)\n{\n\tfloat a = fullAtan(p.xz); // axis y\n    \n    vec2 c;\n    c.x = mix(0.2, -0.5, sin(a * 2.));\n    c.y = mix(0.5, 0.0, sin(a * 3.));\n    \n    float path = length(p.xz) - 3.;\n    \n    vec2 rev = vec2(path, p.y);\n    float aa = a + iTime;\n    rev *= mat2(cos(aa),-sin(aa),sin(aa),cos(aa)); // rot near axis y\n\t\n\treturn vec4(fractus(rev, c) - 0.0, rev, 0);\n}\n\nvec4 df(vec3 p)\n{\n\treturn dfFractus(p); \n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    m = iMouse.xy/iResolution.xy;\n    if (m.x == 0.) m.x = .1;\n    \n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n    float a = 1.57;\n\tvec3 rayOrg = vec3(cos(a),1.5,sin(a)) * 5.;\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,-1.5,0);\n\t\n\tfloat fov = .5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat s = 0.;\n    float d = 0.;\n\tfloat dMax = 20.;\n\tfloat count = 0.;\n\tfor (float i=0.; i<500.; i++)\n\t{\n\t\tif (d*d/s>1e6 || d>dMax) break;\n        s = df(rayOrg + rayDir * d).x;\n\t\td += s * 0.2;\n\t\tcount+=1.;\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n   \t/*vec4 mat = df(rayOrg + rayDir * d);\n   \tvec3 tex = texture(iChannel0, mat.yz * 0.8).rgb;\n    d += dot(tex, vec3(0.05));*/\n\t\n\tif (d<dMax)\n\t{\n        \n\t\tvec3 p = rayOrg + rayDir * d;\n        vec3 n = nor(p, 0.001);\n\t\tvec4 mat = df(p);\n        \n        vec3 tex = texture(iChannel0, mat.yz).rgb; // wood\n        \n\t\t// iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.16).x);\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n        float sss = df(p - n*0.001).x/0.01;\n\t\n        dif *= softshadow( p, ld, 0.1, 2. );\n        \n        vec3 brdf = vec3(-0.5) * tex;\n        brdf += 0.5*dif*vec3(1.00,0.90,0.60);\n        brdf += 0.4*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.3*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.5*(1.-sss)*vec3(0.2,0.7,0.2);\n        fragColor.rgb *= brdf;\n\n        fragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.01*d*d*count/150. ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n    \n    fragColor.rgb = sqrt(fragColor.rgb * fragColor.rgb * 0.8);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjyWm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 272, 296, 296, 379], [381, 381, 412, 412, 952], [954, 954, 978, 978, 1332], [1334, 1334, 1351, 1351, 1376], [1378, 1378, 1410, 1410, 1588], [1590, 1606, 1680, 1680, 1919], [1921, 1937, 1979, 1979, 2278], [2280, 2475, 2532, 2532, 2820], [2822, 2822, 2879, 2879, 4790]]}
{"id": "MtjyzK", "name": "Frustum CSG Tree Intersection", "author": "paniq", "description": "demonstrating how to perform CSG on brushes without z-sorting by evaluating distances to brush intervals stored as a toposorted CSG tree. mouse down displays distance estimate for that position and evaluations performed.", "tags": ["marching", "csg", "tree", "1d", "frustum", "interval", "culling"], "likes": 9, "viewed": 740, "published": "Public API", "date": "1509372416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Frustum CSG Tree Intersection\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// note that this version is verbose and purposefully lacks \n// any form of optimization for the sake of education.\n\n// the general principle here is that we first evaluate the near and\n// far boundaries of the brushes that cross our line of sight, \n// so we end up with a list of 1D intervals for each brush.\n//\n// then we can perform CSG in rayspace and raymarch towards the\n// nearest resulting visible surface by repeatedly evaluating\n// a distance estimator that gives us the distance to the \n// nearest horizon.\n//\n// the distance estimator evaluates the CSG tree to receive \n// a lower bound on the distance to the edge closest to \n// the right of a given 1D scalar t.\n//\n// the CSG tree evaluation is sped up by transforming the tree\n// to a topologically sorted array of nodes (here done manually) \n// that can be evaluated sequentially.\n//\n// the CSG tree has four kinds of operands:\n// SET X:brush (copy)\n// OR A:op B:op (boolean union)\n// AND A:op B:op (boolean intersection)\n// ANDN A:op B:op (boolean subtraction)\n//\n// the complexity is O(n) for n union-only instructions,\n// but can reach O(n*n) in the worst case; the performance in\n// practice however is typically around O(6n). Through hierarchical\n// culling one can aggressively reduce the number of instructions\n// required to solve a tile:\n//\n// it is possible, not demonstrated here, to source the brush \n// intervals from a primitive-frustum intersection instead, and\n// to cull/rewrite instructions that yield no result, allowing\n// for hierarchical quadtree-style raymarching using\n// per-tile linked lists for tiles that contain more than one \n// instruction.\n\n// set to 1 to show CSG operator debug setup\n#define DEBUG_CSG_OPS 0\n#define DEBUG_CSG_OP CSG_OR\n#define TEST_SETUP 0\n\nvec2 ray_origin0;\nvec2 ray_origin1;\nconst vec2 ray_dir = vec2(1.0,0.0);\n\nconst int op_set = 0;\nconst int op_or = 1;\nconst int op_and = 2;\nconst int op_and_not = 3;\n\nconst int empty = -1;\nconst int solid = -2;\n\nconst float infinity = 1.0/0.0;\nconst vec2 empty_interval = vec2(infinity);\n\nstruct Edge {\n    // position of next feature\n    // if positive, area in front of / behind gray zone is empty\n    // if negative, area is solid\n    float t;\n    // if true, gray zone is right of cursor\n    // otherwise cursor is in gray zone\n\tbool r;\n    // +t r=true : _______|????????\n    // -t r=true : #######|????????\n    // +t r=false: ???????|________\n    // -t r=false: ???????|########\n    \n};\n    \n// these brushes are usually imported using a SSBO\n// here we provide a small local array\n#if DEBUG_CSG_OPS\n#define NUM_BRUSHES 2\n#elif TEST_SETUP\n#define NUM_BRUSHES 3\n#else\n#define NUM_BRUSHES 7\n#endif\nvec3 brushes[NUM_BRUSHES];\n// vec2: fuzzy interval, vec2: solid interval\nvec4 brush_intervals[NUM_BRUSHES];\n\nvec2 iCircle(vec2 o_ro, vec2 rd, vec3 params) {\n\tvec2 ro = o_ro - params.xy;\n\tfloat k = dot(ro, rd);\n    float q = sqrt(k*k - dot(ro, ro) + params.z*params.z);\n    vec2 d = (vec2(-q,q) - k);\n    return (d.x != d.x)?vec2(infinity,-infinity):d;\n}\n\nfloat dCircle(vec2 p, vec3 params) {\n    return length(p - params.xy) - params.z;\n}\n\n// dynamic array index hack\nvec3 get_brush(int brushid) {\n    for (int i = 0; i < NUM_BRUSHES; ++i) {\n        if (i == brushid)\n            return brushes[i];\n    }\n    return vec3(0.0);\n}\n\n// dynamic array index hack\nvec4 get_brush_interval(int brushid) {\n    for (int i = 0; i < NUM_BRUSHES; ++i) {\n        if (i == brushid)\n            return brush_intervals[i];\n    }\n    return vec4(empty_interval, empty_interval);\n}\n   \n\n#if DEBUG_CSG_OPS\n#define NUM_CSG_OPS 3\n#elif TEST_SETUP\n#define NUM_CSG_OPS 5\n#else\n#define NUM_CSG_OPS 13\n#endif\n#define CSG_OP ivec3\n// opcode, src1, src2\n// src1 must be node index, empty, or brush\n// src2 must be node index, empty, or brush\n// in a realworld example, this would be a SSBO\nCSG_OP csg_ops[NUM_CSG_OPS];\nvoid setup_globals(float t) {\n#if DEBUG_CSG_OPS\n    brushes[0] = vec3(0.5,0.0,0.08);\n    brushes[1] = vec3(mix(0.26,0.74,sin(t)*0.5+0.5),0.0,0.1);\n#elif TEST_SETUP\n    vec2 c = vec2(0.5,0.05);\n    float r0 = 0.21;\n    float a0 = t;\n    float a1 = a0 + radians(90.0);\n    brushes[0] = vec3(c.x + cos(a0)*r0, c.y + sin(a0)*r0,0.2);\n    brushes[1] = vec3(c.x - cos(a0)*r0, c.y - sin(a0)*r0,0.2);\n    brushes[2] = vec3(c.x, c.y, 0.1);\n#else\n\tbrushes[0] = vec3(0.3,0.0,0.1);\n    brushes[1] = vec3(mix(0.25,0.35,sin(t*0.7)*0.5+0.5),0.26,0.29);\n    brushes[6] = vec3(0.3,mix(0.0,0.1,sin(t*0.6)*0.5+0.5),0.12);\n    vec2 c = vec2(0.8,0.03);\n    float r0 = 0.08;\n    float r1 = 0.09;\n    float a0 = t;\n    float a1 = a0 + radians(90.0);\n    brushes[2] = vec3(c.x + cos(a0)*r0, c.y + sin(a0)*r0,0.1);\n    brushes[3] = vec3(c.x - cos(a0)*r0, c.y - sin(a0)*r0,0.1);\n    brushes[4] = vec3(c.x + cos(a1)*r1, c.y + sin(a1)*r1,0.1);\n    brushes[5] = vec3(c.x - cos(a1)*r1, c.y - sin(a1)*r1,0.1);\n#endif\n\n// dynamic array indexing hack just so we can squeeze out a little convenience\n#define CSG_INSTR(I, OP, A, B) csg_ops[I] = CSG_OP(OP, A, B);\n#define CSG_SET(I, A) CSG_INSTR(I, op_set, A, A)\n#define CSG_OR(I, A, B) CSG_INSTR(I, op_or, A, B)\n#define CSG_AND(I, A, B) CSG_INSTR(I, op_and, A, B)\n#define CSG_ANDN(I, A, B) CSG_INSTR(I, op_and_not, A, B)\n#define BRUSH(X) X\n#define OP(X) X\n#if DEBUG_CSG_OPS\n    CSG_SET(0,BRUSH(0));\n    CSG_SET(1,BRUSH(1));\n    DEBUG_CSG_OP(2,OP(0),OP(1));\n#elif TEST_SETUP\n    CSG_SET (0,BRUSH(0));\n    CSG_SET (1,BRUSH(1));\n    CSG_OR  (2,OP(0), OP(1));\n    CSG_SET (3,BRUSH(2));\n    CSG_AND (4,OP(2), OP(3));\n#else\n    CSG_SET\t(0,BRUSH(2));\n    CSG_SET\t(1,BRUSH(3));\n    CSG_AND\t(2,OP(0), OP(1));\n\n    CSG_SET\t(3,BRUSH(4));\n    CSG_SET\t(4,BRUSH(5));\n    CSG_AND\t(5,OP(3), OP(4));\n\n    CSG_OR\t(6,OP(2),\tOP(5));\n\n    CSG_SET (7, BRUSH(0));\n    CSG_SET (8, BRUSH(1));\n    CSG_ANDN(9, OP(7), OP(8));\n    CSG_OR  (10,OP(6), OP(9));\n    CSG_SET (11,BRUSH(6));\n    CSG_ANDN(12,OP(10), OP(11));\n#endif\n#undef CSG_INSTR\n#undef CSG_OR\n#undef CSG_AND\n#undef CSG_AND_NOT\n#undef BRUSH\n#undef OP\n\n    // precalculate brush intervals\n    for (int i = 0; i < NUM_BRUSHES; ++i) {\n        vec2 d0 = iCircle(ray_origin0, ray_dir, brushes[i]);\n        vec2 d1 = iCircle(ray_origin1, ray_dir, brushes[i]);\n        vec2 p0 = brushes[i].xy - vec2(brushes[i].z,0.0);\n        vec2 p1 = brushes[i].xy + vec2(brushes[i].z,0.0);\n        \n        // outer interval\n        vec2 od = vec2(min(d0.x,d1.x),max(d0.y,d1.y));\n        if (od.x > od.y) {\n            od = empty_interval;\n        }\n        // inner interval\n        vec2 id = vec2(max(d0.x,d1.x),min(d0.y,d1.y));\n        if (id.x > id.y) {\n            id = empty_interval;\n        }\n        #if 1\n        if ((brushes[i].y > ray_origin0.y) && (brushes[i].y < ray_origin1.y)) {\n            od.x = min(od.x, p0.x);\n            od.y = max(od.y, p1.x);\n        }    \n        #endif\n        brush_intervals[i] = vec4(od, id);\n    }\n}\n\n// temporary space for intermediate computations\n// in a realworld example, these would be in SSBOs\nfloat temp1[NUM_CSG_OPS];\nEdge temp2[NUM_CSG_OPS];\n\nCSG_OP get_op(int idx) {\n    for (int i = 0; i < NUM_CSG_OPS; ++i) {\n        if (i == idx)\n            return csg_ops[i];\n    }    \n    return CSG_OP(0);\n}\n\n// dynamic array index hack\nfloat get_temp1(int idx) {\n    for (int i = 0; i < NUM_CSG_OPS; ++i) {\n        if (i == idx)\n            return temp1[i];\n    }    \n    return infinity;\n}\n\n// dynamic array index hack\nEdge get_temp2(int idx) {\n    for (int i = 0; i < NUM_CSG_OPS; ++i) {\n        if (i == idx)\n            return temp2[i];\n    }    \n    return Edge(infinity, true);\n}\n\nEdge interval_edge(vec4 range, float t) {\n    if (range.x > t) {\n        return Edge(range.x, true);\n\t} else if (range.y > t) {\n        if (range.z != infinity) {\n            if (range.z > t) {\n                return Edge(-range.z, false);\n            } else if (range.w > t) {\n                return Edge(-range.w, true);\n            }\n        }\n        return Edge(range.y, false);\n    } else {\n        return Edge(infinity, true);\n    }\n}\n\nEdge csg_not(Edge x) {\n    return Edge(-x.t, x.r);\n}\n\nEdge csg_or(Edge a, Edge b) {\n    float ct = ((a.r?a.t:abs(a.t)) < (b.r?b.t:abs(b.t)))?a.t:b.t;\n    bool cr = (a.r && b.r) || (a.r && (sign(a.t) < 0.0)) || (b.r && (sign(b.t) < 0.0));\n    return Edge(ct, cr);    \n}\nEdge csg_and(Edge a, Edge b) {\n#if 0\n    return csg_not(csg_or(csg_not(a),csg_not(b)));\n#else\n    float ct = ((a.r?a.t:-abs(a.t)) > (b.r?b.t:-abs(b.t)))?a.t:b.t;\n    bool cr = (a.r && b.r) || (a.r && (sign(a.t) > 0.0)) || (b.r && (sign(b.t) > 0.0));\n    return Edge(ct, cr);\n#endif\n}\nEdge csg_and_not(Edge a, Edge b) {\n    return csg_and(a, csg_not(b));\n}\n\nEdge scene_next_feature(float t) {\n    Edge d;\n    for (int i = 0; i < NUM_CSG_OPS; ++i) {\n        CSG_OP op = get_op(i);\n        int opcode = op[0];\n        if (opcode == op_set) {\n            d = interval_edge(get_brush_interval(op[1]), t);\n        } else {\n            Edge a = get_temp2(op[1]);\n            Edge b = get_temp2(op[2]);\n            if (opcode == op_or) {\n                d = csg_or(a, b);\n            } else if (opcode == op_and) {\n                d = csg_and(a, b);\n            } else if (opcode == op_and_not) {\n                d = csg_and_not(a, b);\n            } else {\n                d = Edge(infinity, true);\n            }\n        }\n        temp2[i] = d;\n    }\n    return d;\n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nvoid paint_edge(Edge rd, float y, float h) {\n    float t = abs(rd.t);\n    float gd = 0.02;\n    if (rd.r) {\n        set_source_linear_gradient(\n            vec4(0.8,0.8,0.8,1.0), \n            vec4(0.8,0.8,0.8,0.0),\n            vec2(t, 0.0), \n            vec2(t+gd, 0.0));\n        rectangle(t,y,gd,h);\n    } else {\n        set_source_linear_gradient(\n            vec4(0.8,0.8,0.8,1.0), \n            vec4(0.8,0.8,0.8,0.0),\n            vec2(t, 0.0), \n            vec2(t-gd, 0.0));\n        rectangle(t-gd,y,gd,h);\n    }\n    fill();\n    if (rd.t < 0.0) {\n        if (rd.r) {\n            set_source_linear_gradient(\n                vec4(vec3(0.0),1.0), \n                vec4(vec3(0.0),0.0),\n                vec2(t, 0.0), \n                vec2(t-gd, 0.0));\n            rectangle(t-gd,y,gd,h);\n        } else {\n            set_source_linear_gradient(\n                vec4(vec3(0.0),1.0), \n                vec4(vec3(0.0),0.0),\n                vec2(t, 0.0), \n                vec2(t+gd, 0.0));\n            rectangle(t,y,gd,h);\n        }\n        fill();\n    }\n    set_source_rgb(vec3(0.0));\n    move_to(abs(rd.t), y);\n    line_to(abs(rd.t), y+h);\n    stroke();            \n    \n}\n\nvoid paint() {\n    float rdot = AAINV*1.0;\n\n    scale(3.);\n    translate(-0.5,0.0);\n\n    float frustum_offset = 0.0;\n    if (iMouse.z > 0.5) {\n        frustum_offset = get_query().y;\n    }\n    float frustum_half_width = 0.01; //0.025;\n    ray_origin0 = vec2(0.0,-frustum_half_width + frustum_offset);\n    ray_origin1 = vec2(0.0, frustum_half_width + frustum_offset);\n    \n    float t = iTime;\n    setup_globals(t);    \n    \n    set_line_width_px(1.0);\n\n    // compute CSG field per pixel\n    vec2 p = get_origin();\n    {\n        float d;\n        for (int i = 0; i < NUM_CSG_OPS; ++i) {\n            CSG_OP op = get_op(i);\n            int opcode = op[0];\n            if (opcode == op_set) {\n                d = dCircle(p, get_brush(op[1]));\n            } else {\n                float a = get_temp1(op[1]);\n                float b = get_temp1(op[2]);\n                if (opcode == op_or) {\n                    d = min(a, b);\n                } else if (opcode == op_and) {\n                    d = max(a, b);\n                } else if (opcode == op_and_not) {\n                    d = max(a, -b);\n                }\n            }\n            temp1[i] = d;\n        }    \n\t    add_field(d);\n    }\n    set_source_rgb(hsl(0.6,0.7,0.95));\n    fill_preserve();\n    set_source_rgb(hsl(0.6,0.2,0.5));\n    stroke();\n    \n    // paint brushes\n    set_source_rgba(hsl(0.6,0.2,0.5,0.3));\n    for (int i = 0; i < NUM_BRUSHES; ++i) {\n        vec3 brush = brushes[i];\n\t\tcircle(brush.xy, brush.z);\n\t    stroke();\n    }   \n    \n    set_source_rgba(0.0,0.0,0.0,0.2);\n    move_to(0.0, ray_origin0.y);\n    line_to(0.0, ray_origin1.y);\n    stroke();\n    \n    for (int i = 0; i < 2; ++i) {\n        float y = (i == 0)?ray_origin0.y:ray_origin1.y;\n        // paint ray    \n        set_source_rgba(0.0,0.0,0.0,0.2);\n        move_to(0.0, y);\n        line_to(1.0, y);\n        stroke();    \n        set_source_rgb(vec3(0.0));\n        circle(0.0, y, rdot);\n        fill();    \n        move_to(1.0, y+rdot);\n        line_to(1.0, y-rdot);\n        line_to(1.0+rdot*3.0, y);\n        close_path();\n        fill();\n    }\n    \n    vec2 m = get_query();\n    if (iMouse.z > 0.5) {        \n        set_source_rgba(0.0,0.0,0.0,0.2);\n        move_to(m.x, -1.0);\n        line_to(m.x, 1.0);\n        stroke();\n        {\n            float y = ray_origin0.y;\n            float h = ray_origin1.y - ray_origin0.y;            \n            Edge d;\n            for (int i = 0; i < NUM_CSG_OPS; ++i) {\n                CSG_OP op = get_op(i);\n                int opcode = op[0];\n                if (opcode == op_set) {\n                    d = interval_edge(get_brush_interval(op[1]), m.x);\n                } else {\n                    Edge a = get_temp2(op[1]);\n                    Edge b = get_temp2(op[2]);\n                    if (opcode == op_or) {\n                        d = csg_or(a, b);\n                    } else if (opcode == op_and) {\n                        d = csg_and(a, b);\n                    } else if (opcode == op_and_not) {\n                        d = csg_and_not(a, b);\n                    } else {\n                        d = Edge(infinity, true);\n                    }\n                }\n                y = ray_origin0.y + h*float(NUM_CSG_OPS - i - 1);\n                paint_edge(d, y, h);\n                temp2[i] = d;\n            }\n        }\n    } else {\n        float t = 0.0;\n        float t0 = infinity;\n        float t1 = infinity;\n        for (int i = 0; i < (NUM_CSG_OPS + 1); ++i) {\n            Edge dv = scene_next_feature(t);\n            if (!dv.r) {\n                t0 = t;\n                set_source_rgb(vec3(0.0));\n                circle(t, ray_origin0.y, rdot * 0.7);\n                circle(t, ray_origin1.y, rdot * 0.7);\n                stroke();\n                t = abs(dv.t);\n                t1 = t;\n\t\t        for (int k = 0; k < (NUM_CSG_OPS + 1); ++k) {\n                    if (k < i) continue;\n                    Edge dv = scene_next_feature(t);\n                    if ((dv.t < 0.0) && dv.r) {\n                        t1 = t;\n                        set_source_rgb(vec3(0.0));\n                        circle(t, ray_origin0.y, rdot * 0.7);\n                        circle(t, ray_origin1.y, rdot * 0.7);\n                        fill();\n                        move_to(t, ray_origin0.y);\n                        line_to(t, ray_origin1.y);\n                        stroke();\n                        break;\n                    }\n                    t = abs(dv.t);\n                    if (!dv.r) {\n                        t1 = t;\n                    }\n                    if (t == infinity) break;\n                    float cf = float(k) / float(NUM_CSG_OPS + 1);\n                    set_source_rgb(hsl(cf,0.8,0.7));\n                    move_to(t, ray_origin0.y);\n                    line_to(t, ray_origin1.y);\n                    stroke();\n                }\n                break;\n            }\n            t = dv.t;\n            if (t == infinity) break;\n            float cf = float(i) / float(NUM_CSG_OPS + 1);\n            set_source_rgb(hsl(cf,0.8,0.7));\n            move_to(t, ray_origin0.y);\n            line_to(t, ray_origin1.y);\n            stroke();\n        }\n        if (t0 < infinity) {\n            float d;\n            for (int i = 0; i < NUM_CSG_OPS; ++i) {\n                CSG_OP op = get_op(i);\n                int opcode = op[0];\n                if (opcode == op_set) {\n                    vec4 bv = get_brush_interval(op[1]);\n                    if ((bv.x >= t1)||(bv.y <= t0)) {\n                        d = 1.0;\n                    } else if ((bv.z <= t0) && (bv.w >= t1)) {\n                        d = -1.0;                        \n                    } else {     \n                        vec3 brush = get_brush(op[1]);\n                        set_source_rgba(0.3,0.0,0.0,0.3);\n                        circle(brush.xy, brush.z);\n                        stroke();                        \n                    \td = dCircle(p, brush);\n                    }\n                } else {\n                    float a = get_temp1(op[1]);\n                    float b = get_temp1(op[2]);\n                    if (opcode == op_or) {\n                        d = min(a, b);\n                    } else if (opcode == op_and) {\n                        d = max(a, b);\n                    } else if (opcode == op_and_not) {\n                        d = max(a, -b);\n                    }\n                }\n                temp1[i] = d;\n            }    \n            add_field(d);\n            set_source_rgba(hsl(0.0,1.0,0.5,0.3));\n            fill_preserve();\n            set_source_rgba(hsl(0.0,0.2,0.5,0.5));\n            stroke();\n            {\n            \tfloat y = ray_origin0.y;\n            \tfloat h = ray_origin1.y - ray_origin0.y;\n                rectangle(t0,y,t1 - t0,h);\n\t            set_source_rgba(hsl(0.0,1.0,0.5,0.3));\n                fill();\n            }\n        }\n    }\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    c = c / _stack.scale.x;\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2795, 2877, 2924, 2924, 3121], [3123, 3123, 3159, 3159, 3206], [3208, 3236, 3265, 3265, 3396], [3398, 3426, 3464, 3464, 3630], [3772, 3959, 3988, 3988, 6934], [6936, 7088, 7112, 7112, 7243], [7245, 7273, 7299, 7299, 7427], [7429, 7457, 7482, 7482, 7622], [7624, 7624, 7665, 7665, 8065], [8067, 8067, 8089, 8089, 8119], [8121, 8121, 8150, 8150, 8335], [8336, 8336, 8366, 8366, 8619], [8620, 8620, 8654, 8654, 8691], [8693, 8693, 8727, 8727, 9394], [15140, 15205, 15249, 15249, 16371], [16373, 16373, 16387, 16387, 23232], [23386, 23446, 23473, 23473, 23499], [23501, 23561, 23582, 23582, 23689], [23691, 23691, 23728, 23728, 23814], [23816, 23816, 23862, 23862, 23895], [23897, 24035, 24063, 24063, 24523], [24551, 24551, 24570, 24570, 24603], [24605, 24605, 24623, 24623, 24656], [24658, 24658, 24682, 24682, 24786], [24788, 24788, 24805, 24805, 24826], [24828, 24828, 24855, 24877, 25160], [25162, 25162, 25190, 25190, 25424], [25426, 25426, 25450, 25450, 25536], [25538, 25538, 25565, 25565, 25778], [25780, 25780, 25806, 25806, 26034], [26036, 26036, 26058, 26058, 26184], [26186, 26186, 26206, 26206, 26266], [26268, 26268, 26300, 26300, 26327], [26329, 26329, 26350, 26350, 26372], [26374, 26374, 26398, 26398, 26458], [26460, 26460, 26494, 26494, 26518], [26520, 26520, 26534, 26534, 26598], [26600, 26600, 26626, 26626, 26658], [26660, 26660, 26686, 26686, 26707], [26709, 26709, 26732, 26732, 26827], [26829, 26829, 26853, 26853, 26922], [26924, 26924, 26949, 26949, 27024], [27026, 27026, 27043, 27043, 27156], [27158, 27158, 27181, 27181, 27310], [27312, 27312, 27340, 27340, 27468], [27470, 27470, 27494, 27494, 27634], [27636, 27636, 27674, 27674, 27808], [27810, 27810, 27847, 27847, 27882], [27884, 27884, 27911, 27911, 27961], [27963, 27963, 27993, 27993, 28049], [28051, 28051, 28080, 28080, 28261], [28263, 28263, 28285, 28285, 28452], [28454, 28454, 28467, 28467, 28506], [28508, 28508, 28538, 28538, 28567], [28569, 28569, 28602, 28602, 28659], [28661, 28661, 28687, 28687, 28737], [28739, 28739, 28760, 28760, 28825], [28827, 28827, 28851, 28851, 28934], [28936, 28936, 28951, 28951, 28992], [28994, 28994, 29010, 29010, 29048], [29050, 29050, 29068, 29068, 29125], [29127, 29127, 29157, 29157, 29527], [29529, 29529, 29587, 29587, 29625], [29627, 29627, 29656, 29656, 29692], [29694, 29694, 29742, 29742, 29773], [29775, 29775, 29809, 29809, 29868], [29870, 29870, 29947, 29947, 30112], [30114, 30114, 30191, 30191, 30271], [30273, 30273, 30349, 30349, 30465], [30467, 30467, 30543, 30543, 30621], [30623, 30623, 30661, 30661, 30695], [30697, 30697, 30719, 30719, 30765], [30767, 30767, 30794, 30794, 30838], [30840, 30840, 30889, 30889, 31150], [31152, 31152, 31225, 31225, 31279], [31281, 31281, 31313, 31313, 31349], [31351, 31351, 31407, 31407, 31463], [31465, 31465, 31495, 31495, 31588], [31589, 31589, 31629, 31629, 31652], [31654, 31700, 31739, 31739, 32895], [32897, 32897, 32927, 32927, 33029], [33031, 33031, 33083, 33083, 33123], [33125, 33125, 33147, 33147, 33198], [33200, 33200, 33232, 33232, 33254], [33256, 33271, 33293, 33293, 33585], [33587, 33587, 33619, 33619, 33641], [33643, 33643, 33662, 33662, 33694], [33743, 33806, 33848, 33848, 33914], [33916, 33986, 34037, 34037, 34389], [34391, 34425, 34471, 34471, 34983], [34985, 35054, 35100, 35100, 35606], [35608, 35608, 35641, 35641, 35857], [35859, 35859, 35918, 35918, 35963], [35965, 35965, 36008, 36008, 36069], [36071, 36071, 36113, 36113, 36155], [36157, 36217, 36274, 36274, 36473]]}
{"id": "MtjyzR", "name": "Simplex Slicing", "author": "paniq", "description": "efficient and robust intersection of 2-quad, 2-simplex and 3-simplex with planes.", "tags": ["intersection", "tetrahedron", "plane"], "likes": 13, "viewed": 635, "published": "Public API", "date": "1507296753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simplex Toolkit\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n\nstruct simplex2 {\n    vec2 v[3];\n};\n\nstruct quad2 {\n    vec2 v[4];\n};\n\nstruct simplex3 {\n    vec3 v[4];\n};\n\nvoid simplex2_transform(in simplex2 src, in mat3 mtx, out simplex2 dest) {\n    for (int i = 0; i < 3; ++i) {\n    \tdest.v[i] = (vec3(src.v[i],1.0) * mtx).xy;\n\t}\n}\n\nvoid simplex3_transform(in simplex3 src, in mat4 mtx, out simplex3 dest) {\n    for (int i = 0; i < 4; ++i) {\n    \tdest.v[i] = (vec4(src.v[i],1.0) * mtx).xyz;\n\t}\n}\n\n// d0: dot((p0,1), plane)\n// d1: dot((p1,1), plane)\nvec3 intersect_plane_edge(vec4 plane, float d0, float d1, vec3 p0, vec3 p1) {\n    float D = d1 - d0;\n    float t = ((D == 0.0)?0.0:(-d0/D));\n    return p0 * (1.0 - t) + p1 * t;\n}\n\n#define INTERSECT1(I,A,B) p[I] = intersect_plane_edge(plane, d[A], d[B], src.v[A], src.v[B])\n#define INTERSECT3(R,A,B,C) INTERSECT1(0,R,A); INTERSECT1(1,R,B); INTERSECT1(2,R,C); return 3;\n#define INTERSECT4(L1,L2,R1,R2) INTERSECT1(0,L1,R1); INTERSECT1(1,L1,R2); INTERSECT1(2,L2,R2); INTERSECT1(3,L2,R1); return 4;\n\n// slice a 3-simplex by a plane to return 0, 3 or 4 points describing\n// the resulting polytope embedded in 3-space.\n// with support for dynamic indexing, one can store the index map in a table\nint simplex3_slice(in simplex3 src, vec4 plane, out vec3 p[4]) {\n    float d[4];\n    for (int i = 0; i < 4; ++i) {\n        d[i] = dot(vec4(src.v[i],1.0), plane);\n    }\n    int idx = \n          ((sign(d[0]) < 0.0)?0:1)\n        + ((sign(d[1]) < 0.0)?0:2)\n        + ((sign(d[2]) < 0.0)?0:4)\n        + ((sign(d[3]) < 0.0)?0:8);\n    idx = (idx > 7)?(15 - idx):idx;\n    if (idx == 1) {\n        // 3 2 1| 0\n        INTERSECT3(0,1,2,3);\n    } else if (idx == 2) {\n        // 3 2 0 | 1\n        INTERSECT3(1,0,2,3);\n    } else if (idx == 3) {\n        // 3 2 | 1 0\n        INTERSECT4(0,1,2,3);\n    } else if (idx == 4) {\n        // 3 1 0 | 2\n        INTERSECT3(2,0,1,3);\n    } else if (idx == 5) {\n        // 3 1 | 2 0\n        INTERSECT4(0,2,1,3);\n    } else if (idx == 6) {\n        // 2 1 | 3 0\n        INTERSECT4(0,3,1,2);\n    } else if (idx == 7) {\n        // 2 1 0 | 3\n        INTERSECT3(3,0,1,2);\n    } else {\n        // | 3 2 1 0\n        return 0;        \n    }    \n}\n\n#define INTERSECT2(R,A,B) INTERSECT1(0,R,A); INTERSECT1(1,R,B); return 2;\n\n// d0: dot((p0,1), plane)\n// d1: dot((p1,1), plane)\nvec2 intersect_plane_edge(vec3 plane, float d0, float d1, vec2 p0, vec2 p1) {\n    float D = d1 - d0;\n    float t = ((D == 0.0)?0.0:(-d0/D));\n    return p0 * (1.0 - t) + p1 * t;\n}\n\n// slice a 2-simplex by a 2-plane to return 0 or 2 points describing\n// the resulting line.\n// with support for dynamic indexing, one can store the index map in a table\nint simplex2_slice(in simplex2 src, vec3 plane, out vec2 p[2]) {\n    float d[3];\n    for (int i = 0; i < 3; ++i) {\n        d[i] = dot(vec3(src.v[i],1.0), plane);\n    }\n    int idx = \n          ((sign(d[0]) < 0.0)?0:1)\n        + ((sign(d[1]) < 0.0)?0:2)\n        + ((sign(d[2]) < 0.0)?0:4);\n    idx = (idx > 3)?(7 - idx):idx;\n    if (idx == 1) {\n        // 2 1 | 0\n        INTERSECT2(0,1,2);\n    } else if (idx == 2) {\n        // 2 0 | 1\n        INTERSECT2(1,0,2);\n    } else if (idx == 3) {\n        // 1 0 | 2\n        INTERSECT2(2,0,1);\n    } else {\n        // | 2 1 0\n        return 0;       \n    }\n}\n\n#define INTERSECT22(A,B,C,D) INTERSECT1(0,A,B); INTERSECT1(1,C,D); return 2;\n\n// slice a quad by a 2-plane to return 0 or 2 points describing\n// the resulting line.\n// with support for dynamic indexing, one can store the index map in a table\nint quad2_slice(in quad2 src, vec3 plane, out vec2 p[2]) {\n    float d[4];\n    for (int i = 0; i < 4; ++i) {\n        d[i] = dot(vec3(src.v[i],1.0), plane);\n    }\n    int idx = \n          ((sign(d[0]) < 0.0)?0:1)\n        + ((sign(d[1]) < 0.0)?0:2)\n        + ((sign(d[2]) < 0.0)?0:4)\n        + ((sign(d[3]) < 0.0)?0:8);\n    idx = (idx > 7)?(15 - idx):idx;\n    if (idx == 1) {\n        // 3 2 1 | 0\n        INTERSECT2(0,1,3);\n    } else if (idx == 2) {\n        // 3 2 0 | 1\n        INTERSECT2(1,0,2);\n    } else if (idx == 3) {\n        // 3 2 | 1 0\n        INTERSECT22(0,3,1,2);\n    } else if (idx == 4) {\n        // 3 1 0 | 2\n        INTERSECT2(2,3,1);\n    } else if (idx == 5) {\n        // 3 1 | 2 0\n        // impossible with convex quad\n        return 0;\n    } else if (idx == 6) {\n        // 2 1 | 3 0\n        INTERSECT22(0,1,2,3);\n    } else if (idx == 7) {\n        // 2 1 0 | 3\n        INTERSECT2(3,0,2);\n    } else {\n        // | 3 2 1 0\n        return 0;        \n    }\n}\n\n#undef INTERSECT1\n#undef INTERSECT2\n#undef INTERSECT22\n#undef INTERSECT3\n#undef INTERSECT4\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// construct a quaternion from an axis and angle\nvec4 versor(vec3 w, float a) {\n    a *= 0.5;\n    return vec4(w * sin(a), cos(a));\n}\n\nmat4 viewmat;\n\n// rotation matrix constructor from versor\nmat3 rotation (vec4 q) {\n    float n = dot(q,q);\n    vec4 qs = (n == 0.0)?vec4(0.0):(q * (2.0 / n));\n    vec3 w = qs.w * q.xyz;\n    vec3 x = qs.x * q.xyz;\n    vec3 y = qs.y * q.xyz;\n    float zz = qs.z * q.z;\n    return mat3(\n        1.0 - (y.y + zz), x.y + w.z, x.z - w.y,\n        x.y - w.z, 1.0 - (x.x + zz), y.z + w.x,\n        x.z + w.y, y.z - w.x, 1.0 - (x.x + y.y));\n}\n\nvec2 tf(vec3 p) {\n    p.xyz = p.yzx;\n    p = (vec4(p,1.0) * viewmat).xyz;\n    p.z += 2.0;\n    vec2 uv = p.xy / p.z;\n    return uv * 2.0;\n}\n\nvoid paint() {\n    float t = iTime;\n    \n    viewmat = mat4(rotation(versor(vec3(1.0,0.0,0.0),0.25)));\n    \n    float a = t*0.5;\n    float c = cos(a);\n    float s = sin(a);\n    mat2 rot_mtx = mat2(\n        -s, c,\n         c, s\n    );\n    \n    simplex3 obj3;\n    mat4 mtx = mat4(rot_mtx);\n    simplex3 obj;\n    obj.v[0] = vec3(-0.3);\n    obj.v[1] = obj.v[0] + vec3(1.0,0.0,0.0);\n    obj.v[2] = obj.v[0] + vec3(0.0,1.0,0.0);\n    obj.v[3] = obj.v[0] + vec3(0.0,0.0,1.0);\n    simplex3_transform(obj, mtx, obj3);        \n    \n    set_line_width_px(1.3);\n    set_source_rgb(1.0,1.0,0.0);\n    move_to(tf(obj3.v[1]));\n    line_to(tf(obj3.v[2]));\n    stroke();\n    set_source_rgb(1.0,0.0,0.0);\n    move_to(tf(obj3.v[0]));\n    line_to(tf(obj3.v[1]));\n    stroke();\n    set_source_rgb(0.0,1.0,0.0);\n    move_to(tf(obj3.v[0]));\n    line_to(tf(obj3.v[2]));\n    stroke();\n    set_source_rgb(0.0,0.0,1.0);\n    move_to(tf(obj3.v[0]));\n    line_to(tf(obj3.v[3]));\n    stroke();\n    set_source_rgb(0.0,1.0,1.0);\n    move_to(tf(obj3.v[2]));\n    line_to(tf(obj3.v[3]));\n    stroke();\n    set_source_rgb(1.0,0.0,1.0);\n    move_to(tf(obj3.v[1]));\n    line_to(tf(obj3.v[3]));\n    stroke();\n    \n#if 0\n    quad2 obj2;\n    obj2.v[0] = vec2(-1.0, -1.0)*0.5;\n    obj2.v[1] = vec2( 1.0, -1.0)*0.5;\n    obj2.v[2] = vec2( 1.0,  1.0)*0.5;\n    obj2.v[3] = vec2(-1.0,  1.0)*0.5;\n    for (int i = 0; i <= 8; ++i) {\n        float d = ((float(i)/8.0)-0.5)*1.0;\n        set_source_rgb(0.5,0.2,1.0);\n        vec3 plane = vec3(s,c,d);\n        vec2 p[2];\n        int count = quad2_slice(obj2, plane, p);\n        if (count == 2) {\n            move_to(tf(vec3(p[0],-0.3)));\n            line_to(tf(vec3(p[1],-0.3)));\n            stroke();\n        }\n    }    \n#else\n    simplex2 obj2;\n    obj2.v[0] = obj3.v[0].xy;\n    obj2.v[1] = obj3.v[1].xy;\n    obj2.v[2] = obj3.v[2].xy;\n    for (int i = 0; i <= 8; ++i) {\n        float d = ((float(i)/8.0)-0.5)*1.0;\n        set_source_rgb(0.5,0.2,1.0);\n        vec3 plane = vec3(s,c,d);\n        vec2 p[2];\n        int count = simplex2_slice(obj2, plane, p);\n        if (count == 2) {\n            move_to(tf(vec3(p[0],-0.3)));\n            line_to(tf(vec3(p[1],-0.3)));\n            stroke();\n        }\n    }\n#endif\n    \n    for (int i = 0; i <= 8; ++i) {\n        float d = ((float(i)/8.0)-0.5)*1.0;\n        vec4 cutplane = vec4(rotation(versor(normalize(vec3(1.0,1.0,0.0)), t*0.72))[2], d);\n        vec3 p[4];\n        int count = simplex3_slice(obj3, cutplane, p);\n        set_source_rgb(vec3(0.0));\n        if (count == 3) {\n            move_to(tf(p[0]));\n            line_to(tf(p[1]));\n            line_to(tf(p[2]));\n            close_path();\n            stroke();        \n        } else if (count == 4) {\n            move_to(tf(p[0]));\n            line_to(tf(p[1]));\n            line_to(tf(p[2]));\n            line_to(tf(p[3]));\n            close_path();\n            stroke();        \n        }\n    }\n   \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));\n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\n    float m = ab.x*p.x/l;\n\tfloat n = ab.y*p.y/l;\n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n\n    vec2 r = vec2( ab.x*co, ab.y*si );\n\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjyzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 205, 279, 279, 366], [368, 368, 442, 442, 530], [532, 584, 661, 661, 762], [1079, 1273, 1337, 1337, 2235], [2312, 2364, 2441, 2441, 2542], [2544, 2713, 2777, 2777, 3313], [3393, 3557, 3615, 3615, 4532], [10435, 10484, 10514, 10514, 10567], [10584, 10627, 10651, 10651, 11000], [11002, 11002, 11019, 11019, 11140], [11142, 11142, 11156, 11156, 14043], [14197, 14257, 14284, 14284, 14310], [14312, 14372, 14393, 14393, 14500], [14502, 14502, 14539, 14539, 14625], [14627, 14627, 14673, 14673, 14706], [14708, 14846, 14874, 14874, 15334], [15362, 15362, 15381, 15381, 15414], [15416, 15416, 15434, 15434, 15467], [15469, 15469, 15493, 15493, 15597], [15599, 15599, 15616, 15616, 15637], [15639, 15639, 15666, 15688, 15971], [15973, 15973, 16001, 16001, 16235], [16237, 16237, 16261, 16261, 16347], [16349, 16349, 16376, 16376, 16589], [16591, 16591, 16617, 16617, 16845], [16847, 16847, 16869, 16869, 16995], [16997, 16997, 17017, 17017, 17077], [17079, 17079, 17111, 17111, 17138], [17140, 17140, 17161, 17161, 17183], [17185, 17185, 17209, 17209, 17269], [17271, 17271, 17305, 17305, 17329], [17331, 17331, 17345, 17345, 17409], [17411, 17411, 17437, 17437, 17475], [17477, 17477, 17503, 17503, 17524], [17526, 17526, 17549, 17549, 17644], [17646, 17646, 17670, 17670, 17739], [17741, 17741, 17766, 17766, 17813], [17815, 17815, 17832, 17832, 17945], [17947, 17947, 17970, 17970, 18099], [18101, 18101, 18129, 18129, 18257], [18259, 18259, 18283, 18283, 18423], [18425, 18425, 18463, 18463, 18597], [18599, 18599, 18636, 18636, 18671], [18673, 18673, 18700, 18700, 18750], [18752, 18752, 18782, 18782, 18838], [18840, 18840, 18869, 18869, 19050], [19052, 19052, 19074, 19074, 19233], [19235, 19235, 19248, 19248, 19287], [19289, 19289, 19319, 19319, 19348], [19350, 19350, 19383, 19383, 19440], [19442, 19442, 19468, 19468, 19518], [19520, 19520, 19541, 19541, 19606], [19608, 19608, 19632, 19632, 19715], [19717, 19717, 19732, 19732, 19773], [19775, 19775, 19791, 19791, 19829], [19831, 19831, 19849, 19849, 19906], [19908, 19908, 19938, 19938, 20308], [20310, 20310, 20368, 20368, 20406], [20408, 20408, 20437, 20437, 20473], [20475, 20475, 20523, 20523, 20554], [20556, 20556, 20590, 20590, 20649], [20651, 20651, 20728, 20728, 20893], [20895, 20895, 20972, 20972, 21052], [21054, 21054, 21130, 21130, 21246], [21248, 21248, 21324, 21324, 21402], [21404, 21404, 21442, 21442, 21476], [21478, 21478, 21500, 21500, 21546], [21548, 21548, 21575, 21575, 21619], [21621, 21621, 21670, 21670, 21931], [21933, 21933, 22006, 22006, 22060], [22062, 22062, 22094, 22094, 22130], [22132, 22132, 22188, 22188, 22244], [22246, 22246, 22276, 22276, 22369], [22370, 22370, 22410, 22410, 22433], [22435, 22481, 22520, 22520, 23668], [23670, 23670, 23700, 23700, 23802], [23804, 23804, 23856, 23856, 23896], [23898, 23898, 23920, 23920, 23971], [23973, 23973, 24005, 24005, 24027], [24029, 24044, 24066, 24066, 24358], [24360, 24360, 24392, 24392, 24414], [24416, 24416, 24435, 24435, 24467], [24516, 24579, 24621, 24621, 24687], [24689, 24759, 24810, 24810, 25162], [25164, 25198, 25244, 25244, 25756], [25758, 25827, 25873, 25873, 26379], [26381, 26381, 26414, 26414, 26630], [26632, 26632, 26691, 26691, 26736], [26738, 26738, 26781, 26781, 26842], [26844, 26844, 26886, 26886, 26923], [26925, 26985, 27042, 27042, 27241]]}
{"id": "MtlcD4", "name": "Raymarch fake light", "author": "FranciscoGarcia", "description": "Fake light representation, based on the WbGl Paris 2015, i played with some primitive shapes.", "tags": ["3d", "raymarch", "fakeligth"], "likes": 3, "viewed": 364, "published": "Public", "date": "1506817298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.001\nvec2 rot(in vec2 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c) * pos;\n}\n\nfloat plane(in vec3 p) {\n\treturn p.y;\n}\n\nfloat sph(in vec3 p, float rad) {\n    p -= vec3(-4.0, 2.3, 8.0);\n    p.xy = rot(p.xy, iTime);\n    p.xz = rot(p.xz, iTime);\n\treturn length(p) - rad;\n}\n\nfloat box(in vec3 p,in vec3 dim) {\n    p -= vec3(-3.5, 1.3, -2.0);\n    p.yz = rot(p.yz, iTime);\n    p.xy = rot(p.xy, iTime);\n\tfloat d3 = length(max(abs(p)-dim, 0.0)) ;\n    return d3;\n}\n\nfloat torus(in vec3 pos, in vec2 t) {\n    pos -= vec3(3.0, 1.0, 0.3);\n    pos.yz = rot(pos.yz, 0.1*iTime);\n    pos.xy = rot(pos.xy, 0.5*iTime);\n\tvec2 q = vec2(length(pos.xz) - t.x, pos.y);\n    return length(q) - t.y;\n}\n\nfloat map(in vec3 pos) {\n   float d1 = min(plane(pos), sph(pos, 2.0)); \n   float du1 = min(d1,  box(pos, vec3(0.5)));\n   float du2 = min(du1,torus(pos, vec2(1.0, 0.5)));\n   return du2;\n}\n\nvec3 material(in vec3 p) {\n\tp *= 0.6;\n    float f = smoothstep(0.5, 0.51, fract(p.x - sin(p.z) + cos(p.z)));\n    return f*vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = 2.0*uv -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\tvec3 ro = vec3(0.0 + 0.8*sin(iTime), 3.0 + 0.5*cos(iTime), -6.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 col = vec3(0.0);\n    float t = 0.0;\n    \n\tfor(int i=0; i<100; i++){\n        vec3 pos = ro + t*rd;\n\t\tfloat d = map(pos);\n\t\tif( d < EPS ) {\n            float ligthD = sph(pos, 1.0);\n            float ligthT = torus(pos, vec2(1.5, 0.8));\n            float ligthB = box(pos, vec3(0.9));\n\t\t\tcol  = 2.4 / (ligthD*ligthD)*vec3(1.6,0.7,0.0)*material(pos);\n            col += 0.4 / (ligthT*ligthT)*vec3(1.6,0.0,1.0)*material(pos);\n            col += 0.4 / (ligthB*ligthB)*vec3(1.0)*material(pos);\n\t\t\tbreak;\n\t\t}\n\t\tro += d*rd;\n\t}\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlcD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 54, 54, 141], [143, 143, 167, 167, 182], [184, 184, 217, 217, 333], [335, 335, 369, 369, 519], [521, 521, 558, 558, 739], [741, 741, 765, 765, 927], [929, 929, 955, 955, 1063], [1065, 1065, 1122, 1122, 1886]]}
{"id": "MtlcWl", "name": "ML Stripe Shader", "author": "aaaidan", "description": "Stripes and shadows.", "tags": ["2d", "morninglight"], "likes": 0, "viewed": 108, "published": "Public API", "date": "1507032692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// HEY! Mousedown to change area type\n\n// Constants\n#define PI 3.141592654\n#define TWO_PI 6.28318530718\n\n// Parameters\n#define STRIPE_COLOR1 (vec4(194, 216, 68, 255)/255.)\n#define STRIPE_COLOR2 (vec4(194, 216, 68, 0)/255.)\n#define STRIPE_WIDTH 50.0\n#define STRIPE_ANGLE -45.0\n#define BACKGROUND_COLOR (vec4(235, 232, 222, 255)/255.)\n#define CIRCLE_RADIUS 150.0\n#define SHADOW_COLOR (vec4(0,0, 0, 100)/255.)\n#define SHADOW_DEPTH 7.0\n#define SHADOW_SIZE 15.0\n#define SHADOW_SCALE 2.0\n#define GRID_LINE_WIDTH 1.5\n#define GRID_COLOR (vec4(255.,255.,255.,255.)/255.)\n#define GRID_COLOR2 (vec4(0.,0.,0.,9.)/255.)\n#define GRID_X_SIZE 150.0\n#define GRID_Y_SIZE 150.0\n#define EXCLUSION_COLOR (vec4(.4,.4,.4,1.0))\n\n// Calculations\n#define _STRIPE_SCALE (1.0/STRIPE_WIDTH)\n#define _HALF_SHADOW_SIZE (SHADOW_SIZE/2.0)\n\nvec4 blend(in vec4 under, in vec4 over) {\n    float outA = over.a + under.a * (1.0 - over.a);\n    vec3 outCol = vec3(0.0);\n    if (outA > 0.0) {\n    \toutCol = ( over.rgb*over.a + under.rgb*under.a*(1.0-over.a) ) / outA;\n    }\n    return vec4(outCol,outA);\n}\n\nvec4 stripes( in vec2 fragCoord, in bool stripey, float exclusionAmt)\n{\n    vec2 center = iResolution.xy / 2.0;\n    \n    bool inCircle = \n        pow(fragCoord.x - center.x, 2.) + \n        pow(fragCoord.y - center.y, 2.) <\n        CIRCLE_RADIUS * CIRCLE_RADIUS;\n    \n    if (!stripey) {\n        vec4 col = blend(STRIPE_COLOR1, vec4(EXCLUSION_COLOR.rgb,exclusionAmt));\n        return inCircle ? col : vec4(col.rgb, 0.0);\n    }\n    \n    float angle = (STRIPE_ANGLE) / 360.0 * TWO_PI;\n    \n    float sx = sin(angle) * (fragCoord.x - iMouse.x);\n    float sy = cos(angle) * (fragCoord.y - iMouse.y);\n    \n    float amt = sin((sx + sy) * TWO_PI * _STRIPE_SCALE);\n    \n    vec4 color = amt > 0.0 ? vec4(STRIPE_COLOR1) : vec4(STRIPE_COLOR2);\n    \n    return vec4(color.rgb, inCircle ? color.a : 0.0);\n}\n\nfloat smoothbump(float min, float max, float slope, float val) {\n    return smoothstep(min,min+slope,val) - \n        smoothstep(max-slope, max, val);\n}\n\nvec4 grid(in vec2 fragCoord) {\n    float angle = (STRIPE_ANGLE + iTime*3.6) / 360.0 * TWO_PI;\n    \n    vec2 s1 = vec2(\n        sin(angle) * (fragCoord.x - iMouse.x),\n    \tcos(angle) * (fragCoord.y - iMouse.y)\n\t);\n    vec2 s2 = vec2(\n        sin(angle + PI/2.0) * (fragCoord.x - iMouse.x),\n    \tcos(angle + PI/2.0) * (fragCoord.y - iMouse.y)\n\t);\n    \n    float sizeMod = (sin(iTime*0.15)*0.5+0.5) * 50.0;\n    \n    float amt = min(1.0,\n        smoothbump(0.0, GRID_LINE_WIDTH + 1.0, 1.0, mod(s1.x + s1.y, GRID_X_SIZE + sizeMod) ) +\n        smoothbump(0.0, GRID_LINE_WIDTH + 1.0, 1.0, mod(s2.x + s2.y, GRID_Y_SIZE + sizeMod) )\n\t);\n    \n    return vec4(GRID_COLOR.rgb, amt * GRID_COLOR.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    bool stripey = iMouse.z > 0.0;\n    float exclusionAmt = (!stripey ? 1.0 : 0.0) * (1.0 - smoothstep(iResolution.x*0.4 + 0.,iResolution.x*0.4 + 1.,fragCoord.x - fragCoord.y*0.1));\n    \n    vec4 grid = grid(fragCoord);\n    \n\tfragColor  = stripes(fragCoord + vec2(-.25,-.25), stripey, exclusionAmt);\n    fragColor += stripes(fragCoord + vec2(-.25, .25), stripey, exclusionAmt);\n    fragColor += stripes(fragCoord + vec2( .25,-.25), stripey, exclusionAmt);\n    fragColor += stripes(fragCoord + vec2( .25, .25), stripey, exclusionAmt);\n    fragColor /= 4.0;\n    \n    float grid2Amt = GRID_COLOR2.a * grid.a;\n    \n    fragColor = vec4( GRID_COLOR2.rgb * grid2Amt + fragColor.rgb * (1. - grid2Amt),\n                     fragColor.a);\n    \n    if (!stripey) {\n        \n        // outline\n        float minOutlineSample = 999999.;\n        \n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2( 2.1,-2.1), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2(-2.1,-2.1), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2( 2.1, 2.1), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2(-2.1, 2.1), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2( 0.0,-3.0), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2( 0.0, 3.0), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2( 3.0, 0.0), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2(-3.0, 0.0), stripey, 0.0).a);\n        \n        float outlineAmt = (1.0 - minOutlineSample);\n        \n        fragColor = vec4(\n            outlineAmt * vec3(1.0,1.0,1.0) + (1.-outlineAmt) * fragColor.rgb,\n            fragColor.a);\n        \n        // shadow\n        float totalSamples = 0.0;\n        float shadowAmt = 0.0;\n        for (float x=0.;x < SHADOW_SIZE; x+=1.) {\n            for (float y=0.;y < SHADOW_SIZE; y+=1.) {\n                // this is my attempt at a circular (lens) blur \n                float sampleAmt = length(SHADOW_SCALE*(vec2(x,y) - _HALF_SHADOW_SIZE));\n                sampleAmt = 1.0 - step(SHADOW_SCALE*_HALF_SHADOW_SIZE, sampleAmt);\n\n                shadowAmt += stripes(\n                    fragCoord + vec2(\n                        SHADOW_SCALE*(x - _HALF_SHADOW_SIZE),\n                        SHADOW_SCALE*(y - _HALF_SHADOW_SIZE) + SHADOW_DEPTH\n                    ),\n                    stripey, 0.0\n                ).a * sampleAmt;\n                totalSamples += sampleAmt;\n            }\n        }\n        shadowAmt /= totalSamples;\n        \n    \tvec4 shadow = vec4(SHADOW_COLOR.rgb, SHADOW_COLOR.a * shadowAmt);\n    \tfragColor = blend(shadow, fragColor);\n    }\n    \n    // grid\n    fragColor = blend(grid, fragColor);\n    \n    fragColor = blend(BACKGROUND_COLOR, fragColor);\n    \n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[705, 807, 848, 848, 1064], [1066, 1066, 1137, 1137, 1860], [1862, 1862, 1926, 1926, 2013], [2015, 2015, 2045, 2045, 2702], [2704, 2704, 2761, 2761, 5719]]}
{"id": "MtlyWl", "name": "Flexibility", "author": "dr2", "description": "Accordion tube arms (mouse enabled)", "tags": ["tube", "flex", "accordion", "concertina"], "likes": 6, "viewed": 405, "published": "Public API", "date": "1507021775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Flexibility\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\n\nvec3 ltDir;\nvec2 arcLim, dpLoop, qBlk;\nfloat tCur, dstFar, rLoop, aLoop, rBase, rTop, rIn;\nint idObj;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, rVar, cExt, s, r;\n  cExt = 0.3;\n  rVar = 0.02;\n  p.y -= 8. * cExt;\n  dMin = dstFar;\n  qq = p;\n  qq.xz = Rot2D (p.xz, 2. * pi * (floor (3. * atan (p.z, - p.x) / (2. * pi) + 0.5) / 3.));\n  qq.x -= - rBase;\n  q = qq;  q.x -= rLoop;\n  q.xy = Rot2D (q.xy, aLoop);\n  s = mod (30. * atan (q.y, - q.x) / (pi * aLoop), 1.);\n  d = PrTorusDf (q, rIn + rVar * SmoothBump (0.25, 0.75, 0.1, s), rLoop);\n  d = max (d, dot (vec2 (q.x, abs (q.y)), arcLim));\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q = qq;  q.x -= rLoop;  q.xy -= dpLoop;\n  q.xy = Rot2D (q.xy, aLoop);\n  s = mod (30. * atan (q.y, q.x) / (pi * aLoop), 1.);\n  d = PrTorusDf (q, rIn + rVar * SmoothBump (0.25, 0.75, 0.1, s), rLoop);\n  d = max (d, dot (vec2 (- q.x, abs (q.y)), arcLim));\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q = qq;  q.y -= -4. * cExt;\n  d = PrRCylDf (q.xzy, rIn + rVar, 0.05, 4. * cExt + 0.05);\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q = qq;  q.xy -= vec2 (2. * rLoop, cExt) + dpLoop;\n  d = PrRCylDf (q.xzy, rIn + rVar, 0.05, cExt + 0.05);\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q = p;  q.y -= dpLoop.y + 2. * cExt + 0.5 * rIn + 3. * rVar;\n  q.xz = Rot2D (q.xz, - pi / 18.);\n  r = rBase - 2. * rLoop - dpLoop.x;\n  s = mod (9. * atan (q.x, - q.z) / (2. * pi), 1.);\n  d = PrTorusDf (q.xzy, 0.5 * rIn + 2. * rVar *\n     SmoothBump (0.5 - 0.15 / r, 0.5 + 0.15 / r, 0.01, s), r);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = p;  q.y -= -4. * cExt;\n  q.y = abs (q.y) - cExt;\n  d = PrTorusDf (q.xzy, 0.35 * rIn, rBase);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = p;  q.y -= -8. * cExt - 0.05 - 0.01;\n  d = PrCylDf (q.xzy, rBase + 0.3, 0.01);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q = p;  q.y -= dpLoop.y + 2. * cExt + 0.5 * rIn + 3. * rVar;\n  d = PrCylDf (q.xzy, rTop, 0.02);\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.002, -0.002, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvoid BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, qnBlk;\n  float dn, df, bSize;\n  bSize = 10. * dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  if (df > 0. && dn < df) {\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, qnBlk), dot (u.yzx, qnBlk)) / bSize;\n  }\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float u;\n  u = rd.y + 1.;\n  return vec3 (0.5, 0.5, 1.) * (0.05 + 0.245 * u * u);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj;\n  rLoop = 2. + 1.2 * sin (0.1 * 2. * pi * tCur);\n  aLoop = 0.5 * pi / rLoop;\n  arcLim = vec2 (sin (1.01 * aLoop), cos (1.01 * aLoop));\n  dpLoop = 2. * rLoop * vec2 (- cos (2. * aLoop), sin (2. * aLoop));\n  rIn = 0.2;\n  rBase = 6.;\n  rTop = rBase - 2. * rLoop - dpLoop.x - 0.65 * rIn;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar && idObj == 1) {\n    vn = ObjNf (ro + dstObj * rd);\n    if (vn.y > 0.99) {\n      ro += dstObj * rd;\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 3) {\n      col = vec3 (0.9, 0.9, 1.) * (0.5 - 0.5 * dot (rd, vn)) / (1. + 0.6 * pow (length (ro.xz) / rTop, 4.));\n    } else if (idObj == 4) {\n      col = vec3 (0.9, 0.9, 0.8);\n      col = col * (0.1 + 0.9 * max (dot (vn, ltDir), 0.)) +\n         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    } else {\n      col = vec3 (0.5, 0.4, 0.);\n      col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n         0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    }\n    if (idObj == 4) {\n      BlkHit (ro, reflect (rd, vn));\n      qBlk = mod (8. * qBlk, 1.);\n      col = mix (col, vec3 (0.5) * (0.5 + 0.5 * SmoothBump (0.1, 0.9, 0.02, qBlk.x) *\n         SmoothBump (0.1, 0.9, 0.02, qBlk.y)), 0.2);\n    }\n  } else {\n    col = BgCol (rd);\n    BlkHit (ro, rd);\n    qBlk = mod (8. * qBlk, 1.);\n    col = mix (col, vec3 (0.5) * (0.9 + 0.1 * SmoothBump (0.1, 0.9, 0.02, qBlk.x) *\n       SmoothBump (0.1, 0.9, 0.02, qBlk.y)), 0.2);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = pi / 6.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.05 * tCur;\n    el += 0.1 * pi * sin (0.03 * 2. * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 2., -30.);\n  rd = vuMat * normalize (vec3 (uv, 3.2));\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (pow (ShowScene (ro, rd), vec3 (0.8)), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlyWl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 477, 499, 499, 2356], [2358, 2358, 2391, 2391, 2568], [2570, 2570, 2591, 2591, 2793], [2795, 2795, 2827, 2827, 3326], [3328, 3328, 3350, 3350, 3435], [3437, 3437, 3472, 3472, 5104], [5106, 5106, 5159, 5159, 6006], [6008, 6008, 6050, 6050, 6101], [6103, 6103, 6156, 6156, 6335], [6337, 6337, 6383, 6383, 6440], [6442, 6442, 6472, 6472, 6530], [6532, 6532, 6589, 6589, 6672]]}
{"id": "MtScD1", "name": "PurpleSeven", "author": "Del", "description": "// purple seven.\n// tweaked version of this by 'bmodone' - https://www.shadertoy.com/view/4llcDH", "tags": ["blur", "flower", "radial", "cheap", "frig"], "likes": 1, "viewed": 134, "published": "Public", "date": "1508353526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.141592\n\n// tweaked version of this by 'bmodone' - https://www.shadertoy.com/view/4llcDH\n\nfloat radial(vec2 uv, float offset, float repeat)\n{\n    float a = mod((atan(uv.y, uv.x) + M_PI + (offset * 2.0 * M_PI)) * repeat / M_PI, 2.0);\n    return min(a,2.0-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - 0.5* iResolution.xy ) / iResolution.y;\n    \n    float off = length(uv);\n \tfloat d = off - 0.2;\n    float a = radial(uv, sin(off*4.0-iTime*0.5)/16.0, 7.0) - 0.6;\n\n    d = a-d;\n    \n    float m = clamp(-d*2.0, 0.0, 1.0);\n    \n    vec3 col = mix(vec3(0.6, 0.1, 0.9), vec3(0.82, 0.81, 0.6-d), m);\n    \n    col *= (sin(-off * 6.0 - iTime*2.0) / 7.0) + 0.9;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtScD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 104, 155, 155, 273], [275, 275, 332, 332, 747]]}
{"id": "MtSyDh", "name": "Tiled Improved Perlin Noise", "author": "VinceTavernier", "description": "A tiled version of improved perlin noise. Reference implementation: http://mrl.nyu.edu/~perlin/noise/ . Shader code based on https://www.shadertoy.com/view/XscGzl .", "tags": ["noise", "tiled", "perlin", "improved"], "likes": 3, "viewed": 491, "published": "Public API", "date": "1508328081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Permutation table\nconst int p[] = int[](151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180);\n\n// Coordinate hashing function\nfloat gradient(int hash, vec3 unit)\n{\n\tint h = hash & 15;\n    float u = h<8 ? unit.x : unit.y,\n          v = h<4 ? unit.y : (h==12||h==14 ? unit.x : unit.z);\n    return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n}\n\n// Smootherstep interpolant\nvec3 fade(vec3 t)\n{\n    return t*t*t*(t*(6.*t - 15.) + 10.);\n}    \n\n/**\n * The meat of it:\n *\n * It helps to visualize the unit cube:\n *\n *      (0,1,1)----------------(1,1,1)\n *        /|                     /|\n *       / |                    / |\n *      /  |                   /  |\n *     /   |                  /   |\n * (0,1,0)-+--------------(1,1,0) |\n *    |    |                 |    |\n *    |    |                 |    |\n *    |    |                 |    |\n *    | (0,0,1)--------------+-(1,0,1)\n *    |   /                  |   /\n *    |  /                   |  /\n *    | /                    | /\n *    |/                     |/ \n * (0,0,0)----------------(1,0,0)\n */\nfloat noise(in vec3 coord, in int N)\n{\n    coord *= float(N);\n    \n    ivec3 c = ivec3(coord);   // current cell\n    vec3 unit = fract(coord); // orientation in current cell\n   \n    vec3 unit_000 = unit;\n    vec3 unit_100 = unit - vec3(1, 0, 0);\n    vec3 unit_001 = unit - vec3(0, 0, 1);\n    vec3 unit_101 = unit - vec3(1, 0, 1);\n    vec3 unit_010 = unit - vec3(0, 1, 0);\n    vec3 unit_110 = unit - vec3(1, 1, 0);\n    vec3 unit_011 = unit - vec3(0, 1, 1);\n    vec3 unit_111 = unit - 1.;\n    \n    // Hash cell coordinates\n    int A = p[(c.x  ) % N] + c.y, AA = p[A % N] + c.z, AB = p[(A+1) % N] + c.z,\n        B = p[(c.x+1) % N] + c.y, BA = p[B % N] + c.z, BB = p[(B+1) % N] + c.z;\n\n    float x000 = gradient(p[(AA  ) % N], unit_000);\n\tfloat x100 = gradient(p[(BA  ) % N], unit_100);\n\tfloat x010 = gradient(p[(AB  ) % N], unit_010);\n\tfloat x110 = gradient(p[(BB  ) % N], unit_110);\n    float x001 = gradient(p[(AA+1) % N], unit_001);\n\tfloat x101 = gradient(p[(BA+1) % N], unit_101);\n\tfloat x011 = gradient(p[(AB+1) % N], unit_011);\n\tfloat x111 = gradient(p[(BB+1) % N], unit_111);\n\n    // Compute fade curves\n    vec3 w = fade(unit);\n    \n    return mix(mix(mix(x000, x100, w.x),\n                   mix(x010, x110, w.x),\n                   w.y),\n               mix(mix(x001, x101, w.x),\n                   mix(x011, x111, w.x),\n                   w.y),\n               w.z);\n}\t\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    // Number of cells\n    int N = 64;\n    // 0-1 U\n    U /= iResolution.y;\n    \n    //U = fract(2.*U); // uncomment to check tiling\n    \n    // horizontal slice through 3D noise\n    vec3 coord = vec3(U, iTime/200.);\n    \n    O = .5*vec4(noise(coord, N))+.5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSyDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1023, 1054, 1091, 1091, 1271], [1273, 1301, 1320, 1320, 1363], [1369, 1977, 2015, 2015, 3351], [3354, 3354, 3393, 3416, 3654]]}
{"id": "MtSyRz", "name": "random cubic Truchet flow", "author": "mattz", "description": "Keys/mouse do things -- see comments above code.", "tags": ["random", "truchet", "flow", "cubic"], "likes": 30, "viewed": 843, "published": "Public API", "date": "1507155885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n    random cubic Truchet flow, by mattz\n    License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tInspired by:\n\n      Truchet Marbles (Simple) by shau - https://www.shadertoy.com/view/MtlcDs\n      Square Truchet Flow by Shane - https://www.shadertoy.com/view/XtfyDX\n\n\n    Keys:\n\n      D - toggle direction arrows (rotations/reflections of canonical cell)\n      M - toggle camera motion\n      S - toggle spheres\n      T - toggle Truchet torii\n      X - toggle X-axis alternation\n\n\n    Mouse to bottom-left to get default viewing angle.\n\n\n    Analogous to Shane's 2D shader, this fixes the flow directions along cube faces\n    in a repeating fashion. I randomize the torus orientations while confirming to the\n    predetermined flow directions.\n\n    See the documentation of the truchet function below for the meat.\n\n    This calls atan to do the shading along each torus segment, but I make sure\n    to only call it once per pixel when actually shading. \n\n*/\n\n// Bunch of globals/constants:\nconst int rayiter = 60;\nconst float dmax = 20.0;\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\nfloat move_camera = 1.0;\nfloat show_spheres = 1.0;\nfloat show_directions = 0.0;\nfloat show_truchet = 1.0;\nfloat alternate_x = 1.0;\n\nconst float HALFPI = 1.5707963267948966;\nconst float TUBE_SIZE = 0.015;\nconst float SPHERE_SIZE = 0.06;\n\nconst float ARROW_RAD = 0.025;\nvec2 ARROW_HEAD_SLOPE = normalize(vec2(1, 2));\n    \nconst float ARROW_BODY_LENGTH = 0.3;\nconst float ARROW_HEAD_LENGTH = 0.1;\n\n/* RGB from hue. */\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n/* From https://www.shadertoy.com/view/4djSRW */\n#define HASHSCALE1 .1031\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n/* Distance to 3D arrow - steal this if you like! */\nfloat sdArrow(vec3 p, vec3 d) {\n    \n    // component along\n    float t = dot(p, d);\n    \n    // component perp\n    float n = length(p - t*d);\n    \n\t// distance to cylinder body\n    float dist = n - ARROW_RAD;\n    \n    // account for arrowhead size\n    t += 0.5*ARROW_HEAD_LENGTH;\n    \n    // body caps\n    dist = max(dist, abs(t)-0.5*ARROW_BODY_LENGTH);\n    \n    // move to end of arrow\n    t -= 0.5*ARROW_BODY_LENGTH;\n    \n    // cone head\n    dist = min(dist, max(-t, dot(ARROW_HEAD_SLOPE, vec2(t-ARROW_HEAD_LENGTH, n))));\n    \n    return dist;\n    \n}\n\n\n/* Check distance to torus at origin, perpendicular to z axis. */\nfloat sdTorus(vec3 u) {\n    \n    vec2 q = vec2(length(u.xy)-0.5,u.z);\n    float d = length(q) - TUBE_SIZE;\n    d = max(d, max(u.x, u.y));\n\n    return d;\n    \n}\n\n/* Distance to ball along torus segment orbiting origin (same frame as sdTorus). */\nfloat sdBall(vec3 u) {\n    \n    float theta = HALFPI * fract(0.2*iTime);\n\n\t// Is this cheaper than separate sin & cos? I dunno.    \n    vec2 sc = 0.5*sin(vec2(theta, theta+HALFPI));\n    \n    // Need multiple checks to handle ball crossing cube face boundaries!\n    float d = length(u + vec3(sc.x, sc.y, 0));\n    d = min(d, length(u + vec3(sc.y, -sc.x, 0)));\n    d = min(d, length(u + vec3(-sc.y, sc.x, 0)));\n    \n    return d - SPHERE_SIZE;\n\n}\n\n/* Compute edge-relative coords and torus distance given:\n\n    - p is point in cube with vertices at +/- 0.5:\n    - src is outward facing normal of flow source face \n    - dst is outward facing normal of flow sink face\n\n   Returns a vec4 (ux uy uz d) where:\n\n     - ux is distance from src face (negative inside cube)\n     - uy is distance from dst face (also negative inside cube)\n     - uz is projected distance along edge from center (positive or negative)\n     - d is distance to torus.\n\n*/\nvec4 checkTorus(vec3 p, vec3 src, vec3 dst) {\n    \n    vec3 n = cross(dst, src);\n    vec3 ctr = 0.5*(src+dst);\n    \n    p -= ctr;\n    \n    vec3 u = p * mat3(src, dst, n);\n    \n    return vec4(u, sdTorus(u));\n    \n}\n\n/* Chooses vec4 with least last element (useful for comparing checkTorus output) */\nvec4 tmin(vec4 a, vec4 b) {\n    \n    return a.w < b.w ? a : b;\n    \n}\n\n\n/* This is the workhorse of the Truchet arrangement. Input argument is\n   an arbitrary 3D point, which is modified to become relative to cell\n   center and orientation upon output. Also outputs a mat3 of the format\n   output by sdTorus above. \n\n   As you can see by enabling cell directions, every cubic cell in the\n   Truchet tiling has three flow inputs and three outputs. The \"canonical \n   cell\" has flow inputs on the +X, -Y, and +Y faces (and flow outputs on\n   the -X, -Z, +Z) faces.\n\n   In order to get these to tile space, we need to swap Y with Z in a\n   checkerboard pattern along the YZ plane.\n\n   Also, it looks obviously \"fake\" (in my opinion, at least) to have all \n   of the flow from +X to -X, so I also alternate the X direction on\n   successive Y levels. \n\n   So, we now have the \"canonical cell\" potentially with Y/Z swapped, and/or\n   X negated. There are four possible torus segment arrangements within \n   the canonical cell. The table below shows for each input face (+X, -Y, +Y),\n   what output face it connects to:\n\n     case | +X -Y +Y\n     -----+----------\n        0 | -Z -X +Z\n        1 | -Z +Z -X\n        2 | +Z -X -Z\n        3 | +Z -Z -X\n       \n   We choose one of these cases at random for each cell, and get the torus \n   distance for the given point.\n\n*/\nvec4 truchet(inout vec3 pos) {\n\n    // Shift by 0.5 to place world origin at vertex, not cell center\n    pos -= 0.5;\n    \n    // Find center of nearest cell\n    vec3 ctr = floor(pos+0.5);\n    \n    // Subtract off difference\n    pos -= ctr;\n    \n    // Alternating sign on each axis\n    vec3 s = sign(mod(ctr, 2.0) - 0.5);\n    \n    // Swap Y and Z in checkerboard pattern.\n    if (s.y * s.z > 0.0) { pos.yz = pos.zy; }\n\n    // Alternate sign on X within cell if desired\n    if (alternate_x > 0.0) { pos.x *= -s.y; }\n\n    // Get case and set up destination axes\n    float k = hash13(ctr) * 4.0;\n    \n    mat3 dst = mat3(0, 0, -1, \n                    -1, 0, 0, \n                    0, 0, 1);                \n    \n    if (k < 2.0) {\n        if (k < 1.0) {\n            // NOP - just use setup above\n            // dst = dst\n        } else {\n            dst = mat3(dst[0], dst[2], dst[1]); \n        }\n    } else {\n        if (k < 3.0) {\n            dst = mat3(dst[2], dst[0], dst[1]); \n        } else {\n            dst = mat3(dst[2], dst[1], dst[0]); \n        }\n    }\n    \n    // Handle +X face\n    vec4 t = checkTorus(pos, vec3(1, 0, 0), dst[0]);\n    \n    // Handle +Y face\n    t = tmin(t, checkTorus(pos, vec3(0, 1, 0), dst[1]));\n    \n    // Handle -Y face\n    t = tmin(t, checkTorus(pos, vec3(0, -1, 0), dst[2]));\n    \n    return t;\n\n    \n}\n\n/* Boolean union of solids for map function below */\nvec2 dmin(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\n/* Distance function to scene */\nvec2 map(in vec3 pos) {\t\n    \n    vec4 t = truchet(pos);\n    \n    vec2 dm = vec2(1e5, -1);\n    \n    if (show_truchet != 0.0) {\n        dm = dmin(dm, vec2(t.w, 2.0));\n    }\n    \n    if (show_spheres != 0.0) {\n        dm = dmin(dm, vec2(sdBall(t.xyz), 1.1));\n    }\n\n    if (show_directions != 0.0) {\n        dm = dmin(dm, vec2(sdArrow(pos - vec3(0.5, 0, 0), vec3(-1, 0, 0)), 0));\n        dm = dmin(dm, vec2(sdArrow(pos + vec3(0.5, 0, 0), vec3(-1, 0, 0)), 0));\n        dm = dmin(dm, vec2(sdArrow(pos - vec3(0, 0.5, 0), vec3(0, -1, 0)), 0.3333));\n        dm = dmin(dm, vec2(sdArrow(pos + vec3(0, 0.5, 0), vec3(0, 1, 0)), 0.3333));\n        dm = dmin(dm, vec2(sdArrow(pos - vec3(0, 0, 0.5), vec3(0, 0, 1)), 0.6666));\n        dm = dmin(dm, vec2(sdArrow(pos + vec3(0, 0, 0.5), vec3(0, 0, -1)), 0.6666));\n    }\n\n    return dm;\n\n}\n\n\n/* IQ's normal calculation. */\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n/* IQ's distance marcher. */\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\n    const float precis = 0.002;   \n    float h=2.0*precis;\n\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;        \n    }    \n\n    if (t > maxd) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n/* Only clever thing about the shading is to postpone the expensive atan call\n   until the last possible second. It should buy us a bit of framerate on \n   slower cards, but I was getting 60FPS before I decided to do this. Meh.\n */\nvec3 shade( in vec3 ro, in vec3 rd ){\n\n    vec2 tm = castRay(ro, rd, dmax);        \n\n    vec3 c;\n\n    if (tm.y < 0.0) { \n\n        // miss\n        return vec3(1.0);\n\n    } else {        \n\n        // hit\n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);\n\n        \n        if (tm.y >= 2.0) { \n            \n            // material 2 means we hit a torus, so use atan-based rainbow map\n            vec4 t = truchet(pos);\n            tm.y = fract( atan(t.y, t.x)/HALFPI - 0.25*iTime );\n            \n        }\n\n        vec3 color = hue(tm.y);\n\n        vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * color;\n        vec3 R = 2.0*n*dot(n,L)-L;\n        float spec = 0.3*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n        vec3 c = diffamb + spec;\n        \n        return mix(c, vec3(1), 1.0-exp(-0.25*tm.x));\n\n    }\n\n\n}\n\n/* Compare key state to default state. */\nfloat keyState(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.75)).x - default_state );\n}\n\nconst float KEY_D = 68.5/256.0;\nconst float KEY_M = 77.5/256.0;\nconst float KEY_S = 83.5/256.0;\nconst float KEY_T = 84.5/256.0;\nconst float KEY_X = 88.5/256.0;\n\n/* Finally, our main function: */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    show_directions = keyState(KEY_D, show_directions);\n    move_camera = keyState(KEY_M, move_camera);\n    show_truchet = keyState(KEY_T, show_truchet);\n    show_spheres = keyState(KEY_S, show_spheres);\n    alternate_x = keyState(KEY_X, alternate_x);\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n    \n    const vec3 tgt = vec3(0.0, 0.0, 0.0);\n    const vec3 cpos = vec3(0, 0, 5);\n    const vec3 up = vec3(0, 1, 0);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n\n    vec2 mpos;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        mpos.xy = iMouse.xy;\n    } else {\n        mpos = iResolution.xy * vec2(0.432, 0.415);\n    }\n    \n    float thetax = (mpos.y - .5*iResolution.y) * -4.0*HALFPI/iResolution.y; \n    float thetay = (mpos.x - .5*iResolution.x) * 8.0*HALFPI/iResolution.x; \n\n\n    Rview = mat3(rx,ry,rz)*rotY(thetay)*rotX(thetax); \n    L = Rview*L;\n\n   \t/* Render. */\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n    \n    if (move_camera != 0.0) {\n        ro -= 0.15*iTime;\n    }\n\n    fragColor.xyz = shade(ro, rd);\n\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSyRz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1526, 1546, 1565, 1565, 1682], [1684, 1710, 1733, 1733, 1854], [1856, 1882, 1905, 1905, 2026], [2028, 2103, 2126, 2126, 2234], [2236, 2289, 2320, 2348, 2843], [2846, 2912, 2935, 2935, 3071], [3073, 3157, 3179, 3179, 3600], [3602, 4097, 4142, 4142, 4311], [4313, 4397, 4424, 4424, 4466], [4469, 5759, 5789, 5859, 7097], [7099, 7152, 7179, 7179, 7211], [7213, 7246, 7269, 7269, 8066], [8069, 8100, 8132, 8132, 8371], [8374, 8403, 8458, 8458, 8833], [8835, 9067, 9104, 9104, 9895], [9897, 9939, 9987, 9987, 10062], [10225, 10259, 10316, 10316, 11497]]}
{"id": "Xl2cRR", "name": "horizon mouse VR", "author": "ollj", "description": "continuation of \nhttps://www.shadertoy.com/view/4lscW2\nadded VR and mouse input.\nremoved fisheye cam", "tags": ["reflection", "shadow", "water", "mirror", "vr", "horizon", "dynamiceps", "edynvr"], "likes": 3, "viewed": 779, "published": "Public API", "date": "1507175347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self  : https://www.shadertoy.com/view/4lscW2\n//parent: https://www.shadertoy.com/view/4td3Dj\n//many minor improvements. I twiddledand learned a few things\n//hard to describe your progress when you basically just try somewhat random ideas\n//and only let the apparently better ones progress.\n\n//the MAX_ limit range definitions only set upper bounds.\n//that are reached exponentially, so their size barely matters.\n//\n//MAX_SHADOW_REFLECTIONS sets how many reflections will have shadows calculated for them\n#define MAX_SHADOW_REFLECTIONS 2.0\n//with 2.0, a reflection in a reflection has shadows in it. usually enough.\n//\n///MAX_DIST can easily be 1000000. but may crash in higher resolutions\n#define MAX_DIST          100.\n//note to self , with synamiceps log() , \"MAX_DIST\" changed its meaning \n// into something that is just not \"maximum distance\" of anything non fuzzyanymore.\n\n//MAX_STEPS can easily be 1000000. but may crash in higher resolutions\n#define MAX_STEPS         200.\n//MAX_HARD can be 200 to 2000, depending on hardware, but may crash in higher resolutions\n#define MAX_HARD  700\n//this is the absolute upper limit of steps per ray, including all its reflections.\n//the hardlimit is only reached in extreme cases, \n//like when the camera POSITION is already close to a surface!\n\n\n//every second pixel is skipped and left black. +20% more fps on older hardware?\n//#define doLazyDither\n//not worth it.\n\n#define doOcclusionShaddow\n//AO really helps the projection, because it is full of mirrors, confusing without AO\n#define doOcclusionAmbient\n\n#define sat(a) clamp(a,.0,1.)\n\n/*\nThis revision adds 2 LOD modes to how it approaches the surface of a gradient.\nIn a sense, this makes it similar to heavily mixing 2 LOD renders of \"spyro the dragon\"; .\n Close distance has epsilon increase over     distanceÂ² , good for mirror, bad for horizon\n Far   distance has epsilon increase over log(distanceÂ²), too much distortion for mirrors\nA lot of twiddilng is involved to make the 2 \"overlap\" nicely.\n \"overlap\" in the sense that, a ray may bounce 5 times,\n  and all accumulating precision errors of many rough estimates must be kept small.\n*/\n\n/*\nhard bugs:\n distance to sinusoidial floow is not lipschitz continuousÃ¶\n maybe add any texturing to this bland method-demo.\n It could need more parameters to the shadow function \n  to make it look better close up than a far.\n I have incomplete plans to include [Cauchy distribution] \n  to move shadowSamlingPoints closer to the camera.\n \n Not sure why, but shadertoy makes the color depth in reflections within reflections \n  look a lot lower than other boilerplates.\n this is likely a precision issue, unlikely a conversion error.\n*/\n\n\n/*\n Older notes from the parent version:\n\n by ollj\n goal is to allow for high render distance and high detail close to the camera\n goal is to allow for hall of mirror reflections for as long as there are steps left, \n  scatterable non-fake reflections.\n goal is to see the shadow in the reflection of a revflection of a reflection...\n goal is to have any fragment converge in the same linear time\n  where closer surfaces simply get more detail/reflections.\n Idealy a top down perspective gets the same fps than a set with an infinite horizon!\n practically, there is still a difference of 60to5 fps, but i am slowly getting to 40to40; ..\n Ambient Occlusion calculatons are draining most resources.\n\nBelow methods causes raymarching to converge more linearily\n for many very different fragments of very different scenes\n  While it also \"warps space\" towards the ray, the more steps have been taken.\n Surfaces close to the camera have low epsilon, high precision, lots of reflections.\n Surfaces far from the camera have less precision, less reflections, higher epsilon\n Surfaces/hallways that are nearrly coplanar to a ray \n  no longer have the problem of \"running out oof steps\" AT ALL.\n\nLONG RENDER DISTANCE;\nHeuristic root solving either converges too slowly or too quickly.\nif (converges too quickly) you could have more detail == larger distances instead.\nIdeally you want to modify them so that all possible cases converge roughly equally.\nThis is achieved by defining MAX_DIST and MAX_STEPS as non-static float pools\n that diminish with each raymarchng step,\nIf (any pool drains below 0) the raymarching ends before MAX_HARD iterations.\n heuristic root solving is eigher likely [too divergend] or [converging too slowly]\n these 2 extremes are constrained by draining MAX_DIST and MAX_STEPS.\nDoing many small steps drains the 2 pools reciprocally-DIFFERENTLY from, the other \n than doing many large steps!\nBoth with one (reciprocal) factor, both pools converge \"much more equally\" \n depending on \"scene openness\" because they drain by the same factor.\n\nRECURSIVE REFLECTION;\nIf (a ray hits a reflective wall) it keeps raymarching a bounched ray.\n The loop sums up a total color as sum of all reflected rays.\nA reflected ray makes up a smaller fraction of the total color.\nIf (that fraction is too small) no morere flecting of this ray happens,\nFinally, the last reflected fraction of a color is added; \n if (we run out of steps) that is \"sky\" or \"ground\" color.\nTodo, make that =mix(SkyOrGroundColor,gradientColor,reasonablyScaledDistanceToGradient)\n\nBALLACHE OF PRECISION\n (nearby) reflections need high precision of they distort too much.\n DynamicEps methods insist on low precision, tent to be very \"noisy\"\n Depending on a points distance to camera, \n  it use a differet (conditions) to determine if (a point is near a surface).\n p+=SurfaceNormal; is a necessary compromise between fast and good recursive reflections.\n*/\n\n\n#define PI acos(-1.)  \n#define PIB asin(1.)\n\n#define skyColor       vec3(.2,.5,1.)\n#define shadowColor    vec3(.2,.2,.5)\n#define groundColor    vec3(.6,1.,.7)\n#define buildingsColor vec3(.8,.7,.2)\n#define redColor       vec3(.9,.2,.7)\n//these colors visually make sense for contrast, even for red-green blindness.:\n//shadows are blue\n//ground is greener\n//floating objects are red\n//near ground objects are yellow\n#define SKY_MTL 0\n#define GROUND_MTL 1\n#define BUILDINGS_MTL 2\n#define RED_MTL 3\n\n//these defines are not too practiical:\n#define fovyCoefficient 1.\n#define shadowHardness 3.\n#define time iTime\n\n//i lost my latest cleaned up iprved version of this, \n//leaving us with this older messier version.\n\n//the ugliest thing here is that,\n//if a reflected ray runs out of steps/distance, it aborts\n//meaning it is the last reflection\n//but without dithering this looks a bit ugly\n//\n//in other versions i added fake dithering by modifying RayDirection by +=0.001\n//for each step.\n//this warps space a bit (speudo randomly), which is still fine, we call this \"gravity\" , ya know?\n\n//the main trick here is that some cases are better for (nearby) reflections \n//while others are better for ling distance surfaces.\n//and all combinations can be made almost linearily convergent.\n//the problem here is that it only starts to look good \n//with at least 500 itterations of raymarchoing\n//too much for the average 2014 hardware in useful resolutions/framerates\n\nfloat CubeDistance2 (in vec3 point, in vec3 size){return length(max(abs(point)-size,0.));}\nfloat sdHexPrism(vec3 p,vec2 h){vec3 q=abs(p);return max(q.z-h.y,max(q.x*.866025+q.y*.5,q.y)-h.x);}\nvec3 DistanceRepetition(in vec3 point, in vec3 repetition ){\n    vec3 q = mod(point, repetition)-.5*repetition;return q;}\nfloat CubeRepetition(in vec3 point, in vec3 repetition ){\n  point.x+=sin(point.y*.11+time*5.);\n  point.z+=cos(point.y*.11);\n  vec3 q = mod(point,repetition)\n  -0.5*repetition;q.y = point.y;\n  return sdHexPrism(q.zxy,vec2(10.,50));\n  return CubeDistance2 ( q, vec3 (10., 50.+sin(time)*15.,10.));}\nfloat PlaneDistance(in vec3 point,in vec3 normal,in float pDistance){return dot(point-(normal * pDistance), normal);}\nfloat modA(float x){return mod(time*.1+x+55.,230.)-55.;}\nfloat fSphere       (vec3 p,float r){return length(p)-r;}\nfloat SphereDistance(vec3 point, vec3 center, float radius){\n  point.z = modA(point.z);point.x = modA(point.x);\n  return fSphere(point-center,radius);}\nfloat RedDistance(in vec3 position){return SphereDistance(position,vec3(0.,66.,0.),30.);}\nfloat BuildingsDistance(in vec3 position){\n  return min(CubeRepetition(position                                ,vec3(80.,0., 90.)),\n\t         CubeRepetition(position+vec3(350.,sin(time)*30.,0.) ,vec3(90.,0.,100.)));}\nfloat GroundDistance(in vec3 position){return PlaneDistance(position,vec3(0.,1.,0.),0.);}\n//merging distance functions above to distanceField function below:\nfloat df(in vec3 position, out int mtl){\n    float radial=length(vec2(position.x,position.z));\n\tfloat radialSine=sin(radial*.05-time*2.)*5.;\n    float gndDistance=position.y-radialSine+6.;\n    float bldDistance=BuildingsDistance(position);\n    float redDistance=RedDistance      (position);\n                       float closest=gndDistance;mtl=   GROUND_MTL;\n    if (bldDistance<closest){closest=bldDistance;mtl=BUILDINGS_MTL;}\n    if (redDistance<closest){closest=redDistance;mtl=      RED_MTL;}\n    return closest;}\n//end of sdf geometry;\n\n//iqs famous softshadow, set to low quality\nfloat SoftShadow( in vec3 landPoint, in vec3 lightVector, float mint, float maxt, float iterations ){\n    float penumbraFactor=1.0;vec3 sphereNormal;float t=mint;\n    for(int s=0;s<20;++s){if(t > maxt) break;\n        float nextDist = min(\n            BuildingsDistance(landPoint + lightVector * t )\n            , RedDistance(landPoint + lightVector * t ));\n        if( nextDist < 0.001 ){return 0.0;}\n        penumbraFactor = min( penumbraFactor, iterations * nextDist / t );\n        t += nextDist;}return penumbraFactor;}\n\n//distance fog is no longer needed, is a relict here.\nvoid applyFog( in float distance, inout vec3 rgb ){\n    //float fogAmount = (1.0 - clamp(distance*0.0015,0.0,1.0) );\n    //float fogAmount = exp( -distance* 0.006 );\n    //vec3 fogColor = vec3(0.9,0.95,1);\n    //if(fogAmount<.6)rgb= vec3(1.,1.,0.);\n    //else rgb=clamp(rgb,0.,1.);\n    //rgb=mix(skyColor,rgb,fogAmount);\n}\n//for mad()-awareness.\nfloat mad (float b,float c,float d){return b*c+d;}\n\n//this is based on old code, with inefficient material handling:\nvec3 MaterialColor(int mtl){\n    if(mtl==      SKY_MTL) return skyColor;\n    if(mtl==BUILDINGS_MTL) return buildingsColor;\n    if(mtl==   GROUND_MTL) return groundColor;\n    if(mtl==      RED_MTL) return redColor;\n    return vec3(1.0,1.0,1.0);}\nfloat AmbientOcclusion(vec3 p,vec3 n,float d,float s){float r=1.;int t;\n  for(int i=0;i<5;++i){if(--s<0.)break;r-=(s*d-(df(p+n*s*d,t)))/pow(2.,s);}return r;}\n \n//i think THIS version of the shader solved all issues of normals, even normals with small epsilon?\n//by using a different dynamiceps close to the camera than faraway from the camera.\n//and by doing some epsilon twiddeling on the gradient itself.\n//i was tweaking this only to notice that e=0.1 is pretty much the best working value for the scenes scaling.\nvec3 ComputeNormal(vec3 pos, int material,float eps){int d;float e=.1;\n  return vec3(df(vec3(pos.x+e,pos.y  ,pos.z  ),d)-df(vec3(pos.x-e,pos.y  ,pos.z  ),d)\n             ,df(vec3(pos.x  ,pos.y+e,pos.z  ),d)-df(vec3(pos.x  ,pos.y-e,pos.z  ),d)\n             ,df(vec3(pos.x  ,pos.y  ,pos.z+e),d)-df(vec3(pos.x  ,pos.y  ,pos.z-e),d));}\n\n\n//if (near surface) do surface things\n//[p]Position [d]RayDirection [c]colorAccumulator [e]epsilon [m]materialID \n//[s]shadowReflections \n//this function gets a LOT of revision.\n//it was tricky to seperate it from the loop that it is in, to more easily modify it.\n//this is all about making code easier to edit, and not about fast parsing.\nvec3 onSurface(inout vec3 p,inout vec3 d,vec3 c,\n    int m, float e,inout float s,     inout float sg    ){\n    vec3 n=ComputeNormal(p,m,e);n=normalize(n);\n      vec3 col=MaterialColor(m);\n      if(s>.0){//if we stil calculate shadows (for this reflection)\n\t\tvec3 lightpos = vec3(250.0*sin(time*.005), 400.0 + 40.0 *cos(time*.002), 250.0*cos(time*.005));\n        lightpos=lightpos-p;vec3 lightVector=normalize(lightpos);float lightdist=length(lightpos);\n     p+=n;//this is important for good reflections but \n    // it has side effects:\n    //the gradient is measured with the same offset from surface (good)\n    //the reflection happens at that offset, which leads to a [fold] of reflection space!\n    // and to a \"holographic mirror\"\n    //as if the surface has a thickness of +1.\n    //which is not too useful for fract(), adding differentials of -1 to compensate.\n        float shadow = SoftShadow(p, lightVector, 0.3, lightdist,shadowHardness);    \n        #ifdef doOcclusionShaddow\n        if(m==BUILDINGS_MTL){col=mix(shadowColor,col,sat(p.y/7.));}\n\t\tfloat attenuation=sat(dot(n,lightVector));\n\t\tshadow=min(shadow,attenuation);col=mix(shadowColor,col,shadow);\n        #endif\n        #ifdef doOcclusionAmbient\n        float AO=AmbientOcclusion(p,n,1.,7.);col=mix(shadowColor,col,AO);\n        #endif\n         s--;}\n      float refl=.34;//surface reflectiveness\n      if (m==GROUND_MTL)refl=.3;//ground has other reflectiveness\n      c=mix(c,col,sg);//mix the color of the current ray (reflection) with the accumulated total color to be returned.\n      sg=sg*refl;if(sg<.01)return c;\n      d=d-(n*1.5*(dot(d,n)));//direction gets reflected at surface normal. \n        //*1.5 factor means we WILL likely overstp within reflections, accumulatively for each reflection.\n        //this is a reasonable fps booster for less quality in reflections.\n return c;\n}\n\n//the raimarch loop gets complicated\n//, with  \"reflections till the horizon\" and \"dual dynamicEps\"\n/*dynamiceps Raymarching;\n- started with the idea of draining 2 pools, instead of one.\n- - Let [ee] be an epsilon that increments with each step\n     or that is = log(squaredDistanceToCamera/lastStelLength)\n- - there are 2 modes for epsilon increments.\n- - - the log(squared) mode is worse fror precision of reflections\n- - - the     squared  mode is worse for long distances.\n- - - we use [b] to switch between these modes.\n- - Let n be the distance to a surface, the gradient at p.\n- - maxDist-=ee/n; drains slower for many long steps, (substract normalized gradient)\n     This allows for much larger render distance (initial motivation for this)\n- - maxSteps-=ee*n; dains slower on many short step distances of near-parallel/orbital rays,.\n     This allows for smaller epsilon (secondary motivation for this)\n- - if(one of the pools is draind) assume that our epsilon is good enough.\n- - both pools drain speed (very likely) converges quickly.\n*/\n//main raymarching loop with maxDistance and MaxSteps and epsilon changed a bit.\n//if (hits a surface) reflect!\n//returns color of fragment.\n//[o]RayOrigin [t]RayDirection \nvec3 RayMarch(vec3 o,vec3 t)\n{int mtl=0\n;vec3 hitColor\n;vec3 r;\n  float sg=1.;\n  float n= 1.;\n  float s=MAX_SHADOW_REFLECTIONS;\n  float maxDist =MAX_DIST;\n  float maxSteps=MAX_STEPS;\n  #ifndef DynamicEpsLog\n    maxSteps*=4.;//simpler steps, but more steps\n  #endif\n  int hardLimit =MAX_HARD;\n  float e     =.01;\n //main raymardching loop accumulates a color. can do so over many reflections.\n //the maximum number of sphere-tracking steps is MAX_HARD;\n //the maximum number of reflections is MAX_HARD;\n //the maximum number of surfaces that get shadow and AO calculated for them is MAX_SHADOW_REFLECTIONS\n //because AO is an inner lop, and it makes sense to constrain the O(n*m) compleity\n //by limiting m<=MAX_SHADOW_REFLECTIONS, with n==MAX_HARD;\n for(int ever=0;ever<MAX_HARD;ever++){//the ride (n)ever ends! unless [hardlimit<0] triggers a return. this lets me drain hardlÃ¶imit in the loop-\n    n=df(o,mtl);\n   float ee=mad(n,.000001,e*1.00001);\n   float l=dot(o,o);\n   o+=t*n;\n   bool b=l<MAX_DIST;//could be =sqrt(l)*2.<MAX_DIST; makes not much of a difference.here\n   if(b)e=ee;               //for long view distance\n   if(b)b=.0<log(l/n*1e-7);//for long view distance\n   else b=n+.5<e*60.;      //for better close up shadows (+<.6 for sharper corners)\n   if(b){hardLimit--;r=onSurface(o,t,r,mtl,e,s,sg);}\n   maxSteps -=ee*n;\n   maxDist  -=ee/n;\n//i am sure this can be improved a lot. but benchmarking this on different scenes takes time.\n//and i lack the theoretical undertanding to model many cases to an optimum.\t\n      if(\n         maxSteps<0.1\n       ||maxDist<=0.\n       ||hardLimit<=0\n      ){\n\t   return mix(r,skyColor,sg);//overwrite horizon noise with sky\n}\n    \n  }\n    //there are some rays that needed more than MAX_HARD steps\n    //but also never exhausted any countdown.\n    //ths hints at lipschitz discontinuity, likely due to fisheye lens transform.\n    //evaluating rays that got lost in discontinuities is never pretty.\n    //trying my best here\n    //return vec3(3);//highlight what never got near a surface\n    r=onSurface(o,t,r,mtl,e,s,sg);\n    return mix(r,skyColor,sg);//overwrite horizon noise with sky\n;}\n\n\n#define zFar 20.*iResolution.y\n\n//Outoput,Uv,[A]=RayOrigin,[D]=RayDirection\nvoid mainVR(out vec4 O,in vec2 U,in vec3 A,in vec3 D){\n float nearestD=zFar;vec3 color=vec3(0);\n A.y+=1.;//+height of eyes above ground.\n float my=iMouse.y/iResolution.y;\n A.y+=1999.*max((my-.4),.0);\n D *=vec3(-1,1,-1);//A *=vec3(-1,1,-1);//flipping rays instead of flipping set\n float f=.0,d=.01;\n int mat,dd;\n vec3 p=A;//p gets modified in this loop, and used after it, parallel to A\n O=vec4(RayMarch(A,D),1.);\n;}\n\n#define u2(a) ((a)*2.-1.)\n\nvoid mainImage(out vec4 O,in vec2 U){\n const vec3 cameraPos=vec3(0);//camPos is simple offset\n const float rad=360./acos(-1.),dar=acos(-1.)/180.;\n vec2 m=u2(iMouse.xy/iResolution.xy); \n m=PI*mix(vec2(1.-m.x,m.y*.35),vec2(1,0),step(iMouse.z,.0));\n vec2 fov=vec2(25.);fov.x=atan(tan(fov.y/rad)*iResolution.x/iResolution.y)*rad;\n mat3 cam;\n cam[0]=vec3(cos(m.x),0,sin(m.x));//camera.right\n m.x=m.x+PI*.5;\n cam[1]=vec3(cos(m.x)*cos(m.y),sin(m.y),sin(m.x)*cos(m.y));//cameraFwd\n //cam[2]=-cross(cam[0],cam[1]));//camUp\n fov=(2.*U/iResolution.xy-1.)*sin(fov*dar)/sin(PI*.5-fov*dar);\n cam[0]=cameraPos-cam[1]+fov.x*cam[0]-fov.y*cross(cam[0],cam[1]);\n cam[1]=normalize(cam[0]-cameraPos);\n // scene is accidentally backwards, ugh\n cam[1]*=vec3(-1,1,-1);cam[0]*=vec3(-1,1,-1);\n mainVR(O,U,cam[0],cam[1]);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2cRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6708, 7083, 7133, 7133, 7173], [7174, 7174, 7206, 7206, 7273], [7274, 7274, 7334, 7334, 7395], [7396, 7396, 7453, 7453, 7691], [7692, 7692, 7761, 7761, 7809], [7810, 7810, 7830, 7830, 7866], [7867, 7867, 7904, 7904, 7924], [7925, 7925, 7985, 7985, 8076], [8077, 8077, 8113, 8113, 8166], [8167, 8167, 8209, 8209, 8383], [8384, 8384, 8423, 8423, 8473], [8474, 8542, 8582, 8582, 9059], [9084, 9128, 9229, 9229, 9650], [9652, 9706, 9757, 10026, 10028], [10029, 10052, 10088, 10088, 10102], [10104, 10169, 10197, 10197, 10413], [10414, 10414, 10468, 10468, 10571], [10574, 10931, 10984, 10984, 11262], [11265, 11605, 11712, 11712, 13465], [13467, 14690, 14720, 14720, 16831], [16866, 16910, 16964, 16964, 17325], [17354, 17354, 17391, 17391, 18149]]}
{"id": "Xl2cRz", "name": "Cutout thingy", "author": "csaez", "description": "Quick doodle trying to get a cutout/layered look going... just messing around.", "tags": ["2d", "parallax", "layers", "cutout"], "likes": 1, "viewed": 134, "published": "Public", "date": "1507207305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// some constants\n#define speed 2.0\n#define amplitude 0.05\n#define freq 6.0\n#define number_lines 6.0\n#define line_threshold 0.2\n#define fg_color vec4(0.8)\n#define bg_color vec4(0.1, 0.35, 1.0, 1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float decay = (0.5 + (1.0 - uv.y));\n    float t = (freq * uv.x) + (sin((smoothstep(0.0, 1.0, uv.y) - iTime) * speed) * decay);\n    uv.y += sin(t) * amplitude;\n\n    float depth = mix(1.0, 0.2, uv.y);\n    float shadow = fract(uv.y * number_lines);\n\n    float outline = smoothstep(-6.0/iResolution.y, 6.0/iResolution.y, line_threshold - shadow)* depth;\n    shadow = mix(0.7, 1.0, shadow) * depth;\n    fragColor = shadow*bg_color + outline*fg_color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2cRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 199, 256, 256, 749]]}
{"id": "Xl2cWh", "name": "Study beginner - 03", "author": "woodorl", "description": "studying!\n\nSpecial thanks for \nhttps://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg/videos", "tags": ["study"], "likes": 5, "viewed": 132, "published": "Public", "date": "1508371408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t) {\n\treturn sat((t-a) / (b-a));\n}\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn sat((t-a) / (b-a)) * (d-c) + c;\n}\n\nvec2 within (vec2 uv, vec4 rect) {\n    return (uv-rect.xy) / (rect.zw-rect.xy);\n}\n\nvec4 Brow(vec2 uv, float smile) {\n    float offs = .2 * (1. - smile);\n    uv.y += offs;\n    \n    float y = uv.y;\n    uv.y += uv.x* mix(.5, .8, smile) - mix(.1, .3, smile);\n    uv.x -= .1 * smile;\n    uv -= .5;\n\t\n    vec4 col = vec4(0.);\n    \n    float blur = .1;\n    \n    float d1 = length(uv);\n    float s1 = S(.45, .45 - blur, d1);\n    float d2 = length(uv - vec2(.1, -.2) * .7);\n    float s2 = S(.5, .5-blur, d2);\n    \n    float browMask = sat(s1 - s2);\n    \n    float colMask = remap01(.65, .8, y) *.75;\n    colMask *= S(.5, .9, browMask);\n    colMask *= smile;\n    vec4 browCol = mix (vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask);\n    \n    uv.y += .15 - offs * .5;\n    blur += .1 * smile;\n    d1 = length(uv);\n    s1 = S(.45, .45 - blur, d1);\n    d2 = length(uv - vec2(.1, -.2) * .7);\n    s2 = S(.5, .5 - blur, d2);\n    float shadowMask = sat(s1 - s2);\n    \n    col = mix(col, vec4(0., 0., 0., 1.), S(.0, 1., shadowMask) * .5);\n    \n    col = mix(col, browCol, S(.2, .4, browMask));\n    \n    return col;\n}\n    \nvec4 Eye (vec2 uv, float side, vec2 m, float smile) {\n    uv -= .5;\n    uv.x *= side;\n    \n    float d = length(uv);\n    \n    vec4 irisCol = vec4(.3, .5, 1., 1.);\n    vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d) * .5);\n    col.a = S(.5, .48, d);\n    \n    col.rgb *= 1. - S(.45, .5, d) * .5 * sat(-uv.y -uv.x * side);\n    \n    d = length(uv - m * .5);\n    \n    //col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d));\n    col.rgb *= S(.28, .3, d);\n    \n    irisCol.rgb *= 1. + S(.3, .05, d);\n    float irisMask = S(.28, .25, d);\n    col.rgb = mix(col.rgb, irisCol.rgb, irisMask);\n    \n    d = length(uv - m * .6);\n    \n    float pupilSize = mix(.4, .16, smile);\n    float pupilMask = S(pupilSize , pupilSize * .9, d);\n    pupilMask *= irisMask;\n    //col.rgb = mix(col.rgb, vec3(0.), pupilMask);\n    col.rgb *= 1. - pupilMask;\n    \n    float t = iTime * 3.;\n    vec2 offs = vec2(sin(t + uv.y * 25.), sin(t + uv.x * 25.));\n    offs *= .01 * (1. - smile);\n    \n    uv += offs;\n    \n    float highlight = S(.1, .09, length(uv-vec2(-.15, .15)));\n    highlight += S(.07, .05, length(uv+vec2(-.08, .08)));\n    \n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    return col;\n}\n\nvec4 Mouth (vec2 uv, float smile) {\n    uv -= .5;\n    vec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5;\n    uv.y -= uv.x * uv.x * 2. * smile;\n    \n    uv.x *= mix(2., 1., smile);\n    float d = length(uv);\n\tcol.a = S(.5, .48, d);\n    \n    vec2 tUv = uv;\n    tUv.y += (abs(uv.x) * .5 + .1) * (1. - smile);\n    float td = length(tUv-vec2(0., .6));\n    \n    vec3 toothCol = vec3(1.) * S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));\n    \n    td = length(uv+vec2(0., .5));\n    col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td));\n    \n    return col;\n}\n\nvec4 Head (vec2 uv) {\n    vec4 col = vec4(.9, .65, .1, 1.);\n    \n    float d = length(uv);\n    \n    col.a = S(.5, .49, d);\n    \n    float edgeShade = remap01 (.35, .5, d);\n    edgeShade *= edgeShade;\n    \n    col.rgb *= 1. - edgeShade * .5;\n    \n    col.rgb = mix(col.rgb, vec3(.4, .2, .1), S(.475, .48, d));\n    \n    float highlight = S(.41, .405, d) * .75;\n    highlight *= remap(.41, -.1, .75, 0., uv.y);\n    highlight *= S(.17, .18, length(uv-vec2(.205, .08)));\n    \n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    d = length(uv-vec2(.25, -.2));\n    float cheek = S(.2, .01, d) * .4;\n    cheek *= S(.17, .16, d);\n    col.rgb = mix(col.rgb, vec3(1., .1, .1), cheek);\n    \n    return col;\n}\n\nvec4 Smiley (vec2 uv, vec2 m, float smile) {\n    vec4 col = vec4(0.);\n    \n    float side = sign(uv.x);\n    uv.x = abs(uv.x);\n    vec4 head = Head(uv);\n    vec4 eye = Eye(within(uv, vec4(.03, -.1, .37, .25)), side, m, smile);\n    vec4 mouth = Mouth(within(uv, vec4(-.3, -.4, .3, -.1)), smile);\n    vec4 brow = Brow(within(uv, vec4(.03, .2, .4, .45)), smile);\n    \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    col = mix(col, brow, brow.a);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\tvec2 uv = fragCoord.xy / iResolution.xy;\n//\tuv -= 0.5;\n//\tuv.x *= iResolution.x / iResolution.y;\n    float t = iTime;\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n   \tvec2 m = iMouse.xy / iResolution.xy;\n    m -= .5;\n    \n    if(m.x < -.49 && m.y < -.49) {\n        float s = sin(t * .5);\n        float c = cos(t * .38);\n        \n        m = vec2(s, c) * .4;\n    }\n    \n    uv -= m * (.25 - dot(uv, uv));\n    float smile = cos(iTime) * .5 + .5;\n\tfragColor = Smiley(uv, m, smile);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2cWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 114, 114, 144], [145, 145, 203, 203, 245], [247, 247, 281, 281, 328], [330, 330, 363, 363, 1349], [1355, 1355, 1408, 1408, 2526], [2528, 2528, 2563, 2563, 3107], [3109, 3109, 3130, 3130, 3811], [3813, 3813, 3857, 3857, 4335], [4338, 4338, 4395, 4495, 4904]]}
{"id": "Xl2yWh", "name": "Procedural urban landscape", "author": "PrzemyslawZaworski", "description": " ", "tags": ["procedural", "raymarching", "noise", "tutorial", "beginner", "city", "art", "buildings"], "likes": 14, "viewed": 664, "published": "Public", "date": "1508363517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shader code:\n// The MIT License https://opensource.org/licenses/MIT\n// Copyright Â© 2017 Przemyslaw Zaworski\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//#define colorize\n\nmat3 rotationX( float x) \n{\n\treturn mat3\n\t(\n\t\t1.0,0.0,0.0,\n\t\t0.0,cos(x),sin(x),\n\t\t0.0,-sin(x),cos(x)\n\t);\n}\t\t\t\n\nfloat hash (vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414)))*43758.5453);\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)), dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat map (vec3 p)\n{\n\tvec2 u = floor(p.xz*0.005*64.0)/64.0;\n\tfloat h = hash(u);\n\th = p.y - 8.0 * h * h;\n\treturn max( min( h, 0.2), p.y-8.0 );\n}\n\t\t\t\nvec4 color (vec3 ro)\n{\n   \tfloat m = ro.y/8.0;\n    #ifdef colorize\n    return vec4( hash3(floor(ro.xz*0.005*64.0)/64.0)*m,1.0);\n    #endif\n\tvec4 buildings = vec4 (m,m,m,1.0);\n\tvec4 grass = vec4(0,0.1,0,1);\n\treturn mix(buildings,grass,step(ro.y,0.1));\n}\n\t\t\t\nvec4 raymarch (vec3 ro, vec3 rd)\n{\n\tfor (int i=0; i<256; i++)\n\t{\n\t\tfloat t = map(ro);\n\t\tif ( t<0.001 ) return color(ro);\n\t\tro+=t*rd;\n\t}\n\treturn vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(iTime*10.0,25,0);\n    vec3 rd = normalize(vec3(uv,2.0)*rotationX(5.65));\n\tfragColor = raymarch(ro,rd);\n}", "image_inputs": [{"id": "lssSDl", "previewfilepath": "https://soundcloud.com/mikko-tarmia/penumbra-black-plague-ambient-track", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mikko-tarmia/penumbra-black-plague-ambient-track", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2yWh.jpg", "access": "shaders20k", "license": "mit", "functions": [[1137, 1157, 1184, 1184, 1263], [1268, 1268, 1290, 1290, 1355], [1357, 1357, 1379, 1379, 1514], [1516, 1516, 1536, 1536, 1659], [1664, 1664, 1686, 1686, 1916], [1921, 1921, 1955, 1955, 2077], [2079, 2079, 2136, 2136, 2320]]}
{"id": "Xl2yzV", "name": "drl0016", "author": "DrLuke", "description": "I needed some color in my life", "tags": ["pattern", "tiles"], "likes": 8, "viewed": 446, "published": "Public API", "date": "1509367581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThis work is licensed under a Creative Commons Attribution 4.0 International License.\nhttps://creativecommons.org/licenses/by/4.0/\n*/\n\n// Some nice colors\n#define c1 (vec3(238,127,26)/255.)\t// Bright orange\n#define c2 (vec3(58,153,163)/255.)\t// Bright teal\n#define c3 (vec3(65,105,108)/255.)\t// Dark teal\n#define c4 (vec3(109,8,6)/255.)\t\t// Crimson?\n\n#define S(x,w) smoothstep(-w,w,x)\n\n/// Distance functions and smoothMerge from: https://www.shadertoy.com/view/4dfXDn\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nvec2 rot(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\n// Each pattern is a square ranging from 0,0 to 1,1.\n// The orientation vector tells how it is rotated\n\n// Pattern 1\nvec3 pat1(vec2 uv, vec2 orient)\n{\n    uv -= vec2(0.5);\n    vec3 color = c4;\n    \n    color = mix(c1, color, S(boxDist(uv, vec2(.45), 0.05), 0.01));\t// Main box\n    color = mix(c4, color, S(boxDist(rot(uv - vec2(0.2*sign(uv.x), -0.2*sign(uv.x)), 3.14159*0.25), vec2(.1), 0.02), 0.01));\n    float v = smoothMerge(boxDist(uv - vec2(0.15*sign(uv.x)), vec2(.15), 0.1),\n                          boxDist(rot(uv, 3.1415*1./4.), vec2(.15, .1), 0.0),\n                          0.05);\n    color = mix(c4, color, S(v, 0.01));\n    \n    \n    \n    return color;\n    \n    return vec3(1.-S(boxDist(uv, vec2(.45), 0.), 0.01));\n}\n\n#define smoothround(x, w) (floor(x) + smoothstep(0.5-w, 0.5+w, fract(x)))\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n    uv -= vec2(0.5);\n    \n    if(orient.x == 0.0) {orient.x += 0.1;}\n    uv = rot(uv, smoothround(atan(orient.y, orient.x)/(3.14159*0.5), 0.0)*3.14159*0.5-3.14159*0.5);\n    \n    \n    vec3 color = c4;\n    \n    #define pupilsize (cos(iTime) * cos(iTime) * 0.05 + 0.07)\n    \n    // Left Eye\n    color = mix(c2, color, S(boxDist(uv + vec2(0.25, -0.25), vec2(.2), 0.01), 0.01));\n    color = mix(c1, color, S(boxDist(uv + vec2(0.25, -0.25), vec2(.15), 0.01), 0.01));\n    color = mix(c1*0.5, color, S(boxDist(rot(uv + vec2(0.25, -0.25), -iTime), vec2(pupilsize), 0.01), 0.01));\n    \n    // Right eye\n    color = mix(c2, color, S(boxDist(uv + vec2(-0.25, -0.25), vec2(.2), 0.01), 0.01));\n    color = mix(c1, color, S(boxDist(uv + vec2(-0.25, -0.25), vec2(.15), 0.01), 0.01));\n    color = mix(c1*0.5, color, S(boxDist(rot(uv + vec2(-0.25, -0.25), iTime), vec2(pupilsize), 0.01), 0.01));\n    \n    \n    // Mouth\n    color = mix(c2, color, S(boxDist(uv + vec2(0., 0.25), vec2(.45, 0.2), 0.01), 0.01));\n    color = mix(c4, color, S(boxDist(mod(uv,vec2(0.17, 1.)) + vec2(0. , -0.65), vec2(.05, 0.1), 0.01), 0.01));\n    \n    return color;\n}\n\n\n\n#define tilesize1 64.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2. / iResolution.xy) - vec2(1);\n    vec2 norFragCoord = fragCoord.xy - iResolution.xy * 0.5;\n    vec2 uvblocks = floor(norFragCoord.xy / tilesize1);\n\t\n    \n    vec3 color = pat2(fract(norFragCoord.xy / tilesize1), vec2(sin(uvblocks.y *10.)*0.5, sin(uvblocks.y*10.)));\n    \n    if (mod(uvblocks, 2.0) == vec2(0.0) || mod(uvblocks.x + uvblocks.y, 2.) == 0.0)\n    {\n        color = pat1(fract(norFragCoord.xy / tilesize1), vec2(0));\n    }\n    \n    \n\tfragColor = vec4(color,1.0);\n    //fragColor = vec4(uvblocks.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2yzV.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[389, 472, 520, 520, 636], [638, 638, 665, 665, 732], [734, 734, 782, 782, 883], [990, 1003, 1036, 1036, 1614], [1691, 1704, 1737, 1737, 2863], [2890, 2890, 2947, 2947, 3488]]}
{"id": "Xl2yzz", "name": "HelloShadertoy", "author": "ttrkaya", "description": "first", "tags": ["first"], "likes": 1, "viewed": 382, "published": "Public API", "date": "1507222210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (fragCoord - iResolution.xy * 0.5) / iResolution.xy;\n    \n    pos *= (0.9 + 0.1 * sin(iTime * 2. + 13. / (0.3 + length(pos)))) * cos(length(pos) * 2.7) / length(pos);\n    \n    float angle = sin(iTime * 0.3341 + 0.5) * 1.3 + cos(iTime * 0.3245 + 0.3453);\n    pos = vec2(\n    \tpos.x * cos(angle) - pos.y * sin(angle),\n        pos.x * sin(angle) + pos.y * cos(angle)\n\t);\n    \n    const float TILEDNESS = 50.;\n    float a = sin(pos.x * TILEDNESS) < 0. ? 0. : 1.;\n    if(sin(pos.y * TILEDNESS) < 0.) a = 1. - a;\n    \n    float random = 0.38234;\n    for(float i = 0.; i < 5.; i++){\n    \trandom = mod(random * 3457.35242334 + 0.545345, 1.);\n        if(pos.x * 2. * (random - 0.5) + pos.y  * sin(random * 1000. + iTime * 0.3) < 0.) a = 1. - a;\n    } \n    \n    fragColor = vec4(\n        0.4 * (sin(\n        \tpos.x * sin(iTime * 0.523 + 123.) + pos.y  * sin(iTime * 0.945) + iTime\n        ) + 1.), \n        sin(iTime * 0.231 + pos.x + pos.y + pos.x * pos.y) * 0.5 + 0.5, \n        cos(iTime *0.123 + pos.x + pos.y) * 0.5 + 0.5, \n        1.);\n    \n    if(a == 1.){\n    \tfragColor.yz = vec2(1., 1.) - fragColor.xz;    \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2yzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1186]]}
{"id": "XlBcWz", "name": "Merging heat zones", "author": "Fading_Pixel", "description": "Two \"Heat Zones\" that merge as they get closer. The equation for it is :\nmin(min(distance(zone1,p),distance(zone2,p)),(distance(zone1,p)*distance(zone2,p))/strength)-size ", "tags": ["3d", "raymarch", "rainbow"], "likes": 1, "viewed": 73, "published": "Public", "date": "1508153017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float EPSILON = 0.001;\nint MAX_STEPS = 100;\nfloat MAX_DIST = 100.0;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat boxSDF(vec3 p, vec3 size, float r) {\n    vec3 d = abs(p) - (size / 2.0) + r;\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance - r;\n}\n\nfloat sphereSDF(vec3 p, float size) {\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    float strength = 10.0;\n    float size = 1.0;\n    vec3 zone1 = vec3(vec2(sin(iTime*0.5)*3.0),0.0);\n    vec3 zone2 = vec3(vec2(sin(iTime*0.5)*-3.0),0.0);\n    float sdf = min(min(distance(zone1,p),distance(zone2,p)),(distance(zone1,p)*distance(zone2,p))/strength)-size;\n    return sdf;\n}\n\nfloat March(vec3 Dir, vec3 eye) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sceneSDF(eye + (Dir*depth));\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 interp(vec3 a,vec3 b,float t) {\n    return a + ((b-a)*t);\n}\n\nvec3 Light(vec3 p, vec3 eye, vec3 Amb, vec3 Diff, vec3 Spec) {\n    float IntensitySpec = 0.4;\n    float IntensityDiff = 0.4;\n    float shine = 10.0;\n    vec3 source = vec3(sin(2.0*iTime)*5.0,cos(2.0*iTime)*5.0,0.0);\n    //source = vec3(0.0,0.0,0.0);\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(source - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    float millis = iTime*25.0;\n    vec3 color = vec3(sin(millis/10.0)*127.0+127.0,sin(millis/10.0+85.0)*127.0+127.0,sin(millis/10.0+175.0)*127.0+127.0);\n    //Amb = interp(N,Amb,(1.0+cos(iTime))/2.0);\n    Amb = color / 255.0;\n    vec3 col = Amb * 0.5;\n    if (dot(L,N) < 0.0) {\n        return col;\n    }\n    if (dot(R,V) < 0.0) {\n        col += (Diff * IntensityDiff * dot(L,N));\n        return col;\n    }\n    col += (Diff * IntensityDiff * dot(L,N));\n    col += (Spec * pow(dot(R,V),shine));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = vec3(sin(iTime)*5.0,cos(iTime)*5.0,6.5);\n    //eye = vec3(0.0,0.0,6.5);\n    vec3 center = vec3(0.0,0.0,0.0);\n    vec3 up = vec3(0.0,1.0,0.0);\n    mat3 Matrix = viewMatrix(eye,center,up);\n    vec3 dir = rayDirection(90.0,iResolution.xy,fragCoord);\n    float mDist = March(Matrix * dir,eye);\n    vec3 point = eye + (mDist * (Matrix * dir));\n    vec3 light = Light(point, eye, vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0));\n    if (mDist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    fragColor = vec4(light, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBcWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 110, 110, 203], [205, 205, 232, 232, 379], [381, 381, 408, 408, 555], [557, 557, 584, 584, 731], [733, 733, 775, 775, 982], [984, 984, 1021, 1021, 1052], [1054, 1054, 1078, 1078, 1367], [1369, 1369, 1402, 1402, 1707], [1709, 1709, 1774, 1774, 1906], [1908, 1908, 1937, 1937, 2247], [2249, 2249, 2298, 2333, 2464], [2466, 2466, 2502, 2502, 2530], [2532, 2532, 2594, 2594, 3433], [3435, 3435, 3492, 3492, 4075]]}
{"id": "XlBcz3", "name": "Faster Triplanar Blending", "author": "Dain", "description": "Left side uses a constant width for blending between layers.\nRight side uses \"standard\" triplanar texturing. Corners have short blend width, while aligned axis have huge blend width.\n\nRed/Green/Blue = 1 tex\nYellow/Pink/Cyan = 2 tex\nwhite = 3 tex\n\n", "tags": ["triplanar"], "likes": 7, "viewed": 302, "published": "Public", "date": "1509431543", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Left side uses a constant width for blending between layers.\n       This reduces the # of pixels that require > 1 texture sample\n       Also I think it looks better as less pixels are \"blurry\"\n\n    Right side uses \"standard\" triplanar texturing. \n      Corners have almost no blend width, while aligned axis have huge blend width.\n\n    Red/Green/Blue = 1 texture sample\n    Yellow/Pink/Cyan = 2 texture sample\n    white = 3 texture samples\n\n*/\n\n//\"Standard\" triplanar blending.\nvec3 TriPlanarBlendWeightsStandard(vec3 normal) {\n\tvec3 blend_weights = abs(normal.xyz); \n    \n    float blendZone = 0.55;//anything over 1/sqrt(3) or .577 will produce negative values in corner\n\tblend_weights = blend_weights - blendZone; \n\n\tblend_weights = max(blend_weights, 0.0);     \n\tfloat rcpBlend = 1.0 / (blend_weights.x + blend_weights.y + blend_weights.z);\n\treturn blend_weights*rcpBlend;\n}\n\n//Constant width Triplanar blending\nvec3 TriPlanarBlendWeightsConstantOverlap(vec3 normal) {\n\n\tvec3 blend_weights = normal*normal;//or abs(normal) for linear falloff(and adjust BlendZone)\n\tfloat maxBlend = max(blend_weights.x, max(blend_weights.y, blend_weights.z));\n \t\n    float BlendZone = 0.8f;\n\tblend_weights = blend_weights - maxBlend*BlendZone;\n\n\tblend_weights = max(blend_weights, 0.0);   \n\n\tfloat rcpBlend = 1.0 / (blend_weights.x + blend_weights.y + blend_weights.z);\n\treturn blend_weights*rcpBlend;\n}\n\n//Rest of code by mostly by paniq\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+2.0,1.0);\n}\n\nvec2 add_plane(vec3 p, vec2 m) {\n    return min2(plane(p),m);\n}\n\nfloat Sphere(vec3 p, float r){\n  return length(p) -    r;\n}\nvec2 doModel( vec3 p ) {\n \n    float d = Sphere(p, 2.0);\n    return add_plane(p, vec2(d,0.0));\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec4 doMaterial( in vec3 pos, in vec3 nor )\n{\n    float k = doModel(pos).y;\n    float d = doModel(vec3(pos.x,0.0,pos.z)).x;\n    \n    float w = abs(mod(d, 0.1)/0.1 - 0.5);\n    \n    return mix(vec4(0.1,.01,1.0,0.1), //nor * 0.5 + 0.5,\n               vec4(1.0,1.0,1.0,0.0) * w,\n               clamp(k,0.0,1.0));\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n\tfloat cos_Ol = max(0.0, dot(nor, lig));\n    vec3 h = normalize(lig - rd);\n    float cos_Oh = max(0.0,dot(nor, h));\n    float dif = cos_Ol;\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(0.8, 0.7, 0.6)*sha;\n    \n    lin += vec3(0.20,0.30,0.30);\n\n    \n    vec3 col = mal.rgb*lin;\n\n    // specular\n    col += cos_Ol * pow(cos_Oh,40.0);\n    \n    // envmap\n  //  col += mal.w*texture(iChannel0, reflect(rd,nor)).rgb;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<80; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<80; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n        if(h <= 0.0){\n            break;\n        }\n        t +=abs(h);\n        if(t > 20.0){\n            break;\n        }\n      //  t += max(h, 0.;\n\t//\tt += clamp( h, 0.001, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 ff_filmic_gamma3(vec3 linear) {\n    vec3 x = max(vec3(0.0), linear-0.004);\n    return (x*(x*6.2+0.5))/(x*(x*6.2+1.7)+0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n  //  vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n   // vec3 ro, ta;\n    //doCamera( ro, ta, iTime, m.x );\n    //doCamera( ro, ta, 3.0, 0.0 );\n\n    // camera matrix\n   // mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\t//vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \tfloat an = 1.1 + 0.05*(iTime-10.0) - 7.0*m.x;\n    \n\tvec3 ro = vec3(4.5*sin(an),1.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.2,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        vec3 blendFast = TriPlanarBlendWeightsConstantOverlap(nor);\n        vec3 blendOriginal = TriPlanarBlendWeightsStandard(nor);\n        \n        vec3 blend = blendFast;\n        if(p.x > 0.0){\n            blend = blendOriginal;\n        }\n        vec3 triPlanar = vec3(0.0);\n        vec3 debugColor = vec3(0.0);\n        if(blend.x > 0.0){\n            triPlanar = texture(iChannel1, pos.yz).rgb*blend.x;\n         \tdebugColor = vec3(1.0, 0.0,0.0);   \n        }\n         if(blend.y > 0.0){\n            triPlanar += texture(iChannel1, pos.xz).rgb*blend.y;\n         \tdebugColor += vec3(0.0, 1.0,0.0);   \n        }\n         if(blend.z > 0.0){\n            triPlanar += texture(iChannel1, pos.xy).rgb*blend.z;\n         \tdebugColor += vec3(0.0, 0.0,1.0);   \n        }\n        \n        \n        // materials\n        vec4 mal = doMaterial( pos, nor );\n        mal.rgb = sin(iTime) > 0.0 ? triPlanar : debugColor;\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = ff_filmic_gamma3(col * 0.6); //pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBcz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[452, 485, 534, 534, 885], [887, 923, 979, 979, 1397], [1399, 1434, 1517, 1517, 1640], [1642, 1642, 1669, 1669, 1704], [1706, 1706, 1733, 1733, 1764], [1766, 1766, 1793, 1793, 1823], [1826, 1826, 1847, 1847, 1879], [1881, 1881, 1913, 1913, 1944], [1946, 1946, 1976, 1976, 2005], [2006, 2006, 2030, 2030, 2102], [2104, 2457, 2502, 2502, 2767], [2769, 2980, 3064, 3064, 3703], [3705, 3705, 3755, 3755, 4174], [4176, 4176, 4208, 4208, 4628], [4630, 4630, 4678, 4678, 5257], [5259, 5259, 5323, 5323, 5501], [5503, 5503, 5539, 5539, 5633], [5635, 5635, 5692, 5692, 8253]]}
{"id": "XlByRc", "name": "2D Voronoi Noise Fractal", "author": "kaswan", "description": "2D Voronoi Noise Fractal", "tags": ["2d", "fractal", "voronoi", "noise"], "likes": 0, "viewed": 151, "published": "Public", "date": "1509442702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Voronoi noise\nfloat vnoise(vec2 p)\n{\n    vec2 cell_i = floor(p);\n    vec2 cell_f = fract(p);\n    \n    float min_dist = 2.0;\n    for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n        \n \t\t\tvec2 xy = vec2(float(x), float(y)); \n            vec2 point = random2(cell_i + xy);\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n        \tfloat dist = distance(cell_f, xy + point);\n        \tmin_dist = min(min_dist, dist);\n        }\n    }\n\treturn min_dist;\n}\n\nfloat fbm(vec2 p)\n{\n    float v;\n    \n    v  = vnoise(p * 1.0) * 0.5;\n    v += vnoise(p * 2.0) * 0.25;\n    v += vnoise(p * 4.0) * 0.125;\n    v += vnoise(p * 8.0) * 0.0625;\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= 2.0;\n    \n    vec3 color;\n\t\n\tcolor = vec3(fbm(uv));\n    color = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), color);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlByRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [119, 136, 158, 158, 602], [604, 604, 623, 623, 796], [798, 798, 855, 855, 1131]]}
{"id": "XlByzG", "name": "Stars Bonus", "author": "aiekick", "description": "Stars Bonus", "tags": ["stars", "bonus"], "likes": 5, "viewed": 492, "published": "Public API", "date": "1508967820", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n#define countTubes 6.\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nvec2 m;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.1415926535 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nvec2 minObj(vec2 a, vec2 b)\n{\n\tif (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec4 df(vec3 p)\n{\n    float fa = fullAtan(p.xy) + 3.14159/10.;\n    float pathXY = length(p.xy) - 1.5 - (sin(fa*5.)*.5+.5)*.5;\n    vec2 rev = vec2(pathXY, p.z);\n    float a = iTime*2.;\n    float st = 3.14159*1.5 / countTubes;\n    vec2 tu = vec2(length(rev + vec2(cos(a), sin(a)) * 0.5) - 0.2,1);\n    for (float i=2.;i<countTubes;i++)\n    {\n    \ta += st;\n    \ttu = minObj(tu,vec2(length(rev - vec2(cos(a), sin(a)) * 0.5) - 0.2,i));;\n    }\n    \n\treturn vec4(tu,rev); \n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    m = iMouse.xy/iResolution.xy;\n    if (m.x == 0.) m.x = .1;\n    \n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n    float a = iTime*.5;\n\tvec3 rayOrg = vec3(0.5 * cos(a),0.5 * sin(a),1) * 5.6;\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,0,0);\n\t\n\tfloat fov = 0.5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat s = 0.;\n    float d = 0.;\n\tfloat dMax = 20.;\n\tfloat count = 0.;\n\tfor (float i=0.; i<500.; i++)\n\t{\n\t\tif (d*d/s>1e6 || d>dMax) break;\n        s = df(rayOrg + rayDir * d).x;\n\t\td += s * 0.2;\n\t\tcount+=1.;\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n   \tif (d<dMax)\n\t{\n        \n\t\tvec3 p = rayOrg + rayDir * d;\n        vec3 n = nor(p, 0.001);\n\t\tvec4 mat = df(p);\n        \n        vec3 tex = texture(iChannel0, mat.zw).rgb; // wood\n        \n        float m = mat.y;\n        vec3 colSSS = vec3(m*.2,m*.4,m*.2);\n        \n        \n\t\t// iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.16).x);\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n        float sss = df(p - n*0.001).x/0.01;\n\t\n        dif *= softshadow( p, ld, 0.1, 2. );\n        \n        vec3 brdf = vec3(-0.5) * tex;\n        brdf += 0.5*dif*vec3(1.00,0.90,0.60);\n        brdf += 0.4*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.3*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.5*(1.-sss)*colSSS;//vec3(0.2,0.7,0.2);\n        fragColor.rgb *= brdf;\n\n        fragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.01*d*d*count/150. ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n    \n    fragColor.rgb = sqrt(fragColor.rgb * fragColor.rgb * 0.8);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlByzG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 295, 319, 319, 402], [404, 404, 433, 433, 483], [485, 485, 502, 502, 951], [953, 953, 985, 985, 1163], [1165, 1181, 1255, 1255, 1494], [1496, 1512, 1554, 1554, 1853], [1855, 2050, 2107, 2107, 2395], [2397, 2397, 2454, 2454, 4347]]}
{"id": "XlfyWl", "name": "oOoOoOoOoOoOoOoOoOoOoOoOoOoOoOo", "author": "TinyTexel", "description": "practical application of analytical AA for disks ( https://www.shadertoy.com/view/XtfyWs ) and\nSpherical Fibonacci Mapping ( http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/ )\n", "tags": ["ooooo"], "likes": 47, "viewed": 5033, "published": "Public API", "date": "1507494255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// oOoOoOoOoOoOoOoOoOoOoOoOoOoOoOo\n// by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\npractical application of analytical AA for disks ( https://www.shadertoy.com/view/XtfyWs ) and\nSpherical Fibonacci Mapping ( http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/ )\npartly inspired by \"A Spiral of Circles\" by knarkowicz ( https://www.shadertoy.com/view/Md2yWR )\n*/\n\n#define SPOT_COUNT_MUL 12.0\n\n// uses 5x super sampling on top of the analytical AA; mainly improves quality at acute viewing angles\n// #define USE_SSAA\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\nconst float Pi2  = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\n#define If(cond, tru, fls) mix(fls, tru, cond)\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//=================================================================================================//\n// Spherical Fibonacci Mapping\n// http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/\n// Authors: Benjamin Keinert, Matthias Innmann, Michael SÃ¤nger, Marc Stamminger\n// (code copied from: https://www.shadertoy.com/view/4t2XWK)\n//-------------------------------------------------------------------------------------------------//\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat madfrac( float a,float b) { return a*b -floor(a*b); }\nvec2  madfrac( vec2 a, float b) { return a*b -floor(a*b); }\n\nfloat sf2id(vec3 p, float n) \n{\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI*PHI)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    \n    vec2 F = vec2( round(Fk), round(Fk * PHI) );\n\n    vec2 ka = -2.0*F/n;\n    vec2 kb = 2.0*PI*madfrac(F+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0);    \n    mat2 iB = mat2( ka.y, -ka.x, -kb.y, kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - (1.0-1.0/n)));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float cosTheta = dot(ka, uv + c) + (1.0-1.0/n);\n        \n        cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n        float i = floor(n*0.5 - cosTheta*n*0.5);\n        float phi = 2.0*PI*madfrac(i, PHI-1.0);\n        cosTheta = 1.0 - (2.0*i + 1.)/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return j;\n}\n\nvec3 id2sf( float i, float n) \n{\n    float phi = 2.0*PI*madfrac(i,PHI);\n    float zi = 1.0 - (2.0*i+1.)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n//=================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/*\nProjSphereArea - returns the screen space area of the projection of a sphere (assuming its an ellipse)\n\nIN:\n\trdz- z component of the unnormalized ray direction in camera space\n\tp  - center position of the sphere in camera space\n\trr - squared radius of the sphere\n\n\"Sphere - projection\" code used under\nThe MIT License\nCopyright Â© 2014 Inigo Quilez\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nfloat ProjSphereArea(float rdz, vec3 p, float rr)\n{\n\tfloat zz = p.z * p.z;\t\n\tfloat ll = dot(p, p);\n\t\n\t//return Pi * rdz*rdz * rr * sqrt(abs((rr - ll) / (zz - rr))) / (zz - rr);\n    return Pi * rdz*rdz * rr * rsqrt(abs(Pow3(rr - zz) / (rr - ll)));\n}\n\n// https://www.shadertoy.com/view/XtfyWs\nvec4 ProjDisk(vec3 rd, vec3 p, vec3 n, float rr)\n{   \n    vec3 np0 = n * p.xyz;\n    vec3 np1 = n * p.yzx;\n    vec3 np2 = n * p.zxy;  \n\n    mat3 k_mat = mat3(vec3( np0.y + np0.z,  np2.x        ,  np1.x        ),\n\t\t\t\t\t\t  vec3(-np2.y        ,  np1.y        , -np0.x - np0.z),\n\t\t\t\t\t\t  vec3(-np1.z        , -np0.x - np0.y,  np2.z        ));    \n    \n    vec3 u =     k_mat * rd;\n    vec3 k = u * k_mat;\n    \n    \n    float nrd = dot(n, rd);\n    \n    float nrd_rr = nrd * rr;\n\n    \n    float v = dot(u, u) - nrd * nrd_rr; \n    vec3  g =    (k     - n   * nrd_rr) * 2.0;   \n    \n    return vec4(g.xy, 0.0, v);\n}\n\n\n\nfloat Sph(float x, float rr) { return sqrt(rr - x*x); }\nfloat SphX0(float d, float rr0, float rr1) { return 0.5 * (d + (rr0 - rr1) / d); }\n\nvec3 EvalSceneCol(vec3 cpos, mat3 cam_mat, float focalLen, vec2 uv0)\n{      \n    const vec3 cBG = 0.014 * vec3(0.9, 1.0, 1.2);\n\n        \n    vec2 uv2 = uv0 - PixelCount.xy * 0.5;\n    \n  \tvec3 rdir0 = vec3(uv2, focalLen);\n    \n    float rdir0S = 0.5 * PixelCount.x;\n    rdir0 /= rdir0S;\n    \n    vec3 rdir = normalize(cam_mat * rdir0); \n    \n    \n    vec2 t;\n\tfloat hit = Intersect_Ray_Sphere(cpos, rdir, vec3(0.0), 1.0, OUT t);\n    \n    if(hit <= 0.0) return cBG;\n\n\n    vec3 pf = cpos + rdir * t.x;\n    vec3 pb = cpos + rdir * t.y;\n\n\tvec3 col = cBG;\n\n    //float lerpF = 0.0;\n    \n    float rra = 0.0;\n\n    vec3 p2;\n    float rr;\n    {\n\tconst float s = SPOT_COUNT_MUL;        \n    const float n = 1024.0*s;\n        \n    float id = sf2id(pf.xzy, n);\n    \t  p2 = id2sf(id,     n).xzy;        \n\n    float u = id / n;\n    float arg = (-u* 615.5*2.0*s) + Time * 1.0;//238-3 384.-2 615-1\n        \n    rra = sin(arg);\n    \n    #if 0    \n\t//for(float i = 0.0; i < 2.0; ++i)        \n\trra = (Pow2(rra)*2.-1.);\n    #endif\n        \n\trra = mix(abs(rra), Pow2(rra), 0.75);        \n      \n    rr = 0.0025/s * rra; \n    }\n    \n    \n    vec3 n2 = normalize(p2);\n    \n    const float maskS = 0.5;// sharpness\n\n    \n    if(SqrLen(pf - p2) > rr) return cBG;\n\n    float d = length(p2);\n\n    float x0 = SphX0(d, 1.0, rr);        \n    vec3 d0c = n2 * x0;\n\n    float d0rr = 1.0 - x0*x0;\n\n    vec3 dp_c = (d0c - cpos) * cam_mat;\n    vec3 dn_c = n2 * cam_mat;\n\n    vec4 r = ProjDisk(rdir0, dp_c, dn_c, d0rr);        \n\n    float cmask = clamp01(-r.w * rsqrt(dot(r.xy, r.xy))*rdir0S * maskS);\n\n    float cmask2 = 0.0;\n    {\n        vec3 d1c = n2 * (x0 - 0.005);\n\n        vec4 r = ProjDisk(rdir0, (d1c - cpos) * cam_mat, n2 * cam_mat, (1.0 - x0*x0)*rra);\n        cmask2 = clamp01(-r.w * rsqrt(dot(r.xy, r.xy))*rdir0S * maskS);\n    }\n\n\n    #if 1\t\n    float A = ProjSphereArea(rdir0.z, dp_c, d0rr);        \n    A *= rdir0S*rdir0S;\n\n    float NdV = abs(dot(dn_c, normalize(dp_c)));\n\n    A *= NdV;\n    \n    #ifndef USE_SSAA\n    A *= NdV;\n    cmask *= clamp01((A -2.0)*0.125);\n    #else\n    A = mix(A, A*NdV, 0.5);\n    cmask *= clamp01((A - 3.)*0.125);\n    #endif\n\n\n    #endif\n\n\n    const vec3 cB = vec3(0.1, 0.4, 1.0);\n    const vec3 cR = vec3(1., 0.02, 0.2);\n\n    //vec3 cX = mix(cB, cR, lerpF);\n    //vec3 cY = mix(cR, cB, lerpF);\n\n    return mix(cBG, mix(cR, vec3(0.0), cmask2), cmask);        \n    //return mix(cBG, mix(cR, cB, cmask2), cmask);\n    //return mix(cBG, mix(cX, cY, cmask2), cmask);        \n    //return mix(cBG, mix(cW, cX, cmask2), cmask);\n    //return mix(cBG, vec3(1.0), cmask);\n    //return vec3(-r.w*10.0);\n    //return vec3(1.0);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n  \n    \n    //vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n\n    vec2 ang = vec2(Pi * 0.0, -Pi * 0.3);\n    //ang += mouseAccu.xy * 0.008;\n\n    #if 1\n    ang.x += Time * 0.15;\n    //ang.y = sin(Time * 0.2 * Pi) *0.2;\n    \n    //ang.y += Time * 0.073;\n    #endif\n\n    float fov = Pi * 0.5;\n    \n    mat3 cam_mat;\n    float focalLen;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        vec3 up    = cross(right, front);\n\n        focalLen = PixelCount.x * 0.5 * tan(Pi05 - fov * 0.5);\n        \n        cam_mat = mat3(right, up, front);\n    }\n    \n    //vec3 cpos = -cam_mat[2] * (exp2(-0.3 + mouseAccu.w * 0.03));\n    vec3 cpos = -cam_mat[2] * (exp2(-0.3));\n\n    cpos.y += .75;\n\n    \n    #ifndef USE_SSAA\n    \n\tcol = EvalSceneCol(cpos, cam_mat, focalLen, uv0);\n    \n\t#elif 1\n    \n    col  = EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.3, 0.1));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.9, 0.3));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.5, 0.5));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.1, 0.7));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.7, 0.9));   \n    col *= 0.2;\n    \n \t#elif 1\n    \n    float o = 1.;\n    col  = EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.3, 0.1) * o - 0.5*o+0.5) * vec3(1.5, 0.75, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.9, 0.3) * o - 0.5*o+0.5) * vec3(0.0, 0.0, 3.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.5, 0.5) * o - 0.5*o+0.5) * vec3(0.0, 3.0, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.1, 0.7) * o - 0.5*o+0.5) * vec3(3.0, 0.0, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.7, 0.9) * o - 0.5*o+0.5) * vec3(0.0, 0.75, 1.5);   \n    \n    col /= vec3(4.5, 4.5, 4.5);\n\n    #endif\n\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfyWl.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[592, 995, 1016, 1016, 1028], [1029, 1029, 1050, 1050, 1064], [1065, 1065, 1086, 1086, 1108], [1110, 1110, 1136, 1136, 1173], [1176, 1176, 1199, 1199, 1213], [1214, 1214, 1237, 1237, 1255], [1256, 1256, 1279, 1279, 1297], [1298, 1298, 1321, 1321, 1339], [1341, 1341, 1369, 1369, 1395], [1396, 1396, 1422, 1422, 1454], [1455, 1455, 1481, 1481, 1513], [1514, 1514, 1540, 1540, 1572], [1774, 2071, 2152, 2152, 2581], [2585, 3254, 3287, 3287, 3313], [3314, 3314, 3347, 3347, 3373], [3375, 3375, 3406, 3406, 4606], [4608, 4608, 4640, 4640, 4817], [5024, 6400, 6451, 6451, 6648], [6650, 6691, 6741, 6741, 7295], [7299, 7299, 7329, 7329, 7354], [7355, 7355, 7399, 7399, 7437], [7439, 7439, 7509, 7509, 10082], [10085, 10085, 10133, 10133, 12349]]}
{"id": "XljcD1", "name": "Spell Demon Souls", "author": "leon", "description": "A sketch inspired by Dark Souls. Sometime you can see the twisted souls emerging from the distorted shapes. I could tweak this for days and nights...", "tags": ["spell"], "likes": 83, "viewed": 2105, "published": "Public", "date": "1508546072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define STEPS 1./50.\n#define VOLUME_BIAS 0.01\n#define MIN_DIST 0.005\n#define STEP_DAMPING .9\n#define PI 3.14159\n#define TAU PI*2.\n\n// raymarch toolbox\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\nfloat sdIso(vec3 p, float r) { return max(0.,dot(p,normalize(sign(p))))-r; }\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat amod (inout vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an/2.;\n    float c = floor(a/an);\n    a = mod(a,an)-an/2.;\n    p.xy = vec2(cos(a),sin(a))*length(p);\n    return c;\n}\n\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\nfloat smin (float a, float b, float r) {\n    float h = clamp(.5+.5*(b-a)/r, 0., 1.);\n    return mix(b,a,h)-r*h*(1.-h);\n}\n\n// geometry for spell\nfloat tubes (vec3 pos) {\n    \n    // cylinder made of 8 tube\n    float cylinderRadius = .02; // change shape\n    vec3 p = pos;\n    p.xz *= rot(p.y*.5); // twist amount\n    float c = amod(p.xz, 8.); // amount of tubes\n    p.x -= 2.; // tube cylinder radius\n    float tube = sdCylinder(p.xz, cylinderRadius);\n    \n    // another cylinder made of tubes 16\n    p = pos;\n    p.xz *= rot(-p.y*.5); // twist amount\n    c = amod(p.xz, 16.); // amount of tubes\n    p.x -= 2.; // tube cylinder radius\n    tube = smin(tube, sdCylinder(p.xz, cylinderRadius), .15);\n    return tube;\n}\n\n// geometry for spell\nfloat disks (vec3 pos) {\n    float radius = 1.5;\n    float radiusInner = .57;\n    float thin = .01;\n    float repeatY = 2.;\n    float cellY = floor(pos.y/repeatY);\n    float a = atan(pos.z,pos.x)-iTime*.3+cellY*.1;\n    vec3 p = pos;\n    p.y += sin(a*6.)*.1;\n    p.y = repeat(p.y, repeatY);\n    float disk = max(-sdCylinder(p.xz, radiusInner), sdCylinder(p.xz, radius));\n    disk = max(abs(p.y)-thin,disk);\n    return disk;\n}\n\nvec3 anim1 (vec3 p) {\n    float t = iTime*.5;\n    p.xz *= rot(t);\n    p.xy *= rot(t*.7);\n    p.yz *= rot(t*.5);\n    return p;\n}\n\nvec3 anim2 (vec3 p) {\n    float t = -iTime*.4;\n    p.xz *= rot(t*.9);\n    p.xy *= rot(t*.6);\n    p.yz *= rot(t*.3);\n    return p;\n}\n\nfloat map (vec3 pos) {\n    float scene = 1000.;\n    \n    // ground and ceiling\n    float bump = texture(iChannel0, pos.xz*.1).r;\n    float ground = 2. - bump*.1;\n    scene = min(scene, pos.y+ground);\n    scene = min(scene, -(pos.y-ground));\n    \n    // spell geometry 1\n    vec3 p = pos;\n    p.y += sin(atan(p.z,p.x)*10.)*3.; // change numbers to get new distortion\n    p.xz *= rot(p.y*.2-iTime);\n    p = anim1(p);\n    p.x = length(p.xyz)-3.;\n    scene = smin(scene, tubes(p), .5);\n    scene = smin(scene, disks(p), .5);\n    \n    // spell geometry 2\n    p = pos;\n    p.y += sin(atan(p.z,p.x)*3.)*2.; // change numbers to get new distortion\n    p = anim2(p);\n    p.xz *= rot(p.y+iTime);\n    p.x = length(p.xyz)-3.;\n    scene = smin(scene, tubes(p), .3);\n    scene = smin(scene, disks(p), .3);\n    \n    return scene;\n}\n\nvoid camera (inout vec3 p) {\n    p.xz *= rot((-PI*(iMouse.x/iResolution.x-.5)));\n}\n\nvoid mainImage( out vec4 color, in vec2 uv )\n{\n\tuv = (uv.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec3 eye = vec3(0.,0.,-7.+mouse.y*3.);\n    vec3 ray = normalize(vec3(uv,.7));\n    camera(eye);\n    camera(ray);\n    vec3 pos = eye;\n    float shade = 0.;\n    for (float i = 0.; i <= 1.; i += STEPS) {\n        float dist = map(pos);\n        if (dist < VOLUME_BIAS) {\n            shade += STEPS;\n        }\n        if (shade >= 1.) break;\n        dist *= STEP_DAMPING + .1 * rng(uv+fract(iTime));\n        dist = max(MIN_DIST, dist);\n        pos += dist * ray;\n    }\n\tcolor = vec4(1);\n    color.rgb *= shade;\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljcD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 152, 175, 175, 242], [243, 243, 263, 263, 313], [314, 314, 348, 348, 370], [371, 371, 407, 407, 429], [430, 430, 460, 460, 506], [507, 507, 538, 538, 625], [626, 626, 666, 666, 837], [839, 839, 872, 872, 896], [897, 897, 937, 937, 1017], [1019, 1041, 1065, 1101, 1612], [1614, 1636, 1660, 1660, 2060], [2062, 2062, 2083, 2083, 2189], [2191, 2191, 2212, 2212, 2322], [2324, 2324, 2346, 2346, 3140], [3142, 3142, 3170, 3170, 3224], [3226, 3226, 3272, 3272, 3872]]}
{"id": "XljcDh", "name": "2d signed distance functions v2", "author": "tholzer", "description": "Test stuff for antialaised '2d signed distance functions' \nVersion 2 with corrected scaling and small improvements!\nSet 2nd light position with mouse.\n3nd row: sub, and, or, soft or, xor, arc. ", "tags": ["2d", "shadow", "distance", "occlusion", "penumbra", "ambient", "soft", "signed"], "likes": 29, "viewed": 908, "published": "Public", "date": "1509052499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// 2dDistanceFunctionsV2.glsl\n\n/**\n original:   https://www.shadertoy.com/view/4dfXDn by Maarten 2015-Aug-17\n\n Hi all,\tThis is just my playground for a bunch of 2D stuff:\n Some distance functions and blend functions\n Cone marched 2D Soft shadows\n Use the mouse to control the 2nd light\n\n tags: 2d, shadow, distance, occlusion, penumbra, ambient, soft, signed \n\n v2.0  2017-10-29  improved version\n v2.1  2017-11-06  sdEllipse, pumpkin2D & flower added\n       2017-12-01  working on... \n\n references: \n \n  - 2d-Primitive collection\n      https://www.shadertoy.com/view/MssyRN \n\n  - modeling with distance functions\n      http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n  - ellipse distance by Inigo Quilez\n      http://iquilezles.org/www/articles/ellipsedist/ellipsedist.htm\n*/\n\n\n#define BORDER_THICKNESS 2.5\n\nconst vec4 fillColor   = vec4(1.0, 0.4, 0.0, 1.0);   // orange\nconst vec4 borderColor = vec4(0.1, 0.1, 0.1, 1.0);   // darkgray\n\nconst float HALF_PI = 1.57079632679;\nconst float      PI = 3.14159265359;\nconst float  TWO_PI = 6.28318530718;\n\nvec2 uv = vec2(0);  // centered pixel position -1 .. 1\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\nfloat mergeExclude(float d1, float d2)\n{\n\treturn min(max(-d1, d2), max(-d2, d1));\n}\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\nvec2 rotateCCW (vec2 pos, float angle)\n{ float ca = cos(angle),  sa = sin(angle);\n  return pos * mat2(ca, sa, -sa, ca);  }\n\n\nvec2 rotateCW (vec2 pos, float angle)\n{ float ca = cos(angle),  sa = sin(angle);\n  return pos * mat2(ca, -sa, sa, ca);  }\n\n\nvec2 translate(vec2 p, vec2 t) \n{ return p - t; }\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\nfloat pie(vec2 p, float angle)\n{\n  angle = radians(angle) / 2.0;\n  return abs(p.x) * sin(angle) + p.y*cos(angle);\n}\n\nfloat sdCircle (vec2 p, float radius)\n{\n  return length(p) - radius;\n}\n\nfloat triangleDist(vec2 p, float radius)\n{\n  return max( abs(p.x) * 0.866025 + p.y * 0.5, -p.y) -radius * 0.5;\n}\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n  vec2 n = normalize(vec2(height, width / 2.0));\n  return max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n  width /= 2.0;\n  radius -= width;\n  return substract(pie(p, angle + sin(iTime)*55.), \n                       abs(length(p) - radius) - width);\n}\n\n//---------------------------------------------------------\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n  vec2 dir = start - end;\n  float lngth = length(dir);\n  dir /= lngth;\n  vec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n  return length( (start - p) - proj ) - (width / 2.0);\n}\n\n//---------------------------------------------------------\n// IQ's signed distance to a 2D rounded box\n//---------------------------------------------------------\nfloat sdBox(in vec2 p, in vec2 size, in float radius)\n{\n  vec2 d = abs(p) - size + radius;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n//---------------------------------------------------------\n// IQ's signed distance to ellipse\n//---------------------------------------------------------\nfloat sdEllipse(in vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * sign(p.y-r.y);\n}\n\n//---------------------------------------------------------\n// draw polygon with given radius n edges at pos \n//---------------------------------------------------------\nfloat polygon(vec2 p, float radius, float vertices)\n{\n  float angle = atan(p.x, -p.y) + TWO_PI;\n  float r = TWO_PI / vertices;\n  return cos(floor(0.5 + angle / r) * r - angle) * length(p) - radius;\n}\n//---------------------------------------------------------\nfloat flower(vec2 p, float radius, float leafs)\n{\n  return 25.*(length(p)/radius - 0.4*sin(leafs*(atan(p.y,p.x)-iTime)) -0.75);\n}\n//---------------------------------------------------------\n// https://www.shadertoy.com/view/4tBcRV\n//---------------------------------------------------------\nfloat pumpkin2D(vec2 p, float radius, float vertices, float curvature)\n{\n  float angle = atan(p.x, -p.y) / TWO_PI * vertices;\n  return length(p) -radius +smoothstep(0., 1., abs(fract(angle)-0.5)) *radius *curvature;\n}\n//---------------------------------------------------------\nfloat PacMan (vec2 p, float radius)  // toDo need correction\n{\n  float d = length(p);   // get distance of current coordinate\n  float circle = d - radius;   // basic circle\n  // smooth paint if coordinate is inside circle and outside the mouth\n  float mouth = smoothstep(p.x/d, p.x/d-0.1, 0.2*sin(iTime*12.)+0.84);\n  if (mouth < circle) return circle;\n  return max(circle, 4.0*mouth);  // what's wrong ???\n}\n\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\nfloat innerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\treturn clamp(dist + width, 0.0, 1.0) - clamp(dist, 0.0, 1.0);\n}\n\nfloat outerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\treturn clamp(dist, 0.0, 1.0) - clamp(dist - width, 0.0, 1.0);\n}\n\n\n///////////////\n// The scene //\n///////////////\n\nfloat sceneDistance(vec2 p)  // p: position\n{\n    //=== 1st row ===\n    int yd = 340;\n    \n    float ts = sin(iTime)*.49+.49;\n    float edges = 4. + floor(8. * ts);  \n\n    float  m = polygon(\t\t\ttranslate(p, vec2(100, yd)), 40.0, edges);\n//    float  m = PacMan(\t\t\ttranslate(p, vec2(100, yd)), 35.0);\n    \n    float p1 = pumpkin2D(\t\ttranslate(p, vec2(200, yd)), 35.0, edges, -0.5);\n    float s1 = pumpkin2D(\t\ttranslate(p, vec2(300, yd)), 40.0, edges, +0.4);\n\tfloat bb = sdBox(\t\t\ttranslate(p, vec2(400, yd)), vec2(40, 20), 10.0);\n//    float e1 = sdEllipse(\t\ttranslate(p, vec2(500, yd)), vec2(40, 20));\n    float f1 = flower(          translate(p, vec2(500, yd)), 40., edges);\n    \n    vec2        pt = rotateCW ( translate(p, vec2(600, yd)), iTime);\n    float e2 = sdEllipse(\t\tpt, vec2(40, 20));\n    \n    m = merge(m, p1); // not working \n    m = merge(m, s1); \n    m = merge(m, bb); \n    m = merge(m, f1); \n    m = merge(m, e2); \n    \n    //=== 2nd row ===\n    yd = 210;\n    \n    float c1 = sdCircle(\t\ttranslate(p, vec2(100, yd)), 40.0);\n\tfloat b1 = sdBox(\t\t\ttranslate(p, vec2(200, yd)), vec2(40, 40),  0.0);\n\tfloat b2 = sdBox(\t\t\ttranslate(p, vec2(300, yd)), vec2(40, 40), 10.0);\n\n               pt = rotateCCW( translate(p, vec2(400, yd)), iTime);\n\tfloat l1 = lineDist(\t\tpt,  vec2(-30, -30),  vec2(30, 30),\t10.0);\n\n                pt = rotateCW(  translate(p, vec2(500, yd-40)), 0.5*sin(iTime));\n    float t1 = triangleDist(\tpt, 60.0, 80.0);\n\n                pt = rotateCW(  translate(p, vec2(600, yd)), iTime);\n\tfloat t2 = triangleDist(\tpt, 40.0);\n\t\n    m = merge(m, c1);  // circle\n    m = merge(m, b1);  // square\n\tm = merge(m, b2);  // rounded box\n\tm = merge(m, l1);  // line\n\tm = merge(m, t1);  // triangle 1\n\tm = merge(m, t2);  // triangle 2\n\t\n    //=== 3nd row ===\n    float yr = 80.;\n    \n\t// circle - rectangle\n    float b3 = sdBox(\t\ttranslate(p, vec2(100, yr + sin(iTime * 3.0 + 1.0) * 40.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c2 = sdCircle(\ttranslate(p, vec2(100, yr)),\t30.0);\n\tfloat sub = substract(b3, c2);\n\t\n    // circle and rectangle\n\tfloat b4 = sdBox(\t\ttranslate(p, vec2(200, yr + sin(iTime * 3.0 + 2.0) * 40.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c3 = sdCircle(\ttranslate(p, vec2(200, yr)), \t30.0);\n\tfloat and = intersect(b4, c3);\n\t\n\t// circle or rectangle\n    float b5 = sdBox(\t\ttranslate(p, vec2(300, yr + sin(iTime * 3.0 + 3.0) * 40.0)),\n                            vec2(40, 15), \t0.0);\n\tfloat c4 = sdCircle(\ttranslate(p, vec2(300, yr)), \t30.0);\n\tfloat or = merge(b5, c4);\n\t\n\t// soft circle or rectangle\n\tfloat b6 = sdBox(\t\ttranslate(p, vec2(400, yr + sin(iTime * 1.0) * 20.0)),\n                            vec2(40, 15), \t0.0);\n\tfloat c5 = sdCircle(\ttranslate(p, vec2(400, yr)), \t30.0);\n\tfloat sor = smoothMerge(b6, c5, 10.0);\n\t\n\t// circle xor rectangle\n    float b7 = sdBox(\t\ttranslate(p, vec2(500, yr + sin(iTime * 3.0 + 3.0) * 40.0)),\n                            vec2(40, 15), \t0.0);\n\tfloat c6 = sdCircle(\ttranslate(p, vec2(500, yr)), \t30.0);\n\tfloat xor = mergeExclude(b7, c6);\n    \n\t// arc\n\tfloat arc = semiCircleDist(translate(p, vec2(600,yr)), 40.0, 90.0, 10.0);\n    \n\tm = merge(m, sub);  // sub \n\tm = merge(m, and);  // and \n\tm = merge(m, or);   // or\n\tm = merge(m, sor);  // soft or\n    m = merge(m, xor);  // xor\n\tm = merge(m, arc);  // arc\n\n\treturn m;\n}\n\nfloat sceneSmooth(vec2 p, float r)\n{\n\tfloat accum = sceneDistance(p);\n\taccum += sceneDistance(p + vec2(0.0, r));\n\taccum += sceneDistance(p + vec2(0.0, -r));\n\taccum += sceneDistance(p + vec2(r, 0.0));\n\taccum += sceneDistance(p + vec2(-r, 0.0));\n\treturn accum; // / 5.0;\n}\n\n\n//////////////////////\n// Shadow and light //\n//////////////////////\n\nfloat shadow(vec2 p, vec2 pos, float radius)\n{\n\tvec2 dir = normalize(pos - p);\n\tfloat dl = length(p - pos);\n\t\n\t// fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * dl;\n\t\n\t// distance traveled\n\tfloat dt = 0.01;\n\n\tfor (int i = 0; i < 64; ++i)\n\t{\t\t\t\t\n\t\t// distance to scene at current position\n\t\tfloat sd = sceneDistance(p + dir * dt);\n\n        // early out when this ray is guaranteed to be full shadow\n        if (sd < -radius) \n          return 0.0;\n        \n\t\t// width of cone-overlap at light\n\t\t// 0 in center, so 50% overlap: add one radius outside of loop to get total coverage\n\t\t// should be '(sd / dt) * dl', but '*dl' outside of loop\n\t\tlf = min(lf, sd / dt);\n\t\t\n\t\t// move ahead\n\t\tdt += max(1.0, abs(sd));\n\t\tif (dt > dl) break;\n\t}\n\t// multiply by dl to get the real projected overlap (moved out of loop)\n\t// add one radius, before between -radius and + radius\n\t// normalize to 1 ( / 2*radius)\n\tlf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\treturn lf;\n}\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)\n{\n\t// distance to light\n\tfloat ld = length(p - pos);\n\t\n\t// out of range ?\n\tif (ld > range) return vec4(0.0);\n\t\n\t// shadow and falloff\n\tfloat shad = shadow(p, pos, radius);\n\tfloat fall = (range - ld)/range;\n\tfall *= fall;\n\tfloat source = fillMask(sdCircle(p - pos, radius));\n\treturn (shad * fall + source) * color;\n}\n\nfloat luminance(vec4 col)\n{\n\treturn 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\n\nvoid setLuminance(inout vec4 col, float lum)\n{\n\tlum /= luminance(col);\n\tcol *= lum;\n}\n\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n\tfloat a = clamp(dist / radius, 0.0, 1.0) - 1.0;\n\treturn 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n\treturn smoothstep(0.0, 1.0, dist / radius);\n}\n\n\n/////////////////\n// The program //\n/////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rx = iResolution.x;\n\tvec2 uv = 700. * (fragCoord.xy + vec2(0.5)) / rx;\n\tvec2 mp = (iMouse.xy) * 700. / rx;\n\t\n\tfloat dist = sceneDistance(uv);\n\t\n    // mouse light \n\tvec2 light1Pos = mp.xy;\n\tvec4 light1Col = vec4(0.75, 1.0, 0.5, 1.0);\n\tsetLuminance(light1Col, 0.4);\n\t\n\t// moving light\n    vec2 light2Pos = vec2(rx * (sin(iTime + 3.1415) + 1.2) / 2.4, 150.0);\n\tvec4 light2Col = vec4(1.0, 0.75, 0.5, 1.0);\n\tsetLuminance(light2Col, 0.5);\n\t\n//\tvec2 light3Pos = vec2(rx * (sin(iTime) + 1.2) / 2.4, 340.0);\n//\tvec4 light3Col = vec4(0.5, 0.75, 1.0, 1.0);\n//\tsetLuminance(light3Col, 0.6);\n\t\n\t// gradient\n\tvec4 col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(iResolution.xy/1.4 - uv)/rx);\n\t// grid\n\tcol *= clamp(min(mod(uv.y, 10.0), mod(uv.x, 10.0)), 0.9, 1.0);\n\t// ambient occlusion\n\tcol *= AO(uv, sceneSmooth(uv, 10.0), 40.0, 0.4);\n\t//col *= 1.0-AO(uv, sceneDistance(uv), 40.0, 1.0);  // object lightning\n\n    // light\n\tcol += drawLight(uv, light1Pos, light1Col, dist, 150.0, 6.0);\n\tcol += drawLight(uv, light2Pos, light2Col, dist, 200.0, 8.0);\n//\tcol += drawLight(uv, light3Pos, light3Col, dist, 300.0, 12.0);\n\n    col = mix(col, fillColor, fillMask(dist));\n\tcol = mix(col, borderColor, innerBorderMask(dist, BORDER_THICKNESS));\n\n\tfragColor = clamp(col, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljcDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1127, 1245, 1293, 1293, 1394], [1396, 1396, 1429, 1429, 1452], [1454, 1454, 1494, 1494, 1537], [1539, 1539, 1576, 1576, 1600], [1602, 1602, 1639, 1639, 1662], [1664, 1758, 1798, 1798, 1880], [1883, 1883, 1922, 1922, 2004], [2007, 2007, 2040, 2040, 2056], [2059, 2153, 2185, 2185, 2268], [2270, 2270, 2309, 2309, 2340], [2342, 2342, 2384, 2384, 2454], [2456, 2456, 2511, 2511, 2622], [2624, 2624, 2694, 2694, 2840], [2842, 2902, 2961, 2961, 3154], [3156, 3320, 3375, 3375, 3477], [3479, 3634, 3675, 3675, 4740], [4742, 4912, 4965, 4965, 5111], [5112, 5172, 5221, 5221, 5301], [5302, 5463, 5535, 5535, 5680], [5681, 5741, 5803, 5803, 6148], [6151, 6224, 6252, 6252, 6286], [6288, 6288, 6336, 6352, 6417], [6419, 6419, 6467, 6483, 6548], [6551, 6600, 6645, 6667, 9896], [9898, 9898, 9934, 9934, 10168], [10171, 10241, 10287, 10287, 11294], [11296, 11296, 11381, 11403, 11695], [11697, 11697, 11724, 11724, 11784], [11786, 11786, 11832, 11832, 11871], [11873, 11873, 11934, 11934, 12102], [12105, 12161, 12218, 12218, 13487]]}
{"id": "XljcRh", "name": "Cubic Spline Approximation", "author": "paniq", "description": "two quadratic patches easily assembled to approximate a cubic spline, using bernstein polynomials of second degree.", "tags": ["spline", "cubic", "quadratic", "polynomial", "bernstein"], "likes": 7, "viewed": 488, "published": "Public API", "date": "1507419448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// undefine to show ground truth\n#define SHOW_CUBIC_SPLINE\n\nfloat p[4];\n\nfloat cubic_spline_approx(float x) {\n    float m[2];\n    m[0] = p[1] + (p[2] - p[0]) / 8.0;\n    m[1] = p[2] - (p[3] - p[1]) / 8.0;\n    float c = (m[0] + m[1]) / 2.0;\n    x = x*2.0 - 1.0;\n    bool left = (x < 0.0);\n    vec3 q = left?vec3(p[1],m[0],c):vec3(c, m[1], p[2]);\n    x += float(left);\n    float t0 = (1.0 - x); t0 *= t0;\n    float t1 = 2.0*(1.0 - x)*x;\n    float t2 = x*x;\n    return t0*q[0] + t1*q[1] + t2*q[2];\n}\n\nfloat cubic_spline(float x) {\n\tfloat m[2];    \n    // compute control points\n    m[0] = p[1] + (p[2] - p[0]) / 6.0;\n    m[1] = p[2] - (p[3] - p[1]) / 6.0;\n    \n    float rx = (1.0 - x);\n    float rxx = rx*rx;\n    float xx = x*x;\n    \n    float t0 = rxx*rx;\n    float t1 = 3.0*x*rxx;\n    float t2 = 3.0*xx*rx;\n    float t3 = xx*x;\n    \n    return t0 * p[1] + t1 * m[0] + t2 * m[1] + t3 * p[2];\n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nvoid paint() {\n    float t = iTime;\n    \n    p[0] = cos(t*0.79)*1.5;\n    p[1] = sin(t*0.9)*0.8;\n    p[2] = cos(t*0.49)*0.8;\n    p[3] = cos(t*0.3333)*1.5;\n    \n    float d0 = (p[2] - p[0]) / 2.0;\n    float d1 = (p[3] - p[1]) / 2.0;\n    \n    float m[2];\n    m[0] = p[1] + d0 / 3.0;\n    m[1] = p[2] - d1 / 3.0;\n    \n    translate(-0.5, 0.0);\n    \n    set_source_rgb(vec3(1.0));\n    clear();\n    \n    set_line_width_px(1.3);\n    \n    set_source_rgba(1.0,0.0,0.0,1.0);\n    move_to(0.0,p[1]);\n\tline_to(0.25,p[1]+d0/4.0);\n    line_to(0.75,p[2]-d1/4.0);\n\tline_to(1.0,p[2]);\n    stroke();\n\n#ifdef SHOW_CUBIC_SPLINE\n    set_source_rgba(0.5,0.5,0.5,1.0);\n    graph1D(cubic_spline);\n\tstroke();\n#endif\n    set_source_rgba(0.0,0.0,0.0,1.0);\n    graph1D(cubic_spline_approx);\n\tstroke();\n    \n    \n    move_to(-3.0,0.0);\n    line_to(3.0,0.0);\n    move_to(-1.0,-1.0);\n\tline_to(-1.0,1.0);\n    move_to(0.0,-1.0);\n\tline_to(0.0,1.0);\n    move_to(1.0,-1.0);\n\tline_to(1.0,1.0);\n    move_to(2.0,-1.0);\n\tline_to(2.0,1.0);\n    stroke();\n    \n    circle(-1.0, p[0], 0.02);\n    circle(0.0, p[1], 0.02);\n    circle(1.0, p[2], 0.02);\n    circle(2.0, p[3], 0.02);\n\tfill();\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));\n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\n    float m = ab.x*p.x/l;\n\tfloat n = ab.y*p.y/l;\n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n\n    vec2 r = vec2( ab.x*co, ab.y*si );\n\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljcRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 150, 186, 186, 572], [574, 574, 603, 603, 968], [6714, 6779, 6793, 6793, 7922], [8076, 8136, 8163, 8163, 8189], [8191, 8251, 8272, 8272, 8379], [8381, 8381, 8418, 8418, 8504], [8506, 8506, 8552, 8552, 8585], [8587, 8725, 8753, 8753, 9213], [9241, 9241, 9260, 9260, 9293], [9295, 9295, 9313, 9313, 9346], [9348, 9348, 9372, 9372, 9476], [9478, 9478, 9495, 9495, 9516], [9518, 9518, 9545, 9567, 9850], [9852, 9852, 9880, 9880, 10114], [10116, 10116, 10140, 10140, 10226], [10228, 10228, 10255, 10255, 10468], [10470, 10470, 10496, 10496, 10724], [10726, 10726, 10748, 10748, 10874], [10876, 10876, 10896, 10896, 10956], [10958, 10958, 10990, 10990, 11017], [11019, 11019, 11040, 11040, 11062], [11064, 11064, 11088, 11088, 11148], [11150, 11150, 11184, 11184, 11208], [11210, 11210, 11224, 11224, 11288], [11290, 11290, 11316, 11316, 11354], [11356, 11356, 11382, 11382, 11403], [11405, 11405, 11428, 11428, 11523], [11525, 11525, 11549, 11549, 11618], [11620, 11620, 11645, 11645, 11692], [11694, 11694, 11711, 11711, 11824], [11826, 11826, 11849, 11849, 11978], [11980, 11980, 12008, 12008, 12136], [12138, 12138, 12162, 12162, 12302], [12304, 12304, 12342, 12342, 12476], [12478, 12478, 12515, 12515, 12550], [12552, 12552, 12579, 12579, 12629], [12631, 12631, 12661, 12661, 12717], [12719, 12719, 12748, 12748, 12929], [12931, 12931, 12953, 12953, 13112], [13114, 13114, 13127, 13127, 13166], [13168, 13168, 13198, 13198, 13227], [13229, 13229, 13262, 13262, 13319], [13321, 13321, 13347, 13347, 13397], [13399, 13399, 13420, 13420, 13485], [13487, 13487, 13511, 13511, 13594], [13596, 13596, 13611, 13611, 13652], [13654, 13654, 13670, 13670, 13708], [13710, 13710, 13728, 13728, 13785], [13787, 13787, 13817, 13817, 14187], [14189, 14189, 14247, 14247, 14285], [14287, 14287, 14316, 14316, 14352], [14354, 14354, 14402, 14402, 14433], [14435, 14435, 14469, 14469, 14528], [14530, 14530, 14607, 14607, 14772], [14774, 14774, 14851, 14851, 14931], [14933, 14933, 15009, 15009, 15125], [15127, 15127, 15203, 15203, 15281], [15283, 15283, 15321, 15321, 15355], [15357, 15357, 15379, 15379, 15425], [15427, 15427, 15454, 15454, 15498], [15500, 15500, 15549, 15549, 15810], [15812, 15812, 15885, 15885, 15939], [15941, 15941, 15973, 15973, 16009], [16011, 16011, 16067, 16067, 16123], [16125, 16125, 16155, 16155, 16248], [16249, 16249, 16289, 16289, 16312], [16314, 16360, 16399, 16399, 17547], [17549, 17549, 17579, 17579, 17681], [17683, 17683, 17735, 17735, 17775], [17777, 17777, 17799, 17799, 17850], [17852, 17852, 17884, 17884, 17906], [17908, 17923, 17945, 17945, 18237], [18239, 18239, 18271, 18271, 18293], [18295, 18295, 18314, 18314, 18346], [18395, 18458, 18500, 18500, 18566], [18568, 18638, 18689, 18689, 19041], [19043, 19077, 19123, 19123, 19635], [19637, 19706, 19752, 19752, 20258], [20260, 20260, 20293, 20293, 20509], [20511, 20511, 20570, 20570, 20615], [20617, 20617, 20660, 20660, 20721], [20723, 20723, 20765, 20765, 20802], [20804, 20864, 20921, 20921, 21120]]}
{"id": "XljcRR", "name": "preAlpha Vector Field", "author": "Chris_M_Thomasson", "description": "Here is one of my vector fields in a GLSL pre-alpha experiment. Sorry for the verbose nature of the code: I am still trying to feel things out in GLSL. ;^o", "tags": ["fractal", "math", "circle", "space", "field", "vector", "art", "parametric", "trigonometry"], "likes": 6, "viewed": 259, "published": "Public", "date": "1507174391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nPre-Alpha Vector Field by Chris M. Thomasson\nThe code is basic, and the math can be streamlined.\nThis is a basic experiment, not thinking of sheer performance yet.\n___________________________________*/\n\n\n// The number of points in the spiral\n#define CT_N 16\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// A vector field point\nstruct ct_vfpoint\n{\n    vec2 p;\n    float m;\n};\n\n\n// Our global per-pixel points\nct_vfpoint g_vfp[CT_N];\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec2 ct_vfield_normal(\n    in vec2 p,\n    float npow\n){\n    vec2 g = vec2(0.0, 0.0);\n    \n    const int imax = CT_N;\n    \n    for (int i = 0; i < imax; ++i)\n    {\n        vec2 dif = g_vfp[i].p - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1];\n        float mass = pow(sum, npow);\n        \n      \tg[0] = g[0] + g_vfp[i].m * dif[0] / mass;\n      \tg[1] = g[1] + g_vfp[i].m * dif[1] / mass;\n        \n        \n    }\n    \n    return normalize(g);\n}\n\nfloat ct_normal_pi(\n    in vec2 z\n){\n    vec2 d = vec2(z[0] * z[0] + z[1] * z[1]);\n    float a = atan(d[1], d[0]);\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    vec2 vn = ct_vfield_normal(z, npow);\n    float npi = ct_normal_pi(vn);\n    \n    float blah = length(vn);\n    \n    if (blah < .01)\n    {\n        return vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    \n    return vec4(vn.x, vn.y, vn.x * vn.y, 1.0);\n}\n\n\n// High-Level Entry\nvec4 ct_main(\n    in vec2 c\n){\n    \n    float bradius = 1.0;\n    float abase = 6.28318 / float(CT_N);\n    float arbase = bradius / float(CT_N);\n    \n    for (int i = 0; i < CT_N; ++i)\n    {\n        float angle = abase * float(i) + cos(iTime * .1);\n        float radius = 1.2 + arbase * float(i) + abs(sin(iTime)) * .7;\n       \n        vec2 z = vec2(\n            cos(angle) * abs(cos(angle + sin(iTime * .1))) * radius,\n            sin(angle) * abs(sin(angle)) * radius\n        );\n        \n        g_vfp[i] = ct_vfpoint(z, 1.0);\n    }\n    \n    return ct_vpixel(c, c, 128, 2.0 + abs(cos(iTime * 3.0)) * 7.14);\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(0.0, 0.0, 1.618);\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(c);\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljcRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 373, 425, 425, 585], [588, 692, 744, 744, 1433], [1436, 1436, 1498, 1498, 1606], [1740, 1803, 1858, 1858, 2255], [2257, 2257, 2293, 2293, 2436], [2439, 2465, 2545, 2545, 2786], [2789, 2809, 2839, 2839, 3418], [3421, 3435, 3496, 3496, 3766]]}
{"id": "XljyRR", "name": "Gaussian Blue Noise 2", "author": "TimoKinnunen", "description": "A bigger comparison of various noise functions at top/left and two ways of doing approximate Gaussian blue noise at bottom/right. Notice how the noises based on the sin-function start showing more and more patterns after a while.", "tags": ["noise", "blue", "gaussian", "dithering", "histogram", "triangular"], "likes": 14, "viewed": 1051, "published": "Public API", "date": "1507169521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Gaussian Blue Noise 2\n// by Timo Kinnunen 2017\n//\n// Comparison between approximated Gaussian blue noise,\n// approximated Gaussian noise and triangular noise.\n//\n// The idea is to approximate a Gaussian distribution by\n// adding a bunch of uncorrelated random values together.\n// Given enough values the familiar bell shaped curve\n// should emerge, but we only add 4 to reduce the cost.\n//\n// To approximate blue noise, the resulting random values\n// are filtered. Using a 5x5 filter kernel causing\n// \"ringing\" would give a nice result, but we only\n// use a 3x1 kernel on the theory that on an LCD screen\n// vertical stripes are less apparent than\n//\n// __________ horizontal lines. ___________\n//\n// The end result is a self-contained noise function that\n// hopefully should optimize well.\n//\n\n//\n// Segments from top to bottom and left to right are:\n//\n// Triangular noise w/ a 2to2-hash\n// Triangular noise w/ 2x 2to1-hash\n// Triangular noise w/ a 2to1-hash, remapped\n// Exponential noise w/ a 2to1-hash, remapped from ^1 to ^8 (use mouse!)\n// Gaussian noise w/ 4x 2to1-hash, summed\n// Gaussian noise w/ 2x 2to1-hash, remapped\n// Gaussian blue noise w/ 3 taps of 2x 2to1-hash, remapped\n// Gaussian blue noise w/ 3 taps of a 2to4-hash, summed\n//\n\n//\n// Based on A faster triangle noise by TomF\n// @ https://www.shadertoy.com/view/4t2SDh\n//\n// Based on Triangular PDF Noise Dithering by andyborrell\n// @ https://www.shadertoy.com/view/Mllczf\n//\n\n// Modification of https://www.shadertoy.com/view/4ssXRX\n// Added a second way to do triangle noise without doing\n// a second random sample.\n\nconst int NUM_BUCKETS = 32;\nconst int ITER_PER_BUCKET = 1024;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\n\nfloat iiTime;\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(p.xyx * vec3(9.1031, 8.1030, 7.0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.x+p3.yz)*p3.zy);\n}\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat truncate( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\nfloat n2rand( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\n\nfloat n2rand_faster( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\n    // Convert uniform distribution into triangle-shaped distribution.\n    float orig = nrnd0*2.0-1.0;\n    nrnd0 = orig*inversesqrt(abs(orig));\n    nrnd0 = max(-1.0,nrnd0); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!\n    nrnd0 = nrnd0-sign(orig)+0.5;\n    \n    // Result is range [-0.5,1.5] which is\n    // useful for actual dithering.\n    // convert to [0,1] for histogram.\n    return (nrnd0+0.5) * 0.5;\n}\nfloat n2rand_tri(vec2 n) {\n    n += 0.07* fract(iiTime);\n    return dot(hash22(n), vec2(1))*0.5;\n}\nfloat n3rand( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\treturn (nrnd0+nrnd1+nrnd2) / 3.0;\n}\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n}\nfloat n4rand_inv( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    float nrnd4 = nrand( n + 0.19*t );\n\tfloat v1 = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n    float v2 = 0.5 * remap( 0.0, 0.5, v1 ) + 0.5;\n    float v3 = 0.5 * remap( 0.5, 1.0, v1 );\n    return (nrnd4<0.5) ? v2 : v3;\n}\n\n//alternate Gaussian,\n//thanks to @self_shadow\nfloat n4rand_ss( vec2 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07*fract( iiTime ) );\n\tfloat nrnd1 = nrand( n + 0.11*fract( iiTime + 0.573953 ) );\t\n\treturn 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;\n}\n//Mouse Y give you a curve distribution of ^1 to ^8\n//thanks to Trisomie21\nfloat n4rand_cus( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\t\n\tfloat p = 1. / (1. + iMouse.y * 8. / iResolution.y);\n\tnrnd0 -= .5;\n\tnrnd0 *= 2.;\n\tif(nrnd0<0.)\n\t\tnrnd0 = pow(1.+nrnd0, p)*.5;\n\telse\n\t\tnrnd0 = 1.-pow(nrnd0, p)*.5;\n\treturn nrnd0; \n}\nfloat blugausnoise(vec2 c1) {\n    c1 += 0.07* fract(iiTime);\n    //vec2 c0 = vec2(c1.x- 1.,c1.y);\n    //vec2 c2 = vec2(c1.x+ 1.,c1.y);\n    vec3 cx = c1.x+ vec3(-1,0,1);\n    vec4 f0 = fract(vec4(cx* 9.1031,c1.y* 8.1030));\n    vec4 f1 = fract(vec4(cx* 7.0973,c1.y* 6.0970));\n\tvec4 t0 = vec4(f0.xw,f1.xw);//fract(c0.xyxy* vec4(.1031,.1030,.0973,.0970));\n\tvec4 t1 = vec4(f0.yw,f1.yw);//fract(c1.xyxy* vec4(.1031,.1030,.0973,.0970));\n\tvec4 t2 = vec4(f0.zw,f1.zw);//fract(c2.xyxy* vec4(.1031,.1030,.0973,.0970));\n    vec4 p0 = t0+ dot(t0,t0.wzxy+ 19.19);\n    vec4 p1 = t1+ dot(t1,t1.wzxy+ 19.19);\n    vec4 p2 = t2+ dot(t2,t2.wzxy+ 19.19);\n\tvec4 n0 = fract(p0.zywx* (p0.xxyz+ p0.yzzw));\n\tvec4 n1 = fract(p1.zywx* (p1.xxyz+ p1.yzzw));\n\tvec4 n2 = fract(p2.zywx* (p2.xxyz+ p2.yzzw));\n    return dot(0.5* n1- 0.125* (n0+ n2),vec4(1));\n}\nfloat blugausnoise2(vec2 c1) {\n    float nrand1 = n4rand_ss(c1);\n    float nrand0 = n4rand_ss(vec2(c1.x- 1.,c1.y));\n    float nrand2 = n4rand_ss(vec2(c1.x+ 1.,c1.y));\n    return 2.0* nrand1- 0.5* (nrand0+ nrand2);\n}\n\nfloat histogram( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( truncate(t,NUM_BUCKETS_F), truncate(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)/ITER_PER_BUCKET_F;\n\t\t\n\t\tfloat r;\n        if        ( iter < 2 ) { r = n2rand_tri   ((vec2(uv.x,0.5) + seed)* iResolution.xy );\n\t\t} else if ( iter < 3 ) { r = n2rand       ( vec2(uv.x,0.5) + seed );\n\t\t} else if ( iter < 4 ) { r = n2rand_faster( vec2(uv.x,0.5) + seed );\n\t\t} else if ( iter < 5 ) { r = n4rand_cus   ( vec2(uv.x,0.5) + seed );\n\t\t} else if ( iter < 6 ) { r = n4rand       ( vec2(uv.x,0.5) + seed );\n\t\t} else if ( iter < 7 ) { r = n4rand_ss    ( vec2(uv.x,0.5) + seed );\n\t\t} else if ( iter < 8 ) { r = blugausnoise2((vec2(uv.x,0.5) + seed)* iResolution.xy );\n\t\t} else                 { r = blugausnoise ((vec2(uv.x,0.5) + seed)* iResolution.xy );\n\t\t}\n        bucketval += step(bucket.x,r) * step(r,bucket.y);\n\t}\n\tbucketval /= ITER_PER_BUCKET_F;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y / height, bucketval );\n    float v1 = step( (uv.y-1.0/iResolution.y) / height, bucketval );\n    float v2 = step( (uv.y+1.0/iResolution.y) / height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\nvec4 mainImageTop(vec2 fragCoord) {\n    iiTime = 0.0;\n    vec2 uv = fragCoord.xy/ iResolution.xy;\n    uv.y = fract(uv.y* 2.0)* 0.5;\n\n    const float bands = 4.;\n    const float den = 0.5/8.0;\n    float o = fract(uv.x+ iTime* 0.1);\n    if        (uv.y > 7.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n2rand_tri   (fragCoord));  // Triangular PDF noise\n    } else if (uv.y > 6.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n2rand       ( uv ));\n    } else if (uv.y > 5.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n2rand_faster( uv ));\n    } else if (uv.y > 4.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n4rand_cus   ( uv ));\n    } else if (uv.y > 3.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n4rand       ( uv ));\n    } else if (uv.y > 2.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n4rand_ss    ( uv ));\n    } else if (uv.y > 1.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* blugausnoise2(fragCoord));  // Gaussian blue noise\n    } else                       {o += (1.0/ bands)* (-1.0+ 2.0* blugausnoise (fragCoord));  // Gaussian blue noise\n    }\n    o = floor(o* bands+ 0.5)/ bands; // Quantisation\n    \n    return vec4(o,o,o,1);\n}\nvec4 mainImageBottom(vec2 fragCoord) {\n    iiTime = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tconst float num = 8.0;\n\tfloat o = 0.0;\n\tif        ( uv.x < 1.0 / num ) { o += n2rand_tri   ( fragCoord );\n\t} else if ( uv.x < 2.0 / num ) { o += n2rand       ( uv );\n\t} else if ( uv.x < 3.0 / num ) { o += n2rand_faster( uv );\n\t} else if ( uv.x < 4.0 / num ) { o += n4rand_cus   ( uv );\n\t} else if ( uv.x < 5.0 / num ) { o += n4rand       ( uv );\n\t} else if ( uv.x < 6.0 / num ) { o += n4rand_ss    ( uv );\n\t} else if ( uv.x < 7.0 / num ) { o += blugausnoise2( fragCoord );\n\t} else                         { o += blugausnoise ( fragCoord );\n\t}\n    int idx = int(1.0+ uv.x* num);\n    vec2 uvrange = vec2( float(idx- 1)/ num, float(idx)/ num );\n\n    //display histogram\n    if ( uv.y < 1.0 / 4.0 )\n\t\to = 0.125 + histogram( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );\n    \n\t//display lines\n\tif ( abs(mod(uv.x- 0.5 / num,1.0 / num) - 0.5 / num) < 0.002 ) o = 0.0;\n\tif ( abs(mod(uv.y- 0.5 / 4.0,1.0 / 4.0) - 0.5 / 4.0) < 0.002 ) o = 0.0;\n\n\t\n\treturn vec4( vec3(o), 1.0 );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = fragCoord.y* 2.0 < iResolution.y ? mainImageBottom(fragCoord) : mainImageTop(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljyRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1454, 1808, 1829, 1829, 1961], [1963, 2017, 2040, 2040, 2108], [2109, 2153, 2195, 2195, 2239], [2240, 2270, 2306, 2306, 2330], [2332, 2332, 2356, 2356, 2437], [2438, 2438, 2462, 2462, 2593], [2595, 2595, 2626, 2626, 3116], [3117, 3117, 3143, 3143, 3215], [3216, 3216, 3240, 3240, 3413], [3414, 3414, 3438, 3438, 3654], [3655, 3655, 3683, 3683, 4070], [4072, 4119, 4146, 4146, 4328], [4329, 4404, 4432, 4432, 4680], [4681, 4681, 4710, 4710, 5506], [5507, 5507, 5537, 5537, 5722], [5724, 5724, 5804, 5804, 7034], [7035, 7035, 7070, 7070, 8141], [8142, 8142, 8180, 8180, 9207], [9208, 9208, 9265, 9265, 9372]]}
{"id": "XlscDl", "name": "Slipping", "author": "Gaeel", "description": "Was putting some stuff together for a project, wanted to make sure shaders worked so I wrote one and got carried away...\n\nThis is my first raymarcher, followed a tute and modified it with some trippier stuff", "tags": ["raymarching", "first"], "likes": 2, "viewed": 119, "published": "Public", "date": "1506978336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time(float t){\n    float tt = floor(t)+smoothstep(0.0,1.0,fract(t));\n    //t=floor(tt)+smoothstep(0.0,1.0,fract(tt));\n    return tt;\n}\n\n\nfloat map(vec3 p){\n    p+=0.25;\n    vec3 q = fract(p+0.5) * 2.0 - 1.0;\n    vec3 q2 = fract(p) * 2.0 - 1.0;\n\tvec3 r = floor(p);\n    vec3 s = mod(r, 1.0);\n    \n\treturn min(\n        length(q2)-0.5\n        ,\n        min(length(q.xy), min(length(q.xz), length(q.yz))) - 0.02\n    );    \n}\n\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    \n    for (int i=0;i<int(pow(2.0,3.5+sin(iTime/4.0)*2.0)); ++i){\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    float off = sin(uv.x+time(iTime/2.0))*sin(uv.y-iTime/2.0);\n    vec3 r = normalize(vec3(uv, 2.0+off));\n    \n    \n    float the = time(iTime/3.0);\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    the = time(iTime/4.0);\n    r.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    the = time(iTime/6.0);\n    r.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n                  \n    vec3 o = vec3(time(iTime/3.0), 0.0, time(iTime));\n                  \n\tfloat t = trace(o,r);\n                  \n\tfloat fog = 1.0 / (1.0 + t * t * 0.1);\n    fog = pow(fog,4.5-sin(time(iTime/4.0))*4.0);\n   \tvec3 fc = vec3(fog); \n   \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlscDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 140], [143, 143, 161, 161, 425], [428, 428, 456, 456, 643], [645, 645, 702, 702, 1484]]}
{"id": "XlSczc", "name": "Distance weighing colors", "author": "grinist", "description": "Colors weighed with normalized inverse distance to each individual color position. Mouse x controls distance bias, mouse y controls distance power. More colorful than the average shader.", "tags": ["colors", "filter", "weighing"], "likes": 8, "viewed": 918, "published": "Public API", "date": "1509461825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define POINTS 32 // try between 2 and 256, gets slow fast\n#define PI 3.1415926536\n#define TAU (2.0 * PI)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float bias = 0.0001;\n    float power = 2.0;\n    // mouse x controls bias, mouse y controls power\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n    bias = iMouse.z <= 0.0 ? bias : pow(10.0, (-0.5 + mouse.x) * 10.0);\n\tpower = iMouse.z <= 0.0 ? power : 0.5 + mouse.y * 9.5;\n    \n    float cN = 0.0;\n    // array used to store contributions in first loop\n    float contribution[POINTS];\n    \n    for (int i = 0; i < POINTS; i++)\n    {\n        float f = float(i) / float(POINTS) * TAU;\n\t    vec2 pos = 0.5 + 0.35 * vec2(cos(iTime * 0.25 + f), sin(iTime * 0.8 + f * 2.0));\n\t\tpos = uv - pos;\n        float dist = length(pos);\n        // calculate contribution\n    \tfloat c = 1.0 / (bias + pow(dist, power));\n        contribution[i] = c;\n        // sum total contribution\n        cN += c;\n    }\n    \n    // normalize contributions and weigh colors\n    vec3 col = vec3(0, 0, 0);\n    cN = 1.0 / cN;\n    for (int i = 0; i < POINTS; i++)\n    {\n        float f = float(i) / float(POINTS) * TAU + iTime * 0.1;\n\t    vec3 pcol = 0.5 + 0.5 * cos(vec3(f * 2.0, f, f * 4.0));\n        col += contribution[i] * cN * pcol;\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSczc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 164, 164, 1349]]}
{"id": "XlSyRD", "name": "omni-directional v-scat", "author": "ollj", "description": "mouse does things\n\nfork of \nhttps://www.shadertoy.com/view/XsfGR7\n\nnot as amazing but useful in its simplicity. see inscatter()", "tags": ["light", "volumetric", "fog", "godrays", "simplex", "scattering", "crepuscularity"], "likes": 3, "viewed": 639, "published": "Public API", "date": "1507575514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self  : https://www.shadertoy.com/view/XlSyRD\n//parent: https://www.shadertoy.com/view/XsfGR7\n/* \n\nreference:\nhttps://www.shadertoy.com/view/Mdl3Rr\n*/\n\n#define LIGHT_ANIMATION\n//#define LOW_QUALITY\t\t// uncomment this if this shader runs too slow on your PC\n//#define ULTRA_QUALITY \t// uncomment this if you have a really fast GPU :-)\n#define SMOKE\t\t\t\t// comment this if you think the smoke effect is too annoying\n\n#define gAnimTime iTime*.5\n\nfloat h11(float n){return fract(sin(n)*43758.5453);}\nfloat simplex(in vec3 x){\n;vec3 p=floor(x),f=fract(x)\n;f=f*f*(3.-2.*f)\n;float n=p.x+p.y*57.+113.*p.z\n;return mix(mix(mix(h11(n),h11(n+1.),f.x),\n                mix(h11(n+ 57.), h11(n+ 58.),f.x),f.y),\n            mix(mix(h11(n+113.), h11(n+114.),f.x),\n                mix(h11(n+170.), h11(n+171.),f.x),f.y),f.z);}\n\nfloat udRoundBox(vec3 p,vec3 b){return length(max(abs(p)-b,.0));}\n// n or p must be normalized\nfloat sdPlane(vec3 p,vec4 n){return dot(p,n.xyz)+n.w;}\n\nfloat scene( in vec3 p){\n;vec4 plane=vec4(0,1,0,0); \n;vec4 boxd1=vec4(.5, 4.,.5,.25); \n;vec4 boxp1=vec4(0,4.,0,0);\n;boxd1.xyz -= boxd1.w;\t\n;vec4 boxd2=vec4(3,.5,.5,.25 );\n;vec4 boxp2=vec4(0,4.,0,0 );\n;boxd2.xyz -= boxd2.w\t\n;float d=99999.\n;d=min(d,udRoundBox(p-boxp1.xyz,boxd1.xyz)-boxd1.w)\n;d=min(d,udRoundBox(p-boxp2.xyz,boxd2.xyz)-boxd2.w)\n;d=min(d,sdPlane(p,plane))\n;return d;}\n\nvec3 sceneNormal(vec3 p){vec2 e= vec2(.001,0)\n;return normalize(vec3(scene(p+e.xyy)-scene(p-e.xyy )\n,scene(p+e.yxy)-scene(p-e.yxy),scene(p+e.yyx)-scene(p-e.yyx )));}\n\n#define iterRm 16.\n\n//RayOrigin,Rayditection,iterations,HirPosition,normal\nvec3 raymarch(vec3 u,vec3 t, float j,out vec3 h, out vec3 n){\n;const float e=.0001;h=u\n;for (float i=.0;i<j;i++){float d=scene(u)\n ;if (d<e){h=u;return sceneNormal(u);}u+=d*t;}return n;}\n\n#ifdef LOW_QUALITY\n #define  INSCATTER_STEPS 24.\n#else\n #ifdef ULTRA_QUALITY\n  #define INSCATTER_STEPS 64.\n #else\n  #define INSCATTER_STEPS 48.\n #endif\n#endif\n\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,.0,1.)\n\n/*\nfloat raySphereIntersect( in vec3 u, in vec3 t, in vec4 sph )\n{u=u-sph.xyz; // looks like we are going place sphere from an offset from ray origin, which is = camera\n;float b=2.*dot(u,t),c=dd(u)-sph.w*sph.w,h=b*b-4.*c\n;return mix(-1e4,-b-sqrt(h)*.5,sign(h));}\n*/\n\n//this is the core function for crepusularity rays\n//and it does 24 df iterations without a break condition\n//[u]=cameraPosition\n//[t]=CameraRayDirection\n//[l]=LichtPosition.xyz LicgtIntensity.z (10 is fine)\n//[s]=noise feed, scales noise, vec3(fragCoord.xy,iTime) is fine\n//[d]=screentracedepth; scale factor, (12. is fine)\nvec3 inscatter(vec3 u,vec3 t, in vec4 l, in vec3 s, in float d ){\n;vec3 tt = normalize( t );\n//below line seems absurd or sub par efficient, is removed:\n//;if(raySphereIntersect(u,tt,light)< -9999.)return vec3(.0);\n;float a=.0,iss =1./INSCATTER_STEPS;vec3 h,n=vec3(0),p=u,dp=tt*iss*d\n;p+=dp*simplex(s)*1.5;for(float i=0.;i<INSCATTER_STEPS;++i){\n ;p+=dp;vec3 t=l.xyz-p;float lt=length(t),b=.0;t/=8.\n ;if(raymarch(u,t,16.,h,n)==vec3(0)){\n  ;float falloff=1.-pow(sat(lt/l.w),.125);b+=falloff;\t\n  #ifdef SMOKE\n  ;b+=falloff*simplex(1.25*(p+vec3(gAnimTime,0,0)))*0.375\n  #endif\n;}a+=b;}return vec3(a*iss*8.);}\n\n//u,t are ray from lightsource to surface, a,b are minmax,k is softneess\nfloat softshadow(vec3 u,vec3 t,float a,float b,float k){\n;float d=a;a=1.0;for(int i=0;i<128;++i ){\n ;float h=scene(u+t*t);if(h<.001 )return 0.\n ;a=min(a,k*h/d);t+=h;if(d>b)break;}return a;}\n\nvoid mainImage(out vec4 o, in vec2 fragCoord){\n;vec2 ndcXY =  + 2.0 * fragCoord.xy / iResolution.xy-1.0;\n;vec2 m =iMouse.xy*2./ iResolution.xy-1.0;\n;float aspectRatio = iResolution.x / iResolution.y;\n;vec3 u=vec3(0,3,5);\n;vec3 t=vec3(ndcXY * vec2( aspectRatio, 1.0 ), -1.0 );\n;vec4 lightWs=vec4( 0,4.5,-4,10);\n;if(iMouse.z<=0.)lightWs.xy+=vec2(sin(gAnimTime),cos(gAnimTime))*2.;\nelse lightWs.xy=m*9.;\n;vec3 p;//becomes intersection point.\n;vec3 n=vec3(0)//becomes surface notmal to test for intersection\n;if(raymarch(u,t, 128., p,n )!=vec3(0)){\n //f=... simple fog works becaue the light emmitter normal is==.z\n //a more general case must calculte some intersection here?\n ;float f=sat((p.z-t.z+20.)*.2);\n ;o.rgb=vec3(.125*f*f);\n}\n// apply scattering of the\n;o.rgb+=inscatter( u,t, lightWs, vec3(fragCoord.xy,iTime),12.);\n;o.r=smoothstep( 0.,1.,o.r )\n;o.g=smoothstep( 0.,1.,o.g-1.)\n;o.b=smoothstep(-1.,1.,o.b-1.)\n;o.a=1.;\n;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSyRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 444, 463, 463, 496], [497, 497, 522, 522, 809], [811, 811, 843, 843, 876], [877, 906, 935, 935, 960], [962, 962, 986, 986, 1343], [1345, 1345, 1370, 1370, 1510], [1532, 1587, 1648, 1648, 1773], [2256, 2581, 2646, 2646, 3185], [3187, 3260, 3316, 3316, 3449], [3451, 3451, 3497, 3497, 4375]]}
{"id": "XlSyRh", "name": "Sin Circles", "author": "pedrogarlaschi", "description": "Trying to learn Shaders with some simple playgrounds", "tags": ["spheres"], "likes": 2, "viewed": 96, "published": "Public", "date": "1507286038", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Circle(U,p,r,b) smoothstep(r , r - (b) , length(U - (p)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2 R = iResolution.xy,\n         U = u / R.y;\n \n    float  n = 20.,\n           T = abs(sin(iTime)) * length(U - abs(sin(iTime) / 2.)),\n           t1 = 0.,\n           t2 = 0.,\n    \t   b = 2./iResolution.y;\n   \n    U -= ( floor( U * n ) + .5 ) / n;\n    \n    float c = Circle( U, t1, .015 + (.01 * T) , b) -  Circle( U, t1, .01 * (1. - T) , b);\n    \n    O =  vec4(c);\n}\n\n/*float Circle(vec2 uv , vec2 p , float r , float b)\n{\n    float d = length(uv - p);\n    float c = smoothstep(r , r - b , d);\n    \n    return c;\n}*/\n\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    float c = .0;\n    \n    vec2 p;\n    \n    int lin = 20;\n    int col = 20;\n    \n    float xd = 1.0 / float(lin); \n    xd *= iResolution.x / iResolution.y;\n    \n    float yd = 1.0 / float(lin); \n    \n    float t1 = abs(sin(iTime)) * (1.0 - length((fragCoord.xy / iResolution.xy) - 0.5));\n    \n    \n    for(int x = 0;x < col;x++)\n    {\n        for(int y = 0;y < lin;y++)\n        {\n\n           p.x = (xd / 2.0) + (float(x) * xd);\n           p.y = (yd / 2.0) + (float(y) * yd);\n           \n           c += Circle(uv , p,0.01 + (0.02 * t1),0.005);\n        }\n        \n    }\n    \n    float t2 = 1.0 - abs(sin(iTime));\n    \n     for(int x = 0;x < col;x++)\n    {\n        for(int y = 0;y < lin;y++)\n        {\n\n           p.x = (xd / 2.0) + (float(x) * xd);\n           p.y = (yd / 2.0) + (float(y) * yd);\n           \n           c -= Circle(uv , p,0.01 +(0.01 * t2),0.01);\n        }    \n    }\n    \n    fragColor = vec4(vec3(c) , 1);\n}*/\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSyRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 105, 105, 474]]}
{"id": "XlSyRz", "name": "tried using smoothmin", "author": "Torumu106", "description": "Same as title.", "tags": ["raymarch", "smoothmin"], "likes": 0, "viewed": 72, "published": "Public", "date": "1507101634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\nfloat PI = 3.1415926535;\nvec3 col = vec3(1.0, 1.0, 1.0);\nint stop = 0;\nvec3 stoppos = vec3(0.0);\nfloat map(vec3 p){\n    float d = length(max(abs(p) - vec3(1.0),0.0));\n    vec3 p1 = p;\n    float the = iTime / 2.1;\n    p1.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    d = smin(d, length(p1 - vec3(1.2,1.2,1.2)) - 0.7, 3.0);\n    d = smin(d, length(p1 - vec3(-1.2,1.2,1.2)) - 0.7, 3.0);\n    d = smin(d, length(p1 - vec3(1.2,1.2,-1.2)) - 0.7, 3.0);\n    d = smin(d, length(p1 - vec3(-1.2,1.2,-1.2)) - 0.7, 3.0);\n    if(d < 0.001) col= vec3(0.0, 1.0, 1.0);\n    d = min(d, dot(p,vec3(0.0, 1.0, 0.0)) + 1.0);\n    return d;\n}\nvec3 grad(vec3 p) {\n    vec2 d = vec2(0.0, 0.001);\n\tfloat dFx = map(p + d.yxx) - map(p - d.yxx);\n\tfloat dFy = map(p + d.xyx) - map(p - d.xyx);\n\tfloat dFz = map(p + d.xxy) - map(p - d.xxy);\n\treturn normalize(vec3(dFx, dFy, dFz));\n}\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p;\n    for(int i = 0; i < 256; ++i){\n    \tp = o + r * t;\n        float d = map(p);\n        if(d < 0.001){\n            stop = 1;\n        \tbreak;\n        }\n        t += d * 0.9;\n    }\n    stoppos = p;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv - vec2(0.0, PI / 3.0), 1.0));\n    \n    float the = iTime;\n    vec3 o = vec3(0.0,10.0, -10.0);\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    o.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    float t = trace(o, r);\n    float light = 0.0;\n    if(stop == 1){\n    \tvec3 nor = grad(stoppos);\n        light = 0.6 * max(dot(nor, vec3(1.0,0.8,0.4)), 0.0) + 0.3;\n        stop = 0;\n        trace(stoppos + nor * 0.002, normalize(vec3(1.0,0.7,0.4)));\n        if(stop == 1) light = 0.1;\n    }\n    \n    vec3 fc = vec3(light) * col;\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 112], [210, 210, 228, 228, 739], [740, 740, 759, 759, 970], [971, 971, 999, 999, 1239], [1240, 1240, 1297, 1297, 2019]]}
{"id": "XlsyWB", "name": "Glow City", "author": "mhnewman", "description": "Skyline tour over Glow City", "tags": ["procedural", "3d", "grid", "marching", "fog", "glow", "night", "city", "skyline"], "likes": 99, "viewed": 2264, "published": "Public", "date": "1506873848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Grid marching from iq's Grid of Cylinders\n// https://www.shadertoy.com/view/4dSGW1\n\nconst float streetDistance = 0.6;\nconst vec3 streetColor = vec3(4.0, 8.0, 10.0);\n\nconst float fogDensity = 0.5;\nconst float fogDistance = 4.0;\nconst vec3 fogColor = vec3(0.34, 0.37, 0.4);\n\nconst float windowSize = 0.1;\nconst float windowDivergence = 0.2;\nconst vec3 windowColor = vec3(0.1, 0.2, 0.5);\n\nconst float beaconProb = 0.0003;\nconst float beaconFreq = 0.6;\nconst vec3 beaconColor = vec3(1.5, 0.2, 0.0);\n\n\nconst float tau = 6.283185;\n\nfloat hash1(vec2 p2) {\n    p2 = fract(p2 * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec2 p2, float p) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(vec2 p2) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p2.x));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 hash2(vec2 p2, float p) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash3(vec2 p2) {\n    vec3 p3 = fract(vec3(p2.xyx) * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nfloat noise1(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash1(i + vec2(0.0, 0.0)), \n                   hash1(i + vec2(1.0, 0.0)), u.x),\n               mix(hash1(i + vec2(0.0, 1.0)), \n                   hash1(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec4 castRay(vec3 eye, vec3 ray) {\n    vec2 block = floor(eye.xy);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 side = 0.5 + 0.5 * rs;\n    vec2 ris = ri.xy * rs.xy;\n    vec2 dis = (block - eye.xy + 0.5 + rs.xy * 0.5) * ri.xy;\n    \n    float beacon = 0.0;\n    \n    for (int i = 0; i < 200; ++i) {\n        vec2 lo0 = vec2(block + 0.01);\n        vec2 loX = vec2(0.3, 0.3);\n        vec2 hi0 = vec2(block + 0.69);\n        vec2 hiX = vec2(0.3, 0.3);\n        float height = (0.5 + hash1(block)) * (2.0 + 4.0 * pow(noise1(0.1 * block), 2.5));\n        \n        float dist = 500.0;\n        float face = 0.0;\n        for (int j = 0; j < 3; ++j) {\n            float top = height * (1.0 - 0.1 * float(j));\n            vec3 lo = vec3(lo0 + loX * hash2(block, float(j)), 0.0);\n            vec3 hi = vec3(hi0 + hiX * hash2(block, float(j) + 0.5), top);\n\n            vec3 wall = mix(hi, lo, side);\n            vec3 t = (wall - eye) * ri;\n\n            vec3 dim = step(t.zxy, t) * step(t.yzx, t);            \n            float maxT = dot(dim, t);\n            float maxFace = 1.0 - dim.z;\n            \n            vec3 p = eye + maxT * ray;\n            dim += step(lo, p) * step(p, hi);\n            if (dim.x * dim.y * dim.z > 0.5 && maxT < dist) {\n                dist = maxT;\n                face = maxFace;\n            }\n        }\n        \n        float prob = beaconProb * pow(height, 3.0);\n        vec2 h = hash2(block);\n        if (h.x < prob) {\n            vec3 center = vec3(block + 0.5, height + 0.2);\n            float t = dot(center - eye, ray);\n            if (t < dist) {\n                vec3 p = eye + t * ray;\n                float fog = (exp(-p.z / fogDistance) - exp(-eye.z / fogDistance)) / ray.z;\n                fog = exp(fogDensity * fog);\n\n                t = distance(center, p);\n                fog *= smoothstep(1.0, 0.5, cos(tau * (beaconFreq * iTime + h.y)));\n                beacon += fog * pow(clamp(1.0 - 2.0 * t, 0.0, 1.0), 4.0);\n            }\n        }\n        \n        if (dist < 400.0) {\n            return vec4(dist, beacon, face, 1.0);\n        }\n        \n        vec2 dim = step(dis.xy, dis.yx); \n        dis += dim * ris;\n        block += dim * rs.xy;\n    }\n    \n    if (ray.z < 0.0) {\n        return vec4(-eye.z * ri.z, beacon, 0.0, 1.0);\n    }\n\n    return vec4(0.0, beacon, 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 m = vec2(0.03 * iTime, 0.8);\n    if (iMouse.z > 0.0)\n        m = iMouse.xy / iResolution.xy;\n    m *= tau * vec2(1.0, 0.25);\n    \n    vec3 center = vec3(6.0 * iTime, 0.5, 3.0);\n    float dist = 20.0;\n    vec3 eye = center + vec3(dist * sin(m.x) * sin(m.y), dist * cos(m.x) * sin(m.y), dist * cos(m.y));\n    float zoom = 3.0;\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    zoom *= iResolution.y;\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward);\n    \n    vec4 res = castRay(eye, ray);\n    vec3 p = eye + res.x * ray;\n\n    vec2 block = floor(p.xy);\n    vec3 window = floor(p / windowSize);\n    float x = hash1(block, window.x);\n    float y = hash1(block, window.y);\n    float z = hash1(block, window.z);\n    vec3 color = windowColor + windowDivergence * (hash3(block) - 0.5);\n    color *= smoothstep(0.1, 0.9, fract(2.5 * (x * y * z)));\n\n    vec3 streetLevel = streetColor * exp(-p.z / streetDistance);\n    color += streetLevel;\n    color = clamp(mix(0.25 * streetLevel, color, res.z), 0.0, 1.0);\n\n    float fog = (exp(-p.z / fogDistance) - exp(-eye.z / fogDistance)) / ray.z;\n    fog = exp(fogDensity * fog);\n    color = mix(fogColor, color, fog);\n    \n    color = mix(fogColor, color, res.w);\n    color += res.y * beaconColor;\n    color += pow(res.y, 2.0);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsyWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 529, 551, 551, 691], [693, 693, 724, 724, 870], [872, 872, 893, 893, 1045], [1047, 1047, 1077, 1077, 1226], [1228, 1228, 1249, 1249, 1398], [1400, 1400, 1422, 1422, 1712], [1714, 1714, 1748, 1748, 4033], [4035, 4035, 4090, 4090, 5568]]}
{"id": "XlXcDl", "name": "Outerspace 1", "author": "lsdlive", "description": "Another visual experiment.", "tags": ["raymarching"], "likes": 5, "viewed": 289, "published": "Public", "date": "1506872058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define ENABLE_SCANLINE 0\n\nmat2 r2d(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 amod(vec2 p, float m) {\n\tfloat a = mod(atan(p.x, p.y), m) - m * .5;\n\treturn vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat sc(vec3 p) {\n\tp = abs(p);\n\treturn min(min(max(p.x, p.y), max(p.y, p.z)), max(p.z, p.x));\n}\n\nfloat sc2(vec3 p) {\n\tp = abs(p);\n\tvec3 g = max(p.xyz, p.yzx);\n\treturn min(g.x, g.z);\n\n}\n\nconst float pi = 3.14159;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(0., 0., -iTime), p;\n\tp = ro;\n\tvec3 rd = normalize(vec3(uv, -1));\n\n\t//p.z = -iTime* 0.5;\n\t//p.x = cos(iTime*.2);\n\n\tp.z = -iTime;\n\tp.x = cos(iTime);\n\n\tfloat ti = 64., e = 1.;\n\tfor (float i = 64.; i > 0.; i--) {\n\n\t\tti = i;\n\n\t\tif (.1 > e*i) {\n\t\t\tbreak;\n\t\t}\n\n\n\n\t\tvec3 q = p;\n\n\t\t//q.xy *= r2d(pi / 2. + .2*cos(iTime*.8));\n\t\tq.xy *= r2d(iTime*.4);\n\n\n\t\tq = mod(q, 4.) - 2.;\n\n\n\t\tvec3 newp = q;\n\t\tnewp.yz = amod(newp.yz, pi / 16.);\n\n\t\tnewp.xz *= r2d(pi / (7. + 5.*cos(iTime)));\n\n\n\t\tq.zy = amod(q.zy, pi / 2.);\n\t\te = min(sc2(q) - .5, sc(newp) - .4);\n\n\t\tp += rd * e;\n\t}\n\n\tvec3 c = vec3(.8, .7, .7);\n\t//c = vec3(1.);\n\n\tc = mix(c, 1. - sqrt(abs(p + cos(iTime))) * ti / 64., ti / 64.);\n\n    if(ENABLE_SCANLINE == 1)\n\t\tc = c + cos(1e3*uv.y) * .2 * tan(iTime*.5);\n\t\n    fragColor.xyz = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXcDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 47, 47, 114], [116, 116, 144, 144, 232], [234, 234, 252, 252, 330], [332, 332, 351, 351, 419], [448, 448, 503, 503, 1378]]}
{"id": "Xt2cRR", "name": "Pinwheel_000", "author": "timeiskey", "description": "pixels whos angle to a point are within some range are black", "tags": ["beginner"], "likes": 1, "viewed": 86, "published": "Public", "date": "1507174728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pixelP = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3( 1.0, 1.0, 1.0 );\n    \n    vec2 point = iMouse.xy / iResolution.xy;\n    vec2 dist2Point = pixelP - point;\n    float angle2Point = atan( dist2Point.y, dist2Point.x );\n    float radius = 0.1 + 0.4*tan( angle2Point * iTime * iTime * iTime );\n    \n    color *= smoothstep( radius, radius + 0.01, length(dist2Point ) );\n    \n\tfragColor = vec4( color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2cRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 484]]}
{"id": "Xt2yzR", "name": "Interactive Marble Exploration", "author": "colonel_hilbert", "description": "I picked 12 on-off parameters, and divided the screen into 2^12 regions. Click and drag to select which one generates the Marble.", "tags": ["3d", "interactive", "volumetric"], "likes": 8, "viewed": 429, "published": "Public", "date": "1507191004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015 - https://www.shadertoy.com/view/MtX3Ws\n// Modified by C. Hinrichs 2017\n\n\nfloat zoom=0.28;\n\n\n//vec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph, bool has0 )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 )\n        if(has0) return vec2(-4.0);\n        else     return vec2(-.50);\n        \n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map(in vec3 p, bool has1, bool has2, bool has3, bool has4) {\n\tfloat res = 0.;\n\t\n    vec3 pw = vec3(sin((iTime + 5.)/10.)*0.35 + 1.);\n    \n    vec3 c = p;\n\tfor (int i = 0; i < 5; ++i) {\n        p =.7*pow(abs(p), pw)/dot(p,p) -.7;\n        if(has1) p.yz = csqr(p.yz);\n        if(has2) p    = p.zxy;\n        \n        if(has3) res += exp(-19. *     (abs(dot(p,c))));\n        else     res += exp(-19. * sqrt(abs(dot(p,c))));\n        \n\t}\n    \n    if(!has4) return    (res/2.); \n    else      return log(res/2.);\n}\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax, vec2 m )\n{\n    float t = tminmax.x;\n    float dt = .02;\n    // dt = .2 - .195*cos(iTime*.05);//animated\n    \n    vec3 col= vec3(0.);\n    float c = 0.;\n    float sc = 0.14;\n    \n    //moving these computations outside of the main loop\n    bool has1  = mod(m.x *  .5, 1.) > 0.5;\n    bool has2  = mod(m.x      , 1.) > 0.5;\n    bool has3  = mod(m.x *  2., 1.) > 0.5;\n    bool has4  = mod(m.x *  4., 1.) > 0.5;\n    bool has5  = mod(m.x *  8., 1.) > 0.5;\n   \n    \n    bool has6  = mod(m.y * .25, 1.) > 0.5;\n    bool has7  = mod(m.y *  .5, 1.) > 0.5;\n    bool has8  = mod(m.y      , 1.) > 0.5;\n    bool has9  = mod(m.y *  2., 1.) > 0.5;\n    bool has10 = mod(m.y *  4., 1.) > 0.5;\n    bool has11 = mod(m.y *  8., 1.) > 0.5;\n    \n    \n    for( int i=0; i<68; i++ )\n\t{\n        if(    has6) \n            if(has7) t+=dt*exp(-11.*c);\n            else     t+=dt*exp(-1.8*c);\n        else\n            if(has7) t+=dt*exp(-3.6*c);\n            else     t+=dt*exp(-7.8*c);\n        \n        vec3 pos = ro+t*rd;\n        \n        c = map(pos, has1, has2, has3, has4);           \n        if(t>tminmax.y && tminmax.x != tminmax.y && has4 ) break; // c /= 1.25;\n        \n        //There are some interactions between flags 3&4 and 6&7\n        if(has3){\n            c=c*c;\n            if(has6 || has7) sc = 0.005;\n            if(has4) sc = sc/5.;\n        }\n        \n        if(    !has9)\n            if(!has10) col +=  sc*vec3(c*c*c, c*c, c);//blue\n            else       col +=  sc*vec3(c*c, c, c*c*c);//green\n        else\n        \tif(!has10) col +=  sc*vec3(c, c*c, c*c*c);//red\n            else       col +=  sc*vec3(c*c, c*c, c*c);//white\n    }\n    \n    if(! has11) col *= log(1.25 + 2.*abs(rd.yxz));\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy*3.14;\n    else               m = vec2(mod(iTime/83., iTime/199.), 0.89);\n    m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(4.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    \n    \n    //m=p;\n    vec2 tmm = iSphere( ro, rd, vec4(.8,0.,.45,1.), mod(m.x * .25, 1.) <= 0.5 );\n\n\t// raymarch\n    vec3 col = raymarch(ro,rd,tmm, m);\n    //if (tmm.x<0.)col = texture(iChannel0, rd).rgb;\n    //else {\n    //    vec3 nor=(ro+tmm.x*rd)/2.;\n    //    nor = reflect(rd, nor);        \n    //    float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\n    //    col += texture(iChannel0, nor).rgb * fre;\n    //}\n\t\n\t// shade\n    \n    if(mod(m.x *  8., 1.) <= 0.5) col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n     \n    fragColor = vec4( col, 1.0 );\n}\n\n\n/*\n\tParameters:\n\tl. 21 return -2. or -1.\t\t0x001\n\tl. 33 do or don't do\t\t0x002\n\tl. 34 do or don't do\t\t0x004\n\tl. 35 do sqrt or not\t\t0x008\n\tl. 38 log or not\t\t\t0x010\n\tl. 45 or l.46\t\t\t\t0x020\n\tl. 55 do or don't do\t\t0x040\n\n\tl. 51 12.0, 7.8, 3.6, 1.8 \t0x080, 0x100\n\tl. 57-59 R,G,B or white\t\t0x200, 0x400\n\tl. 61 Do chroma or not\t\t0x800\n\n\t12 bits - 128x32 for every combination\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2yzR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[212, 300, 322, 322, 371], [374, 374, 393, 393, 440], [443, 443, 516, 516, 764], [766, 766, 832, 832, 1278], [1281, 1281, 1341, 1341, 3027], [3030, 3030, 3087, 3087, 4273]]}
{"id": "XtBcDD", "name": "color phase experiment", "author": "tourgen", "description": "working out details with color and mod() function", "tags": ["2d"], "likes": 2, "viewed": 69, "published": "Public", "date": "1508512523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float phase = 8.0 * M_PI + 4.0 * sin( iTime * 9.0  + 7.0 * uv.x + 3.0 * uv.y );\n    uv = abs( uv + vec2( -0.5, -0.5 ) );\n    float p = cos( phase * 1.0 * uv.x * 1.0 * M_PI );\n    float q = cos( phase * 1.0 * uv.y * 1.0 * M_PI );\n    float color_phase = 1.8 * sin( phase * 0.1 ) * sin( phase * 0.1 );//mod( phase, 2.2 );\n    float r_color = max( p, q ) * color_phase * 0.7;\n    float g_color =  max( p, q ) * color_phase * 0.7;//step( 0.5, p );\n    float b_color =  color_phase;\n    \n    \n    fragColor = vec4( r_color, g_color, b_color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBcDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 676]]}
{"id": "XtBcRV", "name": "Quads Rotate", "author": "aiekick", "description": "Quad Rotate", "tags": ["rotate", "quad"], "likes": 3, "viewed": 462, "published": "Public API", "date": "1509140297", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on the shader Ellipse - Distance of iq : https://www.shadertoy.com/view/4sS3zz\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y*3.;\n\n    float t = sin(iTime*0.2)*.5+.5;\n\t\n    float n = 8.;\n    float an = 3.14159 / n;\n\tfloat a = atan( p.y, p.x );\n\ta = mod( a, an * 2.0 ) - an;\n\tp = vec2( cos( a ), sin( a ) ) * length(p);\n\t\n    p.x -= 2.;\n    \n    float rot = iTime;\n    \n    p *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n    \n    float d = 0.;\n    \n    //d = length(p)*.3; \t\t\t\t\t// circle\n    d = max(abs(p.x),abs(p.y));\t\t\t\t// quad\n   \t//d = max(abs(p.y*.87)-p.x*.5,+p.x);\t// triangle\n    \n    //d = abs(d-.5); \t\t\t\t\t\t// add thickness\n    \n    d -= 0.5;\t\t\t\t\t\t\t\t// radius\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*abs(d)+iTime*10.);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBcRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 146, 146, 980]]}
{"id": "XtBcWh", "name": "Blur Circle", "author": "smkgames", "description": "Simple Blur :)", "tags": ["2d", "blur", "cricle"], "likes": 5, "viewed": 804, "published": "Public API", "date": "1508304516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.y;\n  uv = uv*2.0-1.0 - vec2(0.7,0.0);\n  float Length = length(uv);\n  Length = 1.0-smoothstep(Length,0.0,0.4) / abs(sin(iTime));\n  vec3 col = vec3(abs(sin(iTime)),abs(sin(iTime)),1.0);\n  fragColor = vec4(col*Length,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBcWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 318]]}
{"id": "XtByRV", "name": "Simple Disco Lights", "author": "klk", "description": "Disco Lights", "tags": ["discolights"], "likes": 8, "viewed": 757, "published": "Public API", "date": "1509135204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t=iTime*30.0;\n    float l=uv.x;\n    vec3 col=vec3(\n        sin(t*0.51+l*1.5+93.0)+sin(t*0.12+l*3.2+35.0),\n        sin(t*0.37-l*1.7+12.1)+sin(t*0.17+l*1.9-85.0),\n        sin(t*0.45+l*2.1+15.0)+sin(t*0.22+l*2.5+95.0)\n    )*0.2+0.5;\n\tfragColor = vec4(col*uv.y*(1.0-uv.y)*4.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtByRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 389]]}
{"id": "XtByRw", "name": "Cuentame kitchen tile", "author": "josemorval", "description": "A shader inspired on a kitchen tile I saw", "tags": ["2d", "reflection", "simple", "sun", "flower", "animation", "cuentame", "kitchen"], "likes": 2, "viewed": 462, "published": "Public API", "date": "1507802796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 orip = uv-0.5;\n   \torip.y += 0.15;\n    orip.x*=iResolution.x/iResolution.y;\n    orip*=5.;\n\n    vec2 p = orip;\n    p.y = mix(-2.5*orip.y,orip.y,step(0.,orip.y));\n    p.x += 0.2*sin(21.*orip.y*orip.y+13.*orip.x*orip.x+time)*sin(41.*orip.x*orip.y+12.*orip.x+time)*step(0.,-orip.y)*smoothstep(0.,1.,-orip.y);\n\n    vec3 col = vec3(255.,253.,208.)/255.;\n\t\n    float aa = 5./iResolution.y;\n    \n    float s = smoothstep(-aa,aa,p.y-pow(abs(p.x),3.5+2.5*cos(time)*cos(time)));\n    s = min(s, smoothstep(-aa,aa,pow(abs(p.x)+0.05,0.2)-p.y+0.5));\n    s = min(s, smoothstep(-aa,aa,sin(-30.*abs(p.x)+20.*p.y+time)));\n    s *= 0.1+0.9*smoothstep(-.5,0.2,orip.y);\n    col=mix(col,vec3(0.,100.,0.)/255.,s);\n\n    s = smoothstep(-aa,aa,p.y-0.55-pow(abs(p.x)+0.05,0.2));\n    s = min(s, smoothstep(-aa,aa,0.4-length(p-vec2(0.,1.4+0.1*sin(time)*sin(time)))));\n    s *= 0.1+0.9*smoothstep(-1.,-0.,orip.y);\n    col=mix(col,vec3(255.,125.,0.)/255.,s);\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtByRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1096]]}
{"id": "XtByRz", "name": "Maki's Candy Spiral", "author": "MakiXx", "description": "Trying out Shadertoy for the first time!", "tags": ["cute"], "likes": 6, "viewed": 128, "published": "Public", "date": "1507109179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define size 5.0\n#define spirals 0.5\n#define time iTime/4.0\n\n#define blue vec4(172, 218, 205, 255)/255.0\n#define pink vec4(240, 180, 180, 255)/255.0\n#define white vec4(1,1,1,1);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = (fragCoord-iResolution.xy*.5) / iResolution.y; // UV 0 to 1\n   \n    float d = length(uv)*size; // Distance fom center\n    float a = atan(uv.x, uv.y)/3.141592*spirals; // Angle from center\n    \n    float v = fract(d + a - time); // Spirals!\n    \n    fragColor =\n        v<.25 ? blue :\n    \tv>.5 && v<.75 ? pink :\n    \twhite;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtByRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 234, 234, 579]]}
{"id": "XtGGRt", "name": "Auroras", "author": "nimitz", "description": "Trying to get cheap and fully procedural northern lights effect. Looks better in full screen. Could still be improved...", "tags": ["procedural", "aurora", "atmosphere", "weather"], "likes": 481, "viewed": 24291, "published": "Public", "date": "1507050602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Auroras by nimitz 2017 (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\t\n\tThere are two main hurdles I encountered rendering this effect. \n\tFirst, the nature of the texture that needs to be generated to get a believable effect\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\n\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\n\tthe rest of the effect. Which is always the case for auroras.\n\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\n\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\n\tdirection. But this was not required for this demo and would be trivial to fix.\n*/\n\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(time*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    \n    for(float i=0.;i<50.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = ro + pt*rd;\n        vec2 p = bpos.zx;\n        float rzt = triNoise2d(p, 0.06);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\n        \n    }\n    \n    col *= (clamp(rd.y*15.+.4,0.,1.));\n    \n    \n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\n    \n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n    return col*1.8;\n    //return pow(col,vec4(1.))*2.\n}\n\n\n//-------------------Background and Stars--------------------\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\nvec3 bg(in vec3 rd)\n{\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\n    return col*.63;\n}\n//-----------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-6.7);\n    vec3 rd = normalize(vec3(p,1.3));\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\n    \n    vec3 col = vec3(0.);\n    vec3 brd = rd;\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\n    \n    col = bg(rd)*fade;\n    \n    if (rd.y > 0.){\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\n        col += stars(rd);\n        col = col*(1.-aur.a) + aur.rgb;\n    }\n    else //Reflections\n    {\n        rd.y = abs(rd.y);\n        col = bg(rd)*fade*0.6;\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\n        col += stars(rd)*0.1;\n        col = col*(1.-aur.a) + aur.rgb;\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\n    }\n    \n\tfragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGGRt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[184, 1537, 1558, 1558, 1610], [1664, 1664, 1686, 1686, 1728], [1729, 1729, 1750, 1750, 1800], [1802, 1802, 1842, 1842, 2250], [2252, 2252, 2276, 2276, 2341], [2342, 2342, 2373, 2373, 3311], [3314, 3377, 3401, 3401, 3592], [3594, 3594, 3617, 3617, 4039], [4041, 4041, 4062, 4062, 4236], [4237, 4301, 4358, 4358, 5446]]}
{"id": "XtjcDW", "name": "S curves: sigmoid vs smoothstep", "author": "luluco250", "description": "Comparing \"S curve\" contrast filters using sigmoid (with some scaling and offsetting to normalize it) and smoothstep.\nTop is sigmoid, bottom is smoothstep.", "tags": ["2d", "color", "contrast", "curve", "smoothstep", "s", "sigmoid"], "likes": 3, "viewed": 219, "published": "Public", "date": "1508634413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Regular sigmoid curve with the exception of\n// x * 10 - 5, which seems to normalize the curve.\nvec3 sigmoid(vec3 x) {\n    return vec3(1.0) / (vec3(1.0) + exp(-(x * 10.0 - 5.0)));\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    color = texture(iChannel0, uv);\n    \n    // The time factor is multiplied by 4\n    // for the filter flashing.\n    vec2 t = sin(vec2(iTime) * vec2(4.0, 1.0)) * 0.5 + 0.5;\n    \n    // If mouse is clicking on the canvas.\n    if (iMouse.z > 0.0)\n        t = iMouse.xy * ps;\n    \n    if (uv.y > t.y)\n    \tcolor.rgb = mix(color.rgb, sigmoid(color.rgb), t.x);\n    else\n        color.rgb = mix(color.rgb, smoothstep(0.0, 1.0, color.rgb), t.x);\n    \n    // Create a separator, inverting the colors.\n    if (uv.y < t.y + ps.y && uv.y > t.y - ps.y)\n        color.rgb = vec3(1.0) - color.rgb;\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjcDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 98, 120, 120, 183], [185, 185, 229, 229, 890]]}
{"id": "XtjcRV", "name": "Scalable Portals", "author": "ShnitzelKiller", "description": "A test of portal technology. Portals can possess non-uniform scales. Note: I'm learning the ropes, so don't use my probably crappy code as a reference for how to do things.\nMOUSE: movement\nSPACE: central camera view (gaze into infinity (or purple!))", "tags": ["raytracing", "portals"], "likes": 8, "viewed": 559, "published": "Public API", "date": "1509304615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define depth 0.1\n#define fdist 0.7\n#define background 0.\n#define portalmat1 1.\n#define portalmat2 2.\n#define framemat 3.\n#define floormat 4.\n#define geommat 5.\n#define maxdist 100.\n#define maxstep 100\n#define threshold 0.0025\n#define lightdir normalize(vec3(-1., 1., 0.5))\n#define lightintensity 1.5\n#define eps 0.01\n#define shadoweps 0.1\n#define dark vec3(0.2, 0.4, 0.4)\n#define floorheight -1.5\n#define maxpasses 20\n\n#define KEY_SPACE\t(vec2 (32.5, 0.5) / 256.0)\n\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\nstruct PortalFrame {\n    vec3 c;\n    vec3 dir;\n    vec3 up;\n    vec2 dims;\n} p1, p2;\n    \n\nfloat spheresdf(vec3 pos, vec3 c, float r, out vec3 coords) {\n    pos -= c;\n    coords = pos/(r*2. + 0.1);\n    return length(pos)-r;\n}\n\nfloat boxsdf(vec3 pos, vec3 c, vec3 dims, out vec3 coords) {\n    pos -= c;\n    dims /= 2.;\n    float d = max(pos.x - dims.x, -pos.x - dims.x);\n    d = max(d, max(pos.y - dims.y, -pos.y - dims.y));\n    d = max(d, max(pos.z - dims.z, -pos.z - dims.z));\n    coords = pos/max(dims.x, max(dims.y, dims.z));\n    return d;\n}\n\nfloat cylindersdf(vec3 pos, vec3 c, float r, float h, out vec3 coords) {\n    pos -= c;\n    coords = pos/max(r, h);\n    return max(length(pos.xz)-r, max(-pos.y, pos.y - h));\n}\n\nvec2 portalsdf(vec3 pos, PortalFrame p, out vec3 coords) {\n    vec3 r = pos - p.c;\n    float h = dot(r, p.dir);\n    vec3 u = normalize(cross(p.dir, p.up));\n    vec3 v = cross(u, p.dir);\n    float x = dot(r, u);\n    float y = dot(r, v);\n    p.dims = p.dims/2.;\n    \n    //frame\n    //float d2 = max(x-dims.x, -x-dims.x);\n    //d2 = -max(d2, max(y-dims.y, -y-dims.y));\n    \n    float d = max(h-depth/2., -h-depth/2.);\n    d = max(d, max(x-p.dims.x-depth, -x-p.dims.x-depth));\n    d = max(d, max(y-p.dims.y-depth, -y-p.dims.y-depth));\n    //d = max(d, d2);\n    \n    coords = vec3(x, y, h);\n    return vec2(d, abs(x) < p.dims.x && abs(y) < p.dims.y ? portalmat1 : framemat);\n}\n\nvec2 sdf(vec3 pos, out vec3 coords) {\n    vec3 coords1;\n    vec3 coords2;\n    vec2 d1 = portalsdf(pos, p1, coords1);\n    vec2 d2 = portalsdf(pos, p2, coords2);\n\tvec2 d;\n    if (d1.x < d2.x) {\n        d = d1;\n        coords = coords1;\n    } else {\n        d = vec2(d2.x, d2.y < 2.5 ? portalmat2 : framemat);\n        coords = coords2;\n    }\n    float mindist = d.x;\n    float mat = d.y;\n    float h = max(pos.y-floorheight, length(pos.xz)-10.);\n    if (h < mindist) {\n        coords = pos;\n        mindist = h;\n        mat = floormat;\n    }\n    //primitives\n    h = spheresdf(pos, vec3(2., 0., 0.), 0.8, coords1);\n    if (h < mindist) {\n        coords = coords1;\n        mindist = h;\n        mat = geommat;\n    }\n    h = cylindersdf(pos, vec3(-0.3, -1.5, 0.), 0.1, 1.5, coords1);\n    if (h < mindist) {\n        coords = coords1;\n        mindist = h;\n        mat = geommat;\n    }\n    h = boxsdf(pos, vec3(0., -0.5, -3.), vec3(0.4, 1.7, 0.4), coords1);\n    if (h < mindist) {\n        coords = coords1;\n        mindist = h;\n        mat = geommat;\n    }\n    h = boxsdf(pos, vec3(0., -1., 3.), vec3(5., 0.5, 0.9), coords1);\n    if (h < mindist) {\n        coords = coords1;\n        mindist = h;\n        mat = geommat;\n    }\n    return vec2(mindist, mat);\n}\n\nvec2 raytrace(vec3 rp, vec3 rd, out vec3 coords) {\n    float t = 0.;\n    vec2 d = sdf(rp, coords);\n    int i;\n    for (i=0; i<maxstep; i++) {\n        t += d.x;\n        if (t > maxdist) break;\n        d = sdf(rp + t*rd, coords);\n        if (abs(d.x)<threshold) {\n            return vec2(t, d.y); \n        }\n    }\n    return vec2(maxdist, background);\n}\n\nvec3 getnormal(vec3 pos) {\n    vec3 coords;\n    vec2 diff = vec2(eps, 0.);\n    float dx = sdf(pos+diff.xyy, coords).x-sdf(pos-diff.xyy, coords).x;\n    float dy = sdf(pos+diff.yxy, coords).x-sdf(pos-diff.yxy, coords).x;\n    float dz = sdf(pos+diff.yyx, coords).x-sdf(pos-diff.yyx, coords).x;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec2 shaderay(vec3 pos, vec3 rd, float hardness) {\n    vec3 coords;\n\tvec3 n = getnormal(pos);\n    float lambert = max(0., dot(n, lightdir))*lightintensity;\n    vec2 ds = raytrace(pos + shadoweps*lightdir, lightdir, coords);\n    lambert = ds.y < 0.5 ? lambert : 0.;\n    vec3 h = normalize(-rd + lightdir);\n    float phong = pow(clamp(dot(h, n), 0., 1.), hardness);\n    return vec2(lambert, phong);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float space = texture (iChannel0, KEY_SPACE).r;\n    float alt = clamp(iMouse.y/iResolution.y-0.5, -0.15, 1.) * PI/2.;\n    float azi = (iMouse.x/iResolution.x-0.35) * TWO_PI;\n    float cphi = cos(alt);\n    vec3 eye = (0.01 + 5. * (1.-space)) * vec3(sin(azi)*cphi, sin(alt) + 2.*exp(-iTime), cos(azi)*cphi);\n    vec3 w = -normalize(eye);\n    eye += vec3(-0.3, 0.05, 0.);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(fdist*w + (fragCoord.x/iResolution.x-0.5)*u + (fragCoord.y/iResolution.x-0.5*iResolution.y/iResolution.x)*v);\n    \n    \n    float t = (sin(iTime/5.)+1.) * PI;\n    p1 = PortalFrame(vec3(0., 0., 0.), normalize(vec3(1., 0.1*cos(iTime*2.)*sin(t), 0.0)), vec3(0., 1., 0.2*sin(iTime*2.)*cos(t)), vec2(1.5 - 0.2*cos(t/2.), 2.+ 0.7*cos(t / 2.)));\n    p2 = PortalFrame(vec3(-1.5, 0., 0.), normalize(vec3(cos(t), 0., sin(t))), vec3(0., 1., 0.), vec2(1.5, 2.));\n    \n    \n    int i;\n    for (i=0; i<maxpasses; i++) {\n        vec3 coords;\n    \tvec2 d = raytrace(eye, rd, coords);\n        if (d.y < 0.5) {\n            //background\n            fragColor = vec4(0., 0.5, 1., 1.);\n            break;\n        } else if (d.y < 1.5) {\n            //portal1\n            u = normalize(cross(p1.dir, p1.up));\n    \t\tv = cross(u, p1.dir);\n    \t\tfloat x = dot(rd, u);\n    \t\tfloat y = dot(rd, v);\n            float z = dot(rd, p1.dir);\n            u = normalize(cross(p2.dir, p2.up));\n    \t\tv = cross(u, p2.dir);\n            vec2 scale = p2.dims/p1.dims;\n            rd = normalize(x*u*scale.x + y*v*scale.y + z*p2.dir);\n            eye = p2.c + coords.x*u*scale.x + coords.y*v*scale.y - coords.z * p2.dir + 2.*threshold*rd;\n            //dummy frag color to indicate that we can't render any further into the portals\n            fragColor = vec4(0.2, 0.8, 1., 1.);\n        } else if (d.y < 2.5) {\n            //portal2\n            u = normalize(cross(p2.dir, p2.up));\n    \t\tv = cross(u, p2.dir);\n    \t\tfloat x = dot(rd, u);\n    \t\tfloat y = dot(rd, v);\n            float z = dot(rd, p2.dir);\n            u = normalize(cross(p1.dir, p1.up));\n    \t\tv = cross(u, p1.dir);\n            vec2 scale = p1.dims/p2.dims;\n            rd = normalize(x*u*scale.x + y*v*scale.y + z*p1.dir);\n            eye = p1.c + coords.x*u*scale.x + coords.y*v*scale.y - coords.z * p1.dir + 2.*threshold*rd;\n            \n            fragColor = vec4(0.8, 0.2, 1., 1.);\n        } else if (d.y < 3.5) {\n            //portal border\n            vec3 col = mix(vec3(0.2, 0.2, 0.2), vec3(0.2, 0.7, 0.6), abs(abs(step(mod(coords.x, 0.5), 0.25)-step(mod(coords.z, 0.5), 0.25))-step(mod(coords.y, 0.5), 0.25)));\n            vec2 shade = shaderay(eye + d.x*rd, rd, 1.);\n            fragColor = vec4(max(dark.b, shade.x)*col, 1.0);\n            break;\n        } else if (d.y < 4.5) {\n            //floor\n            vec3 col = mix(vec3(0.4, 0.4, 0.4), vec3(0.7, 0.7, 0.7), abs(step(mod(coords.x, 1.), 0.25)-step(mod(coords.z, 1.), 0.25)));\n            vec2 shade = shaderay(eye + d.x*rd, rd, 10.);\n            fragColor = vec4(max(dark.b, shade.x)*col+shade.y/3., 1.0);\n            break;\n        } else {\n            //yellow checkered objects\n            vec3 col = mix(vec3(0.4, 0.8, 0.4), vec3(1., 0.7, 0.2), abs(abs(step(mod(coords.x, 0.5), 0.25)-step(mod(coords.z, 0.5), 0.25))-step(mod(coords.y, 0.5), 0.25)));\n            vec2 shade = shaderay(eye + d.x*rd, rd, 20.);\n            fragColor = vec4(max(dark.b, shade.x)*col+shade.y/3., 1.0);\n            break;\n        }\n    }\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjcRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[612, 612, 673, 673, 746], [748, 748, 808, 808, 1065], [1067, 1067, 1139, 1139, 1241], [1243, 1243, 1301, 1301, 1915], [1917, 1917, 1954, 1954, 3165], [3167, 3167, 3217, 3217, 3518], [3520, 3520, 3546, 3546, 3849], [3851, 3851, 3901, 3901, 4249], [4251, 4251, 4308, 4308, 7803]]}
{"id": "XtjczR", "name": "Mandel Distort 2", "author": "themasmo", "description": "Two noise value distort mandel", "tags": ["mandelbrot", "distort", "mandel", "boise"], "likes": 0, "viewed": 78, "published": "Public", "date": "1507199263", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 p, float ang){\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.y * c - p.x * s, p.y * s + p.x * c);\n}\n\nvec3 hsb2rgb( in vec3 c )\n{\n  vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0)\n\t\t  , 6.0)-3.0)-1.0, 0.0, 10.0 );\n  rgb *= rgb*(11.5-0.0*rgb);\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*4758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 1.0*(fragCoord.xy / iResolution.xy)-0.5;\n\t\n\n\tp*=4.0;\n\t\n\tvec2 r=rotate(p,iTime);\n\tr*=1.0+sin(iTime)/2.0;\n\tvec2 r1=vec2((p.x+iTime),(p.y+iTime));\n\tfloat n1=1.0*(r.x+noise(r1)/10.0)-0.4;\n\tvec2 r2=vec2((p.x-iTime),(p.y-iTime));\n\tfloat n2=1.0*(r.y+noise(r2)/10.0)-0.0;\n\tvec2 v=vec2(n1,n2);\n\n\t//\n\tfloat cre=n1;\n\tfloat cim=n2;\n\tfloat zre=0.0;\n\tfloat zim=0.0;\n\tfloat max=32.0;\n\tfloat j=0.0;\n\tfloat cm=0.0;\n\t\n\tfor(float i=0.0;i<256.0;i++)\n\t{\n\t\tif(i>max)\n\t\t{\n\t\t\tcm=0.0;\n\t\t\tbreak;\n\t\t}\n\t\tfloat dam=zre*zre-zim*zim+cre;\n\t\tzim=2.0*zre*zim+cim;\n\t\tzre=dam;\n\t\tif( (zre*zre+zim*zim)>4.0)\n\t\t{\n\t\t\tcm=i/max;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t\n\t//\n\tfloat color = 0.0;\n\tvec2 r3=vec2(sin(p.x+iTime),cos(p.y+iTime));\n\tfloat n3=noise(r3);\n\tvec2 r4=vec2(sin(p.x-iTime),cos(p.y-iTime));\n\tfloat n4=noise(r4);\n\tvec2 v1=vec2(n3,n4);\n\t\n\tcolor= (length(v1 - p));\n\tvec3 cc=vec3(color, cm, 1.0-color);\n\t\n    fragColor = vec4( hsb2rgb(cc), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjczR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 126], [128, 128, 155, 155, 315], [317, 317, 339, 339, 418], [420, 420, 446, 446, 747], [749, 749, 806, 806, 1716]]}
{"id": "XtjyDD", "name": "Just some spinning dots", "author": "AdmiralPotato", "description": "One of my first GLSL ever - Click and drag to move the stuff", "tags": ["2d"], "likes": 1, "viewed": 376, "published": "Public API", "date": "1508751796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = atan(1.0) * 4.0;\nfloat TAU = atan(1.0) * 8.0;\n\n\nfloat circle (vec2 center, vec2 fragCoord, float radius, float pixelWidth) {\n    return smoothstep(radius + pixelWidth, radius - pixelWidth, length(fragCoord - center));\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat pixelWidth = 1.0 / min(iResolution.x, iResolution.y);\n\tvec2 pos = (fragCoord - 0.5 * iResolution.xy) * pixelWidth;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) * pixelWidth;\n    \n    if(iMouse.xy == vec2(0.0)) {\n        mouse += 0.5 * iResolution.xy * pixelWidth;\n    }\n    \n    float phase = -(iTime / 2.0) * TAU;\n    float radius = 0.05 + (cos(phase) * 0.01);\n    fragColor.r += circle(vec2(cos(phase), sin(phase)) *  0.15 + mouse, pos, radius, pixelWidth);\n    fragColor.g += circle(vec2(0.0) + mouse, pos, radius, pixelWidth);\n    fragColor.b += circle(vec2(cos(phase), sin(phase)) * -0.15 + mouse, pos, radius, pixelWidth);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjyDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 135, 135, 230], [233, 233, 290, 290, 935]]}
{"id": "XtjyDz", "name": "Sharingans", "author": "hankhplee", "description": "AMATERASU", "tags": ["naruto"], "likes": 2, "viewed": 360, "published": "Public", "date": "1508259405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RED vec4(1., 0., 0., 1.)\n#define BLACK vec4(0.)\n \nfloat PI = acos(-1.);\n \nfloat deg2rad(float x){\n    return x / 180. * PI;\n}\n \nvec2 rad2cod(float r, float t){\n    return vec2(r * cos(t), r * sin(t));\n}\n \nfloat norm2(vec2 xy){\n    return sqrt(xy.x * xy.x + xy.y * xy.y);\n}\n \nint seed = 20150118;\nint rand(){\n    return seed = seed * 0xdefaced + 1;\n}\n \nfloat dir = -1.;\n \nvec4 draw(vec2 fragCoord, vec2 center){\n    float r = iTime * dir;\n    mat2 rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n    float var = sin(texture(iChannel0, vec2(iTime, 0.)).x);\n    vec2 xy = rot * (fragCoord.xy - center);\n    vec4 col = vec4(-1.);\n    if(norm2(xy) < 100. + var * 20.){\n        col = RED;\n    }\n   \n    if(norm2(xy) < 15. + var * 20.){\n        col = BLACK;\n    }\n    if(70. <= norm2(xy) && norm2(xy) <= 72.5){\n        col = BLACK;\n    }\n   \n    if(norm2(xy - rad2cod(70., deg2rad(0.0))) < 15. + var * 20.){\n        col = BLACK;  \n    }\n    if(norm2(xy - rad2cod(70., deg2rad(120.0))) < 15. + var * 20.){\n        col = BLACK;  \n    }\n    if(norm2(xy - rad2cod(70., deg2rad(240.0))) < 15. + var * 20.){\n        col = BLACK;  \n    }\n \n    return col;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float offset = mod(iTime * 100., 360.);\n    vec4 col = vec4(1.);\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float var = sin(texture(iChannel0, vec2(iTime, 0.)).x);\n    if(norm2(xy) < 400.){\n        col = BLACK;\n    }\n    if(norm2(xy) < 40. + var * 60.){\n        col = RED;\n    }\n    if(240. < norm2(xy) && norm2(xy) < 245.){\n        col = RED;\n    }\n   \n    if(norm2(xy - rad2cod(250., deg2rad(0.0   + offset))) < 300.){\n        vec4 tmp = draw(fragCoord, iResolution.xy / 2. + rad2cod(250., deg2rad(0.0   + offset)));\n        if(tmp != vec4(-1.))\n            col = tmp;\n    }\n    if(norm2(xy - rad2cod(250., deg2rad(120.0   + offset))) < 300.){\n        vec4 tmp = draw(fragCoord, iResolution.xy / 2. + rad2cod(250., deg2rad(120.0   + offset)));\n        if(tmp != vec4(-1.))\n            col = tmp;\n    }\n    if(norm2(xy - rad2cod(250., deg2rad(240.0   + offset))) < 300.){\n        vec4 tmp = draw(fragCoord, iResolution.xy / 2. + rad2cod(250., deg2rad(240.0   + offset)));\n        if(tmp != vec4(-1.))\n            col = tmp;\n    }\n    if(var > 0.4)\n        col = vec4(1.) - col;\n    fragColor = col;\n}", "image_inputs": [{"id": "ldlSWl", "previewfilepath": "https://soundcloud.com/naruto-uzumaki-2/naruto-main-theme", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/naruto-uzumaki-2/naruto-main-theme", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjyDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 105, 105, 133], [136, 136, 167, 167, 210], [213, 213, 234, 234, 280], [304, 304, 315, 315, 357], [379, 379, 418, 418, 1148], [1151, 1151, 1207, 1207, 2322]]}
{"id": "XtlyDl", "name": "4d raymarching", "author": "abje", "description": "a grid of 4d spheres and cubes.\nworking on truchet", "tags": ["raymarching", "simple", "4d"], "likes": 2, "viewed": 532, "published": "Public API", "date": "1506971538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define pi acos(-1.0)\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat box(vec4 p, float size) {\n    vec4 p2 = abs(p)-size;\n    return length(max(p2,0.0))+min(0.0,max(max(max(p2.x,p2.y),p2.z),p2.w));\n}\n\nfloat torus(vec4 p, vec2 r) {//creates 4 toruses\n    return length(vec2(abs(length(p.xyz)-r.x),p.w))-r.y;\n}\n\nfloat torus2(vec4 p, vec2 r) {//creates 4 toruses\n    return length(vec3(abs(length(p.xy)-r.x),p.zw))-r.y;\n}\n\n/*float map(vec4 p) {\n    vec4 p2 = mod(p,4.0)-2.0;\n    \n    //float transition = clamp(abs(mod(iTime*0.2,2.0)-1.0)*5.0-2.0,0.0,1.0);\n    //return min(box(p2,1.0-transition)-transition,length(abs(p2)-1.0)-0.5);\n    //return box(p2,1.0-transition)-transition;\n    return torus(p2,vec2(1.0,0.3));\n}*/\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat map(vec4 p) {\n    \n    \n    \n    //vec4 p2 = abs(mod(p,4.0)-2.0)-1.0;\n    //return box(p2,0.5);\n    vec4 p2 = mod(p,2.0)-1.0;\n    vec4 floorpos = floor(p*0.5);\n    float len = 1e10;\n    \n    //the truchet flipping\n    vec4 orientation = floor(hash44(floorpos)+0.5)*2.0-1.0;\n    //orientation.yz = vec2(1.0);\n    \n    //actually flipping the truchet\n    vec4 p3 = p2*orientation;\n    \n    //positions relative to truchet centers\n    \n    float x = 1.0;\n    \n    vec4[4] truchet = vec4[4] (\n        vec4(p3.xy+vec2(+1,-1),p3.zw),// +x +y\n        vec4(p3.xz+vec2(-1,-1),p3.yw),// +x    +z\n        vec4(p3.yw+vec2(+1,-1),p3.xz),//    +y    +w\n        vec4(p3.zw+vec2(+1,+1),p3.xy) //       +z +w\n    );\n    \n    //finding distance to truchet\n    len = min(min(min(\n        torus2(truchet[0],vec2(1.0,0.05)),\n        torus2(truchet[1],vec2(1.0,0.05))),\n        torus2(truchet[2],vec2(1.0,0.05))),\n        torus2(truchet[3],vec2(1.0,0.05)));\n    \n    return len;\n}\n\nvec4 findnormal(vec4 p, float len) {\n    vec2 eps = vec2(0.01,0.0);\n    \n    return normalize(vec4(\n        map(p+eps.xyyy)-len,\n        map(p+eps.yxyy)-len,\n        map(p+eps.yyxy)-len,\n        map(p+eps.yyyx)-len));\n}\n\nvec4 findnormal(vec4 p) {\n    vec2 eps = vec2(0.01,0.0);\n    \n    return normalize(vec4(\n        map(p+eps.xyyy)-map(p-eps.xyyy),\n        map(p+eps.yxyy)-map(p-eps.yxyy),\n        map(p+eps.yyxy)-map(p-eps.yyxy),\n        map(p+eps.yyyx)-map(p-eps.yyyx)));\n}\n\nvec4 shade(vec4 p, vec4 d, vec4 objnorm, float depth) {\n    vec4 sun = normalize(vec4(-1.0));\n    vec4 reflectnorm = reflect(d,objnorm);\n    vec4 color = objnorm*0.5+0.5;\n    vec4 fragColor = vec4(color*max(0.4,0.8*dot(objnorm,sun)));\n    fragColor /= depth*depth*0.01+1.0;\n    fragColor = max(fragColor,(dot(reflectnorm,sun)-0.9)*3.0/depth/depth);\n    return clamp(fragColor,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.0-iResolution.xy) / iResolution.y;\n\t\n    float time = iTime*0.5;\n    \n    vec4 pos4d = vec4(0,0,time+sin(time*pi)/pi,0).wxyz;\n    vec4 dir4d = normalize(vec4(uv,1,0));\n    //dir4d.xy *= rot(iTime*0.1);\n    //dir4d.yz *= rot(iTime*0.1);\n    //dir4d.zw *= rot(iTime*0.1);\n    //dir4d.wx *= rot(iTime*0.1);\n    \n    float dist = 0.0;\n    bool hit = false;\n    \n    float reflections = 1.0;\n    float colorlength = 0.0;\n    float len;\n    for (int i = 0; i < 100; i++) {\n        len = map(pos4d);\n        if (abs(len) < 0.01) {\n            hit = true;\n            /*vec4 normal = findnormal(pos4d,len);\n        \tfragColor += shade(pos4d,dir4d, normal,dist)*reflections;\n            dir4d = reflect(dir4d,normal);\n            pos4d += dir4d*0.1;\n            colorlength += reflections;\n            if (reflections < 0.5) break;\n            reflections *= 0.5;*/\n            \n            break;\n        }\n        pos4d += dir4d*abs(len);\n        dist += abs(len);\n    }\n    fragColor /= colorlength;\n    if (hit)\n    {\n        /*\n        fragColor = (mod(pos4d,3.0)-1.5);\n        /*\n        vec4 sun = normalize(vec4(-1.0));\n        vec4 objnorm = findnormal(pos4d);\n        vec4 reflectnorm = reflect(dir4d,objnorm);\n        fragColor = objnorm*0.5+0.5;\n        fragColor = vec4(fragColor*max(0.6,dot(objnorm,sun)));\n        */\n        fragColor = shade(pos4d,dir4d, findnormal(pos4d,len), dist);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 241, 241, 346], [348, 348, 377, 396, 455], [457, 457, 487, 506, 565], [867, 937, 959, 959, 1071], [1073, 1073, 1092, 1174, 2037], [2039, 2039, 2075, 2075, 2258], [2260, 2260, 2285, 2285, 2516], [2518, 2518, 2573, 2573, 2905], [2907, 2907, 2964, 2964, 4391]]}
{"id": "XtscDl", "name": "Exploding Mandelbrot", "author": "Chris_M_Thomasson", "description": "Using the smooth coloring code created by Inigo Quilez:\n\nhttp://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n\nAn implementation of my Exploding Mandelbrot set in a shader:\n\nhttp://www.fractalforums.com/index.php?action=gallery;sa=view;id=20582", "tags": ["2d", "fractal", "mandelbrot", "field", "vector", "scale"], "likes": 17, "viewed": 628, "published": "Public", "date": "1506976596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Very nice coloring, zoom and anti-aliasing by:\n\n// inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// See here for more information on smooth iteration count:\n//\n// http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n\n\n// Exploding Pulsing Mandelbrot Set by Chris M. Thomasson\n// Orbit trap color by Chris M. Thomasson\n// http://www.fractalforums.com/index.php?action=gallery;sa=view;id=20582\n\nvec2 ct_cmul(in vec2 p0, in vec2 p1)\n{\n    return vec2(p0.x * p1.x - p0.y * p1.y, p0.x * p1.y + p0.y * p1.x);\n}\n\n\n// increase this if you have a very fast GPU\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        float w = float(AA*m+n);\n        float time = iTime + 0.5*(1.0/24.0)*w/float(AA*AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        float time = iTime;\n#endif\n    \n        float zoo = 1.0 + 0.38*cos(.07*time);\n        float coa = cos( 0.15*(1.0-zoo)*time );\n        float sia = sin( 0.15*(1.0-zoo)*time );\n        zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 c = vec2(-.745,.186) + xy*zoo;\n\n        float B = 200.0;// + abs(cos(iTime * .25)) * 30.0;\n        float l = 0.0;\n        float ct_o = 999999999.0;\n\t    vec2 z  = vec2(0.0);\n        int ct_retry = 0;\n        int ct_switch = 0;\n        for( int i=0; i<256; i++ )\n        {\n            // z = z*z + c\t\t\n    \t\tz = vec2( z.x*z.x - z.y*z.y * (1.0 + abs(cos(iTime * 2.0)) * .1), (2.0 + abs(sin(iTime * 3.0)) * .1)*z.x*z.y ) + c;\n            ct_o = min(ct_o, sqrt(z.x * z.x + z.y * z.y));\n\t\t\n    \t\tif(z.x * z.x + z.y * z.y > B)\n            {\n                // Chris M. Thomassons Exploder!\n                if (ct_retry < 7)\n                {\n                    if (ct_switch == 0)\n                    {\n                        z = ct_cmul(z, vec2(.02 + abs(cos(iTime * .5)) * .02, .07));\n                        ct_switch = 1;\n                    }\n                    \n                    else\n                    {\n                        z = ct_cmul(z, vec2(-.04, -(.04 + abs(sin(iTime)) * .041)));\n                        ct_switch = 0;\n                    }\n                    \n                \t++ct_retry;\n                \tcontinue;\n                }\n                break;\n            }\n\n    \t\tl += 1.0;\n        }\n\n    \t// ------------------------------------------------------\n        // smooth interation count\n    \t//float sl = l - log(log(length(z))/log(B))/log(2.0);\n        \n        // equivalent optimized smooth interation count\n    \tfloat sl = l - log2(log2(dot(z,z))) + 4.0; \n    \t// ------------------------------------------------------\n\t\n        float al = smoothstep( -5.0, 0.0, cos(3.14*iTime) );\n        l = mix( l, sl, al );\n\n        // CT: added some color wrt ct_o variable.\n        col += 0.5 + 0.5*cos( 3.0 + l*0.15 + vec3(.5 + cos(3.14*iTime) * .5, ct_o * l * .05, 0));\n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtscDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[297, 472, 510, 510, 583], [586, 645, 702, 702, 3247]]}
{"id": "XtScDR", "name": "Blurry Triangles", "author": "BigWIngs", "description": "See comments for details.", "tags": ["triangle", "blur", "texture", "filtering"], "likes": 41, "viewed": 788, "published": "Public", "date": "1508167732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Blurry Triangles\" by Martijn Steinrucken aka BigWings/CountFrolic - 2017\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n\n\tI started playing around with triangular tiling and came up with a way to blur them.\n\tPerhaps it is useful to someone.\n*/\n#define S(a, b, t) smoothstep(a, b, t)\n#define GRID 15.\n\n#define R2 1.41421356\n#define PI 3.14159265\n\nfloat SimpleTriangle(vec2 uv, float w) {\n\tfloat diag = S(-w, w, uv.x-uv.y);\n    float bottom = S(-w, w, uv.y);\n    float right = S(w, -w, uv.x-1.);\n    float top = S(w, -w, uv.y-1.);\n    float left = S(-w, w, uv.x);\n    \n    return diag*bottom*top*left*right;\n}\n\nfloat Triangle(vec2 u, float w) {\n    // Optimized blurred triangle. The way I got here was by writing out\n    // the sum of a SimpleTriangle tile and it's 8 neighbors and then compacting and\n    // throwing out stuff that doesn't contribute.\n    // Still takes 7 smoothsteps, could perhaps be optimized more by exploiting \n    // symmetries. I'm sure someone will be able to reduce this further.\n    // The smoothsteps catch tile edges + diagonals (centers)\n    // â---â¬---â¬---â\n    // |   | F |   |\n    // â---â¼-A-â¼---â¤\n    // | K X C B F |\n    // â---â¼-Y-â¼---â¤\n    // |   | K |   |\n    // â---â´---â´---â\n    float diag = u.x-u.y;\n    float C = S(-w, w, diag);\n    float Y = S(-w, w, u.y);\n    float X = S(-w, w, u.x);\n    float A = S(-w, w, u.y-1.);\n    float B = S(-w, w, u.x-1.);\n    float F = S(-w, w, diag-1.);\n    float K = S(-w, w, diag+1.);\n    \n    return \tX*(1.-B)*(C*Y*(1.-A) + K*A+ F*(1.-Y)) + \n        \tB*(C*A + F*Y*(1.-A)) + \n        \t((1.-X)*(C*(1.-Y) + K*Y*(1.-A) + A));\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n\tU = (U-iResolution.xy*.5)/iResolution.x;\n    vec2 uv = U;\n    \n    float t = iTime*.2;\n   \n    float c = cos(t), s = sin(t);\n    uv*= mat2(-c, s, s, c);\n    \n    \n    uv *= mix(2., GRID, sin(t*.5)*.5+.5);\n\n    c = cos(PI/4.), s = sin(PI/4.);\t// rotate 45 degrees\n    uv.x *= .5*sqrt(2.)*sqrt(3./4.);\t\t\t// stretch so sides are of equal length\n    uv *= mat2(-c, s, s, c);\t\t\t\t\t// apply rotation\n    \n    uv+=iTime;\n    uv = fract(uv);\n  \n    float blur = iMouse.y/iResolution.y;\n    blur = mix(.01, .7, cos(iTime*2.+U.x*PI)*.5+.5);\n    \n    float v = Triangle(uv, blur);\n    \n   // v = S(.18, .2, v)*S(.82, .8, v);\n    O = vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtScDR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 418, 458, 458, 679], [681, 681, 714, 1318, 1702], [1704, 1704, 1745, 1745, 2378]]}
{"id": "XtscDs", "name": "All Seeing Marble", "author": "colonel_hilbert", "description": "Based on the Marble - [url]https://www.shadertoy.com/view/MtX3Ws[/url]\nNote the return value in l. 22, the sqrt() in l. 35, the addition of hue variation in l. 61, ", "tags": ["3d", "raymarching", "volumetric"], "likes": 21, "viewed": 474, "published": "Public", "date": "1507018861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015 - https://www.shadertoy.com/view/MtX3Ws\n// Modified by C. Hinrichs 2017\n\n\nfloat zoom=0.28;\n\n//vec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-2.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map(in vec3 p) {\n\tfloat res = 0.;\n\t\n    vec3 c = p;\n\tfor (int i = 0; i < 10; ++i) {\n        p =.7*abs(p)/dot(p,p) -.7;\n        //p.yz= csqr(p.yz);\n        //p=p.zxy;\n        res += exp(-19. * sqrt(abs(dot(p,c))));\n        \n\t}\n\treturn (res/2.); //log(res/2.)\n}\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\n{\n    float t = tminmax.x;\n    float dt = .02;\n    //float dt = .2 - .195*cos(iTime*.05);//animated\n    vec3 col= vec3(0.);\n    float c = 0.;\n    for( int i=0; i<68; i++ )\n\t{\n        t+=dt*exp(-7.8*c);\n        vec3 pos = ro+t*rd;\n        \n        c = map(pos);               \n        if(t>tminmax.y && tminmax.x != tminmax.y) break; // c /= 1.25;\n        \n        //col += .12*vec3(c*c, c, c*c*c);\n        col +=  .14*vec3(c*c*c, c*c, c);//blue\n    }\n    \n    col *= log(1.25 + 2.*abs(rd.yxz));\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(4.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n    \n    vec2 tmm = iSphere( ro, rd, vec4(.8,0.,.45,1.) );\n\n\t// raymarch\n    vec3 col = raymarch(ro,rd,tmm);\n    //if (tmm.x<0.)col = texture(iChannel0, rd).rgb;\n    //else {\n    //    vec3 nor=(ro+tmm.x*rd)/2.;\n    //    nor = reflect(rd, nor);        \n    //    float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\n    //    col += texture(iChannel0, nor).rgb * fre;\n    //}\n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtscDs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[211, 299, 321, 321, 370], [373, 373, 392, 392, 439], [441, 441, 503, 503, 689], [691, 691, 713, 713, 956], [959, 959, 1011, 1011, 1522], [1525, 1525, 1582, 1582, 2619]]}
{"id": "XtScRW", "name": "Circle Andii", "author": "Andii", "description": "Circle", "tags": ["circle"], "likes": 0, "viewed": 398, "published": "Public API", "date": "1507551631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float scale = 80.0;\n    float width = 10.0;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = vec4(0,0,0,0);\n    vec4 colorBg = vec4(uv.y,uv.x,uv.y,1);\n        \n    \n    vec2 cord = vec2(fragCoord.x + 50.0 * sin(iTime), fragCoord.y);\n    \n    float dist = distance(cord,iResolution.xy/2.0);\n \t\n    if(dist <= scale && dist >= scale - width)\n    {\n        color = vec4(0,0.7,1,1);\n    }\n    else\n    {\n    \tcolor = colorBg;   \n    }\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtScRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 545]]}
{"id": "XtSczh", "name": "MandelBar", "author": "themasmo", "description": "Three effect in one", "tags": ["fractal", "oldschool", "mandel", "coloredbar"], "likes": 1, "viewed": 81, "published": "Public", "date": "1507300825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 p, float ang){\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.y * c - p.x * s, p.y * s + p.x * c);\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*4758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = 4.0*( fragCoord.xy / iResolution.xy )-2.0 ;\n    \n\n    \n\tfloat v=0.0;\n\tfloat ii=0.0;\n\tfloat rg=1.0;\n\tint f=0;\n\n\t// White\t\n\tfor(int i=0;i<20;i++)\n\t{\n\t\tvec2 n1=rg*vec2(sin(iTime+ii),cos(iTime+ii));\n\t\tvec2 n2=rg*vec2(cos(iTime+ii),sin(iTime+ii));\n\t\tvec2 pos=vec2(noise(n1)*2.0,noise(n2)*2.0);\n\t\tfloat l1 = 0.1/length(pos - position);\n\t\tif( f==0 )\n\t\t{\n\t\t\tv+=l1;\n\t\t\tf=0;\n\t\t}\n\t\tii+=0.1;\n\t}\n\t\n\t\n\tvec2 r=rotate(position,iTime);\n\tr*=1.0+sin(iTime)/4.0;\t// black\n\tfloat zim=0.0;\n\tfloat zre=0.0;\n\tfloat cre=r.x;\n\tfloat cim=r.y;\n\tfloat ite=0.0;\n\tfor(int i=0;i<32;i++)\n\t{\n\t\tite++;\n\t\tfloat dam=zre*zre-zim*zim+cre;\n\t\tzim=(abs(3.0*sin(iTime/10.0)))*zre*zim+cim;\n\t\tzre=dam;\n\t\tif( (zre*zre+zim*zim)>4.0)\n\t\t\tbreak;\n\t}\n\tv=pow(v,2.0);\n\tif(ite>30.0)\n\t{\n\t\tfloat rcolor = 0.0;\n\t\tfloat gcolor = 0.0;\n\t\tfloat bcolor = 0.0;\n\t\tfloat rg=0.5;\n\t\tfloat an=iTime*48.0;\n\t\tfloat ck=16.0+16.0*iMouse.x;\n\t\n\t\tfor(float i=0.0;i<16.0;i++)\n\t\t{\n\t\t\tfloat di=0.08;\n\t\t\tfloat y=rg*sin( (an+i*10.0)*3.141/180.0);\n\t\t\n\t\t\tif( position.y>y-di && position.y<y+di )\n\t\t\t{\n\t\t\t\tfloat c=1.0-abs(position.y-y)*10.0;\n\t\t\t\t\n\t\t\t\trcolor=c;\n\t\t\t\tgcolor=rcolor*(i/ck);\n\t\t\t\tbcolor=rcolor*(i/ck);\n\t\t\t}\n\t\t\n\t\t}\t\n\t\t\n\t\tfragColor = vec4( vec3( rcolor, gcolor , bcolor  ), 1.0 );\n\t}\n\telse\n\t{\n\t\tv=(ite+v)/32.0;\n\t\tfragColor = vec4(vec3(v),1.0);\n\t}    \n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSczh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 126], [128, 128, 150, 150, 229], [231, 231, 257, 257, 558], [560, 560, 617, 617, 1914]]}
{"id": "XtSczV", "name": "Rotational symmetry", "author": "iq", "description": "Rotational symmetry with regular mod() domain repetition. Since the repeated objects extend past half the repeating space, the one extra neighbor needs to be checked for distance too. This can be done cheaply without extra trigonometry (line 46).", "tags": ["2d", "sdf", "symmetry", "rotational"], "likes": 32, "viewed": 1121, "published": "Public API", "date": "1509144777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Rotational symmetry with regular mod() domain repetition. Since the repeated objects extend \n// past half the repeating space, one extra neighbor need to be checked for distance too. This\n// can be done cheaply without extra trigonometry (line 46).\n//    \n// Idea from aiekick's https://www.shadertoy.com/view/XtBcRV but with fixed discontinuities at\n// minimal cost, and euclidean distance\n\n\nconst int n = 8;\nconst float an = 6.2831/float(n);\nconst mat2 inc = mat2( cos(an),sin(an),-sin(an),cos(an)); // can replace by constants\n//const mat2 inc = mat2(1.0,1.0,-1.0,1.0)/1.41421; // same as above for n=8\n\n//#define SIMULATE_BUG\n#define BOX_SIZE 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = (fragCoord*2.-iResolution.xy)/iResolution.y*3.;\n\n    float fa = (atan(q.y,q.x)+an*0.5)/an;\n    float ia = floor( fa );\n    \n    float sym = an*ia;\n    vec2 r = mat2(cos(sym),-sin(sym),\n                  sin(sym), cos(sym))*q;\n        \n    #ifndef SIMULATE_BUG\n    if( fract(fa)>0.5 ) r = r*inc; // rotate one backwards\n    #endif\n\n    float d = 4.0 + length(q);\n    #ifndef SIMULATE_BUG\n    for( int i=0; i<2; i++ )\n    #endif\n    {\n                                            // int id = (int(ia)-i) % n; or float id = mod(ia-float(i),float(n));\n        float rot = iTime;                  // + 2.0*float(id); // try this for different angles\n        \n        // translate and rotate each box\n        vec2 p = mat2( cos(rot),sin(rot),\n                      -sin(rot),cos(rot))*(r - vec2(2.0,0.0));\n\n        // box distance\n        p = abs(p) - BOX_SIZE;                   // + 0.4*sin(3.0*float(id)); // try this for different size\n        d = min( d, min(max(p.x,p.y),0.0) + length(max(p,0.0)) );\n        \n        // next angle\n        r = inc*r;\n\t}\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSczV.jpg", "access": "shaders20k", "license": "mit", "functions": [[1688, 1733, 1790, 1790, 3078]]}
{"id": "XtSyDh", "name": "Simple Ray Tracer - Shadow", "author": "kaswan", "description": "simple raytracer with shadow", "tags": ["raytracing", "shadow"], "likes": 2, "viewed": 276, "published": "Public", "date": "1508340222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float checkboard(vec2 p)\n{\n    p = mod(floor(p/100.0), 2.0);\n    return mod(p.x + p.y, 2.0) < 1.0 ? 0.5 : 0.1;\n}\n\n//vec3 Light = vec3(-2.0 * cos(iTime * 2.0), 3.0, 2.0 * sin(iTime * 2.0));\nvec3 ambient = vec3(0.1, 0.1, 0.3);\nvec3 vEye = vec3(0.0, 0.0, 3.5);\n\nfloat shadow(vec3 sRay, vec3 Pos);\n\nvec3 calcLight(vec3 N, vec3 L, vec3 V, vec3 matColor)\n{\n    vec3 color;\n    \n\tvec3 Rf = reflect(-L,N);\n\n    float diffuse = max(dot(N, L), 0.0);\n    float specular = 0.0;\n    if (diffuse > 0.0) specular = pow(max(dot(Rf, V),0.0), 16.0);\n\t\t\n    color = diffuse * matColor;\n\tcolor += specular;\n    color += ambient;\n\t\n    return color;\n}\n\nvec3 plane(vec3 vRay)\n{\nvec3 Light = vec3(-2.0 * cos(iTime * 2.0), 3.0, 2.0 * sin(iTime * 2.0));\n    vec3 color;\n    vec3 N = vec3(0.0, 1.0, 0.0);\n    float D = -1.0;\n        \n\tfloat Det = dot(N, vRay); \n    if (Det < 0.0) { // Floor with chess texture\n            \n    \tfloat t = (D - dot(vEye, N)) / Det;\n        \t\n        vec3 Pos = vEye + t * vRay;\n    \tvec3 L = normalize(Light - Pos);\n    \tvec3 V = normalize(vEye - Pos);\n\t\t\t\n\t\tvec3 matColor = vec3(1.0, 1.0, 1.0);\n\t\tmatColor *= checkboard(Pos.xz * 100.0);\n        \n        color = calcLight(N, L, V, matColor);\n        vec3 sRay = L;\n        color *= shadow(sRay, Pos);\n\n\t}\n\telse { // Sky\n\t\tcolor = vec3(0.5, 0.7, 1.0); // Sky color\n\t}\n    return color;\n}\n\nvec3 sphere(vec3 vRay)\n{\n    vec3 color;\nvec3 Light = vec3(-2.0 * cos(iTime * 2.0), 3.0, 2.0 * sin(iTime * 2.0));    \n    vec3 vSphere = vec3(0.0, 0.5 * sin(iTime), -0.5);\n    float R = 1.0;\n\tvec3 vE2S = vSphere - vEye;\n\tfloat glass = 0.96;\n    \n    float A = dot(vRay, vRay);\n    float B = -2.0 * dot(vRay, vE2S);\n    float C = dot(vE2S, vE2S) - R*R;\n\n\tfloat Det = B*B - 4.0*A*C;\n    \n    vec3 matColor = vec3(1.0, 0.0, 1.0);\n\t    \n    if (Det > 0.0) { // Sphere\n    \t\n        float t = (-B - sqrt(Det)) / (2.0*A);\n        \n        vec3 Pos = vEye + t * vRay;\n        \n        vec3 N = normalize(Pos - vSphere);\n        vec3 L = normalize(Light - Pos);\n        vec3 V = normalize(vEye - Pos);\n        \n        vec3 Rf = refract(-V, N, glass);\n        //vec3 Rf = reflect(-V, N);\n        vec3 RfColor = plane(Rf);\n        \n        color = calcLight(N, L, V, matColor);\n\t\tcolor += RfColor;\n    }\n    else { // No Sphere\n\t\tcolor = plane(vRay);\n    }\n    \n    return color;\n}\n\nbool sphereCheck(vec3 sRay, vec3 Pos)\n{\n    vec3 vSphere = vec3(0.0, 0.5 * sin(iTime), 0.0);\n    float R = 1.0;\n\tvec3 vE2S = vSphere - Pos;\n    \n    float A = dot(sRay, sRay);\n    float B = -2.0 * dot(sRay, vE2S);\n    float C = dot(vE2S, vE2S) - R*R;\n\n\tfloat Det = B*B - 4.0*A*C;\n    \n    if (Det > 0.0) return true;\n    else return false;\n}\n\nfloat shadow(vec3 sRay, vec3 Pos)\n{\n \tif (sphereCheck(sRay, Pos)) return 0.4;\n    else return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv = 2.0 * uv - vec2(1.0, 1.0);\n    uv.x *= aspectRatio;\n    \n\tvec3 vRay = vec3(uv, 1.5) - vEye;\n    //vRay = normalize(vRay);\n    \n    vec3 color;\n    color = sphere(vRay);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSyDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 112], [114, 295, 350, 350, 630], [632, 632, 655, 655, 1344], [1346, 1346, 1370, 1370, 2318], [2320, 2320, 2359, 2359, 2661], [2663, 2663, 2698, 2698, 2763], [2765, 2765, 2822, 2822, 3130]]}
{"id": "XtSyRD", "name": "iSimplexPrim", "author": "paniq", "description": "An intersectable primitive that defines a quadratic surface as a barycentric interpolation of bezier weights along a tetrahedron. This demo stitches three primitives together and blends between different weights.", "tags": ["ray", "quadric", "bezier", "intersection", "simplex", "cone", "tetrahedron", "ellipsoid", "cylinder", "prim"], "likes": 51, "viewed": 2439, "published": "Public API", "date": "1507644629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// uncomment to solve for quadratic surface only\n#define HIT_TET_PLANES\n\nvoid compute_edges(vec3 p[4], out vec3 e[6]) {\n    e[0] = p[2] - p[1];\n    e[1] = p[0] - p[2];\n    e[2] = p[1] - p[0];\n    e[3] = p[1] - p[3];\n    e[4] = p[2] - p[3];\n    e[5] = p[0] - p[3];\n}\n\nvoid compute_planes(vec3 p[4], out vec3 n[3]) {\n    vec3 e[6];\n    compute_edges(p, e);\n    n[0] = cross(e[0], e[3]);\n    n[1] = cross(e[1], e[4]);\n    n[2] = cross(e[2], e[5]);\n    float det = 1.0/dot(n[0], e[1]);\n    // premultiply the plane orthogonals by the inverse determinant\n    n[0] *= det;\n    n[1] *= det;\n    n[2] *= det;\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec4 to_bary(vec3 p3, vec3 n[3], vec3 t) {\n    // weights are scaled distance of point to individual planes\n    t -= p3;\n    float w0 = dot(t, n[0]); \n    float w1 = dot(t, n[1]); \n    float w2 = dot(t, n[2]); \n    float w3 = 1.0 - w0 - w1 - w2;\n    return vec4(w0, w1, w2, w3);\n}\n\nvec3 from_bary(vec3 p[4], vec4 w) {\n\treturn p[0] * w.x + p[1] * w.y + p[2] * w.z + p[3] * w.w;\n}\n\nvec3 normal_from_bary(vec3 n[3], vec4 w) {\n    return normalize(n[0] * (w.w - w.x) + n[1] * (w.w - w.y) + n[2] * (w.w - w.z));\n}\n\n// evaluate quadratic in tetrahedron with given corners and midweights\n// first set of weights are the weights on face xyz opposite of each vertex\n// second set of weights are on edges xyz-w\nfloat eval_quadratic(vec4 w, vec4 c, vec3 m1, vec3 m2) {\n    return w.x*w.x*c.x + w.y*w.y*c.y + w.z*w.z*c.z + w.w*w.w*c.w\n        + 2.0*(m1.x*w.y*w.z + m1.y*w.x*w.z + m1.z*w.x*w.y\n             + m2.x*w.w*w.x + m2.y*w.w*w.y + m2.z*w.w*w.z);\n}\n\n// return first derivative at given point in barycentric basis\nvec4 eval_quadratic_diff(vec4 w, vec4 c, vec3 m1, vec3 m2) {\n    return 2.0*vec4(\n    m2.x*w.w + c.x*w.x + m1.z*w.y + m1.y*w.z,\n    m2.y*w.w + m1.z*w.x + c.y*w.y + m1.x*w.z,\n    m2.z*w.w + m1.y*w.x + m1.x*w.y + c.z*w.z,\n    c.w*w.w + m2.x*w.x + m2.y*w.y + m2.z*w.z\n\t);\n}\n\nstruct Hit {\n    // ray scalar\n    float t;\n    // barycenter\n    vec4 b;\n    // normal\n    vec3 n;\n};\n\n// return normal of nearest plane in barycentric coordinates\nvec4 select_plane_normal(vec4 b) {\n    float lc = min(min(b.x, b.y), min(b.z, b.w));\n    return step(b, vec4(lc));\n}\n\n// return the intersection of ray, tetrahedron and a quadratic function\n// with the corner weights c and the edge weights m1 and m2\n// as well as the barycentric coordinates and normals of the hit points\nbool iSimplexPrim(vec3 p[4], \n\tvec4 c, vec3 m1, vec3 m2, \n\tvec3 ro, vec3 rd, \n\tout Hit near, out Hit far) {\n    \n    vec3 sn[3];\n    compute_planes(p, sn);\n    \n    // convert ray endpoints to barycentric basis\n    // this can be optimized further by caching the determinant\n    vec4 r0 = to_bary(p[3], sn, ro);\n    vec4 r1 = to_bary(p[3], sn, ro + rd);\n\n    // build barycentric ray direction from endpoints\n    vec4 brd = r1 - r0;\n    // compute ray scalars for each plane\n    vec4 t = -r0/brd;\n    \n    // valid since GL 4.1\n    near.t = -1.0 / 0.0;\n    far.t = 1.0 / 0.0;    \n#if 0\n    for (int i = 0; i < 4; ++i) {\n        // equivalent to checking dot product of ray dir and plane normal\n        if (brd[i] < 0.0) {\n            far.t = min(far.t, t[i]);\n        } else {\n            near.t = max(near.t, t[i]);\n        }\n    }\n#else\n    // loopless, branchless alternative\n    // equivalent to checking dot product of ray dir and plane normal    \n    bvec4 comp = lessThan(brd, vec4(0.0));\n    vec4 far4 = mix(vec4(far.t), t, comp);\n    vec4 near4 = mix(t, vec4(near.t), comp);\n    far.t = min(min(far4.x,far4.y),min(far4.z,far4.w));\n    near.t = max(max(near4.x,near4.y),max(near4.z,near4.w));\n#endif\n    \n    if ((far.t <= 0.0) || (far.t <= near.t))\n        return false;\n    near.b = r0 + brd * near.t;\n    far.b = r0 + brd * far.t;\n\n#ifdef HIT_TET_PLANES\n    vec4 n0 = select_plane_normal(near.b);\n    vec4 n1 = select_plane_normal(far.b);\n#else\n    vec4 n0;\n    vec4 n1;\n#endif\n        \n#if 1\n    // reconstruct 1D quadratic coefficients from three samples\n    float c0 = eval_quadratic(near.b, c, m1, m2);\n    float c1 = eval_quadratic(r0 + brd * (near.t + far.t) * 0.5, c, m1, m2);\n    float c2 = eval_quadratic(far.b, c, m1, m2);\n\n    float A = 2.0*(c2 + c0 - 2.0*c1);\n    float B = 4.0*c1 - 3.0*c0 - c2;\n    float C = c0;\n    \n    if (A == 0.0) return false;\n    // solve quadratic\n    float k = B*B - 4.0*A*C;\n    if (k < 0.0)\n        return false;\n    k = sqrt(k);\n    float d0 = (-B - k) / (2.0*A);\n    float d1 = (-B + k) / (2.0*A);\n    \n    //if (min(B,C) > 0.0) return false;\n    \n    if (d0 > 1.0) return false;\n    // for a conic surface, d1 can be smaller than d0\n    if ((d1 <= d0)||(d1 > 1.0))\n        d1 = 1.0;\n    else if (d1 < 0.0) return false;\n    if (d0 > 0.0) {\n        near.t = near.t + (far.t - near.t)*d0;\n    }\n    far.t = near.t + (far.t - near.t)*d1;\n    near.b = r0 + brd * near.t;\n    far.b = r0 + brd * far.t;\n#ifdef HIT_TET_PLANES\n    if ((d0 > 0.0) && (d0 < 1.0)) {\n        n0 = -eval_quadratic_diff(near.b, c, m1, m2);\n    }\n    if ((d1 > 0.0) && (d1 < 1.0)) {\n        n1 = -eval_quadratic_diff(far.b, c, m1, m2);\n    }\n#else\n    if ((d0 > 0.0) && (d0 < 1.0)) {\n        n0 = -eval_quadratic_diff(near.b, c, m1, m2);\n    } else if ((d1 > 0.0) && (d1 < 1.0)) {\n        n0 = eval_quadratic_diff(far.b, c, m1, m2);\n    }  else {\n        return false;\n    }\n#endif\n    \n#else\n#endif\n    near.n = normal_from_bary(sn, n0);\n    far.n = normal_from_bary(sn, n1);\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = iTime * 0.5;\n    float d = 3.0;\n\tcamPos = vec3(d*sin(an),mix(-0.8,2.0,sin(iTime*0.25)*0.5+0.5),d*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\nfloat imTestSphere(vec3 p) {\n    float r = 0.5;\n    return p.x*p.x + p.y*p.y + p.z*p.z - r*r;\n}\n\nfloat imTestCylinder(vec3 p) {\n    float r = 0.5;\n    return p.x*p.x + p.y*p.y - r*r;\n}\n\nfloat imTestCone(vec3 p) {\n    p.z = (p.z - 1.0)*0.5;\n    float r = 0.5;\n    return (p.x*p.x + p.y*p.y)/(r * r) - p.z*p.z;\n}\n\nfloat imSolid(vec3 p) {\n    float r = 1.0;\n    return p.x*p.x + p.y*p.y - r*r;\n}\n\n#define SHAPE_COUNT 5.0\nvoid getfactor (int i, out float c[6], out float m[12]) {\n    // reference coordinates\n    vec3 p[6];\n    p[0] = vec3(cos(radians(0.0)),sin(radians(0.0)),-1.0);\n    p[1] = vec3(cos(radians(120.0)),sin(radians(120.0)),-1.0);\n    p[2] = vec3(cos(radians(240.0)),sin(radians(240.0)),-1.0);\n    p[3] = vec3(cos(radians(0.0)),sin(radians(0.0)), 1.0);\n    p[4] = vec3(cos(radians(240.0)),sin(radians(240.0)), 1.0);\n    p[5] = vec3(cos(radians(120.0)),sin(radians(120.0)), 1.0);\n\n#define DEF_C(F) for (int i = 0; i < 6; ++i) { c[i] = F(p[i]); }\n#define DEF_M(I, F, V1, V2) m[I] = F((p[V1]+p[V2])*0.5)*2.0 - (c[V1]+c[V2])*0.5\n#define DEF_M0(F) DEF_M(0, F, 1, 2); DEF_M(1, F, 2, 0); DEF_M(2, F, 1, 0);\n#define DEF_M1(F) DEF_M(3, F, 4, 5); DEF_M(4, F, 5, 3); DEF_M(5, F, 4, 3);\n#define DEF_M2(F) DEF_M(6, F, 3, 0); DEF_M(7, F, 2, 3); DEF_M(8, F, 2, 4);\n#define DEF_M3(F) DEF_M(9, F, 4, 1); DEF_M(10, F, 5, 1); DEF_M(11, F, 1, 3);\n#define DEF_F(F) DEF_C(F); DEF_M0(F); DEF_M1(F); DEF_M2(F); DEF_M3(F);\n    \n    if (i == 0) {\n        DEF_F(imTestSphere);\n    } else if (i == 1) {\n        DEF_F(imTestCylinder);\n    } else if (i == 2) {\n        DEF_F(imTestCone);\n    } else if (i == 3) {\n        DEF_F(imSolid);\n    } else if (i == 4) {\n        for (int i = 0; i < 6; ++i) {\n            c[i] = 2.0;\n        }\n        for (int i = 0; i < 12; ++i) {\n            m[i] = -1.0;\n        }        \n    }\n}\n\nvoid anim_coeffs(out float c[6], out float m[12]) {\n    float k = iTime*0.5;\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    float c1[6];\n    float c2[6];\n    float m1[12];\n    float m2[12];\n    getfactor(s1, c1, m1);\n    getfactor(s2, c2, m2);\n    for (int i = 0; i < 6; ++i) {\n        c[i] = mix(c1[i],c2[i],u);\n    }\n    for (int i = 0; i < 12; ++i) {\n        m[i] = mix(m1[i],m2[i],u);\n    }\n}\n\nvec2 rotate_xy(vec2 p, float a) {\n    vec2 o;\n    float s = sin(a); float c = cos(a);\n    o.x = c*p.x + s*p.y;\n    o.y = -s*p.x + c*p.y;\n    return o;\n}\n\nvoid anim_split(inout vec3 p[4]) {\n#if 0\n    vec3 c = (p[0]+p[1]+p[2]+p[3])/4.0;\n    float s = mix(1.0, 0.8, clamp(pow(sin(iTime*0.1),16.0),0.0,1.0));\n    for (int i = 0; i < 4; ++i) {\n\t    p[i] = c + (p[i] - c)*s;\n    }\n#endif\n}\n\nbool anim_prism( in vec3 ro, in vec3 rd, out Hit h0, out Hit h1) {\n    // prism vertices\n    vec3 p[6];\n    p[0] = vec3(cos(radians(0.0)),sin(radians(0.0)),-1.0);\n    p[1] = vec3(cos(radians(120.0)),sin(radians(120.0)),-1.0);\n    p[2] = vec3(cos(radians(240.0)),sin(radians(240.0)),-1.0);\n    p[3] = vec3(cos(radians(0.0)),sin(radians(0.0)), 1.0);\n    p[4] = vec3(cos(radians(240.0)),sin(radians(240.0)), 1.0);\n    p[5] = vec3(cos(radians(120.0)),sin(radians(120.0)), 1.0);\n    for (int i = 3; i < 6; ++i) {\n        vec3 v = p[i];\n        v.xz = rotate_xy(v.xz, sin(iTime * 10.0)*sin(iTime)*0.1);\n        v.z += mix(-1.5, 0.0, sin(iTime * 0.2)*0.5+0.5);\n        p[i] = v;\n        \n    }\n    float c[6];\n    c[0] = 2.0; c[1] = 2.0; c[2] = 2.0;\n    c[3] = 2.0; c[4] = 2.0; c[5] = 2.0;\n    float m[12];\n    m[0] = -1.0; m[ 1] = -1.0; m[ 2] = -1.0;\n    m[3] = -1.0; m[ 4] = -1.0; m[ 5] = -1.0;\n    m[6] = -1.0; m[ 7] = -1.0; m[ 8] = -1.0;\n    m[9] = -1.0; m[10] = -1.0; m[11] = -1.0;\n\n    anim_coeffs(c, m);\n    \n    vec4 qc; vec3 qm1, qm2;\n    \n    vec3 q[4];\n    Hit near; Hit far;\n    h0.t = 1.0/0.0;\n\th1.t = -1.0/0.0;\n    q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3];\n    anim_split(q);\n    qc = vec4(c[0], c[1], c[2], c[3]);\n    qm1 = vec3(m[0], m[1], m[2]); qm2 = vec3(m[6], m[11], m[7]);\n    bool hit = false;\n    if (iSimplexPrim(q, qc, qm1, qm2, ro, rd, near, far)) {\n        if (near.t < h0.t)\n            h0 = near;\n        if (far.t > h1.t)\n            h1 = far;\n        hit = true;\n    }\n    q[0] = p[1]; q[1] = p[2]; q[2] = p[3]; q[3] = p[4];\n    anim_split(q);\n    qc = vec4(c[1], c[2], c[3], c[4]);\n    qm1 = vec3(m[7], m[11], m[0]); qm2 = vec3(m[9], m[8], m[5]);\n    if (iSimplexPrim(q, qc, qm1, qm2, ro, rd, near, far)) {\n        if (near.t < h0.t)\n            h0 = near;\n        if (far.t > h1.t)\n            h1 = far;\n        hit = true;\n    }\n    q[0] = p[3]; q[1] = p[4]; q[2] = p[5]; q[3] = p[1];\n    anim_split(q);\n    qc = vec4(c[3], c[4], c[5], c[1]);\n    qm1 = vec3(m[3], m[4], m[5]); qm2 = vec3(m[11], m[9], m[10]);\n    if (iSimplexPrim(q, qc, qm1, qm2, ro, rd, near, far)) {\n        if (near.t < h0.t)\n            h0 = near;\n        if (far.t > h1.t)\n            h1 = far;\n        hit = true;\n    }    \n    return hit;\n}\n\nvec3 calc_intersection( in vec3 ro, in vec3 rd ) {\n    ro = ro.zxy;\n    rd = rd.zxy;    \n    vec3 l = normalize(vec3(1.0, -1.0, -2.0));\n    \n    vec3 col = vec3(0.0);\n    \n    Hit h0, h1;\n    if (anim_prism(ro, rd, h0, h1)) {\n        vec4 c = (h0.t > 0.0)?h0.b:h1.b;\n        \n        float lit = max(0.0, dot(l, -h0.n));\n        \n        lit += 0.1;\n        \n#if 1\n        col += lit * vec3(0.1, 0.5, 1.0);\n#else\n        col += lit * (\n              c.x * vec3(1.0, 0.0, 0.0)\n        \t+ c.y * vec3(0.0, 1.0, 0.0)\n            + c.z * vec3(0.0, 0.0, 1.0)\n            + c.w * vec3(1.0, 1.0, 1.0));\n#endif\n        col += lit * pow(max(0.0, dot(-l, reflect(rd, h0.n)) - 0.1), 25.0)*1e-7;\n    } else {\n        float plane_t = -(ro.z + 1.0) / rd.z;\n        if (plane_t > 0.0) {\n            vec3 plane_p = ro + rd * plane_t;\n\n            float sh = anim_prism(plane_p, -l, h0, h1)?0.3:1.0;\n            col += vec3(sh) * abs(rd.z);\n        }\n    }    \n    return col;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = ( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    col = calc_intersection( ro, rd );\n\t   \n    fragColor = vec4( sqrt(col), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSyRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 74, 120, 120, 266], [268, 268, 315, 315, 603], [605, 737, 779, 844, 1017], [1019, 1019, 1054, 1054, 1115], [1117, 1117, 1159, 1159, 1245], [1247, 1438, 1494, 1494, 1679], [1681, 1744, 1804, 1804, 2014], [2120, 2181, 2215, 2215, 2297], [2299, 2503, 2610, 2610, 5521], [5523, 5598, 5681, 5681, 5837], [5840, 5840, 5867, 5867, 5902], [5904, 5904, 5925, 5925, 6032], [6034, 6034, 6071, 6071, 6157], [6159, 6159, 6205, 6205, 6238], [6240, 6240, 6268, 6268, 6335], [6337, 6337, 6367, 6367, 6424], [6426, 6426, 6452, 6452, 6550], [6552, 6552, 6575, 6575, 6632], [6658, 6658, 6715, 6744, 8044], [8046, 8046, 8097, 8097, 8543], [8545, 8545, 8578, 8578, 8697], [8699, 8699, 8733, 8733, 8928], [8930, 8930, 8996, 9018, 11181], [11183, 11183, 11233, 11233, 12143], [12145, 12145, 12209, 12209, 12387], [12389, 12389, 12446, 12446, 13017]]}
{"id": "XtSyRR", "name": "shitty-waves", "author": "tshirtman", "description": "a simple 2D parallax wave experiment", "tags": ["2d"], "likes": 1, "viewed": 79, "published": "Public", "date": "1507053710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// quick 2D wave experiment\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0.2823529411764706, 0.39215686274509803, 0.9450980392156862, 1.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    int WAVES = 5;\n    for (int i=1; i < WAVES; i++){\n        if (\n            uv.y < (\n                sin(uv.x * 6. + iTime * pow(2., float(i + 1)))\n                / pow(4., float(i +1)) +\n                sin(uv.x * 10. + iTime * pow(1.5, float(i))) / 10.\n                + 1. - pow(.75, float(i))\n               ) + sin(iTime/10.)\n        ){\n            fragColor = color / pow(2., float(i));\n            break;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSyRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 28, 85, 85, 649]]}
{"id": "XtsyWf", "name": "Slimy sphere", "author": "Zibe", "description": "[WIP]\nBased on the raymarching tutorial from user jlfwong (https://www.shadertoy.com/user/jlfwong), that you can find here : http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\nUsed a polymonial smooth function from the iq's blog", "tags": ["raymarching"], "likes": 1, "viewed": 151, "published": "Public", "date": "1506937886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.14;\n\nfloat sphereSDF(vec3 samplePoint, vec3 center, float radius) {\n    return length(center - samplePoint) - radius;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    float dst = sphereSDF(samplePoint, vec3(sin(iTime *PI)/2.5, 0.,0.), 0.2);\n    dst = smin(dst, sphereSDF(samplePoint, vec3(0., sin(iTime)/3.,0.), 0.25), 0.1);\n    dst = smin(dst, sphereSDF(samplePoint, vec3(sin(iTime + 0.3)/3., 0.,sin(iTime + 0.5)/3.), 0.2), 0.1);\n    dst = smin(dst, sphereSDF(samplePoint, vec3(sin(iTime)/3., sin(iTime + 4.)/3.,0.), 0.2), 0.1);\n    return smin(sphereSDF(samplePoint, vec3(0),0.5), dst, .4);\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.1, 0.7, 0.3);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 211, 211, 263], [265, 265, 306, 306, 399], [402, 402, 436, 436, 868], [871, 871, 962, 962, 1268], [1270, 1270, 1335, 1335, 1467], [1469, 1469, 1498, 1498, 1808], [1810, 1810, 1950, 1950, 2379], [2381, 2381, 2466, 2466, 3224], [3227, 3227, 3284, 3284, 3849]]}
{"id": "XtSyzh", "name": "GVD of cubic Truchet cell", "author": "mattz", "description": "Yellow net is equidistant to red & green torus segments. Ditto for cyan/green/blue and magenta/blue/red, respectively. T toggles last torus segment. V toggles Voronoi boundary. H toggles hyperbolic paraboloid.", "tags": ["voronoi", "truchet", "cubic", "diagram", "generalized", "gvd"], "likes": 16, "viewed": 496, "published": "Public API", "date": "1507305667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n    GVD of cubic Truchet cell, by mattz\n    License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tIf you've spent way too much time thinking about cubic Truchet tilings,\n    you might be tempted to ask how the three torus segments divide the cube\n    into three equal volumes.\n\n    The answer is given by the Generalized Voronoi Diagram (GVD) of the cell.\n    This is the set of surfaces that are equidistant to pairs of torii. \n    See, for instance: http://sci.utah.edu/~jedwards/research/gvd/\n\n    These particular Voronoi boundaries appear similar to hyperbolic paraboloids:\n    http://mathworld.wolfram.com/HyperbolicParaboloid.html -- but I don't think\n    they actually are hyperbolic paraboloids. Press H to compare.\n\n    Thanks to Shane for posing the question that took me here!\n\n\n*/\n\n// Bunch of globals/constants:\nconst int rayiter = 60;\nconst float dmax = 20.0;\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\nfloat show_t2 = 1.;\n\nfloat show_voronoi = 1.;\nfloat show_hyperb = 0.;\n\nconst float HALFPI = 1.5707963267948966;\n\nconst int HSTEPS = 10;\n\n/* RGB from hue. */\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n/* Compute torus distance and normal vector given:\n\n    - p is point in cube with vertices at +/- 0.5:\n    - src is outward facing normal of flow source face \n    - dst is outward facing normal of flow sink face\n\n   Returns a vec4 (nx, ny, nd, d) where:\n\n     - nx, ny, nz is unit normal pointing away from torus\n     - d is distance to torus.\n\n*/\nvec4 checkTorus(vec3 p, vec3 src, vec3 dst) {\n    \n    vec3 z = cross(dst, src);\n    vec3 ctr = 0.5*(src+dst);\n    \n    p -= ctr;\n    \n    vec3 pc = 0.5*normalize(src*dot(p, src) + dst*dot(p, dst));\n    \n    vec3 n = p - pc;\n    float l = length(n);\n    \n    float d = l;\n \n    return vec4(n/l, d);\n    \n}\n\n/* Boolean union of solids for map function below */\nvec2 dmin(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\n/* Sort vec3 coordinates descending - for box edges. */\nvec3 psort(vec3 p) {\n    p = abs(p);\n    if (p.y < p.z) { p.yz = p.zy; } // y & z are sorted\n    if (p.x < p.z) { p.xz = p.zx; } // x & z are sorted\n    if (p.x < p.y) { p.xy = p.yx; } // x & y are sorted\n    return p;\n}\n\n/* Inf. norm for box edges. */\nfloat infnorm(vec3 a) {\n    a = abs(a);\n    return max(a.x, max(a.y, a.z));\n}\n\n/* Make an approximate distance field out of the difference of two \n   distance fields whose gradients (normals) are known. This is \n   exactly the method used in iq's \"Distance estimation to implicits\"\n   article: http://iquilezles.org/www/articles/distance/distance.htm\n*/\nfloat vdiff(vec4 a, vec4 b) {\n    return abs(a.w - b.w) / length(a.xyz - b.xyz);\n}\n\n/* Construct a doubly-ruled surface - I *think* this is a hyperbolic paraboloid? */\nvec3 psurf(vec2 uv) {\n    \n    const vec3 a = 0.5*vec3(1, 1, -1);\n    const vec3 b = 0.5*vec3(-1, 1, -1);\n    const vec3 c = 0.5*vec3(1, 1, 1);\n    const vec3 d = 0.5*vec3(1, -1, 1);\n    \n    vec3 p = mix(a, b, uv.x);\n    vec3 q = mix(c, d, uv.x);\n\n   \treturn mix(p, q, uv.y);\n    \n}\n\nfloat dline(vec3 p, vec3 a, vec3 b) {\n    \n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    \n    float u = clamp(dot(pa,ba) / dot(ba, ba), 0., 1.);\n    return length(pa - u*ba);\n    \n}\n\n/* Distance function to scene */\nvec2 map(in vec3 pos) {\t\n    \n    // Get distances and normals for each of 3 torus segments \n    vec4 t0 = checkTorus(pos, vec3(0, 1, 0), vec3(0, 0, 1));\n    vec4 t1 = checkTorus(pos, vec3(1, 0, 0), vec3(0, 0, -1));\n \n    // Minimum distance to torus & material color\n    vec2 tm = vec2(t0.w, 0./6.); \n    tm = dmin(tm, vec2(t1.w, 2./6.)); \n    \n\n    \n    // Distance to generalized Voronoi boundaries depends upon closest feature --\n    // we will only check 2 of 3 possible boundaries.\n    vec2 vm = vec2(1e5, -1);\n    \n    if (show_t2 != 0.) {\n        \n        vec4 t2 = checkTorus(pos, vec3(0, -1, 0), vec3(-1, 0, 0));\n        tm = dmin(tm, vec2(t2.w, 4./6.)); \n\n        if (tm.x == t0.w) { \n            vm = dmin(vm, vec2(vdiff(t0, t1), 1./6.));\n            vm = dmin(vm, vec2(vdiff(t2, t0), 5./6.));\n        } else if (tm.x == t1.w) {\n            vm = dmin(vm, vec2(vdiff(t0, t1), 1./6.));\n            vm = dmin(vm, vec2(vdiff(t1, t2), 3./6.));\n        } else {\n            vm = dmin(vm, vec2(vdiff(t1, t2), 3./6.));\n            vm = dmin(vm, vec2(vdiff(t2, t0), 5./6.));\n        }\n        \n    } else {\n        \n        vm = dmin(vm, vec2(vdiff(t0, t1), 1./6.));\n        \n    }\n    \n    // Give torii some radius    \n    tm.x -= 0.04;\n    \n    // Since we are raymarching an implicit, scaling the\n    // estimated distance down a bit gives our raymarcher\n    // more of a chance to intersect.\n    vm.x *= 0.5;\n    \n    // Give implicit surface a bit of thickness\n    vm.x -= 0.004;\n    \n    // Punch some holes in the voronoi boundaries to make netting\n    vec3 cctr = floor(12.0*pos+0.5)/12.0;\n    vec3 cpos = abs(pos - cctr);\n    vm.x = max(vm.x, min(cpos.x, min(cpos.y, cpos.z))-0.01);\n    \n    // Prepare the final return value for the map function\n    vec2 dm = show_voronoi != 0.0 ? dmin(tm, vm) : tm;\n    \n    if (show_hyperb != 0.) {\n        for (int n=0; n<=HSTEPS; ++n) {\n            float i = float(n)/float(HSTEPS);\n            dm = dmin(dm, vec2(dline(pos, psurf(vec2(i, 0)), psurf(vec2(i, 1)))-0.008, 1.5));\n            dm = dmin(dm, vec2(dline(pos, psurf(vec2(0, i)), psurf(vec2(1, i)))-0.008, 1.5));\n        }\n    }\n    \n    // Handle box edge\n    vec3 ps = psort(pos);\n    float u = clamp(ps.z, 0.0, 0.5);\n    vec3 pc = vec3(0.5, 0.5, u);\n    dm = dmin(dm, vec2(infnorm(ps - pc)-0.02, 1.01));\n    \n    // Clamp to cube extents\n    dm.x = max(dm.x, ps.x - 0.5);\n    \n    // Return value\n    return dm;\n\n\n}\n\n\n/* IQ's normal calculation. */\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n/* IQ's distance marcher. */\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\n    const float precis = 0.001;   \n    float h=2.0*precis;\n\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h; \n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;        \n    }    \n\n    if (t > maxd) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n/* Pretty standard shading function. */\nvec3 shade( in vec3 ro, in vec3 rd ){\n\n    vec2 tm = castRay(ro, rd, dmax);        \n\n    vec3 c;\n\n    if (tm.y < 0.0) { \n\n        // miss\n        return vec3(1.0);\n\n    } else {        \n\n        // hit\n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);\n\n        vec3 color = hue(tm.y);\n\n        vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * color;\n        vec3 R = 2.0*n*dot(n,L)-L;\n        float spec = 0.3*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n        vec3 c = diffamb + spec;\n        \n        return c;\n\n    }\n\n\n}\n\nconst float KEY_H = 72.5 / 256.0;\nconst float KEY_T = 84.5 / 256.0;\nconst float KEY_V = 86.5 / 256.0;\n\n/* Compare key state to default state. */\nfloat keyState(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.75)).x - default_state );\n}\n\n/* Finally, our main function: */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n    \n    const vec3 tgt = vec3(0.0, 0.0, 0.0);\n    const vec3 cpos = vec3(0, 0, 2);\n    const vec3 up = vec3(0, 1, 0);\n    \n   \n    show_t2 = keyState(KEY_T, show_t2);\n    show_voronoi = keyState(KEY_V, show_voronoi);\n    show_hyperb = keyState(KEY_H, show_hyperb);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    vec2 mpos;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        mpos.xy = iMouse.xy;\n    } else {\n        mpos = iResolution.xy * vec2(0.432 + 0.015*iTime, 0.415);\n    }\n    \n    float thetax = (mpos.y - .5*iResolution.y) * -4.0*HALFPI/iResolution.y; \n    float thetay = (mpos.x - .5*iResolution.x) * 8.0*HALFPI/iResolution.x; \n\n\n    Rview = mat3(rx,ry,rz)*rotY(thetay)*rotX(thetax); \n    L = Rview*L;\n\n   \t/* Render. */\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n    \n    fragColor.xyz = shade(ro, rd);\n\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSyzh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1104, 1124, 1143, 1143, 1260], [1262, 1288, 1311, 1311, 1432], [1434, 1460, 1483, 1483, 1604], [1606, 1954, 1999, 1999, 2259], [2261, 2314, 2341, 2341, 2373], [2375, 2431, 2451, 2451, 2651], [2653, 2684, 2707, 2707, 2761], [2763, 3038, 3067, 3067, 3120], [3122, 3206, 3227, 3227, 3489], [3491, 3491, 3528, 3528, 3668], [3670, 3703, 3726, 3795, 6131], [6134, 6165, 6197, 6197, 6436], [6439, 6468, 6523, 6523, 6899], [6901, 6941, 6978, 6978, 7483], [7588, 7630, 7678, 7678, 7753], [7755, 7789, 7846, 7846, 8867]]}
